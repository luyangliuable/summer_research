 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2000-2005 Silicon Graphics, Inc.

 * Copyright (c) 2013 Red Hat, Inc.

 * All Rights Reserved.

/*

 * Function declarations.

/*

 * Convert data space db to the corresponding free db.

/*

 * Convert data space db to the corresponding index in a free db.

/*

 * Check internal consistency of a leafn block.

 XXX: should bounds check the xfs_dir3_icfree_hdr here */

 Everything ok in the free block header? */

 Check things that we can't do in the verifier. */

 try read returns without an error or *bpp if it lands in a hole */

	/*

	 * Initialize the new block to be empty, and remember

	 * its first slot as our empty slot.

/*

 * Log entries from a freespace block.

 first entry to log */

 last entry to log */

/*

 * Log header from a freespace block.

 freespace structure */

/*

 * Convert a leaf-format directory to a node-format directory.

 * We need to change the magic number of the leaf block, and copy

 * the freespace table out of the leaf block into its own block.

 error */

 operation arguments */

 leaf buffer */

 incore directory inode */

 error return value */

 freespace buffer */

 freespace block number */

 pointer to freespace entry */

 leaf freespace index */

 leaf structure */

 leaf tail structure */

 count of live freespc ents */

 freespace entry value */

 transaction pointer */

	/*

	 * Add a freespace block to the directory.

	/*

	 * Get the buffer for the new freespace block.

	/*

	 * Copy freespace entries from the leaf block to the new block.

	 * Count active entries.

	/*

	 * Now initialize the freespace block header.

	/*

	 * Converting the leaf to a leafnode is just a matter of changing the

	 * magic number and the ops. Do the change directly to the buffer as

	 * it's less work (and less code) than decoding the header to host

	 * format and back again.

/*

 * Add a leaf entry to a leaf block in a node-form directory.

 * The other work necessary is done from the caller.

 error */

 leaf buffer */

 operation arguments */

 insertion pt for new entry */

 compacting stale leaves */

 next stale entry */

 high leaf entry logging */

 low leaf entry logging */

 previous stale entry */

	/*

	 * Quick check just to make sure we are not going to index

	 * into other peoples memory

	/*

	 * If there are already the maximum number of leaf entries in

	 * the block, if there are no stale entries it won't fit.

	 * Caller will do a split.  If there are stale entries we'll do

	 * a compact.

	/*

	 * Compact out all but one stale leaf entry.  Leaves behind

	 * the entry closest to index.

		/*

		 * Set impossible logging indices for this case.

	/*

	 * Insert the new entry, log everything.

 DEBUG */

/*

 * Return the last hash value in the leaf.

 * Stale entries are ok.

 hash value */

 leaf buffer */

 count of entries in leaf */

/*

 * Look up a leaf entry for space to add a name in a node-format leaf block.

 * The extrablk in state is a freespace block.

 leaf buffer */

 operation arguments */

 out: leaf entry index */

 state to fill in */

 current data/free buffer */

 current data block number */

 current free block number */

 incore directory inode */

 error return value */

 free entry index */

 free block structure */

 leaf entry index */

 leaf structure */

 length of new data entry */

 leaf entry */

 filesystem mount point */

 new data block number */

 new free block number */

 transaction pointer */

	/*

	 * Look up the hash value in the leaf entries.

	/*

	 * Do we have a buffer coming in?

 If so, it's a free block buffer, get the block number. */

	/*

	 * Loop over leaf entries with the right hash value.

		/*

		 * Skip stale leaf entries.

		/*

		 * Pull the data block number from the entry.

		/*

		 * For addname, we're looking for a place to put the new entry.

		 * We want to use a data block with an entry of equal

		 * hash value to ours if there is one with room.

		 *

		 * If this block isn't the data block we already have

		 * in hand, take a look at it.

			/*

			 * Convert the data block to the free block

			 * holding its freespace information.

			/*

			 * If it's not the one we have in hand, read it in.

				/*

				 * If we had one before, drop it.

			/*

			 * Get the index for our entry.

			/*

			 * If it has room, return it.

 Didn't find any space */

 Giving back a free block. */

		/*

		 * Important: this magic number is not in the buffer - it's for

		 * buffer type information and therefore only the free/data type

		 * matters here, not whether CRCs are enabled or not.

	/*

	 * Return the index, that will be the insertion point.

/*

 * Look up a leaf entry in a node-format leaf block.

 * The extrablk in state a data block.

 leaf buffer */

 operation arguments */

 out: leaf entry index */

 state to fill in */

 current data/free buffer */

 current data block number */

 data block entry */

 incore directory inode */

 error return value */

 leaf entry index */

 leaf structure */

 leaf entry */

 filesystem mount point */

 new data block number */

 transaction pointer */

 comparison result */

	/*

	 * Look up the hash value in the leaf entries.

	/*

	 * Do we have a buffer coming in?

	/*

	 * Loop over leaf entries with the right hash value.

		/*

		 * Skip stale leaf entries.

		/*

		 * Pull the data block number from the entry.

		/*

		 * Not adding a new entry, so we really want to find

		 * the name given to us.

		 *

		 * If it's a different data block, go get it.

			/*

			 * If we had a block before that we aren't saving

			 * for a CI name, drop it

			/*

			 * If needing the block that is saved with a CI match,

			 * use it otherwise read in the new data block.

		/*

		 * Point to the data entry.

		/*

		 * Compare the entry and if it's an exact match, return

		 * EEXIST immediately. If it's the first case-insensitive

		 * match, store the block & inode number and continue looking.

 If there is a CI match block, drop it */

 Giving back last used data block. */

 If the curbp is not the CI match block, drop it */

/*

 * Look up a leaf entry in a node-format leaf block.

 * If this is an addname then the extrablk in state is a freespace block,

 * otherwise it's a data block.

 leaf buffer */

 operation arguments */

 out: leaf entry index */

 state to fill in */

/*

 * Move count leaf entries from source to destination leaf.

 * Log entries and headers.  Stale entries are preserved.

 operation arguments */

 source */

 source leaf index */

 destination */

 destination leaf index */

 count of leaves to copy */

 count stale leaves copied */

	/*

	 * Silently return if nothing to do.

	/*

	 * If the destination index is not the end of the current

	 * destination leaf entries, open up a hole in the destination

	 * to hold the new entries.

	/*

	 * If the source has stale leaves, count the ones in the copy range

	 * so we can update the header correctly.

 temp leaf index */

	/*

	 * Copy the leaf entries from source to destination.

	/*

	 * If there are source entries after the ones we copied,

	 * delete the ones we copied by sliding the next ones down.

	/*

	 * Update the headers and log them.

/*

 * Determine the sort order of two leaf blocks.

 * Returns 1 if both are valid and leaf2 should be before leaf1, else 0.

 sort order */

 leaf1 buffer */

 leaf2 buffer */

/*

 * Rebalance leaf entries between two leaf blocks.

 * This is actually only called when the second block is new,

 * though the code deals with the general case.

 * A new entry will be inserted in one of the blocks, and that

 * entry is taken into account when balancing.

 btree cursor */

 first btree block */

 second btree block */

 operation arguments */

 count (& direction) leaves */

 new goes in left leaf */

 first leaf structure */

 second leaf structure */

 midpoint leaf index */

 old count of stale leaves */

 old total leaf count */

 swapped leaf blocks */

	/*

	 * If the block order is wrong, swap the arguments.

	/*

	 * If the old leaf count was odd then the new one will be even,

	 * so we need to divide the new count evenly.

 middle entry hash value */

	/*

	 * If the old count is even then the new count is odd, so there's

	 * no preferred side for the new entry.

	 * Pick the left one.

	/*

	 * Calculate moved entry count.  Positive means left-to-right,

	 * negative means right-to-left.  Then move the entries.

 log the changes made when moving the entries */

	/*

	 * Mark whether we're inserting into the old or new leaf.

	/*

	 * Adjust the expected index for insertion.

	/*

	 * Finally sanity check just to make sure we are not returning a

	 * negative index

		/*

		 * Data block is not empty, just set the free entry to the new

		 * value.

 One less used entry in the free table. */

	/*

	 * If this was the last entry in the table, we can trim the table size

	 * back.  There might be other entries at the end referring to

	 * non-existent data blocks, get those too.

 free entry index */

 Not the last entry, just punch it out.  */

	/*

	 * If there are no useful entries left in the block, get rid of the

	 * block if we can.

		/*

		 * It's possible to get ENOSPC if there is no

		 * space reservation.  In this case some one

		 * else will eventually get rid of this block.

 Log the free entry that changed, unless we got rid of it.  */

/*

 * Remove an entry from a node directory.

 * This removes the leaf entry and the data entry,

 * and updates the free block if necessary.

 error */

 operation arguments */

 leaf buffer */

 leaf entry index */

 data block */

 resulting block needs join */

 data block header */

 data block number */

 data block buffer */

 data block entry */

 incore directory inode */

 leaf structure */

 leaf entry */

 longest data free entry */

 data block entry offset */

 need to log data header */

 need to rescan data frees */

 transaction pointer */

 bestfree table */

	/*

	 * Point to the entry we're removing.

	/*

	 * Extract the data block and offset from the entry.

	/*

	 * Kill the leaf entry by marking it stale.

	 * Log the leaf block changes.

	/*

	 * Make the data entry free.  Keep track of the longest freespace

	 * in the data block in case it changes.

	/*

	 * Rescan the data block freespaces for bestfree.

	 * Log the data block header if needed.

	/*

	 * If the longest data block freespace changes, need to update

	 * the corresponding freeblock entry.

 error return value */

 freeblock buffer */

 freeblock block number */

 index in freeblock entries */

 freeblock structure */

		/*

		 * Convert the data block number to a free block,

		 * read in the free block.

		/*

		 * Calculate which entry we need to fix.

		/*

		 * If the data block is now empty we can get rid of it

		 * (usually).

			/*

			 * Try to punch out the data block.

			/*

			 * We can get ENOSPC if there's no space reservation.

			 * In this case just drop the buffer and some one else

			 * will eventually get rid of the empty block.

		/*

		 * If we got rid of the data block, we can eliminate that entry

		 * in the free block.

	/*

	 * Return indication of whether this leaf block is empty enough

	 * to justify trying to join it with a neighbor.

/*

 * Split the leaf entries in the old block into old and new blocks.

 error */

 btree cursor */

 original block */

 newly created block */

 operation arguments */

 new leaf block number */

 error return value */

	/*

	 * Allocate space for a new leaf node.

	/*

	 * Initialize the new leaf block.

	/*

	 * Rebalance the entries across the two leaves, link the new

	 * block into the leaves.

	/*

	 * Insert the new entry in the correct block.

	/*

	 * Update last hashval in each block since we added the name.

/*

 * Check a leaf block and its neighbors to see if the block should be

 * collapsed into one or the other neighbor.  Always keep the block

 * with the smaller block number.

 * If the current block is over 50% full, don't try to join it, return 0.

 * If the block is empty, fill in the state structure and return 2.

 * If it can be collapsed, fill in the state structure and return 1.

 * If nothing can be done, return 0.

 error */

 btree cursor */

 resulting action to take */

 leaf block */

 leaf block number */

 leaf buffer */

 bytes in use */

 leaf live entry count */

 error return value */

 sibling block direction */

 sibling counter */

 leaf structure */

 result from path_shift */

	/*

	 * Check for the degenerate case of the block being over 50% full.

	 * If so, it's not worth even looking to see if we might be able

	 * to coalesce with a sibling.

		/*

		 * Blk over 50%, don't try to join.

	/*

	 * Check for the degenerate case of the block being empty.

	 * If the block is empty, we'll simply delete it, no need to

	 * coalesce it with a sibling block.  We choose (arbitrarily)

	 * to merge with the forward block unless it is NULL.

		/*

		 * Make altpath point to the block we want to keep and

		 * path point to the block we want to drop (this one).

	/*

	 * Examine each sibling block to see if we can coalesce with

	 * at least 25% free space to spare.  We need to figure out

	 * whether to merge with the forward or the backward block.

	 * We prefer coalescing with the lower numbered sibling so as

	 * to shrink a directory over time.

		/*

		 * Read the sibling leaf block.

		/*

		 * Count bytes in the two blocks combined.

		/*

		 * Fits with at least 25% to spare.

	/*

	 * Didn't like either block, give up.

	/*

	 * Make altpath point to the block we want to keep (the lower

	 * numbered block) and path point to the block we want to drop.

/*

 * Move all the leaf entries from drop_blk to save_blk.

 * This is done as part of a join operation.

 cursor */

 dead block */

 surviving block */

 operation arguments */

 dead leaf structure */

 surviving leaf structure */

	/*

	 * If there are any stale leaf entries, take this opportunity

	 * to purge them.

	/*

	 * Move the entries from drop to the appropriate end of save.

 log the changes made when moving the entries */

/*

 * Add a new data block to the directory at the free space index that the caller

 * has specified.

 Not allowed to allocate, return failure. */

 Allocate and initialize the new data block.  */

	/*

	 * Get the freespace block corresponding to the data block

	 * that was just allocated.

	/*

	 * If there wasn't a freespace block, the read will

	 * return a NULL fbp.  Allocate and initialize a new one.

 Get a buffer for the new block. */

 Remember the first slot as our empty slot. */

 Set the freespace block index from the data block number. */

 Extend the freespace table if the new data block is off the end. */

	/*

	 * If this entry was for an empty data block (this should always be

	 * true) then update the header.

 Update the freespace value for the new block in the table. */

	/*

	 * If we came in with a freespace block that means that lookup

	 * found an entry with our hash value.  This is the freespace

	 * block for that data entry.

 caller already found the freespace for us. */

		/*

		 * The data block looked at didn't have enough room.

		 * We'll start at the beginning of the freespace entries.

	/*

	 * If we don't have a data block yet, we're going to scan the freespace

	 * data for a data block with enough free space in it.

 If it's ifbno we already looked at it. */

		/*

		 * Read the block.  There can be holes in the freespace blocks,

		 * so this might not succeed.  This should be really rare, so

		 * there's no reason to avoid it.

 Scan the free entry array for a large enough free space. */

 Didn't find free space, go on to next free block */

/*

 * Add the data entry for a node-format directory name addition.

 * The leaf entry is added in xfs_dir2_leafn_add.

 * We may enter with a freespace block that the lookup found.

 operation arguments */

 optional freespace block */

 data unused entry pointer */

 data entry pointer */

 data block header */

 data block buffer */

 freespace buffer */

 data block number */

 error return value */

 freespace entry index */

 length of the new entry */

 need to log free entry */

 need to log data header */

 need to rescan data frees */

 data entry tag pointer */

	/*

	 * Now we know if we must allocate blocks, so if we are checking whether

	 * we can insert without allocation then we can return now.

	/*

	 * If we don't have a data block, we need to allocate one and make

	 * the freespace entries refer to it.

 we're going to have to log the free block index later */

 Read the data block in. */

 setup for data block up now */

 Point to the existing unused space. */

 Mark the first part of the unused space, inuse for us. */

 Fill in the new entry and log it. */

 Rescan the freespace and log the data block if needed. */

 If the freespace block entry is now wrong, update it. */

 Log the freespace entry if needed. */

 Return the data block and offset in args. */

/*

 * Top-level node form directory addname routine.

 error */

 operation arguments */

 leaf block for insert */

 error return value */

 sub-return value */

 btree cursor */

	/*

	 * Allocate and initialize the state (btree cursor).

	/*

	 * Look up the name.  We're not supposed to find it, but

	 * this gives us the insertion point.

	/*

	 * Add the data entry to a data block.

	 * Extravalid is set to a freeblock found by lookup.

	/*

	 * Add the new leaf entry.

		/*

		 * It worked, fix the hash values up the btree.

		/*

		 * It didn't work, we need to split the leaf block.

		/*

		 * Split the leaf block and insert the new entry.

/*

 * Lookup an entry in a node-format directory.

 * All the real work happens in xfs_da3_node_lookup_int.

 * The only real output is the inode number of the entry.

 error */

 operation arguments */

 error return value */

 btree level */

 operation return value */

 btree cursor */

	/*

	 * Allocate and initialize the btree cursor.

	/*

	 * Fill in the path to the entry in the cursor.

 If a CI match, dup the actual name and return -EEXIST */

	/*

	 * Release the btree blocks and leaf block.

	/*

	 * Release the data block if we have it.

/*

 * Remove an entry from a node-format directory.

 error */

 operation arguments */

 leaf block */

 error return value */

 operation return value */

 btree cursor */

	/*

	 * Allocate and initialize the btree cursor.

 Look up the entry we're deleting, set up the cursor. */

 Didn't find it, upper layer screwed up. */

	/*

	 * Remove the leaf and data entries.

	 * Extrablk refers to the data block.

	/*

	 * Fix the hash values up the btree.

	/*

	 * If we need to join leaf blocks, do it.

	/*

	 * If no errors so far, try conversion to leaf format.

/*

 * Replace an entry's inode number in a node-format directory.

 error */

 operation arguments */

 leaf block */

 data block header */

 data entry changed */

 error return value */

 btree level */

 new inode number */

 new file type */

 internal return value */

 btree cursor */

	/*

	 * Allocate and initialize the btree cursor.

	/*

	 * We have to save new inode number and ftype since

	 * xfs_da3_node_lookup_int() is going to overwrite them

	/*

	 * Lookup the entry to change in the btree.

	/*

	 * It should be found, since the vnodeops layer has looked it up

	 * and locked it.  But paranoia is good.

		/*

		 * Find the leaf entry.

		/*

		 * Point to the data entry.

		/*

		 * Fill in the new inode number and log the entry.

	/*

	 * Didn't find it, and we're holding a data block.  Drop it.

	/*

	 * Release all the buffers in the cursor.

/*

 * Trim off a trailing empty freespace block.

 * Return (in rvalp) 1 if we did it, 0 if not.

 error */

 operation arguments */

 free block number */

 out: did something */

 freespace buffer */

 incore directory inode */

 error return code */

 freespace structure */

 transaction pointer */

	/*

	 * Read the freespace block.

	/*

	 * There can be holes in freespace.  If fo is a hole, there's

	 * nothing to do.

	/*

	 * If there are used entries, there's nothing to do.

	/*

	 * Blow the block away.

		/*

		 * Can't fail with ENOSPC since that only happens with no

		 * space reservation, when breaking up an extent into two

		 * pieces.  This is the last block of an extent.

	/*

	 * Return that we succeeded.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2020 Oracle.  All Rights Reserved.

 * Author: Darrick J. Wong <darrick.wong@oracle.com>

/*

 * Staging Cursors and Fake Roots for Btrees

 * =========================================

 *

 * A staging btree cursor is a special type of btree cursor that callers must

 * use to construct a new btree index using the btree bulk loader code.  The

 * bulk loading code uses the staging btree cursor to abstract the details of

 * initializing new btree blocks and filling them with records or key/ptr

 * pairs.  Regular btree operations (e.g. queries and modifications) are not

 * supported with staging cursors, and callers must not invoke them.

 *

 * Fake root structures contain all the information about a btree that is under

 * construction by the bulk loading code.  Staging btree cursors point to fake

 * root structures instead of the usual AG header or inode structure.

 *

 * Callers are expected to initialize a fake root structure and pass it into

 * the _stage_cursor function for a specific btree type.  When bulk loading is

 * complete, callers should call the _commit_staged_btree function for that

 * specific btree type to commit the new btree into the filesystem.

/*

 * Don't allow staging cursors to be duplicated because they're supposed to be

 * kept private to a single thread.

/*

 * Don't allow block allocation for a staging cursor, because staging cursors

 * do not support regular btree modifications.

 *

 * Bulk loading uses a separate callback to obtain new blocks from a

 * preallocated list, which prevents ENOSPC failures during loading.

/*

 * Don't allow block freeing for a staging cursor, because staging cursors

 * do not support regular btree modifications.

 Initialize a pointer to the root block from the fakeroot. */

/*

 * Bulk Loading for AG Btrees

 * ==========================

 *

 * For a btree rooted in an AG header, pass a xbtree_afakeroot structure to the

 * staging cursor.  Callers should initialize this to zero.

 *

 * The _stage_cursor() function for a specific btree type should call

 * xfs_btree_stage_afakeroot to set up the in-memory cursor as a staging

 * cursor.  The corresponding _commit_staged_btree() function should log the

 * new root and call xfs_btree_commit_afakeroot() to transform the staging

 * cursor into a regular btree cursor.

 Update the btree root information for a per-AG fake root. */

/*

 * Initialize a AG-rooted btree cursor with the given AG btree fake root.

 * The btree cursor's bc_ops will be overridden as needed to make the staging

 * functionality work.

/*

 * Transform an AG-rooted staging btree cursor back into a regular cursor by

 * substituting a real btree root for the fake one and restoring normal btree

 * cursor ops.  The caller must log the btree root change prior to calling

 * this.

/*

 * Bulk Loading for Inode-Rooted Btrees

 * ====================================

 *

 * For a btree rooted in an inode fork, pass a xbtree_ifakeroot structure to

 * the staging cursor.  This structure should be initialized as follows:

 *

 * - if_fork_size field should be set to the number of bytes available to the

 *   fork in the inode.

 *

 * - if_fork should point to a freshly allocated struct xfs_ifork.

 *

 * - if_format should be set to the appropriate fork type (e.g.

 *   XFS_DINODE_FMT_BTREE).

 *

 * All other fields must be zero.

 *

 * The _stage_cursor() function for a specific btree type should call

 * xfs_btree_stage_ifakeroot to set up the in-memory cursor as a staging

 * cursor.  The corresponding _commit_staged_btree() function should log the

 * new root and call xfs_btree_commit_ifakeroot() to transform the staging

 * cursor into a regular btree cursor.

/*

 * Initialize an inode-rooted btree cursor with the given inode btree fake

 * root.  The btree cursor's bc_ops will be overridden as needed to make the

 * staging functionality work.  If new_ops is not NULL, these new ops will be

 * passed out to the caller for further overriding.

/*

 * Transform an inode-rooted staging btree cursor back into a regular cursor by

 * substituting a real btree root for the fake one and restoring normal btree

 * cursor ops.  The caller must log the btree root change prior to calling

 * this.

/*

 * Bulk Loading of Staged Btrees

 * =============================

 *

 * This interface is used with a staged btree cursor to create a totally new

 * btree with a large number of records (i.e. more than what would fit in a

 * single root block).  When the creation is complete, the new root can be

 * linked atomically into the filesystem by committing the staged cursor.

 *

 * Creation of a new btree proceeds roughly as follows:

 *

 * The first step is to initialize an appropriate fake btree root structure and

 * then construct a staged btree cursor.  Refer to the block comments about

 * "Bulk Loading for AG Btrees" and "Bulk Loading for Inode-Rooted Btrees" for

 * more information about how to do this.

 *

 * The second step is to initialize a struct xfs_btree_bload context as

 * documented in the structure definition.

 *

 * The third step is to call xfs_btree_bload_compute_geometry to compute the

 * height of and the number of blocks needed to construct the btree.  See the

 * section "Computing the Geometry of the New Btree" for details about this

 * computation.

 *

 * In step four, the caller must allocate xfs_btree_bload.nr_blocks blocks and

 * save them for later use by ->claim_block().  Bulk loading requires all

 * blocks to be allocated beforehand to avoid ENOSPC failures midway through a

 * rebuild, and to minimize seek distances of the new btree.

 *

 * Step five is to call xfs_btree_bload() to start constructing the btree.

 *

 * The final step is to commit the staging btree cursor, which logs the new

 * btree root and turns the staging cursor into a regular cursor.  The caller

 * is responsible for cleaning up the previous btree blocks, if any.

 *

 * Computing the Geometry of the New Btree

 * =======================================

 *

 * The number of items placed in each btree block is computed via the following

 * algorithm: For leaf levels, the number of items for the level is nr_records

 * in the bload structure.  For node levels, the number of items for the level

 * is the number of blocks in the next lower level of the tree.  For each

 * level, the desired number of items per block is defined as:

 *

 * desired = max(minrecs, maxrecs - slack factor)

 *

 * The number of blocks for the level is defined to be:

 *

 * blocks = floor(nr_items / desired)

 *

 * Note this is rounded down so that the npb calculation below will never fall

 * below minrecs.  The number of items that will actually be loaded into each

 * btree block is defined as:

 *

 * npb =  nr_items / blocks

 *

 * Some of the leftmost blocks in the level will contain one extra record as

 * needed to handle uneven division.  If the number of records in any block

 * would exceed maxrecs for that level, blocks is incremented and npb is

 * recalculated.

 *

 * In other words, we compute the number of blocks needed to satisfy a given

 * loading level, then spread the items as evenly as possible.

 *

 * The height and number of fs blocks required to create the btree are computed

 * and returned via btree_height and nr_blocks.

/*

 * Put a btree block that we're loading onto the ordered list and release it.

 * The btree blocks will be written to disk when bulk loading is finished.

/*

 * Allocate and initialize one btree block for bulk loading.

 *

 * The new btree block will have its level and numrecs fields set to the values

 * of the level and nr_this_block parameters, respectively.

 *

 * The caller should ensure that ptrp, bpp, and blockp refer to the left

 * sibling of the new block, if there is any.  On exit, ptrp, bpp, and blockp

 * will all point to the new block.

 in/out */

 in/out */

 in/out */

 Allocate a new incore btree root block. */

 Initialize it and send it out. */

 Claim one of the caller's preallocated blocks. */

	/*

	 * The previous block (if any) is the left sibling of the new block,

	 * so set its right sibling pointer to the new block and drop it.

 Initialize the new btree block. */

 Set the out parameters. */

 Load one leaf block. */

 Fill the leaf block with records. */

/*

 * Load one node block with key/ptr pairs.

 *

 * child_ptr must point to a block within the next level down in the tree.  A

 * key/ptr entry will be created in the new node block to the block pointed to

 * by child_ptr.  On exit, child_ptr points to the next block on the child

 * level that needs processing.

 Fill the node block with keys and pointers. */

/*

 * Compute the maximum number of records (or keyptrs) per block that we want to

 * install at this level in the btree.  Caller is responsible for having set

 * @cur->bc_ino.forksize to the desired fork size, if appropriate.

/*

 * Compute the desired number of records (or keyptrs) per block that we want to

 * install at this level in the btree, which must be somewhere between minrecs

 * and max_npb.  The caller is free to install fewer records per block.

 Root blocks are not subject to minrecs rules. */

/*

 * Compute the number of records to be stored in each block at this level and

 * the number of blocks for this level.  For leaf levels, we must populate an

 * empty root block even if there are no records, so we have to have at least

 * one block.

	/*

	 * Compute the number of blocks we need to fill each block with the

	 * desired number of records/keyptrs per block.  Because desired_npb

	 * could be minrecs, we use regular integer division (which rounds

	 * the block count down) so that in the next step the effective # of

	 * items per block will never be less than desired_npb.

	/*

	 * Compute the number of records that we will actually put in each

	 * block, assuming that we want to spread the records evenly between

	 * the blocks.  Take care that the effective # of items per block (npb)

	 * won't exceed maxrecs even for the blocks that get an extra record,

	 * since desired_npb could be maxrecs, and in the previous step we

	 * rounded the block count down.

/*

 * Ensure a slack value is appropriate for the btree.

 *

 * If the slack value is negative, set slack so that we fill the block to

 * halfway between minrecs and maxrecs.  Make sure the slack is never so large

 * that we can underflow minrecs.

	/*

	 * If slack is negative, automatically set slack so that we load the

	 * btree block approximately halfway between minrecs and maxrecs.

	 * Generally, this will net us 75% loading.

/*

 * Prepare a btree cursor for a bulk load operation by computing the geometry

 * fields in bbl.  Caller must ensure that the btree cursor is a staging

 * cursor.  This function can be called multiple times.

	/*

	 * Make sure that the slack values make sense for traditional leaf and

	 * node blocks.  Inode-rooted btrees will return different minrecs and

	 * maxrecs values for the root block (bc_nlevels == level - 1).  We're

	 * checking levels 0 and 1 here, so set bc_nlevels such that the btree

	 * code doesn't interpret either as the root level.

			/*

			 * If all the items we want to store at this level

			 * would fit in the inode root block, then we have our

			 * btree root and are done.

			 *

			 * Note that bmap btrees forbid records in the root.

			/*

			 * Otherwise, we have to store all the items for this

			 * level in traditional btree blocks and therefore need

			 * another level of btree to point to those blocks.

			 *

			 * We have to re-compute the geometry for each level of

			 * an inode-rooted btree because the geometry differs

			 * between a btree root in an inode fork and a

			 * traditional btree block.

			 *

			 * This distinction is made in the btree code based on

			 * whether level == bc_nlevels - 1.  Based on the

			 * previous root block size check against the root

			 * block geometry, we know that we aren't yet ready to

			 * populate the root.  Increment bc_nevels and

			 * recalculate the geometry for a traditional

			 * block-based btree level.

			/*

			 * If all the items we want to store at this level

			 * would fit in a single root block, we're done.

 Otherwise, we need another level of btree. */

 Bulk load a btree given the parameters and geometry established in bbl. */

 Load each leaf block. */

		/*

		 * Due to rounding, btree blocks will not be evenly populated

		 * in most cases.  blocks_with_extra tells us how many blocks

		 * will receive an extra record to distribute the excess across

		 * the current level as evenly as possible.

		/*

		 * Record the leftmost leaf pointer so we know where to start

		 * with the first node level.

 Populate the internal btree nodes. */

 Load each node block. */

			/*

			 * Record the leftmost node pointer so that we know

			 * where to start the next node level above this one.

 Initialize the new root. */

	/*

	 * Write the new blocks to disk.  If the ordered list isn't empty after

	 * that, then something went wrong and we have to fail.  This should

	 * never happen, but we'll check anyway.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2000-2003,2005 Silicon Graphics, Inc.

 * Copyright (c) 2013 Red Hat, Inc.

 * All Rights Reserved.

/*

 * Local function declarations.

/*

 * Check the internal consistency of a leaf1 block.

 * Pop an assert if something is wrong.

	/*

	 * XXX (dgc): This value is not restrictive enough.

	 * Should factor in the size of the bests table as well.

	 * We can deduce a value for that from i_disk_size.

 Leaves and bests don't overlap in leaf format. */

 Check hash value order, count stale entries.  */

/*

 * We verify the magic numbers before decoding the leaf header so that on debug

 * kernels we don't get assertion failures in xfs_dir3_leaf_hdr_from_disk() due

 * to incorrect magic numbers.

/*

 * Initialize a new leaf block, leaf1 or leafn magic accepted.

	/*

	 * If it's a leaf-format directory initialize the tail.

	 * Caller is responsible for initialising the bests table.

/*

 * Convert a block form directory to a leaf form directory.

 error */

 operation arguments */

 input block's buffer */

 leaf's bestsp entries */

 leaf block's bno */

 block header */

 block's leaf entries */

 block's tail */

 incore directory inode */

 error return code */

 leaf block's buffer */

 leaf block's bno */

 leaf structure */

 leaf's tail */

 need to log block header */

 need to rescan bestfree */

 transaction pointer */

	/*

	 * Add the leaf block to the inode.

	 * This interface will only put blocks in the leaf/node range.

	 * Since that's empty now, we'll get the root (block 0 in range).

	/*

	 * Initialize the leaf block, get a buffer for it.

	/*

	 * Set the counts in the leaf header.

	/*

	 * Could compact these but I think we always do the conversion

	 * after squeezing out stale entries.

	/*

	 * Make the space formerly occupied by the leaf entries and block

	 * tail be free.

	/*

	 * Fix up the block header, make it a data block.

	/*

	 * Set up leaf tail and bests table.

	/*

	 * Log the data header and leaf bests table.

	/*

	 * Find the first stale entry before our index, if any.

	/*

	 * Find the first stale entry at or after our index, if any.

	 * Stop if the result would require moving more entries than using

	 * lowstale.

 leaf table position */

 need to compact leaves */

 index of prev stale leaf */

 index of next stale leaf */

 low leaf logging index */

 high leaf logging index */

 leaf entry table pointer */

		/*

		 * Now we need to make room to insert the leaf entry.

		 *

		 * If there are no stale entries, just insert a hole at index.

		/*

		 * Record low and high logging indices for the leaf.

	/*

	 * There are stale entries.

	 *

	 * We will use one of them for the new entry.  It's probably not at

	 * the right location, so we'll have to shift some up or down first.

	 *

	 * If we didn't compact before, we need to find the nearest stale

	 * entries before and after our insertion point.

	/*

	 * If the low one is better, use it.

		/*

		 * Copy entries up to cover the stale entry and make room

		 * for the new entry.

	/*

	 * The high one is better, so use that one.

	/*

	 * Copy entries down to cover the stale entry and make room for the

	 * new entry.

/*

 * Add an entry to a leaf form directory.

 error */

 operation arguments */

 freespace table in leaf */

 end of data entry */

 data block buffer */

 leaf's buffer */

 leaf structure */

 incore directory inode */

 data block header */

 data block entry */

 leaf entry table pointer */

 data unused entry */

 leaf tail pointer */

 bestfree table */

 need to compact leaves */

 error return value */

 allocated new data block */

 index of next stale leaf */

 temporary, index */

 leaf table position */

 length of new entry */

 low leaf logging index */

 high leaf logging index */

 index of prev stale leaf */

 leaf block bytes needed */

 need to log data header */

 need to rescan data free */

 data block number */

	/*

	 * Look up the entry by hash value and name.

	 * We know it's not there, our caller has already done a lookup.

	 * So the index is of the entry to insert in front of.

	 * But if there are dup hash values the index is of the first of those.

	/*

	 * See if there are any entries with the same hash value

	 * and space in their block for the new entry.

	 * This is good because it puts multiple same-hash value entries

	 * in a data block, improving the lookup of those entries.

	/*

	 * Didn't find a block yet, linear search all the data blocks.

			/*

			 * Remember a block we see that's missing.

	/*

	 * How many bytes do we need in the leaf block?

	/*

	 * Now kill use_block if it refers to a missing block, so we

	 * can use it as an indication of allocation needed.

	/*

	 * If we don't have enough free bytes but we can make enough

	 * by compacting out stale entries, we'll do that.

	/*

	 * Otherwise if we don't have enough free bytes we need to

	 * convert to node form.

		/*

		 * Just checking or no space reservation, give up.

		/*

		 * Convert to node form.

		/*

		 * Then add the new entry.

	/*

	 * Otherwise it will fit without compaction.

	/*

	 * If just checking, then it will fit unless we needed to allocate

	 * a new data block.

	/*

	 * If no allocations are allowed, return now before we've

	 * changed anything.

	/*

	 * Need to compact the leaf entries, removing stale ones.

	 * Leave one stale entry behind - the one closest to our

	 * insertion index - and we'll shift that one to our insertion

	 * point later.

	/*

	 * There are stale entries, so we'll need log-low and log-high

	 * impossibly bad values later.

	/*

	 * If there was no data block space found, we need to allocate

	 * a new one.

		/*

		 * Add the new data block.

		/*

		 * Initialize the block.

		/*

		 * If we're adding a new data block on the end we need to

		 * extend the bests table.  Copy it up one entry.

		/*

		 * If we're filling in a previously empty block just log it.

		/*

		 * Already had space in some data block.

		 * Just read that one in.

	/*

	 * Point to the biggest freespace in our data block.

	/*

	 * Mark the initial part of our freespace in use for the new entry.

	/*

	 * Initialize our new entry (at last).

	/*

	 * Need to scan fix up the bestfree table.

	/*

	 * Need to log the data block's header.

	/*

	 * If the bests table needs to be changed, do it.

	 * Log the change unless we've already done that.

	/*

	 * Fill in the new leaf entry.

	/*

	 * Log the leaf fields and give up the buffers.

/*

 * Compact out any stale entries in the leaf.

 * Log the header and changed leaf entries, if any.

 operation arguments */

 leaf buffer */

 source leaf index */

 leaf structure */

 first leaf entry to log */

 target leaf index */

	/*

	 * Compress out the stale entries in place.

		/*

		 * Only actually copy the entries that are different.

	/*

	 * Update and log the header, log the leaf entries.

/*

 * Compact the leaf entries, removing stale ones.

 * Leave one stale entry behind - the one closest to our

 * insertion index - and the caller will shift that one to our insertion

 * point later.

 * Return new insertion index, where the remaining stale entry is,

 * and leaf logging indices.

 insertion index */

 out: stale entry before us */

 out: stale entry after us */

 out: low log index */

 out: high log index */

 source copy index */

 stale entry at/after index */

 insertion index */

 source index of kept stale */

 stale entry before index */

 new insertion index */

 destination copy index */

	/*

	 * Pick the better of lowstale and highstale.

	/*

	 * Copy the entries in place, removing all the stale entries

	 * except keepstale.

		/*

		 * Notice the new value of index.

		/*

		 * Record the new keepstale value for the insertion.

		/*

		 * Copy only the entries that have moved.

	/*

	 * If the insertion point was past the last entry,

	 * set the new insertion point accordingly.

	/*

	 * Adjust the leaf header values.

	/*

	 * Remember the low/high stale value only in the "right"

	 * direction.

/*

 * Log the bests entries indicated from a leaf1 block.

 leaf buffer */

 first entry to log */

 last entry to log */

 pointer to first entry */

 pointer to last entry */

 leaf tail structure */

/*

 * Log the leaf entries indicated from a leaf1 or leafn block.

 pointer to first entry */

 pointer to last entry */

/*

 * Log the header of the leaf1 or leafn block.

/*

 * Log the tail of the leaf1 block.

 leaf tail structure */

/*

 * Look up the entry referred to by args in the leaf format directory.

 * Most of the work is done by the xfs_dir2_leaf_lookup_int routine which

 * is also used by the node-format code.

 operation arguments */

 data block buffer */

 data block entry */

 incore directory inode */

 error return code */

 found entry index */

 leaf buffer */

 leaf entry */

 transaction pointer */

	/*

	 * Look up name in the leaf block, returning both buffers and index.

	/*

	 * Get to the leaf entry and contained data entry address.

	/*

	 * Point to the data entry.

	/*

	 * Return the found inode number & CI name if appropriate

/*

 * Look up name/hash in the leaf block.

 * Fill in indexp with the found index, and dbpp with the data buffer.

 * If not found dbpp will be NULL, and ENOENT comes back.

 * lbpp will always be filled in with the leaf buffer unless there's an error.

 error */

 operation arguments */

 out: leaf buffer */

 out: index in leaf block */

 out: data buffer */

 current data block number */

 data buffer */

 data entry */

 incore directory inode */

 error return code */

 index in leaf block */

 leaf buffer */

 leaf entry */

 leaf structure */

 filesystem mount point */

 new data block number */

 transaction pointer */

 case match data block no. */

 name compare result */

	/*

	 * Look for the first leaf entry with our hash value.

	/*

	 * Loop over all the entries with the right hash value

	 * looking to match the name.

		/*

		 * Skip over stale leaf entries.

		/*

		 * Get the new data block number.

		/*

		 * If it's not the same as the old data block number,

		 * need to pitch the old one and read the new one.

		/*

		 * Point to the data entry.

		/*

		 * Compare name and if it's an exact match, return the index

		 * and buffer. If it's the first case-insensitive match, store

		 * the index and buffer and continue looking for an exact match.

 case exact match: return the current buffer. */

	/*

	 * Here, we can only be doing a lookup (not a rename or remove).

	 * If a case-insensitive match was found earlier, re-read the

	 * appropriate data block if required and return it.

	/*

	 * No match found, return -ENOENT.

/*

 * Remove an entry from a leaf format directory.

 error */

 operation arguments */

 leaf block best freespace */

 data block header */

 data block number */

 data block buffer */

 data entry structure */

 incore directory inode */

 error return code */

 temporary data block # */

 index into leaf entries */

 leaf buffer */

 leaf structure */

 leaf entry */

 leaf tail structure */

 need to log data header */

 need to rescan data frees */

 old value of best free */

 bestfree table */

	/*

	 * Lookup the leaf entry, get the leaf and data blocks read in.

	/*

	 * Point to the leaf entry, use that to point to the data entry.

	/*

	 * Mark the former data entry unused.

	/*

	 * We just mark the leaf entry stale by putting a null in it.

	/*

	 * Scan the freespace in the data block again if necessary,

	 * log the data block header if necessary.

	/*

	 * If the longest freespace in the data block has changed,

	 * put the new value in the bests table and log that.

	/*

	 * If the data block is now empty then get rid of the data block.

			/*

			 * Nope, can't get rid of it because it caused

			 * allocation of a bmap btree block to do so.

			 * Just go on, returning success, leaving the

			 * empty block in place.

		/*

		 * If this is the last data block then compact the

		 * bests table by getting rid of entries.

			/*

			 * Look for the last active entry (i).

			/*

			 * Copy the table down so inactive entries at the

			 * end are removed.

	/*

	 * If the data block was not the first one, drop it.

	/*

	 * See if we can convert to block form.

/*

 * Replace the inode number in a leaf format directory entry.

 error */

 operation arguments */

 data block buffer */

 data block entry */

 incore directory inode */

 error return code */

 index of leaf entry */

 leaf buffer */

 leaf entry */

 transaction pointer */

	/*

	 * Look up the entry.

	/*

	 * Point to the leaf entry, get data address from it.

	/*

	 * Point to the data entry.

	/*

	 * Put the new inode number in, log it.

/*

 * Return index in the leaf block (lbp) which is either the first

 * one with this hash value, or if there are none, the insert point

 * for that hash value.

 index value */

 operation arguments */

 leaf buffer */

 hash from this entry */

 hash value looking for */

 high leaf index */

 low leaf index */

 leaf entry */

 current leaf index */

	/*

	 * Note, the table cannot be empty, so we have to go through the loop.

	 * Binary search the leaf entries looking for our hash value.

	/*

	 * Found one, back up through all the equal hash values.

	/*

	 * Need to point to an entry higher than ours.

/*

 * Trim off a trailing data block.  We know it's empty since the leaf

 * freespace table says so.

 error */

 operation arguments */

 leaf buffer */

 data block number */

 leaf bests table */

 data block buffer */

 incore directory inode */

 error return value */

 leaf structure */

 leaf tail structure */

 transaction pointer */

	/*

	 * Read the offending data block.  We need its buffer.

	/*

	 * Get rid of the data block.

	/*

	 * Eliminate the last bests entry from the table.

/*

 * Convert node form directory to leaf form directory.

 * The root of the node form dir needs to already be a LEAFN block.

 * Just return if we can't do anything.

 error */

 directory operation state */

 operation arguments */

 incore directory inode */

 error return code */

 buffer for freespace block */

 freespace file offset */

 buffer for leaf block */

 tail of leaf structure */

 leaf structure */

 filesystem mount point */

 successful free trim? */

 transaction pointer */

	/*

	 * There's more than a leaf level in the btree, so there must

	 * be multiple leafn blocks.  Give up.

	/*

	 * Get the last offset in the file.

	/*

	 * If there are freespace blocks other than the first one,

	 * take this opportunity to remove trailing empty freespace blocks

	 * that may have been left behind during no-space-reservation

	 * operations.

	/*

	 * Now find the block just before the freespace block.

	/*

	 * If it's not the single leaf block, give up.

	/*

	 * Read the freespace block.

	/*

	 * Now see if the leafn and free data will fit in a leaf1.

	 * If not, release the buffer and give up.

	/*

	 * If the leaf has any stale entries in it, compress them out.

	/*

	 * Set up the leaf tail from the freespace block.

	/*

	 * Set up the leaf bests table.

	/*

	 * Get rid of the freespace block.

		/*

		 * This can't fail here because it can only happen when

		 * punching out the middle of an extent, and this is an

		 * isolated block.

	/*

	 * Now see if we can convert the single-leaf directory

	 * down to a block form directory.

	 * This routine always kills the dabuf for the leaf, so

	 * eliminate it from the path.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2000-2006 Silicon Graphics, Inc.

 * All Rights Reserved.

/*

 * If we are doing readahead on an inode buffer, we might be in log recovery

 * reading an inode allocation buffer that hasn't yet been replayed, and hence

 * has not had the inode cores stamped into it. Hence for readahead, the buffer

 * may be potentially invalid.

 *

 * If the readahead buffer is invalid, we need to mark it with an error and

 * clear the DONE status of the buffer so that a followup read will re-read it

 * from disk. We don't report the error otherwise to avoid warnings during log

 * recovery and we don't get unnecessary panics on debug kernels. We use EIO here

 * because all we want to do is say readahead failed; there is no-one to report

 * the error to, so this will distinguish it from a non-ra verifier failure.

 * Changes to this readahead error behaviour also need to be reflected in

 * xfs_dquot_buf_readahead_verify().

	/*

	 * Validate the magic number and version of every inode in the buffer

/*

 * This routine is called to map an inode to the buffer containing the on-disk

 * version of the inode.  It returns a pointer to the buffer containing the

 * on-disk inode in the bpp parameter.

 Convert an ondisk timestamp to an incore timestamp. */

	/*

	 * First get the permanent information that is needed to allocate an

	 * inode. If the inode is unused, mode is zero and we shouldn't mess

	 * with the uninitialized part of it.

	/*

	 * Convert v1 inodes immediately to v2 inode format as this is the

	 * minimum inode version format we support in the rest of the code.

	 * They will also be unconditionally written back to disk as v2 inodes.

	/*

	 * Time is signed, so need to convert to signed 32 bit before

	 * storing in inode timestamp which may be 64 bit. Otherwise

	 * a time before epoch is converted to a time long after epoch

	 * on 64 bit systems.

 Convert an incore timestamp to an ondisk timestamp. */

		/*

		 * no local regular files yet

 fall through ... */

 fall through ... */

 Verify v3 integrity information first */

 don't allow invalid i_size */

 No zero-length symlinks/dirs. */

 Fork checks carried over from xfs_iformat_fork */

 check for illegal values of forkoff */

 Do we have appropriate data fork formats for the mode? */

 Uninitialized inode ok. */

		/*

		 * If there is no fork offset, this may be a freshly-made inode

		 * in a new disk cluster, in which case di_aformat is zeroed.

		 * Otherwise, such an inode must be in EXTENTS format; this goes

		 * for freed inodes as well.

 extent size hint validation */

 only version 3 or greater inodes are extensively verified here */

 don't allow reflink/cowextsize if we don't have reflink */

 only regular files get reflink */

 don't let reflink and realtime mix */

 COW extent size hint validation */

 bigtime iflag can only happen on bigtime filesystems */

/*

 * Validate di_extsize hint.

 *

 * 1. Extent size hint is only valid for directories and regular files.

 * 2. FS_XFLAG_EXTSIZE is only valid for regular files.

 * 3. FS_XFLAG_EXTSZINHERIT is only valid for directories.

 * 4. Hint cannot be larger than MAXTEXTLEN.

 * 5. Can be changed on directories at any time.

 * 6. Hint value of 0 turns off hints, clears inode flags.

 * 7. Extent size must be a multiple of the appropriate block size.

 *    For realtime files, this is the rt extent size.

 * 8. For non-realtime files, the extent size hint must be limited

 *    to half the AG size to avoid alignment extending the extent beyond the

 *    limits of the AG.

	/*

	 * This comment describes a historic gap in this verifier function.

	 *

	 * For a directory with both RTINHERIT and EXTSZINHERIT flags set, this

	 * function has never checked that the extent size hint is an integer

	 * multiple of the realtime extent size.  Since we allow users to set

	 * this combination  on non-rt filesystems /and/ to change the rt

	 * extent size when adding a rt device to a filesystem, the net effect

	 * is that users can configure a filesystem anticipating one rt

	 * geometry and change their minds later.  Directories do not use the

	 * extent size hint, so this is harmless for them.

	 *

	 * If a directory with a misaligned extent size hint is allowed to

	 * propagate that hint into a new regular realtime file, the result

	 * is that the inode cluster buffer verifier will trigger a corruption

	 * shutdown the next time it is run, because the verifier has always

	 * enforced the alignment rule for regular files.

	 *

	 * Because we allow administrators to set a new rt extent size when

	 * adding a rt section, we cannot add a check to this verifier because

	 * that will result a new source of directory corruption errors when

	 * reading an existing filesystem.  Instead, we rely on callers to

	 * decide when alignment checks are appropriate, and fix things up as

	 * needed.

 free inodes get flags set to zero but extsize remains */

/*

 * Validate di_cowextsize hint.

 *

 * 1. CoW extent size hint can only be set if reflink is enabled on the fs.

 *    The inode does not have to have any shared blocks, but it must be a v3.

 * 2. FS_XFLAG_COWEXTSIZE is only valid for directories and regular files;

 *    for a directory, the hint is propagated to new files.

 * 3. Can be changed on files & directories at any time.

 * 4. Hint value of 0 turns off hints, clears inode flags.

 * 5. Extent size must be a multiple of the appropriate block size.

 * 6. The extent size hint must be limited to half the AG size to avoid

 *    alignment extending the extent beyond the limits of the AG.

 free inodes get flags set to zero but cowextsize remains */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2000-2001,2005 Silicon Graphics, Inc.

 * All Rights Reserved.

/*

 * Convert inode mode to directory entry filetype

/*

 * ASCII case-insensitive (ie. A-Z) support for directories that was

 * used in IRIX.

 set up directory geometry */

	/*

	 * Now we've set up the block conversion variables, we can calculate the

	 * segment block constants using the geometry structure.

 set up attribute geometry - single fsb only */

/*

 * Return 1 if directory contains only "." and "..".

 might happen during shutdown. */

/*

 * Validate a given inode number.

/*

 * Initialize a directory with its "." and ".." entries.

/*

 * Enter a name in a directory, or check for available space.

 * If inum is 0, only the available space test is performed.

 new entry inode number */

 bmap's total block count */

 type-checking value */

/*

 * If doing a CI lookup and case-insensitive match, dup actual name into

 * args.value. Return EEXIST for success (ie. name found) or an error.

/*

 * Lookup a name in a directory, give back the inode number.

 * If ci_name is not NULL, returns the actual name in ci_name if it differs

 * to name, or ci_name->name is set to NULL for an exact match.

 out: inode number */

 out: actual name if CI match */

 type-checking value */

	/*

	 * We need to use KM_NOFS here so that lockdep will not throw false

	 * positive deadlock warnings on a non-transactional lookup path. It is

	 * safe to recurse into inode recalim in that case, but lockdep can't

	 * easily be taught about it. Hence KM_NOFS avoids having to add more

	 * lockdep Doing this avoids having to add a bunch of lockdep class

	 * annotations into the reclaim path for the ilock.

/*

 * Remove an entry from a directory.

 bmap's total block count */

 type-checking value */

/*

 * Replace the inode number of a directory entry.

 name of entry to replace */

 new inode number */

 bmap's total block count */

 type-checking value */

/*

 * See if this entry can be added to the directory without allocating space.

 name of entry to add */

/*

 * Utility routines.

/*

 * Add a block to the directory.

 *

 * This routine is for data and free blocks, not leaf/node blocks which are

 * handled by xfs_da_grow_inode.

 v2 dir's space XFS_DIR2_xxx_SPACE */

 out: block number added */

 directory offset of new block */

 count of filesystem blocks */

	/*

	 * Set lowest possible block in the space requested.

	/*

	 * Update file's size if this is the data space and it grew.

 directory file (data) size */

/*

 * See if the directory is a single-block form directory.

 out: 1 is block, 0 is not block */

 last file offset */

/*

 * See if the directory is a single-leaf form directory.

 out: 1 is block, 0 is not block */

 last file offset */

/*

 * Remove the given block from the directory.

 * This routine is used for data and free blocks, leaf/node are done

 * by xfs_da_shrink_inode.

 directory file offset */

 directory file offset */

 bunmap is finished */

 Unmap the fsblock(s). */

		/*

		 * ENOSPC actually can happen if we're in a removename with no

		 * space reservation, and the resulting block removal would

		 * cause a bmap btree split or conversion from extents to btree.

		 * This can only happen for un-fragmented directory blocks,

		 * since you need to be punching out the middle of an extent.

		 * In this case we need to leave the block in the file, and not

		 * binval it.  So the block has to be in a consistent empty

		 * state and appropriately logged.  We don't free up the buffer,

		 * the caller can tell it hasn't happened since it got an error

		 * back.

	/*

	 * Invalidate the buffer from the transaction.

	/*

	 * If it's not a data block, we're done.

	/*

	 * If the block isn't the last one in the directory, we're done.

		/*

		 * This can't really happen unless there's kernel corruption.

	/*

	 * Set the size to the new last block.

 Returns true if the directory entry name is valid. */

	/*

	 * MAXNAMELEN includes the trailing null, but (name/length) leave it

	 * out, so use >= for the length check.

 There shouldn't be any slashes or nulls here */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2000-2002,2005 Silicon Graphics, Inc.

 * All Rights Reserved.

/*

 * Size of the AGFL.  For CRC-enabled filesystes we steal a couple of slots in

 * the beginning of the block for a proper header with the location information

 * and CRC.

/*

 * In order to avoid ENOSPC-related deadlock caused by out-of-order locking of

 * AGF buffer (PV 947395), we place constraints on the relationship among

 * actual allocations for data blocks, freelist blocks, and potential file data

 * bmap btree blocks. However, these restrictions may result in no actual space

 * allocated for a delayed extent, for example, a data block in a certain AG is

 * allocated but there is no additional block for the additional bmap btree

 * block due to a split of the bmap btree of the file. The result of this may

 * lead to an infinite loop when the file gets flushed to disk and all delayed

 * extents need to be actually allocated. To get around this, we explicitly set

 * aside a few blocks which will not be reserved in delayed allocation.

 *

 * We need to reserve 4 fsbs _per AG_ for the freelist and 4 more to handle a

 * potential split of the file's bmap btree.

/*

 * When deciding how much space to allocate out of an AG, we limit the

 * allocation maximum size to the size the AG. However, we cannot use all the

 * blocks in the AG - some are permanently used by metadata. These

 * blocks are generally:

 *	- the AG superblock, AGF, AGI and AGFL

 *	- the AGF (bno and cnt) and AGI btree root blocks, and optionally

 *	  the AGI free inode and rmap btree root blocks.

 *	- blocks on the AGFL according to xfs_alloc_set_aside() limits

 *	- the rmapbt root block

 *

 * The AG headers are sector sized, so the amount of space they take up is

 * dependent on filesystem geometry. The others are all single blocks.

 ag headers */

 AGF, AGI btree root blocks */

 finobt root block */

 rmap root block */

 refcount root block */

/*

 * Lookup the record equal to [bno, len] in the btree given by cur.

 error */

 btree cursor */

 starting block of extent */

 length of extent */

 success/failure */

/*

 * Lookup the first record greater than or equal to [bno, len]

 * in the btree given by cur.

 error */

 btree cursor */

 starting block of extent */

 length of extent */

 success/failure */

/*

 * Lookup the first record less than or equal to [bno, len]

 * in the btree given by cur.

 error */

 btree cursor */

 starting block of extent */

 length of extent */

 success/failure */

/*

 * Update the record referred to by cur to the value given

 * by [bno, len].

 * This either works (return 0) or gets an EFSCORRUPTED error.

 error */

 btree cursor */

 starting block of extent */

 length of extent */

/*

 * Get the data from the pointed-to record.

 error */

 btree cursor */

 output: starting block of extent */

 output: length of extent */

 output: success/failure */

 check for valid extent range, including overflow */

/*

 * Compute aligned version of the found extent.

 * Takes alignment and min length into account.

 allocation argument structure */

 starting block in found extent */

 length in found extent */

 result block number */

 result length */

 Trim busy sections out of found extent */

	/*

	 * If we have a largish extent that happens to start before min_agbno,

	 * see if we can shift it into range...

/*

 * Compute best start block and diff for "near" allocations.

 * freelen >= wantlen already checked by caller.

 difference value (absolute) */

 target starting block */

 target length */

 target alignment */

 are we allocating data? */

 freespace's starting block */

 freespace's length */

 result: best start block from free */

 end of freespace extent */

 return block number */

 other new block number */

 length with newbno1 */

 length with newbno2 */

 end of target extent */

	/*

	 * We want to allocate from the start of a free extent if it is past

	 * the desired block or if we are allocating user data and the free

	 * extent is before desired block. The second case is there to allow

	 * for contiguous allocation from the remaining free space if the file

	 * grows in the short term.

/*

 * Fix up the length, based on mod and prod.

 * len should be k * prod + mod for some k.

 * If len is too small it is returned unchanged.

 * If len hits maxlen it is left alone.

 allocation argument structure */

 casts to (int) catch length underflows */

/*

 * Update the two btrees, logically removing from freespace the extent

 * starting at rbno, rlen blocks.  The extent is contained within the

 * actual (current) free extent fbno for flen blocks.

 * Flags are passed in indicating whether the cursors are set to the

 * relevant records.

 error code */

 cursor for by-size btree */

 cursor for by-block btree */

 starting block of free extent */

 length of free extent */

 starting block of returned extent */

 length of returned extent */

 flags, XFSA_FIXUP_... */

 error code */

 operation results */

 first new free startblock */

 second new free startblock */

 first new free length */

 second new free length */

	/*

	 * Look up the record in the by-size tree if necessary.

	/*

	 * Look up the record in the by-block tree if necessary.

	/*

	 * Deal with all four cases: the allocated record is contained

	 * within the freespace record, so we can have new freespace

	 * at either (or both) end, or no freespace remaining.

	/*

	 * Delete the entry from the by-size btree.

	/*

	 * Add new by-size btree entry(s).

	/*

	 * Fix up the by-block btree entry(s).

		/*

		 * No remaining freespace, just delete the by-block tree entry.

		/*

		 * Update the by-block entry to start later|be shorter.

		/*

		 * 2 resulting free entries, need to add one.

	/*

	 * There is no verification of non-crc AGFLs because mkfs does not

	 * initialise the AGFL to zero or NULL. Hence the only valid part of the

	 * AGFL is what the AGF says is active. We can't get to the AGF, so we

	 * can't verify just those entries are valid.

	/*

	 * during growfs operations, the perag is not fully initialised,

	 * so we can't use it for any useful checking. growfs ensures we can't

	 * use it by using uncached buffers that don't have the perag attached

	 * so we can detect and avoid this problem.

	/*

	 * There is no verification of non-crc AGFLs because mkfs does not

	 * initialise the AGFL to zero or NULL. Hence the only valid part of the

	 * AGFL is what the AGF says is active. We can't get to the AGF, so we

	 * can't verify just those entries are valid.

 no verification of non-crc AGFLs */

/*

 * Read in the allocation group free block array.

 error */

 mount point structure */

 transaction pointer */

 allocation group number */

 buffer for the ag free block array */

 return value */

/*

 * Block allocation algorithm and data structures.

 btree cursors */

 current search length */

 extent startblock */

 extent length */

 alloc bno */

 alloc len */

 diff from search bno */

 busy state */

/*

 * Set up cursors, etc. in the extent allocation cursor. This function can be

 * called multiple times to reset an initialized structure without having to

 * reallocate cursors.

	/*

	 * Perform an initial cntbt lookup to check for availability of maxlen

	 * extents. If this fails, we'll return -ENOSPC to signal the caller to

	 * attempt a small allocation.

	/*

	 * Allocate the bnobt left and right search cursors.

/*

 * Check an extent for allocation and track the best available candidate in the

 * allocation structure. The cursor is deactivated if it has entered an out of

 * range state based on allocation arguments. Optionally return the extent

 * extent geometry and allocation status if requested by the caller.

	/*

	 * Check minlen and deactivate a cntbt cursor if out of acceptable size

	 * range (i.e., walking backwards looking for a minlen extent).

 deactivate a bnobt cursor outside of locality range */

	/*

	 * We have an aligned record that satisfies minlen and beats or matches

	 * the candidate extent size. Compare locality for near allocation mode.

	/*

	 * Deactivate a bnobt cursor with worse locality than the current best.

	/*

	 * We're done if we found a perfect allocation. This only deactivates

	 * the current cursor, but this is just an optimization to terminate a

	 * cntbt search that otherwise runs to the edge of the tree.

/*

 * Complete an allocation of a candidate extent. Remove the extent from both

 * trees and update the args structure.

/*

 * Locality allocation lookup algorithm. This expects a cntbt cursor and uses

 * bno optimized lookup to search for extents with ideal size and locality.

 locality optimized lookup */

 check the current record and update search length from it */

	/*

	 * We looked up the first record >= [agbno, len] above. The agbno is a

	 * secondary key and so the current record may lie just before or after

	 * agbno. If it is past agbno, check the previous record too so long as

	 * the length matches as it may be closer. Don't check a smaller record

	 * because that could deactivate our cursor.

	/*

	 * Increment the search key until we find at least one allocation

	 * candidate or if the extent we found was larger. Otherwise, double the

	 * search key to optimize the search. Efficiency is more important here

	 * than absolute best locality.

/*

 * Deal with the case where only small freespaces remain. Either return the

 * contents of the last freespace record, or allocate space from the freelist if

 * there is nothing in the tree.

 error */

 allocation argument structure */

 optional by-size cursor */

 result block number */

 result length */

 status: 0-freelist, 1-normal/none */

	/*

	 * If a cntbt cursor is provided, try to allocate the largest record in

	 * the tree. Try the AGFL if the cntbt is empty, otherwise fail the

	 * allocation. Make sure to respect minleft even when pulling from the

	 * freelist.

	/*

	 * If we're feeding an AGFL block to something that doesn't live in the

	 * free space, we need to clear out the OWN_AG rmap.

	/*

	 * Can't do the allocation, give up.

/*

 * Allocate a variable extent in the allocation group agno.

 * Type and bno are used to determine where in the allocation group the

 * extent will start.

 * Extent's length (returned in *len) will be between minlen and maxlen,

 * and of the form k * prod + mod unless there's nothing that large.

 * Return the starting a.g. block, or NULLAGBLOCK if we can't do it.

 error */

 argument structure for allocation */

	/*

	 * Branch to correct routine based on the type.

 NOTREACHED */

 if not file data, insert new block into the reverse map btree */

/*

 * Allocate a variable extent at exactly agno/bno.

 * Extent's length (returned in *len) will be between minlen and maxlen,

 * and of the form k * prod + mod unless there's nothing that large.

 * Return the starting a.g. block (bno), or NULLAGBLOCK if we can't do it.

 error */

 allocation argument structure */

 by block-number btree cursor */

 by count btree cursor */

 start block of found extent */

 length of found extent */

 start block of busy extent */

 length of busy extent */

 end block of busy extent */

 success/failure of operation */

	/*

	 * Allocate/initialize a cursor for the by-number freespace btree.

	/*

	 * Lookup bno and minlen in the btree (minlen is irrelevant, really).

	 * Look for the closest free block <= bno, it must contain bno

	 * if any free block does.

	/*

	 * Grab the freespace record.

	/*

	 * Check for overlapping busy extents.

	/*

	 * Give up if the start of the extent is busy, or the freespace isn't

	 * long enough for the minimum request.

	/*

	 * End of extent will be smaller of the freespace end and the

	 * maximal requested end.

	 *

	 * Fix the length according to mod and prod if given.

	/*

	 * We are allocating agbno for args->len

	 * Allocate/initialize a cursor for the by-size btree.

 Didn't find it, return null. */

/*

 * Search a given number of btree records in a given direction. Check each

 * record against the good extent we've already found.

 quit on first candidate */

 rec count (-1 for infinite) */

	/*

	 * Search so long as the cursor is active or we find a better extent.

	 * The cursor is deactivated if it extends beyond the range of the

	 * current allocation candidate.

/*

 * Search the by-bno and by-size btrees in parallel in search of an extent with

 * ideal locality based on the NEAR mode ->agbno locality hint.

	/*

	 * Search the bnobt and cntbt in parallel. Search the bnobt left and

	 * right and lookup the closest extent to the locality hint for each

	 * extent size key in the cntbt. The entire search terminates

	 * immediately on a bnobt hit because that means we've found best case

	 * locality. Otherwise the search continues until the cntbt cursor runs

	 * off the end of the tree. If no allocation candidate is found at this

	 * point, give up on locality, walk backwards from the end of the cntbt

	 * and take the first available extent.

	 *

	 * The parallel tree searches balance each other out to provide fairly

	 * consistent performance for various situations. The bnobt search can

	 * have pathological behavior in the worst case scenario of larger

	 * allocation requests and fragmented free space. On the other hand, the

	 * bnobt is able to satisfy most smaller allocation requests much more

	 * quickly than the cntbt. The cntbt search can sift through fragmented

	 * free space and sets of free extents for larger allocation requests

	 * more quickly than the bnobt. Since the locality hint is just a hint

	 * and we don't want to scan the entire bnobt for perfect locality, the

	 * cntbt search essentially bounds the bnobt search such that we can

	 * find good enough locality at reasonable performance in most cases.

		/*

		 * Search the bnobt left and right. In the case of a hit, finish

		 * the search in the opposite direction and we're done.

		/*

		 * Check the extent with best locality based on the current

		 * extent size search key and keep track of the best candidate.

	/*

	 * If we failed to find anything due to busy extents, return empty

	 * handed so the caller can flush and retry. If no busy extents were

	 * found, walk backwards from the end of the cntbt as a last resort.

	/*

	 * Search in the opposite direction for a better entry in the case of

	 * a bnobt hit or walk backwards from the end of the cntbt.

 Check the last block of the cnt btree for allocations. */

 Randomly don't execute the first algorithm. */

	/*

	 * Start from the entry that lookup found, sequence through all larger

	 * free blocks.  If we're actually pointing at a record smaller than

	 * maxlen, go to the start of this block, and skip all those smaller

	 * than minlen.

	/*

	 * It didn't work.  We COULD be in a case where there's a good record

	 * somewhere, so try again.

/*

 * Allocate a variable extent near bno in the allocation group agno.

 * Extent's length (returned in len) will be between minlen and maxlen,

 * and of the form k * prod + mod unless there's nothing that large.

 * Return the starting a.g. block, or NULLAGBLOCK if we can't do it.

 error code */

 result code, temporary */

 handle uninitialized agbno range so caller doesn't have to */

 clamp agbno to the range if it's outside */

	/*

	 * Set up cursors and see if there are any free extents as big as

	 * maxlen. If not, pick the last entry in the tree unless the tree is

	 * empty.

	/*

	 * First algorithm.

	 * If the requested extent is large wrt the freespaces available

	 * in this a.g., then the cursor will be pointing to a btree entry

	 * near the right edge of the tree.  If it's in the last btree leaf

	 * block, then we just examine all the entries in that block

	 * that are big enough, and pick the best one.

	/*

	 * Second algorithm. Combined cntbt and bnobt search to find ideal

	 * locality.

	/*

	 * If we couldn't get anything, give up.

 fix up btrees on a successful allocation */

/*

 * Allocate a variable extent anywhere in the allocation group agno.

 * Extent's length (returned in len) will be between minlen and maxlen,

 * and of the form k * prod + mod unless there's nothing that large.

 * Return the starting a.g. block, or NULLAGBLOCK if we can't do it.

 error */

 allocation argument structure */

 cursor for bno btree */

 cursor for cnt btree */

 error result */

 start of found freespace */

 length of found freespace */

 temp status variable */

 returned block number */

 length of returned extent */

	/*

	 * Allocate and initialize a cursor for the by-size btree.

	/*

	 * Look for an entry >= maxlen+alignment-1 blocks.

	/*

	 * If none then we have to settle for a smaller extent. In the case that

	 * there are no large extents, this will return the last entry in the

	 * tree unless the tree is empty. In the case that there are only busy

	 * large extents, this will return the largest small extent unless there

	 * are no smaller extents available.

		/*

		 * Search for a non-busy extent that is large enough.

				/*

				 * Our only valid extents must have been busy.

				 * Make it unbusy by forcing the log out and

				 * retrying.

	/*

	 * In the first case above, we got the last entry in the

	 * by-size btree.  Now we check to see if the space hits maxlen

	 * once aligned; if not, we search left for something better.

	 * This can't happen in the second case above.

	/*

	 * Fix up the length.

	/*

	 * Allocate and initialize a cursor for the by-block tree.

/*

 * Free the extent starting at agno/bno for length.

 start of right neighbor */

 length of right neighbor */

 start of left neighbor */

 length of left neighbor */

 new starting block of freesp */

 new length of freespace */

 have a left neighbor */

 have a right neighbor */

	/*

	 * Allocate and initialize a cursor for the by-block btree.

	/*

	 * Look for a neighboring block on the left (lower block numbers)

	 * that is contiguous with this space.

		/*

		 * There is a block to our left.

		/*

		 * It's not contiguous, though.

			/*

			 * If this failure happens the request to free this

			 * space was invalid, it's (partly) already free.

			 * Very bad.

	/*

	 * Look for a neighboring block on the right (higher block numbers)

	 * that is contiguous with this space.

		/*

		 * There is a block to our right.

		/*

		 * It's not contiguous, though.

			/*

			 * If this failure happens the request to free this

			 * space was invalid, it's (partly) already free.

			 * Very bad.

	/*

	 * Now allocate and initialize a cursor for the by-size tree.

	/*

	 * Have both left and right contiguous neighbors.

	 * Merge all three into a single free block.

		/*

		 * Delete the old by-size entry on the left.

		/*

		 * Delete the old by-size entry on the right.

		/*

		 * Delete the old by-block entry for the right block.

		/*

		 * Move the by-block cursor back to the left neighbor.

		/*

		 * Check that this is the right record: delete didn't

		 * mangle the cursor.

		/*

		 * Update remaining by-block entry to the new, joined block.

	/*

	 * Have only a left contiguous neighbor.

	 * Merge it together with the new freespace.

		/*

		 * Delete the old by-size entry on the left.

		/*

		 * Back up the by-block cursor to the left neighbor, and

		 * update its length.

	/*

	 * Have only a right contiguous neighbor.

	 * Merge it together with the new freespace.

		/*

		 * Delete the old by-size entry on the right.

		/*

		 * Update the starting block and length of the right

		 * neighbor in the by-block tree.

	/*

	 * No contiguous neighbors.

	 * Insert the new freespace into the by-block tree.

	/*

	 * In all cases we need to insert the new freespace in the by-size tree.

	/*

	 * Update the freespace totals in the ag and superblock.

/*

 * Visible (exported) allocation/free functions.

 * Some of these are used just by xfs_alloc_btree.c and this file.

/*

 * Compute and fill in value of m_alloc_maxlevels.

 file system mount structure */

/*

 * Find the length of the longest extent in an AG.  The 'need' parameter

 * specifies how much space we're going to need for the AGFL and the

 * 'reserved' parameter tells us how many blocks in this AG are reserved for

 * other callers.

	/*

	 * If the AGFL needs a recharge, we'll have to subtract that from the

	 * longest extent.

	/*

	 * If we cannot maintain others' reservations with space from the

	 * not-longest freesp extents, we'll have to subtract /that/ from

	 * the longest extent too.

	/*

	 * If the longest extent is long enough to satisfy all the

	 * reservations and AGFL rules in place, we can return this extent.

 Otherwise, let the caller try for 1 block if there's space. */

/*

 * Compute the minimum length of the AGFL in the given AG.  If @pag is NULL,

 * return the largest possible minimum length.

 AG btrees have at least 1 level. */

 space needed by-bno freespace btree */

 space needed by-size freespace btree */

 space needed reverse mapping used space btree */

/*

 * Check if the operation we are fixing up the freelist for should go ahead or

 * not. If we are freeing blocks, we always allow it, otherwise the allocation

 * is dependent on whether the size and shape of free space available will

 * permit the requested allocation to take place.

 blocks that are still reserved */

 do we have enough contiguous free space for the allocation? */

	/*

	 * Do we have enough free space remaining for the allocation? Don't

	 * account extra agfl blocks because we are about to defer free them,

	 * making them unavailable until the current transaction commits.

	/*

	 * Clamp maxlen to the amount of free space available for the actual

	 * extent allocation.

/*

 * Check the agfl fields of the agf for inconsistency or corruption. The purpose

 * is to detect an agfl header padding mismatch between current and early v5

 * kernels. This problem manifests as a 1-slot size difference between the

 * on-disk flcount and the active [first, last] range of a wrapped agfl. This

 * may also catch variants of agfl count corruption unrelated to padding. Either

 * way, we'll reset the agfl and warn the user.

 *

 * Return true if a reset is required before the agfl can be used, false

 * otherwise.

 no agfl header on v4 supers */

	/*

	 * The agf read verifier catches severe corruption of these fields.

	 * Repeat some sanity checks to cover a packed -> unpacked mismatch if

	 * the verifier allows it.

	/*

	 * Check consistency between the on-disk count and the active range. An

	 * agfl padding mismatch manifests as an inconsistent flcount.

/*

 * Reset the agfl to an empty state. Ignore/drop any existing blocks since the

 * agfl content cannot be trusted. Warn the user that a repair is required to

 * recover leaked blocks.

 *

 * The purpose of this mechanism is to handle filesystems affected by the agfl

 * header padding mismatch problem. A reset keeps the filesystem online with a

 * relatively minor free space accounting inconsistency rather than suffer the

 * inevitable crash from use of an invalid agfl block.

/*

 * Defer an AGFL block free. This is effectively equivalent to

 * xfs_free_extent_later() with some special handling particular to AGFL blocks.

 *

 * Deferring AGFL frees helps prevent log reservation overruns due to too many

 * allocation operations in a transaction. AGFL frees are prone to this problem

 * because for one they are always freed one at a time. Further, an immediate

 * AGFL block free can cause a btree join and require another block free before

 * the real allocation can proceed. Deferring the free disconnects freeing up

 * the AGFL slot from freeing the block.

 new element */

/*

 * Add the extent to the list of extents to be free at transaction end.

 * The list is maintained sorted (by block number).

 new element */

/*

 * Check if an AGF has a free extent record whose length is equal to

 * args->minlen.

/*

 * Decide whether to use this allocation group for this allocation.

 * If so, fix up the btree freelist's size.

 error */

 allocation argument structure */

 XFS_ALLOC_FLAG_... */

 local allocation arguments */

 freelist block */

 total blocks needed in freelist */

 deferred ops (AGFL block frees) require permanent transactions */

 Couldn't lock the AGF so skip this AG. */

	/*

	 * If this is a metadata preferred pag and we are user data then try

	 * somewhere else if we are not being asked to try harder at this

	 * point

	/*

	 * Get the a.g. freespace buffer.

	 * Can fail if we're not blocking on locks, and it's held.

 Couldn't lock the AGF so skip this AG. */

 reset a padding mismatched agfl before final free space check */

 If there isn't enough total space or single-extent, reject it. */

	/*

	 * Make the freelist shorter if it's too long.

	 *

	 * Note that from this point onwards, we will always release the agf and

	 * agfl buffers on error. This handles the case where we error out and

	 * the buffers are clean or may not have been joined to the transaction

	 * and hence need to be released manually. If they have been joined to

	 * the transaction, then xfs_trans_brelse() will handle them

	 * appropriately based on the recursion count and dirty state of the

	 * buffer.

	 *

	 * XXX (dgc): When we have lots of free space, does this buy us

	 * anything other than extra overhead when we need to put more blocks

	 * back on the free list? Maybe we should only do this when space is

	 * getting low or the AGFL is more than half full?

	 *

	 * The NOSHRINK flag prevents the AGFL from being shrunk if it's too

	 * big; the NORMAP flag prevents AGFL expand/shrink operations from

	 * updating the rmapbt.  Both flags are used in xfs_repair while we're

	 * rebuilding the rmapbt, and neither are used by the kernel.  They're

	 * both required to ensure that rmaps are correctly recorded for the

	 * regenerated AGFL, bnobt, and cntbt.  See repair/phase5.c and

	 * repair/rmap.c in xfsprogs for details.

 struct copy below */

 defer agfl frees */

 Make the freelist longer if it's too short. */

 Allocate as many blocks as possible at once. */

		/*

		 * Stop if we run out.  Won't happen if callers are obeying

		 * the restrictions correctly.  Can happen for free calls

		 * on a completely full ag.

		/*

		 * Put each allocated block on the list.

/*

 * Get a block from the freelist.

 * Returns with the buffer for the block gotten.

	/*

	 * Freelist is empty, give up.

	/*

	 * Read the array of free blocks.

	/*

	 * Get the block number and update the data structures.

/*

 * Log the given fields from the agf structure.

 transaction pointer */

 buffer for a.g. freelist header */

 mask of fields to be logged (XFS_AGF_...) */

 first byte offset */

 last byte offset */

 needed so that we don't log the whole rest of the structure: */

/*

 * Interface for inode allocation to force the pag data to be initialized.

 error */

 file system mount structure */

 transaction pointer */

 allocation group number */

 XFS_ALLOC_FLAGS_... */

/*

 * Put the block on the freelist for the allocation group.

	/*

	 * during growfs operations, the perag is not fully initialised,

	 * so we can't use it for any useful checking. growfs ensures we can't

	 * use it by using uncached buffers that don't have the perag attached

	 * so we can detect and avoid this problem.

/*

 * Read in the allocation group header (free/alloc section).

 error */

 mount point structure */

 transaction pointer */

 allocation group number */

 XFS_BUF_ */

 buffer for the ag freelist header */

/*

 * Read in the allocation group header (free/alloc section).

 error */

 mount point structure */

 transaction pointer */

 allocation group number */

 XFS_ALLOC_FLAG_... */

 buffer for the ag freelist header */

 ag freelist header */

 per allocation group data */

 We don't support trylock when freeing. */

		/*

		 * Update the in-core allocbt counter. Filter out the rmapbt

		 * subset of the btreeblks counter because the rmapbt is managed

		 * by perag reservation. Subtract one for the rmapbt root block

		 * because the rmap counter includes it while the btreeblks

		 * counter only tracks non-root blocks.

/*

 * Allocate an extent (variable-size).

 * Depending on the allocation type, we either look in a single allocation

 * group or loop over the allocation groups to find the result.

 error */

 allocation argument structure */

 allocation group size */

 XFS_ALLOC_FLAG_... locking flags */

 mount structure pointer */

 starting allocation group number */

 input allocation type */

 inode32 agf stepper */

	/*

	 * Just fix this up, for the case where the last a.g. is shorter

	 * (or there's only one a.g.) and the caller couldn't easily figure

	 * that out (xfs_bmap_alloc).

		/*

		 * These three force us into a single a.g.

		/*

		 * Try near allocation first, then anywhere-in-ag after

		 * the first a.g. fails.

		/*

		 * Rotate through the allocation groups looking for a winner.

			/*

			 * Start with allocation group given by bno.

			/*

			 * Start with the given allocation group.

		/*

		 * Loop over allocation groups twice; first time with

		 * trylock set, second time without.

			/*

			 * If we get a buffer back then the allocation will fly.

			/*

			 * Didn't work, figure out the next iteration.

			/*

			* For the first allocation, we can try any AG to get

			* space.  However, if we already have allocated a

			* block, we don't want to try AGs whose number is below

			* sagno. Otherwise, we may end up with out-of-order

			* locking of AGF, which might cause deadlock.

			/*

			 * Reached the starting a.g., must either be done

			 * or switch to non-trylock mode.

 NOTREACHED */

 Ensure that the freelist is at full capacity. */

	/*

	 * validate that the block number is legal - the enables us to detect

	 * and handle a silent filesystem corruption rather than crashing.

/*

 * Free an extent.

 * Just break up the extent address and hand off to xfs_free_ag_extent

 * after fixing up the freelist.

 validate the extent size is legal now we have the agf locked */

 Format btree record and pass to our callback. */

 Find all free space within a given range of blocks. */

 Find all free space records. */

 Is there a record covering a given extent? */

/*

 * Walk all the blocks in the AGFL.  The @walk_fn can return any negative

 * error code or XFS_ITER_*.

 Nothing to walk in an empty AGFL. */

 Otherwise, walk from first to last, wrapping as needed. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2000-2006 Silicon Graphics, Inc.

 * Copyright (c) 2013 Red Hat, Inc.

 * All Rights Reserved.

 basic block units */

/*

 * Do some primitive error checking on ondisk dquot data structures.

 *

 * The xfs_dqblk structure /contains/ the xfs_disk_dquot structure;

 * we verify them separately because at some points we have only the

 * smaller xfs_disk_dquot structure available.

 used only during quotacheck */

	/*

	 * We can encounter an uninitialized dquot buffer for 2 reasons:

	 * 1. If we crash while deleting the quotainode(s), and those blks got

	 *    used for user data. This is because we take the path of regular

	 *    file deletion; however, the size field of quotainodes is never

	 *    updated, so all the tricks that we play in itruncate_finish

	 *    don't quite matter.

	 *

	 * 2. We don't play the quota buffers when there's a quotaoff logitem.

	 *    But the allocation will be replayed so we'll end up with an

	 *    uninitialized quota block.

	 *

	 * This is all fine; things are still consistent, and we haven't lost

	 * any quota information. Just don't complain about bad dquot blks.

 used only during quotacheck */

/*

 * Do some primitive error checking on ondisk dquot data structures.

	/*

	 * Typically, a repair is only requested by quotacheck.

	/*

	 * if we are in log recovery, the quota subsystem has not been

	 * initialised so we have no quotainfo structure. In that case, we need

	 * to manually calculate the number of dquots in the buffer.

	/*

	 * if we are in log recovery, the quota subsystem has not been

	 * initialised so we have no quotainfo structure. In that case, we need

	 * to manually calculate the number of dquots in the buffer.

	/*

	 * On the first read of the buffer, verify that each dquot is valid.

	 * We don't know what the id of the dquot is supposed to be, just that

	 * they should be increasing monotonically within the buffer. If the

	 * first id is corrupt, then it will fail on the second dquot in the

	 * buffer so corruptions could point to the wrong dquot in this case.

/*

 * readahead errors are silent and simply leave the buffer as !done so a real

 * read will then be run with the xfs_dquot_buf_ops verifier. See

 * xfs_inode_buf_verify() for why we use EIO and ~XBF_DONE here rather than

 * reporting the failure.

/*

 * we don't calculate the CRC here as that is done when the dquot is flushed to

 * the buffer after the update is done. This ensures that the dquot in the

 * buffer always has an up-to-date CRC value.

 Convert an on-disk timer value into an incore timer value. */

 Convert an incore timer value into an on-disk timer value. */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright (C) 2016 Oracle.  All Rights Reserved.

 * Author: Darrick J. Wong <darrick.wong@oracle.com>

/*

 * Per-AG Block Reservations

 *

 * For some kinds of allocation group metadata structures, it is advantageous

 * to reserve a small number of blocks in each AG so that future expansions of

 * that data structure do not encounter ENOSPC because errors during a btree

 * split cause the filesystem to go offline.

 *

 * Prior to the introduction of reflink, this wasn't an issue because the free

 * space btrees maintain a reserve of space (the AGFL) to handle any expansion

 * that may be necessary; and allocations of other metadata (inodes, BMBT,

 * dir/attr) aren't restricted to a single AG.  However, with reflink it is

 * possible to allocate all the space in an AG, have subsequent reflink/CoW

 * activity expand the refcount btree, and discover that there's no space left

 * to handle that expansion.  Since we can calculate the maximum size of the

 * refcount btree, we can reserve space for it and avoid ENOSPC.

 *

 * Handling per-AG reservations consists of three changes to the allocator's

 * behavior:  First, because these reservations are always needed, we decrease

 * the ag_max_usable counter to reflect the size of the AG after the reserved

 * blocks are taken.  Second, the reservations must be reflected in the

 * fdblocks count to maintain proper accounting.  Third, each AG must maintain

 * its own reserved block counter so that we can calculate the amount of space

 * that must remain free to maintain the reservations.  Fourth, the "remaining

 * reserved blocks" count must be used when calculating the length of the

 * longest free extent in an AG and to clamp maxlen in the per-AG allocation

 * functions.  In other words, we maintain a virtual allocation via in-core

 * accounting tricks so that we don't have to clean up after a crash. :)

 *

 * Reserved blocks can be managed by passing one of the enum xfs_ag_resv_type

 * values via struct xfs_alloc_arg or directly to the xfs_free_extent

 * function.  It might seem a little funny to maintain a reservoir of blocks

 * to feed another reservoir, but the AGFL only holds enough blocks to get

 * through the next transaction.  The per-AG reservation is to ensure (we

 * hope) that each AG never runs out of blocks.  Each data structure wanting

 * to use the reservation system should update ask/used in xfs_ag_resv_init.

/*

 * Are we critically low on blocks?  For now we'll define that as the number

 * of blocks we can get our hands on being less than 10% of what we reserved

 * or less than some arbitrary number (maximum btree height).

 Critically low if less than 10% or max btree height remains. */

/*

 * How many blocks are reserved but not used, and therefore must not be

 * allocated away?

 empty */

 Clean out a reservation */

	/*

	 * RMAPBT blocks come from the AGFL and AGFL blocks are always

	 * considered "free", so whatever was reserved at mount time must be

	 * given back at umount.

 Free a per-AG reservation. */

		/*

		 * Space taken by the rmapbt is not subtracted from fdblocks

		 * because the rmapbt lives in the free space.  Here we must

		 * subtract the entire reservation from fdblocks so that we

		 * always have blocks available for rmapbt expansion.

		/*

		 * Space taken by all other metadata btrees are accounted

		 * on-disk as used space.  We therefore only hide the space

		 * that is reserved but not used by the trees.

	/*

	 * Reduce the maximum per-AG allocation length by however much we're

	 * trying to reserve for an AG.  Since this is a filesystem-wide

	 * counter, we only make the adjustment for AG 0.  This assumes that

	 * there aren't any AGs hungrier for per-AG reservation than AG 0.

 Create a per-AG block reservation. */

 Create the metadata reservation. */

			/*

			 * Because we didn't have per-AG reservations when the

			 * finobt feature was added we might not be able to

			 * reserve all needed blocks.  Warn and fall back to the

			 * old and potentially buggy code in that case, but

			 * ensure we do have the reservation for the refcountbt.

 Create the RMAPBT metadata reservation */

	/*

	 * Initialize the pagf if we have at least one active reservation on the

	 * AG. This may have occurred already via reservation calculation, but

	 * fall back to an explicit init to ensure the in-core allocbt usage

	 * counters are initialized as soon as possible. This is important

	 * because filesystems with large perag reservations are susceptible to

	 * free space reservation problems that the allocbt counter is used to

	 * address.

		/*

		 * If there isn't enough space in the AG to satisfy the

		 * reservation, let the caller know that there wasn't enough

		 * space.  Callers are responsible for deciding what to do

		 * next, since (in theory) we can stumble along with

		 * insufficient reservation if data blocks are being freed to

		 * replenish the AG's free space.

 Allocate a block from the reservation. */

 Allocations of reserved blocks only need on-disk sb updates... */

 ...but non-reserved blocks need in-core and on-disk updates. */

 Free a block to the reservation. */

 Freeing into the reserved pool only requires on-disk update... */

 ...but freeing beyond that requires in-core and on-disk update. */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright (C) 2016 Oracle.  All Rights Reserved.

 * Author: Darrick J. Wong <darrick.wong@oracle.com>

 Allowable refcount adjustment amounts. */

/*

 * Look up the first record less than or equal to [bno, len] in the btree

 * given by cur.

/*

 * Look up the first record greater than or equal to [bno, len] in the btree

 * given by cur.

/*

 * Look up the first record equal to [bno, len] in the btree

 * given by cur.

 Convert on-disk record to in-core format. */

/*

 * Get the data from the pointed-to record.

 handle special COW-staging state */

 check for valid extent range, including overflow */

/*

 * Update the record referred to by cur to the value given

 * by [bno, len, refcount].

 * This either works (return 0) or gets an EFSCORRUPTED error.

/*

 * Insert the record referred to by cur to the value given

 * by [bno, len, refcount].

 * This either works (return 0) or gets an EFSCORRUPTED error.

/*

 * Remove the record referred to by cur, then set the pointer to the spot

 * where the record could be re-inserted, in case we want to increment or

 * decrement the cursor.

 * This either works (return 0) or gets an EFSCORRUPTED error.

/*

 * Adjusting the Reference Count

 *

 * As stated elsewhere, the reference count btree (refcbt) stores

 * >1 reference counts for extents of physical blocks.  In this

 * operation, we're either raising or lowering the reference count of

 * some subrange stored in the tree:

 *

 *      <------ adjustment range ------>

 * ----+   +---+-----+ +--+--------+---------

 *  2  |   | 3 |  4  | |17|   55   |   10

 * ----+   +---+-----+ +--+--------+---------

 * X axis is physical blocks number;

 * reference counts are the numbers inside the rectangles

 *

 * The first thing we need to do is to ensure that there are no

 * refcount extents crossing either boundary of the range to be

 * adjusted.  For any extent that does cross a boundary, split it into

 * two extents so that we can increment the refcount of one of the

 * pieces later:

 *

 *      <------ adjustment range ------>

 * ----+   +---+-----+ +--+--------+----+----

 *  2  |   | 3 |  2  | |17|   55   | 10 | 10

 * ----+   +---+-----+ +--+--------+----+----

 *

 * For this next step, let's assume that all the physical blocks in

 * the adjustment range are mapped to a file and are therefore in use

 * at least once.  Therefore, we can infer that any gap in the

 * refcount tree within the adjustment range represents a physical

 * extent with refcount == 1:

 *

 *      <------ adjustment range ------>

 * ----+---+---+-----+-+--+--------+----+----

 *  2  |"1"| 3 |  2  |1|17|   55   | 10 | 10

 * ----+---+---+-----+-+--+--------+----+----

 *      ^

 *

 * For each extent that falls within the interval range, figure out

 * which extent is to the left or the right of that extent.  Now we

 * have a left, current, and right extent.  If the new reference count

 * of the center extent enables us to merge left, center, and right

 * into one record covering all three, do so.  If the center extent is

 * at the left end of the range, abuts the left extent, and its new

 * reference count matches the left extent's record, then merge them.

 * If the center extent is at the right end of the range, abuts the

 * right extent, and the reference counts match, merge those.  In the

 * example, we can left merge (assuming an increment operation):

 *

 *      <------ adjustment range ------>

 * --------+---+-----+-+--+--------+----+----

 *    2    | 3 |  2  |1|17|   55   | 10 | 10

 * --------+---+-----+-+--+--------+----+----

 *          ^

 *

 * For all other extents within the range, adjust the reference count

 * or delete it if the refcount falls below 2.  If we were

 * incrementing, the end result looks like this:

 *

 *      <------ adjustment range ------>

 * --------+---+-----+-+--+--------+----+----

 *    2    | 4 |  3  |2|18|   56   | 11 | 10

 * --------+---+-----+-+--+--------+----+----

 *

 * The result of a decrement operation looks as such:

 *

 *      <------ adjustment range ------>

 * ----+   +---+       +--+--------+----+----

 *  2  |   | 2 |       |16|   54   |  9 | 10

 * ----+   +---+       +--+--------+----+----

 *      DDDD    111111DD

 *

 * The blocks marked "D" are freed; the blocks marked "1" are only

 * referenced once and therefore the record is removed from the

 * refcount btree.

 Next block after this extent. */

/*

 * Split a refcount extent that crosses agbno.

 Establish the right extent. */

 Insert the left extent. */

/*

 * Merge the left, center, and right extents.

	/*

	 * Make sure the center and right extents are not in the btree.

	 * If the center extent was synthesized, the first delete call

	 * removes the right extent and we skip the second deletion.

	 * If center and right were in the btree, then the first delete

	 * call removes the center and the second one removes the right

	 * extent.

 Enlarge the left extent. */

/*

 * Merge with the left extent.

 If the extent at agbno (cleft) wasn't synthesized, remove it. */

 Enlarge the left extent. */

/*

 * Merge with the right extent.

	/*

	 * If the extent ending at agbno+aglen (cright) wasn't synthesized,

	 * remove it.

 Enlarge the right extent. */

/*

 * Find the left extent and the one after it (cleft).  This function assumes

 * that we've already split any extent crossing agbno.

 We have a left extent; retrieve (or invent) the next right one */

 if tmp starts at the end of our range, just use that */

			/*

			 * There's a gap in the refcntbt at the start of the

			 * range we're interested in (refcount == 1) so

			 * synthesize the implied extent and pass it back.

			 * We assume here that the agbno/aglen range was

			 * passed in from a data fork extent mapping and

			 * therefore is allocated to exactly one owner.

		/*

		 * No extents, so pretend that there's one covering the whole

		 * range.

/*

 * Find the right extent and the one before it (cright).  This function

 * assumes that we've already split any extents crossing agbno + aglen.

 We have a right extent; retrieve (or invent) the next left one */

 if tmp ends at the end of our range, just use that */

			/*

			 * There's a gap in the refcntbt at the end of the

			 * range we're interested in (refcount == 1) so

			 * create the implied extent and pass it back.

			 * We assume here that the agbno/aglen range was

			 * passed in from a data fork extent mapping and

			 * therefore is allocated to exactly one owner.

		/*

		 * No extents, so pretend that there's one covering the whole

		 * range.

 Is this extent valid? */

/*

 * Try to merge with any extents on the boundaries of the adjustment range.

	/*

	 * Find the extent just below agbno [left], just above agbno [cleft],

	 * just below (agbno + aglen) [cright], and just above (agbno + aglen)

	 * [right].

 No left or right extent to merge; exit. */

 Try to merge left, cleft, and right.  cleft must == cright. */

 Try to merge left and cleft. */

		/*

		 * If we just merged left + cleft and cleft == cright,

		 * we no longer have a cright to merge with right.  We're done.

 Try to merge cright and right. */

/*

 * XXX: This is a pretty hand-wavy estimate.  The penalty for guessing

 * true incorrectly is a shutdown FS; the penalty for guessing false

 * incorrectly is more transaction rolls than might be necessary.

 * Be conservative here.

	/*

	 * Only allow 2 refcount extent updates per transaction if the

	 * refcount continue update "error" has been injected.

/*

 * Adjust the refcounts of middle extents.  At this point we should have

 * split extents that crossed the adjustment range; merged with adjacent

 * extents; and updated agbno/aglen to reflect the merges.  Therefore,

 * all we have to do is update the extents inside [agbno, agbno + aglen].

 Merging did all the work already. */

		/*

		 * Deal with a hole in the refcount tree; if a file maps to

		 * these blocks and there's no refcountbt record, pretend that

		 * there is one with refcount == 1.

			/*

			 * Either cover the hole (increment) or

			 * delete the range (decrement).

 Stop if there's nothing left to modify */

		/*

		 * Adjust the reference count and either update the tree

		 * (incr) or free the blocks (decr).

 Adjust the reference count of a range of AG blocks. */

	/*

	 * Ensure that no rcextents cross the boundary of the adjustment range.

	/*

	 * Try to merge with the left or right extents of the range.

 Now that we've taken care of the ends, adjust the middle extents */

 Clean up after calling xfs_refcount_finish_one. */

/*

 * Process one of the deferred refcount operations.  We pass back the

 * btree cursor to maintain our lock on the btree between calls.

 * This saves time and eliminates a buffer deadlock between the

 * superblock and the AGF because we'll always grab them in the same

 * order.

	/*

	 * If we haven't gotten a cursor or the cursor AG doesn't match

	 * the startblock, get one now.

/*

 * Record a refcount intent for later processing.

/*

 * Increase the reference count of the blocks backing a file's extent.

/*

 * Decrease the reference count of the blocks backing a file's extent.

/*

 * Given an AG extent, find the lowest-numbered run of shared blocks

 * within that range and return the range in fbno/flen.  If

 * find_end_of_shared is set, return the longest contiguous extent of

 * shared blocks; if not, just return the first extent we find.  If no

 * shared blocks are found, fbno and flen will be set to NULLAGBLOCK

 * and 0, respectively.

 By default, skip the whole range */

 Try to find a refcount extent that crosses the start */

 No left extent, look at the next one */

 If the extent ends before the start, look at the next one */

 If the extent starts after the range we want, bail out */

 We found the start of a shared extent! */

 Otherwise, find the end of this shared extent */

/*

 * Recovering CoW Blocks After a Crash

 *

 * Due to the way that the copy on write mechanism works, there's a window of

 * opportunity in which we can lose track of allocated blocks during a crash.

 * Because CoW uses delayed allocation in the in-core CoW fork, writeback

 * causes blocks to be allocated and stored in the CoW fork.  The blocks are

 * no longer in the free space btree but are not otherwise recorded anywhere

 * until the write completes and the blocks are mapped into the file.  A crash

 * in between allocation and remapping results in the replacement blocks being

 * lost.  This situation is exacerbated by the CoW extent size hint because

 * allocations can hang around for long time.

 *

 * However, there is a place where we can record these allocations before they

 * become mappings -- the reference count btree.  The btree does not record

 * extents with refcount == 1, so we can record allocations with a refcount of

 * 1.  Blocks being used for CoW writeout cannot be shared, so there should be

 * no conflict with shared block records.  These mappings should be created

 * when we allocate blocks to the CoW fork and deleted when they're removed

 * from the CoW fork.

 *

 * Minor nit: records for in-progress CoW allocations and records for shared

 * extents must never be merged, to preserve the property that (except for CoW

 * allocations) there are no refcount btree entries with refcount == 1.  The

 * only time this could potentially happen is when unsharing a block that's

 * adjacent to CoW allocations, so we must be careful to avoid this.

 *

 * At mount time we recover lost CoW allocations by searching the refcount

 * btree for these refcount == 1 mappings.  These represent CoW allocations

 * that were in progress at the time the filesystem went down, so we can free

 * them to get the space back.

 *

 * This mechanism is superior to creating EFIs for unmapped CoW extents for

 * several reasons -- first, EFIs pin the tail of the log and would have to be

 * periodically relogged to avoid filling up the log.  Second, CoW completions

 * will have to file an EFD and create new EFIs for whatever remains in the

 * CoW fork; this partially takes care of (1) but extent-size reservations

 * will have to periodically relog even if there's no writeout in progress.

 * This can happen if the CoW extent size hint is set, which you really want.

 * Third, EFIs cannot currently be automatically relogged into newer

 * transactions to advance the log tail.  Fourth, stuffing the log full of

 * EFIs places an upper bound on the number of CoW allocations that can be

 * held filesystem-wide at any given time.  Recording them in the refcount

 * btree doesn't require us to maintain any state in memory and doesn't pin

 * the log.

/*

 * Adjust the refcounts of CoW allocations.  These allocations are "magic"

 * in that they're not referenced anywhere else in the filesystem, so we

 * stash them in the refcount btree with a refcount of 1 until either file

 * remapping (or CoW cancellation) happens.

 Find any overlapping refcount records */

 Adding a CoW reservation, there should be nothing here. */

 Removing a CoW reservation, there should be one extent. */

/*

 * Add or remove refcount btree entries for CoW reservations.

	/*

	 * Ensure that no rcextents cross the boundary of the adjustment range.

	/*

	 * Try to merge with the left or right extents of the range.

 Now that we've taken care of the ends, adjust the middle extents */

/*

 * Record a CoW allocation in the refcount btree.

 Add refcount btree reservation */

/*

 * Remove a CoW allocation from the refcount btree.

 Remove refcount btree reservation */

 Record a CoW staging extent in the refcount btree. */

 Add rmap entry */

 Forget a CoW staging event in the refcount btree. */

 Remove rmap entry */

 Stuff an extent on the recovery list. */

 Find and remove leftover CoW reservations. */

	/*

	 * In this first part, we use an empty transaction to gather up

	 * all the leftover CoW extents so that we can subsequently

	 * delete them.  The empty transaction is used to avoid

	 * a buffer lock deadlock if there happens to be a loop in the

	 * refcountbt because we're allowed to re-grab a buffer that is

	 * already attached to our transaction.  When we're done

	 * recording the CoW debris we cancel the (empty) transaction

	 * and everything goes away cleanly.

 Find all the leftover CoW staging extents. */

 Now iterate the list to free the leftovers */

 Set up transaction. */

 Free the orphan record */

 Free the block. */

 Free the leftover list */

 Is there a record covering a given extent? */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2000-2001,2005 Silicon Graphics, Inc.

 * All Rights Reserved.

 level change */

 level change */

 Update the inode btree block counter for this btree. */

 block allocation args */

 error return value */

 ir_holemask/ir_count not supported on-disk */

/*

 * initial value of ptr for lookup

	/*

	 * During growfs operations, we can't verify the exact owner as the

	 * perag is not fully initialised and hence not attached to the buffer.

	 *

	 * Similarly, during log recovery we will have a perag structure

	 * attached, but the agi information will not yet have been initialised

	 * from the on disk AGI. We don't currently use any of this information,

	 * but beware of the landmine (i.e. need to check pag->pagi_init) if we

	 * ever do.

 level verification */

/*

 * Initialize a new inode btree cursor.

 file system mount point */

 transaction pointer */

 ialloc or free ino btree */

 take a reference for the cursor */

 Create an inode btree cursor. */

 Create an inode btree cursor with a fake root for staging. */

/*

 * Install a new inobt btree root.  Caller is responsible for invalidating

 * and freeing the old btree blocks.

 Calculate number of records in an inode btree block. */

/*

 * Calculate number of records in an inobt btree block.

/*

 * Maximum number of inode btree records per AG.  Pretend that we can fill an

 * entire AG completely full of inodes except for the AG headers.

 Compute the max possible height for the inode btree. */

 Compute the max possible height for the free inode btree. */

 Compute the max possible height for either inode btree. */

/*

 * Convert the inode record holemask to an inode allocation bitmap. The inode

 * allocation bitmap is inode granularity and specifies whether an inode is

 * physically allocated on disk (not whether the inode is considered allocated

 * or free by the fs).

 *

 * A bit value of 1 means the inode is allocated, a value of 0 means it is free.

	/*

	 * The holemask has 16-bits for a 64 inode record. Therefore each

	 * holemask bit represents multiple inodes. Create a mask of bits to set

	 * in the allocmask for each holemask bit.

	/*

	 * Allocated inodes are represented by 0 bits in holemask. Invert the 0

	 * bits to 1 and convert to a uint so we can use xfs_next_bit(). Mask

	 * anything beyond the 16 holemask bits since this casts to a larger

	 * type.

	/*

	 * allocbitmap is the inverted holemask so every set bit represents

	 * allocated inodes. To expand from 16-bit holemask granularity to

	 * 64-bit (e.g., bit-per-inode), set inodespbit bits in the target

	 * bitmap for every holemask bit.

/*

 * Verify that an in-core inode record has a valid inode count.

 DEBUG */

 Bail out if we're uninitialized, which can happen in mkfs. */

	/*

	 * The log is permanently allocated, so the space it occupies will

	 * never be available for the kinds of things that would require btree

	 * expansion.  We therefore can pretend the space isn't there.

 Read AGI and create inobt cursor. */

 Read finobt block count from AGI header. */

/*

 * Figure out how many blocks to reserve and how many are used by this btree.

 Calculate the inobt btree size for some records. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2000-2002,2005 Silicon Graphics, Inc.

 * Copyright (C) 2017 Oracle.

 * All Rights Reserved.

 Find the size of the AG, in blocks. */

/*

 * Verify that an AG block number pointer neither points outside the AG

 * nor points at static metadata.

/*

 * Verify that an FS block number pointer neither points outside the

 * filesystem nor points at static AG metadata.

/*

 * Verify that a data device extent is fully contained inside the filesystem,

 * does not cross an AG boundary, and does not point at static metadata.

 Calculate the first and last possible inode number in an AG. */

	/*

	 * Calculate the first inode, which will be in the first

	 * cluster-aligned block after the AGFL.

	/*

	 * Calculate the last inode, which will be at the end of the

	 * last (aligned) cluster that can be allocated in the AG.

/*

 * Verify that an AG inode number pointer neither points outside the AG

 * nor points at static metadata.

/*

 * Verify that an AG inode number pointer neither points outside the AG

 * nor points at static metadata, or is NULLAGINO.

/*

 * Verify that an FS inode number pointer neither points outside the

 * filesystem nor points at static AG metadata.

 Is this an internal inode number? */

/*

 * Verify that a directory entry's inode number doesn't point at an internal

 * inode, empty space, or static AG metadata.

/*

 * Verify that an realtime block number pointer doesn't point off the

 * end of the realtime device.

 Verify that a realtime device extent is fully contained inside the volume. */

 Calculate the range of valid icount values. */

 root, rtbitmap, rtsum all live in the first chunk */

 Sanity-checking of inode counts. */

 Sanity-checking of dir/attr block offsets. */

 Check that a file block offset does not exceed the maximum. */

 Check that a range of file block offsets do not exceed the maximum. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2000-2005 Silicon Graphics, Inc.

 * All Rights Reserved.

/*

 * Physical superblock buffer manipulations. Shared with libxfs in userspace.

/*

 * We support all XFS versions newer than a v4 superblock with V2 directories.

 all v5 filesystems are supported */

 versions prior to v4 are not supported */

 V4 filesystems need v2 directories and unwritten extents */

 And must not have any unknown v4 feature bits set */

 It's a supported v4 filesystem */

 optional V4 features */

 Always on V5 features */

 Optional V5 features */

 Check all the superblock fields we care about when reading one in. */

	/*

	 * Version 5 superblock feature mask validation. Reject combinations

	 * the kernel cannot support up front before checking anything else.

 Check all the superblock fields we care about when writing one out. */

	/*

	 * Carry out additional sb summary counter sanity checks when we write

	 * the superblock.  We skip this in the read validator because there

	 * could be newer superblocks in the log and if the values are garbage

	 * even after replay we'll recalculate them at the end of log mount.

	 *

	 * mkfs has traditionally written zeroed counters to inprogress and

	 * secondary superblocks, so allow this usage to continue because

	 * we never read counters from such superblocks.

	/*

	 * Version 5 superblock feature mask validation. Reject combinations

	 * the kernel cannot support since we checked for unsupported bits in

	 * the read verifier, which means that memory is corrupt.

	/*

	 * We can't read verify the sb LSN because the read verifier is called

	 * before the log is allocated and processed. We know the log is set up

	 * before write verifier calls, so check it here.

 Check the validity of the SB. */

	/*

	 * Validate feature flags and state

 V5 has a separate project quota inode */

		/*

		 * Full inode chunks must be aligned to inode chunk size when

		 * sparse inodes are enabled to support the sparse chunk

		 * allocation algorithm and prevent overlapping inode records.

 Compute agcount for this number of dblocks and agblocks */

	/*

	 * More sanity checking.  Most of these were stolen directly from

	 * xfs_repair.

 zero sb_imax_pct is valid */)	||

 Validate the realtime geometry; stolen from xfs_repair */

	/*

	 * Either (sb_unit and !hasdalign) or (!sb_unit and hasdalign)

	 * would imply the image is corrupted.

	/*

	 * Currently only very few inode sizes are supported.

	/*

	 * older mkfs doesn't initialize quota inodes to NULLFSINO. This

	 * leads to in-core values having two different values for a quota

	 * inode to be invalid: 0 and NULLFSINO. Change it to a single value

	 * NULLFSINO.

	 *

	 * Note that this change affect only the in-core values. These

	 * values are not written back to disk unless any quota information

	 * is written to the disk. Even in that case, sb_pquotino field is

	 * not written to disk unless the superblock supports pquotino.

	/*

	 * We need to do these manipilations only if we are working

	 * with an older version of on-disk superblock.

		/*

		 * In older version of superblock, on-disk superblock only

		 * has sb_gquotino, and in-core superblock has both sb_gquotino

		 * and sb_pquotino. But, only one of them is supported at any

		 * point of time. So, if PQUOTA is set in disk superblock,

		 * copy over sb_gquotino to sb_pquotino.  The NULLFSINO test

		 * above is to make sure we don't do this twice and wipe them

		 * both out!

 crc is only used on disk, not in memory; just init to 0 here. */

	/*

	 * sb_meta_uuid is only on disk if it differs from sb_uuid and the

	 * feature flag is set; if not set we keep it only in memory.

 Convert on-disk flags to in-memory flags? */

	/*

	 * The in-memory superblock quota state matches the v5 on-disk format so

	 * just write them out and return

	/*

	 * For older superblocks (v4), the in-core version of sb_qflags do not

	 * have XFS_OQUOTA_* flags, whereas the on-disk version does.  So,

	 * convert incore XFS_{PG}QUOTA_* flags to on-disk XFS_OQUOTA_* flags.

	/*

	 * GQUOTINO and PQUOTINO cannot be used together in versions

	 * of superblock that do not have pquotino. from->sb_flags

	 * tells us which quota is active and should be copied to

	 * disk. If neither are active, we should NULL the inode.

	 *

	 * In all cases, the separate pquotino must remain 0 because it

	 * is beyond the "end" of the valid non-pquotino superblock.

		/*

		 * We can't rely on just the fields being logged to tell us

		 * that it is safe to write NULLFSINO - we should only do that

		 * if quotas are not actually enabled. Hence only write

		 * NULLFSINO if both in-core quota inodes are NULL.

	/*

	 * We need to ensure that bad_features2 always matches features2.

	 * Hence we enforce that here rather than having to remember to do it

	 * everywhere else that updates features2.

/*

 * If the superblock has the CRC feature bit set or the CRC field is non-null,

 * check that the CRC is valid.  We check the CRC field is non-null because a

 * single bit error could clear the feature bit and unused parts of the

 * superblock are supposed to be zero. Hence a non-null crc field indicates that

 * we've potentially lost a feature bit and we should check it anyway.

 *

 * However, past bugs (i.e. in growfs) left non-zeroed regions beyond the

 * last field in V4 secondary superblocks.  So for secondary superblocks,

 * we are more forgiving, and ignore CRC failures if the primary doesn't

 * indicate that the fs version is V5.

	/*

	 * open code the version check to avoid needing to convert the entire

	 * superblock from disk order just to check the version number

 Only fail bad secondaries on a known V5 filesystem */

	/*

	 * Check all the superblock fields.  Don't byteswap the xquota flags

	 * because _verify_common checks the on-disk values.

/*

 * We may be probed for a filesystem match, so we may not want to emit

 * messages when the superblock buffer is not actually an XFS superblock.

 * If we find an XFS superblock, then run a normal, noisy mount because we are

 * really going to mount it and want to know about errors.

 XFS filesystem, verify noisily! */

 quietly fail */

	/*

	 * Check all the superblock fields.  Don't byteswap the xquota flags

	 * because _verify_common checks the on-disk values.

/*

 * xfs_mount_common

 *

 * Mount initialization code establishing various mount

 * fields from the superblock associated with the given

 * mount structure.

 *

 * Inode geometry are calculated in xfs_ialloc_setup_geometry.

/*

 * xfs_log_sb() can be used to copy arbitrary changes to the in-core superblock

 * into the superblock buffer to be logged.  It does not provide the higher

 * level of locking that is needed to protect the in-core superblock from

 * concurrent access.

	/*

	 * Lazy sb counters don't update the in-core superblock so do that now.

	 * If this is at unmount, the counters will be exactly correct, but at

	 * any other time they will only be ballpark correct because of

	 * reservations that have been taken out percpu counters. If we have an

	 * unclean shutdown, this will be corrected by log recovery rebuilding

	 * the counters from the AGF block counts.

/*

 * xfs_sync_sb

 *

 * Sync the superblock to disk.

 *

 * Note that the caller is responsible for checking the frozen state of the

 * filesystem. This procedure uses the non-blocking transaction allocator and

 * thus will allow modifications to a frozen fs. This is required because this

 * code can be called during the process of freezing where use of the high-level

 * allocator would deadlock.

/*

 * Update all the secondary superblocks to match the new state of the primary.

 * Because we are completely overwriting all the existing fields in the

 * secondary superblock buffers, there is no need to read them in from disk.

 * Just get a new buffer, stamp it and write it.

 *

 * The sb buffers need to be cached here so that we serialise against other

 * operations that access the secondary superblocks, but we don't want to keep

 * them in memory once it is written so we mark it as a one-shot buffer.

 update secondary superblocks. */

		/*

		 * If we get an error reading or writing alternate superblocks,

		 * continue.  xfs_repair chooses the "best" superblock based

		 * on most matches; if we break early, we'll leave more

		 * superblocks un-updated than updated, and xfs_repair may

		 * pick them over the properly-updated primary.

 don't hold too many buffers at once */

/*

 * Same behavior as xfs_sync_sb, except that it is always synchronous and it

 * also writes the superblock buffer to disk sector 0 immediately.

	/*

	 * write out the sb buffer to get the changes to disk

 Read a secondary superblock. */

 Get an uninitialised secondary superblock buffer. */

/*

 * sunit, swidth, sectorsize(optional with 0) should be all in bytes,

 * so users won't be confused by values in error messages.

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright (C) 2016 Oracle.  All Rights Reserved.

 * Author: Darrick J. Wong <darrick.wong@oracle.com>

 block allocation args */

 error return value */

/*

 * Initialize a new refcount btree cursor.

 take a reference for the cursor */

 Create a btree cursor. */

 Create a btree cursor with a fake root for staging. */

/*

 * Swap in the new btree root.  Once we pass this point the newly rebuilt btree

 * is in place and we have to kill off all the old btree blocks.

 Calculate number of records in a refcount btree block. */

/*

 * Calculate the number of records in a refcount btree block.

 Compute the max possible height of the maximally sized refcount btree. */

 Compute the maximum height of a refcount btree. */

 Calculate the refcount btree size for some records. */

/*

 * Calculate the maximum refcount btree size.

 Bail out if we're uninitialized, which can happen in mkfs. */

/*

 * Figure out how many blocks to reserve and how many are used by this btree.

	/*

	 * The log is permanently allocated, so the space it occupies will

	 * never be available for the kinds of things that would require btree

	 * expansion.  We therefore can pretend the space isn't there.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2000-2006 Silicon Graphics, Inc.

 * All Rights Reserved.

	/*

	 * If we are using the local fork to store a symlink body we need to

	 * zero-terminate it so that we can pass it back to the VFS directly.

	 * Overallocate the in-memory fork by one for that and add a zero

	 * to terminate it below.

/*

 * The file is in-lined in the on-disk inode.

	/*

	 * If the size is unreasonable, then something

	 * is wrong and we just bail out rather than crash in

	 * kmem_alloc() or memcpy() below.

/*

 * The file consists of a set of extents all of which fit into the on-disk

 * inode.

	/*

	 * If the number of extents is unreasonable, then something is wrong and

	 * we just bail out rather than crash in kmem_alloc() or memcpy() below.

/*

 * The file has too many extents to fit into

 * the inode, so they are in B-tree format.

 * Allocate a buffer for the root of the B-tree

 * and copy the root into it.  The i_extents

 * field will remain NULL until all of the

 * extents are read in (when they are needed).

 REFERENCED */

	/*

	 * blow out if -- fork has less extents than can fit in

	 * fork (fork shouldn't be a btree format), root btree

	 * block has more records than can fit into the fork,

	 * or the number of extents is greater than the number of

	 * blocks.

	/*

	 * Copy and convert from the on-disk structure

	 * to the in-memory structure.

	/*

	 * Initialize the extent count early, as the per-format routines may

	 * depend on it.

	/*

	 * Initialize the extent count early, as the per-format routines may

	 * depend on it.

/*

 * Reallocate the space for if_broot based on the number of records

 * being added or deleted as indicated in rec_diff.  Move the records

 * and pointers in if_broot to fit the new size.  When shrinking this

 * will eliminate holes between the records and pointers created by

 * the caller.  When growing this will create holes to be filled in

 * by the caller.

 *

 * The caller must not request to add more records than would fit in

 * the on-disk inode root.  If the if_broot is currently NULL, then

 * if we are adding records, one will be allocated.  The caller must also

 * not request that the number of records go below zero, although

 * it can go to zero.

 *

 * ip -- the inode whose if_broot area is changing

 * ext_diff -- the change in the number of records, positive or negative,

 *	 requested for the if_broot array.

	/*

	 * Handle the degenerate case quietly.

		/*

		 * If there wasn't any memory allocated before, just

		 * allocate it now and get out.

		/*

		 * If there is already an existing if_broot, then we need

		 * to realloc() it and shift the pointers to their new

		 * location.  The records don't change location because

		 * they are kept butted up against the btree block header.

	/*

	 * rec_diff is less than 0.  In this case, we are shrinking the

	 * if_broot buffer.  It must already exist.  If we go to zero

	 * records, just get rid of the root and clear the status bit.

		/*

		 * First copy over the btree block header.

	/*

	 * Only copy the records and pointers if there are any.

		/*

		 * First copy the records.

		/*

		 * Then copy the pointers.

/*

 * This is called when the amount of space needed for if_data

 * is increased or decreased.  The change in size is indicated by

 * the number of bytes that need to be added or deleted in the

 * byte_diff parameter.

 *

 * If the amount of space needed has decreased below the size of the

 * inline buffer, then switch to using the inline buffer.  Otherwise,

 * use kmem_realloc() or kmem_alloc() to adjust the size of the buffer

 * to what is needed.

 *

 * ip -- the inode whose if_data area is changing

 * byte_diff -- the change in the number of bytes, positive or negative,

 *	 requested for the if_data array.

	/*

	 * For inline data, the underlying buffer must be a multiple of 4 bytes

	 * in size so that it can be logged and stay on word boundaries.

	 * We enforce that here.

/*

 * Convert in-core extents to on-disk form

 *

 * In the case of the data fork, the in-core and on-disk fork sizes can be

 * different due to delayed allocation extents. We only copy on-disk extents

 * here, so callers must always use the physical fork size to determine the

 * size of the buffer passed to this routine.  We will return the size actually

 * used.

/*

 * Each of the following cases stores data into the same region

 * of the on-disk inode, so only one of them can be valid at

 * any given time. While it is possible to have conflicting formats

 * and log flags, e.g. having XFS_ILOG_?DATA set when the fork is

 * in EXTENTS format, this can only happen when the fork has

 * changed formats after being modified but before being flushed.

 * In these cases, the format always takes precedence, because the

 * format indicates the current state of the fork.

	/*

	 * This can happen if we gave up in iformat in an error path,

	 * for the attribute fork.

 Convert bmap state flags to an inode fork. */

/*

 * Initialize an inode's copy-on-write fork.

 Verify the inline contents of the data fork of an inode. */

 Verify the inline contents of the attr fork of an inode. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2000-2005 Silicon Graphics, Inc.

 * Copyright (c) 2013 Red Hat, Inc.

 * All Rights Reserved.

/*

 * xfs_attr_leaf.c

 *

 * Routines to implement leaf blocks of attributes as Btrees of hashed names.

/*========================================================================

 * Function prototypes for the kernel.

/*

 * Routines used for growing the Btree.

/*

 * Utility routines.

/*

 * attr3 block 'firstused' conversion helpers.

 *

 * firstused refers to the offset of the first used byte of the nameval region

 * of an attr leaf block. The region starts at the tail of the block and expands

 * backwards towards the middle. As such, firstused is initialized to the block

 * size for an empty leaf block and is reduced from there.

 *

 * The attr3 block size is pegged to the fsb size and the maximum fsb is 64k.

 * The in-core firstused field is 32-bit and thus supports the maximum fsb size.

 * The on-disk field is only 16-bit, however, and overflows at 64k. Since this

 * only occurs at exactly 64k, we use zero as a magic on-disk value to represent

 * the attr block size. The following helpers manage the conversion between the

 * in-core and on-disk formats.

	/*

	 * Convert from the magic fsb size value to actual blocksize. This

	 * should only occur for empty blocks when the block size overflows

	 * 16-bits.

 magic value should only be seen on disk */

	/*

	 * Scale down the 32-bit in-core firstused value to the 16-bit on-disk

	 * value. This only overflows at the max supported value of 64k. Use the

	 * magic on-disk value to represent block size in this case.

 hash order check */

	/*

	 * Check the name information.  The namelen fields are u8 so we can't

	 * possibly exceed the maximum name length of 255 bytes.

 must be 32bit - see below */

	/*

	 * firstused is the block offset of the first name info structure.

	 * Make sure it doesn't go off the block or crash into the header.

 Make sure the entries array doesn't crash into the name info. */

	/*

	 * NOTE: This verifier historically failed empty leaf buffers because

	 * we expect the fork to be in another format. Empty attr fork format

	 * conversions are possible during xattr set, however, and format

	 * conversion is not atomic with the xattr set that triggers it. We

	 * cannot assume leaf blocks are non-empty until that is addressed.

	/*

	 * Quickly check the freemap information.  Attribute data has to be

	 * aligned to 4-byte boundaries, and likewise for the free space.

	 *

	 * Note that for 64k block size filesystems, the freemap entries cannot

	 * overflow as they are only be16 fields. However, when checking end

	 * pointer of the freemap, we have to be careful to detect overflows and

	 * so use uint32_t for those checks.

 be care of 16 bit overflows here */

/*

 * leaf/node format detection on trees is sketchy, so a node read can be done on

 * leaf level blocks when detection identifies the tree as a node format tree

 * incorrectly. In this case, we need to swap the verifier to match the correct

 * format of the block being read.

/*========================================================================

 * Namespace helper routines

	/*

	 * If we are looking for incomplete entries, show only those, else only

	 * show complete entries.

	/*

	 * No copy if all we have to do is get the length

	/*

	 * No copy if the length of the existing buffer is too small

 remote block xattr requires IO for copy-in */

	/*

	 * This is to prevent a GCC warning because the remote xattr case

	 * doesn't have a value to pass in. In that case, we never reach here,

	 * but GCC can't work that out and so throws a "passing NULL to

	 * memcpy" warning.

/*========================================================================

 * External routines when attribute fork size < XFS_LITINO(mp).

/*

 * Query whether the total requested number of attr fork bytes of extended

 * attribute space will be able to fit inline.

 *

 * Returns zero if not, else the i_forkoff fork offset to be used in the

 * literal area for attribute data once the new bytes have been added.

 *

 * i_forkoff must be 8 byte aligned, hence is stored as a >>3 value;

 * special case for dev/uuid inodes, they have fixed size data forks.

	/*

	 * Check if the new size could fit at all first:

 rounded down */

	/*

	 * If the requested numbers of bytes is smaller or equal to the

	 * current attribute fork size we can always proceed.

	 *

	 * Note that if_bytes in the data fork might actually be larger than

	 * the current data fork size is due to delalloc extents. In that

	 * case either the extent count will go down when they are converted

	 * to real extents, or the delalloc conversion will take care of the

	 * literal area rebalancing.

	/*

	 * For attr2 we can try to move the forkoff if there is space in the

	 * literal area, but for the old format we are done if there is no

	 * space in the fixed attribute fork.

		/*

		 * If there is no attr fork and the data fork is extents,

		 * determine if creating the default attr fork will result

		 * in the extents form migrating to btree. If so, the

		 * minimum offset only needs to be the space required for

		 * the btree root.

		/*

		 * If we have a data btree then keep forkoff if we have one,

		 * otherwise we are adding a new attr, so then we set

		 * minforkoff to where the btree root can finish so we have

		 * plenty of room for attrs

	/*

	 * A data fork btree root must have space for at least

	 * MINDBTPTRS key/ptr pairs if the data fork is small or empty.

 attr fork btree root can have at least this many key/ptr pairs */

 rounded down */

/*

 * Switch on the ATTR2 superblock bit (implies also FEATURES2) unless:

 * - noattr2 mount option is set,

 * - on-disk version bit says it is already set, or

 * - the attr2 mount option is not set to enable automatic upgrade from attr1.

/*

 * Create the initial contents of a shortform attribute list.

/*

 * Return -EEXIST if attr is found, or -ENOATTR if not

 * args:  args containing attribute name and namelen

 * sfep:  If not null, pointer will be set to the last attr entry found on

	  -EEXIST.  On -ENOATTR pointer is left at the last entry in the list

 * basep: If not null, pointer is set to the byte offset of the entry in the

 *	  list on -EEXIST.  On -ENOATTR, pointer is left at the byte offset of

 *	  the last entry in the list

/*

 * Add a name/value pair to the shortform attribute list.

 * Overflow from the inode has already been checked for.

/*

 * After the last attribute is removed revert to original inode format,

 * making all literal area available to the data fork once more.

/*

 * Remove an attribute from the shortform attribute list structure.

	/*

	 * Fix up the attribute fork data, covering the hole

	/*

	 * Fix up the start offset of the attribute fork

/*

 * Look up a name in a shortform attribute list structure.

ARGSUSED*/

/*

 * Retrieve the attribute value and length.

 *

 * If args->valuelen is zero, only the length needs to be returned.  Unlike a

 * lookup, we only return an error if the attribute does not exist or we can't

 * retrieve the value.

/*

 * Convert from using the shortform to the leaf.  On success, return the

 * buffer so that we can keep it locked until we're totally done with it.

 set a->index */

/*

 * Check a leaf attribute block to see if all the entries would fit into

 * a shortform attribute list.

 don't copy partial entries */

 Verify the consistency of an inline attribute fork. */

	/*

	 * Give up if the attribute is way too short.

 Check all reported entries */

		/*

		 * struct xfs_attr_sf_entry has a variable length.

		 * Check the fixed-offset parts of the structure are

		 * within the data buffer.

		 * xfs_attr_sf_entry is defined with a 1-byte variable

		 * array at the end, so we must subtract that off.

 Don't allow names with known bad length. */

		/*

		 * Check that the variable-length part of the structure is

		 * within the data buffer.  The next entry starts after the

		 * name component, so nextentry is an acceptable test.

		/*

		 * Check for unknown flags.  Short form doesn't support

		 * the incomplete or local bits, so we can use the namespace

		 * mask here.

		/*

		 * Check for invalid namespace combinations.  We only allow

		 * one namespace flag per xattr, so we can just count the

		 * bits (i.e. hweight) here.

/*

 * Convert a leaf attribute list to shortform attribute list

 XXX (dgc): buffer is about to be marked stale - why zero it? */

	/*

	 * Clean out the prior contents of the attribute list.

	/*

	 * Copy the attributes

 don't copy partial entries */

/*

 * Convert from using a single leaf to a root node and a leaf.

 copy leaf to new buffer, update identifiers */

	/*

	 * Set up the new root node.

 both on-disk, don't endian-flip twice */

/*========================================================================

 * Routines used for growing the Btree.

/*

 * Create the initial contents of a leaf attribute list

 * or a leaf in a node attribute list.

/*

 * Split the leaf node, rebalance, then add the new entry.

	/*

	 * Allocate space for a new leaf node.

	/*

	 * Rebalance the entries across the two leaves.

	 * NOTE: rebalance() currently depends on the 2nd block being empty.

	/*

	 * Save info on "old" attribute for "atomic rename" ops, leaf_add()

	 * modifies the index/blkno/rmtblk/rmtblkcnt fields to show the

	 * "new" attrs info.  Will need the "old" info to remove it later.

	 *

	 * Insert the "new" entry in the correct block.

	/*

	 * Update last hashval in each block since we added the name.

/*

 * Add a name to the leaf attribute list structure.

	/*

	 * Search through freemap for first-fit on new name length.

	 * (may need to figure in size of entry struct too)

 no space in this map */

	/*

	 * If there are no holes in the address space of the block,

	 * and we don't have enough freespace, then compaction will do us

	 * no good and we should just give up.

	/*

	 * Compact the entries to coalesce free space.

	 * This may change the hdr->count via dropping INCOMPLETE entries.

	/*

	 * After compaction, the block is guaranteed to have only one

	 * free region, in freemap[0].  If it is not big enough, give up.

/*

 * Add a name to a leaf attribute list structure.

	/*

	 * Force open some space in the entry array and fill it in.

	/*

	 * Allocate space for the new string (at the end of the run).

	/*

	 * For "remote" attribute values, simply note that we need to

	 * allocate space for the "remote" value.  We can't actually

	 * allocate the extents in this transaction, and we can't decide

	 * which blocks they should be as we might allocate more blocks

	 * as part of this transaction (a split operation for example).

 just in case */

	/*

	 * Update the control info for this leaf node

/*

 * Garbage collect a leaf attribute list block by copying it to a new buffer.

	/*

	 * Copy the on-disk header back into the destination buffer to ensure

	 * all the information in the header that is not part of the incore

	 * header structure is preserved.

 Initialise the incore headers */

 struct copy */

 write the header back to initialise the underlying buffer */

	/*

	 * Copy all entry's in the same (sorted) order,

	 * but allocate name/value pairs packed and in sequence.

	/*

	 * this logs the entire buffer, but the caller must write the header

	 * back to the buffer when it is finished modifying it.

/*

 * Compare two leaf blocks "order".

 * Return 0 unless leaf2 should go before leaf1.

/*

 * Redistribute the attribute list entries between two leaf nodes,

 * taking into account the size of the new entry.

 *

 * NOTE: if new block is empty, then it will get the upper half of the

 * old block.  At present, all (one) callers pass in an empty second block.

 *

 * This code adjusts the args->index/blkno and args->index2/blkno2 fields

 * to match what it is doing in splitting the attribute leaf block.  Those

 * values are used in "atomic rename" operations on attributes.  Note that

 * the "new" and "old" values can end up in different blocks.

	/*

	 * Set up environment.

	/*

	 * Check ordering of blocks, reverse if it makes things simpler.

	 *

	 * NOTE: Given that all (current) callers pass in an empty

	 * second block, this code should never set "swap".

 swap structures rather than reconverting them */

	/*

	 * Examine entries until we reduce the absolute difference in

	 * byte usage between the two blocks to a minimum.  Then get

	 * the direction to copy and the number of elements to move.

	 *

	 * "inleaf" is true if the new entry should be inserted into blk1.

	 * If "swap" is also true, then reverse the sense of "inleaf".

	/*

	 * Move any entries required from leaf to leaf:

		/*

		 * Figure the total bytes to be added to the destination leaf.

 number entries being moved */

		/*

		 * leaf2 is the destination, compact it if it looks tight.

		/*

		 * Move high entries from leaf1 to low end of leaf2.

		/*

		 * I assert that since all callers pass in an empty

		 * second buffer, this code should never execute.

		/*

		 * Figure the total bytes to be added to the destination leaf.

 number entries being moved */

		/*

		 * leaf1 is the destination, compact it if it looks tight.

		/*

		 * Move low entries from leaf2 to high end of leaf1.

	/*

	 * Copy out last hashval in each block for B-tree code.

	/*

	 * Adjust the expected index for insertion.

	 * NOTE: this code depends on the (current) situation that the

	 * second block was originally empty.

	 *

	 * If the insertion point moved to the 2nd block, we must adjust

	 * the index.  We must also track the entry just following the

	 * new entry for use in an "atomic rename" operation, that entry

	 * is always the "old" entry and the "new" entry is what we are

	 * inserting.  The index/blkno fields refer to the "old" entry,

	 * while the index2/blkno2 fields refer to the "new" entry.

			/*

			 * On a double leaf split, the original attr location

			 * is already stored in blkno2/index2, so don't

			 * overwrite it overwise we corrupt the tree.

				/*

				 * set the new attr location to match the old

				 * one and let the higher level split code

				 * decide where in the leaf to place it.

/*

 * Examine entries until we reduce the absolute difference in

 * byte usage between the two blocks to a minimum.

 * GROT: Is this really necessary?  With other than a 512 byte blocksize,

 * GROT: there will always be enough room in either block for a new entry.

 * GROT: Do a double-split for this case?

	/*

	 * Examine entries until we reduce the absolute difference in

	 * byte usage between the two blocks to a minimum.

		/*

		 * The new entry is in the first block, account for it.

		/*

		 * Wrap around into the second block if necessary.

		/*

		 * Figure out if next leaf entry would be too much.

	/*

	 * Calculate the number of usedbytes that will end up in lower block.

	 * If new entry not in lower block, fix up the count.

/*========================================================================

 * Routines used for shrinking the Btree.

/*

 * Check a leaf block and its neighbors to see if the block should be

 * collapsed into one or the other neighbor.  Always keep the block

 * with the smaller block number.

 * If the current block is over 50% full, don't try to join it, return 0.

 * If the block is empty, fill in the state structure and return 2.

 * If it can be collapsed, fill in the state structure and return 1.

 * If nothing can be done, return 0.

 *

 * GROT: allow for INCOMPLETE entries in calculation.

	/*

	 * Check for the degenerate case of the block being over 50% full.

	 * If so, it's not worth even looking to see if we might be able

	 * to coalesce with a sibling.

 blk over 50%, don't try to join */

	/*

	 * Check for the degenerate case of the block being empty.

	 * If the block is empty, we'll simply delete it, no need to

	 * coalesce it with a sibling block.  We choose (arbitrarily)

	 * to merge with the forward block unless it is NULL.

		/*

		 * Make altpath point to the block we want to keep and

		 * path point to the block we want to drop (this one).

	/*

	 * Examine each sibling block to see if we can coalesce with

	 * at least 25% free space to spare.  We need to figure out

	 * whether to merge with the forward or the backward block.

	 * We prefer coalescing with the lower numbered sibling so as

	 * to shrink an attribute list over time.

 start with smaller blk num */

 fits with at least 25% to spare */

	/*

	 * Make altpath point to the block we want to keep (the lower

	 * numbered block) and path point to the block we want to drop.

/*

 * Remove a name from the leaf attribute list structure.

 *

 * Return 1 if leaf is less than 37% full, 0 if >= 37% full.

 * If two leaves are 37% full, when combined they will leave 25% free.

	/*

	 * Scan through free region table:

	 *    check for adjacency of free'd entry with an existing one,

	 *    find smallest free region in case we need to replace it,

	 *    adjust any map that borders the entry table,

	/*

	 * Coalesce adjacent freemap regions,

	 * or replace the smallest region.

		/*

		 * Replace smallest region (if it is smaller than free'd entry)

	/*

	 * Did we remove the first entry?

	/*

	 * Compress the remaining entries and zero out the removed stuff.

	/*

	 * If we removed the first entry, re-find the first used byte

	 * in the name area.  Note that if the entry was the "firstused",

	 * then we don't have a "hole" in our block resulting from

	 * removing the name.

 mark as needing compaction */

	/*

	 * Check if leaf is less than 50% full, caller may want to

	 * "join" the leaf with a sibling if so.

 leaf is < 37% full */

/*

 * Move all the attribute list entries from drop_leaf into save_leaf.

	/*

	 * Save last hashval from dying block for later Btree fixup.

	/*

	 * Check if we need a temp buffer, or can we do it in place.

	 * Note that we don't check "leaf" for holes because we will

	 * always be dropping it, toosmall() decided that for us already.

		/*

		 * dest leaf has no holes, so we add there.  May need

		 * to make some room in the entry array.

		/*

		 * Destination has holes, so we make a temporary copy

		 * of the leaf and add them both to that.

		/*

		 * Copy the header into the temp leaf so that all the stuff

		 * not in the incore header is present and gets copied back in

		 * once we've moved all the entries.

 write the header to the temp buffer to initialise it */

 struct copy */

	/*

	 * Copy out last hashval in each block for B-tree code.

/*========================================================================

 * Routines used for finding things in the Btree.

/*

 * Look up a name in a leaf attribute list structure.

 * This is the internal routine, it uses the caller's buffer.

 *

 * Note that duplicate keys are allowed, but only check within the

 * current leaf node.  The Btree code must check in adjacent leaf nodes.

 *

 * Return in args->index the index into the entry[] array of either

 * the found entry, or where the entry should have been (insert before

 * that entry).

 *

 * Don't change the args->value unless we find the attribute.

	/*

	 * Binary search.  (note: small blocks will skip this loop)

	/*

	 * Since we may have duplicate hashval's, find the first matching

	 * hashval in the leaf.

	/*

	 * Duplicate keys may be present, so search all of them for a match.

/*

 * GROT: Add code to remove incomplete entries.

/*

 * Get the value associated with an attribute name from a leaf attribute

 * list structure.

 *

 * If args->valuelen is zero, only the length needs to be returned.  Unlike a

 * lookup, we only return an error if the attribute does not exist or we can't

 * retrieve the value.

/*========================================================================

 * Utility routines.

/*

 * Move the indicated entries from one leaf to another.

 * NOTE: this routine modifies both source and destination leaves.

ARGSUSED*/

	/*

	 * Check for nothing to do.

	/*

	 * Set up environment.

	/*

	 * Move the entries in the destination leaf up to make a hole?

	/*

	 * Copy all entry's in the same (sorted) order,

	 * but allocate attribute info packed and in sequence.

		/*

		 * Code to drop INCOMPLETE entries.  Difficult to use as we

		 * may also need to change the insertion index.  Code turned

		 * off for 6.2, should be revisited later.

 skip partials? */

 to compensate for ++ in loop hdr */

 insertion index adjustment */

 GROT */

 both on-disk, don't endian flip twice */

 GROT */

	/*

	 * Zero out the entries we just copied.

		/*

		 * Move the remaining entries down to fill the hole,

		 * then zero the entries at the top.

	/*

	 * Fill in the freemap information

 leaf may not be compact */

/*

 * Pick up the last hashvalue from a leaf block.

/*

 * Calculate the number of bytes used to store the indicated attribute

 * (whether local or remote only calculate bytes in this block).

/*

 * Calculate the number of bytes that would be required to store the new

 * attribute (whether local or remote only calculate bytes in this block).

 * This routine decides as a side effect whether the attribute will be

 * a "local" or a "remote" attribute.

/*========================================================================

 * Manage the INCOMPLETE flag in a leaf entry

/*

 * Clear the INCOMPLETE flag on an entry in a leaf block.

 DEBUG */

	/*

	 * Set up the operation.

 DEBUG */

/*

 * Set the INCOMPLETE flag on an entry in a leaf block.

	/*

	 * Set up the operation.

/*

 * In a single transaction, clear the INCOMPLETE flag on the leaf entry

 * given by args->blkno/index and set the INCOMPLETE flag on the leaf

 * entry given by args->blkno2/index2.

 *

 * Note that they could be in different blocks, or in the same block.

 DEBUG */

	/*

	 * Read the block containing the "old" attr

	/*

	 * Read the block containing the "new" attr, if it is different

 DEBUG */

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/befs/io.c

 *

 * Copyright (C) 2001 Will Dyson <will_dyson@pobox.com

 *

 * Based on portions of file.c and inode.c

 * by Makoto Kato (m_kato@ga2.so-net.ne.jp)

 *

 * Many thanks to Dominic Giampaolo, author of Practical File System

 * Design with the Be File System, for such a helpful book.

 *

/*

 * Converts befs notion of disk addr to a disk offset and uses

 * linux kernel function sb_bread() to get the buffer containing

 * the offset.

/*

 * super.c

 *

 * Copyright (C) 2001-2002 Will Dyson <will_dyson@pobox.com>

 *

 * Licensed under the GNU GPL. See the file COPYING for details.

 *

 for PAGE_SIZE */

/*

 * befs_load_sb -- Read from disk and properly byteswap all the fields

 * of the befs superblock

 Check the byte order of the filesystem */

 Check magic headers of super block */

	/*

	 * Check blocksize of BEFS.

	 *

	 * Blocksize of BEFS is 1024, 2048, 4096 or 8192.

	/*

	 * block_shift and block_size encode the same information

	 * in different ways as a consistency check.

	/* ag_shift also encodes the same information as blocks_per_ag in a

	 * different way, non-fatal consistency check

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/befs/datastream.c

 *

 * Copyright (C) 2001 Will Dyson <will_dyson@pobox.com>

 *

 * Based on portions of file.c by Makoto Kato <m_kato@ga2.so-net.ne.jp>

 *

 * Many thanks to Dominic Giampaolo, author of "Practical File System

 * Design with the Be File System", for such a helpful book.

 *

/**

 * befs_read_datastream - get buffer_head containing data, starting from pos.

 * @sb: Filesystem superblock

 * @ds: datastream to find data with

 * @pos: start of data

 * @off: offset of data in buffer_head->b_data

 *

 * Returns pointer to buffer_head containing data starting with offset @off,

 * if you don't need to know offset just set @off = NULL.

 block coresponding to pos */

/**

 * befs_fblock2brun - give back block run for fblock

 * @sb: the superblock

 * @data: datastream to read from

 * @fblock: the blocknumber with the file position to find

 * @run: The found run is passed back through this pointer

 *

 * Takes a file position and gives back a brun who's starting block

 * is block number fblock of the file.

 *

 * Returns BEFS_OK or BEFS_ERR.

 *

 * Calls specialized functions for each of the three possible

 * datastream regions.

/**

 * befs_read_lsmylink - read long symlink from datastream.

 * @sb: Filesystem superblock

 * @ds: Datastream to read from

 * @buff: Buffer in which to place long symlink data

 * @len: Length of the long symlink in bytes

 *

 * Returns the number of bytes read

 bytes readed */

/**

 * befs_count_blocks - blocks used by a file

 * @sb: Filesystem superblock

 * @ds: Datastream of the file

 *

 * Counts the number of fs blocks that the file represented by

 * inode occupies on the filesystem, counting both regular file

 * data and filesystem metadata (and eventually attribute data

 * when we support attributes)

 File data blocks */

 FS metadata blocks */

 Start with 1 block for inode */

 Size of indirect block */

	/*

	 * Double indir block, plus all the indirect blocks it maps.

	 * In the double-indirect range, all block runs of data are

	 * BEFS_DBLINDIR_BRUN_LEN blocks long. Therefore, we know

	 * how many data block runs are in the double-indirect region,

	 * and from that we know how many indirect blocks it takes to

	 * map them. We assume that the indirect blocks are also

	 * BEFS_DBLINDIR_BRUN_LEN blocks long.

/**

 * befs_find_brun_direct - find a direct block run in the datastream

 * @sb: the superblock

 * @data: the datastream

 * @blockno: the blocknumber to find

 * @run: The found run is passed back through this pointer

 *

 * Finds the block run that starts at file block number blockno

 * in the file represented by the datastream data, if that

 * blockno is in the direct region of the datastream.

 *

 * Return value is BEFS_OK if the blockrun is found, BEFS_ERR

 * otherwise.

 *

 * Algorithm:

 * Linear search. Checks each element of array[] to see if it

 * contains the blockno-th filesystem block. This is necessary

 * because the block runs map variable amounts of data. Simply

 * keeps a count of the number of blocks searched so far (sum),

 * incrementing this by the length of each block run as we come

 * across it. Adds sum to *count before returning (this is so

 * you can search multiple arrays that are logicaly one array,

 * as in the indirect region code).

 *

 * When/if blockno is found, if blockno is inside of a block

 * run as stored on disk, we offset the start and length members

 * of the block run, so that blockno is the start and len is

 * still valid (the run ends in the same place).

/**

 * befs_find_brun_indirect - find a block run in the datastream

 * @sb: the superblock

 * @data: the datastream

 * @blockno: the blocknumber to find

 * @run: The found run is passed back through this pointer

 *

 * Finds the block run that starts at file block number blockno

 * in the file represented by the datastream data, if that

 * blockno is in the indirect region of the datastream.

 *

 * Return value is BEFS_OK if the blockrun is found, BEFS_ERR

 * otherwise.

 *

 * Algorithm:

 * For each block in the indirect run of the datastream, read

 * it in and search through it for search_blk.

 *

 * XXX:

 * Really should check to make sure blockno is inside indirect

 * region.

 Examine blocks of the indirect run one at a time */

 Only fallthrough is an error */

/**

 * befs_find_brun_dblindirect - find a block run in the datastream

 * @sb: the superblock

 * @data: the datastream

 * @blockno: the blocknumber to find

 * @run: The found run is passed back through this pointer

 *

 * Finds the block run that starts at file block number blockno

 * in the file represented by the datastream data, if that

 * blockno is in the double-indirect region of the datastream.

 *

 * Return value is BEFS_OK if the blockrun is found, BEFS_ERR

 * otherwise.

 *

 * Algorithm:

 * The block runs in the double-indirect region are different.

 * They are always allocated 4 fs blocks at a time, so each

 * block run maps a constant amount of file data. This means

 * that we can directly calculate how many block runs into the

 * double-indirect region we need to go to get to the one that

 * maps a particular filesystem block.

 *

 * We do this in two stages. First we calculate which of the

 * inode addresses in the double-indirect block will point us

 * to the indirect block that contains the mapping for the data,

 * then we calculate which of the inode addresses in that

 * indirect block maps the data block we are after.

 *

 * Oh, and once we've done that, we actually read in the blocks

 * that contain the inode addresses we calculated above. Even

 * though the double-indirect run may be several blocks long,

 * we can calculate which of those blocks will contain the index

 * we are after and only read that one. We then follow it to

 * the indirect block and perform a similar process to find

 * the actual block run that maps the data block we are interested

 * in.

 *

 * Then we offset the run as in befs_find_brun_array() and we are

 * done.

	/* number of data blocks mapped by each of the iaddrs in

	 * the indirect block pointed to by the double indirect block

	/* number of data blocks mapped by each of the iaddrs in

	 * the double indirect block

	/* First, discover which of the double_indir->indir blocks

	 * contains pos. Then figure out how much of pos that

	 * accounted for. Then discover which of the iaddrs in

	 * the indirect block contains pos.

 Read double indirect block */

 Read indirect block */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/fs/befs/linuxvfs.c

 *

 * Copyright (C) 2001 Will Dyson <will_dyson@pobox.com

 *

 The units the vfs expects inode->i_blocks to be in */

 allocate a new inode */

 deallocate an inode */

 uninit super */

 statfs */

 slab cache for befs_inode_info objects */

/*

 * Called by generic_file_read() to read a page of data

 *

 * In turn, simply calls a generic block read function and

 * passes it the address of befs_get_block, for mapping file

 * positions to disk blocks.

/*

 * Generic function to map a file position (block) to a

 * disk offset (passed back in bh_result).

 *

 * Used by many higher level functions.

 *

 * Calls befs_fblock2brun() in datastream.c to do the real work.

 Convert to UTF-8 */

 Convert to NLS */

 convert from vfs's inode number to befs's inode number */

	/*

	 * set uid and gid.  But since current BeOS is single user OS, so

	 * you can change by "uid" or "gid" options.

	/*

	 * BEFS's time is 64 bits, but current VFS is 32 bits...

	 * BEFS don't have access time. Nor inode change time. VFS

	 * doesn't have creation time.

	 * Also, the lower 16 bits of the last_modified_time and

	 * create_time are just a counter to help ensure uniqueness

	 * for indexing purposes. (PFD, page 54)

 lower 16 bits are not a time */

/* Initialize the inode cache. Called at fs setup.

 *

 * Taken from NFS implementation by Al Viro.

/* Called at fs teardown.

 *

 * Taken from NFS implementation by Al Viro.

	/*

	 * Make sure all delayed rcu free inodes are flushed before we

	 * destroy cache.

/*

 * The inode of symbolic link is different to data stream.

 * The data stream become link name. Unless the LONG_SYMLINK

 * flag is set.

/*

 * UTF-8 to NLS charset convert routine

 *

 * Uses uni2char() / char2uni() rather than the nls tables directly

	/* The utf8->nls conversion won't make the final nls string bigger

	 * than the utf one, but if the string is pure ascii they'll have the

	 * same width and an extra char is needed to save the additional \0

 convert from UTF-8 to Unicode */

 convert from Unicode to nls */

/**

 * befs_nls2utf - Convert NLS string to utf8 encodeing

 * @sb: Superblock

 * @in: Input string buffer in NLS format

 * @in_len: Length of input string in bytes

 * @out: The output string in UTF-8 format

 * @out_len: Length of the output buffer

 *

 * Converts input string @in, which is in the format of the loaded NLS map,

 * into a utf8 string.

 *

 * The destination string @out is allocated by this function and the caller is

 * responsible for freeing it with kfree()

 *

 * On return, *@out_len is the length of @out in bytes.

 *

 * On success, the return value is the number of utf8 characters written to

 * the output buffer @out.

 *

 * On Failure, a negative number coresponding to the error code is returned.

	/*

	 * There are nls characters that will translate to 3-chars-wide UTF-8

	 * characters, an additional byte is needed to save the final \0

	 * in special cases

 convert from nls to unicode */

 convert from unicode to UTF-8 */

 No need to handle i_generation */

/*

 * Map a NFS file handle to a corresponding dentry

/*

 * Find the parent for a file specified by NFS handle

 Initialize options */

/* This function has the responsibiltiy of getting the

 * filesystem ready for unmounting.

 * Basically, we free everything that we allocated in

 * befs_read_inode

/* Allocate private field of the superblock, fill it.

 *

 * Finish filling the public superblock fields

 * Make the root directory

 * Load a set of NLS translations if needed.

	/*

	 * Set dummy blocksize to read super block.

	 * Will be set to real fs blocksize later.

	 *

	 * Linux 2.4.10 and later refuse to read blocks smaller than

	 * the logical block size for the device. But we also need to read at

	 * least 1k to get the second 512 bytes of the volume.

 account for offset of super block on x86 */

	/*

	 * set up enough so that it can read an inode

	 * Fill in kernel superblock fields from private sb

 Set real blocksize of fs */

 load nls library */

 load default nls if none is specified  in mount options */

 UNKNOWN */

 UNKNOWN */

/*

 * Macros that typecheck the init and exit functions,

 * ensures that they are called at init and cleanup,

 * and eliminates warnings about unused functions.

 SPDX-License-Identifier: GPL-2.0

/*

 * inode.c

 *

 * Copyright (C) 2001 Will Dyson <will_dyson@pobox.com>

/*

 * Validates the correctness of the befs inode

 * Returns BEFS_OK if the inode should be used, otherwise

 * returns BEFS_BAD_INODE

 check magic header. */

	/*

	 * Sanity check2: inodes store their own block address. Check it.

	/*

	 * check flag

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/befs/debug.c

 *

 * Copyright (C) 2001 Will Dyson (will_dyson at pobox.com)

 *

 * With help from the ntfs-tng driver by Anton Altparmakov

 *

 * Copyright (C) 1999  Makoto Kato (m_kato@ga2.so-net.ne.jp)

 *

 * debug functions

 __KERNEL__ */

CONFIG_BEFS_DEBUG

CONFIG_BEFS_DEBUG

/*

 * Display super block structure for debug.

CONFIG_BEFS_DEBUG

 unused */

 unused */

CONFIG_BEFS_DEBUG

  0  */

CONFIG_BEFS_DEBUG

CONFIG_BEFS_DEBUG

/*

 * linux/fs/befs/btree.c

 *

 * Copyright (C) 2001-2002 Will Dyson <will_dyson@pobox.com>

 *

 * Licensed under the GNU GPL. See the file COPYING for details.

 *

 * 2002-02-05: Sergey S. Kostyliov added binary search within

 * 		btree nodes.

 *

 * Many thanks to:

 *

 * Dominic Giampaolo, author of "Practical File System

 * Design with the Be File System", for such a helpful book.

 *

 * Marcus J. Ranum, author of the b+tree package in

 * comp.sources.misc volume 10. This code is not copied from that

 * work, but it is partially based on it.

 *

 * Makoto Kato, author of the original BeFS for linux filesystem

 * driver.

/*

 * The btree functions in this file are built on top of the

 * datastream.c interface, which is in turn built on top of the

 * io.c interface.

/* Befs B+tree structure:

 *

 * The first thing in the tree is the tree superblock. It tells you

 * all kinds of useful things about the tree, like where the rootnode

 * is located, and the size of the nodes (always 1024 with current version

 * of BeOS).

 *

 * The rest of the tree consists of a series of nodes. Nodes contain a header

 * (struct befs_btree_nodehead), the packed key data, an array of shorts

 * containing the ending offsets for each of the keys, and an array of

 * befs_off_t values. In interior nodes, the keys are the ending keys for

 * the childnode they point to, and the values are offsets into the

 * datastream containing the tree.

/* Note:

 *

 * The book states 2 confusing things about befs b+trees. First,

 * it states that the overflow field of node headers is used by internal nodes

 * to point to another node that "effectively continues this one". Here is what

 * I believe that means. Each key in internal nodes points to another node that

 * contains key values less than itself. Inspection reveals that the last key

 * in the internal node is not the last key in the index. Keys that are

 * greater than the last key in the internal node go into the overflow node.

 * I imagine there is a performance reason for this.

 *

 * Second, it states that the header of a btree node is sufficient to

 * distinguish internal nodes from leaf nodes. Without saying exactly how.

 * After figuring out the first, it becomes obvious that internal nodes have

 * overflow nodes and leafnodes do not.

/*

 * Currently, this code is only good for directory B+trees.

 * In order to be used for other BFS indexes, it needs to be extended to handle

 * duplicate keys and non-string keytypes (int32, int64, float, double).

/*

 * In memory structure of each btree node

 head of node converted to cpu byteorder */

 on disk node */

 local constants */

 local functions */

/**

 * befs_bt_read_super() - read in btree superblock convert to cpu byteorder

 * @sb:        Filesystem superblock

 * @ds:        Datastream to read from

 * @sup:       Buffer in which to place the btree superblock

 *

 * Calls befs_read_datastream to read in the btree superblock and

 * makes sure it is in cpu byteorder, byteswapping if necessary.

 * Return: BEFS_OK on success and if *@sup contains the btree superblock in cpu

 * byte order. Otherwise return BEFS_ERR on error.

/**

 * befs_bt_read_node - read in btree node and convert to cpu byteorder

 * @sb: Filesystem superblock

 * @ds: Datastream to read from

 * @node: Buffer in which to place the btree node

 * @node_off: Starting offset (in bytes) of the node in @ds

 *

 * Calls befs_read_datastream to read in the indicated btree node and

 * makes sure its header fields are in cpu byteorder, byteswapping if

 * necessary.

 * Note: node->bh must be NULL when this function is called the first time.

 * Don't forget brelse(node->bh) after last call.

 *

 * On success, returns BEFS_OK and *@node contains the btree node that

 * starts at @node_off, with the node->head fields in cpu byte order.

 *

 * On failure, BEFS_ERR is returned.

/**

 * befs_btree_find - Find a key in a befs B+tree

 * @sb: Filesystem superblock

 * @ds: Datastream containing btree

 * @key: Key string to lookup in btree

 * @value: Value stored with @key

 *

 * On success, returns BEFS_OK and sets *@value to the value stored

 * with @key (usually the disk block number of an inode).

 *

 * On failure, returns BEFS_ERR or BEFS_BT_NOT_FOUND.

 *

 * Algorithm:

 *   Read the superblock and rootnode of the b+tree.

 *   Drill down through the interior nodes using befs_find_key().

 *   Once at the correct leaf node, use befs_find_key() again to get the

 *   actual value stored with the key.

 read in root node */

 if no key set, try the overflow node */

 at a leaf node now, check if it is correct */

/**

 * befs_find_key - Search for a key within a node

 * @sb: Filesystem superblock

 * @node: Node to find the key within

 * @findkey: Keystring to search for

 * @value: If key is found, the value stored with the key is put here

 *

 * Finds exact match if one exists, and returns BEFS_BT_MATCH.

 * If there is no match and node's value array is too small for key, return

 * BEFS_BT_OVERFLOW.

 * If no match and node should countain this key, return BEFS_BT_NOT_FOUND.

 *

 * Uses binary search instead of a linear.

 if node can not contain key, just skip this node */

 simple binary search */

 return an existing value so caller can arrive to a leaf node */

/**

 * befs_btree_read - Traverse leafnodes of a btree

 * @sb: Filesystem superblock

 * @ds: Datastream containing btree

 * @key_no: Key number (alphabetical order) of key to read

 * @bufsize: Size of the buffer to return key in

 * @keybuf: Pointer to a buffer to put the key in

 * @keysize: Length of the returned key

 * @value: Value stored with the returned key

 *

 * Here's how it works: Key_no is the index of the key/value pair to

 * return in keybuf/value.

 * Bufsize is the size of keybuf (BEFS_NAME_LEN+1 is a good size). Keysize is

 * the number of characters in the key (just a convenience).

 *

 * Algorithm:

 *   Get the first leafnode of the tree. See if the requested key is in that

 *   node. If not, follow the node->right link to the next leafnode. Repeat

 *   until the (key_no)th key is found or the tree is out of keys.

 seeks down to first leafnode, reads it into this_node */

 find the leaf node containing the key_no key */

 no more nodes to look in: key_no is too large */

 how many keys into this_node is key_no */

 get pointers to datastructures within the node body */

/**

 * befs_btree_seekleaf - Find the first leafnode in the btree

 * @sb: Filesystem superblock

 * @ds: Datastream containing btree

 * @bt_super: Pointer to the superblock of the btree

 * @this_node: Buffer to return the leafnode in

 * @node_off: Pointer to offset of current node within datastream. Modified

 * 		by the function.

 *

 * Helper function for btree traverse. Moves the current position to the

 * start of the first leaf node.

 *

 * Also checks for an empty tree. If there are no keys, returns BEFS_BT_EMPTY.

/**

 * befs_leafnode - Determine if the btree node is a leaf node or an

 * interior node

 * @node: Pointer to node structure to test

 *

 * Return 1 if leaf, 0 if interior

 all interior nodes (and only interior nodes) have an overflow node */

/**

 * befs_bt_keylen_index - Finds start of keylen index in a node

 * @node: Pointer to the node structure to find the keylen index within

 *

 * Returns a pointer to the start of the key length index array

 * of the B+tree node *@node

 *

 * "The length of all the keys in the node is added to the size of the

 * header and then rounded up to a multiple of four to get the beginning

 * of the key length index" (p.88, practical filesystem design).

 *

 * Except that rounding up to 8 works, and rounding up to 4 doesn't.

/**

 * befs_bt_valarray - Finds the start of value array in a node

 * @node: Pointer to the node structure to find the value array within

 *

 * Returns a pointer to the start of the value array

 * of the node pointed to by the node header

/**

 * befs_bt_keydata - Finds start of keydata array in a node

 * @node: Pointer to the node structure to find the keydata array within

 *

 * Returns a pointer to the start of the keydata array

 * of the node pointed to by the node header

/**

 * befs_bt_get_key - returns a pointer to the start of a key

 * @sb: filesystem superblock

 * @node: node in which to look for the key

 * @index: the index of the key to get

 * @keylen: modified to be the length of the key at @index

 *

 * Returns a valid pointer into @node on success.

 * Returns NULL on failure (bad input) and sets *@keylen = 0

/**

 * befs_compare_strings - compare two strings

 * @key1: pointer to the first key to be compared

 * @keylen1: length in bytes of key1

 * @key2: pointer to the second key to be compared

 * @keylen2: length in bytes of key2

 *

 * Returns 0 if @key1 and @key2 are equal.

 * Returns >0 if @key1 is greater.

 * Returns <0 if @key2 is greater.

 These will be used for non-string keyed btrees */

0

 SPDX-License-Identifier: GPL-2.0

/*

 * Simple file system for zoned block devices exposing zones as files.

 *

 * Copyright (C) 2019 Western Digital Corporation or its affiliates.

	/*

	 * A full zone is no longer open/active and does not need

	 * explicit closing.

 All I/Os should always be within the file maximum size */

	/*

	 * Sequential zones can only accept direct writes. This is already

	 * checked when writes are issued, so warn if we see a page writeback

	 * operation.

	/*

	 * For conventional zones, all blocks are always mapped. For sequential

	 * zones, all blocks after always mapped below the inode size (zone

	 * write pointer) and unwriten beyond.

/*

 * Map blocks for page writeback. This is used only on conventional zone files,

 * which implies that the page range can only be within the fixed inode size.

 If the mapping is already OK, nothing needs to be done */

	/*

	 * This may be called for an update after an IO error.

	 * So beware of the values seen.

/*

 * Check a zone condition and adjust its file inode access permissions for

 * offline and readonly zones. Return the inode size corresponding to the

 * amount of readable data in the zone.

		/*

		 * Dead zone: make the inode immutable, disable all accesses

		 * and set the file size to 0 (zone wp set to zone start).

		/*

		 * The write pointer of read-only zones is invalid. If such a

		 * zone is found during mount, the file size cannot be retrieved

		 * so we treat the zone as offline (mount == true case).

		 * Otherwise, keep the file size as it was when last updated

		 * so that the user can recover data. In both cases, writes are

		 * always disabled for the zone.

 The write pointer of full zones is invalid. */

	/*

	 * Check the zone condition: if the zone is not "bad" (offline or

	 * read-only), read errors are simply signaled to the IO issuer as long

	 * as there is no inconsistency between the inode size and the amount of

	 * data writen in the zone (data_size).

	/*

	 * At this point, we detected either a bad zone or an inconsistency

	 * between the inode size and the amount of data written in the zone.

	 * For the latter case, the cause may be a write IO error or an external

	 * action on the device. Two error patterns exist:

	 * 1) The inode size is lower than the amount of data in the zone:

	 *    a write operation partially failed and data was writen at the end

	 *    of the file. This can happen in the case of a large direct IO

	 *    needing several BIOs and/or write requests to be processed.

	 * 2) The inode size is larger than the amount of data in the zone:

	 *    this can happen with a deferred write error with the use of the

	 *    device side write cache after getting successful write IO

	 *    completions. Other possibilities are (a) an external corruption,

	 *    e.g. an application reset the zone directly, or (b) the device

	 *    has a serious problem (e.g. firmware bug).

	 *

	 * In all cases, warn about inode size inconsistency and handle the

	 * IO error according to the zone condition and to the mount options.

	/*

	 * First handle bad zones signaled by hardware. The mount options

	 * errors=zone-ro and errors=zone-offline result in changing the

	 * zone condition to read-only and offline respectively, as if the

	 * condition was signaled by the hardware.

	/*

	 * If the filesystem is mounted with the explicit-open mount option, we

	 * need to clear the ZONEFS_ZONE_OPEN flag if the zone transitioned to

	 * the read-only or offline condition, to avoid attempting an explicit

	 * close of the zone when the inode file is closed.

	/*

	 * If error=remount-ro was specified, any error result in remounting

	 * the volume as read-only.

	/*

	 * Update block usage stats and the inode size  to prevent access to

	 * invalid data.

/*

 * When an file IO error occurs, check the file zone to see if there is a change

 * in the zone condition (e.g. offline or read-only). For a failed write to a

 * sequential zone, the zone write pointer position must also be checked to

 * eventually correct the file size and zonefs inode write pointer offset

 * (which can be out of sync with the drive due to partial write failures).

	/*

	 * Memory allocations in blkdev_report_zones() can trigger a memory

	 * reclaim which may in turn cause a recursion into zonefs as well as

	 * struct request allocations for the same device. The former case may

	 * end up in a deadlock on the inode truncate mutex, while the latter

	 * may prevent IO forward progress. Executing the report zones under

	 * the GFP_NOIO context avoids both problems.

	/*

	 * Only sequential zone files can be truncated and truncation is allowed

	 * only down to a 0 size, which is equivalent to a zone reset, and to

	 * the maximum file size, which is equivalent to a zone finish.

 Serialize against page faults */

 Serialize against zonefs_iomap_begin() */

	/*

	 * If the mount option ZONEFS_MNTOPT_EXPLICIT_OPEN is set,

	 * take care of open zones.

		/*

		 * Truncating a zone to EMPTY or FULL is the equivalent of

		 * closing the zone. For a truncation to 0, we need to

		 * re-open the zone to ensure new writes can be processed.

		 * For a truncation to the maximum file size, the zone is

		 * closed and writes cannot be accepted anymore, so clear

		 * the open flag.

	/*

	 * Since files and directories cannot be created nor deleted, do not

	 * allow setting any write attributes on the sub-directories grouping

	 * files by zone type.

	/*

	 * Since only direct writes are allowed in sequential files, page cache

	 * flush is needed only for conventional zone files.

	/*

	 * Sanity check: only conventional zone files can have shared

	 * writeable mappings.

 Serialize against truncates */

	/*

	 * Conventional zones accept random writes, so their files can support

	 * shared writable mappings. For sequential zone files, only read

	 * mappings are possible since there are no guarantees for write

	 * ordering between msync() and page cache writeback.

	/*

	 * Seeks are limited to below the zone size for conventional zones

	 * and below the zone write pointer for sequential zones. In both

	 * cases, this limit is the inode size.

		/*

		 * Note that we may be seeing completions out of order,

		 * but that is not a problem since a write completed

		 * successfully necessarily means that all preceding writes

		 * were also successful. So we can safely increase the inode

		 * size to the write end location.

/*

 * Do not exceed the LFS limits nor the file zone size. If pos is under the

 * limit it becomes a short access. If it exceeds the limit, return -EFBIG.

/*

 * Handle direct writes. For sequential zone files, this is the only possible

 * write path. For these files, check that the user is issuing writes

 * sequentially from the end of the file. This code assumes that the block layer

 * delivers write requests to the device in sequential order. This is always the

 * case if a block IO scheduler implementing the ELEVATOR_F_ZBD_SEQ_WRITE

 * elevator feature is being used (e.g. mq-deadline). The block layer always

 * automatically select such an elevator for zoned block devices during the

 * device initialization.

	/*

	 * For async direct IOs to sequential zone files, refuse IOCB_NOWAIT

	 * as this can cause write reordering (e.g. the first aio gets EAGAIN

	 * on the inode lock but the second goes through but is now unaligned).

 Enforce sequential writes (append only) in sequential zones */

	/*

	 * Direct IO writes are mandatory for sequential zone files so that the

	 * write IO issuing order is preserved.

 Write operations beyond the zone size are not allowed */

 Offline zones cannot be read */

 Limit read operations to written data */

		/*

		 * If the file zone is full, it is not open anymore and we only

		 * need to decrement the open count.

			/*

			 * Leaving zones explicitly open may lead to a state

			 * where most zones cannot be written (zone resources

			 * exhausted). So take preventive action by remounting

			 * read-only.

	/*

	 * If we explicitly open a zone we must close it again as well, but the

	 * zone management operation can fail (either due to an IO error or as

	 * the zone has gone offline or read-only). Make sure we don't fail the

	 * close(2) for user-space.

/*

 * File system stat.

/*

 * Create a zone group and populate it with zone files.

 If the group is empty, there is nothing to do */

	/*

	 * The first zone contains the super block: skip it.

		/*

		 * For conventional zones, contiguous zones can be aggregated

		 * together to form larger files. Note that this overwrites the

		 * length of the first zone of the set of contiguous zones

		 * aggregated together. If one offline or read-only zone is

		 * found, assume that all zones aggregated have the same

		 * condition.

		/*

		 * Use the file number within its group as file name.

	/*

	 * Count the number of usable zones: the first zone at index 0 contains

	 * the super block and is ignored.

 Get zones information from the device */

/*

 * Read super block information from the device.

/*

 * Check that the device is zoned. If it is, get the list of zones and create

 * sub-directories and files according to the device zone configuration and

 * format options.

	/*

	 * Initialize super block information: the maximum file size is updated

	 * when the zone files are created so that the format option

	 * ZONEFS_F_AGGRCNV which increases the maximum file size of a file

	 * beyond the zone size is taken into account.

	/*

	 * The block size is set to the device zone write granularity to ensure

	 * that write operations are always aligned according to the device

	 * interface constraints.

 Create root directory inode */

 Create and populate files in zone groups directories */

/*

 * File system definition and registration.

	/*

	 * Make sure all delayed rcu free inodes are flushed before we

	 * destroy the inode cache.

/*

 * Copyright (c) 2014 SGI.

 * All rights reserved.

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation.

 *

 * This program is distributed in the hope that it would be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * You should have received a copy of the GNU General Public License

 * along with this program; if not, write the Free Software Foundation,

 * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

 Generator for a compact trie for unicode normalization */

 Default names of the in- and output files. */

 An arbitrary line size limit on input lines. */

 ------------------------------------------------------------------ */

/*

 * Unicode version numbers consist of three parts: major, minor, and a

 * revision.  These numbers are packed into an unsigned int to obtain

 * a single version number.

 *

 * To save space in the generated trie, the unicode version is not

 * stored directly, instead we calculate a generation number from the

 * unicode versions seen in the DerivedAge file, and use that as an

 * index into a table of unicode versions.

 ------------------------------------------------------------------ */

/*

 * utf8trie_t

 *

 * A compact binary tree, used to decode UTF-8 characters.

 *

 * Internal nodes are one byte for the node itself, and up to three

 * bytes for an offset into the tree.  The first byte contains the

 * following information:

 *  NEXTBYTE  - flag        - advance to next byte if set

 *  BITNUM    - 3 bit field - the bit number to tested

 *  OFFLEN    - 2 bit field - number of bytes in the offset

 * if offlen == 0 (non-branching node)

 *  RIGHTPATH - 1 bit field - set if the following node is for the

 *                            right-hand path (tested bit is set)

 *  TRIENODE  - 1 bit field - set if the following node is an internal

 *                            node, otherwise it is a leaf node

 * if offlen != 0 (branching node)

 *  LEFTNODE  - 1 bit field - set if the left-hand node is internal

 *  RIGHTNODE - 1 bit field - set if the right-hand node is internal

 *

 * Due to the way utf8 works, there cannot be branching nodes with

 * NEXTBYTE set, and moreover those nodes always have a righthand

 * descendant.

/*

 * utf8leaf_t

 *

 * The leaves of the trie are embedded in the trie, and so the same

 * underlying datatype, unsigned char.

 *

 * leaf[0]: The unicode version, stored as a generation number that is

 *          an index into utf8agetab[].  With this we can filter code

 *          points based on the unicode version in which they were

 *          defined.  The CCC of a non-defined code point is 0.

 * leaf[1]: Canonical Combining Class. During normalization, we need

 *          to do a stable sort into ascending order of all characters

 *          with a non-zero CCC that occur between two characters with

 *          a CCC of 0, or at the begin or end of a string.

 *          The unicode standard guarantees that all CCC values are

 *          between 0 and 254 inclusive, which leaves 255 available as

 *          a special value.

 *          Code points with CCC 0 are known as stoppers.

 * leaf[2]: Decomposition. If leaf[1] == 255, then leaf[2] is the

 *          start of a NUL-terminated string that is the decomposition

 *          of the character.

 *          The CCC of a decomposable character is the same as the CCC

 *          of the first character of its decomposition.

 *          Some characters decompose as the empty string: these are

 *          characters with the Default_Ignorable_Code_Point property.

 *          These do affect normalization, as they all have CCC 0.

 *

 * The decompositions in the trie have been fully expanded.

 *

 * Casefolding, if applicable, is also done using decompositions.

 ------------------------------------------------------------------ */

/*

 * UTF8 valid ranges.

 *

 * The UTF-8 encoding spreads the bits of a 32bit word over several

 * bytes. This table gives the ranges that can be held and how they'd

 * be represented.

 *

 * 0x00000000 0x0000007F: 0xxxxxxx

 * 0x00000000 0x000007FF: 110xxxxx 10xxxxxx

 * 0x00000000 0x0000FFFF: 1110xxxx 10xxxxxx 10xxxxxx

 * 0x00000000 0x001FFFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

 * 0x00000000 0x03FFFFFF: 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx

 * 0x00000000 0x7FFFFFFF: 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx

 *

 * There is an additional requirement on UTF-8, in that only the

 * shortest representation of a 32bit value is to be used.  A decoder

 * must not decode sequences that do not satisfy this requirement.

 * Thus the allowed ranges have a lower bound.

 *

 * 0x00000000 0x0000007F: 0xxxxxxx

 * 0x00000080 0x000007FF: 110xxxxx 10xxxxxx

 * 0x00000800 0x0000FFFF: 1110xxxx 10xxxxxx 10xxxxxx

 * 0x00010000 0x001FFFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

 * 0x00200000 0x03FFFFFF: 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx

 * 0x04000000 0x7FFFFFFF: 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx

 *

 * Actual unicode characters are limited to the range 0x0 - 0x10FFFF,

 * 17 planes of 65536 values.  This limits the sequences actually seen

 * even more, to just the following.

 *

 *          0 -     0x7f: 0                     0x7f

 *       0x80 -    0x7ff: 0xc2 0x80             0xdf 0xbf

 *      0x800 -   0xffff: 0xe0 0xa0 0x80        0xef 0xbf 0xbf

 *    0x10000 - 0x10ffff: 0xf0 0x90 0x80 0x80   0xf4 0x8f 0xbf 0xbf

 *

 * Even within those ranges not all values are allowed: the surrogates

 * 0xd800 - 0xdfff should never be seen.

 *

 * Note that the longest sequence seen with valid usage is 4 bytes,

 * the same a single UTF-32 character.  This makes the UTF-8

 * representation of Unicode strictly smaller than UTF-32.

 *

 * The shortest sequence requirement was introduced by:

 *    Corrigendum #1: UTF-8 Shortest Form

 * It can be found here:

 *    http://www.unicode.org/versions/corrigendum1.html

 *

/*

 * Example lookup function for a tree.

 Right leg */

 Left leg */

/*

 * A simple non-recursive tree walker: keep track of visits to the

 * left and right branches in the leftmask and rightmask.

/*

 * Allocate an initialize a new internal node.

/*

 * Insert a new leaf into the tree, and collapse any subtrees that are

 * fully populated and end in identical leaves. A nextbyte tagged

 * internal node will not be removed to preserve the tree's integrity.

 * Note that due to the structure of utf8, no nextbyte tagged node

 * will be a candidate for removal.

 Insert, creating path along the way. */

 Merge subtrees if possible. */

 Compare */

 Keep left, drop right leaf. */

 Check in parent */

 root of tree! */

 internal tree error */

 Propagate keymasks up along singleton chains. */

 Nix the mask for parents with two children. */

/*

 * Prune internal nodes.

 *

 * Fully populated subtrees that end at the same leaf have already

 * been collapsed.  There are still internal nodes that have for both

 * their left and right branches a sequence of singletons that make

 * identical choices and end in identical leaves.  The keymask and

 * keybits collected in the nodes describe the choices made in these

 * singleton chains.  When they are identical for the left and right

 * branch of a node, and the two leaves comare identical, the node in

 * question can be removed.

 *

 * Note that nodes with the nextbyte tag set will not be removed by

 * this to ensure tree integrity.  Note as well that the structure of

 * utf8 ensures that these nodes would not have been candidates for

 * removal in any case.

		/*

		 * This node has identical singleton-only subtrees.

		 * Remove it.

 Propagate keymasks up along singleton chains. */

 Force re-check */

 Force re-check */

/*

 * Mark the nodes in the tree that lead to leaves that must be

 * emitted.

 second pass: left siblings and singletons */

/*

 * Compute the index of each node and leaf, which is the offset in the

 * emitted trie.  These values must be pre-computed because relative

 * offsets between nodes are used to navigate the tree.

 Align to a cache line (or half a cache line?). */

 Round up to a multiple of 16 */

/*

 * Mark the nodes in a subtree, helper for size_nodes().

/*

 * Compute the size of nodes and leaves. We start by assuming that

 * each node needs to store a three-byte offset. The indexes of the

 * nodes are calculated based on that, and then this function is

 * called to see if the sizes of some nodes can be reduced.  This is

 * repeated until no more changes are seen.

				/*

				 * If the right node is not marked,

				 * look for a corresponding node in

				 * the next tree.  Such a node need

				 * not exist.

 Make sure the right node is marked. */

 offset <= 0xffffff */

/*

 * Emit a trie for the given tree into the data array.

 ------------------------------------------------------------------ */

/*

 * Unicode data.

 *

 * We need to keep track of the Canonical Combining Class, the Age,

 * and decompositions for a code point.

 *

 * For the Age, we store the index into the ages table.  Effectively

 * this is a generation number that the table maps to a unicode

 * version.

 *

 * The correction field is used to indicate that this entry is in the

 * corrections array, which contains decompositions that were

 * corrected in later revisions.  The value of the correction field is

 * the Unicode version in which the mapping was corrected.

/*

 * Check the corrections array to see if this entry was corrected at

 * some point.

 Count the number of different ages. */

 Two trees per age: nfdi and nfdicf */

 Assign ages to the trees. */

 The ages assigned above are off by one. */

 Set up the forwarding between trees. */

 Assign the callouts. */

 Finish init. */

 ------------------------------------------------------------------ */

www.unicode.org/Public/UCD/latest/ucd/\n");

 ------------------------------------------------------------------ */

 ------------------------------------------------------------------ */

 We must have found something above. */

 There is a 0 entry. */

 And a guard entry. */

 Nix surrogate block */

 Magic - guaranteed not to be exceeded. */

 skip over <tag> */

 decode the decomposition into UTF-32 */

 Magic - guaranteed not to be exceeded. */

 Use the C+F casefold. */

 Magic - guaranteed not to be exceeded. */

 ------------------------------------------------------------------ */

/*

 * Hangul decomposition (algorithm from Section 3.12 of Unicode 6.3.0)

 *

 * AC00;<Hangul Syllable, First>;Lo;0;L;;;;;N;;;;;

 * D7A3;<Hangul Syllable, Last>;Lo;0;L;;;;;N;;;;;

 *

 * SBase = 0xAC00

 * LBase = 0x1100

 * VBase = 0x1161

 * TBase = 0x11A7

 * LCount = 19

 * VCount = 21

 * TCount = 28

 * NCount = 588 (VCount * TCount)

 * SCount = 11172 (LCount * NCount)

 *

 * Decomposition:

 *   SIndex = s - SBase

 *

 * LV (Canonical/Full)

 *   LIndex = SIndex / NCount

 *   VIndex = (Sindex % NCount) / TCount

 *   LPart = LBase + LIndex

 *   VPart = VBase + VIndex

 *

 * LVT (Canonical)

 *   LVIndex = (SIndex / TCount) * TCount

 *   TIndex = (Sindex % TCount)

 *   LVPart = SBase + LVIndex

 *   TPart = TBase + TIndex

 *

 * LVT (Full)

 *   LIndex = SIndex / NCount

 *   VIndex = (Sindex % NCount) / TCount

 *   TIndex = (Sindex % TCount)

 *   LPart = LBase + LIndex

 *   VPart = VBase + VIndex

 *   if (TIndex == 0) {

 *          d = <LPart, VPart>

 *   } else {

 *          TPart = TBase + TIndex

 *          d = <LPart, VPart, TPart>

 *   }

 *

 unsigned int lc = 19; */

 unsigned int sc = (lc * nc); */

 Hangul */

		/*

		 * Add a cookie as a reminder that the hangul syllable

		 * decompositions must not be stored in the generated

		 * trie.

 Magic - guaranteed not to be exceeded. */

 Add this decomposition to nfdicf if there is no entry. */

 Magic - guaranteed not to be exceeded. */

 ------------------------------------------------------------------ */

/*

 * Hangul decomposition (algorithm from Section 3.12 of Unicode 6.3.0)

 *

 * AC00;<Hangul Syllable, First>;Lo;0;L;;;;;N;;;;;

 * D7A3;<Hangul Syllable, Last>;Lo;0;L;;;;;N;;;;;

 *

 * SBase = 0xAC00

 * LBase = 0x1100

 * VBase = 0x1161

 * TBase = 0x11A7

 * LCount = 19

 * VCount = 21

 * TCount = 28

 * NCount = 588 (VCount * TCount)

 * SCount = 11172 (LCount * NCount)

 *

 * Decomposition:

 *   SIndex = s - SBase

 *

 * LV (Canonical/Full)

 *   LIndex = SIndex / NCount

 *   VIndex = (Sindex % NCount) / TCount

 *   LPart = LBase + LIndex

 *   VPart = VBase + VIndex

 *

 * LVT (Canonical)

 *   LVIndex = (SIndex / TCount) * TCount

 *   TIndex = (Sindex % TCount)

 *   LVPart = SBase + LVIndex

 *   TPart = TBase + TIndex

 *

 * LVT (Full)

 *   LIndex = SIndex / NCount

 *   VIndex = (Sindex % NCount) / TCount

 *   TIndex = (Sindex % TCount)

 *   LPart = LBase + LIndex

 *   VPart = VBase + VIndex

 *   if (TIndex == 0) {

 *          d = <LPart, VPart>

 *   } else {

 *          TPart = TBase + TIndex

 *          d = <LPart, VPart, TPart>

 *   }

 Constants */

 Algorithmic decomposition of hangul syllable. */

 Calculate the SI, LI, VI, and TI values. */

 Fill in base of leaf. */

 Add LPart, a 3-byte UTF-8 sequence. */

 Add VPart, a 3-byte UTF-8 sequence. */

 Add TPart if required, also a 3-byte UTF-8 sequence. */

 Terminate string. */

/*

 * Use trie to scan s, touching at most len bytes.

 * Returns the leaf if one exists, NULL otherwise.

 *

 * A non-NULL return guarantees that the UTF-8 sequence starting at s

 * is well-formed and corresponds to a known unicode code point.  The

 * shorthand for this will be "is valid UTF-8 unicode".

 Right leg */

 Right node at offset of trie */

 Right node after this node */

 No right node. */

 Left leg */

 Left node after this node. */

 No left node. */

 Left node after this node */

	/*

	 * Hangul decomposition is done algorithmically. These are the

	 * codepoints >= 0xAC00 and <= 0xD7A3. Their UTF-8 encoding is

	 * always 3 bytes long, so s has been advanced twice, and the

	 * start of the sequence is at s-2.

/*

 * Use trie to scan s.

 * Returns the leaf if one exists, NULL otherwise.

 *

 * Forwards to trie_nlookup().

/*

 * Return the number of bytes used by the current UTF-8 sequence.

 * Assumes the input points to the first byte of a valid UTF-8

 * sequence.

/*

 * Maximum age of any character in s.

 * Return -1 if s is not valid UTF-8 unicode.

 * Return 0 if only non-assigned code points are used.

/*

 * Minimum age of any character in s.

 * Return -1 if s is not valid UTF-8 unicode.

 * Return 0 if non-assigned code points are used.

/*

 * Maximum age of any character in s, touch at most len bytes.

 * Return -1 if s is not valid UTF-8 unicode.

/*

 * Maximum age of any character in s, touch at most len bytes.

 * Return -1 if s is not valid UTF-8 unicode.

/*

 * Length of the normalization of s.

 * Return -1 if s is not valid UTF-8 unicode.

 *

 * A string of Default_Ignorable_Code_Point has length 0.

/*

 * Length of the normalization of s, touch at most len bytes.

 * Return -1 if s is not valid UTF-8 unicode.

/*

 * Cursor structure used by the normalizer.

/*

 * Set up an utf8cursor for use by utf8byte().

 *

 *   s      : string.

 *   len    : length of s.

 *   u8c    : pointer to cursor.

 *   trie   : utf8trie_t to use for normalization.

 *

 * Returns -1 on error, 0 on success.

 Check we didn't clobber the maximum length. */

 The first byte of s may not be an utf8 continuation. */

/*

 * Set up an utf8cursor for use by utf8byte().

 *

 *   s      : NUL-terminated string.

 *   u8c    : pointer to cursor.

 *   trie   : utf8trie_t to use for normalization.

 *

 * Returns -1 on error, 0 on success.

/*

 * Get one byte from the normalized form of the string described by u8c.

 *

 * Returns the byte cast to an unsigned char on succes, and -1 on failure.

 *

 * The cursor keeps track of the location in the string in u8c->s.

 * When a character is decomposed, the current location is stored in

 * u8c->p, and u8c->s is set to the start of the decomposition. Note

 * that bytes from a decomposition do not count against u8c->len.

 *

 * Characters are emitted if they match the current CCC in u8c->ccc.

 * Hitting end-of-string while u8c->ccc == STOPPER means we're done,

 * and the function returns 0 in that case.

 *

 * Sorting by CCC is done by repeatedly scanning the string.  The

 * values of u8c->s and u8c->p are stored in u8c->ss and u8c->sp at

 * the start of the scan.  The first pass finds the lowest CCC to be

 * emitted and stores it in u8c->nccc, the second pass emits the

 * characters with this CCC and finds the next lowest CCC. This limits

 * the number of passes to 1 + the number of different CCCs in the

 * sequence being scanned.

 *

 * Therefore:

 *  u8c->p  != NULL -> a decomposition is being scanned.

 *  u8c->ss != NULL -> this is a repeating scan.

 *  u8c->ccc == -1  -> this is the first scan of a repeating scan.

 Check for the end of a decomposed character. */

 Check for end-of-string. */

 There is no next byte. */

 End-of-string during a scan counts as a stopper. */

 This is a continuation of the current character. */

 Look up the data for the current character. */

 No leaf found implies that the input is a binary blob. */

 Characters that are too new have CCC 0. */

 Empty decomposition implies CCC 0. */

		/*

		 * If this is not a stopper, then see if it updates

		 * the next canonical class to be emitted.

		/*

		 * Return the current byte if this is the current

		 * combining class.

 Current combining class mismatch. */

			/*

			 * Scan forward for the first canonical class

			 * to be emitted.  Save the position from

			 * which to restart.

 Not a stopper, and not the ccc we're emitting. */

 At a stopper, restart for next ccc. */

 All done, proceed from here. */

 ------------------------------------------------------------------ */

 First test: null-terminated string. */

 Second test: length-limited string. */

 Replace NUL with a value that will cause an error if seen. */

 Step one, read data from file. */

 ------------------------------------------------------------------ */

 This file is generated code, do not edit. */\n");

 %s_%x */\n",

 ------------------------------------------------------------------ */

 Prevent "unused function" warning. */

 SPDX-License-Identifier: GPL-2.0 */

/* String cf is expected to be a valid UTF-8 casefolded

 * string.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Kernel module for testing utf-8 support.

 *

 * Copyright 2017 Collabora Ltd.

 Tests will be based on this version. */

 UTF-8 strings in this vector _must_ be NULL-terminated. */

 Trivial sequence */

 "ABba" decomposes to itself */

 Simple equivalent sequences */

               /* 'VULGAR FRACTION ONE QUARTER' cannot decompose to

                  'NUMBER 1' + 'FRACTION SLASH' + 'NUMBER 4' on

		/* 'LATIN SMALL LETTER A WITH DIAERESIS' decomposes to

		/* 'LATIN SMALL LETTER LJ' can't decompose to

 GREEK ANO TELEIA decomposes to MIDDLE DOT */

 Canonical ordering */

		/* A + 'COMBINING ACUTE ACCENT' + 'COMBINING OGONEK' decomposes

		/* 'LATIN SMALL LETTER A WITH DIAERESIS' + 'COMBINING OGONEK'

		   decomposes to

 UTF-8 strings in this vector _must_ be NULL-terminated. */

 Trivial sequences */

 "ABba" folds to lowercase */

 All ASCII folds to lower-case */

		/* LATIN SMALL LETTER SHARP S folds to

		/* LATIN CAPITAL LETTER A WITH RING ABOVE folds to

 Introduced by UTF-8.0.0. */

	/* Cherokee letters are interesting test-cases because they fold

	   to upper-case.  Before 8.0.0, Cherokee lowercase were

	   undefined, thus, the folding from LC is not stable between

 CHEROKEE SMALL LETTER A folds to CHEROKEE LETTER A */

 CHEROKEE SMALL LETTER YE folds to CHEROKEE LETTER YE */

		/* OLD HUNGARIAN CAPITAL LETTER AMB folds to

 Introduced by UTF-9.0.0. */

		/* OSAGE CAPITAL LETTER CHA folds to

		/* LATIN CAPITAL LETTER SMALL CAPITAL I folds to

 Introduced by UTF-11.0.0. */

		/* GEORGIAN SMALL LETTER AN folds to GEORGIAN MTAVRULI

 Unicode 7.0.0 should be supported. */

 Unicode 9.0.0 should be supported. */

 Unicode 1x.0.0 (the latest version) should be supported. */

 Next versions don't exist. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 SGI.

 * All rights reserved.

/*

 * UTF-8 valid ranges.

 *

 * The UTF-8 encoding spreads the bits of a 32bit word over several

 * bytes. This table gives the ranges that can be held and how they'd

 * be represented.

 *

 * 0x00000000 0x0000007F: 0xxxxxxx

 * 0x00000000 0x000007FF: 110xxxxx 10xxxxxx

 * 0x00000000 0x0000FFFF: 1110xxxx 10xxxxxx 10xxxxxx

 * 0x00000000 0x001FFFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

 * 0x00000000 0x03FFFFFF: 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx

 * 0x00000000 0x7FFFFFFF: 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx

 *

 * There is an additional requirement on UTF-8, in that only the

 * shortest representation of a 32bit value is to be used.  A decoder

 * must not decode sequences that do not satisfy this requirement.

 * Thus the allowed ranges have a lower bound.

 *

 * 0x00000000 0x0000007F: 0xxxxxxx

 * 0x00000080 0x000007FF: 110xxxxx 10xxxxxx

 * 0x00000800 0x0000FFFF: 1110xxxx 10xxxxxx 10xxxxxx

 * 0x00010000 0x001FFFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

 * 0x00200000 0x03FFFFFF: 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx

 * 0x04000000 0x7FFFFFFF: 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx

 *

 * Actual unicode characters are limited to the range 0x0 - 0x10FFFF,

 * 17 planes of 65536 values.  This limits the sequences actually seen

 * even more, to just the following.

 *

 *          0 -     0x7F: 0                   - 0x7F

 *       0x80 -    0x7FF: 0xC2 0x80           - 0xDF 0xBF

 *      0x800 -   0xFFFF: 0xE0 0xA0 0x80      - 0xEF 0xBF 0xBF

 *    0x10000 - 0x10FFFF: 0xF0 0x90 0x80 0x80 - 0xF4 0x8F 0xBF 0xBF

 *

 * Within those ranges the surrogates 0xD800 - 0xDFFF are not allowed.

 *

 * Note that the longest sequence seen with valid usage is 4 bytes,

 * the same a single UTF-32 character.  This makes the UTF-8

 * representation of Unicode strictly smaller than UTF-32.

 *

 * The shortest sequence requirement was introduced by:

 *    Corrigendum #1: UTF-8 Shortest Form

 * It can be found here:

 *    http://www.unicode.org/versions/corrigendum1.html

 *

/*

 * Return the number of bytes used by the current UTF-8 sequence.

 * Assumes the input points to the first byte of a valid UTF-8

 * sequence.

/*

 * Decode a 3-byte UTF-8 sequence.

/*

 * Encode a 3-byte UTF-8 sequence.

/*

 * utf8trie_t

 *

 * A compact binary tree, used to decode UTF-8 characters.

 *

 * Internal nodes are one byte for the node itself, and up to three

 * bytes for an offset into the tree.  The first byte contains the

 * following information:

 *  NEXTBYTE  - flag        - advance to next byte if set

 *  BITNUM    - 3 bit field - the bit number to tested

 *  OFFLEN    - 2 bit field - number of bytes in the offset

 * if offlen == 0 (non-branching node)

 *  RIGHTPATH - 1 bit field - set if the following node is for the

 *                            right-hand path (tested bit is set)

 *  TRIENODE  - 1 bit field - set if the following node is an internal

 *                            node, otherwise it is a leaf node

 * if offlen != 0 (branching node)

 *  LEFTNODE  - 1 bit field - set if the left-hand node is internal

 *  RIGHTNODE - 1 bit field - set if the right-hand node is internal

 *

 * Due to the way utf8 works, there cannot be branching nodes with

 * NEXTBYTE set, and moreover those nodes always have a righthand

 * descendant.

/*

 * utf8leaf_t

 *

 * The leaves of the trie are embedded in the trie, and so the same

 * underlying datatype: unsigned char.

 *

 * leaf[0]: The unicode version, stored as a generation number that is

 *          an index into utf8agetab[].  With this we can filter code

 *          points based on the unicode version in which they were

 *          defined.  The CCC of a non-defined code point is 0.

 * leaf[1]: Canonical Combining Class. During normalization, we need

 *          to do a stable sort into ascending order of all characters

 *          with a non-zero CCC that occur between two characters with

 *          a CCC of 0, or at the begin or end of a string.

 *          The unicode standard guarantees that all CCC values are

 *          between 0 and 254 inclusive, which leaves 255 available as

 *          a special value.

 *          Code points with CCC 0 are known as stoppers.

 * leaf[2]: Decomposition. If leaf[1] == 255, then leaf[2] is the

 *          start of a NUL-terminated string that is the decomposition

 *          of the character.

 *          The CCC of a decomposable character is the same as the CCC

 *          of the first character of its decomposition.

 *          Some characters decompose as the empty string: these are

 *          characters with the Default_Ignorable_Code_Point property.

 *          These do affect normalization, as they all have CCC 0.

 *

 * The decompositions in the trie have been fully expanded, with the

 * exception of Hangul syllables, which are decomposed algorithmically.

 *

 * Casefolding, if applicable, is also done using decompositions.

 *

 * The trie is constructed in such a way that leaves exist for all

 * UTF-8 sequences that match the criteria from the "UTF-8 valid

 * ranges" comment above, and only for those sequences.  Therefore a

 * lookup in the trie can be used to validate the UTF-8 input.

 Marker for hangul syllable decomposition. */

 Size of the synthesized leaf used for Hangul syllable decomposition. */

/*

 * Hangul decomposition (algorithm from Section 3.12 of Unicode 6.3.0)

 *

 * AC00;<Hangul Syllable, First>;Lo;0;L;;;;;N;;;;;

 * D7A3;<Hangul Syllable, Last>;Lo;0;L;;;;;N;;;;;

 *

 * SBase = 0xAC00

 * LBase = 0x1100

 * VBase = 0x1161

 * TBase = 0x11A7

 * LCount = 19

 * VCount = 21

 * TCount = 28

 * NCount = 588 (VCount * TCount)

 * SCount = 11172 (LCount * NCount)

 *

 * Decomposition:

 *   SIndex = s - SBase

 *

 * LV (Canonical/Full)

 *   LIndex = SIndex / NCount

 *   VIndex = (Sindex % NCount) / TCount

 *   LPart = LBase + LIndex

 *   VPart = VBase + VIndex

 *

 * LVT (Canonical)

 *   LVIndex = (SIndex / TCount) * TCount

 *   TIndex = (Sindex % TCount)

 *   LVPart = SBase + LVIndex

 *   TPart = TBase + TIndex

 *

 * LVT (Full)

 *   LIndex = SIndex / NCount

 *   VIndex = (Sindex % NCount) / TCount

 *   TIndex = (Sindex % TCount)

 *   LPart = LBase + LIndex

 *   VPart = VBase + VIndex

 *   if (TIndex == 0) {

 *          d = <LPart, VPart>

 *   } else {

 *          TPart = TBase + TIndex

 *          d = <LPart, TPart, VPart>

 *   }

 Constants */

 Algorithmic decomposition of hangul syllable. */

 Calculate the SI, LI, VI, and TI values. */

 Fill in base of leaf. */

 Add LPart, a 3-byte UTF-8 sequence. */

 Add VPart, a 3-byte UTF-8 sequence. */

 Add TPart if required, also a 3-byte UTF-8 sequence. */

 Terminate string. */

/*

 * Use trie to scan s, touching at most len bytes.

 * Returns the leaf if one exists, NULL otherwise.

 *

 * A non-NULL return guarantees that the UTF-8 sequence starting at s

 * is well-formed and corresponds to a known unicode code point.  The

 * shorthand for this will be "is valid UTF-8 unicode".

 Right leg */

 Right node at offset of trie */

 Right node after this node */

 No right node. */

 Left leg */

 Left node after this node. */

 No left node. */

 Left node after this node */

	/*

	 * Hangul decomposition is done algorithmically. These are the

	 * codepoints >= 0xAC00 and <= 0xD7A3. Their UTF-8 encoding is

	 * always 3 bytes long, so s has been advanced twice, and the

	 * start of the sequence is at s-2.

/*

 * Use trie to scan s.

 * Returns the leaf if one exists, NULL otherwise.

 *

 * Forwards to utf8nlookup().

/*

 * Maximum age of any character in s.

 * Return -1 if s is not valid UTF-8 unicode.

 * Return 0 if only non-assigned code points are used.

/*

 * Minimum age of any character in s.

 * Return -1 if s is not valid UTF-8 unicode.

 * Return 0 if non-assigned code points are used.

/*

 * Maximum age of any character in s, touch at most len bytes.

 * Return -1 if s is not valid UTF-8 unicode.

/*

 * Maximum age of any character in s, touch at most len bytes.

 * Return -1 if s is not valid UTF-8 unicode.

/*

 * Length of the normalization of s.

 * Return -1 if s is not valid UTF-8 unicode.

 *

 * A string of Default_Ignorable_Code_Point has length 0.

/*

 * Length of the normalization of s, touch at most len bytes.

 * Return -1 if s is not valid UTF-8 unicode.

/*

 * Set up an utf8cursor for use by utf8byte().

 *

 *   u8c    : pointer to cursor.

 *   data   : const struct utf8data to use for normalization.

 *   s      : string.

 *   len    : length of s.

 *

 * Returns -1 on error, 0 on success.

 Check we didn't clobber the maximum length. */

 The first byte of s may not be an utf8 continuation. */

/*

 * Set up an utf8cursor for use by utf8byte().

 *

 *   u8c    : pointer to cursor.

 *   data   : const struct utf8data to use for normalization.

 *   s      : NUL-terminated string.

 *

 * Returns -1 on error, 0 on success.

/*

 * Get one byte from the normalized form of the string described by u8c.

 *

 * Returns the byte cast to an unsigned char on succes, and -1 on failure.

 *

 * The cursor keeps track of the location in the string in u8c->s.

 * When a character is decomposed, the current location is stored in

 * u8c->p, and u8c->s is set to the start of the decomposition. Note

 * that bytes from a decomposition do not count against u8c->len.

 *

 * Characters are emitted if they match the current CCC in u8c->ccc.

 * Hitting end-of-string while u8c->ccc == STOPPER means we're done,

 * and the function returns 0 in that case.

 *

 * Sorting by CCC is done by repeatedly scanning the string.  The

 * values of u8c->s and u8c->p are stored in u8c->ss and u8c->sp at

 * the start of the scan.  The first pass finds the lowest CCC to be

 * emitted and stores it in u8c->nccc, the second pass emits the

 * characters with this CCC and finds the next lowest CCC. This limits

 * the number of passes to 1 + the number of different CCCs in the

 * sequence being scanned.

 *

 * Therefore:

 *  u8c->p  != NULL -> a decomposition is being scanned.

 *  u8c->ss != NULL -> this is a repeating scan.

 *  u8c->ccc == -1   -> this is the first scan of a repeating scan.

 Check for the end of a decomposed character. */

 Check for end-of-string. */

 There is no next byte. */

 End-of-string during a scan counts as a stopper. */

 This is a continuation of the current character. */

 Look up the data for the current character. */

 No leaf found implies that the input is a binary blob. */

 Characters that are too new have CCC 0. */

 Empty decomposition implies CCC 0. */

		/*

		 * If this is not a stopper, then see if it updates

		 * the next canonical class to be emitted.

		/*

		 * Return the current byte if this is the current

		 * combining class.

 Current combining class mismatch. */

			/*

			 * Scan forward for the first canonical class

			 * to be emitted.  Save the position from

			 * which to restart.

 Not a stopper, and not the ccc we're emitting. */

 At a stopper, restart for next ccc. */

 All done, proceed from here. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * eCryptfs: Linux filesystem encryption layer

 *

 * Copyright (C) 2008 International Business Machines Corp.

 *   Author(s): Michael A. Halcrow <mhalcrow@us.ibm.com>

/**

 * ecryptfs_miscdev_poll

 * @file: dev file

 * @pt: dev poll table (ignored)

 *

 * Returns the poll mask

/**

 * ecryptfs_miscdev_open

 * @inode: inode of miscdev handle (ignored)

 * @file: file for miscdev handle

 *

 * Returns zero on success; non-zero otherwise

/**

 * ecryptfs_miscdev_release

 * @inode: inode of fs/ecryptfs/euid handle (ignored)

 * @file: file for fs/ecryptfs/euid handle

 *

 * This keeps the daemon registered until the daemon sends another

 * ioctl to fs/ecryptfs/ctl or until the kernel module unregisters.

 *

 * Returns zero on success; non-zero otherwise

/**

 * ecryptfs_send_miscdev

 * @data: Data to send to daemon; may be NULL

 * @data_size: Amount of data to send to daemon

 * @msg_ctx: Message context, which is used to handle the reply. If

 *           this is NULL, then we do not expect a reply.

 * @msg_type: Type of message

 * @msg_flags: Flags for message

 * @daemon: eCryptfs daemon object

 *

 * Add msg_ctx to queue and then, if it exists, notify the blocked

 * miscdevess about the data being available. Must be called with

 * ecryptfs_daemon_hash_mux held.

 *

 * Returns zero on success; non-zero otherwise

/*

 * miscdevfs packet format:

 *  Octet 0: Type

 *  Octets 1-4: network byte order msg_ctx->counter

 *  Octets 5-N0: Size of struct ecryptfs_message to follow

 *  Octets N0-N1: struct ecryptfs_message (including data)

 *

 *  Octets 5-N1 not written if the packet type does not include a message

 4 + ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES comes from tag 65 packet format */

/**

 * ecryptfs_miscdev_read - format and send message from queue

 * @file: miscdevfs handle

 * @buf: User buffer into which to copy the next message on the daemon queue

 * @count: Amount of space available in @buf

 * @ppos: Offset in file (ignored)

 *

 * Pulls the most recent message from the daemon queue, formats it for

 * being sent via a miscdevfs handle, and copies it into @buf

 *

 * Returns the number of bytes copied into the user buffer

 This daemon will not go away so long as this flag is set */

		/* Something else jumped in since the

		 * wait_event_interruptable() and removed the

	/* We do not expect a reply from the userspace daemon for any

/**

 * ecryptfs_miscdev_response - miscdevess response to message previously sent to daemon

 * @daemon: eCryptfs daemon object

 * @data: Bytes comprising struct ecryptfs_message

 * @data_size: sizeof(struct ecryptfs_message) + data len

 * @seq: Sequence number for miscdev response packet

 *

 * Returns zero on success; non-zero otherwise

/**

 * ecryptfs_miscdev_write - handle write to daemon miscdev handle

 * @file: File for misc dev handle

 * @buf: Buffer containing user data

 * @count: Amount of data in @buf

 * @ppos: Pointer to offset in file (ignored)

 *

 * Returns the number of bytes read from @buf

 Likely a harmless MSG_HELO or MSG_QUIT - no packet length */

/**

 * ecryptfs_init_ecryptfs_miscdev

 *

 * Messages sent to the userspace daemon from the kernel are placed on

 * a queue associated with the daemon. The next read against the

 * miscdev handle by that daemon will return the oldest message placed

 * on the message queue for the daemon.

 *

 * Returns zero on success; non-zero otherwise

/**

 * ecryptfs_destroy_ecryptfs_miscdev

 *

 * All of the daemons must be exorcised prior to calling this

 * function.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * eCryptfs: Linux filesystem encryption layer

 *

 * Copyright (C) 1997-2003 Erez Zadok

 * Copyright (C) 2001-2003 Stony Brook University

 * Copyright (C) 2004-2006 International Business Machines Corp.

 *   Author(s): Michael A. Halcrow <mahalcro@us.ibm.com>

/**

 * ecryptfs_d_revalidate - revalidate an ecryptfs dentry

 * @dentry: The ecryptfs dentry

 * @flags: lookup flags

 *

 * Called when the VFS needs to revalidate a dentry. This

 * is called whenever a name lookup finds a dentry in the

 * dcache. Most filesystems leave this as NULL, because all their

 * dentries in the dcache are valid.

 *

 * Returns 1 if valid, 0 otherwise.

 *

/**

 * ecryptfs_d_release

 * @dentry: The ecryptfs dentry

 *

 * Called when a dentry is really deallocated.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * eCryptfs: Linux filesystem encryption layer

 *

 * Copyright (C) 1997-2003 Erez Zadok

 * Copyright (C) 2001-2003 Stony Brook University

 * Copyright (C) 2004-2006 International Business Machines Corp.

 *   Author(s): Michael A. Halcrow <mahalcro@us.ibm.com>

 *              Michael C. Thompson <mcthomps@us.ibm.com>

/**

 * ecryptfs_alloc_inode - allocate an ecryptfs inode

 * @sb: Pointer to the ecryptfs super block

 *

 * Called to bring an inode into existence.

 *

 * Only handle allocation, setting up structures should be done in

 * ecryptfs_read_inode. This is because the kernel, between now and

 * then, will 0 out the private data pointer.

 *

 * Returns a pointer to a newly allocated inode, NULL otherwise

/**

 * ecryptfs_destroy_inode

 * @inode: The ecryptfs inode

 *

 * This is used during the final destruction of the inode.  All

 * allocation of memory related to the inode, including allocated

 * memory in the crypt_stat struct, will be released here.

 * There should be no chance that this deallocation will be missed.

/**

 * ecryptfs_statfs

 * @dentry: The ecryptfs dentry

 * @buf: The struct kstatfs to fill in with stats

 *

 * Get the filesystem statistics. Currently, we let this pass right through

 * to the lower filesystem and take no action ourselves.

/**

 * ecryptfs_evict_inode

 * @inode: The ecryptfs inode

 *

 * Called by iput() when the inode reference count reached zero

 * and the inode is not hashed anywhere.  Used to clear anything

 * that needs to be, before the inode is completely destroyed and put

 * on the inode free list. We use this to drop out reference to the

 * lower inode.

/*

 * ecryptfs_show_options

 *

 * Prints the mount options for a given superblock.

 * Returns zero; does not fail.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * eCryptfs: Linux filesystem encryption layer

 *

 * Copyright (C) 2008 International Business Machines Corp.

 *   Author(s): Michael A. Halcrow <mahalcro@us.ibm.com>

/**

 * ecryptfs_threadfn

 * @ignored: ignored

 *

 * The eCryptfs kernel thread that has the responsibility of getting

 * the lower file with RW permissions.

 *

 * Returns zero on success; non-zero otherwise

/**

 * ecryptfs_privileged_open

 * @lower_file: Result of dentry_open by root on lower dentry

 * @lower_dentry: Lower dentry for file to open

 * @lower_mnt: Lower vfsmount for file to open

 * @cred: credential to use for this call

 *

 * This function gets a r/w file opened against the lower dentry.

 *

 * Returns zero on success; non-zero otherwise

	/* Corresponding dput() and mntput() are done when the

	 * lower file is fput() when all eCryptfs files for the inode are

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * eCryptfs: Linux filesystem encryption layer

 * In-kernel key management code.  Includes functions to parse and

 * write authentication token-related packets with the underlying

 * file.

 *

 * Copyright (C) 2004-2006 International Business Machines Corp.

 *   Author(s): Michael A. Halcrow <mhalcrow@us.ibm.com>

 *              Michael C. Thompson <mcthomps@us.ibm.com>

 *              Trevor S. Highland <trevor.highland@gmail.com>

/*

 * request_key returned an error instead of a valid key address;

 * determine the type of error, make appropriate log entries, and

 * return an error code.

/**

 * ecryptfs_parse_packet_length

 * @data: Pointer to memory containing length at offset

 * @size: This function writes the decoded size to this memory

 *        address; zero on error

 * @length_size: The number of bytes occupied by the encoded length

 *

 * Returns zero on success; non-zero on error

 One-byte length */

 Two-byte length */

 If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */

/**

 * ecryptfs_write_packet_length

 * @dest: The byte array target into which to write the length. Must

 *        have at least ECRYPTFS_MAX_PKT_LEN_SIZE bytes allocated.

 * @size: The length to write.

 * @packet_size_length: The number of bytes used to encode the packet

 *                      length is written to this address.

 *

 * Returns zero on success; non-zero on error.

 If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */

	/*

	 *              ***** TAG 64 Packet Format *****

	 *    | Content Type                       | 1 byte       |

	 *    | Key Identifier Size                | 1 or 2 bytes |

	 *    | Key Identifier                     | arbitrary    |

	 *    | Encrypted File Encryption Key Size | 1 or 2 bytes |

	 *    | Encrypted File Encryption Key      | arbitrary    |

	/*

	 *              ***** TAG 65 Packet Format *****

	 *         | Content Type             | 1 byte       |

	 *         | Status Indicator         | 1 byte       |

	 *         | File Encryption Key Size | 1 or 2 bytes |

	 *         | File Encryption Key      | arbitrary    |

 The decrypted key includes 1 byte cipher code and 2 byte checksum */

	/*

	 *              ***** TAG 66 Packet Format *****

	 *         | Content Type             | 1 byte       |

	 *         | Key Identifier Size      | 1 or 2 bytes |

	 *         | Key Identifier           | arbitrary    |

	 *         | File Encryption Key Size | 1 or 2 bytes |

	 *         | File Encryption Key      | arbitrary    |

 The encrypted key includes 1 byte cipher code and 2 byte checksum */

	/*

	 *              ***** TAG 65 Packet Format *****

	 *    | Content Type                       | 1 byte       |

	 *    | Status Indicator                   | 1 byte       |

	 *    | Encrypted File Encryption Key Size | 1 or 2 bytes |

	 *    | Encrypted File Encryption Key      | arbitrary    |

 verify that everything through the encrypted FEK size is present */

/**

 * ecryptfs_verify_version

 * @version: The version number to confirm

 *

 * Returns zero on good version; non-zero otherwise

/**

 * ecryptfs_verify_auth_tok_from_key

 * @auth_tok_key: key containing the authentication token

 * @auth_tok: authentication token

 *

 * Returns zero on valid auth tok; -EINVAL if the payload is invalid; or

 * -EKEYREVOKED if the key was revoked before we acquired its semaphore.

/**

 * ecryptfs_find_auth_tok_for_sig

 * @auth_tok_key: key containing the authentication token

 * @auth_tok: Set to the matching auth_tok; NULL if not found

 * @mount_crypt_stat: inode crypt_stat crypto context

 * @sig: Sig of auth_tok to find

 *

 * For now, this function simply looks at the registered auth_tok's

 * linked off the mount_crypt_stat, so all the auth_toks that can be

 * used must be registered at mount time. This function could

 * potentially try a lot harder to find auth_tok's (e.g., by calling

 * out to ecryptfsd to dynamically retrieve an auth_tok object) so

 * that static registration of auth_tok's will no longer be necessary.

 *

 * Returns zero on no error; non-zero on error

		/* if the flag ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY is set in the

		 * mount_crypt_stat structure, we prevent to use auth toks that

		 * are not inserted through the ecryptfs_add_global_auth_tok

		 * function.

/*

 * write_tag_70_packet can gobble a lot of stack space. We stuff most

 * of the function's parameters in a kmalloc'd struct to help reduce

 * eCryptfs' overall stack usage.

/*

 * write_tag_70_packet - Write encrypted filename (EFN) packet against FNEK

 * @filename: NULL-terminated filename string

 *

 * This is the simplest mechanism for achieving filename encryption in

 * eCryptfs. It encrypts the given filename with the mount-wide

 * filename encryption key (FNEK) and stores it in a packet to @dest,

 * which the callee will encode and write directly into the dentry

 * name.

	/* Plus one for the \0 separator between the random prefix

	/* Octet 0: Tag 70 identifier

	 * Octets 1-N1: Tag 70 packet size (includes cipher identifier

	 *              and block-aligned encrypted filename size)

	 * Octets N1-N2: FNEK sig (ECRYPTFS_SIG_SIZE)

	 * Octet N2-N3: Cipher identifier (1 octet)

	 * Octets N3-N4: Block-aligned encrypted filename

	 *  - Consists of a minimum number of random characters, a \0

 Cipher code */

	/* TODO: Support other key modules than passphrase for

	/* The characters in the first block effectively do the job

	 * of the IV here, so we just use 0's for the IV. Note the

	 * constraint that ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES

/**

 * ecryptfs_parse_tag_70_packet - Parse and process FNEK-encrypted passphrase packet

 * @filename: This function kmalloc's the memory for the filename

 * @filename_size: This function sets this to the amount of memory

 *                 kmalloc'd for the filename

 * @packet_size: This function sets this to the the number of octets

 *               in the packet parsed

 * @mount_crypt_stat: The mount-wide cryptographic context

 * @data: The memory location containing the start of the tag 70

 *        packet

 * @max_packet_size: The maximum legal size of the packet to be parsed

 *                   from @data

 *

 * Returns zero on success; non-zero otherwise

	/* Octet 0: Tag 70 identifier

	 * Octets 1-N1: Tag 70 packet size (includes cipher identifier

	 *              and block-aligned encrypted filename size)

	 * Octets N1-N2: FNEK sig (ECRYPTFS_SIG_SIZE)

	 * Octet N2-N3: Cipher identifier (1 octet)

	 * Octets N3-N4: Block-aligned encrypted filename

	 *  - Consists of a minimum number of random numbers, a \0

	/* The characters in the first block effectively do the job of

	 * the IV here, so we just use 0's for the IV. Note the

	 * constraint that ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES

	/* TODO: Support other key modules than passphrase for

/**

 * decrypt_pki_encrypted_session_key - Decrypt the session key with the given auth_tok.

 * @auth_tok: The key authentication token used to decrypt the session key

 * @crypt_stat: The cryptographic context

 *

 * Returns zero on success; non-zero error otherwise.

/**

 * parse_tag_1_packet

 * @crypt_stat: The cryptographic context to modify based on packet contents

 * @data: The raw bytes of the packet.

 * @auth_tok_list: eCryptfs parses packets into authentication tokens;

 *                 a new authentication token will be placed at the

 *                 end of this list for this packet.

 * @new_auth_tok: Pointer to a pointer to memory that this function

 *                allocates; sets the memory address of the pointer to

 *                NULL on error. This object is added to the

 *                auth_tok_list.

 * @packet_size: This function writes the size of the parsed packet

 *               into this memory location; zero on error.

 * @max_packet_size: The maximum allowable packet size

 *

 * Returns zero on success; non-zero on error.

	/**

	 * This format is inspired by OpenPGP; see RFC 2440

	 * packet tag 1

	 *

	 * Tag 1 identifier (1 byte)

	 * Max Tag 1 packet size (max 3 bytes)

	 * Version (1 byte)

	 * Key identifier (8 bytes; ECRYPTFS_SIG_SIZE)

	 * Cipher identifier (1 byte)

	 * Encrypted key size (arbitrary)

	 *

	 * 12 bytes minimum packet size

	/* Released: wipe_auth_tok_list called in ecryptfs_parse_packet_set or

	/* This byte is skipped because the kernel does not need to

/**

 * parse_tag_3_packet

 * @crypt_stat: The cryptographic context to modify based on packet

 *              contents.

 * @data: The raw bytes of the packet.

 * @auth_tok_list: eCryptfs parses packets into authentication tokens;

 *                 a new authentication token will be placed at the end

 *                 of this list for this packet.

 * @new_auth_tok: Pointer to a pointer to memory that this function

 *                allocates; sets the memory address of the pointer to

 *                NULL on error. This object is added to the

 *                auth_tok_list.

 * @packet_size: This function writes the size of the parsed packet

 *               into this memory location; zero on error.

 * @max_packet_size: maximum number of bytes to parse

 *

 * Returns zero on success; non-zero on error.

	/**

	 *This format is inspired by OpenPGP; see RFC 2440

	 * packet tag 3

	 *

	 * Tag 3 identifier (1 byte)

	 * Max Tag 3 packet size (max 3 bytes)

	 * Version (1 byte)

	 * Cipher code (1 byte)

	 * S2K specifier (1 byte)

	 * Hash identifier (1 byte)

	 * Salt (ECRYPTFS_SALT_SIZE)

	 * Hash iterations (1 byte)

	 * Encrypted key (arbitrary)

	 *

	 * (ECRYPTFS_SALT_SIZE + 7) minimum packet size

	/* Released: wipe_auth_tok_list called in ecryptfs_parse_packet_set or

	/* A little extra work to differentiate among the AES key

 TODO: finish the hash mapping */

 See RFC2440 for these numbers and their mappings */

 Choose MD5 */

 This conversion was taken straight from RFC2440 */

		/* Friendly reminder:

		 * (*new_auth_tok)->session_key.encrypted_key_size =

 MD5 */

	/* TODO: Parametarize; we might actually want userspace to

/**

 * parse_tag_11_packet

 * @data: The raw bytes of the packet

 * @contents: This function writes the data contents of the literal

 *            packet into this memory location

 * @max_contents_bytes: The maximum number of bytes that this function

 *                      is allowed to write into contents

 * @tag_11_contents_size: This function writes the size of the parsed

 *                        contents into this memory location; zero on

 *                        error

 * @packet_size: This function writes the size of the parsed packet

 *               into this memory location; zero on error

 * @max_packet_size: maximum number of bytes to parse

 *

 * Returns zero on success; non-zero on error.

	/* This format is inspired by OpenPGP; see RFC 2440

	 * packet tag 11

	 *

	 * Tag 11 identifier (1 byte)

	 * Max Tag 11 packet size (max 3 bytes)

	 * Binary format specifier (1 byte)

	 * Filename length (1 byte)

	 * Filename ("_CONSOLE") (8 bytes)

	 * Modification date (4 bytes)

	 * Literal data (arbitrary)

	 *

	 * We need at least 16 bytes of data for the packet to even be

	 * valid.

 Ignore filename and modification date */

/**

 * decrypt_passphrase_encrypted_session_key - Decrypt the session key with the given auth_tok.

 * @auth_tok: The passphrase authentication token to use to encrypt the FEK

 * @crypt_stat: The cryptographic context

 *

 * Returns zero on success; non-zero error otherwise

/**

 * ecryptfs_parse_packet_set

 * @crypt_stat: The cryptographic context

 * @src: Virtual address of region of memory containing the packets

 * @ecryptfs_dentry: The eCryptfs dentry associated with the packet set

 *

 * Get crypt_stat to have the file's session key if the requisite key

 * is available to decrypt the session key.

 *

 * Returns Zero if a valid authentication token was retrieved and

 * processed; negative value for file not encrypted or for error

 * conditions.

	/* Parse the header to find as many packets as we can; these will be

	/* auth_tok_list contains the set of authentication tokens

	 * parsed from the metadata. We need to find a matching

	 * authentication token that has the secret component(s)

	 * necessary to decrypt the EFEK in the auth_tok parsed from

	 * the metadata. There may be several potential matches, but

/**

 * write_tag_1_packet - Write an RFC2440-compatible tag 1 (public key) packet

 * @dest: Buffer into which to write the packet

 * @remaining_bytes: Maximum number of bytes that can be writtn

 * @auth_tok_key: The authentication token key to unlock and put when done with

 *                @auth_tok

 * @auth_tok: The authentication token used for generating the tag 1 packet

 * @crypt_stat: The cryptographic context

 * @key_rec: The key record struct for the tag 1 packet

 * @packet_size: This function will write the number of bytes that end

 *               up constituting the packet; set to zero on error

 *

 * Returns zero on success; non-zero on error.

	/* This format is inspired by OpenPGP; see RFC 2440

 Tag 1 identifier */

 Max Tag 1 packet size */

 Version */

 Key identifier */

 Cipher identifier */

 Encrypted key size */

 version 3 */

/**

 * write_tag_11_packet

 * @dest: Target into which Tag 11 packet is to be written

 * @remaining_bytes: Maximum packet length

 * @contents: Byte array of contents to copy in

 * @contents_length: Number of bytes in contents

 * @packet_length: Length of the Tag 11 packet written; zero on error

 *

 * Returns zero on success; non-zero on error.

	/* This format is inspired by OpenPGP; see RFC 2440

 Tag 11 identifier */

 Max Tag 11 packet size */

 Binary format specifier */

 Filename length */

 Filename ("_CONSOLE") */

 Modification date */

 Literal data */

 binary data format specifier */

/**

 * write_tag_3_packet

 * @dest: Buffer into which to write the packet

 * @remaining_bytes: Maximum number of bytes that can be written

 * @auth_tok: Authentication token

 * @crypt_stat: The cryptographic context

 * @key_rec: encrypted key

 * @packet_size: This function will write the number of bytes that end

 *               up constituting the packet; set to zero on error

 *

 * Returns zero on success; non-zero on error.

	/* This format is inspired by OpenPGP; see RFC 2440

 Tag 3 identifier */

 Max Tag 3 packet size */

 Version */

 Cipher code */

 S2K specifier */

 Hash identifier */

 Salt */

 Hash iterations */

 Encrypted key size */

	/* Chop off the Tag 3 identifier(1) and Tag 3 packet size(3)

 version 4 */

	/* TODO: Break from RFC2440 so that arbitrary ciphers can be

 S2K */

 MD5 (TODO: parameterize) */

 salt */

 hash iterations (65536) */

/**

 * ecryptfs_generate_key_packet_set

 * @dest_base: Virtual address from which to write the key record set

 * @crypt_stat: The cryptographic context from which the

 *              authentication tokens will be retrieved

 * @ecryptfs_dentry: The dentry, used to retrieve the mount crypt stat

 *                   for the global parameters

 * @len: The amount written

 * @max: The maximum amount of data allowed to be written

 *

 * Generates a key packet set and writes it to the virtual address

 * passed in.

 *

 * Returns zero on success; non-zero on error.

 Write auth tok signature packet */

 Caller must hold keysig_list_mutex */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * eCryptfs: Linux filesystem encryption layer

 *

 * Copyright (C) 1997-2004 Erez Zadok

 * Copyright (C) 2001-2004 Stony Brook University

 * Copyright (C) 2004-2007 International Business Machines Corp.

 *   Author(s): Michael A. Halcrow <mahalcro@us.ibm.com>

 *              Michael C. Thompsion <mcthomps@us.ibm.com>

 i_size will be overwritten for encrypted regular files */

/**

 * ecryptfs_interpose

 * @lower_dentry: Existing dentry in the lower filesystem

 * @dentry: ecryptfs' dentry

 * @sb: ecryptfs's super_block

 *

 * Interposes upper and lower dentries.

 *

 * Returns zero on success; non-zero otherwise

 don't even try to make the lower negative

/**

 * ecryptfs_do_create

 * @directory_inode: inode of the new file's dentry's parent in ecryptfs

 * @ecryptfs_dentry: New file's dentry in ecryptfs

 * @mode: The mode of the new file

 *

 * Creates the underlying file and the eCryptfs inode which will link to

 * it. It will also update the eCryptfs directory inode to mimic the

 * stat of the lower directory inode.

 *

 * Returns the new eCryptfs inode on success; an ERR_PTR on error condition

/*

 * ecryptfs_initialize_file

 *

 * Cause the file to be changed from a basic empty file to an ecryptfs

 * file with a header and first data page.

 *

 * Returns zero on success

/*

 * ecryptfs_create

 * @mode: The mode of the new file.

 *

 * Creates a new file.

 *

 * Returns zero on success; non-zero on error condition

	/* At this point, a file exists on "disk"; we need to make sure

 TODO: lock for crypt_stat comparison */

 Must return 0 to allow non-eCryptfs files to be looked up, too */

/*

 * ecryptfs_lookup_interpose - Dentry interposition for a lookup

	/*

	 * negative dentry can go positive under us here - its parent is not

	 * locked.  That's OK and that could happen just as we return from

	 * ecryptfs_lookup() anyway.  Just need to be careful and fetch

	 * ->d_inode only once - it's not stable here.

 We want to add because we couldn't find in lower */

/**

 * ecryptfs_lookup

 * @ecryptfs_dir_inode: The eCryptfs directory inode

 * @ecryptfs_dentry: The eCryptfs dentry that we are looking up

 * @flags: lookup flags

 *

 * Find a file on disk. If the file does not exist, then we'll add it to the

 * dentry cache and continue on to read it from the disk.

 don't even try to make the lower negative

 source should not be ancestor of target */

 target should not be ancestor of source */

/**

 * upper_size_to_lower_size

 * @crypt_stat: Crypt_stat associated with file

 * @upper_size: Size of the upper file

 *

 * Calculate the required size of the lower file based on the

 * specified size of the upper file. This calculation is based on the

 * number of headers in the underlying file and the extent size.

 *

 * Returns Calculated size of the lower file.

/**

 * truncate_upper

 * @dentry: The ecryptfs layer dentry

 * @ia: Address of the ecryptfs inode's attributes

 * @lower_ia: Address of the lower inode's attributes

 *

 * Function to handle truncations modifying the size of the file. Note

 * that the file sizes are interpolated. When expanding, we are simply

 * writing strings of 0's out. When truncating, we truncate the upper

 * inode and update the lower_ia according to the page index

 * interpolations. If ATTR_SIZE is set in lower_ia->ia_valid upon return,

 * the caller must use lower_ia in a call to notify_change() to perform

 * the truncation of the lower inode.

 *

 * Returns zero on success; non-zero otherwise

 Switch on growing or shrinking file */

		/* Write a single 0 at the last position of the file;

		 * this triggers code that will fill in 0's throughout

		 * the intermediate portion of the previous end of the

 ia->ia_size < i_size_read(inode) */

		/* We're chopping off all the pages down to the page

		 * in which ia->ia_size is located. Fill in the end of

		 * that page from (ia->ia_size & ~PAGE_MASK) to

		/* We are reducing the size of the ecryptfs file, and need to

		/*

		 * The eCryptfs inode and the new *lower* size are mixed here

		 * because we may not have the lower i_mutex held and/or it may

		 * not be appropriate to call inode_newsize_ok() with inodes

		 * from other filesystems.

/**

 * ecryptfs_truncate

 * @dentry: The ecryptfs layer dentry

 * @new_length: The length to expand the file to

 *

 * Simple function that handles the truncation of an eCryptfs inode and

 * its corresponding lower inode.

 *

 * Returns zero on success; non-zero otherwise

/**

 * ecryptfs_setattr

 * @mnt_userns: user namespace of the target mount

 * @dentry: dentry handle to the inode to modify

 * @ia: Structure with flags of what to change and values

 *

 * Updates the metadata of an inode. If the update is to the size

 * i.e. truncation, then ecryptfs_truncate will handle the size modification

 * of both the ecryptfs inode and the lower inode.

 *

 * All other metadata changes will be passed right to the lower filesystem,

 * and we will just update our inode to look like the lower.

	/*

	 * mode change is for clearing setuid/setgid bits. Allow lower fs

	 * to interpret this in its own way.

 match anything */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * eCryptfs: Linux filesystem encryption layer

 *

 * Copyright (C) 1997-2004 Erez Zadok

 * Copyright (C) 2001-2004 Stony Brook University

 * Copyright (C) 2004-2007 International Business Machines Corp.

 *   Author(s): Michael A. Halcrow <mahalcro@us.ibm.com>

 *   		Michael C. Thompson <mcthomps@us.ibm.com>

/**

 * ecryptfs_from_hex

 * @dst: Buffer to take the bytes from src hex; must be at least of

 *       size (src_size / 2)

 * @src: Buffer to be converted from a hex string representation to raw value

 * @dst_size: size of dst buffer, or number of hex characters pairs to convert

/**

 * ecryptfs_calculate_md5 - calculates the md5 of @src

 * @dst: Pointer to 16 bytes of allocated memory

 * @crypt_stat: Pointer to crypt_stat struct for the current inode

 * @src: Data to be md5'd

 * @len: Length of @src

 *

 * Uses the allocated crypto context that crypt_stat references to

 * generate the MD5 sum of the contents of src.

/**

 * ecryptfs_derive_iv

 * @iv: destination for the derived iv vale

 * @crypt_stat: Pointer to crypt_stat struct for the current inode

 * @offset: Offset of the extent whose IV we are to derive

 *

 * Generate the initialization vector from the given root IV and page

 * offset.

 *

 * Returns zero on success; non-zero on error.

	/* TODO: It is probably secure to just cast the least

	 * significant bits of the root IV into an unsigned long and

	 * add the offset to that rather than go through all this

/**

 * ecryptfs_init_crypt_stat

 * @crypt_stat: Pointer to the crypt_stat struct to initialize.

 *

 * Initialize the crypt_stat structure.

/**

 * ecryptfs_destroy_crypt_stat

 * @crypt_stat: Pointer to the crypt_stat struct to initialize.

 *

 * Releases all memory associated with a crypt_stat struct.

/**

 * virt_to_scatterlist

 * @addr: Virtual address

 * @size: Size of data; should be an even multiple of the block size

 * @sg: Pointer to scatterlist array; set to NULL to obtain only

 *      the number of scatterlist structs required in array

 * @sg_size: Max array size

 *

 * Fills in a scatterlist array with page references for a passed

 * virtual address.

 *

 * Returns the number of scatterlist structs in array used

/**

 * crypt_scatterlist

 * @crypt_stat: Pointer to the crypt_stat struct to initialize.

 * @dst_sg: Destination of the data after performing the crypto operation

 * @src_sg: Data to be encrypted or decrypted

 * @size: Length of data

 * @iv: IV to use

 * @op: ENCRYPT or DECRYPT to indicate the desired operation

 *

 * Returns the number of bytes encrypted or decrypted; negative value on error

 Consider doing this once, when the file is opened */

/*

 * lower_offset_for_page

 *

 * Convert an eCryptfs page index into a lower byte offset

/**

 * crypt_extent

 * @crypt_stat: crypt_stat containing cryptographic context for the

 *              encryption operation

 * @dst_page: The page to write the result into

 * @src_page: The page to read from

 * @extent_offset: Page extent offset for use in generating IV

 * @op: ENCRYPT or DECRYPT to indicate the desired operation

 *

 * Encrypts or decrypts one extent of data.

 *

 * Return zero on success; non-zero otherwise

/**

 * ecryptfs_encrypt_page

 * @page: Page mapped from the eCryptfs inode for the file; contains

 *        decrypted content that needs to be encrypted (to a temporary

 *        page; not in place) and written out to the lower file

 *

 * Encrypt an eCryptfs page. This is done on a per-extent basis. Note

 * that eCryptfs pages may straddle the lower pages -- for instance,

 * if the file was created on a machine with an 8K page size

 * (resulting in an 8K header), and then the file is copied onto a

 * host with a 32K page size, then when reading page 0 of the eCryptfs

 * file, 24K of page 0 of the lower file will be read and decrypted,

 * and then 8K of page 1 of the lower file will be read and decrypted.

 *

 * Returns zero on success; negative on error

/**

 * ecryptfs_decrypt_page

 * @page: Page mapped from the eCryptfs inode for the file; data read

 *        and decrypted from the lower file will be written into this

 *        page

 *

 * Decrypt an eCryptfs page. This is done on a per-extent basis. Note

 * that eCryptfs pages may straddle the lower pages -- for instance,

 * if the file was created on a machine with an 8K page size

 * (resulting in an 8K header), and then the file is copied onto a

 * host with a 32K page size, then when reading page 0 of the eCryptfs

 * file, 24K of page 0 of the lower file will be read and decrypted,

 * and then 8K of page 1 of the lower file will be read and decrypted.

 *

 * Returns zero on success; negative on error

/**

 * ecryptfs_init_crypt_ctx

 * @crypt_stat: Uninitialized crypt stats structure

 *

 * Initialize the crypto context.

 *

 * TODO: Performance: Keep a cache of initialized cipher contexts;

 * only init if needed

	/* Default values; may be overwritten as we are parsing the

/*

 * ecryptfs_compute_root_iv

 *

 * On error, sets the root IV to all 0's.

/**

 * ecryptfs_copy_mount_wide_flags_to_inode_flags

 * @crypt_stat: The inode's cryptographic context

 * @mount_crypt_stat: The mount point's cryptographic context

 *

 * This function propagates the mount-wide flags to individual inode

 * flags.

/**

 * ecryptfs_set_default_crypt_stat_vals

 * @crypt_stat: The inode's cryptographic context

 * @mount_crypt_stat: The mount point's cryptographic context

 *

 * Default values in the event that policy does not override them.

/**

 * ecryptfs_new_file_context

 * @ecryptfs_inode: The eCryptfs inode

 *

 * If the crypto context for the file has not yet been established,

 * this is where we do that.  Establishing a new crypto context

 * involves the following decisions:

 *  - What cipher to use?

 *  - What set of authentication tokens to use?

 * Here we just worry about getting enough information into the

 * authentication tokens so that we know that they are available.

 * We associate the available authentication tokens with the new file

 * via the set of signatures in the crypt_stat struct.  Later, when

 * the headers are actually written out, we may again defer to

 * userspace to perform the encryption of the session key; for the

 * foreseeable future, this will be the case with public key packets.

 *

 * Returns zero on success; non-zero otherwise

/**

 * ecryptfs_validate_marker - check for the ecryptfs marker

 * @data: The data block in which to check

 *

 * Returns zero if marker found; -EINVAL if not found

 Add support for additional flags by adding elements here. */

/**

 * ecryptfs_process_flags

 * @crypt_stat: The cryptographic context

 * @page_virt: Source data to be parsed

 * @bytes_read: Updated with the number of bytes read

 Version is in top 8 bits of the 32-bit flag vector */

/**

 * write_ecryptfs_marker

 * @page_virt: The pointer to in a page to begin writing the marker

 * @written: Number of bytes written

 *

 * Marker = 0x3c81b7f5

 Version is in top 8 bits of the 32-bit flag vector */

/* Add support for additional ciphers by adding elements here. The

 * cipher_code is whatever OpenPGP applications use to identify the

/**

 * ecryptfs_code_for_cipher_string

 * @cipher_name: The string alias for the cipher

 * @key_bytes: Length of key in bytes; used for AES code selection

 *

 * Returns zero on no match, or the cipher code on match

/**

 * ecryptfs_cipher_code_to_string

 * @str: Destination to write out the cipher name

 * @cipher_code: The code to convert to cipher name string

 *

 * Returns zero on success

/**

 * ecryptfs_write_headers_virt

 * @page_virt: The virtual address to write the headers to

 * @max: The size of memory allocated at page_virt

 * @size: Set to the number of bytes written by this function

 * @crypt_stat: The cryptographic context

 * @ecryptfs_dentry: The eCryptfs dentry

 *

 * Format version: 1

 *

 *   Header Extent:

 *     Octets 0-7:        Unencrypted file size (big-endian)

 *     Octets 8-15:       eCryptfs special marker

 *     Octets 16-19:      Flags

 *      Octet 16:         File format version number (between 0 and 255)

 *      Octets 17-18:     Reserved

 *      Octet 19:         Bit 1 (lsb): Reserved

 *                        Bit 2: Encrypted?

 *                        Bits 3-8: Reserved

 *     Octets 20-23:      Header extent size (big-endian)

 *     Octets 24-25:      Number of header extents at front of file

 *                        (big-endian)

 *     Octet  26:         Begin RFC 2440 authentication token packet set

 *   Data Extent 0:

 *     Lower data (CBC encrypted)

 *   Data Extent 1:

 *     Lower data (CBC encrypted)

 *   ...

 *

 * Returns zero on success

/**

 * ecryptfs_write_metadata

 * @ecryptfs_dentry: The eCryptfs dentry, which should be negative

 * @ecryptfs_inode: The newly created eCryptfs inode

 *

 * Write the file headers out.  This will likely involve a userspace

 * callout, in which the session key is encrypted with one or more

 * public keys and/or the passphrase necessary to do the encryption is

 * retrieved via a prompt.  Exactly what happens at this point should

 * be policy-dependent.

 *

 * Returns zero on success; non-zero on error

 Released in this function */

 Zeroed page ensures the in-header unencrypted i_size is set to 0 */

/**

 * set_default_header_data

 * @crypt_stat: The cryptographic context

 *

 * For version 0 file format; this function is only for backwards

 * compatibility for files created with the prior versions of

 * eCryptfs.

/**

 * ecryptfs_read_headers_virt

 * @page_virt: The virtual address into which to read the headers

 * @crypt_stat: The cryptographic context

 * @ecryptfs_dentry: The eCryptfs dentry

 * @validate_header_size: Whether to validate the header size while reading

 *

 * Read/parse the header data. The header format is detailed in the

 * comment block for the ecryptfs_write_headers_virt() function.

 *

 * Returns zero on success

/**

 * ecryptfs_read_xattr_region

 * @page_virt: The vitual address into which to read the xattr data

 * @ecryptfs_inode: The eCryptfs inode

 *

 * Attempts to read the crypto metadata from the extended attribute

 * region of the lower file.

 *

 * Returns zero on success; non-zero on error

/*

 * ecryptfs_read_metadata

 *

 * Common entry point for reading file metadata. From here, we could

 * retrieve the header information from the header region of the file,

 * the xattr region of the file, or some other repository that is

 * stored separately from the file itself. The current implementation

 * supports retrieving the metadata information from the file contents

 * and from the xattr region.

 *

 * Returns zero if valid headers found and parsed; non-zero otherwise

 Read the first page from the underlying file */

 metadata is not in the file header, so try xattrs */

/*

 * ecryptfs_encrypt_filename - encrypt filename

 *

 * CBC-encrypts the filename. We do not want to encrypt the same

 * filename with the same key and IV, which may happen with hard

 * links, so we prepend random bits to each filename.

 *

 * Returns zero on success; non-zero otherwise

	(*copied_name)[(name_size)] = '\0';	/* Only for convenience

						 * in printing out the

						 * string in debug

/**

 * ecryptfs_process_key_cipher - Perform key cipher initialization.

 * @key_tfm: Crypto context for key material, set by this function

 * @cipher_name: Name of the cipher

 * @key_size: Size of the key in bytes

 *

 * Returns zero on success. Any crypto_tfm structs allocated here

 * should be released by other functions, such as on a superblock put

 * event, regardless of whether this function succeeds for fails.

/**

 * ecryptfs_destroy_crypto - free all cached key_tfms on key_tfm_list

 *

 * Called only at module unload time

/**

 * ecryptfs_tfm_exists - Search for existing tfm for cipher_name.

 * @cipher_name: the name of the cipher to search for

 * @key_tfm: set to corresponding tfm if found

 *

 * Searches for cached key_tfm matching @cipher_name

 * Must be called with &key_tfm_list_mutex held

 * Returns 1 if found, with @key_tfm set

 * Returns 0 if not found, with @key_tfm set to NULL

/**

 * ecryptfs_get_tfm_and_mutex_for_cipher_name

 *

 * @tfm: set to cached tfm found, or new tfm created

 * @tfm_mutex: set to mutex for cached tfm found, or new tfm created

 * @cipher_name: the name of the cipher to search for and/or add

 *

 * Sets pointers to @tfm & @tfm_mutex matching @cipher_name.

 * Searches for cached item first, and creates new if not found.

 * Returns 0 on success, non-zero if adding new cipher failed

 64 characters forming a 6-bit target field */

/* We could either offset on every reverse map or just pad some 0x00's

 7 */

 15 */

 23 */

 31 */

 39 */

 47 */

 55 */

 63 */

 71 */

 79 */

 87 */

 95 */

 103 */

 111 */

 119 */

 123 - 255 initialized to 0x00 */

/**

 * ecryptfs_encode_for_filename

 * @dst: Destination location for encoded filename

 * @dst_size: Size of the encoded filename in bytes

 * @src: Source location for the filename to encode

 * @src_size: Size of the source in bytes

	/* Not exact; conservatively long. Every block of 4

	 * encoded characters decodes into a block of 3

	 * decoded characters. This segment of code provides

	 * the caller with the maximum amount of allocated

	 * space that @dst will need to point to in a

/**

 * ecryptfs_decode_from_filename

 * @dst: If NULL, this function only sets @dst_size and returns. If

 *       non-NULL, this function decodes the encoded octets in @src

 *       into the memory that @dst points to.

 * @dst_size: Set to the size of the decoded string.

 * @src: The encoded set of octets to decode.

 * @src_size: The size of the encoded set of octets to decode.

/**

 * ecryptfs_encrypt_and_encode_filename - converts a plaintext file name to cipher text

 * @encoded_name: The encrypted name

 * @encoded_name_size: Length of the encrypted name

 * @mount_crypt_stat: The crypt_stat struct associated with the file name to encode

 * @name: The plaintext name

 * @name_size: The length of the plaintext name

 *

 * Encrypts and encodes a filename into something that constitutes a

 * valid filename for a filesystem, with printable characters.

 *

 * We assume that we have a properly initialized crypto context,

 * pointed to by crypt_stat->tfm.

 *

 * Returns zero on success; non-zero on otherwise

/**

 * ecryptfs_decode_and_decrypt_filename - converts the encoded cipher text name to decoded plaintext

 * @plaintext_name: The plaintext name

 * @plaintext_name_size: The plaintext name size

 * @sb: Ecryptfs's super_block

 * @name: The filename in cipher text

 * @name_size: The cipher text name size

 *

 * Decrypts and decodes the filename.

 *

 * Returns zero on error; non-zero otherwise

 Return an exact amount for the common cases */

 Return a safe estimate for the uncommon cases */

 Since this is the max decoded size, subtract 1 "decoded block" len */

 Worst case is that the filename is padded nearly a full block size */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * eCryptfs: Linux filesystem encryption layer

 * This is where eCryptfs coordinates the symmetric encryption and

 * decryption of the file data as it passes between the lower

 * encrypted file and the upper decrypted file.

 *

 * Copyright (C) 1997-2003 Erez Zadok

 * Copyright (C) 2001-2003 Stony Brook University

 * Copyright (C) 2004-2007 International Business Machines Corp.

 *   Author(s): Michael A. Halcrow <mahalcro@us.ibm.com>

/*

 * ecryptfs_get_locked_page

 *

 * Get one page from cache or lower f/s, return error otherwise.

 *

 * Returns locked and up-to-date page (if ok), with increased

 * refcnt.

/**

 * ecryptfs_writepage

 * @page: Page that is locked before this call is made

 * @wbc: Write-back control structure

 *

 * Returns zero on success; non-zero otherwise

 *

 * This is where we encrypt the data and pass the encrypted data to

 * the lower filesystem.  In OpenPGP-compatible mode, we operate on

 * entire underlying packets.

/*

 *   Header Extent:

 *     Octets 0-7:        Unencrypted file size (big-endian)

 *     Octets 8-15:       eCryptfs special marker

 *     Octets 16-19:      Flags

 *      Octet 16:         File format version number (between 0 and 255)

 *      Octets 17-18:     Reserved

 *      Octet 19:         Bit 1 (lsb): Reserved

 *                        Bit 2: Encrypted?

 *                        Bits 3-8: Reserved

 *     Octets 20-23:      Header extent size (big-endian)

 *     Octets 24-25:      Number of header extents at front of file

 *                        (big-endian)

 *     Octet  26:         Begin RFC 2440 authentication token packet set

/**

 * ecryptfs_copy_up_encrypted_with_header

 * @page: Sort of a ``virtual'' representation of the encrypted lower

 *        file. The actual lower file does not have the metadata in

 *        the header. This is locked.

 * @crypt_stat: The eCryptfs inode's cryptographic context

 *

 * The ``view'' is the version of the file that userspace winds up

 * seeing, with the header information inserted.

 This is a header extent */

 TODO: Support more than one header extent */

 This is an encrypted data extent */

/**

 * ecryptfs_readpage

 * @file: An eCryptfs file

 * @page: Page from eCryptfs inode mapping into which to stick the read data

 *

 * Read in a page, decrypting if necessary.

 *

 * Returns zero on success; non-zero on error.

/*

 * Called with lower inode mutex held.

/**

 * ecryptfs_write_begin

 * @file: The eCryptfs file

 * @mapping: The eCryptfs object

 * @pos: The file offset at which to start writing

 * @len: Length of the write

 * @flags: Various flags

 * @pagep: Pointer to return the page

 * @fsdata: Pointer to return fs data (unused)

 *

 * This function must zero any hole we create

 *

 * Returns zero on success; non-zero otherwise

	/* If creating a page or more of holes, zero them out via truncate.

	/* Writing to a new page, and creating a small hole from start

/*

 * ecryptfs_write_inode_size_to_header

 *

 * Writes the lower file size to the first 8 bytes of the header.

 *

 * Returns zero on success; non-zero on error.

/**

 * ecryptfs_write_end

 * @file: The eCryptfs file object

 * @mapping: The eCryptfs object

 * @pos: The file position

 * @len: The length of the data (unused)

 * @copied: The amount of data copied

 * @page: The eCryptfs page

 * @fsdata: The fsdata (unused)

 Fills in zeros if 'to' goes beyond inode size */

	/*

	 * XXX: This is pretty broken for multiple reasons: ecryptfs does not

	 * actually use buffer_heads, and ecryptfs will crash without

	 * CONFIG_BLOCK.  But it matches the behavior before the default for

	 * address_space_operations without the ->set_page_dirty method was

	 * cleaned up, so this is the best we can do without maintainer

	 * feedback.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * eCryptfs: Linux filesystem encryption layer

 *

 * Copyright (C) 1997-2004 Erez Zadok

 * Copyright (C) 2001-2004 Stony Brook University

 * Copyright (C) 2004-2007 International Business Machines Corp.

 *   Author(s): Michael A. Halcrow <mhalcrow@us.ibm.com>

 *   		Michael C. Thompson <mcthomps@us.ibm.com>

/*

 * ecryptfs_read_update_atime

 *

 * generic_file_read updates the atime of upper layer inode.  But, it

 * doesn't give us a chance to update the atime of the lower layer

 * inode.  This function is a wrapper to generic_file_read.  It

 * updates the atime of the lower level inode if generic_file_read

 * returns without any errors. This is to be used only for file reads.

 * The function to be used for directory reads is ecryptfs_read.

 Inspired by generic filldir in fs/readdir.c */

		/* Mask -EINVAL errors as these are most likely due a plaintext

		 * filename present in the lower filesystem despite filename

		 * encryption being enabled. One unavoidable example would be

		 * the "lost+found" dentry in the root directory of an Ext4

		 * filesystem.

/**

 * ecryptfs_readdir

 * @file: The eCryptfs directory file

 * @ctx: The actor to feed the entries to

	/*

	 * Don't allow mmap on top of file systems that don't support it

	 * natively.  If FILESYSTEM_MAX_STACK_DEPTH > 2 or ecryptfs

	 * allows recursive mounting, this will need to be extended.

/**

 * ecryptfs_open

 * @inode: inode specifying file to open

 * @file: Structure to return filled in

 *

 * Opens the file specified by inode.

 *

 * Returns zero on success; non-zero otherwise

	/* Private value of ecryptfs_dentry allocated in

 Released in ecryptfs_release or end of function if failure */

 Policy code enabled in future release */

/**

 * ecryptfs_dir_open

 * @inode: inode specifying file to open

 * @file: Structure to return filled in

 *

 * Opens the file specified by inode.

 *

 * Returns zero on success; non-zero otherwise

	/* Private value of ecryptfs_dentry allocated in

 Released in ecryptfs_release or end of function if failure */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * eCryptfs: Linux filesystem encryption layer

 *

 * Copyright (C) 2004-2008 International Business Machines Corp.

 *   Author(s): Michael A. Halcrow <mhalcrow@us.ibm.com>

 *		Tyler Hicks <code@tyhicks.com>

/**

 * ecryptfs_acquire_free_msg_ctx

 * @msg_ctx: The context that was acquired from the free list

 *

 * Acquires a context element from the free list and locks the mutex

 * on the context.  Sets the msg_ctx task to current.  Returns zero on

 * success; non-zero on error or upon failure to acquire a free

 * context element.  Must be called with ecryptfs_msg_ctx_lists_mux

 * held.

/**

 * ecryptfs_msg_ctx_free_to_alloc

 * @msg_ctx: The context to move from the free list to the alloc list

 *

 * Must be called with ecryptfs_msg_ctx_lists_mux held.

/**

 * ecryptfs_msg_ctx_alloc_to_free

 * @msg_ctx: The context to move from the alloc list to the free list

 *

 * Must be called with ecryptfs_msg_ctx_lists_mux held.

/**

 * ecryptfs_find_daemon_by_euid

 * @daemon: If return value is zero, points to the desired daemon pointer

 *

 * Must be called with ecryptfs_daemon_hash_mux held.

 *

 * Search the hash list for the current effective user id.

 *

 * Returns zero if the user id exists in the list; non-zero otherwise.

/**

 * ecryptfs_spawn_daemon - Create and initialize a new daemon struct

 * @daemon: Pointer to set to newly allocated daemon struct

 * @file: File used when opening /dev/ecryptfs

 *

 * Must be called ceremoniously while in possession of

 * ecryptfs_sacred_daemon_hash_mux

 *

 * Returns zero on success; non-zero otherwise

/*

 * ecryptfs_exorcise_daemon - Destroy the daemon struct

 *

 * Must be called ceremoniously while in possession of

 * ecryptfs_daemon_hash_mux and the daemon's own mux.

/**

 * ecryptfs_process_response

 * @daemon: eCryptfs daemon object

 * @msg: The ecryptfs message received; the caller should sanity check

 *       msg->data_len and free the memory

 * @seq: The sequence number of the message; must match the sequence

 *       number for the existing message context waiting for this

 *       response

 *

 * Processes a response message after sending an operation request to

 * userspace. Some other process is awaiting this response. Before

 * sending out its first communications, the other process allocated a

 * msg_ctx from the ecryptfs_msg_ctx_arr at a particular index. The

 * response message contains this index so that we can copy over the

 * response message into the msg_ctx that the process holds a

 * reference to. The other process is going to wake up, check to see

 * that msg_ctx->state == ECRYPTFS_MSG_CTX_STATE_DONE, and then

 * proceed to read off and process the response message. Returns zero

 * upon delivery to desired context element; non-zero upon delivery

 * failure or error.

 *

 * Returns zero on success; non-zero otherwise

/**

 * ecryptfs_send_message_locked

 * @data: The data to send

 * @data_len: The length of data

 * @msg_type: Type of message

 * @msg_ctx: The message context allocated for the send

 *

 * Must be called with ecryptfs_daemon_hash_mux held.

 *

 * Returns zero on success; non-zero otherwise

/**

 * ecryptfs_send_message

 * @data: The data to send

 * @data_len: The length of data

 * @msg_ctx: The message context allocated for the send

 *

 * Grabs ecryptfs_daemon_hash_mux.

 *

 * Returns zero on success; non-zero otherwise

/**

 * ecryptfs_wait_for_response

 * @msg_ctx: The context that was assigned when sending a message

 * @msg: The incoming message from userspace; not set if rc != 0

 *

 * Sleeps until awaken by ecryptfs_receive_message or until the amount

 * of time exceeds ecryptfs_message_wait_timeout.  If zero is

 * returned, msg will point to a valid message from userspace; a

 * non-zero value is returned upon failure to receive a message or an

 * error occurs. Callee must free @msg on success.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * eCryptfs: Linux filesystem encryption layer

 * Functions only useful for debugging.

 *

 * Copyright (C) 2006 International Business Machines Corp.

 *   Author(s): Michael A. Halcrow <mahalcro@us.ibm.com>

/*

 * ecryptfs_dump_auth_tok - debug function to print auth toks

 *

 * This function will print the contents of an ecryptfs authentication

 * token.

/**

 * ecryptfs_dump_hex - debug hex printer

 * @data: string of bytes to be printed

 * @bytes: number of bytes to print

 *

 * Dump hexadecimal representation of char array

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * eCryptfs: Linux filesystem encryption layer

 *

 * Copyright (C) 2007 International Business Machines Corp.

 *   Author(s): Michael A. Halcrow <mahalcro@us.ibm.com>

/**

 * ecryptfs_write_lower

 * @ecryptfs_inode: The eCryptfs inode

 * @data: Data to write

 * @offset: Byte offset in the lower file to which to write the data

 * @size: Number of bytes from @data to write at @offset in the lower

 *        file

 *

 * Write data to the lower file.

 *

 * Returns bytes written on success; less than zero on error

/**

 * ecryptfs_write_lower_page_segment

 * @ecryptfs_inode: The eCryptfs inode

 * @page_for_lower: The page containing the data to be written to the

 *                  lower file

 * @offset_in_page: The offset in the @page_for_lower from which to

 *                  start writing the data

 * @size: The amount of data from @page_for_lower to write to the

 *        lower file

 *

 * Determines the byte offset in the file for the given page and

 * offset within the page, maps the page, and makes the call to write

 * the contents of @page_for_lower to the lower inode.

 *

 * Returns zero on success; non-zero otherwise

/**

 * ecryptfs_write

 * @ecryptfs_inode: The eCryptfs file into which to write

 * @data: Virtual address where data to write is located

 * @offset: Offset in the eCryptfs file at which to begin writing the

 *          data from @data

 * @size: The number of bytes to write from @data

 *

 * Write an arbitrary amount of data to an arbitrary location in the

 * eCryptfs inode page cache. This is done on a page-by-page, and then

 * by an extent-by-extent, basis; individual extents are encrypted and

 * written to the lower page cache (via VFS writes). This function

 * takes care of all the address translation to locations in the lower

 * filesystem; it also handles truncate events, writing out zeros

 * where necessary.

 *

 * Returns zero on success; non-zero otherwise

	/*

	 * if we are writing beyond current size, then start pos

	 * at the current size - we'll fill in zeros from there.

 remaining zeros to write, up to destination offset */

		/*

		 * pos: where we're now writing, offset: where the request was

		 * If current pos is before request, we are filling zeros

		 * If we are at or beyond request, we are writing the *data*

		 * If we're in a fresh page beyond eof, zero it in either case

			/* We are extending past the previous end of the file.

 pos >= offset, we are now writing the data request */

/**

 * ecryptfs_read_lower

 * @data: The read data is stored here by this function

 * @offset: Byte offset in the lower file from which to read the data

 * @size: Number of bytes to read from @offset of the lower file and

 *        store into @data

 * @ecryptfs_inode: The eCryptfs inode

 *

 * Read @size bytes of data at byte offset @offset from the lower

 * inode into memory location @data.

 *

 * Returns bytes read on success; 0 on EOF; less than zero on error

/**

 * ecryptfs_read_lower_page_segment

 * @page_for_ecryptfs: The page into which data for eCryptfs will be

 *                     written

 * @page_index: Page index in @page_for_ecryptfs from which to start

 *		writing

 * @offset_in_page: Offset in @page_for_ecryptfs from which to start

 *                  writing

 * @size: The number of bytes to write into @page_for_ecryptfs

 * @ecryptfs_inode: The eCryptfs inode

 *

 * Determines the byte offset in the file for the given page and

 * offset within the page, maps the page, and makes the call to read

 * the contents of @page_for_ecryptfs from the lower inode.

 *

 * Returns zero on success; non-zero otherwise

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * eCryptfs: Linux filesystem encryption layer

 *

 * Copyright (C) 1997-2003 Erez Zadok

 * Copyright (C) 2001-2003 Stony Brook University

 * Copyright (C) 2004-2007 International Business Machines Corp.

 *   Author(s): Michael A. Halcrow <mahalcro@us.ibm.com>

 *              Michael C. Thompson <mcthomps@us.ibm.com>

 *              Tyler Hicks <code@tyhicks.com>

/*

 * Module parameter that defines the ecryptfs_verbosity level.

/*

 * Module parameter that defines the number of message buffer elements

/*

 * Module parameter that defines the maximum guaranteed amount of time to wait

 * for a response from ecryptfsd.  The actual sleep time will be, more than

 * likely, a small amount greater than this specified value, but only less if

 * the message successfully arrives.

/*

 * Module parameter that is an estimate of the maximum number of users

 * that will be concurrently using eCryptfs. Set this to the right

 * value to balance performance and memory use.

 KERN_DEBUG */

/*

 * ecryptfs_init_lower_file

 * @ecryptfs_dentry: Fully initialized eCryptfs dentry object, with

 *                   the lower dentry and the lower mount set

 *

 * eCryptfs only ever keeps a single open file for every lower

 * inode. All I/O operations to the lower inode occur through that

 * file. When the first eCryptfs dentry that interposes with the first

 * lower dentry for that inode is created, this function creates the

 * lower file struct and associates it with the eCryptfs

 * inode. When all eCryptfs files associated with the inode are released, the

 * file is closed.

 *

 * The lower file will be opened with read/write permissions, if

 * possible. Otherwise, it is opened read-only.

 *

 * This function does nothing if a lower file is already

 * associated with the eCryptfs inode.

 *

 * Returns zero on success; non-zero otherwise

/**

 * ecryptfs_parse_options

 * @sbi: The ecryptfs super block

 * @options: The options passed to the kernel

 * @check_ruid: set to 1 if device uid should be checked against the ruid

 *

 * Parse mount options:

 * debug=N 	   - ecryptfs_verbosity level for debug output

 * sig=XXX	   - description(signature) of the key to use

 *

 * Returns the dentry object of the lower-level (lower/interposed)

 * directory; We want to mount our stackable file system on top of

 * that lower directory.

 *

 * The signature of the key to use must be the description of a key

 * already in the keyring. Mounting will fail if the key can not be

 * found.

 *

 * Returns zero on success; non-zero on error

/*

 * ecryptfs_mount

 * @fs_type: The filesystem type that the superblock should belong to

 * @flags: The flags associated with the mount

 * @dev_name: The path to mount over

 * @raw_data: The options passed into the kernel

 ->kill_sb() will take care of sbi after that point */

	/**

	 * Set the POSIX ACL flag based on whether they're enabled in the lower

	 * mount.

	/**

	 * Force a read-only eCryptfs mount when:

	 *   1) The lower mount is ro

	 *   2) The ecryptfs_encrypted_view mount option is specified

 ->kill_sb() will take care of root_info */

/**

 * ecryptfs_kill_block_super

 * @sb: The ecryptfs super block

 *

 * Used to bring the superblock down and free the private data.

/*

 * inode_info_init_once

 *

 * Initializes the ecryptfs_inode_info_cache when it is created

	/*

	 * Make sure all delayed rcu free inodes are flushed before we

	 * destroy cache.

/**

 * ecryptfs_init_kmem_caches

 *

 * Returns zero on success; non-zero otherwise

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 1997-1998 Transmeta Corporation -- All Rights Reserved

 * Copyright 2005-2006 Ian Kent <raven@themaw.net>

	/*

	 * In the event of a failure in get_sb_nodev the superblock

	 * info is not present so nothing else has been setup, so

	 * just call kill_anon_super when we are called from

	 * deactivate_super.

 Free wait queues, close pipe */

	/*

	 * Get the root inode and dentry, but defer checking for errors.

 Can this call block? */

 Test versions first */

 Establish highest kernel protocol version */

	/*

	 * Success! Install the root dentry now to indicate completion.

	/*

	 * Failure ... clean up.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 1997-1998 Transmeta Corporation -- All Rights Reserved

 * Copyright 2001-2006 Ian Kent <raven@themaw.net>

/* We make this a static variable rather than a part of the superblock; it

 * is better if we don't reassign numbers easily even across filesystems

 Erase all wait queues */

 Magic is gone - report failure */

 Close the pipe */

	/* Keep the currently executing process from receiving a

	 * SIGPIPE unless it was already supposed to get one

 if 'wr' returned 0 (impossible) we assume -EIO (safe) */

 For security reasons */

 Kernel protocol v4 missing and expire packets */

	/*

	 * Kernel protocol v5 packet for handling indirect and direct

	 * mount missing and expire requests

 Just fail this one */

/*

 * Check if we have a valid request.

 * Returns

 * 1 if the request should continue.

 *   In this case we can return an autofs_wait_queue entry if one is

 *   found or NULL to idicate a new wait needs to be created.

 * 0 or a negative errno if the request shouldn't continue.

 Wait in progress, continue; */

 If we don't yet have any info this is a new request */

	/*

	 * If we've been asked to wait on an existing expire (NFY_NONE)

	 * but there is no wait in the queue ...

		/*

		 * Either we've betean the pending expire to post it's

		 * wait or it finished while we waited on the mutex.

		 * So we need to wait till either, the wait appears

		 * or the expire finishes.

		/*

		 * Not ideal but the status has already gone. Of the two

		 * cases where we wait on NFY_NONE neither depend on the

		 * return status of the wait.

	/*

	 * If we've been asked to trigger a mount and the request

	 * completed while we waited on the mutex ...

		/*

		 * If the dentry was successfully mounted while we slept

		 * on the wait queue mutex we can return success. If it

		 * isn't mounted (doesn't have submounts for the case of

		 * a multi-mount with no mount at it's base) we can

		 * continue on and create a new request.

 In catatonic mode, we don't wait for nobody */

	/*

	 * Try translating pids to the namespace of the daemon.

	 *

	 * Zero means failure: we are in an unrelated pid namespace.

		/*

		 * A wait for a negative dentry is invalid for certain

		 * cases. A direct or offset mount "always" has its mount

		 * point directory created and so the request dentry must

		 * be positive or the map key doesn't exist. The situation

		 * is very similar for indirect mounts except only dentrys

		 * in the root of the autofs file system may be negative.

 If this is a direct mount request create a dummy name */

 skip the leading slash

 Create a new wait queue */

 Status return if interrupted */

		/*

		 * autofs_notify_daemon() may block; it will unlock ->wq_mutex

	/*

	 * wq->name.name is NULL iff the lock is already released

	 * or the mount has been made catatonic.

	/*

	 * For direct and offset mounts we need to track the requester's

	 * uid and gid in the dentry info struct. This is so it can be

	 * supplied, on request, by the misc device ioctl interface.

	 * This is needed during daemon resatart when reconnecting

	 * to existing, active, autofs mounts. The uid and gid (and

	 * related string values) may be used for macro substitution

	 * in autofs mount maps.

 direct mount or browsable map */

 If not lookup actual dentry used */

 Set mount requester */

 Are we the last process to need status? */

 Unlink from chain */

 Do not wait on this queue */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 1997-1998 Transmeta Corporation -- All Rights Reserved

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 1997-1998 Transmeta Corporation -- All Rights Reserved

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2008 Red Hat, Inc. All rights reserved.

 * Copyright 2008 Ian Kent <raven@themaw.net>

/*

 * This module implements an interface for routing autofs ioctl control

 * commands via a miscellaneous device file.

 *

 * The alternate interface is needed because we need to be able open

 * an ioctl file descriptor on an autofs mount that may be covered by

 * another mount. This situation arises when starting automount(8)

 * or other user space daemon which uses direct mounts or offset

 * mounts (used for autofs lazy mount/umount of nested mount trees),

 * which have been left busy at service shutdown.

/*

 * Check a string doesn't overrun the chunk of

 * memory we copied from user land.

/*

 * Check that the user compiled against correct version of autofs

 * misc device code.

 *

 * As well as checking the version compatibility this always copies

 * the kernel interface version out.

 Fill in the kernel version. */

/*

 * Copy parameter control struct, including a possible path allocated

 * at the end of the struct.

/*

 * Check sanity of parameter control fields and if a path is present

 * check that it is terminated and contains at least one "/".

 Return autofs dev ioctl version */

 This should have already been set. */

 Return autofs module protocol version */

 Return autofs module protocol sub version */

 Find the topmost mount satisfying test() */

/*

 * Open a file descriptor on the autofs mount point corresponding

 * to the given path and device number (aka. new_encode_dev(sb->s_dev)).

 Open a file descriptor on an autofs mount point */

 param->path has been checked in validate_dev_ioctl() */

 Close file descriptor allocated above (user can also use close(2)). */

/*

 * Send "ready" status for an existing wait (either a mount or an expire

 * request).

/*

 * Send "fail" status for an existing wait (either a mount or an expire

 * request).

/*

 * Set the pipe fd for kernel communication to the daemon.

 *

 * Normally this is set at mount using an option but if we

 * are reconnecting to a busy mount then we need to use this

 * to tell the autofs mount about the new kernel pipe fd. In

 * order to protect mounts against incorrectly setting the

 * pipefd we also require that the autofs mount be catatonic.

 *

 * This also sets the process group id used to identify the

 * controlling process (eg. the owning automount(8) daemon).

/*

 * Make the autofs mount point catatonic, no longer responsive to

 * mount requests. Also closes the kernel pipe file descriptor.

 Set the autofs mount timeout */

/*

 * Return the uid and gid of the last request for the mount

 *

 * When reconstructing an autofs mount tree with active mounts

 * we need to re-connect to mounts that may have used the original

 * process uid and gid (or string variations of them) for mount

 * lookups within the map entry.

 param->path has been checked in validate_dev_ioctl() */

/*

 * Call repeatedly until it returns -EAGAIN, meaning there's nothing

 * more that can be done.

 Check if autofs mount point is in use */

/*

 * Check if the given path is a mountpoint.

 *

 * If we are supplied with the file descriptor of an autofs

 * mount we're looking for a specific mount. In this case

 * the path is considered a mountpoint if it is itself a

 * mountpoint or contains a mount, such as a multi-mount

 * without a root mount. In this case we return 1 if the

 * path is a mount point and the super magic of the covering

 * mount if there is one or 0 if it isn't a mountpoint.

 *

 * If we aren't supplied with a file descriptor then we

 * lookup the path and check if it is the root of a mount.

 * If a type is given we are looking for a particular autofs

 * mount and if we don't find a match we return fail. If the

 * located path is the root of a mount we return 1 along with

 * the super magic of the mount or 0 otherwise.

 *

 * In both cases the device number (as returned by

 * new_encode_dev()) is also returned.

 param->path has been checked in validate_dev_ioctl() */

/*

 * Our range of ioctl numbers isn't 0 based so we need to shift

 * the array index by _IOC_NR(AUTOFS_CTL_IOC_FIRST) for the table

 * lookup.

 ioctl dispatcher */

	/* Only root can use ioctls other than AUTOFS_DEV_IOCTL_VERSION_CMD

	 * and AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD

 Copy the parameters into kernel space. */

	/*

	 * For obvious reasons the openmount can't have a file

	 * descriptor yet. We don't take a reference to the

	 * file during close to allow for immediate release,

	 * and the same for retrieving ioctl version.

		/*

		 * Admin needs to be able to set the mount catatonic in

		 * order to be able to perform the re-open.

 Register/deregister misc character device */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 1997-1998 Transmeta Corporation -- All Rights Reserved

 * Copyright 1999-2000 Jeremy Fitzhardinge <jeremy@goop.org>

 * Copyright 2001-2006 Ian Kent <raven@themaw.net>

 Check if a dentry can be expired */

 dentry in the process of being deleted */

 Too young to die */

 Check a mount point for busyness */

 This is an autofs submount, we can't expire it */

 Not a submount, has a forced expire been requested */

 Update the expiry counter if fs is busy */

 p->d_lock held */

/*

 * Calculate and dget next entry in the subdirs list under root.

/*

 * Calculate and dget next entry in top down tree traversal.

/*

 * Check a direct mount point for busyness.

 * Direct mounts have similar expiry semantics to tree mounts.

 * The tree is not busy iff no mountpoints are busy and there are no

 * autofs submounts.

 Forced expire, user space handles busy mounts */

 If it's busy update the expiry counters */

 Timeout of a direct mount is determined by its top dentry */

/*

 * Check a directory tree of mount points for busyness

 * The tree is not busy iff no mountpoints are busy

 Negative dentry - give up */

		/*

		 * Is someone visiting anywhere in the subtree ?

		 * If there's no mount we need to check the usage

		 * count for the autofs dentry.

		 * If the fs is busy update the expiry counter.

 allow for dget above and top is already dgot */

 Forced expire, user space handles busy mounts */

 Timeout of a tree mount is ultimately determined by its top dentry */

 Can we umount this guy */

			/* This isn't a submount so if a forced expire

			 * has been requested, user space handles busy

 Can we expire this guy */

 Check if we can expire a direct mount (possibly a tree) */

 No point expiring a pending mount */

/* Check if 'dentry' should expire, or return a nearby

 * dentry that is suitable.

 * If returned dentry is different from arg dentry,

 * then a dget() reference was taken, else not.

 No point expiring a pending mount */

	/*

	 * Case 1: (i) indirect mount or top level pseudo direct mount

	 *	   (autofs-4.1).

	 *	   (ii) indirect mount with offset mount, check the "/"

	 *	   offset (autofs-5.0+).

 Can we umount this guy */

		/* This isn't a submount so if a forced expire

		 * has been requested, user space handles busy

 Can we expire this guy */

 Forced expire, user space handles busy mounts */

		/*

		 * A symlink can't be "busy" in the usual sense so

		 * just check last used for expire timeout.

 Case 2: tree mount, expire iff entire tree is not busy */

 Not a forced expire? */

 ref-walk currently on this dentry? */

	/*

	 * Case 3: pseudo direct mount, expire individual leaves

	 *	   (autofs-4.1).

 Not a forced expire? */

 ref-walk currently on this dentry? */

/*

 * Find an eligible tree to time-out

 * A tree is eligible if :-

 *  - it is unused by any user process

 *  - it has been unused for exp_timeout time

		/* Make sure a reference is not taken on found if

		 * things have changed.

 something has changed, continue

 Block on any pending expire */

		/*

		 * Possibly being selected for expire, wait until

		 * it's selected or not.

 Perform an expiry operation */

 avoid rapid-fire expire attempts if expiry fails */

		/* This is synchronous because it makes the daemon a

		 * little easier

 avoid rapid-fire expire attempts if expiry fails */

/*

 * Call repeatedly until it returns -EAGAIN, meaning there's nothing

 * more to be done.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 1997-1998 Transmeta Corporation -- All Rights Reserved

 * Copyright 1999-2000 Jeremy Fitzhardinge <jeremy@goop.org>

 * Copyright 2001-2006 Ian Kent <raven@themaw.net>

	/*

	 * An empty directory in an autofs file system is always a

	 * mount point. The daemon must have failed to mount this

	 * during lookup so it doesn't exist. This can happen, for

	 * example, if user space returns an incorrect status for a

	 * mount request. Otherwise we're doing a readdir on the

	 * autofs file system so just let the libfs routines handle

	 * it.

 Already gone? */

 We've already been dentry_iput or unlinked */

		/*

		 * If we are racing with expire the request might not

		 * be quite complete, but the directory has been removed

		 * so it must have been successful, just wait for it.

	/*

	 * If this is an indirect mount the dentry could have gone away

	 * as a result of an expire and a new one created.

 The daemon never triggers a mount. */

	/*

	 * If an expire request is pending everyone must wait.

	 * If the expire fails we're still mounted so continue

	 * the follow and return. A return of -EAGAIN (which only

	 * happens with indirect mounts) means the expire completed

	 * and the directory was removed, so just go ahead and try

	 * the mount.

 Callback to the daemon to perform the mount or wait */

	/*

	 * If the dentry is a symlink it's equivalent to a directory

	 * having path_is_mountpoint() true, so there's no need to call

	 * back to the daemon.

		/*

		 * It's possible that user space hasn't removed directories

		 * after umounting a rootless multi-mount, although it

		 * should. For v5 path_has_submounts() is sufficient to

		 * handle this because the leaves of the directory tree under

		 * the mount never trigger mounts themselves (they have an

		 * autofs trigger mount mounted on them). But v4 pseudo direct

		 * mounts do need the leaves to trigger mounts. In this case

		 * we have no choice but to use the list_empty() check and

		 * require user space behave.

 Mount succeeded, check if we ended up with a new dentry */

 The daemon never waits. */

 Wait for pending expires */

	/*

	 * This dentry may be under construction so wait on mount

	 * completion.

		/* We don't need fs_lock in rcu_walk mode,

		 * just testing 'AUTOFS_INFO_NO_RCU' is enough.

		 * simple_empty() takes a spinlock, so leave it

		 * to last.

		 * We only return -EISDIR when certain this isn't

		 * a mount-trap.

	/*

	 * If the dentry has been selected for expire while we slept

	 * on the lock then it might go away. We'll deal with that in

	 * ->d_automount() and wait on a new mount if the expire

	 * succeeds or return here if it doesn't (since there's no

	 * mount to follow with a rootless multi-mount).

		/*

		 * Any needed mounting has been completed and the path

		 * updated so check if this is a rootless multi-mount so

		 * we can avoid needless calls ->d_automount() and avoid

		 * an incorrect ELOOP error return.

 Lookups in the root directory */

 File name too long to exist */

		/*

		 * A dentry that is not within the root can never trigger a

		 * mount operation, unless the directory already exists, so we

		 * can return fail immediately.  The daemon however does need

		 * to create directories within the file system.

 Mark entries in the root as mount triggers */

	/* autofs_oz_mode() needs to allow path walks when the

	 * autofs mount is catatonic but the state of an autofs

	 * file system needs to be preserved over restarts.

/*

 * NOTE!

 *

 * Normal filesystems would do a "d_delete()" to tell the VFS dcache

 * that the file no longer exists. However, doing that means that the

 * VFS layer can turn the dentry into a negative dentry.  We don't want

 * this, because the unlink is probably the result of an expire.

 * We simply d_drop it and add it to a expiring list in the super block,

 * which allows the dentry lookup to check for an incomplete expire.

 *

 * If a process is blocked on the dentry waiting for the expire to finish,

 * it will invalidate the dentry and try to mount with a new one.

 *

 * Also see autofs_dir_rmdir()..

	/* autofs_oz_mode() needs to allow path walks when the

	 * autofs mount is catatonic but the state of an autofs

	 * file system needs to be preserved over restarts.

/*

 * Version 4 of autofs provides a pseudo direct mount implementation

 * that relies on directories at the leaves of a directory tree under

 * an indirect mount to trigger mounts. To allow for this we need to

 * set the DMANAGED_AUTOMOUNT and DMANAGED_TRANSIT flags on the leaves

 * of the directory tree. There is no need to clear the automount flag

 * following a mount or restore it after an expire because these mounts

 * are always covered. However, it is necessary to ensure that these

 * flags are clear on non-empty directories to avoid unnecessary calls

 * during path walks.

 root and dentrys in the root are already handled */

 only consider parents below dentrys in the root */

 flags for dentrys in the root are handled elsewhere */

 only consider parents below dentrys in the root */

	/* autofs_oz_mode() needs to allow path walks when the

	 * autofs mount is catatonic but the state of an autofs

	 * file system needs to be preserved over restarts.

	/* autofs_oz_mode() needs to allow path walks when the

	 * autofs mount is catatonic but the state of an autofs

	 * file system needs to be preserved over restarts.

 Get/set timeout ioctl() operation */

 Return protocol version */

 Return protocol sub version */

/*

* Tells the daemon whether it can umount the autofs mount.

/* Identify autofs_dentries - this is so we can tell if there's

 * an extra dentry refcount or not.  We only hold a refcount on the

 * dentry if its non-negative (ie, d_inode != NULL)

/*

 * ioctl()'s on the root directory is the chief method for the daemon to

 * generate kernel reactions

 Wait queue: go ahead and retry */

 Wait queue: fail with ENOENT */

 Enter catatonic mode (daemon shutdown) */

 Get protocol version */

 Get protocol sub version */

 return a single thing to expire */

 same as above, but can send multiple expires through pipe */

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/ext4/acl.c

 *

 * Copyright (C) 2001-2003 Andreas Gruenbacher, <agruen@suse.de>

/*

 * Convert from filesystem to in-memory representation.

/*

 * Convert from in-memory to filesystem representation.

/*

 * Inode operation get_posix_acl().

 *

 * inode->i_mutex: don't care

/*

 * Set the access or default ACL of an inode.

 *

 * inode->i_mutex: down unless called from ext4_new_inode

 is_create */,

 xattr_flags */);

/*

 * Initialize the ACLs of a new inode. Called from ext4_new_inode.

 *

 * dir->i_mutex: down

 * inode->i_mutex: up (access to inode is still exclusive)

 SPDX-License-Identifier: GPL-2.0

/*

 * fs/ext4/fast_commit.c

 *

 * Written by Harshad Shirwadkar <harshadshirwadkar@gmail.com>

 *

 * Ext4 fast commits routines.

/*

 * Ext4 Fast Commits

 * -----------------

 *

 * Ext4 fast commits implement fine grained journalling for Ext4.

 *

 * Fast commits are organized as a log of tag-length-value (TLV) structs. (See

 * struct ext4_fc_tl). Each TLV contains some delta that is replayed TLV by

 * TLV during the recovery phase. For the scenarios for which we currently

 * don't have replay code, fast commit falls back to full commits.

 * Fast commits record delta in one of the following three categories.

 *

 * (A) Directory entry updates:

 *

 * - EXT4_FC_TAG_UNLINK		- records directory entry unlink

 * - EXT4_FC_TAG_LINK		- records directory entry link

 * - EXT4_FC_TAG_CREAT		- records inode and directory entry creation

 *

 * (B) File specific data range updates:

 *

 * - EXT4_FC_TAG_ADD_RANGE	- records addition of new blocks to an inode

 * - EXT4_FC_TAG_DEL_RANGE	- records deletion of blocks from an inode

 *

 * (C) Inode metadata (mtime / ctime etc):

 *

 * - EXT4_FC_TAG_INODE		- record the inode that should be replayed

 *				  during recovery. Note that iblocks field is

 *				  not replayed and instead derived during

 *				  replay.

 * Commit Operation

 * ----------------

 * With fast commits, we maintain all the directory entry operations in the

 * order in which they are issued in an in-memory queue. This queue is flushed

 * to disk during the commit operation. We also maintain a list of inodes

 * that need to be committed during a fast commit in another in memory queue of

 * inodes. During the commit operation, we commit in the following order:

 *

 * [1] Lock inodes for any further data updates by setting COMMITTING state

 * [2] Submit data buffers of all the inodes

 * [3] Wait for [2] to complete

 * [4] Commit all the directory entry updates in the fast commit space

 * [5] Commit all the changed inode structures

 * [6] Write tail tag (this tag ensures the atomicity, please read the following

 *     section for more details).

 * [7] Wait for [4], [5] and [6] to complete.

 *

 * All the inode updates must call ext4_fc_start_update() before starting an

 * update. If such an ongoing update is present, fast commit waits for it to

 * complete. The completion of such an update is marked by

 * ext4_fc_stop_update().

 *

 * Fast Commit Ineligibility

 * -------------------------

 * Not all operations are supported by fast commits today (e.g extended

 * attributes). Fast commit ineligibility is marked by calling one of the

 * two following functions:

 *

 * - ext4_fc_mark_ineligible(): This makes next fast commit operation to fall

 *   back to full commit. This is useful in case of transient errors.

 *

 * - ext4_fc_start_ineligible() and ext4_fc_stop_ineligible() - This makes all

 *   the fast commits happening between ext4_fc_start_ineligible() and

 *   ext4_fc_stop_ineligible() and one fast commit after the call to

 *   ext4_fc_stop_ineligible() to fall back to full commits. It is important to

 *   make one more fast commit to fall back to full commit after stop call so

 *   that it guaranteed that the fast commit ineligible operation contained

 *   within ext4_fc_start_ineligible() and ext4_fc_stop_ineligible() is

 *   followed by at least 1 full commit.

 *

 * Atomicity of commits

 * --------------------

 * In order to guarantee atomicity during the commit operation, fast commit

 * uses "EXT4_FC_TAG_TAIL" tag that marks a fast commit as complete. Tail

 * tag contains CRC of the contents and TID of the transaction after which

 * this fast commit should be applied. Recovery code replays fast commit

 * logs only if there's at least 1 valid tail present. For every fast commit

 * operation, there is 1 tail. This means, we may end up with multiple tails

 * in the fast commit space. Here's an example:

 *

 * - Create a new file A and remove existing file B

 * - fsync()

 * - Append contents to file A

 * - Truncate file A

 * - fsync()

 *

 * The fast commit space at the end of above operations would look like this:

 *      [HEAD] [CREAT A] [UNLINK B] [TAIL] [ADD_RANGE A] [DEL_RANGE A] [TAIL]

 *             |<---  Fast Commit 1   --->|<---      Fast Commit 2     ---->|

 *

 * Replay code should thus check for all the valid tails in the FC area.

 *

 * Fast Commit Replay Idempotence

 * ------------------------------

 *

 * Fast commits tags are idempotent in nature provided the recovery code follows

 * certain rules. The guiding principle that the commit path follows while

 * committing is that it stores the result of a particular operation instead of

 * storing the procedure.

 *

 * Let's consider this rename operation: 'mv /a /b'. Let's assume dirent '/a'

 * was associated with inode 10. During fast commit, instead of storing this

 * operation as a procedure "rename a to b", we store the resulting file system

 * state as a "series" of outcomes:

 *

 * - Link dirent b to inode 10

 * - Unlink dirent a

 * - Inode <10> with valid refcount

 *

 * Now when recovery code runs, it needs "enforce" this state on the file

 * system. This is what guarantees idempotence of fast commit replay.

 *

 * Let's take an example of a procedure that is not idempotent and see how fast

 * commits make it idempotent. Consider following sequence of operations:

 *

 *     rm A;    mv B A;    read A

 *  (x)     (y)        (z)

 *

 * (x), (y) and (z) are the points at which we can crash. If we store this

 * sequence of operations as is then the replay is not idempotent. Let's say

 * while in replay, we crash at (z). During the second replay, file A (which was

 * actually created as a result of "mv B A" operation) would get deleted. Thus,

 * file named A would be absent when we try to read A. So, this sequence of

 * operations is not idempotent. However, as mentioned above, instead of storing

 * the procedure fast commits store the outcome of each procedure. Thus the fast

 * commit log for above procedure would be as follows:

 *

 * (Let's assume dirent A was linked to inode 10 and dirent B was linked to

 * inode 11 before the replay)

 *

 *    [Unlink A]   [Link A to inode 11]   [Unlink B]   [Inode 11]

 * (w)          (x)                    (y)          (z)

 *

 * If we crash at (z), we will have file A linked to inode 11. During the second

 * replay, we will remove file A (inode 11). But we will create it back and make

 * it point to inode 11. We won't find B, so we'll just skip that step. At this

 * point, the refcount for inode 11 is not reliable, but that gets fixed by the

 * replay of last inode 11 tag. Crashes at points (w), (x) and (y) get handled

 * similarly. Thus, by converting a non-idempotent procedure into a series of

 * idempotent outcomes, fast commits ensured idempotence during the replay.

 *

 * TODOs

 * -----

 *

 * 0) Fast commit replay path hardening: Fast commit replay code should use

 *    journal handles to make sure all the updates it does during the replay

 *    path are atomic. With that if we crash during fast commit replay, after

 *    trying to do recovery again, we will find a file system where fast commit

 *    area is invalid (because new full commit would be found). In order to deal

 *    with that, fast commit replay code should ensure that the "FC_REPLAY"

 *    superblock state is persisted before starting the replay, so that after

 *    the crash, fast commit recovery code can look at that flag and perform

 *    fast commit recovery even if that area is invalidated by later full

 *    commits.

 *

 * 1) Make fast commit atomic updates more fine grained. Today, a fast commit

 *    eligible update must be protected within ext4_fc_start_update() and

 *    ext4_fc_stop_update(). These routines are called at much higher

 *    routines. This can be made more fine grained by combining with

 *    ext4_journal_start().

 *

 * 2) Same above for ext4_fc_start_ineligible() and ext4_fc_stop_ineligible()

 *

 * 3) Handle more ineligible cases.

 This function must be called with sbi->s_fc_lock held. */

/*

 * Inform Ext4's fast about start of an inode update

 *

 * This function is called by the high level call VFS callbacks before

 * performing any inode update. This function blocks if there's an ongoing

 * fast commit on the inode in question.

/*

 * Stop inode update and wake up waiting fast commits if any.

/*

 * Remove inode from fast commit list. If the inode is being committed

 * we wait until inode commit is done.

/*

 * Mark file system as fast commit ineligible. This means that next commit

 * operation would result in a full jbd2 commit.

/*

 * Start a fast commit ineligible update. Any commits that happen while

 * such an operation is in progress fall back to full commits.

/*

 * Stop a fast commit ineligible update. We set EXT4_MF_FC_INELIGIBLE flag here

 * to ensure that after stopping the ineligible update, at least one full

 * commit takes place.

/*

 * Generic fast commit tracking function. If this is the first time this we are

 * called after a full commit, we initialize fast commit fields and then call

 * __fc_track_fn() with update = 0. If we have already been called after a full

 * commit, we pass update = 1. Based on that, the track function can determine

 * if it needs to track a field for the first time or if it needs to just

 * update the previously tracked value.

 *

 * If enqueue is set, this function enqueues the inode in fast commit list.

 __track_fn for directory entry updates. Called with ei->i_fc_lock. */

 __track_fn for inode tracking */

 __track_fn for tracking data updates */

 Add REQ_FUA | REQ_PREFLUSH only its tail */

 Ext4 commit path routines */

 memzero and update CRC */

/*

 * Allocate len bytes on a fast commit buffer.

 *

 * During the commit time this function is used to manage fast commit

 * block space. We don't split a fast commit log onto different

 * blocks. So this function makes sure that if there's not enough space

 * on the current block, the remaining space in the current block is

 * marked as unused by adding EXT4_FC_TAG_PAD tag. In that case,

 * new block is from jbd2 and CRC is updated to reflect the padding

 * we added.

	/*

	 * After allocating len, we should have space at least for a 0 byte

	 * padding.

		/*

		 * Only allocate from current buffer if we have enough space for

		 * this request AND we have space to add a zero byte padding.

 Need to add PAD tag */

 memcpy to fc reserved space and update CRC */

/*

 * Complete a fast commit by writing tail tag.

 *

 * Writing tail tag marks the end of a fast commit. In order to guarantee

 * atomicity, after writing tail tag, even if there's space remaining

 * in the block, next commit shouldn't use it. That's why tail tag

 * has the length as that of the remaining space on the block.

	/*

	 * ext4_fc_reserve_space takes care of allocating an extra block if

	 * there's no enough space on this block for accommodating this tail.

/*

 * Adds tag, length, value and updates CRC. Returns true if tlv was added.

 * Returns false if there's not enough space.

 Same as above, but adds dentry tlv. */

/*

 * Writes inode in the fast commit space under TLV with tag @tag.

 * Returns 0 on success, error on failure.

/*

 * Writes updated data ranges for the inode in question. Updates CRC.

 * Returns 0 on success, error otherwise.

 Limit the number of blocks in one extent */

 Submit data for all the fast commit inodes */

 Wait for completion of data for all the fast commit inodes */

 Commit all the directory entry updates */

		/*

		 * If we don't find inode in our list, then it was deleted,

		 * in which case, we don't need to record it's create tag.

		/*

		 * We first write the inode and then the create dirent. This

		 * allows the recovery code to create an unnamed inode first

		 * and then link it to a directory entry. This allows us

		 * to use namei.c routines almost as is and simplifies

		 * the recovery code.

	/*

	 * If file system device is different from journal device, issue a cache

	 * flush before we start writing fast commit blocks.

		/*

		 * Add a head tag only if this is the first fast commit

		 * in this TID.

/*

 * The main commit entry point. Performs a fast commit for transaction

 * commit_tid if needed. If it's not possible to perform a fast commit

 * due to various reasons, we fall back to full commit. Returns 0

 * on success, error otherwise.

 There was an ongoing commit, check if we need to restart */

 Has any ineligible update happened since we started? */

	/*

	 * weight the commit time higher than the average time so we don't

	 * react too strongly to vast changes in the commit time

/*

 * Fast commit cleanup routine. This is called after every fast commit and

 * full commit. full is true if we are called after a full commit.

 Make sure EXT4_STATE_FC_COMMITTING bit is clear */

 Ext4 Replay Path Routines */

 Helper struct for dentry replay routines */

 Unlink replay function */

 -ENOENT ok coz it might not exist anymore. */

	/*

	 * It's possible that link already existed since data blocks

	 * for the dir in question got persisted before we crashed OR

	 * we replayed this tag and crashed before the entire replay

	 * could complete.

 Link replay function */

/*

 * Record all the modified inodes during replay. We use this later to setup

 * block bitmaps correctly.

/*

 * Inode replay function

 Immediately update the inode on disk. */

 Given that we just wrote the inode on disk, this SHOULD succeed. */

	/*

	 * Our allocator could have made different decisions than before

	 * crashing. This should be fixed but until then, we calculate

	 * the number of blocks the inode.

/*

 * Dentry create replay function.

 *

 * EXT4_FC_TAG_CREAT is preceded by EXT4_FC_TAG_INODE_FULL. Which means, the

 * inode for which we are trying to create a dentry here, should already have

 * been replayed before we start here.

 This takes care of update group descriptor and other metadata */

		/*

		 * If we are creating a directory, we need to make sure that the

		 * dot and dot dot dirents are setup properly.

/*

 * Record physical disk regions which are in use as per fast commit area. Our

 * simple replay phase allocator excludes these regions from allocation.

 Replay add range tag */

 Range is not mapped */

			/*

			 * Logical to physical mapping changed. This can happen

			 * if this range was removed and then reallocated to

			 * map to new physical blocks during a fast commit.

			/*

			 * Mark the old blocks as free since they aren't used

			 * anymore. We maintain an array of all the modified

			 * inodes. In case these blocks are still used at either

			 * a different logical range in the same inode or in

			 * some different inode, we will mark them as allocated

			 * at the end of the FC replay using our array of

			 * modified inodes.

 Range is mapped and needs a state change */

		/*

		 * We may have split the extent tree while toggling the state.

		 * Try to shrink the extent tree now.

 Replay DEL_RANGE tag */

/*

 * Check if block is in excluded regions for block allocation. The simple

 * allocator that runs during replay phase is calls this function to see

 * if it is okay to use a block.

 Cleanup function called after replay */

/*

 * Recovery Scan phase handler

 *

 * This function is called during the scan phase and is responsible

 * for doing following things:

 * - Make sure the fast commit area has valid tags for replay

 * - Count number of tags that need to be replayed by the replay handler

 * - Verify CRC

 * - Create a list of excluded blocks for allocation during replay phase

 *

 * This function returns JBD2_FC_REPLAY_CONTINUE to indicate that SCAN is

 * incomplete and JBD2 should send more blocks. It returns JBD2_FC_REPLAY_STOP

 * to indicate that scan has finished and JBD2 can now start replay phase.

 * It returns a negative error to indicate that there was an error. At the end

 * of a successful scan phase, sbi->s_fc_replay_state.fc_replay_num_tags is set

 * to indicate the number of tags that need to replayed during the replay phase.

 Check if we can stop early */

/*

 * Main recovery path entry point.

 * The meaning of return codes is similar as above.

	/*

	 * We set replay callback even if fast commit disabled because we may

	 * could still have fast commit blocks that need to be replayed even if

	 * fast commit has now been turned off.

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/ext4/fsync.c

 *

 *  Copyright (C) 1993  Stephen Tweedie (sct@redhat.com)

 *  from

 *  Copyright (C) 1992  Remy Card (card@masi.ibp.fr)

 *                      Laboratoire MASI - Institut Blaise Pascal

 *                      Universite Pierre et Marie Curie (Paris VI)

 *  from

 *  linux/fs/minix/truncate.c   Copyright (C) 1991, 1992  Linus Torvalds

 *

 *  ext4fs fsync primitive

 *

 *  Big-endian to little-endian byte-swapping/bitmaps by

 *        David S. Miller (davem@caip.rutgers.edu), 1995

 *

 *  Removed unnecessary code duplication for little endian machines

 *  and excessive __inline__s.

 *        Andi Kleen, 1997

 *

 * Major simplications and cleanup - we only need to do the metadata, because

 * we can depend on generic_block_fdatasync() to sync the data blocks.

/*

 * If we're not journaling and this is a just-created file, we have to

 * sync our parent directory (if it was freshly created) since

 * otherwise it will only be written by writeback, leaving a huge

 * window during which a crash may lose the file.  This may apply for

 * the parent directory's parent as well, and so on recursively, if

 * they are also freshly created.

		/*

		 * The directory inode may have gone through rmdir by now. But

		 * the inode itself and its blocks are still allocated (we hold

		 * a reference to the inode via its dentry), so it didn't go

		 * through ext4_evict_inode()) and so we are safe to flush

		 * metadata blocks and the inode.

/*

 * akpm: A new design for ext4_sync_file().

 *

 * This is only called from sys_fsync(), sys_fdatasync() and sys_msync().

 * There cannot be a transaction open by this task.

 * Another task could have dirtied this inode.  Its data can be in any

 * state in the journalling system.

 *

 * What we do is just kick off a commit and wait on it.  This will snapshot the

 * inode to disk.

 Make sure that we read updated s_mount_flags value */

	/*

	 * data=writeback,ordered:

	 *  The caller's filemap_fdatawrite()/wait will sync the data.

	 *  Metadata is in the journal, we wait for proper transaction to

	 *  commit here.

	 *

	 * data=journal:

	 *  filemap_fdatawrite won't do anything (the buffers are clean).

	 *  ext4_force_commit will write the file data into the journal and

	 *  will wait on that.

	 *  filemap_fdatawait() will encounter a ton of newly-dirtied pages

	 *  (they were dirtied by commit).  But that's OK - the blocks are

	 *  safe in-journal, which is all fsync() needs to ensure.

 SPDX-License-Identifier: LGPL-2.1

/*

 * Copyright (c) 2008,2009 NEC Software Tohoku, Ltd.

 * Written by Takashi Sato <t-sato@yk.jp.nec.com>

 *            Akira Fujita <a-fujita@rs.jp.nec.com>

/**

 * get_ext_path() - Find an extent path for designated logical block number.

 * @inode:	inode to be searched

 * @lblock:	logical block number to find an extent path

 * @ppath:	pointer to an extent path pointer (for output)

 *

 * ext4_find_extent wrapper. Return 0 on success, or a negative error value

 * on failure.

/**

 * ext4_double_down_write_data_sem() - write lock two inodes's i_data_sem

 * @first: inode to be locked

 * @second: inode to be locked

 *

 * Acquire write lock of i_data_sem of the two inodes

/**

 * ext4_double_up_write_data_sem - Release two inodes' write lock of i_data_sem

 *

 * @orig_inode:		original inode structure to be released its lock first

 * @donor_inode:	donor inode structure to be released its lock second

 * Release write lock of i_data_sem of two inodes (orig and donor).

/**

 * mext_check_coverage - Check that all extents in range has the same type

 *

 * @inode:		inode in question

 * @from:		block offset of inode

 * @count:		block count to be checked

 * @unwritten:		extents expected to be unwritten

 * @err:		pointer to save error value

 *

 * Return 1 if all extents in range has expected type, and zero otherwise.

/**

 * mext_page_double_lock - Grab and lock pages on both @inode1 and @inode2

 *

 * @inode1:	the inode structure

 * @inode2:	the inode structure

 * @index1:	page index

 * @index2:	page index

 * @page:	result page vector

 *

 * Grab two locked pages for inode's by inode order

	/*

	 * grab_cache_page_write_begin() may not wait on page's writeback if

	 * BDI not demand that. But it is reasonable to be very conservative

	 * here and explicitly wait on page's writeback

 Force page buffers uptodate w/o dropping page's lock */

 No io required */

/**

 * move_extent_per_page - Move extent data per page

 *

 * @o_filp:			file structure of original file

 * @donor_inode:		donor inode

 * @orig_page_offset:		page index on original file

 * @donor_page_offset:		page index on donor file

 * @data_offset_in_page:	block index where data swapping starts

 * @block_len_in_page:		the number of blocks to be swapped

 * @unwritten:			orig extent is unwritten or not

 * @err:			pointer to save return value

 *

 * Save the data in original inode blocks and replace original inode extents

 * with donor inode extents by calling ext4_swap_extents().

 * Finally, write out the saved data in new original inode blocks. Return

 * replaced block count.

	/*

	 * It needs twice the amount of ordinary journal buffers because

	 * inode and donor_inode may change each different metadata blocks.

 Calculate data_size */

 Replace the last block */

		/*

		 * If data_size equal zero, it shows data_size is multiples of

		 * blocksize. So we set appropriate value.

	/*

	 * If orig extent was unwritten it can become initialized

	 * at any time after i_data_sem was dropped, in order to

	 * serialize with delalloc we have recheck extent while we

	 * hold page's lock, if it is still the case data copy is not

	 * necessary, just swap data blocks between orig and donor.

		/* If any of extents in range became initialized we have to

	/* At this point all buffers in range are uptodate, old mapping layout

	/* Perform all necessary steps similar write_begin()/write_end()

	/* Even in case of data=writeback it is reasonable to pin

	/* Buffer was busy because probably is pinned to journal transaction,

	/*

	 * This should never ever happen!

	 * Extents are swapped already, but we are not able to copy data.

	 * Try to swap extents to it's original places

/**

 * mext_check_arguments - Check whether move extent can be done

 *

 * @orig_inode:		original inode

 * @donor_inode:	donor inode

 * @orig_start:		logical start offset in block for orig

 * @donor_start:	logical start offset in block for donor

 * @len:		the number of blocks to be moved

 *

 * Check the arguments of ext4_move_extents() whether the files can be

 * exchanged with each other.

 * Return 0 on success, or a negative error value on failure.

 Ext4 move extent does not support swapfile */

 Ext4 move extent supports only extent based file */

 Start offset should be same */

/**

 * ext4_move_extents - Exchange the specified range of a file

 *

 * @o_filp:		file structure of the original file

 * @d_filp:		file structure of the donor file

 * @orig_blk:		start offset in block for orig

 * @donor_blk:		start offset in block for donor

 * @len:		the number of blocks to be moved

 * @moved_len:		moved block length

 *

 * This function returns 0 and moved block length is set in moved_len

 * if succeed, otherwise returns error value.

 *

 orig and donor should be different inodes */

 Regular file check */

	/* TODO: it's not obvious how to swap blocks for inodes with full

 Protect orig and donor inodes against a truncate */

 Wait for all existing dio workers */

 Protect extent tree against block allocations via delalloc */

 Check the filesystem environment whether move_extent can be done */

 Check hole before the start pos */

 Check hole after the start pos */

 Skip hole */

 Extent inside requested range ?*/

 in_range(o_start, o_blk, o_len) */

		/*

		 * Up semaphore to avoid following problems:

		 * a. transaction deadlock among ext4_journal_start,

		 *    ->write_begin via pagefault, and jbd2_journal_commit

		 * b. racing with ->readpage, ->write_begin, and ext4_get_block

		 *    in move_extent_per_page

 Swap original branches with new branches */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/ext4/block_validity.c

 *

 * Copyright (C) 2009

 * Theodore Ts'o (tytso@mit.edu)

 *

 * Track which blocks in the filesystem are metadata blocks that

 * should never be used as data blocks by files or directories.

/*

 * Mark a range of blocks as belonging to the "system zone" --- that

 * is, filesystem metadata blocks which should never be used by

 * inodes.

 Unexpected overlap of system zones. */

 Can we merge to the left? */

 Can we merge to the right? */

/*

 * Build system zone rbtree which is used for block validity checking.

 *

 * The update of system_blks pointer in this function is protected by

 * sb->s_umount semaphore. However we have to be careful as we can be

 * racing with ext4_inode_block_valid() calls reading system_blks rbtree

 * protected only by RCU. That's why we first build the rbtree and then

 * swap it in place.

	/*

	 * System blks rbtree complete, announce it once to prevent racing

	 * with ext4_inode_block_valid() accessing the rbtree at the same

	 * time.

/*

 * Called when the filesystem is unmounted or when remounting it with

 * noblock_validity specified.

 *

 * The update of system_blks pointer in this function is protected by

 * sb->s_umount semaphore. However we have to be careful as we can be

 * racing with ext4_inode_block_valid() calls reading system_blks rbtree

 * protected only by RCU. So we first clear the system_blks pointer and

 * then free the rbtree only after RCU grace period expires.

/*

 * Returns 1 if the passed-in block region (start_blk,

 * start_blk+count) is valid; 0 if some part of the block region

 * overlaps with some other filesystem metadata blocks.

	/*

	 * Lock the system zone to prevent it being released concurrently

	 * when doing a remount which inverse current "[no]block_validity"

	 * mount option.

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/ext4/xattr_user.c

 * Handler for extended user attributes.

 *

 * Copyright (C) 2001 by Andreas Gruenbacher, <a.gruenbacher@computer.org>

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/ext4/ioctl.c

 *

 * Copyright (C) 1993, 1994, 1995

 * Remy Card (card@masi.ibp.fr)

 * Laboratoire MASI - Institut Blaise Pascal

 * Universite Pierre et Marie Curie (Paris VI)

/**

 * Swap memory between @a and @b for @len bytes.

 *

 * @a:          pointer to first memory area

 * @b:          pointer to second memory area

 * @len:        number of bytes to swap

 *

/**

 * Swap i_data and associated attributes between @inode1 and @inode2.

 * This function is used for the primary swap between inode1 and inode2

 * and also to revert this primary swap in case of errors.

 *

 * Therefore you have to make sure, that calling this method twice

 * will revert all changes.

 *

 * @inode1:     pointer to first inode

 * @inode2:     pointer to second inode

/**

 * Swap the information from the given @inode and the inode

 * EXT4_BOOT_LOADER_INO. It will basically swap i_data and all other

 * important fields of the inodes.

 *

 * @sb:         the super block of the filesystem

 * @mnt_userns:	user namespace of the mount the inode was found from

 * @inode:      the inode to swap with EXT4_BOOT_LOADER_INO

 *

	/* Protect orig inodes against a truncate and make sure,

 Wait for all existing dio workers */

 Protect extent tree against block allocations via delalloc */

 this inode has never been used as a BOOT_LOADER */

 No need to update quota information. */

 Revert all changes: */

 No need to update quota information. */

 Bootloader inode should not be counted into quota information. */

 Revert all changes: */

/*

 * If immutable is set and we are not clearing it, we're not allowed to change

 * anything else in the inode.  Don't error out if we're only trying to set

 * immutable on an immutable file.

 Allow the DAX flag to be changed on inline directories */

 Is it quota file? Do not allow user to mess with it */

	/*

	 * The JOURNAL_DATA flag can only be changed by

	 * the relevant capability.

	/*

	 * Wait for all pending directio and then flush all the dirty pages

	 * for this file.  The flush marks all the pages readonly, so any

	 * subsequent attempt to write to the file (particularly mmap pages)

	 * will come through the filesystem and fail.

 These flags get special treatment later */

		/*

		 * Changes to the journaling mode can cause unsafe changes to

		 * S_DAX if the inode is DAX

 Is it quota file? Do not allow user to mess with it */

		/* __dquot_transfer() calls back ext4_get_inode_usage() which

		 * counts xattr inode references.

	/*

	 * ext4 doesn't report file extents at all, so the only valid

	 * file offsets are the magic ones (all zeroes or all ones).

 If we didn't abort, set the "last" flag in the last fmx */

 copy back header */

	/*

	 * chattr(1) grabs flags via GETFLAGS, modifies the result and

	 * passes that to SETFLAGS. So we cannot easily make SETFLAGS

	 * more restrictive than just silently masking off visible but

	 * not settable flags as we always did.

 So that the fiemap access checks can't overflow on 32 bit machines. */

 check for invalid bits set */

		/*

		 * inode_mutex prevent write and truncate on the file.

		 * Read still goes through. We take i_data_sem in

		 * ext4_ext_swap_inode_data before we switch the

		 * inode format to prevent read.

		/*

		 * We haven't replayed the journal, so we cannot use our

		 * block-bitmap-guided storage zapping commands.

 These are just misnamed, they actually get/put from/to user an int */

/*

 * Ext4 orphan inode handling

	/*

	 * Find block with free orphan entry. Use CPU number for a naive hash

	 * for a search start in the orphan file

		/*

		 * For now we don't grow or shrink orphan file. We just use

		 * whatever was allocated at mke2fs time. The additional

		 * credits we would have to reserve for each orphan inode

		 * operation just don't seem worth it.

 Find empty slot in a block */

			/*

			 * Did we walk through the block several times without

			 * finding free entry? It is theoretically possible

			 * if entries get constantly allocated and freed or

			 * if the block is corrupted. Avoid indefinite looping

			 * and bail. We'll use orphan list instead.

/*

 * ext4_orphan_add() links an unlinked or truncated inode into a list of

 * such inodes, starting at the superblock, in case we crash before the

 * file is closed/deleted, or in case the inode truncate spans multiple

 * transactions and the last transaction is not recovered after a crash.

 *

 * At filesystem recovery time, we walk this list deleting unlinked

 * inodes and truncating linked inodes in ext4_orphan_cleanup().

 *

 * Orphan list manipulation functions must be called under i_mutex unless

 * we are just creating the inode or deleting it.

	/*

	 * Inode orphaned in orphan file or in orphan list?

	/*

	 * Orphan handling is only valid for files with data blocks

	 * being truncated, or files being unlinked. Note that we either

	 * hold i_mutex, or the inode can not be referenced from outside,

	 * so i_nlink should not be bumped due to race

		/*

		 * Fallback to normal orphan list of orphan file is

		 * out of space

	/*

	 * Due to previous errors inode may be already a part of on-disk

	 * orphan list. If so skip on-disk list modification.

 Insert this inode at the head of the on-disk orphan list */

			/*

			 * We have to remove inode from in-memory list if

			 * addition to on disk orphan list failed. Stray orphan

			 * list entries can cause panics at unmount time.

/*

 * ext4_orphan_del() removes an unlinked or truncated inode from the list

 * of such inodes stored on disk, because it is finally being cleaned up.

 Do this quick check before taking global s_orphan_lock. */

 Grab inode buffer early before taking global s_orphan_lock */

	/* If we're on an error path, we may not have a valid

	 * transaction handle with which to update the orphan list on

	 * disk, but we still need to remove the inode from the linked

			/*

			 * We need to clean up the in-core orphan list

			 * manually if ext4_truncate() failed to get a

			 * transaction handle.

 The delete magic happens here! */

/* ext4_orphan_cleanup() walks a singly-linked list of inodes (starting at

 * the superblock) which were deleted from all directories, but held open by

 * a process at the time of a crash.  We walk the list and try to delete these

 * inodes at recovery time (only with a read-write filesystem).

 *

 * In order to keep the orphan inode chain consistent during traversal (in

 * case of crash during recovery), we link each inode into the superblock

 * orphan list_head and handle it the same way as an inode deletion during

 * normal operation (which journals the operations for us).

 *

 * We only do an iget() and an iput() on each inode, which is very safe if we

 * accidentally point at an in-use or already deleted inode.  The worst that

 * can happen in this case is that we get a "bit already cleared" message from

 * ext4_free_inode().  The only reason we would point at a wrong inode is if

 * e2fsck was run on this filesystem, and it must have already done the orphan

 * inode cleanup for us, so we can safely abort without any further action.

 Check if feature set would not allow a r/w mount */

 don't clear list on RO mount w/ errors */

	/*

	 * Turn on quotas which were not enabled for read-only mounts if

	 * filesystem has quota feature, so that they are updated correctly.

 Turn on journaled quotas used for old sytle */

		/*

		 * We may have encountered an error during cleanup; if

		 * so, skip the rest.

 Turn off quotas if they were enabled for orphan cleanup */

 Restore SB_RDONLY status */

 This gets called only when checksumming is enabled */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/ext4/namei.c

 *

 * Copyright (C) 1992, 1993, 1994, 1995

 * Remy Card (card@masi.ibp.fr)

 * Laboratoire MASI - Institut Blaise Pascal

 * Universite Pierre et Marie Curie (Paris VI)

 *

 *  from

 *

 *  linux/fs/minix/namei.c

 *

 *  Copyright (C) 1991, 1992  Linus Torvalds

 *

 *  Big-endian to little-endian byte-swapping/bitmaps by

 *        David S. Miller (davem@caip.rutgers.edu), 1995

 *  Directory entry file type support and forward compatibility hooks

 *	for B-tree directories by Theodore Ts'o (tytso@mit.edu), 1998

 *  Hash Tree Directory indexing (c)

 *	Daniel Phillips, 2001

 *  Hash Tree Directory indexing porting

 *	Christopher Li, 2002

 *  Hash Tree Directory indexing cleanup

 *	Theodore Ts'o, 2002

/*

 * define how far ahead to read directories while searching them.

/*

 * Hints to ext4_read_dirblock regarding whether we expect a directory

 * block being read to be an index block, or a block containing

 * directory entries (and if the latter, whether it was found via a

 * logical block in an htree index block).  This is used to control

 * what sort of sanity checkinig ext4_read_dirblock() will do on the

 * directory block read from the storage device.  EITHER will means

 * the caller doesn't know what kind of directory block will be read,

 * so no specific verification will be done.

 Determine whether or not we have an index block */

	/*

	 * An empty leaf block can get mistaken for a index block; for

	 * this reason, we can only check the index checksum when the

	 * caller is sure it should be an index block.

/*

 * dx_root_info is laid out so that if it should somehow get overlaid by a

 * dirent the two low bits of the hash version will be zero.  Therefore, the

 * hash version mod 4 should never be 0.  Sincerely, the paranoia department.

 8 */

/*

 * This goes at the end of each htree block.

 crc32c(uuid+inum+dirblock) */

 checksumming functions */

 Walk through a dirent block to find a checksum "dirent" at the tail */

/*

 * p is at least 6 bytes before the end of page

/*

 * Future: use high four bits of block for coalesce-on-delete flags

 * Mask them off for now.

/*

 * Debug

 Directory is not encrypted */

 Directory is encrypted */

/*

 * Linear search cross check

 DX_DEBUG */

 DX_DEBUG */

/*

 * Probe for a directory leaf block to search.

 *

 * dx_probe can return ERR_BAD_DX_DIR, which means there was a format

 * error in the directory index, and the caller should fall back to

 * searching the directory normally.  The callers of dx_probe **MUST**

 * check for this error code, and make sure it never gets reflected

 * back to userspace.

 hash is already computed for encrypted casefolded directory */

 save local copy, "info" may be freed after brelse() */

/*

 * This function increments the frame pointer to search the next leaf

 * block, and reads in the necessary intervening nodes if the search

 * should be necessary.  Whether or not the search is necessary is

 * controlled by the hash parameter.  If the hash value is even, then

 * the search is only continued if the next block starts with that

 * hash value.  This is used if we are searching for a specific file.

 *

 * If the hash value is HASH_NB_ALWAYS, then always go to the next block.

 *

 * This function returns 1 if the caller should continue to search,

 * or 0 if it should not.  If there is an error reading one of the

 * index blocks, it will a negative error code.

 *

 * If start_hash is non-null, it will be filled in with the starting

 * hash of the next page.

	/*

	 * Find the next leaf page by incrementing the frame pointer.

	 * If we run out of entries in the interior node, loop around and

	 * increment pointer in the parent node.  When we break out of

	 * this loop, num_frames indicates the number of interior

	 * nodes need to be read.

	/*

	 * If the hash is 1, then continue only if the next page has a

	 * continuation hash of any value.  This is used for readdir

	 * handling.  Otherwise, check to see if the hash matches the

	 * desired continuation hash.  If it doesn't, return since

	 * there's no point to read in the successive index pages.

	/*

	 * If the hash is HASH_NB_ALWAYS, we always go to the next

	 * block so no check is necessary

/*

 * This function fills a red-black tree with information from a

 * directory block.  It returns the number directory entries loaded

 * into the tree.  If there is an error it is returned in err.

 csum entries are not larger in the casefolded encrypted case */

 Check if the directory is encrypted */

 silently ignore the rest of the block */

 Directory is encrypted */

/*

 * This function fills a red-black tree with information from a

 * directory.  We start scanning the directory in hash order, starting

 * at start_hash and start_minor_hash.

 *

 * This function returns the number of entries inserted into the tree,

 * or a negative error code.

 Add '.' and '..' from the htree header */

		/*

		 * Stop if:  (a) there are no more entries, or

		 * (b) we have inserted at least one entry and the

		 * next hash value is not a continuation

/*

 * Directory block splitting, compacting

/*

 * Create map of hash values, offsets, and sizes, stored at end of block.

 * Returns number of entries mapped.

 XXX: do we need to check rec_len == 0 case? -Chris */

 Sort map by hash value */

 Combsort until bubble sort doesn't suck */

 9, 10 -> 11 */

 Garden variety bubble sort */

/*

 * Test whether a case-insensitive directory entry matches the filename

 * being searched for.  If quick is set, assume the name being looked up

 * is already in the casefolded form.

 *

 * Returns: 0 if the directory entry matches, more than 0 if it

 * doesn't match or less than zero on error.

		/* Handle invalid character sequence as either an error

		 * or as an opaque byte sequence.

/*

 * Test whether a directory entry matches the filename being searched for.

 *

 * Return: %true if the directory entry matches, otherwise %false.

/*

 * Returns 0 if not found, -1 on failure, and 1 on success

 this code is executed quadratically often */

 do minimal checking `by hand' */

			/* found a match - just to be sure, do

 prevent looping on a bad block */

/*

 *	__ext4_find_entry()

 *

 * finds an entry in the specified directory with the wanted name. It

 * returns the cache buffer in which the entry was found, and the entry

 * itself (as a parameter - res_dir). It does NOT read the inode of the

 * entry - you'll have to do that yourself if you want to.

 *

 * The returned buffer_head has ->b_count elevated.  The caller is expected

 * to brelse() it when appropriate.

	size_t ra_max = 0;	/* Number of bh's in the readahead

	size_t ra_ptr = 0;	/* Current index into readahead

		/*

		 * "." or ".." will only be in the first block

		 * NFS may look up ".."; "." should be handled by the VFS

		/*

		 * On success, or if the error was file not found,

		 * return.  Otherwise, fall back to doing a search the

		 * old fashioned way.

		/*

		 * We deal with the read-ahead logic here.

 Refill the readahead buffer */

 wait */, bh_use);

	/*

	 * If the directory has grown while we were searching, then

	 * search the last part of the directory before giving up.

 Clean up the read-ahead blocks */

 Check to see if we should continue to search */

		/* Eventually we want to call d_add_ci(dentry, NULL)

		 * for negative dentries in the encoding case as

		 * well.  For now, prevent the negative dentry

		 * from being cached.

/*

 * Move count entries from end of map between two memory locations.

 * Returns pointer to last entry moved.

 wipe dir_entry excluding the rec_len field */

/*

 * Compact each dir entry in the range to the minimal rec_len.

 * Returns pointer to last entry in range.

/*

 * Split a full leaf block to make room for a new dir entry.

 * Allocate a new block, and move entries so that they are approx. equally full.

 * Returns pointer to de in block into which the new entry will be inserted.

 create map in the end of data2 block */

 Ensure that neither split block is over half full */

 is more than half of this entry in 2nd half of the block? */

	/*

	 * map index at which we will split

	 *

	 * If the sum of active entries didn't exceed half the block size, just

	 * split it in half by count; each resulting block will have at least

	 * half the space free.

 Fancy dance to stay within two buffers */

 Which block gets the new entry? */

/*

 * Add a new entry into a directory (leaf) block.  If de is non-NULL,

 * it points to a directory entry which is guaranteed to be large

 * enough for new directory entry.  If de is NULL, then

 * add_dirent_to_buf will attempt search the directory block for

 * space.  It will return -ENOSPC if no space is available, and -EIO

 * and -EEXIST if directory entry already exists.

 By now the buffer is marked for journaling */

	/*

	 * XXX shouldn't update any times until successful

	 * completion of syscall, but too many callers depend

	 * on this.

	 *

	 * XXX similarly, too many callers depend on

	 * ext4_new_inode() setting the times, but error

	 * recovery deletes the inode, so the worst that can

	 * happen is that the times are slightly out of date

	 * and/or different from the directory change time.

/*

 * This converts a one block unindexed directory to a 3 block indexed

 * directory, and adds the dentry to the indexed directory.

 The 0th block becomes the root, move the dirents out */

 Allocate new block for the 0th block's dirents */

 wipe old data */

 Initialize the root; the dot dirents already exist */

 Initialize as for dx_probe */

 casefolded encrypted hashes are computed on fname setup */

	/*

	 * Even if the block split failed, we have to properly write

	 * out all the changes we did so far. Otherwise we can end up

	 * with corrupted filesystem.

/*

 *	ext4_add_entry()

 *

 * adds a file entry to the specified directory, using the same

 * semantics as ext4_find_entry(). It returns NULL if it failed.

 *

 * NOTE!! The inode part of 'de' is left at 0 - which means you

 * may not sleep between calling this and putting something into

 * the entry, as someone else might have used it while you slept.

 Can we just ignore htree data? */

 make_indexed_dir releases bh */

/*

 * Returns 0 for success, or a negative error value

 Block full, should compress but for now just split */

 Need to split index? */

 split higher index block */

 index root */

 Which index block gets the new entry? */

 Set up root */

 this is a no-op if err == 0 */

	/* @restart is true means htree-path has been changed, we need to

	 * repeat dx_probe() to find out valid htree-path

/*

 * ext4_generic_delete_entry deletes a directory entry by merging it

 * with the previous entry

 wipe entire dir_entry */

 wipe dir_entry excluding the rec_len field */

/*

 * Set directory link count to 1 if nlinks > EXT4_LINK_MAX, or if nlinks == 2

 * since this indicates that nlinks count was previously 1 to avoid overflowing

 * the 16-bit i_links_count field on disk.  Directories with i_nlink == 1 mean

 * that subdirectory link counts are not being maintained accurately.

 *

 * The caller has already checked for i_nlink overflow in case the DIR_LINK

 * feature is not enabled and returned -EMLINK.  The is_dx() check is a proxy

 * for checking S_ISDIR(inode) (since the INODE_INDEX feature will not be set

 * on regular files) and to avoid creating huge/slow non-HTREE directories.

/*

 * If a directory had nlink == 1, then we should let it be 1. This indicates

 * directory has >EXT4_LINK_MAX subdirs.

/*

 * Add non-directory inode to a directory. On success, the inode reference is

 * consumed by dentry is instantiation. This is also indicated by clearing of

 * *inodep pointer. On failure, the caller is responsible for dropping the

 * inode reference in the safe context.

/*

 * By the time this is called, we already have created

 * the directory cache entry for the new file, but it

 * is so far negative - it has no inode.

 *

 * If the create succeeds, we fill in the inode information

 * with d_instantiate().

/*

 * routine to check that the specified directory is empty (for rmdir)

	/* The first directory block must not be a hole,

	 * so treat it as DIRENT_HTREE

	/* Initialize quotas before so that eventual writes go in

	/* There's no need to set i_disksize: the fact that i_nlink is

	 * zero will ensure that the right thing happens during any

	/* VFS negative dentries are incompatible with Encoding and

	 * Case-insensitiveness. Eventually we'll want avoid

	 * invalidating the dentries here, alongside with returning the

	 * negative dentries at ext4_lookup(), when it is better

	 * supported by the VFS for the CI case.

		/*

		 * It's okay if we find dont find dentry which matches

		 * the inode. That's because it might have gotten

		 * renamed to a different inode number

	/*

	 * Initialize quotas before so that eventual writes go

	 * in separate transaction

	/* VFS negative dentries are incompatible with Encoding and

	 * Case-insensitiveness. Eventually we'll want avoid

	 * invalidating the dentries here, alongside with returning the

	 * negative dentries at ext4_lookup(), when it is  better

	 * supported by the VFS for the CI case.

		/*

		 * For non-fast symlinks, we just allocate inode and put it on

		 * orphan list in the first transaction => we need bitmap,

		 * group descriptor, sb, inode block, quota blocks, and

		 * possibly selinux xattr blocks.

		/*

		 * Fast symlink. We have to add entry to directory

		 * (EXT4_DATA_TRANS_BLOCKS + EXT4_INDEX_EXTRA_TRANS_BLOCKS),

		 * allocate new inode (bitmap, group descriptor, inode block,

		 * quota blocks, sb is already counted in previous macros).

		/*

		 * We cannot call page_symlink() with transaction started

		 * because it calls into ext4_write_begin() which can wait

		 * for transaction commit if we are running out of space

		 * and thus we deadlock. So we have to stop transaction now

		 * and restart it when symlink contents is written.

		 *

		 * To keep fs consistent in case of crash, we have to put inode

		 * to orphan list in the mean time.

		/*

		 * Now inode is being linked into dir (EXT4_DATA_TRANS_BLOCKS

		 * + EXT4_INDEX_EXTRA_TRANS_BLOCKS), inode is also modified

 clear the extent format for fast symlink */

		/* this can happen only for tmpfile being

		 * linked the first time

/*

 * Try to find buffer head where contains the parent block.

 * It should be the inode block if it is inlined or the 1st block

 * if it is a normal dir.

		/* The first directory block must not be a hole, so

		 * treat it as DIRENT_HTREE

 entry for "dentry" */

 entry for ".." in inode if it's a directory */

	/*

	 * old->de could have moved from under us during make indexed dir,

	 * so the old->de may no longer valid and need to find it again

	 * before reset old inode info.

	/*

	 * ent->de could have moved from under us during htree split, so make

	 * sure that we are deleting the right entry.  We might also be pointing

	 * to a stale entry in the unused part of ent->bh so just checking inum

	 * and the name isn't enough.

	/*

	 * for inode block, sb block, group summaries,

	 * and inode bitmap

/*

 * Anybody can rename anything with this: the permission checks are left to the

 * higher-level routines.

 *

 * n.b.  old_{dentry,inode) refers to the source dentry/inode

 * while new_{dentry,inode) refers to the destination dentry/inode

 * This comes from rename(const char *oldpath, const char *newpath)

	/* Initialize quotas before so that eventual writes go

	/*

	 *  Check for inode number is _not_ due to possible IO errors.

	 *  We might rmdir the source, keep it as pwd of some process

	 *  and merrily kill the link to whatever was created under the

	 *  same name. Goodbye sticky bit ;-<

	/*

	 * If we're renaming a file within an inline_data dir and adding or

	 * setting the new dirent causes a conversion from inline_data to

	 * extents/blockmap, we need to force the dirent delete code to

	 * re-read the directory, or else we end up trying to delete a dirent

	 * from what is now the extent tree root (or a block map).

		/*

		 * Do this before adding a new entry, so the old entry is sure

		 * to be still pointing to the valid old entry.

	/*

	 * Like most other Unix systems, set the ctime for inodes on a

	 * rename.

		/*

		 * ok, that's it

			/* checked ext4_empty_dir above, can't have another

			 * parent, ext4_dec_count() won't work for many-linked

		/*

		 * We disable fast commits here that's because the

		 * replay code is not yet capable of changing dot dot

		 * dirents in directories.

	/*

	 *  Check for inode number is _not_ due to possible IO errors.

	 *  We might rmdir the source, keep it as pwd of some process

	 *  and merrily kill the link to whatever was created under the

	 *  same name. Goodbye sticky bit ;-<

 RENAME_EXCHANGE case: old *and* new must both exist */

	/*

	 * Other than the special case of overwriting a directory, parents'

	 * nlink only needs to be modified if this is a cross directory rename.

	/*

	 * Like most other Unix systems, set the ctime for inodes on a

	 * rename.

/*

 * directories can handle most operations...

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/ext4/super.c

 *

 * Copyright (C) 1992, 1993, 1994, 1995

 * Remy Card (card@masi.ibp.fr)

 * Laboratoire MASI - Institut Blaise Pascal

 * Universite Pierre et Marie Curie (Paris VI)

 *

 *  from

 *

 *  linux/fs/minix/inode.c

 *

 *  Copyright (C) 1991, 1992  Linus Torvalds

 *

 *  Big-endian to little-endian byte-swapping/bitmaps by

 *        David S. Miller (davem@caip.rutgers.edu), 1995

 Needed for trace points definition */

/*

 * Lock ordering

 *

 * page fault path:

 * mmap_lock -> sb_start_pagefault -> invalidate_lock (r) -> transaction start

 *   -> page lock -> i_data_sem (rw)

 *

 * buffered write path:

 * sb_start_write -> i_mutex -> mmap_lock

 * sb_start_write -> i_mutex -> transaction start -> page lock ->

 *   i_data_sem (rw)

 *

 * truncate:

 * sb_start_write -> i_mutex -> invalidate_lock (w) -> i_mmap_rwsem (w) ->

 *   page lock

 * sb_start_write -> i_mutex -> invalidate_lock (w) -> transaction start ->

 *   i_data_sem (rw)

 *

 * direct IO:

 * sb_start_write -> i_mutex -> mmap_lock

 * sb_start_write -> i_mutex -> transaction start -> i_data_sem (rw)

 *

 * writepages:

 * transaction start -> page lock(s) -> i_data_sem (rw)

	/*

	 * buffer's verified bit is no longer valid after reading from

	 * disk again due to write out error, clear it to make sure we

	 * recheck the buffer contents.

/*

 * This works like __bread_gfp() except it uses ERR_PTR for error

 * returns.  Currently with sb_bread it's impossible to distinguish

 * between ENOMEM and EIO situations (since both result in a NULL

 * return.

/*

 * The del_gendisk() function uninitializes the disk-specific data

 * structures, including the bdi structure, without telling anyone

 * else.  Once this happens, any attempt to call mark_buffer_dirty()

 * (for example, by ext4_commit_super), will cause a kernel OOPS.

 * This is a kludge to prevent these oops until we can put in a proper

 * hook in del_gendisk() to inform the VFS and file system layers.

/*

 * This writepage callback for write_cache_pages()

 * takes care of a few cases after page cleaning.

 *

 * write_cache_pages() already checks for dirty pages

 * and calls clear_page_dirty_for_io(), which we want,

 * to write protect the pages.

 *

 * However, we may have to redirty a page (see below.)

		/*

		 * We have to redirty a page in these cases:

		 * 1) If buffer is dirty, it means the page was dirty because it

		 * contains a buffer that needs checkpointing. So the dirty bit

		 * needs to be preserved so that checkpointing writes the buffer

		 * properly.

		 * 2) If buffer is not part of the committing transaction

		 * (we may have just accidentally come across this buffer because

		 * inode range tracking is not exact) or if the currently running

		 * transaction already contains this buffer as well, dirty bit

		 * needs to be preserved so that the buffer gets writeprotected

		 * properly on running transaction's commit.

 We default to EFSCORRUPTED error... */

/* Deal with the reporting of failure conditions on a filesystem such as

 * inconsistencies detected or read IO failures.

 *

 * On ext2, we can store the error state of the filesystem in the

 * superblock.  That is not possible on ext4, because we may have other

 * write ordering constraints on the superblock which prevent us from

 * writing it out straight away; and given that the journal is about to

 * be aborted, we can't rely on the current, or future, transactions to

 * write out the superblock safely.

 *

 * We'll just use the jbd2_journal_abort() error code to record an error in

 * the journal instead.  On recovery, the journal will complain about

 * that error until we've noted it down and cleared it.

 *

 * If force_ro is set, we unconditionally force the filesystem into an

 * ABORT|READONLY state, unless the error response on the fs has been set to

 * panic in which case we take the easy way out and panic immediately. This is

 * used to deal with unrecoverable failures such as journal IO errors or ENOMEM

 * at a critical moment in log management.

		/*

		 * In case the fs should keep running, we need to writeout

		 * superblock through the journal. Due to lock ordering

		 * constraints, it may not be safe to do it right here so we

		 * defer superblock flushing to a workqueue.

	/*

	 * We force ERRORS_RO behavior when system is rebooting. Otherwise we

	 * could panic during 'reboot -f' as the underlying device got already

	 * disabled.

	/*

	 * Make sure updated value of ->s_mount_flags will be visible before

	 * ->s_flags update

	/*

	 * If the journal is still running, we have to write out superblock

	 * through the journal to avoid collisions of other journalled sb

	 * updates.

	 *

	 * We use directly jbd2 functions here to avoid recursing back into

	 * ext4 error handling code during handling of previous errors.

	/*

	 * Write through journal failed. Write sb directly to get error info

	 * out and hope for the best.

		/* If the caller passed in an extra buffer for unknown

		 * errors, textualise them now.  Else we just return

 Check for truncated error codes... */

/* __ext4_std_error decodes expected errors from journaling functions

	/* Special case: if the error is EROFS, and we're not already

	 * inside a transaction, then there's really no point in logging

	/*

	 * We only get here in the ERRORS_RO case; relocking the group

	 * may be dangerous, but nothing bad will happen since the

	 * filesystem will have already been marked read/only and the

	 * journal has been aborted.  We return 1 as a hint to callers

	 * who might what to use the return value from

	 * ext4_grp_locked_error() to distinguish between the

	 * ERRORS_CONT and ERRORS_RO case, and perhaps return more

	 * aggressively from the ext4 function in question, with a

	 * more appropriate error code.

 leave es->s_feature_*compat flags alone */

 es->s_uuid will be set by e2fsck if empty */

	/*

	 * The rest of the superblock fields should be zero, and if not it

	 * means they are likely already in use, so leave them alone.  We

	 * can leave it up to e2fsck to clean up any inconsistencies there.

/*

 * Open the external journal device

/*

 * Release the journal device

 Use our quota_off function to clear inode flags etc. */

/*

 * This is a helper function which is used in the mount/remount

 * codepaths (which holds s_umount) to fetch the quota file name.

	/*

	 * Unregister sysfs before destroying jbd2 journal.

	 * Since we could still access attr_journal_task attribute via sysfs

	 * path which could have sbi->s_journal->j_task as NULL

	/* Debugging code just in case the in-memory inode orphan list

	 * isn't empty.  The on-disk one can be non-empty if we've

	 * detected an error and taken the fs readonly, but the

		/*

		 * Invalidate the journal device's buffers.  We don't want them

		 * floating about in memory - the physical journal device may

		 * hotswapped, and it breaks the `ro-after' testing code.

	/*

	 * Now that we are completely done shutting down the

	 * superblock, we need to actually destroy the kobject.

/*

 * Called inside transaction, so use GFP_NOFS

	/*

	 * Make sure all delayed rcu free inodes are flushed before we

	 * destroy cache.

	/*

	 * Currently we don't know the generation for parent directory, so

	 * a generation of 0 means "accept any"

	/*

	 * Encrypting the root directory is not allowed because e2fsck expects

	 * lost+found to exist and be unencrypted, and encrypting the root

	 * directory would imply encrypting the lost+found directory as well as

	 * the filename "lost+found" itself.

	/*

	 * If a journal handle was specified, then the encryption context is

	 * being set on a new inode via inheritance and is part of a larger

	 * transaction to create the inode.  Otherwise the encryption context is

	 * being set on an existing inode in its own transaction.  Only in the

	 * latter case should the "retry on ENOSPC" logic be used.

			/*

			 * Update inode->i_flags - S_ENCRYPTED will be enabled,

			 * S_DAX may be disabled

 is_create */,

		/*

		 * Update inode->i_flags - S_ENCRYPTED will be enabled,

		 * S_DAX may be disabled

 for backward compatibility */

 mount option from ext2/3 */

 mount option from ext2/3 */

 mount option from ext2/3 */

 mount option from ext2/3 */

 mount option from ext2/3 */

 Default location */

 TODO: use simple_strtoll with >32bit ext4 */

	/*

	 * This mount option is just for testing, and it's not worthwhile to

	 * implement the extra complexity (e.g. RCU protection) that would be

	 * needed to allow it to be set or changed during remount.  We do allow

	 * it to be specified during remount, but only if there is no change.

 handled by get_sb_block() */

 Strictly for printing options */

		/*

		 * Initialize args struct so we know whether arg was

		 * found; some options take optional arguments.

	/*

	 * We do the test below only for project quotas. 'usrquota' and

	 * 'grpquota' mount options are allowed even without quota feature

	 * to support legacy quotas in quota files.

/*

 * Show an option if

 *  - it's set to a non-default value OR

 *  - if the per-sb default is different from the global default

 skip if same as the default */

 select Opt_noFoo vs Opt_Foo */

 Use new metadata_csum algorithm */

 old crc16 code */

 skip checksum */

 for checksum of struct ext4_group_desc do the rest...*/

 Called at mount-time, super-block is locked */

/*

 * Maximal extent format file size.

 * Resulting logical blkno at s_maxbytes must fit in our on-disk

 * extent format containers, within a sector_t, and within i_blocks

 * in the vfs.  ext4 inode has 48 bits of i_block in fsblock units,

 * so that won't be a limiting factor.

 *

 * However there is other limiting factor. We do store extents in the form

 * of starting block and length, hence the resulting length of the extent

 * covering maximum file size must fit into on-disk format containers as

 * well. Given that length is always by 1 unit bigger than max unit (because

 * we count 0 as well) we have to lower the s_maxbytes by one fs block.

 *

 * Note, this does *not* consider any metadata overhead for vfs i_blocks.

 total blocks in file system block size */

	/*

	 * 32-bit extent-start container, ee_block. We lower the maxbytes

	 * by one fs block, so ee_len can cover the extent of maximum file

	 * size

 Sanity check against vm- & vfs- imposed limits */

/*

 * Maximal bitmap file size.  There is a direct, and {,double-,triple-}indirect

 * block limit, and also a limit of (2^48 - 1) 512-byte sectors in i_blocks.

 * We need to be 1 filesystem block less than the 2^48 sector limit.

	/*

	 * This is calculated to be the largest file size for a dense, block

	 * mapped file such that the file's total number of 512-byte sectors,

	 * including data and all indirect blocks, does not exceed (2^48 - 1).

	 *

	 * __u32 i_blocks_lo and _u16 i_blocks_high represent the total

	 * number of 512-byte sectors of the file.

		/*

		 * !has_huge_files or implies that the inode i_block field

		 * represents total file blocks in 2^32 512-byte sectors ==

		 * size of vfs inode i_blocks * 8

 total blocks in file system block size */

		/*

		 * We use 48 bit ext4_inode i_blocks

		 * With EXT4_HUGE_FILE_FL set the i_blocks

		 * represent total number of blocks in

		 * file system block size

 indirect blocks */

 double indirect blocks */

 tripple indirect blocks */

	/*

	 * If we have a meta_bg fs with 1k blocks, group 0's GDT is at

	 * block 2, not 1.  If s_first_data_block == 0 (bigalloc is enabled

	 * on modern mke2fs or blksize > 1k on older mke2fs) then we must

	 * compensate.

/**

 * ext4_get_stripe_size: Get the stripe size.

 * @sbi: In memory super block info

 *

 * If we have specified it via mount option, then

 * use the mount option value. If the value specified at mount time is

 * greater than the blocks per group use the super block value.

 * If the super block value is greater than blocks per group return 0.

 * Allocator needs it be less than blocks per group.

 *

	/*

	 * If the stripe width is 1, this makes no sense and

	 * we set it to 0 to turn off stripe handling code.

/*

 * Check whether this filesystem can be mounted based on

 * the features present and the RDONLY/RDWR mount requested.

 * Returns 1 if this filesystem can be mounted as requested,

 * 0 if it cannot be.

 Check that feature set is OK for a read-write mount */

 CONFIG_QUOTA */

/*

 * This function is called once a day if we have errors logged

 * on the file system

 fsck newer than v1.41.13 is needed to clean this condition. */

 Once a day */

 Find next suitable group and run ext4_init_inode_table */

/*

 * Remove lr_request from the list_request and free the

 * request structure. Should be called with li_list_mtx held

/*

 * This is the function where ext4lazyinit thread lives. It walks

 * through the request list searching for next scheduled filesystem.

 * When such a fs is found, run the lazy initialization request

 * (ext4_rn_li_request) and keep track of the time spend in this

 * function. Based on that time we compute next schedule time of

 * the request. When walking through the list is complete, compute

 * next waking time and put itself into sleep.

					/*

					 * We hold sb->s_umount, sb can not

					 * be removed from the list, it is

					 * now safe to drop li_list_mtx

 error, remove the lazy_init job */

	/*

	 * It looks like the request list is empty, but we need

	 * to check it under the li_list_mtx lock, to prevent any

	 * additions into it, and of course we should lock ext4_li_mtx

	 * to atomically free the list and ext4_li_info, because at

	 * this point another ext4 filesystem could be registering

	 * new one.

/*

 * Check whether it make sense to run itable init. thread or not.

 * If there is at least one uninitialized inode table, return

 * corresponding group number, else the loop goes through all

 * groups and return total number of groups.

	/*

	 * Randomize first schedule time of the request to

	 * spread the inode table initialization requests

	 * better.

		/*

		 * Reset timeout so it can be computed again, because

		 * s_li_wait_mult might have changed.

	/*

	 * set elr to NULL here since it has been inserted to

	 * the request_list and the removal and free of it is

	 * handled by ext4_clear_request_list from now on.

/*

 * We do not need to lock anything since this is called on

 * module unload.

	/*

	 * If thread exited earlier

	 * there's nothing to be done.

 journal checksum v3 */

 journal checksum v1 */

/*

 * Note: calculating the overhead so we can be compatible with

 * historical BSD practice is quite difficult in the face of

 * clusters/bigalloc.  This is because multiple metadata blocks from

 * different block group can end up in the same allocation cluster.

 * Calculating the exact overhead in the face of clustered allocation

 * requires either O(all block bitmaps) in memory or O(number of block

 * groups**2) in time.  We will still calculate the superblock for

 * older file systems --- and if we come across with a bigalloc file

 * system with zero in s_overhead_clusters the estimate will be close to

 * correct especially for very large cluster sizes --- but for newer

 * file systems, it's better to calculate this figure once at mkfs

 * time, and store it in the superblock.  If the superblock value is

 * present (even for non-bigalloc file systems), we will use it.

/*

 * Compute the overhead and stash it in sbi->s_overhead

	/*

	 * Compute the overhead (FS structures).  This is constant

	 * for a given filesystem unless the number of block groups

	 * changes so we cache the previous value until it does.

	/*

	 * All of the blocks before first_data_block are overhead

	/*

	 * Add the overhead found in each block group

	/*

	 * Add the internal journal blocks whether the journal has been

	 * loaded or not

 j_inum for internal journal is non-zero */

	/*

	 * There's no need to reserve anything when we aren't using extents.

	 * The space estimates are exact, there are no unwritten extents,

	 * hole punching doesn't need new metadata... This is needed especially

	 * to keep ext2/3 backward compatibility.

	/*

	 * By default we reserve 2% or 4096 clusters, whichever is smaller.

	 * This should cover the situations where we can not afford to run

	 * out of space like for example punch hole, or converting

	 * unwritten extents in delalloc path. In most cases such

	 * allocation would require 1, or 2 blocks, higher numbers are

	 * very rare.

 Set defaults for the variables that will be set during parsing */

 Cleanup superblock name */

 -EINVAL is default */

	/*

	 * The ext4 superblock will not be buffer aligned for other than 1kB

	 * block sizes.  We need to calculate the offset from buffer start.

	/*

	 * Note: s_es must be initialized as soon as possible because

	 *       some ext4 macro-instructions depend on its value

 Warn if metadata_csum and gdt_csum are both set. */

 Check for a known checksum algorithm */

 Load the checksum driver */

 Check superblock checksum */

 Precompute checksum seed for all metadata */

 Set defaults before we parse the mount options */

 xattr user namespace & acls are now defaulted on */

 don't forget to enable journal_csum when metadata_csum is enabled. */

 block_validity enabled by default; disable with noblock_validity */

	/*

	 * enable delayed allocation by default

	 * Use -o nodelalloc to turn it off

	/*

	 * set default s_li_wait_mult for lazyinit, for the case there is

	 * no mount option specified.

		/*

		 * i_atime_extra is the last extra field available for

		 * [acm]times in struct ext4_inode. Checking for that

		 * field should suffice to ensure we have extra space

		 * for all three.

 can't mount with both data=journal and dioread_nolock. */

		/*

		 * ea_inode feature uses l_i_version field which is not

		 * available in HURD_COMPAT mode.

			/*

			 * If we're probing be silent, if this looks like

			 * it's actually an ext[34] filesystem.

			/*

			 * If we're probing be silent, if this looks like

			 * it's actually an ext4 filesystem.

	/*

	 * Check feature flags regardless of the revision level, since we

	 * previously didn't change the revision level when setting the flags,

	 * so there is a chance incompat flags are set on a rev 0 filesystem.

		/*

		 * bh must be released before kill_bdev(), otherwise

		 * it won't be freed and its page also. kill_bdev()

		 * is called by sb_set_blocksize().

 Validate the filesystem blocksize */

 Handle clustersize */

 Do we have standard group size of clustersize * 8 blocks ? */

	/*

	 * Test whether we have more sectors than will fit in sector_t,

	 * and whether the max offset is addressable by the page cache.

 check blocks count against device size */

	/*

	 * It makes no sense for the first data block to be beyond the end

	 * of the filesystem.

 Pre-read the descriptors into the buffer cache */

 Register extent status tree shrinker */

	/*

	 * set up enough so that it can read an inode

 unlinked but open files */

 Initialize fast commit stuff */

	/*

	 * The first inode we look at is the journal inode.  Don't try

	 * root first: it may be modified in the journal!

 Nojournal mode, all journal mount options are illegal */

	/* We have now updated the journal if required, so we can

		/* No mode set, assume a default based on the journal

		 * capabilities: ORDERED_DATA if the journal can

		 * cope, else JOURNAL_DATA

	/*

	 * Get the # of file system overhead blocks from the

	 * superblock if present.

	/*

	 * The maximum number of concurrent works can be high and

	 * concurrency isn't really necessary.  Limit it to 1.

	/*

	 * The jbd2_journal_load will have done any necessary log recovery,

	 * so we can safely mount the rest of the filesystem now.

	/*

	 * Enable optimize_scan if number of groups is > threshold. This can be

	 * turned off by passing "mb_optimize_scan=0". This can also be

	 * turned on forcefully by passing "mb_optimize_scan=1".

	/*

	 * We can only set up the journal commit callback once

	 * mballoc is initialized

	/*

	 * Update the checksum after updating free space/inode

	 * counters.  Otherwise the superblock can have an incorrect

	 * checksum in the buffer cache until it is written out and

	 * e2fsprogs programs trying to open a file system immediately

	 * after it is mounted can fail.

 Enable quota usage during mount. */

 CONFIG_QUOTA */

	/*

	 * Save the original bdev mapping's wb_err value which could be

	 * used to detect the metadata async write error.

 5 minutes */

 Enable message ratelimiting. Default is 10 messages per 5 secs. */

 flush s_error_work before journal destroy. */

 flush s_error_work before sbi destroy */

 ext4_blkdev_remove() calls kill_bdev(), release bh before it. */

/*

 * Setup any per-fs journal parameters now.  We'll do this both on

 * initial mount, once the journal has been initialised but before we've

 * done any recovery; and again on any subsequent remount.

	/*

	 * Test for the existence of a valid inode on disk.  Bad things

	 * happen if we iget() an unused inode, as the subsequent iput()

	 * will try to delete it.

 we're done with the superblock */

	/*

	 * Are we loading a blank journal or performing recovery after a

	 * crash?  For recovery, we need to check in advance whether we

	 * can get read-write access to the device.

 Make sure we flush the recovery flag to disk. */

 Copy state of EXT4_SB(sb) into buffer for on-disk superblock */

	/*

	 * If the file system is mounted read-only, don't update the

	 * superblock write time.  This avoids updating the superblock

	 * write time when we are mounting the root file system

	 * read/only but we need to replay the journal; at that point,

	 * for people who are east of GMT and who make their clock

	 * tick in localtime for Windows bug-for-bug compatibility,

	 * the clock is set in the future, and this will cause e2fsck

	 * to complain and force a full file system check.

 Copy error information to the on-disk superblock */

		/*

		 * Start the daily error reporting function if it hasn't been

		 * started already

		/*

		 * Oh, dear.  A previous attempt to write the

		 * superblock failed.  This could happen because the

		 * USB device was yanked out.  Or it could happen to

		 * be a transient write error and maybe the block will

		 * be remapped.  Nothing we can do but to retry the

		 * write and hope for the best.

/*

 * Have we just finished recovery?  If so, and if we are mounting (or

 * remounting) the filesystem readonly, then we will end up with a

 * consistent fs on disk.  Record that fact.

/*

 * If we are mounting (or read-write remounting) a filesystem whose journal

 * has recorded an error from a previous lifetime, move that error to the

 * main filesystem now.

	/*

	 * Now check for any error status which may have been recorded in the

	 * journal by a prior ext4_error() or ext4_abort()

/*

 * Force the running and committing transactions to commit,

 * and wait on the commit.

	/*

	 * Writeback quota in non-journalled quota case - journalled quota has

	 * no dirty dquots

	/*

	 * Data writeback is possible w/o journal transaction, so barrier must

	 * being sent at the end of the function. But we can skip it if

	 * transaction_commit will do it for us.

/*

 * LVM calls this function before a (read-only) snapshot is created.  This

 * gives us a chance to flush the journal completely and mark the fs clean.

 *

 * Note that only this function cannot bring a filesystem to be in a clean

 * state independently. It relies on upper layer to stop all data & metadata

 * modifications.

 Now we set up the journal barrier. */

		/*

		 * Don't clear the needs_recovery flag if we failed to

		 * flush the journal.

 Journal blocked and flushed, clear needs_recovery flag. */

 we rely on upper layer to stop further updates */

/*

 * Called by LVM after the snapshot is done.  We need to reset the RECOVER

 * flag here, even though the filesystem is not technically dirty yet.

 Reset the needs_recovery flag before the fs is unlocked. */

/*

 * Structure to save mount options for ext4_remount's benefit

 Store the original options */

	/*

	 * Some options can be enabled by ext4 and/or by VFS mount flag

	 * either way we need to make sure it matches in both *flags and

	 * s_flags. Copy those selected flags from *flags to s_flags

 Flush outstanding errors before changing fs state */

			/*

			 * First of all, the unconditional stuff we have to do

			 * to disable replay of the journal when we next remount

			/*

			 * OK, test if we are remounting a valid rw partition

			 * readonly, and if so set the rdonly flag and then

			 * mark the partition as valid again.

				/*

				 * We let remount-ro finish even if marking fs

				 * as clean failed...

 Make sure we can mount this feature set readwrite */

			/*

			 * Make sure the group descriptor checksums

			 * are sane.  If they aren't, refuse to remount r/w.

			/*

			 * If we have an unprocessed orphan list hanging

			 * around from a previously readonly bdev mount,

			 * require a full umount/remount for now.

			/*

			 * Mounting a RDONLY partition read-write, so reread

			 * and store the current valid flag.  (It may have

			 * been changed by e2fsck since we originally mounted

			 * the partition.)

	/*

	 * Reinitialize lazy itable initialization thread based on

	 * current settings

	/*

	 * Handle creation of system zone data early because it can fail.

	 * Releasing of existing data is done when we are sure remount will

	 * succeed.

 Release old quota file names */

	/*

	 * Some options can be enabled by ext4 and/or by VFS mount flag

	 * either way we need to make sure it matches in both *flags and

	 * s_flags. Copy those selected flags from s_flags to *flags

 prevent underflow in case that few free space is available */

/*

 * Helper functions so that transaction is started before we acquire dqio_sem

 * to keep correct lock ordering of transaction > dqio_sem

 Release dquot anyway to avoid endless cycle in dqput() */

 Data block + inode block */

	/* The first argument of lockdep_set_subclass has to be

	 * *exactly* the same as the argument to init_rwsem() --- in

	 * this case, in init_once() --- or lockdep gets unhappy

	 * because the name of the lock is set using the

	 * stringification of the argument to init_rwsem().

 shut up clang warning if !CONFIG_LOCKDEP */

/*

 * Standard function to be called on quota_on

 Quotafile not on the same filesystem? */

 Quota already enabled for this file? */

 Journaling quota? */

 Quotafile not in fs root? */

		/*

		 * Clear the flag just in case mount options changed since

		 * last time.

	/*

	 * When we journal data on quota file, we have to flush journal to see

	 * all updates to the file when we bypass pagecache...

		/*

		 * We don't need to lock updates but journal_flush() could

		 * otherwise be livelocked...

		/*

		 * Set inode flags to prevent userspace from messing with quota

		 * files. If this fails, we return success anyway since quotas

		 * are already enabled and this is not a hard failure.

 Don't account quota for quota files to avoid recursion */

 Enable usage tracking for all quota types. */

	/* Force all delayed allocation blocks to be allocated.

	/*

	 * Update modification times of quota files when userspace can

	 * start looking at them. If we fail, we return success anyway since

	 * this is not a hard failure and quotas are already disabled.

/* Read data from quotafile - avoid pagecache and such because we cannot afford

 * acquiring the locks... As quota files are never truncated and quota code

 * itself serializes the operations (and no one else should touch the files)

 A hole? */

/* Write to quotafile (we know the transaction is already started and has

	/*

	 * Since we account only one data block in transaction credits,

	 * then it is impossible to cross a block boundary.

 Shared across all ext4 file systems */

 Build-time check for flags consistency */

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/ext4/xattr_hurd.c

 * Handler for extended gnu attributes for the Hurd.

 *

 * Copyright (C) 2001 by Andreas Gruenbacher, <a.gruenbacher@computer.org>

 * Copyright (C) 2020 by Jan (janneke) Nieuwenhuizen, <janneke@gnu.org>

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/ext4/ialloc.c

 *

 * Copyright (C) 1992, 1993, 1994, 1995

 * Remy Card (card@masi.ibp.fr)

 * Laboratoire MASI - Institut Blaise Pascal

 * Universite Pierre et Marie Curie (Paris VI)

 *

 *  BSD ufs-inspired inode and directory allocation by

 *  Stephen Tweedie (sct@redhat.com), 1993

 *  Big-endian to little-endian byte-swapping/bitmaps by

 *        David S. Miller (davem@caip.rutgers.edu), 1995

/*

 * ialloc.c contains the inodes allocation and deallocation routines

/*

 * The free inodes are managed by bitmaps.  A file system contains several

 * blocks groups.  Each group contains 1 bitmap block for blocks, 1 bitmap

 * block for inodes, N blocks for the inode table and data blocks.

 *

 * The file system contains group descriptors which are located after the

 * super block.  Each descriptor contains the number of the bitmap block and

 * the free blocks count in the block.

/*

 * To avoid calling the atomic setbit hundreds or thousands of times, we only

 * need to use it within a single byte (to ensure we get endianness right).

 * We can use memset for the rest of the bitmap as there are no other users.

/*

 * Read the inode allocation bitmap for a given block_group, reading

 * into the specified slot in the superblock's bitmap cache.

 *

 * Return buffer_head of bitmap on success, or an ERR_PTR on error.

		/*

		 * if not uninit if bh is uptodate,

		 * bitmap is also uptodate

	/*

	 * submit the buffer_head for reading

/*

 * NOTE! When we get the inode, we're the only people

 * that have access to it, and as such there are no

 * race conditions we have to worry about. The inode

 * is not on the hash-lists, and it cannot be reached

 * through the filesystem because the directory entry

 * has been deleted earlier.

 *

 * HOWEVER: we must make sure that we get no aliases,

 * which means that we have to call "clear_inode()"

 * _before_ we mark the inode not in use in the inode

 * bitmaps. Otherwise a newly created file might use

 * the same inode number (not actually the same pointer

 * though), and then we'd have two inodes sharing the

 * same inode number and space on the harddisk.

 Do this BEFORE marking the inode not in use or returning an error */

 Don't bother if the inode bitmap is corrupt. */

/*

 * Helper function for Orlov's allocator; returns critical information

 * for a particular block group or flex_bg.  If flex_size is 1, then g

 * is a block group number; otherwise it is flex_bg number.

/*

 * Orlov's allocator for directories.

 *

 * We always try to spread first-level directories.

 *

 * If there are blockgroups with both free inodes and free clusters counts

 * not worse than average we return one with smallest directory count.

 * Otherwise we simply return a random group.

 *

 * For the rest rules look so:

 *

 * It's OK to put directory into a group unless

 * it has too many directories already (max_dirs) or

 * it has too few free inodes left (min_inodes) or

 * it has too few free clusters left (min_clusters) or

 * Parent's group is preferred, if it doesn't satisfy these

 * conditions we search cyclically through the rest. If none

 * of the groups look good we just look for a group with more

 * free inodes than average (starting at parent's group).

		/*

		 * We pack inodes at the beginning of the flexgroup's

		 * inode tables.  Block allocation decisions will do

		 * something similar, although regular files will

		 * start at 2nd block group of the flexgroup.  See

		 * ext4_ext_find_goal() and ext4_find_near().

	/*

	 * Start looking in the flex group where we last allocated an

	 * inode for this parent directory

		/*

		 * The free-inodes counter is approximate, and for really small

		 * filesystems the above test can fail to find any blockgroups

	/*

	 * Try to place the inode is the same flex group as its

	 * parent.  If we can't find space, use the Orlov algorithm to

	 * find another flex group, and store that information in the

	 * parent directory's inode information so that use that flex

	 * group for future allocations.

		/*

		 * If this didn't work, use the Orlov search algorithm

		 * to find a new flex group; we pass in the mode to

		 * avoid the topdir algorithms.

	/*

	 * Try to place the inode in its parent directory

	/*

	 * We're going to place this inode in a different blockgroup from its

	 * parent.  We want to cause files in a common directory to all land in

	 * the same blockgroup.  But we want files which are in a different

	 * directory which shares a blockgroup with our parent to land in a

	 * different blockgroup.

	 *

	 * So add our directory's i_ino into the starting point for the hash.

	/*

	 * Use a quadratic hash to find a group with a free inode and some free

	 * blocks.

	/*

	 * That failed: try linear search for a free inode, even if that group

	 * has no free blocks.

/*

 * In no journal mode, if an inode has recently been deleted, we want

 * to avoid reusing it until we're reasonably sure the inode table

 * block has been written back to disk.  (Yes, these values are

 * somewhat arbitrary...)

		/*

		 * If the block is not in the buffer cache, then it

		 * must have been written out.

	/* i_dtime is only 32 bits on disk, but we only care about relative

	 * times in the range of a few minutes (i.e. long enough to sync a

	 * recently-deleted inode to disk), so using the low 32 bits of the

	/*

	 * Not reusing recently deleted inodes is mostly a preference. We don't

	 * want to report ENOSPC or skew allocation patterns because of that.

	 * So return even recently deleted inode if we could find better in the

	 * given range.

 We may have to initialize the block bitmap if it isn't already */

 recheck and clear flag under lock if we still need to */

 Update the relevant bg descriptor fields */

 while we modify the bg desc */

		/*

		 * Check the relative inode number against the last used

		 * relative inode number in this group. if it is greater

		 * we need to update the bg_itable_unused count

 inode */,

 block_bh */, acl_size,

 is_create */);

		/*

		 * We assume that security xattrs are never more than 1k.

		 * In practice they are under 128 bytes.

 inode */,

 block_bh */, 1024,

 is_create */);

 inode */,

 block_bh */,

 is_create */);

/*

 * There are two policies for allocating an inode.  If the new inode is

 * a directory, then a forward search is made for a block group with both

 * free space and a low directory-to-inode ratio; if that fails, then of

 * the groups with above-average free space, that group with the fewest

 * directories already is chosen.

 *

 * For other inodes, search forward from the parent directory's block

 * group to find a free inode.

 Cannot create files in a deleted directory */

	/*

	 * Initialize owners and quota early so that we don't have to account

	 * for quota initialization worst case in standard inode creating

	 * transaction

	/*

	 * Normally we will only go through one pass of this loop,

	 * unless we get unlucky and it turns out the group we selected

	 * had its last inode grabbed by someone else.

		/*

		 * Check free inodes count before loading bitmap.

			/*

			 * Skip groups with already-known suspicious inode

			 * tables

 Skip groups with suspicious inode tables */

			/* Someone already took the bit. Repeat the search

			 * with lock held.

 we didn't grab the inode */

 the inode bitmap is zero-based */

 we grabbed the inode! */

 We may have to initialize the block bitmap if it isn't already */

 recheck and clear flag under lock if we still need to */

 Update the relevant bg descriptor fields */

			down_read(&grp->alloc_sem); /*

						     * protect vs itable

						     * lazyinit

 while we modify the bg desc */

		/*

		 * Check the relative inode number against the last used

		 * relative inode number in this group. if it is greater

		 * we need to update the bg_itable_unused count

 This is the optimal IO size (for stat), not the fs block size */

 Don't inherit extent flag from directory, amongst others. */

		/*

		 * Likely a bitmap corruption causing inode to be allocated

		 * twice.

 Precompute checksum seed for inode metadata */

 Only relevant on 32-bit archs */

	/*

	 * Since the encryption xattr will always be unique, create it first so

	 * that it's less likely to end up in an external xattr block and

	 * prevent its deduplication.

 set extent flag only for directory, file and normal symlink*/

 Verify that we are loading a valid orphan from disk */

	/* Having the inode bit set should be a 100% indicator that this

	 * is a valid orphan (no e2fsck run on fs).  Orphans also include

	 * inodes that were being truncated, so we can't check i_nlink==0.

	/*

	 * If the orphans has i_nlinks > 0 then it should be able to

	 * be truncated, otherwise it won't be removed from the orphan

	 * list during processing and an infinite loop will result.

	 * Similarly, it must not be a bad inode.

 Avoid freeing blocks if we got a bad deleted inode */

 Called at mount-time, super-block is locked */

/*

 * Zeroes not yet zeroed inode table - just write zeroes through the whole

 * inode table. Must be called without any spinlock held. The only place

 * where it is called from on active part of filesystem is ext4lazyinit

 * thread, so we do not need any special locks, however we have to prevent

 * inode allocation from the current group, so we take alloc_sem lock, to

 * block ext4_new_inode() until we are finished.

 This should not happen, but just to be sure check this */

	/*

	 * We do not need to lock this, because we are the only one

	 * handling this flag.

	/*

	 * If inode bitmap was already initialized there may be some

	 * used inodes so we need to skip blocks with used inodes in

	 * inode table.

 Bogus inode unused count? */

		/*

		 * Are there some uninitialized inodes in the inode table

		 * before the first normal inode?

	/*

	 * Skip zeroout if the inode table is full. But we set the ZEROED

	 * flag anyway, because obviously, when it is full it does not need

	 * further zeroing.

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/ext4/readpage.c

 *

 * Copyright (C) 2002, Linus Torvalds.

 * Copyright (C) 2015, Google, Inc.

 *

 * This was originally taken from fs/mpage.c

 *

 * The ext4_mpage_readpages() function here is intended to

 * replace mpage_readahead() in the general case, not just for

 * encrypted files.  It has some limitations (see below), where it

 * will fall back to read_block_full_page(), but these limitations

 * should only be hit when page_size != block_size.

 *

 * This will allow us to attach a callback function to support ext4

 * encryption.

 *

 * If anything unusual happens, such as:

 *

 * - encountering a page which has buffers

 * - encountering a page which has a non-hole after a hole

 * - encountering a page with non-contiguous blocks

 *

 * then this code just gives up and calls the buffer_head-based read function.

 * It does handle a page which has holes at the end - that is a common case:

 * the end-of-file on blocksize < PAGE_SIZE setups.

 *

 postprocessing steps for read bios */

 PG_error was set if any post_read step failed */

 will re-read again later */

	/*

	 * fsverity_verify_bio() may call readpages() again, and although verity

	 * will be disabled for that, decryption may still be needed, causing

	 * another bio_post_read_ctx to be allocated.  So to guarantee that

	 * mempool_alloc() never deadlocks we must free the current ctx first.

	 * This is safe because verity is the last post-read step.

	/*

	 * We use different work queues for decryption and for verity because

	 * verity may require reading metadata pages that need decryption, and

	 * we shouldn't recurse to the same workqueue.

/*

 * I/O completion handler for multipage BIOs.

 *

 * The mpage code never puts partial pages into a BIO (except for end-of-file).

 * If a page does not map to a contiguous run of blocks then it simply falls

 * back to block_read_full_page().

 *

 * Why is this?  If a page's completion depends on a number of different BIOs

 * which can complete in any order (or at the same time) then determining the

 * status of that page is hard.  See end_buffer_async_read() for the details.

 * There is no point in duplicating all that complexity.

 Due to the mempool, this never fails. */

		/*

		 * Map blocks using the previous result first.

 needed? */

		/*

		 * Then do more ext4_map_blocks() calls until we are

		 * done with this page.

 hole -> non-hole */

 Contiguous blocks? */

 needed? */

		/*

		 * This page will go to BIO.  Do we need to send this

		 * BIO off first?

			/*

			 * bio_alloc will _always_ be able to allocate a bio if

			 * __GFP_DIRECT_RECLAIM is set, see bio_alloc_bioset().

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/ext4/xattr.c

 *

 * Copyright (C) 2001-2003 Andreas Gruenbacher, <agruen@suse.de>

 *

 * Fix by Harrison Xing <harrison@mountainviewdata.com>.

 * Ext4 code with a lot of help from Eric Jarman <ejarman@acm.org>.

 * Extended attributes for symlinks and special files added per

 *  suggestion of Luka Renko <luka.renko@hermes.si>.

 * xattr consolidation Copyright (c) 2004 James Morris <jmorris@redhat.com>,

 *  Red Hat Inc.

 * ea-in-inode support by Alex Tomas <alex@clusterfs.com> aka bzzz

 *  and Andreas Gruenbacher <agruen@suse.de>.

/*

 * Extended attributes are stored directly in inodes (on file systems with

 * inodes bigger than 128 bytes) and on additional disk blocks. The i_file_acl

 * field contains the block number if an inode uses an additional block. All

 * attributes must fit in the inode and one additional block. Blocks that

 * contain the identical set of attributes may be shared among several inodes.

 * Identical blocks are detected by keeping a cache of blocks that have

 * recently been accessed.

 *

 * The attributes in inodes and on blocks have a different header; the entries

 * are stored in the same format:

 *

 *   +------------------+

 *   | header           |

 *   | entry 1          | |

 *   | entry 2          | | growing downwards

 *   | entry 3          | v

 *   | four null bytes  |

 *   | . . .            |

 *   | value 1          | ^

 *   | value 3          | | growing upwards

 *   | value 2          | |

 *   +------------------+

 *

 * The header is followed by multiple entry descriptors. In disk blocks, the

 * entry descriptors are kept sorted. In inodes, they are unsorted. The

 * attribute values are aligned to the end of the block in no specific order.

 *

 * Locking strategy

 * ----------------

 * EXT4_I(inode)->i_file_acl is protected by EXT4_I(inode)->xattr_sem.

 * EA blocks are only changed if they are exclusive to an inode, so

 * holding xattr_sem also means that nothing but the EA block's reference

 * count can change. Multiple writers to the same block are synchronized

 * by the buffer lock.

 Find the end of the names list */

 Check the values */

			/*

			 * The value cannot overlap the names, and the value

			 * with padding cannot extend beyond 'end'.  Check both

			 * the padded and unpadded sizes, since the size may

			 * overflow to 0 when adding padding.

/*

 * Read the EA value from an inode.

 block */, bh_count,

 wait */, bhs);

 There shouldn't be any holes in ea_inode. */

	/*

	 * Check whether this is an old Lustre-style xattr inode. Lustre

	 * implementation does not have hash validation, rather it has a

	 * backpointer from ea_inode to the parent inode.

 Verify stored hash matches calculated hash. */

 Verify entry hash. */

/*

 * Read xattr value from the EA inode.

 reusable */);

/*

 * ext4_xattr_get()

 *

 * Copy an extended attribute into the buffer

 * provided, or compute the buffer size required.

 * Buffer is NULL to compute the size of the buffer required.

 *

 * Returns a negative error number on failure, or the number of bytes

 * used / required on success.

 total size */

/*

 * Inode operation listxattr()

 *

 * d_inode(dentry)->i_rwsem: don't care

 *

 * Copy a list of attribute names into the buffer

 * provided, or compute the buffer size required.

 * Buffer is NULL to compute the size of the buffer required.

 *

 * Returns a negative error number on failure, or the number of bytes

 * used / required on success.

/*

 * If the EXT4_FEATURE_COMPAT_EXT_ATTR feature of this file system is

 * not set, set it.

	/*

	 * 1) Owner inode update

	 * 2) Ref count update on old xattr block

	 * 3) new xattr block

	 * 4) block bitmap update for new xattr block

	 * 5) group descriptor for new xattr block

	 * 6) block bitmap update for old xattr block

	 * 7) group descriptor for old block

	 *

	 * 6 & 7 can happen if we have two racing threads T_a and T_b

	 * which are each trying to set an xattr on inodes I_a and I_b

	 * which were both initially sharing an xattr block.

 Quota updates. */

	/*

	 * In case of inline data, we may push out the data to a block,

	 * so we need to reserve credits for this eventuality

 We are done if ea_inode feature is not enabled. */

 New ea_inode, inode map, block bitmap, group descriptor. */

 Data blocks. */

 Indirection block or one level of extent tree. */

 Block bitmap and group descriptor updates for each block. */

 Blocks themselves. */

		/* Dereference ea_inode holding old xattr value.

		 * Old ea_inode, inode map, block bitmap, group descriptor.

 Data blocks for old ea_inode. */

		/* Indirection block or one level of extent tree for old

		 * ea_inode.

 Block bitmap and group descriptor updates for each block. */

	/* We may need to clone the existing xattr block in which case we need

	 * to increment ref counts for existing ea_inodes referenced by it.

 Ref count update on ea_inode. */

 reusable */);

 One credit for dec ref on ea_inode, one for orphan list addition, */

		/*

		 * Forget about ea_inode within the same transaction that

		 * decrements the ref count. This avoids duplicate decrements in

		 * case the rest of the work spills over to subsequent

		 * transactions.

		/*

		 * Note that we are deliberately skipping csum calculation for

		 * the final update because we do not expect any journal

		 * restarts until xattr block is freed.

/*

 * Release the xattr block BH: If the reference count is > 1, decrement it;

 * otherwise free the block.

		/*

		 * This must happen under buffer lock for

		 * ext4_xattr_block_set() to reliably detect freed block

 block_csum */,

 skip_quota */);

		/*

		 * Beware of this ugliness: Releasing of xattr block references

		 * from different inodes can race and so we have to protect

		 * from a race where someone else frees the block (and releases

		 * its journal_head) before we are done dirtying the buffer. In

		 * nojournal mode this race is harmless and we actually cannot

		 * call ext4_handle_dirty_metadata() with locked buffer as

		 * that function can call sync_dirty_buffer() so for that case

		 * we handle the dirtying after unlocking the buffer.

/*

 * Find the available free space for EAs. This also returns the total number of

 * bytes used by EA entries.

/*

 * Write the value of the EA in an inode.

/*

 * Create an inode to store the value of a large EA.

	/*

	 * Let the next inode be the goal, so we try and allocate the EA inode

	 * in the same group, or nearby one.

		/*

		 * Xattr inodes are shared therefore quota charging is performed

		 * at a higher level.

/*

 * Add value of the EA in an inode.

 Create an inode for the EA value */

 reusable */);

/*

 * Reserve min(block_size/8, 1024) bytes for xattr entries/names if ea_inode

 * feature is enabled.

 Space used by old and new values. */

	/*

	 * Optimization for the simple case when old and new values have the

	 * same padded sizes. Not applicable if external inodes are involved.

 Clear padding bytes. */

 Compute min_offs and last. */

 Check whether we have enough space. */

		/*

		 * If storing the value in an external inode is an option,

		 * reserve space for xattr entries/names in the external

		 * attribute block so that a long value does not occupy the

		 * whole space and prevent further entries being added.

	/*

	 * Getting access to old and new ea inodes is subject to failures.

	 * Finish that work before doing any modifications to the xattr data.

 We are ready to release ref count on the old_ea_inode. */

 Release newly required ref count on new_ea_inode. */

 No failures allowed past this point. */

 Remove the old value. */

 Adjust all value offsets. */

 Remove old name. */

 Insert new name. */

 This is an update, reset value info. */

 Insert new value. */

 Clear padding bytes. */

 Entry hash calculation. */

			/*

			 * Feed crc32c hash instead of the raw value for entry

			 * hash calculation. This is to avoid walking

			 * potentially long value buffer again.

 The inode already has an extended attribute block. */

 Find the named attribute. */

			/*

			 * This must happen under buffer lock for

			 * ext4_xattr_block_set() to reliably detect modified

			 * block

 is_block */);

			/*

			 * If existing entry points to an xattr inode, we need

			 * to prevent ext4_xattr_set_entry() from decrementing

			 * ref count on it because the reference belongs to the

			 * original block. In this case, make the entry look

			 * like it has an empty value.

					/*

					 * Defer quota free call for previous

					 * inode until success is guaranteed.

 Allocate a buffer where we construct the new block. */

 is_block */);

		/*

		 * A ref count on ea_inode has been taken as part of the call to

		 * ext4_xattr_set_entry() above. We would like to drop this

		 * extra ref but we have to wait until the xattr block is

		 * initialized and has its own ref count on the ea_inode.

 We found an identical block in the cache. */

				/* The old block is released after updating

				/*

				 * We have to be careful about races with

				 * freeing, rehashing or adding references to

				 * xattr block. Once we hold buffer lock xattr

				 * block's state is stable so we can check

				 * whether the block got freed / rehashed or

				 * not.  Since we unhash mbcache entry under

				 * buffer lock when freeing / rehashing xattr

				 * block, checking whether entry is still

				 * hashed is reliable. Same rules hold for

				 * e_reusable handling.

					/*

					 * Undo everything and check mbcache

					 * again.

 We were modifying this block in-place. */

 We need to allocate a new block */

 non-extent files can't have physical blocks past 2^32 */

 Drop the extra ref on ea_inode. */

 Update the inode. */

 Drop the previous xattr block. */

 extra_credits */);

 If there was an error, revert the quota charge. */

 Find the named attribute. */

 is_block */);

 When e_value_inum is set the value is stored externally. */

/*

 * ext4_xattr_set_handle()

 *

 * Create, replace or remove an extended attribute for this inode.  Value

 * is NULL to remove an existing extended attribute, and non-NULL to

 * either replace an existing extended attribute, or create a new extended

 * attribute. The flags XATTR_REPLACE and XATTR_CREATE

 * specify that an extended attribute must exist and must not exist

 * previous to the call, respectively.

 *

 * Returns 0, or a negative error number on failure.

 Check journal credits under write lock. */

 Xattr value did not change? Save us some work and bail out */

				/*

				 * Xattr does not fit in the block, store at

				 * external inode if possible.

		/*

		 * The bh is consumed by ext4_mark_iloc_dirty, even with

		 * error != 0.

/*

 * ext4_xattr_set()

 *

 * Like ext4_xattr_set_handle, but start from an inode. This extended

 * attribute modification is a filesystem transaction by itself.

 *

 * Returns 0, or a negative error number on failure.

/*

 * Shift the EA entries in the inode to create space for the increased

 * i_extra_isize.

 We always shift xattr headers further thus offsets get lower */

 Adjust the value offsets of the entries */

 Shift the entries by n bytes */

/*

 * Move xattr pointed to by 'entry' from inode into external xattr block

 Save the entry name and the entry value */

 Remove the chosen entry from the inode */

 Add entry which was removed from the inode into the block */

 EA entry size */

 EA entry size + value size */

 Find the entry best suited to be pushed into EA block */

 never move system.data out of the inode */

/*

 * Expand an inode by new_extra_isize bytes when EAs are present.

 * Returns 0 on success or negative error number on failure.

 How much do we need to grow i_extra_isize */

	/*

	 * Check if enough free space is available in the inode to shift the

	 * entries ahead by new_extra_isize.

	/*

	 * Enough free space isn't available in the inode, check if

	 * EA block can hold new_extra_isize bytes.

 Adjust the offsets and shift the remaining entries ahead */

 must be 2^n */

/* Add the large xattr @inode into @ea_inode_array for deferred iput().

 * If @ea_inode_array is new or full it will be grown and the old

 * contents copied over.

		/*

		 * Start with 15 inodes, so it fits into a power-of-two size.

		 * If *ea_inode_array is NULL, this is essentially offsetof()

 expand the array once all 15 + n * 16 slots are full */

 if new_array is NULL, this is essentially offsetof() */

/*

 * ext4_xattr_delete_inode()

 *

 * Free extended attribute resources associated with this inode. Traverse

 * all entries and decrement reference on any xattr inodes associated with this

 * inode. This is called immediately before an inode is freed. We have exclusive

 * access to the inode. If an orphan inode is deleted it will also release its

 * references on xattr block and xattr inodes.

 block_csum */,

 skip_quota */);

		/*

		 * Update i_file_acl value in the same transaction that releases

		 * block.

/*

 * ext4_xattr_block_cache_insert()

 *

 * Create a new entry in the extended attribute block cache, and insert

 * it unless such an entry is already in the cache.

 *

 * Returns 0, or a negative error number on failure.

/*

 * ext4_xattr_cmp()

 *

 * Compare two extended attribute blocks for equality.

 *

 * Returns 0 if the blocks are equal, 1 if they differ, and

 * a negative error number on errors.

/*

 * ext4_xattr_block_cache_find()

 *

 * Find an identical extended attribute block.

 *

 * Returns a pointer to the block found, or NULL if such a block was

 * not found or an error occurred.

 never share */

/*

 * ext4_xattr_hash_entry()

 *

 * Compute the hash of an extended attribute.

/*

 * ext4_xattr_rehash()

 *

 * Re-compute the extended attribute hash value after an entry has changed.

 Block is not shared if an entry's hash value == 0 */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2003-2006, Cluster File Systems, Inc, info@clusterfs.com

 * Written by Alex Tomas <alex@clusterfs.com>

 *

 * Architecture independence:

 *   Copyright (c) 2005, Bull S.A.

 *   Written by Pierre Peiffer <pierre.peiffer@bull.net>

/*

 * Extents support for EXT4

 *

 * TODO:

 *   - ext4*_error() should be used in some situations

 *   - analyze all BUG()/BUG_ON(), use -EIO where appropriate

 *   - smart tree reduction

/*

 * used by extent splitting.

#define EXT4_EXT_MAY_ZEROOUT	0x1  /* safe to zeroout if split fails \

 mark first half unwritten */

 mark second half unwritten */

 first half contains valid data */

 second half contains valid data */

	/*

	 * Drop i_data_sem to avoid deadlock with ext4_map_blocks.  At this

	 * moment, get_block can be called only for blocks inside i_size since

	 * page cache has been already dropped and writes are blocked by

	 * i_mutex. So we can safely drop the i_data_sem here.

/*

 * Make sure 'handle' has at least 'check_cred' credits. If not, restart

 * transaction with 'restart_cred' credits. The function drops i_data_sem

 * when restarting transaction and gets it after transaction is restarted.

 *

 * The function returns 0 on success, 1 if transaction had to be restarted,

 * and < 0 in case of fatal error.

/*

 * could return:

 *  - EROFS

 *  - ENOMEM

 path points to block */

		/*

		 * The extent buffer's verified bit will be set again in

		 * __ext4_ext_dirty(). We could leave an inconsistent

		 * buffer if the extents updating procudure break off du

		 * to some error happens, force to check it again.

 path points to leaf/index in inode body */

 we use in-core data, no need to protect them */

/*

 * could return:

 *  - EROFS

 *  - ENOMEM

 *  - EIO

 path points to block */

 Extents updating done, re-set verified flag */

 path points to leaf/index in inode body */

		/*

		 * Try to predict block placement assuming that we are

		 * filling in a file which will eventually be

		 * non-sparse --- i.e., in the case of libbfd writing

		 * an ELF object sections out-of-order but in a way

		 * the eventually results in a contiguous object or

		 * executable file, or some database extending a table

		 * space file.  However, this is actually somewhat

		 * non-ideal if we are writing a sparse file such as

		 * qemu or KVM writing a raw image file that is going

		 * to stay fairly sparse, since it will end up

		 * fragmenting the file system's free space.  Maybe we

		 * should have some hueristics or some way to allow

		 * userspace to pass a hint to file system,

		 * especially if the latter case turns out to be

		 * common.

		/* it looks like index is empty;

 OK. use inode's group */

/*

 * Allocation for a meta data block

	/*

	 * We allow neither:

	 *  - zero length

	 *  - overflow/wrap-around

 leaf entries */

		/*

		 * The logical block in the first entry should equal to

		 * the number in the index block.

 Check for overlapping extents */

		/*

		 * The logical block in the first entry should equal to

		 * the number in the parent index block.

 Check for overlapping index extents */

 Verify checksum on non-root extent tree nodes */

	/*

	 * If this is a leaf block, cache all of its entries

/*

 * This function is called to cache a file's extent information in the

 * extent status tree

 not an extent-mapped inode */

 Don't cache anything if there are no external extent blocks */

		/*

		 * If this is a leaf block or we've reached the end of

		 * the index block, go up

/*

 * ext4_ext_binsearch_idx:

 * binary search for the closest index of the given block

 * the header must be checked before calling this

/*

 * ext4_ext_binsearch:

 * binary search for closest extent of the given block

 * the header must be checked before calling this

		/*

		 * this leaf is empty:

		 * we get such a leaf in split/add case

 account possible depth increase */

 walk through the tree */

 find extent */

 if not an empty leaf */

/*

 * ext4_ext_insert_index:

 * insert new index [@logical;@ptr] into the block at @curp;

 * check where to insert: before @curp or after @curp

 insert after */

 insert before */

/*

 * ext4_ext_split:

 * inserts new subtree into the path, using free index entry

 * at depth @at:

 * - allocates all needed blocks (new leaf and all intermediate index blocks)

 * - makes decision where to split

 * - moves remaining extents and index entries (right to the split point)

 *   into the newly allocated blocks

 * - initializes subtree

 array of allocated blocks */

 make decision: where to split? */

 FIXME: now decision is simplest: at current extent */

	/* if current leaf will be split, then we should use

	/*

	 * If error occurs, then we break processing

	 * and mark filesystem read-only. index won't

	 * be inserted and tree will be in consistent

	 * state. Next mount will repair buffers too.

	/*

	 * Get array to track all allocated blocks.

	 * We need this to handle errors and free blocks

	 * upon them.

 allocate all needed blocks */

 initialize new leaf */

 move remainder of path[depth] to the new leaf */

 start copy from next extent */

 zero out unused area in the extent block */

 correct old leaf */

 create intermediate indexes */

 insert new index into current index block */

 current depth stored in i var */

 move remainder of path[i] to the new index block */

 start copy indexes */

 zero out unused area in the extent block */

 correct old index */

 insert new index */

 free all allocated blocks in error case */

/*

 * ext4_ext_grow_indepth:

 * implements tree growing procedure:

 * - allocates new block

 * - moves top-level data (index block or leaf) into the new block

 * - initializes new top-level, creating index that points to the

 *   just created block

 Try to prepend new index to old one */

 move top-level index/leaf into new block */

 zero out unused area in the extent block */

 set size of new block */

	/* old root could have indexes or leaves

 Update top-level index: num,max,pointer */

 Root extent block becomes index block */

/*

 * ext4_ext_create_new_leaf:

 * finds empty index and adds new leaf.

 * if no free index is found, then it requests in-depth growing.

 walk up to the tree and look for free index entry */

	/* we use already allocated block for index block,

		/* if we found index with free entry, then use that

 refill path */

 tree is full, time to grow in depth */

 refill path */

		/*

		 * only first (depth 0 -> 1) produces free space;

		 * in all other cases we have to split the grown tree

 now we need to split */

/*

 * search the closest allocated block to the left for *logical

 * and returns it at @logical + it's physical address at @phys

 * if *logical is the smallest allocated block, the function

 * returns 0 at @phys

 * return value contains 0 (success) or error code

	/* usually extent in the path covers blocks smaller

	 * then *logical, but it can be that extent is the

/*

 * Search the closest allocated block to the right for *logical

 * and returns it at @logical + it's physical address at @phys.

 * If not exists, return 0 and @phys is set to 0. We will return

 * 1 which means we found an allocated block and ret_ex is valid.

 * Or return a (< 0) error code.

 Note, NOT eh_depth; depth from top of tree */

	/* usually extent in the path covers blocks smaller

	 * then *logical, but it can be that extent is the

 next allocated block in this leaf */

 go up and search for index to the right */

 we've gone up to the root and found no index to the right */

	/* we've found index to the right, let's

	 * follow it and find the closest allocated

 subtract from p_depth to get proper eh_depth */

/*

 * ext4_ext_next_allocated_block:

 * returns allocated block in subsequent extent or EXT_MAX_BLOCKS.

 * NOTE: it considers block number from index entry as

 * allocated block. Thus, index entries have to be consistent

 * with leaves.

 leaf */

 index */

/*

 * ext4_ext_next_leaf_block:

 * returns first allocated block from next leaf or EXT_MAX_BLOCKS

 zero-tree has no leaf blocks at all */

 go to index block */

/*

 * ext4_ext_correct_indexes:

 * if leaf gets modified and modified extent is first in the leaf,

 * then we have to correct all indexes above.

 * TODO: do we need to correct tree in all cases?

 there is no tree at all */

 we correct tree if first leaf got modified only */

	/*

	 * TODO: we need correction if border is smaller than current one

 change all left-side indexes */

/*

 * This function tries to merge the "ex" extent to the next extent in the tree.

 * It always tries to merge towards right. If you want to merge towards

 * left, pass "ex - 1" as argument instead of "ex".

 * Returns 0 if the extents (ex and ex+1) were _not_ merged and returns

 * 1 if they got merged.

 merge with next extent! */

/*

 * This function does a very simple check to see if we can collapse

 * an extent tree with a single extent tree leaf block into the inode.

	/*

	 * We need to modify the block allocation bitmap and the block

	 * group descriptor to release the extent tree block.  If we

	 * can't get the journal credits, give up.

	/*

	 * Copy the extent data up to the inode

/*

 * This function tries to merge the @ex extent to neighbours in the tree, then

 * tries to collapse the extent tree into the inode.

/*

 * check if a portion of the "newext" extent overlaps with an

 * existing extent.

 *

 * If there is an overlap discovered, it updates the length of the newext

 * such that there will be no overlap, and then returns 1.

 * If there is no overlap found, it returns 0.

	/*

	 * get the next allocated block if the extent in the path

	 * is before the requested block(s)

 check for wrap through zero on extent logical start block*/

 check for overlap */

/*

 * ext4_ext_insert_extent:

 * tries to merge requested extent into the existing extent or

 * inserts requested extent as new one into the tree,

 * creating new leaf in the no-space case.

 nearest extent */

 try to insert block into found extent and return */

		/*

		 * Try to see whether we should rather test the extent on

		 * right from ex, or from the left of ex. This is because

		 * ext4_find_extent() can return either extent on the

		 * left, or on the right from the searched position. This

		 * will make merging more effective.

 Try to append newex to the ex */

 Try to prepend newex to the ex */

 probably next leaf has space for us? */

	/*

	 * There is no free space in the found leaf.

	 * We're gonna add a new leaf in the tree.

 there is no extent in this leaf, create first one */

 Insert after */

 Insert before */

 try to merge extents */

 time to correct all indexes above */

/*

 * ext4_ext_determine_hole - determine hole around given block

 * @inode:	inode we lookup in

 * @path:	path in extent tree to @lblk

 * @lblk:	pointer to logical block around which we want to determine hole

 *

 * Determine hole length (and start if easily possible) around given logical

 * block. We don't try too hard to find the beginning of the hole but @path

 * actually points to extent before @lblk, we provide it.

 *

 * The function returns the length of a hole starting at @lblk. We update @lblk

 * to the beginning of the hole if we managed to find it.

 there is no extent yet, so gap is [0;-] */

/*

 * ext4_ext_put_gap_in_cache:

 * calculate boundaries of the gap that the requested block fits into

 * and cache this gap

 There's delayed extent containing lblock? */

/*

 * ext4_ext_rm_idx:

 * removes index from the index block.

 free index block */

/*

 * ext4_ext_calc_credits_for_single_extent:

 * This routine returns max. credits that needed to insert an extent

 * to the extent tree.

 * When pass the actual path, the caller should calculate credits

 * under i_data_sem.

 probably there is space in leaf? */

			/*

			 *  There are some space in the leaf tree, no

			 *  need to account for leaf block credit

			 *

			 *  bitmaps and block group descriptor blocks

			 *  and other metadata blocks still need to be

			 *  accounted.

 1 bitmap, 1 block group descriptor */

/*

 * How many index/leaf blocks need to change/allocate to add @extents extents?

 *

 * If we add a single extent, then in the worse case, each tree level

 * index/leaf need to be changed in case of the tree split.

 *

 * If more extents are inserted, they could cause the whole tree split more

 * than once, but this is really rare.

 If we are converting the inline data, only one is needed here. */

/*

 * ext4_rereserve_cluster - increment the reserved cluster count when

 *                          freeing a cluster with a pending reservation

 *

 * @inode - file containing the cluster

 * @lblk - logical block in cluster to be reserved

 *

 * Increments the reserved cluster count and adjusts quota in a bigalloc

 * file system when freeing a partial cluster containing at least one

 * delayed and unwritten block.  A partial cluster meeting that

 * requirement will have a pending reservation.  If so, the

 * RERESERVE_CLUSTER flag is used when calling ext4_free_blocks() to

 * defer reserved and allocated space accounting to a subsequent call

 * to this function.

 only extent tail removal is allowed */

	/*

	 * if we have a partial cluster, and it's different from the

	 * cluster of the last block in the extent, we free it

	/*

	 * We free the partial cluster at the end of the extent (if any),

	 * unless the cluster is used by another extent (partial_cluster

	 * state is nofree).  If a partial cluster exists here, it must be

	 * shared with the last block in the extent.

 partial, left end cluster aligned, right end unaligned */

	/*

	 * For bigalloc file systems, we never free a partial cluster

	 * at the beginning of the extent.  Instead, we check to see if we

	 * need to free it on a subsequent call to ext4_remove_blocks,

	 * or at the end of ext4_ext_rm_leaf or ext4_ext_remove_space.

 reset the partial cluster if we've freed past it */

	/*

	 * If we've freed the entire extent but the beginning is not left

	 * cluster aligned and is not marked as ineligible for freeing we

	 * record the partial cluster at the beginning of the extent.  It

	 * wasn't freed by the preceding ext4_free_blocks() call, and we

	 * need to look farther to the left to determine if it's to be freed

	 * (not shared with another extent). Else, reset the partial

	 * cluster - we're either  done freeing or the beginning of the

	 * extent is left cluster aligned.

/*

 * ext4_ext_rm_leaf() Removes the extents associated with the

 * blocks appearing between "start" and "end".  Both "start"

 * and "end" must appear in the same extent or EIO is returned.

 *

 * @handle: The journal handle

 * @inode:  The files inode

 * @path:   The path to the leaf

 * @partial_cluster: The cluster which we'll have to free if all extents

 *                   has been released from it.  However, if this value is

 *                   negative, it's a cluster just to the right of the

 *                   punched region and it must not be freed.

 * @start:  The first block to remove

 * @end:   The last block to remove

 the header must be checked already in ext4_ext_remove_space() */

 find where to start removing */

 If this extent is beyond the end of the hole, skip it */

			/*

			 * We're going to skip this extent and move to another,

			 * so note that its first cluster is in use to avoid

			 * freeing it when removing blocks.  Eventually, the

			 * right edge of the truncated/punched region will

			 * be just to the left.

 remove tail of the extent */

 remove whole extent: excellent! */

		/*

		 * 3 for leaf, sb, and inode plus 2 (bmap and group

		 * descriptor) for each block group; assume two block

		 * groups plus ex_ee_len/blocks_per_block_group for

		 * the worst case

		/*

		 * We may end up freeing some index blocks and data from the

		 * punched range. Note that partial clusters are accounted for

		 * by ext4_free_data_revoke_credits().

 this extent is removed; mark slot entirely unused */

		/*

		 * Do not mark unwritten if all the blocks in the

		 * extent have been removed.

		/*

		 * If the extent was completely released,

		 * we need to remove it from the leaf

				/*

				 * For hole punching, we need to scoot all the

				 * extents up when an extent is removed so that

				 * we dont have blank extents in the middle

 Now get rid of the one at the end */

	/*

	 * If there's a partial cluster and at least one extent remains in

	 * the leaf, free the partial cluster if it isn't shared with the

	 * current extent.  If it is shared with the current extent

	 * we reset the partial cluster because we've reached the start of the

	 * truncated/punched region and we're done removing blocks.

	/* if this leaf is free, then we should

/*

 * ext4_ext_more_to_rm:

 * returns 1 if current index has to be freed (even partial)

	/*

	 * if truncate on deeper level happened, it wasn't partial,

	 * so we have to consider current index for truncation

 probably first extent we're gonna free will be last in block */

	/*

	 * Check if we are removing extents inside the extent tree. If that

	 * is the case, we are going to punch a hole inside the extent tree

	 * so we have to check whether we need to split the extent covering

	 * the last block to remove so we can easily remove the part of it

	 * in ext4_ext_rm_leaf().

 find extent for or closest extent to this block */

 Leaf not may not exist only if inode has no blocks at all */

		/*

		 * See if the last block is inside the extent, if so split

		 * the extent at 'end' block so we can easily remove the

		 * tail of the first part of the split extent in

		 * ext4_ext_rm_leaf().

			/*

			 * If we're going to split the extent, note that

			 * the cluster containing the block after 'end' is

			 * in use to avoid freeing it when removing blocks.

			/*

			 * Split the extent in two so that 'end' is the last

			 * block in the first new extent. Also we should not

			 * fail removing space due to ENOSPC so try to use

			 * reserved block if that happens.

			/*

			 * If we're punching, there's an extent to the right.

			 * If the partial cluster hasn't been set, set it to

			 * that extent's first cluster and its state to nofree

			 * so it won't be freed should it contain blocks to be

			 * removed. If it's already set (tofree/nofree), we're

			 * retrying and keep the original partial cluster info

			 * so a cluster marked tofree as a result of earlier

			 * extent removal is not lost.

	/*

	 * We start scanning from right side, freeing all the blocks

	 * after i_size and walking into the tree depth-wise.

 this is leaf block */

 root level has p_bh == NULL, brelse() eats this */

 this is index block */

 this level hasn't been touched yet */

 we were already here, see at next index */

 go to the next level */

 should we reset i_size? */

			/* Yield here to deal with large extent trees.

			/* save actual number of indexes since this

 we finished processing this index, go up */

				/* index is empty, remove it;

				 * handle must be already prepared by the

 root level has p_bh == NULL, brelse() eats this */

	/*

	 * if there's a partial cluster and we have removed the first extent

	 * in the file, then we also free the partial cluster, if any

 TODO: flexible tree reduction should be here */

		/*

		 * truncate to zero freed all the tree,

		 * so we need to correct eh_depth

/*

 * called at mount time

	/*

	 * possible initialization would be here

/*

 * called at umount time

 FIXME!! we need to try to merge to left or right after zero-out  */

/*

 * ext4_split_extent_at() splits an extent at given block.

 *

 * @handle: the journal handle

 * @inode: the file inode

 * @path: the path to the extent

 * @split: the logical block where the extent is splitted.

 * @split_flags: indicates if the extent could be zeroout if split fails, and

 *		 the states(init or unwritten) of new extents.

 * @flags: flags used to insert new extent to extent tree.

 *

 *

 * Splits extent [a, b] into two extents [a, @split) and [@split, b], states

 * of which are determined by split_flag.

 *

 * There are two cases:

 *  a> the extent are splitted into two extent.

 *  b> split is not needed, and just mark the extent.

 *

 * return 0 on success.

		/*

		 * case b: block @split is the block that the extent begins with

		 * then we just change the state of the extent, and splitting

		 * is not needed.

 case a */

	/*

	 * path may lead to new leaf, not to original leaf any more

	 * after ext4_ext_insert_extent() returns,

 update the extent length and mark as initialized */

 update extent status tree */

			/* If we failed at this point, we don't know in which

			 * state the extent tree exactly is so don't try to fix

			 * length of the original extent as it may do even more

			 * damage.

	/*

	 * Ignore ext4_ext_dirty return value since we are already in error path

	 * and err is a non-zero error code.

/*

 * ext4_split_extents() splits an extent and mark extent which is covered

 * by @map as split_flags indicates

 *

 * It may result in splitting the extent into multiple extents (up to three)

 * There are three possibilities:

 *   a> There is no split required

 *   b> Splits in two extents: Split is happening at either end of the extent

 *   c> Splits in three extents: Somone is splitting in middle of the extent

 *

	/*

	 * Update path is required because previous ext4_split_extent_at() may

	 * result in split of original leaf or extent zeroout.

/*

 * This function is called by ext4_ext_map_blocks() if someone tries to write

 * to an unwritten extent. It may result in splitting the unwritten

 * extent into multiple extents (up to three - one initialized and two

 * unwritten).

 * There are three possibilities:

 *   a> There is no split required: Entire extent should be initialized

 *   b> Splits in two extents: Write is happening at either end of the extent

 *   c> Splits in three extents: Somone is writing in middle of the extent

 *

 * Pre-conditions:

 *  - The extent pointed to by 'path' is unwritten.

 *  - The extent pointed to by 'path' contains a superset

 *    of the logical span [map->m_lblk, map->m_lblk + map->m_len).

 *

 * Post-conditions on success:

 *  - the returned value is the number of blocks beyond map->l_lblk

 *    that are allocated and initialized.

 *    It is guaranteed to be >= map->m_len.

 Pre-conditions */

	/*

	 * Attempt to transfer newly initialized blocks from the currently

	 * unwritten extent to its neighbor. This is much cheaper

	 * than an insertion followed by a merge as those involve costly

	 * memmove() calls. Transferring to the left is the common case in

	 * steady state for workloads doing fallocate(FALLOC_FL_KEEP_SIZE)

	 * followed by append writes.

	 *

	 * Limitations of the current logic:

	 *  - L1: we do not deal with writes covering the whole extent.

	 *    This would require removing the extent if the transfer

	 *    is possible.

	 *  - L2: we only attempt to merge with an extent stored in the

	 *    same extent tree node.

 See if we can merge left */

L1*/

L2*/

		/*

		 * A transfer of blocks from 'ex' to 'abut_ex' is allowed

		 * upon those conditions:

		 * - C1: abut_ex is initialized,

		 * - C2: abut_ex is logically abutting ex,

		 * - C3: abut_ex is physically abutting ex,

		 * - C4: abut_ex can receive the additional blocks without

		 *   overflowing the (initialized) length limit.

C1*/

C2*/

C3*/

C4*/

 Shift the start of ex by 'map_len' blocks */

 Restore the flag */

 Extend abut_ex by 'map_len' blocks */

 Result: number of initialized blocks past m_lblk */

L1*/

L2*/

 See if we can merge right */

		/*

		 * A transfer of blocks from 'ex' to 'abut_ex' is allowed

		 * upon those conditions:

		 * - C1: abut_ex is initialized,

		 * - C2: abut_ex is logically abutting ex,

		 * - C3: abut_ex is physically abutting ex,

		 * - C4: abut_ex can receive the additional blocks without

		 *   overflowing the (initialized) length limit.

C1*/

C2*/

C3*/

C4*/

 Shift the start of abut_ex by 'map_len' blocks */

 Restore the flag */

 Extend abut_ex by 'map_len' blocks */

 Result: number of initialized blocks past m_lblk */

 Mark the block containing both extents as dirty */

 Update path to point to the right extent */

	/*

	 * It is safe to convert extent to initialized via explicit

	 * zeroout only if extent is fully inside i_size or new_size.

	/*

	 * five cases:

	 * 1. split the extent into three extents.

	 * 2. split the extent into two extents, zeroout the head of the first

	 *    extent.

	 * 3. split the extent into two extents, zeroout the tail of the second

	 *    extent.

	 * 4. split the extent into two extents with out zeroout.

	 * 5. no splitting needed, just possibly zeroout the head and / or the

	 *    tail of the extent.

 case 3 or 5 */

 case 2 or 5 */

 If we have gotten a failure, don't zero out status tree */

/*

 * This function is called by ext4_ext_map_blocks() from

 * ext4_get_blocks_dio_write() when DIO to write

 * to an unwritten extent.

 *

 * Writing to an unwritten extent may result in splitting the unwritten

 * extent into multiple initialized/unwritten extents (up to three)

 * There are three possibilities:

 *   a> There is no split required: Entire extent should be unwritten

 *   b> Splits in two extents: Write is happening at either end of the extent

 *   c> Splits in three extents: Somone is writing in middle of the extent

 *

 * This works the same way in the case of initialized -> unwritten conversion.

 *

 * One of more index blocks maybe needed if the extent tree grow after

 * the unwritten extent split. To prevent ENOSPC occur at the IO

 * complete, we need to split the unwritten extent before DIO submit

 * the IO. The unwritten extent called at this time will be split

 * into three unwritten extent(at most). After IO complete, the part

 * being filled will be convert to initialized by the end_io callback function

 * via ext4_convert_unwritten_extents().

 *

 * Returns the size of unwritten extent to be written on success.

	/*

	 * It is safe to convert extent to initialized via explicit

	 * zeroout only if extent is fully inside i_size or new_size.

 Convert to unwritten */

 Convert to initialized */

	/* If extent is larger than requested it is a clear sign that we still

	 * have some extent state machine issues left. So extent_split is still

	 * required.

	 * TODO: Once all related issues will be fixed this situation should be

	 * illegal.

 first mark the extent as initialized */

	/* note: ext4_ext_correct_indexes() isn't needed here because

	 * borders are not changed

 Mark modified extent as dirty */

	/*

	 * Make sure that the extent is no bigger than we support with

	 * unwritten extent

 first mark the extent as unwritten */

	/* note: ext4_ext_correct_indexes() isn't needed here because

	 * borders are not changed

 Mark modified extent as dirty */

	/*

	 * When writing into unwritten space, we should not fail to

	 * allocate metadata blocks for the new extent block if needed.

 get_block() before submitting IO, split the extent */

		/*

		 * shouldn't get a 0 return when splitting an extent unless

		 * m_len is 0 (bug) or extent has been corrupted

 IO end_io complete, convert the filled extent to written */

 buffered IO cases */

	/*

	 * repeat fallocate creation request

	 * we already have an unwritten extent

 buffered READ or buffered write_begin() lookup */

		/*

		 * We have blocks reserved already.  We

		 * return allocated blocks so that delalloc

		 * won't do block reservation for us.  But

		 * the buffer head will be unmapped so that

		 * a read from the block returns 0s.

	/*

	 * Default case when (flags & EXT4_GET_BLOCKS_CREATE) == 1.

	 * For buffered writes, at writepage time, etc.  Convert a

	 * discovered unwritten extent to written.

	/*

	 * shouldn't get a 0 return when converting an unwritten extent

	 * unless m_len is 0 (bug) or extent has been corrupted

/*

 * get_implied_cluster_alloc - check to see if the requested

 * allocation (in the map structure) overlaps with a cluster already

 * allocated in an extent.

 *	@sb	The filesystem superblock structure

 *	@map	The requested lblk->pblk mapping

 *	@ex	The extent structure which might contain an implied

 *			cluster allocation

 *

 * This function is called by ext4_ext_map_blocks() after we failed to

 * find blocks that were already in the inode's extent tree.  Hence,

 * we know that the beginning of the requested region cannot overlap

 * the extent from the inode's extent tree.  There are three cases we

 * want to catch.  The first is this case:

 *

 *		 |--- cluster # N--|

 *    |--- extent ---|	|---- requested region ---|

 *			|==========|

 *

 * The second case that we need to test for is this one:

 *

 *   |--------- cluster # N ----------------|

 *	   |--- requested region --|   |------- extent ----|

 *	   |=======================|

 *

 * The third case is when the requested region lies between two extents

 * within the same cluster:

 *          |------------- cluster # N-------------|

 * |----- ex -----|                  |---- ex_right ----|

 *                  |------ requested region ------|

 *                  |================|

 *

 * In each of the above cases, we need to set the map->m_pblk and

 * map->m_len so it corresponds to the return the extent labelled as

 * "|====|" from cluster #N, since it is already in use for data in

 * cluster EXT4_B2C(sbi, map->m_lblk).	We will then return 1 to

 * signal to ext4_ext_map_blocks() that map->m_pblk should be treated

 * as a new "allocated" block region.  Otherwise, we will return 0 and

 * ext4_ext_map_blocks() will then allocate one or more new clusters

 * by calling ext4_mb_new_blocks().

 The extent passed in that we are trying to match */

 The requested region passed into ext4_map_blocks() */

		/*

		 * Check for and handle this case:

		 *

		 *   |--------- cluster # N-------------|

		 *		       |------- extent ----|

		 *	   |--- requested region ---|

		 *	   |===========|

		/*

		 * Check for the case where there is already another allocated

		 * block to the right of 'ex' but before the end of the cluster.

		 *

		 *          |------------- cluster # N-------------|

		 * |----- ex -----|                  |---- ex_right ----|

		 *                  |------ requested region ------|

		 *                  |================|

/*

 * Block allocation/map/preallocation routine for extents based files

 *

 *

 * Need to be called with

 * down_read(&EXT4_I(inode)->i_data_sem) if not allocating file system block

 * (ie, create is zero). Otherwise down_write(&EXT4_I(inode)->i_data_sem)

 *

 * return > 0, number of blocks already mapped/allocated

 *          if create == 0 and these are pre-allocated blocks

 *          	buffer head is unmapped

 *          otherwise blocks are mapped

 *

 * return = 0, if plain look up failed (blocks have not been allocated)

 *          buffer head is unmapped

 *

 * return < 0, error case.

 find extent for this block */

	/*

	 * consistent leaf must not be empty;

	 * this situation is possible, though, _during_ tree modification;

	 * this is why assert can't be put in ext4_find_extent()

		/*

		 * unwritten extents are treated as holes, except that

		 * we split out initialized portions during a write.

 if found extent covers block, simply return it */

 number of remaining blocks in the extent */

			/*

			 * If the extent is initialized check whether the

			 * caller wants to convert it to unwritten.

	/*

	 * requested block isn't allocated yet;

	 * we couldn't try to create block if create flag is zero

		/*

		 * put just found gap into cache to speed up

		 * subsequent requests

 Update hole_len to reflect hole size after map->m_lblk */

	/*

	 * Okay, we need to do block allocation.

	/*

	 * If we are doing bigalloc, check to see if the extent returned

	 * by ext4_find_extent() implies a cluster we can use.

 find neighbour allocated blocks */

	/* Check if the extent after searching to the right implies a

	/*

	 * See if request is beyond maximum number of blocks we can have in

	 * a single extent. For an initialized extent this limit is

	 * EXT_INIT_MAX_LEN and for an unwritten extent this limit is

	 * EXT_UNWRITTEN_MAX_LEN.

 Check if we can really insert (m_lblk)::(m_lblk + m_len) extent */

 allocate new block */

	/*

	 * We calculate the offset from the beginning of the cluster

	 * for the logical block number, since when we allocate a

	 * physical cluster, the physical block should start at the

	 * same offset from the beginning of the cluster.  This is

	 * needed so that future calls to get_implied_cluster_alloc()

	 * work correctly.

 disable in-core preallocation for non-regular files */

 try to insert new extent into found leaf and return */

 Mark unwritten */

			/*

			 * free data blocks we just allocated.

			 * not a good idea to call discard here directly,

			 * but otherwise we'd need to call it every free().

	/*

	 * Reduce the reserved cluster count to reflect successful deferred

	 * allocation of delayed allocated clusters or direct allocation of

	 * clusters discovered to be delayed allocated.  Once allocated, a

	 * cluster is not included in the reserved count.

			/*

			 * When allocating delayed allocated clusters, simply

			 * reduce the reserved cluster count and claim quota

			/*

			 * When allocating non-delayed allocated clusters

			 * (from fallocate, filemap, DIO, or clusters

			 * allocated when delalloc has been disabled by

			 * ext4_nonda_switch), reduce the reserved cluster

			 * count by the number of allocated clusters that

			 * have previously been delayed allocated.  Quota

			 * has been claimed by ext4_mb_new_blocks() above,

			 * so release the quota reservations made for any

			 * previously delayed allocated clusters.

	/*

	 * Cache the extent and update transaction to commit on fdatasync only

	 * when it is _not_ an unwritten extent.

	/*

	 * TODO: optimization is possible here.

	 * Probably we need not scan at all,

	 * because page truncation is enough.

 we have to know where to truncate from in crash case */

	/*

	 * Don't normalize the request if it can fit in one extent so

	 * that it doesn't get unnecessarily split into multiple

	 * extents.

	/*

	 * credits to insert 1 extent into extent tree

		/*

		 * Recalculate credits when extent tree depth changes.

		/*

		 * allow a full retry cycle for any remaining allocations

 Call ext4_force_commit to flush all data in case of data=journal. */

	/*

	 * Round up offset. This is not fallocate, we need to zero out

	 * blocks, so convert interior block aligned part of the range to

	 * unwritten and possibly manually zero out unaligned parts of the

	 * range.

	/*

	 * Indirect files do not support unwritten extents

 Wait all existing dio workers, newcomers will block on i_mutex */

 Preallocate the range including the unaligned edges */

 Zero range excluding the unaligned edges */

		/*

		 * Prevent page faults from reinstantiating pages we have

		 * released from page cache.

 Now release the pages and zero block aligned part of pages */

	/*

	 * In worst case we have to writeout two nonadjacent unwritten

	 * blocks and update the inode

 Zero out partial block at the edges of the range */

/*

 * preallocate space for a file. This implements ext4's fallocate file

 * operation, which gets called from sys_fallocate system call.

 * For block-mapped files, posix_fallocate should fall back to the method

 * of writing zeroes to the required new blocks (the same behavior which is

 * expected for file systems which do not support fallocate() system call).

	/*

	 * Encrypted inodes can't handle collapse range or insert

	 * range since we would need to re-encrypt blocks with a

	 * different IV or XTS tweak (which are based on the logical

	 * block number).

 Return error if mode is not supported */

	/*

	 * We only support preallocation for extent-based files only

 Wait all existing dio workers, newcomers will block on i_mutex */

/*

 * This function convert a range of blocks to written extents

 * The caller of this function will pass the start offset and the size.

 * all unwritten extents within this range will be converted to

 * written extents.

 *

 * This function is called from the direct IO end io call back

 * function, to convert the fallocated extents after IO is completed.

 * Returns 0 on success.

		/*

		 * credits to insert 1 extent into extent tree

	/*

	 * This is somewhat ugly but the idea is clear: When transaction is

	 * reserved, everything goes into it. Otherwise we rather start several

	 * smaller transactions for conversion of each extent separately.

 in-inode? */

 offset of xattr in inode */

 external block */

 no in-inode or external block for xattr, so return -ENOENT */

	/*

	 * Shrink request scope to what the fs can actually handle.

	/*

	 * For bitmap files the maximum size limit could be smaller than

	 * s_maxbytes, so check len here manually instead of just relying on the

	 * generic check.

	/*

	 * Walk the extent tree gathering extent information

	 * and pushing extents back to the user.

/*

 * ext4_ext_shift_path_extents:

 * Shift the extents of a path structure lying between path[depth].p_ext

 * and EXT_LAST_EXTENT(path[depth].p_hdr), by @shift blocks. @SHIFT tells

 * if it is right shift or left shift operation.

 leaf + sb + inode */

 extent tree + sb + inode */

 Try to merge to the left. */

 Update index too */

 we are done if current index is not a starting index */

/*

 * ext4_ext_shift_extents:

 * All the extents which lies in the range from @start to the last allocated

 * block for the @inode are shifted either towards left or right (depending

 * upon @SHIFT) by @shift blocks.

 * On success, 0 is returned, error otherwise.

 Let path point to the last extent */

       /*

	* For left shifts, make sure the hole on the left is big enough to

	* accommodate the shift.  For right shifts, make sure the last extent

	* won't be shifted beyond EXT_MAX_BLOCKS.

	/*

	 * In case of left shift, iterator points to start and it is increased

	 * till we reach stop. In case of right shift, iterator points to stop

	 * and it is decreased till we reach start.

	/*

	 * Its safe to start updating extents.  Start and stop are unsigned, so

	 * in case of right shift if extent with 0 block is reached, iterator

	 * becomes NULL to indicate the end of the loop.

 Hole, move to the next extent */

 Beginning is reached, end of the loop */

 Update path extent in case we need to stop */

 iterator can be NULL which means we should break */

/*

 * ext4_collapse_range:

 * This implements the fallocate's collapse range functionality for ext4

 * Returns: 0 and non-zero on error.

	/*

	 * We need to test this early because xfstests assumes that a

	 * collapse range of (0, 1) will return EOPNOTSUPP if the file

	 * system does not support collapse range.

 Collapse range works only on fs cluster size aligned regions. */

 Call ext4_force_commit to flush all data in case of data=journal. */

	/*

	 * There is no need to overlap collapse range with EOF, in which case

	 * it is effectively a truncate operation

 Currently just for extent based files */

 Wait for existing dio to complete */

	/*

	 * Prevent page faults from reinstantiating pages we have released from

	 * page cache.

	/*

	 * Need to round down offset to be aligned with page size boundary

	 * for page size > block size.

	/*

	 * Write tail of the last page before removed range since it will get

	 * removed from the page cache below.

	/*

	 * Write data that will be shifted to preserve them when discarding

	 * page cache below. We are also protected from pages becoming dirty

	 * by i_rwsem and invalidate_lock.

/*

 * ext4_insert_range:

 * This function implements the FALLOC_FL_INSERT_RANGE flag of fallocate.

 * The data blocks starting from @offset to the EOF are shifted by @len

 * towards right to create a hole in the @inode. Inode size is increased

 * by len bytes.

 * Returns 0 on success, error otherwise.

	/*

	 * We need to test this early because xfstests assumes that an

	 * insert range of (0, 1) will return EOPNOTSUPP if the file

	 * system does not support insert range.

 Insert range works only on fs cluster size aligned regions. */

 Call ext4_force_commit to flush all data in case of data=journal */

 Currently just for extent based files */

 Check whether the maximum file size would be exceeded */

 Offset must be less than i_size */

 Wait for existing dio to complete */

	/*

	 * Prevent page faults from reinstantiating pages we have released from

	 * page cache.

	/*

	 * Need to round down to align start offset to page size boundary

	 * for page size > block size.

 Write out all dirty pages */

 Expand file to avoid data loss if there is error while shifting */

		/*

		 * If offset_lblk is not the starting block of extent, split

		 * the extent @offset_lblk

	/*

	 * if offset_lblk lies in a hole which is at start of file, use

	 * ee_start_lblk to shift extents

/**

 * ext4_swap_extents() - Swap extents between two inodes

 * @handle: handle for this transaction

 * @inode1:	First inode

 * @inode2:	Second inode

 * @lblk1:	Start block for first inode

 * @lblk2:	Start block for second inode

 * @count:	Number of blocks to swap

 * @unwritten: Mark second inode's extents as unwritten after swap

 * @erp:	Pointer to save error value

 *

 * This helper routine does exactly what is promise "swap extents". All other

 * stuff such as page-cache locking consistency, bh mapping consistency or

 * extent's data copying must be performed by caller.

 * Locking:

 * 		i_mutex is held for both inodes

 * 		i_data_sem is locked for write for both inodes

 * Assumptions:

 *		All pages from requested range are locked for both inodes

 Do we have something to swap ? */

 Hole handling */

 if hole after extent, then go to next extent */

 If hole before extent, then shift to that extent */

 Do we have something to swap */

 Move to the rightest boundary */

 Prepare left boundary */

		/* ext4_split_extent_at() may result in leaf extent split,

 Prepare right boundary */

		/* ext4_split_extent_at() may result in leaf extent split,

 Both extents are fully inside boundaries. Swap it now */

		/*

		 * Looks scarry ah..? second inode already points to new blocks,

		 * and it was successfully dirtied. But luckily error may happen

		 * only due to journal error, so full transaction will be

		 * aborted anyway.

/*

 * ext4_clu_mapped - determine whether any block in a logical cluster has

 *                   been mapped to a physical cluster

 *

 * @inode - file containing the logical cluster

 * @lclu - logical cluster of interest

 *

 * Returns 1 if any block in the logical cluster is mapped, signifying

 * that a physical cluster has been allocated for it.  Otherwise,

 * returns 0.  Can also return negative error codes.  Derived from

 * ext4_ext_map_blocks().

 search for the extent closest to the first block in the cluster */

	/*

	 * A consistent leaf must not be empty.  This situation is possible,

	 * though, _during_ tree modification, and it's why an assert can't

	 * be put in ext4_find_extent().

 can't be mapped if the extent tree is empty */

	/*

	 * Three possible outcomes at this point - found extent spanning

	 * the target cluster, to the left of the target cluster, or to the

	 * right of the target cluster.  The first two cases are handled here.

	 * The last case indicates the target cluster is not mapped.

/*

 * Updates physical block address and unwritten status of extent

 * starting at lblk start and of len. If such an extent doesn't exist,

 * this function splits the extent tree appropriately to create an

 * extent like this.  This function is called in the fast commit

 * replay path.  Returns 0 on success and error on failure.

 We need to split this extent to match our extent first */

 Try to shrink the extent tree */

 Check if *cur is a hole and if it is, skip it */

 Count number of blocks used by this inode and update i_blocks */

 Determin the size of the file first */

 Count the number of data blocks */

	/*

	 * Count the number of extent tree blocks. We do it by looking up

	 * two successive extents and determining the difference between

	 * their paths. When path is different for 2 successive extents

	 * we compare the blocks in the path at each level and increment

	 * iblocks by total number of differences found.

 Determin the size of the file first */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/ext4/inode.c

 *

 * Copyright (C) 1992, 1993, 1994, 1995

 * Remy Card (card@masi.ibp.fr)

 * Laboratoire MASI - Institut Blaise Pascal

 * Universite Pierre et Marie Curie (Paris VI)

 *

 *  from

 *

 *  linux/fs/minix/inode.c

 *

 *  Copyright (C) 1991, 1992  Linus Torvalds

 *

 *  64-bit file support on 64-bit platforms by Jakub Jelinek

 *	(jj@sunsite.ms.mff.cuni.cz)

 *

 *  Assorted race fixes, rewrite of ext4_get_block() by Al Viro, 2000

	/*

	 * If jinode is zero, then we never opened the file for

	 * writing, so there's no need to call

	 * jbd2_journal_begin_ordered_truncate() since there's no

	 * outstanding writes we need to flush.

/*

 * Test whether an inode is a fast symlink.

 * A fast symlink has its symlink data stored in ext4_inode_info->i_data.

/*

 * Called at the last iput() if i_nlink is zero.

	/*

	 * Credits for final inode cleanup and freeing:

	 * sb + inode (ext4_orphan_del()), block bitmap, group descriptor

	 * (xattr block freeing), bitmap, group descriptor (inode freeing)

		/*

		 * When journalling data dirty buffers are tracked only in the

		 * journal. So although mm thinks everything is clean and

		 * ready for reaping the inode might still have some pages to

		 * write in the running transaction or waiting to be

		 * checkpointed. Thus calling jbd2_journal_invalidatepage()

		 * (via truncate_inode_pages()) to discard these buffers can

		 * cause data loss. Also even if we did not discard these

		 * buffers, we would have no way to find them after the inode

		 * is reaped and thus user could see stale data if he tries to

		 * read them before the transaction is checkpointed. So be

		 * careful and force everything to disk here... We use

		 * ei->i_datasync_tid to store the newest transaction

		 * containing inode's data.

		 *

		 * Note that directories do not have this problem because they

		 * don't use page cache.

	/*

	 * For inodes with journalled data, transaction commit could have

	 * dirtied the inode. Flush worker is ignoring it because of I_FREEING

	 * flag but we still need to remove the inode from the writeback lists.

	/*

	 * Protect us against freezing - iput() caller didn't have to have any

	 * protection against it. When we are in a running transaction though,

	 * we are already protected against freezing and we cannot grab further

	 * protection due to lock ordering constraints.

	/*

	 * Block bitmap, group descriptor, and inode are accounted in both

	 * ext4_blocks_for_truncate() and extra_credits. So subtract 3.

		/*

		 * If we're going to skip the normal cleanup, we still need to

		 * make sure that the in-core orphan linked list is properly

		 * cleaned up.

	/*

	 * Set inode->i_size to 0 before calling ext4_truncate(). We need

	 * special handling of symlinks here because i_size is used to

	 * determine whether ext4_inode_info->i_data contains symlink data or

	 * block mappings. Setting i_size to 0 will remove its fast symlink

	 * status. Erase i_data so that it becomes a valid empty block map.

 Remove xattr references. */

	/*

	 * Kill off the orphan record which ext4_truncate created.

	 * AKPM: I think this can be inside the above `if'.

	 * Note that ext4_orphan_del() has to be able to cope with the

	 * deletion of a non-existent orphan - this is because we don't

	 * know if ext4_truncate() actually created an orphan record.

	 * (Well, we could do this if we need to, but heck - it works)

	/*

	 * One subtle ordering requirement: if anything has gone wrong

	 * (transaction abort, IO errors, whatever), then we can still

	 * do these next steps (the fs will already have been marked as

	 * having errors), but we can't free the inode if the mark_dirty

	 * fails.

 If that failed, just do the required in-core inode clear. */

 We must guarantee clearing of inode... */

/*

 * Called with i_data_sem down, which is important since we can call

 * ext4_discard_preallocations() from here.

 Update per-inode reservations */

 Update quota subsystem for data blocks */

		/*

		 * We did fallocate with an offset that is already delayed

		 * allocated. So on delayed allocated writeback we should

		 * not re-claim the quota for fallocated blocks.

	/*

	 * If we have done all the pending block allocations and if

	 * there aren't any writers on the inode, we can discard the

	 * inode's preallocations.

	/*

	 * There is a race window that the result is not the same.

	 * e.g. xfstests #223 when dioread_nolock enables.  The reason

	 * is that we lookup a block mapping in extent status tree with

	 * out taking i_data_sem.  So at the time the unwritten extent

	 * could be converted.

	/*

	 * We don't check m_len because extent will be collpased in status

	 * tree.  So the m_len might not equal.

 ES_AGGRESSIVE_TEST */

/*

 * The ext4_map_blocks() function tries to look up the requested blocks,

 * and returns if the blocks are already mapped.

 *

 * Otherwise it takes the write lock of the i_data_sem and allocate blocks

 * and store the allocated blocks in the result buffer head and mark it

 * mapped.

 *

 * If file type is extents based, it will call ext4_ext_map_blocks(),

 * Otherwise, call with ext4_ind_map_blocks() to handle indirect mapping

 * based files

 *

 * On success, it returns the number of blocks being mapped or allocated.  if

 * create==0 and the blocks are pre-allocated and unwritten, the resulting @map

 * is marked as unwritten. If the create == 1, it will mark @map as mapped.

 *

 * It returns 0 if plain look up failed (blocks have not been allocated), in

 * that case, @map is returned as unmapped but we still do fill map->m_len to

 * indicate the length of a hole starting at map->m_lblk.

 *

 * It returns the error in case of allocation failure.

	/*

	 * ext4_map_blocks returns an int, and m_len is an unsigned int

 We can handle the block number less than EXT_MAX_BLOCKS */

 Lookup extent status tree firstly */

	/*

	 * Try to see if we can get the block without requesting a new

	 * file system block.

 If it is only a block(s) look up */

	/*

	 * Returns if the blocks have already allocated

	 *

	 * Note that if blocks have been preallocated

	 * ext4_ext_get_block() returns the create = 0

	 * with buffer head unmapped.

		/*

		 * If we need to convert extent to unwritten

		 * we continue and do the actual work in

		 * ext4_ext_map_blocks()

	/*

	 * Here we clear m_flags because after allocating an new extent,

	 * it will be set again.

	/*

	 * New blocks allocate and/or writing to unwritten extent

	 * will possibly result in updating i_data, so we take

	 * the write lock of i_data_sem, and call get_block()

	 * with create == 1 flag.

	/*

	 * We need to check for EXT4 here because migrate

	 * could have changed the inode type in between

			/*

			 * We allocated new blocks which will result in

			 * i_data's format changing.  Force the migrate

			 * to fail by clearing migrate flags

		/*

		 * Update reserved blocks/metadata blocks after successful

		 * block allocation which had been deferred till now. We don't

		 * support fallocate for non extent files. So we can update

		 * reserve space here.

		/*

		 * We have to zeroout blocks before inserting them into extent

		 * status tree. Otherwise someone could look them up there and

		 * use them before they are really zeroed. We also have to

		 * unmap metadata before zeroing as otherwise writeback can

		 * overwrite zeros with stale data from block device.

		/*

		 * If the extent has been zeroed out, we don't need to update

		 * extent status tree.

		/*

		 * Inodes with freshly allocated blocks where contents will be

		 * visible after transaction commit must be on transaction's

		 * ordered data list.

/*

 * Update EXT4_MAP_FLAGS in bh->b_state. For buffer heads attached to pages

 * we have to be careful as someone else may be manipulating b_state as well.

 Dummy buffer_head? Set non-atomically. */

	/*

	 * Someone else may be modifying b_state. Be careful! This is ugly but

	 * once we get rid of using bh as a container for mapping information

	 * to pass to / from get_block functions, this can go away.

 hole case, need to fill in bh->b_size */

/*

 * Get block function used when preparing for buffered write if we require

 * creating an unwritten extent if blocks haven't been allocated.  The extent

 * will be converted to written after the IO is complete.

 Maximum number of blocks we map for direct IO at once. */

/*

 * `handle' can be NULL if create is zero

		/*

		 * Now that we do not always journal data, we should

		 * keep in mind whether this should always journal the

		 * new buffer as metadata.  For now, regular file

		 * writes use ext4_get_block instead, so it's not a

		 * problem.

 Read a contiguous batch of blocks. */

 map_flags */);

 Note that NULL bhs[i] is valid because of holes. */

/*

 * To preserve ordering, it is essential that the hole instantiation and

 * the data write be encapsulated in a single transaction.  We cannot

 * close off a transaction and start a new one between the ext4_get_block()

 * and the commit_write().  So doing the jbd2_journal_start at the start of

 * prepare_write() is the right place.

 *

 * Also, this function can nest inside ext4_writepage().  In that case, we

 * *know* that ext4_writepage() has generated enough buffer credits to do the

 * whole page.  So we won't block on the journal in that case, which is good,

 * because the caller may be PF_MEMALLOC.

 *

 * By accident, ext4 can be reentered when a transaction is open via

 * quota file writes.  If we were to commit the transaction while thus

 * reentered, there can be a deadlock - we would be holding a quota

 * lock, and the commit would never complete if another thread had a

 * transaction open and was blocking on the quota lock - a ranking

 * violation.

 *

 * So what we do is to rely on the fact that jbd2_journal_stop/journal_start

 * will _not_ run commit under these circumstances because handle->h_ref

 * is elevated.  We'll still have enough credits for the tiny quotafile

 * write.

	/*

	 * __block_write_begin() could have dirtied some buffers. Clean

	 * the dirty bit as jbd2_journal_get_write_access() could complain

	 * otherwise about fs integrity issues. Setting of the dirty bit

	 * by __block_write_begin() isn't a real problem here as we clear

	 * the bit before releasing a page lock and thus writeback cannot

	 * ever write the buffer.

	/*

	 * If we issued read requests, let them complete.

	/*

	 * Reserve one block more for addition to orphan list in case

	 * we allocate blocks but write fails for some reason

	/*

	 * grab_cache_page_write_begin() can take a long time if the

	 * system is thrashing due to memory pressure, or if the page

	 * is being written back.  So grab it first before we start

	 * the transaction handle.  This also allows us to allocate

	 * the page (if needed) without using GFP_NOFS.

 The page got truncated from under us */

 In case writeback began while the page was unlocked */

		/*

		 * __block_write_begin may have instantiated a few blocks

		 * outside i_size.  Trim these off again. Don't need

		 * i_size_read because we hold i_mutex.

		 *

		 * Add inode to orphan list in case we crash before

		 * truncate finishes

			/*

			 * If truncate failed early the inode might

			 * still be on the orphan list; we need to

			 * make sure the inode is removed from the

			 * orphan list in that case.

 For write_end() in data=journal mode */

/*

 * We need to pick up the new inode size which generic_commit_write gave us

 * `file' can be NULL - eg, when called from page_symlink().

 *

 * ext4 never places buffers on inode->i_mapping->private_list.  metadata

 * buffers are managed internally.

	/*

	 * it's important to update i_size while still holding page lock:

	 * page writeout could otherwise come in and zero beyond i_size.

	 *

	 * If FS_IOC_ENABLE_VERITY is running on this inode, then Merkle tree

	 * blocks are being written past EOF, so skip the i_size update.

	/*

	 * Don't mark the inode dirty under page lock. First, it unnecessarily

	 * makes the holding time of page lock longer. Second, it forces lock

	 * ordering of page lock and transaction start for journaling

	 * filesystems.

		/* if we have allocated more blocks and copied

		 * less. We will have blocks allocated outside

		 * inode->i_size. So truncate them

		/*

		 * If truncate failed early the inode might still be

		 * on the orphan list; we need to make sure the inode

		 * is removed from the orphan list in that case.

/*

 * This is a private version of page_zero_new_buffers() which doesn't

 * set the buffer to be dirty, since in data=journalled mode we need

 * to call ext4_handle_dirty_metadata() instead.

		/* if we have allocated more blocks and copied

		 * less. We will have blocks allocated outside

		 * inode->i_size. So truncate them

		/*

		 * If truncate failed early the inode might still be

		 * on the orphan list; we need to make sure the inode

		 * is removed from the orphan list in that case.

/*

 * Reserve space for a single cluster

	/*

	 * We will charge metadata quota at writeout time; this saves

	 * us from metadata over-estimation, though we may go over by

	 * a small amount in the end.  Here we just reserve for data.

 success */

 Nothing to release, exit */

		/*

		 * if there aren't enough reserved blocks, then the

		 * counter is messed up somewhere.  Since this

		 * function is called from invalidate page, it's

		 * harmless to return without any action.

 update fs dirty data blocks counter */

/*

 * Delayed allocation stuff

 The first page to write */

 Current page to examine */

 Last page to examine */

	/*

	 * Extent to map - this can be after first_page because that can be

	 * fully mapped. We somewhat abuse m_flags to store whether the extent

	 * is delalloc or unwritten.

 IO submission data */

 This is necessary when next_page == 0. */

/*

 * ext4_insert_delayed_block - adds a delayed block to the extents status

 *                             tree, incrementing the reserved cluster/block

 *                             count or making a pending reservation

 *                             where needed

 *

 * @inode - file containing the newly added block

 * @lblk - logical block to be added

 *

 * Returns 0 on success, negative error code on failure.

	/*

	 * If the cluster containing lblk is shared with a delayed,

	 * written, or unwritten extent in a bigalloc file system, it's

	 * already been accounted for and does not need to be reserved.

	 * A pending reservation must be made for the cluster if it's

	 * shared with a written or unwritten extent and doesn't already

	 * have one.  Written and unwritten extents can be purged from the

	 * extents status tree if the system is under memory pressure, so

	 * it's necessary to examine the extent tree if a search of the

	 * extents status tree doesn't get a match.

 ENOSPC */

 bigalloc */

 ENOSPC */

/*

 * This function is grabs code from the very beginning of

 * ext4_map_blocks, but assumes that the caller is from delayed write

 * time. This function looks up the requested blocks and sets the

 * buffer delay bit under the protection of i_data_sem.

 Lookup extent status tree firstly */

		/*

		 * Delayed extent could be allocated by fallocate.

		 * So we need to check it.

	/*

	 * Try to see if we can get the block without requesting a new

	 * file system block.

		/*

		 * XXX: __block_prepare_write() unmaps passed block,

		 * is it OK?

/*

 * This is a special get_block_t callback which is used by

 * ext4_da_write_begin().  It will either return mapped block or

 * reserve space for a single block.

 *

 * For delayed buffer_head we have BH_Mapped, BH_New, BH_Delay set.

 * We also have b_blocknr = -1 and b_bdev initialized properly

 *

 * For unwritten buffer_head we have BH_Mapped, BH_New, BH_Unwritten set.

 * We also have b_blocknr = physicalblock mapping unwritten extent and b_bdev

 * initialized properly.

	/*

	 * first, we need to know whether the block is allocated already

	 * preallocated blocks are unmapped but should treated

	 * the same as allocated blocks.

		/* A delayed write to unwritten bh should be marked

		 * new and mapped.  Mapped ensures that we don't do

		 * get_block multiple times when we write to the same

		 * offset and new ensures that we do proper zero out

		 * for partial write.

	/*

	 * We need to release the page lock before we start the

	 * journal, so grab a reference so the page won't disappear

	 * out from under us.

 The page got truncated from under us */

/*

 * Note that we don't need to start a transaction unless we're journaling data

 * because we should have holes filled from ext4_page_mkwrite(). We even don't

 * need to file the inode to the transaction's list in ordered mode because if

 * we are writing back data added by write(), the inode is already there and if

 * we are writing back data modified via mmap(), no one guarantees in which

 * transaction the data will hit the disk. In case we are journaling data, we

 * cannot start transaction directly because transaction start ranks above page

 * lock so we have to do some magic.

 *

 * This function can get called via...

 *   - ext4_writepages after taking page lock (have journal handle)

 *   - journal_submit_inode_data_buffers (no journal handle)

 *   - shrink_page_list via the kswapd/direct reclaim (no journal handle)

 *   - grab_page_cache when doing write_begin (have journal handle)

 *

 * We don't do any block allocation in this function. If we have page with

 * multiple blocks we need to write those buffer_heads that are mapped. This

 * is important for mmaped based write. So if we do with blocksize 1K

 * truncate(f, 1024);

 * a = mmap(f, 0, 4096);

 * a[0] = 'a';

 * truncate(f, 4096);

 * we have in the page first buffer_head mapped via page_mkwrite call back

 * but other buffer_heads would be unmapped but dirty (dirty done via the

 * do_wp_page). So writepage should write the first block. If we modify

 * the mmap area beyond 1024 we will again get a page_fault and the

 * page_mkwrite callback will do the block allocation and mark the

 * buffer_heads mapped.

 *

 * We redirty the page if we have any buffer_heads that is either delay or

 * unwritten in the page.

 *

 * We can get recursively called as show below.

 *

 *	ext4_writepage() -> kmalloc() -> __alloc_pages() -> page_launder() ->

 *		ext4_writepage()

 *

 * But since we don't do any block allocation we should not deadlock.

 * Page also have the dirty flag cleared so we don't get recurive page_lock.

	/*

	 * We cannot do block allocation or other extent handling in this

	 * function. If there are buffers needing that, we have to redirty

	 * the page. But we may reach here when we do a journal commit via

	 * journal_submit_inode_data_buffers() and in that case we must write

	 * allocated buffers to achieve data=ordered mode guarantees.

	 *

	 * Also, if there is only one buffer per page (the fs block

	 * size == the page size), if one buffer needs block

	 * allocation or needs to modify the extent tree to clear the

	 * unwritten flag, we know that the page can't be written at

	 * all, so we might as well refuse the write immediately.

	 * Unfortunately if the block size != page size, we can't as

	 * easily detect this case using ext4_walk_page_buffers(), but

	 * for the extremely common case, this is an optimization that

	 * skips a useless round trip through ext4_bio_write_page().

			/*

			 * For memory cleaning there's no point in writing only

			 * some buffers. So just bail out. Warn if we came here

			 * from direct reclaim.

		/*

		 * It's mmapped pagecache.  Add buffers and journal it.  There

		 * doesn't seem much point in redirtying the page here.

 Drop io_end reference we got from init */

	/*

	 * We have to be very careful here!  Nothing protects writeback path

	 * against i_size changes and the page can be writeably mapped into

	 * page tables. So an application can be growing i_size and writing

	 * data through mmap while writeback runs. clear_page_dirty_for_io()

	 * write-protects our page in page tables and the page cannot get

	 * written to again until we release page lock. So only after

	 * clear_page_dirty_for_io() we are safe to sample i_size for

	 * ext4_bio_write_page() to zero-out tail of the written page. We rely

	 * on the barrier provided by TestClearPageDirty in

	 * clear_page_dirty_for_io() to make sure i_size is really sampled only

	 * after page tables are updated.

/*

 * mballoc gives us at most this number of blocks...

 * XXX: That seems to be only a limitation of ext4_mb_normalize_request().

 * The rest of mballoc seems to handle chunks up to full group size.

/*

 * mpage_add_bh_to_extent - try to add bh to extent of blocks to map

 *

 * @mpd - extent of blocks

 * @lblk - logical number of the block in the file

 * @bh - buffer head we want to add to the extent

 *

 * The function is used to collect contig. blocks in the same state. If the

 * buffer doesn't require mapping for writeback and we haven't started the

 * extent of buffers to map yet, the function returns 'true' immediately - the

 * caller can write the buffer right away. Otherwise the function returns true

 * if the block has been added to the extent, false if the block couldn't be

 * added.

 Buffer that doesn't need mapping for writeback? */

 So far no extent to map => we write the buffer right away */

 First block in the extent? */

 We cannot map unless handle is started... */

 Don't go larger than mballoc is willing to allocate */

 Can we merge the block to our big extent? */

/*

 * mpage_process_page_bufs - submit page buffers for IO or add them to extent

 *

 * @mpd - extent of blocks for mapping

 * @head - the first buffer in the page

 * @bh - buffer we should start processing from

 * @lblk - logical number of the block in the file corresponding to @bh

 *

 * Walk through page buffers from @bh upto @head (exclusive) and either submit

 * the page for IO if all buffers in this page were mapped and there's no

 * accumulated extent of buffers to map or add buffers in the page to the

 * extent of buffers to map. The function returns 1 if the caller can continue

 * by processing the next page, 0 if it should stop adding buffers to the

 * extent to map because we cannot extend it anymore. It can also return value

 * < 0 in case of error during IO submission.

 Found extent to map? */

 Buffer needs mapping and handle is not started? */

 Everything mapped so far and we hit EOF */

 So far everything mapped? Submit the page for IO. */

/*

 * mpage_process_page - update page buffers corresponding to changed extent and

 *		       may submit fully mapped page for IO

 *

 * @mpd		- description of extent to map, on return next extent to map

 * @m_lblk	- logical block mapping.

 * @m_pblk	- corresponding physical mapping.

 * @map_bh	- determines on return whether this page requires any further

 *		  mapping or not.

 * Scan given page buffers corresponding to changed extent and update buffer

 * state according to new extent state.

 * We map delalloc buffers to their physical location, clear unwritten bits.

 * If the given page is not fully mapped, we update @map to the next extent in

 * the given page that needs mapping & return @map_bh as true.

			/*

			 * Buffer after end of mapped extent.

			 * Find next buffer in the page to map.

/*

 * mpage_map_buffers - update buffers corresponding to changed extent and

 *		       submit fully mapped pages for IO

 *

 * @mpd - description of extent to map, on return next extent to map

 *

 * Scan buffers corresponding to changed extent (we expect corresponding pages

 * to be already locked) and update buffer state according to new extent state.

 * We map delalloc buffers to their physical location, clear unwritten bits,

 * and mark buffers as uninit when we perform writes to unwritten extents

 * and do extent conversion after IO is finished. If the last page is not fully

 * mapped, we update @map to the next extent in the last page that needs

 * mapping. Otherwise we submit the page for IO.

			/*

			 * If map_bh is true, means page may require further bh

			 * mapping, or maybe the page was submitted for IO.

			 * So we return to call further extent mapping.

 Page fully mapped - let IO run! */

 Extent fully mapped and matches with page boundary. We are done. */

	/*

	 * Call ext4_map_blocks() to allocate any delayed allocation blocks, or

	 * to convert an unwritten extent to be initialized (in the case

	 * where we have written into one or more preallocated blocks).  It is

	 * possible that we're going to need more metadata blocks than

	 * previously reserved. However we must not fail because we're in

	 * writeback and there is nothing we can do about it so it might result

	 * in data loss.  So use reserved blocks to allocate metadata if

	 * possible.

	 *

	 * We pass in the magic EXT4_GET_BLOCKS_DELALLOC_RESERVE if

	 * the blocks in question are delalloc blocks.  This indicates

	 * that the blocks and quotas has already been checked when

	 * the data was copied into the page cache.

/*

 * mpage_map_and_submit_extent - map extent starting at mpd->lblk of length

 *				 mpd->len and submit pages underlying it for IO

 *

 * @handle - handle for journal operations

 * @mpd - extent to map

 * @give_up_on_write - we set this to true iff there is a fatal error and there

 *                     is no hope of writing the data. The caller should discard

 *                     dirty pages to avoid infinite loops.

 *

 * The function maps extent starting at mpd->lblk of length mpd->len. If it is

 * delayed, blocks are allocated, if it is unwritten, we may need to convert

 * them to initialized or split the described range from larger unwritten

 * extent. Note that we need not map all the described range since allocation

 * can return less blocks or the range is covered by more unwritten extents. We

 * cannot map more because we are limited by reserved transaction credits. On

 * the other hand we always make sure that the last touched page is fully

 * mapped so that it can be written out (and thus forward progress is

 * guaranteed). After mapping we submit all mapped pages for IO.

			/*

			 * Let the uper layers retry transient errors.

			 * In the case of ENOSPC, if ext4_count_free_blocks()

			 * is non-zero, a commit should free up blocks.

		/*

		 * Update buffer state, submit mapped pages, and get us new

		 * extent to map

	/*

	 * Update on-disk size after IO is submitted.  Races with

	 * truncate are avoided by checking i_size under i_data_sem.

/*

 * Calculate the total number of credits to reserve for one writepages

 * iteration. This is called from ext4_writepages(). We map an extent of

 * up to MAX_WRITEPAGES_EXTENT_LEN blocks and then we go on and finish mapping

 * the last partial page. So in total we can map MAX_WRITEPAGES_EXTENT_LEN +

 * bpp - 1 blocks in bpp different extents.

/*

 * mpage_prepare_extent_to_map - find & lock contiguous range of dirty pages

 * 				 and underlying extent to map

 *

 * @mpd - where to look for pages

 *

 * Walk dirty pages in the mapping. If they are fully mapped, submit them for

 * IO immediately. When we find a page which isn't mapped we start accumulating

 * extent of buffers underlying these pages that needs mapping (formed by

 * either delayed or unwritten buffers). We also lock the pages containing

 * these buffers. The extent found is returned in @mpd structure (starting at

 * mpd->lblk with length mpd->len blocks).

 *

 * Note that this function can attach bios to one io_end structure which are

 * neither logically nor physically contiguous. Although it may seem as an

 * unnecessary complication, it is actually inevitable in blocksize < pagesize

 * case as we need to track IO to all buffers underlying a page in one io_end.

			/*

			 * Accumulated enough dirty pages? This doesn't apply

			 * to WB_SYNC_ALL mode. For integrity sync we have to

			 * keep going because someone may be concurrently

			 * dirtying pages, and we might have synced a lot of

			 * newly appeared dirty pages, but have not synced all

			 * of the old dirty pages.

 If we can't merge this page, we are done. */

			/*

			 * If the page is no longer dirty, or its mapping no

			 * longer corresponds to inode we are writing (which

			 * means it has been truncated or invalidated), or the

			 * page is already under writeback and we are not doing

			 * a data integrity writeback, skip the page

 Add all dirty buffers to mpd */

	/*

	 * No pages to write? This is mainly a kludge to avoid starting

	 * a transaction for special inodes like journal inode on last iput()

	 * because that could violate lock ordering on umount

	/*

	 * If the filesystem has aborted, it is read-only, so return

	 * right away instead of dumping stack traces later on that

	 * will obscure the real source of the problem.  We test

	 * EXT4_MF_FS_ABORTED instead of sb->s_flag's SB_RDONLY because

	 * the latter could be true if the filesystem is mounted

	 * read-only, and in that case, ext4_writepages should

	 * *never* be called, so if that ever happens, we would want

	 * the stack trace.

	/*

	 * If we have inline data and arrive here, it means that

	 * we will soon create the block for the 1st page, so

	 * we'd better clear the inline data here.

 Just inode will be modified... */

		/*

		 * We may need to convert up to one extent per block in

		 * the page and we may dirty the inode.

	/*

	 * First writeback pages that don't need mapping - we can avoid

	 * starting a transaction unnecessarily and also avoid being blocked

	 * in the block layer on device congestion while having transaction

	 * started.

 Unlock pages we didn't use */

 Submit prepared bio */

 For each extent of pages we use new io_end */

		/*

		 * We have two constraints: We find one extent to map and we

		 * must always write out whole page (makes a difference when

		 * blocksize < pagesize) so that we don't block on IO when we

		 * try to write out the rest of the page. Journalled mode is

		 * not supported by delalloc.

 start a new transaction */

 Release allocated io_end */

		/*

		 * Caution: If the handle is synchronous,

		 * ext4_journal_stop() can wait for transaction commit

		 * to finish which may depend on writeback of pages to

		 * complete or on page lock to be released.  In that

		 * case, we have to wait until after we have

		 * submitted all the IO, released page locks we hold,

		 * and dropped io_end reference (for extent conversion

		 * to be able to complete) before stopping the handle.

 Unlock pages we didn't use */

 Submit prepared bio */

		/*

		 * Drop our io_end reference we got from init. We have

		 * to be careful and use deferred io_end finishing if

		 * we are still holding the transaction as we can

		 * release the last reference to io_end which may end

		 * up doing unwritten extent conversion.

			/*

			 * Commit the transaction which would

			 * free blocks released in the transaction

			 * and try again

 Fatal error - ENOMEM, EIO... */

 Update index */

		/*

		 * Set the writeback_index so that range_cyclic

		 * mode will write it back later

	/*

	 * switch to non delalloc mode if we are running low

	 * on free block. The free block accounting via percpu

	 * counters can get slightly wrong with percpu_counter_batch getting

	 * accumulated on each CPU without updating global counters

	 * Delalloc need an accurate free block accounting. So switch

	 * to non delalloc when we are near to error range.

	/*

	 * Start pushing delalloc when 1/2 of free blocks are dirty.

		/*

		 * free block count is less than 150% of dirty blocks

		 * or free blocks is less than watermark

 In case writeback began while the page was unlocked */

		/*

		 * block_write_begin may have instantiated a few blocks

		 * outside i_size.  Trim these off again. Don't need

		 * i_size_read because we hold inode lock.

/*

 * Check if we should update i_disksize

 * when write to the end of file but not require block allocation

	/*

	 * Since we are holding inode lock, we are sure i_disksize <=

	 * i_size. We also know that if i_disksize < i_size, there are

	 * delalloc writes pending in the range upto i_size. If the end of

	 * the current write is <= i_size, there's no need to touch

	 * i_disksize since writeback will push i_disksize upto i_size

	 * eventually. If the end of the current write is > i_size and

	 * inside an allocated block (ext4_da_should_update_i_disksize()

	 * check), we need to update i_disksize here as neither

	 * ext4_writepage() nor certain ext4_writepages() paths not

	 * allocating blocks update i_disksize.

	 *

	 * Note that we defer inode dirtying to generic_write_end() /

	 * ext4_da_write_inline_data_end().

/*

 * Force all delayed allocation blocks to be allocated for a given inode.

	/*

	 * We do something simple for now.  The filemap_flush() will

	 * also start triggering a write of the data blocks, which is

	 * not strictly speaking necessary (and for users of

	 * laptop_mode, not even desirable).  However, to do otherwise

	 * would require replicating code paths in:

	 *

	 * ext4_writepages() ->

	 *    write_cache_pages() ---> (via passed in callback function)

	 *        __mpage_da_writepage() -->

	 *           mpage_add_bh_to_extent()

	 *           mpage_da_map_blocks()

	 *

	 * The problem is that write_cache_pages(), located in

	 * mm/page-writeback.c, marks pages clean in preparation for

	 * doing I/O, which is not desirable if we're not planning on

	 * doing I/O at all.

	 *

	 * We could call write_cache_pages(), and then redirty all of

	 * the pages by calling redirty_page_for_writepage() but that

	 * would be ugly in the extreme.  So instead we would need to

	 * replicate parts of the code in the above functions,

	 * simplifying them because we wouldn't actually intend to

	 * write out the pages, but rather only collect contiguous

	 * logical block extents, call the multi-block allocator, and

	 * then update the buffer heads with the block allocations.

	 *

	 * For now, though, we'll cheat by calling filemap_flush(),

	 * which will map the blocks, and start the I/O, but not

	 * actually wait for the I/O to complete.

/*

 * bmap() is special.  It gets used by applications such as lilo and by

 * the swapper to find the on-disk block of a specific piece of data.

 *

 * Naturally, this is dangerous if the block concerned is still in the

 * journal.  If somebody makes a swapfile on an ext4 data-journaling

 * filesystem and enables swap, then they may get a nasty shock when the

 * data getting swapped to that swapfile suddenly gets overwritten by

 * the original zero's written out previously to the journal and

 * awaiting writeback in the kernel's buffer cache.

 *

 * So, if we see any bmap calls here on a modified, data-journaled file,

 * take extra steps to flush any blocks which might be in the cache.

	/*

	 * We can get here for an inline file via the FIBMAP ioctl

		/*

		 * With delalloc we want to sync the file

		 * so that we can make sure we allocate

		 * blocks for file

		/*

		 * This is a REALLY heavyweight approach, but the use of

		 * bmap on dirty files is expected to be extremely rare:

		 * only if we run lilo or swapon on a freshly made file

		 * do we expect this to happen.

		 *

		 * (bmap requires CAP_SYS_RAWIO so this does not

		 * represent an unprivileged user DOS attack --- we'd be

		 * in trouble if mortal users could trigger this path at

		 * will.)

		 *

		 * NB. EXT4_STATE_JDATA is not set on files other than

		 * regular files.  If somebody wants to bmap a directory

		 * or symlink and gets confused because the buffer

		 * hasn't yet been flushed to disk, they deserve

		 * everything they get.

 If the file has inline data, no need to do readahead. */

 No journalling happens on data buffers when this function is used */

	/*

	 * If it's a full truncate we just forget about the pending dirtying

 Wrapper for aops... */

 Page has dirty journalled data -> cannot release */

 Any metadata buffers to write? */

	/*

	 * Writes that span EOF might trigger an I/O size update on completion,

	 * so consider them to be dirty for the purpose of O_DSYNC, even if

	 * there is no other metadata changes being made or are pending.

	/*

	 * Flags passed to ext4_map_blocks() for direct I/O writes can result

	 * in m_flags having both EXT4_MAP_MAPPED and EXT4_MAP_UNWRITTEN bits

	 * set. In order for any allocated unwritten extents to be converted

	 * into written extents correctly within the ->end_io() handler, we

	 * need to ensure that the iomap->type is set appropriately. Hence, the

	 * reason why we need to check whether the EXT4_MAP_UNWRITTEN bit has

	 * been set first.

	/*

	 * Trim the mapping request to the maximum value that we can map at

	 * once for direct I/O.

	/*

	 * Either we allocate blocks and then don't get an unwritten extent, so

	 * in that case we have reserved enough credits. Or, the blocks are

	 * already allocated and unwritten. In that case, the extent conversion

	 * fits into the credits as well.

	/*

	 * DAX and direct I/O are the only two operations that are currently

	 * supported with IOMAP_WRITE.

	/*

	 * We use i_size instead of i_disksize here because delalloc writeback

	 * can complete at any point during the I/O and subsequently push the

	 * i_disksize out to i_size. This could be beyond where direct I/O is

	 * happening and thus expose allocated blocks to direct I/O reads.

	/*

	 * We cannot fill holes in indirect tree based inodes as that could

	 * expose stale data in the case of a crash. Use the magic error code

	 * to fallback to buffered I/O.

	/*

	 * Calculate the first and last logical blocks respectively.

		/*

		 * We check here if the blocks are already allocated, then we

		 * don't need to start a journal txn and we can directly return

		 * the mapping information. This could boost performance

		 * especially in multi-threaded overwrite requests.

	/*

	 * Even for writes we don't need to allocate blocks, so just pretend

	 * we are reading to save overhead of starting a transaction.

	/*

	 * Check to see whether an error occurred while writing out the data to

	 * the allocated blocks. If so, return the magic error code so that we

	 * fallback to buffered I/O and attempt to complete the remainder of

	 * the I/O. Any blocks that may have been allocated in preparation for

	 * the direct I/O will be reused during buffered I/O.

	/*

	 * Calculate the first and last logical block respectively.

	/*

	 * Fiemap callers may call for offset beyond s_bitmap_maxbytes.

	 * So handle it here itself instead of querying ext4_map_blocks().

	 * Since ext4_map_blocks() will warn about it and will return

	 * -EIO error.

/*

 * Pages can be marked dirty completely asynchronously from ext4's journalling

 * activity.  By filemap_sync_pte(), try_to_unmap_one(), etc.  We cannot do

 * much here because ->set_page_dirty is called under VFS locks.  The page is

 * not necessarily locked.

 *

 * We cannot just dirty the page and leave attached buffers clean, because the

 * buffers' dirty state is "definitive".  We cannot just set the buffers dirty

 * or jbddirty because all the journalling code will explode.

 *

 * So what we do is to mark the page "pending dirty" and next time writepage

 * is called, propagate that into the buffers appropriately.

 Find the buffer that contains "offset" */

 unmapped? It's a hole - nothing to do */

 Ok, it's mapped. Make sure it's up-to-date */

 We expect the key to be set. */

/*

 * ext4_block_zero_page_range() zeros out a mapping of length 'length'

 * starting from file offset 'from'.  The range to be zero'd must

 * be contained with in one block.  If the specified range exceeds

 * the end of the block it will be shortened to end of the block

 * that corresponds to 'from'

	/*

	 * correct length if it does not fall between

	 * 'from' and the end of the block

/*

 * ext4_block_truncate_page() zeroes out a mapping from file offset `from'

 * up to the end of the block which corresponds to `from'.

 * This required during truncate. We need to physically zero the tail end

 * of that block so it doesn't yield old data if the file is later grown.

 If we are processing an encrypted inode during orphan list handling */

 Handle partial zero within the single block */

 Handle partial zero out on the start of the range */

 Handle partial zero out on the end of the range */

/*

 * We have to make sure i_disksize gets properly updated before we truncate

 * page cache due to hole punching or zero range. Otherwise i_disksize update

 * can get lost as it may have been postponed to submission of writeback but

 * that will never happen after we truncate page cache.

/*

 * ext4_punch_hole: punches a hole in a file by releasing the blocks

 * associated with the given offset and length

 *

 * @inode:  File inode

 * @offset: The offset where the hole will begin

 * @len:    The length of the hole

 *

 * Returns: 0 on success or negative on failure

	/*

	 * Write out all dirty pages to avoid race conditions

	 * Then release them.

 No need to punch hole beyond i_size */

	/*

	 * If the hole extends beyond i_size, set the hole

	 * to end after the page that contains i_size

		/*

		 * Attach jinode to inode for jbd2 if we do any zeroing of

		 * partial block

 Wait all existing dio workers, newcomers will block on i_mutex */

	/*

	 * Prevent page faults from reinstantiating pages we have released from

	 * page cache.

 Now release the pages and zero block aligned part of pages*/

 If there are blocks to remove, do it */

/*

 * ext4_truncate()

 *

 * We block out ext4_get_block() block instantiations across the entire

 * transaction, and VFS/VM ensures that ext4_truncate() cannot run

 * simultaneously on behalf of the same inode.

 *

 * As we work through the truncate and commit bits of it to the journal there

 * is one core, guiding principle: the file's tree must always be consistent on

 * disk.  We must be able to restart the truncate after a crash.

 *

 * The file's tree may be transiently inconsistent in memory (although it

 * probably isn't), but whenever we close off and commit a journal transaction,

 * the contents of (the filesystem + the journal) must be consistent and

 * restartable.  It's pretty simple, really: bottom up, right to left (although

 * left-to-right works OK too).

 *

 * Note that at recovery time, journal replay occurs *before* the restart of

 * truncate against the orphan inode list.

 *

 * The committed inode has the new, desired i_size (which is the same as

 * i_disksize in this case).  After a crash, ext4_orphan_cleanup() will see

 * that this inode's truncate did not complete and it will again call

 * ext4_truncate() to have another go.  So there will be instantiated blocks

 * to the right of the truncation point in a crashed ext4 filesystem.  But

 * that's fine - as long as they are linked from the inode, the post-crash

 * ext4_truncate() run will find them and release them.

	/*

	 * There is a possibility that we're either freeing the inode

	 * or it's a completely new inode. In those cases we might not

	 * have i_mutex locked because it's not necessary.

 If we zero-out tail of the page, we have to create jinode for jbd2 */

	/*

	 * We add the inode to the orphan list, so that if this

	 * truncate spans multiple transactions, and we crash, we will

	 * resume the truncate when the filesystem recovers.  It also

	 * marks the inode dirty, to catch the new size.

	 *

	 * Implication: the file must always be in a sane, consistent

	 * truncatable state while each transaction commits.

	/*

	 * If this was a simple ftruncate() and the file will remain alive,

	 * then we need to clear up the orphan record which we created above.

	 * However, if this was a real unlink then we were called by

	 * ext4_evict_inode(), and we allow that function to clean up the

	 * orphan info for us.

		/*

		 * i_blocks can be represented in a 32 bit variable

		 * as multiple of 512 bytes

	/*

	 * This should never happen since sb->s_maxbytes should not have

	 * allowed this, sb->s_maxbytes was set according to the huge_file

	 * feature in ext4_fill_super().

		/*

		 * i_blocks can be represented in a 48 bit variable

		 * as multiple of 512 bytes

 i_block is stored in file system block size */

		/*

		 * Fix up interoperability with old kernels. Otherwise,

		 * old inodes get re-used with the upper 16 bits of the

		 * uid/gid intact.

/*

 * ext4_get_inode_loc returns with an extra refcount against the inode's

 * underlying buffer_head on success. If we pass 'inode' and it does not

 * have in-inode xattr, we have all inode data in memory that is needed

 * to recreate the on-disk version of this inode.

	/*

	 * Figure out the offset within the block group inode table

 Someone brought it uptodate while we waited */

	/*

	 * If we have all information of the inode in memory and this

	 * is the only valid inode in the block, we need not read the

	 * block.

 Is the inode bitmap in cache? */

		/*

		 * If the inode bitmap isn't in cache then the

		 * optimisation may end up performing two reads instead

		 * of one, so skip it.

 all other inodes are free, so skip I/O */

	/*

	 * If we need to do any I/O, try to pre-readahead extra

	 * blocks from the inode table.

 s_inode_readahead_blks is always a power of 2 */

	/*

	 * There are other valid inodes in the buffer, this inode

	 * has in-inode xattrs, or we don't have this inode in memory.

	 * Read the block from disk.

	/* Because of the way inode_set_flags() works we must preserve S_DAX

 we are using combined 48 bit field */

 i_blocks represent file system block size */

/*

 * ext4 has self-managed i_version for ea inodes, it stores the lower 32bit of

 * refcount in i_version, so use raw values if inode has EXT4_EA_INODE_FL flag

 * set.

 Precompute checksum seed for inode metadata */

 Only relevant on 32-bit archs */

	/* We now have enough fields to check if the inode was active or not.

	 * This is needed because nfsd might try to access dead inodes

	 * the test is that same one that e2fsck uses

	 * NeilBrown 1999oct15

 this inode is deleted */

		/* The only unlinked inodes we let through here have

		 * valid i_mode and are being read by the orphan

		 * recovery code: that's fine, we're about to complete

		 * the process of deleting those.

		 * OR it is the EXT4_BOOT_LOADER_INO which is

	/*

	 * If dir_index is not enabled but there's dir with INDEX flag set,

	 * we'd normally treat htree data as empty space. But with metadata

	 * checksumming that corrupts checksums so forbid that.

	/*

	 * NOTE! The in-memory inode i_data array is in little-endian order

	 * even on big-endian machines: we do NOT byteswap the block numbers!

	/*

	 * Set transaction id's of transactions that have to be committed

	 * to finish f[data]sync. We set them to currently running transaction

	 * as we cannot be sure that the inode or some of its metadata isn't

	 * part of the transaction - the inode could have been reclaimed and

	 * now it is reread from disk.

 The extra space is currently unused. Use it. */

 validate the block references in the inode */

 VFS does not allow setting these so must be corruption */

/*

 * Opportunistically update the other time fields for other inodes in

 * the same inode table block.

	/*

	 * Calculate the first inode in the inode table block.  Inode

	 * numbers are one-based.  That is, the first inode in a block

	 * (assuming 4k blocks and 256 byte inodes) is (n*16 + 1).

/*

 * Post the struct inode info into an on-disk inode location in the

 * buffer-cache.  This gobbles the caller's reference to the

 * buffer_head in the inode location struct.

 *

 * The caller must have write access to iloc->bh.

	/*

	 * For fields not tracked in the in-memory inode, initialise them

	 * to zero for new inodes.

/*

 * ext4_write_inode()

 *

 * We are called from a few places:

 *

 * - Within generic_file_aio_write() -> generic_write_sync() for O_SYNC files.

 *   Here, there will be no transaction running. We wait for any running

 *   transaction to commit.

 *

 * - Within flush work (sys_sync(), kupdate and such).

 *   We wait on commit, if told to.

 *

 * - Within iput_final() -> write_inode_now()

 *   We wait on commit, if told to.

 *

 * In all cases it is actually safe for us to return without doing anything,

 * because the inode has been copied into a raw inode buffer in

 * ext4_mark_inode_dirty().  This is a correctness thing for WB_SYNC_ALL

 * writeback.

 *

 * Note that we are absolutely dependent upon all inode dirtiers doing the

 * right thing: they *must* call mark_inode_dirty() after dirtying info in

 * which we are interested.

 *

 * It would be a bug for them to not do this.  The code:

 *

 *	mark_inode_dirty(inode)

 *	stuff();

 *	inode->i_size = expr;

 *

 * is in error because write_inode() could occur while `stuff()' is running,

 * and the new i_size will be lost.  Plus the inode will no longer be on the

 * superblock's dirty inode list.

		/*

		 * No need to force transaction in WB_SYNC_NONE mode. Also

		 * ext4_sync_fs() will force the commit after everything is

		 * written.

		/*

		 * sync(2) will flush the whole buffer cache. No need to do

		 * it here separately for each inode.

/*

 * In data=journal mode ext4_journalled_invalidatepage() may fail to invalidate

 * buffers that are attached to a page stradding i_size and are undergoing

 * commit. In that case we have to wait for commit to finish and try again.

	/*

	 * If the page is fully truncated, we don't need to wait for any commit

	 * (and we even should not as __ext4_journalled_invalidatepage() may

	 * strip all buffers from the page but keep the page dirty which can then

	 * confuse e.g. concurrent ext4_writepage() seeing dirty page without

	 * buffers). Also we don't need to wait for any commit if all buffers in

	 * the page remain valid. This is most beneficial for the common case of

	 * blocksize == PAGESIZE.

/*

 * ext4_setattr()

 *

 * Called from notify_change.

 *

 * We want to trap VFS attempts to truncate the file as soon as

 * possible.  In particular, we want to make sure that when the VFS

 * shrinks i_size, we put the inode on the orphan list and modify

 * i_disksize immediately, so that during the subsequent flushing of

 * dirty pages and freeing of disk blocks, we can guarantee that any

 * commit will leave the blocks being flushed in an unused state on

 * disk.  (On recovery, the inode will get truncated and the blocks will

 * be freed, so we have a strong guarantee that no future commit will

 * leave these blocks visible to the user.)

 *

 * Another thing we have to assure is that if we are in ordered mode

 * and inode is still attached to the committing transaction, we must

 * we start writeout of all the dirty pages which are being truncated.

 * This way we are sure that all the data written in the previous

 * transaction are already on disk (truncate waits for pages under

 * writeback).

 *

 * Called with inode->i_mutex down.

		/* (user+group)*(old+new) structure, inode write (sb,

		/* dquot_transfer() calls back ext4_get_inode_usage() which

		 * counts xattr inode references.

		/* Update corresponding info in inode so that everything is in

			/*

			 * Blocks are going to be removed from the inode. Wait

			 * for dio in flight.

			/*

			 * Update c/mtime on truncate up, ext4_truncate() will

			 * update c/mtime in shrink case below

			/*

			 * We have to update i_size under i_data_sem together

			 * with i_disksize to avoid races with writeback code

			 * running ext4_wb_update_i_disksize().

		/*

		 * Truncate pagecache after we've waited for commit

		 * in data=journal mode to make pages freeable.

		/*

		 * Call ext4_truncate() even if i_size didn't change to

		 * truncate possible preallocated blocks.

	/*

	 * If the call to ext4_truncate failed to get a transaction handle at

	 * all, we need to clean up the in-core orphan list manually.

	/*

	 * If there is inline data in the inode, the inode will normally not

	 * have data blocks allocated (it may have an external xattr block).

	 * Report at least one sector for such files, so tools like tar, rsync,

	 * others don't incorrectly think the file is completely sparse.

	/*

	 * We can't update i_blocks if the block allocation is delayed

	 * otherwise in the case of system crash before the real block

	 * allocation is done, we will have i_blocks inconsistent with

	 * on-disk file blocks.

	 * We always keep i_blocks updated together with real

	 * allocation. But to not confuse with user, stat

	 * will return the blocks that include the delayed allocation

	 * blocks for this file.

/*

 * Account for index blocks, block groups bitmaps and block group

 * descriptor blocks if modify datablocks and index blocks

 * worse case, the indexs blocks spread over different block groups

 *

 * If datablocks are discontiguous, they are possible to spread over

 * different block groups too. If they are contiguous, with flexbg,

 * they could still across block group boundary.

 *

 * Also account for superblock, inode, quota and xattr blocks

	/*

	 * How many index blocks need to touch to map @lblocks logical blocks

	 * to @pextents physical extents?

	/*

	 * Now let's see how many group bitmaps and group descriptors need

	 * to account

 bitmaps and block group descriptor blocks */

 Blocks for super block, inode, quota and xattr blocks */

/*

 * Calculate the total number of credits to reserve to fit

 * the modification of a single pages into a single transaction,

 * which may include multiple chunks of block allocations.

 *

 * This could be called via ext4_write_begin()

 *

 * We need to consider the worse case, when

 * one new block per extent.

 Account for data blocks for journalled mode */

/*

 * Calculate the journal credits for a chunk of data modification.

 *

 * This is called from DIO, fallocate or whoever calling

 * ext4_map_blocks() to map/allocate a chunk of contiguous disk blocks.

 *

 * journal buffers for data blocks are not included here, as DIO

 * and fallocate do no need to journal data buffers.

/*

 * The caller must have previously called ext4_reserve_inode_write().

 * Give this, we know that the caller already has write access to iloc->bh.

 the do_update_inode consumes one bh->b_count */

 ext4_do_update_inode() does jbd2_journal_dirty_metadata */

/*

 * On success, We end up with an outstanding reference count against

 * iloc->bh.  This _must_ be cleaned up later.

 this was checked at iget time, but double check for good measure */

 Should never happen */

 No extended attributes present */

 try to expand with EAs present */

		/*

		 * Inode size expansion failed; don't try again

/*

 * Expand an inode by new_extra_isize bytes.

 * Returns 0 on success or negative error number on failure.

	/*

	 * In nojournal mode, we can immediately attempt to expand

	 * the inode.  When journaled, we first need to obtain extra

	 * buffer credits since we may write into the EA block

	 * with this same handle. If journal_extend fails, then it will

	 * only result in a minor loss of functionality for that inode.

	 * If this is felt to be critical, then e2fsck should be run to

	 * force a large enough s_min_extra_isize.

/*

 * What we do here is to mark the in-core inode as clean with respect to inode

 * dirtiness (it may still be data-dirty).

 * This means that the in-core inode may be reaped by prune_icache

 * without having to perform any I/O.  This is a very good thing,

 * because *any* task may call prune_icache - even ones which

 * have a transaction open against a different journal.

 *

 * Is this cheating?  Not really.  Sure, we haven't written the

 * inode out, but prune_icache isn't a user-visible syncing function.

 * Whenever the user wants stuff synced (sys_sync, sys_msync, sys_fsync)

 * we start and wait on commits.

/*

 * ext4_dirty_inode() is called from __mark_inode_dirty()

 *

 * We're really interested in the case where a file is being extended.

 * i_size has been changed by generic_commit_write() and we thus need

 * to include the updated inode in the current transaction.

 *

 * Also, dquot_alloc_block() will always dirty the inode when blocks

 * are allocated to the file.

 *

 * If the inode is marked synchronous, we don't honour that here - doing

 * so would cause a commit on atime updates, which we don't bother doing.

 * We handle synchronous inodes at the highest possible level.

	/*

	 * We have to be very careful here: changing a data block's

	 * journaling status dynamically is dangerous.  If we write a

	 * data block to the journal, change the status and then delete

	 * that block, we risk forgetting to revoke the old log record

	 * from the journal and so a subsequent replay can corrupt data.

	 * So, first we make sure that the journal is empty and that

	 * nobody is changing anything.

 Wait for all existing dio workers */

	/*

	 * Before flushing the journal and switching inode's aops, we have

	 * to flush all dirty data the inode has. There can be outstanding

	 * delayed allocations, there can be unwritten extents created by

	 * fallocate or buffered writes in dioread_nolock mode covered by

	 * dirty data which can be converted only after flushing the dirty

	 * data (and journalled aops don't know how to handle these cases).

	/*

	 * OK, there are no updates running now, and all cached data is

	 * synced to disk.  We are now in a completely consistent state

	 * which doesn't have anything in the journal, and we know that

	 * no filesystem updates are running, so it is safe to modify

	 * the inode's in-core data-journaling state flag now.

 Finally we can mark the inode as dirty. */

	/*

	 * On data journalling we skip straight to the transaction handle:

	 * there's no delalloc; page truncated will be checked later; the

	 * early return w/ all buffers mapped (calculates size/len) can't

	 * be used; and there's no dioread_nolock, so only ext4_get_block.

 Delalloc case is easy... */

 Page got truncated from under us? */

	/*

	 * Return if we have all the buffers mapped. This avoids the need to do

	 * journal_start/journal_stop which can block and take a long time

	 *

	 * This cannot be done for data journalling, as we have to add the

	 * inode to the transaction's list to writeprotect pages on commit.

 Wait so that we don't change page under IO */

 OK, we need to fill the hole... */

	/*

	 * Data journalling can't use block_page_mkwrite() because it

	 * will set_buffer_dirty() before do_journal_get_write_access()

	 * thus might hit warning messages for dirty metadata buffers.

 Page got truncated from under us? */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/ext4/dir.c

 *

 * Copyright (C) 1992, 1993, 1994, 1995

 * Remy Card (card@masi.ibp.fr)

 * Laboratoire MASI - Institut Blaise Pascal

 * Universite Pierre et Marie Curie (Paris VI)

 *

 *  from

 *

 *  linux/fs/minix/dir.c

 *

 *  Copyright (C) 1991, 1992  Linus Torvalds

 *

 *  ext4 directory handling functions

 *

 *  Big-endian to little-endian byte-swapping/bitmaps by

 *        David S. Miller (davem@caip.rutgers.edu), 1995

 *

 * Hash Tree Directory indexing (c) 2001  Daniel Phillips

 *

/**

 * is_dx_dir() - check if a directory is using htree indexing

 * @inode: directory inode

 *

 * Check if the given dir-inode refers to an htree-indexed directory

 * (or a directory which could potentially get converted to use htree

 * indexing).

 *

 * Return 1 if it is a dx dir, 0 if not

 Check if . or .. , or skip if namelen is 0 */

 Check if this is a csum entry */

/*

 * Return 0 if the directory entry is OK, and 1 if there is a problem

 *

 * Note: this is the opposite of what ext2 and ext3 historically returned...

 *

 * bh passed here can be an inode block or a dir data block, depending

 * on the inode inline data flag.

 Can we just clear INDEX flag to ignore htree information? */

			/*

			 * We don't set the inode dirty flag since it's not

			 * critical that it gets flushed back to the disk.

			/* m_len should never be zero but let's avoid

 corrupt size?  Maybe no more blocks to read */

 Check the checksum */

		/* If the dir block has changed since the last call to

		 * readdir(2), then we might be pointing to an invalid

		 * dirent right now.  Scan from the start of the block

				/* It's too expensive to do a full

				 * dirent test each time round this

				 * loop, but we do have to test at

				 * least that it is non-zero.  A

				 * failure will be detected in the

				/*

				 * On error, skip to the next block

 Directory is encrypted */

/*

 * These functions convert from the major/minor hash to an f_pos

 * value for dx directories

 *

 * Upper layer (for example NFS) should specify FMODE_32BITHASH or

 * FMODE_64BITHASH explicitly. On the other hand, we allow ext4 to be mounted

 * directly on both 32-bit and 64-bit nodes, under such case, neither

 * FMODE_32BITHASH nor FMODE_64BITHASH is specified.

/*

 * Return 32- or 64-bit end-of-file for dx directories

/*

 * ext4_dir_llseek() calls generic_file_llseek_size to handle htree

 * directories, where the "offset" is in terms of the filename hash

 * value instead of the byte offset.

 *

 * Because we may return a 64-bit hash that is well beyond offset limits,

 * we need to pass the max hash as the maximum allowable offset in

 * the htree directory case.

 *

 * For non-htree, ext4_llseek already chooses the proper max offset.

/*

 * This structure holds the nodes of the red-black tree used to store

 * the directory entry in hash order.

/*

 * This functoin implements a non-recursive way of freeing all of the

 * nodes in the red-black tree.

/*

 * Given a directory entry, enter it into the fname rb tree.

 *

 * When filename encryption is enabled, the dirent will hold the

 * encrypted filename, while the htree will hold decrypted filename.

 * The decrypted filename is passed in via ent_name.  parameter.

 Create and allocate the fname structure */

		/*

		 * If the hash and minor hash match up, then we put

		 * them on a linked list.  This rarely happens...

 if (new_fn->minor_hash > fname->minor_hash) */

/*

 * This is a helper function for ext4_dx_readdir.  It calls filldir

 * for all entres on the fname linked list.  (Normally there is only

 * one entry on the linked list, unless there are 62 bit hash collisions.)

 EOF */

 Some one has messed with f_pos; reset the world */

	/*

	 * If there are any leftover names on the hash collision

	 * chain, return them first.

		/*

		 * Fill the rbtree if we have no more entries,

		 * or the inode has changed since we last read in the

		 * cached entries.

 SPDX-License-Identifier: GPL-2.0

/*

 * KUnit test of ext4 inode that verify the seconds part of [a/c/m]

 * timestamps in ext4 inode structs are decoded correctly.

/*

 * For constructing the nonnegative timestamp lower bound value.

 * binary: 00000000 00000000 00000000 00000000

/*

 * For constructing the nonnegative timestamp upper bound value.

 * binary: 01111111 11111111 11111111 11111111

 *

/*

 * For constructing the negative timestamp lower bound value.

 * binary: 10000000 00000000 00000000 00000000

 avoid overflow */

/*

 * For constructing the negative timestamp upper bound value.

 * binary: 11111111 11111111 11111111 11111111

/*

 * Upper bound for nanoseconds value supported by the encoding.

 * binary: 00111111 11111111 11111111 11111111

/*

 *  Test data is derived from the table in the Inode Timestamps section of

 *  Documentation/filesystems/ext4/inodes.rst.

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/ext4/balloc.c

 *

 * Copyright (C) 1992, 1993, 1994, 1995

 * Remy Card (card@masi.ibp.fr)

 * Laboratoire MASI - Institut Blaise Pascal

 * Universite Pierre et Marie Curie (Paris VI)

 *

 *  Enhanced block allocation by Stephen Tweedie (sct@redhat.com), 1993

 *  Big-endian to little-endian byte-swapping/bitmaps by

 *        David S. Miller (davem@caip.rutgers.edu), 1995

/*

 * balloc.c contains the blocks allocation and deallocation routines

/*

 * Calculate block group number for a given block number

/*

 * Calculate the block group number and offset into the block/cluster

 * allocation bitmap, given a block number

/*

 * Check whether the 'block' lives within the 'block_group'. Returns 1 if so

 * and 0 otherwise.

/* Return the number of clusters used for file system metadata; this

 * represents the overhead needed by the file system.

	/* This is the number of clusters used by the superblock,

	 * block group descriptors, and reserved block group

	/*

	 * For the allocation bitmaps and inode table, we first need

	 * to check to see if the block is in the block group.  If it

	 * is, then check to see if the cluster is already accounted

	 * for in the clusters used for the base metadata cluster, or

	 * if we can increment the base metadata cluster to include

	 * that block.  Otherwise, we will have to track the cluster

	 * used for the allocation bitmap or inode table explicitly.

	 * Normally all of these blocks are contiguous, so the special

	 * case handling shouldn't be necessary except for *very*

	 * unusual file system layouts.

		/*

		 * Even though mke2fs always initializes the first and

		 * last group, just in case some other tool was used,

		 * we need to make sure we calculate the right free

		 * blocks.

 Initializes an uninitialized block bitmap */

	/* If checksum is bad mark all blocks used to prevent allocation

 Set bits for block and inode bitmaps, and inode table */

	/*

	 * Also if the number of blocks within the group is less than

	 * the blocksize * 8 ( which is the size of bitmap ), set rest

	 * of the block bitmap to 1

/* Return the number of free blocks in a block group.  It is used when

 * the block bitmap is uninitialized, so we can't just count the bits

/*

 * The free blocks are managed by bitmaps.  A file system contains several

 * blocks groups.  Each group contains 1 bitmap block for blocks, 1 bitmap

 * block for inodes, N blocks for the inode table and data blocks.

 *

 * The file system contains group descriptors which are located after the

 * super block.  Each descriptor contains the number of the bitmap block and

 * the free blocks count in the block.  The descriptors are loaded in memory

 * when a file system is mounted (see ext4_fill_super).

/**

 * ext4_get_group_desc() -- load group descriptor from disk

 * @sb:			super block

 * @block_group:	given block group

 * @bh:			pointer to the buffer head to store the block

 *			group descriptor

	/*

	 * sbi_array_rcu_deref returns with rcu unlocked, this is ok since

	 * the pointer being dereferenced won't be dereferenced again. By

	 * looking at the usage in add_new_gdb() the value isn't modified,

	 * just the pointer, and so it remains valid.

/*

 * Return the block number which was discovered to be invalid, or 0 if

 * the block bitmap is valid.

		/* with FLEX_BG, the inode/block bitmaps and itable

		 * blocks may not be in the group at all

		 * so the bitmap validation will be skipped for those groups

		 * or it has to also read the block group where the bitmaps

		 * are located to verify they are set.

 check whether block bitmap block number is set */

 bad block bitmap */

 check whether the inode bitmap block number is set */

 bad block bitmap */

 check whether the inode table block number is set */

 bad bitmap for inode tables */

/**

 * ext4_read_block_bitmap_nowait()

 * @sb:			super block

 * @block_group:	given block group

 *

 * Read the bitmap for a given block_group,and validate the

 * bits for block/inode/inode tables are set in the bitmaps

 *

 * Return buffer_head on success or an ERR_PTR in case of failure.

 buffer under IO already, return if called for prefetching */

		/*

		 * if not uninit if bh is uptodate,

		 * bitmap is also uptodate

	/*

	 * submit the buffer_head for reading

 Returns 0 on success, -errno on error */

 Panic or remount fs read-only if block bitmap is invalid */

/**

 * ext4_has_free_clusters()

 * @sbi:	in-core super block structure.

 * @nclusters:	number of needed blocks

 * @flags:	flags from ext4_mb_new_blocks()

 *

 * Check if filesystem has nclusters free & available for allocation.

 * On success return 1, return 0 on failure.

	/*

	 * r_blocks_count should always be multiple of the cluster ratio so

	 * we are safe to do a plane bit shift only.

	/* Check whether we have space after accounting for current

	 * dirty clusters & root reserved clusters.

 Hm, nope.  Are (enough) root reserved clusters available? */

 No free blocks. Let's see if we can dip into reserved pool */

/**

 * ext4_should_retry_alloc() - check if a block allocation should be retried

 * @sb:			superblock

 * @retries:		number of retry attempts made so far

 *

 * ext4_should_retry_alloc() is called when ENOSPC is returned while

 * attempting to allocate blocks.  If there's an indication that a pending

 * journal transaction might free some space and allow another attempt to

 * succeed, this function will wait for the current or committing transaction

 * to complete and then return TRUE.

	/*

	 * if there's no indication that blocks are about to be freed it's

	 * possible we just missed a transaction commit that did so

	/*

	 * it's possible we've just missed a transaction commit here,

	 * so ignore the returned status

/*

 * ext4_new_meta_blocks() -- allocate block for meta data (indexing) blocks

 *

 * @handle:             handle to this transaction

 * @inode:              file inode

 * @goal:               given target block(filesystem wide)

 * @count:		pointer to total number of clusters needed

 * @errp:               error code

 *

 * Return 1st allocated block number on success, *count stores total account

 * error stores in errp pointer

 Fill with neighbour allocated blocks */

	/*

	 * Account for the allocated meta blocks.  We will never

	 * fail EDQUOT for metdata, but we do account for it.

/**

 * ext4_count_free_clusters() -- count filesystem free clusters

 * @sb:		superblock

 *

 * Adds up the number of free clusters from each block group.

/**

 *	ext4_bg_has_super - number of blocks used by the superblock in group

 *	@sb: superblock for filesystem

 *	@group: group number to check

 *

 *	Return the number of blocks used by the superblock (primary or backup)

 *	in this group.  Currently this will be only 0 or 1.

/**

 *	ext4_bg_num_gdb - number of blocks used by the group table in group

 *	@sb: superblock for filesystem

 *	@group: group number to check

 *

 *	Return the number of blocks used by the group descriptor table

 *	(primary or backup) in this group.  In the future there may be a

 *	different number of descriptor blocks in each group.

/*

 * This function returns the number of file system metadata clusters at

 * the beginning of a block group, including the reserved gdt blocks.

 Check for superblock and gdt backups in this group */

 For META_BG_BLOCK_GROUPS */

/**

 *	ext4_inode_to_goal_block - return a hint for block allocation

 *	@inode: inode for block allocation

 *

 *	Return the ideal location to start allocating blocks for a

 *	newly created inode.

		/*

		 * If there are at least EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME

		 * block groups per flexgroup, reserve the first block

		 * group for directories and special files.  Regular

		 * files will start at the second block group.  This

		 * tends to speed up directory access and improves

		 * fsck times.

	/*

	 * If we are doing delayed allocation, we don't need take

	 * colour into account.

 SPDX-License-Identifier: GPL-2.0

/*

 * Interface between ext4 and JBD

 writeback */

 We do not support data journalling with delayed allocation */

 We do not support data journalling for encrypted data */

 ordered */

 journal data */

 ordered */

 writeback */

 Just increment the non-pointer handle value */

 Decrement the non-pointer handle value */

/*

 * Wrappers for jbd2_journal_start/end.

	/*

	 * Special case here: if the journal has aborted behind our

	 * backs (eg. EIO in the commit thread), then we still need to

	 * take the FS itself readonly cleanly.

	/*

	 * If the block device has write error flag, it may have failed to

	 * async write out metadata buffers in the background. In this case,

	 * we could read old data from disk and write it out again, which

	 * may lead to on-disk filesystem inconsistency.

/*

 * The ext4 forget function must perform a revoke if we are freeing data

 * which has been journaled.  Metadata (eg. indirect blocks) must be

 * revoked in all cases.

 *

 * "bh" may be NULL: a metadata block may have been freed from memory

 * but there may still be a record of it in the journal, and that record

 * still needs to be revoked.

 In the no journal case, we can just do a bforget and return */

	/* Never use the revoke function if we are doing full data

	 * journaling: there is no need to, and a V1 superblock won't

	 * support it.  Otherwise, only skip the revoke on un-journaled

	/*

	 * data!=journal && (is_metadata || should_journal_data(inode))

 Errors can only happen due to aborted journal or a nasty bug */

 SPDX-License-Identifier: GPL-2.0

 Checksumming functions */

/*

 * Write the MMP block using REQ_SYNC to try to get the block on-disk

 * faster.

	/*

	 * We protect against freezing so that we don't create dirty buffers

	 * on frozen filesystem.

/*

 * Read the MMP block. It _must_ be read from disk and hence we clear the

 * uptodate flag on the buffer.

	/* This would be sb_bread(sb, mmp_block), except we need to be sure

	 * that the MD RAID device cache has been bypassed, and that the read

/*

 * Dump as much information as possible to help the admin.

/*

 * kmmpd will update the MMP sequence every s_mmp_update_interval seconds

	/*

	 * Start with the higher mmp_check_interval and reduce it if

	 * the MMP block is being updated on time.

		/*

		 * Don't spew too many error messages. Print one every

		 * (s_mmp_update_interval * 60) seconds.

		/*

		 * We need to make sure that more than mmp_check_interval

		 * seconds have not passed since writing. If that has happened

		 * we need to check if the MMP block is as we left it.

		 /*

		 * Adjust the mmp_check_interval depending on how much time

		 * it took for the MMP block to be written.

	/*

	 * Unmount seems to be clean.

/*

 * Get a random new sequence number but make sure it is not greater than

 * EXT4_MMP_SEQ_MAX.

/*

 * Protect the filesystem from being mounted more than once.

	/*

	 * If check_interval in MMP block is larger, use that instead of

	 * update_interval from the superblock.

 Print MMP interval if more than 20 secs. */

	/*

	 * write a new random sequence number.

	/*

	 * wait for MMP interval and check mmp_seq.

	/*

	 * Start a kernel thread to update the MMP block periodically.

 SPDX-License-Identifier: LGPL-2.1

/*

 * Copyright IBM Corporation, 2007

 * Author Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>

 *

/*

 * The contiguous blocks details which can be

 * represented by a single extent

 Add the extent to temp inode*/

 Locking only for convenience since we are operating on temp inode */

	/*

	 * Calculate the credit needed to inserting this extent

	 * Since we are doing this in loop we may accumulate extra

	 * credit. But below we try to not accumulate too much

	 * of them by restarting the journal.

	/*

	 * See if we can add on to the existing range (if it exists)

	/*

	 * Start a new range.

 Only update the file block number */

 Only update the file block number */

 ei->i_data[EXT4_IND_BLOCK] */

 ei->i_data[EXT4_DIND_BLOCK] */

 ei->i_data[EXT4_TIND_BLOCK] */

	/*

	 * One credit accounted for writing the

	 * i_data field of the original inode

	/*

	 * if EXT4_STATE_EXT_MIGRATE is cleared a block allocation

	 * happened after we started the migrate. We need to

	 * fail the migrate

	/*

	 * We have the extent map build with the tmp inode.

	 * Now copy the i_data across

	/*

	 * Update i_blocks with the new blocks that got

	 * allocated while adding extents for extent index

	 * blocks.

	 *

	 * While converting to extents we need not

	 * update the original inode i_blocks for extent blocks

	 * via quota APIs. The quota update happened via tmp_inode already.

	/*

	 * We mark the inode dirty after, because we decrement the

	 * i_blocks when freeing the indirect meta-data blocks

/*

 * Free the extent meta data blocks only

		/*

		 * No extra blocks allocated for extent meta data

	/*

	 * If the filesystem does not support extents, or the inode

	 * already is extent-based, error out.

		/*

		 * don't migrate fast symlink

	/*

	 * Worst case we can touch the allocation bitmaps, a bgd

	 * block, and a block to link in the orphan list.  We do need

	 * need to worry about credits for modifying the quota inode.

	/*

	 * Set the i_nlink to zero so it will be deleted later

	 * when we drop inode reference.

	/*

	 * start with one credit accounted for

	 * superblock modification.

	 *

	 * For the tmp_inode we already have committed the

	 * transaction that created the inode. Later as and

	 * when we add extents we extent the journal

	/*

	 * Even though we take i_mutex we can still cause block

	 * allocation via mmap write to holes. If we have allocated

	 * new blocks we fail migrate.  New block allocation will

	 * clear EXT4_STATE_EXT_MIGRATE flag.  The flag is updated

	 * with i_data_sem held to prevent racing with block

	 * allocation.

		/*

		 * It is impossible to update on-disk structures without

		 * a handle, so just rollback in-core changes and live other

		 * work to orphan_list_cleanup()

 32 bit block address 4 bytes */

	/*

	 * Build the last extent

		/*

		 * Failure case delete the extent information with the

		 * tmp_inode

			/*

			 * if we fail to swap inode data free the extent

			 * details of the tmp inode

 We mark the tmp_inode dirty via ext4_ext_tree_init. */

	/*

	 * Mark the tmp_inode as of size zero

	/*

	 * set the  i_blocks count to zero

	 * so that the ext4_evict_inode() does the

	 * right job

	 *

	 * We don't need to take the i_lock because

	 * the inode is not visible to user space.

 Reset the extent details */

/*

 * Migrate a simple extent-based inode to use the i_blocks[] array

	/*

	 * In order to get correct extent info, force all delayed allocation

	 * blocks to be allocated, otherwise delayed allocation blocks may not

	 * be reflected and bypass the checks on extent header.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2003-2006, Cluster File Systems, Inc, info@clusterfs.com

 * Written by Alex Tomas <alex@clusterfs.com>

/*

 * mballoc.c contains the multiblocks allocation routines

/*

 * MUSTDO:

 *   - test ext4_ext_search_left() and ext4_ext_search_right()

 *   - search for metadata in few groups

 *

 * TODO v4:

 *   - normalization should take into account whether file is still open

 *   - discard preallocations if no free space left (policy?)

 *   - don't normalize tails

 *   - quota

 *   - reservation for superuser

 *

 * TODO v3:

 *   - bitmap read-ahead (proposed by Oleg Drokin aka green)

 *   - track min/max extents in each group for better group selection

 *   - mb_mark_used() may allocate chunk right after splitting buddy

 *   - tree of groups sorted by number of free blocks

 *   - error handling

/*

 * The allocation request involve request for multiple number of blocks

 * near to the goal(block) value specified.

 *

 * During initialization phase of the allocator we decide to use the

 * group preallocation or inode preallocation depending on the size of

 * the file. The size of the file could be the resulting file size we

 * would have after allocation, or the current file size, which ever

 * is larger. If the size is less than sbi->s_mb_stream_request we

 * select to use the group preallocation. The default value of

 * s_mb_stream_request is 16 blocks. This can also be tuned via

 * /sys/fs/ext4/<partition>/mb_stream_req. The value is represented in

 * terms of number of blocks.

 *

 * The main motivation for having small file use group preallocation is to

 * ensure that we have small files closer together on the disk.

 *

 * First stage the allocator looks at the inode prealloc list,

 * ext4_inode_info->i_prealloc_list, which contains list of prealloc

 * spaces for this particular inode. The inode prealloc space is

 * represented as:

 *

 * pa_lstart -> the logical start block for this prealloc space

 * pa_pstart -> the physical start block for this prealloc space

 * pa_len    -> length for this prealloc space (in clusters)

 * pa_free   ->  free space available in this prealloc space (in clusters)

 *

 * The inode preallocation space is used looking at the _logical_ start

 * block. If only the logical file block falls within the range of prealloc

 * space we will consume the particular prealloc space. This makes sure that

 * we have contiguous physical blocks representing the file blocks

 *

 * The important thing to be noted in case of inode prealloc space is that

 * we don't modify the values associated to inode prealloc space except

 * pa_free.

 *

 * If we are not able to find blocks in the inode prealloc space and if we

 * have the group allocation flag set then we look at the locality group

 * prealloc space. These are per CPU prealloc list represented as

 *

 * ext4_sb_info.s_locality_groups[smp_processor_id()]

 *

 * The reason for having a per cpu locality group is to reduce the contention

 * between CPUs. It is possible to get scheduled at this point.

 *

 * The locality group prealloc space is used looking at whether we have

 * enough free space (pa_free) within the prealloc space.

 *

 * If we can't allocate blocks via inode prealloc or/and locality group

 * prealloc then we look at the buddy cache. The buddy cache is represented

 * by ext4_sb_info.s_buddy_cache (struct inode) whose file offset gets

 * mapped to the buddy and bitmap information regarding different

 * groups. The buddy information is attached to buddy cache inode so that

 * we can access them through the page cache. The information regarding

 * each group is loaded via ext4_mb_load_buddy.  The information involve

 * block bitmap and buddy information. The information are stored in the

 * inode as:

 *

 *  {                        page                        }

 *  [ group 0 bitmap][ group 0 buddy] [group 1][ group 1]...

 *

 *

 * one block each for bitmap and buddy information.  So for each group we

 * take up 2 blocks. A page can contain blocks_per_page (PAGE_SIZE /

 * blocksize) blocks.  So it can have information regarding groups_per_page

 * which is blocks_per_page/2

 *

 * The buddy cache inode is not stored on disk. The inode is thrown

 * away when the filesystem is unmounted.

 *

 * We look for count number of blocks in the buddy cache. If we were able

 * to locate that many free blocks we return with additional information

 * regarding rest of the contiguous physical block available

 *

 * Before allocating blocks via buddy cache we normalize the request

 * blocks. This ensure we ask for more blocks that we needed. The extra

 * blocks that we get after allocation is added to the respective prealloc

 * list. In case of inode preallocation we follow a list of heuristics

 * based on file size. This can be found in ext4_mb_normalize_request. If

 * we are doing a group prealloc we try to normalize the request to

 * sbi->s_mb_group_prealloc.  The default value of s_mb_group_prealloc is

 * dependent on the cluster size; for non-bigalloc file systems, it is

 * 512 blocks. This can be tuned via

 * /sys/fs/ext4/<partition>/mb_group_prealloc. The value is represented in

 * terms of number of blocks. If we have mounted the file system with -O

 * stripe=<value> option the group prealloc request is normalized to the

 * smallest multiple of the stripe value (sbi->s_stripe) which is

 * greater than the default mb_group_prealloc.

 *

 * If "mb_optimize_scan" mount option is set, we maintain in memory group info

 * structures in two data structures:

 *

 * 1) Array of largest free order lists (sbi->s_mb_largest_free_orders)

 *

 *    Locking: sbi->s_mb_largest_free_orders_locks(array of rw locks)

 *

 *    This is an array of lists where the index in the array represents the

 *    largest free order in the buddy bitmap of the participating group infos of

 *    that list. So, there are exactly MB_NUM_ORDERS(sb) (which means total

 *    number of buddy bitmap orders possible) number of lists. Group-infos are

 *    placed in appropriate lists.

 *

 * 2) Average fragment size rb tree (sbi->s_mb_avg_fragment_size_root)

 *

 *    Locking: sbi->s_mb_rb_lock (rwlock)

 *

 *    This is a red black tree consisting of group infos and the tree is sorted

 *    by average fragment sizes (which is calculated as ext4_group_info->bb_free

 *    / ext4_group_info->bb_fragments).

 *

 * When "mb_optimize_scan" mount option is set, mballoc consults the above data

 * structures to decide the order in which groups are to be traversed for

 * fulfilling an allocation request.

 *

 * At CR = 0, we look for groups which have the largest_free_order >= the order

 * of the request. We directly look at the largest free order list in the data

 * structure (1) above where largest_free_order = order of the request. If that

 * list is empty, we look at remaining list in the increasing order of

 * largest_free_order. This allows us to perform CR = 0 lookup in O(1) time.

 *

 * At CR = 1, we only consider groups where average fragment size > request

 * size. So, we lookup a group which has average fragment size just above or

 * equal to request size using our rb tree (data structure 2) in O(log N) time.

 *

 * If "mb_optimize_scan" mount option is not set, mballoc traverses groups in

 * linear order which requires O(N) search time for each CR 0 and CR 1 phase.

 *

 * The regular allocator (using the buddy cache) supports a few tunables.

 *

 * /sys/fs/ext4/<partition>/mb_min_to_scan

 * /sys/fs/ext4/<partition>/mb_max_to_scan

 * /sys/fs/ext4/<partition>/mb_order2_req

 * /sys/fs/ext4/<partition>/mb_linear_limit

 *

 * The regular allocator uses buddy scan only if the request len is power of

 * 2 blocks and the order of allocation is >= sbi->s_mb_order2_reqs. The

 * value of s_mb_order2_reqs can be tuned via

 * /sys/fs/ext4/<partition>/mb_order2_req.  If the request len is equal to

 * stripe size (sbi->s_stripe), we try to search for contiguous block in

 * stripe size. This should result in better allocation on RAID setups. If

 * not, we search in the specific group using bitmap for best extents. The

 * tunable min_to_scan and max_to_scan control the behaviour here.

 * min_to_scan indicate how long the mballoc __must__ look for a best

 * extent and max_to_scan indicates how long the mballoc __can__ look for a

 * best extent in the found extents. Searching for the blocks starts with

 * the group specified as the goal value in allocation context via

 * ac_g_ex. Each group is first checked based on the criteria whether it

 * can be used for allocation. ext4_mb_good_group explains how the groups are

 * checked.

 *

 * When "mb_optimize_scan" is turned on, as mentioned above, the groups may not

 * get traversed linearly. That may result in subsequent allocations being not

 * close to each other. And so, the underlying device may get filled up in a

 * non-linear fashion. While that may not matter on non-rotational devices, for

 * rotational devices that may result in higher seek times. "mb_linear_limit"

 * tells mballoc how many groups mballoc should search linearly before

 * performing consulting above data structures for more efficient lookups. For

 * non rotational devices, this value defaults to 0 and for rotational devices

 * this is set to MB_DEFAULT_LINEAR_LIMIT.

 *

 * Both the prealloc space are getting populated as above. So for the first

 * request we will hit the buddy cache which will result in this prealloc

 * space getting filled. The prealloc space is then later used for the

 * subsequent request.

/*

 * mballoc operates on the following data:

 *  - on-disk bitmap

 *  - in-core buddy (actually includes buddy and bitmap)

 *  - preallocation descriptors (PAs)

 *

 * there are two types of preallocations:

 *  - inode

 *    assiged to specific inode and can be used for this inode only.

 *    it describes part of inode's space preallocated to specific

 *    physical blocks. any block from that preallocated can be used

 *    independent. the descriptor just tracks number of blocks left

 *    unused. so, before taking some block from descriptor, one must

 *    make sure corresponded logical block isn't allocated yet. this

 *    also means that freeing any block within descriptor's range

 *    must discard all preallocated blocks.

 *  - locality group

 *    assigned to specific locality group which does not translate to

 *    permanent set of inodes: inode can join and leave group. space

 *    from this type of preallocation can be used for any inode. thus

 *    it's consumed from the beginning to the end.

 *

 * relation between them can be expressed as:

 *    in-core buddy = on-disk bitmap + preallocation descriptors

 *

 * this mean blocks mballoc considers used are:

 *  - allocated blocks (persistent)

 *  - preallocated blocks (non-persistent)

 *

 * consistency in mballoc world means that at any time a block is either

 * free or used in ALL structures. notice: "any time" should not be read

 * literally -- time is discrete and delimited by locks.

 *

 *  to keep it simple, we don't use block numbers, instead we count number of

 *  blocks: how many blocks marked used/free in on-disk bitmap, buddy and PA.

 *

 * all operations can be expressed as:

 *  - init buddy:			buddy = on-disk + PAs

 *  - new PA:				buddy += N; PA = N

 *  - use inode PA:			on-disk += N; PA -= N

 *  - discard inode PA			buddy -= on-disk - PA; PA = 0

 *  - use locality group PA		on-disk += N; PA -= N

 *  - discard locality group PA		buddy -= PA; PA = 0

 *  note: 'buddy -= on-disk - PA' is used to show that on-disk bitmap

 *        is used in real operation because we can't know actual used

 *        bits from PA, only from on-disk bitmap

 *

 * if we follow this strict logic, then all operations above should be atomic.

 * given some of them can block, we'd have to use something like semaphores

 * killing performance on high-end SMP hardware. let's try to relax it using

 * the following knowledge:

 *  1) if buddy is referenced, it's already initialized

 *  2) while block is used in buddy and the buddy is referenced,

 *     nobody can re-allocate that block

 *  3) we work on bitmaps and '+' actually means 'set bits'. if on-disk has

 *     bit set and PA claims same block, it's OK. IOW, one can set bit in

 *     on-disk bitmap if buddy has same bit set or/and PA covers corresponded

 *     block

 *

 * so, now we're building a concurrency table:

 *  - init buddy vs.

 *    - new PA

 *      blocks for PA are allocated in the buddy, buddy must be referenced

 *      until PA is linked to allocation group to avoid concurrent buddy init

 *    - use inode PA

 *      we need to make sure that either on-disk bitmap or PA has uptodate data

 *      given (3) we care that PA-=N operation doesn't interfere with init

 *    - discard inode PA

 *      the simplest way would be to have buddy initialized by the discard

 *    - use locality group PA

 *      again PA-=N must be serialized with init

 *    - discard locality group PA

 *      the simplest way would be to have buddy initialized by the discard

 *  - new PA vs.

 *    - use inode PA

 *      i_data_sem serializes them

 *    - discard inode PA

 *      discard process must wait until PA isn't used by another process

 *    - use locality group PA

 *      some mutex should serialize them

 *    - discard locality group PA

 *      discard process must wait until PA isn't used by another process

 *  - use inode PA

 *    - use inode PA

 *      i_data_sem or another mutex should serializes them

 *    - discard inode PA

 *      discard process must wait until PA isn't used by another process

 *    - use locality group PA

 *      nothing wrong here -- they're different PAs covering different blocks

 *    - discard locality group PA

 *      discard process must wait until PA isn't used by another process

 *

 * now we're ready to make few consequences:

 *  - PA is referenced and while it is no discard is possible

 *  - PA is referenced until block isn't marked in on-disk bitmap

 *  - PA changes only after on-disk bitmap

 *  - discard must not compete with init. either init is done before

 *    any discard or they're serialized somehow

 *  - buddy init as sum of on-disk bitmap and PAs is done atomically

 *

 * a special case when we've used PA to emptiness. no need to modify buddy

 * in this case, but we should care about concurrent init

 *

 /*

 * Logic in few words:

 *

 *  - allocation:

 *    load group

 *    find blocks

 *    mark bits in on-disk bitmap

 *    release group

 *

 *  - use preallocation:

 *    find proper PA (per-inode or group)

 *    load group

 *    mark bits in on-disk bitmap

 *    release group

 *    release PA

 *

 *  - free:

 *    load group

 *    mark bits in on-disk bitmap

 *    release group

 *

 *  - discard preallocations in group:

 *    mark PAs deleted

 *    move them onto local list

 *    load on-disk bitmap

 *    load group

 *    remove PA from object (inode or locality group)

 *    mark free blocks in-core

 *

 *  - discard inode's preallocations:

/*

 * Locking rules

 *

 * Locks:

 *  - bitlock on a group	(group)

 *  - object (inode/locality)	(object)

 *  - per-pa lock		(pa)

 *  - cr0 lists lock		(cr0)

 *  - cr1 tree lock		(cr1)

 *

 * Paths:

 *  - new pa

 *    object

 *    group

 *

 *  - find and use pa:

 *    pa

 *

 *  - release consumed pa:

 *    pa

 *    group

 *    object

 *

 *  - generate in-core bitmap:

 *    group

 *        pa

 *

 *  - discard all for given object (inode, locality group):

 *    object

 *        pa

 *    group

 *

 *  - discard all for given group:

 *    group

 *        pa

 *    group

 *        object

 *

 *  - allocation path (ext4_mb_regular_allocator)

 *    group

 *    cr0/cr1

/* We create slab caches for groupinfo data structures based on the

 * superblock block size.  There will be one per mounted filesystem for

/*

 * The algorithm using this percpu seq counter goes below:

 * 1. We sample the percpu discard_pa_seq counter before trying for block

 *    allocation in ext4_mb_new_blocks().

 * 2. We increment this percpu discard_pa_seq counter when we either allocate

 *    or free these blocks i.e. while marking those blocks as used/free in

 *    mb_mark_used()/mb_free_blocks().

 * 3. We also increment this percpu seq counter when we successfully identify

 *    that the bb_prealloc_list is not empty and hence proceed for discarding

 *    of those PAs inside ext4_mb_discard_group_preallocations().

 *

 * Now to make sure that the regular fast path of block allocation is not

 * affected, as a small optimization we only sample the percpu seq counter

 * on that cpu. Only when the block allocation fails and when freed blocks

 * found were 0, that is when we sample percpu seq counter for all cpus using

 * below function ext4_get_discard_pa_seq_sum(). This happens after making

 * sure that all the PAs on grp->bb_prealloc_list got freed or if it's empty.

	/*

	 * ext4_test_bit on architecture like powerpc

	 * needs unsigned long aligned address

 at order 0 we see each particular block */

 only single bit in buddy2 may be 1 */

 both bits in buddy2 must be 1 */

 check used bits only */

/*

 * Divide blocks started from @first with length @len into

 * smaller chunks with power of 2 blocks.

 * Clear the bits in bitmap which the blocks of the chunk(s) covered,

 * then increase bb_counters[] for corresponded chunk size.

 find how many blocks can be covered since this position */

 find how many blocks of power 2 we need to mark */

 mark multiblock chunks only */

/*

 * Reinsert grpinfo into the avg_fragment_size tree with new average

 * fragment size.

/*

 * Choose next group by traversing largest_free_order lists. Updates *new_cr if

 * cr level needs an update.

 Increment cr and search again */

/*

 * Choose next group by traversing average fragment size tree. Updates *new_cr

 * if cr lvel needs an update. Sets EXT4_MB_SEARCH_NEXT_LINEAR to indicate that

 * the linear search should continue for one iteration since there's lock

 * contention on the rb tree lock.

	/*

	 * If there is contention on the lock, instead of waiting for the lock

	 * to become available, just continue searching lineraly. We'll resume

	 * our rb tree search later starting at ac->ac_last_optimal_group.

 We have found something at CR 1 in the past */

/*

 * Return next linear group for allocation. If linear traversal should not be

 * performed, this function just returns the same group

	/*

	 * Artificially restricted ngroups for non-extent

	 * files makes group > ngroups possible on first loop.

/*

 * ext4_mb_choose_next_group: choose next group for allocation.

 *

 * @ac        Allocation Context

 * @new_cr    This is an output parameter. If the there is no good group

 *            available at current CR level, this field is updated to indicate

 *            the new cr level that should be used.

 * @group     This is an input / output parameter. As an input it indicates the

 *            next group that the allocator intends to use for allocation. As

 *            output, this field indicates the next group that should be used as

 *            determined by the optimization functions.

 * @ngroups   Total number of groups

		/*

		 * TODO: For CR=2, we can arrange groups in an rb tree sorted by

		 * bb_free. But until that happens, we should never come here.

/*

 * Cache the order of the largest free extent we have available in this block

 * group.

 uninit */

	/* initialize buddy from bitmap which is aggregation

		/*

		 * If we intend to continue, we consider group descriptor

		 * corrupt and update bb_free using bitmap value

/* The buddy information is attached the buddy cache inode

 * for convenience. The information regarding each group

 * is loaded via ext4_mb_load_buddy. The information involve

 * block bitmap and buddy information. The information are

 * stored in the inode as

 *

 * {                        page                        }

 * [ group 0 bitmap][ group 0 buddy] [group 1][ group 1]...

 *

 *

 * one block each for bitmap and buddy information.

 * So for each group we take up 2 blocks. A page can

 * contain blocks_per_page (PAGE_SIZE / blocksize)  blocks.

 * So it can have information regarding groups_per_page which

 * is blocks_per_page/2

 *

 * Locking note:  This routine takes the block group lock of all groups

 * for this page; do not hold this lock when calling this routine!

 allocate buffer_heads to read bitmaps */

 read all groups the page covers into the cache */

		/*

		 * If page is uptodate then we came here after online resize

		 * which added some new uninitialized group info structs, so

		 * we must skip all initialized uptodate buddies on the page,

		 * which may be currently in use by an allocating task.

 wait for I/O completion */

 skip initialized uptodate buddy */

 Skip faulty bitmaps */

		/*

		 * data carry information regarding this

		 * particular group in the format specified

		 * above

		 *

		/*

		 * We place the buddy block and bitmap block

		 * close together

 this is block of buddy */

			/*

			 * incore got set to the group block bitmap below

 init the buddy */

 this is block of bitmap */

 see comments in ext4_mb_put_pa() */

 mark all preallocated blks used in in-core bitmap */

			/* set incore so that the buddy information can be

			 * generated using this

/*

 * Lock the buddy and bitmap pages. This make sure other parallel init_group

 * on the same buddy page doesn't happen whild holding the buddy page lock.

 * Return locked buddy and bitmap pages on e4b struct. If buddy and bitmap

 * are on the same page e4b->bd_buddy_page is NULL and return value is 0.

	/*

	 * the buddy cache inode stores the block bitmap

	 * and buddy information in consecutive blocks.

	 * So for each group we need two blocks.

 buddy and bitmap are on the same page */

/*

 * Locking note:  This routine calls ext4_mb_init_cache(), which takes the

 * block group lock of all groups for this page; do not hold the BG lock when

 * calling this routine!

	/*

	 * This ensures that we don't reinit the buddy cache

	 * page which map to the group from which we are already

	 * allocating. If we are looking at the buddy cache we would

	 * have taken a reference using ext4_mb_load_buddy and that

	 * would have pinned buddy page to page cache.

	 * The call to ext4_mb_get_buddy_page_lock will mark the

	 * page accessed.

		/*

		 * somebody initialized the group

		 * return without doing anything

		/*

		 * If both the bitmap and buddy are in

		 * the same page we don't need to force

		 * init the buddy

 init buddy cache */

/*

 * Locking note:  This routine calls ext4_mb_init_cache(), which takes the

 * block group lock of all groups for this page; do not hold the BG lock when

 * calling this routine!

		/*

		 * we need full data about the group

		 * to make a good selection

	/*

	 * the buddy cache inode stores the block bitmap

	 * and buddy information in consecutive blocks.

	 * So for each group we need two blocks.

	/* we could use find_or_create_page(), but it locks page

			/*

			 * drop the page reference and try

			 * to get the page with lock. If we

			 * are not uptodate that implies

			 * somebody just created the page but

			 * is yet to initialize the same. So

			 * wait for it to initialize.

 Pages marked accessed already */

 Pages marked accessed already */

 this block is part of buddy of order 'order' */

 fast path: clear whole word at once */

/* clear bits in given range

 * will return first found zero bit if any, -1 otherwise

 fast path: clear whole word at once */

 fast path: set whole word at once */

		/* Bits in range [first; last] are known to be set since

		 * corresponding blocks were allocated. Bits in range

		 * (first; last) will stay set because they form buddies on

		 * upper layer. We just deal with borders if they don't

		 * align with upper layer and then go up.

		 * Releasing entire group is all about clearing

		 * single bit of highest order buddy.

		/* Example:

		 * ---------------------------------

		 * |   1   |   1   |   1   |   1   |

		 * ---------------------------------

		 * | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |

		 * ---------------------------------

		 *   0   1   2   3   4   5   6   7

		 *      \_____________________/

		 *

		 * Neither [1] nor [6] is aligned to above layer.

		 * Left neighbour [0] is free, so mark it busy,

		 * decrease bb_counters and extend range to

		 * [0; 6]

		 * Right neighbour [7] is busy. It can't be coaleasced with [6], so

		 * mark [6] free, increase bb_counters and shrink range to

		 * [0; 5].

		 * Then shift range to [0; 2], go up and do the same.

 Don't bother if the block group is corrupt. */

	/* access memory sequentially: check left neighbour,

	 * clear range and then check right neighbour

 let's maintain fragments counter */

	/* buddy[0] == bd_bitmap is a special case, so handle

	 * it right away and let mb_buddy_mark_free stay free of

	 * zero order checks.

	 * Check if neighbours are to be coaleasced,

	 * adjust bitmap bb_counters and borders appropriately.

 find actual order */

 calc difference from given start */

 Should never happen! (but apparently sometimes does?!?) */

 let's maintain fragments counter */

 let's maintain buddy itself */

 the whole chunk may be allocated at once! */

 store for history */

 we have to split large buddy */

/*

 * Must be called under group lock!

	/* preallocation can change ac_b_ex, thus we store actually

	/*

	 * take the page reference. We want the page to be pinned

	 * so that we don't get a ext4_mb_init_cache_call for this

	 * group until we update the bitmap. That would mean we

	 * double allocate blocks. The reference is dropped

	 * in ext4_mb_release_context

 store last allocated for subsequent stream allocation */

	/*

	 * As we've just preallocated more space than

	 * user requested originally, we store allocated

	 * space in a special descriptor.

	/*

	 * We don't want to scan for a whole year

	/*

	 * Haven't found good chunk so far, let's continue

		/* recheck chunk's availability - we don't know

		 * when it was found (within this lock-unlock

/*

 * The routine checks whether found extent is good enough. If it is,

 * then the extent gets marked used and flag is set to the context

 * to stop scanning. Otherwise, the extent is compared with the

 * previous found extent and if new one is better, then it's stored

 * in the context. Later, the best found extent will be used, if

 * mballoc can't find good enough extent.

 *

 * FIXME: real allocation policy is to be designed yet!

	/*

	 * The special case - take what you catch first

	/*

	 * Let's check whether the chuck is good enough

	/*

	 * If this is first found extent, just store it in the context

	/*

	 * If new found extent is better, store it in the context

		/* if the request isn't satisfied, any found extent

		/* if the request is satisfied, then we try to find

		 * an extent that still satisfy the request, but is

 debug value */

 use do_div to get remainder (would be 64-bit modulo) */

		/* Sometimes, caller may want to merge even small

/*

 * The routine scans buddy structures (not bitmap!) from given order

 * to max order and tries to find big enough chunk to satisfy the req

/*

 * The routine scans the group and measures all found extents.

 * In order to optimize scanning, caller must pass number of

 * free blocks in the group, so the routine can know upper limit.

			/*

			 * IF we have corrupt bitmap, we won't find any

			 * free blocks even though group info says we

			 * have free blocks

			/*

			 * The number of free blocks differs. This mostly

			 * indicate that the bitmap is corrupt. So exit

			 * without claiming the space.

 debug value */

/*

 * This is a special case for storages like raid5

 * we try to find stripe-aligned chunks for stripe-size-multiple requests

 find first stripe-aligned block in group */

 debug value */

/*

 * This is also called BEFORE we load the buddy bitmap.

 * Returns either 1 or 0 indicating that the group is either suitable

 * for the allocation or not.

 Avoid using the first bg of a flexgroup for data files */

/*

 * This could return negative error code if something goes wrong

 * during ext4_mb_init_group(). This should not be called with

 * ext4_lock_group() held.

 *

 * Note: because we are conditionally operating with the group lock in

 * the EXT4_MB_STRICT_CHECK case, we need to fake out sparse in this

 * function using __acquire and __release.  This means we need to be

 * super careful before messing with the error path handling via "goto

 * out"!

 We only do this if the grp has never been initialized */

		/* cr=0/1 is a very optimistic search to find large

		 * good chunks almost for free.  If buddy data is not

		 * ready, then this optimization makes no sense.  But

		 * we never skip the first block group in a flex_bg,

		 * since this gets used for metadata block allocation,

		 * and we want to make sure we locate metadata blocks

		 * in the first block group in the flex_bg if possible.

/*

 * Start prefetching @nr block bitmaps starting at @group.

 * Return the next group which needs to be prefetched.

		/*

		 * Prefetch block groups with free blocks; but don't

		 * bother if it is marked uninitialized on disk, since

		 * it won't require I/O to read.  Also only try to

		 * prefetch once, so we avoid getblk() call, which can

		 * be expensive.

/*

 * Prefetching reads the block bitmap into the buffer cache; but we

 * need to make sure that the buddy bitmap in the page cache has been

 * initialized.  Note that ext4_mb_init_group() will block if the I/O

 * is not yet completed, or indeed if it was not initiated by

 * ext4_mb_prefetch did not start the I/O.

 *

 * TODO: We should actually kick off the buddy bitmap setup in a work

 * queue when the buffer I/O is completed, so that we don't block

 * waiting for the block allocation bitmap read to finish when

 * ext4_mb_prefetch_fini is called from ext4_mb_regular_allocator().

 non-extent files are limited to low blocks/groups */

 first, try the goal */

	/*

	 * ac->ac_2order is set only if the fe_len is a power of 2

	 * if ac->ac_2order is set we also set criteria to 0 so that we

	 * try exact allocation using buddy.

	/*

	 * We search using buddy data only if the order of the request

	 * is greater than equal to the sbi_s_mb_order2_reqs

	 * You can tune it via /sys/fs/ext4/<partition>/mb_order2_req

	 * We also support searching for power-of-two requests only for

	 * requests upto maximum buddy size we have constructed.

		/*

		 * This should tell if fe_len is exactly power of 2

 if stream allocation is enabled, use global goal */

 TBD: may be hot point */

 Let's just scan groups to find more-less suitable blocks */

	/*

	 * cr == 0 try to get exact allocation,

	 * cr == 3  try to get anything

		/*

		 * searching for the right group start

		 * from the goal value specified

			/*

			 * Batch reads of the block allocation bitmaps

			 * to get multiple READs in flight; limit

			 * prefetching at cr=0/1, otherwise mballoc can

			 * spend a lot of time loading imperfect groups

 This now checks without needing the buddy page */

			/*

			 * We need to check again after locking the

			 * block group

 Processed all groups and haven't found blocks */

		/*

		 * We've been searching too long. Let's try to allocate

		 * the best chunk we've found so far

			/*

			 * Someone more lucky has already allocated it.

			 * The only thing we can do is just take first

			 * found block(s)

 Load the group info in memory only if not already loaded. */

/*

 * Allocate the top-level s_group_info array for the specified number

 * of groups

 Create and initialize ext4_group_info data for the given group. */

	/*

	 * First check if this group is the first of a reserved block.

	 * If it's true, we have to allocate a new table of pointers

	 * to ext4_group_info structures

	/*

	 * initialize bb_free to be able to skip

	 * empty groups without initialization

 uninit */

 If a meta_group_info table has been allocated, release it now */

 ext4_mb_add_groupinfo */

	/* To avoid potentially colliding with an valid on-disk inode number,

	 * use EXT4_BAD_INO for the buddy cache inode number.  This inode is

	 * not in the inode hash, so it should never be found by iget(), but

		/* a single flex group is supposed to be read by a single IO.

		 * 2 ^ s_log_groups_per_flex != UINT_MAX as s_mb_prefetch is

		 * unsigned integer, so the maximum shift is 32.

 8 prefetch IOs in flight at most */

	/* now many real IOs to prefetch within a single allocation at cr=0

	 * given cr=0 is an CPU-related optimization we shouldn't try to

	 * load too many groups, at some point we should start to use what

	 * we've got in memory.

	 * with an average random access time 5ms, it'd take a second to get

	 * 200 groups (* N with flex_bg), so let's make this limit 4

 Already created */

		/*

		 * If filesystem is umounting or no memory or suffering

		 * from no space, give up the discard

 order 0 is regular bitmap */

	/*

	 * The default group preallocation is 512, which for 4k block

	 * sizes translates to 2 megabytes.  However for bigalloc file

	 * systems, this is probably too big (i.e, if the cluster size

	 * is 1 megabyte, then group preallocation size becomes half a

	 * gigabyte!).  As a default, we will keep a two megabyte

	 * group pralloc size for cluster sizes up to 64k, and after

	 * that, we will force a minimum group preallocation size of

	 * 32 clusters.  This translates to 8 megs when the cluster

	 * size is 256k, and 32 megs when the cluster size is 1 meg,

	 * which seems reasonable as a default.

	/*

	 * If there is a s_stripe > 1, then we set the s_mb_group_prealloc

	 * to the lowest multiple of s_stripe which is bigger than

	 * the s_mb_group_prealloc as determined above. We want

	 * the preallocation size to be an exact multiple of the

	 * RAID stripe size so that preallocations don't fragment

	 * the stripes.

 init file for buddy data */

 need to called with the ext4 group lock held */

		/*

		 * wait the discard work to drain all of ext4_free_data

 we expect to find existing buddy because it's pinned */

 there are blocks to put in buddy to make them really free */

 Take it out of per group rb tree */

	/*

	 * Clear the trimmed flag for the group so that the next

	 * ext4_trim_fs can trim it.

	 * If the volume is mounted with -o discard, online discard

	 * is supported and the free blocks will be trimmed online.

		/* No more items in the per group rb tree

		 * balance refcounts from ext4_mb_free_metadata()

/*

 * This function is called by the jbd2 layer once the commit has finished,

 * so we know we can free the blocks that were released with that commit.

	/*

	 * Wait for completion of call_rcu()'s on ext4_pspace_cachep

	 * before destroying the slab cache.

/*

 * Check quota and mark chosen space (ac->ac_b_ex) non-free in bitmaps

 * Returns 0 if success or error code

		/* File system mounted not to panic on error

		 * Fix the bitmap and return EFSCORRUPTED

		 * We leak some of the blocks here.

	/*

	 * Now reduce the dirty block count also. Should not go negative

 release all the reserved blocks if non delalloc */

/*

 * Idempotent helper for Ext4 fast commit replay path to set the state of

 * blocks in bitmaps and update counters.

/*

 * here we normalize request for locality group

 * Group request are normalized to s_mb_group_prealloc, which goes to

 * s_strip if we set the same via mount option.

 * s_mb_group_prealloc can be configured via

 * /sys/fs/ext4/<partition>/mb_group_prealloc

 *

 * XXX: should we try to preallocate more than the group has now?

/*

 * Normalization means making request better in terms of

 * size and alignment

	/* do normalize only data requests, metadata requests

 sometime caller may want exact blocks */

	/* caller may indicate that preallocation isn't

	/* first, let's learn actual file size

 max size of free chunks */

 first, try to predict filesize */

 XXX: should this table be tunable? */

 don't cover already allocated blocks in selected range */

	/*

	 * Trim allocation request for filesystems with artificially small

	 * groups.

 check we don't cross already preallocated blocks */

 PA must not overlap original request */

 skip PAs this normalized request doesn't overlap with */

 adjust start or end to be adjacent to this pa */

 XXX: extra loop to check we really don't overlap preallocations */

 now prepare goal request */

	/* XXX: is it better to align blocks WRT to logical

 define goal start in order to merge */

 merge to the right */

 merge to the left */

/*

 * Called on failure; free up any blocks from the inode PA for this

 * context.  We don't need this for MB_GROUP_PA because we only change

 * pa_free in ext4_mb_release_context(), but on failure, we've already

 * zeroed out ac->ac_b_ex.fe_len, so group_pa->pa_free is not changed.

			/*

			 * This should never happen since we pin the

			 * pages in the ext4_allocation_context so

			 * ext4_mb_load_buddy() should never fail.

/*

 * use blocks preallocated to inode

 found preallocated blocks, use them */

/*

 * use blocks preallocated to locality group

	/* we don't correct pa_pstart or pa_plen here to avoid

	 * possible race when the group is being loaded concurrently

	 * instead we correct pa later, after blocks are marked

	 * in on-disk bitmap -- see ext4_mb_release_context()

	 * Other CPUs are prevented from allocating from this pa by lg_mutex

/*

 * Return the prealloc space that have minimal distance

 * from the goal block. @cpa is the prealloc

 * space that is having currently known minimal distance

 * from the goal block.

 drop the previous reference */

/*

 * search goal blocks in preallocated space

 only data can be preallocated */

 first, try per-file preallocation */

		/* all fields in this condition don't change,

 non-extent files can't have physical blocks past 2^32 */

 found preallocated blocks, use them */

 can we use group allocation? */

 inode may have no locality group for some reason */

 The max size of hash table is PREALLOC_TB_SIZE */

	/*

	 * search for the prealloc space that is having

	 * minimal distance from the goal block.

/*

 * the function goes through all block freed in the group

 * but not yet committed and marks them used in in-core bitmap.

 * buddy must be generated from this bitmap

 * Need to be called with the ext4 group lock held

/*

 * the function goes through all preallocation in this group and marks them

 * used in in-core bitmap. buddy must be generated from this bitmap

 * Need to be called with ext4 group lock held

	/* all form of preallocation discards first load group,

	 * so the only competing code is preallocation use.

	 * we don't need any locking here

	 * notice we do NOT ignore preallocations with pa_deleted

	 * otherwise we could leave used blocks available for

	 * allocation in buddy when concurrent ext4_mb_put_pa()

	 * is dropping preallocation

/*

 * drops a reference to preallocated space descriptor

 * if this was the last reference and the space is consumed

 in this short window concurrent discard can set pa_deleted */

	/*

	 * If doing group-based preallocation, pa_pstart may be in the

	 * next group when pa is used up

	/*

	 * possible race:

	 *

	 *  P1 (buddy init)			P2 (regular allocation)

	 *					find block B in PA

	 *  copy on-disk bitmap to buddy

	 *  					mark B in on-disk bitmap

	 *					drop PA from group

	 *  mark all PAs in buddy

	 *

	 * thus, P1 initializes buddy with B available. to prevent this

	 * we make "copy" and "mark all PAs" atomic and serialize "drop PA"

	 * against that pair

/*

 * creates new preallocated space for given inode

 preallocate only when found space is larger then requested */

		/* we can't allocate as much as normalizer wants.

		 * so, found space must get proper lstart

		/* we're limited by original request in that

		 * logical block must be covered any way

 also, we should cover whole original request */

 the smallest one defines real window */

	/* preallocation can change ac_b_ex, thus we store actually

/*

 * creates new preallocated space for locality group inodes belongs to

 preallocate only when found space is larger then requested */

	/* preallocation can change ac_b_ex, thus we store actually

	/*

	 * We will later add the new pa to the right bucket

	 * after updating the pa_free in ext4_mb_release_context

/*

 * finds all unused blocks in on-disk bitmap, frees them in

 * in-core bitmap and buddy.

 * @pa must be unlinked from inode and group lists, so that

 * nobody else can find/use it.

 * the caller MUST hold group/inode locks.

 * TODO: optimize the case when there are no in-core structures yet

		/*

		 * pa is already deleted so we use the value obtained

		 * from the bitmap and continue.

/*

 * releases all preallocations in given group

 *

 * first, we need to decide discard policy:

 * - when do we discard

 *   1) ENOSPC

 * - how many do we discard

 *   1) how many requested

 seems this one can be freed ... */

 we can trust pa_free ... */

 now free all selected PAs */

 remove from object (inode or locality group) */

 if we still need more blocks and some PAs were used, try again */

/*

 * releases all non-used preallocated blocks for given inode

 *

 * It's important to discard preallocations under i_data_sem

 * We don't want another block to be served from the prealloc

 * space when we are discarding the inode prealloc space.

 *

 * FIXME!! Make sure it is valid at all the call sites

BUG_ON(!list_empty(&ei->i_prealloc_list));*/

 first, collect all pa's in the inode */

			/* this shouldn't happen often - nobody should

 someone is deleting pa right now */

		/* we have to wait here because pa_deleted

		 * doesn't mean pa is already unlinked from

		 * the list. as we might be called from

		 * ->clear_inode() the inode will get freed

		 * and concurrent thread which is unlinking

		 * pa from inode's list may access already

		/* XXX: if this happens too often, we can

		 * add a flag to force wait only in case

		 * of ->clear_inode(), but not in case of

/*

 * We use locality group preallocation for small size file. The size of the

 * file is determined by the current size or the resulting size after

 * allocation which ever is larger

 *

 * One can tune this size via /sys/fs/ext4/<partition>/mb_stream_req

 don't use group allocation for large files */

	/*

	 * locality group prealloc space are per cpu. The reason for having

	 * per cpu locality group is to reduce the contention between block

	 * request from multiple CPUs.

 we're going to use group allocation */

 serialize all allocations in the group */

 we can't allocate > group size */

 just a dirty hack to filter too big requests  */

 start searching from the goal */

 set up allocation goals */

	/* we have to define context: we'll work with a file or

			/*

			 * This is the pa that we just used

			 * for block allocation. So don't

			 * free that

 only lg prealloc space */

 seems this one can be freed ... */

			/*

			 * we want to keep only 5 entries

			 * allowing it to grow to 8. This

			 * mak sure we don't call discard

			 * soon for this list.

/*

 * We have incremented pa_count. So it cannot be freed at this

 * point. Also we hold lg_mutex. So no parallel allocation is

 * possible from this lg. That means pa_free cannot be updated.

 *

 * A parallel ext4_mb_discard_group_preallocations is possible.

 * which can cause the lg_prealloc_list to be updated.

 The max size of hash table is PREALLOC_TB_SIZE */

 Add the prealloc space to lg */

 Add to the tail of the previous entry */

			/*

			 * we want to count the total

			 * number of entries in the list

 Now trim the list to be not more than 8 elements */

/*

 * if per-inode prealloc list is too long, trim some PA

/*

 * release all resource we used in allocation

 see comment in ext4_mb_use_group_pa() */

			/*

			 * We want to add the pa to the right bucket.

			 * Remove it from the list and while adding

			 * make sure the list to which we are adding

			 * doesn't grow big.

			/*

			 * treat per-inode prealloc list as a lru list, then try

			 * to trim the least recently used PA.

/*

 * Main entry point into mballoc to allocate blocks

 * it tries to use preallocation first, then falls back

 * to usual allocation

 Allow to use superuser reservation for quota file */

		/* Without delayed allocation we need to verify

		 * there is enough free blocks to do block allocation

		 * and verify allocation doesn't exceed the quota limits.

 let others to free the space */

 allocate space in core */

		/*

		 * pa allocated above is added to grp->bb_prealloc_list only

		 * when we were able to allocate some block i.e. when

		 * ac->ac_status == AC_STATUS_FOUND.

		 * And error from above mean ac->ac_status != AC_STATUS_FOUND

		 * So we have to free this pa here itself.

		/*

		 * If block allocation fails then the pa allocated above

		 * needs to be freed here itself.

 release all the reserved blocks if non delalloc */

/*

 * We can merge two free data extents only if the physical blocks

 * are contiguous, AND the extents were freed by the same transaction,

 * AND the blocks are associated with the same group.

		/* first free block exent. We need to

		   protect buddy cache from being freed,

		 * otherwise we'll refresh it from

		 * on-disk bitmap and lose not-yet-available

 Now try to see the extent can be merged to left and right */

/*

 * Simple allocator for Ext4 fast commit replay path. It searches for blocks

 * linearly starting at the goal block and also excludes the blocks which

 * are going to be in use after fast commit replay.

/**

 * ext4_free_blocks() -- Free given blocks and update quota

 * @handle:		handle for this transaction

 * @inode:		inode

 * @bh:			optional buffer of the block to be freed

 * @block:		starting physical block to be freed

 * @count:		number of blocks to be freed

 * @flags:		flags used by ext4_free_blocks

	/*

	 * If the extent to be freed does not begin on a cluster

	 * boundary, we need to deal with partial clusters at the

	 * beginning and end of the extent.  Normally we will free

	 * blocks at the beginning or the end unless we are explicitly

	 * requested to avoid doing so.

	/*

	 * Check to see if we are freeing blocks across a group

	 * boundary.

 err = 0. ext4_std_error should be a no op */

	/*

	 * We are about to modify some metadata.  Call the journal APIs

	 * to unshare ->b_data if a currently-committing transaction is

	 * using it

 __GFP_NOFAIL: retry infinitely, ignore TIF_MEMDIE and memcg limit. */

	/*

	 * We need to make sure we don't reuse the freed block until after the

	 * transaction is committed. We make an exception if the inode is to be

	 * written in writeback mode since writeback mode has weak data

	 * consistency guarantees.

		/*

		 * We use __GFP_NOFAIL because ext4_free_blocks() is not allowed

		 * to fail.

		/* need to update group_info->bb_free and bitmap

		 * with group lock held. generate_buddy look at

		 * them with group lock_held

	/*

	 * on a bigalloc file system, defer the s_freeclusters_counter

	 * update to the caller (ext4_remove_space and friends) so they

	 * can determine if a cluster freed here should be rereserved

 We dirtied the bitmap block */

 And the group descriptor block */

/**

 * ext4_group_add_blocks() -- Add given blocks to an existing group

 * @handle:			handle to this transaction

 * @sb:				super block

 * @block:			start physical block to add to the block group

 * @count:			number of blocks to free

 *

 * This marks the blocks as free in the bitmap and buddy.

	/*

	 * Check to see if we are freeing blocks across a group

	 * boundary.

	/*

	 * We are about to modify some metadata.  Call the journal APIs

	 * to unshare ->b_data if a currently-committing transaction is

	 * using it

	/*

	 * need to update group_info->bb_free and bitmap

	 * with group lock held. generate_buddy look at

	 * them with group lock_held

 We dirtied the bitmap block */

 And the group descriptor block */

/**

 * ext4_trim_extent -- function to TRIM one single free extent in the group

 * @sb:		super block for the file system

 * @start:	starting block of the free extent in the alloc. group

 * @count:	number of blocks to TRIM

 * @e4b:	ext4 buddy for the group

 *

 * Trim "count" blocks starting at "start" in the "group". To assure that no

 * one will allocate those blocks, mark it as used in buddy bitmap. This must

 * be called with under the group lock.

	/*

	 * Mark blocks used, so no one can reuse them while

	 * being trimmed.

/**

 * ext4_trim_all_free -- function to trim all free space in alloc. group

 * @sb:			super block for file system

 * @group:		group to be trimmed

 * @start:		first group block to examine

 * @max:		last group block to examine

 * @minblocks:		minimum extent block count

 *

 * ext4_trim_all_free walks through group's block bitmap searching for free

 * extents. When the free extent is found, mark it as used in group buddy

 * bitmap. Then issue a TRIM command on this extent and free the extent in

 * the group buddy bitmap.

/**

 * ext4_trim_fs() -- trim ioctl handle function

 * @sb:			superblock for filesystem

 * @range:		fstrim_range structure

 *

 * start:	First Byte to trim

 * len:		number of Bytes to trim from start

 * minlen:	minimum extent length in Bytes

 * ext4_trim_fs goes through all allocation groups containing Bytes from

 * start to start+len. For each such a group ext4_trim_all_free function

 * is invoked to trim all free space.

 Determine first and last group to examine based on start and end */

 end now represents the last cluster to discard in this group */

 We only do this if the grp has never been initialized */

		/*

		 * For all the groups except the last one, last cluster will

		 * always be EXT4_CLUSTERS_PER_GROUP(sb)-1, so we only need to

		 * change it for the last group, note that last_cluster is

		 * already computed earlier by ext4_get_group_no_and_offset()

		/*

		 * For every group except the first one, we are sure

		 * that the first cluster to discard will be cluster #0.

 Iterate all the free extents in the group. */

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/ext4/page-io.c

 *

 * This contains the new page_io functions for ext4

 *

 * Written by Theodore Ts'o, 2010.

/*

 * Print an buffer I/O error compatible with the fs/buffer.c.  This

 * provides compatibility with dmesg scrapers that look for a specific

 * buffer I/O error message.  We really need a unified error reporting

 * structure to userspace ala Digital Unix's uerf system, but it's

 * probably not going to happen in my lifetime, due to LKML politics...

		/*

		 * We check all buffers in the page under b_uptodate_lock

		 * to avoid races with other end io clearing async_write flags

/*

 * Check a range of space and convert unwritten extents to written. Note that

 * we are protected from truncate touching same part of extent tree by the

 * fact that truncate code waits for all DIO to finish (thus exclusion from

 * direct IO is achieved) and also waits for PageWriteback bits. Thus we

 * cannot get to ext4_ext_truncate() before all IOs overlapping that range are

 * completed (happens from ext4_free_ioend()).

 Following call will use up the handle */

 Add the io_end to per-inode completed end_io list. */

 Only reserved conversions from writeback should enter here */

/*

 * work on completed IO, to convert unwritten extents to extents

 BIO completion function for page writeback */

		/*

		 * Link bio into list hanging from io_end. We have to do it

		 * atomically as bio completions can be racing against each

		 * other.

		/*

		 * Drop io_end reference early. Inode can get freed once

		 * we finish the bio.

	/*

	 * bio_alloc will _always_ be able to allocate a bio if

	 * __GFP_DIRECT_RECLAIM is set, see comments for bio_alloc_bioset().

	/*

	 * Comments copied from block_write_full_page:

	 *

	 * The page straddles i_size.  It must be zeroed out on each and every

	 * writepage invocation because it may be mmapped.  "A file is mapped

	 * in multiples of the page size.  For a file that is not a multiple of

	 * the page size, the remaining memory is zeroed when mapped, and

	 * writes to that region are not written out to the file."

	/*

	 * In the first loop we prepare and mark buffers to submit. We have to

	 * mark all buffers in the page before submitting so that

	 * end_page_writeback() cannot be called from ext4_bio_end_io() when IO

	 * on the first buffer finishes and we are still working on submitting

	 * the second buffer.

 A hole? We can safely clear the dirty bit */

	/*

	 * If any blocks are being written to an encrypted file, encrypt them

	 * into a bounce page.  For simplicity, just encrypt until the last

	 * block which might be needed.  This may cause some unneeded blocks

	 * (e.g. holes) to be unnecessarily encrypted, but this is rare and

	 * can't happen in the common case of blocksize == PAGE_SIZE.

		/*

		 * Since bounce page allocation uses a mempool, we can only use

		 * a waiting mask (i.e. request guaranteed allocation) on the

		 * first page of the bio.  Otherwise it can deadlock.

 Now submit buffers to write */

 Nothing submitted - we have to end page writeback */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/ext4/resize.c

 *

 * Support for resizing an ext4 filesystem while it is mounted.

 *

 * Copyright (C) 2001, 2002 Andreas Dilger <adilger@clusterfs.com>

 *

 * This could probably be made into a module, because it is not often in use.

	/*

	 * If we are not using the primary superblock/GDT copy don't resize,

         * because the user tools have no way of handling this.  Probably a

         * bad time to do it anyways.

	/*

	 * We are not allowed to do online-resizing on a filesystem mounted

	 * with error, because it can destroy the filesystem easily.

/*

 * ext4_new_flex_group_data is used by 64bit-resize interface to add a flex

 * group each time.

	struct ext4_new_group_data *groups;	/* new_group_data for groups

	__u16 *bg_flags;			/* block group flags of groups

	ext4_group_t count;			/* number of groups in @groups

/*

 * alloc_flex_gd() allocates a ext4_new_flex_group_data with size of

 * @flexbg_size.

 *

 * Returns NULL on failure otherwise address of the allocated structure.

/*

 * ext4_alloc_group_tables() allocates block bitmaps, inode bitmaps

 * and inode tables for a flex group.

 *

 * This function is used by 64bit-resize.  Note that this function allocates

 * group tables from the 1st group of groups contained by @flexgd, which may

 * be a partial of a flex group.

 *

 * @sb: super block of fs to which the groups belongs

 *

 * Returns 0 on a successful allocation of the metadata blocks in the

 * block group.

 We collect contiguous blocks as much as possible. */

 Allocate block bitmaps */

 Allocate inode bitmaps */

 Allocate inode tables */

 Update free clusters count to exclude metadata blocks */

/*

 * set_flexbg_block_bitmap() mark clusters [@first_cluster, @last_cluster] used.

 *

 * Helper function for ext4_setup_new_group_blocks() which set .

 *

 * @sb: super block

 * @handle: journal handle

 * @flex_gd: flex group data

/*

 * Set up the block and inode bitmaps, and the inode table for the new groups.

 * This doesn't need to be part of the main transaction, since we are only

 * changing blocks outside the actual filesystem.  We still do journaling to

 * ensure the recovery is correct in case of a failure just after resize.

 * If any part of this fails, we simply abort the resize.

 *

 * setup_new_flex_group_blocks handles a flex group as follow:

 *  1. copy super block and GDT, and initialize group tables if necessary.

 *     In this step, we only set bits in blocks bitmaps for blocks taken by

 *     super block and GDT.

 *  2. allocate group tables in block bitmaps, that is, set bits in block

 *     bitmap for blocks taken by group tables.

 This transaction may be extended/restarted along the way */

 Copy all of the GDT blocks into the backup in this group */

		/* Zero out all of the reserved backup group descriptor

		 * table blocks

 Initialize group tables of the grop @group */

 Zero out all of the inode table blocks */

 Initialize block bitmap of the @group */

 Initialize inode bitmap of the @group */

 Mark unused entries in inode bitmap used */

 Mark group tables in block bitmap */

/*

 * Iterate through the groups which hold BACKUP superblock/GDT copies in an

 * ext4 filesystem.  The counters should be initialized to 1, 5, and 7 before

 * calling this for the first time.  In a sparse filesystem it will be the

 * sequence of powers of 3, 5, and 7: 1, 3, 5, 7, 9, 25, 27, 49, 81, ...

 * For a non-sparse filesystem it will be every group: 1, 2, 3, 4, ...

/*

 * Check that all of the backup GDT blocks are held in the primary GDT block.

 * It is assumed that they are stored in group order.  Returns the number of

 * groups in current filesystem that have BACKUPS, or -ve error code.

/*

 * Called when we need to bring a reserved group descriptor table block into

 * use from the resize inode.  The primary copy of the new GDT block currently

 * is an indirect block (under the double indirect block in the resize inode).

 * The new backup GDT blocks will be stored as leaf blocks in this indirect

 * block, in group order.  Even though we know all the block numbers we need,

 * we check to ensure that the resize inode has actually reserved these blocks.

 *

 * Don't need to update the block bitmaps because the blocks are still in use.

 *

 * We get all of the error cases out of the way, so that we are sure to not

 * fail once we start modifying the data on disk, because JBD has no rollback.

 ext4_reserve_inode_write() gets a reference on the iloc */

	/*

	 * Finally, we have all of the possible failures behind us...

	 *

	 * Remove new GDT block from inode double-indirect block and clear out

	 * the new GDT block for use (which also "frees" the backup GDT blocks

	 * from the reserved inode).  We don't need to change the bitmaps for

	 * these blocks, because they are marked as in-use from being in the

	 * reserved inode, and will become GDT blocks (primary and backup).

/*

 * add_new_gdb_meta_bg is the sister of add_new_gdb.

/*

 * Called when we are adding a new group which has a backup copy of each of

 * the GDT blocks (i.e. sparse group) and there are reserved GDT blocks.

 * We need to add these reserved backup GDT blocks to the resize inode, so

 * that they are kept for future resizing and not allocated to files.

 *

 * Each reserved backup GDT block will go into a different indirect block.

 * The indirect blocks are actually the primary reserved GDT blocks,

 * so we know in advance what their block numbers are.  We only get the

 * double-indirect block to verify it is pointing to the primary reserved

 * GDT blocks so we don't overwrite a data block by accident.  The reserved

 * backup GDT blocks are stored in their reserved primary GDT block.

 Get each reserved primary GDT block and verify it holds backups */

	/*

	 * Finally we can add each of the reserved backup GDT blocks from

	 * the new group to its reserved primary GDT block.

		/* printk("reserving backup %lu[%u] = %lu\n",

		       primary[i]->b_blocknr, gdbackups,

/*

 * Update the backup copies of the ext4 metadata.  These don't need to be part

 * of the main resize transaction, because e2fsck will re-write them if there

 * is a problem (basically only OOM will cause a problem).  However, we

 * _should_ update the backups if possible, in case the primary gets trashed

 * for some reason and we need to run e2fsck from a backup superblock.  The

 * important part is that the new block and inode counts are in the backup

 * superblocks, and the location of the new group metadata in the GDT backups.

 *

 * We do not need take the s_resize_lock for this, because these

 * blocks are not otherwise touched by the filesystem code when it is

 * mounted.  We don't need to worry about last changing from

 * sbi->s_groups_count, because the worst that can happen is that we

 * do not copy the full number of backups at this time.  The resize

 * which changed s_groups_count will backup again.

 Out of journal space, and can't get more - abort - so sad */

	/*

	 * Ugh! Need to have e2fsck write the backup copies.  It is too

	 * late to revert the resize, we shouldn't fail just because of

	 * the backup copies (they are only needed in case of corruption).

	 *

	 * However, if we got here we have a journal problem too, so we

	 * can't really start a transaction to mark the superblock.

	 * Chicken out and just set the flag on the hope it will be written

	 * to disk, and if not - we will simply wait until next fsck.

/*

 * ext4_add_new_descs() adds @count group descriptor of groups

 * starting at @group

 *

 * @handle: journal handle

 * @sb: super block

 * @group: the group no. of the first group desc to be added

 * @resize_inode: the resize inode

 * @count: number of group descriptors to be added

		/*

		 * We will only either add reserved group blocks to a backup group

		 * or remove reserved blocks for the first group in a new group block.

		 * Doing both would be mean more complex code, and sane people don't

		 * use non-sparse filesystems anymore.  This is already checked above.

/*

 * ext4_setup_new_descs() will set up the group descriptor descriptors of a flex bg

		/*

		 * get_write_access() has been called on gdb_bh by ext4_add_new_desc().

 Update group descriptor block for new group */

		/*

		 * We can allocate memory for mb_alloc based on the new group

		 * descriptor

/*

 * ext4_update_super() updates the super block so that the newly added

 * groups can be seen by the filesystem.

 *

 * @sb: super block

 * @flex_gd: new added groups

	/*

	 * Make the new blocks and inodes valid next.  We do this before

	 * increasing the group count so that once the group is enabled,

	 * all of its blocks and inodes are already valid.

	 *

	 * We always allocate group-by-group, then block-by-block or

	 * inode-by-inode within a group, so enabling these

	 * blocks/inodes before the group is live won't actually let us

	 * allocate the new space yet.

	/*

	 * We need to protect s_groups_count against other CPUs seeing

	 * inconsistent state in the superblock.

	 *

	 * The precise rules we use are:

	 *

	 * * Writers must perform a smp_wmb() after updating all

	 *   dependent data and before modifying the groups count

	 *

	 * * Readers must perform an smp_rmb() after reading the groups

	 *   count and before reading any dependent data.

	 *

	 * NB. These rules can be relaxed when checking the group count

	 * while freeing data, as we can only allocate from a block

	 * group after serialising against the group count, and we can

	 * only then free after serialising in turn against that

	 * allocation.

 Update the global fs size fields */

	/* Update the reserved block counts only once the new group is

 Update the free space counts */

	/*

	 * Update the fs overhead information

/* Add a flex group to an fs. Ensure we handle all possible error conditions

 * _before_ we start modifying the filesystem, because we cannot abort the

 * transaction and not have it write the data to disk.

	/*

	 * We will always be modifying at least the superblock and  GDT

	 * blocks.  If we are adding a group past the last current GDT block,

	 * we will also modify the inode and the dindirect block.  If we

	 * are adding a group with superblock/GDT backups  we will also

	 * modify each of the reserved GDT dindirect blocks.

 sb, resize inode, resize inode dindirect */

 GDT blocks */

 Reserved GDT dindirect blocks */

 We need to initialize block bitmap of last group. */

/* Add group descriptor data to an existing or new group descriptor block.

 * Ensure we handle all possible error conditions _before_ we start modifying

 * the filesystem, because we cannot abort the transaction and not have it

 * write the data to disk.

 *

 * If we are on a GDT block boundary, we need to get the reserved GDT block.

 * Otherwise, we may need to add backup GDT blocks for a sparse group.

 *

 * We only need to hold the superblock lock while we are actually adding

 * in the new group's counts to the superblock.  Prior to that we have

 * not really "added" the group at all.  We re-check that we are still

 * adding in the last group in case things have changed since verifying.

 ext4_group_add */

/*

 * extend a group without checking assuming that checking has been done.

	/* We will update the superblock, one block bitmap, and

	 * one group descriptor via ext4_group_add_blocks().

 We add the blocks to the bitmap and set the group need init bit */

/*

 * Extend the filesystem to the new number of blocks specified.  This entry

 * point is only used to extend the current filesystem to the end of the last

 * existing group.  It can be accessed via ioctl, or by "remount,resize=<size>"

 * for emergencies (because it has no dependencies on reserved blocks).

 *

 * If we _really_ wanted, we could use default values to call ext4_group_add()

 * allow the "remount" trick to work for arbitrary resizing, assuming enough

 * GDT blocks are reserved to grow to the desired size.

 Handle the remaining blocks in the last group only. */

 See if the device is actually as big as what was requested */

 ext4_group_extend */

/*

 * Release the resize inode and drop the resize_inode feature if there

 * are no more reserved gdt blocks, and then convert the file system

 * to enable meta_bg

 Do a quick sanity check of the resize inode */

 block bitmap, bg descriptor, resize inode */

/*

 * ext4_resize_fs() resizes a fs to new size specified by @n_blocks_count

 *

 * @sb: super block of the fs to be resized

 * @n_blocks_count: the number of blocks resides in the resized fs

 See if the device is actually as big as what was requested */

 On-line shrinking not supported */

 Nothing need to do */

 set to last group number */

	/*

	 * Make sure the last group has enough space so that it's

	 * guaranteed to have enough space for all metadata blocks

	 * that it might need to hold.  (We might not need to store

	 * the inode table blocks in the last block group, but there

	 * will be cases where this might be needed.)

 extend the last group */

	/* Add flex groups. Note that a regular group is a

	 * flex group with 1 group.

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/ext4/file.c

 *

 * Copyright (C) 1992, 1993, 1994, 1995

 * Remy Card (card@masi.ibp.fr)

 * Laboratoire MASI - Institut Blaise Pascal

 * Universite Pierre et Marie Curie (Paris VI)

 *

 *  from

 *

 *  linux/fs/minix/file.c

 *

 *  Copyright (C) 1991, 1992  Linus Torvalds

 *

 *  ext4 fs regular file handling primitives

 *

 *  64-bit file support on 64-bit platforms by Jakub Jelinek

 *	(jj@sunsite.ms.mff.cuni.cz)

		/*

		 * Fallback to buffered I/O if the operation being performed on

		 * the inode is not supported by direct I/O. The IOCB_DIRECT

		 * flag needs to be cleared here in order to ensure that the

		 * direct I/O path within generic_file_read_iter() is not

		 * taken.

	/*

	 * Recheck under inode lock - at this point we are sure it cannot

	 * change anymore

 Fallback to buffered IO in case we cannot support DAX */

 skip atime */

/*

 * Called when an inode is released. Note that this is different

 * from ext4_file_open: open gets called at every open, but release

 * gets called only when /all/ the files are closed.

 if we are the last writer on the inode, drop the block reservation */

/*

 * This tests whether the IO in question is block-aligned or not.

 * Ext4 utilizes unwritten extents when hole-filling during direct IO, and they

 * are converted to written only after the IO is complete.  Until they are

 * mapped, these blocks appear as holes, so dio_zero_block() will assume that

 * it needs to zero out portions of the start and/or end block.  If 2 AIO

 * threads are at work on the same unwritten block, they must be synchronized

 * or one thread will zero the other's data, causing corruption.

 Is IO overwriting allocated and initialized blocks? */

	/*

	 * 'err==len' means that all of the blocks have been preallocated,

	 * regardless of whether they have been initialized or not. To exclude

	 * unwritten extents, we need to check m_flags.

	/*

	 * If we have encountered a bitmap-format file, the size limit

	 * is smaller than s_maxbytes, which is for extent-mapped files.

	/*

	 * Note that EXT4_I(inode)->i_disksize can get extended up to

	 * inode->i_size while the I/O was running due to writeback of delalloc

	 * blocks. But, the code in ext4_iomap_alloc() is careful to use

	 * zeroed/unwritten extents if this is possible; thus we won't leave

	 * uninitialized blocks in a file even if we didn't succeed in writing

	 * as much as we intended.

		/*

		 * We need to ensure that the inode is removed from the orphan

		 * list if it has been added prematurely, due to writeback of

		 * delalloc blocks.

	/*

	 * We may need to truncate allocated but not written blocks beyond EOF.

	/*

	 * Remove the inode from the orphan list if it has been extended and

	 * everything went OK.

		/*

		 * If the truncate operation failed early, then the inode may

		 * still be on the orphan list. In that case, we need to try

		 * remove the inode from the in-memory linked list.

	/*

	 * If we are extending the file, we have to update i_size here before

	 * page cache gets invalidated in iomap_dio_rw(). Otherwise racing

	 * buffered reads could zero out too much from page cache pages. Update

	 * of on-disk size will happen later in ext4_dio_write_iter() where

	 * we have enough information to also perform orphan list handling etc.

	 * Note that we perform all extending writes synchronously under

	 * i_rwsem held exclusively so i_size update is safe here in that case.

	 * If the write was not extending, we cannot see pos > i_size here

	 * because operations reducing i_size like truncate wait for all

	 * outstanding DIO before updating i_size.

/*

 * The intention here is to start with shared lock acquired then see if any

 * condition requires an exclusive inode lock. If yes, then we restart the

 * whole operation by releasing the shared lock and acquiring exclusive lock.

 *

 * - For unaligned_io we never take shared lock as it may cause data corruption

 *   when two unaligned IO tries to modify the same block e.g. while zeroing.

 *

 * - For extending writes case we don't take the shared lock, since it requires

 *   updating inode i_disksize and/or orphan handling with exclusive lock.

 *

 * - shared locking will only be true mostly with overwrites. Otherwise we will

 *   switch to exclusive i_rwsem lock.

	/*

	 * Determine whether the IO operation will overwrite allocated

	 * and initialized blocks.

	 * We need exclusive i_rwsem for changing security info

	 * in file_modified().

	/*

	 * We initially start with shared inode lock unless it is

	 * unaligned IO which needs exclusive lock anyways.

	/*

	 * Quick check here without any i_rwsem lock to see if it is extending

	 * IO. A more reliable check is done in ext4_dio_write_checks() with

	 * proper locking in place.

 Fallback to buffered I/O if the inode does not support direct I/O. */

 if we're going to block and IOCB_NOWAIT is set, return -EAGAIN */

	/*

	 * Unaligned direct IO must be serialized among each other as zeroing

	 * of partial blocks of two competing unaligned IOs can result in data

	 * corruption.

	 *

	 * So we make sure we don't allow any unaligned IO in flight.

	 * For IOs where we need not wait (like unaligned non-AIO DIO),

	 * below inode_dio_wait() may anyway become a no-op, since we start

	 * with exclusive lock.

		/*

		 * We need to ensure that the pages within the page cache for

		 * the range covered by this I/O are written to disk and

		 * invalidated. This is in attempt to preserve the expected

		 * direct I/O semantics in the case we fallback to buffered I/O

		 * to complete off the I/O request.

	/*

	 * We have to distinguish real writes from writes which will result in a

	 * COW page; COW writes should *not* poke the journal (the file will not

	 * be changed). Doing so would cause unintended failures when mounted

	 * read-only.

	 *

	 * We check for VM_SHARED rather than vmf->cow_page since the latter is

	 * unset for pe_size != PE_SIZE_PTE (i.e. only in do_cow_fault); for

	 * other sizes, dax_iomap_fault will handle splitting / fallback so that

	 * we eventually come back with a COW page.

 Handling synchronous page fault? */

	/*

	 * We don't support synchronous mappings for non-DAX files and

	 * for DAX files if underneath dax_device is not synchronous.

	/*

	 * Sample where the filesystem has been mounted and

	 * store it in the superblock for sysadmin convenience

	 * when trying to sort through large numbers of block

	 * devices or filesystem images.

	/*

	 * Set up the jbd2_inode if we are opening the inode for

	 * writing and the journal is present

/*

 * ext4_llseek() handles both block-mapped and extent-mapped maxbytes values

 * by calling generic_file_llseek_size() with the appropriate maxbytes

 * value for each.

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright (C) 2017 Oracle.  All Rights Reserved.

 *

 * Author: Darrick J. Wong <darrick.wong@oracle.com>

 Convert an ext4_fsmap to an fsmap. */

 Convert an fsmap to an ext4_fsmap. */

 getfsmap query state */

 formatting fn */

 format buffer */

 next fsblock we expect */

 device id */

 bg number, if applicable */

 low rmap key */

 high rmap key */

 free ext at end of last bg */

 fixed metadata list */

 last extent? */

 Associate a device with a getfsmap handler. */

 Compare two getfsmap device handlers. */

 Compare a record against our starting point */

/*

 * Format a reverse mapping for getfsmap, having translated rm_startblock

 * into the appropriate daddr units.

	/*

	 * Filter out records that start before our startpoint, if the

	 * caller requested that.

 Are we just counting mappings? */

	/*

	 * If the record starts past the last physical block we saw,

	 * then we've found a gap.  Report the gap as being owned by

	 * whatever the caller specified is the missing owner.

 Fill out the extent we found */

 Transform a blockgroup's free record into a fsmap */

 If the retained free extent record is set... */

 ...and abuts this one, lengthen it and return. */

		/*

		 * There's a gap between the two free extents; emit the

		 * retained extent prior to merging the meta_list.

 Merge in any relevant extents from the meta_list */

 If this is a free extent at the end of a bg, buffer it. */

 Otherwise, emit it */

 Execute a getfsmap query against the log device. */

 Set up search keys */

 Fabricate an rmap entry for the external log device. */

 Helper to fill out an ext4_fsmap. */

/*

 * This function returns the number of file system metadata blocks at

 * the beginning of a block group, including the reserved gdt blocks.

 Record the superblock. */

 Record the group descriptors. */

 Reserved GDT blocks */

 Compare two fsmap items. */

 Merge adjacent extents of fixed metadata. */

 Free a list of fixed metadata. */

 Find all the fixed metadata in the filesystem. */

 Collect everything. */

 Superblock & GDT */

 Block bitmap */

 Inode bitmap */

 Inodes */

 Sort the list */

 Merge adjacent extents */

 Execute a getfsmap query against the buddy bitmaps */

 Determine first and last group to examine based on start and end */

	/*

	 * Convert the fsmap low/high keys to bg based keys.  Initialize

	 * low to the fsmap low key and max out the high key to the end

	 * of the bg.

 Assemble a list of all the fixed-location metadata. */

 Query each bg */

		/*

		 * Set the bg high key from the fsmap high key if this

		 * is the last bg that we're querying.

		/*

		 * Set the bg low key to the start of the bg prior to

		 * moving on to the next bg.

 Do we have a retained free extent? */

 Report any gaps at the end of the bg */

 Do we recognize the device? */

 Ensure that the low key is less than the high key. */

/*

 * Get filesystem's extents as described in head, and format for

 * output.  Calls formatter to fill the user's buffer until all

 * extents are mapped, until the passed-in head->fmh_count slots have

 * been filled, or until the formatter short-circuits the loop, if it

 * is tracking filled-in extents on its own.

 *

 * Key to Confusion

 * ----------------

 * There are multiple levels of keys and counters at work here:

 * _fsmap_head.fmh_keys		-- low and high fsmap keys passed in;

 * 				   these reflect fs-wide block addrs.

 * dkeys			-- fmh_keys used to query each device;

 * 				   these are fmh_keys but w/ the low key

 * 				   bumped up by fmr_length.

 * _getfsmap_info.gfi_next_fsblk-- next fs block we expect to see; this

 *				   is how we detect gaps in the fsmap

 *				   records and report them.

 * _getfsmap_info.gfi_low/high	-- per-bg low/high keys computed from

 * 				   dkeys; used to query the free space.

 per-dev keys */

 Set up our device handlers. */

	/*

	 * To continue where we left off, we allow userspace to use the

	 * last mapping from a previous call as the low key of the next.

	 * This is identified by a non-zero length in the low key. We

	 * have to increment the low key in this scenario to ensure we

	 * don't return the same mapping again, and instead return the

	 * very next mapping.

	 *

	 * Bump the physical offset as there can be no other mapping for

	 * the same physical block range.

 For each device we support... */

 Is this device within the range the user asked for? */

		/*

		 * If this device number matches the high key, we have

		 * to pass the high key to the handler to limit the

		 * query results.  If the device number exceeds the

		 * low key, zero out the low key so that we get

		 * everything from the beginning.

 SPDX-License-Identifier: GPL-2.0

/*

 *  fs/ext4/extents_status.c

 *

 * Written by Yongqiang Yang <xiaoqiangnk@gmail.com>

 * Modified by

 *	Allison Henderson <achender@linux.vnet.ibm.com>

 *	Hugh Dickins <hughd@google.com>

 *	Zheng Liu <wenqing.lz@taobao.com>

 *

 * Ext4 extents status tree core functions.

/*

 * According to previous discussion in Ext4 Developer Workshop, we

 * will introduce a new structure called io tree to track all extent

 * status in order to solve some problems that we have met

 * (e.g. Reservation space warning), and provide extent-level locking.

 * Delay extent tree is the first step to achieve this goal.  It is

 * original built by Yongqiang Yang.  At that time it is called delay

 * extent tree, whose goal is only track delayed extents in memory to

 * simplify the implementation of fiemap and bigalloc, and introduce

 * lseek SEEK_DATA/SEEK_HOLE support.  That is why it is still called

 * delay extent tree at the first commit.  But for better understand

 * what it does, it has been rename to extent status tree.

 *

 * Step1:

 * Currently the first step has been done.  All delayed extents are

 * tracked in the tree.  It maintains the delayed extent when a delayed

 * allocation is issued, and the delayed extent is written out or

 * invalidated.  Therefore the implementation of fiemap and bigalloc

 * are simplified, and SEEK_DATA/SEEK_HOLE are introduced.

 *

 * The following comment describes the implemenmtation of extent

 * status tree and future works.

 *

 * Step2:

 * In this step all extent status are tracked by extent status tree.

 * Thus, we can first try to lookup a block mapping in this tree before

 * finding it in extent tree.  Hence, single extent cache can be removed

 * because extent status tree can do a better job.  Extents in status

 * tree are loaded on-demand.  Therefore, the extent status tree may not

 * contain all of the extents in a file.  Meanwhile we define a shrinker

 * to reclaim memory from extent status tree because fragmented extent

 * tree will make status tree cost too much memory.  written/unwritten/-

 * hole extents in the tree will be reclaimed by this shrinker when we

 * are under high memory pressure.  Delayed extents will not be

 * reclimed because fiemap, bigalloc, and seek_data/hole need it.

/*

 * Extent status tree implementation for ext4.

 *

 *

 * ==========================================================================

 * Extent status tree tracks all extent status.

 *

 * 1. Why we need to implement extent status tree?

 *

 * Without extent status tree, ext4 identifies a delayed extent by looking

 * up page cache, this has several deficiencies - complicated, buggy,

 * and inefficient code.

 *

 * FIEMAP, SEEK_HOLE/DATA, bigalloc, and writeout all need to know if a

 * block or a range of blocks are belonged to a delayed extent.

 *

 * Let us have a look at how they do without extent status tree.

 *   --	FIEMAP

 *	FIEMAP looks up page cache to identify delayed allocations from holes.

 *

 *   --	SEEK_HOLE/DATA

 *	SEEK_HOLE/DATA has the same problem as FIEMAP.

 *

 *   --	bigalloc

 *	bigalloc looks up page cache to figure out if a block is

 *	already under delayed allocation or not to determine whether

 *	quota reserving is needed for the cluster.

 *

 *   --	writeout

 *	Writeout looks up whole page cache to see if a buffer is

 *	mapped, If there are not very many delayed buffers, then it is

 *	time consuming.

 *

 * With extent status tree implementation, FIEMAP, SEEK_HOLE/DATA,

 * bigalloc and writeout can figure out if a block or a range of

 * blocks is under delayed allocation(belonged to a delayed extent) or

 * not by searching the extent tree.

 *

 *

 * ==========================================================================

 * 2. Ext4 extent status tree impelmentation

 *

 *   --	extent

 *	A extent is a range of blocks which are contiguous logically and

 *	physically.  Unlike extent in extent tree, this extent in ext4 is

 *	a in-memory struct, there is no corresponding on-disk data.  There

 *	is no limit on length of extent, so an extent can contain as many

 *	blocks as they are contiguous logically and physically.

 *

 *   --	extent status tree

 *	Every inode has an extent status tree and all allocation blocks

 *	are added to the tree with different status.  The extent in the

 *	tree are ordered by logical block no.

 *

 *   --	operations on a extent status tree

 *	There are three important operations on a delayed extent tree: find

 *	next extent, adding a extent(a range of blocks) and removing a extent.

 *

 *   --	race on a extent status tree

 *	Extent status tree is protected by inode->i_es_lock.

 *

 *   --	memory consumption

 *      Fragmented extent tree will make extent status tree cost too much

 *      memory.  Hence, we will reclaim written/unwritten/hole extents from

 *      the tree under a heavy memory pressure.

 *

 *

 * ==========================================================================

 * 3. Performance analysis

 *

 *   --	overhead

 *	1. There is a cache extent for write access, so if writes are

 *	not very random, adding space operaions are in O(1) time.

 *

 *   --	gain

 *	2. Code is much simpler, more readable, more maintainable and

 *	more efficient.

 *

 *

 * ==========================================================================

 * 4. TODO list

 *

 *   -- Refactor delayed space reservation

 *

 *   -- Extent-level locking

/*

 * search through the tree for an delayed extent with a given offset.  If

 * it can't be found, try to find next extent.

/*

 * ext4_es_find_extent_range - find extent with specified status within block

 *                             range or next extent following block range in

 *                             extents status tree

 *

 * @inode - file containing the range

 * @matching_fn - pointer to function that matches extents with desired status

 * @lblk - logical block defining start of range

 * @end - logical block defining end of range

 * @es - extent found, if any

 *

 * Find the first extent within the block range specified by @lblk and @end

 * in the extents status tree that satisfies @matching_fn.  If a match

 * is found, it's returned in @es.  If not, and a matching extent is found

 * beyond the block range, it's returned in @es.  If no match is found, an

 * extent is returned in @es whose es_lblk, es_len, and es_pblk components

 * are 0.

 see if the extent has been cached */

/*

 * Locking for __es_find_extent_range() for external use

/*

 * __es_scan_range - search block range for block with specified status

 *                   in extents status tree

 *

 * @inode - file containing the range

 * @matching_fn - pointer to function that matches extents with desired status

 * @lblk - logical block defining start of range

 * @end - logical block defining end of range

 *

 * Returns true if at least one block in the specified block range satisfies

 * the criterion specified by @matching_fn, and false if not.  If at least

 * one extent has the specified status, then there is at least one block

 * in the cluster with that status.  Should only be called by code that has

 * taken i_es_lock.

 no matching extent in the tree */

/*

 * Locking for __es_scan_range() for external use

/*

 * __es_scan_clu - search cluster for block with specified status in

 *                 extents status tree

 *

 * @inode - file containing the cluster

 * @matching_fn - pointer to function that matches extents with desired status

 * @lblk - logical block in cluster to be searched

 *

 * Returns true if at least one extent in the cluster containing @lblk

 * satisfies the criterion specified by @matching_fn, and false if not.  If at

 * least one extent has the specified status, then there is at least one block

 * in the cluster with that status.  Should only be called by code that has

 * taken i_es_lock.

/*

 * Locking for __es_scan_clu() for external use

	/*

	 * We don't count delayed extent because we never try to reclaim them

 Decrease the shrink counter when this es is not delayed */

/*

 * Check whether or not two extents can be merged

 * Condition:

 *  - logical block number is contiguous

 *  - physical block number is contiguous

 *  - status is equal

 we need to check delayed extent is without unwritten status */

 Needed when ES_AGGRESSIVE_TEST is defined */

		/*

		 * Make sure ex and es are not overlap when we try to insert

		 * a delayed/hole extent.

		/*

		 * We don't check ee_block == es->es_lblk, etc. because es

		 * might be a part of whole extent, vice versa.

		/*

		 * We can't find an extent on disk.  So we need to make sure

		 * that we don't want to add an written/unwritten extent.

	/*

	 * Here we call ext4_ind_map_blocks to lookup a block mapping because

	 * 'Indirect' structure is defined in indirect.c.  So we couldn't

	 * access direct/indirect tree from outside.  It is too dirty to define

	 * this function in indirect.c file.

			/*

			 * We want to add a delayed/hole extent but this

			 * block has been allocated.

			/*

			 * We don't need to check unwritten extent because

			 * indirect-based file doesn't have it.

	/*

	 * We don't need to worry about the race condition because

	 * caller takes i_data_sem locking.

				/*

				 * Here we can modify es_lblk directly

				 * because it isn't overlapped.

/*

 * ext4_es_insert_extent() adds information to an inode's extent

 * status tree.

 *

 * Return 0 on success, error code on failure.

/*

 * ext4_es_cache_extent() inserts information into the extent status

 * tree if and only if there isn't information about the range in

 * question already.

/*

 * ext4_es_lookup_extent() looks up an extent in extent status tree.

 *

 * ext4_es_lookup_extent is called by ext4_map_blocks/ext4_da_map_blocks.

 *

 * Return: 1 on found, 0 on not

 find extent in cache firstly */

/*

 * init_rsvd - initialize reserved count data before removing block range

 *	       in file from extent status tree

 *

 * @inode - file containing range

 * @lblk - first block in range

 * @es - pointer to first extent in range

 * @rc - pointer to reserved count data

 *

 * Assumes es is not NULL

	/*

	 * for bigalloc, note the first delonly block in the range has not

	 * been found, record the extent containing the block to the left of

	 * the region to be removed, if any, and note that there's no partial

	 * cluster to track

/*

 * count_rsvd - count the clusters containing delayed and not unwritten

 *		(delonly) blocks in a range within an extent and add to

 *	        the running tally in rsvd_count

 *

 * @inode - file containing extent

 * @lblk - first block in range

 * @len - length of range in blocks

 * @es - pointer to extent containing clusters to be counted

 * @rc - pointer to reserved count data

 *

 * Tracks partial clusters found at the beginning and end of extents so

 * they aren't overcounted when they span adjacent extents

 bigalloc */

 record the first block of the first delonly extent seen */

 update the last lblk in the region seen so far */

	/*

	 * if we're tracking a partial cluster and the current extent

	 * doesn't start with it, count it and stop tracking

	/*

	 * if the first cluster doesn't start on a cluster boundary but

	 * ends on one, count it

	/*

	 * if the current cluster starts on a cluster boundary, count the

	 * number of whole delonly clusters in the extent

	/*

	 * start tracking a partial cluster if there's a partial at the end

	 * of the current extent and we're not already tracking one

/*

 * __pr_tree_search - search for a pending cluster reservation

 *

 * @root - root of pending reservation tree

 * @lclu - logical cluster to search for

 *

 * Returns the pending reservation for the cluster identified by @lclu

 * if found.  If not, returns a reservation for the next cluster if any,

 * and if not, returns NULL.

/*

 * get_rsvd - calculates and returns the number of cluster reservations to be

 *	      released when removing a block range from the extent status tree

 *	      and releases any pending reservations within the range

 *

 * @inode - file containing block range

 * @end - last block in range

 * @right_es - pointer to extent containing next block beyond end or NULL

 * @rc - pointer to reserved count data

 *

 * The number of reservations to be released is equal to the number of

 * clusters containing delayed and not unwritten (delonly) blocks within

 * the range, minus the number of clusters still containing delonly blocks

 * at the ends of the range, and minus the number of pending reservations

 * within the range.

 count any remaining partial cluster */

		/*

		 * decrease the delonly count by the number of clusters at the

		 * ends of the range that still contain delonly blocks -

		 * these clusters still need to be reserved

		/*

		 * Determine the block range that should be searched for

		 * pending reservations, if any.  Clusters on the ends of the

		 * original removed range containing delonly blocks are

		 * excluded.  They've already been accounted for and it's not

		 * possible to determine if an associated pending reservation

		 * should be released with the information available in the

		 * extents status tree.

		/*

		 * a pending reservation found between first_lclu and last_lclu

		 * represents an allocated cluster that contained at least one

		 * delonly block, so the delonly total must be reduced by one

		 * for each pending reservation found and released

/*

 * __es_remove_extent - removes block range from extent status tree

 *

 * @inode - file containing range

 * @lblk - first block in range

 * @end - last block in range

 * @reserved - number of cluster reservations released

 *

 * If @reserved is not NULL and delayed allocation is enabled, counts

 * block/cluster reservations freed by removing range and if bigalloc

 * enabled cancels pending reservations as needed. Returns 0 on success,

 * error code on failure.

 Simply invalidate cache_es. */

/*

 * ext4_es_remove_extent - removes block range from extent status tree

 *

 * @inode - file containing range

 * @lblk - first block in range

 * @len - number of blocks to remove

 *

 * Reduces block/cluster reservation count and for bigalloc cancels pending

 * reservations as needed. Returns 0 on success, error code on failure.

	/*

	 * ext4_clear_inode() depends on us taking i_es_lock unconditionally

	 * so that we are sure __es_shrink() is done with the inode before it

	 * is reclaimed.

 Move the inode to the tail */

		/*

		 * Normally we try hard to avoid shrinking precached inodes,

		 * but we will as a last resort.

		/*

		 * Now we hold i_es_lock which protects us from inode reclaim

		 * freeing inode under us

	/*

	 * If we skipped any inodes, and we weren't able to make any

	 * forward progress, try again to scan precached inodes.

 here we just find an inode that has the max nr. of objects */

 Make sure we have enough bits for physical block number */

/*

 * Shrink extents in given inode from ei->i_es_shrink_lblk till end. Scan at

 * most *nr_to_scan extents, update *nr_to_scan accordingly.

 *

 * Return 0 if we hit end of tree / interval, 1 if we exhausted nr_to_scan.

 * Increment *nr_shrunk by the number of reclaimed extents. Also update

 * ei->i_es_shrink_lblk to where we should continue scanning.

		/*

		 * We can't reclaim delayed extent from status tree because

		 * fiemap, bigallic, and seek_data/hole need to use it.

/*

 * Called to support EXT4_IOC_CLEAR_ES_CACHE.  We can only remove

 * discretionary entries from the extent status cache.  (Some entries

 * must be present for proper operations.)

/*

 * __get_pending - retrieve a pointer to a pending reservation

 *

 * @inode - file containing the pending cluster reservation

 * @lclu - logical cluster of interest

 *

 * Returns a pointer to a pending reservation if it's a member of

 * the set, and NULL if not.  Must be called holding i_es_lock.

/*

 * __insert_pending - adds a pending cluster reservation to the set of

 *                    pending reservations

 *

 * @inode - file containing the cluster

 * @lblk - logical block in the cluster to be added

 *

 * Returns 0 on successful insertion and -ENOMEM on failure.  If the

 * pending reservation is already in the set, returns successfully.

 search to find parent for insertion */

 pending reservation already inserted */

/*

 * __remove_pending - removes a pending cluster reservation from the set

 *                    of pending reservations

 *

 * @inode - file containing the cluster

 * @lblk - logical block in the pending cluster reservation to be removed

 *

 * Returns successfully if pending reservation is not a member of the set.

/*

 * ext4_remove_pending - removes a pending cluster reservation from the set

 *                       of pending reservations

 *

 * @inode - file containing the cluster

 * @lblk - logical block in the pending cluster reservation to be removed

 *

 * Locking for external use of __remove_pending.

/*

 * ext4_is_pending - determine whether a cluster has a pending reservation

 *                   on it

 *

 * @inode - file containing the cluster

 * @lblk - logical block in the cluster

 *

 * Returns true if there's a pending reservation for the cluster in the

 * set of pending reservations, and false if not.

/*

 * ext4_es_insert_delayed_block - adds a delayed block to the extents status

 *                                tree, adding a pending reservation where

 *                                needed

 *

 * @inode - file containing the newly added block

 * @lblk - logical block to be added

 * @allocated - indicates whether a physical cluster has been allocated for

 *              the logical cluster that contains the block

 *

 * Returns 0 on success, negative error code on failure.

/*

 * __es_delayed_clu - count number of clusters containing blocks that

 *                    are delayed only

 *

 * @inode - file containing block range

 * @start - logical block defining start of range

 * @end - logical block defining end of range

 *

 * Returns the number of clusters containing only delayed (not delayed

 * and unwritten) blocks in the range specified by @start and @end.  Any

 * cluster or part of a cluster within the range and containing a delayed

 * and not unwritten block within the range is counted as a whole cluster.

 guaranteed to be unequal to any ext4_lblk_t value */

/*

 * ext4_es_delayed_clu - count number of clusters containing blocks that

 *                       are both delayed and unwritten

 *

 * @inode - file containing block range

 * @lblk - logical block defining start of range

 * @len - number of blocks in range

 *

 * Locking for external use of __es_delayed_clu().

/*

 * __revise_pending - makes, cancels, or leaves unchanged pending cluster

 *                    reservations for a specified block range depending

 *                    upon the presence or absence of delayed blocks

 *                    outside the range within clusters at the ends of the

 *                    range

 *

 * @inode - file containing the range

 * @lblk - logical block defining the start of range

 * @len  - length of range in blocks

 *

 * Used after a newly allocated extent is added to the extents status tree.

 * Requires that the extents in the range have either written or unwritten

 * status.  Must be called while holding i_es_lock.

	/*

	 * Two cases - block range within single cluster and block range

	 * spanning two or more clusters.  Note that a cluster belonging

	 * to a range starting and/or ending on a cluster boundary is treated

	 * as if it does not contain a delayed extent.  The new range may

	 * have allocated space for previously delayed blocks out to the

	 * cluster boundary, requiring that any pre-existing pending

	 * reservation be canceled.  Because this code only looks at blocks

	 * outside the range, it should revise pending reservations

	 * correctly even if the extent represented by the range can't be

	 * inserted in the extents status tree due to ENOSPC.

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/ext4/symlink.c

 *

 * Only fast symlinks left here - the rest is done by generic code. AV, 1999

 *

 * Copyright (C) 1992, 1993, 1994, 1995

 * Remy Card (card@masi.ibp.fr)

 * Laboratoire MASI - Institut Blaise Pascal

 * Universite Pierre et Marie Curie (Paris VI)

 *

 *  from

 *

 *  linux/fs/minix/symlink.c

 *

 *  Copyright (C) 1991, 1992  Linus Torvalds

 *

 *  ext4 symlink handling code

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/ext4/indirect.c

 *

 *  from

 *

 *  linux/fs/ext4/inode.c

 *

 * Copyright (C) 1992, 1993, 1994, 1995

 * Remy Card (card@masi.ibp.fr)

 * Laboratoire MASI - Institut Blaise Pascal

 * Universite Pierre et Marie Curie (Paris VI)

 *

 *  from

 *

 *  linux/fs/minix/inode.c

 *

 *  Copyright (C) 1991, 1992  Linus Torvalds

 *

 *  Goal-directed block allocation by Stephen Tweedie

 *	(sct@redhat.com), 1993, 1998

/**

 *	ext4_block_to_path - parse the block number into array of offsets

 *	@inode: inode in question (we are only interested in its superblock)

 *	@i_block: block number to be parsed

 *	@offsets: array to store the offsets in

 *	@boundary: set this non-zero if the referred-to block is likely to be

 *	       followed (on disk) by an indirect block.

 *

 *	To store the locations of file's data ext4 uses a data structure common

 *	for UNIX filesystems - tree of pointers anchored in the inode, with

 *	data blocks at leaves and indirect blocks in intermediate nodes.

 *	This function translates the block number into path in that tree -

 *	return value is the path length and @offsets[n] is the offset of

 *	pointer to (n+1)th node in the nth one. If @block is out of range

 *	(negative or too large) warning is printed and zero returned.

 *

 *	Note: function doesn't find node addresses, so no IO is needed. All

 *	we need to know is the capacity of indirect blocks (taken from the

 *	inode->i_sb).

/*

 * Portability note: the last comparison (check that we fit into triple

 * indirect block) is spelled differently, because otherwise on an

 * architecture with 32-bit longs and 8Kb pages we might get into trouble

 * if our filesystem had 8Kb blocks. We might use long long, but that would

 * kill us on x86. Oh, well, at least the sign propagation does not matter -

 * i_block would have to be negative in the very beginning, so we would not

 * get there at all.

/**

 *	ext4_get_branch - read the chain of indirect blocks leading to data

 *	@inode: inode in question

 *	@depth: depth of the chain (1 - direct pointer, etc.)

 *	@offsets: offsets of pointers in inode/indirect blocks

 *	@chain: place to store the result

 *	@err: here we store the error value

 *

 *	Function fills the array of triples <key, p, bh> and returns %NULL

 *	if everything went OK or the pointer to the last filled triple

 *	(incomplete one) otherwise. Upon the return chain[i].key contains

 *	the number of (i+1)-th block in the chain (as it is stored in memory,

 *	i.e. little-endian 32-bit), chain[i].p contains the address of that

 *	number (it points into struct inode for i==0 and into the bh->b_data

 *	for i>0) and chain[i].bh points to the buffer_head of i-th indirect

 *	block for i>0 and NULL for i==0. In other words, it holds the block

 *	numbers of the chain, addresses they were taken from (and where we can

 *	verify that chain did not change) and buffer_heads hosting these

 *	numbers.

 *

 *	Function stops when it stumbles upon zero pointer (absent block)

 *		(pointer to last triple returned, *@err == 0)

 *	or when it gets an IO error reading an indirect block

 *		(ditto, *@err == -EIO)

 *	or when it reads all @depth-1 indirect blocks successfully and finds

 *	the whole chain, all way to the data (returns %NULL, *err == 0).

 *

 *      Need to be called with

 *      down_read(&EXT4_I(inode)->i_data_sem)

 i_data is not going away, no lock needed */

 validate block references */

 Reader: end */

/**

 *	ext4_find_near - find a place for allocation with sufficient locality

 *	@inode: owner

 *	@ind: descriptor of indirect block.

 *

 *	This function returns the preferred place for block allocation.

 *	It is used when heuristic for sequential allocation fails.

 *	Rules are:

 *	  + if there is a block to the left of our position - allocate near it.

 *	  + if pointer will live in indirect block - allocate near that block.

 *	  + if pointer will live in inode - allocate in the same

 *	    cylinder group.

 *

 * In the latter case we colour the starting block by the callers PID to

 * prevent it from clashing with concurrent allocations for a different inode

 * in the same block group.   The PID is used here so that functionally related

 * files will be close-by on-disk.

 *

 *	Caller must make sure that @ind is valid and will stay that way.

 Try to find previous block */

 No such thing, so let's try location of indirect block */

	/*

	 * It is going to be referred to from the inode itself? OK, just put it

	 * into the same cylinder group then.

/**

 *	ext4_find_goal - find a preferred place for allocation.

 *	@inode: owner

 *	@block:  block we want

 *	@partial: pointer to the last triple within a chain

 *

 *	Normally this function find the preferred place for block allocation,

 *	returns it.

 *	Because this is only used for non-extent files, we limit the block nr

 *	to 32 bits.

	/*

	 * XXX need to get goal block from mballoc's data structures

/**

 *	ext4_blks_to_allocate - Look up the block map and count the number

 *	of direct blocks need to be allocated for the given branch.

 *

 *	@branch: chain of indirect blocks

 *	@k: number of blocks need for indirect blocks

 *	@blks: number of data blocks to be mapped.

 *	@blocks_to_boundary:  the offset in the indirect block

 *

 *	return the total number of blocks to be allocate, including the

 *	direct and indirect blocks.

	/*

	 * Simple case, [t,d]Indirect block(s) has not allocated yet

	 * then it's clear blocks on that path have not allocated

 right now we don't handle cross boundary allocation */

/**

 * ext4_alloc_branch() - allocate and set up a chain of blocks

 * @handle: handle for this transaction

 * @ar: structure describing the allocation request

 * @indirect_blks: number of allocated indirect blocks

 * @offsets: offsets (in the blocks) to store the pointers to next.

 * @branch: place to store the chain in.

 *

 *	This function allocates blocks, zeroes out all but the last one,

 *	links them into chain and (if we are synchronous) writes them to disk.

 *	In other words, it prepares a branch that can be spliced onto the

 *	inode. It stores the information about that chain in the branch[], in

 *	the same format as ext4_get_branch() would do. We are calling it after

 *	we had read the existing part of chain and partial points to the last

 *	triple of that (one with zero ->key). Upon the exit we have the same

 *	picture as after the successful ext4_get_block(), except that in one

 *	place chain is disconnected - *branch->p is still zero (we did not

 *	set the last link), but branch->key contains the number that should

 *	be placed into *branch->p to fill that gap.

 *

 *	If allocation fails we free all blocks we've allocated (and forget

 *	their buffer_heads) and return the error value the from failed

 *	ext4_alloc_block() (normally -ENOSPC). Otherwise we set the chain

 *	as described above and return 0.

 Simplify error cleanup... */

 Free data blocks */

		/*

		 * We want to ext4_forget() only freshly allocated indirect

		 * blocks. Buffer for new_blocks[i] is at branch[i+1].bh

		 * (buffer at branch[0].bh is indirect block / inode already

		 * existing before ext4_alloc_branch() was called). Also

		 * because blocks are freshly allocated, we don't need to

		 * revoke them which is why we don't set

		 * EXT4_FREE_BLOCKS_METADATA.

/**

 * ext4_splice_branch() - splice the allocated branch onto inode.

 * @handle: handle for this transaction

 * @ar: structure describing the allocation request

 * @where: location of missing link

 * @num:   number of indirect blocks we are adding

 *

 * This function fills the missing link and does all housekeeping needed in

 * inode (->i_blocks, etc.). In case of success we end up with the full

 * chain to new block and return 0.

	/*

	 * If we're splicing into a [td]indirect block (as opposed to the

	 * inode) then we need to get write access to the [td]indirect block

	 * before the splice.

 That's it */

	/*

	 * Update the host buffer_head or inode to point to more just allocated

	 * direct blocks blocks

 We are done with atomic stuff, now do the rest of housekeeping */

 had we spliced it onto indirect block? */

		/*

		 * If we spliced it onto an indirect block, we haven't

		 * altered the inode.  Note however that if it is being spliced

		 * onto an indirect block at the very end of the file (the

		 * file is growing) then we *will* alter the inode to reflect

		 * the new i_size.  But that is not done here - it is done in

		 * generic_commit_write->__mark_inode_dirty->ext4_dirty_inode.

		/*

		 * OK, we spliced it into the inode itself on a direct block.

		/*

		 * branch[i].bh is newly allocated, so there is no

		 * need to revoke the block, which is why we don't

		 * need to set EXT4_FREE_BLOCKS_METADATA.

/*

 * The ext4_ind_map_blocks() function handles non-extents inodes

 * (i.e., using the traditional indirect/double-indirect i_blocks

 * scheme) for ext4_map_blocks().

 *

 * Allocation strategy is simple: if we have to allocate something, we will

 * have to go the whole way to leaf. So let's do it before attaching anything

 * to tree, set linkage between the newborn blocks, write them if sync is

 * required, recheck the path, free and repeat if check fails, otherwise

 * set the last missing link (that will protect us from any truncate-generated

 * removals - all blocks on the path are immune now) and possibly force the

 * write on the parent block.

 * That has a nice additional property: no special recovery from the failed

 * allocations is needed - we simply release blocks and do not touch anything

 * reachable from inode.

 *

 * `handle' can be NULL if create == 0.

 *

 * return > 0, # of blocks mapped or allocated.

 * return = 0, if plain lookup failed.

 * return < 0, error case.

 *

 * The ext4_ind_get_blocks() function should be called with

 * down_write(&EXT4_I(inode)->i_data_sem) if allocating filesystem

 * blocks (i.e., flags has EXT4_GET_BLOCKS_CREATE set) or

 * down_read(&EXT4_I(inode)->i_data_sem) if not allocating file system

 * blocks.

 Simplest case - block found, no allocation needed */

map more blocks*/

 Next simple case - plain lookup failed */

		/*

		 * Count number blocks in a subtree under 'partial'. At each

		 * level we count number of complete empty subtrees beyond

		 * current offset and then descend into the subtree only

		 * partially beyond current offset.

 Fill in size of a hole we found */

 Failed read of indirect block */

	/*

	 * Okay, we need to do block allocation.

 Set up for the direct block allocation */

 the number of blocks need to allocate for [d,t]indirect blocks */

	/*

	 * Next look up the indirect map to count the totoal number of

	 * direct blocks to allocate for this branch.

	/*

	 * Block out ext4_truncate while we alter the tree

	/*

	 * The ext4_splice_branch call will free and forget any buffers

	 * on the new chain if there is a failure, but that risks using

	 * up transaction credits, especially for bitmaps where the

	 * credits cannot be returned.  Can we handle this somehow?  We

	 * may need to return -EAGAIN upwards in the worst case.  --sct

 Clean up and exit */

 the whole chain */

/*

 * Calculate number of indirect blocks touched by mapping @nrblocks logically

 * contiguous blocks

	/*

	 * With N contiguous data blocks, we need at most

	 * N/EXT4_ADDR_PER_BLOCK(inode->i_sb) + 1 indirect blocks,

	 * 2 dindirect blocks, and 1 tindirect block

	/*

	 * Drop i_data_sem to avoid deadlock with ext4_map_blocks.  At this

	 * moment, get_block can be called only for blocks inside i_size since

	 * page cache has been already dropped and writes are blocked by

	 * i_mutex. So we can safely drop the i_data_sem here.

/*

 * Truncate transactions can be complex and absolutely huge.  So we need to

 * be able to restart the transaction at a convenient checkpoint to make

 * sure we don't overflow the journal.

 *

 * Try to extend this transaction for the purposes of truncation.  If

 * extend fails, we restart transaction.

/*

 * Probably it should be a library function... search for first non-zero word

 * or memcmp with zero_page, whatever is better for particular architecture.

 * Linus?

/**

 *	ext4_find_shared - find the indirect blocks for partial truncation.

 *	@inode:	  inode in question

 *	@depth:	  depth of the affected branch

 *	@offsets: offsets of pointers in that branch (see ext4_block_to_path)

 *	@chain:	  place to store the pointers to partial indirect blocks

 *	@top:	  place to the (detached) top of branch

 *

 *	This is a helper function used by ext4_truncate().

 *

 *	When we do truncate() we may have to clean the ends of several

 *	indirect blocks but leave the blocks themselves alive. Block is

 *	partially truncated if some data below the new i_size is referred

 *	from it (and it is on the path to the first completely truncated

 *	data block, indeed).  We have to free the top of that path along

 *	with everything to the right of the path. Since no allocation

 *	past the truncation point is possible until ext4_truncate()

 *	finishes, we may safely do the latter, but top of branch may

 *	require special attention - pageout below the truncation point

 *	might try to populate it.

 *

 *	We atomically detach the top of branch from the tree, store the

 *	block number of its root in *@top, pointers to buffer_heads of

 *	partially truncated blocks - in @chain[].bh and pointers to

 *	their last elements that should not be removed - in

 *	@chain[].p. Return value is the pointer to last filled element

 *	of @chain.

 *

 *	The work left to caller to do the actual freeing of subtrees:

 *		a) free the subtree starting from *@top

 *		b) free the subtrees whose roots are stored in

 *			(@chain[i].p+1 .. end of @chain[i].bh->b_data)

 *		c) free the subtrees growing from the inode past the @chain[0].

 Make k index the deepest non-null offset + 1 */

 Writer: pointers */

	/*

	 * If the branch acquired continuation since we've looked at it -

	 * fine, it should all survive and (new) top doesn't belong to us.

 Writer: end */

	/*

	 * OK, we've found the last block that must survive. The rest of our

	 * branch should be detached before unlocking. However, if that rest

	 * of branch is all ours and does not grow immediately from the inode

	 * it's easier to cheat and just decrement partial->p.

 Nope, don't do this in ext4.  Must leave the tree intact */

 Writer: end */

/*

 * Zero a number of block pointers in either an inode or an indirect block.

 * If we restart the transaction we must again get write access to the

 * indirect block for further modification.

 *

 * We release `count' blocks on disk, but (last - first) may be greater

 * than `count' because there can be holes in there.

 *

 * Return 0 on success, 1 on invalid block range

 * and < 0 on fatal error.

/**

 * ext4_free_data - free a list of data blocks

 * @handle:	handle for this transaction

 * @inode:	inode we are dealing with

 * @this_bh:	indirect buffer_head which contains *@first and *@last

 * @first:	array of block numbers

 * @last:	points immediately past the end of array

 *

 * We are freeing all blocks referred from that array (numbers are stored as

 * little-endian 32-bit) and updating @inode->i_blocks appropriately.

 *

 * We accumulate contiguous runs of blocks to free.  Conveniently, if these

 * blocks are contiguous then releasing them at one time will only affect one

 * or two bitmap blocks (+ group descriptor(s) and superblock) and we won't

 * actually use a lot of journal space.

 *

 * @this_bh will be %NULL if @first and @last point into the inode's direct

 * block pointers.

 Starting block # of a run */

 Number of blocks in the run */

	__le32 *block_to_free_p = NULL;	    /* Pointer into inode/ind

					       corresponding to

 Current block # */

	__le32 *p;			    /* Pointer into inode/ind

 For indirect block */

		/* Important: if we can't update the indirect pointers

 accumulate blocks to free if they're contiguous */

 fatal error */

		/*

		 * The buffer head should have an attached journal head at this

		 * point. However, if the data is corrupted and an indirect

		 * block pointed to itself, it would have been detached when

		 * the block was cleared. Check for this instead of OOPSing.

/**

 *	ext4_free_branches - free an array of branches

 *	@handle: JBD handle for this transaction

 *	@inode:	inode we are dealing with

 *	@parent_bh: the buffer_head which contains *@first and *@last

 *	@first:	array of block numbers

 *	@last:	pointer immediately past the end of array

 *	@depth:	depth of the branches to free

 *

 *	We are freeing all blocks referred from these branches (numbers are

 *	stored as little-endian 32-bit) and updating @inode->i_blocks

 *	appropriately.

 A hole */

 Go read the buffer for the next level down */

			/*

			 * A read failure? Report error and clear slot

			 * (should be rare).

 This zaps the entire block.  Bottom up. */

			/*

			 * Everything below this pointer has been

			 * released.  Now let this top-of-subtree go.

			 *

			 * We want the freeing of this indirect block to be

			 * atomic in the journal with the updating of the

			 * bitmap block which owns it.  So make some room in

			 * the journal.

			 *

			 * We zero the parent pointer *after* freeing its

			 * pointee in the bitmaps, so if extend_transaction()

			 * for some reason fails to put the bitmap changes and

			 * the release into the same transaction, recovery

			 * will merely complain about releasing a free block,

			 * rather than leaking blocks.

			/*

			 * The forget flag here is critical because if

			 * we are journaling (and not doing data

			 * journaling), we have to make sure a revoke

			 * record is written to prevent the journal

			 * replay from overwriting the (former)

			 * indirect block if it gets reallocated as a

			 * data block.  This must happen in the same

			 * transaction where the data blocks are

			 * actually freed.

				/*

				 * The block which we have just freed is

				 * pointed to by an indirect block: journal it

 We have reached the bottom of the tree. */

	/*

	 * The orphan list entry will now protect us from any crash which

	 * occurs before the truncate completes, so it is now safe to propagate

	 * the new, shorter inode size (held for now in i_size) into the

	 * on-disk inode. We do this via i_disksize, which is the value which

	 * ext4 *really* writes onto the disk inode.

		/*

		 * It is unnecessary to free any data blocks if last_block is

		 * equal to the indirect block limit.

 direct blocks */

 Kill the top of shared branch (not detached) */

 Shared branch grows from the inode */

			/*

			 * We mark the inode dirty prior to restart,

			 * and prior to stop.  No need for it here.

 Shared branch grows from an indirect block */

 Clear the ends of indirect blocks on the shared branch */

 Kill the remaining (whole) subtrees */

/**

 *	ext4_ind_remove_space - remove space from the range

 *	@handle: JBD handle for this transaction

 *	@inode:	inode we are dealing with

 *	@start:	First block to remove

 *	@end:	One block after the last block to remove (exclusive)

 *

 *	Free the blocks in the defined range (end is exclusive endpoint of

 *	range). This is used by ext4_punch_hole().

 We're punching only within direct block range */

		/*

		 * Start and end are on a different levels so we're going to

		 * free partial block at start, and partial block at end of

		 * the range. If there are some levels in between then

		 * do_indirects label will take care of that.

			/*

			 * Start is at the direct block level, free

			 * everything to the end of the level.

 Shared branch grows from the inode */

 Shared branch grows from an indirect block */

		/*

		 * Clear the ends of indirect blocks on the shared branch

		 * at the start of the range

				/*

				 * Remember, end is exclusive so here we're at

				 * the start of the next level we're not going

				 * to free. Everything was covered by the start

				 * of the range.

			/*

			 * ext4_find_shared returns Indirect structure which

			 * points to the last element which should not be

			 * removed by truncate. But this is end of the range

			 * in punch_hole so we need to point to the next element

		/*

		 * Clear the ends of indirect blocks on the shared branch

		 * at the end of the range

 Punch happened within the same level (n == n2) */

 Free top, but only if partial2 isn't its subtree. */

 Shared branch grows from the inode */

 Shared branch grows from an indirect block */

		/*

		 * ext4_find_shared returns Indirect structure which

		 * points to the last element which should not be

		 * removed by truncate. But this is end of the range

		 * in punch_hole so we need to point to the next element

			/*

			 * We've converged on the same block. Clear the range,

			 * then we're done.

		/*

		 * The start and end partial branches may not be at the same

		 * level even though the punch happened within one level. So, we

		 * give them a chance to arrive at the same level, then walk

		 * them in step with each other until we converge on the same

		 * block.

 Kill the remaining (whole) subtrees */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/ext4/bitmap.c

 *

 * Copyright (C) 1992, 1993, 1994, 1995

 * Remy Card (card@masi.ibp.fr)

 * Laboratoire MASI - Institut Blaise Pascal

 * Universite Pierre et Marie Curie (Paris VI)

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/ext4/xattr_trusted.c

 * Handler for trusted extended attributes.

 *

 * Copyright (C) 2003 by Andreas Gruenbacher, <a.gruenbacher@computer.org>

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/ext4/sysfs.c

 *

 * Copyright (C) 1992, 1993, 1994, 1995

 * Remy Card (card@masi.ibp.fr)

 * Theodore Ts'o (tytso@mit.edu)

 *

 Features this copy of ext4 supports */

 SPDX-License-Identifier: LGPL-2.1

/*

 * Copyright (c) 2012 Taobao.

 * Written by Tao Ma <boyu.mt@taobao.com>

	/*

	 * We need to subtract another sizeof(__u32) since an in-inode xattr

	 * needs an empty 4 bytes to indicate the gap between the xattr entry

	 * and the name/value pair.

 Compute min_offs. */

/*

 * Get the maximum size we now can store in an inode.

 * If we can't find the space for a xattr entry, don't use the space

 * of the extents since we have no space to indicate the inline data.

/*

 * this function does not take xattr_sem, which is OK because it is

 * currently only used in a code path coming form ext4_iget, before

 * the new inode has been unlocked

/*

 * write the buffer to the inline inode.

 * If 'create' is set, we don't need to do the extra copy in the xattr

 * value since it is already handled by ext4_xattr_ibody_set.

 * That saves us one memcpy.

 Insert the xttr entry. */

 If the old space is ok, write the data directly. */

 Update the xattr entry. */

	/*

	 * Current inline data can only exist in the 1st page,

	 * So for all the other pages, just set them uptodate.

		/*

		 * clear the flag so that no new write

		 * will trap here again.

	/* We cannot recurse into the filesystem as the transaction is already

 If some one has already done this for us, just exit. */

		/*

		 * If truncate failed early the inode might

		 * still be on the orphan list; we need to

		 * make sure the inode is removed from the

		 * orphan list in that case.

/*

 * Try to write data in the inode.

 * If the inode has inline data, check whether the new write can be

 * in the inode also. If not, create the page the handle, move the data

 * to the page make it update and let the later codes create extent for it.

	/*

	 * The possible write could happen in the inode,

	 * so try to reserve the space in inode first.

 We don't have space in inline inode, so convert it to extent. */

		/*

		 * ei->i_inline_off may have changed since

		 * ext4_write_begin() called

		 * ext4_try_to_write_inline_data()

 clear page dirty so that writepages wouldn't work for us. */

		/*

		 * It's important to update i_size while still holding page

		 * lock: page writeout could otherwise come in and zero

		 * beyond i_size.

	/*

	 * Don't mark the inode dirty under page lock. First, it unnecessarily

	 * makes the holding time of page lock longer. Second, it forces lock

	 * ordering of page lock and transaction start for journaling

	 * filesystems.

	/*

	 * If we didn't copy as much data as expected, we need to trim back

	 * size of xattr containing inline data.

		/*

		 * If truncate failed early the inode might still be

		 * on the orphan list; we need to make sure the inode

		 * is removed from the orphan list in that case.

/*

 * Try to make the page cache and handle ready for the inline data case.

 * We can call this function in 2 cases:

 * 1. The inode is created and the first write exceeds inline size. We can

 *    clear the inode state safely.

 * 2. The inode has inline data, then we need to read the data, make it

 *    update and dirty so that ext4_da_writepages can handle it. We don't

 *    need to start the journal since the file's metadata isn't changed now.

/*

 * Prepare the write for the inline data.

 * If the data can be written into the inode, we just read

 * the page and make it uptodate, and start the journal.

 * Otherwise read the page, makes it dirty so that it can be

 * handle in writepages(the i_disksize update is left to the

 * normal ext4_da_write_end).

	/*

	 * We cannot recurse into the filesystem as the transaction

	 * is already started.

/*

 * Add a new entry into a inline dir.

 * It will return -ENOSPC if no space is available, and -EIO

 * and -EEXIST if directory entry already exists.

	/*

	 * XXX shouldn't update any times until successful

	 * completion of syscall, but too many callers depend

	 * on this.

	 *

	 * XXX similarly, too many callers depend on

	 * ext4_new_inode() setting the times, but error

	 * recovery deletes the inode, so the worst that can

	 * happen is that the times are slightly out of date

	 * and/or different from the directory change time.

 Set the final de to cover the whole block. */

 this is just created, so create an empty entry. */

	/*

	 * First create "." and ".." and then copy the dir information

	 * back to the block.

	/*

	 * Make sure the inline directory entries pass checks before we try to

	 * convert them, so that we avoid touching stuff that needs fsck.

/*

 * Try to add the new entry to the inline data.

 * If succeeds, return 0. If not, extended the inline dir and copied data to

 * the new created block.

 check whether it can be inserted to inline xattr space. */

 Try to use the xattr space.*/

	/*

	 * The inline space is filled up, so create a new block for it.

	 * As the extent tree will be created, we have to save the inline

	 * dir first.

/*

 * This function fills a red-black tree with information from an

 * inlined dir.  It returns the number directory entries loaded

 * into the tree.  If there is an error it is returned in err.

		/*

		 * As inlined dir doesn't store any information about '.' and

		 * only the inode number of '..' is stored, we have to handle

		 * them differently.

/*

 * So this function is called when the volume is mkfsed with

 * dir_index disabled. In order to keep f_pos persistent

 * after we convert from an inlined dir to a blocked based,

 * we just pretend that we are a normal dir and return the

 * offset as if '.' and '..' really take place.

 *

	/*

	 * dotdot_offset and dotdot_size is the real offset and

	 * size for ".." and "." if the dir is block based while

	 * the real size for them are only EXT4_INLINE_DOTDOT_SIZE.

	 * So we will use extra_offset and extra_size to indicate them

	 * during the inline dir iteration.

	/*

	 * If the version has changed since the last call to

	 * readdir(2), then we might be pointing to an invalid

	 * dirent right now.  Scan from the start of the inline

	 * dir to make sure.

			/*

			 * "." is with offset 0 and

			 * ".." is dotdot_offset.

			/* for other entry, the real offset in

			 * the buf has to be tuned accordingly.

			/* It's too expensive to do a full

			 * dirent test each time round this

			 * loop, but we do have to test at

			 * least that it is non-zero.  A

			 * failure will be detected in the

/*

 * Try to create the inline data for the new dir.

 * If it succeeds, return 0, otherwise return the error.

 * In case of ENOSPC, the caller should create the normal disk layout dir.

	/*

	 * For inline dir, we only save the inode information for the ".."

	 * and create a fake dentry to cover the left space.

/*

 * Get the inline dentry at offset.

		/*

		 * if there's inline data to truncate and this file was

		 * converted to extents after that inline data was written,

		 * the extent status cache must be cleared to avoid leaving

		 * behind stale delayed allocated extent entries

 Clear the content in the xattr space. */

 Clear the content within i_blocks. */

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/ext4/xattr_security.c

 * Handler for storing security labels as extended attributes.

 SPDX-License-Identifier: GPL-2.0

/*

 * fs/ext4/verity.c: fs-verity support for ext4

 *

 * Copyright 2019 Google LLC

/*

 * Implementation of fsverity_operations for ext4.

 *

 * ext4 stores the verity metadata (Merkle tree and fsverity_descriptor) past

 * the end of the file, starting at the first 64K boundary beyond i_size.  This

 * approach works because (a) verity files are readonly, and (b) pages fully

 * beyond i_size aren't visible to userspace but can be read/written internally

 * by ext4 with only some relatively small changes to ext4.  This approach

 * avoids having to depend on the EA_INODE feature and on rearchitecturing

 * ext4's xattr support to support paging multi-gigabyte xattrs into memory, and

 * to support encrypting xattrs.  Note that the verity metadata *must* be

 * encrypted when the file is, since it contains hashes of the plaintext data.

 *

 * Using a 64K boundary rather than a 4K one keeps things ready for

 * architectures with 64K pages, and it doesn't necessarily waste space on-disk

 * since there can be a hole between i_size and the start of the Merkle tree.

/*

 * Read some verity metadata from the inode.  __vfs_read() can't be used because

 * we need to read beyond i_size.

/*

 * Write some verity metadata to the inode for FS_IOC_ENABLE_VERITY.

 * kernel_write() can't be used because the file descriptor is readonly.

 superblock and inode for ext4_orphan_add() */

	/*

	 * Since the file was opened readonly, we have to initialize the jbd

	 * inode and quotas here and not rely on ->open() doing it.  This must

	 * be done before evicting the inline data.

	/*

	 * ext4 uses the last allocated block to find the verity descriptor, so

	 * we must remove any other blocks past EOF which might confuse things.

/*

 * ext4 stores the verity descriptor beginning on the next filesystem block

 * boundary after the Merkle tree.  Then, the descriptor size is stored in the

 * last 4 bytes of the last allocated filesystem block --- which is either the

 * block in which the descriptor ends, or the next block after that if there

 * weren't at least 4 bytes remaining.

 *

 * We can't simply store the descriptor in an xattr because it *must* be

 * encrypted when ext4 encryption is used, but ext4 encryption doesn't encrypt

 * xattrs.  Also, if the descriptor includes a large signature blob it may be

 * too large to store in an xattr without the EA_INODE feature.

 superblock and inode for ext4_orphan_del() */

	/*

	 * If an error already occurred (which fs/verity/ signals by passing

	 * desc == NULL), then only clean-up is needed.

 Append the verity descriptor. */

	/*

	 * Write all pages (both data and verity metadata).  Note that this must

	 * happen before clearing EXT4_STATE_VERITY_IN_PROGRESS; otherwise pages

	 * beyond i_size won't be written properly.  For crash consistency, this

	 * also must happen before the verity inode flag gets persisted.

	/*

	 * Finally, set the verity inode flag and remove the inode from the

	 * orphan list (in a single transaction).

	/*

	 * Verity failed to be enabled, so clean up by truncating any verity

	 * metadata that was written beyond i_size (both from cache and from

	 * disk), removing the inode from the orphan list (if it wasn't done

	 * already), and clearing EXT4_STATE_VERITY_IN_PROGRESS.

	/*

	 * Descriptor size is in last 4 bytes of last allocated block.

	 * See ext4_write_verity_descriptor().

	/*

	 * The descriptor is stored just before the desc_size_disk, but starting

	 * on a filesystem block boundary.

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/ext4/hash.c

 *

 * Copyright (C) 2002 by Theodore Ts'o

 F, G and H are basic MD4 functions: selection, majority, parity */

/*

 * The generic round function.  The application is so specific that

 * we don't bother protecting all the arguments with parens, as is generally

 * good macro practice, in favor of extra legibility.

 * Rotation is separate from addition to prevent recomputation

/*

 * Basic cut-down MD4 transform.  Returns only 32 bits of result.

 Round 1 */

 Round 2 */

 Round 3 */

 "most hashed" word */

 The old legacy hash */

/*

 * Returns the hash of a filename.  If len is 0 and name is NULL, then

 * this function can be used to test whether or not a hash version is

 * supported.

 *

 * The seed is an 4 longword (32 bits) "secret" which can be used to

 * uniquify a hash.  If the seed is all zero's, then some default seed

 * may be used.

 *

 * A particular hash version specifies whether or not the seed is

 * represented, and whether or not the returned hash is 32 bits or 64

 * bits.  32 bit hashes will return 0 for the minor hash.

 Initialize the default seed for the hash checksum functions */

 Check to see if the seed is all zero's */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * usnjrnl.h - NTFS kernel transaction log ($UsnJrnl) handling.  Part of the

 *	       Linux-NTFS project.

 *

 * Copyright (c) 2005 Anton Altaparmakov

/**

 * ntfs_stamp_usnjrnl - stamp the transaction log ($UsnJrnl) on an ntfs volume

 * @vol:	ntfs volume on which to stamp the transaction log

 *

 * Stamp the transaction log ($UsnJrnl) on the ntfs volume @vol and return

 * 'true' on success and 'false' on error.

 *

 * This function assumes that the transaction log has already been loaded and

 * consistency checked by a call to fs/ntfs/super.c::load_and_init_usnjrnl().

 Set the flag so we do not have to do it again on remount. */

 NTFS_RW */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * namei.c - NTFS kernel directory inode operations. Part of the Linux-NTFS

 *	     project.

 *

 * Copyright (c) 2001-2006 Anton Altaparmakov

/**

 * ntfs_lookup - find the inode represented by a dentry in a directory inode

 * @dir_ino:	directory inode in which to look for the inode

 * @dent:	dentry representing the inode to look for

 * @flags:	lookup flags

 *

 * In short, ntfs_lookup() looks for the inode represented by the dentry @dent

 * in the directory inode @dir_ino and if found attaches the inode to the

 * dentry @dent.

 *

 * In more detail, the dentry @dent specifies which inode to look for by

 * supplying the name of the inode in @dent->d_name.name. ntfs_lookup()

 * converts the name to Unicode and walks the contents of the directory inode

 * @dir_ino looking for the converted Unicode name. If the name is found in the

 * directory, the corresponding inode is loaded by calling ntfs_iget() on its

 * inode number and the inode is associated with the dentry @dent via a call to

 * d_splice_alias().

 *

 * If the name is not found in the directory, a NULL inode is inserted into the

 * dentry @dent via a call to d_add(). The dentry is then termed a negative

 * dentry.

 *

 * Only if an actual error occurs, do we return an error via ERR_PTR().

 *

 * In order to handle the case insensitivity issues of NTFS with regards to the

 * dcache and the dcache requiring only one dentry per directory, we deal with

 * dentry aliases that only differ in case in ->ntfs_lookup() while maintaining

 * a case sensitive dcache. This means that we get the full benefit of dcache

 * speed when the file/directory is looked up with the same case as returned by

 * ->ntfs_readdir() but that a lookup for any other case (or for the short file

 * name) will not find anything in dcache and will enter ->ntfs_lookup()

 * instead, where we search the directory for a fully matching file name

 * (including case) and if that is not found, we search for a file name that

 * matches with different case and if that has non-POSIX semantics we return

 * that. We actually do only one search (case sensitive) and keep tabs on

 * whether we have found a case insensitive match in the process.

 *

 * To simplify matters for us, we do not treat the short vs long filenames as

 * two hard links but instead if the lookup matches a short filename, we

 * return the dentry for the corresponding long filename instead.

 *

 * There are three cases we need to distinguish here:

 *

 * 1) @dent perfectly matches (i.e. including case) a directory entry with a

 *    file name in the WIN32 or POSIX namespaces. In this case

 *    ntfs_lookup_inode_by_name() will return with name set to NULL and we

 *    just d_splice_alias() @dent.

 * 2) @dent matches (not including case) a directory entry with a file name in

 *    the WIN32 namespace. In this case ntfs_lookup_inode_by_name() will return

 *    with name set to point to a kmalloc()ed ntfs_name structure containing

 *    the properly cased little endian Unicode name. We convert the name to the

 *    current NLS code page, search if a dentry with this name already exists

 *    and if so return that instead of @dent.  At this point things are

 *    complicated by the possibility of 'disconnected' dentries due to NFS

 *    which we deal with appropriately (see the code comments).  The VFS will

 *    then destroy the old @dent and use the one we returned.  If a dentry is

 *    not found, we allocate a new one, d_splice_alias() it, and return it as

 *    above.

 * 3) @dent matches either perfectly or not (i.e. we don't care about case) a

 *    directory entry with a file name in the DOS namespace. In this case

 *    ntfs_lookup_inode_by_name() will return with name set to point to a

 *    kmalloc()ed ntfs_name structure containing the mft reference (cpu endian)

 *    of the inode. We use the mft reference to read the inode and to find the

 *    file name in the WIN32 namespace corresponding to the matched short file

 *    name. We then convert the name to the current NLS code page, and proceed

 *    searching for a dentry with this name, etc, as in case 2), above.

 *

 * Locking: Caller must hold i_mutex on the directory.

 Convert the name of the dentry to Unicode. */

 Consistency check. */

 Perfect WIN32/POSIX match. -- Case 1. */

				/*

				 * We are too indented.  Handle imperfect

				 * matches and short file names further below.

 Return the error code. */

 It is guaranteed that @name is no longer allocated at this point. */

 The dcache will handle negative entries. */

 TODO: Consider moving this lot to a separate function! (AIA)

 Case 2. */

 if (name->type == FILE_NAME_DOS) */ {		
 Find the WIN32 name corresponding to the matched DOS name. */

 Consistency checks. */

 Convert the found WIN32 name to current NLS code page. */

 Check if a conversion error occurred. */

/**

 * Inode operations for directories.

 VFS: Lookup directory. */

/**

 * ntfs_get_parent - find the dentry of the parent of a given directory dentry

 * @child_dent:		dentry of the directory whose parent directory to find

 *

 * Find the dentry for the parent directory of the directory specified by the

 * dentry @child_dent.  This function is called from

 * fs/exportfs/expfs.c::find_exported_dentry() which in turn is called from the

 * default ->decode_fh() which is export_decode_fh() in the same file.

 *

 * The code is based on the ext3 ->get_parent() implementation found in

 * fs/ext3/namei.c::ext3_get_parent().

 *

 * Note: ntfs_get_parent() is called with @d_inode(child_dent)->i_mutex down.

 *

 * Return the dentry of the parent directory on success or the error code on

 * error (IS_ERR() is true).

 Get the mft record of the inode belonging to the child dentry. */

 Find the first file name attribute in the mft record. */

 Get the inode number of the parent directory. */

 Release the search context and the mft record of the child. */

/**

 * Export operations allowing NFS exporting of mounted NTFS partitions.

 *

 * We use the default ->encode_fh() for now.  Note that they

 * use 32 bits to store the inode number which is an unsigned long so on 64-bit

 * architectures is usually 64 bits so it would all fail horribly on huge

 * volumes.  I guess we need to define our own encode and decode fh functions

 * that store 64-bit inode numbers at some point but for now we will ignore the

 * problem...

 *

 * We also use the default ->get_name() helper (used by ->decode_fh() via

 * fs/exportfs/expfs.c::find_exported_dentry()) as that is completely fs

 * independent.

 *

 * The default ->get_parent() just returns -EACCES so we have to provide our

 * own and the default ->get_dentry() is incompatible with NTFS due to not

 * allowing the inode number 0 which is used in NTFS for the system file $MFT

 * and due to using iget() whereas NTFS needs ntfs_iget().

	.get_parent	= ntfs_get_parent,	/* Find the parent of a given

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * index.c - NTFS kernel index handling.  Part of the Linux-NTFS project.

 *

 * Copyright (c) 2004-2005 Anton Altaparmakov

/**

 * ntfs_index_ctx_get - allocate and initialize a new index context

 * @idx_ni:	ntfs index inode with which to initialize the context

 *

 * Allocate a new index context, initialize it with @idx_ni and return it.

 * Return NULL if allocation failed.

 *

 * Locking:  Caller must hold i_mutex on the index inode.

/**

 * ntfs_index_ctx_put - release an index context

 * @ictx:	index context to free

 *

 * Release the index context @ictx, releasing all associated resources.

 *

 * Locking:  Caller must hold i_mutex on the index inode.

/**

 * ntfs_index_lookup - find a key in an index and return its index entry

 * @key:	[IN] key for which to search in the index

 * @key_len:	[IN] length of @key in bytes

 * @ictx:	[IN/OUT] context describing the index and the returned entry

 *

 * Before calling ntfs_index_lookup(), @ictx must have been obtained from a

 * call to ntfs_index_ctx_get().

 *

 * Look for the @key in the index specified by the index lookup context @ictx.

 * ntfs_index_lookup() walks the contents of the index looking for the @key.

 *

 * If the @key is found in the index, 0 is returned and @ictx is setup to

 * describe the index entry containing the matching @key.  @ictx->entry is the

 * index entry and @ictx->data and @ictx->data_len are the index entry data and

 * its length in bytes, respectively.

 *

 * If the @key is not found in the index, -ENOENT is returned and @ictx is

 * setup to describe the index entry whose key collates immediately after the

 * search @key, i.e. this is the position in the index at which an index entry

 * with a key of @key would need to be inserted.

 *

 * If an error occurs return the negative error code and @ictx is left

 * untouched.

 *

 * When finished with the entry and its data, call ntfs_index_ctx_put() to free

 * the context and other associated resources.

 *

 * If the index entry was modified, call flush_dcache_index_entry_page()

 * immediately after the modification and either ntfs_index_entry_mark_dirty()

 * or ntfs_index_entry_write() before the call to ntfs_index_ctx_put() to

 * ensure that the changes are written to disk.

 *

 * Locking:  - Caller must hold i_mutex on the index inode.

 *	     - Each page cache page in the index allocation mapping must be

 *	       locked whilst being accessed otherwise we may find a corrupt

 *	       page due to it being under ->writepage at the moment which

 *	       applies the mst protection fixups before writing out and then

 *	       removes them again after the write is complete after which it 

 *	       unlocks the page.

 Get hold of the mft record for the index inode. */

 Find the index root attribute in the mft record. */

 Get to the index root value (it has been verified in read_inode). */

 The first index entry. */

	/*

	 * Loop until we exceed valid memory (corruption case) or until we

	 * reach the last entry.

 Bounds checks. */

		/*

		 * The last entry cannot contain a key.  It can however contain

		 * a pointer to a child node in the B+tree so we just break out.

 Further bounds checks. */

 If the keys match perfectly, we setup @ictx and return 0. */

		/*

		 * Not a perfect match, need to do full blown collation so we

		 * know which way in the B+tree we have to go.

		/*

		 * If @key collates before the key of the current entry, there

		 * is definitely no such key in this index but we might need to

		 * descend into the B+tree so we just break out of the loop.

		/*

		 * A match should never happen as the memcmp() call should have

		 * cought it, but we still treat it correctly.

 The keys are not equal, continue the search. */

	/*

	 * We have finished with this index without success.  Check for the

	 * presence of a child node and if not present setup @ictx and return

	 * -ENOENT.

 Child node present, descend into it. */

 Consistency check: Verify that an index allocation exists. */

 Get the starting vcn of the index_block holding the child node. */

	/*

	 * We are done with the index root and the mft record.  Release them,

	 * otherwise we deadlock with ntfs_map_page().

	/*

	 * Convert vcn to index into the index allocation attribute in units

	 * of PAGE_SIZE and map the page cache page, reading it from

	 * disk if necessary.

 Get to the index allocation block. */

 Bounds checks. */

 Catch multi sector transfer fixup errors. */

 The first index entry. */

	/*

	 * Iterate similar to above big loop but applied to index buffer, thus

	 * loop until we exceed valid memory (corruption case) or until we

	 * reach the last entry.

 Bounds checks. */

		/*

		 * The last entry cannot contain a key.  It can however contain

		 * a pointer to a child node in the B+tree so we just break out.

 Further bounds checks. */

 If the keys match perfectly, we setup @ictx and return 0. */

		/*

		 * Not a perfect match, need to do full blown collation so we

		 * know which way in the B+tree we have to go.

		/*

		 * If @key collates before the key of the current entry, there

		 * is definitely no such key in this index but we might need to

		 * descend into the B+tree so we just break out of the loop.

		/*

		 * A match should never happen as the memcmp() call should have

		 * cought it, but we still treat it correctly.

 The keys are not equal, continue the search. */

	/*

	 * We have finished with this index buffer without success.  Check for

	 * the presence of a child node and if not present return -ENOENT.

 Child node present, descend into it. */

		/*

		 * If vcn is in the same page cache page as old_vcn we recycle

		 * the mapped page.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * super.c - NTFS kernel super block handling. Part of the Linux-NTFS project.

 *

 * Copyright (c) 2001-2012 Anton Altaparmakov and Tuxera Inc.

 * Copyright (c) 2001,2002 Richard Russon

 For bdev_logical_block_size(). */

 Number of mounted filesystems which have compression enabled. */

 A global default upcase table and a corresponding reference count. */

 Error constants/strings used in inode.c::ntfs_show_options(). */

 One of these must be present, default is ON_ERRORS_CONTINUE. */

 Optional, can be combined with any of the above. */

/**

 * simple_getbool -

 *

 * Copied from old ntfs driver (which copied from vfat driver).

/**

 * parse_options - parse the (re)mount options

 * @vol:	ntfs volume

 * @opt:	string containing the (re)mount options

 *

 * Parse the recognized options in @opt for the ntfs volume described by @vol.

 I am lazy... (-8 */

 nls_map */ {

 Keep this first! */

 else (!vol->nls_map) */

 (!nls_map) */ {

/**

 * ntfs_write_volume_flags - write new flags to the volume information flags

 * @vol:	ntfs volume on which to modify the flags

 * @flags:	new flags value for the volume information flags

 *

 * Internal function.  You probably want to use ntfs_{set,clear}_volume_flags()

 * instead (see below).

 *

 * Replace the volume information flags on the volume @vol with the value

 * supplied in @flags.  Note, this overwrites the volume information flags, so

 * make sure to combine the flags you want to modify with the old flags and use

 * the result when calling ntfs_write_volume_flags().

 *

 * Return 0 on success and -errno on error.

/**

 * ntfs_set_volume_flags - set bits in the volume information flags

 * @vol:	ntfs volume on which to modify the flags

 * @flags:	flags to set on the volume

 *

 * Set the bits in @flags in the volume information flags on the volume @vol.

 *

 * Return 0 on success and -errno on error.

/**

 * ntfs_clear_volume_flags - clear bits in the volume information flags

 * @vol:	ntfs volume on which to modify the flags

 * @flags:	flags to clear on the volume

 *

 * Clear the bits in @flags in the volume information flags on the volume @vol.

 *

 * Return 0 on success and -errno on error.

 NTFS_RW */

/**

 * ntfs_remount - change the mount options of a mounted ntfs filesystem

 * @sb:		superblock of mounted ntfs filesystem

 * @flags:	remount flags

 * @opt:	remount options string

 *

 * Change the mount options of an already mounted ntfs filesystem.

 *

 * NOTE:  The VFS sets the @sb->s_flags remount flags to @flags after

 * ntfs_remount() returns successfully (i.e. returns 0).  Otherwise,

 * @sb->s_flags are not changed.

 For read-only compiled driver, enforce read-only flag. */

 NTFS_RW */

	/*

	 * For the read-write compiled driver, if we are remounting read-write,

	 * make sure there are no volume errors and that no unsupported volume

	 * flags are set.  Also, empty the logfile journal as it would become

	 * stale as soon as something is written to the volume and mark the

	 * volume dirty so that chkdsk is run if the volume is not umounted

	 * cleanly.  Finally, mark the quotas out of date so Windows rescans

	 * the volume on boot and updates them.

	 *

	 * When remounting read-only, mark the volume clean if no volume errors

	 * have occurred.

 Remounting read-write. */

 TODO: Enable this code once we start modifying anything that

	 is different between NTFS 1.2 and 3.x...

 Set NT4 compatibility flag on newer NTFS version volumes. */

 Remounting read-only. */

 NTFS_RW */

 TODO: Deal with *flags.

/**

 * is_boot_sector_ntfs - check whether a boot sector is a valid NTFS boot sector

 * @sb:		Super block of the device to which @b belongs.

 * @b:		Boot sector of device @sb to check.

 * @silent:	If 'true', all output will be silenced.

 *

 * is_boot_sector_ntfs() checks whether the boot sector @b is a valid NTFS boot

 * sector. Returns 'true' if it is valid and 'false' if not.

 *

 * @sb is only needed for warning/error output, i.e. it can be NULL when silent

 * is 'true'.

	/*

	 * Check that checksum == sum of u32 values from b to the checksum

	 * field.  If checksum is zero, no checking is done.  We will work when

	 * the checksum test fails, since some utilities update the boot sector

	 * ignoring the checksum which leaves the checksum out-of-date.  We

	 * report a warning if this is the case.

 Check OEMidentifier is "NTFS    " */

 Check bytes per sector value is between 256 and 4096. */

 Check sectors per cluster value is valid. */

 Check the cluster size is not above the maximum (64kiB). */

 Check reserved/unused fields are really zero. */

 Check clusters per file mft record value is valid. */

 Check clusters per index block value is valid. */

	/*

	 * Check for valid end of sector marker. We will work without it, but

	 * many BIOSes will refuse to boot from a bootsector if the magic is

	 * incorrect, so we emit a warning.

/**

 * read_ntfs_boot_sector - read the NTFS boot sector of a device

 * @sb:		super block of device to read the boot sector from

 * @silent:	if true, suppress all output

 *

 * Reads the boot sector from the device and validates it. If that fails, tries

 * to read the backup boot sector, first from the end of the device a-la NT4 and

 * later and then from the middle of the device a-la NT3.51 and before.

 *

 * If a valid boot sector is found but it is not the primary boot sector, we

 * repair the primary boot sector silently (unless the device is read-only or

 * the primary boot sector is not accessible).

 *

 * NOTE: To call this function, @sb must have the fields s_dev, the ntfs super

 * block (u.ntfs_sb), nr_blocks and the device flags (s_flags) initialized

 * to their respective values.

 *

 * Return the unlocked buffer head containing the boot sector or NULL on error.

 Try to read primary boot sector. */

 Try to read NT4+ backup boot sector. */

 Try to read NT3.51- backup boot sector. */

 We failed. Cleanup and return. */

		/*

		 * If we managed to read sector zero and the volume is not

		 * read-only, copy the found, valid backup boot sector to the

		 * primary boot sector.  Note we only copy the actual boot

		 * sector structure, not the actual whole device sector as that

		 * may be bigger and would potentially damage the $Boot system

		 * file (FIXME: Would be nice to know if the backup boot sector

		 * on a large sector device contains the whole boot loader or

		 * just the first 512 bytes).

/**

 * parse_ntfs_boot_sector - parse the boot sector and store the data in @vol

 * @vol:	volume structure to initialise with data from boot sector

 * @b:		boot sector to parse

 *

 * Parse the ntfs boot sector @b and store all imporant information therein in

 * the ntfs super block @vol.  Return 'true' on success and 'false' on error.

		/*

		 * When mft_record_size < cluster_size, clusters_per_mft_record

		 * = -log2(mft_record_size) bytes. mft_record_size normaly is

		 * 1024 bytes, which is encoded as 0xF6 (-10 in decimal).

	/*

	 * We cannot support mft record sizes above the PAGE_SIZE since

	 * we store $MFT/$DATA, the table of mft records in the page cache.

 We cannot support mft record sizes below the sector size. */

		/*

		 * When index_record_size < cluster_size,

		 * clusters_per_index_record = -log2(index_record_size) bytes.

		 * index_record_size normaly equals 4096 bytes, which is

		 * encoded as 0xF4 (-12 in decimal).

 We cannot support index record sizes below the sector size. */

	/*

	 * Get the size of the volume in clusters and check for 64-bit-ness.

	 * Windows currently only uses 32 bits to save the clusters so we do

	 * the same as it is much faster on 32-bit CPUs.

	/*

	 * On an architecture where unsigned long is 32-bits, we restrict the

	 * volume size to 2TiB (2^41). On a 64-bit architecture, the compiler

	 * will hopefully optimize the whole check away.

	/*

	 * Work out the size of the mft mirror in number of mft records. If the

	 * cluster size is less than or equal to the size taken by four mft

	 * records, the mft mirror stores the first four mft records. If the

	 * cluster size is bigger than the size taken by four mft records, the

	 * mft mirror contains as many mft records as will fit into one

	 * cluster.

 NTFS_RW */

/**

 * ntfs_setup_allocators - initialize the cluster and mft allocators

 * @vol:	volume structure for which to setup the allocators

 *

 * Setup the cluster (lcn) and mft allocators to the starting values.

 NTFS_RW */

 Determine the size of the MFT zone. */

 % of volume size in clusters */

 50%   */

 37.5% */

 25%   */

 case 1: */

 12.5% */

 Setup the mft zone. */

	/*

	 * Calculate the mft_lcn for an unmodified NTFS volume (see mkntfs

	 * source) and if the actual mft_lcn is in the expected place or even

	 * further to the front of the volume, extend the mft_zone to cover the

	 * beginning of the volume as well.  This is in order to protect the

	 * area reserved for the mft bitmap as well within the mft_zone itself.

	 * On non-standard volumes we do not protect it as the overhead would

	 * be higher than the speed increase we would get by doing it.

	/*

	 * Need to cap the mft zone on non-standard volumes so that it does

	 * not point outside the boundaries of the volume.  We do this by

	 * halving the zone size until we are inside the volume.

	/*

	 * Set the current position within each data zone to the start of the

	 * respective zone.

 Set the mft data allocation position to mft record 24. */

 NTFS_RW */

/**

 * load_and_init_mft_mirror - load and setup the mft mirror inode for a volume

 * @vol:	ntfs super block describing device whose mft mirror to load

 *

 * Return 'true' on success or 'false' on error.

 Get mft mirror inode. */

 Caller will display error message. */

	/*

	 * Re-initialize some specifics about $MFTMirr's inode as

	 * ntfs_read_inode() will have set up the default ones.

 Set uid and gid to root. */

 Regular file.  No access for anyone. */

 No VFS initiated operations allowed for $MFTMirr. */

 Put in our special address space operations. */

 The $MFTMirr, like the $MFT is multi sector transfer protected. */

	/*

	 * Set up our little cheat allowing us to reuse the async read io

	 * completion handler for directories.

/**

 * check_mft_mirror - compare contents of the mft mirror with the mft

 * @vol:	ntfs super block describing device whose mft mirror to check

 *

 * Return 'true' on success or 'false' on error.

 *

 * Note, this function also results in the mft mirror runlist being completely

 * mapped into memory.  The mft mirror write code requires this and will BUG()

 * should it find an unmapped runlist element.

 Compare contents of $MFT and $MFTMirr. */

 Switch pages if necessary. */

 Get the $MFT page. */

 Get the $MFTMirr page. */

 Do not check the record if it is not in use. */

 Make sure the record is ok. */

 Do not check the mirror record if it is not in use. */

 Get the amount of data in the current record. */

 Compare the two records. */

 Release the last pages. */

 Construct the mft mirror runlist by hand. */

	/*

	 * Because we have just read all of the mft mirror, we know we have

	 * mapped the full runlist for it.

 Compare the two runlists.  They must be identical. */

/**

 * load_and_check_logfile - load and check the logfile inode for a volume

 * @vol:	ntfs super block describing device whose logfile to load

 *

 * Return 'true' on success or 'false' on error.

 Caller will display error message. */

 ntfs_check_logfile() will have displayed error output. */

/**

 * check_windows_hibernation_status - check if Windows is suspended on a volume

 * @vol:	ntfs super block of device to check

 *

 * Check if Windows is hibernated on the ntfs volume @vol.  This is done by

 * looking for the file hiberfil.sys in the root directory of the volume.  If

 * the file is not present Windows is definitely not suspended.

 *

 * If hiberfil.sys exists and is less than 4kiB in size it means Windows is

 * definitely suspended (this volume is not the system volume).  Caveat:  on a

 * system with many volumes it is possible that the < 4kiB check is bogus but

 * for now this should do fine.

 *

 * If hiberfil.sys exists and is larger than 4kiB in size, we need to read the

 * hiberfil header (which is the first 4kiB).  If this begins with "hibr",

 * Windows is definitely suspended.  If it is completely full of zeroes,

 * Windows is definitely not hibernated.  Any other case is treated as if

 * Windows is suspended.  This caters for the above mentioned caveat of a

 * system with many volumes where no "hibr" magic would be present and there is

 * no zero header.

 *

 * Return 0 if Windows is not hibernated on the volume, >0 if Windows is

 * hibernated on the volume, and -errno on error.

	/*

	 * Find the inode number for the hibernation file by looking up the

	 * filename hiberfil.sys in the root directory.

 If the file does not exist, Windows is not hibernated. */

 A real error occurred. */

 We do not care for the type of match that was found. */

 Get the inode. */

'hibr'*/) {

/**

 * load_and_init_quota - load and setup the quota file for a volume if present

 * @vol:	ntfs super block describing device whose quota file to load

 *

 * Return 'true' on success or 'false' on error.  If $Quota is not present, we

 * leave vol->quota_ino as NULL and return success.

	/*

	 * Find the inode number for the quota file by looking up the filename

	 * $Quota in the extended system files directory $Extend.

		/*

		 * If the file does not exist, quotas are disabled and have

		 * never been enabled on this volume, just return success.

			/*

			 * No need to try to set quotas out of date if they are

			 * not enabled.

 A real error occurred. */

 We do not care for the type of match that was found. */

 Get the inode. */

 Get the $Q index allocation attribute. */

/**

 * load_and_init_usnjrnl - load and setup the transaction log if present

 * @vol:	ntfs super block describing device whose usnjrnl file to load

 *

 * Return 'true' on success or 'false' on error.

 *

 * If $UsnJrnl is not present or in the process of being disabled, we set

 * NVolUsnJrnlStamped() and return success.

 *

 * If the $UsnJrnl $DATA/$J attribute has a size equal to the lowest valid usn,

 * i.e. transaction logging has only just been enabled or the journal has been

 * stamped and nothing has been logged since, we also set NVolUsnJrnlStamped()

 * and return success.

	/*

	 * Find the inode number for the transaction log file by looking up the

	 * filename $UsnJrnl in the extended system files directory $Extend.

		/*

		 * If the file does not exist, transaction logging is disabled,

		 * just return success.

			/*

			 * No need to try to stamp the transaction log if

			 * transaction logging is not enabled.

 A real error occurred. */

 We do not care for the type of match that was found. */

 Get the inode. */

	/*

	 * If the transaction log is in the process of being deleted, we can

	 * ignore it.

 Get the $DATA/$Max attribute. */

 Get the $DATA/$J attribute. */

 Verify $J is non-resident and sparse. */

 Read the USN_HEADER from $DATA/$Max. */

 Sanity check the $Max. */

	/*

	 * If the transaction log has been stamped and nothing has been written

	 * to it since, we do not need to stamp it.

/**

 * load_and_init_attrdef - load the attribute definitions table for a volume

 * @vol:	ntfs super block describing device whose attrdef to load

 *

 * Return 'true' on success or 'false' on error.

 Read attrdef table and setup vol->attrdef and vol->attrdef_size. */

 The size of FILE_AttrDef must be above 0 and fit inside 31 bits. */

 Read the attrdef table and copy it into the linear buffer. */

 NTFS_RW */

/**

 * load_and_init_upcase - load the upcase table for an ntfs volume

 * @vol:	ntfs super block describing device whose upcase to load

 *

 * Return 'true' on success or 'false' on error.

 Read upcase table and setup vol->upcase and vol->upcase_len. */

	/*

	 * The upcase size must not be above 64k Unicode characters, must not

	 * be zero and must be a multiple of sizeof(ntfschar).

 Read the upcase table and copy it into the linear buffer. */

/*

 * The lcn and mft bitmap inodes are NTFS-internal inodes with

 * their own special locking rules:

/**

 * load_system_files - open the system files using normal functions

 * @vol:	ntfs super block describing device whose system files to load

 *

 * Open the system files with normal access functions and complete setting up

 * the ntfs super block @vol.

 *

 * Return 'true' on success or 'false' on error.

 NTFS_RW */

 Get mft mirror inode compare the contents of $MFT and $MFTMirr. */

 If a read-write mount, convert it to a read-only mount. */

 This will prevent a read-write remount. */

 NTFS_RW */

 Get mft bitmap attribute inode. */

 Read upcase table and setup @vol->upcase and @vol->upcase_len. */

	/*

	 * Read attribute definitions table and setup @vol->attrdef and

	 * @vol->attrdef_size.

 NTFS_RW */

	/*

	 * Get the cluster allocation bitmap inode and verify the size, no

	 * need for any locking at this stage as we are already running

	 * exclusively as we are mount in progress task.

	/*

	 * Get the volume inode and setup our cache of the volume flags and

	 * version.

 Some bounds checks. */

 Copy the volume flags and version to the ntfs_volume structure. */

 Make sure that no unsupported volume flags are set. */

 If a read-write mount, convert it to a read-only mount. */

		/*

		 * Do not set NVolErrors() because ntfs_remount() re-checks the

		 * flags which we need to do in case any flags have changed.

	/*

	 * Get the inode for the logfile, check it and determine if the volume

	 * was shutdown cleanly.

 If a read-write mount, convert it to a read-only mount. */

 This will prevent a read-write remount. */

 NTFS_RW */

 Get the root directory inode so we can do path lookups. */

	/*

	 * Check if Windows is suspended to disk on the target volume.  If it

	 * is hibernated, we must not write *anything* to the disk so set

	 * NVolErrors() without setting the dirty volume flag and mount

	 * read-only.  This will prevent read-write remounting and it will also

	 * prevent all writes.

 If a read-write mount, convert it to a read-only mount. */

 This will prevent a read-write remount. */

 If (still) a read-write mount, mark the volume dirty. */

 Convert to a read-only mount. */

		/*

		 * Do not set NVolErrors() because ntfs_remount() might manage

		 * to set the dirty flag in which case all would be well.

 TODO: Enable this code once we start modifying anything that is

	 different between NTFS 1.2 and 3.x...

	/*

	 * If (still) a read-write mount, set the NT4 compatibility flag on

	 * newer NTFS version volumes.

 Convert to a read-only mount. */

 If (still) a read-write mount, empty the logfile. */

 Convert to a read-only mount. */

 NTFS_RW */

 If on NTFS versions before 3.0, we are done. */

 NTFS 3.0+ specific initialization. */

 Get the security descriptors inode. */

 TODO: Initialize security.

 Get the extended system files' directory inode. */

 Find the quota file, load it if present, and set it up. */

 If a read-write mount, convert it to a read-only mount. */

 This will prevent a read-write remount. */

 If (still) a read-write mount, mark the quotas out of date. */

 Convert to a read-only mount. */

	/*

	 * Find the transaction log file ($UsnJrnl), load it if present, check

	 * it, and set it up.

 If a read-write mount, convert it to a read-only mount. */

 This will prevent a read-write remount. */

 If (still) a read-write mount, stamp the transaction log. */

 Convert to a read-only mount. */

 NTFS_RW */

 NTFS_RW */

 NTFS_RW */

 NTFS_RW */

 NTFS_RW */

/**

 * ntfs_put_super - called by the vfs to unmount a volume

 * @sb:		vfs superblock of volume to unmount

 *

 * ntfs_put_super() is called by the VFS (from fs/super.c::do_umount()) when

 * the volume is being unmounted (umount system call has been invoked) and it

 * releases all inodes and memory belonging to the NTFS specific part of the

 * super block.

	/*

	 * Commit all inodes while they are still open in case some of them

	 * cause others to be dirtied.

 NTFS 3.0+ specific. */

	/*

	 * If a read-write mount and no volume errors have occurred, mark the

	 * volume clean.  Also, re-commit all affected inodes.

 NTFS_RW */

 NTFS 3.0+ specific clean up. */

 NTFS_RW */

 Re-commit the mft mirror and mft just in case. */

	/*

	 * We should have no dirty inodes left, due to

	 * mft.c::ntfs_mft_writepage() cleaning all the dirty pages as

	 * the underlying mft records are written out and cleaned.

 NTFS_RW */

 Throw away the table of attribute definitions. */

	/*

	 * Destroy the global default upcase table if necessary.  Also decrease

	 * the number of upcase users if we are a user.

/**

 * get_nr_free_clusters - return the number of free clusters on a volume

 * @vol:	ntfs volume for which to obtain free cluster count

 *

 * Calculate the number of free clusters on the mounted NTFS volume @vol. We

 * actually calculate the number of clusters in use instead because this

 * allows us to not care about partial pages as these will be just zero filled

 * and hence not be counted as allocated clusters.

 *

 * The only particularity is that clusters beyond the end of the logical ntfs

 * volume will be marked as allocated to prevent errors which means we have to

 * discount those at the end. This is important as the cluster bitmap always

 * has a size in multiples of 8 bytes, i.e. up to 63 clusters could be outside

 * the logical volume and marked in use when they are not as they do not exist.

 *

 * If any pages cannot be read we assume all clusters in the erroring pages are

 * in use. This means we return an underestimate on errors which is better than

 * an overestimate.

 Serialize accesses to the cluster bitmap. */

	/*

	 * Convert the number of bits into bytes rounded up, then convert into

	 * multiples of PAGE_SIZE, rounding up so that if we have one

	 * full and one partial page max_index = 2.

 Use multiples of 4 bytes, thus max_size is PAGE_SIZE / 4. */

		/*

		 * Read the page from page cache, getting it from backing store

		 * if necessary, and increment the use count.

 Ignore pages which errored synchronously. */

		/*

		 * Subtract the number of set bits. If this

		 * is the last page and it is partial we don't really care as

		 * it just means we do a little extra work but it won't affect

		 * the result as all out of range bytes are set to zero by

		 * ntfs_readpage().

	/*

	 * Fixup for eventual bits outside logical ntfs volume (see function

	 * description above).

 If errors occurred we may well have gone below zero, fix this. */

/**

 * __get_nr_free_mft_records - return the number of free inodes on a volume

 * @vol:	ntfs volume for which to obtain free inode count

 * @nr_free:	number of mft records in filesystem

 * @max_index:	maximum number of pages containing set bits

 *

 * Calculate the number of free mft records (inodes) on the mounted NTFS

 * volume @vol. We actually calculate the number of mft records in use instead

 * because this allows us to not care about partial pages as these will be just

 * zero filled and hence not be counted as allocated mft record.

 *

 * If any pages cannot be read we assume all mft records in the erroring pages

 * are in use. This means we return an underestimate on errors which is better

 * than an overestimate.

 *

 * NOTE: Caller must hold mftbmp_lock rw_semaphore for reading or writing.

 Use multiples of 4 bytes, thus max_size is PAGE_SIZE / 4. */

		/*

		 * Read the page from page cache, getting it from backing store

		 * if necessary, and increment the use count.

 Ignore pages which errored synchronously. */

		/*

		 * Subtract the number of set bits. If this

		 * is the last page and it is partial we don't really care as

		 * it just means we do a little extra work but it won't affect

		 * the result as all out of range bytes are set to zero by

		 * ntfs_readpage().

 If errors occurred we may well have gone below zero, fix this. */

/**

 * ntfs_statfs - return information about mounted NTFS volume

 * @dentry:	dentry from mounted volume

 * @sfs:	statfs structure in which to return the information

 *

 * Return information about the mounted NTFS volume @dentry in the statfs structure

 * pointed to by @sfs (this is initialized with zeros before ntfs_statfs is

 * called). We interpret the values to be correct of the moment in time at

 * which we are called. Most values are variable otherwise and this isn't just

 * the free values but the totals as well. For example we can increase the

 * total number of file nodes if we run out and we can keep doing this until

 * there is no more space on the volume left at all.

 *

 * Called from vfs_statfs which is used to handle the statfs, fstatfs, and

 * ustat system calls.

 *

 * Return 0 on success or -errno on error.

 Type of filesystem. */

 Optimal transfer block size. */

	/*

	 * Total data blocks in filesystem in units of f_bsize and since

	 * inodes are also stored in data blocs ($MFT is a file) this is just

	 * the total clusters.

 Free data blocks in filesystem in units of f_bsize. */

 Free blocks avail to non-superuser, same as above on NTFS. */

 Serialize accesses to the inode bitmap. */

	/*

	 * Convert the maximum number of set bits into bytes rounded up, then

	 * convert into multiples of PAGE_SIZE, rounding up so that if we

	 * have one full and one partial page max_index = 2.

 Number of inodes in filesystem (at this point in time). */

 Free inodes in fs (based on current total count). */

	/*

	 * File system id. This is extremely *nix flavour dependent and even

	 * within Linux itself all fs do their own thing. I interpret this to

	 * mean a unique id associated with the mounted fs and not the id

	 * associated with the filesystem driver, the latter is already given

	 * by the filesystem type in sfs->f_type. Thus we use the 64-bit

	 * volume serial number splitting it into two 32-bit parts. We enter

	 * the least significant 32-bits in f_fsid[0] and the most significant

	 * 32-bits in f_fsid[1].

 Maximum length of filenames. */

/**

 * The complete super operations.

 VFS: Allocate new inode. */

 VFS: Deallocate inode. */

	.write_inode	= ntfs_write_inode,	/* VFS: Write dirty inode to

 NTFS_RW */

 Syscall: umount. */

 Syscall: statfs */

 Syscall: mount -o remount. */

	.evict_inode	= ntfs_evict_big_inode,	/* VFS: Called when an inode is

	.show_options	= ntfs_show_options,	/* Show mount options in

/**

 * ntfs_fill_super - mount an ntfs filesystem

 * @sb:		super block of ntfs filesystem to mount

 * @opt:	string containing the mount options

 * @silent:	silence error output

 *

 * ntfs_fill_super() is called by the VFS to mount the device described by @sb

 * with the mount otions in @data with the NTFS filesystem.

 *

 * If @silent is true, remain silent even if errors are detected. This is used

 * during bootup, when the kernel tries to mount the root filesystem with all

 * registered filesystems one after the other until one succeeds. This implies

 * that all filesystems except the correct one will quite correctly and

 * expectedly return an error, but nobody wants to see error messages when in

 * fact this is what is supposed to happen.

 *

 * NOTE: @sb->s_flags contains the mount options flags.

	/*

	 * We do a pretty difficult piece of bootstrap by reading the

	 * MFT (and other metadata) from disk into memory. We'll only

	 * release this metadata during umount, so the locking patterns

	 * observed during bootstrap do not count. So turn off the

	 * observation of locking patterns (strictly for this context

	 * only) while mounting NTFS. [The validator is still active

	 * otherwise, even for this context: it will for example record

	 * lock class registrations.]

 ! NTFS_RW */

 Allocate a new ntfs_volume and place it in sb->s_fs_info. */

 Initialize ntfs_volume structure. */

		/*

		 * Default is group and other don't have any access to files or

		 * directories while owner has full access. Further, files by

		 * default are not executable but directories are of course

		 * browseable.

 By default, enable sparse support. */

 Important to get the mount options dealt with now. */

 We support sector sizes up to the PAGE_SIZE. */

	/*

	 * Setup the device access block size to NTFS_BLOCK_SIZE or the hard

	 * sector size, whichever is bigger.

 Determine the size of the device in units of block_size bytes. */

 Read the boot sector and return unlocked buffer head to it. */

	/*

	 * Extract the data from the boot sector and setup the ntfs volume

	 * using it.

	/*

	 * If the boot sector indicates a sector size bigger than the current

	 * device block size, switch the device block size to the sector size.

	 * TODO: It may be possible to support this case even when the set

	 * below fails, we would just be breaking up the i/o for each sector

	 * into multiple blocks for i/o purposes but otherwise it should just

	 * work.  However it is safer to leave disabled until someone hits this

	 * error message and then we can get them to try it without the setting

	 * so we know for sure that it works.

 Initialize the cluster and mft allocators. */

 Setup remaining fields in the super block. */

	/*

	 * Ntfs allows 63 bits for the file size, i.e. correct would be:

	 *	sb->s_maxbytes = ~0ULL >> 1;

	 * But the kernel uses a long as the page cache page index which on

	 * 32-bit architectures is only 32-bits. MAX_LFS_FILESIZE is kernel

	 * defined to the maximum the page cache page index can cope with

	 * without overflowing the index or to 2^63 - 1, whichever is smaller.

 Ntfs measures time in 100ns intervals. */

	/*

	 * Now load the metadata required for the page cache and our address

	 * space operations to function. We do this by setting up a specialised

	 * read_inode method and then just calling the normal iget() to obtain

	 * the inode for $MFT which is sufficient to allow our normal inode

	 * operations and associated address space operations to function.

	/*

	 * The current mount is a compression user if the cluster size is

	 * less than or equal 4kiB.

	/*

	 * Generate the global default upcase table if necessary.  Also

	 * temporarily increment the number of upcase users to avoid race

	 * conditions with concurrent (u)mounts.

	/*

	 * From now on, ignore @silent parameter. If we fail below this line,

	 * it will be due to a corrupt fs or a system error, so we report it.

	/*

	 * Open the system files with normal access functions and complete

	 * setting up the ntfs super block.

 We grab a reference, simulating an ntfs_iget(). */

 Release the default upcase if it has no users. */

 Clean up after the successful load_system_files() call from above. */

 TODO: Use ntfs_put_super() instead of repeating all this code...

 FIXME: Should mark the volume clean as the error is most likely

 	  -ENOMEM.

 NTFS 3.0+ specific clean up. */

 NTFS_RW */

 NTFS_RW */

 Throw away the table of attribute definitions. */

 Error exit code path. */

	/*

	 * Decrease the number of upcase users and destroy the global default

	 * upcase table if necessary.

 Errors at this stage are irrelevant. */

/*

 * This is a slab cache to optimize allocations and deallocations of Unicode

 * strings of the maximum length allowed by NTFS, which is NTFS_MAX_NAME_LEN

 * (255) Unicode characters + a terminating NULL Unicode character.

 Slab caches for efficient allocation/deallocation of inodes. */

 Init once constructor for the inode slab cache. */

/*

 * Slab caches to optimize allocations and deallocations of attribute search

 * contexts and index contexts, respectively.

 Driver wide mutex. */

 Stable names for the slab caches. */

 This may be ugly but it results in pretty output so who cares. (-8 */

 offset */,

 ctor */);

 offset */,

 ctor */);

 Register the ntfs sysctls. */

 Success! */

 Unregister the ntfs sysctls. */

	/*

	 * Make sure all delayed rcu free inodes are flushed before we

	 * destroy cache.

 Unregister the ntfs sysctls. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * upcase.c - Generate the full NTFS Unicode upcase table in little endian.

 *	      Part of the Linux-NTFS project.

 *

 * Copyright (c) 2001 Richard Russon <ntfs@flatcap.org>

 * Copyright (c) 2001-2006 Anton Altaparmakov

 Start, End, Add */

 Start, End */

 Offset, Value */

 Generate the little endian Unicode upcase table used by ntfs. */

 SPDX-License-Identifier: GPL-2.0-or-later

/**

 * attrib.c - NTFS attribute operations.  Part of the Linux-NTFS project.

 *

 * Copyright (c) 2001-2012 Anton Altaparmakov and Tuxera Inc.

 * Copyright (c) 2002 Richard Russon

/**

 * ntfs_map_runlist_nolock - map (a part of) a runlist of an ntfs inode

 * @ni:		ntfs inode for which to map (part of) a runlist

 * @vcn:	map runlist part containing this vcn

 * @ctx:	active attribute search context if present or NULL if not

 *

 * Map the part of a runlist containing the @vcn of the ntfs inode @ni.

 *

 * If @ctx is specified, it is an active search context of @ni and its base mft

 * record.  This is needed when ntfs_map_runlist_nolock() encounters unmapped

 * runlist fragments and allows their mapping.  If you do not have the mft

 * record mapped, you can specify @ctx as NULL and ntfs_map_runlist_nolock()

 * will perform the necessary mapping and unmapping.

 *

 * Note, ntfs_map_runlist_nolock() saves the state of @ctx on entry and

 * restores it before returning.  Thus, @ctx will be left pointing to the same

 * attribute on return as on entry.  However, the actual pointers in @ctx may

 * point to different memory locations on return, so you must remember to reset

 * any cached pointers from the @ctx, i.e. after the call to

 * ntfs_map_runlist_nolock(), you will probably want to do:

 *	m = ctx->mrec;

 *	a = ctx->attr;

 * Assuming you cache ctx->attr in a variable @a of type ATTR_RECORD * and that

 * you cache ctx->mrec in a variable @m of type MFT_RECORD *.

 *

 * Return 0 on success and -errno on error.  There is one special error code

 * which is not an error as such.  This is -ENOENT.  It means that @vcn is out

 * of bounds of the runlist.

 *

 * Note the runlist can be NULL after this function returns if @vcn is zero and

 * the attribute has zero allocated size, i.e. there simply is no runlist.

 *

 * WARNING: If @ctx is supplied, regardless of whether success or failure is

 *	    returned, you need to check IS_ERR(@ctx->mrec) and if 'true' the @ctx

 *	    is no longer valid, i.e. you need to either call

 *	    ntfs_attr_reinit_search_ctx() or ntfs_attr_put_search_ctx() on it.

 *	    In that case PTR_ERR(@ctx->mrec) will give you the error code for

 *	    why the mapping of the old inode failed.

 *

 * Locking: - The runlist described by @ni must be locked for writing on entry

 *	      and is locked on return.  Note the runlist will be modified.

 *	    - If @ctx is NULL, the base mft record of @ni must not be mapped on

 *	      entry and it will be left unmapped on return.

 *	    - If @ctx is not NULL, the base mft record must be mapped on entry

 *	      and it will be left mapped on return.

		/*

		 * If we already have the attribute extent containing @vcn in

		 * @ctx, no need to look it up again.  We slightly cheat in

		 * that if vcn exceeds the allocated size, we will refuse to

		 * map the runlist below, so there is definitely no need to get

		 * the right attribute extent.

 Save the old search context. */

			/*

			 * If the currently mapped (extent) inode is not the

			 * base inode we will unmap it when we reinitialize the

			 * search context which means we need to get a

			 * reference to the page containing the mapped mft

			 * record so we do not accidentally drop changes to the

			 * mft record when it has not been marked dirty yet.

			/*

			 * Reinitialize the search context so we can lookup the

			 * needed attribute extent.

	/*

	 * Only decompress the mapping pairs if @vcn is inside it.  Otherwise

	 * we get into problems when we try to map an out of bounds vcn because

	 * we then try to map the already mapped runlist fragment and

	 * ntfs_mapping_pairs_decompress() fails.

		/*

		 * If there is no attribute list, restoring the search context

		 * is accomplished simply by copying the saved context back over

		 * the caller supplied context.  If there is an attribute list,

		 * things are more complicated as we need to deal with mapping

		 * of mft records and resulting potential changes in pointers.

			/*

			 * If the currently mapped (extent) inode is not the

			 * one we had before, we need to unmap it and map the

			 * old one.

				/*

				 * If the currently mapped inode is not the

				 * base inode, unmap it.

				/*

				 * If the old mapped inode is not the base

				 * inode, map it.

					/*

					 * Something bad has happened.  If out

					 * of memory retry till it succeeds.

					 * Any other errors are fatal and we

					 * return the error code in ctx->mrec.

					 * Let the caller deal with it...  We

					 * just need to fudge things so the

					 * caller can reinit and/or put the

					 * search context safely.

 Update the changed pointers in the saved context. */

 Restore the search context to the saved one. */

		/*

		 * We drop the reference on the page we took earlier.  In the

		 * case that IS_ERR(ctx->mrec) is true this means we might lose

		 * some changes to the mft record that had been made between

		 * the last time it was marked dirty/written out and now.  This

		 * at this stage is not a problem as the mapping error is fatal

		 * enough that the mft record cannot be written out anyway and

		 * the caller is very likely to shutdown the whole inode

		 * immediately and mark the volume dirty for chkdsk to pick up

		 * the pieces anyway.

/**

 * ntfs_map_runlist - map (a part of) a runlist of an ntfs inode

 * @ni:		ntfs inode for which to map (part of) a runlist

 * @vcn:	map runlist part containing this vcn

 *

 * Map the part of a runlist containing the @vcn of the ntfs inode @ni.

 *

 * Return 0 on success and -errno on error.  There is one special error code

 * which is not an error as such.  This is -ENOENT.  It means that @vcn is out

 * of bounds of the runlist.

 *

 * Locking: - The runlist must be unlocked on entry and is unlocked on return.

 *	    - This function takes the runlist lock for writing and may modify

 *	      the runlist.

 Make sure someone else didn't do the work while we were sleeping. */

/**

 * ntfs_attr_vcn_to_lcn_nolock - convert a vcn into a lcn given an ntfs inode

 * @ni:			ntfs inode of the attribute whose runlist to search

 * @vcn:		vcn to convert

 * @write_locked:	true if the runlist is locked for writing

 *

 * Find the virtual cluster number @vcn in the runlist of the ntfs attribute

 * described by the ntfs inode @ni and return the corresponding logical cluster

 * number (lcn).

 *

 * If the @vcn is not mapped yet, the attempt is made to map the attribute

 * extent containing the @vcn and the vcn to lcn conversion is retried.

 *

 * If @write_locked is true the caller has locked the runlist for writing and

 * if false for reading.

 *

 * Since lcns must be >= 0, we use negative return codes with special meaning:

 *

 * Return code	Meaning / Description

 * ==========================================

 *  LCN_HOLE	Hole / not allocated on disk.

 *  LCN_ENOENT	There is no such vcn in the runlist, i.e. @vcn is out of bounds.

 *  LCN_ENOMEM	Not enough memory to map runlist.

 *  LCN_EIO	Critical error (runlist/file is corrupt, i/o error, etc).

 *

 * Locking: - The runlist must be locked on entry and is left locked on return.

 *	    - If @write_locked is 'false', i.e. the runlist is locked for reading,

 *	      the lock may be dropped inside the function so you cannot rely on

 *	      the runlist still being the same when this function returns.

 Convert vcn to lcn.  If that fails map the runlist and retry once. */

/**

 * ntfs_attr_find_vcn_nolock - find a vcn in the runlist of an ntfs inode

 * @ni:		ntfs inode describing the runlist to search

 * @vcn:	vcn to find

 * @ctx:	active attribute search context if present or NULL if not

 *

 * Find the virtual cluster number @vcn in the runlist described by the ntfs

 * inode @ni and return the address of the runlist element containing the @vcn.

 *

 * If the @vcn is not mapped yet, the attempt is made to map the attribute

 * extent containing the @vcn and the vcn to lcn conversion is retried.

 *

 * If @ctx is specified, it is an active search context of @ni and its base mft

 * record.  This is needed when ntfs_attr_find_vcn_nolock() encounters unmapped

 * runlist fragments and allows their mapping.  If you do not have the mft

 * record mapped, you can specify @ctx as NULL and ntfs_attr_find_vcn_nolock()

 * will perform the necessary mapping and unmapping.

 *

 * Note, ntfs_attr_find_vcn_nolock() saves the state of @ctx on entry and

 * restores it before returning.  Thus, @ctx will be left pointing to the same

 * attribute on return as on entry.  However, the actual pointers in @ctx may

 * point to different memory locations on return, so you must remember to reset

 * any cached pointers from the @ctx, i.e. after the call to

 * ntfs_attr_find_vcn_nolock(), you will probably want to do:

 *	m = ctx->mrec;

 *	a = ctx->attr;

 * Assuming you cache ctx->attr in a variable @a of type ATTR_RECORD * and that

 * you cache ctx->mrec in a variable @m of type MFT_RECORD *.

 * Note you need to distinguish between the lcn of the returned runlist element

 * being >= 0 and LCN_HOLE.  In the later case you have to return zeroes on

 * read and allocate clusters on write.

 *

 * Return the runlist element containing the @vcn on success and

 * ERR_PTR(-errno) on error.  You need to test the return value with IS_ERR()

 * to decide if the return is success or failure and PTR_ERR() to get to the

 * error code if IS_ERR() is true.

 *

 * The possible error return codes are:

 *	-ENOENT - No such vcn in the runlist, i.e. @vcn is out of bounds.

 *	-ENOMEM - Not enough memory to map runlist.

 *	-EIO	- Critical error (runlist/file is corrupt, i/o error, etc).

 *

 * WARNING: If @ctx is supplied, regardless of whether success or failure is

 *	    returned, you need to check IS_ERR(@ctx->mrec) and if 'true' the @ctx

 *	    is no longer valid, i.e. you need to either call

 *	    ntfs_attr_reinit_search_ctx() or ntfs_attr_put_search_ctx() on it.

 *	    In that case PTR_ERR(@ctx->mrec) will give you the error code for

 *	    why the mapping of the old inode failed.

 *

 * Locking: - The runlist described by @ni must be locked for writing on entry

 *	      and is locked on return.  Note the runlist may be modified when

 *	      needed runlist fragments need to be mapped.

 *	    - If @ctx is NULL, the base mft record of @ni must not be mapped on

 *	      entry and it will be left unmapped on return.

 *	    - If @ctx is not NULL, the base mft record must be mapped on entry

 *	      and it will be left mapped on return.

		/*

		 * If the search context is invalid we cannot map the unmapped

		 * region.

			/*

			 * The @vcn is in an unmapped region, map the runlist

			 * and retry.

/**

 * ntfs_attr_find - find (next) attribute in mft record

 * @type:	attribute type to find

 * @name:	attribute name to find (optional, i.e. NULL means don't care)

 * @name_len:	attribute name length (only needed if @name present)

 * @ic:		IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)

 * @val:	attribute value to find (optional, resident attributes only)

 * @val_len:	attribute value length

 * @ctx:	search context with mft record and attribute to search from

 *

 * You should not need to call this function directly.  Use ntfs_attr_lookup()

 * instead.

 *

 * ntfs_attr_find() takes a search context @ctx as parameter and searches the

 * mft record specified by @ctx->mrec, beginning at @ctx->attr, for an

 * attribute of @type, optionally @name and @val.

 *

 * If the attribute is found, ntfs_attr_find() returns 0 and @ctx->attr will

 * point to the found attribute.

 *

 * If the attribute is not found, ntfs_attr_find() returns -ENOENT and

 * @ctx->attr will point to the attribute before which the attribute being

 * searched for would need to be inserted if such an action were to be desired.

 *

 * On actual error, ntfs_attr_find() returns -EIO.  In this case @ctx->attr is

 * undefined and in particular do not rely on it not changing.

 *

 * If @ctx->is_first is 'true', the search begins with @ctx->attr itself.  If it

 * is 'false', the search begins after @ctx->attr.

 *

 * If @ic is IGNORE_CASE, the @name comparisson is not case sensitive and

 * @ctx->ntfs_ino must be set to the ntfs inode to which the mft record

 * @ctx->mrec belongs.  This is so we can get at the ntfs volume and hence at

 * the upcase table.  If @ic is CASE_SENSITIVE, the comparison is case

 * sensitive.  When @name is present, @name_len is the @name length in Unicode

 * characters.

 *

 * If @name is not present (NULL), we assume that the unnamed attribute is

 * being searched for.

 *

 * Finally, the resident attribute value @val is looked for, if present.  If

 * @val is not present (NULL), @val_len is ignored.

 *

 * ntfs_attr_find() only searches the specified mft record and it ignores the

 * presence of an attribute list attribute (unless it is the one being searched

 * for, obviously).  If you need to take attribute lists into consideration,

 * use ntfs_attr_lookup() instead (see below).  This also means that you cannot

 * use ntfs_attr_find() to search for extent records of non-resident

 * attributes, as extents with lowest_vcn != 0 are usually described by the

 * attribute list attribute only. - Note that it is possible that the first

 * extent is only in the attribute list while the last extent is in the base

 * mft record, so do not rely on being able to find the first extent in the

 * base mft record.

 *

 * Warning: Never use @val when looking for attribute types which can be

 *	    non-resident as this most likely will result in a crash!

	/*

	 * Iterate over attributes in mft record starting at @ctx->attr, or the

	 * attribute following that, if @ctx->is_first is 'true'.

		/*

		 * If @name is present, compare the two names.  If @name is

		 * missing, assume we want an unnamed attribute.

 The search failed if the found attribute is named. */

			/*

			 * If @name collates before a->name, there is no

			 * matching attribute.

 If the strings are not equal, continue search. */

		/*

		 * The names match or @name not present and attribute is

		 * unnamed.  If no @val specified, we have found the attribute

		 * and are done.

 @val is present; compare values. */

			/*

			 * If @val collates before the current attribute's

			 * value, there is no matching attribute.

/**

 * load_attribute_list - load an attribute list into memory

 * @vol:		ntfs volume from which to read

 * @runlist:		runlist of the attribute list

 * @al_start:		destination buffer

 * @size:		size of the destination buffer in bytes

 * @initialized_size:	initialized size of the attribute list

 *

 * Walk the runlist @runlist and load all clusters from it copying them into

 * the linear buffer @al. The maximum number of bytes copied to @al is @size

 * bytes. Note, @size does not need to be a multiple of the cluster size. If

 * @initialized_size is less than @size, the region in @al between

 * @initialized_size and @size will be zeroed and not read from disk.

 *

 * Return 0 on success or -errno on error.

 Read all clusters specified by the runlist one run at a time. */

 The attribute list cannot be sparse. */

 Read the run from device in chunks of block_size bytes. */

		/*

		 * Partial block.

		 *

		 * Note: The attribute list can be smaller than its allocation

		 * by multiple clusters.  This has been encountered by at least

		 * two people running Windows XP, thus we cannot do any

		 * truncation sanity checking here. (AIA)

 Real overflow! */

/**

 * ntfs_external_attr_find - find an attribute in the attribute list of an inode

 * @type:	attribute type to find

 * @name:	attribute name to find (optional, i.e. NULL means don't care)

 * @name_len:	attribute name length (only needed if @name present)

 * @ic:		IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)

 * @lowest_vcn:	lowest vcn to find (optional, non-resident attributes only)

 * @val:	attribute value to find (optional, resident attributes only)

 * @val_len:	attribute value length

 * @ctx:	search context with mft record and attribute to search from

 *

 * You should not need to call this function directly.  Use ntfs_attr_lookup()

 * instead.

 *

 * Find an attribute by searching the attribute list for the corresponding

 * attribute list entry.  Having found the entry, map the mft record if the

 * attribute is in a different mft record/inode, ntfs_attr_find() the attribute

 * in there and return it.

 *

 * On first search @ctx->ntfs_ino must be the base mft record and @ctx must

 * have been obtained from a call to ntfs_attr_get_search_ctx().  On subsequent

 * calls @ctx->ntfs_ino can be any extent inode, too (@ctx->base_ntfs_ino is

 * then the base inode).

 *

 * After finishing with the attribute/mft record you need to call

 * ntfs_attr_put_search_ctx() to cleanup the search context (unmapping any

 * mapped inodes, etc).

 *

 * If the attribute is found, ntfs_external_attr_find() returns 0 and

 * @ctx->attr will point to the found attribute.  @ctx->mrec will point to the

 * mft record in which @ctx->attr is located and @ctx->al_entry will point to

 * the attribute list entry for the attribute.

 *

 * If the attribute is not found, ntfs_external_attr_find() returns -ENOENT and

 * @ctx->attr will point to the attribute in the base mft record before which

 * the attribute being searched for would need to be inserted if such an action

 * were to be desired.  @ctx->mrec will point to the mft record in which

 * @ctx->attr is located and @ctx->al_entry will point to the attribute list

 * entry of the attribute before which the attribute being searched for would

 * need to be inserted if such an action were to be desired.

 *

 * Thus to insert the not found attribute, one wants to add the attribute to

 * @ctx->mrec (the base mft record) and if there is not enough space, the

 * attribute should be placed in a newly allocated extent mft record.  The

 * attribute list entry for the inserted attribute should be inserted in the

 * attribute list attribute at @ctx->al_entry.

 *

 * On actual error, ntfs_external_attr_find() returns -EIO.  In this case

 * @ctx->attr is undefined and in particular do not rely on it not changing.

 First call happens with the base mft record. */

	/*

	 * Iterate over entries in attribute list starting at @ctx->al_entry,

	 * or the entry following that, if @ctx->is_first is 'true'.

 Out of bounds check. */

 Inode is corrupt. */

 Catch the end of the attribute list. */

		/*

		 * If @name is present, compare the two names.  If @name is

		 * missing, assume we want an unnamed attribute.

			/*

			 * If @name collates before al_name, there is no

			 * matching attribute.

 If the strings are not equal, continue search. */

			/*

			 * FIXME: Reverse engineering showed 0, IGNORE_CASE but

			 * that is inconsistent with ntfs_attr_find().  The

			 * subsequent rc checks were also different.  Perhaps I

			 * made a mistake in one of the two.  Need to recheck

			 * which is correct or at least see what is going on...

			 * (AIA)

		/*

		 * The names match or @name not present and attribute is

		 * unnamed.  Now check @lowest_vcn.  Continue search if the

		 * next attribute list entry still fits @lowest_vcn.  Otherwise

		 * we have reached the right one or the search has failed.

 Mft references do not match. */

 If there is a mapped record unmap it first. */

 Do we want the base record back? */

 We want an extent record. */

 Cause @ctx to be sanitized below. */

		/*

		 * ctx->vfs_ino, ctx->mrec, and ctx->attr now point to the

		 * mft record containing the attribute represented by the

		 * current al_entry.

		/*

		 * We could call into ntfs_attr_find() to find the right

		 * attribute in this mft record but this would be less

		 * efficient and not quite accurate as ntfs_attr_find() ignores

		 * the attribute instance numbers for example which become

		 * important when one plays with attribute lists.  Also,

		 * because a proper match has been found in the attribute list

		 * entry above, the comparison can now be optimized.  So it is

		 * worth re-implementing a simplified ntfs_attr_find() here.

		/*

		 * Use a manual loop so we can still use break and continue

		 * with the same meanings as above.

		/*

		 * If the type and/or the name are mismatched between the

		 * attribute list entry and the attribute record, there is

		 * corruption so we break and return error EIO.

		/*

		 * If no @val specified or @val specified and it matches, we

		 * have found it!

 Proceed to the next attribute in the current mft record. */

	/*

	 * If we were looking for AT_END, we reset the search context @ctx and

	 * use ntfs_attr_find() to seek to the end of the base mft record.

	/*

	 * The attribute was not found.  Before we return, we want to ensure

	 * @ctx->mrec and @ctx->attr indicate the position at which the

	 * attribute should be inserted in the base mft record.  Since we also

	 * want to preserve @ctx->al_entry we cannot reinitialize the search

	 * context using ntfs_attr_reinit_search_ctx() as this would set

	 * @ctx->al_entry to NULL.  Thus we do the necessary bits manually (see

	 * ntfs_attr_init_search_ctx() below).  Note, we _only_ preserve

	 * @ctx->al_entry as the remaining fields (base_*) are identical to

	 * their non base_ counterparts and we cannot set @ctx->base_attr

	 * correctly yet as we do not know what @ctx->attr will be set to by

	 * the call to ntfs_attr_find() below.

	/*

	 * In case there are multiple matches in the base mft record, need to

	 * keep enumerating until we get an attribute not found response (or

	 * another error), otherwise we would keep returning the same attribute

	 * over and over again and all programs using us for enumeration would

	 * lock up in a tight loop.

/**

 * ntfs_attr_lookup - find an attribute in an ntfs inode

 * @type:	attribute type to find

 * @name:	attribute name to find (optional, i.e. NULL means don't care)

 * @name_len:	attribute name length (only needed if @name present)

 * @ic:		IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)

 * @lowest_vcn:	lowest vcn to find (optional, non-resident attributes only)

 * @val:	attribute value to find (optional, resident attributes only)

 * @val_len:	attribute value length

 * @ctx:	search context with mft record and attribute to search from

 *

 * Find an attribute in an ntfs inode.  On first search @ctx->ntfs_ino must

 * be the base mft record and @ctx must have been obtained from a call to

 * ntfs_attr_get_search_ctx().

 *

 * This function transparently handles attribute lists and @ctx is used to

 * continue searches where they were left off at.

 *

 * After finishing with the attribute/mft record you need to call

 * ntfs_attr_put_search_ctx() to cleanup the search context (unmapping any

 * mapped inodes, etc).

 *

 * Return 0 if the search was successful and -errno if not.

 *

 * When 0, @ctx->attr is the found attribute and it is in mft record

 * @ctx->mrec.  If an attribute list attribute is present, @ctx->al_entry is

 * the attribute list entry of the found attribute.

 *

 * When -ENOENT, @ctx->attr is the attribute which collates just after the

 * attribute being searched for, i.e. if one wants to add the attribute to the

 * mft record this is the correct place to insert it into.  If an attribute

 * list attribute is present, @ctx->al_entry is the attribute list entry which

 * collates just after the attribute list entry of the attribute being searched

 * for, i.e. if one wants to add the attribute to the mft record this is the

 * correct place to insert its attribute list entry into.

 *

 * When -errno != -ENOENT, an error occurred during the lookup.  @ctx->attr is

 * then undefined and in particular you should not rely on it not changing.

 Sanity check, just for debugging really. */

/**

 * ntfs_attr_init_search_ctx - initialize an attribute search context

 * @ctx:	attribute search context to initialize

 * @ni:		ntfs inode with which to initialize the search context

 * @mrec:	mft record with which to initialize the search context

 *

 * Initialize the attribute search context @ctx with @ni and @mrec.

 Sanity checks are performed elsewhere. */

/**

 * ntfs_attr_reinit_search_ctx - reinitialize an attribute search context

 * @ctx:	attribute search context to reinitialize

 *

 * Reinitialize the attribute search context @ctx, unmapping an associated

 * extent mft record if present, and initialize the search context again.

 *

 * This is used when a search for a new attribute is being started to reset

 * the search context to the beginning.

 No attribute list. */

 Sanity checks are performed elsewhere. */

		/*

		 * This needs resetting due to ntfs_external_attr_find() which

		 * can leave it set despite having zeroed ctx->base_ntfs_ino.

 Attribute list. */

/**

 * ntfs_attr_get_search_ctx - allocate/initialize a new attribute search context

 * @ni:		ntfs inode with which to initialize the search context

 * @mrec:	mft record with which to initialize the search context

 *

 * Allocate a new attribute search context, initialize it with @ni and @mrec,

 * and return it. Return NULL if allocation failed.

/**

 * ntfs_attr_put_search_ctx - release an attribute search context

 * @ctx:	attribute search context to free

 *

 * Release the attribute search context @ctx, unmapping an associated extent

 * mft record if present.

/**

 * ntfs_attr_find_in_attrdef - find an attribute in the $AttrDef system file

 * @vol:	ntfs volume to which the attribute belongs

 * @type:	attribute type which to find

 *

 * Search for the attribute definition record corresponding to the attribute

 * @type in the $AttrDef system file.

 *

 * Return the attribute type definition record if found and NULL if not found.

 We have not found it yet, carry on searching. */

 We found the attribute; return it. */

 We have gone too far already.  No point in continuing. */

 Attribute not found. */

/**

 * ntfs_attr_size_bounds_check - check a size of an attribute type for validity

 * @vol:	ntfs volume to which the attribute belongs

 * @type:	attribute type which to check

 * @size:	size which to check

 *

 * Check whether the @size in bytes is valid for an attribute of @type on the

 * ntfs volume @vol.  This information is obtained from $AttrDef system file.

 *

 * Return 0 if valid, -ERANGE if not valid, or -ENOENT if the attribute is not

 * listed in $AttrDef.

	/*

	 * $ATTRIBUTE_LIST has a maximum size of 256kiB, but this is not

	 * listed in $AttrDef.

 Get the $AttrDef entry for the attribute @type. */

 Do the bounds check. */

/**

 * ntfs_attr_can_be_non_resident - check if an attribute can be non-resident

 * @vol:	ntfs volume to which the attribute belongs

 * @type:	attribute type which to check

 *

 * Check whether the attribute of @type on the ntfs volume @vol is allowed to

 * be non-resident.  This information is obtained from $AttrDef system file.

 *

 * Return 0 if the attribute is allowed to be non-resident, -EPERM if not, and

 * -ENOENT if the attribute is not listed in $AttrDef.

 Find the attribute definition record in $AttrDef. */

 Check the flags and return the result. */

/**

 * ntfs_attr_can_be_resident - check if an attribute can be resident

 * @vol:	ntfs volume to which the attribute belongs

 * @type:	attribute type which to check

 *

 * Check whether the attribute of @type on the ntfs volume @vol is allowed to

 * be resident.  This information is derived from our ntfs knowledge and may

 * not be completely accurate, especially when user defined attributes are

 * present.  Basically we allow everything to be resident except for index

 * allocation and $EA attributes.

 *

 * Return 0 if the attribute is allowed to be non-resident and -EPERM if not.

 *

 * Warning: In the system file $MFT the attribute $Bitmap must be non-resident

 *	    otherwise windows will not boot (blue screen of death)!  We cannot

 *	    check for this here as we do not know which inode's $Bitmap is

 *	    being asked about so the caller needs to special case this.

/**

 * ntfs_attr_record_resize - resize an attribute record

 * @m:		mft record containing attribute record

 * @a:		attribute record to resize

 * @new_size:	new size in bytes to which to resize the attribute record @a

 *

 * Resize the attribute record @a, i.e. the resident part of the attribute, in

 * the mft record @m to @new_size bytes.

 *

 * Return 0 on success and -errno on error.  The following error codes are

 * defined:

 *	-ENOSPC	- Not enough space in the mft record @m to perform the resize.

 *

 * Note: On error, no modifications have been performed whatsoever.

 *

 * Warning: If you make a record smaller without having copied all the data you

 *	    are interested in the data may be overwritten.

 Align to 8 bytes if it is not already done. */

 If the actual attribute length has changed, move things around. */

 Not enough space in this mft record. */

 Move attributes following @a to their new location. */

 Adjust @m to reflect the change in used space. */

 Adjust @a to reflect the new size. */

/**

 * ntfs_resident_attr_value_resize - resize the value of a resident attribute

 * @m:		mft record containing attribute record

 * @a:		attribute record whose value to resize

 * @new_size:	new size in bytes to which to resize the attribute value of @a

 *

 * Resize the value of the attribute @a in the mft record @m to @new_size bytes.

 * If the value is made bigger, the newly allocated space is cleared.

 *

 * Return 0 on success and -errno on error.  The following error codes are

 * defined:

 *	-ENOSPC	- Not enough space in the mft record @m to perform the resize.

 *

 * Note: On error, no modifications have been performed whatsoever.

 *

 * Warning: If you make a record smaller without having copied all the data you

 *	    are interested in the data may be overwritten.

 Resize the resident part of the attribute record. */

	/*

	 * The resize succeeded!  If we made the attribute value bigger, clear

	 * the area between the old size and @new_size.

 Finally update the length of the attribute value. */

/**

 * ntfs_attr_make_non_resident - convert a resident to a non-resident attribute

 * @ni:		ntfs inode describing the attribute to convert

 * @data_size:	size of the resident data to copy to the non-resident attribute

 *

 * Convert the resident ntfs attribute described by the ntfs inode @ni to a

 * non-resident one.

 *

 * @data_size must be equal to the attribute value size.  This is needed since

 * we need to know the size before we can map the mft record and our callers

 * always know it.  The reason we cannot simply read the size from the vfs

 * inode i_size is that this is not necessarily uptodate.  This happens when

 * ntfs_attr_make_non_resident() is called in the ->truncate call path(s).

 *

 * Return 0 on success and -errno on error.  The following error return codes

 * are defined:

 *	-EPERM	- The attribute is not allowed to be non-resident.

 *	-ENOMEM	- Not enough memory.

 *	-ENOSPC	- Not enough disk space.

 *	-EINVAL	- Attribute not defined on the volume.

 *	-EIO	- I/o error or other error.

 * Note that -ENOSPC is also returned in the case that there is not enough

 * space in the mft record to do the conversion.  This can happen when the mft

 * record is already very full.  The caller is responsible for trying to make

 * space in the mft record and trying again.  FIXME: Do we need a separate

 * error return code for this kind of -ENOSPC or is it always worth trying

 * again in case the attribute may then fit in a resident state so no need to

 * make it non-resident at all?  Ho-hum...  (AIA)

 *

 * NOTE to self: No changes in the attribute list are required to move from

 *		 a resident to a non-resident attribute.

 *

 * Locking: - The caller must hold i_mutex on the inode.

 Check that the attribute is allowed to be non-resident. */

	/*

	 * FIXME: Compressed and encrypted attributes are not supported when

	 * writing and we should never have gotten here for them.

	/*

	 * The size needs to be aligned to a cluster boundary for allocation

	 * purposes.

		/*

		 * Will need the page later and since the page lock nests

		 * outside all ntfs locks, we need to get the page now.

 Start by allocating clusters to hold the attribute value. */

 Determine the size of the mapping pairs array. */

	/*

	 * Calculate new offsets for the name and the mapping pairs array.

	/*

	 * Determine the size of the resident part of the now non-resident

	 * attribute record.

	/*

	 * If the page is not uptodate bring it uptodate by copying from the

	 * attribute value.

 Backup the attribute flag. */

 Resize the resident part of the attribute record. */

	/*

	 * Convert the resident part of the attribute record to describe a

	 * non-resident attribute.

 Move the attribute name if it exists and update the offset. */

 Setup the fields specific to non-resident attributes. */

 Generate the mapping pairs array into the attribute record. */

 Setup the in-memory attribute structure to be non-resident. */

	/*

	 * This needs to be last since the address space operations ->readpage

	 * and ->writepage can run concurrently with us as they are not

	 * serialized on i_mutex.  Note, we are not allowed to fail once we flip

	 * this switch, which is another reason to do this last.

 Mark the mft record dirty, so it gets written back. */

 Convert the attribute back into a resident attribute. */

 Move the attribute name if it exists and update the offset. */

 Resize the resident part of the attribute record. */

		/*

		 * This cannot happen (well if memory corruption is at work it

		 * could happen in theory), but deal with it as well as we can.

		 * If the old size is too small, truncate the attribute,

		 * otherwise simply give it a larger allocated size.

		 * FIXME: Should check whether chkdsk complains when the

		 * allocated size is much bigger than the resident value size.

 Setup the fields specific to resident attributes. */

 Copy the data from the page back to the attribute value. */

 Setup the allocated size in the ntfs inode in case it changed. */

 Mark the mft record dirty, so it gets written back. */

/**

 * ntfs_attr_extend_allocation - extend the allocated space of an attribute

 * @ni:			ntfs inode of the attribute whose allocation to extend

 * @new_alloc_size:	new size in bytes to which to extend the allocation to

 * @new_data_size:	new size in bytes to which to extend the data to

 * @data_start:		beginning of region which is required to be non-sparse

 *

 * Extend the allocated space of an attribute described by the ntfs inode @ni

 * to @new_alloc_size bytes.  If @data_start is -1, the whole extension may be

 * implemented as a hole in the file (as long as both the volume and the ntfs

 * inode @ni have sparse support enabled).  If @data_start is >= 0, then the

 * region between the old allocated size and @data_start - 1 may be made sparse

 * but the regions between @data_start and @new_alloc_size must be backed by

 * actual clusters.

 *

 * If @new_data_size is -1, it is ignored.  If it is >= 0, then the data size

 * of the attribute is extended to @new_data_size.  Note that the i_size of the

 * vfs inode is not updated.  Only the data size in the base attribute record

 * is updated.  The caller has to update i_size separately if this is required.

 * WARNING: It is a BUG() for @new_data_size to be smaller than the old data

 * size as well as for @new_data_size to be greater than @new_alloc_size.

 *

 * For resident attributes this involves resizing the attribute record and if

 * necessary moving it and/or other attributes into extent mft records and/or

 * converting the attribute to a non-resident attribute which in turn involves

 * extending the allocation of a non-resident attribute as described below.

 *

 * For non-resident attributes this involves allocating clusters in the data

 * zone on the volume (except for regions that are being made sparse) and

 * extending the run list to describe the allocated clusters as well as

 * updating the mapping pairs array of the attribute.  This in turn involves

 * resizing the attribute record and if necessary moving it and/or other

 * attributes into extent mft records and/or splitting the attribute record

 * into multiple extent attribute records.

 *

 * Also, the attribute list attribute is updated if present and in some of the

 * above cases (the ones where extent mft records/attributes come into play),

 * an attribute list attribute is created if not already present.

 *

 * Return the new allocated size on success and -errno on error.  In the case

 * that an error is encountered but a partial extension at least up to

 * @data_start (if present) is possible, the allocation is partially extended

 * and this is returned.  This means the caller must check the returned size to

 * determine if the extension was partial.  If @data_start is -1 then partial

 * allocations are not performed.

 *

 * WARNING: Do not call ntfs_attr_extend_allocation() for $MFT/$DATA.

 *

 * Locking: This function takes the runlist lock of @ni for writing as well as

 * locking the mft record of the base ntfs inode.  These locks are maintained

 * throughout execution of the function.  These locks are required so that the

 * attribute can be resized safely and so that it can for example be converted

 * from resident to non-resident safely.

 *

 * TODO: At present attribute list attribute handling is not implemented.

 *

 * TODO: At present it is not safe to call this function for anything other

 * than the $DATA attribute(s) of an uncompressed and unencrypted file.

 Silence stupid gcc warning. */

	/*

	 * For non-resident attributes, @start and @new_size need to be aligned

	 * to cluster boundaries for allocation purposes.

 Check if new size is allowed in $AttrDef. */

 Only emit errors when the write will fail completely. */

 Translate error code to be POSIX conformant for write(2). */

	/*

	 * We will be modifying both the runlist (if non-resident) and the mft

	 * record so lock them both down.

	/*

	 * If non-resident, seek to the last extent.  If resident, there is

	 * only one extent, so seek to that.

	/*

	 * Abort if someone did the work whilst we waited for the locks.  If we

	 * just converted the attribute from resident to non-resident it is

	 * likely that exactly this has happened already.  We cannot quite

	 * abort if we need to update the data size.

		/*

		 * We want the first attribute extent so that we can update the

		 * data size.

 Use goto to reduce indentation. */

 The total length of the attribute value. */

	/*

	 * Extend the attribute record to be able to store the new attribute

	 * size.  ntfs_attr_record_resize() will not do anything if the size is

	 * not changing.

 The resize succeeded! */

	/*

	 * We have to drop all the locks so we can call

	 * ntfs_attr_make_non_resident().  This could be optimised by try-

	 * locking the first page cache page and only if that fails dropping

	 * the locks, locking the page, and redoing all the locking and

	 * lookups.  While this would be a huge optimisation, it is not worth

	 * it as this is definitely a slow code path.

	/*

	 * Not enough space in the mft record, try to make the attribute

	 * non-resident and if successful restart the extension process.

	/*

	 * Could not make non-resident.  If this is due to this not being

	 * permitted for this attribute type or there not being enough space,

	 * try to make other attributes non-resident.  Otherwise fail.

 Only emit errors when the write will fail completely. */

 TODO: Not implemented from here, abort. */

 if (err == -EPERM) */

 TODO: Attempt to make other attributes non-resident.

	/*

	 * Both the attribute list attribute and the standard information

	 * attribute must remain in the base inode.  Thus, if this is one of

	 * these attributes, we have to try to move other attributes out into

	 * extent mft records instead.

 TODO: Attempt to move other attributes into extent mft

 records.

 TODO: Attempt to move this attribute to an extent mft record, but

 only if it is not already the only attribute in an mft record in

 which case there would be nothing to gain.

 There is nothing we can do to make enough space. )-: */

	/*

	 * If the data starts after the end of the old allocation, this is a

	 * $DATA attribute and sparse attributes are enabled on the volume and

	 * for this inode, then create a sparse region between the old

	 * allocated size and the start of the data.  Otherwise simply proceed

	 * with filling the whole space between the old allocated size and the

	 * new allocated size with clusters.

 TODO: This is not implemented yet.  We just fill in with real

 clusters for now...

 Seek to the end of the runlist. */

 If this attribute extent is not mapped, map it now. */

 Seek to the end of the runlist. */

	/*

	 * We now know the runlist of the last extent is mapped and @rl is at

	 * the end of the runlist.  We want to begin allocating clusters

	 * starting at the last allocated cluster to reduce fragmentation.  If

	 * there are no valid LCNs in the attribute we let the cluster

	 * allocator choose the starting cluster.

 If the last LCN is a hole or simillar seek back to last real LCN. */

 FIXME: Need to implement partial allocations so at least part of the

 write can be performed when start >= 0.  (Needed for POSIX write(2)

 conformance.)

 Find the runlist element with which the attribute extent starts. */

 Get the size for the new mapping pairs array for this extent. */

 Extend the attribute record to fit the bigger mapping pairs array. */

 TODO: Deal with this by moving this extent to a new mft

 record or by starting a new extent in a new mft record,

 possibly by extending this extent partially and filling it

 and creating a new extent for the remainder, or by making

 other attributes non-resident and/or by moving other

 attributes out of this mft record.

 Generate the mapping pairs array directly into the attr record. */

 Update the highest_vcn. */

	/*

	 * We now have extended the allocated size of the attribute.  Reflect

	 * this in the ntfs_inode structure and the attribute record.

		/*

		 * We are not in the first attribute extent, switch to it, but

		 * first ensure the changes will make it to disk later.

 @m is not used any more so no need to set it. */

	/*

	 * FIXME: This would fail if @ni is a directory, $MFT, or an index,

	 * since those can have sparse/compressed set.  For example can be

	 * set compressed even though it is not compressed itself and in that

	 * case the bit means that files are to be created compressed in the

	 * directory...  At present this is ok as this code is only called for

	 * regular files, and only for their $DATA attribute(s).

	 * FIXME: The calculation is wrong if we created a hole above.  For now

	 * it does not matter as we never create holes.

 Ensure the changes make it to disk. */

		/*

		 * FIXME: This would fail if @ni is a directory...  See above.

		 * FIXME: The calculation is wrong if we created a hole above.

		 * For now it does not matter as we never create holes.

		/*

		 * The only thing that is now wrong is the allocated size of the

		 * base attribute extent which chkdsk should be able to fix.

	/*

	 * If the runlist truncation fails and/or the search context is no

	 * longer valid, we cannot resize the attribute record or build the

	 * mapping pairs array thus we mark the inode bad so that no access to

	 * the freed clusters can happen.

 if (success) */ {

/**

 * ntfs_attr_set - fill (a part of) an attribute with a byte

 * @ni:		ntfs inode describing the attribute to fill

 * @ofs:	offset inside the attribute at which to start to fill

 * @cnt:	number of bytes to fill

 * @val:	the unsigned 8-bit value with which to fill the attribute

 *

 * Fill @cnt bytes of the attribute described by the ntfs inode @ni starting at

 * byte offset @ofs inside the attribute with the constant byte @val.

 *

 * This function is effectively like memset() applied to an ntfs attribute.

 * Note thie function actually only operates on the page cache pages belonging

 * to the ntfs attribute and it marks them dirty after doing the memset().

 * Thus it relies on the vm dirty page write code paths to cause the modified

 * pages to be written to the mft record/disk.

 *

 * Return 0 on success and -errno on error.  An error code of -ESPIPE means

 * that @ofs + @cnt were outside the end of the attribute and no write was

 * performed.

	/*

	 * FIXME: Compressed and encrypted attributes are not supported when

	 * writing and we should never have gotten here for them.

 Work out the starting index and page offset. */

 Work out the ending index and page offset. */

 If the end is outside the inode size return -ESPIPE. */

 If there is a first partial page, need to do it the slow way. */

		/*

		 * If the last page is the same as the first page, need to

		 * limit the write to the end offset.

 Do the whole pages the fast way. */

 Find or create the current page.  (The page is locked.) */

		/*

		 * If the page has buffers, mark them uptodate since buffer

		 * state and not page state is definitive in 2.6 kernels.

 Now that buffers are uptodate, set the page uptodate, too. */

		/*

		 * Set the page and all its buffers dirty and mark the inode

		 * dirty, too.  The VM will write the page later on.

 Finally unlock and release the page. */

 If there is a last partial page, need to do it the slow way. */

 NTFS_RW */

 SPDX-License-Identifier: GPL-2.0-or-later

/**

 * compress.c - NTFS kernel compressed attributes handling.

 *		Part of the Linux-NTFS project.

 *

 * Copyright (c) 2001-2004 Anton Altaparmakov

 * Copyright (c) 2002 Richard Russon

/**

 * ntfs_compression_constants - enum of constants used in the compression code

 Token types and access mask. */

 Compression sub-block constants. */

	/*

	 * The maximum compression block size is by definition 16 * the cluster

	 * size, with the maximum supported cluster size being 4kiB. Thus the

	 * maximum compression buffer size is 64kiB, so we use this when

	 * initializing the compression buffer.

/**

 * ntfs_compression_buffer - one buffer for the decompression engine

/**

 * ntfs_cb_lock - spinlock which protects ntfs_compression_buffer

/**

 * allocate_compression_buffers - allocate the decompression buffers

 *

 * Caller has to hold the ntfs_lock mutex.

 *

 * Return 0 on success or -ENOMEM if the allocations failed.

/**

 * free_compression_buffers - free the decompression buffers

 *

 * Caller has to hold the ntfs_lock mutex.

/**

 * zero_partial_compressed_page - zero out of bounds compressed page region

/**

 * handle_bounds_compressed_page - test for&handle out of bounds compressed page

/**

 * ntfs_decompress - decompress a compression block into an array of pages

 * @dest_pages:		destination array of pages

 * @completed_pages:	scratch space to track completed pages

 * @dest_index:		current index into @dest_pages (IN/OUT)

 * @dest_ofs:		current offset within @dest_pages[@dest_index] (IN/OUT)

 * @dest_max_index:	maximum index into @dest_pages (IN)

 * @dest_max_ofs:	maximum offset within @dest_pages[@dest_max_index] (IN)

 * @xpage:		the target page (-1 if none) (IN)

 * @xpage_done:		set to 1 if xpage was completed successfully (IN/OUT)

 * @cb_start:		compression block to decompress (IN)

 * @cb_size:		size of compression block @cb_start in bytes (IN)

 * @i_size:		file size when we started the read (IN)

 * @initialized_size:	initialized file size when we started the read (IN)

 *

 * The caller must have disabled preemption. ntfs_decompress() reenables it when

 * the critical section is finished.

 *

 * This decompresses the compression block @cb_start into the array of

 * destination pages @dest_pages starting at index @dest_index into @dest_pages

 * and at offset @dest_pos into the page @dest_pages[@dest_index].

 *

 * When the page @dest_pages[@xpage] is completed, @xpage_done is set to 1.

 * If xpage is -1 or @xpage has not been completed, @xpage_done is not modified.

 *

 * @cb_start is a pointer to the compression block which needs decompressing

 * and @cb_size is the size of @cb_start in bytes (8-64kiB).

 *

 * Return 0 if success or -EOVERFLOW on error in the compressed stream.

 * @xpage_done indicates whether the target page (@dest_pages[@xpage]) was

 * completed during the decompression of the compression block (@cb_start).

 *

 * Warning: This function *REQUIRES* PAGE_SIZE >= 4096 or it will blow up

 * unpredicatbly! You have been warned!

 *

 * Note to hackers: This function may not sleep until it has finished accessing

 * the compression block @cb_start as it is a per-CPU buffer.

	/*

	 * Pointers into the compressed data, i.e. the compression block (cb),

	 * and the therein contained sub-blocks (sb).

 End of cb. */

 Current position in cb. */

 Beginning of the current sb in the cb. */

 End of current sb / beginning of next sb. */

 Variables for uncompressed data / destination. */

 Current destination page being worked on. */

 Current pointer into dp. */

 Start of current sub-block in dp. */

	u8 *dp_sb_end;		/* End of current sb in dp (dp_sb_start +

 @dest_ofs when starting this sub-block. */

	u16 do_sb_end;		/* @dest_ofs of end of this sb (do_sb_start +

 Variables for tag and token parsing. */

 Current tag. */

 Loop counter for the eight tokens in tag. */

 Default error code. */

	/*

	 * Have we reached the end of the compression block or the end of the

	 * decompressed data?  The latter can happen for example if the current

	 * position in the compression block is one byte before its end so the

	 * first two checks do not detect it.

 We can sleep from now on, so we drop lock. */

 Second stage: finalize completed pages. */

				/*

				 * If we are outside the initialized size, zero

				 * the out of bounds page range.

 Setup offsets for the current sub-block destination. */

 Check that we are still within allowed boundaries. */

 Does the minimum size of a compressed sb overflow valid range? */

 Setup the current sub-block source pointers and validate range. */

 Get the current destination page. */

 No page present. Skip decompression of this sub-block. */

 Advance destination position to next sub-block. */

 We have a valid destination page. Setup the destination pointers. */

 Now, we are ready to process the current sub-block (sb). */

 This sb is not compressed, just copy it into destination. */

 Advance source position to first data byte. */

 An uncompressed sb must be full size. */

 Copy the block and advance the source position. */

 Advance destination position to next sub-block. */

			/*

			 * First stage: add current page index to array of

			 * completed pages.

 This sb is compressed, decompress it into destination. */

 Setup destination pointers. */

 Forward to the first tag in the sub-block. */

 Check if the decompressed sub-block was not full-length. */

 Zero remainder and update destination position. */

 We have finished the current sub-block. */

 Check we are still in range. */

 Get the next tag and advance to first token. */

 Parse the eight tokens described by the tag. */

 Check if we are done / still in range. */

 Determine token type and parse appropriately.*/

			/*

			 * We have a symbol token, copy the symbol across, and

			 * advance the source and destination positions.

 Continue with the next token. */

		/*

		 * We have a phrase token. Make sure it is not the first tag in

		 * the sb as this is illegal and would confuse the code below.

		/*

		 * Determine the number of bytes to go back (p) and the number

		 * of bytes to copy (l). We use an optimized algorithm in which

		 * we first calculate log2(current destination position in sb),

		 * which allows determination of l and p in O(1) rather than

		 * O(n). We just need an arch-optimized log2() function now.

 Get the phrase token into i. */

		/*

		 * Calculate starting position of the byte sequence in

		 * the destination using the fact that p = (pt >> (12 - lg)) + 1

		 * and make sure we don't go too far back.

 Now calculate the length of the byte sequence. */

 Advance destination position and verify it is in range. */

 The number of non-overlapping bytes. */

 The byte sequence doesn't overlap, just copy it. */

 Advance destination pointer. */

			/*

			 * The byte sequence does overlap, copy non-overlapping

			 * part and then do a slow byte by byte copy for the

			 * overlapping part. Also, advance the destination

			 * pointer.

 Advance source position and continue with the next token. */

 No tokens left in the current tag. Continue with the next tag. */

/**

 * ntfs_read_compressed_block - read a compressed block into the page cache

 * @page:	locked page in the compression block(s) we need to read

 *

 * When we are called the page has already been verified to be locked and the

 * attribute is known to be non-resident, not encrypted, but compressed.

 *

 * 1. Determine which compression block(s) @page is in.

 * 2. Get hold of all pages corresponding to this/these compression block(s).

 * 3. Read the (first) compression block.

 * 4. Decompress it into the corresponding pages.

 * 5. Throw the compressed data away and proceed to 3. for the next compression

 *    block or return success if no more compression blocks left.

 *

 * Warning: We have to be careful what we do about existing pages. They might

 * have been written to so that we would lose data if we were to just overwrite

 * them with the out-of-date uncompressed data.

 *

 * FIXME: For PAGE_SIZE > cb_size we are not doing the Right Thing(TM) at

 * the end of the file I think. We need to detect this case and zero the out

 * of bounds remainder of the page in question and mark it as handled. At the

 * moment we would just return -EIO on such a page. This bug will only become

 * apparent if pages are above 8kiB and the NTFS volume only uses 512 byte

 * clusters so is probably not going to be seen by anyone. Still this should

 * be fixed. (AIA)

 *

 * FIXME: Again for PAGE_SIZE > cb_size we are screwing up both in

 * handling sparse and compressed cbs. (AIA)

 *

 * FIXME: At the moment we don't do any zeroing out in the case that

 * initialized_size is less than data_size. This should be safe because of the

 * nature of the compression algorithm used. Just in case we check and output

 * an error message in read inode if the two sizes are not equal for a

 * compressed file. (AIA)

 The first wanted vcn (minimum alignment is PAGE_SIZE). */

	/*

	 * The first vcn after the last wanted vcn (minimum alignment is again

	 * PAGE_SIZE.

 Number of compression blocks (cbs) in the wanted vcn range. */

	/*

	 * Number of pages required to store the uncompressed data from all

	 * compression blocks (cbs) overlapping @page. Due to alignment

	 * guarantees of start_vcn and end_vcn, no need to round up here.

	/*

	 * Bad things happen if we get here for anything that is not an

	 * unnamed $DATA attribute.

 Allocate memory to store the buffer heads we need. */

	/*

	 * We have already been given one page, this is the one we must do.

	 * Once again, the alignment guarantees keep it simple.

	/*

	 * The remaining pages need to be allocated and inserted into the page

	 * cache, alignment guarantees keep all the below much simpler. (-8

 Is the page fully outside i_size? (truncate in progress) */

			/*

			 * We only (re)read the page if it isn't already read

			 * in and/or dirty or we would be losing data or at

			 * least wasting our time.

	/*

	 * We have the runlist, and all the destination pages we need to fill.

	 * Now read the first compression block.

 Read all cb buffer heads one cluster at a time. */

 Seek to element containing target vcn. */

			/*

			 * When we reach the first sparse cluster we have

			 * finished with the cb.

			/*

			 * Attempt to map runlist, dropping lock for the

			 * duration.

 Read the lcn from device in chunks of block_size bytes. */

 Release the lock if we took it. */

 Setup and initiate io on all buffer heads. */

 Wait for io completion on all buffer heads. */

		/*

		 * We need an optimization barrier here, otherwise we start

		 * hitting the below fixup code when accessing a loopback

		 * mounted ntfs partition. This indicates either there is a

		 * race condition in the loop driver or, more likely, gcc

		 * overoptimises the code without the barrier and it doesn't

		 * do the Right Thing(TM).

	/*

	 * Get the compression buffer. We must not sleep any more

	 * until we are finished with it.

 Copy the buffer heads into the contiguous buffer. */

 Just a precaution. */

 Reset cb_pos back to the beginning. */

 We now have both source (if present) and destination. */

 The last page and maximum offset within it for the current cb. */

 Catch end of file inside a compression block. */

 Sparse cb, zero out page range overlapping the cb. */

 We can sleep from now on, so we drop lock. */

 If we have a partial final page, deal with it now. */

			/*

			 * No need to update cb_pos at this stage:

			 *	cb_pos += cb_max_ofs - cur_ofs;

 We can't sleep so we need two stages. */

 Uncompressed cb, copy it to the destination pages. */

		/*

		 * TODO: As a big optimization, we could detect this case

		 * before we read all the pages and use block_read_full_page()

		 * on all full pages instead (we still have to treat partial

		 * pages especially but at least we are getting rid of the

		 * synchronous io for the majority of pages.

		 * Or if we choose not to do the read-ahead/-behind stuff, we

		 * could just return block_read_full_page(pages[xpage]) as long

		 * as PAGE_SIZE <= cb_size.

 First stage: copy data into destination pages. */

 If we have a partial final page, deal with it now. */

 We can sleep from now on, so drop lock. */

 Second stage: finalize pages. */

				/*

				 * If we are outside the initialized size, zero

				 * the out of bounds page range.

 Compressed cb, decompress it into the destination page(s). */

		/*

		 * We can sleep from now on, lock already dropped by

		 * ntfs_decompress().

 Release the unfinished pages. */

 Release the buffer heads. */

 Do we have more work to do? */

 We no longer need the list of buffer heads. */

 Clean up if we have any pages left. Should never happen. */

 We no longer need the list of pages. */

 If we have completed the requested page, we return success. */

 Release the buffer heads. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * lcnalloc.c - Cluster (de)allocation code.  Part of the Linux-NTFS project.

 *

 * Copyright (c) 2004-2005 Anton Altaparmakov

/**

 * ntfs_cluster_free_from_rl_nolock - free clusters from runlist

 * @vol:	mounted ntfs volume on which to free the clusters

 * @rl:		runlist describing the clusters to free

 *

 * Free all the clusters described by the runlist @rl on the volume @vol.  In

 * the case of an error being returned, at least some of the clusters were not

 * freed.

 *

 * Return 0 on success and -errno on error.

 *

 * Locking: - The volume lcn bitmap must be locked for writing on entry and is

 *	      left locked on return.

/**

 * ntfs_cluster_alloc - allocate clusters on an ntfs volume

 * @vol:	mounted ntfs volume on which to allocate the clusters

 * @start_vcn:	vcn to use for the first allocated cluster

 * @count:	number of clusters to allocate

 * @start_lcn:	starting lcn at which to allocate the clusters (or -1 if none)

 * @zone:	zone from which to allocate the clusters

 * @is_extension:	if 'true', this is an attribute extension

 *

 * Allocate @count clusters preferably starting at cluster @start_lcn or at the

 * current allocator position if @start_lcn is -1, on the mounted ntfs volume

 * @vol. @zone is either DATA_ZONE for allocation of normal clusters or

 * MFT_ZONE for allocation of clusters for the master file table, i.e. the

 * $MFT/$DATA attribute.

 *

 * @start_vcn specifies the vcn of the first allocated cluster.  This makes

 * merging the resulting runlist with the old runlist easier.

 *

 * If @is_extension is 'true', the caller is allocating clusters to extend an

 * attribute and if it is 'false', the caller is allocating clusters to fill a

 * hole in an attribute.  Practically the difference is that if @is_extension

 * is 'true' the returned runlist will be terminated with LCN_ENOENT and if

 * @is_extension is 'false' the runlist will be terminated with

 * LCN_RL_NOT_MAPPED.

 *

 * You need to check the return value with IS_ERR().  If this is false, the

 * function was successful and the return value is a runlist describing the

 * allocated cluster(s).  If IS_ERR() is true, the function failed and

 * PTR_ERR() gives you the error code.

 *

 * Notes on the allocation algorithm

 * =================================

 *

 * There are two data zones.  First is the area between the end of the mft zone

 * and the end of the volume, and second is the area between the start of the

 * volume and the start of the mft zone.  On unmodified/standard NTFS 1.x

 * volumes, the second data zone does not exist due to the mft zone being

 * expanded to cover the start of the volume in order to reserve space for the

 * mft bitmap attribute.

 *

 * This is not the prettiest function but the complexity stems from the need of

 * implementing the mft vs data zoned approach and from the fact that we have

 * access to the lcn bitmap in portions of up to 8192 bytes at a time, so we

 * need to cope with crossing over boundaries of two buffers.  Further, the

 * fact that the allocator allows for caller supplied hints as to the location

 * of where allocation should begin and the fact that the allocator keeps track

 * of where in the data zones the next natural allocation should occur,

 * contribute to the complexity of the function.  But it should all be

 * worthwhile, because this allocator should: 1) be a full implementation of

 * the MFT zone approach used by Windows NT, 2) cause reduction in

 * fragmentation, and 3) be speedy in allocations (the code is not optimized

 * for speed, but the algorithm is, so further speed improvements are probably

 * possible).

 *

 * FIXME: We should be monitoring cluster allocation and increment the MFT zone

 * size dynamically but this is something for the future.  We will just cause

 * heavier fragmentation by not doing it and I am not even sure Windows would

 * grow the MFT zone dynamically, so it might even be correct not to do this.

 * The overhead in doing dynamic MFT zone expansion would be very large and

 * unlikely worth the effort. (AIA)

 *

 * TODO: I have added in double the required zone position pointer wrap around

 * logic which can be optimized to having only one of the two logic sets.

 * However, having the double logic will work fine, but if we have only one of

 * the sets and we get it wrong somewhere, then we get into trouble, so

 * removing the duplicate logic requires _very_ careful consideration of _all_

 * possible code paths.  So at least for now, I am leaving the double logic -

 * better safe than sorry... (AIA)

 *

 * Locking: - The volume lcn bitmap must be unlocked on entry and is unlocked

 *	      on return.

 *	    - This function takes the volume lcn bitmap lock for writing and

 *	      modifies the bitmap contents.

 Return NULL if @count is zero. */

 Take the lcnbmp lock for writing. */

	/*

	 * If no specific @start_lcn was requested, use the current data zone

	 * position, otherwise use the requested @start_lcn but make sure it

	 * lies outside the mft zone.  Also set done_zones to 0 (no zones done)

	 * and pass depending on whether we are starting inside a zone (1) or

	 * at the beginning of a zone (2).  If requesting from the MFT_ZONE,

	 * we either start at the current position within the mft zone or at

	 * the specified position.  If the latter is out of bounds then we start

	 * at the beginning of the MFT_ZONE.

	/*

	 * zone_start and zone_end are the current search range.  search_zone

	 * is 1 for mft zone, 2 for data zone 1 (end of mft zone till end of

	 * volume) and 4 for data zone 2 (start of volume till start of mft

	 * zone).

			/*

			 * Zone starts at beginning of volume which means a

			 * single pass is sufficient.

		/*

		 * Starting at beginning of data1_zone which means a single

		 * pass in this zone is sufficient.

		/*

		 * Starting at beginning of volume which means a single pass

		 * is sufficient.

 if (zone == DATA_ZONE) */ {

 Skip searching the mft zone. */

	/*

	 * bmp_pos is the current bit position inside the bitmap.  We use

	 * bmp_initial_pos to determine whether or not to do a zone switch.

 Loop until all clusters are allocated, i.e. clusters == 0. */

 Loop until we run out of free clusters. */

 Skip full bytes. */

 If the bit is already set, go onto the next one. */

			/*

			 * Allocate more memory if needed, including space for

			 * the terminator element.

			 * ntfs_malloc_nofs() operates on whole pages only.

 Allocate the bitmap bit. */

 We need to write this bitmap page to disk. */

			/*

			 * Coalesce with previous run if adjacent LCNs.

			 * Otherwise, append a new run.

 Done? */

				/*

				 * Update the current zone position.  Positions

				 * of already scanned zones have been updated

				 * during the respective zone switches.

 Finished with the current zone pass. */

			/*

			 * Now do pass 2, scanning the first part of the zone

			 * we omitted in pass 1.

 mft_zone */

 data1_zone */

 data2_zone */

 Sanity check. */

 pass == 2 */

 Now switch to the next zone we haven't done yet. */

 Update mft zone position. */

 Switch from mft zone to data1 zone. */

 Update data1 zone position. */

 Switch from data1 zone to data2 zone. */

 Update data2 zone position. */

 Switch from data2 zone to data1 zone. */

 Empty zone. Don't bother searching it. */

 done_zones == 7 */

		/*

		 * All zones are finished!  If DATA_ZONE, shrink mft zone.  If

		 * MFT_ZONE, we have really run out of space.

 Really no more space left on device. */

 zone == DATA_ZONE && mft_zone_size > 0 */

 mft zone and data2 zone no longer exist. */

 Add runlist terminator element. */

 Deallocate all allocated clusters. */

 Free the runlist. */

/**

 * __ntfs_cluster_free - free clusters on an ntfs volume

 * @ni:		ntfs inode whose runlist describes the clusters to free

 * @start_vcn:	vcn in the runlist of @ni at which to start freeing clusters

 * @count:	number of clusters to free or -1 for all clusters

 * @ctx:	active attribute search context if present or NULL if not

 * @is_rollback:	true if this is a rollback operation

 *

 * Free @count clusters starting at the cluster @start_vcn in the runlist

 * described by the vfs inode @ni.

 *

 * If @count is -1, all clusters from @start_vcn to the end of the runlist are

 * deallocated.  Thus, to completely free all clusters in a runlist, use

 * @start_vcn = 0 and @count = -1.

 *

 * If @ctx is specified, it is an active search context of @ni and its base mft

 * record.  This is needed when __ntfs_cluster_free() encounters unmapped

 * runlist fragments and allows their mapping.  If you do not have the mft

 * record mapped, you can specify @ctx as NULL and __ntfs_cluster_free() will

 * perform the necessary mapping and unmapping.

 *

 * Note, __ntfs_cluster_free() saves the state of @ctx on entry and restores it

 * before returning.  Thus, @ctx will be left pointing to the same attribute on

 * return as on entry.  However, the actual pointers in @ctx may point to

 * different memory locations on return, so you must remember to reset any

 * cached pointers from the @ctx, i.e. after the call to __ntfs_cluster_free(),

 * you will probably want to do:

 *	m = ctx->mrec;

 *	a = ctx->attr;

 * Assuming you cache ctx->attr in a variable @a of type ATTR_RECORD * and that

 * you cache ctx->mrec in a variable @m of type MFT_RECORD *.

 *

 * @is_rollback should always be 'false', it is for internal use to rollback

 * errors.  You probably want to use ntfs_cluster_free() instead.

 *

 * Note, __ntfs_cluster_free() does not modify the runlist, so you have to

 * remove from the runlist or mark sparse the freed runs later.

 *

 * Return the number of deallocated clusters (not counting sparse ones) on

 * success and -errno on error.

 *

 * WARNING: If @ctx is supplied, regardless of whether success or failure is

 *	    returned, you need to check IS_ERR(@ctx->mrec) and if 'true' the @ctx

 *	    is no longer valid, i.e. you need to either call

 *	    ntfs_attr_reinit_search_ctx() or ntfs_attr_put_search_ctx() on it.

 *	    In that case PTR_ERR(@ctx->mrec) will give you the error code for

 *	    why the mapping of the old inode failed.

 *

 * Locking: - The runlist described by @ni must be locked for writing on entry

 *	      and is locked on return.  Note the runlist may be modified when

 *	      needed runlist fragments need to be mapped.

 *	    - The volume lcn bitmap must be unlocked on entry and is unlocked

 *	      on return.

 *	    - This function takes the volume lcn bitmap lock for writing and

 *	      modifies the bitmap contents.

 *	    - If @ctx is NULL, the base mft record of @ni must not be mapped on

 *	      entry and it will be left unmapped on return.

 *	    - If @ctx is not NULL, the base mft record must be mapped on entry

 *	      and it will be left mapped on return.

	/*

	 * Lock the lcn bitmap for writing but only if not rolling back.  We

	 * must hold the lock all the way including through rollback otherwise

	 * rollback is not possible because once we have cleared a bit and

	 * dropped the lock, anyone could have set the bit again, thus

	 * allocating the cluster for another use.

 Find the starting cluster inside the run that needs freeing. */

 The number of clusters in this run that need freeing. */

 Do the actual freeing of the clusters in this run. */

 We have freed @to_free real clusters. */

 Go to the next run and adjust the number of clusters left to free. */

 Keep track of the total "freed" clusters, including sparse ones. */

	/*

	 * Loop over the remaining runs, using @count as a capping value, and

	 * free them.

 Attempt to map runlist. */

 The number of clusters in this run that need freeing. */

 Do the actual freeing of the clusters in the run. */

 We have freed @to_free real clusters. */

 Adjust the number of clusters left to free. */

 Update the total done clusters. */

 We are done.  Return the number of actually freed clusters. */

 If no real clusters were freed, no need to rollback. */

	/*

	 * Attempt to rollback and if that succeeds just return the error code.

	 * If rollback fails, set the volume errors flag, emit an error

	 * message, and return the error code.

 NTFS_RW */

 SPDX-License-Identifier: GPL-2.0-or-later

/**

 * inode.c - NTFS kernel inode handling.

 *

 * Copyright (c) 2001-2014 Anton Altaparmakov and Tuxera Inc.

/**

 * ntfs_test_inode - compare two (possibly fake) inodes for equality

 * @vi:		vfs inode which to test

 * @data:	data which is being tested with

 *

 * Compare the ntfs attribute embedded in the ntfs specific part of the vfs

 * inode @vi for equality with the ntfs attribute @data.

 *

 * If searching for the normal file/directory inode, set @na->type to AT_UNUSED.

 * @na->name and @na->name_len are then ignored.

 *

 * Return 1 if the attributes match and 0 if not.

 *

 * NOTE: This function runs with the inode_hash_lock spin lock held so it is not

 * allowed to sleep.

 If !NInoAttr(ni), @vi is a normal file or directory inode. */

 If not looking for a normal inode this is a mismatch. */

 A fake inode describing an attribute. */

 Match! */

/**

 * ntfs_init_locked_inode - initialize an inode

 * @vi:		vfs inode to initialize

 * @data:	data which to initialize @vi to

 *

 * Initialize the vfs inode @vi with the values from the ntfs attribute @data in

 * order to enable ntfs_test_inode() to do its work.

 *

 * If initializing the normal file/directory inode, set @na->type to AT_UNUSED.

 * In that case, @na->name and @na->name_len should be set to NULL and 0,

 * respectively. Although that is not strictly necessary as

 * ntfs_read_locked_inode() will fill them in later.

 *

 * Return 0 on success and -errno on error.

 *

 * NOTE: This function runs with the inode->i_lock spin lock held so it is not

 * allowed to sleep. (Hence the GFP_ATOMIC allocation.)

 If initializing a normal inode, we are done. */

 It is a fake inode. */

	/*

	 * We have I30 global constant as an optimization as it is the name

	 * in >99.9% of named attributes! The other <0.1% incur a GFP_ATOMIC

	 * allocation but that is ok. And most attributes are unnamed anyway,

	 * thus the fraction of named attributes with name != I30 is actually

	 * absolutely tiny.

/**

 * ntfs_iget - obtain a struct inode corresponding to a specific normal inode

 * @sb:		super block of mounted volume

 * @mft_no:	mft record number / inode number to obtain

 *

 * Obtain the struct inode corresponding to a specific normal inode (i.e. a

 * file or directory).

 *

 * If the inode is in the cache, it is just returned with an increased

 * reference count. Otherwise, a new struct inode is allocated and initialized,

 * and finally ntfs_read_locked_inode() is called to read in the inode and

 * fill in the remainder of the inode structure.

 *

 * Return the struct inode on success. Check the return value with IS_ERR() and

 * if true, the function failed and the error code is obtained from PTR_ERR().

 If this is a freshly allocated inode, need to read it now. */

	/*

	 * There is no point in keeping bad inodes around if the failure was

	 * due to ENOMEM. We want to be able to retry again later.

/**

 * ntfs_attr_iget - obtain a struct inode corresponding to an attribute

 * @base_vi:	vfs base inode containing the attribute

 * @type:	attribute type

 * @name:	Unicode name of the attribute (NULL if unnamed)

 * @name_len:	length of @name in Unicode characters (0 if unnamed)

 *

 * Obtain the (fake) struct inode corresponding to the attribute specified by

 * @type, @name, and @name_len, which is present in the base mft record

 * specified by the vfs inode @base_vi.

 *

 * If the attribute inode is in the cache, it is just returned with an

 * increased reference count. Otherwise, a new struct inode is allocated and

 * initialized, and finally ntfs_read_locked_attr_inode() is called to read the

 * attribute and fill in the inode structure.

 *

 * Note, for index allocation attributes, you need to use ntfs_index_iget()

 * instead of ntfs_attr_iget() as working with indices is a lot more complex.

 *

 * Return the struct inode of the attribute inode on success. Check the return

 * value with IS_ERR() and if true, the function failed and the error code is

 * obtained from PTR_ERR().

 Make sure no one calls ntfs_attr_iget() for indices. */

 If this is a freshly allocated inode, need to read it now. */

	/*

	 * There is no point in keeping bad attribute inodes around. This also

	 * simplifies things in that we never need to check for bad attribute

	 * inodes elsewhere.

/**

 * ntfs_index_iget - obtain a struct inode corresponding to an index

 * @base_vi:	vfs base inode containing the index related attributes

 * @name:	Unicode name of the index

 * @name_len:	length of @name in Unicode characters

 *

 * Obtain the (fake) struct inode corresponding to the index specified by @name

 * and @name_len, which is present in the base mft record specified by the vfs

 * inode @base_vi.

 *

 * If the index inode is in the cache, it is just returned with an increased

 * reference count.  Otherwise, a new struct inode is allocated and

 * initialized, and finally ntfs_read_locked_index_inode() is called to read

 * the index related attributes and fill in the inode structure.

 *

 * Return the struct inode of the index inode on success. Check the return

 * value with IS_ERR() and if true, the function failed and the error code is

 * obtained from PTR_ERR().

 If this is a freshly allocated inode, need to read it now. */

	/*

	 * There is no point in keeping bad index inodes around.  This also

	 * simplifies things in that we never need to check for bad index

	 * inodes elsewhere.

/*

 * The attribute runlist lock has separate locking rules from the

 * normal runlist lock, so split the two lock-classes:

/**

 * __ntfs_init_inode - initialize ntfs specific part of an inode

 * @sb:		super block of mounted volume

 * @ni:		freshly allocated ntfs inode which to initialize

 *

 * Initialize an ntfs inode to defaults.

 *

 * NOTE: ni->mft_no, ni->state, ni->type, ni->name, and ni->name_len are left

 * untouched. Make sure to initialize them elsewhere.

 *

 * Return zero on success and -ENOMEM on error.

/*

 * Extent inodes get MFT-mapped in a nested way, while the base inode

 * is still mapped. Teach this nesting to the lock validator by creating

 * a separate class for nested inode's mrec_lock's:

/**

 * ntfs_is_extended_system_file - check if a file is in the $Extend directory

 * @ctx:	initialized attribute search context

 *

 * Search all file name attributes in the inode described by the attribute

 * search context @ctx and check if any of the names are in the $Extend system

 * directory.

 *

 * Return values:

 *	   1: file is in $Extend directory

 *	   0: file is not in $Extend directory

 *    -errno: failed to determine if the file is in the $Extend directory

 Restart search. */

 Get number of hard links. */

 Loop through all hard links. */

		/*

		 * Maximum sanity checking as we are called on an inode that

		 * we suspect might be corrupt.

 This attribute is ok, but is it in the $Extend directory? */

 YES, it's an extended system file. */

 NO, it is not an extended system file. */

/**

 * ntfs_read_locked_inode - read an inode from its device

 * @vi:		inode to read

 *

 * ntfs_read_locked_inode() is called from ntfs_iget() to read the inode

 * described by @vi into memory from the device.

 *

 * The only fields in @vi that we need to/can look at when the function is

 * called are i_sb, pointing to the mounted device's super block, and i_ino,

 * the number of the inode to load.

 *

 * ntfs_read_locked_inode() maps, pins and locks the mft record number i_ino

 * for reading and sets up the necessary @vi fields as well as initializing

 * the ntfs inode.

 *

 * Q: What locks are held when the function is called?

 * A: i_state has I_NEW set, hence the inode is locked, also

 *    i_count is set to 1, so it is not going to go away

 *    i_flags is set to 0 and we have no business touching it.  Only an ioctl()

 *    is allowed to write to them. We should of course be honouring them but

 *    we need to do that using the IS_* macros defined in include/linux/fs.h.

 *    In any case ntfs_read_locked_inode() has nothing to do with i_flags.

 *

 * Return 0 on success and -errno on error.  In the error case, the inode will

 * have had make_bad_inode() executed on it.

 Setup the generic vfs inode parts now. */

	/*

	 * Initialize the ntfs specific part of @vi special casing

	 * FILE_MFT which we need to do at mount time.

 Transfer information from mft record into vfs and ntfs inodes. */

	/*

	 * FIXME: Keep in mind that link_count is two for files which have both

	 * a long file name and a short file name as separate entries, so if

	 * we are hiding short file names this will be too high. Either we need

	 * to account for the short file names by subtracting them or we need

	 * to make sure we delete files even though i_nlink is not zero which

	 * might be tricky due to vfs interactions. Need to think about this

	 * some more when implementing the unlink command.

	/*

	 * FIXME: Reparse points can have the directory bit set even though

	 * they would be S_IFLNK. Need to deal with this further below when we

	 * implement reparse points / symbolic links but it will do for now.

	 * Also if not a directory, it could be something else, rather than

	 * a regular file. But again, will do for now.

 Everyone gets all permissions. */

 If read-only, no one gets write permissions. */

		/*

		 * Apply the directory permissions mask set in the mount

		 * options.

 Things break without this kludge! */

 Apply the file permissions mask set in the mount options. */

	/*

	 * Find the standard information attribute in the mft record. At this

	 * stage we haven't setup the attribute list stuff yet, so this could

	 * in fact fail if the standard information is in an extent record, but

	 * I don't think this actually ever happens.

			/*

			 * TODO: We should be performing a hot fix here (if the

			 * recover mount option is set) by creating a new

			 * attribute.

 Get the standard information attribute value. */

 Transfer information from the standard information into vi. */

	/*

	 * Note: The i_?times do not quite map perfectly onto the NTFS times,

	 * but they are close enough, and in the end it doesn't really matter

	 * that much...

	/*

	 * mtime is the last change of the data within the file. Not changed

	 * when only metadata is changed, e.g. a rename doesn't affect mtime.

	/*

	 * ctime is the last change of the metadata of the file. This obviously

	 * always changes, when mtime is changed. ctime can be changed on its

	 * own, mtime is then not changed, e.g. when a file is renamed.

	/*

	 * Last access to the data within the file. Not changed during a rename

	 * for example but changed whenever the file is written to.

 Find the attribute list attribute if present. */

 if (!err) */ {

 Now allocate memory for the attribute list. */

			/*

			 * Setup the runlist. No need for locking as we have

			 * exclusive access to the inode at this time.

 Now load the attribute list. */

 if (!a->non_resident) */ {

 Now copy the attribute list. */

	/*

	 * If an attribute list is present we now have the attribute list value

	 * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.

 It is a directory, find index root attribute. */

 FIXME: File is corrupt! Hot-fix with empty

 index root attribute if recovery option is

 set.

 Set up the state. */

 Ensure the attribute name is placed before the value. */

		/*

		 * Compressed/encrypted index root just means that the newly

		 * created files in that directory should be created compressed/

		 * encrypted. However index root cannot be both compressed and

		 * encrypted.

 Determine the size of a vcn in the directory index. */

 Setup the index allocation attribute, even if not present. */

 No index allocation. */

 We are done with the mft record, so we release it. */

 LARGE_INDEX: Index allocation present. Setup state. */

 Find index allocation attribute. */

		/*

		 * Ensure the attribute name is placed before the mapping pairs

		 * array.

		/*

		 * We are done with the mft record, so we release it. Otherwise

		 * we would deadlock in ntfs_attr_iget().

 Get the index bitmap attribute inode. */

 Consistency check bitmap size vs. index allocation size. */

 No longer need the bitmap attribute inode. */

 Setup the operations for this inode. */

 It is a file. */

 Setup the data attribute, even if not present. */

 Find first extent of the unnamed data attribute. */

			/*

			 * FILE_Secure does not have an unnamed $DATA

			 * attribute, so we special case it here.

			/*

			 * Most if not all the system files in the $Extend

			 * system directory do not have unnamed data

			 * attributes so we need to check if the parent

			 * directory of the file is FILE_Extend and if it is

			 * ignore this error. To do this we need to get the

			 * name of this inode from the mft record as the name

			 * contains the back reference to the parent directory.

 FIXME: File is corrupt! Hot-fix with empty data

 attribute if recovery option is set.

 Setup the state. */

 Resident attribute. */

 We are done with the mft record, so we release it. */

 Setup the operations for this inode. */

	/*

	 * The number of 512-byte blocks used on disk (for stat). This is in so

	 * far inaccurate as it doesn't account for any named streams or other

	 * special non-resident attributes, but that is how Windows works, too,

	 * so we are at least consistent with Windows, if not entirely

	 * consistent with the Linux Way. Doing it the Linux Way would cause a

	 * significant slowdown as it would involve iterating over all

	 * attributes in the mft record and adding the allocated/compressed

	 * sizes of all non-resident attributes present to give us the Linux

	 * correct size that should go into i_blocks (after division by 512).

/**

 * ntfs_read_locked_attr_inode - read an attribute inode from its base inode

 * @base_vi:	base inode

 * @vi:		attribute inode to read

 *

 * ntfs_read_locked_attr_inode() is called from ntfs_attr_iget() to read the

 * attribute inode described by @vi into memory from the base mft record

 * described by @base_ni.

 *

 * ntfs_read_locked_attr_inode() maps, pins and locks the base inode for

 * reading and looks up the attribute described by @vi before setting up the

 * necessary fields in @vi as well as initializing the ntfs inode.

 *

 * Q: What locks are held when the function is called?

 * A: i_state has I_NEW set, hence the inode is locked, also

 *    i_count is set to 1, so it is not going to go away

 *

 * Return 0 on success and -errno on error.  In the error case, the inode will

 * have had make_bad_inode() executed on it.

 *

 * Note this cannot be called for AT_INDEX_ALLOCATION.

 Just mirror the values from the base inode. */

 Set inode type to zero but preserve permissions. */

 Find the attribute. */

		/*

		 * The compressed/sparse flag set in an index root just means

		 * to compress all files.

		/*

		 * The encryption flag set in an index root just means to

		 * encrypt all files.

 Ensure the attribute name is placed before the value. */

		/*

		 * Ensure the attribute name is placed before the mapping pairs

		 * array.

	/*

	 * Make sure the base inode does not go away and attach it to the

	 * attribute inode.

/**

 * ntfs_read_locked_index_inode - read an index inode from its base inode

 * @base_vi:	base inode

 * @vi:		index inode to read

 *

 * ntfs_read_locked_index_inode() is called from ntfs_index_iget() to read the

 * index inode described by @vi into memory from the base mft record described

 * by @base_ni.

 *

 * ntfs_read_locked_index_inode() maps, pins and locks the base inode for

 * reading and looks up the attributes relating to the index described by @vi

 * before setting up the necessary fields in @vi as well as initializing the

 * ntfs inode.

 *

 * Note, index inodes are essentially attribute inodes (NInoAttr() is true)

 * with the attribute type set to AT_INDEX_ALLOCATION.  Apart from that, they

 * are setup like directory inodes since directories are a special case of

 * indices ao they need to be treated in much the same way.  Most importantly,

 * for small indices the index allocation attribute might not actually exist.

 * However, the index root attribute always exists but this does not need to

 * have an inode associated with it and this is why we define a new inode type

 * index.  Also, like for directories, we need to have an attribute inode for

 * the bitmap attribute corresponding to the index allocation attribute and we

 * can store this in the appropriate field of the inode, just like we do for

 * normal directory inodes.

 *

 * Q: What locks are held when the function is called?

 * A: i_state has I_NEW set, hence the inode is locked, also

 *    i_count is set to 1, so it is not going to go away

 *

 * Return 0 on success and -errno on error.  In the error case, the inode will

 * have had make_bad_inode() executed on it.

 Just mirror the values from the base inode. */

 Set inode type to zero but preserve permissions. */

 Map the mft record for the base inode. */

 Find the index root attribute. */

 Set up the state. */

 Ensure the attribute name is placed before the value. */

	/*

	 * Compressed/encrypted/sparse index root is not allowed, except for

	 * directories of course but those are not dealt with here.

 Determine the size of a vcn in the index. */

 Check for presence of index allocation attribute. */

 No index allocation. */

 We are done with the mft record, so we release it. */

 LARGE_INDEX:  Index allocation present.  Setup state. */

 Find index allocation attribute. */

	/*

	 * Ensure the attribute name is placed before the mapping pairs array.

	/*

	 * We are done with the mft record, so we release it.  Otherwise

	 * we would deadlock in ntfs_attr_iget().

 Get the index bitmap attribute inode. */

 Consistency check bitmap size vs. index allocation size. */

 Setup the operations for this index inode. */

	/*

	 * Make sure the base inode doesn't go away and attach it to the

	 * index inode.

/*

 * The MFT inode has special locking, so teach the lock validator

 * about this by splitting off the locking rules of the MFT from

 * the locking rules of other inodes. The MFT inode can never be

 * accessed from the VFS side (or even internally), only by the

 * map_mft functions.

/**

 * ntfs_read_inode_mount - special read_inode for mount time use only

 * @vi:		inode to read

 *

 * Read inode FILE_MFT at mount time, only called with super_block lock

 * held from within the read_super() code path.

 *

 * This function exists because when it is called the page cache for $MFT/$DATA

 * is not initialized and hence we cannot get at the contents of mft records

 * by calling map_mft_record*().

 *

 * Further it needs to cope with the circular references problem, i.e. cannot

 * load any attributes other than $ATTRIBUTE_LIST until $DATA is loaded, because

 * we do not know where the other extent mft records are yet and again, because

 * we cannot call map_mft_record*() yet.  Obviously this applies only when an

 * attribute list is actually present in $MFT inode.

 *

 * We solve these problems by starting with the $DATA attribute before anything

 * else and iterating using ntfs_attr_lookup($DATA) over all extents.  As each

 * extent is found, we ntfs_mapping_pairs_decompress() including the implied

 * ntfs_runlists_merge().  Each step of the iteration necessarily provides

 * sufficient information for the next step to complete.

 *

 * This should work but there are two possible pit falls (see inline comments

 * below), but only time will tell if they are real pits or just smoke...

 Initialize the ntfs specific part of @vi. */

 Setup the data attribute. It is special as it is mst protected. */

	/*

	 * This sets up our little cheat allowing us to reuse the async read io

	 * completion handler for directories.

 Very important! Needed to be able to call map_mft_record*(). */

 Allocate enough memory to read the first mft record. */

 Determine the first block of the $MFT/$DATA attribute. */

 Load $MFT/$DATA's first mft record. */

 Apply the mst fixups. */

 FIXME: Try to use the $MFTMirr now. */

 Need this to sanity check attribute list references to $MFT. */

 Provides readpage() for map_mft_record(). */

 Find the attribute list attribute if present. */

 if (!err) */ {

 Now allocate memory for the attribute list. */

 Setup the runlist. */

 Now load the attribute list. */

 if (!ctx.attr->non_resident) */ {

 Now copy the attribute list. */

 The attribute list is now setup in memory. */

		/*

		 * FIXME: I don't know if this case is actually possible.

		 * According to logic it is not possible but I have seen too

		 * many weird things in MS software to rely on logic... Thus we

		 * perform a manual search and make sure the first $MFT/$DATA

		 * extent is in the base inode. If it is not we abort with an

		 * error and if we ever see a report of this error we will need

		 * to do some magic in order to have the necessary mft record

		 * loaded and in the right place in the page cache. But

		 * hopefully logic will prevail and this never happens...

 Out of bounds check. */

 Catch the end of the attribute list. */

 We want an unnamed attribute. */

 Want the first entry, i.e. lowest_vcn == 0. */

 First entry has to be in the base mft record. */

 MFT references do not match, logic fails. */

 Sequence numbers must match. */

 Got it. All is ok. We can stop now. */

 Now load all attribute extents. */

 Cache the current attribute. */

 $MFT must be non-resident. */

 $MFT must be uncompressed and unencrypted. */

		/*

		 * Decompress the mapping pairs array of this extent and merge

		 * the result into the existing runlist. No need for locking

		 * as we have exclusive access to the inode at this time and we

		 * are a mount in progress task, too.

 Are we in the first extent? */

 Get the last vcn in the $DATA attribute. */

 Fill in the inode size. */

			/*

			 * Verify the number of mft records does not exceed

			 * 2^32 - 1.

			/*

			 * We have got the first extent of the runlist for

			 * $MFT which means it is now relatively safe to call

			 * the normal ntfs_read_inode() function.

			 * Complete reading the inode, this will actually

			 * re-read the mft record for $MFT, this time entering

			 * it into the page cache with which we complete the

			 * kick start of the volume. It should be safe to do

			 * this now as the first extent of $MFT/$DATA is

			 * already known and we would hope that we don't need

			 * further extents in order to find the other

			 * attributes belonging to $MFT. Only time will tell if

			 * this is really the case. If not we will have to play

			 * magic at this point, possibly duplicating a lot of

			 * ntfs_read_inode() at this point. We will need to

			 * ensure we do enough of its work to be able to call

			 * ntfs_read_inode() on extents of $MFT/$DATA. But lets

			 * hope this never happens...

 Revert to the safe super operations. */

			/*

			 * Re-initialize some specifics about $MFT's inode as

			 * ntfs_read_inode() will have set up the default ones.

 Set uid and gid to root. */

 Regular file. No access for anyone. */

 No VFS initiated operations allowed for $MFT. */

 Get the lowest vcn for the next extent. */

 Only one extent or error, which we catch below. */

 Avoid endless loops due to corruption. */

	/*

	 * Split the locking rules of the MFT inode from the

	 * locking rules of other inodes:

 Free all alocated memory. */

 Catch bugs... */

 FIXME:  Do something!!!

 NTFS_RW */

 Bye, bye... */

/**

 * ntfs_evict_big_inode - clean up the ntfs specific part of an inode

 * @vi:		vfs inode pending annihilation

 *

 * When the VFS is going to remove an inode from memory, ntfs_clear_big_inode()

 * is called, which deallocates all memory belonging to the NTFS specific part

 * of the inode and returns.

 *

 * If the MFT record is dirty, we commit it before doing anything else.

 Committing the inode also commits all extent inodes. */

 FIXME:  Do something!!!

 NTFS_RW */

 No need to lock at this stage as no one else has a reference. */

 Release the base inode if we are holding it. */

/**

 * ntfs_show_options - show mount options in /proc/mounts

 * @sf:		seq_file in which to write our mount options

 * @root:	root of the mounted tree whose mount options to display

 *

 * Called by the VFS once for each mounted ntfs volume when someone reads

 * /proc/mounts in order to display the NTFS specific mount options of each

 * mount. The mount options of fs specified by @root are written to the seq file

 * @sf and success is returned.

/**

 * ntfs_truncate - called when the i_size of an ntfs inode is changed

 * @vi:		inode for which the i_size was changed

 *

 * We only support i_size changes for normal files at present, i.e. not

 * compressed and not encrypted.  This is enforced in ntfs_setattr(), see

 * below.

 *

 * The kernel guarantees that @vi is a regular file (S_ISREG() is true) and

 * that the change is allowed.

 *

 * This implies for us that @vi is a file inode rather than a directory, index,

 * or attribute inode as well as that @vi is a base inode.

 *

 * Returns 0 on success or -errno on error.

 *

 * Called with ->i_mutex held.

	/*

	 * Lock the runlist for writing and map the mft record to ensure it is

	 * safe to mess with the attribute runlist and sizes.

	/*

	 * The i_size of the vfs inode is the new size for the attribute value.

 The current size of the attribute value is the old size. */

 Calculate the new allocated size. */

 The current allocated size is the old allocated size. */

	/*

	 * The change in the file size.  This will be 0 if no change, >0 if the

	 * size is growing, and <0 if the size is shrinking.

 As above for the allocated size. */

	/*

	 * If neither the size nor the allocation are being changed there is

	 * nothing to do.

 If the size is changing, check if new size is allowed in $AttrDef. */

 Reset the vfs inode size to the old size. */

 Resize the attribute record to best fit the new attribute size. */

 The resize succeeded! */

 Update the sizes in the ntfs inode and all is done. */

		/*

		 * Note ntfs_resident_attr_value_resize() has already done any

		 * necessary data clearing in the attribute record.  When the

		 * file is being shrunk vmtruncate() will already have cleared

		 * the top part of the last partial page, i.e. since this is

		 * the resident case this is the page with index 0.  However,

		 * when the file is being expanded, the page cache page data

		 * between the old data_size, i.e. old_size, and the new_size

		 * has not been zeroed.  Fortunately, we do not need to zero it

		 * either since on one hand it will either already be zero due

		 * to both readpage and writepage clearing partial page data

		 * beyond i_size in which case there is nothing to do or in the

		 * case of the file being mmap()ped at the same time, POSIX

		 * specifies that the behaviour is unspecified thus we do not

		 * have to do anything.  This means that in our implementation

		 * in the rare case that the file is mmap()ped and a write

		 * occurred into the mmap()ped region just beyond the file size

		 * and writepage has not yet been called to write out the page

		 * (which would clear the area beyond the file size) and we now

		 * extend the file size to incorporate this dirty region

		 * outside the file size, a write of the page would result in

		 * this data being written to disk instead of being cleared.

		 * Given both POSIX and the Linux mmap(2) man page specify that

		 * this corner case is undefined, we choose to leave it like

		 * that as this is much simpler for us as we cannot lock the

		 * relevant page now since we are holding too many ntfs locks

		 * which would result in a lock reversal deadlock.

 If the above resize failed, this must be an attribute extension. */

	/*

	 * We have to drop all the locks so we can call

	 * ntfs_attr_make_non_resident().  This could be optimised by try-

	 * locking the first page cache page and only if that fails dropping

	 * the locks, locking the page, and redoing all the locking and

	 * lookups.  While this would be a huge optimisation, it is not worth

	 * it as this is definitely a slow code path as it only ever can happen

	 * once for any given file.

	/*

	 * Not enough space in the mft record, try to make the attribute

	 * non-resident and if successful restart the truncation process.

	/*

	 * Could not make non-resident.  If this is due to this not being

	 * permitted for this attribute type or there not being enough space,

	 * try to make other attributes non-resident.  Otherwise fail.

 TODO: Not implemented from here, abort. */

 if (err == -EPERM) */

 TODO: Attempt to make other attributes non-resident.

	/*

	 * Both the attribute list attribute and the standard information

	 * attribute must remain in the base inode.  Thus, if this is one of

	 * these attributes, we have to try to move other attributes out into

	 * extent mft records instead.

 TODO: Attempt to move other attributes into extent mft

 records.

 TODO: Attempt to move this attribute to an extent mft record, but

 only if it is not already the only attribute in an mft record in

 which case there would be nothing to gain.

 There is nothing we can do to make enough space. )-: */

			/*

			 * This attribute has multiple extents.  Not yet

			 * supported.

	/*

	 * If the size is shrinking, need to reduce the initialized_size and

	 * the data_size before reducing the allocation.

		/*

		 * Make the valid size smaller (i_size is already up-to-date).

 If the allocated size is not changing, we are done. */

		/*

		 * If the size is shrinking it makes no sense for the

		 * allocation to be growing.

 if (size_change >= 0) */ {

		/*

		 * The file size is growing or staying the same but the

		 * allocation can be shrinking, growing or staying the same.

			/*

			 * We need to extend the allocation and possibly update

			 * the data size.  If we are updating the data size,

			 * since we are not touching the initialized_size we do

			 * not need to worry about the actual data on disk.

			 * And as far as the page cache is concerned, there

			 * will be no pages beyond the old data size and any

			 * partial region in the last page between the old and

			 * new data size (or the end of the page if the new

			 * data size is outside the page) does not need to be

			 * modified as explained above for the resident

			 * attribute truncate case.  To do this, we simply drop

			 * the locks we hold and leave all the work to our

			 * friendly helper ntfs_attr_extend_allocation().

			/*

			 * ntfs_attr_extend_allocation() will have done error

			 * output already.

 alloc_change < 0 */

 Free the clusters. */

 Truncate the runlist. */

	/*

	 * If the runlist truncation failed and/or the search context is no

	 * longer valid, we cannot resize the attribute record or build the

	 * mapping pairs array thus we mark the inode bad so that no access to

	 * the freed clusters can happen.

 Get the size for the shrunk mapping pairs array for the runlist. */

	/*

	 * Shrink the attribute record for the new mapping pairs array.  Note,

	 * this cannot fail since we are making the attribute smaller thus by

	 * definition there is enough space to do so.

	/*

	 * Generate the mapping pairs array directly into the attribute record.

 Update the allocated/compressed size as well as the highest vcn. */

	/*

	 * We have shrunk the allocation.  If this is a shrinking truncate we

	 * have already dealt with the initialized_size and the data_size above

	 * and we are done.  If the truncate is only changing the allocation

	 * and not the data_size, we are also done.  If this is an extending

	 * truncate, need to extend the data_size now which is ensured by the

	 * fact that @size_change is positive.

	/*

	 * If the size is growing, need to update it now.  If it is shrinking,

	 * we have already updated it above (before the allocation change).

 Ensure the modified mft record is written out. */

 Update the mtime and ctime on the base inode. */

	/* normally ->truncate shouldn't update ctime or mtime,

	 * but ntfs did before so it got a copy & paste version

	 * of file_update_time.  one day someone should fix this

	 * for real.

/**

 * ntfs_truncate_vfs - wrapper for ntfs_truncate() that has no return value

 * @vi:		inode for which the i_size was changed

 *

 * Wrapper for ntfs_truncate() that has no return value.

 *

 * See ntfs_truncate() description above for details.

/**

 * ntfs_setattr - called from notify_change() when an attribute is being changed

 * @mnt_userns:	user namespace of the mount the inode was found from

 * @dentry:	dentry whose attributes to change

 * @attr:	structure describing the attributes and the changes

 *

 * We have to trap VFS attempts to truncate the file described by @dentry as

 * soon as possible, because we do not implement changes in i_size yet.  So we

 * abort all i_size changes here.

 *

 * We also abort all changes of user, group, and mode as we do not implement

 * the NTFS ACLs yet.

 *

 * Called with ->i_mutex held.

 We do not support NTFS ACLs yet. */

			/*

			 * FIXME: For now we do not support resizing of

			 * compressed or encrypted files yet.

			/*

			 * We skipped the truncate but must still update

			 * timestamps.

/**

 * ntfs_write_inode - write out a dirty inode

 * @vi:		inode to write out

 * @sync:	if true, write out synchronously

 *

 * Write out a dirty inode to disk including any extent inodes if present.

 *

 * If @sync is true, commit the inode to disk and wait for io completion.  This

 * is done using write_mft_record().

 *

 * If @sync is false, just schedule the write to happen but do not wait for i/o

 * completion.  In 2.6 kernels, scheduling usually happens just by virtue of

 * marking the page (and in this case mft record) dirty but we do not implement

 * this yet as write_mft_record() largely ignores the @sync parameter and

 * always performs synchronous writes.

 *

 * Return 0 on success and -errno on error.

	/*

	 * Dirty attribute inodes are written via their real inodes so just

	 * clean them here.  Access time updates are taken care off when the

	 * real inode is written.

 Map, pin, and lock the mft record belonging to the inode. */

 Update the access times in the standard information attribute. */

 Update the access times if they have changed. */

	/*

	 * If we just modified the standard information attribute we need to

	 * mark the mft record it is in dirty.  We do this manually so that

	 * mark_inode_dirty() is not called which would redirty the inode and

	 * hence result in an infinite loop of trying to write the inode.

	 * There is no need to mark the base inode nor the base mft record

	 * dirty, since we are going to write this mft record below in any case

	 * and the base mft record may actually not have been modified so it

	 * might not need to be written out.

	 * NOTE: It is not a problem when the inode for $MFT itself is being

	 * written out as mark_ntfs_record_dirty() will only set I_DIRTY_PAGES

	 * on the $MFT inode and hence ntfs_write_inode() will not be

	 * re-invoked because of it which in turn is ok since the dirtied mft

	 * record will be cleaned and written out to disk below, i.e. before

	 * this function returns.

 Now the access times are updated, write the base mft record. */

 Write all attached extent mft records. */

 NTFS_RW */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * mst.c - NTFS multi sector transfer protection handling code. Part of the

 *	   Linux-NTFS project.

 *

 * Copyright (c) 2001-2004 Anton Altaparmakov

/**

 * post_read_mst_fixup - deprotect multi sector transfer protected data

 * @b:		pointer to the data to deprotect

 * @size:	size in bytes of @b

 *

 * Perform the necessary post read multi sector transfer fixup and detect the

 * presence of incomplete multi sector transfers. - In that case, overwrite the

 * magic of the ntfs record header being processed with "BAAD" (in memory only!)

 * and abort processing.

 *

 * Return 0 on success and -EINVAL on error ("BAAD" magic will be present).

 *

 * NOTE: We consider the absence / invalidity of an update sequence array to

 * mean that the structure is not protected at all and hence doesn't need to

 * be fixed up. Thus, we return success and not failure in this case. This is

 * in contrast to pre_write_mst_fixup(), see below.

 Setup the variables. */

 Decrement usa_count to get number of fixups. */

 Size and alignment checks. */

 Position of usn in update sequence array. */

	/*

	 * The update sequence number which has to be equal to each of the

	 * u16 values before they are fixed up. Note no need to care for

	 * endianness since we are comparing and moving data for on disk

	 * structures which means the data is consistent. - If it is

	 * consistenty the wrong endianness it doesn't make any difference.

	/*

	 * Position in protected data of first u16 that needs fixing up.

	/*

	 * Check for incomplete multi sector transfer(s).

			/*

			 * Incomplete multi sector transfer detected! )-:

			 * Set the magic to "BAAD" and return failure.

			 * Note that magic_BAAD is already converted to le32.

 Re-setup the variables. */

 Fixup all sectors. */

		/*

		 * Increment position in usa and restore original data from

		 * the usa into the data buffer.

 Increment position in data as well. */

/**

 * pre_write_mst_fixup - apply multi sector transfer protection

 * @b:		pointer to the data to protect

 * @size:	size in bytes of @b

 *

 * Perform the necessary pre write multi sector transfer fixup on the data

 * pointer to by @b of @size.

 *

 * Return 0 if fixup applied (success) or -EINVAL if no fixup was performed

 * (assumed not needed). This is in contrast to post_read_mst_fixup() above.

 *

 * NOTE: We consider the absence / invalidity of an update sequence array to

 * mean that the structure is not subject to protection and hence doesn't need

 * to be fixed up. This means that you have to create a valid update sequence

 * array header in the ntfs record before calling this function, otherwise it

 * will fail (the header needs to contain the position of the update sequence

 * array together with the number of elements in the array). You also need to

 * initialise the update sequence number before calling this function

 * otherwise a random word will be used (whatever was in the record at that

 * position at that time).

 Sanity check + only fixup if it makes sense. */

 Setup the variables. */

 Decrement usa_count to get number of fixups. */

 Size and alignment checks. */

 Position of usn in update sequence array. */

	/*

	 * Cyclically increment the update sequence number

	 * (skipping 0 and -1, i.e. 0xffff).

 Position in data of first u16 that needs fixing up. */

 Fixup all sectors. */

		/*

		 * Increment the position in the usa and save the

		 * original data from the data buffer into the usa.

 Apply fixup to data. */

 Increment position in data as well. */

/**

 * post_write_mst_fixup - fast deprotect multi sector transfer protected data

 * @b:		pointer to the data to deprotect

 *

 * Perform the necessary post write multi sector transfer fixup, not checking

 * for any errors, because we assume we have just used pre_write_mst_fixup(),

 * thus the data will be fine or we would never have gotten here.

 Position of usn in update sequence array. */

 Position in protected data of first u16 that needs fixing up. */

 Fixup all sectors. */

		/*

		 * Increment position in usa and restore original data from

		 * the usa into the data buffer.

 Increment position in data as well. */

 SPDX-License-Identifier: GPL-2.0-or-later

/**

 * runlist.c - NTFS runlist handling code.  Part of the Linux-NTFS project.

 *

 * Copyright (c) 2001-2007 Anton Altaparmakov

 * Copyright (c) 2002-2005 Richard Russon

/**

 * ntfs_rl_mm - runlist memmove

 *

 * It is up to the caller to serialize access to the runlist @base.

/**

 * ntfs_rl_mc - runlist memory copy

 *

 * It is up to the caller to serialize access to the runlists @dstbase and

 * @srcbase.

/**

 * ntfs_rl_realloc - Reallocate memory for runlists

 * @rl:		original runlist

 * @old_size:	number of runlist elements in the original runlist @rl

 * @new_size:	number of runlist elements we need space for

 *

 * As the runlists grow, more memory will be required.  To prevent the

 * kernel having to allocate and reallocate large numbers of small bits of

 * memory, this function returns an entire page of memory.

 *

 * It is up to the caller to serialize access to the runlist @rl.

 *

 * N.B.  If the new allocation doesn't require a different number of pages in

 *       memory, the function will return the original pointer.

 *

 * On success, return a pointer to the newly allocated, or recycled, memory.

 * On error, return -errno. The following error codes are defined:

 *	-ENOMEM	- Not enough memory to allocate runlist array.

 *	-EINVAL	- Invalid parameters were passed in.

/**

 * ntfs_rl_realloc_nofail - Reallocate memory for runlists

 * @rl:		original runlist

 * @old_size:	number of runlist elements in the original runlist @rl

 * @new_size:	number of runlist elements we need space for

 *

 * As the runlists grow, more memory will be required.  To prevent the

 * kernel having to allocate and reallocate large numbers of small bits of

 * memory, this function returns an entire page of memory.

 *

 * This function guarantees that the allocation will succeed.  It will sleep

 * for as long as it takes to complete the allocation.

 *

 * It is up to the caller to serialize access to the runlist @rl.

 *

 * N.B.  If the new allocation doesn't require a different number of pages in

 *       memory, the function will return the original pointer.

 *

 * On success, return a pointer to the newly allocated, or recycled, memory.

 * On error, return -errno. The following error codes are defined:

 *	-ENOMEM	- Not enough memory to allocate runlist array.

 *	-EINVAL	- Invalid parameters were passed in.

/**

 * ntfs_are_rl_mergeable - test if two runlists can be joined together

 * @dst:	original runlist

 * @src:	new runlist to test for mergeability with @dst

 *

 * Test if two runlists can be joined together. For this, their VCNs and LCNs

 * must be adjacent.

 *

 * It is up to the caller to serialize access to the runlists @dst and @src.

 *

 * Return: true   Success, the runlists can be merged.

 *	   false  Failure, the runlists cannot be merged.

 We can merge unmapped regions even if they are misaligned. */

 If the runs are misaligned, we cannot merge them. */

 If both runs are non-sparse and contiguous, we can merge them. */

 If we are merging two holes, we can merge them. */

 Cannot merge. */

/**

 * __ntfs_rl_merge - merge two runlists without testing if they can be merged

 * @dst:	original, destination runlist

 * @src:	new runlist to merge with @dst

 *

 * Merge the two runlists, writing into the destination runlist @dst. The

 * caller must make sure the runlists can be merged or this will corrupt the

 * destination runlist.

 *

 * It is up to the caller to serialize access to the runlists @dst and @src.

/**

 * ntfs_rl_append - append a runlist after a given element

 * @dst:	original runlist to be worked on

 * @dsize:	number of elements in @dst (including end marker)

 * @src:	runlist to be inserted into @dst

 * @ssize:	number of elements in @src (excluding end marker)

 * @loc:	append the new runlist @src after this element in @dst

 *

 * Append the runlist @src after element @loc in @dst.  Merge the right end of

 * the new runlist, if necessary. Adjust the size of the hole before the

 * appended runlist.

 *

 * It is up to the caller to serialize access to the runlists @dst and @src.

 *

 * On success, return a pointer to the new, combined, runlist. Note, both

 * runlists @dst and @src are deallocated before returning so you cannot use

 * the pointers for anything any more. (Strictly speaking the returned runlist

 * may be the same as @dst but this is irrelevant.)

 *

 * On error, return -errno. Both runlists are left unmodified. The following

 * error codes are defined:

 *	-ENOMEM	- Not enough memory to allocate runlist array.

 *	-EINVAL	- Invalid parameters were passed in.

 Right end of @src needs merging. */

 End of the inserted runs. */

 First, check if the right hand end needs merging. */

 Space required: @dst size + @src size, less one if we merged. */

	/*

	 * We are guaranteed to succeed from here so can start modifying the

	 * original runlists.

 First, merge the right hand end, if necessary. */

 First run after the @src runs that have been inserted. */

 Move the tail of @dst out of the way, then copy in @src. */

 Adjust the size of the preceding hole. */

 We may have changed the length of the file, so fix the end marker */

/**

 * ntfs_rl_insert - insert a runlist into another

 * @dst:	original runlist to be worked on

 * @dsize:	number of elements in @dst (including end marker)

 * @src:	new runlist to be inserted

 * @ssize:	number of elements in @src (excluding end marker)

 * @loc:	insert the new runlist @src before this element in @dst

 *

 * Insert the runlist @src before element @loc in the runlist @dst. Merge the

 * left end of the new runlist, if necessary. Adjust the size of the hole

 * after the inserted runlist.

 *

 * It is up to the caller to serialize access to the runlists @dst and @src.

 *

 * On success, return a pointer to the new, combined, runlist. Note, both

 * runlists @dst and @src are deallocated before returning so you cannot use

 * the pointers for anything any more. (Strictly speaking the returned runlist

 * may be the same as @dst but this is irrelevant.)

 *

 * On error, return -errno. Both runlists are left unmodified. The following

 * error codes are defined:

 *	-ENOMEM	- Not enough memory to allocate runlist array.

 *	-EINVAL	- Invalid parameters were passed in.

 Left end of @src needs merging. */

 Discontinuity between @dst and @src. */

 End of the inserted runs. */

	/*

	 * disc => Discontinuity between the end of @dst and the start of @src.

	 *	   This means we might need to insert a "not mapped" run.

	/*

	 * Space required: @dst size + @src size, less one if we merged, plus

	 * one if there was a discontinuity.

	/*

	 * We are guaranteed to succeed from here so can start modifying the

	 * original runlist.

	/*

	 * First run after the @src runs that have been inserted.

	 * Nominally,  @marker equals @loc + @ssize, i.e. location + number of

	 * runs in @src.  However, if @left, then the first run in @src has

	 * been merged with one in @dst.  And if @disc, then @dst and @src do

	 * not meet and we need an extra run to fill the gap.

 Move the tail of @dst out of the way, then copy in @src. */

 Adjust the VCN of the first run after the insertion... */

 ... and the length. */

 Writing beyond the end of the file and there is a discontinuity. */

/**

 * ntfs_rl_replace - overwrite a runlist element with another runlist

 * @dst:	original runlist to be worked on

 * @dsize:	number of elements in @dst (including end marker)

 * @src:	new runlist to be inserted

 * @ssize:	number of elements in @src (excluding end marker)

 * @loc:	index in runlist @dst to overwrite with @src

 *

 * Replace the runlist element @dst at @loc with @src. Merge the left and

 * right ends of the inserted runlist, if necessary.

 *

 * It is up to the caller to serialize access to the runlists @dst and @src.

 *

 * On success, return a pointer to the new, combined, runlist. Note, both

 * runlists @dst and @src are deallocated before returning so you cannot use

 * the pointers for anything any more. (Strictly speaking the returned runlist

 * may be the same as @dst but this is irrelevant.)

 *

 * On error, return -errno. Both runlists are left unmodified. The following

 * error codes are defined:

 *	-ENOMEM	- Not enough memory to allocate runlist array.

 *	-EINVAL	- Invalid parameters were passed in.

 Left end of @src needs merging. */

 Right end of @src needs merging. */

 Start of tail of @dst. */

 End of the inserted runs. */

 First, see if the left and right ends need merging. */

	/*

	 * Allocate some space.  We will need less if the left, right, or both

	 * ends get merged.  The -1 accounts for the run being replaced.

	/*

	 * We are guaranteed to succeed from here so can start modifying the

	 * original runlists.

 First, merge the left and right ends, if necessary. */

	/*

	 * Offset of the tail of @dst.  This needs to be moved out of the way

	 * to make space for the runs to be copied from @src, i.e. the first

	 * run of the tail of @dst.

	 * Nominally, @tail equals @loc + 1, i.e. location, skipping the

	 * replaced run.  However, if @right, then one of @dst's runs is

	 * already merged into @src.

	/*

	 * First run after the @src runs that have been inserted, i.e. where

	 * the tail of @dst needs to be moved to.

	 * Nominally, @marker equals @loc + @ssize, i.e. location + number of

	 * runs in @src.  However, if @left, then the first run in @src has

	 * been merged with one in @dst.

 Move the tail of @dst out of the way, then copy in @src. */

 We may have changed the length of the file, so fix the end marker. */

/**

 * ntfs_rl_split - insert a runlist into the centre of a hole

 * @dst:	original runlist to be worked on

 * @dsize:	number of elements in @dst (including end marker)

 * @src:	new runlist to be inserted

 * @ssize:	number of elements in @src (excluding end marker)

 * @loc:	index in runlist @dst at which to split and insert @src

 *

 * Split the runlist @dst at @loc into two and insert @new in between the two

 * fragments. No merging of runlists is necessary. Adjust the size of the

 * holes either side.

 *

 * It is up to the caller to serialize access to the runlists @dst and @src.

 *

 * On success, return a pointer to the new, combined, runlist. Note, both

 * runlists @dst and @src are deallocated before returning so you cannot use

 * the pointers for anything any more. (Strictly speaking the returned runlist

 * may be the same as @dst but this is irrelevant.)

 *

 * On error, return -errno. Both runlists are left unmodified. The following

 * error codes are defined:

 *	-ENOMEM	- Not enough memory to allocate runlist array.

 *	-EINVAL	- Invalid parameters were passed in.

 Space required: @dst size + @src size + one new hole. */

	/*

	 * We are guaranteed to succeed from here so can start modifying the

	 * original runlists.

 Move the tail of @dst out of the way, then copy in @src. */

 Adjust the size of the holes either size of @src. */

/**

 * ntfs_runlists_merge - merge two runlists into one

 * @drl:	original runlist to be worked on

 * @srl:	new runlist to be merged into @drl

 *

 * First we sanity check the two runlists @srl and @drl to make sure that they

 * are sensible and can be merged. The runlist @srl must be either after the

 * runlist @drl or completely within a hole (or unmapped region) in @drl.

 *

 * It is up to the caller to serialize access to the runlists @drl and @srl.

 *

 * Merging of runlists is necessary in two cases:

 *   1. When attribute lists are used and a further extent is being mapped.

 *   2. When new clusters are allocated to fill a hole or extend a file.

 *

 * There are four possible ways @srl can be merged. It can:

 *	- be inserted at the beginning of a hole,

 *	- split the hole in two and be inserted between the two fragments,

 *	- be appended at the end of a hole, or it can

 *	- replace the whole hole.

 * It can also be appended to the end of the runlist, which is just a variant

 * of the insert case.

 *

 * On success, return a pointer to the new, combined, runlist. Note, both

 * runlists @drl and @srl are deallocated before returning so you cannot use

 * the pointers for anything any more. (Strictly speaking the returned runlist

 * may be the same as @dst but this is irrelevant.)

 *

 * On error, return -errno. Both runlists are left unmodified. The following

 * error codes are defined:

 *	-ENOMEM	- Not enough memory to allocate runlist array.

 *	-EINVAL	- Invalid parameters were passed in.

 *	-ERANGE	- The runlists overlap and cannot be merged.

 Current index into @[ds]rl. */

 First index with lcn > LCN_RL_NOT_MAPPED. */

 Index into @drl at which to insert @srl. */

 Last index into @[ds]rl. */

	int dfinal, sfinal;	/* The last index into @[ds]rl with

 Check for silly calling... */

 Check for the case where the first mapping is being done now. */

 Complete the source runlist if necessary. */

 Scan to the end of the source runlist. */

 Insert start element at the front of the runlist. */

 Skip any unmapped start element(s) in the source runlist. */

 Can't have an entirely unmapped source runlist. */

 Record the starting points. */

	/*

	 * Skip forward in @drl until we reach the position where @srl needs to

	 * be inserted. If we reach the end of @drl, @srl just needs to be

	 * appended to @drl.

 Sanity check for illegal overlaps. */

 Scan to the end of both runlists in order to know their sizes. */

 Scan to the last element with lcn >= LCN_HOLE. */

 Number of elements in drl & srl */

 End of file   */

 Start of hole */

 End of file   */

 End of hole   */

 Or we will lose an end marker. */

 We only need to care if @srl ended after @drl. */

			/*

			 * We need to create an unmapped runlist element in

			 * @drl or extend an existing one before adding the

			 * ENOENT terminator.

 Add an unmapped runlist element. */

 Need to set vcn if it isn't set already. */

 We now used up a slot. */

 Finally add the ENOENT terminator. */

 The merge was completed successfully. */

/**

 * ntfs_mapping_pairs_decompress - convert mapping pairs array to runlist

 * @vol:	ntfs volume on which the attribute resides

 * @attr:	attribute record whose mapping pairs array to decompress

 * @old_rl:	optional runlist in which to insert @attr's runlist

 *

 * It is up to the caller to serialize access to the runlist @old_rl.

 *

 * Decompress the attribute @attr's mapping pairs array into a runlist. On

 * success, return the decompressed runlist.

 *

 * If @old_rl is not NULL, decompressed runlist is inserted into the

 * appropriate place in @old_rl and the resultant, combined runlist is

 * returned. The original @old_rl is deallocated.

 *

 * On error, return -errno. @old_rl is left unmodified in that case.

 *

 * The following error codes are defined:

 *	-ENOMEM	- Not enough memory to allocate runlist array.

 *	-EIO	- Corrupt runlist.

 *	-EINVAL	- Invalid parameters were passed in.

 *	-ERANGE	- The two runlists overlap.

 *

 * FIXME: For now we take the conceptionally simplest approach of creating the

 * new runlist disregarding the already existing one and then splicing the

 * two into one, if that is possible (we check for overlap and discard the new

 * runlist if overlap present before returning ERR_PTR(-ERANGE)).

 Current vcn. */

 Current lcn. */

 Change in [vl]cn. */

 The output runlist. */

 Current position in mapping pairs array. */

 End of attribute. */

 Size of runlist buffer. */

	u16 rlpos;		/* Current runlist position in units of

 Current byte offset in buf. */

 Make sure attr exists and is non-resident. */

 Start at vcn = lowest_vcn and lcn 0. */

 Get start of the mapping pairs array. */

 If the mapping pairs array is valid but empty, nothing to do. */

 Current position in runlist array. */

 Allocate first page and set current runlist size to one page. */

 Insert unmapped starting element if necessary. */

		/*

		 * Allocate more memory if needed, including space for the

		 * not-mapped and terminator elements. ntfs_malloc_nofs()

		 * operates on whole pages only.

 Enter the current vcn into the current runlist element. */

		/*

		 * Get the change in vcn, i.e. the run length in clusters.

		 * Doing it this way ensures that we signextend negative values.

		 * A negative run length doesn't make any sense, but hey, I

		 * didn't make up the NTFS specs and Windows NT4 treats the run

		 * length as a signed value so that's how it is...

 The length entry is compulsory. */

		/*

		 * Assume a negative length to indicate data corruption and

		 * hence clean-up and return NULL.

		/*

		 * Enter the current run length into the current runlist

		 * element.

 Increment the current vcn by the current run length. */

		/*

		 * There might be no lcn change at all, as is the case for

		 * sparse clusters on NTFS 3.0+, in which case we set the lcn

		 * to LCN_HOLE.

 Get the lcn change which really can be negative. */

 Change the current lcn to its new value. */

			/*

			 * On NTFS 1.2-, apparently can have lcn == -1 to

			 * indicate a hole. But we haven't verified ourselves

			 * whether it is really the lcn or the deltaxcn that is

			 * -1. So if either is found give us a message so we

			 * can investigate it further!

 Check lcn is not below -1. */

 Enter the current lcn into the runlist element. */

 Get to the next runlist element. */

 Increment the buffer position to the next mapping pair. */

	/*

	 * If there is a highest_vcn specified, it must be equal to the final

	 * vcn in the runlist - 1, or something has gone badly wrong.

 Setup not mapped runlist element if this is the base extent. */

		/*

		 * A highest_vcn of zero means this is a single extent

		 * attribute so simply terminate the runlist with LCN_ENOENT).

			/*

			 * If there is a difference between the highest_vcn and

			 * the highest cluster, the runlist is either corrupt

			 * or, more likely, there are more extents following

			 * this one.

 Not the base extent. There may be more extents to follow. */

 Setup terminating runlist element. */

 If no existing runlist was specified, we are done. */

 Now combine the new and old runlists checking for overlaps. */

/**

 * ntfs_rl_vcn_to_lcn - convert a vcn into a lcn given a runlist

 * @rl:		runlist to use for conversion

 * @vcn:	vcn to convert

 *

 * Convert the virtual cluster number @vcn of an attribute into a logical

 * cluster number (lcn) of a device using the runlist @rl to map vcns to their

 * corresponding lcns.

 *

 * It is up to the caller to serialize access to the runlist @rl.

 *

 * Since lcns must be >= 0, we use negative return codes with special meaning:

 *

 * Return code		Meaning / Description

 * ==================================================

 *  LCN_HOLE		Hole / not allocated on disk.

 *  LCN_RL_NOT_MAPPED	This is part of the runlist which has not been

 *			inserted into the runlist yet.

 *  LCN_ENOENT		There is no such vcn in the attribute.

 *

 * Locking: - The caller must have locked the runlist (for reading or writing).

 *	    - This function does not touch the lock, nor does it modify the

 *	      runlist.

	/*

	 * If rl is NULL, assume that we have found an unmapped runlist. The

	 * caller can then attempt to map it and fail appropriately if

	 * necessary.

 Catch out of lower bounds vcn. */

	/*

	 * The terminator element is setup to the correct value, i.e. one of

	 * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.

 Just in case... We could replace this with BUG() some day. */

/**

 * ntfs_rl_find_vcn_nolock - find a vcn in a runlist

 * @rl:		runlist to search

 * @vcn:	vcn to find

 *

 * Find the virtual cluster number @vcn in the runlist @rl and return the

 * address of the runlist element containing the @vcn on success.

 *

 * Return NULL if @rl is NULL or @vcn is in an unmapped part/out of bounds of

 * the runlist.

 *

 * Locking: The runlist must be locked on entry.

/**

 * ntfs_get_nr_significant_bytes - get number of bytes needed to store a number

 * @n:		number for which to get the number of bytes for

 *

 * Return the number of bytes required to store @n unambiguously as

 * a signed number.

 *

 * This is used in the context of the mapping pairs array to determine how

 * many bytes will be needed in the array to store a given logical cluster

 * number (lcn) or a specific run length.

 *

 * Return the number of bytes written.  This function cannot fail.

 If the sign bit is wrong, we need an extra byte. */

/**

 * ntfs_get_size_for_mapping_pairs - get bytes needed for mapping pairs array

 * @vol:	ntfs volume (needed for the ntfs version)

 * @rl:		locked runlist to determine the size of the mapping pairs of

 * @first_vcn:	first vcn which to include in the mapping pairs array

 * @last_vcn:	last vcn which to include in the mapping pairs array

 *

 * Walk the locked runlist @rl and calculate the size in bytes of the mapping

 * pairs array corresponding to the runlist @rl, starting at vcn @first_vcn and

 * finishing with vcn @last_vcn.

 *

 * A @last_vcn of -1 means end of runlist and in that case the size of the

 * mapping pairs array corresponding to the runlist starting at vcn @first_vcn

 * and finishing at the end of the runlist is determined.

 *

 * This for example allows us to allocate a buffer of the right size when

 * building the mapping pairs array.

 *

 * If @rl is NULL, just return 1 (for the single terminator byte).

 *

 * Return the calculated size in bytes on success.  On error, return -errno.

 * The following error codes are defined:

 *	-EINVAL	- Run list contains unmapped elements.  Make sure to only pass

 *		  fully mapped runlists to this function.

 *	-EIO	- The runlist is corrupt.

 *

 * Locking: @rl must be locked on entry (either for reading or writing), it

 *	    remains locked throughout, and is left locked upon return.

 Skip to runlist element containing @first_vcn. */

 Always need the termining zero byte. */

 Do the first partial run if present. */

 We know rl->length != 0 already. */

		/*

		 * If @stop_vcn is given and finishes inside this run, cap the

		 * run length.

 Header byte + length. */

		/*

		 * If the logical cluster number (lcn) denotes a hole and we

		 * are on NTFS 3.0+, we don't store it at all, i.e. we need

		 * zero space.  On earlier NTFS versions we just store the lcn.

		 * Note: this assumes that on NTFS 1.2-, holes are stored with

		 * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).

 Change in lcn. */

 Go to next runlist element. */

 Do the full runs. */

		/*

		 * If @stop_vcn is given and finishes inside this run, cap the

		 * run length.

 Header byte + length. */

		/*

		 * If the logical cluster number (lcn) denotes a hole and we

		 * are on NTFS 3.0+, we don't store it at all, i.e. we need

		 * zero space.  On earlier NTFS versions we just store the lcn.

		 * Note: this assumes that on NTFS 1.2-, holes are stored with

		 * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).

 Change in lcn. */

/**

 * ntfs_write_significant_bytes - write the significant bytes of a number

 * @dst:	destination buffer to write to

 * @dst_max:	pointer to last byte of destination buffer for bounds checking

 * @n:		number whose significant bytes to write

 *

 * Store in @dst, the minimum bytes of the number @n which are required to

 * identify @n unambiguously as a signed number, taking care not to exceed

 * @dest_max, the maximum position within @dst to which we are allowed to

 * write.

 *

 * This is used when building the mapping pairs array of a runlist to compress

 * a given logical cluster number (lcn) or a specific run length to the minimum

 * size possible.

 *

 * Return the number of bytes written on success.  On error, i.e. the

 * destination buffer @dst is too small, return -ENOSPC.

 If the sign bit is wrong, we need an extra byte. */

/**

 * ntfs_mapping_pairs_build - build the mapping pairs array from a runlist

 * @vol:	ntfs volume (needed for the ntfs version)

 * @dst:	destination buffer to which to write the mapping pairs array

 * @dst_len:	size of destination buffer @dst in bytes

 * @rl:		locked runlist for which to build the mapping pairs array

 * @first_vcn:	first vcn which to include in the mapping pairs array

 * @last_vcn:	last vcn which to include in the mapping pairs array

 * @stop_vcn:	first vcn outside destination buffer on success or -ENOSPC

 *

 * Create the mapping pairs array from the locked runlist @rl, starting at vcn

 * @first_vcn and finishing with vcn @last_vcn and save the array in @dst.

 * @dst_len is the size of @dst in bytes and it should be at least equal to the

 * value obtained by calling ntfs_get_size_for_mapping_pairs().

 *

 * A @last_vcn of -1 means end of runlist and in that case the mapping pairs

 * array corresponding to the runlist starting at vcn @first_vcn and finishing

 * at the end of the runlist is created.

 *

 * If @rl is NULL, just write a single terminator byte to @dst.

 *

 * On success or -ENOSPC error, if @stop_vcn is not NULL, *@stop_vcn is set to

 * the first vcn outside the destination buffer.  Note that on error, @dst has

 * been filled with all the mapping pairs that will fit, thus it can be treated

 * as partial success, in that a new attribute extent needs to be created or

 * the next extent has to be used and the mapping pairs build has to be

 * continued with @first_vcn set to *@stop_vcn.

 *

 * Return 0 on success and -errno on error.  The following error codes are

 * defined:

 *	-EINVAL	- Run list contains unmapped elements.  Make sure to only pass

 *		  fully mapped runlists to this function.

 *	-EIO	- The runlist is corrupt.

 *	-ENOSPC	- The destination buffer is too small.

 *

 * Locking: @rl must be locked on entry (either for reading or writing), it

 *	    remains locked throughout, and is left locked upon return.

 Terminator byte. */

 Skip to runlist element containing @first_vcn. */

	/*

	 * @dst_max is used for bounds checking in

	 * ntfs_write_significant_bytes().

 Do the first partial run if present. */

 We know rl->length != 0 already. */

		/*

		 * If @stop_vcn is given and finishes inside this run, cap the

		 * run length.

 Write length. */

		/*

		 * If the logical cluster number (lcn) denotes a hole and we

		 * are on NTFS 3.0+, we don't store it at all, i.e. we need

		 * zero space.  On earlier NTFS versions we just write the lcn

		 * change.  FIXME: Do we need to write the lcn change or just

		 * the lcn in that case?  Not sure as I have never seen this

		 * case on NT4. - We assume that we just need to write the lcn

		 * change until someone tells us otherwise... (AIA)

 Write change in lcn. */

 Update header byte. */

 Position at next mapping pairs array element. */

 Go to next runlist element. */

 Do the full runs. */

		/*

		 * If @stop_vcn is given and finishes inside this run, cap the

		 * run length.

 Write length. */

		/*

		 * If the logical cluster number (lcn) denotes a hole and we

		 * are on NTFS 3.0+, we don't store it at all, i.e. we need

		 * zero space.  On earlier NTFS versions we just write the lcn

		 * change.  FIXME: Do we need to write the lcn change or just

		 * the lcn in that case?  Not sure as I have never seen this

		 * case on NT4. - We assume that we just need to write the lcn

		 * change until someone tells us otherwise... (AIA)

 Write change in lcn. */

 Update header byte. */

 Position at next mapping pairs array element. */

 Success. */

 Set stop vcn. */

 Add terminator byte. */

/**

 * ntfs_rl_truncate_nolock - truncate a runlist starting at a specified vcn

 * @vol:	ntfs volume (needed for error output)

 * @runlist:	runlist to truncate

 * @new_length:	the new length of the runlist in VCNs

 *

 * Truncate the runlist described by @runlist as well as the memory buffer

 * holding the runlist elements to a length of @new_length VCNs.

 *

 * If @new_length lies within the runlist, the runlist elements with VCNs of

 * @new_length and above are discarded.  As a special case if @new_length is

 * zero, the runlist is discarded and set to NULL.

 *

 * If @new_length lies beyond the runlist, a sparse runlist element is added to

 * the end of the runlist @runlist or if the last runlist element is a sparse

 * one already, this is extended.

 *

 * Note, no checking is done for unmapped runlist elements.  It is assumed that

 * the caller has mapped any elements that need to be mapped already.

 *

 * Return 0 on success and -errno on error.

 *

 * Locking: The caller must hold @runlist->lock for writing.

		/*

		 * Create a runlist consisting of a sparse runlist element of

		 * length @new_length followed by a terminator runlist element.

 Find @new_length in the runlist. */

	/*

	 * If not at the end of the runlist we need to shrink it.

	 * If at the end of the runlist we need to expand it.

 Determine the runlist size. */

 Truncate the run. */

		/*

		 * If a run was partially truncated, make the following runlist

		 * element a terminator.

 Reallocate memory if necessary. */

 !rl->length && */ new_length > rl->vcn)) {

		/*

		 * If there is a previous runlist element and it is a sparse

		 * one, extend it.  Otherwise need to add a new, sparse runlist

		 * element.

 Determine the runlist size. */

 Reallocate memory if necessary. */

			/*

			 * Set @rl to the same runlist element in the new

			 * runlist as before in the old runlist.

 Add a new, sparse runlist element. */

 Add a new terminator runlist element. */

 if (unlikely(!rl->length && new_length == rl->vcn)) */ {

 Runlist already has same size as requested. */

/**

 * ntfs_rl_punch_nolock - punch a hole into a runlist

 * @vol:	ntfs volume (needed for error output)

 * @runlist:	runlist to punch a hole into

 * @start:	starting VCN of the hole to be created

 * @length:	size of the hole to be created in units of clusters

 *

 * Punch a hole into the runlist @runlist starting at VCN @start and of size

 * @length clusters.

 *

 * Return 0 on success and -errno on error, in which case @runlist has not been

 * modified.

 *

 * If @start and/or @start + @length are outside the runlist return error code

 * -ENOENT.

 *

 * If the runlist contains unmapped or error elements between @start and @start

 * + @length return error code -EINVAL.

 *

 * Locking: The caller must hold @runlist->lock for writing.

 Find @start in the runlist. */

 Find @end in the runlist. */

 Verify there are no unmapped or error elements. */

 Check the last element. */

 This covers @start being out of bounds, too. */

 Determine the runlist size. */

 If @start is in a hole simply extend the hole. */

		/*

		 * If both @start and @end are in the same sparse run, we are

		 * done.

 Extend the hole. */

 If @end is in a hole, merge it with the current one. */

 We have done the hole.  Now deal with the remaining tail. */

 Cut out all runlist elements up to @end. */

 Adjust the beginning of the tail if necessary. */

 Only adjust the lcn if it is real. */

 Reallocate memory if the allocation changed. */

	/*

	 * If @start is at the beginning of a run things are easier as there is

	 * no need to split the first run.

		/*

		 * @start is at the beginning of a run.

		 *

		 * If the previous run is sparse, extend its hole.

		 *

		 * If @end is not in the same run, switch the run to be sparse

		 * and extend the newly created hole.

		 *

		 * Thus both of these cases reduce the problem to the above

		 * case of "@start is in a hole".

		/*

		 * The final case is when @end is in the same run as @start.

		 * For this need to split the run into two.  One run for the

		 * sparse region between the beginning of the old run, i.e.

		 * @start, and @end and one for the remaining non-sparse

		 * region, i.e. between @end and the end of the old run.

 Shift all the runs up by one. */

 Finally, setup the two split runs. */

 Only adjust the lcn if it is real. */

	/*

	 * @start is neither in a hole nor at the beginning of a run.

	 *

	 * If @end is in a hole, things are easier as simply truncating the run

	 * @start is in to end at @start - 1, deleting all runs after that up

	 * to @end, and finally extending the beginning of the run @end is in

	 * to be @start is all that is needed.

 Truncate the run containing @start. */

 Cut out all runlist elements up to @end. */

 Extend the beginning of the run @end is in to be @start. */

	/* 

	 * If @end is not in a hole there are still two cases to distinguish.

	 * Either @end is or is not in the same run as @start.

	 *

	 * The second case is easier as it can be reduced to an already solved

	 * problem by truncating the run @start is in to end at @start - 1.

	 * Then, if @end is in the next run need to split the run into a sparse

	 * run followed by a non-sparse run (already covered above) and if @end

	 * is not in the next run switching it to be sparse, again reduces the

	 * problem to the already covered case of "@start is in a hole".

		/*

		 * If @end is not in the next run, reduce the problem to the

		 * case of "@start is in a hole".

 Truncate the run containing @start. */

 Truncate the run containing @start. */

		/*

		 * @end is in the next run, reduce the problem to the case

		 * where "@start is at the beginning of a run and @end is in

		 * the same run as @start".

 Need this in case the lcn just became negative. */

	/*

	 * The first case from above, i.e. @end is in the same run as @start.

	 * We need to split the run into three.  One run for the non-sparse

	 * region between the beginning of the old run and @start, one for the

	 * sparse region between @start and @end, and one for the remaining

	 * non-sparse region, i.e. between @end and the end of the old run.

 Shift all the runs up by two. */

 Finally, setup the three split runs. */

 NTFS_RW */

 SPDX-License-Identifier: GPL-2.0-or-later

/**

 * dir.c - NTFS kernel directory operations. Part of the Linux-NTFS project.

 *

 * Copyright (c) 2001-2007 Anton Altaparmakov

 * Copyright (c) 2002 Richard Russon

/**

 * The little endian Unicode string $I30 as a global constant.

/**

 * ntfs_lookup_inode_by_name - find an inode in a directory given its name

 * @dir_ni:	ntfs inode of the directory in which to search for the name

 * @uname:	Unicode name for which to search in the directory

 * @uname_len:	length of the name @uname in Unicode characters

 * @res:	return the found file name if necessary (see below)

 *

 * Look for an inode with name @uname in the directory with inode @dir_ni.

 * ntfs_lookup_inode_by_name() walks the contents of the directory looking for

 * the Unicode name. If the name is found in the directory, the corresponding

 * inode number (>= 0) is returned as a mft reference in cpu format, i.e. it

 * is a 64-bit number containing the sequence number.

 *

 * On error, a negative value is returned corresponding to the error code. In

 * particular if the inode is not found -ENOENT is returned. Note that you

 * can't just check the return value for being negative, you have to check the

 * inode number for being negative which you can extract using MREC(return

 * value).

 *

 * Note, @uname_len does not include the (optional) terminating NULL character.

 *

 * Note, we look for a case sensitive match first but we also look for a case

 * insensitive match at the same time. If we find a case insensitive match, we

 * save that for the case that we don't find an exact match, where we return

 * the case insensitive match and setup @res (which we allocate!) with the mft

 * reference, the file name type, length and with a copy of the little endian

 * Unicode file name itself. If we match a file name which is in the DOS name

 * space, we only return the mft reference and file name type in @res.

 * ntfs_lookup() then uses this to find the long file name in the inode itself.

 * This is to avoid polluting the dcache with short file names. We want them to

 * work but we don't care for how quickly one can access them. This also fixes

 * the dcache aliasing issues.

 *

 * Locking:  - Caller must hold i_mutex on the directory.

 *	     - Each page cache page in the index allocation mapping must be

 *	       locked whilst being accessed otherwise we may find a corrupt

 *	       page due to it being under ->writepage at the moment which

 *	       applies the mst protection fixups before writing out and then

 *	       removes them again after the write is complete after which it 

 *	       unlocks the page.

 Get hold of the mft record for the directory. */

 Find the index root attribute in the mft record. */

 Get to the index root value (it's been verified in read_inode). */

 The first index entry. */

	/*

	 * Loop until we exceed valid memory (corruption case) or until we

	 * reach the last entry.

 Bounds checks. */

		/*

		 * The last entry cannot contain a name. It can however contain

		 * a pointer to a child node in the B+tree so we just break out.

		/*

		 * We perform a case sensitive comparison and if that matches

		 * we are done and return the mft reference of the inode (i.e.

		 * the inode number together with the sequence number for

		 * consistency checking). We convert it to cpu format before

		 * returning.

			/*

			 * We have a perfect match, so we don't need to care

			 * about having matched imperfectly before, so we can

			 * free name and set *res to NULL.

			 * However, if the perfect match is a short file name,

			 * we need to signal this through *res, so that

			 * ntfs_lookup() can fix dcache aliasing issues.

			 * As an optimization we just reuse an existing

			 * allocation of *res.

		/*

		 * For a case insensitive mount, we also perform a case

		 * insensitive comparison (provided the file name is not in the

		 * POSIX namespace). If the comparison matches, and the name is

		 * in the WIN32 namespace, we cache the filename in *res so

		 * that the caller, ntfs_lookup(), can work on it. If the

		 * comparison matches, and the name is in the DOS namespace, we

		 * only cache the mft reference and the file name type (we set

		 * the name length to zero for simplicity).

 Only one case insensitive matching name allowed. */

		/*

		 * Not a perfect match, need to do full blown collation so we

		 * know which way in the B+tree we have to go.

		/*

		 * If uname collates before the name of the current entry, there

		 * is definitely no such name in this index but we might need to

		 * descend into the B+tree so we just break out of the loop.

 The names are not equal, continue the search. */

		/*

		 * Names match with case insensitive comparison, now try the

		 * case sensitive comparison, which is required for proper

		 * collation.

		/*

		 * Perfect match, this will never happen as the

		 * ntfs_are_names_equal() call will have gotten a match but we

		 * still treat it correctly.

	/*

	 * We have finished with this index without success. Check for the

	 * presence of a child node and if not present return -ENOENT, unless

	 * we have got a matching name cached in name in which case return the

	 * mft reference associated with it.

 Child node present, descend into it. */

 Consistency check: Verify that an index allocation exists. */

 Get the starting vcn of the index_block holding the child node. */

	/*

	 * We are done with the index root and the mft record. Release them,

	 * otherwise we deadlock with ntfs_map_page().

	/*

	 * Convert vcn to index into the index allocation attribute in units

	 * of PAGE_SIZE and map the page cache page, reading it from

	 * disk if necessary.

 Get to the index allocation block. */

 Bounds checks. */

 Catch multi sector transfer fixup errors. */

 The first index entry. */

	/*

	 * Iterate similar to above big loop but applied to index buffer, thus

	 * loop until we exceed valid memory (corruption case) or until we

	 * reach the last entry.

 Bounds check. */

		/*

		 * The last entry cannot contain a name. It can however contain

		 * a pointer to a child node in the B+tree so we just break out.

		/*

		 * We perform a case sensitive comparison and if that matches

		 * we are done and return the mft reference of the inode (i.e.

		 * the inode number together with the sequence number for

		 * consistency checking). We convert it to cpu format before

		 * returning.

			/*

			 * We have a perfect match, so we don't need to care

			 * about having matched imperfectly before, so we can

			 * free name and set *res to NULL.

			 * However, if the perfect match is a short file name,

			 * we need to signal this through *res, so that

			 * ntfs_lookup() can fix dcache aliasing issues.

			 * As an optimization we just reuse an existing

			 * allocation of *res.

		/*

		 * For a case insensitive mount, we also perform a case

		 * insensitive comparison (provided the file name is not in the

		 * POSIX namespace). If the comparison matches, and the name is

		 * in the WIN32 namespace, we cache the filename in *res so

		 * that the caller, ntfs_lookup(), can work on it. If the

		 * comparison matches, and the name is in the DOS namespace, we

		 * only cache the mft reference and the file name type (we set

		 * the name length to zero for simplicity).

 Only one case insensitive matching name allowed. */

		/*

		 * Not a perfect match, need to do full blown collation so we

		 * know which way in the B+tree we have to go.

		/*

		 * If uname collates before the name of the current entry, there

		 * is definitely no such name in this index but we might need to

		 * descend into the B+tree so we just break out of the loop.

 The names are not equal, continue the search. */

		/*

		 * Names match with case insensitive comparison, now try the

		 * case sensitive comparison, which is required for proper

		 * collation.

		/*

		 * Perfect match, this will never happen as the

		 * ntfs_are_names_equal() call will have gotten a match but we

		 * still treat it correctly.

	/*

	 * We have finished with this index buffer without success. Check for

	 * the presence of a child node.

 Child node present, descend into it. */

			/* If vcn is in the same page cache page as old_vcn we

	/*

	 * No child node present, return -ENOENT, unless we have got a matching

	 * name cached in name in which case return the mft reference

	 * associated with it.

 TODO: (AIA)

 The algorithm embedded in this code will be required for the time when we

 want to support adding of entries to directories, where we require correct

 collation of file names in order not to cause corruption of the filesystem.

/**

 * ntfs_lookup_inode_by_name - find an inode in a directory given its name

 * @dir_ni:	ntfs inode of the directory in which to search for the name

 * @uname:	Unicode name for which to search in the directory

 * @uname_len:	length of the name @uname in Unicode characters

 *

 * Look for an inode with name @uname in the directory with inode @dir_ni.

 * ntfs_lookup_inode_by_name() walks the contents of the directory looking for

 * the Unicode name. If the name is found in the directory, the corresponding

 * inode number (>= 0) is returned as a mft reference in cpu format, i.e. it

 * is a 64-bit number containing the sequence number.

 *

 * On error, a negative value is returned corresponding to the error code. In

 * particular if the inode is not found -ENOENT is returned. Note that you

 * can't just check the return value for being negative, you have to check the

 * inode number for being negative which you can extract using MREC(return

 * value).

 *

 * Note, @uname_len does not include the (optional) terminating NULL character.

 Get hold of the mft record for the directory. */

 Find the index root attribute in the mft record. */

 Get to the index root value (it's been verified in read_inode). */

 The first index entry. */

	/*

	 * Loop until we exceed valid memory (corruption case) or until we

	 * reach the last entry.

 Bounds checks. */

		/*

		 * The last entry cannot contain a name. It can however contain

		 * a pointer to a child node in the B+tree so we just break out.

		/*

		 * If the current entry has a name type of POSIX, the name is

		 * case sensitive and not otherwise. This has the effect of us

		 * not being able to access any POSIX file names which collate

		 * after the non-POSIX one when they only differ in case, but

		 * anyone doing screwy stuff like that deserves to burn in

		 * hell... Doing that kind of stuff on NT4 actually causes

		 * corruption on the partition even when using SP6a and Linux

		 * is not involved at all.

		/*

		 * If the names match perfectly, we are done and return the

		 * mft reference of the inode (i.e. the inode number together

		 * with the sequence number for consistency checking. We

		 * convert it to cpu format before returning.

		/*

		 * Not a perfect match, need to do full blown collation so we

		 * know which way in the B+tree we have to go.

		/*

		 * If uname collates before the name of the current entry, there

		 * is definitely no such name in this index but we might need to

		 * descend into the B+tree so we just break out of the loop.

 The names are not equal, continue the search. */

		/*

		 * Names match with case insensitive comparison, now try the

		 * case sensitive comparison, which is required for proper

		 * collation.

		/*

		 * Perfect match, this will never happen as the

		 * ntfs_are_names_equal() call will have gotten a match but we

		 * still treat it correctly.

	/*

	 * We have finished with this index without success. Check for the

	 * presence of a child node.

 No child node, return -ENOENT. */

 Child node present, descend into it. */

 Consistency check: Verify that an index allocation exists. */

 Get the starting vcn of the index_block holding the child node. */

	/*

	 * We are done with the index root and the mft record. Release them,

	 * otherwise we deadlock with ntfs_map_page().

	/*

	 * Convert vcn to index into the index allocation attribute in units

	 * of PAGE_SIZE and map the page cache page, reading it from

	 * disk if necessary.

 Get to the index allocation block. */

 Bounds checks. */

 Catch multi sector transfer fixup errors. */

 The first index entry. */

	/*

	 * Iterate similar to above big loop but applied to index buffer, thus

	 * loop until we exceed valid memory (corruption case) or until we

	 * reach the last entry.

 Bounds check. */

		/*

		 * The last entry cannot contain a name. It can however contain

		 * a pointer to a child node in the B+tree so we just break out.

		/*

		 * If the current entry has a name type of POSIX, the name is

		 * case sensitive and not otherwise. This has the effect of us

		 * not being able to access any POSIX file names which collate

		 * after the non-POSIX one when they only differ in case, but

		 * anyone doing screwy stuff like that deserves to burn in

		 * hell... Doing that kind of stuff on NT4 actually causes

		 * corruption on the partition even when using SP6a and Linux

		 * is not involved at all.

		/*

		 * If the names match perfectly, we are done and return the

		 * mft reference of the inode (i.e. the inode number together

		 * with the sequence number for consistency checking. We

		 * convert it to cpu format before returning.

		/*

		 * Not a perfect match, need to do full blown collation so we

		 * know which way in the B+tree we have to go.

		/*

		 * If uname collates before the name of the current entry, there

		 * is definitely no such name in this index but we might need to

		 * descend into the B+tree so we just break out of the loop.

 The names are not equal, continue the search. */

		/*

		 * Names match with case insensitive comparison, now try the

		 * case sensitive comparison, which is required for proper

		 * collation.

		/*

		 * Perfect match, this will never happen as the

		 * ntfs_are_names_equal() call will have gotten a match but we

		 * still treat it correctly.

	/*

	 * We have finished with this index buffer without success. Check for

	 * the presence of a child node.

 Child node present, descend into it. */

			/* If vcn is in the same page cache page as old_vcn we

 No child node, return -ENOENT. */

/**

 * ntfs_filldir - ntfs specific filldir method

 * @vol:	current ntfs volume

 * @ndir:	ntfs inode of current directory

 * @ia_page:	page in which the index allocation buffer @ie is in resides

 * @ie:		current index entry

 * @name:	buffer to use for the converted name

 * @actor:	what to feed the entries to

 *

 * Convert the Unicode @name to the loaded NLS and pass it to the @filldir

 * callback.

 *

 * If @ia_page is not NULL it is the locked page containing the index

 * allocation block containing the index entry @ie.

 *

 * Note, we drop (and then reacquire) the page lock on @ia_page across the

 * @filldir() call otherwise we would deadlock with NFSd when it calls ->lookup

 * since ntfs_lookup() will lock the same page.  As an optimization, we do not

 * retake the lock if we are returning a non-zero value as ntfs_readdir()

 * would need to drop the lock immediately anyway.

	/*

	 * Drop the page lock otherwise we deadlock with NFS when it calls

	 * ->lookup since ntfs_lookup() will lock the same page.

 Relock the page but not if we are aborting ->readdir. */

/*

 * We use the same basic approach as the old NTFS driver, i.e. we parse the

 * index root entries and then the index allocation entries that are marked

 * as in use in the index bitmap.

 *

 * While this will return the names in random order this doesn't matter for

 * ->readdir but OTOH results in a faster ->readdir.

 *

 * VFS calls ->readdir without BKL but with i_mutex held. This protects the VFS

 * parts (e.g. ->f_pos and ->i_size, and it also protects against directory

 * modifications).

 *

 * Locking:  - Caller must hold i_mutex on the directory.

 *	     - Each page cache page in the index allocation mapping must be

 *	       locked whilst being accessed otherwise we may find a corrupt

 *	       page due to it being under ->writepage at the moment which

 *	       applies the mst protection fixups before writing out and then

 *	       removes them again after the write is complete after which it 

 *	       unlocks the page.

 Are we at end of dir yet? */

 Emulate . and .. for all directories. */

	/*

	 * Allocate a buffer to store the current name being processed

	 * converted to format determined by current NLS.

 Are we jumping straight into the index allocation attribute? */

 Get hold of the mft record for the directory. */

 Get the offset into the index root attribute. */

 Find the index root attribute in the mft record. */

	/*

	 * Copy the index root attribute value to a buffer so that we can put

	 * the search context and unmap the mft record before calling the

	 * filldir() callback.  We need to do this because of NFSd which calls

	 * ->lookup() from its filldir callback() and this causes NTFS to

	 * deadlock as ntfs_lookup() maps the mft record of the directory and

	 * we have got it mapped here already.  The only solution is for us to

	 * unmap the mft record here so that a call to ntfs_lookup() is able to

	 * map the mft record without deadlocking.

 Copy the index root value (it has been verified in read_inode). */

 The first index entry. */

	/*

	 * Loop until we exceed valid memory (corruption case) or until we

	 * reach the last entry or until filldir tells us it has had enough

	 * or signals an error (both covered by the rc test).

 Bounds checks. */

 The last entry cannot contain a name. */

 Skip index root entry if continuing previous readdir. */

 Advance the position even if going to skip the entry. */

 Submit the name to the filldir callback. */

 We are done with the index root and can free the buffer. */

 If there is no index allocation attribute we are finished. */

 Advance fpos to the beginning of the index allocation. */

 Get the offset into the index allocation attribute. */

 Get the starting bitmap bit position and sanity check it. */

 Get the starting bit position in the current bitmap page. */

 Find next index block in use. */

		/*

		 * If we have reached the end of the bitmap page, get the next

		 * page, and put away the old one.

 If we have reached the end of the bitmap, we are done. */

 If the current index buffer is in the same page we reuse the page. */

		/*

		 * Map the page cache page containing the current ia_pos,

		 * reading it from disk if necessary.

 Get the current index buffer. */

 Bounds checks. */

 Catch multi sector transfer fixup errors. */

 The first index entry in this index buffer. */

	/*

	 * Loop until we exceed valid memory (corruption case) or until we

	 * reach the last entry or until filldir tells us it has had enough

	 * or signals an error (both covered by the rc test).

 Bounds checks. */

 The last entry cannot contain a name. */

 Skip index block entry if continuing previous readdir. */

 Advance the position even if going to skip the entry. */

		/*

		 * Submit the name to the @filldir callback.  Note,

		 * ntfs_filldir() drops the lock on @ia_page but it retakes it

		 * before returning, unless a non-zero value is returned in

		 * which case the page is left unlocked.

 @ia_page is already unlocked in this case. */

 We are finished, set fpos to EOD. */

/**

 * ntfs_dir_open - called when an inode is about to be opened

 * @vi:		inode to be opened

 * @filp:	file structure describing the inode

 *

 * Limit directory size to the page cache limit on architectures where unsigned

 * long is 32-bits. This is the most we can do for now without overflowing the

 * page cache page index. Doing it this way means we don't run into problems

 * because of existing too large directories. It would be better to allow the

 * user to read the accessible part of the directory but I doubt very much

 * anyone is going to hit this check on a 32-bit architecture, so there is no

 * point in adding the extra complexity required to support this.

 *

 * On 64-bit architectures, the check is hopefully optimized away by the

 * compiler.

/**

 * ntfs_dir_fsync - sync a directory to disk

 * @filp:	directory to be synced

 * @dentry:	dentry describing the directory to sync

 * @datasync:	if non-zero only flush user data and not metadata

 *

 * Data integrity sync of a directory to disk.  Used for fsync, fdatasync, and

 * msync system calls.  This function is based on file.c::ntfs_file_fsync().

 *

 * Write the mft record and all associated extent mft records as well as the

 * $INDEX_ALLOCATION and $BITMAP attributes and then sync the block device.

 *

 * If @datasync is true, we do not wait on the inode(s) to be written out

 * but we always wait on the page cache pages to be written out.

 *

 * Note: In the past @filp could be NULL so we ignore it as we don't need it

 * anyway.

 *

 * Locking: Caller must hold i_mutex on the inode.

 *

 * TODO: We should probably also write all attribute/index inodes associated

 * with this inode but since we have no simple way of getting to them we ignore

 * this problem for now.  We do write the $BITMAP attribute if it is present

 * which is the important one for a directory so things are not too bad.

 If the bitmap attribute inode is in memory sync it, too. */

 NTFS_RW */

 Seek inside directory. */

 Return -EISDIR. */

 Read directory contents. */

 Sync a directory to disk. */

 NTFS_RW */

	/*.ioctl	= ,*/			/* Perform function on the

 Open directory. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * sysctl.c - Code for sysctl handling in NTFS Linux kernel driver. Part of

 *	      the Linux-NTFS project. Adapted from the old NTFS driver,

 *	      Copyright (C) 1997 Martin von Löwis, Régis Duchesne

 *

 * Copyright (c) 2002-2005 Anton Altaparmakov

 Definition of the ntfs sysctl. */

 Data pointer and size. */

 Mode, proc handler. */

 Define the parent directory /proc/sys/fs. */

 Storage for the sysctls header. */

/**

 * ntfs_sysctl - add or remove the debug sysctl

 * @add:	add (1) or remove (0) the sysctl

 *

 * Add or remove the debug sysctl. Return 0 on success or -errno on error.

 CONFIG_SYSCTL */

 DEBUG */

 SPDX-License-Identifier: GPL-2.0-or-later

/**

 * mft.c - NTFS kernel mft record operations. Part of the Linux-NTFS project.

 *

 * Copyright (c) 2001-2012 Anton Altaparmakov and Tuxera Inc.

 * Copyright (c) 2002 Richard Russon

/**

 * map_mft_record_page - map the page in which a specific mft record resides

 * @ni:		ntfs inode whose mft record page to map

 *

 * This maps the page in which the mft record of the ntfs inode @ni is situated

 * and returns a pointer to the mft record within the mapped page.

 *

 * Return value needs to be checked with IS_ERR() and if that is true PTR_ERR()

 * contains the negative error code returned.

	/*

	 * The index into the page cache and the offset within the page cache

	 * page of the wanted mft record. FIXME: We need to check for

	 * overflowing the unsigned long, but I don't think we would ever get

	 * here if the volume was that big...

 The maximum valid index into the page cache for $MFT's data. */

 If the wanted index is out of bounds the mft record doesn't exist. */

 Read, map, and pin the page. */

 Catch multi sector transfer fixup errors. */

/**

 * map_mft_record - map, pin and lock an mft record

 * @ni:		ntfs inode whose MFT record to map

 *

 * First, take the mrec_lock mutex.  We might now be sleeping, while waiting

 * for the mutex if it was already locked by someone else.

 *

 * The page of the record is mapped using map_mft_record_page() before being

 * returned to the caller.

 *

 * This in turn uses ntfs_map_page() to get the page containing the wanted mft

 * record (it in turn calls read_cache_page() which reads it in from disk if

 * necessary, increments the use count on the page so that it cannot disappear

 * under us and returns a reference to the page cache page).

 *

 * If read_cache_page() invokes ntfs_readpage() to load the page from disk, it

 * sets PG_locked and clears PG_uptodate on the page. Once I/O has completed

 * and the post-read mst fixups on each mft record in the page have been

 * performed, the page gets PG_uptodate set and PG_locked cleared (this is done

 * in our asynchronous I/O completion handler end_buffer_read_mft_async()).

 * ntfs_map_page() waits for PG_locked to become clear and checks if

 * PG_uptodate is set and returns an error code if not. This provides

 * sufficient protection against races when reading/using the page.

 *

 * However there is the write mapping to think about. Doing the above described

 * checking here will be fine, because when initiating the write we will set

 * PG_locked and clear PG_uptodate making sure nobody is touching the page

 * contents. Doing the locking this way means that the commit to disk code in

 * the page cache code paths is automatically sufficiently locked with us as

 * we will not touch a page that has been locked or is not uptodate. The only

 * locking problem then is them locking the page while we are accessing it.

 *

 * So that code will end up having to own the mrec_lock of all mft

 * records/inodes present in the page before I/O can proceed. In that case we

 * wouldn't need to bother with PG_locked and PG_uptodate as nobody will be

 * accessing anything without owning the mrec_lock mutex.  But we do need to

 * use them because of the read_cache_page() invocation and the code becomes so

 * much simpler this way that it is well worth it.

 *

 * The mft record is now ours and we return a pointer to it. You need to check

 * the returned pointer with IS_ERR() and if that is true, PTR_ERR() will return

 * the error code.

 *

 * NOTE: Caller is responsible for setting the mft record dirty before calling

 * unmap_mft_record(). This is obviously only necessary if the caller really

 * modified the mft record...

 * Q: Do we want to recycle one of the VFS inode state bits instead?

 * A: No, the inode ones mean we want to change the mft record, not we want to

 * write it out.

 Make sure the ntfs inode doesn't go away. */

 Serialize access to this mft record. */

/**

 * unmap_mft_record_page - unmap the page in which a specific mft record resides

 * @ni:		ntfs inode whose mft record page to unmap

 *

 * This unmaps the page in which the mft record of the ntfs inode @ni is

 * situated and returns. This is a NOOP if highmem is not configured.

 *

 * The unmap happens via ntfs_unmap_page() which in turn decrements the use

 * count on the page thus releasing it from the pinned state.

 *

 * We do not actually unmap the page from memory of course, as that will be

 * done by the page cache code itself when memory pressure increases or

 * whatever.

 TODO: If dirty, blah...

/**

 * unmap_mft_record - release a mapped mft record

 * @ni:		ntfs inode whose MFT record to unmap

 *

 * We release the page mapping and the mrec_lock mutex which unmaps the mft

 * record and releases it for others to get hold of. We also release the ntfs

 * inode by decrementing the ntfs inode reference count.

 *

 * NOTE: If caller has modified the mft record, it is imperative to set the mft

 * record dirty BEFORE calling unmap_mft_record().

	/*

	 * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to

	 * ntfs_clear_extent_inode() in the extent inode case, and to the

	 * caller in the non-extent, yet pure ntfs inode case, to do the actual

	 * tear down of all structures and freeing of all allocated memory.

/**

 * map_extent_mft_record - load an extent inode and attach it to its base

 * @base_ni:	base ntfs inode

 * @mref:	mft reference of the extent inode to load

 * @ntfs_ino:	on successful return, pointer to the ntfs_inode structure

 *

 * Load the extent mft record @mref and attach it to its base inode @base_ni.

 * Return the mapped extent mft record if IS_ERR(result) is false.  Otherwise

 * PTR_ERR(result) gives the negative error code.

 *

 * On successful return, @ntfs_ino contains a pointer to the ntfs_inode

 * structure of the mapped extent inode.

 Make sure the base ntfs inode doesn't go away. */

	/*

	 * Check if this extent inode has already been added to the base inode,

	 * in which case just return it. If not found, add it to the base

	 * inode before returning it.

 Make sure the ntfs inode doesn't go away. */

 We found the record; just have to map and return it. */

 map_mft_record() has incremented this on success. */

 Verify the sequence number. */

 Record wasn't there. Get a new ntfs inode and initialize it. */

 Now map the record. */

 Verify the sequence number if it is present. */

 Attach extent inode to base inode, reallocating memory if needed. */

	/*

	 * If the extent inode was not attached to the base inode we need to

	 * release it or we will leak memory.

/**

 * __mark_mft_record_dirty - set the mft record and the page containing it dirty

 * @ni:		ntfs inode describing the mapped mft record

 *

 * Internal function.  Users should call mark_mft_record_dirty() instead.

 *

 * Set the mapped (extent) mft record of the (base or extent) ntfs inode @ni,

 * as well as the page containing the mft record, dirty.  Also, mark the base

 * vfs inode dirty.  This ensures that any changes to the mft record are

 * written out to disk.

 *

 * NOTE:  We only set I_DIRTY_DATASYNC (and not I_DIRTY_PAGES)

 * on the base vfs inode, because even though file data may have been modified,

 * it is dirty in the inode meta data rather than the data page cache of the

 * inode, and thus there are no data pages that need writing out.  Therefore, a

 * full mark_inode_dirty() is overkill.  A mark_inode_dirty_sync(), on the

 * other hand, is not sufficient, because ->write_inode needs to be called even

 * in case of fdatasync. This needs to happen or the file data would not

 * necessarily hit the device synchronously, even though the vfs inode has the

 * O_SYNC flag set.  Also, I_DIRTY_DATASYNC simply "feels" better than just

 * I_DIRTY_SYNC, since the file data has not actually hit the block device yet,

 * which is not what I_DIRTY_SYNC on its own would suggest.

 Determine the base vfs inode and mark it dirty, too. */

/**

 * ntfs_sync_mft_mirror_umount - synchronise an mft record to the mft mirror

 * @vol:	ntfs volume on which the mft record to synchronize resides

 * @mft_no:	mft record number of mft record to synchronize

 * @m:		mapped, mst protected (extent) mft record to synchronize

 *

 * Write the mapped, mst protected (extent) mft record @m with mft record

 * number @mft_no to the mft mirror ($MFTMirr) of the ntfs volume @vol,

 * bypassing the page cache and the $MFTMirr inode itself.

 *

 * This function is only for use at umount time when the mft mirror inode has

 * already been disposed off.  We BUG() if we are called while the mft mirror

 * inode is still attached to the volume.

 *

 * On success return 0.  On error return -errno.

 *

 * NOTE:  This function is not implemented yet as I am not convinced it can

 * actually be triggered considering the sequence of commits we do in super.c::

 * ntfs_put_super().  But just in case we provide this place holder as the

 * alternative would be either to BUG() or to get a NULL pointer dereference

 * and Oops.

/**

 * ntfs_sync_mft_mirror - synchronize an mft record to the mft mirror

 * @vol:	ntfs volume on which the mft record to synchronize resides

 * @mft_no:	mft record number of mft record to synchronize

 * @m:		mapped, mst protected (extent) mft record to synchronize

 * @sync:	if true, wait for i/o completion

 *

 * Write the mapped, mst protected (extent) mft record @m with mft record

 * number @mft_no to the mft mirror ($MFTMirr) of the ntfs volume @vol.

 *

 * On success return 0.  On error return -errno and set the volume errors flag

 * in the ntfs volume @vol.

 *

 * NOTE:  We always perform synchronous i/o and ignore the @sync parameter.

 *

 * TODO:  If @sync is false, want to do truly asynchronous i/o, i.e. just

 * schedule i/o via ->writepage or do it via kntfsd or whatever.

 This could happen during umount... */

 Get the page containing the mirror copy of the mft record @m. */

 Offset of the mft mirror record inside the page. */

 The address in the page of the mirror copy of the mft record @m. */

 Copy the mst protected mft record to the mirror. */

 Create uptodate buffers if not present. */

 If the buffer is outside the mft record, skip it. */

 Need to map the buffer if it is not mapped already. */

 Obtain the vcn and offset of the current block. */

				/*

				 * $MFTMirr always has the whole of its runlist

				 * in memory.

 Seek to element containing target vcn. */

 For $MFTMirr, only lcn >= 0 is a successful remap. */

 Setup buffer head to correct block. */

 Lock buffers and start synchronous write i/o on them. */

 Wait on i/o completion of buffers. */

				/*

				 * Set the buffer uptodate so the page and

				 * buffer states do not become out of sync.

 if (unlikely(err)) */ {

 Clean the buffers. */

 Current state: all buffers are clean, unlocked, and uptodate. */

 Remove the mst protection fixups again. */

/**

 * write_mft_record_nolock - write out a mapped (extent) mft record

 * @ni:		ntfs inode describing the mapped (extent) mft record

 * @m:		mapped (extent) mft record to write

 * @sync:	if true, wait for i/o completion

 *

 * Write the mapped (extent) mft record @m described by the (regular or extent)

 * ntfs inode @ni to backing store.  If the mft record @m has a counterpart in

 * the mft mirror, that is also updated.

 *

 * We only write the mft record if the ntfs inode @ni is dirty and the first

 * buffer belonging to its mft record is dirty, too.  We ignore the dirty state

 * of subsequent buffers because we could have raced with

 * fs/ntfs/aops.c::mark_ntfs_record_dirty().

 *

 * On success, clean the mft record and return 0.  On error, leave the mft

 * record dirty and return -errno.

 *

 * NOTE:  We always perform synchronous i/o and ignore the @sync parameter.

 * However, if the mft record has a counterpart in the mft mirror and @sync is

 * true, we write the mft record, wait for i/o completion, and only then write

 * the mft mirror copy.  This ensures that if the system crashes either the mft

 * or the mft mirror will contain a self-consistent mft record @m.  If @sync is

 * false on the other hand, we start i/o on both and then wait for completion

 * on them.  This provides a speedup but no longer guarantees that you will end

 * up with a self-consistent mft record in the case of a crash but if you asked

 * for asynchronous writing you probably do not care about that anyway.

 *

 * TODO:  If @sync is false, want to do truly asynchronous i/o, i.e. just

 * schedule i/o via ->writepage or do it via kntfsd or whatever.

	/*

	 * If the ntfs_inode is clean no need to do anything.  If it is dirty,

	 * mark it as clean now so that it can be redirtied later on if needed.

	 * There is no danger of races since the caller is holding the locks

	 * for the mft record @m and the page it is in.

 If the buffer is outside the mft record, skip it. */

		/*

		 * If this block is not the first one in the record, we ignore

		 * the buffer's dirty state because we could have raced with a

		 * parallel mark_ntfs_record_dirty().

 This block is the first one in the record. */

 Clean records are not written out. */

 Need to map the buffer if it is not mapped already. */

 Obtain the vcn and offset of the current block. */

 Seek to element containing target vcn. */

 For $MFT, only lcn >= 0 is a successful remap. */

 Setup buffer head to correct block. */

 Apply the mst protection fixups. */

 Lock buffers and start synchronous write i/o on them. */

 Synchronize the mft mirror now if not @sync. */

 Wait on i/o completion of buffers. */

			/*

			 * Set the buffer uptodate so the page and buffer

			 * states do not become out of sync.

 If @sync, now synchronize the mft mirror. */

 Remove the mst protection fixups again. */

 I/O error during writing.  This is really bad! */

 Clean the buffers. */

	/*

	 * Current state: all buffers are clean, unlocked, and uptodate.

	 * The caller should mark the base inode as bad so that no more i/o

	 * happens.  ->clear_inode() will still be invoked so all extent inodes

	 * and other allocated memory will be freed.

/**

 * ntfs_may_write_mft_record - check if an mft record may be written out

 * @vol:	[IN]  ntfs volume on which the mft record to check resides

 * @mft_no:	[IN]  mft record number of the mft record to check

 * @m:		[IN]  mapped mft record to check

 * @locked_ni:	[OUT] caller has to unlock this ntfs inode if one is returned

 *

 * Check if the mapped (base or extent) mft record @m with mft record number

 * @mft_no belonging to the ntfs volume @vol may be written out.  If necessary

 * and possible the ntfs inode of the mft record is locked and the base vfs

 * inode is pinned.  The locked ntfs inode is then returned in @locked_ni.  The

 * caller is responsible for unlocking the ntfs inode and unpinning the base

 * vfs inode.

 *

 * Return 'true' if the mft record may be written out and 'false' if not.

 *

 * The caller has locked the page and cleared the uptodate flag on it which

 * means that we can safely write out any dirty mft records that do not have

 * their inodes in icache as determined by ilookup5() as anyone

 * opening/creating such an inode would block when attempting to map the mft

 * record in read_cache_page() until we are finished with the write out.

 *

 * Here is a description of the tests we perform:

 *

 * If the inode is found in icache we know the mft record must be a base mft

 * record.  If it is dirty, we do not write it and return 'false' as the vfs

 * inode write paths will result in the access times being updated which would

 * cause the base mft record to be redirtied and written out again.  (We know

 * the access time update will modify the base mft record because Windows

 * chkdsk complains if the standard information attribute is not in the base

 * mft record.)

 *

 * If the inode is in icache and not dirty, we attempt to lock the mft record

 * and if we find the lock was already taken, it is not safe to write the mft

 * record and we return 'false'.

 *

 * If we manage to obtain the lock we have exclusive access to the mft record,

 * which also allows us safe writeout of the mft record.  We then set

 * @locked_ni to the locked ntfs inode and return 'true'.

 *

 * Note we cannot just lock the mft record and sleep while waiting for the lock

 * because this would deadlock due to lock reversal (normally the mft record is

 * locked before the page is locked but we already have the page locked here

 * when we try to lock the mft record).

 *

 * If the inode is not in icache we need to perform further checks.

 *

 * If the mft record is not a FILE record or it is a base mft record, we can

 * safely write it and return 'true'.

 *

 * We now know the mft record is an extent mft record.  We check if the inode

 * corresponding to its base mft record is in icache and obtain a reference to

 * it if it is.  If it is not, we can safely write it and return 'true'.

 *

 * We now have the base inode for the extent mft record.  We check if it has an

 * ntfs inode for the extent mft record attached and if not it is safe to write

 * the extent mft record and we return 'true'.

 *

 * The ntfs inode for the extent mft record is attached to the base inode so we

 * attempt to lock the extent mft record and if we find the lock was already

 * taken, it is not safe to write the extent mft record and we return 'false'.

 *

 * If we manage to obtain the lock we have exclusive access to the extent mft

 * record, which also allows us safe writeout of the extent mft record.  We

 * set the ntfs inode of the extent mft record clean and then set @locked_ni to

 * the now locked ntfs inode and return 'true'.

 *

 * Note, the reason for actually writing dirty mft records here and not just

 * relying on the vfs inode dirty code paths is that we can have mft records

 * modified without them ever having actual inodes in memory.  Also we can have

 * dirty mft records with clean ntfs inodes in memory.  None of the described

 * cases would result in the dirty mft records being written out if we only

 * relied on the vfs inode dirty code paths.  And these cases can really occur

 * during allocation of new mft records and in particular when the

 * initialized_size of the $MFT/$DATA attribute is extended and the new space

 * is initialized using ntfs_mft_record_format().  The clean inode can then

 * appear if the mft record is reused for a new inode before it got written

 * out.

	/*

	 * Normally we do not return a locked inode so set @locked_ni to NULL.

	/*

	 * Check if the inode corresponding to this mft record is in the VFS

	 * inode cache and obtain a reference to it if it is.

	/*

	 * Optimize inode 0, i.e. $MFT itself, since we have it in memory and

	 * we get here for it rather often.

 Balance the below iput(). */

		/*

		 * Have to use ilookup5_nowait() since ilookup5() waits for the

		 * inode lock which causes ntfs to deadlock when a concurrent

		 * inode write via the inode dirty code paths and the page

		 * dirty code path of the inode dirty code path when writing

		 * $MFT occurs.

 The inode is in icache. */

 Take a reference to the ntfs inode. */

 If the inode is dirty, do not write this record. */

 The inode is not dirty, try to take the mft record lock. */

		/*

		 * The write has to occur while we hold the mft record lock so

		 * return the locked ntfs inode.

 The inode is not in icache. */

 Write the record if it is not a mft record (type "FILE"). */

 Write the mft record if it is a base inode. */

	/*

	 * This is an extent mft record.  Check if the inode corresponding to

	 * its base mft record is in icache and obtain a reference to it if it

	 * is.

 Balance the below iput(). */

		/*

		 * The base inode is not in icache, write this extent mft

		 * record.

	/*

	 * The base inode is in icache.  Check if it has the extent inode

	 * corresponding to this extent mft record attached.

		/*

		 * The base inode has no attached extent inodes, write this

		 * extent mft record.

 Iterate over the attached extent inodes. */

			/*

			 * Found the extent inode corresponding to this extent

			 * mft record.

	/*

	 * If the extent inode was not attached to the base inode, write this

	 * extent mft record.

 Take a reference to the extent ntfs inode. */

	/*

	 * Found the extent inode coresponding to this extent mft record.

	 * Try to take the mft record lock.

	/*

	 * The write has to occur while we hold the mft record lock so return

	 * the locked extent ntfs inode.

/**

 * ntfs_mft_bitmap_find_and_alloc_free_rec_nolock - see name

 * @vol:	volume on which to search for a free mft record

 * @base_ni:	open base inode if allocating an extent mft record or NULL

 *

 * Search for a free mft record in the mft bitmap attribute on the ntfs volume

 * @vol.

 *

 * If @base_ni is NULL start the search at the default allocator position.

 *

 * If @base_ni is not NULL start the search at the mft record after the base

 * mft record @base_ni.

 *

 * Return the free mft record on success and -errno on error.  An error code of

 * -ENOSPC means that there are no free mft records in the currently

 * initialized mft bitmap.

 *

 * Locking: Caller must hold vol->mftbmp_lock for writing.

	/*

	 * Set the end of the pass making sure we do not overflow the mft

	 * bitmap.

 This happens on a freshly formatted volume. */

 Loop until a free mft record is found. */

 Cap size to pass_end. */

		/*

		 * If we are still within the active pass, search the next page

		 * for a zero bit.

			/*

			 * If the end of the pass has not been reached yet,

			 * continue searching the mft bitmap for a zero bit.

 Do the next pass. */

			/*

			 * Starting the second pass, in which we scan the first

			 * part of the zone which we omitted earlier.

 No free mft records in currently initialized mft bitmap. */

/**

 * ntfs_mft_bitmap_extend_allocation_nolock - extend mft bitmap by a cluster

 * @vol:	volume on which to extend the mft bitmap attribute

 *

 * Extend the mft bitmap attribute on the ntfs volume @vol by one cluster.

 *

 * Note: Only changes allocated_size, i.e. does not touch initialized_size or

 * data_size.

 *

 * Return 0 on success and -errno on error.

 *

 * Locking: - Caller must hold vol->mftbmp_lock for writing.

 *	    - This function takes NTFS_I(vol->mftbmp_ino)->runlist.lock for

 *	      writing and releases it before returning.

 *	    - This function takes vol->lcnbmp_lock for writing and releases it

 *	      before returning.

	/*

	 * Determine the last lcn of the mft bitmap.  The allocated size of the

	 * mft bitmap cannot be zero so we are ok to do this.

	/*

	 * Attempt to get the cluster following the last allocated cluster by

	 * hand as it may be in the MFT zone so the allocator would not give it

	 * to us.

 Next cluster is free, allocate it. */

 Update the mft bitmap runlist. */

 Allocate a cluster from the DATA_ZONE. */

 Find the last run in the new runlist. */

	/*

	 * Update the attribute record as well.  Note: @rl is the last

	 * (non-terminator) runlist element of mft bitmap.

 Search back for the previous last allocated cluster of mft bitmap. */

 Get the size for the new mapping pairs array for this extent. */

 Expand the attribute record if necessary. */

 TODO: Deal with this by moving this extent to a new mft

 record or by starting a new extent in a new mft record or by

 moving other attributes out of this mft record.

 Note: It will need to be a special mft record and if none of

 those are available it gets rather complicated...

 Generate the mapping pairs array directly into the attr record. */

 Update the highest_vcn. */

	/*

	 * We now have extended the mft bitmap allocated_size by one cluster.

	 * Reflect this in the ntfs_inode structure and the attribute record.

		/*

		 * We are not in the first attribute extent, switch to it, but

		 * first ensure the changes will make it to disk later.

 Ensure the changes make it to disk. */

		/*

		 * The only thing that is now wrong is ->allocated_size of the

		 * base attribute extent which chkdsk should be able to fix.

 Truncate the last run in the runlist by one cluster. */

 Remove the last run from the runlist. */

 Deallocate the cluster. */

/**

 * ntfs_mft_bitmap_extend_initialized_nolock - extend mftbmp initialized data

 * @vol:	volume on which to extend the mft bitmap attribute

 *

 * Extend the initialized portion of the mft bitmap attribute on the ntfs

 * volume @vol by 8 bytes.

 *

 * Note:  Only changes initialized_size and data_size, i.e. requires that

 * allocated_size is big enough to fit the new initialized_size.

 *

 * Return 0 on success and -error on error.

 *

 * Locking: Caller must hold vol->mftbmp_lock for writing.

 Get the attribute record. */

	/*

	 * We can simply update the initialized_size before filling the space

	 * with zeroes because the caller is holding the mft bitmap lock for

	 * writing which ensures that no one else is trying to access the data.

 Ensure the changes make it to disk. */

 Initialize the mft bitmap attribute value with zeroes. */

 Try to recover from the error. */

 DEBUG */

/**

 * ntfs_mft_data_extend_allocation_nolock - extend mft data attribute

 * @vol:	volume on which to extend the mft data attribute

 *

 * Extend the mft data attribute on the ntfs volume @vol by 16 mft records

 * worth of clusters or if not enough space for this by one mft record worth

 * of clusters.

 *

 * Note:  Only changes allocated_size, i.e. does not touch initialized_size or

 * data_size.

 *

 * Return 0 on success and -errno on error.

 *

 * Locking: - Caller must hold vol->mftbmp_lock for writing.

 *	    - This function takes NTFS_I(vol->mft_ino)->runlist.lock for

 *	      writing and releases it before returning.

 *	    - This function calls functions which take vol->lcnbmp_lock for

 *	      writing and release it before returning.

	/*

	 * Determine the preferred allocation location, i.e. the last lcn of

	 * the mft data attribute.  The allocated size of the mft data

	 * attribute cannot be zero so we are ok to do this.

 Minimum allocation is one mft record worth of clusters. */

 Want to allocate 16 mft records worth of clusters. */

 Ensure we do not go above 2^32-1 mft records. */

		/*

		 * There is not enough space to do the allocation, but there

		 * might be enough space to do a minimal allocation so try that

		 * before failing.

 Find the last run in the new runlist. */

 Update the attribute record as well. */

 Search back for the previous last allocated cluster of mft bitmap. */

 Get the size for the new mapping pairs array for this extent. */

 Expand the attribute record if necessary. */

 TODO: Deal with this by moving this extent to a new mft

 record or by starting a new extent in a new mft record or by

 moving other attributes out of this mft record.

 Note: Use the special reserved mft records and ensure that

 this extent is not required to find the mft record in

 question.  If no free special records left we would need to

 move an existing record away, insert ours in its place, and

 then place the moved record into the newly allocated space

 and we would then need to update all references to this mft

 record appropriately.  This is rather complicated...

 Generate the mapping pairs array directly into the attr record. */

 Update the highest_vcn. */

	/*

	 * We now have extended the mft data allocated_size by nr clusters.

	 * Reflect this in the ntfs_inode structure and the attribute record.

	 * @rl is the last (non-terminator) runlist element of mft data

	 * attribute.

		/*

		 * We are not in the first attribute extent, switch to it, but

		 * first ensure the changes will make it to disk later.

 Ensure the changes make it to disk. */

		/*

		 * The only thing that is now wrong is ->allocated_size of the

		 * base attribute extent which chkdsk should be able to fix.

/**

 * ntfs_mft_record_layout - layout an mft record into a memory buffer

 * @vol:	volume to which the mft record will belong

 * @mft_no:	mft reference specifying the mft record number

 * @m:		destination buffer of size >= @vol->mft_record_size bytes

 *

 * Layout an empty, unused mft record with the mft record number @mft_no into

 * the buffer @m.  The volume @vol is needed because the mft record structure

 * was modified in NTFS 3.1 so we need to know which volume version this mft

 * record will be used on.

 *

 * Return 0 on success and -errno on error.

 Start by clearing the whole mft record to gives us a clean slate. */

 Aligned to 2-byte boundary. */

		/*

		 * Set the NTFS 3.1+ specific fields while we know that the

		 * volume version is 3.1+.

 Set the update sequence number to 1. */

	/*

	 * Place the attributes straight after the update sequence array,

	 * aligned to 8-byte boundary.

	/*

	 * Using attrs_offset plus eight bytes (for the termination attribute).

	 * attrs_offset is already aligned to 8-byte boundary, so no need to

	 * align again.

 Add the termination attribute. */

/**

 * ntfs_mft_record_format - format an mft record on an ntfs volume

 * @vol:	volume on which to format the mft record

 * @mft_no:	mft record number to format

 *

 * Format the mft record @mft_no in $MFT/$DATA, i.e. lay out an empty, unused

 * mft record into the appropriate place of the mft data attribute.  This is

 * used when extending the mft data attribute.

 *

 * Return 0 on success and -errno on error.

	/*

	 * The index into the page cache and the offset within the page cache

	 * page of the wanted mft record.

 The maximum valid index into the page cache for $MFT's data. */

 Read, map, and pin the page containing the mft record. */

	/*

	 * Make sure the mft record is written out to disk.  We could use

	 * ilookup5() to check if an inode is in icache and so on but this is

	 * unnecessary as ntfs_writepage() will write the dirty record anyway.

/**

 * ntfs_mft_record_alloc - allocate an mft record on an ntfs volume

 * @vol:	[IN]  volume on which to allocate the mft record

 * @mode:	[IN]  mode if want a file or directory, i.e. base inode or 0

 * @base_ni:	[IN]  open base inode if allocating an extent mft record or NULL

 * @mrec:	[OUT] on successful return this is the mapped mft record

 *

 * Allocate an mft record in $MFT/$DATA of an open ntfs volume @vol.

 *

 * If @base_ni is NULL make the mft record a base mft record, i.e. a file or

 * direvctory inode, and allocate it at the default allocator position.  In

 * this case @mode is the file mode as given to us by the caller.  We in

 * particular use @mode to distinguish whether a file or a directory is being

 * created (S_IFDIR(mode) and S_IFREG(mode), respectively).

 *

 * If @base_ni is not NULL make the allocated mft record an extent record,

 * allocate it starting at the mft record after the base mft record and attach

 * the allocated and opened ntfs inode to the base inode @base_ni.  In this

 * case @mode must be 0 as it is meaningless for extent inodes.

 *

 * You need to check the return value with IS_ERR().  If false, the function

 * was successful and the return value is the now opened ntfs inode of the

 * allocated mft record.  *@mrec is then set to the allocated, mapped, pinned,

 * and locked mft record.  If IS_ERR() is true, the function failed and the

 * error code is obtained from PTR_ERR(return value).  *@mrec is undefined in

 * this case.

 *

 * Allocation strategy:

 *

 * To find a free mft record, we scan the mft bitmap for a zero bit.  To

 * optimize this we start scanning at the place specified by @base_ni or if

 * @base_ni is NULL we start where we last stopped and we perform wrap around

 * when we reach the end.  Note, we do not try to allocate mft records below

 * number 24 because numbers 0 to 15 are the defined system files anyway and 16

 * to 24 are special in that they are used for storing extension mft records

 * for the $DATA attribute of $MFT.  This is required to avoid the possibility

 * of creating a runlist with a circular dependency which once written to disk

 * can never be read in again.  Windows will only use records 16 to 24 for

 * normal files if the volume is completely out of space.  We never use them

 * which means that when the volume is really out of space we cannot create any

 * more files while Windows can still create up to 8 small files.  We can start

 * doing this at some later time, it does not matter much for now.

 *

 * When scanning the mft bitmap, we only search up to the last allocated mft

 * record.  If there are no free records left in the range 24 to number of

 * allocated mft records, then we extend the $MFT/$DATA attribute in order to

 * create free mft records.  We extend the allocated size of $MFT/$DATA by 16

 * records at a time or one cluster, if cluster size is above 16kiB.  If there

 * is not sufficient space to do this, we try to extend by a single mft record

 * or one cluster, if cluster size is above the mft record size.

 *

 * No matter how many mft records we allocate, we initialize only the first

 * allocated mft record, incrementing mft data size and initialized size

 * accordingly, open an ntfs_inode for it and return it to the caller, unless

 * there are less than 24 mft records, in which case we allocate and initialize

 * mft records until we reach record 24 which we consider as the first free mft

 * record for use by normal files.

 *

 * If during any stage we overflow the initialized data in the mft bitmap, we

 * extend the initialized size (and data size) by 8 bytes, allocating another

 * cluster if required.  The bitmap data size has to be at least equal to the

 * number of mft records in the mft, but it can be bigger, in which case the

 * superflous bits are padded with zeroes.

 *

 * Thus, when we return successfully (IS_ERR() is false), we will have:

 *	- initialized / extended the mft bitmap if necessary,

 *	- initialized / extended the mft data if necessary,

 *	- set the bit corresponding to the mft record being allocated in the

 *	  mft bitmap,

 *	- opened an ntfs_inode for the allocated mft record, and we will have

 *	- returned the ntfs_inode as well as the allocated mapped, pinned, and

 *	  locked mft record.

 *

 * On error, the volume will be left in a consistent state and no record will

 * be allocated.  If rolling back a partial operation fails, we may leave some

 * inconsistent metadata in which case we set NVolErrors() so the volume is

 * left dirty when unmounted.

 *

 * Note, this function cannot make use of most of the normal functions, like

 * for example for attribute resizing, etc, because when the run list overflows

 * the base mft record and an attribute list is used, it is very important that

 * the extension mft records used to store the $DATA attribute of $MFT can be

 * reached without having to read the information contained inside them, as

 * this would make it impossible to find them in the first place after the

 * volume is unmounted.  $MFT/$BITMAP probably does not need to follow this

 * rule because the bitmap is not essential for finding the mft records, but on

 * the other hand, handling the bitmap in this special way would make life

 * easier because otherwise there might be circular invocations of functions

 * when reading the bitmap.

 @mode and @base_ni are mutually exclusive. */

 @mode and @base_ni are mutually exclusive. */

 We only support creation of normal files and directories. */

	/*

	 * No free mft records left.  If the mft bitmap already covers more

	 * than the currently used mft records, the next records are all free,

	 * so we can simply allocate the first unused mft record.

	 * Note: We also have to make sure that the mft bitmap at least covers

	 * the first 24 mft records as they are special and whilst they may not

	 * be in use, we do not allocate from them.

	/*

	 * The mft bitmap needs to be expanded until it covers the first unused

	 * mft record that we can allocate.

	 * Note: The smallest mft record we allocate is mft record 24.

 Need to extend bitmap by one more cluster. */

 DEBUG */

	/*

	 * We now have sufficient allocated space, extend the initialized_size

	 * as well as the data_size if necessary and fill the new space with

	 * zeroes.

 DEBUG */

 @bit is the found free mft record, allocate it in the mft bitmap. */

	/*

	 * The mft bitmap is now uptodate.  Deal with mft data attribute now.

	 * Note, we keep hold of the mft bitmap lock for writing until all

	 * modifications to the mft data attribute are complete, too, as they

	 * will impact decisions for mft bitmap and mft record allocation done

	 * by a parallel allocation and if the lock is not maintained a

	 * parallel allocation could allocate the same mft record as this one.

	/*

	 * The mft record is outside the initialized data.  Extend the mft data

	 * attribute until it covers the allocated record.  The loop is only

	 * actually traversed more than once when a freshly formatted volume is

	 * first written to so it optimizes away nicely in the common case.

	/*

	 * Extend mft data initialized size (and data size of course) to reach

	 * the allocated mft record, formatting the mft records allong the way.

	 * Note: We only modify the ntfs_inode structure as that is all that is

	 * needed by ntfs_mft_record_format().  We will update the attribute

	 * record itself in one fell swoop later on.

 Update the mft data attribute record to reflect the new sizes. */

 Ensure the changes make it to disk. */

	/*

	 * We can finally drop the mft bitmap lock as the mft data attribute

	 * has been fully updated.  The only disparity left is that the

	 * allocated mft record still needs to be marked as in use to match the

	 * set bit in the mft bitmap but this is actually not a problem since

	 * this mft record is not referenced from anywhere yet and the fact

	 * that it is allocated in the mft bitmap means that no-one will try to

	 * allocate it either.

	/*

	 * We now have allocated and initialized the mft record.  Calculate the

	 * index of and the offset within the page cache page the record is in.

 Read, map, and pin the page containing the mft record. */

 If we just formatted the mft record no need to do it again. */

 Sanity check that the mft record is really not in use. */

		/*

		 * We need to (re-)format the mft record, preserving the

		 * sequence number if it is not zero as well as the update

		 * sequence number if it is not zero or -1 (0xffff).  This

		 * means we do not need to care whether or not something went

		 * wrong with the previous mft record.

 Set the mft record itself in use. */

		/*

		 * Setup the base mft record in the extent mft record.  This

		 * completes initialization of the allocated extent mft record

		 * and we can simply use it with map_extent_mft_record().

		/*

		 * Allocate an extent inode structure for the new mft record,

		 * attach it to the base inode @base_ni and map, pin, and lock

		 * its, i.e. the allocated, mft record.

 Set the mft record itself not in use. */

 Make sure the mft record is written out to disk. */

		/*

		 * Make sure the allocated mft record is written out to disk.

		 * No need to set the inode dirty because the caller is going

		 * to do that anyway after finishing with the new extent mft

		 * record (e.g. at a minimum a new attribute will be added to

		 * the mft record.

		/*

		 * Need to unmap the page since map_extent_mft_record() mapped

		 * it as well so we have it mapped twice at the moment.

		/*

		 * Allocate a new VFS inode and set it up.  NOTE: @vi->i_nlink

		 * is set to 1 but the mft record->link_count is 0.  The caller

		 * needs to bear this in mind.

 Set the mft record itself not in use. */

 Make sure the mft record is written out to disk. */

 The owner and group come from the ntfs volume. */

 Initialize the ntfs specific part of @vi. */

		/*

		 * Set the appropriate mode, attribute type, and name.  For

		 * directories, also setup the index values to the defaults.

 Set the inode times to the current time. */

		/*

		 * Set the file size to 0, the ntfs inode sizes are set to 0 by

		 * the call to ntfs_init_big_inode() below.

 Set the sequence number. */

		/*

		 * Manually map, pin, and lock the mft record as we already

		 * have its page mapped and it is very easy to do.

		/*

		 * Make sure the allocated mft record is written out to disk.

		 * NOTE: We do not set the ntfs inode dirty because this would

		 * fail in ntfs_write_inode() because the inode does not have a

		 * standard information attribute yet.  Also, there is no need

		 * to set the inode dirty because the caller is going to do

		 * that anyway after finishing with the new mft record (e.g. at

		 * a minimum some new attributes will be added to the mft

		 * record.

 Add the inode to the inode hash for the superblock. */

 Update the default mft allocation position. */

	/*

	 * Return the opened, allocated inode of the allocated mft record as

	 * well as the mapped, pinned, and locked mft record.

/**

 * ntfs_extent_mft_record_free - free an extent mft record on an ntfs volume

 * @ni:		ntfs inode of the mapped extent mft record to free

 * @m:		mapped extent mft record of the ntfs inode @ni

 *

 * Free the mapped extent mft record @m of the extent ntfs inode @ni.

 *

 * Note that this function unmaps the mft record and closes and destroys @ni

 * internally and hence you cannot use either @ni nor @m any more after this

 * function returns success.

 *

 * On success return 0 and on error return -errno.  @ni and @m are still valid

 * in this case and have not been freed.

 *

 * For some errors an error message is displayed and the success code 0 is

 * returned and the volume is then left dirty on umount.  This makes sense in

 * case we could not rollback the changes that were already done since the

 * caller no longer wants to reference this mft record so it does not matter to

 * the caller if something is wrong with it as long as it is properly detached

 * from the base inode.

 Make sure we are holding the only reference to the extent inode. */

 Dissociate the ntfs inode from the base inode. */

	/*

	 * The extent inode is no longer attached to the base inode so no one

	 * can get a reference to it any more.

 Mark the mft record as not in use. */

 Increment the sequence number, skipping zero, if it is not zero. */

	/*

	 * Set the ntfs inode dirty and write it out.  We do not need to worry

	 * about the base inode here since whatever caused the extent mft

	 * record to be freed is guaranteed to do it already.

 Unmap and throw away the now freed extent inode. */

 Clear the bit in the $MFT/$BITMAP corresponding to this record. */

		/*

		 * The extent inode is gone but we failed to deallocate it in

		 * the mft bitmap.  Just emit a warning and leave the volume

		 * dirty on umount.

 Rollback what we did... */

 NTFS_RW */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * file.c - NTFS kernel file operations.  Part of the Linux-NTFS project.

 *

 * Copyright (c) 2001-2015 Anton Altaparmakov and Tuxera Inc.

/**

 * ntfs_file_open - called when an inode is about to be opened

 * @vi:		inode to be opened

 * @filp:	file structure describing the inode

 *

 * Limit file size to the page cache limit on architectures where unsigned long

 * is 32-bits. This is the most we can do for now without overflowing the page

 * cache page index. Doing it this way means we don't run into problems because

 * of existing too large files. It would be better to allow the user to read

 * the beginning of the file but I doubt very much anyone is going to hit this

 * check on a 32-bit architecture, so there is no point in adding the extra

 * complexity required to support this.

 *

 * On 64-bit architectures, the check is hopefully optimized away by the

 * compiler.

 *

 * After the check passes, just call generic_file_open() to do its work.

/**

 * ntfs_attr_extend_initialized - extend the initialized size of an attribute

 * @ni:			ntfs inode of the attribute to extend

 * @new_init_size:	requested new initialized size in bytes

 *

 * Extend the initialized size of an attribute described by the ntfs inode @ni

 * to @new_init_size bytes.  This involves zeroing any non-sparse space between

 * the old initialized size and @new_init_size both in the page cache and on

 * disk (if relevant complete pages are already uptodate in the page cache then

 * these are simply marked dirty).

 *

 * As a side-effect, the file size (vfs inode->i_size) may be incremented as,

 * in the resident attribute case, it is tied to the initialized size and, in

 * the non-resident attribute case, it may not fall below the initialized size.

 *

 * Note that if the attribute is resident, we do not need to touch the page

 * cache at all.  This is because if the page cache page is not uptodate we

 * bring it uptodate later, when doing the write to the mft record since we

 * then already have the page mapped.  And if the page is uptodate, the

 * non-initialized region will already have been zeroed when the page was

 * brought uptodate and the region may in fact already have been overwritten

 * with new data via mmap() based writes, so we cannot just zero it.  And since

 * POSIX specifies that the behaviour of resizing a file whilst it is mmap()ped

 * is unspecified, we choose not to do zeroing and thus we do not need to touch

 * the page at all.  For a more detailed explanation see ntfs_truncate() in

 * fs/ntfs/inode.c.

 *

 * Return 0 on success and -errno on error.  In the case that an error is

 * encountered it is possible that the initialized size will already have been

 * incremented some way towards @new_init_size but it is guaranteed that if

 * this is the case, the necessary zeroing will also have happened and that all

 * metadata is self-consistent.

 *

 * Locking: i_mutex on the vfs inode corrseponsind to the ntfs inode @ni must be

 *	    held by the caller.

 Use goto to reduce indentation and we need the label below anyway. */

 The total length of the attribute value. */

	/*

	 * Do the zeroing in the mft record and update the attribute size in

	 * the mft record.

 Finally, update the sizes in the vfs and ntfs inodes. */

	/*

	 * If the new initialized size @new_init_size exceeds the current file

	 * size (vfs inode->i_size), we need to extend the file size to the

	 * new initialized size.

 Update the file size in the vfs inode. */

		/*

		 * Read the page.  If the page is not present, this will zero

		 * the uninitialized regions for us.

		/*

		 * Update the initialized size in the ntfs inode.  This is

		 * enough to make ntfs_writepage() work.

 Set the page dirty so it gets written out. */

		/*

		 * Play nice with the vm and the rest of the system.  This is

		 * very much needed as we can potentially be modifying the

		 * initialised size from a very small value to a really huge

		 * value, e.g.

		 *	f = open(somefile, O_TRUNC);

		 *	truncate(f, 10GiB);

		 *	seek(f, 10GiB);

		 *	write(f, 1);

		 * And this would mean we would be marking dirty hundreds of

		 * thousands of pages or as in the above example more than

		 * two and a half million pages!

		 *

		 * TODO: For sparse pages could optimize this workload by using

		 * the FsMisc / MiscFs page bit as a "PageIsSparse" bit.  This

		 * would be set in readpage for sparse pages and here we would

		 * not need to mark dirty any pages which have this bit set.

		 * The only caveat is that we have to clear the bit everywhere

		 * where we allocate any clusters that lie in the page or that

		 * contain the page.

		 *

		 * TODO: An even greater optimization would be for us to only

		 * call readpage() on pages which are not in sparse regions as

		 * determined from the runlist.  This would greatly reduce the

		 * number of pages we read and make dirty in the case of sparse

		 * files.

 Now bring in sync the initialized_size in the mft record. */

	/*

	 * All checks have passed.  Before we start doing any writing we want

	 * to abort any totally illegal writes.

 If file is encrypted, deny access, just like NT4. */

 Only $DATA attributes can be encrypted. */

		/*

		 * Reminder for later: Encrypted files are _always_

		 * non-resident so that the content can always be encrypted.

 Only unnamed $DATA attribute can be compressed. */

		/*

		 * Reminder for later: If resident, the data is not actually

		 * compressed.  Only on the switch to non-resident does

		 * compression kick in.  This is in contrast to encrypted files

		 * (see above).

	/*

	 * Our ->update_time method always succeeds thus file_update_time()

	 * cannot fail either so there is no need to check the return code.

 The first byte after the last cluster being written to. */

	/*

	 * If the write goes beyond the allocated size, extend the allocation

	 * to cover the whole of the write, rounded up to the nearest cluster.

		/*

		 * Extend the allocation without changing the data size.

		 *

		 * Note we ensure the allocation is big enough to at least

		 * write some data but we do not require the allocation to be

		 * complete, i.e. it may be partial.

 If the extension was partial truncate the write. */

 Perform a partial write if possible or fail. */

	/*

	 * If the write starts beyond the initialized size, extend it up to the

	 * beginning of the write and initialize all non-sparse space between

	 * the old initialized size and the new one.  This automatically also

	 * increments the vfs inode->i_size to keep it above or equal to the

	 * initialized_size.

		/*

		 * Wait for ongoing direct i/o to complete before proceeding.

		 * New direct i/o cannot start as we hold i_mutex.

/**

 * __ntfs_grab_cache_pages - obtain a number of locked pages

 * @mapping:	address space mapping from which to obtain page cache pages

 * @index:	starting index in @mapping at which to begin obtaining pages

 * @nr_pages:	number of page cache pages to obtain

 * @pages:	array of pages in which to return the obtained page cache pages

 * @cached_page: allocated but as yet unused page

 *

 * Obtain @nr_pages locked page cache pages from the mapping @mapping and

 * starting at index @index.

 *

 * If a page is newly created, add it to lru list

 *

 * Note, the page locks are obtained in ascending page index order.

/**

 * ntfs_prepare_pages_for_non_resident_write - prepare pages for receiving data

 * @pages:	array of destination pages

 * @nr_pages:	number of pages in @pages

 * @pos:	byte position in file at which the write begins

 * @bytes:	number of bytes to be written

 *

 * This is called for non-resident attributes from ntfs_file_buffered_write()

 * with i_mutex held on the inode (@pages[0]->mapping->host).  There are

 * @nr_pages pages in @pages which are locked but not kmap()ped.  The source

 * data has not yet been copied into the @pages.

 * 

 * Need to fill any holes with actual clusters, allocate buffers if necessary,

 * ensure all the buffers are mapped, and bring uptodate any buffers that are

 * only partially being written to.

 *

 * If @nr_pages is greater than one, we are guaranteed that the cluster size is

 * greater than PAGE_SIZE, that all pages in @pages are entirely inside

 * the same cluster and that they are the entirety of that cluster, and that

 * the cluster is sparse, i.e. we need to allocate a cluster to fill the hole.

 *

 * i_size is not to be modified yet.

 *

 * Return 0 on success or -errno on error.

		/*

		 * create_empty_buffers() will create uptodate/dirty buffers if

		 * the page is uptodate/dirty.

	/*

	 * Loop over each page and for each page over each buffer.  Use goto to

	 * reduce indentation.

 Clear buffer_new on all buffers to reinitialise state. */

			/*

			 * The buffer is already mapped.  If it is uptodate,

			 * ignore it.

			/*

			 * The buffer is not uptodate.  If the page is uptodate

			 * set the buffer uptodate and otherwise ignore it.

			/*

			 * Neither the page nor the buffer are uptodate.  If

			 * the buffer is only partially being written to, we

			 * need to read it in before the write, i.e. now.

				/*

				 * If the buffer is fully or partially within

				 * the initialized size, do an actual read.

				 * Otherwise, simply zero the buffer.

 Unmapped buffer.  Need to map it. */

		/*

		 * If the current buffer is in the same clusters as the map

		 * cache, there is no need to check the runlist again.  The

		 * map cache is made up of @vcn, which is the first cached file

		 * cluster, @vcn_len which is the number of cached file

		 * clusters, @lcn is the device cluster corresponding to @vcn,

		 * and @lcn_block is the block number corresponding to @lcn.

			/*

			 * If the page is uptodate so is the buffer.  If the

			 * buffer is fully outside the write, we ignore it if

			 * it was already allocated and we mark it dirty so it

			 * gets written out if we allocated it.  On the other

			 * hand, if we allocated the buffer but we are not

			 * marking it dirty we set buffer_new so we can do

			 * error recovery.

 We allocated the buffer. */

 Page is _not_ uptodate. */

				/*

				 * Buffer was already allocated.  If it is not

				 * uptodate and is only partially being written

				 * to, we need to read it in before the write,

				 * i.e. now.

					/*

					 * If the buffer is fully or partially

					 * within the initialized size, do an

					 * actual read.  Otherwise, simply zero

					 * the buffer.

 We allocated the buffer. */

			/*

			 * If the buffer is fully outside the write, zero it,

			 * set it uptodate, and mark it dirty so it gets

			 * written out.  If it is partially being written to,

			 * zero region surrounding the write but leave it to

			 * commit write to do anything else.  Finally, if the

			 * buffer is fully being overwritten, do nothing.

		/*

		 * Slow path: this is the first buffer in the cluster.  If it

		 * is outside allocated size and is not uptodate, zero it and

		 * set it uptodate.

 Seek to element containing target cluster. */

				/*

				 * Successful remap, setup the map cache and

				 * use that to deal with the buffer.

				/*

				 * If the number of remaining clusters touched

				 * by the write is smaller or equal to the

				 * number of cached clusters, unlock the

				 * runlist as the map cache will be used from

				 * now on.

		/*

		 * If it is not a hole and not out of bounds, the runlist is

		 * probably unmapped so try to map it now.

 Attempt to map runlist. */

					/*

					 * We need the runlist locked for

					 * writing, so if it is locked for

					 * reading relock it now and retry in

					 * case it changed whilst we dropped

					 * the lock.

				/*

				 * If @vcn is out of bounds, pretend @lcn is

				 * LCN_ENOENT.  As long as the buffer is out

				 * of bounds this will work fine.

 Failed to map the buffer, even after retrying. */

		/*

		 * The buffer is in a hole or out of bounds.  We need to fill

		 * the hole, unless the buffer is in a cluster which is not

		 * touched by the write, in which case we just leave the buffer

		 * unmapped.  This can only happen when the cluster size is

		 * less than the page cache size.

				/*

				 * If the buffer is uptodate we skip it.  If it

				 * is not but the page is uptodate, we can set

				 * the buffer uptodate.  If the page is not

				 * uptodate, we can clear the buffer and set it

				 * uptodate.  Whether this is worthwhile is

				 * debatable and this could be removed.

		/*

		 * Out of bounds buffer is invalid if it was not really out of

		 * bounds.

		/*

		 * We need the runlist locked for writing, so if it is locked

		 * for reading relock it now and retry in case it changed

		 * whilst we dropped the lock.

 Find the previous last allocated cluster. */

 Map and lock the mft record and get the attribute record. */

		/*

		 * Find the runlist element with which the attribute extent

		 * starts.  Note, we cannot use the _attr_ version because we

		 * have mapped the mft record.  That is ok because we know the

		 * runlist fragment must be mapped already to have ever gotten

		 * here, so we can just use the _rl_ version.

		/*

		 * If @highest_vcn is zero, calculate the real highest_vcn

		 * (which can really be zero).

		/*

		 * Determine the size of the mapping pairs array for the new

		 * extent, i.e. the old extent with the hole filled.

		/*

		 * Resize the attribute record to fit the new mapping pairs

		 * array.

 TODO: Deal with this by using the current attribute

 and fill it with as much of the mapping pairs

 array as possible.  Then loop over each attribute

 extent rewriting the mapping pairs arrays as we go

 along and if when we reach the end we have not

 enough space, try to resize the last attribute

 extent and if even that fails, add a new attribute

 extent.

 We could also try to resize at each step in the hope

 that we will not need to rewrite every single extent.

 Note, we may need to decompress some extents to fill

 the runlist as we are walking the extents...

		/*

		 * Generate the mapping pairs array directly into the attribute

		 * record.

 Update the highest_vcn but only if it was not set. */

		/*

		 * If the attribute is sparse/compressed, update the compressed

		 * size in the ntfs_inode structure and the attribute record.

			/*

			 * If we are not in the first attribute extent, switch

			 * to it, but first ensure the changes will make it to

			 * disk later.

 @m is not used any more so do not set it. */

 Ensure the changes make it to disk. */

 Successfully filled the hole. */

 Setup the map cache and use that to deal with the buffer. */

		/*

		 * If the number of remaining clusters in the @pages is smaller

		 * or equal to the number of cached clusters, unlock the

		 * runlist as the map cache will be used from now on.

 If there are no errors, do the next page. */

 If there are no errors, release the runlist lock if we took it. */

 If we issued read requests, let them complete. */

			/*

			 * If the buffer overflows the initialized size, need

			 * to zero the overflowing region.

 if (unlikely(!buffer_uptodate(bh))) */

 Clear buffer_new on all buffers. */

 Get back to the attribute extent we modified. */

			/*

			 * The only thing that is now wrong is the compressed

			 * size of the base attribute extent which chkdsk

			 * should be able to fix.

	/*

	 * If the runlist has been modified, need to restore it by punching a

	 * hole into it and we then need to deallocate the on-disk cluster as

	 * well.  Note, we only modify the runlist if we are able to generate a

	 * new mapping pairs array, i.e. only when the mapped attribute extent

	 * is not switched.

 Make the file cluster we allocated sparse in the runlist. */

 if (success) */ {

			/*

			 * Deallocate the on-disk cluster we allocated but only

			 * if we succeeded in punching its vcn out of the

			 * runlist.

	/*

	 * Resize the attribute record to its old size and rebuild the mapping

	 * pairs array.  Note, we only can do this if the runlist has been

	 * restored to its old state which also implies that the mapped

	 * attribute extent is not switched.

 if (success) */ {

 Release the mft record and the attribute. */

 Release the runlist lock. */

	/*

	 * Zero out any newly allocated blocks to avoid exposing stale data.

	 * If BH_New is set, we know that the block was newly allocated above

	 * and that it has not been fully zeroed and marked dirty yet.

	/*

	 * Warning: Do not do the decrement at the same time as the call to

	 * flush_dcache_page() because it is a NULL macro on i386 and hence the

	 * decrement never happens so the loop never terminates.

/**

 * ntfs_commit_pages_after_non_resident_write - commit the received data

 * @pages:	array of destination pages

 * @nr_pages:	number of pages in @pages

 * @pos:	byte position in file at which the write begins

 * @bytes:	number of bytes to be written

 *

 * See description of ntfs_commit_pages_after_write(), below.

		/*

		 * If all buffers are now uptodate but the page is not, set the

		 * page uptodate.

	/*

	 * Finally, if we do not need to update initialized_size or i_size we

	 * are finished.

	/*

	 * Update initialized_size/i_size as appropriate, both in the inode and

	 * the mft record.

 Map, pin, and lock the mft record. */

 Mark the mft record dirty, so it gets written back. */

/**

 * ntfs_commit_pages_after_write - commit the received data

 * @pages:	array of destination pages

 * @nr_pages:	number of pages in @pages

 * @pos:	byte position in file at which the write begins

 * @bytes:	number of bytes to be written

 *

 * This is called from ntfs_file_buffered_write() with i_mutex held on the inode

 * (@pages[0]->mapping->host).  There are @nr_pages pages in @pages which are

 * locked but not kmap()ped.  The source data has already been copied into the

 * @page.  ntfs_prepare_pages_for_non_resident_write() has been called before

 * the data was copied (for non-resident attributes only) and it returned

 * success.

 *

 * Need to set uptodate and mark dirty all buffers within the boundary of the

 * write.  If all buffers in a page are uptodate we set the page uptodate, too.

 *

 * Setting the buffers dirty ensures that they get written out later when

 * ntfs_writepage() is invoked by the VM.

 *

 * Finally, we need to update i_size and initialized_size as appropriate both

 * in the inode and the mft record.

 *

 * This is modelled after fs/buffer.c::generic_commit_write(), which marks

 * buffers uptodate and dirty, sets the page uptodate if all buffers in the

 * page are uptodate, and updates i_size if the end of io is beyond i_size.  In

 * that case, it also marks the inode dirty.

 *

 * If things have gone as outlined in

 * ntfs_prepare_pages_for_non_resident_write(), we do not need to do any page

 * content modifications here for non-resident attributes.  For resident

 * attributes we need to do the uptodate bringing here which we combine with

 * the copying into the mft record which means we save one atomic kmap.

 *

 * Return 0 on success or -errno on error.

	/*

	 * Attribute is resident, implying it is not compressed, encrypted, or

	 * sparse.

 Map, pin, and lock the mft record. */

 The total length of the attribute value. */

 Copy the received data from the page to the mft record. */

 Update the attribute length if necessary. */

	/*

	 * If the page is not uptodate, bring the out of bounds area(s)

	 * uptodate by copying data from the mft record to the page.

 Zero the region outside the end of the attribute value. */

 Update initialized_size/i_size if necessary. */

 Mark the mft record dirty, so it gets written back. */

			/*

			 * Put the page on mapping->dirty_pages, but leave its

			 * buffers' dirty state as-is.

/*

 * Copy as much as we can into the pages and return the number of bytes which

 * were successfully copied.  If a fault is encountered then clear the pages

 * out to (ofs + bytes) and return the number of bytes which were copied.

 Zero the rest of the target like __copy_from_user(). */

/**

 * ntfs_perform_write - perform buffered write to a file

 * @file:	file to write to

 * @i:		iov_iter with data to write

 * @pos:	byte offset in file at which to begin writing to

	/*

	 * If a previous ntfs_truncate() failed, repeat it and abort if it

	 * fails again.

	/*

	 * Determine the number of pages per cluster for non-resident

	 * attributes.

				/*

				 * Get the lcn of the vcn the write is in.  If

				 * it is a hole, need to lock down all pages in

				 * the cluster.

		/*

		 * Bring in the user page(s) that we will copy from _first_.

		 * Otherwise there is a nasty deadlock on copying from the same

		 * page(s) as we are writing to, without it/them being marked

		 * up-to-date.  Note, at present there is nothing to stop the

		 * pages being swapped out between us bringing them into memory

		 * and doing the actual copying.

 Get and lock @do_pages starting at index @start_idx. */

		/*

		 * For non-resident attributes, we need to fill any holes with

		 * actual clusters and ensure all bufferes are mapped.  We also

		 * need to bring uptodate any buffers that are only partially

		 * being written to.

/**

 * ntfs_file_write_iter - simple wrapper for ntfs_file_write_iter_nolock()

 * @iocb:	IO state structure

 * @from:	iov_iter with data to write

 *

 * Basically the same as generic_file_write_iter() except that it ends up

 * up calling ntfs_perform_write() instead of generic_perform_write() and that

 * O_DIRECT is not implemented.

 We can write back this queue in page reclaim. */

/**

 * ntfs_file_fsync - sync a file to disk

 * @filp:	file to be synced

 * @datasync:	if non-zero only flush user data and not metadata

 *

 * Data integrity sync of a file to disk.  Used for fsync, fdatasync, and msync

 * system calls.  This function is inspired by fs/buffer.c::file_fsync().

 *

 * If @datasync is false, write the mft record and all associated extent mft

 * records as well as the $DATA attribute and then sync the block device.

 *

 * If @datasync is true and the attribute is non-resident, we skip the writing

 * of the mft record and all associated extent mft records (this might still

 * happen due to the write_inode_now() call).

 *

 * Also, if @datasync is true, we do not wait on the inode to be written out

 * but we always wait on the page cache pages to be written out.

 *

 * Locking: Caller must hold i_mutex on the inode.

 *

 * TODO: We should probably also write all attribute/index inodes associated

 * with this inode but since we have no simple way of getting to them we ignore

 * this problem for now.

	/*

	 * NOTE: If we were to use mapping->private_list (see ext2 and

	 * fs/buffer.c) for dirty blocks then we could optimize the below to be

	 * sync_mapping_buffers(vi->i_mapping).

 NTFS_RW */

 NTFS_RW */

 NTFS_RW */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * quota.c - NTFS kernel quota ($Quota) handling.  Part of the Linux-NTFS

 *	     project.

 *

 * Copyright (c) 2004 Anton Altaparmakov

/**

 * ntfs_mark_quotas_out_of_date - mark the quotas out of date on an ntfs volume

 * @vol:	ntfs volume on which to mark the quotas out of date

 *

 * Mark the quotas out of date on the ntfs volume @vol and return 'true' on

 * success and 'false' on error.

 If quotas are already marked out of date, no need to do anything. */

	/*

	 * If quota tracking is neither requested, nor enabled and there are no

	 * pending deletes, no need to mark the quotas out of date.

	/*

	 * Set the QUOTA_FLAG_OUT_OF_DATE bit thus marking quotas out of date.

	 * This is verified on WinXP to be sufficient to cause windows to

	 * rescan the volume on boot and update all quota entries.

 Ensure the modified flags are written to disk. */

	/*

	 * We set the flag so we do not try to mark the quotas out of date

	 * again on remount.

 NTFS_RW */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * unistr.c - NTFS Unicode string handling. Part of the Linux-NTFS project.

 *

 * Copyright (c) 2001-2006 Anton Altaparmakov

/*

 * IMPORTANT

 * =========

 *

 * All these routines assume that the Unicode characters are in little endian

 * encoding inside the strings!!!

/*

 * This is used by the name collation functions to quickly determine what

 * characters are (in)valid.

/**

 * ntfs_are_names_equal - compare two Unicode names for equality

 * @s1:			name to compare to @s2

 * @s1_len:		length in Unicode characters of @s1

 * @s2:			name to compare to @s1

 * @s2_len:		length in Unicode characters of @s2

 * @ic:			ignore case bool

 * @upcase:		upcase table (only if @ic == IGNORE_CASE)

 * @upcase_size:	length in Unicode characters of @upcase (if present)

 *

 * Compare the names @s1 and @s2 and return 'true' (1) if the names are

 * identical, or 'false' (0) if they are not identical. If @ic is IGNORE_CASE,

 * the @upcase table is used to performa a case insensitive comparison.

/**

 * ntfs_collate_names - collate two Unicode names

 * @name1:	first Unicode name to compare

 * @name2:	second Unicode name to compare

 * @err_val:	if @name1 contains an invalid character return this value

 * @ic:		either CASE_SENSITIVE or IGNORE_CASE

 * @upcase:	upcase table (ignored if @ic is CASE_SENSITIVE)

 * @upcase_len:	upcase table size (ignored if @ic is CASE_SENSITIVE)

 *

 * ntfs_collate_names collates two Unicode names and returns:

 *

 *  -1 if the first name collates before the second one,

 *   0 if the names match,

 *   1 if the second name collates before the first one, or

 * @err_val if an invalid character is found in @name1 during the comparison.

 *

 * The following characters are considered invalid: '"', '*', '<', '>' and '?'.

 name1_len > name2_len */

/**

 * ntfs_ucsncmp - compare two little endian Unicode strings

 * @s1:		first string

 * @s2:		second string

 * @n:		maximum unicode characters to compare

 *

 * Compare the first @n characters of the Unicode strings @s1 and @s2,

 * The strings in little endian format and appropriate le16_to_cpu()

 * conversion is performed on non-little endian machines.

 *

 * The function returns an integer less than, equal to, or greater than zero

 * if @s1 (or the first @n Unicode characters thereof) is found, respectively,

 * to be less than, to match, or be greater than @s2.

/**

 * ntfs_ucsncasecmp - compare two little endian Unicode strings, ignoring case

 * @s1:			first string

 * @s2:			second string

 * @n:			maximum unicode characters to compare

 * @upcase:		upcase table

 * @upcase_size:	upcase table size in Unicode characters

 *

 * Compare the first @n characters of the Unicode strings @s1 and @s2,

 * ignoring case. The strings in little endian format and appropriate

 * le16_to_cpu() conversion is performed on non-little endian machines.

 *

 * Each character is uppercased using the @upcase table before the comparison.

 *

 * The function returns an integer less than, equal to, or greater than zero

 * if @s1 (or the first @n Unicode characters thereof) is found, respectively,

 * to be less than, to match, or be greater than @s2.

/**

 * ntfs_nlstoucs - convert NLS string to little endian Unicode string

 * @vol:	ntfs volume which we are working with

 * @ins:	input NLS string buffer

 * @ins_len:	length of input string in bytes

 * @outs:	on return contains the allocated output Unicode string buffer

 *

 * Convert the input string @ins, which is in whatever format the loaded NLS

 * map dictates, into a little endian, 2-byte Unicode string.

 *

 * This function allocates the string and the caller is responsible for

 * calling kmem_cache_free(ntfs_name_cache, *@outs); when finished with it.

 *

 * On success the function returns the number of Unicode characters written to

 * the output string *@outs (>= 0), not counting the terminating Unicode NULL

 * character. *@outs is set to the allocated output string buffer.

 *

 * On error, a negative number corresponding to the error code is returned. In

 * that case the output string is not allocated. Both *@outs and *@outs_len

 * are then undefined.

 *

 * This might look a bit odd due to fast path optimization...

 We do not trust outside sources. */

 else if (!wc) */

				} /* else if (wc_len < 0 ||

 else if (!ucs) */

 else if (!ins) */

 if (o >= NTFS_MAX_NAME_LEN) */ {

/**

 * ntfs_ucstonls - convert little endian Unicode string to NLS string

 * @vol:	ntfs volume which we are working with

 * @ins:	input Unicode string buffer

 * @ins_len:	length of input string in Unicode characters

 * @outs:	on return contains the (allocated) output NLS string buffer

 * @outs_len:	length of output string buffer in bytes

 *

 * Convert the input little endian, 2-byte Unicode string @ins, of length

 * @ins_len into the string format dictated by the loaded NLS.

 *

 * If *@outs is NULL, this function allocates the string and the caller is

 * responsible for calling kfree(*@outs); when finished with it. In this case

 * @outs_len is ignored and can be 0.

 *

 * On success the function returns the number of bytes written to the output

 * string *@outs (>= 0), not counting the terminating NULL byte. If the output

 * string buffer was allocated, *@outs is set to it.

 *

 * On error, a negative number corresponding to the error code is returned. In

 * that case the output string is not allocated. The contents of *@outs are

 * then undefined.

 *

 * This might look a bit odd due to fast path optimization...

 We don't trust outside sources. */

 Grow in multiples of 64 bytes. */

 No memory so goto conversion_error; */

 wc < 0, real error. */

 else (!ins) */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * logfile.c - NTFS kernel journal handling. Part of the Linux-NTFS project.

 *

 * Copyright (c) 2002-2007 Anton Altaparmakov

/**

 * ntfs_check_restart_page_header - check the page header for consistency

 * @vi:		$LogFile inode to which the restart page header belongs

 * @rp:		restart page header to check

 * @pos:	position in @vi at which the restart page header resides

 *

 * Check the restart page header @rp for consistency and return 'true' if it is

 * consistent and 'false' otherwise.

 *

 * This function only needs NTFS_BLOCK_SIZE bytes in @rp, i.e. it does not

 * require the full restart page.

	/*

	 * If the system or log page sizes are smaller than the ntfs block size

	 * or either is not a power of 2 we cannot handle this log file.

	/*

	 * We must be either at !pos (1st restart page) or at pos = system page

	 * size (2nd restart page).

 We only know how to handle version 1.1. */

	/*

	 * If chkdsk has been run the restart page may not be protected by an

	 * update sequence array.

 Verify the size of the update sequence array. */

 Verify the position of the update sequence array. */

	/*

	 * Verify the position of the restart area.  It must be:

	 *	- aligned to 8-byte boundary,

	 *	- after the update sequence array, and

	 *	- within the system page size.

	/*

	 * Only restart pages modified by chkdsk are allowed to have chkdsk_lsn

	 * set.

/**

 * ntfs_check_restart_area - check the restart area for consistency

 * @vi:		$LogFile inode to which the restart page belongs

 * @rp:		restart page whose restart area to check

 *

 * Check the restart area of the restart page @rp for consistency and return

 * 'true' if it is consistent and 'false' otherwise.

 *

 * This function assumes that the restart page header has already been

 * consistency checked.

 *

 * This function only needs NTFS_BLOCK_SIZE bytes in @rp, i.e. it does not

 * require the full restart page.

	/*

	 * Everything before ra->file_size must be before the first word

	 * protected by an update sequence number.  This ensures that it is

	 * safe to access ra->client_array_offset.

	/*

	 * Now that we can access ra->client_array_offset, make sure everything

	 * up to the log client array is before the first word protected by an

	 * update sequence number.  This ensures we can access all of the

	 * restart area elements safely.  Also, the client array offset must be

	 * aligned to an 8-byte boundary.

	/*

	 * The restart area must end within the system page size both when

	 * calculated manually and as specified by ra->restart_area_length.

	 * Also, the calculated length must not exceed the specified length.

	/*

	 * The ra->client_free_list and ra->client_in_use_list must be either

	 * LOGFILE_NO_CLIENT or less than ra->log_clients or they are

	 * overflowing the client array.

	/*

	 * Check ra->seq_number_bits against ra->file_size for consistency.

	 * We cannot just use ffs() because the file size is not a power of 2.

 The log record header length must be a multiple of 8. */

 Dito for the log page data offset. */

/**

 * ntfs_check_log_client_array - check the log client array for consistency

 * @vi:		$LogFile inode to which the restart page belongs

 * @rp:		restart page whose log client array to check

 *

 * Check the log client array of the restart page @rp for consistency and

 * return 'true' if it is consistent and 'false' otherwise.

 *

 * This function assumes that the restart page header and the restart area have

 * already been consistency checked.

 *

 * Unlike ntfs_check_restart_page_header() and ntfs_check_restart_area(), this

 * function needs @rp->system_page_size bytes in @rp, i.e. it requires the full

 * restart page and the page must be multi sector transfer deprotected.

	/*

	 * Check the ra->client_free_list first and then check the

	 * ra->client_in_use_list.  Check each of the log client records in

	 * each of the lists and check that the array does not overflow the

	 * ra->log_clients value.  Also keep track of the number of records

	 * visited as there cannot be more than ra->log_clients records and

	 * that way we detect eventual loops in within a list.

 Set @cr to the current log client record. */

 The first log client record must not have a prev_client. */

 Switch to and check the in use list if we just did the free list. */

/**

 * ntfs_check_and_load_restart_page - check the restart page for consistency

 * @vi:		$LogFile inode to which the restart page belongs

 * @rp:		restart page to check

 * @pos:	position in @vi at which the restart page resides

 * @wrp:	[OUT] copy of the multi sector transfer deprotected restart page

 * @lsn:	[OUT] set to the current logfile lsn on success

 *

 * Check the restart page @rp for consistency and return 0 if it is consistent

 * and -errno otherwise.  The restart page may have been modified by chkdsk in

 * which case its magic is CHKD instead of RSTR.

 *

 * This function only needs NTFS_BLOCK_SIZE bytes in @rp, i.e. it does not

 * require the full restart page.

 *

 * If @wrp is not NULL, on success, *@wrp will point to a buffer containing a

 * copy of the complete multi sector transfer deprotected page.  On failure,

 * *@wrp is undefined.

 *

 * Simillarly, if @lsn is not NULL, on success *@lsn will be set to the current

 * logfile lsn according to this restart page.  On failure, *@lsn is undefined.

 *

 * The following error codes are defined:

 *	-EINVAL	- The restart page is inconsistent.

 *	-ENOMEM	- Not enough memory to load the restart page.

 *	-EIO	- Failed to reading from $LogFile.

 Check the restart page header for consistency. */

 Error output already done inside the function. */

 Check the restart area for consistency. */

 Error output already done inside the function. */

	/*

	 * Allocate a buffer to store the whole restart page so we can multi

	 * sector transfer deprotect it.

	/*

	 * Read the whole of the restart page into the buffer.  If it fits

	 * completely inside @rp, just copy it from there.  Otherwise map all

	 * the required pages and copy the data from them.

 First copy what we already have in @rp. */

 Copy the remaining data one page at a time. */

	/*

	 * Perform the multi sector transfer deprotection on the buffer if the

	 * restart page is protected.

		/*

		 * A multi sector tranfer error was detected.  We only need to

		 * abort if the restart page contents exceed the multi sector

		 * transfer fixup of the first sector.

	/*

	 * If the restart page is modified by chkdsk or there are no active

	 * logfile clients, the logfile is consistent.  Otherwise, need to

	 * check the log client records for consistency, too.

 if (ntfs_is_chkd_record(rp->magic)) */

/**

 * ntfs_check_logfile - check the journal for consistency

 * @log_vi:	struct inode of loaded journal $LogFile to check

 * @rp:		[OUT] on success this is a copy of the current restart page

 *

 * Check the $LogFile journal for consistency and return 'true' if it is

 * consistent and 'false' if not.  On success, the current restart page is

 * returned in *@rp.  Caller must call ntfs_free(*@rp) when finished with it.

 *

 * At present we only check the two restart pages and ignore the log record

 * pages.

 *

 * Note that the MstProtected flag is not set on the $LogFile inode and hence

 * when reading pages they are not deprotected.  This is because we do not know

 * if the $LogFile was created on a system with a different page size to ours

 * yet and mst deprotection would fail if our page size is smaller.

 An empty $LogFile must have been clean before it got emptied. */

 Make sure the file doesn't exceed the maximum allowed size. */

	/*

	 * Truncate size to a multiple of the page cache size or the default

	 * log page size if the page cache size is between the default log page

	 * log page size if the page cache size is between the default log page

	 * size and twice that.

	/*

	 * Use ntfs_ffs() instead of ffs() to enable the compiler to

	 * optimize log_page_size and log_page_bits into constants.

	/*

	 * Ensure the log file is big enough to store at least the two restart

	 * pages and the minimum number of log record pages.

	/*

	 * Read through the file looking for a restart page.  Since the restart

	 * page header is at the beginning of a page we only need to search at

	 * what could be the beginning of a page (for each page size) rather

	 * than scanning the whole file byte by byte.  If all potential places

	 * contain empty and uninitialzed records, the log file can be assumed

	 * to be empty.

		/*

		 * A non-empty block means the logfile is not empty while an

		 * empty block after a non-empty block has been encountered

		 * means we are done.

		/*

		 * A log record page means there cannot be a restart page after

		 * this so no need to continue searching.

 If not a (modified by chkdsk) restart page, continue. */

		/*

		 * Check the (modified by chkdsk) restart page for consistency

		 * and get a copy of the complete multi sector transfer

		 * deprotected restart page.

			/*

			 * If we have now found the first (modified by chkdsk)

			 * restart page, continue looking for the second one.

			/*

			 * We have now found the second (modified by chkdsk)

			 * restart page, so we can stop looking.

		/*

		 * Error output already done inside the function.  Note, we do

		 * not abort if the restart page was invalid as we might still

		 * find a valid one further in the file.

 Continue looking. */

 If both restart pages were found, use the more recent one. */

		/*

		 * If the second restart area is more recent, switch to it.

		 * Otherwise just throw it away.

 rstr1_lsn = rstr2_lsn; */

 All consistency checks passed. */

/**

 * ntfs_is_logfile_clean - check in the journal if the volume is clean

 * @log_vi:	struct inode of loaded journal $LogFile to check

 * @rp:		copy of the current restart page

 *

 * Analyze the $LogFile journal and return 'true' if it indicates the volume was

 * shutdown cleanly and 'false' if not.

 *

 * At present we only look at the two restart pages and ignore the log record

 * pages.  This is a little bit crude in that there will be a very small number

 * of cases where we think that a volume is dirty when in fact it is clean.

 * This should only affect volumes that have not been shutdown cleanly but did

 * not have any pending, non-check-pointed i/o, i.e. they were completely idle

 * at least for the five seconds preceding the unclean shutdown.

 *

 * This function assumes that the $LogFile journal has already been consistency

 * checked by a call to ntfs_check_logfile() and in particular if the $LogFile

 * is empty this function requires that NVolLogFileEmpty() is true otherwise an

 * empty volume will be reported as dirty.

 An empty $LogFile must have been clean before it got emptied. */

	/*

	 * If the $LogFile has active clients, i.e. it is open, and we do not

	 * have the RESTART_VOLUME_IS_CLEAN bit set in the restart area flags,

	 * we assume there was an unclean shutdown.

 $LogFile indicates a clean shutdown. */

/**

 * ntfs_empty_logfile - empty the contents of the $LogFile journal

 * @log_vi:	struct inode of loaded journal $LogFile to empty

 *

 * Empty the contents of the $LogFile journal @log_vi and return 'true' on

 * success and 'false' on error.

 *

 * This function assumes that the $LogFile journal has already been consistency

 * checked by a call to ntfs_check_logfile() and that ntfs_is_logfile_clean()

 * has been used to ensure that the $LogFile is clean.

	/*

	 * We cannot use ntfs_attr_set() because we may be still in the middle

	 * of a mount operation.  Thus we do the emptying by hand by first

	 * zapping the page cache pages for the $LogFile/$DATA attribute and

	 * then emptying each of the buffers in each of the clusters specified

	 * by the runlist by hand.

 Seek to the runlist element containing @vcn. */

		/*

		 * If this run is not mapped map it now and start again as the

		 * runlist will have been updated.

 If this run is not valid abort with an error. */

 Skip holes. */

 Iterate over the blocks in the run and empty them. */

 Obtain the buffer, possibly not uptodate. */

 Setup buffer i/o submission. */

 Set the entire contents of the buffer to 0xff. */

			/*

			 * Submit the buffer and wait for i/o to complete but

			 * only for the first buffer so we do not miss really

			 * serious i/o errors.  Once the first buffer has

			 * completed ignore errors afterwards as we can assume

			 * that if one buffer worked all of them will work.

	/*

	 * Zap the pages again just in case any got instantiated whilst we were

	 * emptying the blocks by hand.  FIXME: We may not have completed

	 * writing to all the buffer heads yet so this may happen too early.

	 * We really should use a kernel thread to do the emptying

	 * asynchronously and then we can also set the volume dirty and output

	 * an error message if emptying should fail.

 Set the flag so we do not have to do it again on remount. */

 NTFS_RW */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * bitmap.c - NTFS kernel bitmap handling.  Part of the Linux-NTFS project.

 *

 * Copyright (c) 2004-2005 Anton Altaparmakov

/**

 * __ntfs_bitmap_set_bits_in_run - set a run of bits in a bitmap to a value

 * @vi:			vfs inode describing the bitmap

 * @start_bit:		first bit to set

 * @count:		number of bits to set

 * @value:		value to set the bits to (i.e. 0 or 1)

 * @is_rollback:	if 'true' this is a rollback operation

 *

 * Set @count bits starting at bit @start_bit in the bitmap described by the

 * vfs inode @vi to @value, where @value is either 0 or 1.

 *

 * @is_rollback should always be 'false', it is for internal use to rollback

 * errors.  You probably want to use ntfs_bitmap_set_bits_in_run() instead.

 *

 * Return 0 on success and -errno on error.

	/*

	 * Calculate the indices for the pages containing the first and last

	 * bits, i.e. @start_bit and @start_bit + @cnt - 1, respectively.

 Get the page containing the first bit (@start_bit). */

 Set @pos to the position of the byte containing @start_bit. */

 Calculate the position of @start_bit in the first byte. */

 If the first byte is partial, modify the appropriate bits in it. */

 If we are done, unmap the page and return success. */

 Update @pos to the new position. */

	/*

	 * Depending on @value, modify all remaining whole bytes in the page up

	 * to @cnt.

 Update @len to point to the first not-done byte in the page. */

 If we are not in the last page, deal with all subsequent pages. */

 Update @index and get the next page. */

		/*

		 * Depending on @value, modify all remaining whole bytes in the

		 * page up to @cnt.

	/*

	 * The currently mapped page is the last one.  If the last byte is

	 * partial, modify the appropriate bits in it.  Note, @len is the

	 * position of the last byte inside the page.

 We are done.  Unmap the page and return success. */

	/*

	 * Current state:

	 *	- no pages are mapped

	 *	- @count - @cnt is the number of bits that have been modified

 Rollback was successful. */

 Rollback failed. */

 NTFS_RW */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * debug.c - NTFS kernel debug support. Part of the Linux-NTFS project.

 *

 * Copyright (c) 2001-2004 Anton Altaparmakov

/**

 * __ntfs_warning - output a warning to the syslog

 * @function:	name of function outputting the warning

 * @sb:		super block of mounted ntfs filesystem

 * @fmt:	warning string containing format specifications

 * @...:	a variable number of arguments specified in @fmt

 *

 * Outputs a warning to the syslog for the mounted ntfs filesystem described

 * by @sb.

 *

 * @fmt and the corresponding @... is printf style format string containing

 * the warning string and the corresponding format arguments, respectively.

 *

 * @function is the name of the function from which __ntfs_warning is being

 * called.

 *

 * Note, you should be using debug.h::ntfs_warning(@sb, @fmt, @...) instead

 * as this provides the @function parameter automatically.

/**

 * __ntfs_error - output an error to the syslog

 * @function:	name of function outputting the error

 * @sb:		super block of mounted ntfs filesystem

 * @fmt:	error string containing format specifications

 * @...:	a variable number of arguments specified in @fmt

 *

 * Outputs an error to the syslog for the mounted ntfs filesystem described

 * by @sb.

 *

 * @fmt and the corresponding @... is printf style format string containing

 * the error string and the corresponding format arguments, respectively.

 *

 * @function is the name of the function from which __ntfs_error is being

 * called.

 *

 * Note, you should be using debug.h::ntfs_error(@sb, @fmt, @...) instead

 * as this provides the @function parameter automatically.

 If 1, output debug messages, and if 0, don't. */

 Dump a runlist. Caller has to provide synchronisation for @rl. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * collate.c - NTFS kernel collation handling.  Part of the Linux-NTFS project.

 *

 * Copyright (c) 2004 Anton Altaparmakov

 FIXME:  We don't really want to bug here.

ntfs_collate_file_name*/,

ntfs_collate_unicode_string*/,

ntfs_collate_ntofs_sid*/,

ntfs_collate_ntofs_security_hash*/,

ntfs_collate_ntofs_ulongs*/,

/**

 * ntfs_collate - collate two data items using a specified collation rule

 * @vol:	ntfs volume to which the data items belong

 * @cr:		collation rule to use when comparing the items

 * @data1:	first data item to collate

 * @data1_len:	length in bytes of @data1

 * @data2:	second data item to collate

 * @data2_len:	length in bytes of @data2

 *

 * Collate the two data items @data1 and @data2 using the collation rule @cr

 * and return -1, 0, ir 1 if @data1 is found, respectively, to collate before,

 * to match, or to collate after @data2.

 *

 * For speed we use the collation rule @cr as an index into two tables of

 * function pointers to call the appropriate collation function.

	/*

	 * FIXME:  At the moment we only support COLLATION_BINARY and

	 * COLLATION_NTOFS_ULONG, so we BUG() for everything else for now.

 SPDX-License-Identifier: GPL-2.0-or-later

/**

 * aops.c - NTFS kernel address space operations and page cache handling.

 *

 * Copyright (c) 2001-2014 Anton Altaparmakov and Tuxera Inc.

 * Copyright (c) 2002 Richard Russon

/**

 * ntfs_end_buffer_async_read - async io completion for reading attributes

 * @bh:		buffer head on which io is completed

 * @uptodate:	whether @bh is now uptodate or not

 *

 * Asynchronous I/O completion handler for reading pages belonging to the

 * attribute address space of an inode.  The inodes can either be files or

 * directories or they can be fake inodes describing some attribute.

 *

 * If NInoMstProtected(), perform the post read mst fixups when all IO on the

 * page has been completed and mark the page uptodate or set the error bit on

 * the page.  To determine the size of the records that need fixing up, we

 * cheat a little bit by setting the index_block_size in ntfs_inode to the ntfs

 * record size, and index_block_size_bits, to the log(base 2) of the ntfs

 * record size.

 Race with shrinking truncate. */

 Check for the current buffer head overflowing. */

 Async buffers must be locked. */

	/*

	 * If none of the buffers had errors then we can set the page uptodate,

	 * but we first have to perform the post read mst fixups, if the

	 * attribute is mst protected, i.e. if NInoMstProteced(ni) is true.

	 * Note we ignore fixup errors as those are detected when

	 * map_mft_record() is called which gives us per record granularity

	 * rather than per page granularity.

 Should have been verified before we got here... */

/**

 * ntfs_read_block - fill a @page of an address space with data

 * @page:	page cache page to fill with data

 *

 * Fill the page @page of the address space belonging to the @page->host inode.

 * We read each buffer asynchronously and when all buffers are read in, our io

 * completion handler ntfs_end_buffer_read_async(), if required, automatically

 * applies the mst fixups to the page before finally marking it uptodate and

 * unlocking it.

 *

 * We only enforce allocated_size limit because i_size is checked for in

 * generic_file_read().

 *

 * Return 0 on success and -errno on error.

 *

 * Contains an adapted version of fs/buffer.c::block_read_full_page().

 $MFT/$DATA must have its complete runlist in memory at all times. */

	/*

	 * We may be racing with truncate.  To avoid some of the problems we

	 * now take a snapshot of the various sizes and use those for the whole

	 * of the function.  In case of an extending truncate it just means we

	 * may leave some buffers unmapped which are now allocated.  This is

	 * not a problem since these buffers will just get mapped when a write

	 * occurs.  In case of a shrinking truncate, we will detect this later

	 * on due to the runlist being incomplete and if the page is being

	 * fully truncated, truncate will throw it away as soon as we unlock

	 * it so no need to worry what we do with it.

 Race with shrinking truncate. */

 Loop through all the buffers in the page. */

 Is the block within the allowed limits? */

 Convert iblock into corresponding vcn and offset. */

 Seek to element containing target vcn. */

 Successful remap. */

 Setup buffer head to correct block. */

 Only read initialized data blocks. */

 Fully non-initialized data block, zero it. */

 It is a hole, need to zero it. */

 If first try and runlist unmapped, map and retry. */

				/*

				 * Attempt to map runlist, dropping lock for

				 * the duration.

			/*

			 * If buffer is outside the runlist, treat it as a

			 * hole.  This can happen due to concurrent truncate

			 * for example.

 Hard error, zero out region. */

		/*

		 * Either iblock was outside lblock limits or

		 * ntfs_rl_vcn_to_lcn() returned error.  Just zero that portion

		 * of the page and set the buffer uptodate.

 Release the lock if we took it. */

 Check we have at least one buffer ready for i/o. */

 Lock the buffers. */

 Finally, start i/o on the buffers. */

 No i/o was scheduled on any of the buffers. */

 Signal synchronous i/o error. */

/**

 * ntfs_readpage - fill a @page of a @file with data from the device

 * @file:	open file to which the page @page belongs or NULL

 * @page:	page cache page to fill with data

 *

 * For non-resident attributes, ntfs_readpage() fills the @page of the open

 * file @file by calling the ntfs version of the generic block_read_full_page()

 * function, ntfs_read_block(), which in turn creates and reads in the buffers

 * associated with the page asynchronously.

 *

 * For resident attributes, OTOH, ntfs_readpage() fills @page by copying the

 * data from the mft record (which at this stage is most likely in memory) and

 * fills the remainder with zeroes. Thus, in this case, I/O is synchronous, as

 * even if the mft record is not cached at this point in time, we need to wait

 * for it to be read in before we can do the copy.

 *

 * Return 0 on success and -errno on error.

 Is the page fully outside i_size? (truncate in progress) */

	/*

	 * This can potentially happen because we clear PageUptodate() during

	 * ntfs_writepage() of MstProtected() attributes.

	/*

	 * Only $DATA attributes can be encrypted and only unnamed $DATA

	 * attributes can be compressed.  Index root can have the flags set but

	 * this means to create compressed/encrypted files, not that the

	 * attribute is compressed/encrypted.  Note we need to check for

	 * AT_INDEX_ALLOCATION since this is the type of both directory and

	 * index inodes.

 If attribute is encrypted, deny access, just like NT4. */

 Compressed data streams are handled in compress.c. */

 NInoNonResident() == NInoIndexAllocPresent() */

 Normal, non-resident data stream. */

	/*

	 * Attribute is resident, implying it is not compressed or encrypted.

	 * This also means the attribute is smaller than an mft record and

	 * hence smaller than a page, so can simply zero out any pages with

	 * index above 0.  Note the attribute can actually be marked compressed

	 * but if it is resident the actual data is not compressed so we are

	 * ok to ignore the compressed flag here.

 Map, pin, and lock the mft record. */

	/*

	 * If a parallel write made the attribute non-resident, drop the mft

	 * record and retry the readpage.

 Race with shrinking truncate. */

 Copy the data to the page. */

 Zero the remainder of the page. */

/**

 * ntfs_write_block - write a @page to the backing store

 * @page:	page cache page to write out

 * @wbc:	writeback control structure

 *

 * This function is for writing pages belonging to non-resident, non-mst

 * protected attributes to their backing store.

 *

 * For a page with buffers, map and write the dirty buffers asynchronously

 * under page writeback. For a page without buffers, create buffers for the

 * page, then proceed as above.

 *

 * If a page doesn't have buffers the page dirty state is definitive. If a page

 * does have buffers, the page dirty state is just a hint, and the buffer dirty

 * state is definitive. (A hint which has rules: dirty buffers against a clean

 * page is illegal. Other combinations are legal and need to be handled. In

 * particular a dirty page containing clean buffers for example.)

 *

 * Return 0 on success and -errno on error.

 *

 * Based on ntfs_read_block() and __block_write_full_page().

			/*

			 * Put the page back on mapping->dirty_pages, but leave

			 * its buffers' dirty state as-is.

 NOTE: Different naming scheme to ntfs_read_block()! */

 The first block in the page. */

 The first out of bounds block for the data size. */

 The last (fully or partially) initialized block. */

	/*

	 * Be very careful.  We have no exclusion from __set_page_dirty_buffers

	 * here, and the (potentially unmapped) buffers may become dirty at

	 * any time.  If a buffer becomes dirty here after we've inspected it

	 * then we just miss that fact, and the page stays dirty.

	 *

	 * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;

	 * handle that here by just cleaning them.

	/*

	 * Loop through all the buffers in the page, mapping all the dirty

	 * buffers to disk addresses and handling any aliases from the

	 * underlying block device's mapping.

			/*

			 * Mapped buffers outside i_size will occur, because

			 * this page can be outside i_size when there is a

			 * truncate in progress. The contents of such buffers

			 * were zeroed by ntfs_writepage().

			 *

			 * FIXME: What about the small race window where

			 * ntfs_writepage() has not done any clearing because

			 * the page was within i_size but before we get here,

			 * vmtruncate() modifies i_size?

 Clean buffers are not written out, so no need to map them. */

 Make sure we have enough initialized size. */

			/*

			 * If this page is fully outside initialized size, zero

			 * out all pages between the current initialized size

			 * and the current page. Just use ntfs_readpage() to do

			 * the zeroing transparently.

 TODO:

 For each page do:

 - read_cache_page()

 Again for each page do:

 - wait_on_page_locked()

 - Check (PageUptodate(page) &&

			!PageError(page))

 Update initialized size in the attribute and

 in the inode.

 Again, for each page do:

	__set_page_dirty_buffers();

 put_page()

 We don't need to wait on the writes.

 Update iblock.

			/*

			 * The current page straddles initialized size. Zero

			 * all non-uptodate buffers and set them uptodate (and

			 * dirty?). Note, there aren't any non-uptodate buffers

			 * if the page is uptodate.

			 * FIXME: For an uptodate page, the buffers may need to

			 * be written out because they were not initialized on

			 * disk before.

 TODO:

 Zero any non-uptodate buffers up to i_size.

 Set them uptodate and dirty.

 TODO:

 Update initialized size in the attribute and in the

 inode (up to i_size).

 Update iblock.

 FIXME: This is inefficient. Try to batch the two

 size changes to happen in one go.

 Do NOT set_buffer_new() BUT DO clear buffer range

 outside write request range.

 set_buffer_uptodate() on complete buffers as well as

 set_buffer_dirty().

 No need to map buffers that are already mapped. */

 Unmapped, dirty buffer. Need to map it. */

 Convert block into corresponding vcn and offset. */

 Seek to element containing target vcn. */

 Successful remap. */

 Setup buffer head to point to correct block. */

 It is a hole, need to instantiate it. */

 Check if the buffer is zero. */

				/*

				 * Buffer is zero and sparse, no need to write

				 * it.

 TODO: Instantiate the hole.

 clear_buffer_new(bh);

 clean_bdev_bh_alias(bh);

 If first try and runlist unmapped, map and retry. */

			/*

			 * Attempt to map runlist, dropping lock for

			 * the duration.

		/*

		 * If buffer is outside the runlist, truncate has cut it out

		 * of the runlist.  Just clean and clear the buffer and set it

		 * uptodate so it can get discarded by the VM.

 Failed to map the buffer, even after retrying. */

 Release the lock if we took it. */

 For the error case, need to reset bh to the beginning. */

 Just an optimization, so ->readpage() is not called later. */

 Setup all mapped, dirty buffers for async write i/o. */

			/*

			 * For the error case. The buffer may have been set

			 * dirty during attachment to a dirty page.

 TODO: Remove the -EOPNOTSUPP check later on...

			/*

			 * Put the page back on mapping->dirty_pages, but

			 * leave its buffer's dirty state as-is.

 Keeps try_to_free_buffers() away. */

 Submit the prepared buffers for i/o. */

 If no i/o was started, need to end_page_writeback(). */

/**

 * ntfs_write_mst_block - write a @page to the backing store

 * @page:	page cache page to write out

 * @wbc:	writeback control structure

 *

 * This function is for writing pages belonging to non-resident, mst protected

 * attributes to their backing store.  The only supported attributes are index

 * allocation and $MFT/$DATA.  Both directory inodes and index inodes are

 * supported for the index allocation case.

 *

 * The page must remain locked for the duration of the write because we apply

 * the mst fixups, write, and then undo the fixups, so if we were to unlock the

 * page before undoing the fixups, any other user of the page will see the

 * page contents as corrupt.

 *

 * We clear the page uptodate flag for the duration of the function to ensure

 * exclusion for the $MFT/$DATA case against someone mapping an mft record we

 * are about to apply the mst fixups to.

 *

 * Return 0 on success and -errno on error.

 *

 * Based on ntfs_write_block(), ntfs_mft_writepage(), and

 * write_mft_record_nolock().

	/*

	 * NOTE: ntfs_write_mst_block() would be called for $MFTMirr if a page

	 * in its page cache were to be marked dirty.  However this should

	 * never happen with the current driver and considering we do not

	 * handle this case here we do want to BUG(), at least for now.

 Were we called for sync purposes? */

 Make sure we have mapped buffers. */

 The first block in the page. */

 The first out of bounds block for the data size. */

			/*

			 * This block is not the first one in the record.  We

			 * ignore the buffer's dirty state because we could

			 * have raced with a parallel mark_ntfs_record_dirty().

 if (block == rec_block) */ {

 This block is the first one in the record. */

 Clean records are not written out. */

 Need to map the buffer if it is not mapped already. */

 Obtain the vcn and offset of the current block. */

 Seek to element containing target vcn. */

 Successful remap. */

 Setup buffer head to correct block. */

				/*

				 * Remap failed.  Retry to map the runlist once

				 * unless we are working on $MFT which always

				 * has the whole of its runlist in memory.

					/*

					 * Attempt to map runlist, dropping

					 * lock for the duration.

 Hard error.  Abort writing this record. */

				/*

				 * If this is not the first buffer, remove the

				 * buffers in this record from the list of

				 * buffers to write and clear their dirty bit

				 * if not error -ENOMEM.

 If there were no dirty buffers, we are done. */

 Map the page so we can access its contents. */

 Clear the page uptodate flag whilst the mst fixups are applied. */

 Skip buffers which are not at the beginning of records. */

 Get the mft record number. */

 Check whether to write this mft record. */

				/*

				 * The record should not be written.  This

				 * means we need to redirty the page before

				 * returning.

				/*

				 * Remove the buffers in this mft record from

				 * the list of buffers to write.

			/*

			 * The record should be written.  If a locked ntfs

			 * inode was returned, add it to the array of locked

			 * ntfs inodes.

 Apply the mst protection fixups. */

			/*

			 * Mark all the buffers in this record clean as we do

			 * not want to write corrupt data to disk.

 If no records are to be written out, we are done. */

 Lock buffers and start synchronous write i/o on them. */

 The buffer dirty state is now irrelevant, just clean it. */

 Synchronize the mft mirror now if not @sync. */

 Wait on i/o completion of buffers. */

			/*

			 * Set the buffer uptodate so the page and buffer

			 * states do not become out of sync.

 If @sync, now synchronize the mft mirror. */

			/*

			 * Skip buffers which are not at the beginning of

			 * records.

 Skip removed buffers (and hence records). */

 Get the mft record number. */

 Remove the mst protection fixups again. */

 Unlock any locked inodes. */

 Get the base inode. */

		/*

		 * Set page error if there is only one ntfs record in the page.

		 * Otherwise we would loose per-record granularity.

		/*

		 * Keep the VM happy.  This must be done otherwise the

		 * radix-tree tag PAGECACHE_TAG_DIRTY remains set even though

		 * the page is clean.

/**

 * ntfs_writepage - write a @page to the backing store

 * @page:	page cache page to write out

 * @wbc:	writeback control structure

 *

 * This is called from the VM when it wants to have a dirty ntfs page cache

 * page cleaned.  The VM has already locked the page and marked it clean.

 *

 * For non-resident attributes, ntfs_writepage() writes the @page by calling

 * the ntfs version of the generic block_write_full_page() function,

 * ntfs_write_block(), which in turn if necessary creates and writes the

 * buffers associated with the page asynchronously.

 *

 * For resident attributes, OTOH, ntfs_writepage() writes the @page by copying

 * the data to the mft record (which at this stage is most likely in memory).

 * The mft record is then marked dirty and written out asynchronously via the

 * vfs inode dirty code path for the inode the mft record belongs to or via the

 * vm page dirty code path for the page the mft record is in.

 *

 * Based on ntfs_readpage() and fs/buffer.c::block_write_full_page().

 *

 * Return 0 on success and -errno on error.

 Is the page fully outside i_size? (truncate in progress) */

		/*

		 * The page may have dirty, unmapped buffers.  Make them

		 * freeable here, so the page does not leak.

	/*

	 * Only $DATA attributes can be encrypted and only unnamed $DATA

	 * attributes can be compressed.  Index root can have the flags set but

	 * this means to create compressed/encrypted files, not that the

	 * attribute is compressed/encrypted.  Note we need to check for

	 * AT_INDEX_ALLOCATION since this is the type of both directory and

	 * index inodes.

 If file is encrypted, deny access, just like NT4. */

 Compressed data streams are handled in compress.c. */

 TODO: Implement and replace this with

 return ntfs_write_compressed_block(page);

 TODO: Implement and remove this check.

 NInoNonResident() == NInoIndexAllocPresent() */

 We have to zero every time due to mmap-at-end-of-file. */

 The page straddles i_size. */

 Handle mst protected attributes. */

 Normal, non-resident data stream. */

	/*

	 * Attribute is resident, implying it is not compressed, encrypted, or

	 * mst protected.  This also means the attribute is smaller than an mft

	 * record and hence smaller than a page, so can simply return error on

	 * any pages with index above 0.  Note the attribute can actually be

	 * marked compressed but if it is resident the actual data is not

	 * compressed so we are ok to ignore the compressed flag here.

 Map, pin, and lock the mft record. */

	/*

	 * If a parallel write made the attribute non-resident, drop the mft

	 * record and retry the writepage.

	/*

	 * Keep the VM happy.  This must be done otherwise the radix-tree tag

	 * PAGECACHE_TAG_DIRTY remains set even though the page is clean.

 Race with shrinking truncate or a failed truncate. */

		/*

		 * If the truncate failed, fix it up now.  If a concurrent

		 * truncate, we do its job, so it does not have to do anything.

 Shrinking cannot fail. */

 Copy the data from the page to the mft record. */

 Zero out of bounds area in the page cache page. */

 We are done with the page. */

 Finally, mark the mft record dirty, so it gets written back. */

		/*

		 * Put the page back on mapping->dirty_pages, but leave its

		 * buffers' dirty state as-is.

 NTFS_RW */

/**

 * ntfs_bmap - map logical file block to physical device block

 * @mapping:	address space mapping to which the block to be mapped belongs

 * @block:	logical block to map to its physical device block

 *

 * For regular, non-resident files (i.e. not compressed and not encrypted), map

 * the logical @block belonging to the file described by the address space

 * mapping @mapping to its physical device block.

 *

 * The size of the block is equal to the @s_blocksize field of the super block

 * of the mounted file system which is guaranteed to be smaller than or equal

 * to the cluster size thus the block is guaranteed to fit entirely inside the

 * cluster which means we do not need to care how many contiguous bytes are

 * available after the beginning of the block.

 *

 * Return the physical device block if the mapping succeeded or 0 if the block

 * is sparse or there was an error.

 *

 * Note: This is a problem if someone tries to run bmap() on $Boot system file

 * as that really is in block zero but there is nothing we can do.  bmap() is

 * just broken in that respect (just like it cannot distinguish sparse from

 * not available or error).

 None of these can happen. */

	/*

	 * If the offset is outside the initialized size or the block straddles

	 * the initialized size then pretend it is a hole unless the

	 * initialized size equals the file size.

		/*

		 * Step down to an integer to avoid gcc doing a long long

		 * comparision in the switch when we know @lcn is between

		 * LCN_HOLE and LCN_EIO (i.e. -1 to -5).

		 *

		 * Otherwise older gcc (at least on some architectures) will

		 * try to use __cmpdi2() which is of course not available in

		 * the kernel.

			/*

			 * If the offset is out of bounds then pretend it is a

			 * hole.

 It is a hole. */

	/*

	 * The block is really allocated and fullfils all our criteria.

	 * Convert the cluster to units of block size and return the result.

 If the block number was truncated return 0. */

/**

 * ntfs_normal_aops - address space operations for normal inodes and attributes

 *

 * Note these are not used for compressed or mst protected inodes and

 * attributes.

 NTFS_RW */

/**

 * ntfs_compressed_aops - address space operations for compressed inodes

 NTFS_RW */

/**

 * ntfs_mst_aops - general address space operations for mst protecteed inodes

 *		   and attributes

 Fill page with data. */

 Write dirty page to disk. */

	.set_page_dirty	= __set_page_dirty_nobuffers,	/* Set the page dirty

						   without touching the buffers

 NTFS_RW */

/**

 * mark_ntfs_record_dirty - mark an ntfs record dirty

 * @page:	page containing the ntfs record to mark dirty

 * @ofs:	byte offset within @page at which the ntfs record begins

 *

 * Set the buffers and the page in which the ntfs record is located dirty.

 *

 * The latter also marks the vfs inode the ntfs record belongs to dirty

 * (I_DIRTY_PAGES only).

 *

 * If the page does not have buffers, we create them and set them uptodate.

 * The page may not be locked which is why we need to handle the buffers under

 * the mapping->private_lock.  Once the buffers are marked dirty we no longer

 * need the lock since try_to_free_buffers() does not free dirty buffers.

 NTFS_RW */

 SPDX-License-Identifier: GPL-2.0

/*

 *  inode.c - part of debugfs, a tiny little debug file system

 *

 *  Copyright (C) 2004,2019 Greg Kroah-Hartman <greg@kroah.com>

 *  Copyright (C) 2004 IBM Inc.

 *  Copyright (C) 2019 Linux Foundation <gregkh@linuxfoundation.org>

 *

 *  debugfs is for people to use instead of /proc or /sys.

 *  See ./Documentation/core-api/kernel-api.rst for more details.

/*

 * Don't allow access attributes to be changed whilst the kernel is locked down

 * so that we can use the file mode as part of a heuristic to determine whether

 * to lock down individual files.

		/*

		 * We might like to report bad mount options here;

		 * but traditionally debugfs has ignored all mount options

/**

 * debugfs_lookup() - look up an existing debugfs file

 * @name: a pointer to a string containing the name of the file to look up.

 * @parent: a pointer to the parent dentry of the file.

 *

 * This function will return a pointer to a dentry if it succeeds.  If the file

 * doesn't exist or an error occurs, %NULL will be returned.  The returned

 * dentry must be passed to dput() when it is no longer needed.

 *

 * If debugfs is not enabled in the kernel, the value -%ENODEV will be

 * returned.

	/* If the parent is not specified, we create it in the root.

	 * We need the root dentry to do this, which is in the super

	 * block. A pointer to that is in the struct vfsmount that we

	 * have around.

/**

 * debugfs_create_file - create a file in the debugfs filesystem

 * @name: a pointer to a string containing the name of the file to create.

 * @mode: the permission that the file should have.

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @data: a pointer to something that the caller will want to get to later

 *        on.  The inode.i_private pointer will point to this value on

 *        the open() call.

 * @fops: a pointer to a struct file_operations that should be used for

 *        this file.

 *

 * This is the basic "create a file" function for debugfs.  It allows for a

 * wide range of flexibility in creating a file, or a directory (if you want

 * to create a directory, the debugfs_create_dir() function is

 * recommended to be used instead.)

 *

 * This function will return a pointer to a dentry if it succeeds.  This

 * pointer must be passed to the debugfs_remove() function when the file is

 * to be removed (no automatic cleanup happens if your module is unloaded,

 * you are responsible here.)  If an error occurs, ERR_PTR(-ERROR) will be

 * returned.

 *

 * If debugfs is not enabled in the kernel, the value -%ENODEV will be

 * returned.

/**

 * debugfs_create_file_unsafe - create a file in the debugfs filesystem

 * @name: a pointer to a string containing the name of the file to create.

 * @mode: the permission that the file should have.

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @data: a pointer to something that the caller will want to get to later

 *        on.  The inode.i_private pointer will point to this value on

 *        the open() call.

 * @fops: a pointer to a struct file_operations that should be used for

 *        this file.

 *

 * debugfs_create_file_unsafe() is completely analogous to

 * debugfs_create_file(), the only difference being that the fops

 * handed it will not get protected against file removals by the

 * debugfs core.

 *

 * It is your responsibility to protect your struct file_operation

 * methods against file removals by means of debugfs_file_get()

 * and debugfs_file_put(). ->open() is still protected by

 * debugfs though.

 *

 * Any struct file_operations defined by means of

 * DEFINE_DEBUGFS_ATTRIBUTE() is protected against file removals and

 * thus, may be used here.

/**

 * debugfs_create_file_size - create a file in the debugfs filesystem

 * @name: a pointer to a string containing the name of the file to create.

 * @mode: the permission that the file should have.

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @data: a pointer to something that the caller will want to get to later

 *        on.  The inode.i_private pointer will point to this value on

 *        the open() call.

 * @fops: a pointer to a struct file_operations that should be used for

 *        this file.

 * @file_size: initial file size

 *

 * This is the basic "create a file" function for debugfs.  It allows for a

 * wide range of flexibility in creating a file, or a directory (if you want

 * to create a directory, the debugfs_create_dir() function is

 * recommended to be used instead.)

/**

 * debugfs_create_dir - create a directory in the debugfs filesystem

 * @name: a pointer to a string containing the name of the directory to

 *        create.

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is NULL, then the

 *          directory will be created in the root of the debugfs filesystem.

 *

 * This function creates a directory in debugfs with the given name.

 *

 * This function will return a pointer to a dentry if it succeeds.  This

 * pointer must be passed to the debugfs_remove() function when the file is

 * to be removed (no automatic cleanup happens if your module is unloaded,

 * you are responsible here.)  If an error occurs, ERR_PTR(-ERROR) will be

 * returned.

 *

 * If debugfs is not enabled in the kernel, the value -%ENODEV will be

 * returned.

 directory inodes start off with i_nlink == 2 (for "." entry) */

/**

 * debugfs_create_automount - create automount point in the debugfs filesystem

 * @name: a pointer to a string containing the name of the file to create.

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @f: function to be called when pathname resolution steps on that one.

 * @data: opaque argument to pass to f().

 *

 * @f should return what ->d_automount() would.

 directory inodes start off with i_nlink == 2 (for "." entry) */

/**

 * debugfs_create_symlink- create a symbolic link in the debugfs filesystem

 * @name: a pointer to a string containing the name of the symbolic link to

 *        create.

 * @parent: a pointer to the parent dentry for this symbolic link.  This

 *          should be a directory dentry if set.  If this parameter is NULL,

 *          then the symbolic link will be created in the root of the debugfs

 *          filesystem.

 * @target: a pointer to a string containing the path to the target of the

 *          symbolic link.

 *

 * This function creates a symbolic link with the given name in debugfs that

 * links to the given target path.

 *

 * This function will return a pointer to a dentry if it succeeds.  This

 * pointer must be passed to the debugfs_remove() function when the symbolic

 * link is to be removed (no automatic cleanup happens if your module is

 * unloaded, you are responsible here.)  If an error occurs, ERR_PTR(-ERROR)

 * will be returned.

 *

 * If debugfs is not enabled in the kernel, the value -%ENODEV will be

 * returned.

	/*

	 * Paired with the closing smp_mb() implied by a successful

	 * cmpxchg() in debugfs_file_get(): either

	 * debugfs_file_get() must see a dead dentry or we must see a

	 * debugfs_fsdata instance at ->d_fsdata here (or both).

/**

 * debugfs_remove - recursively removes a directory

 * @dentry: a pointer to a the dentry of the directory to be removed.  If this

 *          parameter is NULL or an error value, nothing will be done.

 *

 * This function recursively removes a directory tree in debugfs that

 * was previously created with a call to another debugfs function

 * (like debugfs_create_file() or variants thereof.)

 *

 * This function is required to be called in order for the file to be

 * removed, no automatic cleanup of files will happen when a module is

 * removed, you are responsible here.

/**

 * debugfs_rename - rename a file/directory in the debugfs filesystem

 * @old_dir: a pointer to the parent dentry for the renamed object. This

 *          should be a directory dentry.

 * @old_dentry: dentry of an object to be renamed.

 * @new_dir: a pointer to the parent dentry where the object should be

 *          moved. This should be a directory dentry.

 * @new_name: a pointer to a string containing the target name.

 *

 * This function renames a file/directory in debugfs.  The target must not

 * exist for rename to succeed.

 *

 * This function will return a pointer to old_dentry (which is updated to

 * reflect renaming) if it succeeds. If an error occurs, %NULL will be

 * returned.

 *

 * If debugfs is not enabled in the kernel, the value -%ENODEV will be

 * returned.

 Source or destination directories don't exist? */

 Source does not exist, cyclic rename, or mountpoint? */

 Lookup failed, cyclic rename or target exists? */

/**

 * debugfs_initialized - Tells whether debugfs has been registered

 SPDX-License-Identifier: GPL-2.0

/*

 *  file.c - part of debugfs, a tiny little debug file system

 *

 *  Copyright (C) 2004 Greg Kroah-Hartman <greg@kroah.com>

 *  Copyright (C) 2004 IBM Inc.

 *

 *  debugfs is for people to use instead of /proc or /sys.

 *  See Documentation/filesystems/ for more details.

		/*

		 * Urgh, we've been called w/o a protecting

		 * debugfs_file_get().

/**

 * debugfs_file_get - mark the beginning of file data access

 * @dentry: the dentry object whose data is being accessed.

 *

 * Up to a matching call to debugfs_file_put(), any successive call

 * into the file removing functions debugfs_remove() and

 * debugfs_remove_recursive() will block. Since associated private

 * file data may only get freed after a successful return of any of

 * the removal functions, you may safely access it after a successful

 * call to debugfs_file_get() without worrying about lifetime issues.

 *

 * If -%EIO is returned, the file has already been removed and thus,

 * it is not safe to access any of its data. If, on the other hand,

 * it is allowed to access the file data, zero is returned.

	/*

	 * In case of a successful cmpxchg() above, this check is

	 * strictly necessary and must follow it, see the comment in

	 * __debugfs_remove_file().

	 * OTOH, if the cmpxchg() hasn't been executed or wasn't

	 * successful, this serves the purpose of not starving

	 * removers.

/**

 * debugfs_file_put - mark the end of file data access

 * @dentry: the dentry object formerly passed to

 *          debugfs_file_get().

 *

 * Allow any ongoing concurrent call into debugfs_remove() or

 * debugfs_remove_recursive() blocked by a former call to

 * debugfs_file_get() to proceed and return to its caller.

/*

 * Only permit access to world-readable files when the kernel is locked down.

 * We also need to exclude any file that has ways to write or alter it as root

 * can bypass the permissions check.

 Huh? Module did not clean up after itself at exit? */

	/*

	 * We must not protect this against removal races here: the

	 * original releaser should be called unconditionally in order

	 * not to leak any resources. Releasers must not assume that

	 * ->i_private is still being meaningful here.

 Huh? Module did not cleanup after itself at exit? */

 No protection against file removal anymore. */

 if there are no write bits set, make read only */

 if there are no read bits set, make write only */

/**

 * debugfs_create_u8 - create a debugfs file that is used to read and write an unsigned 8-bit value

 * @name: a pointer to a string containing the name of the file to create.

 * @mode: the permission that the file should have

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is %NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @value: a pointer to the variable that the file should read to and write

 *         from.

 *

 * This function creates a file in debugfs with the given name that

 * contains the value of the variable @value.  If the @mode variable is so

 * set, it can be read from, and written to.

/**

 * debugfs_create_u16 - create a debugfs file that is used to read and write an unsigned 16-bit value

 * @name: a pointer to a string containing the name of the file to create.

 * @mode: the permission that the file should have

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is %NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @value: a pointer to the variable that the file should read to and write

 *         from.

 *

 * This function creates a file in debugfs with the given name that

 * contains the value of the variable @value.  If the @mode variable is so

 * set, it can be read from, and written to.

/**

 * debugfs_create_u32 - create a debugfs file that is used to read and write an unsigned 32-bit value

 * @name: a pointer to a string containing the name of the file to create.

 * @mode: the permission that the file should have

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is %NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @value: a pointer to the variable that the file should read to and write

 *         from.

 *

 * This function creates a file in debugfs with the given name that

 * contains the value of the variable @value.  If the @mode variable is so

 * set, it can be read from, and written to.

/**

 * debugfs_create_u64 - create a debugfs file that is used to read and write an unsigned 64-bit value

 * @name: a pointer to a string containing the name of the file to create.

 * @mode: the permission that the file should have

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is %NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @value: a pointer to the variable that the file should read to and write

 *         from.

 *

 * This function creates a file in debugfs with the given name that

 * contains the value of the variable @value.  If the @mode variable is so

 * set, it can be read from, and written to.

/**

 * debugfs_create_ulong - create a debugfs file that is used to read and write

 * an unsigned long value.

 * @name: a pointer to a string containing the name of the file to create.

 * @mode: the permission that the file should have

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is %NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @value: a pointer to the variable that the file should read to and write

 *         from.

 *

 * This function creates a file in debugfs with the given name that

 * contains the value of the variable @value.  If the @mode variable is so

 * set, it can be read from, and written to.

/*

 * debugfs_create_x{8,16,32,64} - create a debugfs file that is used to read and write an unsigned {8,16,32,64}-bit value

 *

 * These functions are exactly the same as the above functions (but use a hex

 * output for the decimal challenged). For details look at the above unsigned

 * decimal functions.

/**

 * debugfs_create_x8 - create a debugfs file that is used to read and write an unsigned 8-bit value

 * @name: a pointer to a string containing the name of the file to create.

 * @mode: the permission that the file should have

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is %NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @value: a pointer to the variable that the file should read to and write

 *         from.

/**

 * debugfs_create_x16 - create a debugfs file that is used to read and write an unsigned 16-bit value

 * @name: a pointer to a string containing the name of the file to create.

 * @mode: the permission that the file should have

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is %NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @value: a pointer to the variable that the file should read to and write

 *         from.

/**

 * debugfs_create_x32 - create a debugfs file that is used to read and write an unsigned 32-bit value

 * @name: a pointer to a string containing the name of the file to create.

 * @mode: the permission that the file should have

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is %NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @value: a pointer to the variable that the file should read to and write

 *         from.

/**

 * debugfs_create_x64 - create a debugfs file that is used to read and write an unsigned 64-bit value

 * @name: a pointer to a string containing the name of the file to create.

 * @mode: the permission that the file should have

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is %NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @value: a pointer to the variable that the file should read to and write

 *         from.

 %llu and %zu are more or less the same */

/**

 * debugfs_create_size_t - create a debugfs file that is used to read and write an size_t value

 * @name: a pointer to a string containing the name of the file to create.

 * @mode: the permission that the file should have

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is %NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @value: a pointer to the variable that the file should read to and write

 *         from.

/**

 * debugfs_create_atomic_t - create a debugfs file that is used to read and

 * write an atomic_t value

 * @name: a pointer to a string containing the name of the file to create.

 * @mode: the permission that the file should have

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is %NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @value: a pointer to the variable that the file should read to and write

 *         from.

/**

 * debugfs_create_bool - create a debugfs file that is used to read and write a boolean value

 * @name: a pointer to a string containing the name of the file to create.

 * @mode: the permission that the file should have

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is %NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @value: a pointer to the variable that the file should read to and write

 *         from.

 *

 * This function creates a file in debugfs with the given name that

 * contains the value of the variable @value.  If the @mode variable is so

 * set, it can be read from, and written to.

 This is really only for read-only strings */

/**

 * debugfs_create_str - create a debugfs file that is used to read and write a string value

 * @name: a pointer to a string containing the name of the file to create.

 * @mode: the permission that the file should have

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is %NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @value: a pointer to the variable that the file should read to and write

 *         from.

 *

 * This function creates a file in debugfs with the given name that

 * contains the value of the variable @value.  If the @mode variable is so

 * set, it can be read from, and written to.

 *

 * This function will return a pointer to a dentry if it succeeds.  This

 * pointer must be passed to the debugfs_remove() function when the file is

 * to be removed (no automatic cleanup happens if your module is unloaded,

 * you are responsible here.)  If an error occurs, ERR_PTR(-ERROR) will be

 * returned.

 *

 * If debugfs is not enabled in the kernel, the value ERR_PTR(-ENODEV) will

 * be returned.

/**

 * debugfs_create_blob - create a debugfs file that is used to read a binary blob

 * @name: a pointer to a string containing the name of the file to create.

 * @mode: the read permission that the file should have (other permissions are

 *	  masked out)

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is %NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @blob: a pointer to a struct debugfs_blob_wrapper which contains a pointer

 *        to the blob data and the size of the data.

 *

 * This function creates a file in debugfs with the given name that exports

 * @blob->data as a binary blob. If the @mode variable is so set it can be

 * read from. Writing is not supported.

 *

 * This function will return a pointer to a dentry if it succeeds.  This

 * pointer must be passed to the debugfs_remove() function when the file is

 * to be removed (no automatic cleanup happens if your module is unloaded,

 * you are responsible here.)  If an error occurs, ERR_PTR(-ERROR) will be

 * returned.

 *

 * If debugfs is not enabled in the kernel, the value ERR_PTR(-ENODEV) will

 * be returned.

	/*

	 * Max size:

	 *  - 10 digits + ' '/'\n' = 11 bytes per number

	 *  - terminating NUL character

/**

 * debugfs_create_u32_array - create a debugfs file that is used to read u32

 * array.

 * @name: a pointer to a string containing the name of the file to create.

 * @mode: the permission that the file should have.

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is %NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @array: wrapper struct containing data pointer and size of the array.

 *

 * This function creates a file in debugfs with the given name that exports

 * @array as data. If the @mode variable is so set it can be read from.

 * Writing is not supported. Seek within the file is also not supported.

 * Once array is created its size can not be changed.

/*

 * The regset32 stuff is used to print 32-bit registers using the

 * seq_file utilities. We offer printing a register set in an already-opened

 * sequential file or create a debugfs file that only prints a regset32.

/**

 * debugfs_print_regs32 - use seq_print to describe a set of registers

 * @s: the seq_file structure being used to generate output

 * @regs: an array if struct debugfs_reg32 structures

 * @nregs: the length of the above array

 * @base: the base address to be used in reading the registers

 * @prefix: a string to be prefixed to every output line

 *

 * This function outputs a text block describing the current values of

 * some 32-bit hardware registers. It is meant to be used within debugfs

 * files based on seq_file that need to show registers, intermixed with other

 * information. The prefix argument may be used to specify a leading string,

 * because some peripherals have several blocks of identical registers,

 * for example configuration of dma channels

/**

 * debugfs_create_regset32 - create a debugfs file that returns register values

 * @name: a pointer to a string containing the name of the file to create.

 * @mode: the permission that the file should have

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *          directory dentry if set.  If this parameter is %NULL, then the

 *          file will be created in the root of the debugfs filesystem.

 * @regset: a pointer to a struct debugfs_regset32, which contains a pointer

 *          to an array of register definitions, the array size and the base

 *          address where the register bank is to be found.

 *

 * This function creates a file in debugfs with the given name that reports

 * the names and values of a set of 32-bit registers. If the @mode variable

 * is so set it can be read from. Writing is not supported.

 CONFIG_HAS_IOMEM */

/**

 * debugfs_create_devm_seqfile - create a debugfs file that is bound to device.

 *

 * @dev: device related to this debugfs file.

 * @name: name of the debugfs file.

 * @parent: a pointer to the parent dentry for this file.  This should be a

 *	directory dentry if set.  If this parameter is %NULL, then the

 *	file will be created in the root of the debugfs filesystem.

 * @read_fn: function pointer called to print the seq_file content.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Persistent Storage - ramfs parts.

 *

 * Copyright (C) 2010 Intel Corporation <tony.luck@intel.com>

/*

 * When a file is unlinked from our file system we call the

 * platform driver to erase the record from persistent store.

 Make sure we can't race while removing this file. */

/*

 * Display the mount options in /proc/mounts.

	/*

	 * Having no backend is fine -- no records appear.

	 * Not being mounted is fine -- nothing to do.

/*

 * Make a regular file in the root directory of our file system.

 * Load it up with "size" bytes of data from "buf".

 * Set the mtime & ctime to the date that this record was originally stored.

 Skip records that are already present in the filesystem. */

/*

 * Read all the records from the persistent store. Create

 * files in our filesystem.  Don't warn about -EEXIST errors

 * when we are re-scanning the backing store looking to add new

 * error records.

 Create a convenient mount point for people to access pstore */

 SPDX-License-Identifier: GPL-2.0

/*

 * Implements pstore backend driver that write to block (or non-block) storage

 * devices, using the pstore/zone API.

/*

 * blkdev - the block device to use for pstore storage

 * See Documentation/admin-guide/pstore-blk.rst for details.

/*

 * All globals must only be accessed under the pstore_blk_lock

 * during the register/unregister functions.

 Synchronize module parameters with resuls. */	\

 someone already registered before */

 zero means not limit on which backends to attempt to store. */

 Copy in module parameters. */

 Initialize required zone ownership details. */

/**

 * register_pstore_device() - register non-block device to pstore/blk

 *

 * @dev: non-block device information

 *

 * Return:

 * * 0		- OK

 * * Others	- something error.

/**

 * unregister_pstore_device() - unregister non-block device from pstore/blk

 *

 * @dev: non-block device information

 Console/Ftrace backend may handle buffer until flush dirty zones */

/*

 * This takes its configuration only from the module parameters now.

 get information of pstore/blk */

	/*

	 * During early boot the real root file system hasn't been

	 * mounted yet, and no device nodes are present yet. Use the

	 * same scheme to find the device that we use for mounting

	 * the root file system.

 No best-effort mode requested. */

 Reject an empty blkdev. */

	/*

	 * Currently, the only user of psblk_file is best_effort, so

	 * we can assume that pstore_device_info is associated with it.

	 * Once there are "real" blk devices, there will need to be a

	 * dedicated pstore_blk_info, etc.

 If we've been asked to unload, unregister any remaining device. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2012  Google, Inc.

 This doesn't need to be atomic: speed is chosen over correctness here. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * RAM Oops/Panic logger

 *

 * Copyright (C) 2010 Marco Stornelli <marco.stornelli@gmail.com>

 * Copyright (C) 2011 Kees Cook <keescook@chromium.org>

 Oops dump zones */

 Console zone */

 Ftrace zones */

 PMSG zone */

 _read_cnt need clear on ramoops_pstore_open */

 Give up if we never existed or have hit the end. */

 Update old/shadowed buffer. */

	/*

	 * Ramoops headers provide time stamps for PSTORE_TYPE_DMESG, but

	 * PSTORE_TYPE_CONSOLE and PSTORE_TYPE_FTRACE don't currently have

	 * valid time stamps, so it is initialized to zero.

 Find the next valid persistent_ram_zone for DMESG */

 Clear and skip this DMESG record if it has no valid header */

 single */, record);

 single */, record);

 ftrace is last since it may want to dynamically allocate memory. */

 single */,

			/*

			 * Build a new dummy record which combines all the

			 * per-cpu records including metadata and ecc info.

 ECC correction notice */

 "===="(4), %lld(20), "."(1), %06lu(6), "-%c\n"(3) */

		/*

		 * Choose zone by if we're using per-cpu buffers.

	/*

	 * We could filter on record->reason here if we wanted to (which

	 * would duplicate what happened before the "max_reason" setting

	 * was added), but that would defeat the purpose of a system

	 * changing printk.always_kmsg_dump, so instead log everything that

	 * the kmsg dumper sends us, since it should be doing the filtering

	 * based on the combination of printk.always_kmsg_dump and our

	 * requested "max_reason".

	/*

	 * Explicitly only take the first part of any new crash.

	 * If our buffer is larger than kmsg_bytes, this can never happen,

	 * and if our buffer is smaller than kmsg_bytes, we don't want the

	 * report split across multiple records.

	/*

	 * Since this is a new crash dump, we need to reset the buffer in

	 * case it still has an old dump present. Without this, the new dump

	 * will get appended, which would seriously confuse anything trying

	 * to check dump file contents. Specifically, ramoops_read_kmsg_hdr()

	 * expects to find a dump header in the beginning of buffer data, so

	 * we must to reset the buffer values, in order to ensure that the

	 * header will be written to the beginning of the buffer.

 Build header and append record contents. */

 Free dump PRZs */

 Free ftrace PRZs */

 Allocate nothing for 0 mem_sz or 0 record_size. */

	/*

	 * If we have a negative record size, calculate it based on

	 * mem_sz / *cnt. If we have a positive record size, calculate

	 * cnt from mem_sz / record_size.

 Read a u32 from a dt property and make sure it's safe for an int. */

 field is missing, use default value. */

 Sanity check our results. */

	/*

	 * Setting "unbuffered" is deprecated and will be ignored if

	 * "mem_type" is also specified.

	/*

	 * Setting "no-dump-oops" is deprecated and will be ignored if

	 * "max_reason" is also specified.

	/*

	 * Some old Chromebooks relied on the kernel setting the

	 * console_size and pmsg_size to the record size since that's

	 * what the downstream kernel did.  These same Chromebooks had

	 * "ramoops" straight under the root node which isn't

	 * according to the current upstream bindings (though it was

	 * arguably acceptable under a prior version of the bindings).

	 * Let's make those old Chromebooks work by detecting that

	 * we're not a child of "reserved-memory" and mimicking the

	 * expected behavior.

	/*

	 * Only a single ramoops area allowed at a time, so fail extra

	 * probes.

 Make sure we didn't get bogus platform data pointer. */

	/*

	 * Prepare frontend flags based on which areas are initialized.

	 * For ramoops_init_przs() cases, the "max count" variable tells

	 * if there are regions present. For ramoops_init_prz() cases,

	 * the single region size is how to check.

	/*

	 * Since bufsize is only used for dmesg crash dumps, it

	 * must match the size of the dprz record (after PRZ header

	 * and ECC bytes have been accounted for).

	/*

	 * Update the module parameter variables as well so they are visible

	 * through /sys/module/ramoops/parameters/

	/*

	 * Prepare a dummy platform data structure to carry the module

	 * parameters. If mem_size isn't set, then there are no module

	 * parameters, and we can skip this.

 If "max_reason" is set, its value has priority over "dump_oops". */

 Otherwise, if "dump_oops" is set, parse it into "max_reason". */

 And if neither are explicitly set, use the default. */

	/*

	 * For backwards compatibility ramoops.ecc=1 means 16 bytes ECC

	 * (using 1 byte for ECC isn't much of use anyway).

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Persistent Storage - platform driver interface parts.

 *

 * Copyright (C) 2007-2008 Google, Inc.

 * Copyright (C) 2010 Intel Corporation <tony.luck@intel.com>

/*

 * We defer making "oops" entries appear in pstore - see

 * whether the system is actually still running well enough

 * to let someone see the entry

 Names should be in the same order as the enum pstore_type_id */

/*

 * psinfo_lock protects "psinfo" during calls to

 * pstore_register(), pstore_unregister(), and

 * the filesystem mount/unmount routines.

 Compression parameters */

 How much of the console log to snapshot */

 Tag each group of saved records with a sequence number */

/*

 * Should pstore_dump() wait for a concurrent pstore_dump()? If

 * not, the current pstore_dump() will report a failure to dump

 * and return.

 In NMI path, pstore shouldn't block regardless of reason. */

 In panic case, other cpus are stopped by smp_send_stop(). */

 Emergency restart shouldn't be blocked. */

 buffer range for efivars */

 buffer range for nvram, erst */

 Skip if not built-in or compression backend not selected yet. */

 Skip if no pstore backend yet or compression init already done. */

 A non-NULL big_oops_buf indicates compression is available. */

/*

 * Called when compression fails, since the printk buffer

 * would be fetched for compression calling it again when

 * compression fails would have moved the iterator of

 * printk buffer which results in fetching old contents.

 * Copy the recent messages from big_oops_buf to psinfo->buf

 Report zeroed timestamp if called before timekeeping has resumed. */

/*

 * callback from kmsg_dump. Save as much as we can (up to kmsg_bytes) from the

 * end of the buffer.

 Failed to acquire lock: give up if we cannot wait. */

 Write dump header. */

 Write dump contents. */

/*

 * Register with kmsg_dump to save last part of console log on panic.

 Show which backend is going to get console writes. */

	/*

	 * Always initialize flags here since prior unregister_console()

	 * calls may have changed settings (specifically CON_ENABLED).

/*

 * platform specific persistent storage driver registers with

 * us here. If pstore is already mounted, call the platform

 * read function right away to populate the file system. If not

 * then the pstore mount code will call us later to fill out

 * the file system.

 Sanity check flags. */

 Check for required functions. */

 Start watching for new records, if desired. */

	/*

	 * Update the module parameter backend, so it is visible

	 * through /sys/module/pstore/parameters/backend

 It's okay to unregister nothing. */

 Only one backend can be registered at a time. */

 Unregister all callbacks. */

 Stop timer and make sure all work has finished. */

 Remove all backend records from filesystem tree. */

 Only PSTORE_TYPE_DMESG support compression. */

 Missing compression buffer means compression was not initialized. */

 Allocate enough space to hold max decompression and ECC. */

 After decompression "unzipped_len" is almost certainly smaller. */

 Append ECC notice to decompressed buffer. */

 Copy decompressed contents into an minimum-sized allocation. */

 Swap out compressed contents with decompressed contents. */

/*

 * Read all the records from one persistent store backend. Create

 * files in our filesystem.  Don't warn about -EEXIST errors

 * when we are re-scanning the backing store looking to add new

 * error records.

	/*

	 * Backend callback read() allocates record.buf. decompress_record()

	 * may reallocate record.buf. On success, pstore_mkfile() will keep

	 * the record.buf, so free it only on failure.

 No more records left in backend? */

 pstore_mkfile() did not take record, so free it. */

	/*

	 * Check if any pstore backends registered earlier but did not

	 * initialize compression because crypto was not ready. If so,

	 * initialize compression now.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014  Google, Inc.

 check outside lock, page in any data. write_user also checks */

 SPDX-License-Identifier: GPL-2.0

/*

 * Provide a pstore intermediate backend, organized into kernel memory

 * allocated zones that are then mapped and flushed into a single

 * contiguous region on a storage backend of some kind (block, mtd, etc).

/**

 * struct psz_buffer - header of zone to flush to storage

 *

 * @sig: signature to indicate header (PSZ_SIG xor PSZONE-type value)

 * @datalen: length of data in @data

 * @start: offset into @data where the beginning of the stored bytes begin

 * @data: zone data.

 DBGC */

/**

 * struct psz_kmsg_header - kmsg dump-specific header to flush to storage

 *

 * @magic: magic num for kmsg dump header

 * @time: kmsg dump trigger time

 * @compressed: whether conpressed

 * @counter: kmsg dump counter

 * @reason: the kmsg dump reason (e.g. oops, panic, etc)

 * @data: pointer to log data

 *

 * This is a sub-header for a kmsg dump, trailing after &psz_buffer.

 Just a random number */

/**

 * struct pstore_zone - single stored buffer

 *

 * @off: zone offset of storage

 * @type: front-end type for this zone

 * @name: front-end name for this zone

 * @buffer: pointer to data buffer managed by this zone

 * @oldbuf: pointer to old data buffer

 * @buffer_size: bytes in @buffer->data

 * @should_recover: whether this zone should recover from storage

 * @dirty: whether the data in @buffer dirty

 *

 * zone structure in memory.

/**

 * struct psz_context - all about running state of pstore/zone

 *

 * @kpszs: kmsg dump storage zones

 * @ppsz: pmsg storage zone

 * @cpsz: console storage zone

 * @fpszs: ftrace storage zones

 * @kmsg_max_cnt: max count of @kpszs

 * @kmsg_read_cnt: counter of total read kmsg dumps

 * @kmsg_write_cnt: counter of total kmsg dump writes

 * @pmsg_read_cnt: counter of total read pmsg zone

 * @console_read_cnt: counter of total read console zone

 * @ftrace_max_cnt: max count of @fpszs

 * @ftrace_read_cnt: counter of max read ftrace zone

 * @oops_counter: counter of oops dumps

 * @panic_counter: counter of panic dumps

 * @recovered: whether finished recovering data from storage

 * @on_panic: whether panic is happening

 * @pstore_zone_info_lock: lock to @pstore_zone_info

 * @pstore_zone_info: information from backend

 * @pstore: structure for pstore

	/*

	 * These counters should be calculated during recovery.

	 * It records the oops/panic times after crashes rather than boots.

	/*

	 * pstore_zone_info_lock protects this entire structure during calls

	 * to register_pstore_zone()/unregister_pstore_zone().

/**

 * enum psz_flush_mode - flush mode for psz_zone_write()

 *

 * @FLUSH_NONE: do not flush to storage but update data on memory

 * @FLUSH_PART: just flush part of data including meta data to storage

 * @FLUSH_META: just flush meta data of zone to storage

 * @FLUSH_ALL: flush all of zone

 avoid to damage old records */

 no need to mark dirty if going to try next zone */

 flush dirty zones nicely */

	/*

	 * Recover may on panic, we can't allocate any memory by kmalloc.

	 * So, we use local array instead.

		/*

		 * we get the newest zone, and the next one must be the oldest

		 * or unused zone, because we do write one by one like a circle.

 save data as much as possible */

 just keep going */

 get part of data */

 get the rest of data */

/**

 * psz_recovery() - recover data from storage

 * @cxt: the context of pstore/zone

 *

 * recovery means reading data back from storage after rebooting

 *

 * Return: 0 on success, others on failure.

 this zone is already updated, no need to erase */

	/*

	 * if there are new data in zone buffer, that means the old data

	 * are already invalid. It is no need to flush 0 (erase) to

	 * block device.

/*

 * In case zone is broken, which may occur to MTD device, we try each zones,

 * start at cxt->kmsg_write_cnt.

 avoid destroying old data, allocate a new one */

 no need to try next zone, free last zone buffer */

	/*

	 * Explicitly only take the first part of any new crash.

	 * If our buffer is larger than kmsg_bytes, this can never happen,

	 * and if our buffer is smaller than kmsg_bytes, we don't want the

	 * report split across multiple records.

 ensure all data are flushed to storage when panic */

 always return 0 as we had handled it on buffer */

	/**

	 * psz_zone_write will set datalen as start + cnt.

	 * It work if actual data length lesser than buffer size.

	 * If data length greater than buffer size, pmsg will rewrite to

	 * beginning of zone, which make buffer->datalen wrongly.

	 * So we should reset datalen as buffer size once actual data length

	 * greater than buffer size.

	/*

	 * if on panic, do not write except panic records

	 * Fix case that panic_write prints log which wakes up console backend.

		/*

		 * No need psz_old_ok(). Let psz_ftrace_read() do so for

		 * combination. psz_ftrace_read() should traverse over

		 * all zones in case of some zone without data.

 Clear and skip this kmsg dump record if it has no valid header */

 try to combine all ftrace zones */

 then, read next ftrace zone */

 before read, we must recover from storage */

/**

 * register_pstore_zone() - register to pstore/zone

 *

 * @info: back-end driver information. See &struct pstore_zone_info.

 *

 * Only one back-end at one time.

 *

 * Return: 0 on success, others on failure.

	/*

	 * the @read and @write must be applied.

	 * if no @read, pstore may mount failed.

	 * if no @write, pstore do not support to remove record file.

/**

 * unregister_pstore_zone() - unregister to pstore/zone

 *

 * @info: back-end driver information. See struct pstore_zone_info.

 Stop incoming writes from pstore. */

 Flush any pending writes. */

 Clean up allocations. */

 Clear counters and zone state. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2012 Google, Inc.

/**

 * struct persistent_ram_buffer - persistent circular RAM buffer

 *

 * @sig:

 *	signature to indicate header (PERSISTENT_RAM_SIG xor PRZ-type value)

 * @start:

 *	offset into @data where the beginning of the stored bytes begin

 * @size:

 *	number of valid bytes stored in @data

 DBGC */

 increase and wrap the start pointer, returning the old value */

 increase the size counter until it hits the max size */

 Initialize the parity buffer */

	/*

	 * first consecutive root is 0

	 * primitive element to generate roots = 1

 allocate workspace instead of using stack VLA */

	/*

	 * Since vmap() uses page granularity, we must add the offset

	 * into the page here, to get the byte granularity address

	 * into the mapping to represent the actual "start" location.

	/*

	 * Since request_mem_region() and ioremap() are byte-granularity

	 * there is no need handle anything special like we do when the

	 * vmap() case in persistent_ram_vmap() above.

 Reset missing, invalid, or single-use memory area. */

 We must vunmap() at page-granularity. */

 Initialize general buffer state. */

 SPDX-License-Identifier: GPL-2.0-only

/* inode.c: /proc/openprom handling routines

 *

 * Copyright (C) 1996-1999 Jakub Jelinek  (jakub@redhat.com)

 * Copyright (C) 1998      Eddie C. Dost  (ecd@skynet.be)

 Skip over the NULL byte too.  */

 Nothing to do */

 First, the children nodes as directories.  */

 Next, the properties as files.  */

	/*

	 * Make sure all delayed rcu free inodes are flushed before we

	 * destroy cache.

/*

 * linux/fs/nls/nls_koi8-ru.c

 *

 * Charset koi8-ru translation based on charset koi8-u.

 * The Unicode to charset table has only exact mappings.

 koi8-ru and koi8-u differ only on two characters */

 fast path */

 koi8-ru and koi8-u differ only on two characters */

/*

 * linux/fs/nls/nls_cp874.c

 *

 * Charset cp874 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_iso8859-2.c

 *

 * Charset iso8859-2 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_iso8859-7.c

 *

 * Charset iso8859-7 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_cp862.c

 *

 * Charset cp862 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_cp857.c

 *

 * Charset cp857 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_iso8859-15.c

 *

 * Charset iso8859-15 translation tables.

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_cp1251.c

 *

 * Charset cp1251 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/mac-iceland.c

 *

 * Charset maciceland translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

/*

 * COPYRIGHT AND PERMISSION NOTICE

 *

 * Copyright 1991-2012 Unicode, Inc.  All rights reserved.  Distributed under

 * the Terms of Use in http://www.unicode.org/copyright.html.

 *

 * Permission is hereby granted, free of charge, to any person obtaining a

 * copy of the Unicode data files and any associated documentation (the "Data

 * Files") or Unicode software and any associated documentation (the

 * "Software") to deal in the Data Files or Software without restriction,

 * including without limitation the rights to use, copy, modify, merge,

 * publish, distribute, and/or sell copies of the Data Files or Software, and

 * to permit persons to whom the Data Files or Software are furnished to do

 * so, provided that (a) the above copyright notice(s) and this permission

 * notice appear with all copies of the Data Files or Software, (b) both the

 * above copyright notice(s) and this permission notice appear in associated

 * documentation, and (c) there is clear notice in each modified Data File or

 * in the Software as well as in the documentation associated with the Data

 * File(s) or Software that the data or software has been modified.

 *

 * THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY

 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF

 * THIRD PARTY RIGHTS.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS

 * INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT

 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF

 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR

 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR

 * PERFORMANCE OF THE DATA FILES OR SOFTWARE.

 *

 * Except as contained in this notice, the name of a copyright holder shall

 * not be used in advertising or otherwise to promote the sale, use or other

 * dealings in these Data Files or Software without prior written

 * authorization of the copyright holder.

 0x00 */

 0x10 */

 0x20 */

 0x30 */

 0x40 */

 0x50 */

 0x60 */

 0x70 */

 0x80 */

 0x90 */

 0xa0 */

 0xb0 */

 0xc0 */

 0xd0 */

 0xe0 */

 0xf0 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_cp866.c

 *

 * Charset cp866 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_base.c

 *

 * Native language support--charsets and unicode translations.

 * By Gordon Chaffee 1996, 1997

 *

 * Unicode based case conversion 1999 by Wolfram Pienkoss

 *

/*

 * Sample implementation from Unicode home page.

 * http://www.stonehand.com/unicode/standard/fss-utf.html

 1 byte sequence */},

 2 byte sequence */},

 3 byte sequence */},

 4 byte sequence */},

 5 byte sequence */},

 6 byte sequence */},

 end of table    */}

 Ignore character and move on */

 Ignore character and move on */

 Ignore character and move on */

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 Returns a simple default translation table */

/*

 * linux/fs/nls/nls_iso8859-5.c

 *

 * Charset iso8859-5 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_cp861.c

 *

 * Charset cp861 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_ascii.c

 *

 * Charset ascii translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

/*

 * linux/fs/nls/nls_cp936.c

 *

 * Charset cp936 translation tables.

 * This translation table was generated automatically, the

 * original table can be download from the Microsoft website.

 * (http://www.microsoft.com/typography/unicode/unicodecp.htm)

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0x00-0x03 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 Euro symbol.The only exception with a non-ascii unicode */

 handle the U00 plane*/

 if (cl == 0) return -EINVAL;*/ 
 Euro symbol.The only exception with a non-ascii unicode */

 Euro symbol.The only exception with a non-ascii unicode */

/*

 * linux/fs/nls/nls_cp852.c

 *

 * Charset cp852 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_cp949.c

 *

 * Charset cp949 translation tables.

 * This translation table was generated automatically, the

 * original table can be download from the Microsoft website.

 * (http://www.microsoft.com/typography/unicode/unicodecp.htm)

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0x00-0x03 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_cp932.c

 *

 * Charset cp932 translation tables.

 * This translation table was generated automatically, the

 * original table can be download from the Microsoft website.

 * (http://www.microsoft.com/typography/unicode/unicodecp.htm)

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0x00-0x03 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

