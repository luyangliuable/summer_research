 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  acpi_bus.c - ACPI Bus Driver ($Revision: 80 $)

 *

 *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

	/*

	 * Invoke DSDT corruption work-around on all Toshiba Satellite.

	 * https://bugzilla.kernel.org/show_bug.cgi?id=14679

/* --------------------------------------------------------------------------

                                Device Management

 Battery devices must have their deps met before calling _STA */

 Setting up input parameters */

 Need to ignore the bit0 in result code */

/*

 * ACPI 6.0 Section 8.4.4.2 Idle State Coordination

 * OSPM supports platform coordinated low power idle(LPI) states

/*

 * ACPI 6.4 Operating System Capabilities for USB.

 _PR3 is in use */

 Now run _OSC again with query flag clear */

/*

 * Native control of USB4 capabilities. If any of the tunneling bits is

 * set it means OS is in control and we use software based connection

 * manager.

/* --------------------------------------------------------------------------

                             Notification Handling

/**

 * acpi_bus_notify

 * ---------------

 * Callback for all 'system-level' device notifications (values 0x00-0x7F).

 TBD: Exactly what does 'light' mean? */

 Fixed hardware devices have no handles */

 Handle events targeting \_SB device (at present only graceful shutdown) */

	/*

	 * After initiating graceful shutdown, the ACPI spec requires OSPM

	 * to evaluate _OST method once every 10seconds to indicate that

	 * the shutdown is in progress

/* --------------------------------------------------------------------------

                             Device Matching

/**

 * acpi_get_first_physical_node - Get first physical node of an ACPI device

 * @adev:	ACPI device in question

 *

 * Return: First physical node of ACPI device @adev

/**

 * acpi_device_is_first_physical_node - Is given dev first physical node

 * @adev: ACPI companion device

 * @dev: Physical device to check

 *

 * Function checks if given @dev is the first physical devices attached to

 * the ACPI companion device. This distinction is needed in some cases

 * where the same companion device is shared between many physical devices.

 *

 * Note that the caller have to provide valid @adev pointer.

/*

 * acpi_companion_match() - Can we match via ACPI companion device

 * @dev: Device in question

 *

 * Check if the given device has an ACPI companion and if that companion has

 * a valid list of PNP IDs, and if the device is the first (primary) physical

 * device associated with it.  Return the companion pointer if that's the case

 * or NULL otherwise.

 *

 * If multiple physical devices are attached to a single ACPI companion, we need

 * to be careful.  The usage scenario for this kind of relationship is that all

 * of the physical devices in question use resources provided by the ACPI

 * companion.  A typical case is an MFD device where all the sub-devices share

 * the parent's ACPI companion.  In such cases we can only allow the primary

 * (first) physical device to be matched with the help of the companion's PNP

 * IDs.

 *

 * Additional physical devices sharing the ACPI companion can still use

 * resources available from it but they will be matched normally using functions

 * provided by their bus types (and analogously for their modalias).

/**

 * acpi_of_match_device - Match device object using the "compatible" property.

 * @adev: ACPI device object to match.

 * @of_match_table: List of device IDs to match against.

 * @of_id: OF ID if matched

 *

 * If @dev has an ACPI companion which has ACPI_DT_NAMESPACE_HID in its list of

 * identifiers and a _DSD object with the "compatible" property, use that

 * property to match against the given list of identifiers.

 Must be ACPI_TYPE_STRING. */

 Now we can look for the driver DT compatible strings */

 Must be ACPI_TYPE_STRING. */

/**

 * acpi_set_modalias - Set modalias using "compatible" property or supplied ID

 * @adev:	ACPI device object to match

 * @default_id:	ID string to use as default if no compatible string found

 * @modalias:   Pointer to buffer that modalias value will be copied into

 * @len:	Length of modalias buffer

 *

 * This is a counterpart of of_modalias_node() for struct acpi_device objects.

 * If there is a compatible string for @adev, it will be copied to @modalias

 * with the vendor prefix stripped; otherwise, @default_id will be used.

 Apply class-code bitmask, before checking each class-code byte */

	/*

	 * If the device is not present, it is unnecessary to load device

	 * driver for it.

 First, check the ACPI/PNP IDs provided by the caller. */

		/*

		 * Next, check ACPI_DT_NAMESPACE_HID and try to match the

		 * "compatible" property if found.

/**

 * acpi_match_device - Match a struct device against a given list of ACPI IDs

 * @ids: Array of struct acpi_device_id object to match against.

 * @dev: The device structure to match.

 *

 * Check if @dev has a valid ACPI handle and if there is a struct acpi_device

 * object for that handle and use that object to match against a given list of

 * device IDs.

 *

 * Return a pointer to the first matching ID on success or %NULL on failure.

/* --------------------------------------------------------------------------

                              ACPI Driver Management

/**

 * acpi_bus_register_driver - register a driver with the ACPI bus

 * @driver: driver being registered

 *

 * Registers a driver with the ACPI bus.  Searches the namespace for all

 * devices that match the driver's criteria and binds.  Returns zero for

 * success or a negative error status for failure.

/**

 * acpi_bus_unregister_driver - unregisters a driver with the ACPI bus

 * @driver: driver to unregister

 *

 * Unregisters a driver with the ACPI bus.  Searches the namespace for all

 * devices that match the driver's criteria and unbinds.

/* --------------------------------------------------------------------------

                              ACPI Bus operations

/* --------------------------------------------------------------------------

                             Initialization/Cleanup

	/*

	 * Let the system know what interrupt model we are using by

	 * evaluating the \_PIC object, if exists.

/**

 * acpi_early_init - Initialize ACPICA and populate the ACPI namespace.

 *

 * The ACPI tables are accessible after this, but the handling of events has not

 * been initialized and the global lock is not available yet, so AML should not

 * be executed at this point.

 *

 * Doing this before switching the EFI runtime services to virtual mode allows

 * the EfiBootServices memory to be freed slightly earlier on boot.

 enable workarounds, unless strict ACPI spec. compliance */

	/*

	 * If the machine falls into the DMI check table,

	 * DSDT will be copied to memory.

	 * Note that calling dmi_check_system() here on other architectures

	 * would not be OK because only x86 initializes dmi early enough.

	 * Thankfully only x86 systems need such quirks for now.

 compatible (0) means level (3) */

 Set PIC-mode SCI trigger type */

		/*

		 * now that acpi_gbl_FADT is initialized,

		 * update it with result from INT_SRC_OVR parsing

/**

 * acpi_subsystem_init - Finalize the early initialization of ACPI.

 *

 * Switch over the platform to the ACPI mode (if possible).

 *

 * Doing this too early is generally unsafe, but at the same time it needs to be

 * done before all things that really depend on ACPI.  The right spot appears to

 * be before finalizing the EFI initialization.

		/*

		 * If the system is using ACPI then we can be reasonably

		 * confident that any regulators are managed by the firmware

		 * so tell the regulator core it has everything it needs to

		 * know.

	/*

	 * ACPI 2.0 requires the EC driver to be loaded and work before the EC

	 * device is found in the namespace.

	 *

	 * This is accomplished by looking for the ECDT table and getting the EC

	 * parameters out of that.

	 *

	 * Do that before calling acpi_initialize_objects() which may trigger EC

	 * address space accesses.

 Set capability bits for _OSC under processor scope */

	/*

	 * _OSC method may exist in module level code,

	 * so it must be run after ACPI_FULL_INITIALIZATION

	/*

	 * _PDC control method may load dynamic SSDT tables,

	 * and we need to install the table handler before that.

	/*

	 * Maybe EC region is required at bus_scan/acpi_get_devices. So it

	 * is necessary to enable it as early as possible.

 Initialize sleep structures */

	/*

	 * Get the system interrupt model and evaluate \_PIC.

	/*

	 * Register the for all standard device notifications.

	/*

	 * Create the top ACPI proc directory

 Mimic structured exception handling */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Generic Event Device for ACPI.

 *

 * Copyright (c) 2016, The Linux Foundation. All rights reserved.

 *

 * Generic Event Device allows platforms to handle interrupts in ACPI

 * ASL statements. It follows very similar to  _EVT method approach

 * from GPIO events. All interrupts are listed in _CRS and the handler

 * is written in _EVT method. Here is an example.

 *

 * Device (GED0)

 * {

 *

 *     Name (_HID, "ACPI0013")

 *     Name (_UID, 0)

 *     Method (_CRS, 0x0, Serialized)

 *     {

 *		Name (RBUF, ResourceTemplate ()

 *		{

 *		Interrupt(ResourceConsumer, Edge, ActiveHigh, Shared, , , )

 *		{123}

 *		}

 *     })

 *

 *     Method (_EVT, 1) {

 *             if (Lequal(123, Arg0))

 *             {

 *             }

 *     }

 * }

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  battery.c - ACPI Battery Driver (Revision: 2.0)

 *

 *  Copyright (C) 2007 Alexey Starikovskiy <astarikovskiy@suse.de>

 *  Copyright (C) 2004-2007 Vladimir Lebedev <vladimir.p.lebedev@intel.com>

 *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>

 *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

 Battery power unit: 0 means mW, 1 means mA */

 Lists of PMIC ACPI HIDs with an (often better) native battery driver */

 X-Powers AXP288 PMIC */

	/* On Lenovo Thinkpad models from 2010 and 2011, the power unit

	 * switches between mWh and mAh depending on whether the system

	 * is running on battery or not.  When mAh is the unit, most

	 * reported values are incorrect and need to be adjusted by

	 * 10000/design_voltage.  Verified on x201, t410, t410s, and x220.

	 * Pre-2010 and 2012 models appear to always report in mWh and

	 * are thus unaffected (tested with t42, t61, t500, x200, x300,

	 * and x230).  Also, in mid-2012 Lenovo issued a BIOS update for

	 *  the 2011 models that fixes the issue (tested on x220 with a

	 * post-1.29 BIOS), but as of Nov. 2012, no such update is

	 * available for the 2010 models.

	/* for batteries reporting current capacity with design capacity

	 * on a full charge, but showing degradation in full charge cap.

 charging, discharging or critical low */

 battery not reporting charge */

 good batteries update full_charge as the batteries degrade */

 fallback to using design values for broken batteries */

 we don't do any sort of metric based on percentages */

	/*

	 * Some devices wrongly report discharging if the battery's charge level

	 * was above the device's start charging threshold atm the AC adapter

	 * was plugged in and the device thus did not start a new charge cycle.

 run battery update only if it is present */

 Battery Management */

 offset inside struct acpi_sbs_battery */

 int or string? */

 don't have value */

		/* Curiously, design_capacity_low, unlike the rest of them,

		 *  is correct.

		/* capacity_granularity_* equal 1 on the systems tested, so

		 * it's impossible to tell if they would need an adjustment

		 * or not if their values were higher.

	/* For buggy DSDTs that report negative 16-bit values for either

	 * charging or discharging current and/or report 0 as 65536

	 * due to bad math.

 See if alarms are supported, and if so, set default */

/*

 * The Battery Hooking API

 *

 * This API is used inside other drivers that need to expose

 * platform-specific behaviour within the generic driver in a

 * generic way.

 *

	/*

	 * In order to remove a hook, we first need to

	 * de-register all the batteries that are registered.

	/*

	 * Now that the driver is registered, we need

	 * to notify the hook that a battery is available

	 * for each battery, so that the driver may add

	 * its attributes.

			/*

			 * If a add-battery returns non-zero,

			 * the registration of the extension has failed,

			 * and we will not add it to the list of loaded

			 * hooks.

/*

 * This function gets called right after the battery sysfs

 * attributes have been added, so that the drivers that

 * define custom sysfs attributes can add their own.

	/*

	 * Since we added a new battery to the list, we need to

	 * iterate over the hooks and call add_battery for each

	 * hook that was registered. This usually happens

	 * when a battery gets hotplugged or initialized

	 * during the battery module initialization.

			/*

			 * The notification of the extensions has failed, to

			 * prevent further errors we will unload the extension.

	/*

	 * Before removing the hook, we need to remove all

	 * custom attributes from the battery.

 Then, just remove the battery from the list */

	/*

	 * At this point, the acpi_bus_unregister_driver()

	 * has called remove for all batteries. We just

	 * need to remove the hooks.

	/* Note: the hardcoded offsets below have been extracted from

	 * the source code of dmidecode.

/*

 * According to the ACPI spec, some kinds of primary batteries can

 * report percentage battery remaining capacity directly to OS.

 * In this case, it reports the Last Full Charged Capacity == 100

 * and BatteryPresentRate == 0xFFFFFFFF.

 *

 * Now we found some battery reports percentage remaining capacity

 * even if it's rechargeable.

 * https://bugzilla.kernel.org/show_bug.cgi?id=15979

 *

 * Handle this correctly so that they won't break userspace.

	/*

	 * Wakeup the system if battery is critical low

	 * or lower than the alarm level

 The battery has changed its reporting units. */

 Driver Interface */

	/*

	 * On Acer Aspire V5-573G notifications are sometimes triggered too

	 * early. For example, when AC is unplugged and notification is

	 * triggered, battery state is still reported as "Full", and changes to

	 * "Discharging" only after short delay, without any notification.

 acpi_battery_update could remove power_supply object */

 NEC LZ750/LS */

 Acer Aspire V5-573G */

 Point of View mobii wintab p800w */

 Above matches are too generic, add bios-date match */

 ECS EF20EA, AXP288 PMIC but uses separate fuel-gauge */

 Lenovo Ideapad Miix 320, AXP288 PMIC, separate fuel-gauge */

/*

 * Some machines'(E,G Lenovo Z480) ECs are not stable

 * during boot up and this causes battery driver fails to be

 * probed due to failure of getting battery information

 * from EC sometimes. After several retries, the operation

 * may work. So add retry code here and 20ms sleep between

 * every retries.

 this is needed to learn about changes made in suspended state */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * acpi_lpat.c - LPAT table processing functions

 *

 * Copyright (C) 2015 Intel Corporation. All rights reserved.

/**

 * acpi_lpat_raw_to_temp(): Return temperature from raw value through

 * LPAT conversion table

 *

 * @lpat_table: the temperature_raw mapping table structure

 * @raw: the raw value, used as a key to get the temperature from the

 *       above mapping table

 *

 * A positive converted temperature value will be returned on success,

 * a negative errno will be returned in error cases.

/**

 * acpi_lpat_temp_to_raw(): Return raw value from temperature through

 * LPAT conversion table

 *

 * @lpat_table: the temperature_raw mapping table

 * @temp: the temperature, used as a key to get the raw value from the

 *        above mapping table

 *

 * The raw value will be returned on success,

 * a negative errno will be returned in error cases.

/**

 * acpi_lpat_get_conversion_table(): Parse ACPI LPAT table if present.

 *

 * @handle: Handle to acpi device

 *

 * Parse LPAT table to a struct of type acpi_lpat_table. On success

 * it returns a pointer to newly allocated table. This table must

 * be freed by the caller when finished processing, using a call to

 * acpi_lpat_free_conversion_table.

/**

 * acpi_lpat_free_conversion_table(): Free LPAT table.

 *

 * @lpat_table: the temperature_raw mapping table structure

 *

 * Frees the LPAT table previously allocated by a call to

 * acpi_lpat_get_conversion_table.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * SMBus driver for ACPI Embedded Controller (v0.1)

 *

 * Copyright (c) 2007 Alexey Starikovskiy

 protocol, PEC */

 status */

 address */

 command */

 32 data registers */

 number of data bytes */

 alarm address */

 2 bytes alarm data */

	/*

	 * Wait for completion. Save the status code, data size,

	 * and data into the return package (if required by the protocol).

 Check if it is only a completion notify */

 We are only interested in events coming from known devices */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * sleep.c - ACPI sleep support.

 *

 * Copyright (c) 2005 Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>

 * Copyright (c) 2004 David Shaohua Li <shaohua.li@intel.com>

 * Copyright (c) 2000-2003 Patrick Mochel

 * Copyright (c) 2003 Open Source Development Lab

/*

 * Some HW-full platforms do not have _S5, so they may need

 * to leverage efi power off for a shutdown.

		/*

		 * OS can't evaluate the _TTS object correctly. Some warning

		 * message will be printed. But it won't break anything.

 do we have a wakeup address for S2 and S3? */

/*

 * The ACPI specification wants us to save NVS memory regions during hibernation

 * and to restore them during the subsequent resume.  Windows does that also for

 * suspend to RAM.  However, it is known that this mechanism does not work on

 * all machines, so we allow the user to disable it with the help of the

 * 'acpi_sleep=nonvs' kernel command line option.

/*

 * The ACPI specification wants us to save NVS memory regions during hibernation

 * but says nothing about saving NVS during S3.  Not all versions of Windows

 * save NVS on S3 suspend either, and it is clear that not all systems need

 * NVS to be saved at S3 time.  To improve suspend/resume time, allow the

 * user to disable saving NVS on S3 if their system does not require it, but

 * continue to save/restore NVS for S4 as specified.

/*

 * ACPI 1.0 wants us to execute _PTS before suspending devices, so we allow the

 * user to request that behavior by using the 'acpi_old_suspend_ordering'

 * kernel command line option that causes the following variable to be set.

www.abit.com.tw/"),

	/*

	 * https://bugzilla.kernel.org/show_bug.cgi?id=189431

	 * Lenovo G50-45 is a platform later than 2012, but needs nvs memory

	 * saving during S3.

	/*

	 * ThinkPad X1 Tablet(2016) cannot do suspend-to-idle using

	 * the Low Power S0 Idle firmware interface (see

	 * https://bugzilla.kernel.org/show_bug.cgi?id=199057).

/**

 * acpi_pm_freeze - Disable the GPEs and suspend EC transactions.

/**

 * acpi_pm_pre_suspend - Enable wakeup devices, "freeze" EC and save NVS.

/**

 *	__acpi_pm_prepare - Prepare the platform to enter the target state.

 *

 *	If necessary, set the firmware waking vector and do arch-specific

 *	nastiness to get the wakeup code to the waking vector.

/**

 *	acpi_pm_prepare - Prepare the platform to enter the target sleep

 *		state and disable the GPEs.

/**

 *	acpi_pm_finish - Instruct the platform to leave a sleep state.

 *

 *	This is called after we wake back up (or if entering the sleep state

 *	failed).

 reset firmware waking vector */

	/* If we were woken with the fixed power button, provide a small

	 * hint to userspace in the form of a wakeup event on the fixed power

	 * button device (if it can be found).

	 *

	 * We delay the event generation til now, as the PM layer requires

/**

 * acpi_pm_start - Start system PM transition.

/**

 * acpi_pm_end - Finish up system PM transition.

	/*

	 * This is necessary in case acpi_pm_finish() is not called during a

	 * failing transition to a sleep state.

 !CONFIG_ACPI_SLEEP */

 CONFIG_ACPI_SLEEP */

/**

 *	acpi_suspend_begin - Set the target system sleep state to the state

 *		associated with given @pm_state, if supported.

/**

 *	acpi_suspend_enter - Actually enter a sleep state.

 *	@pm_state: ignored

 *

 *	Flush caches and go to sleep. For STR we have to call arch-specific

 *	assembly, which in turn call acpi_enter_sleep_state().

 *	It's unfortunate, but it works. Please fix if you're feeling frisky.

 This violates the spec but is required for bug compatibility. */

 Reprogram control registers */

	/* ACPI 3.0 specs (P62) says that it's the responsibility

	 * of the OSPM to clear the status bit [ implying that the

	 * POWER_BUTTON event should not reach userspace ]

	 *

	 * However, we do generate a small hint for userspace in the form of

	 * a wakeup event. We flag this condition for now and generate the

	 * event later, as we're currently too early in resume to be able to

	 * generate wakeup events.

 Flag for later */

	/*

	 * Disable and clear GPE status before interrupt is enabled. Some GPEs

	 * (like wakeup GPE) haven't handler, this can avoid such GPE misfire.

	 * acpi_leave_sleep_state will reenable specific GPEs later

 Allow EC transactions to happen. */

/**

 *	acpi_suspend_begin_old - Set the target system sleep state to the

 *		state associated with given @pm_state, if supported, and

 *		execute the _PTS control method.  This function is used if the

 *		pre-ACPI 2.0 suspend ordering has been requested.

/*

 * The following callbacks are used if the pre-ACPI 2.0 suspend ordering has

 * been requested.

 Change the configuration of GPEs to avoid spurious wakeup. */

		/*

		 * If IRQD_WAKEUP_ARMED is set for the SCI at this point, the

		 * SCI has not triggered while suspended, so bail out (the

		 * wakeup is pending anyway and the SCI is not the source of

		 * it).

		/*

		 * If the status bit of any enabled fixed event is set, the

		 * wakeup is regarded as valid.

 Check wakeups from drivers sharing the SCI. */

 Check non-EC GPE wakeups and dispatch the EC GPE. */

		/*

		 * Cancel the SCI wakeup and process all pending events in case

		 * there are any wakeup ones in there.

		 *

		 * Note that if any non-EC GPEs are active at this point, the

		 * SCI will retrigger after the rearming below, so no events

		 * should be missed by canceling the wakeup here.

		/*

		 * The SCI is in the "suspended" state now and it cannot produce

		 * new wakeup events till the rearming below, so if any of them

		 * are pending here, they must be resulting from the processing

		 * of EC events above or coming from somewhere else.

	/*

	 * Drain pending events before restoring the working-state configuration

	 * of GPEs.

 synchronize GPE processing */

 flush the EC driver's workqueues */

 synchronize Notify handling */

 !CONFIG_SUSPEND */

 !CONFIG_SUSPEND */

 CONFIG_PM_SLEEP */

 This shouldn't return.  If it returns, we have a problem */

 Reprogram control registers */

	/*

	 * If ACPI is not enabled by the BIOS and the boot kernel, we need to

	 * enable it here.

 Reprogram control registers */

 Check the hardware signature */

 Restore the NVS memory area */

 Allow EC transactions to happen. */

/**

 *	acpi_hibernation_begin_old - Set the target system sleep state to

 *		ACPI_STATE_S4 and execute the _PTS control method.  This

 *		function is used if the pre-ACPI 2.0 suspend ordering has been

 *		requested.

	/*

	 * The _TTS object should always be evaluated before the _PTS object.

	 * When the old_suspended_ordering is true, the _PTS object is

	 * evaluated in the acpi_sleep_prepare.

/*

 * The following callbacks are used if the pre-ACPI 2.0 suspend ordering has

 * been requested.

 !CONFIG_HIBERNATION */

 !CONFIG_HIBERNATION */

 Prepare to power off the system */

 acpi_sleep_prepare(ACPI_STATE_S5) should have already been called */

	/*

	 * Register the tts_notifier to reboot notifier list so that the _TTS

	 * object can also be evaluated when the system enters S5.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  acpi_tables.c - ACPI Boot-Time Table Parsing

 *

 *  Copyright (C) 2001 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

 Uncomment next line to get verbose printout */

 #define DEBUG */

/*

 * Disable table checksum verification for the early stage due to the size

 * limitation of the current x86 early mapping implementation.

/**

 * acpi_parse_entries_array - for each proc_num find a suitable subtable

 *

 * @id: table id (for debugging purposes)

 * @table_size: size of the root table

 * @table_header: where does the table start?

 * @proc: array of acpi_subtable_proc struct containing entry id

 *        and associated handler with it

 * @proc_num: how big proc is?

 * @max_entries: how many entries can we process?

 *

 * For each proc_num find a subtable with proc->id and run proc->handler

 * on it. Assumption is that there's only single handler for particular

 * entry id.

 *

 * The table_size is not the size of the complete ACPI table (the length

 * field in the header struct), but only the size of the root table; i.e.,

 * the offset from the very first byte of the complete ACPI table, to the

 * first byte of the very first subtable.

 *

 * On success returns sum of all matching entries for all proc handlers.

 * Otherwise, -ENODEV or -EINVAL is returned.

 Parse all entries looking for a match. */

		/*

		 * If entry->length is 0, break from this loop to avoid

		 * infinite loop.

/**

 * acpi_table_parse - find table with @id, run @handler on it

 * @id: table id to find

 * @handler: handler to run

 *

 * Scan the ACPI System Descriptor Table (STD) for a table matching @id,

 * run @handler on it.

 *

 * Return 0 if table found, -errno if not.

/*

 * The BIOS is supposed to supply a single APIC/MADT,

 * but some report two.  Provide a knob to use either.

 * (don't you wish instance 0 and 1 were not the same?)

 Copied from acpica/tbutils.c:acpi_tb_checksum() */

 All but ACPI_SIG_RSDP and ACPI_SIG_FACS: */

	/*

	 * Only calling e820_add_reserve does not work and the

	 * tables are invalid (memory got used) later.

	 * memblock_reserve works as expected and the tables won't get modified.

	 * But it's not enough on X86 because ioremap will

	 * complain later (used by acpi_os_map_memory) that the pages

	 * that should get mapped are not marked "reserved".

	 * Both memblock_reserve and e820__range_add (via arch_reserve_mem_area)

	 * works fine.

	/*

	 * early_ioremap only can remap 256k one time. If we map all

	 * tables one time, we will hit the limit. Need to map chunks

	 * one by one during copying the same as that in relocate_initrd().

 Only override tables matched */

		/*

		 * Mark the table to avoid being used in

		 * acpi_table_initrd_scan() and check the revision.

 Skip RSDT/XSDT which should only be used for override */

		/*

		 * Mark the table to avoid being used in

		 * acpi_table_initrd_override(). Though this is not possible

		 * because override is disabled in acpi_install_table().

 CONFIG_ACPI_TABLE_UPGRADE */

/*

 * acpi_locate_initial_tables()

 *

 * find RSDP, find and checksum SDT/XSDT.

 * checksum all tables, print SDT/XSDT

 *

 * result: sdt_entry[] is initialized

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * container.c  - ACPI Generic Container Driver

 *

 * Copyright (C) 2004 Anil S Keshavamurthy (anil.s.keshavamurthy@intel.com)

 * Copyright (C) 2004 Keiichiro Tokunaga (tokunaga.keiich@jp.fujitsu.com)

 * Copyright (C) 2004 Motoyuki Ito (motoyuki@soft.fujitsu.com)

 * Copyright (C) 2004 FUJITSU LIMITED

 * Copyright (C) 2004, 2013 Intel Corp.

 * Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

 Check all of the dependent devices' physical companions. */

 CONFIG_ACPI_CONTAINER */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * processor_throttling.c - Throttling submodule of the ACPI processor driver

 *

 *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>

 *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

 *  Copyright (C) 2004       Dominik Brodowski <linux@brodo.de>

 *  Copyright (C) 2004  Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>

 *                      - Added processor hotplug support

/* ignore_tpc:

 *  0 -> acpi processor driver doesn't ignore _TPC values

 *  1 -> acpi processor driver ignores _TPC values

 cpu nr */

 target T-state */

	/*

	 * Now that we have _TSD data from all CPUs, lets setup T-state

	 * coordination between all CPUs.

 Basic validity check for domain info */

		/*

		 * If tsd package for one cpu is invalid, the coordination

		 * among all CPUs is thought as invalid.

		 * Maybe it is ugly.

		/*

		 * If the number of processor in the TSD domain is 1, it is

		 * unnecessary to parse the coordination for this CPU.

 Validate the Domain info */

			/* Here i and j are in the same domain.

			 * If two TSD packages have the same domain, they

			 * should have the same num_porcessors and

			 * coordination type. Otherwise it will be regarded

			 * as illegal.

			/*

			 * If some CPUS have the same domain, they

			 * will have the same shared_cpu_map.

		/*

		 * Assume no coordination on any error parsing domain info.

		 * The coordination type will be forced as SW_ALL.

/*

 * Update the T-state coordination after the _TSD

 * data for all cpus is obtained.

		/*

		 * Prechange event is used to choose one proper t-state,

		 * which meets the limits of thermal, user and _TPC.

		/*

		 * Postchange event is only used to update the

		 * T-state flag of acpi_processor_throttling.

/*

 * _TPC - Throttling Present Capabilities

 Throttling Limit is unsupported */

 Uncorrect Throttling Limit */

		/*

		 * The current state can meet the requirement of

		 * _TPC limit. But it is reasonable that OSPM changes

		 * t-states from high to low for better performance.

		 * Of course the limit condition of thermal

		 * and user should be considered.

		/*

		 * Unnecessary to change the throttling state

		/*

		 * If the current state is lower than the limit of _TPC, it

		 * will be forced to switch to the throttling state defined

		 * by throttling_platfor_limit.

		 * Because the previous state meets with the limit condition

		 * of thermal and user, it is unnecessary to check it again.

/*

 * This function is used to reevaluate whether the T-state is valid

 * after one CPU is onlined/offlined.

 * It is noted that it won't reevaluate the following properties for

 * the T-state.

 *	1. Control method.

 *	2. the number of supported T-state

 *	3. TSD domain

		/* When one CPU is offline, the T-state throttling

		 * will be invalidated.

	/* the following is to recheck whether the T-state is valid for

	 * the online CPU

		/* If the number of T-state is invalid, it is

		 * invalidated.

	/* Disable throttling (if enabled).  We'll let subsequent

	 * policy (e.g.thermal) decide to lower performance if it

	 * so chooses, but for now we'll crank up the speed.

/*

 * _PTC - Processor Throttling Control (and status) register location

	/*

	 * control_register

	/*

	 * status_register

/*

 * _TSS - Throttling Supported States

/*

 * _TSD - T-State Dependencies

	/*

	 * If the coordination type is not defined in ACPI spec,

	 * the tsd_valid_flag will be clear and coordination type

	 * will be forecd as DOMAIN_COORD_TYPE_SW_ALL.

/* --------------------------------------------------------------------------

                              Throttling Control

	/*

	 * We don't care about error returns - we just try to mark

	 * these reserved so that nobody else is confused into thinking

	 * that this region might be unused..

	 *

	 * (In particular, allocating the IO range for Cardbus)

	/*

	 * Compute the current throttling state when throttling is enabled

	 * (bit 4 is on).

	/*

	 * This is either called from the CPU hotplug callback of

	 * processor_driver or via the ACPI probe function. In the latter

	 * case the CPU is not guaranteed to be online. Both call sites are

	 * protected against CPU hotplug.

 TBD: Support duty_cycle values that span bit 4. */

	/*

	 * Compute state values. Note that throttling displays a linear power

	 * performance relationship (at 50% performance the CPU will consume

	 * 50% power).  Values are in 1/10th of a percent to preserve accuracy.

	/*

	 * Calculate the duty_value and duty_mask.

 Used to clear all duty_value bits */

	/*

	 * Disable throttling by writing a 0 to bit 4.  Note that we must

	 * turn it off before you can change the duty_value.

	/*

	 * Write the new duty_value and then enable throttling.  Note

	 * that a state value of 0 leaves throttling disabled.

		/*

		 * the cpu pointed by pr->id is offline. Unnecessary to change

		 * the throttling state any more.

	/*

	 * The throttling notifier will be called for every

	 * affected cpu in order to get one proper T-state.

	 * The notifier event is THROTTLING_PRECHANGE.

	/*

	 * The function of acpi_processor_set_throttling will be called

	 * to switch T-state. If the coordination type is SW_ALL or HW_ALL,

	 * it is necessary to call it for every affected cpu. Otherwise

	 * it can be called only for the cpu pointed by pr.

		/*

		 * When the T-state coordination is SW_ALL or HW_ALL,

		 * it is necessary to set T-state for every affected

		 * cpus.

			/*

			 * If the pointer is invalid, we will report the

			 * error message and continue.

			/*

			 * If the throttling control is unsupported on CPU i,

			 * we will report the error message and continue.

	/*

	 * After the set_throttling is called, the

	 * throttling notifier is called for every

	 * affected cpu to update the T-states.

	 * The notifier event is THROTTLING_POSTCHANGE

	/*

	 * Evaluate _PTC, _TSS and _TPC

	 * They must all be present or none of them can be used.

	/*

	 * If TSD package for one CPU can't be parsed successfully, it means

	 * that this CPU will have no coordination with other CPUs.

	/*

	 * PIIX4 Errata: We don't support throttling on the original PIIX4.

	 * This shouldn't be an issue as few (if any) mobile systems ever

	 * used this part.

	/*

	 * Disable throttling (if enabled).  We'll let subsequent policy (e.g.

	 * thermal) decide to lower performance if it so chooses, but for now

	 * we'll crank up the speed.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * drivers/acpi/resource.c - ACPI device resources interpretation.

 *

 * Copyright (C) 2012, Intel Corp.

 * Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

 *

 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 *

 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 On X86 IO space is limited to the [0 - 64K] IO port range */

/*

 * ACPI IO descriptors on arches other than X86 contain MMIO CPU physical

 * addresses mapping IO space in CPU physical address space, IO space

 * resources can be placed anywhere in the 64-bit physical address space.

	/*

	 * CHECKME: len might be required to check versus a minimum

	 * length as well. 1 for io is fine, but for memory it does

	 * not make any sense at all.

	 * Note: some BIOSes report incorrect length for ACPI address space

	 * descriptor, so remove check of 'reslen == len' to avoid regression.

/**

 * acpi_dev_resource_memory - Extract ACPI memory resource information.

 * @ares: Input ACPI resource object.

 * @res: Output generic resource object.

 *

 * Check if the given ACPI resource object represents a memory resource and

 * if that's the case, use the information in it to populate the generic

 * resource object pointed to by @res.

 *

 * Return:

 * 1) false with res->flags setting to zero: not the expected resource type

 * 2) false with IORESOURCE_DISABLED in res->flags: valid unassigned resource

 * 3) true: valid assigned resource

/**

 * acpi_dev_resource_io - Extract ACPI I/O resource information.

 * @ares: Input ACPI resource object.

 * @res: Output generic resource object.

 *

 * Check if the given ACPI resource object represents an I/O resource and

 * if that's the case, use the information in it to populate the generic

 * resource object pointed to by @res.

 *

 * Return:

 * 1) false with res->flags setting to zero: not the expected resource type

 * 2) false with IORESOURCE_DISABLED in res->flags: valid unassigned resource

 * 3) true: valid assigned resource

	/*

	 * Filter out invalid descriptor according to ACPI Spec 5.0, section

	 * 6.4.3.5 Address Space Resource Descriptors.

	/*

	 * For bridges that translate addresses across the bridge,

	 * translation_offset is the offset that must be added to the

	 * address on the secondary side to obtain the address on the

	 * primary side. Non-bridge devices must list 0 for all Address

	 * Translation offset bits.

/**

 * acpi_dev_resource_address_space - Extract ACPI address space information.

 * @ares: Input ACPI resource object.

 * @win: Output generic resource object.

 *

 * Check if the given ACPI resource object represents an address space resource

 * and if that's the case, use the information in it to populate the generic

 * resource object pointed to by @win.

 *

 * Return:

 * 1) false with win->res.flags setting to zero: not the expected resource type

 * 2) false with IORESOURCE_DISABLED in win->res.flags: valid unassigned

 *    resource

 * 3) true: valid assigned resource

/**

 * acpi_dev_resource_ext_address_space - Extract ACPI address space information.

 * @ares: Input ACPI resource object.

 * @win: Output generic resource object.

 *

 * Check if the given ACPI resource object represents an extended address space

 * resource and if that's the case, use the information in it to populate the

 * generic resource object pointed to by @win.

 *

 * Return:

 * 1) false with win->res.flags setting to zero: not the expected resource type

 * 2) false with IORESOURCE_DISABLED in win->res.flags: valid unassigned

 *    resource

 * 3) true: valid assigned resource

/**

 * acpi_dev_irq_flags - Determine IRQ resource flags.

 * @triggering: Triggering type as provided by ACPI.

 * @polarity: Interrupt polarity as provided by ACPI.

 * @shareable: Whether or not the interrupt is shareable.

/**

 * acpi_dev_get_irq_type - Determine irq type.

 * @triggering: Triggering type as provided by ACPI.

 * @polarity: Interrupt polarity as provided by ACPI.

	/*

	 * In IO-APIC mode, use overridden attribute. Two reasons:

	 * 1. BIOS bug in DSDT

	 * 2. BIOS uses IO-APIC mode Interrupt Source Override

	 *

	 * We do this only if we are dealing with IRQ() or IRQNoFlags()

	 * resource (the legacy ISA resources). With modern ACPI 5 devices

	 * using extended IRQ descriptors we take the IRQ configuration

	 * from _CRS directly.

/**

 * acpi_dev_resource_interrupt - Extract ACPI interrupt resource information.

 * @ares: Input ACPI resource object.

 * @index: Index into the array of GSIs represented by the resource.

 * @res: Output generic resource object.

 *

 * Check if the given ACPI resource object represents an interrupt resource

 * and @index does not exceed the resource's interrupt count (true is returned

 * in that case regardless of the results of the other checks)).  If that's the

 * case, register the GSI corresponding to @index from the array of interrupts

 * represented by the resource and populate the generic resource object pointed

 * to by @res accordingly.  If the registration of the GSI is not successful,

 * IORESOURCE_DISABLED will be set it that object's flags.

 *

 * Return:

 * 1) false with res->flags setting to zero: not the expected resource type

 * 2) false with IORESOURCE_DISABLED in res->flags: valid unassigned resource

 * 3) true: valid assigned resource

		/*

		 * Per spec, only one interrupt per descriptor is allowed in

		 * _CRS, but some firmware violates this, so parse them all.

/**

 * acpi_dev_free_resource_list - Free resource from %acpi_dev_get_resources().

 * @list: The head of the resource list to free.

/**

 * acpi_dev_get_resources - Get current resources of a device.

 * @adev: ACPI device node to get the resources for.

 * @list: Head of the resultant list of resources (must be empty).

 * @preproc: The caller's preprocessing routine.

 * @preproc_data: Pointer passed to the caller's preprocessing routine.

 *

 * Evaluate the _CRS method for the given device node and process its output by

 * (1) executing the @preproc() routine provided by the caller, passing the

 * resource pointer and @preproc_data to it as arguments, for each ACPI resource

 * returned and (2) converting all of the returned ACPI resources into struct

 * resource objects if possible.  If the return value of @preproc() in step (1)

 * is different from 0, step (2) is not applied to the given ACPI resource and

 * if that value is negative, the whole processing is aborted and that value is

 * returned as the final error code.

 *

 * The resultant struct resource objects are put on the list pointed to by

 * @list, that must be empty initially, as members of struct resource_entry

 * objects.  Callers of this routine should use %acpi_dev_free_resource_list() to

 * free that list.

 *

 * The number of resources in the output list is returned on success, an error

 * code reflecting the error condition is returned otherwise.

/**

 * acpi_dev_get_dma_resources - Get current DMA resources of a device.

 * @adev: ACPI device node to get the resources for.

 * @list: Head of the resultant list of resources (must be empty).

 *

 * Evaluate the _DMA method for the given device node and process its

 * output.

 *

 * The resultant struct resource objects are put on the list pointed to

 * by @list, that must be empty initially, as members of struct

 * resource_entry objects.  Callers of this routine should use

 * %acpi_dev_free_resource_list() to free that list.

 *

 * The number of resources in the output list is returned on success,

 * an error code reflecting the error condition is returned otherwise.

/**

 * acpi_dev_filter_resource_type - Filter ACPI resource according to resource

 *				   types

 * @ares: Input ACPI resource object.

 * @types: Valid resource types of IORESOURCE_XXX

 *

 * This is a helper function to support acpi_dev_get_resources(), which filters

 * ACPI resource objects according to resource types.

/**

 * acpi_resource_consumer - Find the ACPI device that consumes @res.

 * @res: Resource to search for.

 *

 * Search the current resource settings (_CRS) of every ACPI device node

 * for @res.  If we find an ACPI device whose _CRS includes @res, return

 * it.  Otherwise, return NULL.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  dock.c - ACPI dock station driver

 *

 *  Copyright (C) 2006, 2014, Intel Corp.

 *  Author: Kristen Carlson Accardi <kristen.c.accardi@intel.com>

 *          Rafael J. Wysocki <rafael.j.wysocki@intel.com>

/*****************************************************************************

 *                         Dock Dependent device functions                   *

/**

 * add_dock_dependent_device - associate a device with the dock station

 * @ds: Dock station.

 * @adev: Dependent ACPI device object.

 *

 * Add the dependent device to the dock's dependent device list.

/**

 * find_dock_dependent_device - get a device dependent on this dock

 * @ds: the dock station

 * @adev: ACPI device object to find.

 *

 * iterate over the dependent device list for this dock.  If the

 * dependent device matches the handle, return.

/*****************************************************************************

 *                         Dock functions                                    *

/**

 * is_dock_device - see if a device is on a dock station

 * @adev: ACPI device object to check.

 *

 * If this device is either the dock station itself,

 * or is a device dependent on the dock station, then it

 * is a dock device

/**

 * dock_present - see if the dock station is present.

 * @ds: the dock station

 *

 * execute the _STA method.  note that present does not

 * imply that we are docked.

/**

 * hot_remove_dock_devices - Remove dock station devices.

 * @ds: Dock station.

	/*

	 * Walk the list in reverse order so that devices that have been added

	 * last are removed first (in case there are some indirect dependencies

	 * between them).

/**

 * hotplug_dock_devices - Insert devices on a dock station.

 * @ds: the dock station

 * @event: either bus check or device check request

 *

 * Some devices on the dock station need to have drivers called

 * to perform hotplug operations after a dock event has occurred.

 * Traverse the list of dock devices that have registered a

 * hotplug handler, and call the handler.

 Call driver specific post-dock fixups. */

 Call driver specific hotplug functions. */

	/*

	 * Check if all devices have been enumerated already.  If not, run

	 * acpi_bus_scan() for them and that will cause scan handlers to be

	 * attached to device objects or acpi_drivers to be stopped/started if

	 * they are present.

	/*

	 * Indicate that the status of the dock station has

	 * changed.

/**

 * handle_dock - handle a dock event

 * @ds: the dock station

 * @dock: to dock, or undock - that is the question

 *

 * Execute the _DCK method in response to an acpi event

 _DCK method has one argument */

/**

 * dock_in_progress - see if we are in the middle of handling a dock event

 * @ds: the dock station

 *

 * Sometimes while docking, false dock events can be sent to the driver

 * because good connections aren't made or some other reason.  Ignore these

 * if we are in the middle of doing something.

/**

 * handle_eject_request - handle an undock request checking for error conditions

 *

 * Check to make sure the dock device is still present, then undock and

 * hotremove all the devices that may need removing.

	/*

	 * here we need to generate the undock

	 * event prior to actually doing the undock

	 * so that the device struct still exists.

	 * Also, even send the dock event if the

	 * device is not present anymore

/**

 * dock_notify - Handle ACPI dock notification.

 * @adev: Dock station's ACPI device object.

 * @event: Event code.

 *

 * If we are notified to dock, then check to see if the dock is

 * present and then dock.  Notify all drivers of the dock event,

 * and then hotplug and devices that may need hotplugging.

	/*

	 * According to acpi spec 3.0a, if a DEVICE_CHECK notification

	 * is sent and _DCK is present, it is assumed to mean an undock

	 * request.

	/*

	 * dock station: BUS_CHECK - docked or surprise removal

	 *		 DEVICE_CHECK - undocked

	 * other device: BUS_CHECK/DEVICE_CHECK - added or surprise removal

	 *

	 * To simplify event handling, dock dependent device handler always

	 * get ACPI_NOTIFY_BUS_CHECK/ACPI_NOTIFY_DEVICE_CHECK for add and

	 * ACPI_NOTIFY_EJECT_REQUEST for removal

 This is a surprise removal */

 Fall back */

/*

 * show_docked - read method for "docked" file in sysfs

/*

 * show_flags - read method for flags file in sysfs

/*

 * write_undock - write method for "undock" file in sysfs

/*

 * show_dock_uid - read method for "uid" file in sysfs

/**

 * acpi_dock_add - Add a new dock station

 * @adev: Dock station ACPI device object.

 *

 * allocated and initialize a new dock station device.

 we want the dock device to send uevents */

 add the dock station as a device dependent on itself */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * nvs.c - Routines for saving and restoring ACPI NVS memory region

 *

 * Copyright (C) 2008-2011 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc.

 ACPI NVS regions, APEI may use it */

/*

 * Platforms, like ACPI, may want us to save some memory used by them during

 * suspend and to restore the contents of this memory during the subsequent

 * resume.  The code below implements a mechanism allowing us to do that.

/**

 * suspend_nvs_register - register platform NVS memory region to save

 * @start: Physical address of the region.

 * @size: Size of the region.

 *

 * The NVS region need not be page-aligned (both ends) and we arrange

 * things so that the data from page-aligned addresses in this region will

 * be copied into separate RAM pages.

/**

 * suspend_nvs_free - free data pages allocated for saving NVS regions

/**

 * suspend_nvs_alloc - allocate memory necessary for saving NVS regions

/**

 * suspend_nvs_save - save NVS memory regions

/**

 * suspend_nvs_restore - restore NVS memory regions

 *

 * This function is going to be called with interrupts disabled, so it

 * cannot iounmap the virtual addresses used to access the NVS region.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  button.c - ACPI Button Driver

 *

 *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>

 *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

 Please keep this list sorted alphabetically by vendor and model */

 GP-electronic T701, _LID method points to a floating GPIO */

		/*

		 * Lenovo Yoga 9 14ITL5, initial notification of the LID device

		 * never happens.

		/*

		 * Medion Akoya E2215T, notification of the LID device only

		 * happens on close, not on open and _LID always returns closed.

		/*

		 * Medion Akoya E2228T, notification of the LID device only

		 * happens on close, not on open and _LID always returns closed.

		/*

		 * Razer Blade Stealth 13 late 2019, notification of the LID device

		 * only happens on close, not on open and _LID always returns closed.

 for input device */

 FS Interface (/proc) */

	/*

	 * In lid_init_state=ignore mode, if user opens/closes lid

	 * frequently with "open" missing, and "last_time" is also updated

	 * frequently, "close" cannot be delivered to the userspace.

	 * So "last_time" is only updated after a timeout or an actual

	 * switch.

 Complain the buggy firmware */

		/*

		 * Send the unreliable complement switch event:

		 *

		 * On most platforms, the lid device is reliable. However

		 * there are exceptions:

		 * 1. Platforms returning initial lid state as "close" by

		 *    default after booting/resuming:

		 *     https://bugzilla.kernel.org/show_bug.cgi?id=89211

		 *     https://bugzilla.kernel.org/show_bug.cgi?id=106151

		 * 2. Platforms never reporting "open" events:

		 *     https://bugzilla.kernel.org/show_bug.cgi?id=106941

		 * On these buggy platforms, the usage model of the ACPI

		 * lid device actually is:

		 * 1. The initial returning value of _LID may not be

		 *    reliable.

		 * 2. The open event may not be reliable.

		 * 3. The close event is reliable.

		 *

		 * But SW_LID is typed as input switch event, the input

		 * layer checks if the event is redundant. Hence if the

		 * state is not switched, the userspace cannot see this

		 * platform triggered reliable event. By inserting a

		 * complement switch event, it then is guaranteed that the

		 * platform triggered reliable one can always be seen by

		 * the userspace.

			/*

			 * Do generate complement switch event for "close"

			 * as "close" is reliable and wrong "open" won't

			 * trigger unexpected behaviors.

			 * Do not generate complement switch event for

			 * "open" as "open" is not reliable and wrong

			 * "close" will trigger unexpected behaviors.

 Send the platform triggered reliable event */

 procfs I/F for ACPI lid device only */

 create /proc/acpi/button */

 create /proc/acpi/button/lid */

 create /proc/acpi/button/lid/LID/ */

 create /proc/acpi/button/lid/LID/state */

 Driver Interface */

		/*

		 * This assumes there's only one lid device, or if there are

		 * more we only care about the last one...

 Replace the final space with a newline */

	/*

	 * Modules such as nouveau.ko and i915.ko have a link time dependency

	 * on acpi_lid_open(), and would therefore not be loadable on ACPI

	 * capable kernels booted in non-ACPI mode if the return value of

	 * acpi_bus_register_driver() is returned from here with ACPI disabled

	 * when this driver is built as a module.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  osi.c - _OSI implementation

 *

 *  Copyright (C) 2016 Intel Corporation

 *    Author: Lv Zheng <lv.zheng@intel.com>

 Uncomment next line to get verbose printout */

 #define DEBUG */

	/*

	 * Linux-Dell-Video is used by BIOS to disable RTD3 for NVidia graphics

	 * cards as RTD3 is not supported by drivers now.  Systems with NVidia

	 * cards will hang without RTD3 disabled.

	 *

	 * Once NVidia drivers officially support RTD3, this _OSI strings can

	 * be removed if both new and old graphics cards are supported.

	/*

	 * Linux-Lenovo-NV-HDMI-Audio is used by BIOS to power on NVidia's HDMI

	 * audio device which is turned off for power-saving in Windows OS.

	 * This power management feature observed on some Lenovo Thinkpad

	 * systems which will not be able to output audio via HDMI without

	 * a BIOS workaround.

	/*

	 * Linux-HPI-Hybrid-Graphics is used by BIOS to enable dGPU to

	 * output video directly to external monitors on HP Inc. mobile

	 * workstations as Nvidia and AMD VGA drivers provide limited

	 * hybrid graphics supports.

 Do not override acpi_osi=!* */

 Override acpi_osi_dmi_blacklisted() */

/*

 * The story of _OSI(Linux)

 *

 * From pre-history through Linux-2.6.22, Linux responded TRUE upon a BIOS

 * OSI(Linux) query.

 *

 * Unfortunately, reference BIOS writers got wind of this and put

 * OSI(Linux) in their example code, quickly exposing this string as

 * ill-conceived and opening the door to an un-bounded number of BIOS

 * incompatibilities.

 *

 * For example, OSI(Linux) was used on resume to re-POST a video card on

 * one system, because Linux at that time could not do a speedy restore in

 * its native driver. But then upon gaining quick native restore

 * capability, Linux has no way to tell the BIOS to skip the time-consuming

 * POST -- putting Linux at a permanent performance disadvantage. On

 * another system, the BIOS writer used OSI(Linux) to infer native OS

 * support for IPMI!  On other systems, OSI(Linux) simply got in the way of

 * Linux claiming to be compatible with other operating systems, exposing

 * BIOS issues such as skipped device initialization.

 *

 * So "Linux" turned out to be a really poor chose of OSI string, and from

 * Linux-2.6.23 onward we respond FALSE.

 *

 * BIOS writers should NOT query _OSI(Linux) on future systems. Linux will

 * complain on the console when it sees it, and return FALSE. To get Linux

 * to return TRUE for your system  will require a kernel source update to

 * add a DMI entry, or boot with "acpi_osi=Linux"

 Override acpi_osi_dmi_blacklisted() */

/*

 * Modify the list of "OS Interfaces" reported to BIOS via _OSI

 *

 * empty string disables _OSI

 * string starting with '!' disables that string

 * otherwise string is added to list, augmenting built-in strings

/*

 * Linux default _OSI response behavior is determined by this DMI table.

 *

 * Note that _OSI("Linux")/_OSI("Darwin") determined here can be overridden

 * by acpi_osi=!Linux/acpi_osi=!Darwin command line options.

	/*

	 * There have a NVIF method in MSI GX723 DSDT need call by Nvidia

	 * driver (e.g. nouveau) when user press brightness hotkey.

	 * Currently, nouveau driver didn't do the job and it causes there

	 * have a infinite while loop in DSDT when user press hotkey.

	 * We add MSI GX723's dmi information to this table for workaround

	 * this issue.

	 * Will remove MSI GX723 from the table after nouveau grows support.

	/*

	 * The wireless hotkey does not work on those machines when

	 * returning true for _OSI("Windows 2012")

	/*

	 * BIOS invocation of _OSI(Linux) is almost always a BIOS bug.

	 * Linux ignores it, except for the machines enumerated below.

	/*

	 * Without this EEEpc exports a non working WMI interface, with

	 * this it exports a working "good old" eeepc_laptop interface,

	 * fixing both brightness control, and rfkill not working.

 Enable _OSI("Darwin") for Apple platforms. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * scan.c - support for transforming the ACPI namespace into individual objects

/*

 * The UART device described by the SPCR table is the only object which needs

 * special-casing. Everything else is covered by ACPI namespace paths in STAO

 * table.

	/*

	 * acpi_container_offline() calls this for all of the container's

	 * children under the container's physical_node_lock lock.

 Skip devices offlined by the first pass. */

	/*

	 * Carry out two passes here and ignore errors in the first pass,

	 * because if the devices in question are memory blocks and

	 * CONFIG_MEMCG is set, one of the blocks may hold data structures

	 * that the other blocks depend on, but it is not known in advance which

	 * block holds them.

	 *

	 * If the first pass is successful, the second one isn't needed, though.

	/*

	 * TBD: _EJD support.

	/*

	 * Verify if eject was indeed successful.  If not, log an error

	 * message.  No need to call _OST since _EJ0 call was made OK.

		/*

		 * This function is only called for device objects for which

		 * matching scan handlers exist.  The only situation in which

		 * the scan handler is not attached to this device object yet

		 * is when the device has just appeared (either it wasn't

		 * present at all before or it was removed and then added

		 * again).

	/*

	 * The device object's ACPI handle cannot become invalid as long as we

	 * are holding acpi_scan_lock, but it might have become invalid before

	 * that lock was acquired.

		/*

		 * There may be additional notify handlers for device objects

		 * without the .event() callback, so ignore them here.

		/*

		 * Drop references to all power resources that might have been

		 * used by the device.

/**

 * acpi_scan_drop_device - Drop an ACPI device object.

 * @handle: Handle of an ACPI namespace node, not used.

 * @context: Address of the ACPI device object to drop.

 *

 * This is invoked by acpi_ns_delete_node() during the removal of the ACPI

 * namespace node the device object pointed to by @context is attached to.

 *

 * The unregistration is carried out asynchronously to avoid running

 * acpi_device_del() under the ACPICA's namespace mutex and the list is used to

 * ensure the correct ordering (the device objects must be unregistered in the

 * same order in which the corresponding namespace nodes are deleted).

	/*

	 * Use the ACPI hotplug workqueue which is ordered, so this work item

	 * won't run after any hotplug work items submitted subsequently.  That

	 * prevents attempts to register device objects identical to those being

	 * deleted from happening concurrently (such attempts result from

	 * hotplug events handled via the ACPI hotplug workqueue).  It also will

	 * run after all of the work items submitted previously, which helps

	 * those work items to ensure that they are not accessing stale device

	 * objects.

 Make acpi_ns_validate_handle() return NULL for this handle. */

 Find suitable bus_id and instance number in acpi_bus_id_list. */

	/*

	 * Linkage

	 * -------

	 * Link this device to its parent and siblings.

/* --------------------------------------------------------------------------

                                 Device Enumeration

 List of HIDs for which we ignore matching ACPI devices, when checking _DEP lists. */

 Windows-compatible System Power Management Controller */

 Intel Baytrail Mailbox Device */

	/*

	 * Fixed hardware devices do not appear in the namespace and do not

	 * have handles, but we fabricate acpi_devices for them, so we have

	 * to deal with them specially.

 _PRW */

 Power button */

 Lid */

 Sleep button */

 Power button, Lid switch always enable wakeup */

 Do not use Lid/sleep button for S5 wakeup */

 Presence of _PRW indicates wake capable */

	/*

	 * Call _PSW/_DSW object to disable its ability to wake the sleeping

	 * system for the ACPI device with the _PRW object.

	 * The _PSW object is deprecated in ACPI 3.0 and is replaced by _DSW.

	 * So it is necessary to call _DSW object first. Only when it is not

	 * present will the _PSW object used.

 Evaluate "_PRx" to get referenced power resources */

 Evaluate "_PSx" to see if we can do explicit sets */

 State is valid if there are means to put the device into it. */

 Unknown - driver assigned */

 Unknown - driver assigned */

 Presence of _PS0|_PR0 indicates 'power manageable' */

	/*

	 * Power Management Flags

	/*

	 * Enumerate supported power management states

 Set the defaults for D0 and D3hot (always supported). */

	/*

	 * Use power resources only if the D0 list of them is populated, because

	 * some platforms may provide _PR3 only to indicate D3cold support and

	 * in those cases the power resources list returned by it may be bogus.

		/*

		 * D3cold is supported if the D3hot list of power resources is

		 * not empty.

 Presence of _STA indicates 'dynamic_status' */

 Presence of _RMV indicates 'removable' */

 Presence of _EJD|_EJ0 indicates 'ejectable' */

	/*

	 * Bus ID

	 * ------

	 * The device's Bus ID is simply the object name.

	 * TBD: Shouldn't this value be unique (within the ACPI namespace)?

 Clean up trailing underscores (if any) */

/*

 * acpi_ata_match - see if an acpi object is an ATA device

 *

 * If an acpi object has one of the ACPI ATA methods defined,

 * then we can safely call it an ATA device.

/*

 * acpi_bay_match - see if an acpi object is an ejectable driver bay

 *

 * If an acpi object is ejectable and has one of the ACPI ATA methods defined,

 * then we can safely call it an ejectable drive bay

/*

 * acpi_dock_match - see if an acpi object has a _DCK method

 We have backlight support, no need to scan further */

/* Returns true if the ACPI object is a video device which can be

 * handled by video.ko.

 * The device will get a Linux specific CID added in scan.c to

 * identify the device as an ACPI graphics device

 * Be aware that the graphics device may not be physically present

 * Use acpi_video_get_capabilities() to detect general ACPI video

 * capabilities of present cards

 Is this device able to support video switching ? */

 Is this device able to retrieve a video ROM ? */

 Is this device able to configure which video head to be POSTed ? */

 Only check for backlight functionality if one of the above hit. */

/*

 * Old IBM workstations have a DSDT bug wherein the SMBus object

 * lacks the SMBUS01 HID and the methods do not have the necessary "_"

 * prefix.  Work around this.

 Look for SMBS object */

 Does it have the necessary (but misnamed) methods? */

		/*

		 * Some devices don't reliably have _HIDs & _CIDs, so add

		 * synthetic HIDs to make sure drivers can find them.

 \_SB, \_TZ, LNXSYBUS */

/**

 * acpi_dma_supported - Check DMA support for the specified device.

 * @adev: The pointer to acpi device

 *

 * Return false if DMA is not supported. Otherwise, return true

	/*

	* Per ACPI 6.0 sec 6.2.17, assume devices can do cache-coherent

	* DMA on "Intel platforms".  Presumably that includes all x86 and

	* ia64, and other arches will set CONFIG_ACPI_CCA_REQUIRED=y.

/**

 * acpi_get_dma_attr - Check the supported DMA attr for the specified device.

 * @adev: The pointer to acpi device

 *

 * Return enum dev_dma_attr.

/**

 * acpi_dma_get_range() - Get device DMA parameters.

 *

 * @dev: device to configure

 * @dma_addr: pointer device DMA address result

 * @offset: pointer to the DMA offset result

 * @size: pointer to DMA range size result

 *

 * Evaluate DMA regions and return respectively DMA region start, offset

 * and size in dma_addr, offset and size on parsing success; it does not

 * update the passed in values on failure.

 *

 * Return 0 on success, < 0 on failure.

	/*

	 * Walk the device tree chasing an ACPI companion with a _DMA

	 * object while we go. Stop if we find a device with an ACPI

	 * companion containing a _DMA method.

 Take lower and upper limits */

	/*

	 * If we already translated the fwspec there is nothing left to do,

	 * return the iommu_ops.

	/*

	 * If we have reason to believe the IOMMU driver missed the initial

	 * iommu_probe_device() call for dev, replay it to get things in order.

 Ignore all other errors apart from EPROBE_DEFER */

 !CONFIG_IOMMU_API */

 !CONFIG_IOMMU_API */

/**

 * acpi_dma_configure_id - Set-up DMA configuration for the device.

 * @dev: The pointer to the device

 * @attr: device dma attributes

 * @input_id: input device id const value pointer

		/*

		 * From ACPI spec, OSPM will ignore _CCA if an ancestor

		 * already saw one.

			/*

			 * If architecture does not specify that _CCA is

			 * required for DMA-able devices (e.g. x86),

			 * we default to _CCA=1.

 no need to do more checking */

	/*

	 * These devices have multiple I2cSerialBus resources and an i2c-client

	 * must be instantiated for each, each with its own i2c_device_id.

	 * Normally we only instantiate an i2c-client for the first resource,

	 * using the ACPI HID as id. These special cases are handled by the

	 * drivers/platform/x86/i2c-multi-instantiate.c driver, which knows

	 * which i2c_device_id to use for each resource.

 Macs use device properties in lieu of _CRS resources */

 Instantiate a pdev for the i2c-multi-instantiate drv to bind to */

	/*

	 * Getting the status is delayed till here so that we can call

	 * acpi_bus_get_status() and use its quirk handling.  Note that

	 * this must be done before the get power-/wakeup_dev-flags calls.

			/*

			 * Hold the lock until the acpi_tie_acpi_dev() call

			 * below to prevent concurrent acpi_scan_clear_dep()

			 * from deleting a dependency list entry without

			 * updating dep_unmet for the device.

 Check if it should ignore the UART device */

	/*

	 * The UART device described in SPCR table is assumed to have only one

	 * memory resource present. So we only look for the first one here.

	/*

	 * Check for _HID here to avoid deferring the enumeration of:

	 * 1. PCI devices.

	 * 2. ACPI nodes describing USB ports.

	 * Still, checking for _HID catches more then just these cases ...

 Bail out if there are dependencies. */

 for ACPI_ROOT_OBJECT */

	/*

	 * If check_dep is true at this point, the device has no dependencies,

	 * or the creation of the device object would have been postponed above.

	/*

	 * Do not enumerate devices with enumeration_by_parent flag set as

	 * they will be enumerated by their respective parents.

	/*

	 * Since ACPI_DT_NAMESPACE_HID is the only ID handled here, the test

	 * below can be unconditional.

 Skip devices that are not present. */

 Continue parsing if the device object is not present. */

	/*

	 * Since the work function may block on the lock until the entire

	 * initial enumeration of devices is complete, put it into the unbound

	 * workqueue.

/**

 * acpi_walk_dep_device_list - Apply a callback to every entry in acpi_dep_list

 * @handle:	The ACPI handle of the supplier device

 * @callback:	Pointer to the callback function to apply

 * @data:	Pointer to some data to pass to the callback

 *

 * The return value of the callback determines this function's behaviour. If 0

 * is returned we continue to iterate over acpi_dep_list. If a positive value

 * is returned then the loop is broken but this function returns 0. If a

 * negative value is returned by the callback then the loop is broken and that

 * value is returned as the final error.

/**

 * acpi_dev_clear_dependencies - Inform consumers that the device is now active

 * @supplier: Pointer to the supplier &struct acpi_device

 *

 * Clear dependencies on the given device.

/**

 * acpi_dev_get_first_consumer_dev - Return ACPI device dependent on @supplier

 * @supplier: Pointer to the dependee device

 *

 * Returns the first &struct acpi_device which declares itself dependent on

 * @supplier via the _DEP buffer, parsed from the acpi_dep_list.

 *

 * The caller is responsible for putting the reference to adev when it is no

 * longer needed.

/**

 * acpi_bus_scan - Add ACPI device node objects in a given namespace scope.

 * @handle: Root of the namespace scope to scan.

 *

 * Scan a given ACPI tree (probably recently hot-plugged) and create and add

 * found devices.

 *

 * If no devices were found, -ENODEV is returned, but it does not mean that

 * there has been a real error.  There just have been no suitable ACPI objects

 * in the table trunk from which the kernel could create a device and add an

 * appropriate driver.

 *

 * Must be called under acpi_scan_lock.

 Pass 1: Avoid enumerating devices with missing dependencies. */

 Pass 2: Enumerate all of the remaining devices. */

/**

 * acpi_bus_trim - Detach scan handlers and drivers from ACPI device objects.

 * @adev: Root of the ACPI namespace scope to walk.

 *

 * Must be called under acpi_scan_lock.

	/*

	 * Most likely, the device is going away, so put it into D3cold before

	 * that.

	/*

	 * Enumerate all fixed-feature devices.

	/*

	 * If there is STAO table, check whether it needs to ignore the UART

	 * device in SPCR table.

	/*

	 * Although we call __add_memory() that is documented to require the

	 * device_hotplug_lock, it is not necessary here because this is an

	 * early code when userspace or any other code path cannot trigger

	 * hotplug/hotunplug operations.

	/*

	 * Enumerate devices in the ACPI namespace.

 Fixed feature devices do not exist on HW-reduced platform */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * CPPC (Collaborative Processor Performance Control) methods used by CPUfreq drivers.

 *

 * (C) Copyright 2014, 2015 Linaro Ltd.

 * Author: Ashwin Chaugule <ashwin.chaugule@linaro.org>

 *

 * CPPC describes a few methods for controlling CPU performance using

 * information from a per CPU table called CPC. This table is described in

 * the ACPI v5.0+ specification. The table consists of a list of

 * registers which may be memory mapped or hardware registers and also may

 * include some static integer values.

 *

 * CPU performance is on an abstract continuous scale as against a discretized

 * P-state scale which is tied to CPU frequency only. In brief, the basic

 * operation involves:

 *

 * - OS makes a CPU performance request. (Can provide min and max bounds)

 *

 * - Platform (such as BMC) is free to optimize request within requested bounds

 *   depending on power/thermal budgets etc.

 *

 * - Platform conveys its decision back to OS

 *

 * The communication between OS and platform occurs through another medium

 * called (PCC) Platform Communication Channel. This is a generic mailbox like

 * mechanism which includes doorbell semantics to indicate register updates.

 * See drivers/mailbox/pcc.c for details on PCC.

 *

 * Finer details about the PCC and CPPC spec are available in the ACPI v5.1 and

 * above specifications.

 Any pending/batched PCC write cmds? */

 Ownership of PCC subspace */

 Running count of PCC write commands */

	/*

	 * Lock to provide controlled access to the PCC channel.

	 *

	 * For performance critical usecases(currently cppc_set_perf)

	 *	We need to take read_lock and check if channel belongs to OSPM

	 * before reading or writing to PCC subspace

	 *	We need to take write_lock before transferring the channel

	 * ownership to the platform via a Doorbell

	 *	This allows us to batch a number of CPPC requests if they happen

	 * to originate in about the same time

	 *

	 * For non-performance critical usecases(init)

	 *	Take write_lock for all purposes which gives exclusive access

 Wait queue for CPUs whose requests were batched */

 Array to represent the PCC channel per subspace ID */

 The cpu_pcc_subspace_idx contains per CPU subspace ID */

/*

 * The cpc_desc structure contains the ACPI register details

 * as described in the per CPU _CPC tables. The details

 * include the type of register (e.g. PCC, System IO, FFH etc.)

 * and destination addresses which lets us READ/WRITE CPU performance

 * information using the appropriate I/O methods.

 pcc mapped address + header size + offset within PCC subspace */

 Check if a CPC register is in PCC */

 Evaluates to True if reg is a NULL register descriptor */

 Evaluates to True if an optional cpc field is supported */

/*

 * Arbitrary Retries in case the remote processor is slow to respond

 * to PCC commands. Keeping it high enough to cover emulators where

 * the processors run painfully slow.

	/*

	 * Poll PCC status register every 3us(delay_us) for maximum of

	 * deadline_us(timeout_us) until PCC command complete bit is set(cond)

/*

 * This function transfers the ownership of the PCC to the platform

 * So it must be called while holding write_lock(pcc_lock)

	/*

	 * For CMD_WRITE we know for a fact the caller should have checked

	 * the channel before writing to PCC space

		/*

		 * If there are pending cpc_writes, then we stole the channel

		 * before write completion, so first send a WRITE command to

		 * platform

 CMD_WRITE */

	/*

	 * Handle the Minimum Request Turnaround Time(MRTT)

	 * "The minimum amount of time that OSPM must wait after the completion

	 * of a command before issuing the next command, in microseconds"

	/*

	 * Handle the non-zero Maximum Periodic Access Rate(MPAR)

	 * "The maximum number of periodic requests that the subspace channel can

	 * support, reported in commands per minute. 0 indicates no limitation."

	 *

	 * This parameter should be ideally zero or large enough so that it can

	 * handle maximum number of requests that all the cores in the system can

	 * collectively generate. If it is not, we will follow the spec and just

	 * not send the request to the platform after hitting the MPAR limit in

	 * any 60s window

 Write to the shared comm region. */

 Flip CMD COMPLETE bit */

 Ring doorbell */

 wait for completion and check for PCC errro bit */

 _PSD is optional */

/**

 * acpi_get_psd_map - Map the CPUs in the freq domain of a given cpu

 * @cpu: Find all CPUs that share a domain with cpu.

 * @cpu_data: Pointer to CPU specific CPPC data including PSD info.

 *

 *	Return: 0 for success or negative value for err.

	/*

	 * Now that we have _PSD data from all CPUs, let's setup P-state

	 * domain info.

 Validate the Domain info */

 Here i and cpu are in the same domain */

 Assume no coordination on any error parsing domain info */

		/*

		 * cppc_ss->latency is just a Nominal value. In reality

		 * the remote processor could be much slower to reply.

		 * So add an arbitrary amount of wait on top of Nominal.

 Set flag so that we don't come here for each CPU. */

/**

 * cpc_ffh_supported() - check if FFH reading supported

 *

 * Check if the architecture has support for functional fixed hardware

 * read/write capability.

 *

 * Return: true for supported, false for not supported

/**

 * pcc_data_alloc() - Allocate the pcc_data memory for pcc subspace

 *

 * Check and allocate the cppc_pcc_data memory.

 * In some processor configurations it is possible that same subspace

 * is shared between multiple CPUs. This is seen especially in CPUs

 * with hardware multi-threading support.

 *

 * Return: 0 for success, errno for failure

 Check if CPPC revision + num_ent combination is supported */

/*

 * An example CPC table looks like the following.

 *

 *	Name(_CPC, Package()

 *			{

 *			17,

 *			NumEntries

 *			1,

 *			// Revision

 *			ResourceTemplate(){Register(PCC, 32, 0, 0x120, 2)},

 *			// Highest Performance

 *			ResourceTemplate(){Register(PCC, 32, 0, 0x124, 2)},

 *			// Nominal Performance

 *			ResourceTemplate(){Register(PCC, 32, 0, 0x128, 2)},

 *			// Lowest Nonlinear Performance

 *			ResourceTemplate(){Register(PCC, 32, 0, 0x12C, 2)},

 *			// Lowest Performance

 *			ResourceTemplate(){Register(PCC, 32, 0, 0x130, 2)},

 *			// Guaranteed Performance Register

 *			ResourceTemplate(){Register(PCC, 32, 0, 0x110, 2)},

 *			// Desired Performance Register

 *			ResourceTemplate(){Register(SystemMemory, 0, 0, 0, 0)},

 *			..

 *			..

 *			..

 *

 *		}

 * Each Register() encodes how to access that specific register.

 * e.g. a sample PCC entry has the following encoding:

 *

 *	Register (

 *		PCC,

 *		AddressSpaceKeyword

 *		8,

 *		//RegisterBitWidth

 *		8,

 *		//RegisterBitOffset

 *		0x30,

 *		//RegisterAddress

 *		9

 *		//AccessSize (subspace ID)

 *		0

 *		)

 *	}

/**

 * acpi_cppc_processor_probe - Search for per CPU _CPC objects.

 * @pr: Ptr to acpi_processor containing this CPU's logical ID.

 *

 *	Return: 0 for success or negative value for err.

 Parse the ACPI _CPC table for this CPU. */

 First entry is NumEntries. */

 Second entry should be revision. */

 Iterate through remaining entries in _CPC */

			/*

			 * The PCC Subspace index is encoded inside

			 * the CPC table entries. The same PCC index

			 * will be used for all the PCC entries,

			 * so extract it only once.

 Support only PCC ,SYS MEM and FFH type regs */

	/*

	 * Initialize the remaining cpc_regs as unsupported.

	 * Example: In case FW exposes CPPC v2, the below loop will initialize

	 * LOWEST_FREQ and NOMINAL_FREQ regs as unsupported

 Store CPU Logical ID */

 Parse PSD data for this CPU */

 Register PCC channel once for all PCC subspace ID. */

 Everything looks okay */

 Add per logical CPU nodes for reading its feedback counters. */

 Plug PSD data into this CPU's CPC descriptor. */

 Free all the mapped sys mem areas for this CPU */

/**

 * acpi_cppc_processor_exit - Cleanup CPC structs.

 * @pr: Ptr to acpi_processor containing this CPU's logical ID.

 *

 * Return: Void

 Free all the mapped sys mem areas for this CPU */

/**

 * cpc_read_ffh() - Read FFH register

 * @cpunum:	CPU number to read

 * @reg:	cppc register information

 * @val:	place holder for return value

 *

 * Read bit_width bits from a specified address and bit_offset

 *

 * Return: 0 for success and error code

/**

 * cpc_write_ffh() - Write FFH register

 * @cpunum:	CPU number to write

 * @reg:	cppc register information

 * @val:	value to write

 *

 * Write value of bit_width bits to a specified address and bit_offset

 *

 * Return: 0 for success and error code

/*

 * Since cpc_read and cpc_write are called while holding pcc_lock, it should be

 * as fast as possible. We have already mapped the PCC subspace during init, so

 * we can directly write to it.

/**

 * cppc_get_desired_perf - Get the desired performance register value.

 * @cpunum: CPU from which to get desired performance.

 * @desired_perf: Return address.

 *

 * Return: 0 for success, -EIO otherwise.

/**

 * cppc_get_nominal_perf - Get the nominal performance register value.

 * @cpunum: CPU from which to get nominal performance.

 * @nominal_perf: Return address.

 *

 * Return: 0 for success, -EIO otherwise.

/**

 * cppc_get_perf_caps - Get a CPU's performance capabilities.

 * @cpunum: CPU from which to get capabilities info.

 * @perf_caps: ptr to cppc_perf_caps. See cppc_acpi.h

 *

 * Return: 0 for success with perf_caps populated else -ERRNO.

 Are any of the regs PCC ?*/

 Ring doorbell once to update PCC subspace */

 Read optional lowest and nominal frequencies if present */

/**

 * cppc_get_perf_ctrs - Read a CPU's performance feedback counters.

 * @cpunum: CPU from which to read counters.

 * @perf_fb_ctrs: ptr to cppc_perf_fb_ctrs. See cppc_acpi.h

 *

 * Return: 0 for success with perf_fb_ctrs populated else -ERRNO.

	/*

	 * If reference perf register is not supported then we should

	 * use the nominal perf value

 Are any of the regs PCC ?*/

 Ring doorbell once to update PCC subspace */

	/*

	 * Per spec, if ctr_wrap_time optional register is unsupported, then the

	 * performance counters are assumed to never wrap during the lifetime of

	 * platform

/**

 * cppc_set_perf - Set a CPU's performance controls.

 * @cpu: CPU for which to set performance controls.

 * @perf_ctrls: ptr to cppc_perf_ctrls. See cppc_acpi.h

 *

 * Return: 0 for success, -ERRNO otherwise.

	/*

	 * This is Phase-I where we want to write to CPC registers

	 * -> We want all CPUs to be able to execute this phase in parallel

	 *

	 * Since read_lock can be acquired by multiple CPUs simultaneously we

	 * achieve that goal here

 BEGIN Phase-I */

		/*

		 * Update the pending_write to make sure a PCC CMD_READ will not

		 * arrive and steal the channel during the switch to write lock

	/*

	 * Skip writing MIN/MAX until Linux knows how to come up with

	 * useful values.

 END Phase-I */

	/*

	 * This is Phase-II where we transfer the ownership of PCC to Platform

	 *

	 * Short Summary: Basically if we think of a group of cppc_set_perf

	 * requests that happened in short overlapping interval. The last CPU to

	 * come out of Phase-I will enter Phase-II and ring the doorbell.

	 *

	 * We have the following requirements for Phase-II:

	 *     1. We want to execute Phase-II only when there are no CPUs

	 * currently executing in Phase-I

	 *     2. Once we start Phase-II we want to avoid all other CPUs from

	 * entering Phase-I.

	 *     3. We want only one CPU among all those who went through Phase-I

	 * to run phase-II

	 *

	 * If write_trylock fails to get the lock and doesn't transfer the

	 * PCC ownership to the platform, then one of the following will be TRUE

	 *     1. There is at-least one CPU in Phase-I which will later execute

	 * write_trylock, so the CPUs in Phase-I will be responsible for

	 * executing the Phase-II.

	 *     2. Some other CPU has beaten this CPU to successfully execute the

	 * write_trylock and has already acquired the write_lock. We know for a

	 * fact it (other CPU acquiring the write_lock) couldn't have happened

	 * before this CPU's Phase-I as we held the read_lock.

	 *     3. Some other CPU executing pcc CMD_READ has stolen the

	 * down_write, in which case, send_pcc_cmd will check for pending

	 * CMD_WRITE commands by checking the pending_pcc_write_cmd.

	 * So this CPU can be certain that its request will be delivered

	 *    So in all cases, this CPU knows that its request will be delivered

	 * by another CPU and can return

	 *

	 * After getting the down_write we still need to check for

	 * pending_pcc_write_cmd to take care of the following scenario

	 *    The thread running this code could be scheduled out between

	 * Phase-I and Phase-II. Before it is scheduled back on, another CPU

	 * could have delivered the request to Platform by triggering the

	 * doorbell and transferred the ownership of PCC to platform. So this

	 * avoids triggering an unnecessary doorbell and more importantly before

	 * triggering the doorbell it makes sure that the PCC channel ownership

	 * is still with OSPM.

	 *   pending_pcc_write_cmd can also be cleared by a different CPU, if

	 * there was a pcc CMD_READ waiting on down_write and it steals the lock

	 * before the pcc CMD_WRITE is completed. send_pcc_cmd checks for this

	 * case during a CMD_READ and if there are pending writes it delivers

	 * the write command before servicing the read command

 BEGIN Phase-II */

 Update only if there are pending write commands */

 END Phase-II */

 Wait until pcc_write_cnt is updated by send_pcc_cmd */

 send_pcc_cmd updates the status in case of failure */

/**

 * cppc_get_transition_latency - returns frequency transition latency in ns

 *

 * ACPI CPPC does not explicitly specify how a platform can specify the

 * transition latency for performance change requests. The closest we have

 * is the timing information from the PCCT tables which provides the info

 * on the number and frequency of PCC commands the platform can handle.

	/*

	 * Expected transition latency is based on the PCCT timing values

	 * Below are definition from ACPI spec:

	 * pcc_nominal- Expected latency to process a command, in microseconds

	 * pcc_mpar   - The maximum number of periodic requests that the subspace

	 *              channel can support, reported in commands per minute. 0

	 *              indicates no limitation.

	 * pcc_mrtt   - The minimum amount of time that OSPM must wait after the

	 *              completion of a command before issuing the next command,

	 *              in microseconds.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  acpi_fan.c - ACPI Fan Driver ($Revision: 29 $)

 *

 *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>

 *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

 thermal cooling device callbacks */

		/*

		 * When Fine Grain Control is set, return the state

		 * corresponding to maximum fan->fps[i].control

		 * value compared to the current speed. Here the

		 * fan->fps[] is sorted array with increasing speed.

/* --------------------------------------------------------------------------

 *                               Driver Interface

 * --------------------------------------------------------------------------

 minus revision field */

 sort the state array according to fan speed in increase order */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2005 Intel Corporation

 * Copyright (C) 2009 Hewlett-Packard Development Company, L.P.

 *

 *      Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>

 *      - Added _PDC for platforms with Intel CPUs

 Enable coordination with firmware's _TSD info */

 Twiddle arch-specific bits needed for _PDC */

 allocate and initialize pdc. It will be used later. */

/*

 * _PDC is required for a BIOS-OS handshake for most of the newer

 * ACPI processor features.

		/*

		 * If mwait is disabled for CPU C-states, the C2C3_FFH access

		 * mode will be disabled in the parameter of _PDC object.

		 * Of course C1_FFH access mode will also be disabled.

	/*

	 * Check whether the system is DMI table. If yes, OSPM

	 * should not use mwait for CPU-states.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * processor_idle - idle state submodule to the ACPI processor driver

 *

 *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>

 *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

 *  Copyright (C) 2004, 2005 Dominik Brodowski <linux@brodo.de>

 *  Copyright (C) 2004  Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>

 *  			- Added processor hotplug support

 *  Copyright (C) 2005  Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>

 *  			- Added support for C3 on SMP

 need_resched() */

/*

 * Include the apic definitions for x86 to have the APIC timer related defines

 * available also for UP (on SMP it gets magically included via linux/smp.h).

 * asm/acpi.h is not an option, as it would require more include magic. Also

 * creating an empty asm-ia64/apic.h would just trade pest vs. cholera.

/*

 * IBM ThinkPad R40e crashes mysteriously when going into C2 or C3.

 * For now disable this. Probably a bug somewhere else.

 *

 * To skip this limit, boot/load with a large max_cstate limit.

/*

 * Callers should disable interrupts before the call and enable

 * interrupts after return.

/*

 * Some BIOS implementations switch to C3 in the published C2 state.

 * This seems to be a common problem on AMD boxen, but other vendors

 * are affected too. We pick the most conservative approach: we assume

 * that the local APIC stops in both C2 and C3.

	/*

	 * Check, if one of the previous states already marked the lapic

	 * unstable

 Power(C) State timer broadcast control */

		/*

		 * AMD Fam10h TSC will tick in all

		 * C/P/S0/S1 states when this bit is set.

 TSC could halt in idle, so notify users */

 if info is obtained from pblk/fadt, type equals state */

	/*

	 * Check for P_LVL2_UP flag before entering C2 and above on

	 * an SMP system.

 determine C2 and C3 address from pblk */

 determine latencies from FADT */

	/*

	 * FADT specified C2 latency must be less than or equal to

	 * 100 microseconds.

 invalidate C2 */

	/*

	 * FADT supplied C3 latency must be less than or equal to

	 * 1000 microseconds.

 invalidate C3 */

 set the first C-State to C1 */

 all processors need to support C1 */

 the C0 state only exists as a filler in our array */

	/*

	 * PIIX4 Erratum #18: We don't support C3 when Type-F (fast)

	 * DMA transfers are used by any ISA device to avoid livelock.

	 * Note that we could disable Type-F DMA (as recommended by

	 * the erratum), but this is known to disrupt certain ISA

	 * devices thus we take the conservative approach.

 All the logic here assumes flags.bm_check is same across all CPUs */

 Determine whether bm_check is needed based on CPU  */

 bus mastering control is necessary */

 Here we enter C3 without bus mastering */

		/*

		 * WBINVD should be set in fadt, for C3 state to be

		 * supported on when bm_check is not required.

	/*

	 * Otherwise we've met all of our C3 requirements.

	 * Normalize the C3 latency to expidite policy.  Enable

	 * checking of bus mastering status (bm_check) so we can

	 * use this in our C3 policy

	/*

	 * On older chipsets, BM_RLD needs to be set

	 * in order for Bus Master activity to wake the

	 * system from C3.  Newer chipsets handle DMA

	 * during C3 automatically and BM_RLD is a NOP.

	 * In either case, the proper way to

	 * handle BM_RLD is to set it and leave it set.

	/* NOTE: the idle thread may not be running while calling

 Zero initialize all the C-states info. */

	/*

	 * if one state of type C2 or C3 is available, mark this

	 * CPU as being "idle manageable"

/**

 * acpi_idle_bm_check - checks if bus master activity was detected

	/*

	 * PIIX4 Erratum #18: Note that BM_STS doesn't always reflect

	 * the true state of bus mastering activity; forcing us to

	 * manually check the BMIDEA bit of each IDE channel.

 No delay is needed if we are in guest */

	/* Dummy wait op - must do something useless after P_LVL2 read

	   because chipsets cannot guarantee that STPCLK# signal

/**

 * acpi_idle_do_entry - enter idle state using the appropriate method

 * @cx: cstate data

 *

 * Caller disables interrupt before call and enables interrupt after return.

 Call into architectural FFH based C-state */

 IO port based C-state */

/**

 * acpi_idle_play_dead - enters an ACPI state for long-term idle (i.e. off-lining)

 * @dev: the target CPU

 * @index: the index of suggested state

 Never reached */

/**

 * acpi_idle_enter_bm - enters C3 with proper BM handling

 * @drv: cpuidle driver

 * @pr: Target processor

 * @cx: Target state context

 * @index: index of target state

	/*

	 * disable bus master

	 * bm_check implies we need ARB_DIS

	 * bm_control implies whether we can do ARB_DIS

	 *

	 * That leaves a case where bm_check is set and bm_control is not set.

	 * In that case we cannot do much, we enter C3 without doing anything.

 If we can skip BM, demote to a safe state. */

 Disable bus master arbitration when all CPUs are in C3 */

 Re-enable bus master arbitration */

 C2 to C1 demotion. */

 Don't check BM_STS, do an unconditional ARB_DIS for S2IDLE */

		/*

		 * Halt-induced C1 is not good for ->enter_s2idle, because it

		 * re-enables interrupts on exit.  Moreover, C1 is generally not

		 * particularly interesting from the suspend-to-idle angle, so

		 * avoid C1 and the situations in which we may need to fall back

		 * to it altogether.

 CONFIG_ACPI_PROCESSOR_CSTATE */

 There must be at least 4 elements = 3 elements + 1 package */

 Validate number of power states. */

 LPI States start at index 3 */

 elements[7,8] skipped for now i.e. Residency/Usage counter*/

/*

 * flat_state_cnt - the number of composite LPI states after the process of flattening

/**

 * combine_lpi_states - combine local and parent LPI states to form a composite LPI state

 *

 * @local: local LPI state

 * @parent: parent LPI state

 * @result: composite LPI state

 0 means autopromotable */

 leaf/processor node */

 can be optional ? */

 flatten all the LPI states in this level of hierarchy */

 reset the index after flattening */

 Tell driver that _LPI is supported. */

/**

 * acpi_idle_lpi_enter - enters an ACPI any LPI state

 * @dev: the target CPU

 * @drv: cpuidle driver containing cpuidle state info

 * @index: index of target state

 *

 * Return: 0 for success or negative value for error

/**

 * acpi_processor_setup_cpuidle_states- prepares and configures cpuidle

 * global state data i.e. idle routines

 *

 * @pr: the ACPI processor

/**

 * acpi_processor_setup_cpuidle_dev - prepares and configures CPUIDLE

 * device i.e. per-cpu data

 *

 * @pr: the ACPI processor

 * @dev : the cpuidle device

	/*

	 * FIXME:  Design the ACPI notification to make it once per

	 * system instead of once per-cpu.  This condition is a hack

	 * to make the code that updates C-States be called once.

 Protect against cpu-hotplug */

 Disable all cpuidle devices */

 Populate Updated C-state information */

 Enable all cpuidle devices */

	/*

	 * Install the idle handler if processor power management is supported.

	 * Note that we use previously set idle handler will be used on

	 * platforms that only support C1.

 Register acpi_idle_driver if not already registered */

		/* Register per-cpu cpuidle_device. Cpuidle driver

		 * must already be registered before registering device

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ACPI support for PNP bus type

 *

 * Copyright (C) 2014, Intel Corporation

 * Authors: Zhang Rui <rui.zhang@intel.com>

 *          Rafael J. Wysocki <rafael.j.wysocki@intel.com>

 pata_isapnp */

 Generic ESDI/IDE/ATA compatible hard disk controller */

 floppy */

 tpm_inf_pnp */

 Infineon TPMs */

 Infineon TPMs */

tpm_tis */

 TPM */

 Atmel */

 Infineon */

 Broadcom */

 Broadcom */

 National */

 Intel */

 ide   */

 Generic ESDI/IDE/ATA compatible hard disk controller */

 ns558 */

 AdLib NSC16 */

 AZT1008 */

 Opl3-SAx */

 CS4232 */

 CS4236 */

 CS4327 */

 SB16 */

 AWE64 */

 Vibra16 */

 SoundscapeVIVO */

 ES1869 */

 ES1878 */

 ES688 */

 CS4232 */

 OPTi Audio16 */

 Opl3-SA */

 Opl3-SAx */

 Generic */

 i8042 kbd */

 i8042 aux */

 fcpnp */

 radio-cadet */

 ADS Cadet AM/FM Radio Card */

 radio-gemtek */

 AOpen FX-3D/Pro Radio */

 radio-sf16fmr2 */

 tuner subdevice of SF16-FMD2 */

 ene_ir */

 fintek-cir */

 CIR */

 ite-cir */

 Default model */

 CIR found in EEEBox 1501U */

 Bridged IT8512 */

 SRAM-Bridged IT8512 */

 nuvoton-cir */

 CIR */

 CIR for new chip's pnp id */

 Winbond CIR */

 wbsd */

 Winbond CIR */

 3Com Etherlink III (TP) */

 3Com Etherlink III */

 3Com Etherlink III (combo) */

 3Com Etherlink III (TPO) */

 3Com Etherlink III (TPC) */

 3Com Etherlink III compatible */

 3Com Etherlink III compatible */

 nsc-ircc */

 smsc-ircc2 */

 sb1000 */

 parport_pc */

 Standard LPT Printer Port */

 ECP Printer Port */

 apple-gmux */

 system */

 General ID for reserving resources */

 memory controller */

 rtc_cmos */

 c6xdigio */

 Standard LPT Printer Port */

 ECP Printer Port */

 ni_atmio.c */

 serial */

 Archtek America Corp. Archtek SmartLink Modem 3334BT Plug & Play */

 Anchor Datacomm BV. SXPro 144 External Data Fax Modem Plug & Play */

 SXPro 288 External Data Fax Modem Plug & Play */

 PROLiNK 1456VH ISA PnP K56flex Fax Modem */

 Actiontec ISA PNP 56K X2 Fax Modem */

 Rockwell 56K ACF II Fax+Data+Voice Modem */

 ALi Fast Infrared Controller */

 AZT3005 PnP SOUND DEVICE */

 Best Data Products Inc. Smart One 336F PnP Modem */

 Boca Complete Ofc Communicator 14.4 Data-FAX */

 Boca Research 33,600 ACF Modem */

 Boca 33.6 Kbps Internal FD34FSVD */

 Computer Peripherals Inc. EuroViVa CommCenter-33.6 SP PnP */

 Creative Labs Phone Blaster 28.8 DSVD PnP Voice */

 Creative Labs Modem Blaster 28.8 DSVD PnP Voice */

 Davicom ISA 33.6K Modem */

 Creative Modem Blaster Flash56 DI5601-1 */

 Creative Modem Blaster V.90 DI5660 */

 E-Tech CyberBULLET PC56RVP */

 Fujitsu 33600 PnP-I2 R Plug & Play */

 Fujitsu FMV-FX431 Plug & Play */

 Fujitsu 33600 PnP-I4 R Plug & Play */

 Fujitsu Fax Voice 33600 PNP-I5 R Plug & Play */

 Archtek SmartLink Modem 3334BT Plug & Play */

 Archtek SmartLink Modem 3334BRV 33.6K Data Fax Voice */

 Hayes Optima 288 V.34-V.FC + FAX + Voice Plug & Play */

 Hayes Optima 336 V.34 + FAX + Voice PnP */

 Hayes Optima 336B V.34 + FAX + Voice PnP */

 Hayes Accura 56K Ext Fax Modem PnP */

 Hayes Accura 56K Ext Fax Modem PnP */

 Hayes Accura 56K Fax Modem PnP */

 Hayes 288, V.34 + FAX */

 Hayes Optima 288 V.34 + FAX + Voice, Plug & Play */

 IBM Thinkpad 701 Internal Modem Voice */

 Intermec CV60 touchscreen port */

 Intertex 28k8 33k6 Voice EXT PnP */

 Intertex 33k6 56k Voice EXT PnP */

 Intertex 28k8 33k6 Voice SP EXT PnP */

 Intertex 33k6 56k Voice SP EXT PnP */

 Intertex 28k8 33k6 Voice SP INT PnP */

 Intertex 28k8 33k6 Voice SP EXT PnP */

 Intertex 33k6 56k Voice SP EXT PnP */

 KORTEX 28800 Externe PnP */

 KXPro 33.6 Vocal ASVD PnP */

 LASAT Internet 33600 PnP */

 Lasat Safire 560 PnP */

 Lasat Safire 336  PnP */

 Microcom TravelPorte FAST V.34 Plug & Play */

 Microcom DeskPorte V.34 FAST or FAST+ Plug & Play */

 Microcom DeskPorte FAST EP 28.8 Plug & Play */

 Microcom DeskPorte 28.8P Plug & Play */

 Microcom DeskPorte FAST ES 28.8 Plug & Play */

 Microcom DeskPorte FAST ES 28.8 Plug & Play */

 Microcom DeskPorte 28.8S Internal Plug & Play */

 Motorola BitSURFR Plug & Play */

 Motorola TA210 Plug & Play */

 Motorola HMTA 200 (ISDN) Plug & Play */

 Motorola BitSURFR Plug & Play */

 Motorola Lifestyle 28.8 Internal */

 Motorola V.3400 Plug & Play */

 Motorola Lifestyle 28.8 V.34 Plug & Play */

 Motorola Power 28.8 V.34 Plug & Play */

 Motorola ModemSURFR External 28.8 Plug & Play */

 Motorola Premier 33.6 Desktop Plug & Play */

 Motorola VoiceSURFR 56K External PnP */

 Motorola ModemSURFR 56K External PnP */

 Motorola ModemSURFR 56K Internal PnP */

 Motorola ModemSURFR Internal 28.8 Plug & Play */

 Motorola Premier 33.6 Internal Plug & Play */

 Motorola OnlineSURFR 28.8 Internal Plug & Play */

 Motorola VoiceSURFR 56K Internal PnP */

  Deskline K56 Phone System PnP */

 PC Rider K56 Phone System PnP */

 NEC 98NOTE SPEAKER PHONE FAX MODEM(33600bps) */

 Pace 56 Voice Internal Plug & Play Modem */

 Generic standard PC COM port     */

 Generic 16550A-compatible COM port */

 Compaq 14400 Modem */

 Compaq 2400/9600 Modem */

 Dial-Up Networking Serial Cable between 2 PCs */

 Dial-Up Networking Parallel Cable between 2 PCs */

 Standard 9600 bps Modem */

 Standard 14400 bps Modem */

  Standard 28800 bps Modem */

  Standard Modem */

  Standard 9600 bps Modem */

  Standard 14400 bps Modem */

  Standard 28800 bps Modem */

  Standard Modem */

 Standard 9600 bps Modem */

 Standard 14400 bps Modem */

 Standard 28800 bps Modem */

 Standard Modem */

 Standard 9600 bps Modem */

 Standard 14400 bps Modem */

 Standard 28800 bps Modem */

 Standard Modem */

 Standard PCMCIA Card Modem */

 Rockwell 33.6 DPF Internal PnP, Modular Technology 33.6 Internal PnP */

 KORTEX 14400 Externe PnP */

 Rockwell 28.8 */

 Viking 28.8 INTERNAL Fax+Data+Voice PnP */

 Rockwell 33.6 DPF External PnP, BT Prologue 33.6 External PnP, Modular Technology 33.6 External PnP */

 Viking 56K FAX INT */

 K56 par,VV,Voice,Speakphone,AudioSpan,PnP */

 SupraExpress 28.8 Data/Fax PnP modem */

 SupraExpress 336i PnP Voice Modem */

 SupraExpress 33.6 Data/Fax PnP modem */

 SupraExpress 33.6 Data/Fax PnP modem */

 SupraExpress 336i Sp ASVD */

 SupraExpress 33.6 Data/Fax PnP modem */

 SupraExpress 56i Sp Intl */

 Phoebe Micro 33.6 Data Fax 1433VQH Plug & Play */

 Archtek SmartLink Modem 3334BT Plug & Play */

 3Com Corp. Gateway Telepath IIvi 33.6 */

 U.S. Robotics Sporster 33.6K Fax INT PnP */

  Sportster Vi 14.4 PnP FAX Voicemail */

 U.S. Robotics 33.6K Voice INT PnP */

 U.S. Robotics 33.6K Voice EXT PnP */

 U.S. Robotics Courier V.Everything INT PnP */

 U.S. Robotics 33.6K Voice INT PnP */

 U.S. Robotics 56K Voice INT PnP */

 U.S. Robotics 56K Voice EXT PnP */

 U.S. Robotics 56K FAX INT */

 U.S. Robotics 56K FAX INT */

 U.S. Robotics 56K Voice INT PnP */

 U.S. Robotics 56K Voice EXT PnP */

 U.S. Robotics 56K Voice INT PnP */

 U.S. Robotics 56K Message  */

 U.S. Robotics 56K FAX EXT PnP */

 U.S. Robotics 56K FAX INT PnP */

 U.S. Robotics 56K Voice EXT PnP */

 U.S. Robotics 56K Voice INT PnP */

 Wacom tablets */

 Compaq touchscreen */

 Fujitsu Stylistic touchscreens */

 Fujitsu Stylistic LT touchscreens */

 Passive Fujitsu Stylistic touchscreens */

 Fujitsu Wacom Tablet PC device */

 Fujitsu P-series tablet PC device */

 Fujitsu Wacom 2FGT Tablet PC device */

 Fujitsu Wacom 1FGT Tablet PC device */

 LG C1 EXPRESS DUAL (C1-PB11A3) touch screen (actually a FUJ02E6 in disguise) */

 Rockwell's (PORALiNK) 33600 INT PNP */

 Winbond CIR port, should not be probed. We should keep track of it to prevent the legacy serial driver from probing it */

 scl200wdt */

 National Semiconductor PC87307/PC97307 watchdog component */

 mpu401 */

 cs423x-pnpbios */

 Guillemot Turtlebeach something appears to be cs4232 compatible */

 es18xx-pnpbios */

 snd-opl3sa2-pnpbios */

 Gateway Solo 2500 */

/*

 * For CMOS RTC devices, the PNP ACPI scan handler does not work, because

 * there is a CMOS RTC ACPI scan handler installed already, so we need to

 * check those devices and enumerate them to the PNP bus directly.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  blacklist.c

 *

 *  Check to see if the given machine has a known bad ACPI BIOS

 *  or if the BIOS is too old.

 *  Check given machine against acpi_rev_dmi_table[].

 *

 *  Copyright (C) 2004 Len Brown <len.brown@intel.com>

 *  Copyright (C) 2002 Andy Grover <andrew.grover@intel.com>

/*

 * POLICY: If *anything* doesn't work, put it on the blacklist.

 *	   If they are critical errors, mark it critical, and abort driver load.

 Compaq Presario 1700 */

 Sony FX120, FX140, FX150? */

 Compaq Presario 800, Insyde BIOS */

 IBM 600E - _ADR should return 7, but it returns 1 */

	/*

	 * DELL XPS 13 (2015) switches sound between HDA and I2S

	 * depending on the ACPI _REV callback. If userspace supports

	 * I2S sufficiently (or if you do not care about sound), you

	 * can safely disable this quirk.

	/*

	 * Resolves a quirk with the Dell Latitude 3350 that

	 * causes the ethernet adapter to not function.

 CONFIG_DMI */

 SPDX-License-Identifier: GPL-2.0

/*

 * wakeup.c - support wakeup devices

 * Copyright (C) 2004 Li Shaohua <shaohua.li@intel.com>

/*

 * We didn't lock acpi_device_lock in the file, because it invokes oops in

 * suspend/resume and isn't really required as this is called in S-state. At

 * that time, there is no device hotplug

/**

 * acpi_enable_wakeup_devices - Enable wake-up device GPEs.

 * @sleep_state: ACPI system sleep state.

 *

 * Enable wakeup device power of devices with the state.enable flag set and set

 * the wakeup enable mask bits in the GPE registers that correspond to wakeup

 * devices.

 The wake-up power should have been enabled already. */

/**

 * acpi_disable_wakeup_devices - Disable devices' wakeup capability.

 * @sleep_state: ACPI system sleep state.

 Button GPEs are supposed to be always enabled. */

/**

 * acpi_register_wakeup_handler - Register wakeup handler

 * @wake_irq: The IRQ through which the device may receive wakeups

 * @wakeup:   Wakeup-handler to call when the SCI has triggered a wakeup

 * @context:  Context to pass to the handler when calling it

 *

 * Drivers which may share an IRQ with the SCI can use this to register

 * a handler which returns true when the device they are managing wants

 * to trigger a wakeup.

	/*

	 * If the device is not sharing its IRQ with the SCI, there is no

	 * need to register the handler.

/**

 * acpi_unregister_wakeup_handler - Unregister wakeup handler

 * @wakeup:   Wakeup-handler passed to acpi_register_wakeup_handler()

 * @context:  Context passed to acpi_register_wakeup_handler()

 No need to lock, nothing else is running when we're called. */

 SPDX-License-Identifier: GPL-2.0

/*

 * ACPI Time and Alarm (TAD) Device Driver

 *

 * Copyright (C) 2018 Intel Corporation

 * Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

 *

 * This driver is based on Section 9.18 of the ACPI 6.2 specification revision.

 *

 * It only supports the system wakeup capabilities of the TAD.

 *

 * Provided are sysfs attributes, available under the TAD platform device,

 * allowing user space to manage the AC and DC wakeup timers of the TAD:

 * set and read their values, set and check their expire timer wake policies,

 * check and clear their status and check the capabilities of the TAD reported

 * by AML.  The DC timer attributes are only present if the TAD supports a

 * separate DC alarm timer.

 *

 * The wakeup events handling and power management of the TAD is expected to

 * be taken care of by the ACPI PM domain attached to its platform device.

 ACPI TAD capability flags (ACPI 6.2, Section 9.18.2) */

 ACPI TAD alarm timer selection */

 Special value for disabled timer or expired timer wake policy. */

 1900 - 9999 */

 1 - 12 */

 1 - 31 */

 0 - 23 */

 0 - 59 */

 0 - 59 */

 0 (failed) or 1 (success) for reads, 0 for writes */

 1 - 1000 */

 -1440 to 1440 or 2047 (unspecified) */

 must be 0 */

	/*

	 * Initialization failure messages are mostly about firmware issues, so

	 * print them at the "info" level.

	/*

	 * Assume that the ACPI PM domain has been attached to the device and

	 * simply enable system wakeup and runtime PM and put the device into

	 * runtime suspend.  Everything else should be taken care of by the ACPI

	 * PM domain callbacks.

	/*

	 * The platform bus type layer tells the ACPI PM domain powers up the

	 * device, so set the runtime PM status of it to "active".

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/acpi/power.c - ACPI Power Resources management.

 *

 * Copyright (C) 2001 - 2015 Intel Corp.

 * Author: Andy Grover <andrew.grover@intel.com>

 * Author: Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

 * Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

/*

 * ACPI power-managed devices may be controlled in two ways:

 * 1. via "Device Specific (D-State) Control"

 * 2. via "Power Resource Control".

 * The code below deals with ACPI Power Resources control.

 *

 * An ACPI "power resource object" represents a software controllable power

 * plane, clock plane, or other resource depended on by a device.

 *

 * A device may rely on multiple power resources, and a power resource

 * may be shared by multiple devices.

/* --------------------------------------------------------------------------

                             Power Resource Management

 The caller is expected to check the package element types */

 Some ACPI tables contain duplicate power resource references */

 The state of the list is 'on' IFF all resources are 'on'. */

 Only add it once */

/**

 * acpi_device_power_add_dependent - Add dependent device of this ACPI device

 * @adev: ACPI device pointer

 * @dev: Dependent device

 *

 * If @adev has non-empty _PR0 the @dev is added as dependent device to all

 * power resources returned by it. This means that whenever these power

 * resources are turned _ON the dependent devices get runtime resumed. This

 * is needed for devices such as PCI to allow its driver to re-initialize

 * it after it went to D0uninitialized.

 *

 * If @adev does not have _PR0 this does nothing.

 *

 * Returns %0 in case of success and negative errno otherwise.

/**

 * acpi_device_power_remove_dependent - Remove dependent device

 * @adev: ACPI device pointer

 * @dev: Dependent device

 *

 * Does the opposite of acpi_device_power_add_dependent() and removes the

 * dependent device if it is found. Can be called to @adev that does not

 * have _PR0 as well.

	/*

	 * If there are other dependents on this power resource we need to

	 * resume them now so that their drivers can re-initialize the

	 * hardware properly after it went back to D0.

		/*

		 * Make sure that the power resource state and its reference

		 * counter value are consistent with each other.

/* --------------------------------------------------------------------------

                             Device Power Management

/**

 * acpi_device_sleep_wake - execute _DSW (Device Sleep Wake) or (deprecated in

 *                          ACPI 3.0) _PSW (Power State Wake)

 * @dev: Device to handle.

 * @enable: 0 - disable, 1 - enable the wake capabilities of the device.

 * @sleep_state: Target sleep state of the system.

 * @dev_state: Target power state of the device.

 *

 * Execute _DSW (Device Sleep Wake) or (deprecated in ACPI 3.0) _PSW (Power

 * State Wake) for the device, if present.  On failure reset the device's

 * wakeup.flags.valid flag.

 *

 * RETURN VALUE:

 * 0 if either _DSW or _PSW has been successfully executed

 * 0 if neither _DSW nor _PSW has been found

 * -ENODEV if the execution of either _DSW or _PSW has failed

	/*

	 * Try to execute _DSW first.

	 *

	 * Three arguments are needed for the _DSW object:

	 * Argument 0: enable/disable the wake capabilities

	 * Argument 1: target system state

	 * Argument 2: target device state

	 * When _DSW object is called to disable the wake capabilities, maybe

	 * the first argument is filled. The values of the other two arguments

	 * are meaningless.

 Execute _PSW */

/*

 * Prepare a wakeup device, two steps (Ref ACPI 2.0:P229):

 * 1. Power on the power resources required for the wakeup device

 * 2. Execute _DSW (Device Sleep Wake) or (deprecated in ACPI 3.0) _PSW (Power

 *    State Wake) for the device, if present

	/*

	 * Passing 3 as the third argument below means the device may be

	 * put into arbitrary power state afterward.

/*

 * Shutdown a wakeup device, counterpart of above method

 * 1. Execute _DSW (Device Sleep Wake) or (deprecated in ACPI 3.0) _PSW (Power

 *    State Wake) for the device, if present

 * 2. Shutdown down the power resources

 Do nothing if wakeup power has not been enabled for this device. */

	/*

	 * All of the power resources in the list need to be turned off even if

	 * there are errors.

	/*

	 * We know a device's inferred power state when all the resources

	 * required for a given D-state are 'on'.

	/*

	 * First we reference all power resources required in the target list

	 * (e.g. so the device doesn't lose power while transitioning).  Then,

	 * we dereference all power resources used in the current list.

 We shouldn't change the state unless the above operations succeed. */

 Evaluate the object to get the system level and resource order. */

 Get the initial state or just flip it on if that fails. */

/**

 * acpi_turn_off_unused_power_resources - Turn off power resources not in use.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * processor_thermal.c - Passive cooling submodule of the ACPI processor driver

 *

 *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>

 *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

 *  Copyright (C) 2004       Dominik Brodowski <linux@brodo.de>

 *  Copyright (C) 2004  Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>

 *  			- Added processor hotplug support

/* If a passive cooling situation is detected, primarily CPUfreq is used, as it

 * offers (in most cases) voltage scaling in addition to frequency scaling, and

 * thus a cubic (instead of linear) reduction of energy. Also, we allow for

 * _any_ cpufreq driver and not only the acpi-cpufreq driver.

/*

 * Emulate "per package data" using per cpu data (which should really be

 * provided elsewhere)

 *

 * Note we can lose a CPU on cpu hotunplug, in this case we forget the state

 * temporarily. Fortunately that's not a big issue here (I hope)

	/*

	 * Update all the CPUs in the same package because they all

	 * contribute to the temperature and often share the same

	 * frequency.

 ! CONFIG_CPU_FREQ */

 thermal cooling device callbacks */

	/*

	 * There exists four states according to

	 * cpufreq_thermal_reduction_pctg. 0, 1, 2, 3

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  acpi_utils.c - ACPI Utility Functions ($Revision: 10 $)

 *

 *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>

 *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

/* --------------------------------------------------------------------------

                            Object Evaluation Helpers

	/*

	 * Calculate size_required.

 TBD: handle nested packages... */

	/*

	 * Validate output buffer.

	/*

	 * Extract package data.

 NULL terminate string */

 Should never get here */

 NULL terminate string */

 Should never get here */

 Should never get here */

 TBD: handle nested packages... */

 Should never get here */

 Evaluate object. */

 Extract package data. */

 Get the  acpi_handle. */

kfree(list->handles);

/**

 * acpi_evaluate_ost: Evaluate _OST for hotplug operations

 * @handle: ACPI device handle

 * @source_event: source event code

 * @status_code: status code

 * @status_buf: optional detailed information (NULL if none)

 *

 * Evaluate _OST for hotplug operations. All ACPI hotplug handlers

 * must call this function when evaluating _OST for hotplug operations.

 * When the platform does not support _OST, this function has no effect.

/**

 * acpi_handle_path: Return the object path of handle

 * @handle: ACPI device handle

 *

 * Caller must free the returned buffer

/**

 * acpi_handle_printk: Print message with ACPI prefix and object path

 * @level: log level

 * @handle: ACPI device handle

 * @fmt: format string

 *

 * This function is called through acpi_handle_<level> macros and prints

 * a message with ACPI prefix and object path.  This function acquires

 * the global namespace mutex to obtain an object path.  In interrupt

 * context, it shows the object path as <n/a>.

/**

 * __acpi_handle_debug: pr_debug with ACPI prefix and object path

 * @descriptor: Dynamic Debug descriptor

 * @handle: ACPI device handle

 * @fmt: format string

 *

 * This function is called through acpi_handle_debug macro and debug

 * prints a message with ACPI prefix and object path. This function

 * acquires the global namespace mutex to obtain an object path.  In

 * interrupt context, it shows the object path as <n/a>.

/**

 * acpi_evaluation_failure_warn - Log evaluation failure warning.

 * @handle: Parent object handle.

 * @name: Name of the object whose evaluation has failed.

 * @status: Status value returned by the failing object evaluation.

/**

 * acpi_has_method: Check whether @handle has a method named @name

 * @handle: ACPI device handle

 * @name: name of object or method

 *

 * Check whether @handle has a method named @name.

/**

 * acpi_evaluate_ej0: Evaluate _EJ0 method for hotplug operations

 * @handle: ACPI device handle

 *

 * Evaluate device's _EJ0 method for hotplug operations.

/**

 * acpi_evaluate_lck: Evaluate _LCK method to lock/unlock device

 * @handle: ACPI device handle

 * @lock: lock device if non-zero, otherwise unlock device

 *

 * Evaluate device's _LCK method if present to lock/unlock device

/**

 * acpi_evaluate_reg: Evaluate _REG method to register OpRegion presence

 * @handle: ACPI device handle

 * @space_id: ACPI address space id to register OpRegion presence for

 * @function: Parameter to pass to _REG one of ACPI_REG_CONNECT or

 *            ACPI_REG_DISCONNECT

 *

 * Evaluate device's _REG method to register OpRegion presence.

/**

 * acpi_evaluate_dsm - evaluate device's _DSM method

 * @handle: ACPI device handle

 * @guid: GUID of requested functions, should be 16 bytes

 * @rev: revision number of requested function

 * @func: requested function number

 * @argv4: the function specific parameter

 *

 * Evaluate device's _DSM method with specified GUID, revision id and

 * function number. Caller needs to free the returned object.

 *

 * Though ACPI defines the fourth parameter for _DSM should be a package,

 * some old BIOSes do expect a buffer or an integer etc.

/**

 * acpi_check_dsm - check if _DSM method supports requested functions.

 * @handle: ACPI device handle

 * @guid: GUID of requested functions, should be 16 bytes at least

 * @rev: revision number of requested functions

 * @funcs: bitmap of requested functions

 *

 * Evaluate device's _DSM method to check whether it supports requested

 * functions. Currently only support 64 functions at maximum, should be

 * enough for now.

 For compatibility, old BIOSes may return an integer */

	/*

	 * Bit 0 indicates whether there's support for any functions other than

	 * function 0 for the specified GUID and revision.

/**

 * acpi_dev_hid_uid_match - Match device by supplied HID and UID

 * @adev: ACPI device to match.

 * @hid2: Hardware ID of the device.

 * @uid2: Unique ID of the device, pass NULL to not check _UID.

 *

 * Matches HID and UID in @adev with given @hid2 and @uid2.

 * Returns true if matches.

/**

 * acpi_dev_found - Detect presence of a given ACPI device in the namespace.

 * @hid: Hardware ID of the device.

 *

 * Return %true if the device was present at the moment of invocation.

 * Note that if the device is pluggable, it may since have disappeared.

 *

 * For this function to work, acpi_bus_scan() must have been executed

 * which happens in the subsys_initcall() subsection. Hence, do not

 * call from a subsys_initcall() or earlier (use acpi_get_devices()

 * instead). Calling from module_init() is fine (which is synonymous

 * with device_initcall()).

/**

 * acpi_dev_present - Detect that a given ACPI device is present

 * @hid: Hardware ID of the device.

 * @uid: Unique ID of the device, pass NULL to not check _UID

 * @hrv: Hardware Revision of the device, pass -1 to not check _HRV

 *

 * Return %true if a matching device was present at the moment of invocation.

 * Note that if the device is pluggable, it may since have disappeared.

 *

 * Note that unlike acpi_dev_found() this function checks the status

 * of the device. So for devices which are present in the DSDT, but

 * which are disabled (their _STA callback returns 0) this function

 * will return false.

 *

 * For this function to work, acpi_bus_scan() must have been executed

 * which happens in the subsys_initcall() subsection. Hence, do not

 * call from a subsys_initcall() or earlier (use acpi_get_devices()

 * instead). Calling from module_init() is fine (which is synonymous

 * with device_initcall()).

/**

 * acpi_dev_get_next_match_dev - Return the next match of ACPI device

 * @adev: Pointer to the previous ACPI device matching this @hid, @uid and @hrv

 * @hid: Hardware ID of the device.

 * @uid: Unique ID of the device, pass NULL to not check _UID

 * @hrv: Hardware Revision of the device, pass -1 to not check _HRV

 *

 * Return the next match of ACPI device if another matching device was present

 * at the moment of invocation, or NULL otherwise.

 *

 * The caller is responsible for invoking acpi_dev_put() on the returned device.

 * On the other hand the function invokes  acpi_dev_put() on the given @adev

 * assuming that its reference counter had been increased beforehand.

 *

 * See additional information in acpi_dev_present() as well.

/**

 * acpi_dev_get_first_match_dev - Return the first match of ACPI device

 * @hid: Hardware ID of the device.

 * @uid: Unique ID of the device, pass NULL to not check _UID

 * @hrv: Hardware Revision of the device, pass -1 to not check _HRV

 *

 * Return the first match of ACPI device if a matching device was present

 * at the moment of invocation, or NULL otherwise.

 *

 * The caller is responsible for invoking acpi_dev_put() on the returned device.

 *

 * See additional information in acpi_dev_present() as well.

/**

 * acpi_reduced_hardware - Return if this is an ACPI-reduced-hw machine

 *

 * Return true when running on an ACPI-reduced-hw machine, false otherwise.

/*

 * acpi_backlight= handling, this is done here rather then in video_detect.c

 * because __setup cannot be used in modules.

/**

 * acpi_match_platform_list - Check if the system matches with a given list

 * @plat: pointer to acpi_platform_list table terminated by a NULL entry

 *

 * Return the matched index if the system is found in the platform list.

 * Otherwise, return a negative error code.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ACPI watchdog table parsing support.

 *

 * Copyright (C) 2016, Intel Corporation

 * Author: Mika Westerberg <mika.westerberg@linux.intel.com>

/*

 * There are several systems where the WDAT table is accessing RTC SRAM to

 * store persistent information. This does not work well with the Linux RTC

 * driver so on those systems we skip WDAT driver and prefer iTCO_wdt

 * instead.

 *

 * See also https://bugzilla.kernel.org/show_bug.cgi?id=199033.

 It is fine if there is no WDAT */

/**

 * Returns true if this system should prefer ACPI based watchdog instead of

 * the native one (which are typically the same hardware).

 ACPI watchdog can be disabled on boot command line */

 It is fine if there is no WDAT */

 Watchdog disabled by BIOS */

 Skip legacy PCI WDT devices */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * processor_perflib.c - ACPI Processor P-States Library ($Revision: 71 $)

 *

 *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>

 *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

 *  Copyright (C) 2004       Dominik Brodowski <linux@brodo.de>

 *  Copyright (C) 2004  Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>

 *  			- Added processor hotplug support

/*

 * _PPC support is implemented as a CPUfreq policy notifier:

 * This means each time a CPUfreq driver registered also with

 * the ACPI core is asked to change the speed policy, the maximum

 * value is adjusted so that it is within the platform limit.

 *

 * Also, when a new platform limit value is detected, the CPUfreq

 * policy is adjusted accordingly.

/* ignore_ppc:

 * -1 -> cpufreq low level drivers not initialized -> _PSS, etc. not called yet

 *       ignore _PPC

 *  0 -> cpufreq low level drivers initialized -> consider _PPC values

 *  1 -> ignore _PPC totally -> forced by user through boot param

	/*

	 * _PPC indicates the maximum state currently supported by the platform

	 * (e.g. 0 = states 0..n; 1 = states 1..n; etc.

/*

 * acpi_processor_ppc_ost: Notify firmware the _PPC evaluation status

 * @handle: ACPI processor handle

 * @status: the status code of _PPC evaluation

 *	0: success. OSPM is now using the performance state specified.

 *	1: failure. OSPM has not changed the number of P-states in use

		/*

		 * Only when it is notification event, the _OST object

		 * will be evaluated. Otherwise it is skipped.

	/*

	 * Only when it is notification event, the _OST object

	 * will be evaluated. Otherwise it is skipped.

	/*

	 * control_register

	/*

	 * status_register

/*

 * Some AMDs have 50MHz frequency multiples, but only provide 100MHz rounding

 * in their ACPI data. Calculate the real values and fix up the _PSS data.

		/*

		 * MSR C001_0064+:

		 * Bit 63: PstateEn. Read-write. If set, the P-state is valid.

		/*

		 * Check that ACPI's u64 MHz will be valid as u32 KHz in cpufreq

				/*

				 * Copy this valid entry over last_invalid entry

 We need to call _PPC once when cpufreq starts */

	/*

	 * Having _PPC but missing frequencies (_PSS, _PCT) is a very good hint that

	 * the BIOS is older than the CPU and does not know its frequencies

	/* is_done is set to negative if an error occurred,

	 * and to postitive if _no_ error occurred, but SMM

	 * was already notified. This avoids double notification

	 * which might lead to unexpected results...

	/* Success. If there's no _PPC, we need to fear nothing, so

	/*

	 * Check if another driver has already registered, and abort before

	 * changing pr->performance if it has. Check input data as well.

 Look only at processors in ACPI namespace */

 Call _PSD for all CPUs */

	/*

	 * Now that we have _PSD data from all CPUs, lets setup P-state

	 * domain info.

 Validate the Domain info */

 Here i and j are in the same domain */

 Assume no coordination on any error parsing domain info */

 Will be set for real in register */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  video.c - ACPI Video Driver

 *

 *  Copyright (C) 2004 Luming Yu <luming.yu@intel.com>

 *  Copyright (C) 2004 Bruno Ducrot <ducrot@poupinou.org>

 *  Copyright (C) 2006 Thomas Tuttle <linux-kernel@ttuttle.net>

/*

 * By default, we don't allow duplicate ACPI video bus devices

 * under the same VGA controller

/*

 * Whether the struct acpi_video_device_attrib::device_id_scheme bit should be

 * assumed even if not actually set.

/*

 * Indices in the _BCL method response: the first two items are special,

 * the rest are all supported levels.

 *

 * See page 575 of the ACPI spec 3.0

 level when machine has full power */

 level when machine is on batteries */

 actual supported levels begin here */

 can switch video heads */

 can retrieve a video rom */

 can configure the head to */

 Enable/Disable output switching */

 Enumerate all devices attached to display adapter */

 Get ROM Data */

 Get POST Device */

 Set POST Device */

 Video POST Options */

 A zero-based instance of the Display */

 This field differentiates the display type */

 Describe the specific type in use */

 Chipset Vendor Specific */

 BIOS can detect the device */

	u32 depend_on_vga:1;	/* Non-VGA output device whose power is related to

 For VGA multiple-head devices. */

 Must be 0 */

	/*

	 * The device ID might not actually follow the scheme described by this

	 * struct acpi_video_device_attrib. If it does, then this bit

	 * device_id_scheme is set; otherwise, other fields should be ignored.

	 *

	 * (but also see the global flag device_id_scheme)

 protects video_device_list */

 for input device */

 Return the unique ID */

 Query list of brightness control levels supported */

 Set the brightness level */

 Get current brightness level */

 Some buggy BIOS uses _BCQ instead of _BQC */

 Return the EDID for this device */

 backlight device sysfs support */

 thermal cooling device callbacks */

/*

 * --------------------------------------------------------------------------

 *                             Video Management

 * --------------------------------------------------------------------------

/*

 * For some buggy _BQC methods, we need to add a constant value to

 * the _BQC return value to get the actual current brightness level

	/*

	 * Broken _BQC workaround http://bugzilla.kernel.org/show_bug.cgi?id=13121

	/*

	 * Some machines have a broken acpi-video interface for brightness

	 * control, but still need an acpi_video_device_lcd_set_level() call

	 * on resume to turn the backlight power on.  We Enable backlight

	 * control on these systems, but do not register a backlight sysfs

	 * as brightness control does not work.

bugzilla.kernel.org/show_bug.cgi?id=21012 */

bugs.freedesktop.org/show_bug.cgi?id=82634 */

bugzilla.kernel.org/show_bug.cgi?id=21012 */

	/*

	 * Some machine's _DOD IDs don't have bit 31(Device ID Scheme) set

	 * but the IDs actually follow the Device ID Scheme.

bugzilla.kernel.org/show_bug.cgi?id=104121 */

	/*

	 * Some machines have multiple video output devices, but only the one

	 * that is the type of LCD can do the backlight control so we should not

	 * register backlight interface for other video output devices.

bugzilla.kernel.org/show_bug.cgi?id=104121 */

	/*

	 * Some machines report wrong key events on the acpi-bus, suppress

	 * key event reporting on these.  Note this is only intended to work

	 * around events which are plain wrong. In some cases we get double

	 * events, in this case acpi-video is considered the canonical source

	 * and the events from the other source should be filtered. E.g.

	 * by calling acpi_video_handles_brightness_key_presses() from the

	 * vendor acpi/wmi driver or by using /lib/udev/hwdb.d/60-keyboard.hwdb

	/*

	 * Some machines change the brightness themselves when a brightness

	 * hotkey gets pressed, despite us telling them not to. In this case

	 * acpi_video_device_notify() should only call backlight_force_update(

	 * BACKLIGHT_UPDATE_HOTKEY) and not do anything else.

bugzilla.kernel.org/show_bug.cgi?id=204077 */

		/*

		 * _BQC returns an index that doesn't account for the first 2

		 * items with special meaning (see enum acpi_video_level_idx),

		 * so we need to compensate for that by offsetting ourselves

				/*

				 * Caller has indicated he wants the raw

				 * value returned by _BQC, so don't furtherly

				 * mess with the value.

			/*

			 * BQC returned an invalid level.

			 * Stop using it.

			/*

			 * Fixme:

			 * should we return an error or ignore this failure?

			 * dev->brightness->curr is a cached value which stores

			 * the correct current backlight level in most cases.

			 * ACPI video backlight still works w/ buggy _BQC.

			 * http://bugzilla.kernel.org/show_bug.cgi?id=12233

 bus */

/*

 *  Arg:

 *	video		: video bus device pointer

 *	bios_flag	:

 *		0.	The system BIOS should NOT automatically switch(toggle)

 *			the active display output.

 *		1.	The system BIOS should automatically switch (toggle) the

 *			active display output. No switch event.

 *		2.	The _DGS value should be locked.

 *		3.	The system BIOS should not automatically switch (toggle) the

 *			active display output, but instead generate the display switch

 *			event notify code.

 *	lcd_flag	:

 *		0.	The system BIOS should automatically control the brightness level

 *			of the LCD when:

 *			- the power changes from AC to DC (ACPI appendix B)

 *			- a brightness hotkey gets pressed (implied by Win7/8 backlight docs)

 *		1.	The system BIOS should NOT automatically control the brightness

 *			level of the LCD when:

 *			- the power changes from AC to DC (ACPI appendix B)

 *			- a brightness hotkey gets pressed (implied by Win7/8 backlight docs)

 *  Return Value:

 *		-EINVAL	wrong arg.

/*

 * Simple comparison function used to sort backlight levels.

/*

 * Decides if _BQC/_BCQ for this system is usable

 *

 * We do this by changing the level first and then read out the current

 * brightness level, if the value does not match, find out if it is using

 * index. If not, clear the _BQC/_BCQ capability.

 don't mess with existing known broken systems */

	/*

	 * Some systems always report current brightness level as maximum

	 * through _BQC, we need to test another value for them. However,

	 * there is a subtlety:

	 *

	 * If the _BCL package ordering is descending, the first level

	 * (br->levels[2]) is likely to be 0, and if the number of levels

	 * matches the number of steps, we might confuse a returned level to

	 * mean the index.

	 *

	 * For example:

	 *

	 *     current_level = max_level = 100

	 *     test_level = 0

	 *     returned level = 100

	 *

	 * In this case 100 means the level, not the index, and _BCM failed.

	 * Still, if the _BCL package ordering is descending, the index of

	 * level 0 is also 100, so we assume _BQC is indexed, when it's not.

	 *

	 * This causes all _BQC calls to return bogus values causing weird

	 * behavior from the user's perspective.  For example:

	 *

	 * xbacklight -set 10; xbacklight -set 20;

	 *

	 * would flash to 90% and then slowly down to the desired level (20).

	 *

	 * The solution is simple; test anything other than the first level

	 * (e.g. 1).

 buggy _BQC found, need to find out if it uses index */

	/*

	 * Note that we have to reserve 2 extra items (ACPI_VIDEO_FIRST_LEVEL),

	 * in order to account for buggy BIOS which don't export the first two

	 * special levels (see below)

 Skip duplicate entries */

	/*

	 * some buggy BIOS don't export the levels

	 * when machine is on AC/Battery in _BCL package.

	 * In this case, the first two elements in _BCL packages

	 * are also supported brightness levels that OS should take care of.

 Check if the _BCL package is in a reversed order */

/*

 *  Arg:

 *	device	: video output device (LCD, CRT, ..)

 *

 *  Return Value:

 *	Maximum brightness level

 *

 *  Allocate and initialize device->brightness.

 _BQC uses INDEX while _BCL uses VALUE in some laptops */

	/*

	 * cap._BQC may get cleared due to _BQC is found to be broken

	 * in acpi_video_bqc_quirk, so check again here.

	/*

	 * On some buggy laptops, _BQC returns an uninitialized

	 * value when invoked for the first time, i.e.

	 * level_old is invalid (no matter whether it's a level

	 * or an index). Set the backlight to max_level in this case.

/*

 *  Arg:

 *	device	: video output device (LCD, CRT, ..)

 *

 *  Return Value:

 *	None

 *

 *  Find out all required AML methods defined under the output

 *  device.

/*

 *  Arg:

 *	device	: video output device (VGA)

 *

 *  Return Value:

 *	None

 *

 *  Find out all required AML methods defined under the video bus device.

/*

 * Check whether the video bus device has required AML method to

 * support the desired features

	/*

	 * Since there is no HID, CID and so on for VGA driver, we have

	 * to check well known required nodes.

 Does this device support video switching? */

 Does this device support retrieving a video ROM? */

 Does this device support configuring which video device to POST? */

/*

 * --------------------------------------------------------------------------

 *                               Driver Interface

 * --------------------------------------------------------------------------

 device interface */

 Some device omits _ADR, we skip them instead of fail */

 Check for legacy IDs */

 Ignore bits 16 and 18-20 */

/*

 *  Arg:

 *	video	: video bus device

 *

 *  Return:

 *	none

 *

 *  Enumerate the video device list of the video bus,

 *  bind the ids with the corresponding video devices

 *  under the video bus.

/*

 *  Arg:

 *	video	: video bus device

 *	device	: video output device under the video

 *		bus

 *

 *  Return:

 *	none

 *

 *  Bind the ids with the corresponding video devices

 *  under the video bus.

	/*

	 * If we have a broken _DOD or we have more than 8 output devices

	 * under the graphics controller node that we can't proper deal with

	 * in the operation region code currently, no need to test.

/*

 *  Arg:

 *	video	: video bus device

 *

 *  Return:

 *	< 0	: error

 *

 *  Call _DOD to enumerate all devices attached to display adapter

 *

 Find closest level to level_current */

 Adjust level_current to closest available level */

 no warning message if acpi_backlight=vendor or a quirk is used */

	/*

	 * There are systems where video module known to work fine regardless

	 * of broken _DOD and ignoring returned value here doesn't cause

	 * any issues later.

 acpi_video interface */

/*

 * Win8 requires setting bit2 of _DOS to let firmware know it shouldn't

 * perform any automatic brightness change on receiving a notification.

	case ACPI_VIDEO_NOTIFY_SWITCH:	/* User requested a switch,

	case ACPI_VIDEO_NOTIFY_PROBE:	/* User plugged in or removed a video

 Cycle Display output hotkey pressed. */

 Next Display output hotkey pressed. */

 previous Display output hotkey pressed. */

 Something vetoed the keypress. */

 Cycle brightness */

 Increase brightness */

 Decrease brightness */

 zero brightness */

 display device off */

	/*

	 * Save current brightness level in case we have to restore it

	 * before acpi_video_device_lcd_set_level() is called next time.

		/*

		 * Set cooling_dev to NULL so we don't crash trying to free it.

		 * Also, why the hell we are returning early and not attempt to

		 * register video output if cooling device registration failed?

		 * -- dtor

	/*

	 * Do not create backlight device for video output

	 * device that is not in the enumerated list.

 a hack to fix the duplicate name "VID" problem on T61 */

 a hack to fix the duplicate name "VGA" problem on Pa 3553 */

 We don't want to poke around undefined i740 registers */

 Check if the chassis-type indicates there is no builtin LCD panel */

 Desktop */

 Low Profile Desktop */

 Pizza Box */

 Mini Tower */

 Tower */

 Lunch Box */

 Main Server Chassis */

/*

 * We're seeing a lot of bogus backlight interfaces on newer machines

 * without a LCD such as desktops, servers and HDMI sticks. Checking the

 * lcd flag fixes this, enable this by default on any machines which are:

 * 1.  Win8 ready (where we also prefer the native backlight driver, so

 *     normally the acpi_video code should not register there anyways); *and*

 * 2.1 Report a desktop/server DMI chassis-type, or

 * 2.2 Are an ACPI-reduced-hardware platform (and thus won't use the EC for

       backlight control)

		/*

		 * if the function of acpi_video_register is already called,

		 * don't register the acpi_video_bus again and return no error.

	/*

	 * When the acpi_video_bus is loaded successfully, increase

	 * the counter reference.

/*

 * This is kind of nasty. Hardware using Intel chipsets may require

 * the video opregion code to be run first in order to initialise

 * state before any ACPI video calls are made. To handle this we defer

 * registration of the video class until the opregion code has run.

	/*

	 * Let the module load even if ACPI is disabled (e.g. due to

	 * a broken BIOS) so that i915.ko can still be loaded on such

	 * old systems without an AcpiOpRegion.

	 *

	 * acpi_video_register() will report -ENODEV later as well due

	 * to acpi_disabled when i915.ko tries to register itself afterwards.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * debugfs.c - ACPI debugfs interface to userspace.

/*

 *  Copyright (C) 2015       Red Hat Inc.

 *                           Hans de Goede <hdegoede@redhat.com>

 *  Copyright (C) 2008       SuSE Linux Products GmbH

 *                           Thomas Renninger <trenn@suse.de>

 *

 *  May be copied or modified under the terms of the GNU General Public License

 *

 * video_detect.c:

 * After PCI devices are glued with ACPI devices

 * acpi_get_pci_dev() can be called to identify ACPI graphics

 * devices for which a real graphics card is plugged in

 *

 * Depending on whether ACPI graphics extensions (cmp. ACPI spec Appendix B)

 * are available, video.ko should be used to handle the device.

 *

 * Otherwise vendor specific drivers like thinkpad_acpi, asus-laptop,

 * sony_acpi,... can take care about backlight brightness.

 *

 * Backlight drivers can use acpi_video_get_backlight_type() to determine

 * which driver should handle the backlight.

 *

 * If CONFIG_ACPI_VIDEO is neither set as "compiled in" (y) nor as a module (m)

 * this file will not be compiled and acpi_video_get_backlight_type() will

 * always return acpi_backlight_vendor.

/* Force to use vendor driver when the ACPI device is known to be

	/* On Samsung X360, the BIOS will set a flag (VDRV) if generic

	 * ACPI backlight device is used. This flag will definitively break

	 * the backlight interface (even the vendor interface) until next

	 * reboot. It's why we should prevent video.ko from being used here

	 * and we can't rely on a later call to acpi_video_unregister().

 X360 */

 Asus UL30VT */

 Asus UL30A */

 GIGABYTE GB-BXBT-2807 */

 Sony VPCEH3U1E */

 Xiaomi Mi Pad 2 */

	/*

	 * These models have a working acpi_video backlight control, and using

	 * native backlight causes a regression where backlight does not work

	 * when userspace is not handling brightness key events. Disable

	 * native_backlight on these to fix this:

	 * https://bugzilla.kernel.org/show_bug.cgi?id=81691

 ThinkPad T420 */

 ThinkPad T520 */

 ThinkPad X201s */

 ThinkPad X201T */

 The native backlight controls do not work on some older machines */

bugs.freedesktop.org/show_bug.cgi?id=81515 */

 HP ENVY 15 Notebook */

 SAMSUNG 870Z5E/880Z5E/680Z5E */

 SAMSUNG 370R4E/370R4V/370R5E/3570RE/370R5V */

bugzilla.redhat.com/show_bug.cgi?id=1186097 */

 SAMSUNG 3570R/370R/470R/450R/510R/4450RV */

bugzilla.redhat.com/show_bug.cgi?id=1557060 */

 SAMSUNG 670Z5E */

bugzilla.redhat.com/show_bug.cgi?id=1094948 */

 SAMSUNG 730U3E/740U3E */

bugs.freedesktop.org/show_bug.cgi?id=87286 */

 SAMSUNG 900X3C/900X3D/900X3E/900X4C/900X4D */

bugzilla.redhat.com/show_bug.cgi?id=1272633 */

 Dell XPS14 L421X */

bugzilla.redhat.com/show_bug.cgi?id=1163574 */

 Dell XPS15 L521X */

bugzilla.kernel.org/show_bug.cgi?id=108971 */

 SAMSUNG 530U4E/540U4E */

bugs.launchpad.net/bugs/1894667 */

 HP 635 Notebook */

 Non win8 machines which need native backlight nevertheless */

bugzilla.redhat.com/show_bug.cgi?id=1201530 */

 Lenovo Ideapad S405 */

bugzilla.redhat.com/show_bug.cgi?id=1187004 */

 Lenovo Ideapad Z570 */

 Lenovo E41-25 */

 Lenovo E41-45 */

bugzilla.redhat.com/show_bug.cgi?id=1217249 */

 Apple MacBook Pro 12,1 */

 Dell Vostro V131 */

bugzilla.redhat.com/show_bug.cgi?id=1123661 */

 Dell XPS 17 L702X */

 Dell Precision 7510 */

 Acer Aspire 5738z */

bugzilla.kernel.org/show_bug.cgi?id=207835 */

 Acer TravelMate 5735Z */

 ASUSTeK COMPUTER INC. GA401 */

 ASUSTeK COMPUTER INC. GA502 */

 ASUSTeK COMPUTER INC. GA503 */

	/*

	 * Desktops which falsely report a backlight and which our heuristics

	 * for this do not catch.

 Dell OptiPlex 9020M */

 MSI MS-7721 */

 This uses a workqueue to avoid various locking ordering issues */

 A raw bl registering may change video -> native */

/*

 * Determine which type of backlight interface to use on this system,

 * First check cmdline, then dmi quirks, then do autodetect.

 *

 * The autodetect order is:

 * 1) Is the acpi-video backlight interface supported ->

 *  no, use a vendor interface

 * 2) Is this a win8 "ready" BIOS and do we have a native interface ->

 *  yes, use a native interface

 * 3) Else use the acpi-video interface

 *

 * Arguably the native on win8 check should be done first, but that would

 * be a behavior change, which may causes issues.

 Parse cmdline, dmi and acpi only once */

/*

 * Set the preferred backlight interface type based on DMI info.

 * This function allows DMI blacklists to be implemented by external

 * platform drivers instead of putting a big blacklist in video_detect.c

 Remove acpi-video backlight interface if it is no longer desired */

 SPDX-License-Identifier: GPL-2.0

/*

 * Virtual I/O topology

 *

 * The Virtual I/O Translation Table (VIOT) describes the topology of

 * para-virtual IOMMUs and the endpoints they manage. The OS uses it to

 * initialize devices in the right order, preventing endpoints from issuing DMA

 * before their IOMMU is ready.

 *

 * When binding a driver to a device, before calling the device driver's probe()

 * method, the driver infrastructure calls dma_configure(). At that point the

 * VIOT driver looks for an IOMMU associated to the device in the VIOT table.

 * If an IOMMU exists and has been initialized, the VIOT driver initializes the

 * device's IOMMU fwspec, allowing the DMA infrastructure to invoke the IOMMU

 * ops when the device driver configures DMA mappings. If an IOMMU exists and

 * hasn't yet been initialized, VIOT returns -EPROBE_DEFER to postpone probing

 * the device until the IOMMU is available.

 Node offset within the table */

 PCI range */

 MMIO */

		/*

		 * PCI devices aren't necessarily described by ACPI. Create a

		 * fwnode so the IOMMU subsystem can identify this device.

		/*

		 * A future version of the table may use the node for other

		 * purposes. Keep parsing.

/**

 * acpi_viot_init - Parse the VIOT table

 *

 * Parse the VIOT table, prepare the list of endpoints to be used during DMA

 * setup of devices.

 We're not translating ourself */

			/*

			 * If we found a PCI range managed by the viommu, we're

			 * the one that has to request ACS.

/**

 * viot_iommu_configure - Setup IOMMU ops for an endpoint described by VIOT

 * @dev: the endpoint

 *

 * Return: 0 on success, <0 on failure

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ACPI configfs support

 *

 * Copyright (c) 2016 Intel Corporation

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  pci_slot.c - ACPI PCI Slot Driver

 *

 *  The code here is heavily leveraged from the acpiphp module.

 *  Thanks to Matthew Wilcox <matthew@wil.cx> for much guidance.

 *  Thanks to Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com> for code

 *  review and fixes.

 *

 *  Copyright (C) 2007-2008 Hewlett-Packard Development Company, L.P.

 *  	Alex Chiang <achiang@hp.com>

 *

 *  Copyright (C) 2013 Huawei Tech. Co., Ltd.

 *	Jiang Liu <jiang.liu@huawei.com>

 Inspired by #define in acpiphp.h */

 corresponding pci_slot */

 node in the list of slots */

 If SxFy doesn't have _STA, we just assume it's there */

 No _SUN == not a slot == bail */

/*

 * Check whether handle has an associated slot and create PCI slot if it has.

	/*

	 * There may be multiple PCI functions associated with the same slot.

	 * Check whether PCI slot has already been created for this PCI device.

	/*

	 * Fujitsu Primequest machines will return 1023 to indicate an

	 * error if the _SUN method is evaluated on SxFy objects that

	 * are not present (as indicated by _STA), so for those machines,

	 * we want to check _STA before evaluating _SUN.

 SPDX-License-Identifier: GPL-2.0

/*

 * Address translation interface via ACPI DSM.

 * Copyright (C) 2018 Intel Corporation

 *

 * Specification for this interface is available at:

 *

 *	https://cdrdv2.intel.com/v1/dl/getContent/603354

/*

 * The specification doesn't provide a limit on how many

 * components are in a memory address. But since we allocate

 * memory based on the number the BIOS tells us, we should

 * defend against insane values.

/**

 * adxl_get_component_names - get list of memory component names

 * Returns NULL terminated list of string names

 *

 * Give the caller a pointer to the list of memory component names

 * e.g. { "SystemAddress", "ProcessorSocketId", "ChannelId", ... NULL }

 * Caller should count how many strings in order to allocate a buffer

 * for the return from adxl_decode().

/**

 * adxl_decode - ask BIOS to decode a system address to memory address

 * @addr: the address to decode

 * @component_values: pointer to array of values for each component

 * Returns 0 on success, negative error code otherwise

 *

 * The index of each value returned in the array matches the index of

 * each component name returned by adxl_get_component_names().

 * Components that are not defined for this address translation (e.g.

 * mirror channel number for a non-mirrored address) are set to ~0ull.

	/*

	 * Allocate one extra for NULL termination.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Link physical devices with ACPI devices support

 *

 * Copyright (c) 2005 David Shaohua Li <shaohua.li@intel.com>

 * Copyright (c) 2005 Intel Corp.

	/*

	 * If the device has a _HID returning a valid ACPI/PNP device ID, it is

	 * better to make it look less attractive here, so that the other device

	 * with the same _ADR value (that may not have a valid device ID) can be

	 * matched going forward.  [This means a second spec violation in a row,

	 * so whatever we do here is best effort anyway.]

 This is the first matching object.  Save it. */

		/*

		 * There is more than one matching device object with the same

		 * _ADR value.  That really is unexpected, so we are kind of

		 * beyond the scope of the spec here.  We have to choose which

		 * one to return, though.

		 *

		 * First, check if the previously found object is good enough

		 * and return it if so.  Second, do the same for the object that

		 * we've just found.

	/*

	 * Keep the list sorted by node_id so that the IDs of removed nodes can

	 * be recycled easily.

 Sanity check. */

 Drop references taken by acpi_bind_one(). */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * custom_method.c - debugfs interface for customizing ACPI control method

 /sys/kernel/debug/acpi/custom_method */

 parse the table header to get the table length */

 make sure the buf is not allocated */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2016 Broadcom

 *	Author: Jayachandran C <jchandra@broadcom.com>

 * Copyright (C) 2016 Semihalf

 * 	Author: Tomasz Nowicki <tn@semihalf.com>

 Structure to hold entries from the MCFG table */

	{ OEM_ID, OEM_TABLE_ID, REV, SEGMENT, BUS_RANGE, ops, cfgres }, */

 SoC pass2.x */

 SoC pass1.x */

 off-chip devices */

 off-chip devices */

 X-Gene SoC with v1 PCIe controller */

 X-Gene SoC with v2.1 PCIe controller */

 X-Gene SoC with v2.2 PCIe controller */

 List to save MCFG entries */

 Use address from _CBA if present, otherwise lookup MCFG */

	/*

	 * We expect the range in bus_res in the coverage of MCFG bus range.

	/*

	 * Allow quirks to override default ECAM ops and CFG resource

	 * range.  This may even fabricate a CFG resource range in case

	 * MCFG does not have it.  Invalid CFG start address means MCFG

	 * firmware bug or we need another quirk in array.

 Save MCFG IDs and revision for quirks matching */

 Interface called by ACPI - parse and save MCFG table */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  acpi_ipmi.c - ACPI IPMI opregion

 *

 *  Copyright (C) 2010, 2013 Intel Corporation

 *    Author: Zhao Yakui <yakui.zhao@intel.com>

 *            Lv Zheng <lv.zheng@intel.com>

 the IPMI timeout is 5s */

 the device list attached to driver_data.ipmi_devices */

 the IPMI request message list */

 IPMI interface number */

	/*

	 * NOTE: IPMI System Interface Selection

	 * There is no system interface specified by the IPMI operation

	 * region access.  We try to select one system interface with ACPI

	 * handle set.  IPMI messages passed from the ACPI codes are sent

	 * to this selected global IPMI system interface.

	/*

	 * General speaking the addr type should be SI_ADDR_TYPE. And

	 * the addr channel should be BMC.

	 * In fact it can also be IPMB type. But we will have to

	 * parse it from the Netfn command buffer. It is so complex

	 * that it is skipped.

 it is used to track whether the IPMI message is finished */

 tx/rx data . And copy it from/to ACPI object buffer */

 IPMI request/response buffer per ACPI 4.0, sec 5.5.2.4.3.2 */

	/*

	 * Always setting dead flag after deleting from the list or

	 * list_for_each_entry() codes must get changed.

	/*

	 * IPMI network function and command are encoded in the address

	 * within the IPMI OpRegion; see ACPI 4.0, sec 5.5.2.4.3.

	/*

	 * value is the parameter passed by the IPMI opregion space handler.

	 * It points to the IPMI request message buffer

 copy the tx message data */

	/*

	 * now the default type is SYSTEM_INTERFACE and channel type is BMC.

	 * If the netfn is APP_REQUEST and the cmd is SEND_MESSAGE,

	 * the addr type should be changed to IPMB. Then we will have to parse

	 * the IPMI request message buffer to get the IPMB address.

	 * If so, please fix me.

 Get the msgid */

	/*

	 * value is also used as output parameter. It represents the response

	 * IPMI message returned by IPMI command.

	/*

	 * If the flag of msg_done is not set, it means that the IPMI command is

	 * not executed correctly.

	/*

	 * If the IPMI response message is obtained correctly, the status code

	 * will be ACPI_IPMI_OK

	/*

	 * NOTE: On-going ipmi_recv_msg

	 * ipmi_msg_handler() may still be invoked by ipmi_si after

	 * flushing.  But it is safe to do a fast flushing on module_exit()

	 * without waiting for all ipmi_recv_msg(s) to complete from

	 * ipmi_msg_handler() as it is ensured by ipmi_si that all

	 * ipmi_recv_msg(s) are freed after invoking ipmi_destroy_user().

 wake up the sleep thread on the Tx msg */

 copy the response data to Rx_data buffer */

 response msg is an error msg */

		/*

		 * if the corresponding ACPI handle is already added

		 * to the device list, don't add it again.

/*

 * This is the IPMI opregion space handler.

 * @function: indicates the read/write. In fact as the IPMI message is driven

 * by command, only write is meaningful.

 * @address: This contains the netfn/command of IPMI request message.

 * @bits   : not used.

 * @value  : it is an in/out parameter. It points to the IPMI message buffer.

 *	     Before the IPMI message is sent, it represents the actual request

 *	     IPMI message. After the IPMI message is finished, it represents

 *	     the response IPMI message returned by IPMI command.

 * @handler_context: IPMI device context.

	/*

	 * IPMI opregion message.

	 * IPMI message is firstly written to the BMC and system software

	 * can get the respsonse. So it is unmeaningful for the read access

	 * of IPMI opregion.

 Do not add a tx_msg that can not be flushed. */

	/*

	 * When one smi_watcher is unregistered, it is only deleted

	 * from the smi_watcher list. But the smi_gone callback function

	 * is not called. So explicitly uninstall the ACPI IPMI oregion

	 * handler and free it.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * acpi_processor.c - ACPI processor enumeration support

 *

 * Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>

 * Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

 * Copyright (C) 2004       Dominik Brodowski <linux@brodo.de>

 * Copyright (C) 2004  Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>

 * Copyright (C) 2013, Intel Corporation

 *                     Rafael J. Wysocki <rafael.j.wysocki@intel.com>

 Errata Handling */

	/*

	 * Note that 'dev' references the PIIX4 ACPI Controller.

 PIIX4 A-step */

 PIIX4 B-step */

		/*

		 * See specification changes #13 ("Manual Throttle Duty Cycle")

		 * and #14 ("Enabling and Disabling Manual Throttle"), plus

		 * erratum #5 ("STPCLK# Deassertion Time") from the January

		 * 2002 PIIX4 specification update.  Applies to only older

		 * PIIX4 models.

 PIIX4E */

 PIIX4M */

		/*

		 * See erratum #18 ("C3 Power State/BMIDE and Type-F DMA

		 * Livelock") from the January 2002 PIIX4 specification update.

		 * Applies to all PIIX4 models.

		/*

		 * BM-IDE

		 * ------

		 * Find the PIIX4 IDE Controller and get the Bus Master IDE

		 * Status register address.  We'll use this later to read

		 * each IDE controller's DMA status to make sure we catch all

		 * DMA activity.

		/*

		 * Type-F DMA

		 * ----------

		 * Find the PIIX4 ISA Controller and read the Motherboard

		 * DMA controller's status to see if Type-F (Fast) DMA mode

		 * is enabled (bit 7) on either channel.  Note that we'll

		 * disable C3 support if this is enabled, as some legacy

		 * devices won't operate well if fast DMA is disabled.

	/*

	 * PIIX4

 Initialization */

	/*

	 * CPU got hot-added, but cpu_data is not initialized yet.  Set a flag

	 * to delay cpu_idle/throttling initialization and do it when the CPU

	 * gets online for the first time.

 CONFIG_ACPI_HOTPLUG_CPU */

	/*

	 * Check to see if we have bus mastering arbitration control.  This

	 * is required for proper C3 usage (to maintain cache coherency).

 Declared with "Processor" statement; match ProcessorID */

		/*

		 * Declared with "Device" statement; match _UID.

		/*

		 * Handle UP system running SMP kernel, with no CPU

		 * entry in MADT

	/*

	 *  Extra Processor objects may be enumerated on MP systems with

	 *  less than the max # of CPUs. They should be ignored _iff

	 *  they are physically not present.

	 *

	 *  NOTE: Even if the processor has a cpuid, it may not be present

	 *  because cpuid <-> apicid mapping is persistent now.

	/*

	 * On some boxes several processors use the same processor bus id.

	 * But they are located in different scope. For example:

	 * \_SB.SCK0.CPU0

	 * \_SB.SCK1.CPU0

	 * Rename the processor device bus id. And the new bus id will be

	 * generated as the following format:

	 * CPU+CPU ID.

	/*

	 * If ACPI describes a slot number for this CPU, we can use it to

	 * ensure we get the right value in the "physical id" field

	 * of /proc/cpuinfo

/*

 * Do not put anything in here which needs the core to be online.

 * For example MSR access or setting up things which check for cpuinfo_x86

 * (cpu_data(cpu)) values, like CPU feature flags, family, model, etc.

 * Such things have to be put in and set up by the processor driver's .probe().

 Processor is not physically present or unavailable */

	/*

	 * Buggy BIOS check.

	 * ACPI id of processors can be reported wrongly by the BIOS.

	 * Don't trust it blindly

 Give up, but do not abort the namespace scan. */

	/*

	 * processor_device_array is not cleared on errors to allow buggy BIOS

	 * checks.

 Trigger the processor driver's .probe() if present. */

 Removal */

	/*

	 * The only reason why we ever get here is CPU hot-removal.  The CPU is

	 * already offline and the ACPI device removal locking prevents it from

	 * being put back online at this point.

	 *

	 * Unbind the driver from the processor device and detach it from the

	 * ACPI companion object.

 Clean up. */

 Remove the CPU. */

 CONFIG_ACPI_HOTPLUG_CPU */

 set bit 12 */

/*

 * The following ACPI IDs are known to be suitable for representing as

 * processor devices.

 The number of the unique processor IDs */

 The number of the duplicate processor IDs */

 Used to store the unique processor IDs */

 Used to store the duplicate processor IDs */

	/*

	 * Firstly, compare the proc_id with duplicate IDs, if the proc_id is

	 * already in the IDs, do nothing.

	/*

	 * Secondly, compare the proc_id with unique IDs, if the proc_id is in

	 * the IDs, put it in the duplicate IDs.

	/*

	 * Lastly, the proc_id is a unique ID, put it in the unique IDs.

 Exit on error, but don't abort the namespace walk */

 check the correctness for all processors in ACPI namespace */

	/*

	 * compare the proc_id with duplicate IDs, if the proc_id is already

	 * in the duplicate IDs, return true, otherwise, return false.

/**

 * acpi_processor_claim_cst_control - Request _CST control from the platform.

/**

 * acpi_processor_evaluate_cst - Evaluate the processor _CST control method.

 * @handle: ACPI handle of the processor object containing the _CST.

 * @cpu: The numeric ID of the target CPU.

 * @info: Object write the C-states information into.

 *

 * Extract the C-state information for the given CPU from the output of the _CST

 * control method under the corresponding ACPI processor object (or processor

 * device object) and populate @info with it.

 *

 * If any ACPI_ADR_SPACE_FIXED_HARDWARE C-states are found, invoke

 * acpi_processor_ffh_cstate_probe() to verify them and update the

 * cpu_cstate_entry data for @cpu.

 There must be at least 2 elements. */

 Validate the number of C-states. */

		/*

		 * If there is not enough space for all C-states, skip the

		 * excess ones and log a warning.

		/*

		 * There are known cases in which the _CST output does not

		 * contain C1, so if the type of the first state found is not

		 * C1, leave an empty slot for C1 to be filled in later.

				/*

				 * In the majority of cases _CST describes C1 as

				 * a FIXED_HARDWARE C-state, but if the command

				 * line forbids using MWAIT, use CSTATE_HALT for

				 * C1 regardless.

				/*

				 * In the special case of C1, FIXED_HARDWARE can

				 * be handled by executing the HLT instruction.

 CONFIG_ACPI_PROCESSOR_CSTATE */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * IOAPIC/IOxAPIC/IOSAPIC driver

 *

 * Copyright (C) 2009 Fujitsu Limited.

 * (c) Copyright 2009 Hewlett-Packard Development Company, L.P.

 *

 * Copyright (C) 2014 Intel Corporation

 *

 * Based on original drivers/pci/ioapic.c

 *	Yinghai Lu <yinghai@kernel.org>

 *	Jiang Liu <jiang.liu@intel.com>

/*

 * This driver manages I/O APICs added by hotplug after boot.

 * We try to claim all I/O APIC devices, but those present at boot were

 * registered when we parsed the ACPI MADT.

	/*

	 * We might assign this to 'res' later, make sure all pointers are

	 * cleared before the resource is added to the global list

 try pci resource first, then "_CRS" resource */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  sbs.c - ACPI Smart Battery System Driver ($Revision: 2.0 $)

 *

 *  Copyright (c) 2007 Alexey Starikovskiy <astarikovskiy@suse.de>

 *  Copyright (c) 2005-2007 Vladimir Lebedev <vladimir.p.lebedev@intel.com>

 *  Copyright (c) 2005 Rich Townsend <rhdt@bartol.udel.edu>

 dK -> dC

/* --------------------------------------------------------------------------

                            Smart Battery System Management

 command for battery */

 word or block? */

 offset inside struct acpi_sbs_battery */

	/*

	 * The spec requires that bit 4 always be 1. If it's not set, assume

	 * that the implementation doesn't support an SBS charger.

	 *

	 * And on some MacBooks a status of 0xffff is always returned, no

	 * matter whether the charger is plugged in or not, which is also

	 * wrong, so ignore the SBS charger for those too.

/* --------------------------------------------------------------------------

                                 Driver Interface

 Smart Battery */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * FPDT support for exporting boot and suspend/resume performance data

 *

 * Copyright (C) 2021 Intel Corporation. All rights reserved.

/*

 * FPDT contains ACPI table header and a number of fpdt_subtable_entries.

 * Each fpdt_subtable_entry points to a subtable: FBPT or S3PT.

 * Each FPDT subtable (FBPT/S3PT) is composed of a fpdt_subtable_header

 * and a number of fpdt performance records.

 * Each FPDT performance record is composed of a fpdt_record_header and

 * performance data fields, for boot or suspend or resume phase.

 refer to enum fpdt_subtable_type */

 physical address of the S3PT/FBPT table */

 refer to enum fpdt_record_type */

 Other types are reserved in ACPI 6.4 spec. */

 Other types are reserved in ACPI 6.4 spec. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  acpi_osl.c - OS-dependent functions ($Revision: 83 $)

 *

 *  Copyright (C) 2000       Andrew Henroid

 *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>

 *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

 *  Copyright (c) 2008 Intel Corporation

 *   Author: Matthew Wilcox <willy@linux.intel.com>

 Definitions for ACPI_DEBUG_PRINT() */

 stuff for debugger support */

ENABLE_DEBUGGER */

/*

 * This list of permanent mappings is for memory that may be accessed from

 * interrupt context, where we can't do the ioremap().

 Handle possible alignment issues */

 Resources are never freed */

 Length of GPE blocks must be a non-negative multiple of 2 */

	/*

	 * We may have been provided with an RSDP on the command line,

	 * but if a malicious user has done so they may be pointing us

	 * at modified ACPI tables that could alter kernel behaviour -

	 * so, we check the lockdown status before making use of

	 * it. If we trust it then also stash it in an architecture

	 * specific location (if appropriate) so it can be carried

	 * over further kexec()s.

 Must be called with 'acpi_ioremap_lock' or RCU read lock held. */

 Must be called with 'acpi_ioremap_lock' or RCU read lock held. */

 Must be called with 'acpi_ioremap_lock' or RCU read lock held. */

 ioremap will take care of cache attributes */

/**

 * acpi_os_map_iomem - Get a virtual address for a given physical address range.

 * @phys: Start of the physical address range to map.

 * @size: Size of the physical address range to map.

 *

 * Look up the given physical address range in the list of existing ACPI memory

 * mappings.  If found, get a reference to it and return a pointer to it (its

 * virtual address).  If not found, map it, add it to that list and return a

 * pointer to it.

 *

 * During early init (when acpi_permanent_mmap has not been set yet) this

 * routine simply calls __acpi_map_table() to get the job done.

 Check if there's a suitable mapping already. */

 Must be called with mutex_lock(&acpi_ioremap_lock) */

/**

 * acpi_os_unmap_iomem - Drop a memory mapping reference.

 * @virt: Start of the address range to drop a reference to.

 * @size: Size of the address range to drop a reference to.

 *

 * Look up the given virtual address range in the list of existing ACPI memory

 * mappings, drop a reference to it and if there are no more active references

 * to it, queue it up for later removal.

 *

 * During early init (when acpi_permanent_mmap has not been set yet) this

 * routine simply calls __acpi_unmap_table() to get the job done.  Since

 * __acpi_unmap_table() is an __init function, the __ref annotation is needed

 * here.

/**

 * acpi_os_unmap_memory - Drop a memory mapping reference.

 * @virt: Start of the address range to drop a reference to.

 * @size: Size of the address range to drop a reference to.

 Handle possible alignment issues */

 Handle possible alignment issues */

	/*

	 * ACPI interrupts different from the SCI in our copy of the FADT are

	 * not supported.

/*

 * Running in interpreter thread context, safe to sleep

/*

 * Support ACPI 3.0 AML Timer operand. Returns a 64-bit free-running,

 * monotonically increasing timer with 100ns granularity. Do not use

 * ktime_get() to implement this function because this function may get

 * called after timekeeping has been suspended. Note: calling this function

 * after timekeeping has been suspended may lead to unexpected results

 * because when timekeeping is suspended the jiffies counter is not

 * incremented. See also timekeeping_suspend().

/*******************************************************************************

 *

 * FUNCTION:    acpi_os_execute

 *

 * PARAMETERS:  Type               - Type of the callback

 *              Function           - Function to be executed

 *              Context            - Function parameters

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Depending on type, either queues function for deferred execution or

 *              immediately executes function on a separate thread.

 *

	/*

	 * Allocate/initialize DPC structure.  Note that this memory will be

	 * freed by the callee.  The kernel handles the work_struct list  in a

	 * way that allows us to also free its memory inside the callee.

	 * Because we may want to schedule several tasks with different

	 * parameters we can't use the approach some kernel code uses of

	 * having a static work_struct.

	/*

	 * To prevent lockdep from complaining unnecessarily, make sure that

	 * there is a different static lockdep key for each workqueue by using

	 * INIT_WORK() for each of them separately.

	/*

	 * On some machines, a software-initiated SMI causes corruption unless

	 * the SMI runs on CPU 0.  An SMI can be initiated by any AML, but

	 * typically it's done in GPE-related methods that are run via

	 * workqueues, so we can avoid the known corruption cases by always

	 * queueing on CPU 0.

	/*

	 * Make sure the GPE handler or the fixed event handler is not used

	 * on another CPU after removal.

	/*

	 * We can't run hotplug code in kacpid_wq/kacpid_notify_wq etc., because

	 * the hotplug code may call driver .remove() functions, which may

	 * invoke flush_scheduled_work()/acpi_os_wait_events_complete() to flush

	 * these workqueues.

/*

 * TODO: A better way to delete semaphores?  Linux doesn't have a

 * 'delete_semaphore()' function -- may result in an invalid

 * pointer dereference for non-synchronized consumers.	Should

 * we at least check for blocked threads and signal/cancel them?

/*

 * TODO: Support for units > 1?

/*

 * TODO: Support for units > 1?

 remove the CR kdb includes */

		/*

		 * AML Breakpoint

		 * ACPI spec. says to treat it as a NOP unless

		 * you are debugging.  So if/when we integrate

		 * AML debugger into the kernel debugger its

		 * hook will go here.  But until then it is

		 * not useful to print anything on breakpoints.

/*

 * Disable the auto-serialization of named objects creation methods.

 *

 * This feature is enabled by default.  It marks the AML control methods

 * that contain the opcodes to create named objects as "Serialized".

/* Check of resource interference between native drivers and ACPI

 * OperationRegions (SystemIO and System Memory only).

 * IO ports and memory declared in ACPI might be used by the ACPI subsystem

 * in arbitrary AML code and can interfere with legacy drivers.

 * acpi_enforce_resources= can be set to:

 *

 *   - strict (default) (2)

 *     -> further driver trying to access the resources will not load

 *   - lax              (1)

 *     -> further driver trying to access the resources will load, but you

 *     get a system message that something might go wrong...

 *

 *   - no               (0)

 *     -> ACPI Operation Region resources will not be registered

 *

/* Check for resource conflicts between ACPI OperationRegions and native

/**

 * acpi_release_memory - Release any mappings done to a memory region

 * @handle: Handle to namespace node

 * @res: Memory resource

 * @level: A level that terminates the search

 *

 * Walks through @handle and unmaps all SystemMemory Operation Regions that

 * overlap with @res and that have already been activated (mapped).

 *

 * This is a helper that allows drivers to place special requirements on memory

 * region that may overlap with operation regions, primarily allowing them to

 * safely map the region as non-cached memory.

 *

 * The unmapped Operation Regions will be automatically remapped next time they

 * are called, so the drivers do not need to do anything else.

	/*

	 * Wait for all of the mappings queued up for removal by

	 * acpi_deactivate_mem_region() to actually go away.

/*

 * Let drivers know whether the resource checks are effective

/*

 * Deallocate the memory for a spinlock.

/*

 * Acquire a spinlock.

 *

 * handle is a pointer to the spinlock_t.

/*

 * Release a spinlock. See above.

/*******************************************************************************

 *

 * FUNCTION:    acpi_os_create_cache

 *

 * PARAMETERS:  name      - Ascii name for the cache

 *              size      - Size of each cached object

 *              depth     - Maximum depth of the cache (in objects) <ignored>

 *              cache     - Where the new cache object is returned

 *

 * RETURN:      status

 *

 * DESCRIPTION: Create a cache object

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_os_purge_cache

 *

 * PARAMETERS:  Cache           - Handle to cache object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Free all objects within the requested cache.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_os_delete_cache

 *

 * PARAMETERS:  Cache           - Handle to cache object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Free all objects within the requested cache and delete the

 *              cache object.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_os_release_object

 *

 * PARAMETERS:  Cache       - Handle to cache object

 *              Object      - The object to be released

 *

 * RETURN:      None

 *

 * DESCRIPTION: Release an object to the specified cache.  If cache is full,

 *              the object is deleted.

 *

		/*

		 * Use acpi_os_map_generic_address to pre-map the reset

		 * register if it's in system memory.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * drivers/acpi/device_sysfs.c - ACPI device sysfs attributes and modalias.

 *

 * Copyright (C) 2015, Intel Corp.

 * Author: Mika Westerberg <mika.westerberg@linux.intel.com>

 * Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

 *

 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 *

 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/**

 * create_pnp_modalias - Create hid/cid(s) string for modalias and uevent

 * @acpi_dev: ACPI device object.

 * @modalias: Buffer to print into.

 * @size: Size of the buffer.

 *

 * Creates hid/cid(s) string needed for modalias and uevent

 * e.g. on a device with hid:IBM0001 and cid:ACPI0001 you get:

 * char *modalias: "acpi:IBM0001:ACPI0001"

 * Return: 0: no _HID and no _CID

 *         -EINVAL: output error

 *         -ENOMEM: output is truncated

 Avoid unnecessarily loading modules for non present devices. */

	/*

	 * Since we skip ACPI_DT_NAMESPACE_HID from the modalias below, 0 should

	 * be returned if ACPI_DT_NAMESPACE_HID is the only ACPI/PNP ID in the

	 * device's list.

/**

 * create_of_modalias - Creates DT compatible string for modalias and uevent

 * @acpi_dev: ACPI device object.

 * @modalias: Buffer to print into.

 * @size: Size of the buffer.

 *

 * Expose DT compatible modalias as of:NnameTCcompatible.  This function should

 * only be called for devices having ACPI_DT_NAMESPACE_HID in their list of

 * ACPI/PNP IDs.

 DT strings are all in lower case */

 Must be ACPI_TYPE_STRING. */

/**

 * acpi_device_uevent_modalias - uevent modalias for ACPI-enumerated devices.

 * @dev: Struct device to get ACPI device node.

 * @env: Environment variables of the kobject uevent.

 *

 * Create the uevent modalias field for ACPI-enumerated devices.

 *

 * Because other buses do not support ACPI HIDs & CIDs, e.g. for a device with

 * hid:IBM0001 and cid:ACPI0001 you get: "acpi:IBM0001:ACPI0001".

/**

 * acpi_device_modalias - modalias sysfs attribute for ACPI-enumerated devices.

 * @dev: Struct device to get ACPI device node.

 * @buf: The buffer to save pnp_modalias and of_modalias.

 * @size: Size of buffer.

 *

 * Create the modalias sysfs attribute for ACPI-enumerated devices.

 *

 * Because other buses do not support ACPI HIDs & CIDs, e.g. for a device with

 * hid:IBM0001 and cid:ACPI0001 you get: "acpi:IBM0001:ACPI0001".

 sysfs file that shows description text from the ACPI _STR method */

	/*

	 * The _STR object contains a Unicode identifier for a device.

	 * We need to convert to utf-8 so it can be displayed.

/**

 * acpi_device_setup_files - Create sysfs attributes of an ACPI device.

 * @dev: ACPI device object.

	/*

	 * Devices gotten from FADT don't have a "path" attribute

	/*

	 * If device has _STR, 'description' file is created

	/*

	 * If device has _EJ0, 'eject' file is created that is used to trigger

	 * hot-removal function from userland.

/**

 * acpi_device_remove_files - Remove sysfs attributes of an ACPI device.

 * @dev: ACPI device object.

	/*

	 * If device has _STR, remove 'description' file

	/*

	 * If device has _EJ0, remove 'eject' file.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ACPI Hardware Error Device (PNP0C33) Driver

 *

 * Copyright (C) 2010, Intel Corp.

 *	Author: Huang Ying <ying.huang@intel.com>

 *

 * ACPI Hardware Error Device is used to report some hardware errors

 * notified via SCI, mainly the corrected errors.

/*

 * SCI to report hardware error is forwarded to the listeners of HED,

 * it is used by HEST Generic Hardware Error Source with notify type

 * SCI.

 Only one hardware error device */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Extended Error Log driver

 *

 * Copyright (C) 2013 Intel Corp.

 * Author: Chen, Gong <gong.chen@intel.com>

 elog entry address mask */

 Header Version */

 Header Length */

 entire L1 Directory length including this header */

 MCA Error Log Directory base address */

 MCA Error Log Directory length */

 bit 0 - OS/VMM Opt-in */

 Valid L1 Directory entries per logical processor */

 L1 table related physical address */

 L1 table related virtual address */

 if no valid data in elog entry, just return */

 Not more than 2 messages every 5 seconds */

 clear record status to enable BIOS to update it again */

 log event via trace */

 Spec says L1 directory must be 4K aligned, bail out if it isn't */

 get L1 header to fetch necessary information */

 remap L1 header again based on completed information */

 remap elog table */

 allocate buffer to save elog record */

 enable OS to be involved to take over management from BIOS */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  acpi_thermal.c - ACPI Thermal Zone Driver ($Revision: 41 $)

 *

 *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>

 *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

 *

 *  This driver fully implements the ACPI thermal policy as described in the

 *  ACPI 2.0 Specification.

 *

 *  TBD: 1. Implement passive cooling hysteresis.

 *       2. Enhance passive cooling (CPU) states/limit interface to support

 *          concepts of 'multiple limiters', upper/lower limits, etc.

 _SCP */

 _TZD */

 in millidegrees */

/* --------------------------------------------------------------------------

                             Thermal Zone Management

/*

 * This exception is thrown out in two cases:

 * 1.An invalid trip point becomes invalid or a valid trip point becomes invalid

 *   when re-evaluating the AML code.

 * 2.TODO: Devices listed in _PSL, _ALx, _TZD may change.

 *   We need to re-bind the cooling devices of a thermal zone when this occurs.

 Critical Shutdown */

		/*

		 * Treat freezing temperatures as invalid as well; some

		 * BIOSes return really low values and cause reboots at startup.

		 * Below zero (Celsius) values clearly aren't right for sure..

		 * ... so lets discard those as invalid.

				/*

				 * Allow override critical threshold

 Critical Sleep (optional) */

 Passive (optional) */

 Active (optional) */

 disable all active trip points */

					/*

					 * Don't allow override higher than

					 * the next higher trip point

 sys I/F for generic thermal sysfs support */

 Fall back on default trend */

	/*

	 * tz->temperature has already been updated by generic thermal layer,

	 * before this callback being invoked

/* --------------------------------------------------------------------------

                                 Driver Interface

/*

 * On some platforms, the AML code has dependency about

 * the evaluating order of _TMP and _CRT/_HOT/_PSV/_ACx.

 * 1. On HP Pavilion G4-1016tx, _TMP must be invoked after

 *    /_CRT/_HOT/_PSV/_ACx, or else system will be power off.

 * 2. On HP Compaq 6715b/6715s, the return value of _PSV is 0

 *    if _TMP has never been evaluated.

 *

 * As this dependency is totally transparent to OS, evaluate

 * all of them once, in the order of _CRT/_HOT/_PSV/_ACx,

 * _TMP, before they are actually used.

 Get trip points [_CRT, _PSV, etc.] (required) */

 Get temperature [_TMP] (required) */

 Set the cooling mode [_SCP] to active cooling (default) */

 Get default polling frequency [_TZP] (optional) */

/*

 * The exact offset between Kelvin and degree Celsius is 273.15. However ACPI

 * handles temperature values with a single decimal place. As a consequence,

 * some implementations use an offset of 273.1 and others use an offset of

 * 273.2. Try to find out which one is being used, to present the most

 * accurate and visually appealing number.

 *

 * The heuristic below should work for all ACPI thermal zones which have a

 * critical trip point with a value being a multiple of 0.5 degree Celsius.

	/*

	 * In general, it is not sufficient to check the pending bit, because

	 * subsequent instances of this function may be queued after one of them

	 * has started running (e.g. if _TMP sleeps).  Avoid bailing out if just

	 * one of them is running, though, because it may have done the actual

	 * check some time ago, so allow at least one of them to block on the

	 * mutex while another one is running the update.

 Make sure the previously queued thermal check work has been done */

 300 dS = 30 Seconds */

	/*

	 * Award BIOS on this AOpen makes thermal control almost worthless.

	 * http://bugzilla.kernel.org/show_bug.cgi?id=8842

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Author: Erik Kaneda <erik.kaneda@intel.com>

 * Copyright 2020 Intel Corporation

 *

 * prmt.c

 *

 * Each PRM service is an executable that is run in a restricted environment

 * that is invoked by writing to the PlatformRtMechanism OperationRegion from

 * AML bytecode.

 *

 * init_prmt initializes the Platform Runtime Mechanism (PRM) services by

 * processing data in the PRMT as well as registering an ACPI OperationRegion

 * handler for the PlatformRtMechanism subtype.

 *

		/*

		 * Each module is associated with a list of addr

		 * ranges that it can use during the service

 In-coming PRM commands */

 statuses that can be passed back to ASL */

/*

 * This is the PlatformRtMechanism opregion space handler.

 * @function: indicates the read/write. In fact as the PlatformRtMechanism

 * message is driven by command, only write is meaningful.

 *

 * @addr   : not used

 * @bits   : not used.

 * @value  : it is an in/out parameter. It points to the PRM message buffer.

 * @handler_context: not used

	/*

	 * The returned acpi_status will always be AE_OK. Error values will be

	 * saved in the first byte of the PRM message buffer to be used by ASL.

	/*

	 * Return immediately if PRMT table is not present or no PRM module found.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  pci_irq.c - ACPI PCI Interrupt Routing ($Revision: 11 $)

 *

 *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>

 *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

 *  Copyright (C) 2002       Dominik Brodowski <devel@brodo.de>

 *  (c) Copyright 2008 Hewlett-Packard Development Company, L.P.

 *	Bjorn Helgaas <bjorn.helgaas@hp.com>

 GSI, or link _CRS index */

/* --------------------------------------------------------------------------

                         PCI IRQ Routing Table (PRT) Support

bugzilla.kernel.org/show_bug.cgi?id=4773 */

bugzilla.kernel.org/show_bug.cgi?id=5044 */

bugzilla.kernel.org/show_bug.cgi?id=10138 */

 according to BIOS */

/*

 * These systems have incorrect _PRT entries.  The BIOS claims the PCI

 * interrupt at the listed segment/bus/device/pin is connected to the first

 * link device, but it is actually connected to the second.

 All current quirks involve link devices, not GSIs */

	/*

	 * Note that the _PRT uses 0=INTA, 1=INTB, etc, while PCI uses

	 * 1=INTA, 2=INTB.  We use the PCI encoding throughout, so convert

	 * it here.

	/*

	 * Type 1: Dynamic

	 * ---------------

	 * The 'source' field specifies the PCI interrupt link device used to

	 * configure the IRQ assigned to this slot|dev|pin.  The 'source_index'

	 * indicates which resource descriptor in the resource template (of

	 * the link device) this interrupt is allocated from.

	 *

	 * NOTE: Don't query the Link Device for IRQ information at this time

	 *       because Link Device enumeration may not have occurred yet

	 *       (e.g. exists somewhere 'below' this _PRT entry in the ACPI

	 *       namespace).

	/*

	 * Type 2: Static

	 * --------------

	 * The 'source' field is NULL, and the 'source_index' field specifies

	 * the IRQ value, which is hardwired to specific interrupt inputs on

	 * the interrupt controller.

 'handle' is the _PRT's parent (root bridge or PCI-PCI bridge) */

/* --------------------------------------------------------------------------

                          PCI Interrupt Routing Support

/*

 * Some chipsets (e.g. Intel 6700PXH) generate a legacy INTx when the IRQ

 * entry in the chipset's IO-APIC is masked (as, e.g. the RT kernel does

 * during interrupt handling). When this INTx generation cannot be disabled,

 * we reroute these interrupts to their legacy equivalent to get rid of

 * spurious interrupts.

 no rerouting necessary */

			/*

			 * Remap according to INTx routing table in 6700PXH

			 * specs, intel order number 302628-002, section

			 * 2.15.2. Other chipsets (80332, ...) have the same

			 * mapping and are handled here as well.

 CONFIG_X86_IO_APIC */

 CONFIG_X86_IO_APIC */

	/*

	 * Attempt to derive an IRQ for this device from a parent bridge's

	 * PCI interrupt routing entry (eg. yenta bridge and add-in card bridge).

 PC card has the same IRQ as its cardbridge */

 Interrupt Line values above 0xF are forbidden */

	/*

	 * On x86 irq line 0xff means "unknown" or "no connection"

	 * (PCI 3.0, Section 6.2.4, footnote on page 223).

	/*

	 * On ARM systems with the GIC interrupt model, level interrupts

	 * are always polarity high by specification; PCI legacy

	 * IRQs lines are inverted before reaching the interrupt

	 * controller and must therefore be considered active high

	 * as default.

		/*

		 * IDE legacy mode controller IRQs are magic. Why do compat

		 * extensions always make such a nasty mess.

		/*

		 * No IRQ known to the ACPI subsystem - maybe the BIOS /

		 * driver reported one, then use it. Exit in any case.

 Keep IOAPIC pin configuration when suspending */

	/*

	 * TBD: It might be worth clearing dev->irq by magic constant

	 * (e.g. PCI_UNDEFINED_IRQ).

 SPDX-License-Identifier: GPL-2.0

/*

 * sysfs.c - ACPI sysfs interface to userspace.

/*

 * ACPI debug sysfs I/F, including:

 * /sys/modules/acpi/parameters/debug_layer

 * /sys/modules/acpi/parameters/debug_level

 * /sys/modules/acpi/parameters/trace_method_name

 * /sys/modules/acpi/parameters/trace_state

 * /sys/modules/acpi/parameters/trace_debug_layer

 * /sys/modules/acpi/parameters/trace_debug_level

	/*

	 * It's not safe to update acpi_gbl_trace_method_name without

	 * having the tracer stopped, so we save the original tracer

	 * state and disable it.

 This is a hack.  We can't kmalloc in early boot. */

 Restore the original tracer state */

 So "xxx-once" comparison should go prior than "xxx" comparison */

 CONFIG_ACPI_DEBUG */

 /sys/modules/acpi/parameters/aml_debug_output */

 /sys/module/acpi/parameters/acpica_version */

/*

 * ACPI table sysfs I/F:

 * /sys/firmware/acpi/tables/

 * /sys/firmware/acpi/tables/data/

 * /sys/firmware/acpi/tables/dynamic/

 including trailing 0 */

		/*

		 * we do not need to do anything right now

		 * because the table is not deleted from the

		 * global table list when unloading it.

/*

 * Detailed ACPI IRQ counters:

 * /sys/firmware/acpi/interrupts/

 acpi_irq_handled */

 acpi_irq_not_handled */

 other */

 "gpe_all" or "sci" */

/*

 * counter_set() sets the specified counter.

 * setting the total "sci" file to any value clears all counters.

 * enable/disable/clear a gpe/fixed event in user space.

 show the event status for both GPEs and Fixed Events */

/*

 * A Quirk Mechanism for GPE Flooding Prevention:

 *

 * Quirks may be needed to prevent GPE flooding on a specific GPE. The

 * flooding typically cannot be detected and automatically prevented by

 * ACPI_GPE_DISPATCH_NONE check because there is a _Lxx/_Exx prepared in

 * the AML tables. This normally indicates a feature gap in Linux, thus

 * instead of providing endless quirk tables, we provide a boot parameter

 * for those who want this quirk. For example, if the users want to prevent

 * the GPE flooding for GPE 00, they need to specify the following boot

 * parameter:

 *   acpi_mask_gpe=0x00

 * Note, the parameter can be a list (see bitmap_parselist() for the details).

 * The masking status can be modified by the following runtime controlling

 * interface:

 *   echo unmask > /sys/firmware/acpi/interrupts/gpe00

 SPDX-License-Identifier: GPL-2.0

/*

 * pptt.c - parsing of Processor Properties Topology Table (PPTT)

 *

 * Copyright (C) 2018, ARM

 *

 * This file implements parsing of the Processor Properties Topology Table

 * which is optionally used to describe the processor and cache topology.

 * Due to the relative pointers used throughout the table, this doesn't

 * leverage the existing subtable parsing in the kernel.

 *

 * The PPTT structure is an inverted tree, with each node potentially

 * holding one or two inverted tree data structures describing

 * the caches available at that level. Each cache structure optionally

 * contains properties describing the cache at a given level which can be

 * used to override hardware probed values.

 there isn't a subtable at reference 0 */

/**

 * acpi_pptt_walk_cache() - Attempt to find the requested acpi_pptt_cache

 * @table_hdr: Pointer to the head of the PPTT table

 * @local_level: passed res reflects this cache level

 * @res: cache resource in the PPTT we want to walk

 * @found: returns a pointer to the requested level if found

 * @level: the requested cache level

 * @type: the requested cache type

 *

 * Attempt to find a given cache level, while counting the max number

 * of cache levels for the cache node.

 *

 * Given a pptt resource, verify that it is a cache node, then walk

 * down each level of caches, counting how many levels are found

 * as well as checking the cache type (icache, dcache, unified). If a

 * level & type match, then we set found, and continue the search.

 * Once the entire cache branch has been walked return its max

 * depth.

 *

 * Return: The cache structure and the level we terminated with.

			/*

			 * continue looking at this node's resource list

			 * to verify that we don't find a duplicate

			 * cache node.

 walk down from processor node */

		/*

		 * we are looking for the max depth. Since its potentially

		 * possible for a given node to have resources with differing

		 * depths verify that the depth we have found is the largest.

/**

 * acpi_count_levels() - Given a PPTT table, and a CPU node, count the caches

 * @table_hdr: Pointer to the head of the PPTT table

 * @cpu_node: processor node we wish to count caches for

 *

 * Given a processor node containing a processing unit, walk into it and count

 * how many levels exist solely for it, and then walk up each level until we hit

 * the root node (ignore the package level because it may be possible to have

 * caches that exist across packages). Count the number of cache levels that

 * exist at each level on the way up.

 *

 * Return: Total number of levels found.

/**

 * acpi_pptt_leaf_node() - Given a processor node, determine if its a leaf

 * @table_hdr: Pointer to the head of the PPTT table

 * @node: passed node is checked to see if its a leaf

 *

 * Determine if the *node parameter is a leaf node by iterating the

 * PPTT table, looking for nodes which reference it.

 *

 * Return: 0 if we find a node referencing the passed node (or table error),

 * or 1 if we don't.

/**

 * acpi_find_processor_node() - Given a PPTT table find the requested processor

 * @table_hdr:  Pointer to the head of the PPTT table

 * @acpi_cpu_id: CPU we are searching for

 *

 * Find the subtable entry describing the provided processor.

 * This is done by iterating the PPTT table looking for processor nodes

 * which have an acpi_processor_id that matches the acpi_cpu_id parameter

 * passed into the function. If we find a node that matches this criteria

 * we verify that its a leaf node in the topology rather than depending

 * on the valid flag, which doesn't need to be set for leaf nodes.

 *

 * Return: NULL, or the processors acpi_pptt_processor*

 find the processor structure associated with this cpuid */

		/*

		 * It is important that ACPI_PPTT_CACHE_TYPE_UNIFIED

		 * contains the bit pattern that will match both

		 * ACPI unified bit patterns because we use it later

		 * to match both cases.

/**

 * update_cache_properties() - Update cacheinfo for the given processor

 * @this_leaf: Kernel cache info structure being updated

 * @found_cache: The PPTT node describing this cache instance

 * @cpu_node: A unique reference to describe this cache instance

 * @revision: The revision of the PPTT table

 *

 * The ACPI spec implies that the fields in the cache structures are used to

 * extend and correct the information probed from the hardware. Lets only

 * set fields that we determine are VALID.

 *

 * Return: nothing. Side effect of updating the global cacheinfo

	/*

	 * If cache type is NOCACHE, then the cache hasn't been specified

	 * via other mechanisms.  Update the type if a cache type has been

	 * provided.

	 *

	 * Note, we assume such caches are unified based on conventional system

	 * design and known examples.  Significant work is required elsewhere to

	 * fully support data/instruction only type caches which are only

	 * specified in PPTT.

 heterogeneous machines must use PPTT revision > 1 */

 Locate the last node in the tree with IDENTICAL set */

 Passing level values greater than this will result in search termination */

 special case the identical flag to find last identical */

/**

 * topology_get_acpi_cpu_tag() - Find a unique topology value for a feature

 * @table: Pointer to the head of the PPTT table

 * @cpu: Kernel logical CPU number

 * @level: A level that terminates the search

 * @flag: A flag which terminates the search

 *

 * Get a unique value given a CPU, and a topology level, that can be

 * matched to determine which cpus share common topological features

 * at that level.

 *

 * Return: Unique value, or -ENOENT if unable to locate CPU

		/*

		 * As per specification if the processor structure represents

		 * an actual processor, then ACPI processor ID must be valid.

		 * For processor containers ACPI_PPTT_ACPI_PROCESSOR_ID_VALID

		 * should be set if the UID is valid

/**

 * check_acpi_cpu_flag() - Determine if CPU node has a flag set

 * @cpu: Kernel logical CPU number

 * @rev: The minimum PPTT revision defining the flag

 * @flag: The flag itself

 *

 * Check the node representing a CPU for a given flag.

 *

 * Return: -ENOENT if the PPTT doesn't exist, the CPU cannot be found or

 *	   the table revision isn't new enough.

 *	   1, any passed flag set

 *	   0, flag unset

/**

 * acpi_find_last_cache_level() - Determines the number of cache levels for a PE

 * @cpu: Kernel logical CPU number

 *

 * Given a logical CPU number, returns the number of levels of cache represented

 * in the PPTT. Errors caused by lack of a PPTT table, or otherwise, return 0

 * indicating we didn't find any cache levels.

 *

 * Return: Cache levels visible to this core.

/**

 * cache_setup_acpi() - Override CPU cache topology with data from the PPTT

 * @cpu: Kernel logical CPU number

 *

 * Updates the global cache info provided by cpu_get_cacheinfo()

 * when there are valid properties in the acpi_pptt_cache nodes. A

 * successful parse may not result in any updates if none of the

 * cache levels have any valid flags set.  Further, a unique value is

 * associated with each known CPU cache entry. This unique value

 * can be used to determine whether caches are shared between CPUs.

 *

 * Return: -ENOENT on failure to find table, or 0 on success

/**

 * acpi_pptt_cpu_is_thread() - Determine if CPU is a thread

 * @cpu: Kernel logical CPU number

 *

 * Return: 1, a thread

 *         0, not a thread

 *         -ENOENT ,if the PPTT doesn't exist, the CPU cannot be found or

 *         the table revision isn't new enough.

/**

 * find_acpi_cpu_topology() - Determine a unique topology value for a given CPU

 * @cpu: Kernel logical CPU number

 * @level: The topological level for which we would like a unique ID

 *

 * Determine a topology unique ID for each thread/core/cluster/mc_grouping

 * /socket/etc. This ID can then be used to group peers, which will have

 * matching ids.

 *

 * The search terminates when either the requested level is found or

 * we reach a root node. Levels beyond the termination point will return the

 * same unique ID. The unique id for level 0 is the acpi processor id. All

 * other levels beyond this use a generated value to uniquely identify

 * a topological feature.

 *

 * Return: -ENOENT if the PPTT doesn't exist, or the CPU cannot be found.

 * Otherwise returns a value which represents a unique topological feature.

/**

 * find_acpi_cpu_cache_topology() - Determine a unique cache topology value

 * @cpu: Kernel logical CPU number

 * @level: The cache level for which we would like a unique ID

 *

 * Determine a unique ID for each unified cache in the system

 *

 * Return: -ENOENT if the PPTT doesn't exist, or the CPU cannot be found.

 * Otherwise returns a value which represents a unique topological feature.

/**

 * find_acpi_cpu_topology_package() - Determine a unique CPU package value

 * @cpu: Kernel logical CPU number

 *

 * Determine a topology unique package ID for the given CPU.

 * This ID can then be used to group peers, which will have matching ids.

 *

 * The search terminates when either a level is found with the PHYSICAL_PACKAGE

 * flag set or we reach a root node.

 *

 * Return: -ENOENT if the PPTT doesn't exist, or the CPU cannot be found.

 * Otherwise returns a value which represents the package for this CPU.

/**

 * find_acpi_cpu_topology_cluster() - Determine a unique CPU cluster value

 * @cpu: Kernel logical CPU number

 *

 * Determine a topology unique cluster ID for the given CPU/thread.

 * This ID can then be used to group peers, which will have matching ids.

 *

 * The cluster, if present is the level of topology above CPUs. In a

 * multi-thread CPU, it will be the level above the CPU, not the thread.

 * It may not exist in single CPU systems. In simple multi-CPU systems,

 * it may be equal to the package topology level.

 *

 * Return: -ENOENT if the PPTT doesn't exist, the CPU cannot be found

 * or there is no toplogy level above the CPU..

 * Otherwise returns a value which represents the package for this CPU.

/**

 * find_acpi_cpu_topology_hetero_id() - Get a core architecture tag

 * @cpu: Kernel logical CPU number

 *

 * Determine a unique heterogeneous tag for the given CPU. CPUs with the same

 * implementation should have matching tags.

 *

 * The returned tag can be used to group peers with identical implementation.

 *

 * The search terminates when a level is found with the identical implementation

 * flag set or we reach a root node.

 *

 * Due to limitations in the PPTT data structure, there may be rare situations

 * where two cores in a heterogeneous machine may be identical, but won't have

 * the same tag.

 *

 * Return: -ENOENT if the PPTT doesn't exist, or the CPU cannot be found.

 * Otherwise returns a value which represents a group of identical cores

 * similar to this CPU.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * processor_driver.c - ACPI Processor Driver

 *

 *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>

 *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

 *  Copyright (C) 2004       Dominik Brodowski <linux@brodo.de>

 *  Copyright (C) 2004  Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>

 *  			- Added processor hotplug support

 *  Copyright (C) 2013, Intel Corporation

 *                      Rafael J. Wysocki <rafael.j.wysocki@intel.com>

	/*

	 * CPU got physically hotplugged and onlined for the first time:

	 * Initialize missing things.

 Normal CPU soft online event. */

 CONFIG_ACPI_CPU_FREQ_PSS */

 Protect against concurrent CPU hotplug operations */

/*

 * We keep the driver loaded even when ACPI is not running.

 * This is needed for the powernow-k8 driver, that works even without

 * ACPI, but needs symbols from this driver

 SPDX-License-Identifier: GPL-2.0-or-later

 Platform profile sysfs interface */

 Check that profile is valid index */

 Scan for a matching profile */

 Check that platform supports this profile choice */

 We can only have one active profile */

 Sanity check the profile handler field are set */

 SPDX-License-Identifier: GPL-2.0

/*

 * this file provides support for:

 * /proc/acpi/wakeup

 'wakeup device' [R/W] */

 SPDX-License-Identifier: GPL-2.0

/*

 * event.c - exporting ACPI events via procfs

 *

 *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>

 *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

 *

 ACPI notifier chain */

 attributes of acpi_genl_family */

 ACPI event info needed by user space */

 commands supported by the acpi_genl_family */

 kernel->user notifications for ACPI events */

 allocate memory */

 add the genetlink message header */

 fill the data */

 send multicast genetlink message */

 create genetlink for acpi event */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ACPI support for CMOS RTC Address Space access

 *

 * Copyright (C) 2013, Intel Corporation

 * Authors: Lan Tianyu <tianyu.lan@intel.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ACPI support for platform bus type.

 *

 * Copyright (C) 2015, Linaro Ltd

 * Author: Graeme Gregory <graeme.gregory@linaro.org>

 PL061 GPIO Device */

 ARM CoreSight ETM4x */

 ARM CoreSight ETR */

 ARM CoreSight STM */

 ARM CoreSight Debug */

 ARM CoreSight TPIU */

 ARM CoreSight SoC-400 TMC, SoC-600 ETF/ETB */

 ARM CoreSight Dynamic Replicator */

 ARM CoreSight CATU */

 ARM CoreSight Dynamic Funnel */

 If clock already registered */

 If the ACPI node already has a physical device attached, skip it. */

	/*

	 * If the ACPI node has a parent and that parent has a physical device

	 * attached to it, that physical device should be the parent of

	 * the amba device we are about to create.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ec_sys.c

 *

 * Copyright (C) 2010 SUSE Products GmbH/Novell

 * Author:

 *      Thomas Renninger <trenn@suse.de>

	/* Use this if support reading/writing multiple ECs exists in ec.c:

	 * struct acpi_ec *ec = ((struct seq_file *)f->private_data)->private;

 partial read */

	/* Use this if support reading/writing multiple ECs exists in ec.c:

	 * struct acpi_ec *ec = ((struct seq_file *)f->private_data)->private;

 partial write */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  pci_root.c - ACPI PCI Root Bridge Driver ($Revision: 40 $)

 *

 *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>

 *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

 for acpi_hest_init() */

/**

 * acpi_is_root_bridge - determine whether an ACPI CA node is a PCI root bridge

 * @handle:  the ACPI CA node in question.

 *

 * Note: we could make this API take a struct acpi_device * instead, but

 * for now, it's more convenient to operate on an acpi_handle.

/**

 * acpi_get_pci_dev - convert ACPI CA handle to struct pci_dev

 * @handle: the handle in question

 *

 * Given an ACPI CA handle, the desired PCI device is located in the

 * list of PCI devices.

 *

 * If the device is found, its reference count is increased and this

 * function returns a pointer to its data structure.  The caller must

 * decrement the reference count by calling pci_dev_put().

 * If no device is found, %NULL is returned.

	/*

	 * Walk up the ACPI CA namespace until we reach a PCI root bridge.

	/*

	 * Now, walk back down the PCI device tree until we return to our

	 * original handle. Assumes that everything between the PCI root

	 * bridge and the device we're looking for must be a P2P bridge.

		/*

		 * This function may be called for a non-PCI device that has a

		 * PCI parent (eg. a disk under a PCI SATA controller).  In that

		 * case pdev->subordinate will be NULL for the parent.

/**

 * acpi_pci_osc_control_set - Request control of PCI root _OSC features.

 * @handle: ACPI handle of a PCI root bridge (or PCIe Root Complex).

 * @mask: Mask of _OSC bits to request control of, place to store control mask.

 * @req: Mask of _OSC bits the control of is essential to the caller.

 *

 * Run _OSC query for @mask and if that is successful, compare the returned

 * mask of control bits with @req.  If all of the @req bits are set in the

 * returned mask, run _OSC request for it.

 *

 * The variable at the @mask address may be modified regardless of whether or

 * not the function returns success.  On success it will contain the mask of

 * _OSC bits the BIOS has granted control of, but its contents are meaningless

 * on failure.

 Need to check the available controls bits before requesting them. */

 No need to request _OSC if the control was already granted. */

	/*

	 * All supported architectures that use ACPI have support for

	 * PCI domains, so we indicate this in _OSC support capabilities.

	/*

	 * Per the Downstream Port Containment Related Enhancements ECN to

	 * the PCI Firmware Spec, r3.2, sec 4.5.1, table 4-5,

	 * OSC_PCI_EXPRESS_DPC_CONTROL indicates the OS supports both DPC

	 * and EDR.

	/*

	 * Apple always return failure on _OSC calls when _OSI("Darwin") has

	 * been called successfully. We know the feature set supported by the

	 * platform, so avoid calling _OSC at all

			/*

			 * We have ASPM control, but the FADT indicates that

			 * it's unsupported. Leave existing configuration

			 * intact and prevent the OS from touching it.

		/*

		 * We want to disable ASPM here, but aspm_disabled

		 * needs to remain in its state from boot so that we

		 * properly handle PCIe 1.1 devices.  So we set this

		 * flag here, to defer the action until after the ACPI

		 * root scan.

 _OSC is optional for PCI host bridges */

 Check _CRS first, then _BBN.  If no _BBN, default to zero. */

		/*

		 * We need both the start and end of the downstream bus range

		 * to interpret _CBA (MMCONFIG base address), so it really is

		 * supposed to be in _CRS.  If we don't find it there, all we

		 * can do is assume [_BBN-0xFF] or [0-0xFF].

	/*

	 * TBD: Need PCI interface for enumeration/configuration of roots.

	/*

	 * Scan the Root Bridge

	 * --------------------

	 * Must do this prior to any attempt to bind the root device, as the

	 * PCI namespace does not get created until this call is made (and

	 * thus the root bridge's pci_dev does not exist).

		/*

		 * This is only called for the hotadd case. For the boot-time

		 * case, we need to wait until after PCI initialization in

		 * order to deal with IOAPICs mapped in on a PCI BAR.

		 *

		 * This is currently x86-specific, because acpi_ioapic_add()

		 * is an empty function without CONFIG_ACPI_HOTPLUG_IOAPIC.

		 * And CONFIG_ACPI_HOTPLUG_IOAPIC depends on CONFIG_X86_IO_APIC

		 * (see drivers/acpi/Kconfig).

/*

 * Following code to support acpi_pci_root_create() is copied from

 * arch/x86/pci/acpi.c and modified so it could be reused by x86, IA64

 * and ARM64.

 Exclude non-addressable range or non-addressable portion */

			/*

			 * I don't like throwing away windows because then

			 * our resources no longer match the ACPI _CRS, but

			 * the kernel resource tree doesn't allow overlaps.

		/*

		 * Some legacy x86 host bridge drivers use iomem_resource and

		 * ioport_resource as default resource pool, skip it.

	/*

	 * Evaluate the "PCI Boot Configuration" _DSM Function.  If it

	 * exists and returns 0, we must preserve any PCI resource

	 * assignments made by firmware for this host bridge.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * BGRT boot graphic support

 * Authors: Matthew Garrett, Josh Triplett <josh@joshtriplett.org>

 * Copyright 2012 Red Hat, Inc <mjg@redhat.com>

 * Copyright 2012 Intel Corporation

 size gets filled in later */

 SPDX-License-Identifier: GPL-2.0

 The reset register can only live on bus 0. */

 Form PCI device/function pair. */

 Write the value that resets us. */

 ACPI reset register was only introduced with v2 of the FADT */

	/* Is the reset register supported? The spec says we should be

	 * checking the bit width and bit offset, but Windows ignores

	/* The reset register can only exist in I/O, Memory or PCI config space

	/*

	 * Some platforms do not shut down immediately after writing to the

	 * ACPI reset register, and this results in racing with the

	 * subsequent reboot mechanism.

	 *

	 * The 15ms delay has been found to be long enough for the system

	 * to reboot on the affected platforms.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ACPI AML interfacing support

 *

 * Copyright (C) 2015, Intel Corporation

 * Authors: Lv Zheng <lv.zheng@intel.com>

 #define DEBUG */

 user space is writing cmd */

 kernel space is reading cmd */

 user space is reading log */

 kernel space is writing log */

	/*

	 * The debugger interface is in opened state (OPENED && !CLOSED),

	 * then it is allowed to access the debugger buffers from either

	 * user space or the kernel space.

	 * In addition, for the kernel space, only the debugger thread

	 * (thread ID matched) is allowed to access.

	/*

	 * Another read is not in progress and there is data in buffer

	 * available for read.

	/*

	 * Another write is not in progress and there is buffer space

	 * available for write.

	/*

	 * The usage count is prepared to avoid race conditions between the

	 * starts and the stops of the debugger thread.

 sync tail before inserting logs */

 sync head after inserting logs */

 sync head before removing cmds */

 sync tail before inserting cmds */

/*

 * acpi_aml_write_log() - Capture debugger output

 * @msg: the debugger output

 *

 * This function should be used to implement acpi_os_printf() to filter out

 * the debugger output and store the output into the debugger interface

 * buffer. Return the size of stored logs or errno.

			/*

			 * We need to retry when the condition

			 * becomes true.

/*

 * acpi_aml_read_cmd() - Capture debugger input

 * @msg: the debugger input

 * @size: the size of the debugger input

 *

 * This function should be used to implement acpi_os_get_line() to capture

 * the debugger input commands and store the input commands into the

 * debugger interface buffer. Return the size of stored commands or errno.

	/*

	 * This is ensured by the running fact of the debugger thread

	 * unless a bug is introduced.

		/*

		 * Check each input byte to find the end of the command.

			/*

			 * We need to retry when the condition becomes

			 * true.

			/*

			 * acpi_os_get_line() requires a zero terminated command

			 * string.

/*

 * acpi_aml_create_thread() - Create AML debugger thread

 * @function: the debugger thread callback

 * @context: the context to be passed to the debugger thread

 *

 * This function should be used to implement acpi_os_execute() which is

 * used by the ACPICA debugger to create the debugger thread.

	/*

	 * The debugger interface is being closed, no new user is allowed

	 * during this period.

		/*

		 * Only one reader is allowed to initiate the debugger

		 * thread.

		/*

		 * No writer is allowed unless the debugger thread is

		 * ready.

		/*

		 * Wake up all user space/kernel space blocked

		 * readers/writers.

		/*

		 * Wait all user space/kernel space readers/writers to

		 * stop so that ACPICA command loop of the debugger thread

		 * should fail all its command line reads after this point.

		/*

		 * Then we try to terminate the debugger thread if it is

		 * not terminated.

 sync head before removing logs */

 sync tail after removing logs */

				/*

				 * We need to retry when the condition

				 * becomes true.

 sync tail before inserting cmds */

 sync head after inserting cmds */

				/*

				 * We need to retry when the condition

				 * becomes true.

 Initialize AML IO interface */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2004, 2013 Intel Corporation

 * Author: Naveen B S <naveen.b.s@intel.com>

 * Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

 *

 * All rights reserved.

 *

 * ACPI based HotPlug driver that supports Memory Hotplug

 * This driver fields notifications from firmware for memory add

 * and remove operations and alerts the VM of the affected memory

 * ranges.

 Memory Range start physical addr */

 Memory Range length */

 memory cache attribute */

 memory read/write attribute */

 Can we combine the resource range information? */

 Get device present/absent information from the _STA */

	/*

	 * Check for device status. Device should be

	 * present/enabled/functioning.

 We want a single node for the whole memory group */

	/*

	 * Tell the VM there is more memory here...

	 * Note: Assume that this function returns zero on success

	 * We don't have memory-hot-add rollback function,now.

	 * (i.e. memory-hot-remove function)

		/*

		 * If the memory block size is zero, please ignore it.

		 * Don't try to do the following memory hotplug flowchart.

		/*

		 * If the memory block has been used by the kernel, add_memory()

		 * returns -EEXIST. If add_memory() returns the other error, it

		 * means that this memory block is not used by the kernel.

		/*

		 * Add num_enable even if add_memory() returns -EEXIST, so the

		 * device is bound to this driver.

	/*

	 * Sometimes the memory device will contain several memory blocks.

	 * When one memory block is hot-added to the system memory, it will

	 * be regarded as a success.

	 * Otherwise if the last memory block can't be hot-added to the system

	 * memory, it will be failure and the memory device can't be bound with

	 * driver.

 In case we succeeded adding *some* memory, unregistering fails. */

 Get the range from the _CRS */

 CONFIG_ACPI_HOTPLUG_MEMORY */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2005 Intel Corporation

 * Copyright (C) 2009 Hewlett-Packard Development Company, L.P.

 *

 *	Alex Chiang <achiang@hp.com>

 *	- Unified x86/ia64 implementations

 *

 * I/O APIC hotplug support

 *	Yinghai Lu <yinghai@kernel.org>

 *	Jiang Liu <jiang.liu@intel.com>

/*

 * Retrieve the ARM CPU physical identifier (MPIDR)

	/* device_declaration means Device object in DSDT, in the

	 * GIC interrupt model, logical processors are required to

	 * have a Processor Device object in the DSDT, so we should

	 * check device_declaration here

 CPU hardware ID */

 Parse all entries looking for a match. */

		/*

		 * On UP processor, there is no _MAT or MADT table.

		 * So above phys_id is always set to PHYS_CPUID_INVALID.

		 *

		 * BIOS may define multiple CPU handles even for UP processor.

		 * For example,

		 *

		 * Scope (_PR)

		 * {

		 *     Processor (CPU0, 0x00, 0x00000410, 0x06) {}

		 *     Processor (CPU1, 0x01, 0x00000410, 0x06) {}

		 *     Processor (CPU2, 0x02, 0x00000410, 0x06) {}

		 *     Processor (CPU3, 0x03, 0x00000410, 0x06) {}

		 * }

		 *

		 * Ignores phys_id and always returns 0 for the processor

		 * handle with acpi id 0 if nr_cpu_ids is 1.

		 * This should be the case if SMP tables are not found.

		 * Return -EINVAL for other CPU's handle.

 In UP kernel, only processor 0 is valid */

 Parse all entries looking for a match. */

/**

 * acpi_get_ioapic_id - Get IOAPIC ID and physical address matching @gsi_base

 * @handle:	ACPI object for IOAPIC device

 * @gsi_base:	GSI base to match with

 * @phys_addr:	Pointer to store physical address of matching IOAPIC record

 *

 * Walk resources returned by ACPI_MAT method, then ACPI MADT table, to search

 * for an ACPI IOAPIC record matching @gsi_base.

 * Return IOAPIC id and store physical address in @phys_addr if found a match,

 * otherwise return <0.

 CONFIG_ACPI_HOTPLUG_IOAPIC */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ACPI GSI IRQ layer

 *

 * Copyright (C) 2015 ARM Ltd.

 * Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

/**

 * acpi_gsi_to_irq() - Retrieve the linux irq number for a given GSI

 * @gsi: GSI IRQ number to map

 * @irq: pointer where linux IRQ number is stored

 *

 * irq location updated with irq value [>0 on success, 0 on failure]

 *

 * Returns: 0 on success

 *          -EINVAL on failure

	/*

	 * *irq == 0 means no mapping, that should

	 * be reported as a failure

/**

 * acpi_register_gsi() - Map a GSI to a linux IRQ number

 * @dev: device for which IRQ has to be mapped

 * @gsi: GSI IRQ number

 * @trigger: trigger type of the GSI number to be mapped

 * @polarity: polarity of the GSI to be mapped

 *

 * Returns: a valid linux IRQ number on success

 *          -EINVAL on failure

/**

 * acpi_unregister_gsi() - Free a GSI<->linux IRQ number mapping

 * @gsi: GSI IRQ number

/**

 * acpi_get_irq_source_fwhandle() - Retrieve fwhandle from IRQ resource source.

 * @source: acpi_resource_source to use for the lookup.

 *

 * Description:

 * Retrieve the fwhandle of the device referenced by the given IRQ resource

 * source.

 *

 * Return:

 * The referenced device fwhandle or NULL on failure

/*

 * Context for the resource walk used to lookup IRQ resources.

 * Contains a return code, the lookup index, and references to the flags

 * and fwspec where the result is returned.

/**

 * acpi_irq_parse_one_match - Handle a matching IRQ resource.

 * @fwnode: matching fwnode

 * @hwirq: hardware IRQ number

 * @triggering: triggering attributes of hwirq

 * @polarity: polarity attributes of hwirq

 * @polarity: polarity attributes of hwirq

 * @shareable: shareable attributes of hwirq

 * @ctx: acpi_irq_parse_one_ctx updated by this function

 *

 * Description:

 * Handle a matching IRQ resource by populating the given ctx with

 * the information passed.

/**

 * acpi_irq_parse_one_cb - Handle the given resource.

 * @ares: resource to handle

 * @context: context for the walk

 *

 * Description:

 * This is called by acpi_walk_resources passing each resource returned by

 * the _CRS method. We only inspect IRQ resources. Since IRQ resources

 * might contain multiple interrupts we check if the index is within this

 * one's interrupt array, otherwise we subtract the current resource IRQ

 * count from the lookup index to prepare for the next resource.

 * Once a match is found we call acpi_irq_parse_one_match to populate

 * the result and end the walk by returning AE_CTRL_TERMINATE.

 *

 * Return:

 * AE_OK if the walk should continue, AE_CTRL_TERMINATE if a matching

 * IRQ resource was found.

/**

 * acpi_irq_parse_one - Resolve an interrupt for a device

 * @handle: the device whose interrupt is to be resolved

 * @index: index of the interrupt to resolve

 * @fwspec: structure irq_fwspec filled by this function

 * @flags: resource flags filled by this function

 *

 * Description:

 * Resolves an interrupt for a device by walking its CRS resources to find

 * the appropriate ACPI IRQ resource and populating the given struct irq_fwspec

 * and flags.

 *

 * Return:

 * The result stored in ctx.rc by the callback, or the default -EINVAL value

 * if an error occurs.

/**

 * acpi_irq_get - Lookup an ACPI IRQ resource and use it to initialize resource.

 * @handle: ACPI device handle

 * @index:  ACPI IRQ resource index to lookup

 * @res:    Linux IRQ resource to initialize

 *

 * Description:

 * Look for the ACPI IRQ resource with the given index and use it to initialize

 * the given Linux IRQ resource.

 *

 * Return:

 * 0 on success

 * -EINVAL if an error occurs

 * -EPROBE_DEFER if the IRQ lookup/conversion failed

/**

 * acpi_set_irq_model - Setup the GSI irqdomain information

 * @model: the value assigned to acpi_irq_model

 * @fwnode: the irq_domain identifier for mapping and looking up

 *          GSI interrupts

/**

 * acpi_irq_create_hierarchy - Create a hierarchical IRQ domain with the default

 *                             GSI domain as its parent.

 * @flags:      Irq domain flags associated with the domain

 * @size:       Size of the domain.

 * @fwnode:     Optional fwnode of the interrupt controller

 * @ops:        Pointer to the interrupt domain callbacks

 * @host_data:  Controller private data pointer

 SPDX-License-Identifier: GPL-2.0-only

/*

 * drivers/acpi/device_pm.c - ACPI device power management routines.

 *

 * Copyright (C) 2012, Intel Corp.

 * Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

 *

 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 *

 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/**

 * acpi_power_state_string - String representation of ACPI device power state.

 * @state: ACPI device power state to return the string representation of.

/**

 * acpi_device_get_power - Get power state of an ACPI device.

 * @device: Device to get the power state of.

 * @state: Place to store the power state of the device.

 *

 * This function does not update the device's power.state field, but it may

 * update its parent's power.state field (when the parent's power state is

 * unknown and the device's power state turns out to be D0).

 *

 * Also, it does not update power resource reference counters to ensure that

 * the power state returned by it will be persistent and it may return a power

 * state shallower than previously set by acpi_device_set_power() for @device

 * (if that power state depends on any power resources).

 TBD: Non-recursive algorithm for walking up hierarchy. */

	/*

	 * Get the device's power state from power resources settings and _PSC,

	 * if available.

		/*

		 * The power resources settings may indicate a power state

		 * shallower than the actual power state of the device, because

		 * the same power resources may be referenced by other devices.

		 *

		 * For systems predating ACPI 4.0 we assume that D3hot is the

		 * deepest state that can be supported.

	/*

	 * If we were unsure about the device parent's power state up to this

	 * point, the fact that the device is in D0 implies that the parent has

	 * to be in D0 too, except if ignore_parent is set.

/**

 * acpi_device_set_power - Set power state of an ACPI device.

 * @device: Device to set the power state of.

 * @state: New power state to set.

 *

 * Callers must ensure that the device is power manageable before using this

 * function.

 Make sure this is a valid target state */

 There is a special case for D0 addressed below. */

		/*

		 * For transitions to D3cold we need to execute _PS3 and then

		 * possibly drop references to the power resources in use.

 If D3cold is not supported, use D3hot as the target state. */

	/*

	 * Transition Power

	 * ----------------

	 * In accordance with ACPI 6, _PSx is executed before manipulating power

	 * resources, unless the target state is D0, in which case _PS0 is

	 * supposed to be executed after turning the power resources on.

		/*

		 * According to ACPI 6, devices cannot go from lower-power

		 * (deeper) states to higher-power (shallower) states.

		/*

		 * If the device goes from D3hot to D3cold, _PS3 has been

		 * evaluated for it already, so skip it in that case.

 Nothing to do here if _PSC is not present. */

			/*

			 * The power state of the device was set to D0 last

			 * time, but that might have happened before a

			 * system-wide transition involving the platform

			 * firmware, so it may be necessary to evaluate _PS0

			 * for the device here.  However, use extra care here

			 * and evaluate _PSC to check the device's current power

			 * state, and only invoke _PS0 if the evaluation of _PSC

			 * is successful and it returns a power state different

			 * from D0.

 Reference count the power resources. */

			/*

			 * If _PSC is not present and the state inferred from

			 * power resources appears to be D0, it still may be

			 * necessary to execute _PS0 at this point, because

			 * another device using the same power resources may

			 * have been put into D0 previously and that's why we

			 * see D0 here.

		/*

		 * No power resources and missing _PSC?  Cross fingers and make

		 * it D0 in hope that this is what the BIOS put the device into.

		 * [We tried to force D0 here by executing _PS0, but that broke

		 * Toshiba P870-303 in a nasty way.]

/**

 * acpi_device_fix_up_power - Force device with missing _PSC into D0.

 * @device: Device object whose power state is to be fixed up.

 *

 * Devices without power resources and _PSC, but having _PS0 and _PS3 defined,

 * are assumed to be put into D0 by the BIOS.  However, in some cases that may

 * not be the case and this function should be used then.

			/*

			 * We don't need to really switch the state, bu we need

			 * to update the power resources' reference counters.

/**

 * acpi_add_pm_notifier - Register PM notify handler for given ACPI device.

 * @adev: ACPI device to add the notify handler for.

 * @dev: Device to generate a wakeup event for while handling the notification.

 * @func: Work function to execute when handling the notification.

 *

 * NOTE: @adev need not be a run-wake or wakeup device to be a valid source of

 * PM wakeup events.  For example, wakeup events may be generated for bridges

 * if one of the devices below the bridge is signaling wakeup, even if the

 * bridge itself doesn't have a wakeup GPE associated with it.

/**

 * acpi_remove_pm_notifier - Unregister PM notifier from given ACPI device.

 * @adev: ACPI device to remove the notifier from.

/**

 * acpi_dev_pm_get_state - Get preferred power state of ACPI device.

 * @dev: Device whose preferred target power state to return.

 * @adev: ACPI device node corresponding to @dev.

 * @target_state: System state to match the resultant device state.

 * @d_min_p: Location to store the highest power state available to the device.

 * @d_max_p: Location to store the lowest power state available to the device.

 *

 * Find the lowest power (highest number) and highest power (lowest number) ACPI

 * device power states that the device can be in while the system is in the

 * state represented by @target_state.  Store the integer numbers representing

 * those stats in the memory locations pointed to by @d_max_p and @d_min_p,

 * respectively.

 *

 * Callers must ensure that @dev and @adev are valid pointers and that @adev

 * actually corresponds to @dev before using this function.

 *

 * Returns 0 on success or -ENODATA when one of the ACPI methods fails or

 * returns a value that doesn't make sense.  The memory locations pointed to by

 * @d_max_p and @d_min_p are only modified on success.

	/*

	 * If the system state is S0, the lowest power state the device can be

	 * in is D3cold, unless the device has _S0W and is supposed to signal

	 * wakeup, in which case the return value of _S0W has to be used as the

	 * lowest power state available to the device.

	/*

	 * If present, _SxD methods return the minimum D-state (highest power

	 * state) we can use for the corresponding S-states.  Otherwise, the

	 * minimum D-state is D0 (ACPI 3.x).

		/*

		 * We rely on acpi_evaluate_integer() not clobbering the integer

		 * provided if AE_NOT_FOUND is returned.

		/*

		 * We need to handle legacy systems where D3hot and D3cold are

		 * the same and 3 is returned in both cases, so fall back to

		 * D3cold if D3hot is not a valid state.

	/*

	 * If _PRW says we can wake up the system from the target sleep state,

	 * the D-state returned by _SxD is sufficient for that (we assume a

	 * wakeup-aware driver if wake is set).  Still, if _SxW exists

	 * (ACPI 3.x), it should return the maximum (lowest power) D-state that

	 * can wake the system.  _S0W may be valid, too.

			/* No _SxW. In this case, the ACPI spec says that we

			 * must not go into any power state deeper than the

			 * value returned from _SxD.

 Fall back to D3cold if ret is not a valid state. */

/**

 * acpi_pm_device_sleep_state - Get preferred power state of ACPI device.

 * @dev: Device whose preferred target power state to return.

 * @d_min_p: Location to store the upper limit of the allowed states range.

 * @d_max_in: Deepest low-power state to take into consideration.

 * Return value: Preferred power state of the device on success, -ENODEV

 * if there's no 'struct acpi_device' for @dev, -EINVAL if @d_max_in is

 * incorrect, or -ENODATA on ACPI method failure.

 *

 * The caller must ensure that @dev is valid before using this function.

/**

 * acpi_pm_notify_work_func - ACPI devices wakeup notification work function.

 * @context: Device wakeup context.

	/*

	 * If the device wakeup power is already enabled, disable it and enable

	 * it again in case it depends on the configuration of subordinate

	 * devices and the conditions have changed since it was enabled last

	 * time.

/**

 * acpi_device_wakeup_enable - Enable wakeup functionality for device.

 * @adev: ACPI device to enable wakeup functionality for.

 * @target_state: State the system is transitioning into.

 *

 * Enable the GPE associated with @adev so that it can generate wakeup signals

 * for the device in response to external (remote) events and enable wakeup

 * power for it.

 *

 * Callers must ensure that @adev is a valid ACPI device node before executing

 * this function.

/**

 * acpi_device_wakeup_disable - Disable wakeup functionality for device.

 * @adev: ACPI device to disable wakeup functionality for.

 *

 * Disable the GPE associated with @adev and disable wakeup power for it.

 *

 * Callers must ensure that @adev is a valid ACPI device node before executing

 * this function.

/**

 * acpi_pm_set_device_wakeup - Enable/disable remote wakeup for given device.

 * @dev: Device to enable/disable to generate wakeup events.

 * @enable: Whether to enable or disable the wakeup functionality.

/**

 * acpi_dev_pm_low_power - Put ACPI device into a low-power state.

 * @dev: Device to put into a low-power state.

 * @adev: ACPI device node corresponding to @dev.

 * @system_state: System state to choose the device state for.

/**

 * acpi_dev_pm_full_power - Put ACPI device into the full-power state.

 * @adev: ACPI device node to put into the full-power state.

/**

 * acpi_dev_suspend - Put device into a low-power state using ACPI.

 * @dev: Device to put into a low-power state.

 * @wakeup: Whether or not to enable wakeup for the device.

 *

 * Put the given device into a low-power state using the standard ACPI

 * mechanism.  Set up remote wakeup if desired, choose the state to put the

 * device into (this checks if remote wakeup is expected to work too), and set

 * the power state of the device.

/**

 * acpi_dev_resume - Put device into the full-power state using ACPI.

 * @dev: Device to put into the full-power state.

 *

 * Put the given device into the full-power state using the standard ACPI

 * mechanism.  Set the power state of the device to ACPI D0 and disable wakeup.

/**

 * acpi_subsys_runtime_suspend - Suspend device using ACPI.

 * @dev: Device to suspend.

 *

 * Carry out the generic runtime suspend procedure for @dev and use ACPI to put

 * it into a runtime low-power state.

/**

 * acpi_subsys_runtime_resume - Resume device using ACPI.

 * @dev: Device to Resume.

 *

 * Use ACPI to put the given device into the full-power state and carry out the

 * generic runtime resume procedure for it.

/**

 * acpi_subsys_prepare - Prepare device for system transition to a sleep state.

 * @dev: Device to prepare.

/**

 * acpi_subsys_complete - Finalize device's resume during system resume.

 * @dev: Device to handle.

	/*

	 * If the device had been runtime-suspended before the system went into

	 * the sleep state it is going out of and it has never been resumed till

	 * now, resume it in case the firmware powered it up.

/**

 * acpi_subsys_suspend - Run the device driver's suspend callback.

 * @dev: Device to handle.

 *

 * Follow PCI and resume devices from runtime suspend before running their

 * system suspend callbacks, unless the driver can cope with runtime-suspended

 * devices during system suspend and there are no ACPI-specific reasons for

 * resuming them.

/**

 * acpi_subsys_suspend_late - Suspend device using ACPI.

 * @dev: Device to suspend.

 *

 * Carry out the generic late suspend procedure for @dev and use ACPI to put

 * it into a low-power state during system transition into a sleep state.

/**

 * acpi_subsys_suspend_noirq - Run the device driver's "noirq" suspend callback.

 * @dev: Device to suspend.

	/*

	 * If the target system sleep state is suspend-to-idle, it is sufficient

	 * to check whether or not the device's wakeup settings are good for

	 * runtime PM.  Otherwise, the pm_resume_via_firmware() check will cause

	 * acpi_subsys_complete() to take care of fixing up the device's state

	 * anyway, if need be.

/**

 * acpi_subsys_resume_noirq - Run the device driver's "noirq" resume callback.

 * @dev: Device to handle.

/**

 * acpi_subsys_resume_early - Resume device using ACPI.

 * @dev: Device to Resume.

 *

 * Use ACPI to put the given device into the full-power state and carry out the

 * generic early resume procedure for it during system transition into the

 * working state, but only do that if device either defines early resume

 * handler, or does not define power operations at all. Otherwise powering up

 * of the device is postponed to the normal resume phase.

/**

 * acpi_subsys_resume - Resume device using ACPI.

 * @dev: Device to Resume.

 *

 * Use ACPI to put the given device into the full-power state if it has not been

 * powered up during early resume phase, and carry out the generic resume

 * procedure for it during system transition into the working state.

/**

 * acpi_subsys_freeze - Run the device driver's freeze callback.

 * @dev: Device to handle.

	/*

	 * Resume all runtime-suspended devices before creating a snapshot

	 * image of system memory, because the restore kernel generally cannot

	 * be expected to always handle them consistently and they need to be

	 * put into the runtime-active metastate during system resume anyway,

	 * so it is better to ensure that the state saved in the image will be

	 * always consistent with that.

/**

 * acpi_subsys_restore_early - Restore device using ACPI.

 * @dev: Device to restore.

/**

 * acpi_subsys_poweroff - Run the device driver's poweroff callback.

 * @dev: Device to handle.

 *

 * Follow PCI and resume devices from runtime suspend before running their

 * system poweroff callbacks, unless the driver can cope with runtime-suspended

 * devices during system suspend and there are no ACPI-specific reasons for

 * resuming them.

/**

 * acpi_subsys_poweroff_late - Run the device driver's poweroff callback.

 * @dev: Device to handle.

 *

 * Carry out the generic late poweroff procedure for @dev and use ACPI to put

 * it into a low-power state during system transition into a sleep state.

/**

 * acpi_subsys_poweroff_noirq - Run the driver's "noirq" poweroff callback.

 * @dev: Device to suspend.

 CONFIG_PM_SLEEP */

/**

 * acpi_dev_pm_detach - Remove ACPI power management from the device.

 * @dev: Device to take care of.

 * @power_off: Whether or not to try to remove power from the device.

 *

 * Remove the device from the general ACPI PM domain and remove its wakeup

 * notifier.  If @power_off is set, additionally remove power from the device if

 * possible.

 *

 * Callers must ensure proper synchronization of this function with power

 * management callbacks.

			/*

			 * If the device's PM QoS resume latency limit or flags

			 * have been exposed to user space, they have to be

			 * hidden at this point, so that they don't affect the

			 * choice of the low-power state to put the device into.

/**

 * acpi_dev_pm_attach - Prepare device for ACPI power management.

 * @dev: Device to prepare.

 * @power_on: Whether or not to power on the device.

 *

 * If @dev has a valid ACPI handle that has a valid struct acpi_device object

 * attached to it, install a wakeup notification handler for the device and

 * add it to the general ACPI PM domain.  If @power_on is set, the device will

 * be put into the ACPI D0 state before the function returns.

 *

 * This assumes that the @dev's bus type uses generic power management callbacks

 * (or doesn't use any power management callbacks at all).

 *

 * Callers must ensure proper synchronization of this function with power

 * management callbacks.

	/*

	 * Skip devices whose ACPI companions match the device IDs below,

	 * because they require special power management handling incompatible

	 * with the generic ACPI PM domain.

	/*

	 * Only attach the power domain to the first device if the

	 * companion is shared by multiple. This is to prevent doing power

	 * management twice.

/**

 * acpi_storage_d3 - Check if D3 should be used in the suspend path

 * @dev: Device to check

 *

 * Return %true if the platform firmware wants @dev to be programmed

 * into D3hot or D3cold (if supported) in the suspend path, or %false

 * when there is no specific preference. On some platforms, if this

 * hint is ignored, @dev may remain unresponsive after suspending the

 * platform as a whole.

 *

 * Although the property has storage in the name it actually is

 * applied to the PCIe slot and plugging in a non-storage device the

 * same platform restrictions will likely apply.

/**

 * acpi_dev_state_d0 - Tell if the device is in D0 power state

 * @dev: Physical device the ACPI power state of which to check

 *

 * On a system without ACPI, return true. On a system with ACPI, return true if

 * the current ACPI power state of the device is D0, or false otherwise.

 *

 * Note that the power state of a device is not well-defined after it has been

 * passed to acpi_device_set_power() and before that function returns, so it is

 * not valid to ask for the ACPI power state of the device in that time frame.

 *

 * This function is intended to be used in a driver's probe or remove

 * function. See Documentation/firmware-guide/acpi/low-power-probe.rst for

 * more information.

 CONFIG_PM */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  pci_link.c - ACPI PCI Interrupt Link Device Driver ($Revision: 34 $)

 *

 *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>

 *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

 *  Copyright (C) 2002       Dominik Brodowski <devel@brodo.de>

 *

 * TBD:

 *	1. Support more than one IRQ resource entry per link device (index).

 *	2. Implement start/stop mechanism and use ACPI Bus Driver facilities

 *	   for IRQ management (e.g. start()->_SRS).

/*

 * If a link is initialized, we never change its active and initialized

 * later even the link is disable. Instead, we just repick the active irq

 Current IRQ */

 All IRQs */

 All IRQs */

/* --------------------------------------------------------------------------

                            PCI Link Device Management

/*

 * set context (link) possible list from resource list

				/*

				 * IRQ descriptors may have no IRQ# bits set,

				 * particularly those those w/ _STA disabled

				/*

				 * extended IRQ descriptors must

				 * return at least 1 IRQ

/*

 * Run _CRS and set link->irq.active

 *

 * return value:

 * 0 - success

 * !0 - failure

 in practice, status disabled is meaningless, ignore it */

 Query _STA, set link->device->status */

	/*

	 * Query and parse _CRS to get the current IRQ assignment.

 ignore resource_source, it's optional */

 Attempt to set the resource */

 check for total failure */

 Query _STA, set device->status */

 Query _CRS, set link->irq.active */

	/*

	 * Is current setting not what we set?

	 * set link->irq.active

		/*

		 * policy: when _CRS doesn't return what we just _SRS

		 * assume _SRS worked and override _CRS value.

/* --------------------------------------------------------------------------

                            PCI Link IRQ Management

/*

 * "acpi_irq_balance" (default in APIC mode) enables ACPI to use PIC Interrupt

 * Link Devices to move the PIRQs around to minimize sharing.

 *

 * "acpi_irq_nobalance" (default in PIC mode) tells ACPI not to move any PIC IRQs

 * that the BIOS has already set to active.  This is necessary because

 * ACPI has no automatic means of knowing what ISA IRQs are used.  Note that

 * if the BIOS doesn't set a Link Device active, ACPI needs to program it

 * even if acpi_irq_nobalance is set.

 *

 * A tables of penalties avoids directing PCI interrupts to well known

 * ISA IRQs. Boot params are available to over-ride the default table:

 *

 * List interrupts that are free for PCI use.

 * acpi_irq_pci=n[,m]

 *

 * List interrupts that should not be used for PCI:

 * acpi_irq_isa=n[,m]

 *

 * Note that PCI IRQ routers have a list of possible IRQs,

 * which may not include the IRQs this table says are available.

 *

 * Since this heuristic can't tell the difference between a link

 * that no device will attach to, vs. a link which may be shared

 * by multiple active devices -- it is not optimal.

 *

 * If interrupt performance is that important, get an IO-APIC system

 * with a pin dedicated to each device.  Or for that matter, an MSI

 * enabled system.

 IRQ0 timer */

 IRQ1 keyboard */

 IRQ2 cascade */

 IRQ3 serial */

 IRQ4 serial */

 IRQ5 sometimes SoundBlaster */

 IRQ6 */

 IRQ7 parallel, spurious */

 IRQ8 rtc, sometimes */

 IRQ9  PCI, often acpi */

 IRQ10 PCI */

 IRQ11 PCI */

 IRQ12 mouse */

 IRQ13 fpe, sometimes */

 IRQ14 ide0 */

 IRQ15 ide1 */

 >IRQ15 */

		/*

		 * If a link is active, penalize its IRQ heavily

		 * so we try to choose a different IRQ.

		/*

		 * penalize the IRQs PCI might use, but not as severely.

	/*

	 * Update penalties to facilitate IRQ balancing.

		/*

		 * reflect the possible and active irqs in the penalty table --

		 * useful for breaking ties.

 0: static, 1: balance */

 This means the link is disabled but initialized */

	/*

	 * search for active IRQ in list of possible IRQs.

	/*

	 * forget active IRQ that is not in possible list

	/*

	 * if active found, use it; else pick entry from end of possible list.

		/*

		 * Select the best IRQ.  This is done in reverse to promote

		 * the use of IRQs 9, 10, 11, and >15.

 Attempt to enable the link device at this IRQ. */

/*

 * acpi_pci_link_allocate_irq

 * success: return IRQ >= 0

 * failure: return -1

 TBD: Support multiple index (IRQ) entries per Link Device */

/*

 * We don't change link's irq information here.  After it is reenabled, we

 * continue use the info

	/*

	 * The Link reference count allows us to _DISable an unused link

	 * and suspend time, and set it again  on resume.

	 * However, 2.6.12 still has irq_router.resume

	 * which blindly restores the link state.

	 * So we disable the reference count method

	 * to prevent duplicate acpi_pci_link_set()

	 * which would harm some systems

/* --------------------------------------------------------------------------

                                 Driver Interface

 query and set link->irq.active */

 disable all links -- to be activated on use */

/*

 * modify acpi_isa_irq_penalty[] from cmdline

 no number found */

 see if this is a ISA IRQ */

 no next number */

/*

 * We'd like PNP to call this routine for the

 * single ISA_USED value for each legacy device.

 * But instead it calls us with each POSSIBLE setting.

 * There is no ISA_POSSIBLE weight, so we simply use

 * the (small) PCI_USING penalty.

/*

 * Over-ride default table to reserve additional IRQs for use by ISA

 * e.g. acpi_irq_isa=5

 * Useful for telling ACPI how not to interfere with your ISA sound card.

/*

 * Over-ride default table to free additional IRQs for use by PCI

 * e.g. acpi_irq_pci=7,15

 * Used for acpi_irq_balance to free up IRQs to reduce PCI IRQ sharing.

 no command line switch: enable balancing in IOAPIC mode */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  acpi_ac.c - ACPI AC Adapter Driver (Revision: 27)

 *

 *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>

 *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>

 Lists of PMIC ACPI HIDs with an (often better) native charger driver */

 X-Powers AXP288 PMIC */

 Intel Cherrytrail Whiskey Cove PMIC */

 AC Adapter Management */

 sysfs I/F */

 Driver Model */

		/*

		 * A buggy BIOS may notify AC first and then sleep for

		 * a specific time before doing actual operations in the

		 * EC event handler (_Qxx). This will cause the AC state

		 * reported by the ACPI event to be incorrect, so wait for a

		 * specific time for the EC event handler to make progress.

	/*

	 * On HP Pavilion dv6-6179er AC status notifications aren't triggered

	 * when adapter is plugged/unplugged. However, battery status

	 * notifications are triggered when battery starts charging or

	 * discharging. Re-reading AC status triggers lost AC notifications,

	 * if AC status has changed.

 Please keep this list alphabetically sorted */

 ECS EF20EA, AXP288 PMIC but uses separate fuel-gauge */

 Kodlix GK45 returning incorrect state */

 Lenovo Ideapad Miix 320, AXP288 PMIC, separate fuel-gauge */

 Lenovo Thinkpad e530, see comment in acpi_ac_notify() */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ACPI device specific properties support.

 *

 * Copyright (C) 2014, Intel Corporation

 * All rights reserved.

 *

 * Authors: Mika Westerberg <mika.westerberg@linux.intel.com>

 *          Darren Hart <dvhart@linux.intel.com>

 *          Rafael J. Wysocki <rafael.j.wysocki@intel.com>

/*

 * The GUIDs here are made equivalent to each other in order to avoid extra

 * complexity in the properties handling code, with the caveat that the

 * kernel will accept certain combinations of GUID and properties that are

 * not defined without a warning. For instance if any of the properties

 * from different GUID appear in a property list of another, it will be

 * accepted by the kernel. Firmware validation tools should catch these.

 ACPI _DSD device properties GUID: daffd814-6eba-4d8c-8a91-bc9bbf4aa301 */

 Hotplug in D3 GUID: 6211e2c0-58a3-4af3-90e1-927a4e0c55a4 */

 External facing port GUID: efcc06cc-73ac-4bc3-bff0-76143807c389 */

 Thunderbolt GUID for IMR_VALID: c44d002f-69f9-4e7d-a904-a7baabdf43f7 */

 Thunderbolt GUID for WAKE_SUPPORTED: 6c501103-c189-4296-ba72-9bf5a26ebe5d */

 Storage device needs D3 GUID: 5025030f-842f-4ab4-a561-99a5189762d0 */

 ACPI _DSD data subnodes GUID: dbb8e3e6-5886-4ba6-8795-1319f52a966b */

		/*

		 * The scope for the subnode object lookup is the one of the

		 * namespace node (device) containing the object that has

		 * returned the package.  That is, it's the scope of that

		 * object's parent.

 Only two elements allowed. */

 The first one must be a string. */

 The second one may be a string, a reference or a package. */

 Look for the ACPI data subnodes GUID. */

		/*

		 * The first element must be a GUID and the second one must be

		 * a package.

	/*

	 * The value must be an integer, a string, a reference, or a package

	 * whose every element must be an integer, a string, or a reference.

		/*

		 * Only two elements allowed, the first one must be a string and

		 * the second one has to satisfy certain conditions.

 Look for the device properties GUID. */

		/*

		 * The first element must be a GUID and the second one must be

		 * a package.

		/*

		 * We found the matching GUID. Now validate the format of the

		 * package immediately following it.

	/*

	 * Check if ACPI_DT_NAMESPACE_HID is present and inthat case we fill in

	 * Device Tree compatible properties for this device.

/**

 * acpi_data_get_property - return an ACPI property with given name

 * @data: ACPI device deta object to get the property from

 * @name: Name of the property

 * @type: Expected property type

 * @obj: Location to store the property value (if not %NULL)

 *

 * Look up a property with @name and store a pointer to the resulting ACPI

 * object at the location pointed to by @obj if found.

 *

 * Callers must not attempt to free the returned objects.  These objects will be

 * freed by the ACPI core automatically during the removal of @data.

 *

 * Return: %0 if property with @name has been found (success),

 *         %-EINVAL if the arguments are invalid,

 *         %-EINVAL if the property doesn't exist,

 *         %-EPROTO if the property value type doesn't match @type.

/**

 * acpi_dev_get_property - return an ACPI property with given name.

 * @adev: ACPI device to get the property from.

 * @name: Name of the property.

 * @type: Expected property type.

 * @obj: Location to store the property value (if not %NULL).

/**

 * acpi_node_prop_get - return an ACPI property with given name.

 * @fwnode: Firmware node to get the property from.

 * @propname: Name of the property.

 * @valptr: Location to store a pointer to the property value (if not %NULL).

/**

 * acpi_data_get_property_array - return an ACPI array property with given name

 * @data: ACPI data object to get the property from

 * @name: Name of the property

 * @type: Expected type of array elements

 * @obj: Location to store a pointer to the property value (if not NULL)

 *

 * Look up an array property with @name and store a pointer to the resulting

 * ACPI object at the location pointed to by @obj if found.

 *

 * Callers must not attempt to free the returned objects.  Those objects will be

 * freed by the ACPI core automatically during the removal of @data.

 *

 * Return: %0 if array property (package) with @name has been found (success),

 *         %-EINVAL if the arguments are invalid,

 *         %-EINVAL if the property doesn't exist,

 *         %-EPROTO if the property is not a package or the type of its elements

 *           doesn't match @type.

 Check that all elements are of correct type. */

/**

 * __acpi_node_get_property_reference - returns handle to the referenced object

 * @fwnode: Firmware node to get the property from

 * @propname: Name of the property

 * @index: Index of the reference to return

 * @num_args: Maximum number of arguments after each reference

 * @args: Location to store the returned reference with optional arguments

 *

 * Find property with @name, verifify that it is a package containing at least

 * one object reference and if so, store the ACPI device object pointer to the

 * target object in @args->adev.  If the reference includes arguments, store

 * them in the @args->args[] array.

 *

 * If there's more than one reference in the property value package, @index is

 * used to select the one to return.

 *

 * It is possible to leave holes in the property value set like in the

 * example below:

 *

 * Package () {

 *     "cs-gpios",

 *     Package () {

 *        ^GPIO, 19, 0, 0,

 *        ^GPIO, 20, 0, 0,

 *        0,

 *        ^GPIO, 21, 0, 0,

 *     }

 * }

 *

 * Calling this function with index %2 or index %3 return %-ENOENT. If the

 * property does not contain any more values %-ENOENT is returned. The NULL

 * entry must be single integer and preferably contain value %0.

 *

 * Return: %0 on success, negative error code on failure.

	/*

	 * The simplest case is when the value is a single reference.  Just

	 * return that reference then.

	/*

	 * If it is not a single reference, then it is a package of

	 * references followed by number of ints as follows:

	 *

	 *  Package () { REF, INT, REF, INT, INT }

	 *

	 * The index argument is then used to determine which reference

	 * the caller wants (along with the arguments).

			/*

			 * Find the referred data extension node under the

			 * referred device node.

 assume following integer elements are all args */

		/*

		 * The overflow error means that the property is there and it is

		 * single-value, but its type does not match, so return.

		/*

		 * Reading this property as a single-value one failed, but its

		 * value may still be represented as one-element array, so

		 * continue.

/**

 * acpi_node_prop_read - retrieve the value of an ACPI property with given name.

 * @fwnode: Firmware node to get the property from.

 * @propname: Name of the property.

 * @proptype: Expected property type.

 * @val: Location to store the property value (if not %NULL).

 * @nval: Size of the array pointed to by @val.

 *

 * If @val is %NULL, return the number of array elements comprising the value

 * of the property.  Otherwise, read at most @nval values to the array at the

 * location pointed to by @val.

/**

 * acpi_get_next_subnode - Return the next child node handle for a fwnode

 * @fwnode: Firmware node to find the next child node for.

 * @child: Handle to one of the device's child nodes or a null handle.

		/*

		 * We can have a combination of device and data nodes, e.g. with

		 * hierarchical _DSD properties. Make sure the adev pointer is

		 * restored before going through data nodes, otherwise we will

		 * be looking for data_nodes below the last device found instead

		 * of the common fwnode shared by device_nodes and data_nodes.

/**

 * acpi_node_get_parent - Return parent fwnode of this fwnode

 * @fwnode: Firmware node whose parent to get

 *

 * Returns parent node of an ACPI device or data firmware node or %NULL if

 * not available.

 All data nodes have parent pointer so just return that */

/*

 * Return true if the node is an ACPI graph node. Called on either ports

 * or endpoints.

/**

 * acpi_graph_get_next_endpoint - Get next endpoint ACPI firmware node

 * @fwnode: Pointer to the parent firmware node

 * @prev: Previous endpoint node or %NULL to get the first

 *

 * Looks up next endpoint ACPI firmware node below a given @fwnode. Returns

 * %NULL if there is no next endpoint or in case of error. In case of success

 * the next endpoint is returned.

			/*

			 * The names of the port nodes begin with "port@"

			 * followed by the number of the port node and they also

			 * have a "reg" property that also has the number of the

			 * port node. For compatibility reasons a node is also

			 * recognised as a port node from the "port" property.

	/*

	 * The names of the endpoint nodes begin with "endpoint@" followed by

	 * the number of the endpoint node and they also have a "reg" property

	 * that also has the number of the endpoint node. For compatibility

	 * reasons a node is also recognised as an endpoint node from the

	 * "endpoint" property.

/**

 * acpi_graph_get_child_prop_value - Return a child with a given property value

 * @fwnode: device fwnode

 * @prop_name: The name of the property to look for

 * @val: the desired property value

 *

 * Return the port node corresponding to a given port number. Returns

 * the child node on success, NULL otherwise.

/**

 * acpi_graph_get_remote_endpoint - Parses and returns remote end of an endpoint

 * @__fwnode: Endpoint firmware node pointing to a remote device

 *

 * Returns the remote endpoint corresponding to @__fwnode. NULL on error.

 Direct endpoint reference? */

	/*

	 * Always require two arguments with the reference: port and

	 * endpoint indices.

 Is this the root node? */

 Is this the root node? */

 Is this 2nd node from the root? */

 ACPI device or data node. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * NFIT - Machine Check Handler

 *

 * Copyright(c) 2013-2016 Intel Corporation. All rights reserved.

 We only care about uncorrectable memory errors */

 Verify the address reported in the MCE is valid. */

	/*

	 * mce->addr contains the physical addr accessed that caused the

	 * machine check. We need to walk through the list of NFITs, and see

	 * if any of them matches that address, and only then start a scrub.

 find the spa that covers the mce addr */

			/*

			 * We can break at the first match because we're going

			 * to rescan all the SPA ranges. There shouldn't be any

			 * aliasing anyway.

 If this fails due to an -ENOMEM, there is little we can do */

			/*

			 * We can ignore an -EBUSY here because if an ARS is

			 * already in progress, just let that be the last

			 * authoritative one

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright(c) 2013-2015 Intel Corporation. All rights reserved.

/*

 * For readq() and writeq() on 32-bit builds, the hi-lo, lo-hi order is

 * irrelevant.

	/*

	 * The index of bus UUIDs starts immediately following the last

	 * NVDIMM/leaf family.

	/*

	 * If provider == 'ACPI.NFIT' we can assume 'dev' is a struct

	 * acpi_device.

 Command failed */

 No supported scan types for this range */

 ARS is in progress */

 Command failed */

 Command failed */

 Check extended status (Upper two bytes) */

 ARS is in progress */

 No ARS performed for the current boot */

		/*

		 * ARS interrupted, either we overflowed or some other

		 * agent wants the scan to stop.  If we didn't overflow

		 * then just continue with the returned results.

 Unknown status */

 all other non-zero status results in an error */

		/*

		 * In the _LSI, _LSR, _LSW case the locked status is

		 * communicated via the read/write commands

 all other non-zero status results in an error */

 convert _LS{I,R} packages to the buffer object acpi_nfit_ctl expects */

 default */

 In the !call_pkg case, bus commands == bus functions */

 Linux ND commands == NVDIMM_FAMILY_INTEL function numbers */

	/*

	 * Force function number validation to fail since 0 is never

	 * published as a valid function in dsm_mask.

	/*

	 * Check for a valid command.  For ND_CMD_CALL, we also have to

	 * make sure that the DSM function is supported.

 libnvdimm has already validated the input envelope */

 skip over package wrapper */

 call the BIOS, prefer the named methods over _DSM if available */

		/*

		 * Need to support FW function w/o known size in advance.

		 * Caller can determine required size based upon nd_fw_size.

		 * If we return an error (like elsewhere) then caller wouldn't

		 * be able to rely upon data returned to make calculation.

	/*

	 * Set fw_status for all the commands with a known format to be

	 * later interpreted by xlat_status().

			/*

			 * status valid, return the number of bytes left

			 * unfilled in the output buffer

/*

 * An implementation may provide a truncated control region if no block windows

 * are defined.

	/*

	 * This loop runs in two modes, when a dimm is mapped the loop

	 * adds memdev associations to an existing dimm, or creates a

	 * dimm. In the unmapped dimm case this loop sweeps for memdev

	 * instances with an invalid / zero range_index and adds those

	 * dimms without spa associations.

			/*

			 * Record the control region for the dimm.  For

			 * the ACPI 6.1 case, where there are separate

			 * control regions for the pmem vs blk

			 * interfaces, be sure to record the extended

			 * blk details.

 multiple dimms may share a SPA when interleaved */

			/*

			 * A single dimm may belong to multiple SPA-PM

			 * ranges, record at least one in addition to

			 * any SPA-DCR range.

	/*

	 * For each SPA-DCR or SPA-PMEM address range find its

	 * corresponding MEMDEV(s).  From each MEMDEV find the

	 * corresponding DCR.  Then, if we're operating on a SPA-DCR,

	 * try to find a SPA-BDW and a corresponding BDW that references

	 * the DCR.  Throw it all into an nfit_mem object.  Note, that

	 * BDWs are optional.

	/*

	 * If a DIMM has failed to be mapped into SPA there will be no

	 * SPA entries above. Find and register all the unmapped DIMMs

	 * for reporting and recovery purposes.

/*

 * The 'hw_error_scrub' attribute can have the following values written to it:

 * '0': Switch to the default mode where an exception will only insert

 *      the address of the memory error into the poison and badblocks lists.

 * '1': Enable a full scrub to happen if an exception for a memory error is

 *      received.

/*

 * This shows the number of full Address Range Scrubs that have been

 * completed since driver load time. Userspace can wait on this using

 * select/poll etc. A '+' at the end indicates an ARS is in progress

 Allow an admin to poll the busy state at a higher rate */

 assumes DIMMs have at most 2 published interface codes */

 Without a dcr only the memdev attributes can be surfaced */

	/*

	 * If we successfully retrieved acpi_desc, then we know nfit_mem data

	 * is still valid.

	/*

	 * For DIMMs that provide a dynamic facility to retrieve a

	 * dirty-shutdown status and/or a dirty-shutdown count, cache

	 * these values in nfit_mem.

 nfit test assumes 1:1 relationship between commands and dsms */

 unit test case */

	/*

	 * Record nfit_mem for the notification path to track back to

	 * the nfit sysfs attributes for this dimm device object.

	/*

	 * There are 4 "legacy" NVDIMM command sets

	 * (NVDIMM_FAMILY_{INTEL,MSFT,HPE1,HPE2}) that were created before

	 * an EFI working group was established to constrain this

	 * proliferation. The nfit driver probes for the supported command

	 * set by GUID. Note, if you're a platform developer looking to add

	 * a new command set to this probe, consider using an existing set,

	 * or otherwise seek approval to publish the command set at

	 * http://www.uefi.org/RFIC_LIST.

	 *

	 * Note, that checking for function0 (bit0) tells us if any commands

	 * are reachable through this GUID.

 limit the supported commands to those that are publicly documented */

 DSMs are optional, continue loading the driver... */

	/*

	 * Function 0 is the command interrogation function, don't

	 * export it to potential userspace use, and enable it to be

	 * used as an error value in acpi_nfit_ctl().

	/*

	 * Prefer the NVDIMM_FAMILY_INTEL label read commands if present

	 * due to their better semantics handling locked capacity.

 skip _LS{I,R,W} enabling */;

		/*

		 * Quirk read-only label configurations to preserve

		 * access to label-less namespaces by default.

	/*

	 * Clear out the nfit_mem->flags_attr and shut down dimm event

	 * notifications.

 collate flags across all memdevs for this dimm */

		/*

		 * TODO: provide translation for non-NVDIMM_FAMILY_INTEL

		 * devices (i.e. from nd_cmd to acpi_dsm) to standardize the

		 * userspace interface.

			/*

			 * These commands have a 1:1 correspondence

			 * between DSM payload and libnvdimm ioctl

			 * payload format.

 Quirk to ignore LOCAL for labels on HYPERV DIMMs */

	/*

	 * Now that dimms are successfully registered, and async registration

	 * is flushed, attempt to enable event notification.

/*

 * These constants are private because there are no kernel consumers of

 * these commands.

 enable nfit_test to inject bus command emulation */

 Enumerate allowed NVDIMM_BUS_FAMILY_INTEL commands */

 enough info to uniquely specify an interleave set */

 Retrieve the nth entry referencing this spa */

 v1.1 namespaces */

 v1.2 namespaces */

 support v1.1 namespaces created with the wrong sort order */

 record the result of the sort for the mapping position */

 fall back to a conservative default */

 map block aperture memory */

 map block control memory */

	/*

	 * Only advance the ARS state for ARS runs initiated by the

	 * kernel, ignore ARS results from BIOS initiated runs for scrub

	 * completion tracking.

		/*

		 * Assume that if a scrub starts at an offset from the

		 * start of nfit_spa that we are in the continuation

		 * case.

		 *

		 * Otherwise, if the scrub covers the spa range, mark

		 * any pending request complete.

 complete */;

	/*

	 * First record starts at 44 byte offset from the start of the

	 * payload.

	/*

	 * Ignore potentially stale results that are only refreshed

	 * after a start-ARS event.

 only process full records */

 No operation if the region is already registered as PMEM */

 Fallback to address based numa information if node lookup failed */

	/*

	 * Persistence domain bits are hierarchical, if

	 * ACPI_NFIT_CAPABILITY_CACHE_FLUSH is set then

	 * ACPI_NFIT_CAPABILITY_MEM_FLUSH is implied.

 range index 0 == unmapped in SPA or invalid-SPA */

 shouldn't happen, try again later */

		/*

		 * If ars_complete() says we didn't complete the

		 * short scrub, we'll try again with a long

		 * request.

		/*

		 * BIOS was using ARS, wait for it to complete (or

		 * resources to become available) and then perform our

		 * own scrubs.

 prefer short ARS requests first */

		/*

		 * Hmm, we raced someone else starting ARS? Try again in

		 * a bit.

			/*

			 * Consider this spa last for future scrub

			 * requests

 note this should only be set from within the workqueue */

 check that the supported scrub types match the spa type */

 register regions and kick off initial ARS run */

			/*

			 * Kick off background ARS if at least one

			 * region successfully registered ARS

 nothing to register */

 register known regions that don't support ARS */

 don't register unknown regions */

 register this acpi_desc for mce notifications */

 Bounce the device lock to flush acpi_nfit_add / acpi_nfit_notify */

 Bounce the init_mutex to complete initial registration */

	/*

	 * The kernel and userspace may race to initiate a scrub, but

	 * the scrub thread is prepared to lose that initial race.  It

	 * just needs guarantees that any ARS it initiates are not

	 * interrupted by any intervening start requests from userspace.

/*

 * Prevent security and firmware activate commands from being issued via

 * ioctl.

 block all non-nfit bus commands */

	/*

	 * Destruct under acpi_desc_lock so that nfit_handle_mce does not

	 * race teardown

	/*

	 * Bounce the nvdimm bus lock to make sure any in-flight

	 * acpi_nfit_ars_rescan() submissions have had a chance to

	 * either submit or see ->cancel set.

		/* The NVDIMM root device allows OS to trigger enumeration of

		 * NVDIMMs through NFIT at boot time and re-enumeration at

		 * root level via the _FIT method during runtime.

		 * This is ok to return 0 here, we could have an nvdimm

		 * hotplugged later and evaluate _FIT method which returns

		 * data in the format of a series of NFIT Structures.

 Save the acpi header for exporting the revision via sysfs */

 Evaluate _FIT and override with that if present */

 skip over the lead-in header table */

 see acpi_nfit_unregister */

 dev->driver may be null if we're being removed */

		/*

		 * Finish previous registration before considering new

		 * regions.

 Evaluate _FIT */

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2018 Intel Corporation. All rights reserved. */

	/*

	 * Short circuit the state retrieval while we are doing overwrite.

	 * The DSM spec states that the security state is indeterminate

	 * until the overwrite DSM completes.

 check and see if security is enabled and locked */

 DIMM unlocked, invalidate all CPU caches before we read it */

 flush all cache before we erase DIMM */

 DIMM erased, invalidate all CPU caches before we read it */

 flush all cache before we make the nvdimms available */

 flush all cache before we erase DIMM */

/*

 * TODO: define a cross arch wbinvd equivalent when/if

 * NVDIMM_FAMILY_INTEL command support arrives on another arch.

 The fw_ops expect to be called with the nvdimm_bus_lock() held */

	/*

	 * It should not be possible for platform firmware to return

	 * busy because activate is a synchronous operation. Treat it

	 * similar to invalid, i.e. always refresh / poll the status.

 check if capability needs to be refreshed */

 Refresh with platform firmware */

	/*

	 * Capability data is available in the same payload as state. It

	 * is expected to be static.

			/*

			 * Skip hibernate cycle by default if platform

			 * indicates that it does not need devices to be

			 * quiesced.

		/*

		 * Even though activate is run from a suspended context,

		 * for safety, still ask platform firmware to force

		 * quiesce devices by default. Let a module

		 * parameter override that policy.

	/*

	 * Whether the command succeeded, or failed, the agent checking

	 * for the result needs to query the DIMMs individually.

	 * Increment the activation count to invalidate all the DIMM

	 * states at once (it's otherwise not possible to take

	 * acpi_desc->init_mutex in this context)

	/*

	 * Similar to the bus state, since activate is synchronous the

	 * busy state should resolve within the context of 'activate'.

 If no activations occurred the old state is still valid */

	/*

	 * Invalidate the bus-level state, now that we're committed to

	 * changing the 'arm' state.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2019, Intel Corporation.

 *

 * Heterogeneous Memory Attributes Table (HMAT) representation

 *

 * This program parses and reports the platform's HMAT tables, and registers

 * the applicable attributes with the node's interfaces.

/*

 * The defined enum order is used to prioritize attributes to break ties when

 * selecting the best performing node.

	/*

	 * There are potentially multiple ranges per PXM, so record each

	 * in the per-target memregions resource tree.

	/*

	 * Check for invalid and overflow values

	/*

	 * Divide by the base unit for version 1, convert latency from

	 * picosenonds to nanoseconds if revision 2.

 If the node has a CPU, update access 1 */

	/*

	 * If the Address Range Structure provides a local processor pxm, link

	 * only that one. Otherwise, find the best performance attributes and

	 * register all initiators that match.

	/*

	 * We need the initiator list sorted so we can use bitmap_clear for

	 * previously set initiators when we find a better memory accessor.

	 * We'll also use the sorting to prime the candidate nodes with known

	 * initiators.

 Access 1 ignores Generic Initiators */

	/*

	 * Do not bother creating devices if no driver is available to

	 * consume them.

	/*

	 * Devices may belong to either an offline or online

	 * node, so unconditionally add them.

	/*

	 * Skip offline nodes. This can happen when memory

	 * marked EFI_MEMORY_SP, "specific purpose", is applied

	 * to all the memory in a proximity domain leading to

	 * the node being marked offline / unplugged, or if

	 * memory-only "hotplug" node is offline.

 Keep the table and structures if the notifier may use them */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  acpi_numa.c - ACPI NUMA support

 *

 *  Copyright (C) 2002 Takayoshi Kochi <t-kochi@bq.jp.nec.com>

 maps to convert between proximity domain and logical node ID */

			/*

			 * For pci devices this may be the only place they

			 * are assigned a proximity domain

			/*

			 * In this case we can rely on the device having a

			 * proximity domain reference

/*

 * A lot of BIOS fill in 10 (= no distance) everywhere. This messes

 * up the NUMA heuristics which wants the local node to have a smaller

 * distance than the others.

 * Do some quick checks here and only use the SLIT if it passes.

/*

 * Callback for SLIT parsing.  pxm_to_node() returns NUMA_NO_NODE for

 * I/O localities since SRAT does not list them.  I/O localities are

 * not supported at this point.

/*

 * Default callback for parsing of the Proximity Domain <-> Memory

 * Area mappings

 Mark hotplug range in memblock. */

 defined(CONFIG_X86) || defined (CONFIG_ARM64) */

 let architecture-dependent part to do it */

 let architecture-dependent part to do it */

 let architecture-dependent part to do it */

 defined(CONFIG_X86) || defined (CONFIG_ARM64) */

 let architecture-dependent part to do it */

 Real work done in acpi_table_parse_srat below. */

	/*

	 * Should not limit number with cpu num that is from NR_CPUS or nr_cpus=

	 * SRAT cpu entries could have different order with that in MADT.

	 * So go over all cpu entries in SRAT to get apicid to node mapping.

 SRAT: System Resource Affinity Table */

 SLIT: System Locality Information Table */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * apei-base.c - ACPI Platform Error Interface (APEI) supporting

 * infrastructure

 *

 * APEI allows to report errors (for example from the chipset) to the

 * the operating system. This improves NMI handling especially. In

 * addition it supports error serialization and error injection.

 *

 * For more information about APEI, please refer to ACPI Specification

 * version 4.0, chapter 17.

 *

 * This file has Common functions used by more than one APEI table,

 * including framework of interpreter for ERST and EINJ; resource

 * management for APEI registers.

 *

 * Copyright (C) 2009, Intel Corp.

 *	Author: Huang Ying <ying.huang@intel.com>

/*

 * APEI ERST (Error Record Serialization Table) and EINJ (Error

 * INJection) interpreter framework.

/*

 * Interpret the specified action. Go through whole action table,

 * execute all instructions belong to the action.

	/*

	 * "ip" is the instruction pointer of current instruction,

	 * "ctx->ip" specifies the next instruction to executed,

	 * instruction "run" function may change the "ctx->ip" to

	 * implement "goto" semantics.

/*

 * Pre-map all GARs in action table to make it possible to access them

 * in NMI handler.

 Post-unmap all GAR in action table. */

/*

 * Resource management for GARs in APEI

 Collect all resources requested, to avoid conflict */

/*

 * EINJ has two groups of GARs (EINJ table entry and trigger table

 * entry), so common resources are subtracted from the trigger table

 * resources before the second requesting.

/*

 * IO memory/port resource management mechanism is used to check

 * whether memory/port area used by GARs conflicts with normal memory

 * or IO memory/port of devices.

	/*

	 * Some firmware uses ACPI NVS region, that has been marked as

	 * busy, so exclude it from APEI resources to avoid false

	 * conflict.

 Fixup common BIOS bug */

 IO space doesn't need mapping */

 read GAR in interrupt (including NMI) or process context */

 write GAR in interrupt (including NMI) or process context */

/*

 * Same register may be used by multiple instructions in GARs, so

 * resources are collected before requesting.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * APEI Error Record Serialization Table support

 *

 * ERST is a way provided by APEI to save and retrieve hardware error

 * information to and from a persistent store.

 *

 * For more information about ERST, please refer to ACPI Specification

 * version 4.0, section 17.4.

 *

 * Copyright 2010 Intel Corp.

 *   Author: Huang Ying <ying.huang@intel.com>

 kvfree() */

 ERST command status */

 100ns */

 Firmware should respond within 1 milliseconds */

 50us */

 ERST Error Log Address Range attributes */

/*

 * ERST Error Log Address Range, used as buffer for reading/writing

 * error records.

/*

 * Prevent ERST interpreter to run simultaneously, because the

 * corresponding firmware implementation may not work properly when

 * invoked simultaneously.

 *

 * It is used to provide exclusive accessing for ERST Error Log

 * Address Range too.

 ioremap does not work in interrupt context */

 erst_record_id_cache.lock must be held by caller */

 can not skip current ID, or loop back to first ID */

 record id already in cache, try next */

/*

 * Get the record ID of an existing error record on the persistent

 * storage. If there is no error record on the persistent storage, the

 * returned record_id is APEI_ERST_INVALID_RECORD_ID.

 must be enclosed by erst_get_record_id_begin/end */

 found next record id in cache */

 Try to add one more record ID to cache */

 successfully add one new ID */

 erst_record_id_cache.lock must be held by caller */

	/*

	 * erst_disable != 0 should be detected by invoker via the

	 * return value of erst_get_record_id_begin/next, so this

	 * function should not be called for erst_disable != 0.

 NVRAM ERST Error Log Address Range is not supported yet */

 do not print message, because printk is not safe for NMI */

 signature for serialization system */

/*

 * If return value > buflen, the buffer size is not big enough,

 * else if return value < 0, something goes wrong,

 * else everything is OK, and return value is record length

 no more record */

 The record may be cleared by others, try read next record */

 timestamp valid. platform_id, partition_id are invalid */

 fru_id and fru_text is invalid */

 Cleanup ERST Resources */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * APEI Error INJection support

 *

 * EINJ provides a hardware error injection mechanism, this is useful

 * for debugging and testing of other APEI and RAS features.

 *

 * For more information about EINJ, please refer to ACPI Specification

 * version 4.0, section 17.5.

 *

 * Copyright 2009-2010 Intel Corp.

 *   Author: Huang Ying <ying.huang@intel.com>

 1ms */

 5ms */

 Firmware should respond within 1 seconds */

/*

 * ACPI version 5 provides a SET_ERROR_TYPE_WITH_ADDRESS action.

/*

 * Vendor extensions for platform specific operations

/*

 * Some BIOSes allow parameters to the SET_ERROR_TYPE entries in the

 * EINJ table through an unpublished extension. Use with caution as

 * most will ignore the parameter and make their own choice of address

 * for error injection.  This extension is used only if

 * param_extension module parameter is specified.

/*

 * Prevent EINJ interpreter to run simultaneously, because the

 * corresponding firmware implementation may not work properly when

 * invoked simultaneously.

 Get error injection capabilities of the platform */

 do sanity check to trigger table */

 Execute instructions in trigger error action table */

 No action structures in the TRIGGER_ERROR table, nothing to do */

	/*

	 * Some firmware will access target address specified in

	 * param1 to trigger the error when injecting memory error.

	 * This will cause resource conflict with regular memory.  So

	 * remove it from trigger table resources.

 Inject the specified hardware error */

 If user manually set "flags", make sure it is legal */

	/*

	 * We need extra sanity checks for memory errors.

	 * Other types leap directly to injection.

 ensure param1/param2 existed */

 ensure injection is memory related */

	/*

	 * Disallow crazy address masks that give BIOS leeway to pick

	 * injection address almost anywhere. Insist on page or

	 * better granularity and that target address is normal RAM or

	 * NVDIMM.

	/*

	 * Vendor defined types have 0x80000000 bit set, and

	 * are not enumerated by ACPI_EINJ_GET_ERROR_TYPE

 Only one error type can be specified */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * APEI Generic Hardware Error Source support

 *

 * Generic Hardware Error Source provides a way to report platform

 * hardware errors (such as that from chipset). It works in so called

 * "Firmware First" mode, that is, hardware errors are reported to

 * firmware firstly, then reported to Linux by firmware. This way,

 * some non-standard hardware error registers or non-standard hardware

 * link can be checked by firmware to produce more hardware error

 * information for Linux.

 *

 * For more information about Generic Hardware Error Source, please

 * refer to ACPI Specification version 4.0, section 17.3.2.6

 *

 * Copyright 2010,2011 Intel Corp.

 *   Author: Huang Ying <ying.huang@intel.com>

 This is just an estimation for memory pool allocation */

 Prevent too many caches are allocated because of RCU */

/*

 *  NMI-like notifications vary by architecture, before the compiler can prune

 *  unused static functions it needs a value for these enums.

/*

 * This driver isn't really modular, however for the time being,

 * continuing to use module_param is the easiest way to remain

 * compatible with existing boot arg use cases.

/*

 * All error sources notified with HED (Hardware Error Device) share a

 * single notifier callback, so they need to be linked and checked one

 * by one. This holds true for NMI too.

 *

 * RCU is used for these lists, so ghes_list_mutex is only used for

 * list changing, not for traversing.

/*

 * Because the memory area used to transfer hardware error information

 * from BIOS to Linux can be determined only in NMI, IRQ or timer

 * handler, but general ioremap can not be used in atomic context, so

 * the fixmap is used instead.

 *

 * This spinlock is used to prevent the fixmap entry from being used

 * simultaneously.

 Unknown, go panic */

 Check the top-level record header has an appropriate size. */

 Read the CPER block, returning its address, and header in estatus. */

	/*

	 * GHESv2 type HEST entries introduce support for error acknowledgment,

	 * so only acknowledge the error if this support is present.

/*

 * Called as task_work before returning to user-space.

 * Ensure any queued work has been done before we return to the context that

 * triggered the notification.

 iff following two events can be handled properly by now */

		/*

		 * The field (err_info->error_info & BIT(26)) is fixed to set to

		 * 1 in some old firmware of HiSilicon Kunpeng920. We assume that

		 * firmware won't mix corrected errors in an uncorrected section,

		 * and don't filter out 'corrected' error here.

/*

 * PCIe AER errors need to be sent to the AER driver for reporting and

 * recovery. The GHES severities map to the following AER severities and

 * require the following handling:

 *

 * GHES_SEV_CORRECTABLE -> AER_CORRECTABLE

 *     These need to be reported by the AER driver but no recovery is

 *     necessary.

 * GHES_SEV_RECOVERABLE -> AER_NONFATAL

 * GHES_SEV_RECOVERABLE && CPER_SEC_RESET -> AER_FATAL

 *     These both need to be reported and recovered from by the AER driver.

 * GHES_SEV_PANIC does not make it to this handling since the kernel must

 *     panic.

		/*

		 * If firmware reset the component to contain

		 * the error, we must reinitialize it before

		 * use, so treat it as a fatal AER error.

 Not more than 2 messages every 5 seconds */

/*

 * GHES error status reporting throttle, to report more kinds of

 * errors, instead of just most frequently occurred errors.

 new_cache must be put into array after its contents are written */

 reboot to log the error! */

/*

 * Handlers for CPER records may not be NMI safe. For example,

 * memory_failure_queue() takes spinlocks and calls schedule_work_on().

 * In any NMI-like handler, memory from ghes_estatus_pool is used to save

 * estatus, and added to the ghes_estatus_llist. irq_work_queue() causes

 * ghes_proc_in_irq() to run in IRQ context where each estatus in

 * ghes_estatus_llist is processed.

 *

 * Memory from the ghes_estatus_pool is also used with the ghes_estatus_cache

 * to suppress frequent messages.

	/*

	 * Because the time order of estatus in list is reversed,

	 * revert it back to proper order.

	/*

	 * Because the time order of estatus in list is reversed,

	 * revert it back to proper order.

 This error has been reported before, don't process it again. */

/*

 * Return 0 only if one of the SEA error sources successfully reported an error

 * record sent from the firmware.

 CONFIG_ACPI_APEI_SEA */

 CONFIG_ACPI_APEI_SEA */

/*

 * NMI may be triggered on any CPU, so ghes_in_nmi is used for

 * having only one concurrent reader.

	/*

	 * To synchronize with NMI handler, ghes can only be

	 * freed after NMI handler finishes.

 CONFIG_HAVE_ACPI_APEI_NMI */

 CONFIG_HAVE_ACPI_APEI_NMI */

 External interrupt vector is GSI */

 Handle any pending errors right away */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * APEI Error Record Serialization Table debug support

 *

 * ERST is a way provided by APEI to save and retrieve hardware error

 * information to and from a persistent store. This file provide the

 * debugging/testing support for ERST kernel support and firmware

 * implementation.

 *

 * Copyright 2010 Intel Corp.

 *   Author: Huang Ying <ying.huang@intel.com>

 Prevent erst_dbg_read/write from being invoked concurrently */

 no more record */

		/*

		 * If the persistent store is empty initially, the function

		 * 'erst_read' below will return "-ENOENT" value. This causes

		 * 'retry_next' label is entered again. The returned value

		 * should be zero indicating the read operation is EOF.

 The record may be cleared by others, try read next record */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * APEI Boot Error Record Table (BERT) support

 *

 * Copyright 2011 Intel Corp.

 *   Author: Huang Ying <ying.huang@intel.com>

 *

 * Under normal circumstances, when a hardware error occurs, the error

 * handler receives control and processes the error. This gives OSPM a

 * chance to process the error condition, report it, and optionally attempt

 * recovery. In some cases, the system is unable to process an error.

 * For example, system firmware or a management controller may choose to

 * reset the system or the system might experience an uncontrolled crash

 * or reset.The boot error source is used to report unhandled errors that

 * occurred in a previous boot. This mechanism is described in the BERT

 * table.

 *

 * For more information about BERT, please refer to ACPI Specification

 * version 4.0, section 17.3.1

 No more error records. */

		/*

		 * Because the boot error source is "one-time polled" type,

		 * clear Block Status of current Generic Error Status Block,

		 * once it's printed.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * APEI Hardware Error Source Table support

 *

 * HEST describes error sources in detail; communicates operational

 * parameters (i.e. severity levels, masking bits, and threshold

 * values) to Linux as necessary. It also allows the BIOS to report

 * non-standard error sources to Linux (for example, chipset-specific

 * error registers).

 *

 * For more information about HEST, please refer to ACPI Specification

 * version 4.0, section 17.3.2.

 *

 * Copyright 2009 Intel Corp.

 *   Author: Huang Ying <ying.huang@intel.com>

 HEST table parsing */

 need further calculation */

/*

 * Check if firmware advertises firmware first mode. We need FF bit to be set

 * along with a set of MC banks which work in FF mode.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * dptf_power:  DPTF platform power driver

 * Copyright (c) 2016, Intel Corporation.

/*

 * Presentation of attributes which are defined for INT3407 and INT3532.

 * They are:

 * PMAX : Maximum platform powe

 * PSRC : Platform power source

 * ARTG : Adapter rating

 * CTYP : Charger type

 * PBSS : Battery steady power

 * PROP : Rest of worst case platform Power

 * PBSS : Power Battery Steady State

 * PBSS : Power Battery Steady State

 * RBHF : High Frequency Impedance

 * VBNL : Instantaneous No-Load Voltage

 * CMPP : Current Discharge Capability

	/*

	 * Notify that an attribute is changed, so that user space can read

	 * again.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * dptf_pch_fivr:  DPTF PCH FIVR Participant driver

 * Copyright (c) 2020, Intel Corporation.

/*

 * Presentation of attributes which are defined for INT1045

 * They are:

 * freq_mhz_low_clock : Set PCH FIVR switching freq for

 *			FIVR clock 19.2MHz and 24MHz

 * freq_mhz_high_clock : Set PCH FIVR switching freq for

 *			FIVR clock 38.4MHz

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ACPI support for int340x thermal drivers

 *

 * Copyright (C) 2014, Intel Corporation

 * Authors: Zhang Rui <rui.zhang@intel.com>

 Intel SoC DTS thermal driver needs INT3401 to set IRQ descriptor */

 SPDX-License-Identifier: GPL-2.0-only

	/*

	 * If @dev is expected to be DMA-capable then the bus code that created

	 * it should have initialised its dma_mask pointer by this point. For

	 * now, we'll continue the legacy behaviour of coercing it to the

	 * coherent mask if not, but we'll no longer do so quietly.

		/*

		 * Limit coherent and dma mask based on size retrieved from

		 * firmware.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ARM Specific GTDT table Support

 *

 * Copyright (C) 2016, Linaro Ltd.

 * Author: Daniel Lezcano <daniel.lezcano@linaro.org>

 *         Fu Wei <fu.wei@linaro.org>

 *         Hanjun Guo <hanjun.guo@linaro.org>

/**

 * struct acpi_gtdt_descriptor - Store the key info of GTDT for all functions

 * @gtdt:	The pointer to the struct acpi_table_gtdt of GTDT table.

 * @gtdt_end:	The pointer to the end of GTDT table.

 * @platform_timer:	The pointer to the start of Platform Timer Structure

 *

 * The struct store the key info of GTDT table, it should be initialized by

 * acpi_gtdt_init.

/**

 * acpi_gtdt_map_ppi() - Map the PPIs of per-cpu arch_timer.

 * @type:	the type of PPI.

 *

 * Note: Secure state is not managed by the kernel on ARM64 systems.

 * So we only handle the non-secure timer PPIs,

 * ARCH_TIMER_PHYS_SECURE_PPI is treated as invalid type.

 *

 * Return: the mapped PPI value, 0 if error.

/**

 * acpi_gtdt_c3stop() - Got c3stop info from GTDT according to the type of PPI.

 * @type:	the type of PPI.

 *

 * Return: true if the timer HW state is lost when a CPU enters an idle state,

 * false otherwise

/**

 * acpi_gtdt_init() - Get the info of GTDT table to prepare for further init.

 * @table:			The pointer to GTDT table.

 * @platform_timer_count:	It points to a integer variable which is used

 *				for storing the number of platform timers.

 *				This pointer could be NULL, if the caller

 *				doesn't need this info.

 *

 * Return: 0 if success, -EINVAL if error.

	/*

	 * The CNTCTLBase frame is 4KB (register offsets 0x000 - 0xFFC).

	 * See ARM DDI 0487A.k_iss10775, page I1-5129, Table I1-3

	 * "CNTCTLBase memory map".

	/*

	 * Get the GT timer Frame data for every GT Block Timer

 duplicate frame */

		/*

		 * The CNTBaseN frame is 4KB (register offsets 0x000 - 0xFFC).

		 * See ARM DDI 0487A.k_iss10775, page I1-5130, Table I1-4

		 * "CNTBaseN memory map".

/**

 * acpi_arch_timer_mem_init() - Get the info of all GT blocks in GTDT table.

 * @timer_mem:	The pointer to the array of struct arch_timer_mem for returning

 *		the result of parsing. The element number of this array should

 *		be platform_timer_count(the total number of platform timers).

 * @timer_count: It points to a integer variable which is used for storing the

 *		number of GT blocks we have parsed.

 *

 * Return: 0 if success, -EINVAL/-ENODEV if error.

/*

 * Initialize a SBSA generic Watchdog platform device info from GTDT

	/*

	 * According to SBSA specification the size of refresh and control

	 * frames of SBSA Generic Watchdog is SZ_4K(Offset 0x000  0xFFF).

	/*

	 * Add a platform device named "sbsa-gwdt" to match the platform driver.

	 * "sbsa-gwdt": SBSA(Server Base System Architecture) Generic Watchdog

	 * The platform driver can get device info below by matching this name.

	/*

	 * Note: Even though the global variable acpi_gtdt_desc has been

	 * initialized by acpi_gtdt_init() while initializing the arch timers,

	 * when we call this function to get SBSA watchdogs info from GTDT, the

	 * pointers stashed in it are stale (since they are early temporary

	 * mappings carried out before acpi_permanent_mmap is set) and we need

	 * to re-initialize them with permanent mapped pointer values to let the

	 * GTDT parsing possible.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2016, Semihalf

 *	Author: Tomasz Nowicki <tn@semihalf.com>

 *

 * This file implements early detection/parsing of I/O mapping

 * reported to OS through firmware via I/O Remapping Table (IORT)

 * IORT document number: ARM DEN 0049A

/**

 * iort_set_fwnode() - Create iort_fwnode and use it to register

 *		       iommu data in the iort_fwnode_list

 *

 * @iort_node: IORT table node associated with the IOMMU

 * @fwnode: fwnode associated with the IORT node

 *

 * Returns: 0 on success

 *          <0 on failure

/**

 * iort_get_fwnode() - Retrieve fwnode associated with an IORT node

 *

 * @node: IORT table node to be looked-up

 *

 * Returns: fwnode_handle pointer on success, NULL on failure

/**

 * iort_delete_fwnode() - Delete fwnode associated with an IORT node

 *

 * @node: IORT table node associated with fwnode to delete

/**

 * iort_get_iort_node() - Retrieve iort_node associated with an fwnode

 *

 * @fwnode: fwnode associated with device to be looked-up

 *

 * Returns: iort_node pointer on success, NULL on failure

 Root pointer to the mapped IORT table */

/**

 * iort_register_domain_token() - register domain token along with related

 * ITS ID and base address to the list from where we can get it back later on.

 * @trans_id: ITS ID.

 * @base: ITS base address.

 * @fw_node: Domain token.

 *

 * Returns: 0 on success, -ENOMEM if no memory when allocating list element

/**

 * iort_deregister_domain_token() - Deregister domain token based on ITS ID

 * @trans_id: ITS ID.

 *

 * Returns: none.

/**

 * iort_find_domain_token() - Find domain token based on given ITS ID

 * @trans_id: ITS ID.

 *

 * Returns: domain token when find on the list, NULL otherwise

 Get the first IORT node */

		/*

		 * Walk the device tree to find a device with an

		 * ACPI companion; there is no point in scanning

		 * IORT for a device matching a named component if

		 * the device does not have an ACPI companion to

		 * start with.

		/*

		 * It is assumed that PCI segment numbers maps one-to-one

		 * with root complexes. Each segment number can represent only

		 * one root complex.

 Single mapping does not care for input id */

		/*

		 * We already found a mapping for this input ID at the end of

		 * another region. If it coincides with the start of this

		 * region, we assume the prior match was due to the off-by-1

		 * issue mentioned below, and allow it to be superseded.

		 * Otherwise, things are *really* broken, and we just disregard

		 * duplicate matches entirely to retain compatibility.

	/*

	 * Due to confusion regarding the meaning of the id_count field (which

	 * carries the number of IDs *minus 1*), we may have to disregard this

	 * match if it is at the end of the range, and overlaps with the start

	 * of another one.

 Firmware bug! */

		/*

		 * SMMUv3 dev ID mapping index was introduced in revision 1

		 * table, not available in revision 0

		/*

		 * ID mapping index is only ignored if all interrupts are

		 * GSIV based

 Parse the ID mapping tree to find specified node type */

 Firmware bug! */

		/*

		 * Get the special ID mapping index (if any) and skip its

		 * associated ID map to prevent erroneous multi-stage

		 * IORT ID translations.

 Do the ID translation */

 if it is special mapping index, skip it */

 Map input ID to output ID unchanged on mapping failure */

 step 1: retrieve the initial dev id */

	/*

	 * optional step 2: map the initial dev id if its parent is not

	 * the target type we want, map it again for the use cases such

	 * as NC (named component) -> SMMU -> ITS. If the type is matched,

	 * return the initial dev id and its parent pointer directly.

		/*

		 * scan iort_fwnode_list to see if it's an iort platform

		 * device (such as SMMU, PMCG),its iort node already cached

		 * and associated with fwnode when iort platform devices

		 * were initialized.

		/*

		 * if not, then it should be a platform device defined in

		 * DSDT/SSDT (with Named Component node in IORT)

/**

 * iort_msi_map_id() - Map a MSI input ID for a device

 * @dev: The device for which the mapping is to be done.

 * @input_id: The device input ID.

 *

 * Returns: mapped MSI ID on success, input ID otherwise

/**

 * iort_pmsi_get_dev_id() - Get the device id for a device

 * @dev: The device for which the mapping is to be done.

 * @dev_id: The device ID found.

 *

 * Returns: 0 for successful find a dev id, -ENODEV on error

 if there is a valid index, go get the dev_id directly */

/**

 * iort_dev_find_its_id() - Find the ITS identifier for a device

 * @dev: The device.

 * @id: Device's ID

 * @idx: Index of the ITS identifier list.

 * @its_id: ITS identifier.

 *

 * Returns: 0 on success, appropriate error value otherwise

 Move to ITS specific data */

/**

 * iort_get_device_domain() - Find MSI domain related to a device

 * @dev: The device.

 * @id: Requester ID for the device.

 * @bus_token: irq domain bus token.

 *

 * Returns: the MSI domain for this device, NULL otherwise

 Firmware bug! */

 Move to ITS specific data */

/**

 * iort_get_platform_device_domain() - Find MSI domain related to a

 * platform device

 * @dev: the dev pointer associated with the platform device

 *

 * Returns: the MSI domain for this device, NULL otherwise

 find its associated iort node */

 then find its msi parent node */

 Move to ITS specific data */

/**

 * iort_iommu_msi_get_resv_regions - Reserved region driver helper

 * @dev: Device from iommu_get_resv_regions()

 * @head: Reserved region list from iommu_get_resv_regions()

 *

 * Returns: Number of msi reserved regions on success (0 if platform

 *          doesn't require the reservation or no associated msi regions),

 *          appropriate error value otherwise. The ITS interrupt translation

 *          spaces (ITS_base + SZ_64K, SZ_64K) associated with the device

 *          are the msi reserved regions.

	/*

	 * Current logic to reserve ITS regions relies on HW topologies

	 * where a given PCI or named component maps its IDs to only one

	 * ITS group; if a PCI or named component can map its IDs to

	 * different ITS groups through IORT mappings this function has

	 * to be reworked to ensure we reserve regions for all ITS groups

	 * a given PCI or named component may map IDs to.

 Move to ITS specific data */

	/*

	 * If the ops look-up fails, this means that either

	 * the SMMU drivers have not been probed yet or that

	 * the SMMU drivers are not built in the kernel;

	 * Depending on whether the SMMU drivers are built-in

	 * in the kernel or not, defer the IOMMU configuration

	 * or just abort it.

/**

 * iort_iommu_configure_id - Set-up IOMMU configuration for a device.

 *

 * @dev: device to configure

 * @id_in: optional input id const value pointer

 *

 * Returns: 0 on success, <0 on failure

/**

 * iort_dma_get_ranges() - Look up DMA addressing limit for the device

 * @dev: device to lookup

 * @size: DMA range size result pointer

 *

 * Return: 0 on success, an error otherwise.

 Always present mem resource */

 Retrieve SMMUv3 specific data */

	/*

	 * Cavium ThunderX2 implementation doesn't not support unique

	 * irq line. Use single irq line for all the SMMUv3 interrupts.

	/*

	 * ThunderX2 doesn't support MSIs from the SMMU, so we're checking

	 * SPI numbers here.

	/*

	 * Override the size, for Cavium ThunderX2 implementation

	 * which doesn't support the page 1 SMMU register space.

 Retrieve SMMUv3 specific data */

 Retrieve SMMUv3 specific data */

 We expect the dma masks to be equivalent for all SMMUv3 set-ups */

 Configure DMA for the page table walker */

/*

 * set numa proximity domain for smmuv3 device

 Retrieve SMMU specific data */

	/*

	 * Only consider the global fault interrupt and ignore the

	 * configuration access interrupt.

	 *

	 * MMIO address and global fault interrupt resources are always

	 * present so add them to the context interrupt count as a static

	 * value.

 Retrieve SMMU specific data */

 Global IRQs */

 Context IRQs */

 Retrieve SMMU specific data */

 We expect the dma masks to be equivalent for SMMU set-ups */

 Configure DMA for the page table walker */

 Retrieve PMCG specific data */

	/*

	 * There are always 2 memory resources.

	 * If the overflow_gsiv is present then add that for a total of 3.

 Retrieve PMCG specific data */

 HiSilicon Hip08 Platform */

/**

 * iort_add_platform_device() - Allocate a platform device for IORT node

 * @node: Pointer to device ACPI IORT node

 * @ops: Pointer to IORT device config struct

 *

 * Returns: 0 on success, <0 failure

	/*

	 * Resources are duplicated in platform_device_add_resources,

	 * free their allocated memory

	/*

	 * Platform devices based on PMCG nodes uses platform_data to

	 * pass the hardware model info to the driver. For others, add

	 * a copy of IORT node pointer to platform_data to be used to

	 * retrieve IORT data information.

			/*

			 * If we detect a RC->SMMU mapping, make sure

			 * we enable ACS on the system.

	/*

	 * iort_table and iort both point to the start of IORT table, but

	 * have different struct types

 Get the first IORT node */

	/* iort_table will be used at runtime after the iort init,

	 * so we don't need to call acpi_put_table() to release

	 * the IORT table mapping.

/*

 * Extract the highest CPU physical address accessible to all DMA masters in

 * the system. PHYS_ADDR_MAX is returned when no constrained device is found.

 SPDX-License-Identifier: GPL-2.0

/*

 * Dollar Cove TI PMIC operation region driver

 * Copyright (C) 2014 Intel Corporation. All rights reserved.

 *

 * Rewritten and cleaned up

 * Copyright (C) 2017 Takashi Iwai <tiwai@suse.de>

 registers stored in 16bit BE (high:low, total 10bit) */

 TMP2 -> SYSTEMP */

 TMP3 -> BPTHERM */

 TMP5 -> DIETEMP */

 stored in big-endian */

 Re-enumerate devices depending on PMIC */

 SPDX-License-Identifier: GPL-2.0

/*

 * TI TPS68470 PMIC operation region driver

 *

 * Copyright (C) 2017 Intel Corporation. All rights reserved.

 *

 * Author: Rajmohan Mani <rajmohan.mani@intel.com>

 *

 * Based on drivers/acpi/pmic/intel_pmic* drivers

 operation region address */

 corresponding register */

 bit mask for power, clock */

 S_I2C_CTL */

 VCMCTL */

 VAUX1_CTL */

 VAUX2CTL */

 VACTL */

 VDCTL */

 Table to set voltage regulator value */

 TPS68470_REG_VSIOVAL */

 TPS68470_REG_VIOVAL */

 TPS68470_REG_VCMVAL */

 TPS68470_REG_VAUX1VAL */

 TPS68470_REG_VAUX2VAL */

 TPS68470_REG_VAVAL */

 TPS68470_REG_VDVAL */

 Table to configure clock frequency */

 TPS68470_REG_POSTDIV2 */

 TPS68470_REG_BOOSTDIV */

 TPS68470_REG_BUCKDIV */

 TPS68470_REG_PLLSWR */

 TPS68470_REG_XTALDIV */

 TPS68470_REG_PLLDIV */

 TPS68470_REG_POSTDIV */

 Table to configure and enable clocks */

 TPS68470_REG_PLLCTL */

 TPS68470_REG_PLLCTL2 */

 TPS68470_REG_CLKCFG1 */

 TPS68470_REG_CLKCFG2 */

 set/clear for bit 0, bits 0 and 1 together */

 SPDX-License-Identifier: GPL-2.0

/*

 * XPower AXP288 PMIC operation region driver

 *

 * Copyright (C) 2014 Intel Corporation. All rights reserved.

 ALD1 */

 ALD2 */

 ALD3 */

 DLD1 */

 DLD2 */

 DLD3 */

 DLD4 */

 ELD1 */

 ELD2 */

 ELD3 */

 FLD1 */

 FLD2 */

 FLD3 */

 BUC1 */

 BUC2 */

 BUC3 */

 BUC4 */

 BUC5 */

 BUC6 */

 GPI1 */

 TMP0 - TMP5 are the same, all from GPADC */

 GPIO1 LDO regulator needs special handling */

 GPIO1 LDO regulator needs special handling */

/**

 * intel_xpower_pmic_get_raw_temp(): Get raw temperature reading from the PMIC

 *

 * @regmap: regmap of the PMIC device

 * @reg: register to get the reading

 *

 * Return a positive value on success, errno on failure.

	/*

	 * The current-source used for the battery temp-sensor (TS) is shared

	 * with the GPADC. For proper fuel-gauge and charger operation the TS

	 * current-source needs to be permanently on. But to read the GPADC we

	 * need to temporary switch the TS current-source to ondemand, so that

	 * the GPADC can use it, otherwise we will always read an all 0 value.

	 *

	 * Note that the switching from on to on-ondemand is not necessary

	 * when the TS current-source is off (this happens on devices which

	 * do not use the TS-pin).

		/*

		 * AXP288_ADC_TS_PIN_CTRL reads are cached by the regmap, so

		 * this does to a single I2C-transfer, and thus there is no

		 * need to explicitly call iosf_mbi_block_punit_i2c_access().

 Wait a bit after switching the current-source */

 SPDX-License-Identifier: GPL-2.0

/*

 * Intel Cherry Trail Crystal Cove PMIC operation region driver

 *

 * Copyright (C) 2019 Hans de Goede <hdegoede@redhat.com>

/*

 * We have no docs for the CHT Crystal Cove PMIC. The Asus Zenfone-2 kernel

 * code has 2 Crystal Cove regulator drivers, one calls the PMIC a "Crystal

 * Cove Plus" PMIC and talks about Cherry Trail, so presumably that one

 * could be used to get register info for the regulators if we need to

 * implement regulator support in the future.

 *

 * For now the sole purpose of this driver is to make

 * intel_soc_pmic_exec_mipi_pmic_seq_element work on devices with a

 * CHT Crystal Cove PMIC.

 SPDX-License-Identifier: GPL-2.0

/*

 * Intel BXT WhiskeyCove PMIC operation region driver

 *

 * Copyright (C) 2015 Intel Corporation. All rights reserved.

 VDD1 -> VDD1CNT */

 VDD2 -> VDD2CNT */

 VDD3 -> VDD3CNT */

 VLFX -> VFLEXCNT */

 VP1A -> VPROG1ACNT */

 VP1B -> VPROG1BCNT */

 VP1C -> VPROG1CCNT */

 VP1D -> VPROG1DCNT */

 VP2A -> VPROG2ACNT */

 VP2B -> VPROG2BCNT */

 VP2C -> VPROG2CCNT */

 VP3A -> VPROG3ACNT */

 VP3B -> VPROG3BCNT */

 VSW2 -> VLD0CNT Bit 5*/

 VSW1 -> VLD0CNT Bit 4 */

 VUPY -> VLDOCNT Bit 1 */

 VRSO -> VREFSOCCNT*/

 VP1E -> VPROG1ECNT */

 VP1F -> VPROG1FCNT */

 VP2D -> VPROG2DCNT */

 VP4A -> VPROG4ACNT */

 VP4B -> VPROG4BCNT */

 VP4C -> VPROG4CCNT */

 VP4D -> VPROG4DCNT */

 VP5A -> VPROG5ACNT */

 VP5B -> VPROG5BCNT */

 VP6A -> VPROG6ACNT */

 VP6B -> VPROG6BCNT */

 SDWN_N -> MODEMCTRL Bit 2 */

 MOFF -> MODEMCTRL Bit 0 */

 SPDX-License-Identifier: GPL-2.0

/*

 * Intel CHT Whiskey Cove PMIC operation region driver

 * Copyright (C) 2017 Hans de Goede <hdegoede@redhat.com>

 *

 * Based on various non upstream patches to support the CHT Whiskey Cove PMIC:

 * Copyright (C) 2013-2015 Intel Corporation. All rights reserved.

/*

 * Regulator support is based on the non upstream patch:

 * "regulator: whiskey_cove: implements Whiskey Cove pmic VRF support"

 * https://github.com/intel-aero/meta-intel-aero/blob/master/recipes-kernel/linux/linux-yocto/0019-regulator-whiskey_cove-implements-WhiskeyCove-pmic-V.patch

 V18A */

 V18X */

 VDDQ */

 V12A */

 V12X */

 V28X */

 V33A */

 V3SD */

 VSD */

/*	{

		.address = 0x24,

		.reg = ??,

		.bit = ??,

/*	{

		.address = 0x28,

		.reg = ??,

		.bit = ??,

/*	{

		.address = 0x2c,

		.reg = ??,

		.bit = ??,

/*	{

		.address = 0x30,

		.reg = ??,

		.bit = ??,

 VP1A */

 VP1B */

 VP1F */

 VP2D */

 VP3A */

 VP3B */

 VP4A */

 VP4B */

 VP4C */

 VP4D */

 VP5A */

 VP5B */

 VP6A */

 VP6B */

/*	{

		.address = 0x6c,

		.reg = ??,

		.bit = ??,

/*

 * The thermal table and ops are empty, we do not support the Thermal opregion

 * (DPTF) due to lacking documentation.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * intel_pmic.c - Intel PMIC operation region driver

 *

 * Copyright (C) 2014 Intel Corporation. All rights reserved.

/**

 * intel_soc_pmic_exec_mipi_pmic_seq_element - Execute PMIC MIPI sequence

 * @i2c_address:  I2C client address for the PMIC

 * @reg_address:  PMIC register address

 * @value:        New value for the register bits to change

 * @mask:         Mask indicating which register bits to change

 *

 * DSI LCD panels describe an initialization sequence in the i915 VBT (Video

 * BIOS Tables) using so called MIPI sequences. One possible element in these

 * sequences is a PMIC specific element of 15 bytes.

 *

 * This function executes these PMIC specific elements sending the embedded

 * commands to the PMIC.

 *

 * Return 0 on success, < 0 on failure.

 SPDX-License-Identifier: GPL-2.0

/*

 * Intel Bay Trail Crystal Cove PMIC operation region driver

 *

 * Copyright (C) 2014 Intel Corporation. All rights reserved.

/*	{

		.address = 0x00,

		.reg = ??,

		.bit = ??,

 SYSX -> VSYS_SX */

 SYSU -> VSYS_U */

 SYSS -> VSYS_S */

 V50S -> V5P0S */

 HOST -> VHOST, USB2/3 host */

 VBUS -> VBUS, USB2/3 OTG */

 HDMI -> VHDMI */

/*	{

		.address = 0x20,

		.reg = ??,

		.bit = ??,

 X285 -> V2P85SX, camera */

/*	{

		.address = 0x28,

		.reg = ??,

		.bit = ??,

 V33S -> V3P3S, display/ssd/audio */

 V33U -> V3P3U, SDIO wifi&bt */

/*	{

		.address = 0x34 .. 0x40,

		.reg = ??,

		.bit = ??,

 V18S -> V1P8S, SOC/USB PHY/SIM */

 V18X -> V1P8SX, eMMC/camara/audio */

 V18U -> V1P8U, LPDDR */

 V12X -> V1P2SX, SOC SFR */

 V12S -> V1P2S, MIPI */

/*	{

		.address = 0x58,

		.reg = ??,

		.bit = ??,

 V10S -> V1P0S, SOC GFX */

 V10X -> V1P0SX, SOC display/DDR IO/PCIe */

 V105 -> V1P05S, L2 SRAM */

	/*

	 * Raw temperature value is 10bits: 8bits in reg

	 * and 2bits in reg-1: bit0,1

 Update to policy enable bit requires unlocking a0lock */

 restore alert0 */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: dswload - Dispatcher first pass namespace load callbacks

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_init_callbacks

 *

 * PARAMETERS:  walk_state      - Current state of the parse tree walk

 *              pass_number     - 1, 2, or 3

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Init walk state callbacks

 *

 Parse only - caller will setup callbacks */

 Load pass 1 */

 Load pass 2 */

 Execution pass */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_load1_begin_op

 *

 * PARAMETERS:  walk_state      - Current state of the parse tree walk

 *              out_op          - Where to return op if a new one is created

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Descending callback used during the loading of ACPI tables.

 *

 We are only interested in opcodes that have an associated name */

 Check if this object has already been installed in the namespace */

 Map the raw opcode into an internal object type */

		/*

		 * The target name of the Scope() operator must exist at this point so

		 * that we can actually open the scope to enter new names underneath it.

		 * Allow search-to-root for single namesegs.

			/*

			 * Table disassembly:

			 * Target of Scope() not found. Generate an External for it, and

			 * insert the name into the namespace.

		/*

		 * Check to make sure that the target is

		 * one of the opcodes that actually opens a scope

 Scope  */

 These are acceptable types */

			/*

			 * These types we will allow, but we will change the type.

			 * This enables some existing code of the form:

			 *

			 *  Name (DEB, 0)

			 *  Scope (DEB) { ... }

			 *

			 * Note: silently change the type here. On the second pass,

			 * we will report a warning

			/*

			 * Allow scope change to root during execution of module-level

			 * code. Root is typed METHOD during this time.

 All other types are an error */

		/*

		 * For all other named opcodes, we will enter the name into

		 * the namespace.

		 *

		 * Setup the search flags.

		 * Since we are entering a name into the namespace, we do not want to

		 * enable the search-to-root upsearch.

		 *

		 * There are only two conditions where it is acceptable that the name

		 * already exists:

		 *    1) the Scope() operator can reopen a scoping object that was

		 *       previously defined (Scope, Method, Device, etc.)

		 *    2) Whenever we are parsing a deferred opcode (op_region, Buffer,

		 *       buffer_field, or Package), the name of the object is already

		 *       in the namespace.

 This name is already in the namespace, get the node */

		/*

		 * If we are executing a method, do not create any namespace objects

		 * during the load phase, only during execution.

		/*

		 * Enter the named type into the internal namespace. We enter the name

		 * as we go downward in the parse tree. Any necessary subobjects that

		 * involve arguments to the opcode must be created as we go back up the

		 * parse tree later.

 The name already exists in this scope */

					/*

					 * Allow one create on an object or segment that was

					 * previously declared External

 Just retyped a node, probably will need to open a scope */

 Common exit */

 Create a new op */

 Initialize the op */

		/*

		 * Put the Node in the "op" object that the parser uses, so we

		 * can get it again quickly when this scope is closed

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_load1_end_op

 *

 * PARAMETERS:  walk_state      - Current state of the parse tree walk

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Ascending callback used during the loading of the namespace,

 *              both control methods and everything else.

 *

	/*

	 * Disassembler: handle create field operators here.

	 *

	 * create_buffer_field is a deferred op that is typically processed in load

	 * pass 2. However, disassembly of control method contents walk the parse

	 * tree with ACPI_PARSE_LOAD_PASS1 and AML_CREATE operators are processed

	 * in a later walk. This is a problem when there is a control method that

	 * has the same name as the AML_CREATE object. In this case, any use of the

	 * name segment will be detected as a method call rather than a reference

	 * to a buffer field.

	 *

	 * This earlier creation during disassembly solves this issue by inserting

	 * the named object in the ACPI namespace so that references to this name

	 * would be a name string rather than a method call.

 We are only interested in opcodes that have an associated name */

 Get the object type to determine if we should pop the scope */

		/*

		 * If we are executing a method, do not create any namespace objects

		 * during the load phase, only during execution.

	/*

	 * If we are executing a method, do not create any namespace objects

	 * during the load phase, only during execution.

 For Name opcode, get the object type from the argument */

 Set node type if we have a namespace node */

	/*

	 * For external opcode, get the object type from the argument and

	 * get the parameter count from the argument's next.

		/*

		 * Note, if this external is not a method

		 * Op->Common.Value.Arg->Common.Next->Common.Value.Integer == 0

		 * Therefore, param_count will be 0.

		/*

		 * Add the external to the external list because we may be

		 * emitting code based off of the items within the external list.

	/*

	 * If we are executing a method, do not create any namespace objects

	 * during the load phase, only during execution.

			/*

			 * method_op pkg_length name_string method_flags term_list

			 *

			 * Note: We must create the method node/object pair as soon as we

			 * see the method declaration. This allows later pass1 parsing

			 * of invocations of the method (need to know the number of

			 * arguments.)

 Pop the scope stack (only if loading a table) */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: pstree - Parser op tree manipulation/traversal/search

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_get_arg

 *

 * PARAMETERS:  op              - Get an argument for this op

 *              argn            - Nth argument to get

 *

 * RETURN:      The argument (as an Op object). NULL if argument does not exist

 *

 * DESCRIPTION: Get the specified op's argument.

 *

/*

	if (Op->Common.aml_opcode == AML_INT_CONNECTION_OP)

	{

		return (Op->Common.Value.Arg);

	}

 Get the info structure for this opcode */

 Invalid opcode or ASCII character */

 Check if this opcode requires argument sub-objects */

 Has no linked argument objects */

 Get the requested argument object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_append_arg

 *

 * PARAMETERS:  op              - Append an argument to this Op.

 *              arg             - Argument Op to append

 *

 * RETURN:      None.

 *

 * DESCRIPTION: Append an argument to an op's argument list (a NULL arg is OK)

 *

 Get the info structure for this opcode */

 Invalid opcode */

 Check if this opcode requires argument sub-objects */

 Has no linked argument objects */

 Append the argument to the linked argument list */

 Append to existing argument list */

 No argument list, this will be the first argument */

 Set the parent in this arg and any args linked after it */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_get_depth_next

 *

 * PARAMETERS:  origin          - Root of subtree to search

 *              op              - Last (previous) Op that was found

 *

 * RETURN:      Next Op found in the search.

 *

 * DESCRIPTION: Get next op in tree (walking the tree in depth-first order)

 *              Return NULL when reaching "origin" or when walking up from root

 *

 Look for an argument or child */

 Look for a sibling */

 Look for a sibling of parent */

 Reached parent of origin, end search */

 Found sibling of parent */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_get_child

 *

 * PARAMETERS:  op              - Get the child of this Op

 *

 * RETURN:      Child Op, Null if none is found.

 *

 * DESCRIPTION: Get op's children or NULL if none

 *

 All others have no children */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: pswalk - Parser routines to walk parsed op tree(s)

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_delete_parse_tree

 *

 * PARAMETERS:  subtree_root        - Root of tree (or subtree) to delete

 *

 * RETURN:      None

 *

 * DESCRIPTION: Delete a portion of or an entire parse tree.

 *

 Visit all nodes in the subtree */

 This is the descending case */

 This debug option will print the entire parse tree */

 Look for an argument or child of the current op */

 Still going downward in tree (Op is not completed yet) */

 No more children, this Op is complete. */

 If we are back to the starting point, the walk is complete. */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: evevent - Fixed Event handling and dispatch

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Entire module */

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_initialize_events

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Initialize global data structures for ACPI events (Fixed, GPE)

 *

 If Hardware Reduced flag is set, there are no fixed events */

	/*

	 * Initialize the Fixed and General Purpose Events. This is done prior to

	 * enabling SCIs to prevent interrupts from occurring before the handlers

	 * are installed.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_install_xrupt_handlers

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Install interrupt handlers for the SCI and Global Lock

 *

 If Hardware Reduced flag is set, there is no ACPI h/w */

 Install the SCI handler */

 Install the handler for the Global Lock */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_fixed_event_initialize

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Install the fixed event handlers and disable all fixed events.

 *

	/*

	 * Initialize the structure that keeps track of fixed event handlers and

	 * disable all of the fixed events.

 Disable the fixed event */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_fixed_event_detect

 *

 * PARAMETERS:  None

 *

 * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED

 *

 * DESCRIPTION: Checks the PM status register for active fixed events

 *

	/*

	 * Read the fixed feature status and enable registers, as all the cases

	 * depend on their values. Ignore errors here.

	/*

	 * Check for all possible Fixed Events and dispatch those that are active

 Both the status and enable bits must be on for this event */

			/*

			 * Found an active (signalled) event. Invoke global event

			 * handler if present.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_fixed_event_dispatch

 *

 * PARAMETERS:  event               - Event type

 *

 * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED

 *

 * DESCRIPTION: Clears the status bit for the requested event, calls the

 *              handler that previously registered for the event.

 *              NOTE: If there is no handler for the event, the event is

 *              disabled to prevent further interrupts.

 *

 Clear the status bit */

	/*

	 * Make sure that a handler exists. If not, report an error

	 * and disable the event to prevent further interrupts.

 Invoke the Fixed Event handler */

/*******************************************************************************

 *

 * FUNCTION:    acpi_any_fixed_event_status_set

 *

 * PARAMETERS:  None

 *

 * RETURN:      TRUE or FALSE

 *

 * DESCRIPTION: Checks the PM status register for active fixed events

 *

	/*

	 * Check for all possible Fixed Events and dispatch those that are active

 Both the status and enable bits must be on for this event */

 !ACPI_REDUCED_HARDWARE */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: dbhistry - debugger HISTORY command

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_add_to_history

 *

 * PARAMETERS:  command_line    - Command to add

 *

 * RETURN:      None

 *

 * DESCRIPTION: Add a command line to the history buffer.

 *

 Put command into the next available slot */

 Adjust indexes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_history

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display the contents of the history buffer

 *

 Dump entire history buffer */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_get_from_history

 *

 * PARAMETERS:  command_num_arg         - String containing the number of the

 *                                        command to be retrieved

 *

 * RETURN:      Pointer to the retrieved command. Null on error.

 *

 * DESCRIPTION: Get a command from the history buffer

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_get_history_by_index

 *

 * PARAMETERS:  cmd_num             - Index of the desired history entry.

 *                                    Values are 0...(acpi_gbl_next_cmd_num - 1)

 *

 * RETURN:      Pointer to the retrieved command. Null on error.

 *

 * DESCRIPTION: Get a command from the history buffer

 *

 Search history buffer */

 Found the command, return it */

 History buffer is circular */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: rsinfo - Dispatch and Info tables

 *

/*

 * Resource dispatch and information tables. Any new resource types (either

 * Large or Small) must be reflected in each of these tables, so they are here

 * in one place.

 *

 * The tables for Large descriptors are indexed by bits 6:0 of the AML

 * descriptor type byte. The tables for Small descriptors are indexed by

 * bits 6:3 of the descriptor byte. The tables for internal resource

 * descriptors are indexed by the acpi_resource_type field.

 Dispatch table for resource-to-AML (Set Resource) conversion functions */

 0x00, ACPI_RESOURCE_TYPE_IRQ */

 0x01, ACPI_RESOURCE_TYPE_DMA */

 0x02, ACPI_RESOURCE_TYPE_START_DEPENDENT */

 0x03, ACPI_RESOURCE_TYPE_END_DEPENDENT */

 0x04, ACPI_RESOURCE_TYPE_IO */

 0x05, ACPI_RESOURCE_TYPE_FIXED_IO */

 0x06, ACPI_RESOURCE_TYPE_VENDOR */

 0x07, ACPI_RESOURCE_TYPE_END_TAG */

 0x08, ACPI_RESOURCE_TYPE_MEMORY24 */

 0x09, ACPI_RESOURCE_TYPE_MEMORY32 */

 0x0A, ACPI_RESOURCE_TYPE_FIXED_MEMORY32 */

 0x0B, ACPI_RESOURCE_TYPE_ADDRESS16 */

 0x0C, ACPI_RESOURCE_TYPE_ADDRESS32 */

 0x0D, ACPI_RESOURCE_TYPE_ADDRESS64 */

 0x0E, ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64 */

 0x0F, ACPI_RESOURCE_TYPE_EXTENDED_IRQ */

 0x10, ACPI_RESOURCE_TYPE_GENERIC_REGISTER */

 0x11, ACPI_RESOURCE_TYPE_GPIO */

 0x12, ACPI_RESOURCE_TYPE_FIXED_DMA */

 0x13, ACPI_RESOURCE_TYPE_SERIAL_BUS - Use subtype table below */

 0x14, ACPI_RESOURCE_TYPE_PIN_FUNCTION */

 0x15, ACPI_RESOURCE_TYPE_PIN_CONFIG */

 0x16, ACPI_RESOURCE_TYPE_PIN_GROUP */

 0x17, ACPI_RESOURCE_TYPE_PIN_GROUP_FUNCTION */

 0x18, ACPI_RESOURCE_TYPE_PIN_GROUP_CONFIG */

 Dispatch tables for AML-to-resource (Get Resource) conversion functions */

 Small descriptors */

 0x00, Reserved */

 0x01, Reserved */

 0x02, Reserved */

 0x03, Reserved */

 0x04, ACPI_RESOURCE_NAME_IRQ */

 0x05, ACPI_RESOURCE_NAME_DMA */

 0x06, ACPI_RESOURCE_NAME_START_DEPENDENT */

 0x07, ACPI_RESOURCE_NAME_END_DEPENDENT */

 0x08, ACPI_RESOURCE_NAME_IO */

 0x09, ACPI_RESOURCE_NAME_FIXED_IO */

 0x0A, ACPI_RESOURCE_NAME_FIXED_DMA */

 0x0B, Reserved */

 0x0C, Reserved */

 0x0D, Reserved */

 0x0E, ACPI_RESOURCE_NAME_VENDOR_SMALL */

 0x0F, ACPI_RESOURCE_NAME_END_TAG */

 Large descriptors */

 0x00, Reserved */

 0x01, ACPI_RESOURCE_NAME_MEMORY24 */

 0x02, ACPI_RESOURCE_NAME_GENERIC_REGISTER */

 0x03, Reserved */

 0x04, ACPI_RESOURCE_NAME_VENDOR_LARGE */

 0x05, ACPI_RESOURCE_NAME_MEMORY32 */

 0x06, ACPI_RESOURCE_NAME_FIXED_MEMORY32 */

 0x07, ACPI_RESOURCE_NAME_ADDRESS32 */

 0x08, ACPI_RESOURCE_NAME_ADDRESS16 */

 0x09, ACPI_RESOURCE_NAME_EXTENDED_IRQ */

 0x0A, ACPI_RESOURCE_NAME_ADDRESS64 */

 0x0B, ACPI_RESOURCE_NAME_EXTENDED_ADDRESS64 */

 0x0C, ACPI_RESOURCE_NAME_GPIO */

 0x0D, ACPI_RESOURCE_NAME_PIN_FUNCTION */

 0x0E, ACPI_RESOURCE_NAME_SERIAL_BUS - Use subtype table below */

 0x0F, ACPI_RESOURCE_NAME_PIN_CONFIG */

 0x10, ACPI_RESOURCE_NAME_PIN_GROUP */

 0x11, ACPI_RESOURCE_NAME_PIN_GROUP_FUNCTION */

 0x12, ACPI_RESOURCE_NAME_PIN_GROUP_CONFIG */

 Subtype table for serial_bus -- I2C, SPI, UART, and CSI2 */

 Dispatch table for resource dump functions */

 ACPI_RESOURCE_TYPE_IRQ */

 ACPI_RESOURCE_TYPE_DMA */

 ACPI_RESOURCE_TYPE_START_DEPENDENT */

 ACPI_RESOURCE_TYPE_END_DEPENDENT */

 ACPI_RESOURCE_TYPE_IO */

 ACPI_RESOURCE_TYPE_FIXED_IO */

 ACPI_RESOURCE_TYPE_VENDOR */

 ACPI_RESOURCE_TYPE_END_TAG */

 ACPI_RESOURCE_TYPE_MEMORY24 */

 ACPI_RESOURCE_TYPE_MEMORY32 */

 ACPI_RESOURCE_TYPE_FIXED_MEMORY32 */

 ACPI_RESOURCE_TYPE_ADDRESS16 */

 ACPI_RESOURCE_TYPE_ADDRESS32 */

 ACPI_RESOURCE_TYPE_ADDRESS64 */

 ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64 */

 ACPI_RESOURCE_TYPE_EXTENDED_IRQ */

 ACPI_RESOURCE_TYPE_GENERIC_REGISTER */

 ACPI_RESOURCE_TYPE_GPIO */

 ACPI_RESOURCE_TYPE_FIXED_DMA */

 ACPI_RESOURCE_TYPE_SERIAL_BUS */

 ACPI_RESOURCE_TYPE_PIN_FUNCTION */

 ACPI_RESOURCE_TYPE_PIN_CONFIG */

 ACPI_RESOURCE_TYPE_PIN_GROUP */

 ACPI_RESOURCE_TYPE_PIN_GROUP_FUNCTION */

 ACPI_RESOURCE_TYPE_PIN_GROUP_CONFIG */

 AML_RESOURCE_I2C_BUS_TYPE */

 AML_RESOURCE_SPI_BUS_TYPE */

 AML_RESOURCE_UART_BUS_TYPE */

 AML_RESOURCE_CSI2_BUS_TYPE */

/*

 * Base sizes for external AML resource descriptors, indexed by internal type.

 * Includes size of the descriptor header (1 byte for small descriptors,

 * 3 bytes for large descriptors)

 ACPI_RESOURCE_TYPE_IRQ (optional Byte 3 always created) */

 ACPI_RESOURCE_TYPE_DMA */

 ACPI_RESOURCE_TYPE_START_DEPENDENT (optional Byte 1 always created) */

 ACPI_RESOURCE_TYPE_END_DEPENDENT */

 ACPI_RESOURCE_TYPE_IO */

 ACPI_RESOURCE_TYPE_FIXED_IO */

 ACPI_RESOURCE_TYPE_VENDOR */

 ACPI_RESOURCE_TYPE_END_TAG */

 ACPI_RESOURCE_TYPE_MEMORY24 */

 ACPI_RESOURCE_TYPE_MEMORY32 */

 ACPI_RESOURCE_TYPE_FIXED_MEMORY32 */

 ACPI_RESOURCE_TYPE_ADDRESS16 */

 ACPI_RESOURCE_TYPE_ADDRESS32 */

 ACPI_RESOURCE_TYPE_ADDRESS64 */

ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64 */

 ACPI_RESOURCE_TYPE_EXTENDED_IRQ */

 ACPI_RESOURCE_TYPE_GENERIC_REGISTER */

 ACPI_RESOURCE_TYPE_GPIO */

 ACPI_RESOURCE_TYPE_FIXED_DMA */

 ACPI_RESOURCE_TYPE_SERIAL_BUS */

 ACPI_RESOURCE_TYPE_PIN_FUNCTION */

 ACPI_RESOURCE_TYPE_PIN_CONFIG */

 ACPI_RESOURCE_TYPE_PIN_GROUP */

 ACPI_RESOURCE_TYPE_PIN_GROUP_FUNCTION */

 ACPI_RESOURCE_TYPE_PIN_GROUP_CONFIG */

 Small descriptors */

 Large descriptors */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: evxface - External interfaces for ACPI events

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_install_notify_handler

 *

 * PARAMETERS:  device          - The device for which notifies will be handled

 *              handler_type    - The type of handler:

 *                                  ACPI_SYSTEM_NOTIFY: System Handler (00-7F)

 *                                  ACPI_DEVICE_NOTIFY: Device Handler (80-FF)

 *                                  ACPI_ALL_NOTIFY:    Both System and Device

 *              handler         - Address of the handler

 *              context         - Value passed to the handler on each GPE

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Install a handler for notifications on an ACPI Device,

 *              thermal_zone, or Processor object.

 *

 * NOTES:       The Root namespace object may have only one handler for each

 *              type of notify (System/Device). Device/Thermal/Processor objects

 *              may have one device notify handler, and multiple system notify

 *              handlers.

 *

 Parameter validation */

	/*

	 * Root Object:

	 * Registering a notify handler on the root object indicates that the

	 * caller wishes to receive notifications for all objects. Note that

	 * only one global handler can be registered per notify type.

	 * Ensure that a handler is not already installed.

 Global notify handler installed, all done */

	/*

	 * All Other Objects:

	 * Caller will only receive notifications specific to the target

	 * object. Note that only certain object types are allowed to

	 * receive notifications.

 Are Notifies allowed on this object? */

 Check for an existing internal object, might not exist */

 Create a new object */

 Attach new object to the Node, remove local reference */

 Ensure that the handler is not already installed in the lists */

 Create and populate a new notify handler object */

 Install the handler at the list head(s) */

 Add an extra reference if handler was installed in both lists */

/*******************************************************************************

 *

 * FUNCTION:    acpi_remove_notify_handler

 *

 * PARAMETERS:  device          - The device for which the handler is installed

 *              handler_type    - The type of handler:

 *                                  ACPI_SYSTEM_NOTIFY: System Handler (00-7F)

 *                                  ACPI_DEVICE_NOTIFY: Device Handler (80-FF)

 *                                  ACPI_ALL_NOTIFY:    Both System and Device

 *              handler         - Address of the handler

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Remove a handler for notifies on an ACPI device

 *

 Parameter validation */

 Root Object. Global handlers are removed here */

 Make sure all deferred notify tasks are completed */

 All other objects: Are Notifies allowed on this object? */

 Must have an existing internal object */

 Internal object exists. Find the handler and remove it */

 Attempt to find the handler in the handler list */

 Remove the handler object from the list */

 Handler is not at the list head */

 Handler is at the list head */

 Make sure all deferred notify tasks are completed */

/*******************************************************************************

 *

 * FUNCTION:    acpi_install_exception_handler

 *

 * PARAMETERS:  handler         - Pointer to the handler function for the

 *                                event

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Saves the pointer to the handler function

 *

 Don't allow two handlers. */

 Install the handler */

/*******************************************************************************

 *

 * FUNCTION:    acpi_install_sci_handler

 *

 * PARAMETERS:  address             - Address of the handler

 *              context             - Value passed to the handler on each SCI

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Install a handler for a System Control Interrupt.

 *

 Allocate and init a handler object */

 Lock list during installation */

 Ensure handler does not already exist */

 Install the new handler into the global list (at head) */

/*******************************************************************************

 *

 * FUNCTION:    acpi_remove_sci_handler

 *

 * PARAMETERS:  address             - Address of the handler

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Remove a handler for a System Control Interrupt.

 *

 Remove the SCI handler with lock */

 Unlink and free the SCI handler info block */

/*******************************************************************************

 *

 * FUNCTION:    acpi_install_global_event_handler

 *

 * PARAMETERS:  handler         - Pointer to the global event handler function

 *              context         - Value passed to the handler on each event

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Saves the pointer to the handler function. The global handler

 *              is invoked upon each incoming GPE and Fixed Event. It is

 *              invoked at interrupt level at the time of the event dispatch.

 *              Can be used to update event counters, etc.

 *

 Parameter validation */

 Don't allow two handlers. */

/*******************************************************************************

 *

 * FUNCTION:    acpi_install_fixed_event_handler

 *

 * PARAMETERS:  event           - Event type to enable.

 *              handler         - Pointer to the handler function for the

 *                                event

 *              context         - Value passed to the handler on each GPE

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Saves the pointer to the handler function and then enables the

 *              event.

 *

 Parameter validation */

 Do not allow multiple handlers */

 Install the handler before enabling the event */

 Remove the handler */

/*******************************************************************************

 *

 * FUNCTION:    acpi_remove_fixed_event_handler

 *

 * PARAMETERS:  event           - Event type to disable.

 *              handler         - Address of the handler

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Disables the event and unregisters the event handler.

 *

 Parameter validation */

 Disable the event before removing the handler */

 Always Remove the handler */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_install_gpe_handler

 *

 * PARAMETERS:  gpe_device      - Namespace node for the GPE (NULL for FADT

 *                                defined GPEs)

 *              gpe_number      - The GPE number within the GPE block

 *              type            - Whether this GPE should be treated as an

 *                                edge- or level-triggered interrupt.

 *              is_raw_handler  - Whether this GPE should be handled using

 *                                the special GPE handler mode.

 *              address         - Address of the handler

 *              context         - Value passed to the handler on each GPE

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Internal function to install a handler for a General Purpose

 *              Event.

 *

 Parameter validation */

 Allocate and init handler object (before lock) */

 Ensure that we have a valid GPE number */

 Make sure that there isn't a handler there already */

	/*

	 * If the GPE is associated with a method, it may have been enabled

	 * automatically during initialization, in which case it has to be

	 * disabled now to avoid spurious execution of the handler.

 Sanity check of original type against new type */

 Install the handler */

 Setup up dispatch flags to indicate handler (vs. method/notify) */

/*******************************************************************************

 *

 * FUNCTION:    acpi_install_gpe_handler

 *

 * PARAMETERS:  gpe_device      - Namespace node for the GPE (NULL for FADT

 *                                defined GPEs)

 *              gpe_number      - The GPE number within the GPE block

 *              type            - Whether this GPE should be treated as an

 *                                edge- or level-triggered interrupt.

 *              address         - Address of the handler

 *              context         - Value passed to the handler on each GPE

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Install a handler for a General Purpose Event.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_install_gpe_raw_handler

 *

 * PARAMETERS:  gpe_device      - Namespace node for the GPE (NULL for FADT

 *                                defined GPEs)

 *              gpe_number      - The GPE number within the GPE block

 *              type            - Whether this GPE should be treated as an

 *                                edge- or level-triggered interrupt.

 *              address         - Address of the handler

 *              context         - Value passed to the handler on each GPE

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Install a handler for a General Purpose Event.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_remove_gpe_handler

 *

 * PARAMETERS:  gpe_device      - Namespace node for the GPE (NULL for FADT

 *                                defined GPEs)

 *              gpe_number      - The event to remove a handler

 *              address         - Address of the handler

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Remove a handler for a General Purpose acpi_event.

 *

 Parameter validation */

 Ensure that we have a valid GPE number */

 Make sure that a handler is indeed installed */

 Make sure that the installed handler is the same */

 Remove the handler */

 Restore Method node (if any), set dispatch flags */

	/*

	 * If the GPE was previously associated with a method and it was

	 * enabled, it should be enabled at this point to restore the

	 * post-initialization configuration.

 Poll edge triggered GPEs to handle existing events */

 Make sure all deferred GPE tasks are completed */

 Now we can free the handler object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_acquire_global_lock

 *

 * PARAMETERS:  timeout         - How long the caller is willing to wait

 *              handle          - Where the handle to the lock is returned

 *                                (if acquired)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Acquire the ACPI Global Lock

 *

 * Note: Allows callers with the same thread ID to acquire the global lock

 * multiple times. In other words, externally, the behavior of the global lock

 * is identical to an AML mutex. On the first acquire, a new handle is

 * returned. On any subsequent calls to acquire by the same thread, the same

 * handle is returned.

 *

 Must lock interpreter to prevent race conditions */

 Return the global lock handle (updated in acpi_ev_acquire_global_lock) */

/*******************************************************************************

 *

 * FUNCTION:    acpi_release_global_lock

 *

 * PARAMETERS:  handle      - Returned from acpi_acquire_global_lock

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Release the ACPI Global Lock. The handle must be valid.

 *

 !ACPI_REDUCED_HARDWARE */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: evgpeinit - System GPE initialization and update

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Entire module */

/*

 * Note: History of _PRW support in ACPICA

 *

 * Originally (2000 - 2010), the GPE initialization code performed a walk of

 * the entire namespace to execute the _PRW methods and detect all GPEs

 * capable of waking the system.

 *

 * As of 10/2010, the _PRW method execution has been removed since it is

 * actually unnecessary. The host OS must in fact execute all _PRW methods

 * in order to identify the device/power-resource dependencies. We now put

 * the onus on the host OS to identify the wake GPEs as part of this process

 * and to inform ACPICA of these GPEs via the acpi_setup_gpe_for_wake interface. This

 * not only reduces the complexity of the ACPICA initialization code, but in

 * some cases (on systems with very large namespaces) it should reduce the

 * kernel boot time as well.

 ACPI_GPE_USE_LOGICAL_ADDRESSES */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_gpe_initialize

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Initialize the GPE data structures and the FADT GPE 0/1 blocks

 *

	/*

	 * Initialize the GPE Block(s) defined in the FADT

	 *

	 * Why the GPE register block lengths are divided by 2:  From the ACPI

	 * Spec, section "General-Purpose Event Registers", we have:

	 *

	 * "Each register block contains two registers of equal length

	 *  GPEx_STS and GPEx_EN (where x is 0 or 1). The length of the

	 *  GPE0_STS and GPE0_EN registers is equal to half the GPE0_LEN

	 *  The length of the GPE1_STS and GPE1_EN registers is equal to

	 *  half the GPE1_LEN. If a generic register block is not supported

	 *  then its respective block pointer and block length values in the

	 *  FADT table contain zeros. The GPE0_LEN and GPE1_LEN do not need

	 *  to be the same size."

	/*

	 * Determine the maximum GPE number for this machine.

	 *

	 * Note: both GPE0 and GPE1 are optional, and either can exist without

	 * the other.

	 *

	 * If EITHER the register length OR the block address are zero, then that

	 * particular block is not supported.

 GPE block 0 exists (has both length and address > 0) */

 Install GPE Block 0 */

 GPE block 1 exists (has both length and address > 0) */

 Check for GPE0/GPE1 overlap (if both banks exist) */

 Ignore GPE1 block by setting the register count to zero */

 Install GPE Block 1 */

			/*

			 * GPE0 and GPE1 do not have to be contiguous in the GPE number

			 * space. However, GPE0 always starts at GPE number zero.

 Exit if there are no GPE registers */

 GPEs are not required by ACPI, this is OK */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_update_gpes

 *

 * PARAMETERS:  table_owner_id      - ID of the newly-loaded ACPI table

 *

 * RETURN:      None

 *

 * DESCRIPTION: Check for new GPE methods (_Lxx/_Exx) made available as a

 *              result of a Load() or load_table() operation. If new GPE

 *              methods have been installed, register the new methods.

 *

	/*

	 * Find any _Lxx/_Exx GPE methods that have just been loaded.

	 *

	 * Any GPEs that correspond to new _Lxx/_Exx methods are immediately

	 * enabled.

	 *

	 * Examine the namespace underneath each gpe_device within the

	 * gpe_block lists.

 Walk the interrupt level descriptor list */

 Walk all Gpe Blocks attached to this interrupt level */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_match_gpe_method

 *

 * PARAMETERS:  Callback from walk_namespace

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Called from acpi_walk_namespace. Expects each object to be a

 *              control method under the _GPE portion of the namespace.

 *              Extract the name and GPE type from the object, saving this

 *              information for quick lookup during GPE dispatch. Allows a

 *              per-owner_id evaluation if execute_by_owner_id is TRUE in the

 *              walk_info parameter block.

 *

 *              The name of each GPE control method is of the form:

 *              "_Lxx" or "_Exx", where:

 *                  L      - means that the GPE is level triggered

 *                  E      - means that the GPE is edge triggered

 *                  xx     - is the GPE number [in HEX]

 *

 * If walk_info->execute_by_owner_id is TRUE, we only execute examine GPE methods

 * with that owner.

 *

 Check if requested owner_id matches this owner_id */

	/*

	 * Match and decode the _Lxx and _Exx GPE method names

	 *

	 * 1) Extract the method name and null terminate it

 2) Name must begin with an underscore */

 Ignore this method */

	/*

	 * 3) Edge/Level determination is based on the 2nd character

	 *    of the method name

 Unknown method type, just ignore it */

 4) The last two characters of the name are the hex GPE Number */

 Conversion failed; invalid method, just ignore it */

 Ensure that we have a valid GPE number for this GPE block */

		/*

		 * This gpe_number is not valid for this GPE block, just ignore it.

		 * However, it may be valid for a different GPE block, since GPE0

		 * and GPE1 methods both appear under \_GPE.

 If there is already a handler, ignore this GPE method */

		/*

		 * If there is already a method, ignore this method. But check

		 * for a type mismatch (if both the _Lxx AND _Exx exist)

 Disable the GPE in case it's been enabled already. */

	/*

	 * Add the GPE information from above to the gpe_event_info block for

	 * use during dispatch of this GPE.

 !ACPI_REDUCED_HARDWARE */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: rsxface - Public interfaces to the resource manager

 *

 Local macros for 16,32-bit to 64-bit conversion */

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_validate_parameters

 *

 * PARAMETERS:  device_handle   - Handle to a device

 *              buffer          - Pointer to a data buffer

 *              return_node     - Pointer to where the device node is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Common parameter validation for resource interfaces

 *

	/*

	 * Must have a valid handle to an ACPI device

	/*

	 * Validate the user buffer object

	 *

	 * if there is a non-zero buffer length we also need a valid pointer in

	 * the buffer. If it's a zero buffer length, we'll be returning the

	 * needed buffer size (later), so keep going.

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_irq_routing_table

 *

 * PARAMETERS:  device_handle   - Handle to the Bus device we are querying

 *              ret_buffer      - Pointer to a buffer to receive the

 *                                current resources for the device

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to get the IRQ routing table for a

 *              specific bus. The caller must first acquire a handle for the

 *              desired bus. The routine table is placed in the buffer pointed

 *              to by the ret_buffer variable parameter.

 *

 *              If the function fails an appropriate status will be returned

 *              and the value of ret_buffer is undefined.

 *

 *              This function attempts to execute the _PRT method contained in

 *              the object indicated by the passed device_handle.

 *

 Validate parameters then dispatch to internal routine */

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_current_resources

 *

 * PARAMETERS:  device_handle   - Handle to the device object for the

 *                                device we are querying

 *              ret_buffer      - Pointer to a buffer to receive the

 *                                current resources for the device

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to get the current resources for a

 *              specific device. The caller must first acquire a handle for

 *              the desired device. The resource data is placed in the buffer

 *              pointed to by the ret_buffer variable parameter.

 *

 *              If the function fails an appropriate status will be returned

 *              and the value of ret_buffer is undefined.

 *

 *              This function attempts to execute the _CRS method contained in

 *              the object indicated by the passed device_handle.

 *

 Validate parameters then dispatch to internal routine */

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_possible_resources

 *

 * PARAMETERS:  device_handle   - Handle to the device object for the

 *                                device we are querying

 *              ret_buffer      - Pointer to a buffer to receive the

 *                                resources for the device

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to get a list of the possible resources

 *              for a specific device. The caller must first acquire a handle

 *              for the desired device. The resource data is placed in the

 *              buffer pointed to by the ret_buffer variable.

 *

 *              If the function fails an appropriate status will be returned

 *              and the value of ret_buffer is undefined.

 *

 Validate parameters then dispatch to internal routine */

/*******************************************************************************

 *

 * FUNCTION:    acpi_set_current_resources

 *

 * PARAMETERS:  device_handle   - Handle to the device object for the

 *                                device we are setting resources

 *              in_buffer       - Pointer to a buffer containing the

 *                                resources to be set for the device

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to set the current resources for a

 *              specific device. The caller must first acquire a handle for

 *              the desired device. The resource data is passed to the routine

 *              the buffer pointed to by the in_buffer variable.

 *

 Validate the buffer, don't allow zero length */

 Validate parameters then dispatch to internal routine */

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_event_resources

 *

 * PARAMETERS:  device_handle   - Handle to the device object for the

 *                                device we are getting resources

 *              in_buffer       - Pointer to a buffer containing the

 *                                resources to be set for the device

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to get the event resources for a

 *              specific device. The caller must first acquire a handle for

 *              the desired device. The resource data is passed to the routine

 *              the buffer pointed to by the in_buffer variable. Uses the

 *              _AEI method.

 *

 Validate parameters then dispatch to internal routine */

/******************************************************************************

 *

 * FUNCTION:    acpi_resource_to_address64

 *

 * PARAMETERS:  resource        - Pointer to a resource

 *              out             - Pointer to the users's return buffer

 *                                (a struct acpi_resource_address64)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: If the resource is an address16, address32, or address64,

 *              copy it to the address64 return buffer. This saves the

 *              caller from having to duplicate code for different-sized

 *              addresses.

 *

 Convert 16 or 32 address descriptor to 64 */

 Simple copy for 64 bit source */

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_vendor_resource

 *

 * PARAMETERS:  device_handle   - Handle for the parent device object

 *              name            - Method name for the parent resource

 *                                (METHOD_NAME__CRS or METHOD_NAME__PRS)

 *              uuid            - Pointer to the UUID to be matched.

 *                                includes both subtype and 16-byte UUID

 *              ret_buffer      - Where the vendor resource is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Walk a resource template for the specified device to find a

 *              vendor-defined resource that matches the supplied UUID and

 *              UUID subtype. Returns a struct acpi_resource of type Vendor.

 *

 Other parameters are validated by acpi_walk_resources */

 Walk the _CRS or _PRS resource list for this device */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_match_vendor_resource

 *

 * PARAMETERS:  acpi_walk_resource_callback

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Match a vendor resource via the ACPI 3.0 UUID

 *

 Ignore all descriptors except Vendor */

	/*

	 * For a valid match, these conditions must hold:

	 *

	 * 1) Length of descriptor data must be at least as long as a UUID struct

	 * 2) The UUID subtypes must match

	 * 3) The UUID data must match

 Validate/Allocate/Clear caller buffer */

 Found the correct resource, copy and return it */

 Found the desired descriptor, terminate resource walk */

/*******************************************************************************

 *

 * FUNCTION:    acpi_walk_resource_buffer

 *

 * PARAMETERS:  buffer          - Formatted buffer returned by one of the

 *                                various Get*Resource functions

 *              user_function   - Called for each resource

 *              context         - Passed to user_function

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Walks the input resource template. The user_function is called

 *              once for each resource in the list.

 *

 Parameter validation */

 Buffer contains the resource list and length */

 Walk the resource list until the end_tag is found (or buffer end) */

 Sanity check the resource type */

 Sanity check the length. It must not be zero, or we loop forever */

 Invoke the user function, abort on any error returned */

 This is an OK termination by the user function */

 end_tag indicates end-of-list */

 Get the next resource descriptor */

/*******************************************************************************

 *

 * FUNCTION:    acpi_walk_resources

 *

 * PARAMETERS:  device_handle   - Handle to the device object for the

 *                                device we are querying

 *              name            - Method name of the resources we want.

 *                                (METHOD_NAME__CRS, METHOD_NAME__PRS, or

 *                                METHOD_NAME__AEI or METHOD_NAME__DMA)

 *              user_function   - Called for each resource

 *              context         - Passed to user_function

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Retrieves the current or possible resource list for the

 *              specified device. The user_function is called once for

 *              each resource in the list.

 *

 Parameter validation */

 Get the _CRS/_PRS/_AEI/_DMA resource list */

 Walk the resource list and cleanup */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: rscalc - Calculate stream and list lengths

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_count_set_bits

 *

 * PARAMETERS:  bit_field       - Field in which to count bits

 *

 * RETURN:      Number of bits set within the field

 *

 * DESCRIPTION: Count the number of bits set in a resource field. Used for

 *              (Short descriptor) interrupt and DMA lists.

 *

 Zero the least significant bit that is set */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_struct_option_length

 *

 * PARAMETERS:  resource_source     - Pointer to optional descriptor field

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Common code to handle optional resource_source_index and

 *              resource_source fields in some Large descriptors. Used during

 *              list-to-stream conversion

 *

	/*

	 * If the resource_source string is valid, return the size of the string

	 * (string_length includes the NULL terminator) plus the size of the

	 * resource_source_index (1).

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_stream_option_length

 *

 * PARAMETERS:  resource_length     - Length from the resource header

 *              minimum_total_length - Minimum length of this resource, before

 *                                    any optional fields. Includes header size

 *

 * RETURN:      Length of optional string (0 if no string present)

 *

 * DESCRIPTION: Common code to handle optional resource_source_index and

 *              resource_source fields in some Large descriptors. Used during

 *              stream-to-list conversion

 *

	/*

	 * The resource_source_index and resource_source are optional elements of

	 * some Large-type resource descriptors.

	/*

	 * If the length of the actual resource descriptor is greater than the

	 * ACPI spec-defined minimum length, it means that a resource_source_index

	 * exists and is followed by a (required) null terminated string. The

	 * string length (including the null terminator) is the resource length

	 * minus the minimum length, minus one byte for the resource_source_index

	 * itself.

 Compute the length of the optional string */

	/*

	 * Round the length up to a multiple of the native word in order to

	 * guarantee that the entire resource descriptor is native word aligned

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_get_aml_length

 *

 * PARAMETERS:  resource            - Pointer to the resource linked list

 *              resource_list_size  - Size of the resource linked list

 *              size_needed         - Where the required size is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Takes a linked list of internal resource descriptors and

 *              calculates the size buffer needed to hold the corresponding

 *              external resource byte stream.

 *

 Traverse entire list of internal resource descriptors */

 Validate the descriptor type */

 Sanity check the length. It must not be zero, or we loop forever */

 Get the base size of the (external stream) resource descriptor */

		/*

		 * Augment the base size for descriptors with optional and/or

		 * variable-length fields

 Length can be 3 or 2 */

 Length can be 1 or 0 */

			/*

			 * Vendor Defined Resource:

			 * For a Vendor Specific resource, if the Length is between 1 and 7

			 * it will be created as a Small Resource data type, otherwise it

			 * is a Large Resource data type.

 Base size of a Large resource descriptor */

 Add the size of the vendor-specific data */

			/*

			 * End Tag:

			 * We are done -- return the accumulated total size.

 Normal exit */

			/*

			 * 16-Bit Address Resource:

			 * Add the size of the optional resource_source info

			/*

			 * 32-Bit Address Resource:

			 * Add the size of the optional resource_source info

			/*

			 * 64-Bit Address Resource:

			 * Add the size of the optional resource_source info

			/*

			 * Extended IRQ Resource:

			 * Add the size of each additional optional interrupt beyond the

			 * required 1 (4 bytes for each u32 interrupt number)

 Add the size of the optional resource_source info */

 Update the total */

 Point to the next object */

 Did not find an end_tag resource descriptor */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_get_list_length

 *

 * PARAMETERS:  aml_buffer          - Pointer to the resource byte stream

 *              aml_buffer_length   - Size of aml_buffer

 *              size_needed         - Where the size needed is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Takes an external resource byte stream and calculates the size

 *              buffer needed to hold the corresponding internal resource

 *              descriptor linked list.

 *

 Minimum size is one end_tag */

 Walk the list of AML resource descriptors */

 Validate the Resource Type and Resource Length */

			/*

			 * Exit on failure. Cannot continue because the descriptor length

			 * may be bogus also.

 Get the resource length and base (minimum) AML size */

		/*

		 * Augment the size for descriptors with optional

		 * and/or variable length fields

			/*

			 * IRQ Resource:

			 * Get the number of bits set in the 16-bit IRQ mask

			/*

			 * DMA Resource:

			 * Get the number of bits set in the 8-bit DMA mask

			/*

			 * Vendor Resource:

			 * Get the number of vendor data bytes

			/*

			 * There is already one byte included in the minimum

			 * descriptor size. If there are extra struct bytes,

			 * subtract one from the count.

			/*

			 * End Tag: This is the normal exit

			/*

			 * Address Resource:

			 * Add the size of the optional resource_source

			/*

			 * Extended IRQ Resource:

			 * Using the interrupt_table_length, add 4 bytes for each additional

			 * interrupt. Note: at least one interrupt is required and is

			 * included in the minimum descriptor size (reason for the -1)

 Add the size of the optional resource_source */

 Vendor data is optional */

 Vendor data is optional */

 Vendor data is optional */

		/*

		 * Update the required buffer size for the internal descriptor structs

		 *

		 * Important: Round the size up for the appropriate alignment. This

		 * is a requirement on IA64.

		/*

		 * Point to the next resource within the AML stream using the length

		 * contained in the resource descriptor header

 Did not find an end_tag resource descriptor */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_get_pci_routing_table_length

 *

 * PARAMETERS:  package_object          - Pointer to the package object

 *              buffer_size_needed      - u32 pointer of the size buffer

 *                                        needed to properly return the

 *                                        parsed data

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Given a package representing a PCI routing table, this

 *              calculates the size of the corresponding linked list of

 *              descriptions.

 *

	/*

	 * Calculate the size of the return buffer.

	 * The base size is the number of elements * the sizes of the

	 * structures. Additional space for the strings is added below.

	 * The minus one is to subtract the size of the u8 Source[1]

	 * member because it is added below.

	 *

	 * But each PRT_ENTRY structure has a pointer to a string and

	 * the size of that string must be found.

 Dereference the subpackage */

 We must have a valid Package object */

		/*

		 * The sub_object_list will now point to an array of the

		 * four IRQ elements: Address, Pin, Source and source_index

 Scan the irq_table_elements for the Source Name String */

 Null object allowed */

 Look at the next element */

 Was a String type found? */

				/*

				 * The length String.Length field does not include the

				 * terminating NULL, add 1

			/*

			 * If no name was found, then this is a NULL, which is

			 * translated as a u32 zero.

 Round up the size since each element must be aligned */

 Point to the next union acpi_operand_object */

	/*

	 * Add an extra element to the end of the list, essentially a

	 * NULL terminator

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: dsinit - Object initialization namespace walk

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_init_one_object

 *

 * PARAMETERS:  obj_handle      - Node for the object

 *              level           - Current nesting level

 *              context         - Points to a init info struct

 *              return_value    - Not used

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Callback from acpi_walk_namespace. Invoked for every object

 *              within the namespace.

 *

 *              Currently, the only objects that require initialization are:

 *              1) Methods

 *              2) Operation Regions

 *

	/*

	 * We are only interested in NS nodes owned by the table that

	 * was just loaded

 And even then, we are only interested in a few object types */

		/*

		 * Auto-serialization support. We will examine each method that is

		 * not_serialized to determine if it creates any Named objects. If

		 * it does, it will be marked serialized to prevent problems if

		 * the method is entered by two or more threads and an attempt is

		 * made to create the same named object twice -- which results in

		 * an AE_ALREADY_EXISTS exception and method abort.

 Ignore if already serialized */

 Parse/scan method and serialize it if necessary */

 Method was just converted to Serialized */

	/*

	 * We ignore errors from above, and always return OK, since

	 * we don't want to abort the walk on a single error.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_initialize_objects

 *

 * PARAMETERS:  table_desc      - Descriptor for parent ACPI table

 *              start_node      - Root of subtree to be initialized.

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Walk the namespace starting at "StartNode" and perform any

 *              necessary initialization on the objects found therein

 *

 Set all init info to zero */

 Walk entire namespace from the supplied root */

	/*

	 * We don't use acpi_walk_namespace since we do not want to acquire

	 * the namespace reader lock.

 DSDT is always the first AML table */

 Summary of objects initialized */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: nsinit - namespace initialization

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_initialize_objects

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Walk the entire namespace and perform any necessary

 *              initialization on the objects found therein

 *

 Clear the info block */

 Walk entire namespace from the supplied root */

	/*

	 * TBD: will become ACPI_TYPE_PACKAGE as this type object

	 * is now the only one that supports deferred initialization

	 * (forward references).

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_initialize_devices

 *

 * PARAMETERS:  None

 *

 * RETURN:      acpi_status

 *

 * DESCRIPTION: Walk the entire namespace and initialize all ACPI devices.

 *              This means running _INI on all present devices.

 *

 *              Note: We install PCI config space handler on region access,

 *              not here.

 *

 Init counters */

 Tree analysis: find all subtrees that contain _INI methods */

 Allocate the evaluation information block */

		/*

		 * Execute the "global" _INI method that may appear at the root.

		 * This support is provided for Windows compatibility (Vista+) and

		 * is not part of the ACPI specification.

		/*

		 * Execute \_SB._INI.

		 * There appears to be a strict order requirement for \_SB._INI,

		 * which should be evaluated before any _REG evaluations.

	/*

	 * Run all _REG methods

	 *

	 * Note: Any objects accessed by the _REG methods will be automatically

	 * initialized, even if they contain executable AML (see the call to

	 * acpi_ns_initialize_objects below).

	 *

	 * Note: According to the ACPI specification, we actually needn't execute

	 * _REG for system_memory/system_io operation regions, but for PCI_Config

	 * operation regions, it is required to evaluate _REG for those on a PCI

	 * root bus that doesn't contain _BBN object. So this code is kept here

	 * in order not to break things.

 Walk namespace to execute all _INIs on present devices */

		/*

		 * Any _OSI requests should be completed by now. If the BIOS has

		 * requested any Windows OSI strings, we will always truncate

		 * I/O addresses to 16 bits -- for Windows compatibility.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_init_one_package

 *

 * PARAMETERS:  obj_handle      - Node

 *              level           - Current nesting level

 *              context         - Not used

 *              return_value    - Not used

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Callback from acpi_walk_namespace. Invoked for every package

 *              within the namespace. Used during dynamic load of an SSDT.

 *

 Exit if package is already initialized */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_init_one_object

 *

 * PARAMETERS:  obj_handle      - Node

 *              level           - Current nesting level

 *              context         - Points to a init info struct

 *              return_value    - Not used

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Callback from acpi_walk_namespace. Invoked for every object

 *              within the namespace.

 *

 *              Currently, the only objects that require initialization are:

 *              1) Methods

 *              2) Op Regions

 *

 And even then, we are only interested in a few object types */

 Increment counters for object types we are looking for */

 No init required, just exit now */

 If the object is already initialized, nothing else to do */

 Must lock the interpreter before executing AML code */

	/*

	 * Only initialization of Package objects can be deferred, in order

	 * to support forward references.

 TBD: bank_fields do not require deferred init, remove this code */

 Complete the initialization/resolution of the package object */

 No other types should get here */

	/*

	 * We ignore errors from above, and always return OK, since we don't want

	 * to abort the walk on any single error.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_find_ini_methods

 *

 * PARAMETERS:  acpi_walk_callback

 *

 * RETURN:      acpi_status

 *

 * DESCRIPTION: Called during namespace walk. Finds objects named _INI under

 *              device/processor/thermal objects, and marks the entire subtree

 *              with a SUBTREE_HAS_INI flag. This flag is used during the

 *              subsequent device initialization walk to avoid entire subtrees

 *              that do not contain an _INI.

 *

 Keep count of device/processor/thermal objects */

 We are only looking for methods named _INI */

	/*

	 * The only _INI methods that we care about are those that are

	 * present under Device, Processor, and Thermal objects.

 Mark parent and bubble up the INI present flag to the root */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_init_one_device

 *

 * PARAMETERS:  acpi_walk_callback

 *

 * RETURN:      acpi_status

 *

 * DESCRIPTION: This is called once per device soon after ACPI is enabled

 *              to initialize each device. It determines if the device is

 *              present, and if so, calls _INI.

 *

 We are interested in Devices, Processors and thermal_zones only */

	/*

	 * Because of an earlier namespace analysis, all subtrees that contain an

	 * _INI method are tagged.

	 *

	 * If this device subtree does not contain any _INI methods, we

	 * can exit now and stop traversing this entire subtree.

	/*

	 * Run _STA to determine if this device is present and functioning. We

	 * must know this information for two important reasons (from ACPI spec):

	 *

	 * 1) We can only run _INI if the device is present.

	 * 2) We must abort the device tree walk on this subtree if the device is

	 *    not present and is not functional (we will not examine the children)

	 *

	 * The _STA method is not required to be present under the device, we

	 * assume the device is present if _STA does not exist.

 Ignore error and move on to next device */

	/*

	 * Flags == -1 means that _STA was not found. In this case, we assume that

	 * the device is both present and functional.

	 *

	 * From the ACPI spec, description of _STA:

	 *

	 * "If a device object (including the processor object) does not have an

	 * _STA object, then OSPM assumes that all of the above bits are set (in

	 * other words, the device is present, ..., and functioning)"

	/*

	 * Examine the PRESENT and FUNCTIONING status bits

	 *

	 * Note: ACPI spec does not seem to specify behavior for the present but

	 * not functioning case, so we assume functioning if present.

 Device is not present, we must examine the Functioning bit */

			/*

			 * Device is not present but is "functioning". In this case,

			 * we will not run _INI, but we continue to examine the children

			 * of this device.

			 *

			 * From the ACPI spec, description of _STA: (note - no mention

			 * of whether to run _INI or not on the device in question)

			 *

			 * "_STA may return bit 0 clear (not present) with bit 3 set

			 * (device is functional). This case is used to indicate a valid

			 * device for which no device driver should be loaded (for example,

			 * a bridge device.) Children of this device may be present and

			 * valid. OSPM should continue enumeration below a device whose

			 * _STA returns this bit combination"

			/*

			 * Device is not present and is not functioning. We must abort the

			 * walk of this subtree immediately -- don't look at the children

			 * of such a device.

			 *

			 * From the ACPI spec, description of _INI:

			 *

			 * "If the _STA method indicates that the device is not present,

			 * OSPM will not run the _INI and will not examine the children

			 * of the device for _INI methods"

	/*

	 * The device is present or is assumed present if no _STA exists.

	 * Run the _INI if it exists (not required to exist)

	 *

	 * Note: We know there is an _INI within this subtree, but it may not be

	 * under this particular device, it may be lower in the branch.

 Ignore error and move on to next device */

 Ignore errors from above */

	/*

	 * The _INI method has been run if present; call the Global Initialization

	 * Handler for this device.

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: utexcep - Exception code support

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_format_exception

 *

 * PARAMETERS:  status              - The acpi_status code to be formatted

 *

 * RETURN:      A string containing the exception text. A valid pointer is

 *              always returned.

 *

 * DESCRIPTION: This function translates an ACPI exception into an ASCII

 *              string. Returns "unknown status" string for invalid codes.

 *

 Exception code was not recognized */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_validate_exception

 *

 * PARAMETERS:  status              - The acpi_status code to be formatted

 *

 * RETURN:      A string containing the exception text. NULL if exception is

 *              not valid.

 *

 * DESCRIPTION: This function validates and translates an ACPI exception into

 *              an ASCII string.

 *

	/*

	 * Status is composed of two parts, a "type" and an actual code

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exmutex - ASL Mutex Acquire/Release functions

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_unlink_mutex

 *

 * PARAMETERS:  obj_desc            - The mutex to be unlinked

 *

 * RETURN:      None

 *

 * DESCRIPTION: Remove a mutex from the "AcquiredMutex" list

 *

 Doubly linked list */

		/*

		 * Migrate the previous sync level associated with this mutex to

		 * the previous mutex on the list so that it may be preserved.

		 * This handles the case where several mutexes have been acquired

		 * at the same level, but are not released in opposite order.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_link_mutex

 *

 * PARAMETERS:  obj_desc            - The mutex to be linked

 *              thread              - Current executing thread object

 *

 * RETURN:      None

 *

 * DESCRIPTION: Add a mutex to the "AcquiredMutex" list for this walk

 *

 This object will be the first object in the list */

 Update old first object to point back to this object */

 Update list head */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_acquire_mutex_object

 *

 * PARAMETERS:  timeout             - Timeout in milliseconds

 *              obj_desc            - Mutex object

 *              thread_id           - Current thread state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Acquire an AML mutex, low-level interface. Provides a common

 *              path that supports multiple acquires by the same thread.

 *

 * MUTEX:       Interpreter must be locked

 *

 * NOTE: This interface is called from three places:

 * 1) From acpi_ex_acquire_mutex, via an AML Acquire() operator

 * 2) From acpi_ex_acquire_global_lock when an AML Field access requires the

 *    global lock

 * 3) From the external interface, acpi_acquire_global_lock

 *

 Support for multiple acquires by the owning thread */

		/*

		 * The mutex is already owned by this thread, just increment the

		 * acquisition depth

 Acquire the mutex, wait if necessary. Special case for Global Lock */

 Includes failure from a timeout on time_desc */

 Acquired the mutex: update mutex object */

 Used only for AML Acquire() */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_acquire_mutex

 *

 * PARAMETERS:  time_desc           - Timeout integer

 *              obj_desc            - Mutex object

 *              walk_state          - Current method execution state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Acquire an AML mutex

 *

 Must have a valid thread state struct */

	/*

	 * Current sync level must be less than or equal to the sync level

	 * of the mutex. This mechanism provides some deadlock prevention.

 Save Thread object, original/current sync levels */

 Link the mutex to the current thread for force-unlock at method exit */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_release_mutex_object

 *

 * PARAMETERS:  obj_desc            - The object descriptor for this op

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Release a previously acquired Mutex, low level interface.

 *              Provides a common path that supports multiple releases (after

 *              previous multiple acquires) by the same thread.

 *

 * MUTEX:       Interpreter must be locked

 *

 * NOTE: This interface is called from three places:

 * 1) From acpi_ex_release_mutex, via an AML Acquire() operator

 * 2) From acpi_ex_release_global_lock when an AML Field access requires the

 *    global lock

 * 3) From the external interface, acpi_release_global_lock

 *

 Match multiple Acquires with multiple Releases */

 Just decrement the depth and return */

 Unlink the mutex from the owner's list */

 Release the mutex, special case for Global Lock */

 Clear mutex info */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_release_mutex

 *

 * PARAMETERS:  obj_desc            - The object descriptor for this op

 *              walk_state          - Current method execution state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Release a previously acquired Mutex.

 *

 The mutex must have been previously acquired in order to release it */

 Must have a valid thread ID */

	/*

	 * The Mutex is owned, but this thread must be the owner.

	 * Special case for Global Lock, any thread can release

	/*

	 * The sync level of the mutex must be equal to the current sync level. In

	 * other words, the current level means that at least one mutex at that

	 * level is currently being held. Attempting to release a mutex of a

	 * different level can only mean that the mutex ordering rule is being

	 * violated. This behavior is clarified in ACPI 4.0 specification.

	/*

	 * Get the previous sync_level from the head of the acquired mutex list.

	 * This handles the case where several mutexes at the same level have been

	 * acquired, but are not released in reverse order.

 Restore the previous sync_level */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_release_all_mutexes

 *

 * PARAMETERS:  thread              - Current executing thread object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Release all mutexes held by this thread

 *

 * NOTE: This function is called as the thread is exiting the interpreter.

 * Mutexes are not released when an individual control method is exited, but

 * only when the parent thread actually exits the interpreter. This allows one

 * method to acquire a mutex, and a different method to release it, as long as

 * this is performed underneath a single parent control method.

 *

 Traverse the list of owned mutexes, releasing each one */

 Release the mutex, special case for Global Lock */

 Ignore errors */

 Update Thread sync_level (Last mutex is the important one) */

 Mark mutex unowned */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: utaddress - op_region address range check

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_add_address_range

 *

 * PARAMETERS:  space_id            - Address space ID

 *              address             - op_region start address

 *              length              - op_region length

 *              region_node         - op_region namespace node

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Add the Operation Region address range to the global list.

 *              The only supported Space IDs are Memory and I/O. Called when

 *              the op_region address/length operands are fully evaluated.

 *

 * MUTEX:       Locks the namespace

 *

 * NOTE: Because this interface is only called when an op_region argument

 * list is evaluated, there cannot be any duplicate region_nodes.

 * Duplicate Address/Length values are allowed, however, so that multiple

 * address conflicts can be detected.

 *

 Allocate/init a new info block, add it to the appropriate list */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_remove_address_range

 *

 * PARAMETERS:  space_id            - Address space ID

 *              region_node         - op_region namespace node

 *

 * RETURN:      None

 *

 * DESCRIPTION: Remove the Operation Region from the global list. The only

 *              supported Space IDs are Memory and I/O. Called when an

 *              op_region is deleted.

 *

 * MUTEX:       Assumes the namespace is locked

 *

 Get the appropriate list head and check the list */

 Found at list head */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_check_address_range

 *

 * PARAMETERS:  space_id            - Address space ID

 *              address             - Start address

 *              length              - Length of address range

 *              warn                - TRUE if warning on overlap desired

 *

 * RETURN:      Count of the number of conflicts detected. Zero is always

 *              returned for Space IDs other than Memory or I/O.

 *

 * DESCRIPTION: Check if the input address range overlaps any of the

 *              ASL operation region address ranges. The only supported

 *              Space IDs are Memory and I/O.

 *

 * MUTEX:       Assumes the namespace is locked.

 *

 Check entire list for all possible conflicts */

		/*

		 * Check if the requested address/length overlaps this

		 * address range. There are four cases to consider:

		 *

		 * 1) Input address/length is contained completely in the

		 *    address range

		 * 2) Input address/length overlaps range at the range start

		 * 3) Input address/length overlaps range at the range end

		 * 4) Input address/length completely encompasses the range

 Found an address range overlap */

 Optional warning message */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_delete_address_lists

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Delete all global address range lists (called during

 *              subsystem shutdown).

 *

 Delete all elements in all address range lists */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: utxfmutex - external AML mutex access functions

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_mutex_object

 *

 * PARAMETERS:  handle              - Mutex or prefix handle (optional)

 *              pathname            - Mutex pathname (optional)

 *              ret_obj             - Where the mutex object is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Get an AML mutex object. The mutex node is pointed to by

 *              Handle:Pathname. Either Handle or Pathname can be NULL, but

 *              not both.

 *

 Parameter validation */

 Get a the namespace node for the mutex */

 Ensure that we actually have a Mutex object */

 Get the low-level mutex object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_acquire_mutex

 *

 * PARAMETERS:  handle              - Mutex or prefix handle (optional)

 *              pathname            - Mutex pathname (optional)

 *              timeout             - Max time to wait for the lock (millisec)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Acquire an AML mutex. This is a device driver interface to

 *              AML mutex objects, and allows for transaction locking between

 *              drivers and AML code. The mutex node is pointed to by

 *              Handle:Pathname. Either Handle or Pathname can be NULL, but

 *              not both.

 *

 Get the low-level mutex associated with Handle:Pathname */

 Acquire the OS mutex */

/*******************************************************************************

 *

 * FUNCTION:    acpi_release_mutex

 *

 * PARAMETERS:  handle              - Mutex or prefix handle (optional)

 *              pathname            - Mutex pathname (optional)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Release an AML mutex. This is a device driver interface to

 *              AML mutex objects, and allows for transaction locking between

 *              drivers and AML code. The mutex node is pointed to by

 *              Handle:Pathname. Either Handle or Pathname can be NULL, but

 *              not both.

 *

 Get the low-level mutex associated with Handle:Pathname */

 Release the OS mutex */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: utosi - Support for the _OSI predefined control method

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/******************************************************************************

 *

 * ACPICA policy for new _OSI strings:

 *

 * It is the stated policy of ACPICA that new _OSI strings will be integrated

 * into this module as soon as possible after they are defined. It is strongly

 * recommended that all ACPICA hosts mirror this policy and integrate any

 * changes to this module as soon as possible. There are several historical

 * reasons behind this policy:

 *

 * 1) New BIOSs tend to test only the case where the host responds TRUE to

 *    the latest version of Windows, which would respond to the latest/newest

 *    _OSI string. Not responding TRUE to the latest version of Windows will

 *    risk executing untested code paths throughout the DSDT and SSDTs.

 *

 * 2) If a new _OSI string is recognized only after a significant delay, this

 *    has the potential to cause problems on existing working machines because

 *    of the possibility that a new and different path through the ASL code

 *    will be executed.

 *

 * 3) New _OSI strings are tending to come out about once per year. A delay

 *    in recognizing a new string for a significant amount of time risks the

 *    release of another string which only compounds the initial problem.

 *

/*

 * Strings supported by the _OSI predefined control method (which is

 * implemented internally within this module.)

 *

 * March 2009: Removed "Linux" as this host no longer wants to respond true

 * for this string. Basically, the only safe OS strings are windows-related

 * and in many or most cases represent the only test path within the

 * BIOS-provided ASL code.

 *

 * The last element of each entry is used to track the newest version of

 * Windows that the BIOS has requested.

 Operating System Vendor Strings */

 Windows 2000 */

 Windows XP */

 Windows XP SP1 */

 Windows Server 2003 */

 Windows XP SP2 */

 Windows Server 2003 SP1 - Added 03/2006 */

 Windows vista - Added 03/2006 */

 Windows Server 2008 - Added 09/2009 */

 Windows Vista SP1 - Added 09/2009 */

 Windows Vista SP2 - Added 09/2010 */

 Windows 7 and Server 2008 R2 - Added 09/2009 */

 Windows 8 and Server 2012 - Added 08/2012 */

 Windows 8.1 and Server 2012 R2 - Added 01/2014 */

 Windows 10 - Added 03/2015 */

 Windows 10 version 1607 - Added 12/2017 */

 Windows 10 version 1703 - Added 12/2017 */

 Windows 10 version 1709 - Added 02/2018 */

 Windows 10 version 1803 - Added 11/2018 */

 Windows 10 version 1809 - Added 11/2018 */

 Windows 10 version 1903 - Added 08/2019 */

 Windows 10 version 2004 - Added 08/2021 */

 Feature Group Strings */

	/*

	 * All "optional" feature group strings (features that are implemented

	 * by the host) should be dynamically modified to VALID by the host via

	 * acpi_install_interface or acpi_update_interfaces. Such optional feature

	 * group strings are set as INVALID by default here.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_initialize_interfaces

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Initialize the global _OSI supported interfaces list

 *

 Link the static list of supported interfaces */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_interface_terminate

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Delete all interfaces in the global list. Sets

 *              acpi_gbl_supported_interfaces to NULL.

 *

 Only interfaces added at runtime can be freed */

 Interface is in static list. Reset it to invalid or valid. */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_install_interface

 *

 * PARAMETERS:  interface_name      - The interface to install

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Install the interface into the global interface list.

 *              Caller MUST hold acpi_gbl_osi_mutex

 *

 Allocate info block and space for the name string */

 Initialize new info and insert at the head of the global list */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_remove_interface

 *

 * PARAMETERS:  interface_name      - The interface to remove

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Remove the interface from the global interface list.

 *              Caller MUST hold acpi_gbl_osi_mutex

 *

			/*

			 * Found: name is in either the static list

			 * or was added at runtime

 Interface was added dynamically, remove and free it */

				/*

				 * Interface is in static list. If marked invalid, then

				 * it does not actually exist. Else, mark it invalid.

 Interface was not found */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_update_interfaces

 *

 * PARAMETERS:  action              - Actions to be performed during the

 *                                    update

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Update _OSI interface strings, disabling or enabling OS vendor

 *              strings or/and feature group strings.

 *              Caller MUST hold acpi_gbl_osi_mutex

 *

 Mark the interfaces as invalid */

 Mark the interfaces as valid */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_interface

 *

 * PARAMETERS:  interface_name      - The interface to find

 *

 * RETURN:      struct acpi_interface_info if found. NULL if not found.

 *

 * DESCRIPTION: Search for the specified interface name in the global list.

 *              Caller MUST hold acpi_gbl_osi_mutex

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_osi_implementation

 *

 * PARAMETERS:  walk_state          - Current walk state

 *

 * RETURN:      Status

 *              Integer: TRUE (0) if input string is matched

 *                       FALSE (-1) if string is not matched

 *

 * DESCRIPTION: Implementation of the _OSI predefined control method. When

 *              an invocation of _OSI is encountered in the system AML,

 *              control is transferred to this function.

 *

 * (August 2016)

 * Note:  _OSI is now defined to return "Ones" to indicate a match, for

 * compatibility with other ACPI implementations. On a 32-bit DSDT, Ones

 * is 0xFFFFFFFF. On a 64-bit DSDT, Ones is 0xFFFFFFFFFFFFFFFF

 * (ACPI_UINT64_MAX).

 *

 * This function always returns ACPI_UINT64_MAX for TRUE, and later code

 * will truncate this to 32 bits if necessary.

 *

 Validate the string input argument (from the AML caller) */

 Create a return object */

 Default return value is 0, NOT SUPPORTED */

 Lookup the interface in the global _OSI list */

		/*

		 * The interface is supported.

		 * Update the osi_data if necessary. We keep track of the latest

		 * version of Windows that has been requested by the BIOS.

	/*

	 * Invoke an optional _OSI interface handler. The host OS may wish

	 * to do some interface-specific handling. For example, warn about

	 * certain interfaces or override the true/false support value.

 Complete the return object */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: utmutex - local mutex support

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_mutex_initialize

 *

 * PARAMETERS:  None.

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create the system mutex objects. This includes mutexes,

 *              spin locks, and reader/writer locks.

 *

 Create each of the predefined mutex objects */

 Create the spinlocks for use at interrupt level or for speed */

 Mutex for _OSI support */

 Create the reader/writer lock for namespace access */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_mutex_terminate

 *

 * PARAMETERS:  None.

 *

 * RETURN:      None.

 *

 * DESCRIPTION: Delete all of the system mutex objects. This includes mutexes,

 *              spin locks, and reader/writer locks.

 *

 Delete each predefined mutex object */

 Delete the spinlocks */

 Delete the reader/writer lock */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_create_mutex

 *

 * PARAMETERS:  mutex_ID        - ID of the mutex to be created

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create a mutex object.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_delete_mutex

 *

 * PARAMETERS:  mutex_ID        - ID of the mutex to be deleted

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Delete a mutex object.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_acquire_mutex

 *

 * PARAMETERS:  mutex_ID        - ID of the mutex to be acquired

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Acquire a mutex object.

 *

		/*

		 * Mutex debug code, for internal debugging only.

		 *

		 * Deadlock prevention. Check if this thread owns any mutexes of value

		 * greater than or equal to this one. If so, the thread has violated

		 * the mutex ordering rule. This indicates a coding error somewhere in

		 * the ACPI subsystem code.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_release_mutex

 *

 * PARAMETERS:  mutex_ID        - ID of the mutex to be released

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Release a mutex object.

 *

	/*

	 * Mutex must be acquired in order to release it!

		/*

		 * Mutex debug code, for internal debugging only.

		 *

		 * Deadlock prevention. Check if this thread owns any mutexes of value

		 * greater than this one. If so, the thread has violated the mutex

		 * ordering rule. This indicates a coding error somewhere in

		 * the ACPI subsystem code.

 Mark unlocked FIRST */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: evgpeblk - GPE block creation and initialization.

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Entire module */

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_install_gpe_block

 *

 * PARAMETERS:  gpe_block               - New GPE block

 *              interrupt_number        - Xrupt to be associated with this

 *                                        GPE block

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Install new GPE block with mutex support

 *

 Install the new block at the end of the list with lock */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_delete_gpe_block

 *

 * PARAMETERS:  gpe_block           - Existing GPE block

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Remove a GPE block

 *

 Disable all GPEs in this block */

 This is the last gpe_block on this interrupt */

 Remove the block on this interrupt with lock */

 Free the gpe_block */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_create_gpe_info_blocks

 *

 * PARAMETERS:  gpe_block   - New GPE block

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create the register_info and event_info blocks for this GPE block

 *

 Allocate the GPE register information block */

	/*

	 * Allocate the GPE event_info block. There are eight distinct GPEs

	 * per register. Initialization to zeros is sufficient.

 Save the new Info arrays in the GPE block */

	/*

	 * Initialize the GPE Register and Event structures. A goal of these

	 * tables is to hide the fact that there are two separate GPE register

	 * sets in a given GPE hardware block, the status registers occupy the

	 * first half, and the enable registers occupy the second half.

 Init the register_info for this GPE register (8 GPEs) */

 Init the event_info for each GPE within this register */

 Disable all GPEs within this register */

 Clear any pending GPE events within this register */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_create_gpe_block

 *

 * PARAMETERS:  gpe_device          - Handle to the parent GPE block

 *              gpe_block_address   - Address and space_ID

 *              register_count      - Number of GPE register pairs in the block

 *              gpe_block_base_number - Starting GPE number for the block

 *              interrupt_number    - H/W interrupt for the block

 *              return_gpe_block    - Where the new block descriptor is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create and Install a block of GPE registers. All GPEs within

 *              the block are disabled at exit.

 *              Note: Assumes namespace is locked.

 *

 Validate the space_ID */

 Allocate a new GPE block */

 Initialize the new GPE block */

	/*

	 * Create the register_info and event_info sub-structures

	 * Note: disables and clears all GPEs in the block

 Install the new block in the global lists */

 Find all GPE methods (_Lxx or_Exx) for this block */

 Return the new block */

 Update global count of currently available GPEs */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_initialize_gpe_block

 *

 * PARAMETERS:  acpi_gpe_callback

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Initialize and enable a GPE block. Enable GPEs that have

 *              associated methods.

 *              Note: Assumes namespace is locked.

 *

	/*

	 * Ignore a null GPE block (e.g., if no GPE block 1 exists), and

	 * any GPE blocks that have been initialized already.

	/*

	 * Enable all GPEs that have a corresponding method and have the

	 * ACPI_GPE_CAN_WAKE flag unset. Any other GPEs within this block

	 * must be enabled via the acpi_enable_gpe() interface.

 Get the info block for this particular GPE */

			/*

			 * Ignore GPEs that have no corresponding _Lxx/_Exx method

			 * and GPEs that are used for wakeup

 !ACPI_REDUCED_HARDWARE */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: dsargs - Support for execution of dynamic arguments for static

 *                       objects (regions, fields, buffer fields, etc.)

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_execute_arguments

 *

 * PARAMETERS:  node                - Object NS node

 *              scope_node          - Parent NS node

 *              aml_length          - Length of executable AML

 *              aml_start           - Pointer to the AML

 *

 * RETURN:      Status.

 *

 * DESCRIPTION: Late (deferred) execution of region or field arguments

 *

 Allocate a new parser op to be the root of the parsed tree */

 Save the Node for use in acpi_ps_parse_aml */

 Create and initialize a new parser state */

 Mark this parse as a deferred opcode */

 Pass1: Parse the entire declaration */

 Get and init the Op created above */

 Evaluate the deferred arguments */

 Create and initialize a new parser state */

 Execute the opcode and arguments */

 Mark this execution as a deferred opcode */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_get_buffer_field_arguments

 *

 * PARAMETERS:  obj_desc        - A valid buffer_field object

 *

 * RETURN:      Status.

 *

 * DESCRIPTION: Get buffer_field Buffer and Index. This implements the late

 *              evaluation of these field attributes.

 *

 Get the AML pointer (method object) and buffer_field node */

 Execute the AML code for the term_arg arguments */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_get_bank_field_arguments

 *

 * PARAMETERS:  obj_desc        - A valid bank_field object

 *

 * RETURN:      Status.

 *

 * DESCRIPTION: Get bank_field bank_value. This implements the late

 *              evaluation of these field attributes.

 *

 Get the AML pointer (method object) and bank_field node */

 Execute the AML code for the term_arg arguments */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_get_buffer_arguments

 *

 * PARAMETERS:  obj_desc        - A valid Buffer object

 *

 * RETURN:      Status.

 *

 * DESCRIPTION: Get Buffer length and initializer byte list. This implements

 *              the late evaluation of these attributes.

 *

 Get the Buffer node */

 Execute the AML code for the term_arg arguments */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_get_package_arguments

 *

 * PARAMETERS:  obj_desc        - A valid Package object

 *

 * RETURN:      Status.

 *

 * DESCRIPTION: Get Package length and initializer byte list. This implements

 *              the late evaluation of these attributes.

 *

 Get the Package node */

 Execute the AML code for the term_arg arguments */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_get_region_arguments

 *

 * PARAMETERS:  obj_desc        - A valid region object

 *

 * RETURN:      Status.

 *

 * DESCRIPTION: Get region address and length. This implements the late

 *              evaluation of these region attributes.

 *

 Get the Region node */

 Execute the argument AML */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: utglobal - Global variables for the ACPI subsystem

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * Static global variable initialization.

 *

 Various state name strings */

 Hex-to-ascii */

/*******************************************************************************

 *

 * Namespace globals

 *

/*

 * Predefined ACPI Names (Built-in to the Interpreter)

 *

 * NOTES:

 * 1) _SB_ is defined to be a device to allow \_SB_._INI to be run

 *    during the initialization sequence.

 * 2) _TZ_ is defined to be a thermal zone in order to allow ASL code to

 *    perform a Notify() operation on it. 09/2010: Changed to type Device.

 *    This still allows notifies, but does not confuse host code that

 *    searches for valid thermal_zone objects.

	/*

	 * March, 2015:

	 * The _REV object is in the process of being deprecated, because

	 * other ACPI implementations permanently return 2. Thus, it

	 * has little or no value. Return 2 for compatibility with

	 * other ACPI implementations.

 Table terminator */

/******************************************************************************

 *

 * Event and Hardware globals

 *

 Name                                     Parent Register             Register Bit Position                   Register Bit Mask       */

 ACPI_BITREG_TIMER_STATUS         */ {ACPI_REGISTER_PM1_STATUS,

 ACPI_BITREG_BUS_MASTER_STATUS    */ {ACPI_REGISTER_PM1_STATUS,

 ACPI_BITREG_GLOBAL_LOCK_STATUS   */ {ACPI_REGISTER_PM1_STATUS,

 ACPI_BITREG_POWER_BUTTON_STATUS  */ {ACPI_REGISTER_PM1_STATUS,

 ACPI_BITREG_SLEEP_BUTTON_STATUS  */ {ACPI_REGISTER_PM1_STATUS,

 ACPI_BITREG_RT_CLOCK_STATUS      */ {ACPI_REGISTER_PM1_STATUS,

 ACPI_BITREG_WAKE_STATUS          */ {ACPI_REGISTER_PM1_STATUS,

 ACPI_BITREG_PCIEXP_WAKE_STATUS   */ {ACPI_REGISTER_PM1_STATUS,

 ACPI_BITREG_TIMER_ENABLE         */ {ACPI_REGISTER_PM1_ENABLE,

 ACPI_BITREG_GLOBAL_LOCK_ENABLE   */ {ACPI_REGISTER_PM1_ENABLE,

 ACPI_BITREG_POWER_BUTTON_ENABLE  */ {ACPI_REGISTER_PM1_ENABLE,

 ACPI_BITREG_SLEEP_BUTTON_ENABLE  */ {ACPI_REGISTER_PM1_ENABLE,

 ACPI_BITREG_RT_CLOCK_ENABLE      */ {ACPI_REGISTER_PM1_ENABLE,

 ACPI_BITREG_PCIEXP_WAKE_DISABLE  */ {ACPI_REGISTER_PM1_ENABLE,

 ACPI_BITREG_SCI_ENABLE           */ {ACPI_REGISTER_PM1_CONTROL,

 ACPI_BITREG_BUS_MASTER_RLD       */ {ACPI_REGISTER_PM1_CONTROL,

 ACPI_BITREG_GLOBAL_LOCK_RELEASE  */ {ACPI_REGISTER_PM1_CONTROL,

 ACPI_BITREG_SLEEP_TYPE           */ {ACPI_REGISTER_PM1_CONTROL,

 ACPI_BITREG_SLEEP_ENABLE         */ {ACPI_REGISTER_PM1_CONTROL,

 ACPI_BITREG_ARB_DIS              */ {ACPI_REGISTER_PM2_CONTROL,

 ACPI_EVENT_PMTIMER       */ {ACPI_BITREG_TIMER_STATUS,

 ACPI_EVENT_GLOBAL        */ {ACPI_BITREG_GLOBAL_LOCK_STATUS,

 ACPI_EVENT_POWER_BUTTON  */ {ACPI_BITREG_POWER_BUTTON_STATUS,

 ACPI_EVENT_SLEEP_BUTTON  */ {ACPI_BITREG_SLEEP_BUTTON_STATUS,

 ACPI_EVENT_RTC           */ {ACPI_BITREG_RT_CLOCK_STATUS,

 !ACPI_REDUCED_HARDWARE */

 to_pld macro: compile/disassemble strings */

 Public globals */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: evxfregn - External Interfaces, ACPI Operation Regions and

 *                         Address Spaces.

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_install_address_space_handler

 *

 * PARAMETERS:  device          - Handle for the device

 *              space_id        - The address space ID

 *              handler         - Address of the handler

 *              setup           - Address of the setup function

 *              context         - Value passed to the handler on each access

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Install a handler for all op_regions of a given space_id.

 *

 * NOTE: This function should only be called after acpi_enable_subsystem has

 * been called. This is because any _REG methods associated with the Space ID

 * are executed here, and these methods can only be safely executed after

 * the default handlers have been installed and the hardware has been

 * initialized (via acpi_enable_subsystem.)

 *

 Parameter validation */

 Convert and validate the device handle */

 Install the handler for all Regions for this Space ID */

 Run all _REG methods for this address space */

/*******************************************************************************

 *

 * FUNCTION:    acpi_remove_address_space_handler

 *

 * PARAMETERS:  device          - Handle for the device

 *              space_id        - The address space ID

 *              handler         - Address of the handler

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Remove a previously installed handler.

 *

 Parameter validation */

 Convert and validate the device handle */

 Make sure the internal object exists */

 Find the address handler the user requested */

 We have a handler, see if user requested this one */

 Handler must be the same as the installed handler */

 Matched space_id, first dereference this in the Regions */

 Walk the handler's region list */

				/*

				 * First disassociate the handler from the region.

				 *

				 * NOTE: this doesn't mean that the region goes away

				 * The region is just inaccessible as indicated to

				 * the _REG method

				/*

				 * Walk the list: Just grab the head because the

				 * detach_region removed the previous head.

 Remove this Handler object from the list */

 Now we can delete the handler object */

 Walk the linked list of handlers */

 The handler does not exist */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: utinit - Common ACPI subsystem initialization

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

 !ACPI_REDUCED_HARDWARE */

/******************************************************************************

 *

 * FUNCTION:    acpi_ut_free_gpe_lists

 *

 * PARAMETERS:  none

 *

 * RETURN:      none

 *

 * DESCRIPTION: Free global GPE lists

 *

 Free global GPE blocks and related info structures */

 !ACPI_REDUCED_HARDWARE */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_init_globals

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Initialize ACPICA globals. All globals that require specific

 *              initialization should be initialized here. This allows for

 *              a warm restart.

 *

 Create all memory caches */

 Address Range lists */

 Mutex locked flags */

 Last owner_ID is never valid */

 Event counters */

 GPE/SCI support */

 !ACPI_REDUCED_HARDWARE */

 Global handlers */

 Global Lock support */

 Miscellaneous variables */

 Hardware oriented */

 Namespace */

/******************************************************************************

 *

 * FUNCTION:    acpi_ut_terminate

 *

 * PARAMETERS:  none

 *

 * RETURN:      none

 *

 * DESCRIPTION: Free global memory

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_subsystem_shutdown

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Shutdown the various components. Do not delete the mutex

 *              objects here, because the AML debugger may be still running.

 *

 Just exit if subsystem is already shutdown */

 Subsystem appears active, go ahead and shut it down */

 Close the acpi_event Handling */

 Delete any dynamic _OSI interfaces */

 Close the Namespace */

 Delete the ACPI tables */

 Close the globals */

 Purge the local caches */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: dbdisply - debug display commands

 *

 Local prototypes */

/*

 * System handler information.

 * Used for Handlers command, in acpi_db_display_handlers.

 All predefined Address Space IDs */

 Global handler information */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_get_pointer

 *

 * PARAMETERS:  target          - Pointer to string to be converted

 *

 * RETURN:      Converted pointer

 *

 * DESCRIPTION: Convert an ascii pointer value to a real value

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_dump_parser_descriptor

 *

 * PARAMETERS:  op              - A parser Op descriptor

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display a formatted parser object

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_decode_and_display_object

 *

 * PARAMETERS:  target          - String with object to be displayed. Names

 *                                and hex pointers are supported.

 *              output_type     - Byte, Word, Dword, or Qword (B|W|D|Q)

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display a formatted ACPI object

 *

 Decode the output type */

 Differentiate between a number and a name */

 Decode the object type */

 This is a namespace Node */

 This is a ACPI OPERAND OBJECT */

 This is a Parser Op object */

 Is not a recognizable object */

 Just dump some memory */

 The parameter is a name string that must be resolved to a Named obj */

 Now dump the NS node */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_method_info

 *

 * PARAMETERS:  start_op        - Root of the control method parse tree

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display information about the current method

 *

 Decode the opcode */

 Bad opcode or ASCII character */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_locals

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display all locals for the currently running control method

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_arguments

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display all arguments for the currently running control method

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_results

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display current contents of a method result stack

 *

 Index onto current frame */

 From the top element of result stack */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_calling_tree

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display current calling tree of nested control methods

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_object_type

 *

 * PARAMETERS:  object_arg      - User entered NS node handle

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display type of an arbitrary NS node

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_result_object

 *

 * PARAMETERS:  obj_desc        - Object to be displayed

 *              walk_state      - Current walk state

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display the result of an AML opcode

 *

 * Note: Currently only displays the result object if we are single stepping.

 * However, this output may be useful in other contexts and could be enabled

 * to do so if needed.

 *

 Only display if single stepping */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_argument_object

 *

 * PARAMETERS:  obj_desc        - Object to be displayed

 *              walk_state      - Current walk state

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display the result of an AML opcode

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_gpes

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display the current GPE structures

 *

 Walk the GPE lists */

 Examine each GPE Register within the block */

 Now look at the individual GPEs in this byte register */

 This GPE is not used (no method or handler), ignore it */

 Decode the flags byte */

 !ACPI_REDUCED_HARDWARE */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_handlers

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display the currently installed global handlers

 *

 Operation region handlers */

 There is no handler for this space_id */

 Find all handlers for user-defined space_IDs */

 Fixed event handlers */

 !ACPI_REDUCED_HARDWARE */

 Miscellaneous global handlers */

 Other handlers that are installed throughout the namespace */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_non_root_handlers

 *

 * PARAMETERS:  acpi_walk_callback

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Display information about all handlers installed for a

 *              device object.

 *

 Display all handlers associated with this device */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exdump - Interpreter debug output routines

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*

 * The following routines are used for debug output only

 Local prototypes */

/*******************************************************************************

 *

 * Object Descriptor info tables

 *

 * Note: The first table entry must be an INIT opcode and must contain

 * the table length (number of table entries)

 *

 Miscellaneous tables */

 Dispatch table, indexed by object type */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_dump_object

 *

 * PARAMETERS:  obj_desc            - Descriptor to dump

 *              info                - Info table corresponding to this object

 *                                    type

 *

 * RETURN:      None

 *

 * DESCRIPTION: Walk the info table for this object

 *

 First table entry must contain the table length (# of table entries) */

 Dump the package contents */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_dump_operand

 *

 * PARAMETERS:  *obj_desc       - Pointer to entry to be dumped

 *              depth           - Current nesting depth

 *

 * RETURN:      None

 *

 * DESCRIPTION: Dump an operand object

 *

 Check if debug output enabled */

 This could be a null element of a package */

 obj_desc is a valid object */

 Decode object type */

 Unknown reference class */

 Debug only -- dump the buffer contents */

		/*

		 * If elements exist, package element pointer is valid,

		 * and debug_level exceeds 1, dump package's elements.

		/*

		 * If the address and length have not been evaluated,

		 * don't print them.

 Unknown Type */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_dump_operands

 *

 * PARAMETERS:  operands            - A list of Operand objects

 *		opcode_name	    - AML opcode name

 *		num_operands	    - Operand count for this opcode

 *

 * DESCRIPTION: Dump the operands associated with the opcode

 *

 Dump the individual operands */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_out* functions

 *

 * PARAMETERS:  title               - Descriptive text

 *              value               - Value to be displayed

 *

 * DESCRIPTION: Object dump output formatting functions. These functions

 *              reduce the number of format strings required and keeps them

 *              all in one place for easy modification.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_dump_namespace_node

 *

 * PARAMETERS:  node                - Descriptor to dump

 *              flags               - Force display if TRUE

 *

 * DESCRIPTION: Dumps the members of the given.Node

 *

 Check if debug output enabled */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_dump_reference_obj

 *

 * PARAMETERS:  object              - Descriptor to dump

 *

 * DESCRIPTION: Dumps a reference object

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_dump_package_obj

 *

 * PARAMETERS:  obj_desc            - Descriptor to dump

 *              level               - Indentation Level

 *              index               - Package index for this object

 *

 * DESCRIPTION: Dumps the elements of the package

 *

 Indentation and index output */

 Null package elements are allowed */

 Packages may only contain a few object types */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_dump_object_descriptor

 *

 * PARAMETERS:  obj_desc            - Descriptor to dump

 *              flags               - Force display if TRUE

 *

 * DESCRIPTION: Dumps the members of the object descriptor given.

 *

 Check if debug output enabled */

 Validate the object type */

 Common Fields */

 Object-specific fields */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: hwxface - Public ACPICA hardware interfaces

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/******************************************************************************

 *

 * FUNCTION:    acpi_reset

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Set reset register in memory or IO space. Note: Does not

 *              support reset register in PCI config space, this must be

 *              handled separately.

 *

 Check if the reset register is supported */

		/*

		 * For I/O space, write directly to the OSL. This bypasses the port

		 * validation mechanism, which may block a valid write to the reset

		 * register.

		 *

		 * NOTE:

		 * The ACPI spec requires the reset register width to be 8, so we

		 * hardcode it here and ignore the FADT value. This maintains

		 * compatibility with other ACPI implementations that have allowed

		 * BIOS code with bad register width values to go unnoticed.

 Write the reset value to the reset register */

/******************************************************************************

 *

 * FUNCTION:    acpi_read

 *

 * PARAMETERS:  value               - Where the value is returned

 *              reg                 - GAS register structure

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Read from either memory or IO space.

 *

 * LIMITATIONS: <These limitations also apply to acpi_write>

 *      bit_width must be exactly 8, 16, 32, or 64.

 *      space_ID must be system_memory or system_IO.

 *      bit_offset and access_width are currently ignored, as there has

 *          not been a need to implement these.

 *

/******************************************************************************

 *

 * FUNCTION:    acpi_write

 *

 * PARAMETERS:  value               - Value to be written

 *              reg                 - GAS register structure

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Write to either memory or IO space.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_read_bit_register

 *

 * PARAMETERS:  register_id     - ID of ACPI Bit Register to access

 *              return_value    - Value that was read from the register,

 *                                normalized to bit position zero.

 *

 * RETURN:      Status and the value read from the specified Register. Value

 *              returned is normalized to bit0 (is shifted all the way right)

 *

 * DESCRIPTION: ACPI bit_register read function. Does not acquire the HW lock.

 *

 * SUPPORTS:    Bit fields in PM1 Status, PM1 Enable, PM1 Control, and

 *              PM2 Control.

 *

 * Note: The hardware lock is not required when reading the ACPI bit registers

 *       since almost all of them are single bit and it does not matter that

 *       the parent hardware register can be split across two physical

 *       registers. The only multi-bit field is SLP_TYP in the PM1 control

 *       register, but this field does not cross an 8-bit boundary (nor does

 *       it make much sense to actually read this field.)

 *

 Get the info structure corresponding to the requested ACPI Register */

 Read the entire parent register */

 Normalize the value that was read, mask off other bits */

/*******************************************************************************

 *

 * FUNCTION:    acpi_write_bit_register

 *

 * PARAMETERS:  register_id     - ID of ACPI Bit Register to access

 *              value           - Value to write to the register, in bit

 *                                position zero. The bit is automatically

 *                                shifted to the correct position.

 *

 * RETURN:      Status

 *

 * DESCRIPTION: ACPI Bit Register write function. Acquires the hardware lock

 *              since most operations require a read/modify/write sequence.

 *

 * SUPPORTS:    Bit fields in PM1 Status, PM1 Enable, PM1 Control, and

 *              PM2 Control.

 *

 * Note that at this level, the fact that there may be actually two

 * hardware registers (A and B - and B may not exist) is abstracted.

 *

 Get the info structure corresponding to the requested ACPI Register */

	/*

	 * At this point, we know that the parent register is one of the

	 * following: PM1 Status, PM1 Enable, PM1 Control, or PM2 Control

		/*

		 * 1) Case for PM1 Enable, PM1 Control, and PM2 Control

		 *

		 * Perform a register read to preserve the bits that we are not

		 * interested in

		/*

		 * Insert the input bit into the value that was just read

		 * and write the register

		/*

		 * 2) Case for PM1 Status

		 *

		 * The Status register is different from the rest. Clear an event

		 * by writing 1, writing 0 has no effect. So, the only relevant

		 * information is the single bit we're interested in, all others

		 * should be written as 0 so they will be left unchanged.

 No need to write the register if value is all zeros */

 !ACPI_REDUCED_HARDWARE */

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_sleep_type_data

 *

 * PARAMETERS:  sleep_state         - Numeric sleep state

 *              *sleep_type_a        - Where SLP_TYPa is returned

 *              *sleep_type_b        - Where SLP_TYPb is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Obtain the SLP_TYPa and SLP_TYPb values for the requested

 *              sleep state via the appropriate \_Sx object.

 *

 *  The sleep state package returned from the corresponding \_Sx_ object

 *  must contain at least one integer.

 *

 *  March 2005:

 *  Added support for a package that contains two integers. This

 *  goes against the ACPI specification which defines this object as a

 *  package with one encoded DWORD integer. However, existing practice

 *  by many BIOS vendors is to return a package with 2 or more integer

 *  elements, at least one per sleep type (A/B).

 *

 *  January 2013:

 *  Therefore, we must be prepared to accept a package with either a

 *  single integer or multiple integers.

 *

 *  The single integer DWORD format is as follows:

 *      BYTE 0 - Value for the PM1A SLP_TYP register

 *      BYTE 1 - Value for the PM1B SLP_TYP register

 *      BYTE 2-3 - Reserved

 *

 *  The dual integer format is as follows:

 *      Integer 0 - Value for the PM1A SLP_TYP register

 *      Integer 1 - Value for the PM1A SLP_TYP register

 *

 Validate parameters */

 Allocate the evaluation information block */

	/*

	 * Evaluate the \_Sx namespace object containing the register values

	 * for this state

 The _Sx states are optional, ignore NOT_FOUND */

 Must have a return object */

 Return object must be of type Package */

	/*

	 * Any warnings about the package length or the object types have

	 * already been issued by the predefined name module -- there is no

	 * need to repeat them here.

 A valid _Sx_ package with one integer */

 A valid _Sx_ package with two integers */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exfldio - Aml Field I/O

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_setup_region

 *

 * PARAMETERS:  obj_desc                - Field to be read or written

 *              field_datum_byte_offset - Byte offset of this datum within the

 *                                        parent field

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Common processing for acpi_ex_extract_from_field and

 *              acpi_ex_insert_into_field. Initialize the Region if necessary and

 *              validate the request.

 *

 We must have a valid region */

 Validate the Space ID */

	/*

	 * If the Region Address and Length have not been previously evaluated,

	 * evaluate them now and save the results.

	/*

	 * Exit now for SMBus, GSBus or IPMI address space, it has a non-linear

	 * address space and the request cannot be directly validated

 SMBus or IPMI has a non-linear address space */

	/*

	 * If the Field access is any_acc, we can now compute the optimal

	 * access (because we know know the length of the parent region)

	/*

	 * Validate the request. The entire request from the byte offset for a

	 * length of one field datum (access width) must fit within the region.

	 * (Region length is specified in bytes)

			/*

			 * Slack mode only:  We will go ahead and allow access to this

			 * field if it is within the region length rounded up to the next

			 * access width boundary. acpi_size cast for 64-bit compile.

			/*

			 * This is the case where the access_type (acc_word, etc.) is wider

			 * than the region itself. For example, a region of length one

			 * byte, and a field with Dword access specified.

		/*

		 * Offset rounded up to next multiple of field width

		 * exceeds region length, indicate an error

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_access_region

 *

 * PARAMETERS:  obj_desc                - Field to be read

 *              field_datum_byte_offset - Byte offset of this datum within the

 *                                        parent field

 *              value                   - Where to store value (must at least

 *                                        64 bits)

 *              function                - Read or Write flag plus other region-

 *                                        dependent flags

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Read or Write a single field datum to an Operation Region.

 *

	/*

	 * Ensure that the region operands are fully evaluated and verify

	 * the validity of the request

	/*

	 * The physical address of this field datum is:

	 *

	 * 1) The base of the region, plus

	 * 2) The base offset of the field, plus

	 * 3) The current offset into the field

 Invoke the appropriate address_space/op_region handler */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_register_overflow

 *

 * PARAMETERS:  obj_desc                - Register(Field) to be written

 *              value                   - Value to be stored

 *

 * RETURN:      TRUE if value overflows the field, FALSE otherwise

 *

 * DESCRIPTION: Check if a value is out of range of the field being written.

 *              Used to check if the values written to Index and Bank registers

 *              are out of range. Normally, the value is simply truncated

 *              to fit the field, but this case is most likely a serious

 *              coding error in the ASL.

 *

		/*

		 * The field is large enough to hold the maximum integer, so we can

		 * never overflow it.

		/*

		 * The Value is larger than the maximum value that can fit into

		 * the register.

 The Value will fit into the field with no truncation */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_field_datum_io

 *

 * PARAMETERS:  obj_desc                - Field to be read

 *              field_datum_byte_offset - Byte offset of this datum within the

 *                                        parent field

 *              value                   - Where to store value (must be 64 bits)

 *              read_write              - Read or Write flag

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Read or Write a single datum of a field. The field_type is

 *              demultiplexed here to handle the different types of fields

 *              (buffer_field, region_field, index_field, bank_field)

 *

 To support reads without saving return value */

 Clear the entire return buffer first, [Very Important!] */

	/*

	 * The four types of fields are:

	 *

	 * buffer_field - Read/write from/to a Buffer

	 * region_field - Read/write from/to a Operation Region.

	 * bank_field  - Write to a Bank Register, then read/write from/to an

	 *               operation_region

	 * index_field - Write to an Index Register, then read/write from/to a

	 *               Data Register

		/*

		 * If the buffer_field arguments have not been previously evaluated,

		 * evaluate them now and save the results.

			/*

			 * Copy the data from the source buffer.

			 * Length is the field width in bytes.

			/*

			 * Copy the data to the target buffer.

			 * Length is the field width in bytes.

		/*

		 * Ensure that the bank_value is not beyond the capacity of

		 * the register

		/*

		 * For bank_fields, we must write the bank_value to the bank_register

		 * (itself a region_field) before we can access the data.

		/*

		 * Now that the Bank has been selected, fall through to the

		 * region_field case and write the datum to the Operation Region

		/*

		 * For simple region_fields, we just directly access the owning

		 * Operation Region.

		/*

		 * Ensure that the index_value is not beyond the capacity of

		 * the register

 Write the index value to the index_register (itself a region_field) */

 Read the datum from the data_register */

 Write the datum to the data_register */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_write_with_update_rule

 *

 * PARAMETERS:  obj_desc                - Field to be written

 *              mask                    - bitmask within field datum

 *              field_value             - Value to write

 *              field_datum_byte_offset - Offset of datum within field

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Apply the field update rule to a field write

 *

 Start with the new bits  */

 If the mask is all ones, we don't need to worry about the update rule */

 Decode the update rule */

			/*

			 * Check if update rule needs to be applied (not if mask is all

			 * ones)  The left shift drops the bits we want to ignore.

				/*

				 * Read the current contents of the byte/word/dword containing

				 * the field, and merge with the new field value.

 Set positions outside the field to all ones */

 Set positions outside the field to all zeros */

 Write the merged value */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_extract_from_field

 *

 * PARAMETERS:  obj_desc            - Field to be read

 *              buffer              - Where to store the field data

 *              buffer_length       - Length of Buffer

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Retrieve the current value of the given field

 *

 Validate target buffer and clear it */

 Handle the simple case here */

 Use raw_datum (u64) to handle buffers < 64 bits */

 TBD: Move to common setup code */

 Field algorithm is limited to sizeof(u64), truncate if needed */

 Compute the number of datums (access width data items) */

 Priming read from the field */

 Read the rest of the field */

 Get next input datum from the field */

		/*

		 * Merge with previous datum if necessary.

		 *

		 * Note: Before the shift, check if the shift value will be larger than

		 * the integer size. If so, there is no need to perform the operation.

		 * This avoids the differences in behavior between different compilers

		 * concerning shift values larger than the target data width.

 Write merged datum to target buffer */

 Mask off any extra bits in the last datum */

 Write the last datum to the buffer */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_insert_into_field

 *

 * PARAMETERS:  obj_desc            - Field to be written

 *              buffer              - Data to be written

 *              buffer_length       - Length of Buffer

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Store the Buffer contents into the given field

 *

 Validate input buffer */

	/*

	 * We must have a buffer that is at least as long as the field

	 * we are writing to. This is because individual fields are

	 * indivisible and partial writes are not supported -- as per

	 * the ACPI specification.

 We need to create a new buffer */

		/*

		 * Copy the original data to the new buffer, starting

		 * at Byte zero. All unused (upper) bytes of the

		 * buffer will be 0.

 TBD: Move to common setup code */

 Algo is limited to sizeof(u64), so cut the access_byte_width */

 Create the bitmasks used for bit insertion */

 Compute the number of datums (access width data items) */

 Get initial Datum from the input buffer */

 Write the entire field */

 Write merged datum to the target field */

		/*

		 * Start new output datum by merging with previous input datum

		 * if necessary.

		 *

		 * Note: Before the shift, check if the shift value will be larger than

		 * the integer size. If so, there is no need to perform the operation.

		 * This avoids the differences in behavior between different compilers

		 * concerning shift values larger than the target data width.

 Get the next input datum from the buffer */

 Mask off any extra bits in the last datum */

 Write the last datum to the field */

 Free temporary buffer if we used one */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: utuuid -- UUID support functions

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*

 * UUID support functions.

 *

 * This table is used to convert an input UUID ascii string to a 16 byte

 * buffer and the reverse. The table maps a UUID buffer index 0-15 to

 * the index within the 36-byte UUID string where the associated 2-byte

 * hex value can be found.

 *

 * 36-byte UUID strings are of the form:

 *     aabbccdd-eeff-gghh-iijj-kkllmmnnoopp

 * Where aa-pp are one byte hex numbers, made up of two hex digits

 *

 * Note: This table is basically the inverse of the string-to-offset table

 * found in the ACPI spec in the description of the to_UUID macro.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_convert_string_to_uuid

 *

 * PARAMETERS:  in_string           - 36-byte formatted UUID string

 *              uuid_buffer         - Where the 16-byte UUID buffer is returned

 *

 * RETURN:      None. Output data is returned in the uuid_buffer

 *

 * DESCRIPTION: Convert a 36-byte formatted UUID string to 16-byte UUID buffer

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_convert_uuid_to_string

 *

 * PARAMETERS:  uuid_buffer         - 16-byte UUID buffer

 *              out_string          - 36-byte formatted UUID string

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Convert 16-byte UUID buffer to 36-byte formatted UUID string

 *              out_string must be 37 bytes to include null terminator.

 *

 Insert required hyphens (dashes) */

 Null terminate */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: hwpci - Obtain PCI bus, device, and function numbers

 *

 PCI configuration space values */

 PCI header values */

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_hw_derive_pci_id

 *

 * PARAMETERS:  pci_id              - Initial values for the PCI ID. May be

 *                                    modified by this function.

 *              root_pci_device     - A handle to a PCI device object. This

 *                                    object must be a PCI Root Bridge having a

 *                                    _HID value of either PNP0A03 or PNP0A08

 *              pci_region          - A handle to a PCI configuration space

 *                                    Operation Region being initialized

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function derives a full PCI ID for a PCI device,

 *              consisting of a Segment number, Bus number, Device number,

 *              and function code.

 *

 *              The PCI hardware dynamically configures PCI bus numbers

 *              depending on the bus topology discovered during system

 *              initialization. This function is invoked during configuration

 *              of a PCI_Config Operation Region in order to (possibly) update

 *              the Bus/Device/Function numbers in the pci_id with the actual

 *              values as determined by the hardware and operating system

 *              configuration.

 *

 *              The pci_id parameter is initially populated during the Operation

 *              Region initialization. This function is then called, and is

 *              will make any necessary modifications to the Bus, Device, or

 *              Function number PCI ID subfields as appropriate for the

 *              current hardware and OS configuration.

 *

 * NOTE:        Created 08/2010. Replaces the previous OSL acpi_os_derive_pci_id

 *              interface since this feature is OS-independent. This module

 *              specifically avoids any use of recursion by building a local

 *              temporary device list.

 *

 Build a list of PCI devices, from pci_region up to root_pci_device */

 Walk the list, updating the PCI device/function/bus numbers */

 Delete the list */

/*******************************************************************************

 *

 * FUNCTION:    acpi_hw_build_pci_list

 *

 * PARAMETERS:  root_pci_device     - A handle to a PCI device object. This

 *                                    object is guaranteed to be a PCI Root

 *                                    Bridge having a _HID value of either

 *                                    PNP0A03 or PNP0A08

 *              pci_region          - A handle to the PCI configuration space

 *                                    Operation Region

 *              return_list_head    - Where the PCI device list is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Builds a list of devices from the input PCI region up to the

 *              Root PCI device for this namespace subtree.

 *

	/*

	 * Ascend namespace branch until the root_pci_device is reached, building

	 * a list of device nodes. Loop will exit when either the PCI device is

	 * found, or the root of the namespace is reached.

 Must delete the list before exit */

 Finished when we reach the PCI root device (PNP0A03 or PNP0A08) */

 Must delete the list before exit */

 Put new element at the head of the list */

/*******************************************************************************

 *

 * FUNCTION:    acpi_hw_process_pci_list

 *

 * PARAMETERS:  pci_id              - Initial values for the PCI ID. May be

 *                                    modified by this function.

 *              list_head           - Device list created by

 *                                    acpi_hw_build_pci_list

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Walk downward through the PCI device list, getting the device

 *              info for each, via the PCI configuration space and updating

 *              the PCI ID as necessary. Deletes the list during traversal.

 *

	/*

	 * Descend down the namespace tree, collecting PCI device, function,

	 * and bus numbers. bus_number is only important for PCI bridges.

	 * Algorithm: As we descend the tree, use the last valid PCI device,

	 * function, and bus numbers that are discovered, and assign them

	 * to the PCI ID for the target device.

/*******************************************************************************

 *

 * FUNCTION:    acpi_hw_delete_pci_list

 *

 * PARAMETERS:  list_head           - Device list created by

 *                                    acpi_hw_build_pci_list

 *

 * RETURN:      None

 *

 * DESCRIPTION: Free the entire PCI list.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_hw_get_pci_device_info

 *

 * PARAMETERS:  pci_id              - Initial values for the PCI ID. May be

 *                                    modified by this function.

 *              pci_device          - Handle for the PCI device object

 *              bus_number          - Where a PCI bridge bus number is returned

 *              is_bridge           - Return value, indicates if this PCI

 *                                    device is a PCI bridge

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Get the device info for a single PCI device object. Get the

 *              _ADR (contains PCI device and function numbers), and for PCI

 *              bridge devices, get the bus number from PCI configuration

 *              space.

 *

 We only care about objects of type Device */

 We need an _ADR. Ignore device if not present */

	/*

	 * From _ADR, get the PCI Device and Function and

	 * update the PCI ID.

	/*

	 * If the previous device was a bridge, use the previous

	 * device bus number

	/*

	 * Get the bus numbers from PCI Config space:

	 *

	 * First, get the PCI header_type

 We only care about bridges (1=pci_bridge, 2=card_bus_bridge) */

 Bridge: Get the Primary bus_number */

 Bridge: Get the Secondary bus_number */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: psargs - Parse AML opcode arguments

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_get_next_package_length

 *

 * PARAMETERS:  parser_state        - Current parser state object

 *

 * RETURN:      Decoded package length. On completion, the AML pointer points

 *              past the length byte or bytes.

 *

 * DESCRIPTION: Decode and return a package length field.

 *              Note: Largest package length is 28 bits, from ACPI specification

 *

 Default [0:5] */

	/*

	 * Byte 0 bits [6:7] contain the number of additional bytes

	 * used to encode the package length, either 0,1,2, or 3

 Get bytes 3, 2, 1 as needed */

		/*

		 * Final bit positions for the package length bytes:

		 *      Byte3->[20:27]

		 *      Byte2->[12:19]

		 *      Byte1->[04:11]

		 *      Byte0->[00:03]

 Use bits [0:3] of byte 0 */

 Byte 0 is a special case, either bits [0:3] or [0:5] are used */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_get_next_package_end

 *

 * PARAMETERS:  parser_state        - Current parser state object

 *

 * RETURN:      Pointer to end-of-package +1

 *

 * DESCRIPTION: Get next package length and return a pointer past the end of

 *              the package. Consumes the package length field

 *

 Function below updates parser_state->Aml */

 end of package */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_get_next_namestring

 *

 * PARAMETERS:  parser_state        - Current parser state object

 *

 * RETURN:      Pointer to the start of the name string (pointer points into

 *              the AML.

 *

 * DESCRIPTION: Get next raw namestring within the AML stream. Handles all name

 *              prefix characters. Set parser state to point past the string.

 *              (Name is consumed from the AML.)

 *

 Point past any namestring prefix characters (backslash or carat) */

 Decode the path prefix character */

 null_name */

 Two name segments */

 Multiple name segments, 4 chars each, count in next byte */

 Single name segment */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_get_next_namepath

 *

 * PARAMETERS:  parser_state        - Current parser state object

 *              arg                 - Where the namepath will be stored

 *              arg_count           - If the namepath points to a control method

 *                                    the method's argument is returned here.

 *              possible_method_call - Whether the namepath can possibly be the

 *                                    start of a method call

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Get next name (if method call, return # of required args).

 *              Names are looked up in the internal namespace to determine

 *              if the name represents a control method. If a method

 *              is found, the number of arguments to the method is returned.

 *              This information is critical for parsing to continue correctly.

 *

 Null path case is allowed, just exit */

	/*

	 * Lookup the name in the internal namespace, starting with the current

	 * scope. We don't want to add anything new to the namespace here,

	 * however, so we use MODE_EXECUTE.

	 * Allow searching of the parent tree, but don't open a new scope -

	 * we just want to lookup the object (must be mode EXECUTE to perform

	 * the upsearch)

	/*

	 * If this name is a control method invocation, we must

	 * setup the method call

			/*

			 * acpi_ps_get_next_namestring has increased the AML pointer past

			 * the method invocation namestring, so we need to restore the

			 * saved AML pointer back to the original method invocation

			 * namestring.

 This name is actually a control method invocation */

 Change Arg into a METHOD CALL and attach name to it */

 Point METHODCALL/NAME to the METHOD Node */

 Get the number of arguments to expect */

	/*

	 * Special handling if the name was not found during the lookup -

	 * some not_found cases are allowed

 1) not_found is ok during load pass 1/2 (allow forward references) */

 2) not_found during a cond_ref_of(x) is ok by definition */

		/*

		 * 3) not_found while building a Package is ok at this point, we

		 * may flag as an error later if slack mode is not enabled.

		 * (Some ASL code depends on allowing this behavior)

 Final exception check (may have been changed from code above) */

 Report a control method execution error */

 Save the namepath */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_get_next_simple_arg

 *

 * PARAMETERS:  parser_state        - Current parser state object

 *              arg_type            - The argument type (AML_*_ARG)

 *              arg                 - Where the argument is returned

 *

 * RETURN:      None

 *

 * DESCRIPTION: Get the next simple argument (constant, string, or namestring)

 *

 Get 1 byte from the AML stream */

 Get 2 bytes from the AML stream */

 Get 4 bytes from the AML stream */

 Get 8 bytes from the AML stream */

 Get a pointer to the string, point past the string */

 Find the null terminator */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_get_next_field

 *

 * PARAMETERS:  parser_state        - Current parser state object

 *

 * RETURN:      A newly allocated FIELD op

 *

 * DESCRIPTION: Get next field (named_field, reserved_field, or access_field)

 *

 Determine field type */

 Allocate a new field op */

 Decode the field type */

 Get the 4-character name */

		/*

		 * Because the package length isn't represented as a parse tree object,

		 * take comments surrounding this and add to the previously created

		 * parse node.

 Get the length which is encoded as a package length */

 Get the length which is encoded as a package length */

		/*

		 * Get access_type and access_attrib and merge into the field Op

		 * access_type is first operand, access_attribute is second. stuff

		 * these bytes into the node integer value for convenience.

 Get the two bytes (Type/Attribute) */

 This opcode has a third byte, access_length */

		/*

		 * Argument for Connection operator can be either a Buffer

		 * (resource descriptor), or a name_string.

 Non-empty list */

 Get the actual buffer length argument */

 AML_BYTEDATA_ARG */

 AML_WORDDATA_ARG */

 AML_DWORDATA_ARG */

 Fill in bytelist data */

 Skip to End of byte data */

 Get the Namestring argument */

 Link the buffer/namestring to parent (CONNECTION_OP) */

 Opcode was set in previous switch */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_get_next_arg

 *

 * PARAMETERS:  walk_state          - Current state

 *              parser_state        - Current parser state object

 *              arg_type            - The argument type (AML_*_ARG)

 *              return_arg          - Where the next arg is returned

 *

 * RETURN:      Status, and an op object containing the next argument.

 *

 * DESCRIPTION: Get next argument (including complex list arguments that require

 *              pushing the parser stack)

 *

 Constants, strings, and namestrings are all the same size */

 Package length, nothing returned */

 Non-empty list */

 Skip to End of byte data */

 Non-empty list */

 Fill in bytelist data */

 Skip to End of byte data */

 null_name or name_string */

 Single complex argument, nothing returned */

 NULL target (zero). Convert to a NULL namepath */

 Free method call op and corresponding namestring sub-ob */

 Single complex argument, nothing returned */

 Single complex argument, nothing returned */

 Non-empty list of variable arguments, nothing returned */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: dbconvert - debugger miscellaneous conversion routines

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_hex_char_to_value

 *

 * PARAMETERS:  hex_char            - Ascii Hex digit, 0-9|a-f|A-F

 *              return_value        - Where the converted value is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Convert a single hex character to a 4-bit number (0-16).

 *

 Digit must be ascii [0-9a-fA-F] */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_hex_byte_to_binary

 *

 * PARAMETERS:  hex_byte            - Double hex digit (0x00 - 0xFF) in format:

 *                                    hi_byte then lo_byte.

 *              return_value        - Where the converted value is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Convert two hex characters to an 8 bit number (0 - 255).

 *

 High byte */

 Low byte */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_convert_to_buffer

 *

 * PARAMETERS:  string              - Input string to be converted

 *              object              - Where the buffer object is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Convert a string to a buffer object. String is treated a list

 *              of buffer elements, each separated by a space or comma.

 *

 Skip all preceding white space */

 Generate the final buffer length */

 Convert the command line bytes to the buffer */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_convert_to_package

 *

 * PARAMETERS:  string              - Input string to be converted

 *              object              - Where the package object is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Convert a string to a package object. Handles nested packages

 *              via recursion with acpi_db_convert_to_object.

 *

 Recursive call to convert each package element */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_convert_to_object

 *

 * PARAMETERS:  type                - Object type as determined by parser

 *              string              - Input string to be converted

 *              object              - Where the new object is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Convert a typed and tokenized string to a union acpi_object. Typing:

 *              1) String objects were surrounded by quotes.

 *              2) Buffer objects were surrounded by parentheses.

 *              3) Package objects were surrounded by brackets "[]".

 *              4) All standalone tokens are treated as integers.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_encode_pld_buffer

 *

 * PARAMETERS:  pld_info            - _PLD buffer struct (Using local struct)

 *

 * RETURN:      Encode _PLD buffer suitable for return value from _PLD

 *

 * DESCRIPTION: Bit-packs a _PLD buffer struct. Used to test the _PLD macros

 *

 First 32 bits */

 Second 32 bits */

 Third 32 bits */

 Fourth 32 bits */

 Fifth 32 bits */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_dump_pld_buffer

 *

 * PARAMETERS:  obj_desc            - Object returned from _PLD method

 *

 * RETURN:      None.

 *

 * DESCRIPTION: Dumps formatted contents of a _PLD return buffer.

 *

 Object must be of type Package with at least one Buffer element */

 Convert _PLD buffer to local _PLD struct */

 Encode local _PLD struct back to a _PLD buffer */

 The two bit-packed buffers should match */

 First 32-bit dword */

 Second 32-bit dword */

 Third 32-bit dword */

 Fourth 32-bit dword */

 Fifth 32-bit dword */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: utownerid - Support for Table/Method Owner IDs

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_allocate_owner_id

 *

 * PARAMETERS:  owner_id        - Where the new owner ID is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Allocate a table or method owner ID. The owner ID is used to

 *              track objects created by the table or method, to be deleted

 *              when the method exits or the table is unloaded.

 *

 Guard against multiple allocations of ID to the same location */

 Mutex for the global ID mask */

	/*

	 * Find a free owner ID, cycle through all possible IDs on repeated

	 * allocations. (ACPI_NUM_OWNERID_MASKS + 1) because first index

	 * may have to be scanned twice.

 Wraparound to start of mask array */

 There are no free IDs in this mask */

			/*

			 * Note: the u32 cast ensures that 1 is stored as a unsigned

			 * integer. Omitting the cast may result in 1 being stored as an

			 * int. Some compilers or runtime error detection may flag this as

			 * an error.

				/*

				 * Found a free ID. The actual ID is the bit index plus one,

				 * making zero an invalid Owner ID. Save this as the last ID

				 * allocated and update the global ID mask.

				/*

				 * Construct encoded ID from the index and bit position

				 *

				 * Note: Last [j].k (bit 4095) is never used and is marked

				 * permanently allocated (prevents +1 overflow)

	/*

	 * All owner_ids have been allocated. This typically should

	 * not happen since the IDs are reused after deallocation. The IDs are

	 * allocated upon table load (one per table) and method execution, and

	 * they are released when a table is unloaded or a method completes

	 * execution.

	 *

	 * If this error happens, there may be very deep nesting of invoked

	 * control methods, or there may be a bug where the IDs are not released.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_release_owner_id

 *

 * PARAMETERS:  owner_id_ptr        - Pointer to a previously allocated owner_ID

 *

 * RETURN:      None. No error is returned because we are either exiting a

 *              control method or unloading a table. Either way, we would

 *              ignore any error anyway.

 *

 * DESCRIPTION: Release a table or method owner ID. Valid IDs are 1 - 255

 *

 Always clear the input owner_id (zero is an invalid ID) */

 Zero is not a valid owner_ID */

 Mutex for the global ID mask */

 Normalize the ID to zero */

 Decode ID to index/offset pair */

 Free the owner ID only if it is valid */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: nsnames - Name manipulation and search

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_get_external_pathname

 *

 * PARAMETERS:  node            - Namespace node whose pathname is needed

 *

 * RETURN:      Pointer to storage containing the fully qualified name of

 *              the node, In external format (name segments separated by path

 *              separators.)

 *

 * DESCRIPTION: Used to obtain the full pathname to a namespace node, usually

 *              for error and debug statements.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_get_pathname_length

 *

 * PARAMETERS:  node        - Namespace node

 *

 * RETURN:      Length of path, including prefix

 *

 * DESCRIPTION: Get the length of the pathname string for this node

 *

 Validate the Node */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_handle_to_name

 *

 * PARAMETERS:  target_handle           - Handle of named object whose name is

 *                                        to be found

 *              buffer                  - Where the name is returned

 *

 * RETURN:      Status, Buffer is filled with name if status is AE_OK

 *

 * DESCRIPTION: Build and return a full namespace name

 *

 Validate/Allocate/Clear caller buffer */

 Just copy the ACPI name from the Node and zero terminate it */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_handle_to_pathname

 *

 * PARAMETERS:  target_handle           - Handle of named object whose name is

 *                                        to be found

 *              buffer                  - Where the pathname is returned

 *              no_trailing             - Remove trailing '_' for each name

 *                                        segment

 *

 * RETURN:      Status, Buffer is filled with pathname if status is AE_OK

 *

 * DESCRIPTION: Build and return a full namespace pathname

 *

 Determine size required for the caller buffer */

 Validate/Allocate/Clear caller buffer */

 Build the path in the caller buffer */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_build_normalized_path

 *

 * PARAMETERS:  node        - Namespace node

 *              full_path   - Where the path name is returned

 *              path_size   - Size of returned path name buffer

 *              no_trailing - Remove trailing '_' from each name segment

 *

 * RETURN:      Return 1 if the AML path is empty, otherwise returning (length

 *              of pathname + 1) which means the 'FullPath' contains a trailing

 *              null.

 *

 * DESCRIPTION: Build and return a full namespace pathname.

 *              Note that if the size of 'FullPath' isn't large enough to

 *              contain the namespace node's path name, the actual required

 *              buffer length is returned, and it should be greater than

 *              'PathSize'. So callers are able to check the returning value

 *              to determine the buffer size of 'FullPath'.

 *

	/*

	 * Make sure the path_size is correct, so that we don't need to

	 * validate both full_path and path_size.

 Reverse the path string */

 Append the trailing null */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_get_normalized_pathname

 *

 * PARAMETERS:  node            - Namespace node whose pathname is needed

 *              no_trailing     - Remove trailing '_' from each name segment

 *

 * RETURN:      Pointer to storage containing the fully qualified name of

 *              the node, In external format (name segments separated by path

 *              separators.)

 *

 * DESCRIPTION: Used to obtain the full pathname to a namespace node, usually

 *              for error and debug statements. All trailing '_' will be

 *              removed from the full pathname if 'NoTrailing' is specified..

 *

 Calculate required buffer size based on depth below root */

 Allocate a buffer to be returned to caller */

 Build the path in the allocated buffer */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_build_prefixed_pathname

 *

 * PARAMETERS:  prefix_scope        - Scope/Path that prefixes the internal path

 *              internal_path       - Name or path of the namespace node

 *

 * RETURN:      None

 *

 * DESCRIPTION: Construct a fully qualified pathname from a concatenation of:

 *              1) Path associated with the prefix_scope namespace node

 *              2) External path representation of the Internal path

 *

 If there is a prefix, get the pathname to it */

 Merge the prefix path and the path. 2 is for one dot and trailing null */

 Don't merge if the External path is already fully qualified */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_normalize_pathname

 *

 * PARAMETERS:  original_path       - Path to be normalized, in External format

 *

 * RETURN:      The original path is processed in-place

 *

 * DESCRIPTION: Remove trailing underscores from each element of a path.

 *

 *              For example:  \A___.B___.C___ becomes \A.B.C

 *

 Allocate a temp buffer in which to construct the new path */

 Special characters may appear at the beginning of the path */

 Remainder of the path */

 Do one nameseg at a time */

 First char is allowed to be underscore */

 Dot means that there are more namesegs to come */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: utcache - local cache allocation routines

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_os_create_cache

 *

 * PARAMETERS:  cache_name      - Ascii name for the cache

 *              object_size     - Size of each cached object

 *              max_depth       - Maximum depth of the cache (in objects)

 *              return_cache    - Where the new cache object is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create a cache object

 *

 Create the cache object */

 Populate the cache object and return it */

/*******************************************************************************

 *

 * FUNCTION:    acpi_os_purge_cache

 *

 * PARAMETERS:  cache           - Handle to cache object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Free all objects within the requested cache.

 *

 Walk the list of objects in this cache */

 Delete and unlink one cached state object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_os_delete_cache

 *

 * PARAMETERS:  cache           - Handle to cache object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Free all objects within the requested cache and delete the

 *              cache object.

 *

 Purge all objects in the cache */

 Now we can delete the cache object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_os_release_object

 *

 * PARAMETERS:  cache       - Handle to cache object

 *              object      - The object to be released

 *

 * RETURN:      None

 *

 * DESCRIPTION: Release an object to the specified cache. If cache is full,

 *              the object is deleted.

 *

 If cache is full, just free this object */

 Otherwise put this object back into the cache */

 Mark the object as cached */

 Put the object at the head of the cache list */

/*******************************************************************************

 *

 * FUNCTION:    acpi_os_acquire_object

 *

 * PARAMETERS:  cache           - Handle to cache object

 *

 * RETURN:      the acquired object. NULL on error

 *

 * DESCRIPTION: Get an object from the specified cache. If cache is empty,

 *              the object is allocated.

 *

 Check the cache first */

 There is an object available, use it */

 Clear (zero) the previously used Object */

 The cache is empty, create a new object */

 Avoid deadlock with ACPI_ALLOCATE_ZEROED */

 ACPI_USE_LOCAL_CACHE */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: dbstats - Generation and display of ACPI table statistics

 *

 Local prototypes */

/*

 * Statistics subcommands

 Must be null terminated */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_list_info

 *

 * PARAMETERS:  list            - Memory list/cache to be displayed

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display information about the input memory list or cache.

 *

 max_depth > 0 indicates a cache object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_enumerate_object

 *

 * PARAMETERS:  obj_desc            - Object to be counted

 *

 * RETURN:      None

 *

 * DESCRIPTION: Add this object to the global counts, by object type.

 *              Limited recursion handles subobjects and packages, and this

 *              is probably acceptable within the AML debugger only.

 *

 Enumerate this object first */

 Count the sub-objects */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_classify_one_object

 *

 * PARAMETERS:  Callback for walk_namespace

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Enumerate both the object descriptor (including subobjects) and

 *              the parent namespace node.

 *

 TBD: These need to be counted during the initial parsing phase */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_count_namespace_objects

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Count and classify the entire namespace, including all

 *              namespace nodes and attached objects.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_statistics

 *

 * PARAMETERS:  type_arg        - Subcommand

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Display various statistics

 *

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: hwacpi - ACPI Hardware Initialization/Mode Interface

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Entire module */

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_set_mode

 *

 * PARAMETERS:  mode            - SYS_MODE_ACPI or SYS_MODE_LEGACY

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Transitions the system into the requested mode.

 *

 If the Hardware Reduced flag is set, machine is always in acpi mode */

	/*

	 * ACPI 2.0 clarified that if SMI_CMD in FADT is zero,

	 * system does not support mode transition.

	/*

	 * ACPI 2.0 clarified the meaning of ACPI_ENABLE and ACPI_DISABLE

	 * in FADT: If it is zero, enabling or disabling is not supported.

	 * As old systems may have used zero for mode transition,

	 * we make sure both the numbers are zero to determine these

	 * transitions are not supported.

 BIOS should have disabled ALL fixed and GP events */

		/*

		 * BIOS should clear all fixed status bits and restore fixed event

		 * enable bits to default

/*******************************************************************************

 *

 * FUNCTION:    acpi_hw_get_mode

 *

 * PARAMETERS:  none

 *

 * RETURN:      SYS_MODE_ACPI or SYS_MODE_LEGACY

 *

 * DESCRIPTION: Return current operating state of system. Determined by

 *              querying the SCI_EN bit.

 *

 If the Hardware Reduced flag is set, machine is always in acpi mode */

	/*

	 * ACPI 2.0 clarified that if SMI_CMD in FADT is zero,

	 * system does not support mode transition.

 !ACPI_REDUCED_HARDWARE */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: utdelete - object deletion and reference count utilities

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_delete_internal_obj

 *

 * PARAMETERS:  object         - Object to be deleted

 *

 * RETURN:      None

 *

 * DESCRIPTION: Low level object deletion, after reference counts have been

 *              updated (All reference counts, including sub-objects!)

 *

	/*

	 * Must delete or free any pointers within the object that are not

	 * actual ACPI objects (for example, a raw buffer pointer).

 Free the actual string buffer */

 But only if it is NOT a pointer into an ACPI table */

 Free the actual buffer */

 But only if it is NOT a pointer into an ACPI table */

		/*

		 * Elements of the package are not handled here, they are deleted

		 * separately

 Free the (variable length) element pointer array */

		/*

		 * These objects have a possible list of notify handlers.

		 * Device object also may have a GPE block.

 Walk the address handler list for this object */

 Global Lock has extra semaphore */

 Delete the method mutex if it exists */

		/*

		 * Update address_range list. However, only permanent regions

		 * are installed in this list. (Not created within a method)

			/*

			 * Free the region_context if and only if the handler is one of the

			 * default handlers -- and therefore, we created the context object

			 * locally, it was not created by an external caller.

 Remove the region object from the handler list */

 Walk the linked list of handlers */

 Prevent infinite loop if list is corrupted */

 Deactivate region and free region context */

 Now we can free the Extra object */

 Free any allocated memory (pointer within the object) found above */

 Now the object can be safely deleted */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_delete_internal_object_list

 *

 * PARAMETERS:  obj_list        - Pointer to the list to be deleted

 *

 * RETURN:      None

 *

 * DESCRIPTION: This function deletes an internal object list, including both

 *              simple objects and package objects

 *

 Walk the null-terminated internal list */

 Free the combined parameter pointer list and object array */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_update_ref_count

 *

 * PARAMETERS:  object          - Object whose ref count is to be updated

 *              action          - What to do (REF_INCREMENT or REF_DECREMENT)

 *

 * RETURN:      None. Sets new reference count within the object

 *

 * DESCRIPTION: Modify the reference count for an internal acpi object

 *

	/*

	 * Always get the reference count lock. Note: Interpreter and/or

	 * Namespace is not always locked when this function is called.

 Perform the reference count action (increment, decrement) */

 The current reference count should never be zero here */

 The current reference count must be non-zero */

 Actually delete the object on a reference count of zero */

	/*

	 * Sanity check the reference count, for debug purposes only.

	 * (A deleted object will have a huge reference count)

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_update_object_reference

 *

 * PARAMETERS:  object              - Increment or decrement the ref count for

 *                                    this object and all sub-objects

 *              action              - Either REF_INCREMENT or REF_DECREMENT

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Increment or decrement the object reference count

 *

 * Object references are incremented when:

 * 1) An object is attached to a Node (namespace object)

 * 2) An object is copied (all subobjects must be incremented)

 *

 * Object references are decremented when:

 * 1) An object is detached from an Node

 *

 Make sure that this isn't a namespace handle */

		/*

		 * All sub-objects must have their reference count updated

		 * also. Different object types have different subobjects.

			/*

			 * Update the notify objects for these types (if present)

			 * Two lists, system and device notify handlers.

			/*

			 * We must update all the sub-objects of the package,

			 * each of whom may have their own sub-objects.

				/*

				 * Null package elements are legal and can be simply

				 * ignored.

					/*

					 * For these very simple sub-objects, we can just

					 * update the reference count here and continue.

					 * Greatly increases performance of this operation.

					/*

					 * For complex sub-objects, push them onto the stack

					 * for later processing (this eliminates recursion.)

			/*

			 * The target of an Index (a package, string, or buffer) or a named

			 * reference must track changes to the ref count of the index or

			 * target object.

 No subobjects for all other types */

		/*

		 * Now we can update the count in the main object. This can only

		 * happen after we update the sub-objects in case this causes the

		 * main object to be deleted.

 Move on to the next object to be updated */

 Free any stacked Update State objects */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_add_reference

 *

 * PARAMETERS:  object          - Object whose reference count is to be

 *                                incremented

 *

 * RETURN:      None

 *

 * DESCRIPTION: Add one reference to an ACPI object

 *

 Ensure that we have a valid object */

 Increment the reference count */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_remove_reference

 *

 * PARAMETERS:  object         - Object whose ref count will be decremented

 *

 * RETURN:      None

 *

 * DESCRIPTION: Decrement the reference count of an ACPI internal object

 *

	/*

	 * Allow a NULL pointer to be passed in, just ignore it. This saves

	 * each caller from having to check. Also, ignore NS nodes.

 Ensure that we have a valid object */

	/*

	 * Decrement the reference count, and only actually delete the object

	 * if the reference count becomes 0. (Must also decrement the ref count

	 * of all subobjects!)

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: rsio - IO and DMA resource descriptors

 *

/*******************************************************************************

 *

 * acpi_rs_convert_io

 *

 Decode flag */

	/*

	 * These fields are contiguous in both the source and destination:

	 * Address Alignment

	 * Length

	 * Minimum Base Address

	 * Maximum Base Address

/*******************************************************************************

 *

 * acpi_rs_convert_fixed_io

 *

	/*

	 * These fields are contiguous in both the source and destination:

	 * Base Address

	 * Length

/*******************************************************************************

 *

 * acpi_rs_convert_generic_reg

 *

	/*

	 * These fields are contiguous in both the source and destination:

	 * Address Space ID

	 * Register Bit Width

	 * Register Bit Offset

	 * Access Size

 Get the Register Address */

/*******************************************************************************

 *

 * acpi_rs_convert_end_dpf

 *

/*******************************************************************************

 *

 * acpi_rs_convert_end_tag

 *

	/*

	 * Note: The checksum field is set to zero, meaning that the resource

	 * data is treated as if the checksum operation succeeded.

	 * (ACPI Spec 1.0b Section 6.4.2.8)

/*******************************************************************************

 *

 * acpi_rs_get_start_dpf

 *

 Defaults for Compatibility and Performance priorities */

 Get the descriptor length (0 or 1 for Start Dpf descriptor) */

 All done if there is no flag byte present in the descriptor */

 Flag byte is present, get the flags */

/*******************************************************************************

 *

 * acpi_rs_set_start_dpf

 *

 Start with a default descriptor of length 1 */

 Set the default flag values */

	/*

	 * All done if the output descriptor length is required to be 1

	 * (i.e., optimization to 0 bytes cannot be attempted)

 Set length to 0 bytes (no flags byte) */

	/*

	 * All done if the output descriptor length is required to be 0.

	 *

	 * TBD: Perhaps we should check for error if input flags are not

	 * compatible with a 0-byte descriptor.

 Reset length to 1 byte (descriptor with flags byte) */

	/*

	 * All done if flags byte is necessary -- if either priority value

	 * is not ACPI_ACCEPTABLE_CONFIGURATION

 Flag byte is not necessary */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: nsparse - namespace interface to AML parser

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    ns_execute_table

 *

 * PARAMETERS:  table_desc      - An ACPI table descriptor for table to parse

 *              start_node      - Where to enter the table into the namespace

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Load ACPI/AML table by executing the entire table as a single

 *              large control method.

 *

 * NOTE: The point of this is to execute any module-level code in-place

 * as the table is parsed. Some AML code depends on this behavior.

 *

 * It is a run-time option at this time, but will eventually become

 * the default.

 *

 * Note: This causes the table to only have a single-pass parse.

 * However, this is compatible with other ACPI implementations.

 *

 Table must consist of at least a complete header */

 Create, initialize, and link a new temporary method object */

 Allocate the evaluation information block */

 Optional object evaluation log */

 Optional object evaluation log */

/*******************************************************************************

 *

 * FUNCTION:    ns_one_complete_parse

 *

 * PARAMETERS:  pass_number             - 1 or 2

 *              table_desc              - The table to be parsed.

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Perform one complete parse of an ACPI/AML table.

 *

 Table must consist of at least a complete header */

 Create and init a Root Node */

 Create and initialize a new walk state */

 Found OSDT table, enable the namespace override feature */

 start_node is the default location to load the table */

 Parse the AML */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_parse_table

 *

 * PARAMETERS:  table_desc      - An ACPI table descriptor for table to parse

 *              start_node      - Where to enter the table into the namespace

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Parse AML within an ACPI table and return a tree of ops

 *

	/*

	 * Executes the AML table as one large control method.

	 * The point of this is to execute any module-level code in-place

	 * as the table is parsed. Some AML code depends on this behavior.

	 *

	 * Note: This causes the table to only have a single-pass parse.

	 * However, this is compatible with other ACPI implementations.

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exresnte - AML Interpreter object resolution

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_resolve_node_to_value

 *

 * PARAMETERS:  object_ptr      - Pointer to a location that contains

 *                                a pointer to a NS node, and will receive a

 *                                pointer to the resolved object.

 *              walk_state      - Current state. Valid only if executing AML

 *                                code. NULL if simply resolving an object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Resolve a Namespace node to a valued object

 *

 * Note: for some of the data types, the pointer attached to the Node

 * can be either a pointer to an actual internal object or a pointer into the

 * AML stream itself. These types are currently:

 *

 *      ACPI_TYPE_INTEGER

 *      ACPI_TYPE_STRING

 *      ACPI_TYPE_BUFFER

 *      ACPI_TYPE_MUTEX

 *      ACPI_TYPE_PACKAGE

 *

	/*

	 * The stack pointer points to a struct acpi_namespace_node (Node). Get the

	 * object that is attached to the Node.

 There is always exactly one level of indirection */

	/*

	 * Several object types require no further processing:

	 * 1) Device/Thermal objects don't have a "real" subobject, return Node

	 * 2) Method locals and arguments have a pseudo-Node

	 * 3) 10/2007: Added method type to assist with Package construction.

	/*

	 * Action is based on the type of the Node, which indicates the type

	 * of the attached object or pointer

 Return an additional reference to the object */

 Return an additional reference to the object */

 Return an additional reference to the object */

 Return an additional reference to the object */

 For these objects, just return the object attached to the Node */

 Return an additional reference to the object */

 TYPE_ANY is untyped, and thus there is no object associated with it */

 Cannot be AE_TYPE */

 This is a ddb_handle */

 Return an additional reference to the object */

 No named references are allowed here */

 Default case is for unknown types */

 switch (entry_type) */

 Return the object descriptor */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: dsmthdat - control method arguments and local variables

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_method_data_init

 *

 * PARAMETERS:  walk_state          - Current walk state object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Initialize the data structures that hold the method's arguments

 *              and locals. The data struct is an array of namespace nodes for

 *              each - this allows ref_of and de_ref_of to work properly for these

 *              special data types.

 *

 * NOTES:       walk_state fields are initialized to zero by the

 *              ACPI_ALLOCATE_ZEROED().

 *

 *              A pseudo-Namespace Node is assigned to each argument and local

 *              so that ref_of() can return a pointer to the Node.

 *

 Init the method arguments */

 Init the method locals */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_method_data_delete_all

 *

 * PARAMETERS:  walk_state          - Current walk state object

 *

 * RETURN:      None

 *

 * DESCRIPTION: Delete method locals and arguments. Arguments are only

 *              deleted if this method was called from another method.

 *

 Detach the locals */

 Detach object (if present) and remove a reference */

 Detach the arguments */

 Detach object (if present) and remove a reference */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_method_data_init_args

 *

 * PARAMETERS:  *params         - Pointer to a parameter list for the method

 *              max_param_count - The arg count for this method

 *              walk_state      - Current walk state object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Initialize arguments for a method. The parameter list is a list

 *              of ACPI operand objects, either null terminated or whose length

 *              is defined by max_param_count.

 *

 Copy passed parameters into the new method stack frame */

		/*

		 * A valid parameter.

		 * Store the argument in the method/walk descriptor.

		 * Do not copy the arg in order to implement call by reference

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_method_data_get_node

 *

 * PARAMETERS:  type                - Either ACPI_REFCLASS_LOCAL or

 *                                    ACPI_REFCLASS_ARG

 *              index               - Which Local or Arg whose type to get

 *              walk_state          - Current walk state object

 *              node                - Where the node is returned.

 *

 * RETURN:      Status and node

 *

 * DESCRIPTION: Get the Node associated with a local or arg.

 *

	/*

	 * Method Locals and Arguments are supported

 Return a pointer to the pseudo-node */

 Return a pointer to the pseudo-node */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_method_data_set_value

 *

 * PARAMETERS:  type                - Either ACPI_REFCLASS_LOCAL or

 *                                    ACPI_REFCLASS_ARG

 *              index               - Which Local or Arg to get

 *              object              - Object to be inserted into the stack entry

 *              walk_state          - Current walk state object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Insert an object onto the method stack at entry Opcode:Index.

 *              Note: There is no "implicit conversion" for locals.

 *

 Get the namespace node for the arg/local */

	/*

	 * Increment ref count so object can't be deleted while installed.

	 * NOTE: We do not copy the object in order to preserve the call by

	 * reference semantics of ACPI Control Method invocation.

	 * (See ACPI Specification 2.0C)

 Install the object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_method_data_get_value

 *

 * PARAMETERS:  type                - Either ACPI_REFCLASS_LOCAL or

 *                                    ACPI_REFCLASS_ARG

 *              index               - Which localVar or argument to get

 *              walk_state          - Current walk state object

 *              dest_desc           - Where Arg or Local value is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Retrieve value of selected Arg or Local for this method

 *              Used only in acpi_ex_resolve_to_value().

 *

 Validate the object descriptor */

 Get the namespace node for the arg/local */

 Get the object from the node */

 Examine the returned object, it must be valid. */

		/*

		 * Index points to uninitialized object.

		 * This means that either 1) The expected argument was

		 * not passed to the method, or 2) A local variable

		 * was referenced by the method (via the ASL)

		 * before it was initialized. Either case is an error.

 If slack enabled, init the local_x/arg_x to an Integer of value zero */

 Otherwise, return the error */

				/*

				 * No error message for this case, will be trapped again later to

				 * detect and ignore cases of Store(local_x,local_x)

	/*

	 * The Index points to an initialized and valid object.

	 * Return an additional reference to the object

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_method_data_delete_value

 *

 * PARAMETERS:  type                - Either ACPI_REFCLASS_LOCAL or

 *                                    ACPI_REFCLASS_ARG

 *              index               - Which localVar or argument to delete

 *              walk_state          - Current walk state object

 *

 * RETURN:      None

 *

 * DESCRIPTION: Delete the entry at Opcode:Index. Inserts

 *              a null into the stack slot after the object is deleted.

 *

 Get the namespace node for the arg/local */

 Get the associated object */

	/*

	 * Undefine the Arg or Local by setting its descriptor

	 * pointer to NULL. Locals/Args can contain both

	 * ACPI_OPERAND_OBJECTS and ACPI_NAMESPACE_NODEs

		/*

		 * There is a valid object.

		 * Decrement the reference count by one to balance the

		 * increment when the object was stored.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_store_object_to_local

 *

 * PARAMETERS:  type                - Either ACPI_REFCLASS_LOCAL or

 *                                    ACPI_REFCLASS_ARG

 *              index               - Which Local or Arg to set

 *              obj_desc            - Value to be stored

 *              walk_state          - Current walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Store a value in an Arg or Local. The obj_desc is installed

 *              as the new value for the Arg or Local and the reference count

 *              for obj_desc is incremented.

 *

 Parameter validation */

 Get the namespace node for the arg/local */

	/*

	 * If the reference count on the object is more than one, we must

	 * take a copy of the object before we store. A reference count

	 * of exactly 1 means that the object was just created during the

	 * evaluation of an expression, and we can safely use it since it

	 * is not used anywhere else.

	/*

	 * If there is an object already in this slot, we either

	 * have to delete it, or if this is an argument and there

	 * is an object reference stored there, we have to do

	 * an indirect store!

		/*

		 * Check for an indirect store if an argument

		 * contains an object reference (stored as an Node).

		 * We don't allow this automatic dereferencing for

		 * locals, since a store to a local should overwrite

		 * anything there, including an object reference.

		 *

		 * If both Arg0 and Local0 contain ref_of (Local4):

		 *

		 * Store (1, Arg0)             - Causes indirect store to local4

		 * Store (1, Local0)           - Stores 1 in local0, overwriting

		 *                                  the reference to local4

		 * Store (1, de_refof (Local0)) - Causes indirect store to local4

		 *

		 * Weird, but true.

			/*

			 * If we have a valid reference object that came from ref_of(),

			 * do the indirect store

				/*

				 * Store this object to the Node (perform the indirect store)

				 * NOTE: No implicit conversion is performed, as per the ACPI

				 * specification rules on storing to Locals/Args.

 Remove local reference if we copied the object above */

 Delete the existing object before storing the new one */

	/*

	 * Install the Obj descriptor (*new_obj_desc) into

	 * the descriptor for the Arg or Local.

	 * (increments the object reference count by one)

 Remove local reference if we copied the object above */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_method_data_get_type

 *

 * PARAMETERS:  opcode              - Either AML_FIRST LOCAL_OP or

 *                                    AML_FIRST_ARG_OP

 *              index               - Which Local or Arg whose type to get

 *              walk_state          - Current walk state object

 *

 * RETURN:      Data type of current value of the selected Arg or Local

 *

 * DESCRIPTION: Get the type of the object stored in the Local or Arg

 *

 Get the namespace node for the arg/local */

 Get the object */

 Uninitialized local/arg, return TYPE_ANY */

 Get the object type */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: tbinstal - ACPI table installation and removal

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_install_table_with_override

 *

 * PARAMETERS:  new_table_desc          - New table descriptor to install

 *              override                - Whether override should be performed

 *              table_index             - Where the table index is returned

 *

 * RETURN:      None

 *

 * DESCRIPTION: Install an ACPI table into the global data structure. The

 *              table override mechanism is called to allow the host

 *              OS to replace any table before it is installed in the root

 *              table array.

 *

	/*

	 * ACPI Table Override:

	 *

	 * Before we install the table, let the host OS override it with a new

	 * one if desired. Any table within the RSDT/XSDT can be replaced,

	 * including the DSDT which is pointed to by the FADT.

 This synchronizes acpi_gbl_dsdt_index */

 Set the global integer width (based upon revision of the DSDT) */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_install_standard_table

 *

 * PARAMETERS:  address             - Address of the table (might be a virtual

 *                                    address depending on the table_flags)

 *              flags               - Flags for the table

 *              reload              - Whether reload should be performed

 *              override            - Whether override should be performed

 *              table_index         - Where the table index is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to verify and install an ACPI table.

 *              When this function is called by "Load" or "LoadTable" opcodes,

 *              or by acpi_load_table() API, the "Reload" parameter is set.

 *              After successfully returning from this function, table is

 *              "INSTALLED" but not "VALIDATED".

 *

 Acquire a temporary table descriptor for validation */

	/*

	 * Optionally do not load any SSDTs from the RSDT/XSDT. This can

	 * be useful for debugging ACPI problems on some machines.

 Acquire the table lock */

 Validate and verify a table before installation */

			/*

			 * Table was unloaded, allow it to be reloaded.

			 * As we are going to return AE_OK to the caller, we should

			 * take the responsibility of freeing the input descriptor.

			 * Refill the input descriptor to ensure

			 * acpi_tb_install_table_with_override() can be called again to

			 * indicate the re-installation.

 Add the table to the global root table list */

 Invoke table handler */

 Release the table lock */

 Release the temporary table descriptor */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_override_table

 *

 * PARAMETERS:  old_table_desc      - Validated table descriptor to be

 *                                    overridden

 *

 * RETURN:      None

 *

 * DESCRIPTION: Attempt table override by calling the OSL override functions.

 *              Note: If the table is overridden, then the entire new table

 *              is acquired and returned by this function.

 *              Before/after invocation, the table descriptor is in a state

 *              that is "VALIDATED".

 *

 (1) Attempt logical override (returns a logical address) */

 (2) Attempt physical override (returns a physical address) */

 There was no override */

	/*

	 * Validate and verify a table before overriding, no nested table

	 * duplication check as it's too complicated and unnecessary.

 We can now uninstall the original table */

	/*

	 * Replace the original table descriptor and keep its state as

	 * "VALIDATED".

 Release the temporary table descriptor */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_uninstall_table

 *

 * PARAMETERS:  table_desc          - Table descriptor

 *

 * RETURN:      None

 *

 * DESCRIPTION: Delete one internal ACPI table

 *

 Table must be installed */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exconcat - Concatenate-type AML operators

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local Prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_do_concatenate

 *

 * PARAMETERS:  operand0            - First source object

 *              operand1            - Second source object

 *              actual_return_desc  - Where to place the return object

 *              walk_state          - Current walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Concatenate two objects with the ACPI-defined conversion

 *              rules as necessary.

 * NOTE:

 * Per the ACPI spec (up to 6.1), Concatenate only supports Integer,

 * String, and Buffer objects. However, we support all objects here

 * as an extension. This improves the usefulness of both Concatenate

 * and the Printf/Fprintf macros. The extension returns a string

 * describing the object type for the other objects.

 * 02/2016.

 *

 Operand 0 preprocessing */

 For all other types, get the "object type" string */

 Operand 1 preprocessing */

 For all other types, get the "object type" string */

	/*

	 * Convert the second operand if necessary. The first operand (0)

	 * determines the type of the second operand (1) (See the Data Types

	 * section of the ACPI specification). Both object types are

	 * guaranteed to be either Integer/String/Buffer by the operand

	 * resolution mechanism.

 Other types have already been converted to string */

 Take care with any newly created operand objects */

	/*

	 * Both operands are now known to be the same object type

	 * (Both are Integer, String, or Buffer), and we can now perform

	 * the concatenation.

	 *

	 * There are three cases to handle, as per the ACPI spec:

	 *

	 * 1) Two Integers concatenated to produce a new Buffer

	 * 2) Two Strings concatenated to produce a new String

	 * 3) Two Buffers concatenated to produce a new Buffer

 Result of two Integers is a Buffer */

 Need enough buffer space for two integers */

 Copy the first integer, LSB first */

 Copy the second integer (LSB first) after the first */

 Result of two Strings is a String */

 Concatenate the strings */

 Result of two Buffers is a Buffer */

 Concatenate the buffers */

 Invalid object type, should not happen here */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_convert_to_object_type_string

 *

 * PARAMETERS:  obj_desc            - Object to be converted

 *              return_desc         - Where to place the return object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Convert an object of arbitrary type to a string object that

 *              contains the namestring for the object. Used for the

 *              concatenate operator.

 *

 9 For "[ Object]" */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_concat_template

 *

 * PARAMETERS:  operand0            - First source object

 *              operand1            - Second source object

 *              actual_return_desc  - Where to place the return object

 *              walk_state          - Current walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Concatenate two resource templates

 *

	/*

	 * Find the end_tag descriptor in each resource template.

	 * Note1: returned pointers point TO the end_tag, not past it.

	 * Note2: zero-length buffers are allowed; treated like one end_tag

 Get the length of the first resource template */

 Get the length of the second resource template */

 Combine both lengths, minimum size will be 2 for end_tag */

 Create a new buffer object for the result (with one end_tag) */

	/*

	 * Copy the templates to the new buffer, 0 first, then 1 follows. One

	 * end_tag descriptor is copied from Operand1.

 Insert end_tag and set the checksum to zero, means "ignore checksum" */

 Return the completed resource template */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: psutils - Parser miscellaneous utilities (Parser only)

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_create_scope_op

 *

 * PARAMETERS:  None

 *

 * RETURN:      A new Scope object, null on failure

 *

 * DESCRIPTION: Create a Scope and associated namepath op with the root name

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_init_op

 *

 * PARAMETERS:  op              - A newly allocated Op object

 *              opcode          - Opcode to store in the Op

 *

 * RETURN:      None

 *

 * DESCRIPTION: Initialize a parse (Op) object

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_alloc_op

 *

 * PARAMETERS:  opcode          - Opcode that will be stored in the new Op

 *              aml             - Address of the opcode

 *

 * RETURN:      Pointer to the new Op, null on failure

 *

 * DESCRIPTION: Allocate an acpi_op, choose op type (and thus size) based on

 *              opcode. A cache of opcodes is available for the pure

 *              GENERIC_OP, since this is by far the most commonly used.

 *

 Determine type of parse_op required */

 Allocate the minimum required size object */

 The generic op (default) is by far the most common (16 to 1) */

 Extended parseop */

 Initialize the Op */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_free_op

 *

 * PARAMETERS:  op              - Op to be freed

 *

 * RETURN:      None.

 *

 * DESCRIPTION: Free an Op object. Either put it on the GENERIC_OP cache list

 *              or actually free it.

 *

/*******************************************************************************

 *

 * FUNCTION:    Utility functions

 *

 * DESCRIPTION: Low level character and object functions

 *

/*

 * Is "c" a namestring lead character?

/*

 * Get op's name (4-byte name segment) or 0 if unnamed

 The "generic" object has no name associated with it */

 Only the "Extended" parse objects have a name */

/*

 * Set op's name

 The "generic" object has no name associated with it */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: utstring - Common functions for strings and characters

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_print_string

 *

 * PARAMETERS:  string          - Null terminated ASCII string

 *              max_length      - Maximum output length. Used to constrain the

 *                                length of strings during debug output only.

 *

 * RETURN:      None

 *

 * DESCRIPTION: Dump an ASCII string with support for ACPI-defined escape

 *              sequences.

 *

 Escape sequences */

 BELL */

 BACKSPACE */

 FORMFEED */

 LINEFEED */

 CARRIAGE RETURN */

 HORIZONTAL TAB */

 VERTICAL TAB */

 Single Quote */

 Double Quote */

 Backslash */

 Check for printable character or hex escape */

 This is a normal character */

 All others will be Hex escapes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_repair_name

 *

 * PARAMETERS:  name            - The ACPI name to be repaired

 *

 * RETURN:      Repaired version of the name

 *

 * DESCRIPTION: Repair an ACPI name: Change invalid characters to '*' and

 *              return the new name. NOTE: the Name parameter must reside in

 *              read/write memory, cannot be a const.

 *

 * An ACPI Name must consist of valid ACPI characters. We will repair the name

 * if necessary because we don't want to abort because of this, but we want

 * all namespace names to be printable. A warning message is appropriate.

 *

 * This issue came up because there are in fact machines that exhibit

 * this problem, and we want to be able to enable ACPI support for them,

 * even though there are a few bad names.

 *

	/*

	 * Special case for the root node. This can happen if we get an

	 * error during the execution of module-level code.

 Check each character in the name */

		/*

		 * Replace a bad character with something printable, yet technically

		 * still invalid. This prevents any collisions with existing "good"

		 * names in the namespace.

 Report warning only if in strict mode or debug mode */

/*******************************************************************************

 *

 * FUNCTION:    ut_convert_backslashes

 *

 * PARAMETERS:  pathname        - File pathname string to be converted

 *

 * RETURN:      Modifies the input Pathname

 *

 * DESCRIPTION: Convert all backslashes (0x5C) to forward slashes (0x2F) within

 *              the entire input file pathname string.

 *

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: extrace - Support for interpreter execution tracing

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_interpreter_trace_enabled

 *

 * PARAMETERS:  name                - Whether method name should be matched,

 *                                    this should be checked before starting

 *                                    the tracer

 *

 * RETURN:      TRUE if interpreter trace is enabled.

 *

 * DESCRIPTION: Check whether interpreter trace is enabled

 *

 Check if tracing is enabled */

	/*

	 * Check if tracing is filtered:

	 *

	 * 1. If the tracer is started, acpi_gbl_trace_method_object should have

	 *    been filled by the trace starter

	 * 2. If the tracer is not started, acpi_gbl_trace_method_name should be

	 *    matched if it is specified

	 * 3. If the tracer is oneshot style, acpi_gbl_trace_method_name should

	 *    not be cleared by the trace stopper during the first match

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_get_trace_event_name

 *

 * PARAMETERS:  type            - Trace event type

 *

 * RETURN:      Trace event name.

 *

 * DESCRIPTION: Used to obtain the full trace event name.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_trace_point

 *

 * PARAMETERS:  type                - Trace event type

 *              begin               - TRUE if before execution

 *              aml                 - Executed AML address

 *              pathname            - Object path

 *

 * RETURN:      None

 *

 * DESCRIPTION: Internal interpreter execution trace.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_start_trace_method

 *

 * PARAMETERS:  method_node         - Node of the method

 *              obj_desc            - The method object

 *              walk_state          - current state, NULL if not yet executing

 *                                    a method.

 *

 * RETURN:      None

 *

 * DESCRIPTION: Start control method execution trace

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_stop_trace_method

 *

 * PARAMETERS:  method_node         - Node of the method

 *              obj_desc            - The method object

 *              walk_state          - current state, NULL if not yet executing

 *                                    a method.

 *

 * RETURN:      None

 *

 * DESCRIPTION: Stop control method execution trace

 *

 Check whether the tracer should be stopped */

 Disable further tracing if type is one-shot */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_start_trace_opcode

 *

 * PARAMETERS:  op                  - The parser opcode object

 *              walk_state          - current state, NULL if not yet executing

 *                                    a method.

 *

 * RETURN:      None

 *

 * DESCRIPTION: Start opcode execution trace

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_stop_trace_opcode

 *

 * PARAMETERS:  op                  - The parser opcode object

 *              walk_state          - current state, NULL if not yet executing

 *                                    a method.

 *

 * RETURN:      None

 *

 * DESCRIPTION: Stop opcode execution trace

 *

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: dbfileio - Debugger file I/O commands. These can't usually

 *              be used when running the debugger in Ring 0 (Kernel mode)

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_close_debug_file

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: If open, close the current debug output file

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_open_debug_file

 *

 * PARAMETERS:  name                - Filename to open

 *

 * RETURN:      None

 *

 * DESCRIPTION: Open a file where debug output will be directed.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_load_tables

 *

 * PARAMETERS:  list_head       - List of ACPI tables to load

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Load ACPI tables from a previously constructed table list.

 *

 Load all ACPI tables in the list */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: rsmem24 - Memory resource descriptors

 *

/*******************************************************************************

 *

 * acpi_rs_convert_memory24

 *

 Read/Write bit */

	/*

	 * These fields are contiguous in both the source and destination:

	 * Minimum Base Address

	 * Maximum Base Address

	 * Address Base Alignment

	 * Range Length

/*******************************************************************************

 *

 * acpi_rs_convert_memory32

 *

 Read/Write bit */

	/*

	 * These fields are contiguous in both the source and destination:

	 * Minimum Base Address

	 * Maximum Base Address

	 * Address Base Alignment

	 * Range Length

/*******************************************************************************

 *

 * acpi_rs_convert_fixed_memory32

 *

 Read/Write bit */

	/*

	 * These fields are contiguous in both the source and destination:

	 * Base Address

	 * Range Length

/*******************************************************************************

 *

 * acpi_rs_get_vendor_small

 *

 Length of the vendor data (byte count) */

 Vendor data */

/*******************************************************************************

 *

 * acpi_rs_get_vendor_large

 *

 Length of the vendor data (byte count) */

 Vendor data */

/*******************************************************************************

 *

 * acpi_rs_set_vendor

 *

 Default is a small vendor descriptor */

 Get the length and copy the data */

	/*

	 * All done if the Vendor byte length is 7 or less, meaning that it will

	 * fit within a small descriptor

 Must create a large vendor descriptor */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exfield - AML execution - field_unit read/write

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*

 * This table maps the various Attrib protocols to the byte transfer

 * length. Used for the generic serial bus.

 0 - reserved */

 1 - reserved */

 2 - ATTRIB_QUICK */

 3 - reserved */

 4 - ATTRIB_SEND_RECEIVE */

 5 - reserved */

 6 - ATTRIB_BYTE */

 7 - reserved */

 8 - ATTRIB_WORD */

 9 - reserved */

 A - ATTRIB_BLOCK  */

 B - ATTRIB_BYTES */

 C - ATTRIB_PROCESS_CALL */

 D - ATTRIB_BLOCK_PROCESS_CALL */

 E - ATTRIB_RAW_BYTES */

 F - ATTRIB_RAW_PROCESS_BYTES */

/*

 * The following macros determine a given offset is a COMD field.

 * According to the specification, generic subspaces (types 0-2) contains a

 * 2-byte COMD field at offset 4 and master subspaces (type 3) contains a 4-byte

 * COMD field starting at offset 12.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_get_protocol_buffer_length

 *

 * PARAMETERS:  protocol_id     - The type of the protocol indicated by region

 *                                field access attributes

 *              return_length   - Where the protocol byte transfer length is

 *                                returned

 *

 * RETURN:      Status and decoded byte transfer length

 *

 * DESCRIPTION: This routine returns the length of the generic_serial_bus

 *              protocol bytes

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_read_data_from_field

 *

 * PARAMETERS:  walk_state          - Current execution state

 *              obj_desc            - The named field

 *              ret_buffer_desc     - Where the return data object is stored

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Read from a named field. Returns either an Integer or a

 *              Buffer, depending on the size of the field and whether if a

 *              field is created by the create_field() operator.

 *

 Parameter validation */

		/*

		 * If the buffer_field arguments have not been previously evaluated,

		 * evaluate them now and save the results.

 SMBus, GSBus, IPMI serial */

	/*

	 * Allocate a buffer for the contents of the field.

	 *

	 * If the field is larger than the current integer width, create

	 * a BUFFER to hold it. Otherwise, use an INTEGER. This allows

	 * the use of arithmetic operators on the returned value if the

	 * field size is equal or smaller than an Integer.

	 *

	 * However, all buffer fields created by create_field operator needs to

	 * remain as a buffer to match other AML interpreter implementations.

	 *

	 * Note: Field.length is in bits.

 Field is too large for an Integer, create a Buffer instead */

 Field will fit within an Integer (normal case) */

 General Purpose I/O */

		/*

		 * Reading from a PCC field unit does not require the handler because

		 * it only requires reading from the internal_pcc_buffer.

 Lock entire transaction if requested */

 Read from the field */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_write_data_to_field

 *

 * PARAMETERS:  source_desc         - Contains data to write

 *              obj_desc            - The named field

 *              result_desc         - Where the return value is returned, if any

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Write to a named field

 *

 Parameter validation */

		/*

		 * If the buffer_field arguments have not been previously evaluated,

		 * evaluate them now and save the results.

 General Purpose I/O */

 SMBus, GSBus, IPMI serial */

		/*

		 * According to the spec a write to the COMD field will invoke the

		 * region handler. Otherwise, write to the pcc_internal buffer. This

		 * implementation will use the offsets specified rather than the name

		 * of the field. This is considered safer because some firmware tools

		 * are known to obfiscate named objects.

 Perform the write */

 Get a pointer to the data to be written */

 Lock entire transaction if requested */

 Write to the field */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: dswload2 - Dispatcher second pass namespace load callbacks

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_load2_begin_op

 *

 * PARAMETERS:  walk_state      - Current state of the parse tree walk

 *              out_op          - Where to return op if a new one is created

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Descending callback used during the loading of ACPI tables.

 *

 We are executing a while loop outside of a method */

 We only care about Namespace opcodes here */

 Get the name we are going to enter or lookup in the namespace */

 For Namepath op, get the path string */

 No name, just exit */

 Get name from the op */

 Get the namestring from the raw AML */

 Map the opcode into an internal object type */

		/*

		 * The name_path is an object reference to an existing object.

		 * Don't enter the name into the namespace, but look it up

		 * for use later.

 Special case for Scope(\) -> refers to the Root node */

			/*

			 * The Path is an object reference to an existing object.

			 * Don't enter the name into the namespace, but look it up

			 * for use later.

		/*

		 * We must check to make sure that the target is

		 * one of the opcodes that actually opens a scope

 Scope */

 These are acceptable types */

			/*

			 * These types we will allow, but we will change the type.

			 * This enables some existing code of the form:

			 *

			 *  Name (DEB, 0)

			 *  Scope (DEB) { ... }

			/*

			 * Allow scope change to root during execution of module-level

			 * code. Root is typed METHOD during this time.

 All other types are an error */

 All other opcodes */

 This op/node was previously entered into the namespace */

		/*

		 * Enter the named type into the internal namespace. We enter the name

		 * as we go downward in the parse tree. Any necessary subobjects that

		 * involve arguments to the opcode must be created as we go back up the

		 * parse tree later.

		 *

		 * Note: Name may already exist if we are executing a deferred opcode.

 This name is already in the namespace, get the node */

 Execution mode, node cannot already exist, node is temporary */

		/*

		 * Do not open a scope for AML_EXTERNAL_OP

		 * acpi_ns_lookup can open a new scope based on the object type

		 * of this op. AML_EXTERNAL_OP is a declaration rather than a

		 * definition. In the case that this external is a method object,

		 * acpi_ns_lookup will open a new scope. However, an AML_EXTERNAL_OP

		 * associated with the ACPI_TYPE_METHOD is a declaration, rather than

		 * a definition. Flags is set to avoid opening a scope for any

		 * AML_EXTERNAL_OP.

		/*

		 * For name creation opcodes, the full namepath prefix must

		 * exist, except for the final (new) nameseg.

 Add new entry or lookup existing entry */

 Create a new op */

 Initialize the new op */

	/*

	 * Put the Node in the "op" object that the parser uses, so we

	 * can get it again quickly when this scope is closed

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_load2_end_op

 *

 * PARAMETERS:  walk_state      - Current state of the parse tree walk

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Ascending callback used during the loading of the namespace,

 *              both control methods and everything else.

 *

 Check if opcode had an associated namespace object */

	/*

	 * Get the Node/name from the earlier lookup

	 * (It was saved in the *op structure)

	/*

	 * Put the Node on the object stack (Contains the ACPI Name of

	 * this object)

 Pop the scope stack */

	/*

	 * Named operations are as follows:

	 *

	 * AML_ALIAS

	 * AML_BANKFIELD

	 * AML_CREATEBITFIELD

	 * AML_CREATEBYTEFIELD

	 * AML_CREATEDWORDFIELD

	 * AML_CREATEFIELD

	 * AML_CREATEQWORDFIELD

	 * AML_CREATEWORDFIELD

	 * AML_DATA_REGION

	 * AML_DEVICE

	 * AML_EVENT

	 * AML_FIELD

	 * AML_INDEXFIELD

	 * AML_METHOD

	 * AML_METHODCALL

	 * AML_MUTEX

	 * AML_NAME

	 * AML_NAMEDFIELD

	 * AML_OPREGION

	 * AML_POWERRES

	 * AML_PROCESSOR

	 * AML_SCOPE

	 * AML_THERMALZONE

 Decode the opcode */

		/*

		 * Create the field object, but the field buffer and index must

		 * be evaluated later during the execution phase

		/*

		 * If we are executing a method, initialize the field

 All NAMED_FIELD opcodes must be handled above */

 Unknown opcode */

 Delete operands */

			/*

			 * The op_region is not fully parsed at this time. The only valid

			 * argument is the space_id. (We must save the address of the

			 * AML of the address and length operands)

			 *

			 * If we have a valid region, initialize it. The namespace is

			 * unlocked at this point.

			 *

			 * Need to unlock interpreter if it is locked (if we are running

			 * a control method), in order to allow _REG methods to be run

			 * during acpi_ev_initialize_region.

				/*

				 * Executing a method: initialize the region and unlock

				 * the interpreter

			/*

			 * acpi_exec support for namespace initialization file (initialize

			 * Name opcodes in this code.)

 Detach any existing object, attach new object */

			/*

			 * method_op pkg_length name_string method_flags term_list

			 *

			 * Note: We must create the method node/object pair as soon as we

			 * see the method declaration. This allows later pass1 parsing

			 * of invocations of the method (need to know the number of

			 * arguments.)

 All NAMED_COMPLEX opcodes must be handled above */

 case AML_INT_NAMEPATH_OP: */

		/*

		 * Lookup the method name and save the Node

			/*

			 * Make sure that what we found is indeed a method

			 * We didn't search for a method on purpose, to see if the name

			 * would resolve

			/* We could put the returned object (Node) on the object stack for

			 * later, but for now, we will put it in the "op" object that the

			 * parser uses, so we can get it again at the end of this scope

 Remove the Node pushed at the very beginning */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: hwregs - Read/write access functions for the various ACPI

 *                       control and status registers.

 *

 Local Prototypes */

 !ACPI_REDUCED_HARDWARE */

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_get_access_bit_width

 *

 * PARAMETERS:  address             - GAS register address

 *              reg                 - GAS register structure

 *              max_bit_width       - Max bit_width supported (32 or 64)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Obtain optimal access bit width

 *

	/*

	 * GAS format "register", used by FADT:

	 *  1. Detected if bit_offset is 0 and bit_width is 8/16/32/64;

	 *  2. access_size field is ignored and bit_width field is used for

	 *     determining the boundary of the IO accesses.

	 * GAS format "region", used by APEI registers:

	 *  1. Detected if bit_offset is not 0 or bit_width is not 8/16/32/64;

	 *  2. access_size field is used for determining the boundary of the

	 *     IO accesses;

	 *  3. bit_offset/bit_width fields are used to describe the "region".

	 *

	 * Note: This algorithm assumes that the "Address" fields should always

	 *       contain aligned values.

 Maximum IO port access bit width is 32 */

	/*

	 * Return access width according to the requested maximum access bit width,

	 * as the caller should know the format of the register and may enforce

	 * a 32-bit accesses.

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_validate_register

 *

 * PARAMETERS:  reg                 - GAS register structure

 *              max_bit_width       - Max bit_width supported (32 or 64)

 *              address             - Pointer to where the gas->address

 *                                    is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Validate the contents of a GAS register. Checks the GAS

 *              pointer, Address, space_id, bit_width, and bit_offset.

 *

 Must have a valid pointer to a GAS structure */

	/*

	 * Copy the target address. This handles possible alignment issues.

	 * Address must not be null. A null address also indicates an optional

	 * ACPI register that is not supported, so no error message.

 Validate the space_ID */

 Validate the access_width */

 Validate the bit_width, convert access_width into number of bits */

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_read

 *

 * PARAMETERS:  value               - Where the value is returned

 *              reg                 - GAS register structure

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Read from either memory or IO space. This is a 64-bit max

 *              version of acpi_read.

 *

 * LIMITATIONS: <These limitations also apply to acpi_hw_write>

 *      space_ID must be system_memory or system_IO.

 *

 Validate contents of the GAS register */

	/*

	 * Initialize entire 64-bit return value to zero, convert access_width

	 * into number of bits based

	/*

	 * Two address spaces supported: Memory or IO. PCI_Config is

	 * not supported here because the GAS structure is insufficient

 ACPI_ADR_SPACE_SYSTEM_IO, validated earlier */

		/*

		 * Use offset style bit writes because "Index * AccessWidth" is

		 * ensured to be less than 64-bits by acpi_hw_validate_register().

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_write

 *

 * PARAMETERS:  value               - Value to be written

 *              reg                 - GAS register structure

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Write to either memory or IO space. This is a 64-bit max

 *              version of acpi_write.

 *

 Validate contents of the GAS register */

 Convert access_width into number of bits based */

	/*

	 * Two address spaces supported: Memory or IO. PCI_Config is

	 * not supported here because the GAS structure is insufficient

		/*

		 * Use offset style bit reads because "Index * AccessWidth" is

		 * ensured to be less than 64-bits by acpi_hw_validate_register().

 ACPI_ADR_SPACE_SYSTEM_IO, validated earlier */

		/*

		 * Index * access_width is ensured to be less than 32-bits by

		 * acpi_hw_validate_register().

/*******************************************************************************

 *

 * FUNCTION:    acpi_hw_clear_acpi_status

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Clears all fixed and general purpose status bits

 *

 Clear the fixed events in PM1 A/B */

 Clear the GPE Bits in all GPE registers in all GPE blocks */

/*******************************************************************************

 *

 * FUNCTION:    acpi_hw_get_bit_register_info

 *

 * PARAMETERS:  register_id         - Index of ACPI Register to access

 *

 * RETURN:      The bitmask to be used when accessing the register

 *

 * DESCRIPTION: Map register_id into a register bitmask.

 *

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_write_pm1_control

 *

 * PARAMETERS:  pm1a_control        - Value to be written to PM1A control

 *              pm1b_control        - Value to be written to PM1B control

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Write the PM1 A/B control registers. These registers are

 *              different than than the PM1 A/B status and enable registers

 *              in that different values can be written to the A/B registers.

 *              Most notably, the SLP_TYP bits can be different, as per the

 *              values returned from the _Sx predefined methods.

 *

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_register_read

 *

 * PARAMETERS:  register_id         - ACPI Register ID

 *              return_value        - Where the register value is returned

 *

 * RETURN:      Status and the value read.

 *

 * DESCRIPTION: Read from the specified ACPI register

 *

 PM1 A/B: 16-bit access each */

 PM1 A/B: 16-bit access each */

 PM1 A/B: 16-bit access each */

		/*

		 * Zero the write-only bits. From the ACPI specification, "Hardware

		 * Write-Only Bits": "Upon reads to registers with write-only bits,

		 * software masks out all write-only bits."

 8-bit access */

 32-bit access */

 8-bit access */

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_register_write

 *

 * PARAMETERS:  register_id         - ACPI Register ID

 *              value               - The value to write

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Write to the specified ACPI register

 *

 * NOTE: In accordance with the ACPI specification, this function automatically

 * preserves the value of the following bits, meaning that these bits cannot be

 * changed via this interface:

 *

 * PM1_CONTROL[0] = SCI_EN

 * PM1_CONTROL[9]

 * PM1_STATUS[11]

 *

 * ACPI References:

 * 1) Hardware Ignored Bits: When software writes to a register with ignored

 *      bit fields, it preserves the ignored bit fields

 * 2) SCI_EN: OSPM always preserves this bit position

 *

 PM1 A/B: 16-bit access each */

		/*

		 * Handle the "ignored" bit in PM1 Status. According to the ACPI

		 * specification, ignored bits are to be preserved when writing.

		 * Normally, this would mean a read/modify/write sequence. However,

		 * preserving a bit in the status register is different. Writing a

		 * one clears the status, and writing a zero preserves the status.

		 * Therefore, we must always write zero to the ignored bit.

		 *

		 * This behavior is clarified in the ACPI 4.0 specification.

 PM1 A/B: 16-bit access each */

 PM1 A/B: 16-bit access each */

		/*

		 * Perform a read first to preserve certain bits (per ACPI spec)

		 * Note: This includes SCI_EN, we never want to change this bit

 Insert the bits to be preserved */

 Now we can write the data */

 8-bit access */

		/*

		 * For control registers, all reserved bits must be preserved,

		 * as per the ACPI spec.

 Insert the bits to be preserved */

 32-bit access */

 8-bit access */

 SMI_CMD is currently always in IO space */

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_read_multiple

 *

 * PARAMETERS:  value               - Where the register value is returned

 *              register_a           - First ACPI register (required)

 *              register_b           - Second ACPI register (optional)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Read from the specified two-part ACPI register (such as PM1 A/B)

 *

 The first register is always required */

 Second register is optional */

	/*

	 * OR the two return values together. No shifting or masking is necessary,

	 * because of how the PM1 registers are defined in the ACPI specification:

	 *

	 * "Although the bits can be split between the two register blocks (each

	 * register block has a unique pointer within the FADT), the bit positions

	 * are maintained. The register block with unimplemented bits (that is,

	 * those implemented in the other register block) always returns zeros,

	 * and writes have no side effects"

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_write_multiple

 *

 * PARAMETERS:  value               - The value to write

 *              register_a           - First ACPI register (required)

 *              register_b           - Second ACPI register (optional)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Write to the specified two-part ACPI register (such as PM1 A/B)

 *

 The first register is always required */

	/*

	 * Second register is optional

	 *

	 * No bit shifting or clearing is necessary, because of how the PM1

	 * registers are defined in the ACPI specification:

	 *

	 * "Although the bits can be split between the two register blocks (each

	 * register block has a unique pointer within the FADT), the bit positions

	 * are maintained. The register block with unimplemented bits (that is,

	 * those implemented in the other register block) always returns zeros,

	 * and writes have no side effects"

 !ACPI_REDUCED_HARDWARE */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: evrgnini- ACPI address_space (op_region) init

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_system_memory_region_setup

 *

 * PARAMETERS:  handle              - Region we are interested in

 *              function            - Start or stop

 *              handler_context     - Address space handler context

 *              region_context      - Region specific context

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Setup a system_memory operation region

 *

 Delete memory mappings if present */

 Create a new context */

 Save the region length and address for use in the handler */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_io_space_region_setup

 *

 * PARAMETERS:  handle              - Region we are interested in

 *              function            - Start or stop

 *              handler_context     - Address space handler context

 *              region_context      - Region specific context

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Setup a IO operation region

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_pci_config_region_setup

 *

 * PARAMETERS:  handle              - Region we are interested in

 *              function            - Start or stop

 *              handler_context     - Address space handler context

 *              region_context      - Region specific context

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Setup a PCI_Config operation region

 *

 * MUTEX:       Assumes namespace is not locked

 *

		/*

		 * No installed handler. This shouldn't happen because the dispatch

		 * routine checks before we get here, but we check again just in case.

	/*

	 * Get the _SEG and _BBN values from the device upon which the handler

	 * is installed.

	 *

	 * We need to get the _SEG and _BBN objects relative to the PCI BUS device.

	 * This is the device the handler has been registered to handle.

	/*

	 * If the address_space.Node is still pointing to the root, we need

	 * to scan upward for a PCI Root bridge and re-associate the op_region

	 * handlers with that device.

 Start search from the parent object */

 Get the _HID/_CID in order to detect a root_bridge */

 Install a handler for this PCI root bridge */

						/*

						 * It is OK if the handler is already installed on the

						 * root bridge. Still need to return a context object

						 * for the new PCI_Config operation region, however.

 PCI root bridge not found, use namespace root node */

	/*

	 * If this region is now initialized, we are done.

	 * (install_address_space_handler could have initialized it)

 Region is still not initialized. Create a new context */

	/*

	 * For PCI_Config space access, we need the segment, bus, device and

	 * function numbers. Acquire them here.

	 *

	 * Find the parent device object. (This allows the operation region to be

	 * within a subscope under the device, such as a control method.)

	/*

	 * Get the PCI device and function numbers from the _ADR object

	 * contained in the parent's scope.

	/*

	 * The default is zero, and since the allocation above zeroed the data,

	 * just do nothing on failure.

 The PCI segment number comes from the _SEG method */

 The PCI bus number comes from the _BBN method */

 Complete/update the PCI ID for this device */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_is_pci_root_bridge

 *

 * PARAMETERS:  node            - Device node being examined

 *

 * RETURN:      TRUE if device is a PCI/PCI-Express Root Bridge

 *

 * DESCRIPTION: Determine if the input device represents a PCI Root Bridge by

 *              examining the _HID and _CID for the device.

 *

 Get the _HID and check for a PCI Root Bridge */

 The _HID did not match. Get the _CID and check for a PCI Root Bridge */

 Check all _CIDs in the returned list */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_pci_bar_region_setup

 *

 * PARAMETERS:  handle              - Region we are interested in

 *              function            - Start or stop

 *              handler_context     - Address space handler context

 *              region_context      - Region specific context

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Setup a pci_BAR operation region

 *

 * MUTEX:       Assumes namespace is not locked

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_cmos_region_setup

 *

 * PARAMETERS:  handle              - Region we are interested in

 *              function            - Start or stop

 *              handler_context     - Address space handler context

 *              region_context      - Region specific context

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Setup a CMOS operation region

 *

 * MUTEX:       Assumes namespace is not locked

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_default_region_setup

 *

 * PARAMETERS:  handle              - Region we are interested in

 *              function            - Start or stop

 *              handler_context     - Address space handler context

 *              region_context      - Region specific context

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Default region initialization

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_initialize_region

 *

 * PARAMETERS:  region_obj      - Region we are initializing

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Initializes the region, finds any _REG methods and saves them

 *              for execution at a later time

 *

 *              Get the appropriate address space handler for a newly

 *              created region.

 *

 *              This also performs address space specific initialization. For

 *              example, PCI regions must have an _ADR object that contains

 *              a PCI address in the scope of the definition. This address is

 *              required to perform an access to PCI config space.

 *

 * MUTEX:       Interpreter should be unlocked, because we may run the _REG

 *              method for this region.

 *

 * NOTE:        Possible incompliance:

 *              There is a behavior conflict in automatic _REG execution:

 *              1. When the interpreter is evaluating a method, we can only

 *                 automatically run _REG for the following case:

 *                   operation_region (OPR1, 0x80, 0x1000010, 0x4)

 *              2. When the interpreter is loading a table, we can also

 *                 automatically run _REG for the following case:

 *                   operation_region (OPR1, 0x80, 0x1000010, 0x4)

 *              Though this may not be compliant to the de-facto standard, the

 *              logic is kept in order not to trigger regressions. And keeping

 *              this logic should be taken care by the caller of this function.

 *

	/*

	 * The following loop depends upon the root Node having no parent

	 * ie: acpi_gbl_root_node->Parent being set to NULL

 Check to see if a handler exists */

 Can only be a handler if the object exists */

 Ignore other objects */

 Found correct handler */

				/*

				 * Tell all users that this region is usable by

				 * running the _REG method

 This node does not have the handler we need; Pop up one level */

	/*

	 * If we get here, there is no handler for this region. This is not

	 * fatal because many regions get created before a handler is installed

	 * for said region.

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exconfig - Namespace reconfiguration (Load/Unload opcodes)

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_add_table

 *

 * PARAMETERS:  table               - Pointer to raw table

 *              parent_node         - Where to load the table (scope)

 *              ddb_handle          - Where to return the table handle.

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Common function to Install and Load an ACPI table with a

 *              returned table handle.

 *

 Create an object to be the table handle */

 Init the table handle */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_load_table_op

 *

 * PARAMETERS:  walk_state          - Current state with operands

 *              return_desc         - Where to store the return object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Load an ACPI table from the RSDT/XSDT

 *

 Find the ACPI table in the RSDT/XSDT */

 Table not found, return an Integer=0 and AE_OK */

 Default nodes */

 root_path (optional parameter) */

		/*

		 * Find the node referenced by the root_path_string. This is the

		 * location within the namespace where the table will be loaded.

 parameter_path (optional parameter) */

			/*

			 * Path is not absolute, so it will be relative to the node

			 * referenced by the root_path_string (or the NS root if omitted)

 Find the node referenced by the parameter_path_string */

 Load the table into the namespace */

 Complete the initialization/resolution of new objects */

 Parameter Data (optional) */

 Store the parameter data into the optional parameter object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_region_read

 *

 * PARAMETERS:  obj_desc        - Region descriptor

 *              length          - Number of bytes to read

 *              buffer          - Pointer to where to put the data

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Read data from an operation region. The read starts from the

 *              beginning of the region.

 *

 Bytewise reads */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_load_op

 *

 * PARAMETERS:  obj_desc        - Region or Buffer/Field where the table will be

 *                                obtained

 *              target          - Where a handle to the table will be stored

 *              walk_state      - Current state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Load an ACPI table from a field or operation region

 *

 * NOTE: Region Fields (Field, bank_field, index_fields) are resolved to buffer

 *       objects before this code is reached.

 *

 *       If source is an operation region, it must refer to system_memory, as

 *       per the ACPI specification.

 *

 Source Object can be either an op_region or a Buffer/Field */

 Region must be system_memory (from ACPI spec) */

		/*

		 * If the Region Address and Length have not been previously

		 * evaluated, evaluate them now and save the results.

 Get the table header first so we can get the table length */

 Must have at least an ACPI table header */

		/*

		 * The original implementation simply mapped the table, with no copy.

		 * However, the memory region is not guaranteed to remain stable and

		 * we must copy the table to a local buffer. For example, the memory

		 * region is corrupted after suspend on some machines. Dynamically

		 * loaded tables are usually small, so this overhead is minimal.

		 *

		 * The latest implementation (5/2009) does not use a mapping at all.

		 * We use the low-level operation region interface to read the table

		 * instead of the obvious optimization of using a direct mapping.

		 * This maintains a consistent use of operation regions across the

		 * entire subsystem. This is important if additional processing must

		 * be performed in the (possibly user-installed) operation region

		 * handler. For example, acpi_exec and ASLTS depend on this.

 Allocate a buffer for the table */

 Read the entire table */

 Buffer or resolved region_field */

 Must have at least an ACPI table header */

 Get the actual table length from the table header */

 Table cannot extend beyond the buffer */

		/*

		 * Copy the table from the buffer because the buffer could be

		 * modified or even deleted in the future

 Install the new table into the local data structures */

 Delete allocated table buffer */

	/*

	 * Add the table to the namespace.

	 *

	 * Note: Load the table objects relative to the root of the namespace.

	 * This appears to go against the ACPI specification, but we do it for

	 * compatibility with other ACPI implementations.

 On error, table_ptr was deallocated above */

 Complete the initialization/resolution of new objects */

 Store the ddb_handle into the Target operand */

 table_ptr was deallocated above */

 Remove the reference by added by acpi_ex_store above */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_unload_table

 *

 * PARAMETERS:  ddb_handle          - Handle to a previously loaded table

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Unload an ACPI table

 *

	/*

	 * Temporarily emit a warning so that the ASL for the machine can be

	 * hopefully obtained. This is to say that the Unload() operator is

	 * extremely rare if not completely unused.

	/*

	 * May 2018: Unload is no longer supported for the following reasons:

	 * 1) A correct implementation on some hosts may not be possible.

	 * 2) Other ACPI implementations do not correctly/fully support it.

	 * 3) It requires host device driver support which does not exist.

	 *    (To properly support namespace unload out from underneath.)

	 * 4) This AML operator has never been seen in the field.

	/*

	 * Validate the handle

	 * Although the handle is partially validated in acpi_ex_reconfiguration()

	 * when it calls acpi_ex_resolve_operands(), the handle is more completely

	 * validated here.

	 *

	 * Handle must be a valid operand object of type reference. Also, the

	 * ddb_handle must still be marked valid (table has not been previously

	 * unloaded)

 Get the table index from the ddb_handle */

	/*

	 * Release the interpreter lock so that the table lock won't have

	 * strict order requirement against it.

	/*

	 * Invalidate the handle. We do this because the handle may be stored

	 * in a named object and may not be actually deleted until much later.

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: evglock - Global Lock support

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Entire module */

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_init_global_lock_handler

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Install a handler for the global lock release event

 *

 If Hardware Reduced flag is set, there is no global lock */

 Attempt installation of the global lock handler */

	/*

	 * If the global lock does not exist on this platform, the attempt to

	 * enable GBL_STATUS will fail (the GBL_ENABLE bit will not stick).

	 * Map to AE_OK, but mark global lock as not present. Any attempt to

	 * actually use the global lock will be flagged with an error.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_remove_global_lock_handler

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Remove the handler for the Global Lock

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_global_lock_handler

 *

 * PARAMETERS:  context         - From thread interface, not used

 *

 * RETURN:      ACPI_INTERRUPT_HANDLED

 *

 * DESCRIPTION: Invoked directly from the SCI handler when a global lock

 *              release interrupt occurs. If there is actually a pending

 *              request for the lock, signal the waiting thread.

 *

	/*

	 * If a request for the global lock is not actually pending,

	 * we are done. This handles "spurious" global lock interrupts

	 * which are possible (and have been seen) with bad BIOSs.

	/*

	 * Send a unit to the global lock semaphore. The actual acquisition

	 * of the global lock will be performed by the waiting thread.

/******************************************************************************

 *

 * FUNCTION:    acpi_ev_acquire_global_lock

 *

 * PARAMETERS:  timeout         - Max time to wait for the lock, in millisec.

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Attempt to gain ownership of the Global Lock.

 *

 * MUTEX:       Interpreter must be locked

 *

 * Note: The original implementation allowed multiple threads to "acquire" the

 * Global Lock, and the OS would hold the lock until the last thread had

 * released it. However, this could potentially starve the BIOS out of the

 * lock, especially in the case where there is a tight handshake between the

 * Embedded Controller driver and the BIOS. Therefore, this implementation

 * allows only one thread to acquire the HW Global Lock at a time, and makes

 * the global lock appear as a standard mutex on the OS side.

 *

	/*

	 * Only one thread can acquire the GL at a time, the global_lock_mutex

	 * enforces this. This interface releases the interpreter if we must wait.

	/*

	 * Update the global lock handle and check for wraparound. The handle is

	 * only used for the external global lock interfaces, but it is updated

	 * here to properly handle the case where a single thread may acquire the

	 * lock via both the AML and the acpi_acquire_global_lock interfaces. The

	 * handle is therefore updated on the first acquire from a given thread

	 * regardless of where the acquisition request originated.

	/*

	 * Make sure that a global lock actually exists. If not, just

	 * treat the lock as a standard mutex.

 Attempt to acquire the actual hardware lock */

		/*

		 * Did not get the lock. The pending bit was set above, and

		 * we must now wait until we receive the global lock

		 * released interrupt.

		/*

		 * Wait for handshake with the global lock interrupt handler.

		 * This interface releases the interpreter if we must wait.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_release_global_lock

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Releases ownership of the Global Lock.

 *

 Lock must be already acquired */

 Allow any thread to release the lock */

		/*

		 * If the pending bit was set, we must write GBL_RLS to the control

		 * register

 Release the local GL mutex */

 !ACPI_REDUCED_HARDWARE */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: nssearch - Namespace search

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_search_one_scope

 *

 * PARAMETERS:  target_name     - Ascii ACPI name to search for

 *              parent_node     - Starting node where search will begin

 *              type            - Object type to match

 *              return_node     - Where the matched Named obj is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Search a single level of the namespace. Performs a

 *              simple search of the specified level, and does not add

 *              entries or search parents.

 *

 *

 *      Named object lists are built (and subsequently dumped) in the

 *      order in which the names are encountered during the namespace load;

 *

 *      All namespace searching is linear in this implementation, but

 *      could be easily modified to support any improved search

 *      algorithm. However, the linear search was chosen for simplicity

 *      and because the trees are small and the other interpreter

 *      execution overhead is relatively high.

 *

 *      Note: CPU execution analysis has shown that the AML interpreter spends

 *      a very small percentage of its time searching the namespace. Therefore,

 *      the linear search seems to be sufficient, as there would seem to be

 *      little value in improving the search.

 *

	/*

	 * Search for name at this namespace level, which is to say that we

	 * must search for the name among the children of this object

 Check for match against the name */

 Resolve a control method alias if any */

 Found matching entry */

 Didn't match name, move on to the next peer object */

 Searched entire namespace level, not found */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_search_parent_tree

 *

 * PARAMETERS:  target_name     - Ascii ACPI name to search for

 *              node            - Starting node where search will begin

 *              type            - Object type to match

 *              return_node     - Where the matched Node is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Called when a name has not been found in the current namespace

 *              level. Before adding it or giving up, ACPI scope rules require

 *              searching enclosing scopes in cases identified by acpi_ns_local().

 *

 *              "A name is located by finding the matching name in the current

 *              name space, and then in the parent name space. If the parent

 *              name space does not contain the name, the search continues

 *              recursively until either the name is found or the name space

 *              does not have a parent (the root of the name space). This

 *              indicates that the name is not found" (From ACPI Specification,

 *              section 5.3)

 *

	/*

	 * If there is no parent (i.e., we are at the root) or type is "local",

	 * we won't be searching the parent tree.

 Search the parent tree */

 Search parents until target is found or we have backed up to the root */

		/*

		 * Search parent scope. Use TYPE_ANY because we don't care about the

		 * object type at this point, we only care about the existence of

		 * the actual name we are searching for. Typechecking comes later.

 Not found here, go up another level (until we reach the root) */

 Not found in parent tree */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_search_and_enter

 *

 * PARAMETERS:  target_name         - Ascii ACPI name to search for (4 chars)

 *              walk_state          - Current state of the walk

 *              node                - Starting node where search will begin

 *              interpreter_mode    - Add names only in ACPI_MODE_LOAD_PASS_x.

 *                                    Otherwise,search only.

 *              type                - Object type to match

 *              flags               - Flags describing the search restrictions

 *              return_node         - Where the Node is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Search for a name segment in a single namespace level,

 *              optionally adding it if it is not found. If the passed

 *              Type is not Any and the type previously stored in the

 *              entry was Any (i.e. unknown), update the stored type.

 *

 *              In ACPI_IMODE_EXECUTE, search only.

 *              In other modes, search and add if not found.

 *

 Parameter validation */

	/*

	 * Name must consist of valid ACPI characters. We will repair the name if

	 * necessary because we don't want to abort because of this, but we want

	 * all namespace names to be printable. A warning message is appropriate.

	 *

	 * This issue came up because there are in fact machines that exhibit

	 * this problem, and we want to be able to enable ACPI support for them,

	 * even though there are a few bad names.

 Try to find the name in the namespace level specified by the caller */

		/*

		 * If we found it AND the request specifies that a find is an error,

		 * return the error

 The node was found in the namespace */

			/*

			 * If the namespace override feature is enabled for this node,

			 * delete any existing attached sub-object and make the node

			 * look like a new node that is owned by the override table.

 Return an error if we don't expect to find the object */

 Either found it or there was an error: finished either way */

	/*

	 * The name was not found. If we are NOT performing the first pass

	 * (name entry) of loading the namespace, search the parent tree (all the

	 * way to the root if necessary.) We don't want to perform the parent

	 * search when the namespace is actually being loaded. We want to perform

	 * the search when namespace references are being resolved (load pass 2)

	 * and during the execution phase.

		/*

		 * Not found at this level - search parent tree according to the

		 * ACPI specification

 In execute mode, just search, never add names. Exit now */

 Create the new named object */

 Node is an object defined by an External() statement */

 Install the new object into the parent's list of children */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: nsxfeval - Public interfaces to the ACPI subsystem

 *                         ACPI Object evaluation interfaces

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_evaluate_object_typed

 *

 * PARAMETERS:  handle              - Object handle (optional)

 *              pathname            - Object pathname (optional)

 *              external_params     - List of parameters to pass to a method,

 *                                    terminated by NULL. May be NULL

 *                                    if no parameters are being passed.

 *              return_buffer       - Where to put the object's return value (if

 *                                    any). If NULL, no value is returned.

 *              return_type         - Expected type of return object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Find and evaluate the given object, passing the given

 *              parameters if necessary. One of "Handle" or "Pathname" must

 *              be valid (non-null)

 *

 Return buffer must be valid */

 Get a handle here, in order to build an error message if needed */

 Evaluate the object */

 Type ANY means "don't care about return value type" */

 Error because caller specifically asked for a return value */

 Examine the object type returned from evaluate_object */

 Return object type does not match requested type */

		/*

		 * Free a buffer created via ACPI_ALLOCATE_BUFFER.

		 * Note: We use acpi_os_free here because acpi_os_allocate was used

		 * to allocate the buffer. This purposefully bypasses the

		 * (optionally enabled) allocation tracking mechanism since we

		 * only want to track internal allocations.

/*******************************************************************************

 *

 * FUNCTION:    acpi_evaluate_object

 *

 * PARAMETERS:  handle              - Object handle (optional)

 *              pathname            - Object pathname (optional)

 *              external_params     - List of parameters to pass to method,

 *                                    terminated by NULL. May be NULL

 *                                    if no parameters are being passed.

 *              return_buffer       - Where to put method's return value (if

 *                                    any). If NULL, no value is returned.

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Find and evaluate the given object, passing the given

 *              parameters if necessary. One of "Handle" or "Pathname" must

 *              be valid (non-null)

 *

 Allocate and initialize the evaluation information block */

 Convert and validate the device handle */

	/*

	 * Get the actual namespace node for the target object.

	 * Handles these cases:

	 *

	 * 1) Null node, valid pathname from root (absolute path)

	 * 2) Node and valid pathname (path relative to Node)

	 * 3) Node, Null pathname

 The path is fully qualified, just evaluate by name */

		/*

		 * A handle is optional iff a fully qualified pathname is specified.

		 * Since we've already handled fully qualified names above, this is

		 * an error.

	/*

	 * Convert all external objects passed as arguments to the

	 * internal version(s).

 Warn on impossible argument count */

		/*

		 * Allocate a new parameter block for the internal objects

		 * Add 1 to count to allow for null terminated internal list

 Convert each external object in the list to an internal object */

	/*

	 * Begin incoming argument count analysis. Check for too few args

	 * and too many args.

 Check incoming argument count against the method definition */

 Just pass the required number of arguments */

		/*

		 * Any incoming external objects to be passed as arguments to the

		 * method must be converted to internal objects

			/*

			 * Allocate a new parameter block for the internal objects

			 * Add 1 to count to allow for null terminated internal list

 Convert each external object in the list to an internal object */

 Warn if arguments passed to an object that is not a method */

 Now we can evaluate the object */

	/*

	 * If we are expecting a return value, and all went well above,

	 * copy the return value to an external object.

		/*

		 * If we received a NS Node as a return object, this means that

		 * the object we are evaluating has nothing interesting to

		 * return (such as a mutex, etc.)  We return an error because

		 * these types are essentially unsupported by this interface.

		 * We don't check up front because this makes it easier to add

		 * support for various types at a later date if necessary.

 No need to delete a NS Node */

 Dereference Index and ref_of references */

 Get the size of the returned object */

 Validate/Allocate/Clear caller buffer */

			/*

			 * Caller's buffer is too small or a new one can't

			 * be allocated

 We have enough space for the object, build it */

		/*

		 * Delete the internal return object. NOTE: Interpreter must be

		 * locked to avoid race condition.

 Remove one reference on the return object (should delete it) */

 Free the input parameter list (if we created one) */

 Free the allocated parameter block */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_resolve_references

 *

 * PARAMETERS:  info                    - Evaluation info block

 *

 * RETURN:      Info->return_object is replaced with the dereferenced object

 *

 * DESCRIPTION: Dereference certain reference objects. Called before an

 *              internal return object is converted to an external union acpi_object.

 *

 * Performs an automatic dereference of Index and ref_of reference objects.

 * These reference objects are not supported by the union acpi_object, so this is a

 * last resort effort to return something useful. Also, provides compatibility

 * with other ACPI implementations.

 *

 * NOTE: does not handle references within returned package objects or nested

 * references, but this support could be added later if found to be necessary.

 *

 We are interested in reference objects only */

	/*

	 * Two types of references are supported - those created by Index and

	 * ref_of operators. A name reference (AML_NAMEPATH_OP) can be converted

	 * to a union acpi_object, so it is not dereferenced here. A ddb_handle

	 * (AML_LOAD_OP) cannot be dereferenced, nor can it be converted to

	 * a union acpi_object.

 Replace the existing reference object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_walk_namespace

 *

 * PARAMETERS:  type                - acpi_object_type to search for

 *              start_object        - Handle in namespace where search begins

 *              max_depth           - Depth to which search is to reach

 *              descending_callback - Called during tree descent

 *                                    when an object of "Type" is found

 *              ascending_callback  - Called during tree ascent

 *                                    when an object of "Type" is found

 *              context             - Passed to user function(s) above

 *              return_value        - Location where return value of

 *                                    user_function is put if terminated early

 *

 * RETURNS      Return value from the user_function if terminated early.

 *              Otherwise, returns NULL.

 *

 * DESCRIPTION: Performs a modified depth-first walk of the namespace tree,

 *              starting (and ending) at the object specified by start_handle.

 *              The callback function is called whenever an object that matches

 *              the type parameter is found. If the callback function returns

 *              a non-zero value, the search is terminated immediately and this

 *              value is returned to the caller.

 *

 *              The point of this procedure is to provide a generic namespace

 *              walk routine that can be called from multiple places to

 *              provide multiple services; the callback function(s) can be

 *              tailored to each task, whether it is a print function,

 *              a compare function, etc.

 *

 Parameter validation */

	/*

	 * Need to acquire the namespace reader lock to prevent interference

	 * with any concurrent table unloads (which causes the deletion of

	 * namespace objects). We cannot allow the deletion of a namespace node

	 * while the user function is using it. The exception to this are the

	 * nodes created and deleted during control method execution -- these

	 * nodes are marked as temporary nodes and are ignored by the namespace

	 * walk. Thus, control methods can be executed while holding the

	 * namespace deletion lock (and the user function can execute control

	 * methods.)

	/*

	 * Lock the namespace around the walk. The namespace will be

	 * unlocked/locked around each call to the user function - since the user

	 * function must be allowed to make ACPICA calls itself (for example, it

	 * will typically execute control methods during device enumeration.)

 Now we can validate the starting node */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_get_device_callback

 *

 * PARAMETERS:  Callback from acpi_get_device

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Takes callbacks from walk_namespace and filters out all non-

 *              present devices, or if they specified a HID, it filters based

 *              on that.

 *

	/*

	 * First, filter based on the device HID and CID.

	 *

	 * 01/2010: For this case where a specific HID is requested, we don't

	 * want to run _STA until we have an actual HID match. Thus, we will

	 * not unnecessarily execute _STA on devices for which the caller

	 * doesn't care about. Previously, _STA was executed unconditionally

	 * on all devices found here.

	 *

	 * A side-effect of this change is that now we will continue to search

	 * for a matching HID even under device trees where the parent device

	 * would have returned a _STA that indicates it is not present or

	 * not functioning (thus aborting the search on that branch).

			/*

			 * HID does not match, attempt match within the

			 * list of Compatible IDs (CIDs)

 Walk the CID list */

 Found a matching CID */

 Run _STA to determine if device is present */

		/*

		 * Don't examine the children of the device only when the

		 * device is neither present nor functional. See ACPI spec,

		 * description of _STA for more information.

 We have a valid device, invoke the user function */

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_devices

 *

 * PARAMETERS:  HID                 - HID to search for. Can be NULL.

 *              user_function       - Called when a matching object is found

 *              context             - Passed to user function

 *              return_value        - Location where return value of

 *                                    user_function is put if terminated early

 *

 * RETURNS      Return value from the user_function if terminated early.

 *              Otherwise, returns NULL.

 *

 * DESCRIPTION: Performs a modified depth-first walk of the namespace tree,

 *              starting (and ending) at the object specified by start_handle.

 *              The user_function is called whenever an object of type

 *              Device is found. If the user function returns

 *              a non-zero value, the search is terminated immediately and this

 *              value is returned to the caller.

 *

 *              This is a wrapper for walk_namespace, but the callback performs

 *              additional filtering. Please see acpi_ns_get_device_callback.

 *

 Parameter validation */

	/*

	 * We're going to call their callback from OUR callback, so we need

	 * to know what it is, and their context parameter.

	/*

	 * Lock the namespace around the walk.

	 * The namespace will be unlocked/locked around each call

	 * to the user function - since this function

	 * must be allowed to make Acpi calls itself.

/*******************************************************************************

 *

 * FUNCTION:    acpi_attach_data

 *

 * PARAMETERS:  obj_handle          - Namespace node

 *              handler             - Handler for this attachment

 *              data                - Pointer to data to be attached

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Attach arbitrary data and handler to a namespace node.

 *

 Parameter validation */

 Convert and validate the handle */

/*******************************************************************************

 *

 * FUNCTION:    acpi_detach_data

 *

 * PARAMETERS:  obj_handle          - Namespace node handle

 *              handler             - Handler used in call to acpi_attach_data

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Remove data that was previously attached to a node.

 *

 Parameter validation */

 Convert and validate the handle */

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_data_full

 *

 * PARAMETERS:  obj_handle          - Namespace node

 *              handler             - Handler used in call to attach_data

 *              data                - Where the data is returned

 *              callback            - function to execute before returning

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Retrieve data that was previously attached to a namespace node

 *              and execute a callback before returning.

 *

 Parameter validation */

 Convert and validate the handle */

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_data

 *

 * PARAMETERS:  obj_handle          - Namespace node

 *              handler             - Handler used in call to attach_data

 *              data                - Where the data is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Retrieve data that was previously attached to a namespace node.

 *

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exoparg3 - AML execution - opcodes with 3 arguments

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*!

 * Naming convention for AML interpreter execution routines.

 *

 * The routines that begin execution of AML opcodes are named with a common

 * convention based upon the number of arguments, the number of target operands,

 * and whether or not a value is returned:

 *

 *      AcpiExOpcode_xA_yT_zR

 *

 * Where:

 *

 * xA - ARGUMENTS:    The number of arguments (input operands) that are

 *                    required for this opcode type (1 through 6 args).

 * yT - TARGETS:      The number of targets (output operands) that are required

 *                    for this opcode type (0, 1, or 2 targets).

 * zR - RETURN VALUE: Indicates whether this opcode type returns a value

 *                    as the function return (0 or 1).

 *

 * The AcpiExOpcode* functions are called via the Dispatcher component with

 * fully resolved operands.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_opcode_3A_0T_0R

 *

 * PARAMETERS:  walk_state          - Current walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute Triadic operator (3 operands)

 *

 Fatal (fatal_type fatal_code fatal_arg) */

 Always signal the OS! */

 Might return while OS is shutting down, just continue */

		/*

		 * If the interpreter sees this opcode, just ignore it. The External

		 * op is intended for use by disassemblers in order to properly

		 * disassemble control method invocations. The opcode or group of

		 * opcodes should be surrounded by an "if (0)" clause to ensure that

		 * AML interpreters never see the opcode. Thus, something is

		 * wrong if an external opcode ever gets here.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_opcode_3A_1T_1R

 *

 * PARAMETERS:  walk_state          - Current walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute Triadic operator (3 operands)

 *

 Mid (Source[0], Index[1], Length[2], Result[3]) */

		/*

		 * Create the return object. The Source operand is guaranteed to be

		 * either a String or a Buffer, so just use its type.

 Get the Integer values from the objects */

		/*

		 * If the index is beyond the length of the String/Buffer, or if the

		 * requested length is zero, return a zero-length String/Buffer

 Truncate request if larger than the actual String/Buffer */

 Strings always have a sub-pointer, not so for buffers */

 Always allocate a new buffer for the String */

 If the requested length is zero, don't allocate a buffer */

 Allocate a new buffer for the Buffer */

 Should not happen */

 We have a buffer, copy the portion requested */

 Set the length of the new String/Buffer */

 Mark buffer initialized */

 Store the result in the target */

 Delete return object on error */

 Set the return object and exit */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: nspredef - Validation of ACPI predefined methods and objects

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * This module validates predefined ACPI objects that appear in the namespace,

 * at the time they are evaluated (via acpi_evaluate_object). The purpose of this

 * validation is to detect problems with BIOS-exposed predefined ACPI objects

 * before the results are returned to the ACPI-related drivers.

 *

 * There are several areas that are validated:

 *

 *  1) The number of input arguments as defined by the method/object in the

 *     ASL is validated against the ACPI specification.

 *  2) The type of the return object (if any) is validated against the ACPI

 *     specification.

 *  3) For returned package objects, the count of package elements is

 *     validated, as well as the type of each package element. Nested

 *     packages are supported.

 *

 * For any problems found, a warning message is issued.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_check_return_value

 *

 * PARAMETERS:  node            - Namespace node for the method/object

 *              info            - Method execution information block

 *              user_param_count - Number of parameters actually passed

 *              return_status   - Status from the object evaluation

 *              return_object_ptr - Pointer to the object returned from the

 *                                evaluation of a method or object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Check the value returned from a predefined name.

 *

 If not a predefined name, we cannot validate the return object */

	/*

	 * If the method failed or did not actually return an object, we cannot

	 * validate the return object

	/*

	 * Return value validation and possible repair.

	 *

	 * 1) Don't perform return value validation/repair if this feature

	 * has been disabled via a global option.

	 *

	 * 2) We have a return value, but if one wasn't expected, just exit,

	 * this is not a problem. For example, if the "Implicit Return"

	 * feature is enabled, methods will always return a value.

	 *

	 * 3) If the return value can be of any type, then we cannot perform

	 * any validation, just exit.

	/*

	 * Check that the type of the main return object is what is expected

	 * for this predefined name

	/*

	 *

	 * 4) If there is no return value and it is optional, just return

	 * AE_OK (_WAK).

	/*

	 * For returned Package objects, check the type of all sub-objects.

	 * Note: Package may have been newly created by call above.

 We might be able to fix some errors */

	/*

	 * The return object was OK, or it was successfully repaired above.

	 * Now make some additional checks such as verifying that package

	 * objects are sorted correctly (if required) or buffer objects have

	 * the correct data width (bytes vs. dwords). These repairs are

	 * performed on a per-name basis, i.e., the code is specific to

	 * particular predefined names.

	/*

	 * If the object validation failed or if we successfully repaired one

	 * or more objects, mark the parent node to suppress further warning

	 * messages during the next evaluation of the same method/object.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_check_object_type

 *

 * PARAMETERS:  info            - Method execution information block

 *              return_object_ptr - Pointer to the object returned from the

 *                                evaluation of a method or object

 *              expected_btypes - Bitmap of expected return type(s)

 *              package_index   - Index of object within parent package (if

 *                                applicable - ACPI_NOT_PACKAGE_ELEMENT

 *                                otherwise)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Check the type of the return object against the expected object

 *              type(s). Use of Btype allows multiple expected object types.

 *

 Room for 10 types */

 A Namespace node should not get here, but make sure */

	/*

	 * Convert the object type (ACPI_TYPE_xxx) to a bitmapped object type.

	 * The bitmapped type allows multiple possible return types.

	 *

	 * Note, the cases below must handle all of the possible types returned

	 * from all of the predefined names (including elements of returned

	 * packages)

 Not one of the supported objects, must be incorrect */

 For reference objects, check that the reference type is correct */

 Attempt simple repair of the returned object if necessary */

 Successful repair */

 Create a string with all expected types for this predefined object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_check_reference

 *

 * PARAMETERS:  info            - Method execution information block

 *              return_object   - Object returned from the evaluation of a

 *                                method or object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Check a returned reference object for the correct reference

 *              type. The only reference type that can be returned from a

 *              predefined method is a named reference. All others are invalid.

 *

	/*

	 * Check the reference object for the correct reference type (opcode).

	 * The only type of reference that can be converted to a union acpi_object is

	 * a reference to a named object (reference class: NAME)

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_get_bitmapped_type

 *

 * PARAMETERS:  return_object   - Object returned from method/obj evaluation

 *

 * RETURN:      Object return type. ACPI_RTYPE_ANY indicates that the object

 *              type is not supported. ACPI_RTYPE_NONE indicates that no

 *              object was returned (return_object is NULL).

 *

 * DESCRIPTION: Convert object type into a bitmapped object return type.

 *

 Map acpi_object_type to internal bitmapped type */

 Not one of the supported objects, must be incorrect */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: psobject - Support for parse objects

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_get_aml_opcode

 *

 * PARAMETERS:  walk_state          - Current state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Extract the next AML opcode from the input stream.

 *

	/*

	 * First cut to determine what we have found:

	 * 1) A valid AML opcode

	 * 2) A name string

	 * 3) An unknown/invalid opcode

		/*

		 * Starts with a valid prefix or ASCII char, this is a name

		 * string. Convert the bare name string to a namepath.

 The opcode is unrecognized. Complain and skip unknown opcodes */

			/*

			 * This is executed for the disassembler only. Output goes

			 * to the disassembled ASL output file.

			    ("/*\nError: Unknown opcode 0x%.2X at table offset 0x%.4X, context:\n",

			     walk_state->opcode,

			     (u32)(aml_offset +

				   sizeof(struct acpi_table_header)));



			ACPI_ERROR((AE_INFO,

				    "Aborting disassembly, AML byte code is corrupt"));



			/* Dump the context surrounding the invalid opcode */



			acpi_ut_dump_buffer(((u8 *)walk_state->parser_state.

					     aml - 16), 48, DB_BYTE_DISPLAY,

					    (aml_offset +

					     sizeof(struct acpi_table_header) -

					     16));

			/*

			 * Just abort the disassembly, cannot continue because the

			 * parser is essentially lost. The disassembler can then

			 * randomly fail because an ill-constructed parse tree

			 * can result.

 Increment past one-byte or two-byte opcode */

 Can only happen if first byte is 0x5B */

 Found opcode info, this is a normal opcode */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_build_named_op

 *

 * PARAMETERS:  walk_state          - Current state

 *              aml_op_start        - Begin of named Op in AML

 *              unnamed_op          - Early Op (not a named Op)

 *              op                  - Returned Op

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Parse a named Op

 *

	/*

	 * Get and append arguments until we find the node that contains

	 * the name (the type ARGP_NAME).

 are there any inline comments associated with the name_seg?? If so, save this. */

	/*

	 * Make sure that we found a NAME and didn't run out of arguments

 We know that this arg is a name, move to next arg */

	/*

	 * Find the object. This will either insert the object into

	 * the namespace or simply look it up

 save any comments that might be associated with unnamed_op. */

		/*

		 * Defer final parsing of an operation_region body, because we don't

		 * have enough info in the first pass to parse it correctly (i.e.,

		 * there may be method calls within the term_arg elements of the body.)

		 *

		 * However, we must continue parsing because the opregion is not a

		 * standalone package -- we don't know where the end is at this point.

		 *

		 * (Length is unknown until parse of the body complete)

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_create_op

 *

 * PARAMETERS:  walk_state          - Current state

 *              aml_op_start        - Op start in AML

 *              new_op              - Returned Op

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Get Op from AML

 *

 Create Op structure and append to parent's argument list */

			/*

			 * If parsing of AML_EXTERNAL_OP's name path fails, then skip

			 * past this opcode and keep parsing. This is a much better

			 * alternative than to abort the entire disassembler. At this

			 * point, the parser_state is at the end of the namepath of the

			 * external declaration opcode. Setting walk_state->Aml to

			 * walk_state->parser_state.Aml + 2 moves increments the

			 * walk_state->Aml past the object type and the paramcount of the

			 * external opcode.

 Not a named opcode, just allocate Op and append to parent */

		/*

		 * Backup to beginning of create_XXXfield declaration

		 * body_length is unknown until we parse the body

		/*

		 * Backup to beginning of bank_field declaration

		 * body_length is unknown until we parse the body

		/*

		 * Special case for both Increment() and Decrement(), where

		 * the lone argument is both a source and a target.

		/*

		 * Find the object. This will either insert the object into

		 * the namespace or simply look it up

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_complete_op

 *

 * PARAMETERS:  walk_state          - Current state

 *              op                  - Returned Op

 *              status              - Parse status before complete Op

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Complete Op

 *

	/*

	 * Finished one argument of the containing scope

 Close this Op (will result in parse subtree deletion) */

 We are about to transfer to a called method */

 Pop off scopes until we find the While */

 Close this iteration of the While loop */

 Clean up */

 All other non-AE_OK status */

				/*

				 * These Opcodes need to be removed from the namespace because they

				 * get created even if these opcodes cannot be created due to

				 * errors.

		/*

		 * TBD: Cleanup parse ops on error

			/*

			 * There was something that went wrong while executing code at the

			 * module-level. We need to skip parsing whatever caused the

			 * error and keep going. One runtime error during the table load

			 * should not cause the entire table to not be loaded. This is

			 * because there could be correct AML beyond the parts that caused

			 * the runtime error.

 This scope complete? */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_complete_final_op

 *

 * PARAMETERS:  walk_state          - Current state

 *              op                  - Current Op

 *              status              - Current parse status before complete last

 *                                    Op

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Complete last Op.

 *

	/*

	 * Complete the last Op (if not completed), and clear the scope stack.

	 * It is easily possible to end an AML "package" with an unbounded number

	 * of open scopes (such as when several ASL blocks are closed with

	 * sequential closing braces). We want to terminate each one cleanly.

 Clean up */

 First error is most important */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exoparg6 - AML execution - opcodes with 6 arguments

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*!

 * Naming convention for AML interpreter execution routines.

 *

 * The routines that begin execution of AML opcodes are named with a common

 * convention based upon the number of arguments, the number of target operands,

 * and whether or not a value is returned:

 *

 *      AcpiExOpcode_xA_yT_zR

 *

 * Where:

 *

 * xA - ARGUMENTS:    The number of arguments (input operands) that are

 *                    required for this opcode type (1 through 6 args).

 * yT - TARGETS:      The number of targets (output operands) that are required

 *                    for this opcode type (0, 1, or 2 targets).

 * zR - RETURN VALUE: Indicates whether this opcode type returns a value

 *                    as the function return (0 or 1).

 *

 * The AcpiExOpcode* functions are called via the Dispatcher component with

 * fully resolved operands.

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_do_match

 *

 * PARAMETERS:  match_op        - The AML match operand

 *              package_obj     - Object from the target package

 *              match_obj       - Object to be matched

 *

 * RETURN:      TRUE if the match is successful, FALSE otherwise

 *

 * DESCRIPTION: Implements the low-level match for the ASL Match operator.

 *              Package elements will be implicitly converted to the type of

 *              the match object (Integer/Buffer/String).

 *

	/*

	 * Note: Since the package_obj/match_obj ordering is opposite to that of

	 * the standard logical operators, we have to reverse them when we call

	 * do_logical_op in order to make the implicit conversion rules work

	 * correctly. However, this means we have to flip the entire equation

	 * also. A bit ugly perhaps, but overall, better than fussing the

	 * parameters around at runtime, over and over again.

	 *

	 * Below, P[i] refers to the package element, M refers to the Match object.

 Always true */

		/*

		 * True if equal: (P[i] == M)

		 * Change to:     (M == P[i])

		/*

		 * True if less than or equal: (P[i] <= M) (P[i] not_greater than M)

		 * Change to:                  (M >= P[i]) (M not_less than P[i])

		/*

		 * True if less than: (P[i] < M)

		 * Change to:         (M > P[i])

		/*

		 * True if greater than or equal: (P[i] >= M) (P[i] not_less than M)

		 * Change to:                     (M <= P[i]) (M not_greater than P[i])

		/*

		 * True if greater than: (P[i] > M)

		 * Change to:            (M < P[i])

 Undefined */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_opcode_6A_0T_1R

 *

 * PARAMETERS:  walk_state          - Current walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute opcode with 6 arguments, no target, and a return value

 *

		/*

		 * Match (search_pkg[0], match_op1[1], match_obj1[2],

		 *                      match_op2[3], match_obj2[4], start_index[5])

 Validate both Match Term Operators (MTR, MEQ, etc.) */

 Get the package start_index, validate against the package length */

 Create an integer for the return value */

 Default return value is ACPI_UINT64_MAX if no match found */

		/*

		 * Examine each element until a match is found. Both match conditions

		 * must be satisfied for a match to occur. Within the loop,

		 * "continue" signifies that the current element does not match

		 * and the next should be examined.

		 *

		 * Upon finding a match, the loop will terminate via "break" at

		 * the bottom. If it terminates "normally", match_value will be

		 * ACPI_UINT64_MAX (Ones) (its initial value) indicating that no

		 * match was found.

 Get the current package element */

 Treat any uninitialized (NULL) elements as non-matching */

			/*

			 * Both match conditions must be satisfied. Execution of a continue

			 * (proceed to next iteration of enclosing for loop) signifies a

			 * non-match.

 Match found: Index is the return value */

 Delete return object on error */

 Save return object on success */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: evhandler - Support for Address Space handlers

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

 These are the address spaces that will get default handlers */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_install_region_handlers

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Installs the core subsystem default address space handlers.

 *

	/*

	 * All address spaces (PCI Config, EC, SMBus) are scope dependent and

	 * registration must occur for a specific device.

	 *

	 * In the case of the system memory and IO address spaces there is

	 * currently no device associated with the address space. For these we

	 * use the root.

	 *

	 * We install the default PCI config space handler at the root so that

	 * this space is immediately available even though the we have not

	 * enumerated all the PCI Root Buses yet. This is to conform to the ACPI

	 * specification which states that the PCI config space must be always

	 * available -- even though we are nowhere near ready to find the PCI root

	 * buses at this point.

	 *

	 * NOTE: We ignore AE_ALREADY_EXISTS because this means that a handler

	 * has already been installed (via acpi_install_address_space_handler).

	 * Similar for AE_SAME_HANDLER.

 These exceptions are all OK */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_has_default_handler

 *

 * PARAMETERS:  node                - Namespace node for the device

 *              space_id            - The address space ID

 *

 * RETURN:      TRUE if default handler is installed, FALSE otherwise

 *

 * DESCRIPTION: Check if the default handler is installed for the requested

 *              space ID.

 *

 Must have an existing internal object */

 Walk the linked list of handlers for this object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_install_handler

 *

 * PARAMETERS:  walk_namespace callback

 *

 * DESCRIPTION: This routine installs an address handler into objects that are

 *              of type Region or Device.

 *

 *              If the Object is a Device, and the device has a handler of

 *              the same type then the search is terminated in that branch.

 *

 *              This is because the existing handler is closer in proximity

 *              to any more regions than the one we are trying to install.

 *

 Parameter validation */

 Convert and validate the device handle */

	/*

	 * We only care about regions and objects that are allowed to have

	 * address space handlers

 Check for an existing internal object */

 No object, just exit */

 Devices are handled different than regions */

 Check if this Device already has a handler for this address space */

 Found a handler, is it for the same address space? */

			/*

			 * Since the object we found it on was a device, then it means

			 * that someone has already installed a handler for the branch

			 * of the namespace from this device on. Just bail out telling

			 * the walk routine to not traverse this branch. This preserves

			 * the scoping rule for handlers.

		/*

		 * As long as the device didn't have a handler for this space we

		 * don't care about it. We just ignore it and proceed.

 Object is a Region */

 This region is for a different address space, just ignore it */

	/*

	 * Now we have a region and it is for the handler's address space type.

	 *

	 * First disconnect region for any previous handler (if any)

 Connect the region to the new handler */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_find_region_handler

 *

 * PARAMETERS:  space_id        - The address space ID

 *              handler_obj     - Head of the handler object list

 *

 * RETURN:      Matching handler object. NULL if space ID not matched

 *

 * DESCRIPTION: Search a handler object list for a match on the address

 *              space ID.

 *

 Walk the handler list for this device */

 Same space_id indicates a handler is installed */

 Next handler object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_install_space_handler

 *

 * PARAMETERS:  node            - Namespace node for the device

 *              space_id        - The address space ID

 *              handler         - Address of the handler

 *              setup           - Address of the setup function

 *              context         - Value passed to the handler on each access

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Install a handler for all op_regions of a given space_id.

 *              Assumes namespace is locked

 *

	/*

	 * This registration is valid for only the types below and the root.

	 * The root node is where the default handlers get installed.

 If the caller hasn't specified a setup routine, use the default */

 Check for an existing internal object */

		/*

		 * The attached device object already exists. Now make sure

		 * the handler is not already installed.

				/*

				 * It is (relatively) OK to attempt to install the SAME

				 * handler twice. This can easily happen with the

				 * PCI_Config space.

 A handler is already installed */

 obj_desc does not exist, create one */

 Init new descriptor */

 Attach the new object to the Node */

 Remove local reference to the object */

	/*

	 * Install the handler

	 *

	 * At this point there is no existing handler. Just allocate the object

	 * for the handler and link it into the list.

 Init handler obj */

 Install at head of Device.address_space list */

	/*

	 * The Device object is the first reference on the handler_obj.

	 * Each region that uses the handler adds a reference.

	/*

	 * Walk the namespace finding all of the regions this handler will

	 * manage.

	 *

	 * Start at the device and search the branch toward the leaf nodes

	 * until either the leaf is encountered or a device is detected that

	 * has an address handler of the same type.

	 *

	 * In either case, back up and search down the remainder of the branch

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: dbmethod - Debug commands for control methods

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_set_method_breakpoint

 *

 * PARAMETERS:  location            - AML offset of breakpoint

 *              walk_state          - Current walk info

 *              op                  - Current Op (from parse walk)

 *

 * RETURN:      None

 *

 * DESCRIPTION: Set a breakpoint in a control method at the specified

 *              AML offset

 *

 Get and verify the breakpoint address */

 Save breakpoint in current walk */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_set_method_call_breakpoint

 *

 * PARAMETERS:  op                  - Current Op (from parse walk)

 *

 * RETURN:      None

 *

 * DESCRIPTION: Set a breakpoint in a control method at the specified

 *              AML offset

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_set_method_data

 *

 * PARAMETERS:  type_arg        - L for local, A for argument

 *              index_arg       - which one

 *              value_arg       - Value to set.

 *

 * RETURN:      None

 *

 * DESCRIPTION: Set a local or argument for the running control method.

 *              NOTE: only object supported is Number.

 *

 Validate type_arg */

 Get the index and value */

 Create and initialize the new object */

 Store the new object into the target */

 Set a method argument */

 Set a method local */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_disassemble_aml

 *

 * PARAMETERS:  statements          - Number of statements to disassemble

 *              op                  - Current Op (from parse walk)

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display disassembled AML (ASL) starting from Op for the number

 *              of statements specified.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_disassemble_method

 *

 * PARAMETERS:  name            - Name of control method

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display disassembled AML (ASL) starting from Op for the number

 *              of statements specified.

 *

 Create and initialize a new walk state */

 Push start scope on scope stack and make it current */

 Parse the entire method AML including deferred operators */

 Now we can disassemble the method */

 Method cleanup */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_evaluate_object

 *

 * PARAMETERS:  node                - Namespace node for the object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Main execution function for the Evaluate/Execute/All debugger

 *              commands.

 *

 Get the object info for number of method parameters */

 Setup default parameters */

 Do the actual method execution */

 Ignore status from method execution */

 Update count, check if we have executed enough methods */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_walk_for_execute

 *

 * PARAMETERS:  Callback from walk_namespace

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Batch execution function. Evaluates all "predefined" objects --

 *              the nameseg begins with an underscore.

 *

 Ignore status from object evaluation */

 Update count, check if we have executed enough methods */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_walk_for_execute_all

 *

 * PARAMETERS:  Callback from walk_namespace

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Batch execution function. Evaluates all objects whose path ends

 *              with the nameseg "Info->NameSeg". Used for the "ALL" command.

 *

 Now evaluate the input object (node) */

 Ignore status from method execution */

 Update count of executed methods/objects */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_evaluate_predefined_names

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Namespace batch execution. Execute predefined names in the

 *              namespace, up to the max count, if specified.

 *

 Search all nodes in namespace */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_evaluate_all

 *

 * PARAMETERS:  none_acpi_gbl_db_method_info

 *

 * RETURN:      None

 *

 * DESCRIPTION: Namespace batch execution. Implements the "ALL" command.

 *              Execute all namepaths whose final nameseg matches the

 *              input nameseg.

 *

 Search all nodes in namespace */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: dbtest - Various debug-related tests

 *

 Local prototypes */

/*

 * Test subcommands

 Must be null terminated */

/*

 * Support for the special debugger read/write control methods.

 * These methods are installed into the current namespace and are

 * used to read and write the various namespace objects. The point

 * is to force the AML interpreter do all of the work.

 ASL Definitions of the debugger read/write control methods. AML below. */

 Read */

 Write */

 00000000    "SSDT...." */

 00000008    "..Intel." */

 00000010    "DEBUG..." */

 00000018    "....INTL" */

 00000020    "... .._T" */

 00000028    "98...h"   */

 00000000    "SSDT...." */

 00000008    "..Intel." */

 00000010    "DEBUG..." */

 00000018    "....INTL" */

 00000020    "... .._T" */

 00000028    "99.pih"   */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_execute_test

 *

 * PARAMETERS:  type_arg        - Subcommand

 *

 * RETURN:      None

 *

 * DESCRIPTION: Execute various debug tests.

 *

 * Note: Code is prepared for future expansion of the TEST command.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_test_all_objects

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: This test implements the OBJECTS subcommand. It exercises the

 *              namespace by reading/writing/comparing all data objects such

 *              as integers, strings, buffers, fields, buffer fields, etc.

 *

 Install the debugger read-object control method if necessary */

 Install the debugger write-object control method if necessary */

 Walk the entire namespace, testing each supported named data object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_test_one_object

 *

 * PARAMETERS:  acpi_walk_callback

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Test one namespace object. Supported types are Integer,

 *              String, Buffer, Package, buffer_field, and field_unit.

 *              All other object types are simply ignored.

 *

	/*

	 * For the supported types, get the actual bit length or

	 * byte length. Map the type to one of Integer/String/Buffer.

 Integer width is either 32 or 64 */

		/*

		 * The returned object will be a Buffer if the field length

		 * is larger than the size of an Integer (32 or 64 bits

		 * depending on the DSDT version).

 Ignore all non-data types - Methods, Devices, Scopes, etc. */

 Emit the common prefix: Type:Name */

 At this point, we have resolved the object to one of the major types */

 Exit on error, but don't abort the namespace walk */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_test_integer_type

 *

 * PARAMETERS:  node                - Parent NS node for the object

 *              bit_length          - Actual length of the object. Used for

 *                                    support of arbitrary length field_unit

 *                                    and buffer_field objects.

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Test read/write for an Integer-valued object. Performs a

 *              write/read/compare of an arbitrary new value, then performs

 *              a write/read/compare of the original value.

 *

 Read the original value */

 Write a new value */

 Ensure that we can read back the new value */

 Write back the original value */

 Ensure that we can read back the original value */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_test_buffer_type

 *

 * PARAMETERS:  node                - Parent NS node for the object

 *              bit_length          - Actual length of the object.

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Test read/write for an Buffer-valued object. Performs a

 *              write/read/compare of an arbitrary new value, then performs

 *              a write/read/compare of the original value.

 *

 Allocate a local buffer */

 Read the original value */

 Emit a few bytes of the buffer */

	/*

	 * Write a new value.

	 *

	 * Handle possible extra bits at the end of the buffer. Can

	 * happen for field_units larger than an integer, but the bit

	 * count is not an integral number of bytes. Zero out the

	 * unused bits.

 Ensure that we can read back the new value */

 Write back the original value */

 Ensure that we can read back the original value */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_test_string_type

 *

 * PARAMETERS:  node                - Parent NS node for the object

 *              byte_length         - Actual length of the object.

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Test read/write for an String-valued object. Performs a

 *              write/read/compare of an arbitrary new value, then performs

 *              a write/read/compare of the original value.

 *

 Read the original value */

 Write a new value */

 Ensure that we can read back the new value */

 Write back the original value */

 Ensure that we can read back the original value */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_test_package_type

 *

 * PARAMETERS:  node                - Parent NS node for the object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Test read for a Package object.

 *

 Read the original value */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_test_field_unit_type

 *

 * PARAMETERS:  obj_desc                - A field unit object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Test read/write on a named field unit.

 *

 Supported spaces are memory/io/pci_config */

 Need the interpreter to execute */

 Exercise read-then-write */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_read_from_object

 *

 * PARAMETERS:  node                - Parent NS node for the object

 *              expected_type       - Object type expected from the read

 *              value               - Where the value read is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Performs a read from the specified object by invoking the

 *              special debugger control method that reads the object. Thus,

 *              the AML interpreter is doing all of the work, increasing the

 *              validity of the test.

 *

		/*

		 * Did we receive the type we wanted? Most important for the

		 * Integer/Buffer case (when a field is larger than an Integer,

		 * it should return a Buffer).

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_write_to_object

 *

 * PARAMETERS:  node                - Parent NS node for the object

 *              value               - Value to be written

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Performs a write to the specified object by invoking the

 *              special debugger control method that writes the object. Thus,

 *              the AML interpreter is doing all of the work, increasing the

 *              validity of the test.

 *

 Copy the incoming user parameter */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_evaluate_all_predefined_names

 *

 * PARAMETERS:  count_arg           - Max number of methods to execute

 *

 * RETURN:      None

 *

 * DESCRIPTION: Namespace batch execution. Execute predefined names in the

 *              namespace, up to the max count, if specified.

 *

 Search all nodes in namespace */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_evaluate_one_predefined_name

 *

 * PARAMETERS:  Callback from walk_namespace

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Batch execution module. Currently only executes predefined

 *              ACPI names.

 *

 The name must be a predefined ACPI name */

 Get the object info for number of method parameters */

 Setup default parameters (with proper types) */

		/*

		 * Setup the ACPI-required number of arguments, regardless of what

		 * the actual method defines. If there is a difference, then the

		 * method is wrong and a warning will be issued during execution.

 just a garbage buffer */

 Do the actual method execution */

 Ignore status from method execution */

 Update count, check if we have executed enough methods */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: evgpeutil - GPE utilities

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Entire module */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_walk_gpe_list

 *

 * PARAMETERS:  gpe_walk_callback   - Routine called for each GPE block

 *              context             - Value passed to callback

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Walk the GPE lists.

 *

 Walk the interrupt level descriptor list */

 Walk all Gpe Blocks attached to this interrupt level */

 One callback per GPE block */

 Callback abort */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_get_gpe_device

 *

 * PARAMETERS:  GPE_WALK_CALLBACK

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Matches the input GPE index (0-current_gpe_count) with a GPE

 *              block device. NULL if the GPE is one of the FADT-defined GPEs.

 *

 Increment Index by the number of GPEs in this block */

		/*

		 * The GPE index is within this block, get the node. Leave the node

		 * NULL for the FADT-defined GPEs

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_get_gpe_xrupt_block

 *

 * PARAMETERS:  interrupt_number            - Interrupt for a GPE block

 *              gpe_xrupt_block             - Where the block is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Get or Create a GPE interrupt block. There is one interrupt

 *              block per unique interrupt level used for GPEs. Should be

 *              called only when the GPE lists are semaphore locked and not

 *              subject to change.

 *

 No need for lock since we are not changing any list elements here */

 Not found, must allocate a new xrupt descriptor */

 Install new interrupt descriptor with spin lock */

 Install new interrupt handler if not SCI_INT */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_delete_gpe_xrupt

 *

 * PARAMETERS:  gpe_xrupt       - A GPE interrupt info block

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Remove and free a gpe_xrupt block. Remove an associated

 *              interrupt handler if not the SCI interrupt.

 *

 We never want to remove the SCI interrupt handler */

 Disable this interrupt */

 Unlink the interrupt block with lock */

 No previous, update list head */

 Free the block */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_delete_gpe_handlers

 *

 * PARAMETERS:  gpe_xrupt_info      - GPE Interrupt info

 *              gpe_block           - Gpe Block info

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Delete all Handler objects found in the GPE data structs.

 *              Used only prior to termination.

 *

 Examine each GPE Register within the block */

 Now look at the individual GPEs in this byte register */

 Delete an installed handler block */

 Delete the implicit notification device list */

 !ACPI_REDUCED_HARDWARE */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: uthex -- Hex/ASCII support functions

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Hex to ASCII conversion table */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_hex_to_ascii_char

 *

 * PARAMETERS:  integer             - Contains the hex digit

 *              position            - bit position of the digit within the

 *                                    integer (multiple of 4)

 *

 * RETURN:      The converted Ascii character

 *

 * DESCRIPTION: Convert a hex digit to an Ascii character

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_ascii_to_hex_byte

 *

 * PARAMETERS:  two_ascii_chars             - Pointer to two ASCII characters

 *              return_byte                 - Where converted byte is returned

 *

 * RETURN:      Status and converted hex byte

 *

 * DESCRIPTION: Perform ascii-to-hex translation, exactly two ASCII characters

 *              to a single converted byte value.

 *

 Both ASCII characters must be valid hex digits */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_ascii_char_to_hex

 *

 * PARAMETERS:  hex_char                - Hex character in Ascii. Must be:

 *                                        0-9 or A-F or a-f

 *

 * RETURN:      The binary value of the ascii/hex character

 *

 * DESCRIPTION: Perform ascii-to-hex translation

 *

 Values 0-9 */

 Upper case A-F */

 Lower case a-f */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exdebug - Support for stores to the AML Debug Object

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_do_debug_object

 *

 * PARAMETERS:  source_desc         - Object to be output to "Debug Object"

 *              level               - Indentation level (used for packages)

 *              index               - Current package element, zero if not pkg

 *

 * RETURN:      None

 *

 * DESCRIPTION: Handles stores to the AML Debug Object. For example:

 *              Store(INT1, Debug)

 *

 * This function is not compiled if ACPI_NO_ERROR_MESSAGES is set.

 *

 * This function is only enabled if acpi_gbl_enable_aml_debug_object is set, or

 * if ACPI_LV_DEBUG_OBJECT is set in the acpi_dbg_level. Thus, in the normal

 * operational case, stores to the debug object are ignored but can be easily

 * enabled if necessary.

 *

 Output must be enabled via the debug_object global or the dbg_level */

 Newline -- don't emit the line header */

	/*

	 * Print line header as long as we are not in the middle of an

	 * object display

			/*

			 * We will emit the current timer value (in microseconds) with each

			 * debug output. Only need the lower 26 bits. This allows for 67

			 * million microseconds or 67 seconds before rollover.

			 *

			 * Convert 100 nanosecond units to microseconds

 Display the index for package output only */

 No object type prefix needed for integers and strings */

 source_desc is of type ACPI_DESC_TYPE_OPERAND */

 Output correct integer width */

 Output the entire contents of the package */

 Decode the reference */

 Case for ddb_handle */

 Check for valid node first, then valid object */

 These types have no attached object */

 Reference object is a namespace node */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: nsdump - table dumping routines for debug

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 TBD: This entire module is apparently obsolete and should be removed */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_dump_one_device

 *

 * PARAMETERS:  handle              - Node to be dumped

 *              level               - Nesting level of the handle

 *              context             - Passed into walk_namespace

 *              return_value        - Not used

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Dump a single Node that represents a device

 *              This procedure is a user_function called by acpi_ns_walk_namespace.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_dump_root_devices

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Dump all objects of type "device"

 *

 Only dump the table if tracing is enabled */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: dsutils - Dispatcher utilities

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_clear_implicit_return

 *

 * PARAMETERS:  walk_state          - Current State

 *

 * RETURN:      None.

 *

 * DESCRIPTION: Clear and remove a reference on an implicit return value. Used

 *              to delete "stale" return values (if enabled, the return value

 *              from every operator is saved at least momentarily, in case the

 *              parent method exits.)

 *

	/*

	 * Slack must be enabled for this feature

		/*

		 * Delete any "stale" implicit return. However, in

		 * complex statements, the implicit return value can be

		 * bubbled up several levels.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_do_implicit_return

 *

 * PARAMETERS:  return_desc         - The return value

 *              walk_state          - Current State

 *              add_reference       - True if a reference should be added to the

 *                                    return object

 *

 * RETURN:      TRUE if implicit return enabled, FALSE otherwise

 *

 * DESCRIPTION: Implements the optional "implicit return".  We save the result

 *              of every ASL operator and control method invocation in case the

 *              parent method exit. Before storing a new return value, we

 *              delete the previous return value.

 *

	/*

	 * Slack must be enabled for this feature, and we must

	 * have a valid return object

	/*

	 * Delete any "stale" implicit return value first. However, in

	 * complex statements, the implicit return value can be

	 * bubbled up several levels, so we don't clear the value if it

	 * is the same as the return_desc.

 Save the implicit return value, add a reference if requested */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_is_result_used

 *

 * PARAMETERS:  op                  - Current Op

 *              walk_state          - Current State

 *

 * RETURN:      TRUE if result is used, FALSE otherwise

 *

 * DESCRIPTION: Check if a result object will be used by the parent

 *

 Must have both an Op and a Result Object */

	/*

	 * We know that this operator is not a

	 * Return() operator (would not come here.) The following code is the

	 * optional support for a so-called "implicit return". Some AML code

	 * assumes that the last value of the method is "implicitly" returned

	 * to the caller. Just save the last result as the return value.

	 * NOTE: this is optional because the ASL language does not actually

	 * support this behavior.

	/*

	 * Now determine if the parent will use the result

	 *

	 * If there is no parent, or the parent is a scope_op, we are executing

	 * at the method level. An executing method typically has no parent,

	 * since each method is parsed separately. A method invoked externally

	 * via execute_control_method has a scope_op as the parent.

 No parent, the return value cannot possibly be used */

 Get info on the parent. The root_op is AML_SCOPE */

	/*

	 * Decide what to do with the result based on the parent. If

	 * the parent opcode will not use the result, delete the object.

	 * Otherwise leave it as is, it will be deleted when it is used

	 * as an operand later.

 Never delete the return value associated with a return opcode */

			/*

			 * If we are executing the predicate AND this is the predicate op,

			 * we will use the return value

 Ignore other control opcodes */

 The general control opcode returns no result */

		/*

		 * These opcodes allow term_arg(s) as operands and therefore

		 * the operands can be method calls. The result is used.

			/*

			 * These opcodes allow term_arg(s) as operands and therefore

			 * the operands can be method calls. The result is used.

		/*

		 * In all other cases. the parent will actually use the return

		 * object, so keep it.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_delete_result_if_not_used

 *

 * PARAMETERS:  op              - Current parse Op

 *              result_obj      - Result of the operation

 *              walk_state      - Current state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Used after interpretation of an opcode. If there is an internal

 *              result descriptor, check if the parent opcode will actually use

 *              this result. If not, delete the result now so that it will

 *              not become orphaned.

 *

 Must pop the result stack (obj_desc should be equal to result_obj) */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_resolve_operands

 *

 * PARAMETERS:  walk_state          - Current walk state with operands on stack

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Resolve all operands to their values. Used to prepare

 *              arguments to a control method invocation (a call from one

 *              method to another.)

 *

	/*

	 * Attempt to resolve each of the valid operands

	 * Method arguments are passed by reference, not by value. This means

	 * that the actual objects are passed, not copies of the objects.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_clear_operands

 *

 * PARAMETERS:  walk_state          - Current walk state with operands on stack

 *

 * RETURN:      None

 *

 * DESCRIPTION: Clear all operands on the current walk state operand stack.

 *

 Remove a reference on each operand on the stack */

		/*

		 * Remove a reference to all operands, including both

		 * "Arguments" and "Targets".

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_create_operand

 *

 * PARAMETERS:  walk_state      - Current walk state

 *              arg             - Parse object for the argument

 *              arg_index       - Which argument (zero based)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Translate a parse tree object that is an argument to an AML

 *              opcode to the equivalent interpreter object. This may include

 *              looking up a name or entering a new name into the internal

 *              namespace.

 *

 A valid name must be looked up in the namespace */

 Get the entire name string from the AML stream */

 All prefixes have been handled, and the name is in name_string */

		/*

		 * Special handling for buffer_field declarations. This is a deferred

		 * opcode that unfortunately defines the field name as the last

		 * parameter instead of the first. We get here when we are performing

		 * the deferred execution, so the actual name of the field is already

		 * in the namespace. We don't want to attempt to look it up again

		 * because we may be executing in a different scope than where the

		 * actual opcode exists.

 All other opcodes */

			/*

			 * Differentiate between a namespace "create" operation

			 * versus a "lookup" operation (IMODE_LOAD_PASS2 vs.

			 * IMODE_EXECUTE) in order to support the creation of

			 * namespace objects during the execution of control methods.

 Enter name into namespace if not found */

 Return a failure if name not found */

			/*

			 * The only case where we pass through (ignore) a NOT_FOUND

			 * error is for the cond_ref_of opcode.

					/*

					 * For the Conditional Reference op, it's OK if

					 * the name is not found;  We just need a way to

					 * indicate this to the interpreter, set the

					 * object to the root

					/*

					 * This opcode should never appear here. It is used only

					 * by AML disassemblers and is surrounded by an If(0)

					 * by the ASL compiler.

					 *

					 * Therefore, if we see it here, it is a serious error.

					/*

					 * We just plain didn't find it -- which is a

					 * very serious error at this point

 Free the namestring created above */

 Check status from the lookup */

 Put the resulting object onto the current object stack */

 Check for null name case */

			/*

			 * If the name is null, this means that this is an

			 * optional result parameter that was not specified

			 * in the original ASL. Create a Zero Constant for a

			 * placeholder. (Store to a constant is a Noop.)

 Has no arguments! */

 Get the object type of the argument */

			/*

			 * Use value that was already previously returned

			 * by the evaluation of this argument

				/*

				 * Only error is underflow, and this indicates

				 * a missing or null operand!

 Create an ACPI_INTERNAL_OBJECT for the argument */

 Initialize the new object */

 Put the operand object on the object stack */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_create_operands

 *

 * PARAMETERS:  walk_state          - Current state

 *              first_arg           - First argument of a parser argument tree

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Convert an operator's arguments from a parse tree format to

 *              namespace objects and place those argument object on the object

 *              stack in preparation for evaluation by the interpreter.

 *

 Get all arguments in the list */

 Move on to next argument, if any */

 Create the interpreter arguments, in reverse order */

	/*

	 * We must undo everything done above; meaning that we must

	 * pop everything off of the operand stack and delete those

	 * objects

/*****************************************************************************

 *

 * FUNCTION:    acpi_ds_evaluate_name_path

 *

 * PARAMETERS:  walk_state      - Current state of the parse tree walk,

 *                                the opcode of current operation should be

 *                                AML_INT_NAMEPATH_OP

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Translate the -name_path- parse tree object to the equivalent

 *              interpreter object, convert it to value, if needed, duplicate

 *              it, if needed, and push it onto the current result stack.

 *

 This happens after certain exception processing */

 TBD: Should we specify this feature as a bit of op_info->Flags of these opcodes? */

 It was incremented by acpi_ex_resolve_to_value */

		/*

		 * The object either was anew created or is

		 * a Namespace node - don't decrement it.

 Cleanup for name-path operand */

 Force to take it from stack */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: nsaccess - Top-level functions for accessing ACPI namespace

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_root_initialize

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Allocate and initialize the default root named objects

 *

 * MUTEX:       Locks namespace for entire execution

 *

	/*

	 * The global root ptr is initially NULL, so a non-NULL value indicates

	 * that acpi_ns_root_initialize() has already been called; just return.

	/*

	 * Tell the rest of the subsystem that the root is initialized

	 * (This is OK because the namespace is locked)

 Enter the predefined names in the name table */

	/*

	 * Create the initial (default) namespace.

	 * This namespace looks like something similar to this:

	 *

	 *   ACPI Namespace (from Namespace Root):

	 *    0  _GPE Scope        00203160 00

	 *    0  _PR_ Scope        002031D0 00

	 *    0  _SB_ Device       00203240 00 Notify Object: 0020ADD8

	 *    0  _SI_ Scope        002032B0 00

	 *    0  _TZ_ Device       00203320 00

	 *    0  _REV Integer      00203390 00 = 0000000000000002

	 *    0  _OS_ String       00203488 00 Len 14 "Microsoft Windows NT"

	 *    0  _GL_ Mutex        00203580 00 Object 002035F0

	 *    0  _OSI Method       00203678 00 Args 1 Len 0000 Aml 00000000

 _OSI is optional for now, will be permanent later */

		/*

		 * Create, init, and link the new predefined name

		 * Note: No need to use acpi_ns_lookup here because all the

		 * predefined names are at the root level. It is much easier to

		 * just create and link the new node(s) here.

		/*

		 * Name entered successfully. If entry in pre_defined_names[] specifies

		 * an initial value, create the initial value.

			/*

			 * Entry requests an initial value, allocate a

			 * descriptor for it.

			/*

			 * Convert value string from table entry to

			 * internal representation. Only types actually

			 * used for initial values are implemented here.

 Save the parameter count for the iASL compiler */

 Mark this as a very SPECIAL method (_OSI) */

 Build an object around the static string */

 Create a mutex */

 Special case for ACPI Global Lock */

 Create additional counting semaphore for global lock */

 Store pointer to value descriptor in the Node */

 Remove local reference to the object */

 Save a handle to "_GPE", it is always present */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_lookup

 *

 * PARAMETERS:  scope_info      - Current scope info block

 *              pathname        - Search pathname, in internal format

 *                                (as represented in the AML stream)

 *              type            - Type associated with name

 *              interpreter_mode - IMODE_LOAD_PASS2 => add name if not found

 *              flags           - Flags describing the search restrictions

 *              walk_state      - Current state of the walk

 *              return_node     - Where the Node is placed (if found

 *                                or created successfully)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Find or enter the passed name in the name space.

 *              Log an error if name not found in Exec mode.

 *

 * MUTEX:       Assumes namespace is locked.

 *

 Get the prefix scope. A null scope means use the root scope */

			/*

			 * This node might not be a actual "scope" node (such as a

			 * Device/Method, etc.)  It could be a Package or other object

			 * node. Backup up the tree to find the containing scope node.

 Save type. TBD: may be no longer necessary */

	/*

	 * Begin examination of the actual pathname

 A Null name_path is allowed and refers to the root */

		/*

		 * Name pointer is valid (and must be in internal name format)

		 *

		 * Check for scope prefixes:

		 *

		 * As represented in the AML stream, a namepath consists of an

		 * optional scope prefix followed by a name segment part.

		 *

		 * If present, the scope prefix is either a Root Prefix (in

		 * which case the name is fully qualified), or one or more

		 * Parent Prefixes (in which case the name's scope is relative

		 * to the current scope).

 Pathname is fully qualified, start from the root */

 Point to name segment part */

 Pathname is relative to current scope, start there */

			/*

			 * Handle multiple Parent Prefixes (carat) by just getting

			 * the parent node for each prefix instance.

 Name is fully qualified, no search rules apply */

				/*

				 * Point past this prefix to the name segment

				 * part or the next Parent Prefix

 Backup to the parent node */

					/*

					 * Current scope has no parent scope. Externalize

					 * the internal path for error message.

		/*

		 * Determine the number of ACPI name segments in this pathname.

		 *

		 * The segment part consists of either:

		 *  - A Null name segment (0)

		 *  - A dual_name_prefix followed by two 4-byte name segments

		 *  - A multi_name_prefix followed by a byte indicating the

		 *      number of segments and the segments themselves.

		 *  - A single 4-byte name segment

		 *

		 * Examine the name prefix opcode, if any, to determine the number of

		 * segments.

			/*

			 * Null name after a root or parent prefixes. We already

			 * have the correct target node and there are no name segments.

 More than one name_seg, search rules do not apply */

 Two segments, point to first name segment */

 More than one name_seg, search rules do not apply */

 Extract segment count, point to first name segment */

			/*

			 * Not a Null name, no Dual or Multi prefix, hence there is

			 * only one name segment and Pathname is already pointing to it.

	/*

	 * Search namespace for each segment of the name. Loop through and

	 * verify (or add to the namespace) each name segment.

	 *

	 * The object type is significant only at the last name

	 * segment. (We don't care about the types along the path, only

	 * the type of the final target object.)

 This is the last segment, enable typechecking */

			/*

			 * Only allow automatic parent search (search rules) if the caller

			 * requested it AND we have a single, non-fully-qualified name_seg

 Set error flag according to caller */

 Set override flag according to caller */

 Handle opcodes that create a new name_seg via a full name_path */

 Every element of the path must exist (except for the final name_seg) */

 Extract one ACPI name from the front of the pathname */

 Try to find the single (4 character) ACPI name */

 Note: iASL reports this error by itself, not needed here */

 Name not found in ACPI namespace */

			/*

			 * If this ACPI name already exists within the namespace as an

			 * external declaration, then mark the external as a conflicting

			 * declaration and proceed to process the current node as if it did

			 * not exist in the namespace. If this node is not processed as

			 * normal, then it could cause improper namespace resolution

			 * by failing to open a new scope.

 More segments to follow? */

			/*

			 * If we have an alias to an object that opens a scope (such as a

			 * device or processor), we need to dereference the alias here so

			 * that we can access any children of the original node (via the

			 * remaining segments).

 Special handling for the last segment (num_segments == 0) */

			/*

			 * Sanity typecheck of the target object:

			 *

			 * If 1) This is the last segment (num_segments == 0)

			 *    2) And we are looking for a specific type

			 *       (Not checking for TYPE_ANY)

			 *    3) Which is not an alias

			 *    4) Which is not a local type (TYPE_SCOPE)

			 *    5) And the type of target object is known (not TYPE_ANY)

			 *    6) And target object does not match what we are looking for

			 *

			 * Then we have a type mismatch. Just warn and ignore it.

 Complain about a type mismatch */

			/*

			 * If this is the last name segment and we are not looking for a

			 * specific type, but the type of found object is known, use that

			 * type to (later) see if it opens a scope.

 Point to next name segment and make this node current */

 Always check if we need to open a new scope */

		/*

		 * If entry is a type which opens a scope, push the new scope on the

		 * scope stack.

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: nsrepair2 - Repair for objects returned by specific

 *                          predefined methods

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*

 * Information structure and handler for ACPI predefined names that can

 * be repaired on a per-name basis.

 Local prototypes */

 Values for sort_direction above */

/*

 * This table contains the names of the predefined methods for which we can

 * perform more complex repairs.

 *

 * As necessary:

 *

 * _ALR: Sort the list ascending by ambient_illuminance

 * _CID: Strings: uppercase all, remove any leading asterisk

 * _CST: Sort the list ascending by C state type

 * _FDE: Convert Buffer of BYTEs to a Buffer of DWORDs

 * _GTM: Convert Buffer of BYTEs to a Buffer of DWORDs

 * _HID: Strings: uppercase all, remove any leading asterisk

 * _PRT: Fix reversed source_name and source_index

 * _PSS: Sort the list descending by Power

 * _TSS: Sort the list descending by Power

 *

 * Names that must be packages, but cannot be sorted:

 *

 * _BCL: Values are tied to the Package index where they appear, and cannot

 * be moved or sorted. These index values are used for _BQC and _BCM.

 * However, we can fix the case where a buffer is returned, by converting

 * it to a Package of integers.

 _GTM has same repair as _FDE */

 Table terminator */

/******************************************************************************

 *

 * FUNCTION:    acpi_ns_complex_repairs

 *

 * PARAMETERS:  info                - Method execution information block

 *              node                - Namespace node for the method/object

 *              validate_status     - Original status of earlier validation

 *              return_object_ptr   - Pointer to the object returned from the

 *                                    evaluation of a method or object

 *

 * RETURN:      Status. AE_OK if repair was successful. If name is not

 *              matched, validate_status is returned.

 *

 * DESCRIPTION: Attempt to repair/convert a return object of a type that was

 *              not expected.

 *

 Check if this name is in the list of repairable names */

/******************************************************************************

 *

 * FUNCTION:    acpi_ns_match_complex_repair

 *

 * PARAMETERS:  node                - Namespace node for the method/object

 *

 * RETURN:      Pointer to entry in repair table. NULL indicates not found.

 *

 * DESCRIPTION: Check an object name against the repairable object list.

 *

 Search info table for a repairable predefined method/object name */

 Not found */

/******************************************************************************

 *

 * FUNCTION:    acpi_ns_repair_ALR

 *

 * PARAMETERS:  info                - Method execution information block

 *              return_object_ptr   - Pointer to the object returned from the

 *                                    evaluation of a method or object

 *

 * RETURN:      Status. AE_OK if object is OK or was repaired successfully

 *

 * DESCRIPTION: Repair for the _ALR object. If necessary, sort the object list

 *              ascending by the ambient illuminance values.

 *

/******************************************************************************

 *

 * FUNCTION:    acpi_ns_repair_FDE

 *

 * PARAMETERS:  info                - Method execution information block

 *              return_object_ptr   - Pointer to the object returned from the

 *                                    evaluation of a method or object

 *

 * RETURN:      Status. AE_OK if object is OK or was repaired successfully

 *

 * DESCRIPTION: Repair for the _FDE and _GTM objects. The expected return

 *              value is a Buffer of 5 DWORDs. This function repairs a common

 *              problem where the return value is a Buffer of BYTEs, not

 *              DWORDs.

 *

 This is the expected type. Length should be (at least) 5 DWORDs */

 We can only repair if we have exactly 5 BYTEs */

 Create the new (larger) buffer object */

 Expand each byte to a DWORD */

 Delete the original return object, return the new buffer object */

/******************************************************************************

 *

 * FUNCTION:    acpi_ns_repair_CID

 *

 * PARAMETERS:  info                - Method execution information block

 *              return_object_ptr   - Pointer to the object returned from the

 *                                    evaluation of a method or object

 *

 * RETURN:      Status. AE_OK if object is OK or was repaired successfully

 *

 * DESCRIPTION: Repair for the _CID object. If a string, ensure that all

 *              letters are uppercase and that there is no leading asterisk.

 *              If a Package, ensure same for all string elements.

 *

 Check for _CID as a simple string */

 Exit if not a Package */

 Examine each element of the _CID package */

 Update reference count of new object */

/******************************************************************************

 *

 * FUNCTION:    acpi_ns_repair_CST

 *

 * PARAMETERS:  info                - Method execution information block

 *              return_object_ptr   - Pointer to the object returned from the

 *                                    evaluation of a method or object

 *

 * RETURN:      Status. AE_OK if object is OK or was repaired successfully

 *

 * DESCRIPTION: Repair for the _CST object:

 *              1. Sort the list ascending by C state type

 *              2. Ensure type cannot be zero

 *              3. A subpackage count of zero means _CST is meaningless

 *              4. Count must match the number of C state subpackages

 *

	/*

	 * Check if the C-state type values are proportional.

 Index1 = Type */

 Update top-level package count, Type "Integer" checked elsewhere */

	/*

	 * Entries (subpackages) in the _CST Package must be sorted by the

	 * C-state type, in ascending order.

/******************************************************************************

 *

 * FUNCTION:    acpi_ns_repair_HID

 *

 * PARAMETERS:  info                - Method execution information block

 *              return_object_ptr   - Pointer to the object returned from the

 *                                    evaluation of a method or object

 *

 * RETURN:      Status. AE_OK if object is OK or was repaired successfully

 *

 * DESCRIPTION: Repair for the _HID object. If a string, ensure that all

 *              letters are uppercase and that there is no leading asterisk.

 *

 We only care about string _HID objects (not integers) */

 Return AE_OK anyway, let driver handle it */

 It is simplest to always create a new string object */

	/*

	 * Remove a leading asterisk if present. For some unknown reason, there

	 * are many machines in the field that contains IDs like this.

	 *

	 * Examples: "*PNP0C03", "*ACPI0003"

	/*

	 * Copy and uppercase the string. From the ACPI 5.0 specification:

	 *

	 * A valid PNP ID must be of the form "AAA####" where A is an uppercase

	 * letter and # is a hex digit. A valid ACPI ID must be of the form

	 * "NNNN####" where N is an uppercase letter or decimal digit, and

	 * # is a hex digit.

/******************************************************************************

 *

 * FUNCTION:    acpi_ns_repair_PRT

 *

 * PARAMETERS:  info                - Method execution information block

 *              return_object_ptr   - Pointer to the object returned from the

 *                                    evaluation of a method or object

 *

 * RETURN:      Status. AE_OK if object is OK or was repaired successfully

 *

 * DESCRIPTION: Repair for the _PRT object. If necessary, fix reversed

 *              source_name and source_index field, a common BIOS bug.

 *

 Each element in the _PRT package is a subpackage */

 Examine each subpackage */

 Check for minimum required element count */

		/*

		 * If the BIOS has erroneously reversed the _PRT source_name (index 2)

		 * and the source_index (index 3), fix it. _PRT is important enough to

		 * workaround this BIOS error. This also provides compatibility with

		 * other ACPI implementations.

/******************************************************************************

 *

 * FUNCTION:    acpi_ns_repair_PSS

 *

 * PARAMETERS:  info                - Method execution information block

 *              return_object_ptr   - Pointer to the object returned from the

 *                                    evaluation of a method or object

 *

 * RETURN:      Status. AE_OK if object is OK or was repaired successfully

 *

 * DESCRIPTION: Repair for the _PSS object. If necessary, sort the object list

 *              by the CPU frequencies. Check that the power dissipation values

 *              are all proportional to CPU frequency (i.e., sorting by

 *              frequency should be the same as sorting by power.)

 *

	/*

	 * Entries (subpackages) in the _PSS Package must be sorted by power

	 * dissipation, in descending order. If it appears that the list is

	 * incorrectly sorted, sort it. We sort by cpu_frequency, since this

	 * should be proportional to the power.

	/*

	 * We now know the list is correctly sorted by CPU frequency. Check if

	 * the power dissipation values are proportional.

 Index1 = power_dissipation */

/******************************************************************************

 *

 * FUNCTION:    acpi_ns_repair_TSS

 *

 * PARAMETERS:  info                - Method execution information block

 *              return_object_ptr   - Pointer to the object returned from the

 *                                    evaluation of a method or object

 *

 * RETURN:      Status. AE_OK if object is OK or was repaired successfully

 *

 * DESCRIPTION: Repair for the _TSS object. If necessary, sort the object list

 *              descending by the power dissipation values.

 *

	/*

	 * We can only sort the _TSS return package if there is no _PSS in the

	 * same scope. This is because if _PSS is present, the ACPI specification

	 * dictates that the _TSS Power Dissipation field is to be ignored, and

	 * therefore some BIOSs leave garbage values in the _TSS Power field(s).

	 * In this case, it is best to just return the _TSS package as-is.

	 * (May, 2011)

/******************************************************************************

 *

 * FUNCTION:    acpi_ns_check_sorted_list

 *

 * PARAMETERS:  info                - Method execution information block

 *              return_object       - Pointer to the top-level returned object

 *              start_index         - Index of the first subpackage

 *              expected_count      - Minimum length of each subpackage

 *              sort_index          - Subpackage entry to sort on

 *              sort_direction      - Ascending or descending

 *              sort_key_name       - Name of the sort_index field

 *

 * RETURN:      Status. AE_OK if the list is valid and is sorted correctly or

 *              has been repaired by sorting the list.

 *

 * DESCRIPTION: Check if the package list is valid and sorted correctly by the

 *              sort_index. If not, then sort the list.

 *

 The top-level object must be a package */

	/*

	 * NOTE: assumes list of subpackages contains no NULL elements.

	 * Any NULL elements should have been removed by earlier call

	 * to acpi_ns_remove_null_elements.

 Examine each subpackage */

 Each element of the top-level package must also be a package */

 Each subpackage must have the minimum length */

		/*

		 * The list must be sorted in the specified order. If we detect a

		 * discrepancy, sort the entire list.

/******************************************************************************

 *

 * FUNCTION:    acpi_ns_sort_list

 *

 * PARAMETERS:  elements            - Package object element list

 *              count               - Element count for above

 *              index               - Sort by which package element

 *              sort_direction      - Ascending or Descending sort

 *

 * RETURN:      None

 *

 * DESCRIPTION: Sort the objects that are in a package element list.

 *

 * NOTE: Assumes that all NULL elements have been removed from the package,

 *       and that all elements have been verified to be of type Integer.

 *

 Simple bubble sort */

/******************************************************************************

 *

 * FUNCTION:    acpi_ns_remove_element

 *

 * PARAMETERS:  obj_desc            - Package object element list

 *              index               - Index of element to remove

 *

 * RETURN:      None

 *

 * DESCRIPTION: Remove the requested element of a package and delete it.

 *

 Examine all elements of the package object, remove matched index */

 Remove one ref for being in pkg */

 NULL terminate list and update the package count */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Name: hwsleep.c - ACPI Hardware Sleep/Wake Support functions for the

 *                   original/legacy sleep/PM registers.

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Entire module */

/*******************************************************************************

 *

 * FUNCTION:    acpi_hw_legacy_sleep

 *

 * PARAMETERS:  sleep_state         - Which sleep state to enter

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Enter a system sleep state via the legacy FADT PM registers

 *              THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED

 *

 Clear wake status */

 Disable all GPEs */

 Enable all wakeup GPEs */

 Get current value of PM1A control */

 Clear the SLP_EN and SLP_TYP fields */

 Insert the SLP_TYP bits */

	/*

	 * We split the writes of SLP_TYP and SLP_EN to workaround

	 * poorly implemented hardware.

 Write #1: write the SLP_TYP data to the PM1 Control registers */

 Insert the sleep enable (SLP_EN) bit */

 Flush caches, as per ACPI specification */

 Write #2: Write both SLP_TYP + SLP_EN */

		/*

		 * We wanted to sleep > S3, but it didn't happen (by virtue of the

		 * fact that we are still executing!)

		 *

		 * Wait ten seconds, then try again. This is to get S4/S5 to work on

		 * all machines.

		 *

		 * We wait so long to allow chipsets that poll this reg very slowly

		 * to still read the right value. Ideally, this block would go

		 * away entirely.

 Wait for transition back to Working State */

/*******************************************************************************

 *

 * FUNCTION:    acpi_hw_legacy_wake_prep

 *

 * PARAMETERS:  sleep_state         - Which sleep state we just exited

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Perform the first state of OS-independent ACPI cleanup after a

 *              sleep.

 *              Called with interrupts ENABLED.

 *

	/*

	 * Set SLP_TYPE and SLP_EN to state S0.

	 * This is unclear from the ACPI Spec, but it is required

	 * by some machines.

 Get current value of PM1A control */

 Clear the SLP_EN and SLP_TYP fields */

 Insert the SLP_TYP bits */

 Write the control registers and ignore any errors */

/*******************************************************************************

 *

 * FUNCTION:    acpi_hw_legacy_wake

 *

 * PARAMETERS:  sleep_state         - Which sleep state we just exited

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Perform OS-independent ACPI cleanup after a sleep

 *              Called with interrupts ENABLED.

 *

 Ensure enter_sleep_state_prep -> enter_sleep_state ordering */

	/*

	 * GPEs must be enabled before _WAK is called as GPEs

	 * might get fired there

	 *

	 * Restore the GPEs:

	 * 1) Disable all GPEs

	 * 2) Enable all runtime GPEs

	/*

	 * Now we can execute _WAK, etc. Some machines require that the GPEs

	 * are enabled before the wake methods are executed.

	/*

	 * Some BIOS code assumes that WAK_STS will be cleared on resume

	 * and use it to determine whether the system is rebooting or

	 * resuming. Clear WAK_STS for compatibility.

 Enable power button */

 Enable sleep button */

 !ACPI_REDUCED_HARDWARE */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Name: hwxfsleep.c - ACPI Hardware Sleep/Wake External Interfaces

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*

 * These functions are removed for the ACPI_REDUCED_HARDWARE case:

 *      acpi_set_firmware_waking_vector

 *      acpi_enter_sleep_state_s4bios

/*******************************************************************************

 *

 * FUNCTION:    acpi_hw_set_firmware_waking_vector

 *

 * PARAMETERS:  facs                - Pointer to FACS table

 *              physical_address    - 32-bit physical address of ACPI real mode

 *                                    entry point

 *              physical_address64  - 64-bit physical address of ACPI protected

 *                                    mode entry point

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Sets the firmware_waking_vector fields of the FACS

 *

	/*

	 * According to the ACPI specification 2.0c and later, the 64-bit

	 * waking vector should be cleared and the 32-bit waking vector should

	 * be used, unless we want the wake-up code to be called by the BIOS in

	 * Protected Mode.  Some systems (for example HP dv5-1004nr) are known

	 * to fail to resume if the 64-bit vector is used.

 Set the 32-bit vector */

 Set the 64-bit vector */

 Clear the 64-bit vector if it exists */

/*******************************************************************************

 *

 * FUNCTION:    acpi_set_firmware_waking_vector

 *

 * PARAMETERS:  physical_address    - 32-bit physical address of ACPI real mode

 *                                    entry point

 *              physical_address64  - 64-bit physical address of ACPI protected

 *                                    mode entry point

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Sets the firmware_waking_vector fields of the FACS

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_enter_sleep_state_s4bios

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Perform a S4 bios request.

 *              THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED

 *

 Clear the wake status bit (PM1) */

	/*

	 * 1) Disable all GPEs

	 * 2) Enable all wakeup GPEs

 !ACPI_REDUCED_HARDWARE */

/*******************************************************************************

 *

 * FUNCTION:    acpi_enter_sleep_state_prep

 *

 * PARAMETERS:  sleep_state         - Which sleep state to enter

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Prepare to enter a system sleep state.

 *              This function must execute with interrupts enabled.

 *              We break sleeping into 2 stages so that OSPM can handle

 *              various OS-specific tasks between the two steps.

 *

 Execute the _PTS method (Prepare To Sleep) */

 Setup the argument to the _SST method (System STatus) */

 Default is off */

	/*

	 * Set the system indicators to show the desired sleep state.

	 * _SST is an optional method (return no error if not found)

/*******************************************************************************

 *

 * FUNCTION:    acpi_enter_sleep_state

 *

 * PARAMETERS:  sleep_state         - Which sleep state to enter

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Enter a system sleep state

 *              THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_leave_sleep_state_prep

 *

 * PARAMETERS:  sleep_state         - Which sleep state we are exiting

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Perform the first state of OS-independent ACPI cleanup after a

 *              sleep. Called with interrupts DISABLED.

 *              We break wake/resume into 2 stages so that OSPM can handle

 *              various OS-specific tasks between the two steps.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_leave_sleep_state

 *

 * PARAMETERS:  sleep_state         - Which sleep state we are exiting

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Perform OS-independent ACPI cleanup after a sleep

 *              Called with interrupts ENABLED.

 *

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: utpredef - support functions for predefined names

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*

 * Names for the types that can be returned by the predefined objects.

 * Used for warning messages. Must be in the same order as the ACPI_RTYPEs

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_next_predefined_method

 *

 * PARAMETERS:  this_name           - Entry in the predefined method/name table

 *

 * RETURN:      Pointer to next entry in predefined table.

 *

 * DESCRIPTION: Get the next entry in the predefine method table. Handles the

 *              cases where a package info entry follows a method name that

 *              returns a package.

 *

	/*

	 * Skip next entry in the table if this name returns a Package

	 * (next entry contains the package info)

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_match_predefined_method

 *

 * PARAMETERS:  name                - Name to find

 *

 * RETURN:      Pointer to entry in predefined table. NULL indicates not found.

 *

 * DESCRIPTION: Check an object name against the predefined object list.

 *

 Quick check for a predefined name, first character must be underscore */

 Search info table for a predefined method/object name */

 Not found */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_expected_return_types

 *

 * PARAMETERS:  buffer              - Where the formatted string is returned

 *              expected_Btypes     - Bitfield of expected data types

 *

 * RETURN:      Formatted string in Buffer.

 *

 * DESCRIPTION: Format the expected object types into a printable string.

 *

 If one of the expected types, concatenate the name of this type */

 Use name separator from now on */

 Next Rtype */

/*******************************************************************************

 *

 * The remaining functions are used by iASL and acpi_help only

 *

 Local prototypes */

 Types that can be returned externally by a predefined name */

 Indexed by ACPI_TYPE_* */

 Bit widths for resource descriptor predefined names */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_match_resource_name

 *

 * PARAMETERS:  name                - Name to find

 *

 * RETURN:      Pointer to entry in the resource table. NULL indicates not

 *              found.

 *

 * DESCRIPTION: Check an object name against the predefined resource

 *              descriptor object list.

 *

	/*

	 * Quick check for a predefined name, first character must

	 * be underscore

 Search info table for a predefined method/object name */

 Not found */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_display_predefined_method

 *

 * PARAMETERS:  buffer              - Scratch buffer for this function

 *              this_name           - Entry in the predefined method/name table

 *              multi_line          - TRUE if output should be on >1 line

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display information about a predefined method. Number and

 *              type of the input arguments, and expected type(s) for the

 *              return value, if any.

 *

	/*

	 * Get the argument count and the string buffer

	 * containing all argument types

 Display the types for any arguments */

 Get the return value type(s) allowed */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_argument_types

 *

 * PARAMETERS:  buffer              - Where to return the formatted types

 *              argument_types      - Types field for this method

 *

 * RETURN:      count - the number of arguments required for this method

 *

 * DESCRIPTION: Format the required data types for this method (Integer,

 *              String, Buffer, or Package) and return the required argument

 *              count.

 *

 First field in the types list is the count of args to follow */

 Get each argument from the list, convert to ascii, store to buffer */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_resource_bit_width

 *

 * PARAMETERS:  buffer              - Where the formatted string is returned

 *              types               - Bitfield of expected data types

 *

 * RETURN:      Count of return types. Formatted string in Buffer.

 *

 * DESCRIPTION: Format the resource bit widths into a printable string.

 *

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: evsci - System Control Interrupt configuration and

 *                      legacy to ACPI mode state transition functions

 *

 Entire module */

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_sci_dispatch

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status code indicates whether interrupt was handled.

 *

 * DESCRIPTION: Dispatch the SCI to all host-installed SCI handlers.

 *

 Are there any host-installed SCI handlers? */

 Invoke all host-installed SCI handlers */

 Invoke the installed handler (at interrupt level) */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_sci_xrupt_handler

 *

 * PARAMETERS:  context   - Calling Context

 *

 * RETURN:      Status code indicates whether interrupt was handled.

 *

 * DESCRIPTION: Interrupt handler that will figure out what function or

 *              control method to call to deal with a SCI.

 *

	/*

	 * We are guaranteed by the ACPICA initialization/shutdown code that

	 * if this interrupt handler is installed, ACPI is enabled.

	/*

	 * Fixed Events:

	 * Check for and dispatch any Fixed Events that have occurred

	/*

	 * General Purpose Events:

	 * Check for and dispatch any GPEs that have occurred

 Invoke all host-installed SCI handlers */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_gpe_xrupt_handler

 *

 * PARAMETERS:  context   - Calling Context

 *

 * RETURN:      Status code indicates whether interrupt was handled.

 *

 * DESCRIPTION: Handler for GPE Block Device interrupts

 *

	/*

	 * We are guaranteed by the ACPICA initialization/shutdown code that

	 * if this interrupt handler is installed, ACPI is enabled.

 GPEs: Check for and dispatch any GPEs that have occurred */

/******************************************************************************

 *

 * FUNCTION:    acpi_ev_install_sci_handler

 *

 * PARAMETERS:  none

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Installs SCI handler.

 *

/******************************************************************************

 *

 * FUNCTION:    acpi_ev_remove_all_sci_handlers

 *

 * PARAMETERS:  none

 *

 * RETURN:      AE_OK if handler uninstalled, AE_ERROR if handler was not

 *              installed to begin with

 *

 * DESCRIPTION: Remove the SCI interrupt handler. No further SCIs will be

 *              taken. Remove all host-installed SCI handlers.

 *

 * Note:  It doesn't seem important to disable all events or set the event

 *        enable registers to their original values. The OS should disable

 *        the SCI interrupt level when the handler is removed, so no more

 *        events will come in.

 *

 Just let the OS remove the handler and disable the level */

 Free all host-installed SCI handlers */

 !ACPI_REDUCED_HARDWARE */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: utmisc - common utility procedures

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_is_pci_root_bridge

 *

 * PARAMETERS:  id              - The HID/CID in string format

 *

 * RETURN:      TRUE if the Id is a match for a PCI/PCI-Express Root Bridge

 *

 * DESCRIPTION: Determine if the input ID is a PCI Root Bridge ID.

 *

	/*

	 * Check if this is a PCI root bridge.

	 * ACPI 3.0+: check for a PCI Express root also.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_is_aml_table

 *

 * PARAMETERS:  table               - An ACPI table

 *

 * RETURN:      TRUE if table contains executable AML; FALSE otherwise

 *

 * DESCRIPTION: Check ACPI Signature for a table that contains AML code.

 *              Currently, these are DSDT,SSDT,PSDT. All other table types are

 *              data tables that do not contain AML code.

 *

 These are the only tables that contain executable AML */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_dword_byte_swap

 *

 * PARAMETERS:  value           - Value to be converted

 *

 * RETURN:      u32 integer with bytes swapped

 *

 * DESCRIPTION: Convert a 32-bit value to big-endian (swap the bytes)

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_set_integer_width

 *

 * PARAMETERS:  Revision            From DSDT header

 *

 * RETURN:      None

 *

 * DESCRIPTION: Set the global integer bit width based upon the revision

 *              of the DSDT. For Revision 1 and 0, Integers are 32 bits.

 *              For Revision 2 and above, Integers are 64 bits. Yes, this

 *              makes a difference.

 *

 32-bit case */

 64-bit case (ACPI 2.0+) */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_create_update_state_and_push

 *

 * PARAMETERS:  object          - Object to be added to the new state

 *              action          - Increment/Decrement

 *              state_list      - List the state will be added to

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create a new state and push it

 *

 Ignore null objects; these are expected */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_walk_package_tree

 *

 * PARAMETERS:  source_object       - The package to walk

 *              target_object       - Target object (if package is being copied)

 *              walk_callback       - Called once for each package element

 *              context             - Passed to the callback function

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Walk through a package, including subpackages

 *

 Get one element of the package */

		/*

		 * Check for:

		 * 1) An uninitialized package element. It is completely

		 *    legal to declare a package and leave it uninitialized

		 * 2) Not an internal object - can be a namespace node instead

		 * 3) Any type other than a package. Packages are handled in else

		 *    case below.

				/*

				 * We've handled all of the objects at this level,  This means

				 * that we have just completed a package. That package may

				 * have contained one or more packages itself.

				 *

				 * Delete this state and pop the previous state (package).

 Finished when there are no more states */

					/*

					 * We have handled all of the objects in the top level

					 * package just add the length of the package objects

					 * and exit

				/*

				 * Go back up a level and move the index past the just

				 * completed package object.

 This is a subobject of type package */

			/*

			 * Push the current state and create a new one

			 * The callback above returned a new target package object.

 Free any stacked Update State objects */

 We should never get here */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_display_init_pathname

 *

 * PARAMETERS:  type                - Object type of the node

 *              obj_handle          - Handle whose pathname will be displayed

 *              path                - Additional path string to be appended.

 *                                      (NULL if no extra path)

 *

 * RETURN:      acpi_status

 *

 * DESCRIPTION: Display full pathname of an object, DEBUG ONLY

 *

 Only print the path if the appropriate debug level is enabled */

 Get the full pathname to the node */

 Print what we're doing */

 Print the object type and pathname */

 Extra path is used to append names like _STA, _INI, etc. */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exmisc - ACPI AML (p-code) execution - specific opcodes

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_get_object_reference

 *

 * PARAMETERS:  obj_desc            - Create a reference to this object

 *              return_desc         - Where to store the reference

 *              walk_state          - Current state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Obtain and return a "reference" to the target object

 *              Common code for the ref_of_op and the cond_ref_of_op.

 *

		/*

		 * Must be a reference to a Local or Arg

 The referenced object is the pseudo-node for the local/arg */

		/*

		 * A named reference that has already been resolved to a Node

 Create a new reference object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_do_math_op

 *

 * PARAMETERS:  opcode              - AML opcode

 *              integer0            - Integer operand #0

 *              integer1            - Integer operand #1

 *

 * RETURN:      Integer result of the operation

 *

 * DESCRIPTION: Execute a math AML opcode. The purpose of having all of the

 *              math functions here is to prevent a lot of pointer dereferencing

 *              to obtain the operands.

 *

 Add (Integer0, Integer1, Result) */

 And (Integer0, Integer1, Result) */

 NAnd (Integer0, Integer1, Result) */

 Or (Integer0, Integer1, Result) */

 NOr (Integer0, Integer1, Result) */

 XOr (Integer0, Integer1, Result) */

 Multiply (Integer0, Integer1, Result) */

 shift_left (Operand, shift_count, Result) */

		/*

		 * We need to check if the shiftcount is larger than the integer bit

		 * width since the behavior of this is not well-defined in the C language.

 shift_right (Operand, shift_count, Result) */

		/*

		 * We need to check if the shiftcount is larger than the integer bit

		 * width since the behavior of this is not well-defined in the C language.

 Subtract (Integer0, Integer1, Result) */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_do_logical_numeric_op

 *

 * PARAMETERS:  opcode              - AML opcode

 *              integer0            - Integer operand #0

 *              integer1            - Integer operand #1

 *              logical_result      - TRUE/FALSE result of the operation

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute a logical "Numeric" AML opcode. For these Numeric

 *              operators (LAnd and LOr), both operands must be integers.

 *

 *              Note: cleanest machine code seems to be produced by the code

 *              below, rather than using statements of the form:

 *                  Result = (Integer0 && Integer1);

 *

 LAnd (Integer0, Integer1) */

 LOr (Integer0, Integer1) */

 Return the logical result and status */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_do_logical_op

 *

 * PARAMETERS:  opcode              - AML opcode

 *              operand0            - operand #0

 *              operand1            - operand #1

 *              logical_result      - TRUE/FALSE result of the operation

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute a logical AML opcode. The purpose of having all of the

 *              functions here is to prevent a lot of pointer dereferencing

 *              to obtain the operands and to simplify the generation of the

 *              logical value. For the Numeric operators (LAnd and LOr), both

 *              operands must be integers. For the other logical operators,

 *              operands can be any combination of Integer/String/Buffer. The

 *              first operand determines the type to which the second operand

 *              will be converted.

 *

 *              Note: cleanest machine code seems to be produced by the code

 *              below, rather than using statements of the form:

 *                  Result = (Operand0 == Operand1);

 *

	/*

	 * Convert the second operand if necessary. The first operand

	 * determines the type of the second operand, (See the Data Types

	 * section of the ACPI 3.0+ specification.)  Both object types are

	 * guaranteed to be either Integer/String/Buffer by the operand

	 * resolution mechanism.

	/*

	 * Two cases: 1) Both Integers, 2) Both Strings or Buffers

		/*

		 * 1) Both operands are of type integer

		 *    Note: local_operand1 may have changed above

 LEqual (Operand0, Operand1) */

 LGreater (Operand0, Operand1) */

 LLess (Operand0, Operand1) */

		/*

		 * 2) Both operands are Strings or both are Buffers

		 *    Note: Code below takes advantage of common Buffer/String

		 *          object fields. local_operand1 may have changed above. Use

		 *          memcmp to handle nulls in buffers.

 Lexicographic compare: compare the data bytes */

 LEqual (Operand0, Operand1) */

 Length and all bytes must be equal */

 Length and all bytes match ==> TRUE */

 LGreater (Operand0, Operand1) */

 TRUE */

 FALSE */

 Bytes match (to shortest length), compare lengths */

 LLess (Operand0, Operand1) */

 FALSE */

 TRUE */

 Bytes match (to shortest length), compare lengths */

 New object was created if implicit conversion performed - delete */

 Return the logical result and status */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: tbprint - Table output utilities

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_fix_string

 *

 * PARAMETERS:  string              - String to be repaired

 *              length              - Maximum length

 *

 * RETURN:      None

 *

 * DESCRIPTION: Replace every non-printable or non-ascii byte in the string

 *              with a question mark '?'.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_cleanup_table_header

 *

 * PARAMETERS:  out_header          - Where the cleaned header is returned

 *              header              - Input ACPI table header

 *

 * RETURN:      Returns the cleaned header in out_header

 *

 * DESCRIPTION: Copy the table header and ensure that all "string" fields in

 *              the header consist of printable characters.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_print_table_header

 *

 * PARAMETERS:  address             - Table physical address

 *              header              - Table header

 *

 * RETURN:      None

 *

 * DESCRIPTION: Print an ACPI table header. Special cases for FACS and RSDP.

 *

 FACS only has signature and length fields */

 RSDP has no common fields */

 Standard ACPI table with full common header */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_validate_checksum

 *

 * PARAMETERS:  table               - ACPI table to verify

 *              length              - Length of entire table

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Verifies that the table checksums to zero. Optionally returns

 *              exception on bad checksum.

 *

	/*

	 * FACS/S3PT:

	 * They are the odd tables, have no standard ACPI header and no checksum

 Compute the checksum on the table */

 Checksum ok? (should be zero) */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_checksum

 *

 * PARAMETERS:  buffer          - Pointer to memory region to be checked

 *              length          - Length of this memory region

 *

 * RETURN:      Checksum (u8)

 *

 * DESCRIPTION: Calculates circular checksum of memory region.

 *

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: tbfadt   - FADT table utilities

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

 Table for conversion of FADT to common internal format and FADT validation */

 Enable + Status register */

 Enable + Status register */

 ACPI 5.0A: Timer is optional */

 Table used to split Event Blocks into separate status/enable registers */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_init_generic_address

 *

 * PARAMETERS:  generic_address     - GAS struct to be initialized

 *              space_id            - ACPI Space ID for this register

 *              byte_width          - Width of this register

 *              address             - Address of the register

 *              register_name       - ASCII name of the ACPI register

 *

 * RETURN:      None

 *

 * DESCRIPTION: Initialize a Generic Address Structure (GAS)

 *              See the ACPI specification for a full description and

 *              definition of this structure.

 *

	/*

	 * Bit width field in the GAS is only one byte long, 255 max.

	 * Check for bit_width overflow in GAS.

 (31*8)=248, (32*8)=256 */

		/*

		 * No error for GPE blocks, because we do not use the bit_width

		 * for GPEs, the legacy length (byte_width) is used instead to

		 * allow for a large number of GPEs.

	/*

	 * The 64-bit Address field is non-aligned in the byte packed

	 * GAS struct.

 All other fields are byte-wide */

 Access width ANY */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_select_address

 *

 * PARAMETERS:  register_name       - ASCII name of the ACPI register

 *              address32           - 32-bit address of the register

 *              address64           - 64-bit address of the register

 *

 * RETURN:      The resolved 64-bit address

 *

 * DESCRIPTION: Select between 32-bit and 64-bit versions of addresses within

 *              the FADT. Used for the FACS and DSDT addresses.

 *

 * NOTES:

 *

 * Check for FACS and DSDT address mismatches. An address mismatch between

 * the 32-bit and 64-bit address fields (FIRMWARE_CTRL/X_FIRMWARE_CTRL and

 * DSDT/X_DSDT) could be a corrupted address field or it might indicate

 * the presence of two FACS or two DSDT tables.

 *

 * November 2013:

 * By default, as per the ACPICA specification, a valid 64-bit address is

 * used regardless of the value of the 32-bit address. However, this

 * behavior can be overridden via the acpi_gbl_use32_bit_fadt_addresses flag.

 *

 64-bit address is zero, use 32-bit address */

 Address mismatch between 32-bit and 64-bit versions */

 32-bit address override */

 Default is to use the 64-bit address */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_parse_fadt

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Initialize the FADT, DSDT and FACS tables

 *              (FADT contains the addresses of the DSDT and FACS)

 *

	/*

	 * The FADT has multiple versions with different lengths,

	 * and it contains pointers to both the DSDT and FACS tables.

	 *

	 * Get a local copy of the FADT and convert it to a common format

	 * Map entire FADT, assumed to be smaller than one page.

	/*

	 * Validate the FADT checksum before we copy the table. Ignore

	 * checksum error as we want to try to get the DSDT and FACS.

 Create a local copy of the FADT in common ACPI 2.0+ format */

 All done with the real FADT, unmap it */

 Obtain the DSDT and FACS tables via their addresses within the FADT */

 If Hardware Reduced flag is set, there is no FACS */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_create_local_fadt

 *

 * PARAMETERS:  table               - Pointer to BIOS FADT

 *              length              - Length of the table

 *

 * RETURN:      None

 *

 * DESCRIPTION: Get a local copy of the FADT and convert it to a common format.

 *              Performs validation on some important FADT fields.

 *

 * NOTE:        We create a local copy of the FADT regardless of the version.

 *

	/*

	 * Check if the FADT is larger than the largest table that we expect

	 * (typically the current ACPI specification version). If so, truncate

	 * the table, and issue a warning.

 Clear the entire local FADT */

 Copy the original FADT, up to sizeof (struct acpi_table_fadt) */

 Take a copy of the Hardware Reduced flag */

 Convert the local copy of the FADT to the common internal format */

 Initialize the global ACPI register structures */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_convert_fadt

 *

 * PARAMETERS:  none - acpi_gbl_FADT is used.

 *

 * RETURN:      None

 *

 * DESCRIPTION: Converts all versions of the FADT to a common internal format.

 *              Expand 32-bit addresses to 64-bit as necessary. Also validate

 *              important fields within the FADT.

 *

 * NOTE:        acpi_gbl_FADT must be of size (struct acpi_table_fadt), and must

 *              contain a copy of the actual BIOS-provided FADT.

 *

 * Notes on 64-bit register addresses:

 *

 * After this FADT conversion, later ACPICA code will only use the 64-bit "X"

 * fields of the FADT for all ACPI register addresses.

 *

 * The 64-bit X fields are optional extensions to the original 32-bit FADT

 * V1.0 fields. Even if they are present in the FADT, they are optional and

 * are unused if the BIOS sets them to zero. Therefore, we must copy/expand

 * 32-bit V1.0 fields to the 64-bit X fields if the 64-bit X field is originally

 * zero.

 *

 * For ACPI 1.0 FADTs (that contain no 64-bit addresses), all 32-bit address

 * fields are expanded to the corresponding 64-bit X fields in the internal

 * common FADT.

 *

 * For ACPI 2.0+ FADTs, all valid (non-zero) 32-bit address fields are expanded

 * to the corresponding 64-bit X fields, if the 64-bit field is originally

 * zero. Adhering to the ACPI specification, we completely ignore the 32-bit

 * field if the 64-bit field is valid, regardless of whether the host OS is

 * 32-bit or 64-bit.

 *

 * Possible additional checks:

 *  (acpi_gbl_FADT.pm1_event_length >= 4)

 *  (acpi_gbl_FADT.pm1_control_length >= 2)

 *  (acpi_gbl_FADT.pm_timer_length >= 4)

 *  Gpe block lengths must be multiple of 2

 *

	/*

	 * For ACPI 1.0 FADTs (revision 1 or 2), ensure that reserved fields which

	 * should be zero are indeed zero. This will workaround BIOSs that

	 * inadvertently place values in these fields.

	 *

	 * The ACPI 1.0 reserved fields that will be zeroed are the bytes located

	 * at offset 45, 55, 95, and the word located at offset 109, 110.

	 *

	 * Note: The FADT revision value is unreliable. Only the length can be

	 * trusted.

	/*

	 * Now we can update the local FADT length to the length of the

	 * current FADT version as defined by the ACPI specification.

	 * Thus, we will have a common FADT internally.

	/*

	 * Expand the 32-bit DSDT addresses to 64-bit as necessary.

	 * Later ACPICA code will always use the X 64-bit field.

 If Hardware Reduced flag is set, we are all done */

 Examine all of the 64-bit extended address fields (X fields) */

		/*

		 * Get the 32-bit and 64-bit addresses, as well as the register

		 * length and register name.

		/*

		 * Expand the ACPI 1.0 32-bit addresses to the ACPI 2.0 64-bit "X"

		 * generic address structures as necessary. Later code will always use

		 * the 64-bit address structures.

		 *

		 * November 2013:

		 * Now always use the 64-bit address if it is valid (non-zero), in

		 * accordance with the ACPI specification which states that a 64-bit

		 * address supersedes the 32-bit version. This behavior can be

		 * overridden by the acpi_gbl_use32_bit_fadt_addresses flag.

		 *

		 * During 64-bit address construction and verification,

		 * these cases are handled:

		 *

		 * Address32 zero, Address64 [don't care]   - Use Address64

		 *

		 * No override: if acpi_gbl_use32_bit_fadt_addresses is FALSE, and:

		 * Address32 non-zero, Address64 zero       - Copy/use Address32

		 * Address32 non-zero == Address64 non-zero - Use Address64

		 * Address32 non-zero != Address64 non-zero - Warning, use Address64

		 *

		 * Override: if acpi_gbl_use32_bit_fadt_addresses is TRUE, and:

		 * Address32 non-zero, Address64 zero       - Copy/use Address32

		 * Address32 non-zero == Address64 non-zero - Copy/use Address32

		 * Address32 non-zero != Address64 non-zero - Warning, copy/use Address32

		 *

		 * Note: space_id is always I/O for 32-bit legacy address fields

 Address mismatch */

				/*

				 * For each extended field, check for length mismatch

				 * between the legacy length field and the corresponding

				 * 64-bit X length field.

				 * Note: If the legacy length field is > 0xFF bits, ignore

				 * this check. (GPE registers can be larger than the

				 * 64-bit GAS structure can accommodate, 0xFF bits).

			/*

			 * Hardware register access code always uses the 64-bit fields.

			 * So if the 64-bit field is zero or is to be overridden,

			 * initialize it with the 32-bit fields.

			 * Note that when the 32-bit address favor is specified, the

			 * 64-bit fields are always re-initialized so that

			 * access_size/bit_width/bit_offset fields can be correctly

			 * configured to the values to trigger a 32-bit compatible

			 * access mode in the hardware register access code.

			/*

			 * Field is required (Pm1a_event, Pm1a_control).

			 * Both the address and length must be non-zero.

			/*

			 * Field is optional (Pm2_control, GPE0, GPE1) AND has its own

			 * length field. If present, both the address and length must

			 * be valid.

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_setup_fadt_registers

 *

 * PARAMETERS:  None, uses acpi_gbl_FADT.

 *

 * RETURN:      None

 *

 * DESCRIPTION: Initialize global ACPI PM1 register definitions. Optionally,

 *              force FADT register definitions to their default lengths.

 *

	/*

	 * Optionally check all register lengths against the default values and

	 * update them if they are incorrect.

			/*

			 * If a valid register (Address != 0) and the (default_length > 0)

			 * (Not a GPE register), then check the width against the default.

 Incorrect size, set width to the default */

	/*

	 * Get the length of the individual PM1 registers (enable and status).

	 * Each register is defined to be (event block length / 2). Extra divide

	 * by 8 converts bits to bytes.

	/*

	 * Calculate separate GAS structs for the PM1x (A/B) Status and Enable

	 * registers. These addresses do not appear (directly) in the FADT, so it

	 * is useful to pre-calculate them from the PM1 Event Block definitions.

	 *

	 * The PM event blocks are split into two register blocks, first is the

	 * PM Status Register block, followed immediately by the PM Enable

	 * Register block. Each is of length (pm1_event_length/2)

	 *

	 * Note: The PM1A event block is required by the ACPI specification.

	 * However, the PM1B event block is optional and is rarely, if ever,

	 * used.

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: dspkginit - Completion of deferred package initialization

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_build_internal_package_obj

 *

 * PARAMETERS:  walk_state      - Current walk state

 *              op              - Parser object to be translated

 *              element_count   - Number of elements in the package - this is

 *                                the num_elements argument to Package()

 *              obj_desc_ptr    - Where the ACPI internal object is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Translate a parser Op package object to the equivalent

 *              namespace object

 *

 * NOTE: The number of elements in the package will be always be the num_elements

 * count, regardless of the number of elements in the package list. If

 * num_elements is smaller, only that many package list elements are used.

 * if num_elements is larger, the Package object is padded out with

 * objects of type Uninitialized (as per ACPI spec.)

 *

 * Even though the ASL compilers do not allow num_elements to be smaller

 * than the Package list length (for the fixed length package opcode), some

 * BIOS code modifies the AML on the fly to adjust the num_elements, and

 * this code compensates for that. This also provides compatibility with

 * other AML interpreters.

 *

 Check if we are executing module level code */

 Find the parent of a possibly nested package */

	/*

	 * If we are evaluating a Named package object of the form:

	 *      Name (xxxx, Package)

	 * the package object already exists, otherwise it must be created.

 Just in case */

	/*

	 * Allocate the element array (array of pointers to the individual

	 * objects) if necessary. the count is based on the num_elements

	 * parameter. Add an extra pointer slot so that the list is always

	 * null terminated.

 First arg is element count. Second arg begins the initializer list */

	/*

	 * If we are executing module-level code, we will defer the

	 * full resolution of the package elements in order to support

	 * forward references from the elements. This provides

	 * compatibility with other ACPI implementations.

	/*

	 * Initialize the elements of the package, up to the num_elements count.

	 * Package is automatically padded with uninitialized (NULL) elements

	 * if num_elements is greater than the package list length. Likewise,

	 * Package is truncated if num_elements is less than the list length.

				/*

				 * This is the case where an expression has returned a value.

				 * The use of expressions (term_args) within individual

				 * package elements is not supported by the AML interpreter,

				 * even though the ASL grammar supports it. Example:

				 *

				 *      Name (INT1, 0x1234)

				 *

				 *      Name (PKG3, Package () {

				 *          Add (INT1, 0xAAAA0000)

				 *      })

				 *

				 *  1) No known AML interpreter supports this type of construct

				 *  2) This fixes a fault if the construct is encountered

 Cleanup the return object, it is not needed */

				/*

				 * A method reference "looks" to the parser to be a method

				 * invocation, so we special case it here

 This package element is already built, just get it */

				/*

				 * Initialize this package element. This function handles the

				 * resolution of named references within the package.

				 * Forward references from module-level code are deferred

				 * until all ACPI tables are loaded.

 Existing package, get existing reference count */

 Make new element ref count match original ref count */

 TBD: Probably need an acpi_ut_add_references function */

 Check for match between num_elements and actual length of package_list */

		/*

		 * num_elements was exhausted, but there are remaining elements in

		 * the package_list. Truncate the package to num_elements.

		 *

		 * Note: technically, this is an error, from ACPI spec: "It is an

		 * error for NumElements to be less than the number of elements in

		 * the PackageList". However, we just print a message and no

		 * exception is returned. This provides compatibility with other

		 * ACPI implementations. Some firmware implementations will alter

		 * the num_elements on the fly, possibly creating this type of

		 * ill-formed package object.

			/*

			 * We must delete any package elements that were created earlier

			 * and are not going to be used because of the package truncation.

 Find out how many elements there really are */

		/*

		 * Arg list (elements) was exhausted, but we did not reach

		 * num_elements count.

		 *

		 * Note: this is not an error, the package is padded out

		 * with NULLs as per the ACPI specification.

 Module-level packages will be resolved later */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_init_package_element

 *

 * PARAMETERS:  acpi_pkg_callback

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Resolve a named reference element within a package object

 *

	/*

	 * The following code is a bit of a hack to workaround a (current)

	 * limitation of the acpi_pkg_callback interface. We need a pointer

	 * to the location within the element array because a new object

	 * may be created and stored there.

 A direct call was made to this function */

 Call came from acpi_ut_walk_package_tree */

 We are only interested in reference objects/elements */

 Attempt to resolve the (named) reference to a namespace node */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_resolve_package_element

 *

 * PARAMETERS:  element_ptr         - Pointer to a reference object

 *

 * RETURN:      Possible new element is stored to the indirect element_ptr

 *

 * DESCRIPTION: Resolve a package element that is a reference to a named

 *              object.

 *

 Check if reference element is already resolved */

 Element must be a reference object of correct type */

 Prefix node */

			/*

			 * Optionally be silent about the NOT_FOUND case for the referenced

			 * name. Although this is potentially a serious problem,

			 * it can generate a lot of noise/errors on platforms whose

			 * firmware carries around a bunch of unused Package objects.

			 * To disable these errors, set this global to TRUE:

			 *     acpi_gbl_ignore_package_resolution_errors

			 *

			 * If the AML actually tries to use such a package, the unresolved

			 * element(s) will be replaced with NULL elements.

 Referenced name not found, set the element to NULL */

 Could not resolve name, set the element to NULL */

 Named reference not resolved, return a NULL package element */

	/*

	 * Special handling for Alias objects. We need resolved_node to point

	 * to the Alias target. This effectively "resolves" the alias.

 Update the reference object */

	/*

	 * Attempt to resolve the node to a value before we insert it into

	 * the package. If this is a reference to a common data type,

	 * resolve it immediately. According to the ACPI spec, package

	 * elements can only be "data objects" or method references.

	 * Attempt to resolve to an Integer, Buffer, String or Package.

	 * If cannot, return the named reference (for things like Devices,

	 * Methods, etc.) Buffer Fields and Fields will resolve to simple

	 * objects (int/buf/str/pkg).

	 *

	 * NOTE: References to things like Devices, Methods, Mutexes, etc.

	 * will remain as named references. This behavior is not described

	 * in the ACPI spec, but it appears to be an oversight.

		/*

		 * These object types are a result of named references, so we will

		 * leave them as reference objects. In other words, these types

		 * have no intrinsic "value".

 acpi_ex_resolve_node_to_value gave these an extra reference */

		/*

		 * For all other types - the node was resolved to an actual

		 * operand object with a value, return the object. Remove

		 * a reference on the existing object.

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: evxfgpe - External Interfaces for General Purpose Events (GPEs)

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Entire module */

/*******************************************************************************

 *

 * FUNCTION:    acpi_update_all_gpes

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Complete GPE initialization and enable all GPEs that have

 *              associated _Lxx or _Exx methods and are not pointed to by any

 *              device _PRW methods (this indicates that these GPEs are

 *              generally intended for system or device wakeup. Such GPEs

 *              have to be enabled directly when the devices whose _PRW

 *              methods point to them are set up for wakeup signaling.)

 *

 * NOTE: Should be called after any GPEs are added to the system. Primarily,

 * after the system _PRW methods have been run, but also after a GPE Block

 * Device has been added or if any new GPE methods have been added via a

 * dynamic table load.

 *

 Poll GPEs to handle already triggered events */

/*******************************************************************************

 *

 * FUNCTION:    acpi_enable_gpe

 *

 * PARAMETERS:  gpe_device          - Parent GPE Device. NULL for GPE0/GPE1

 *              gpe_number          - GPE level within the GPE block

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Add a reference to a GPE. On the first reference, the GPE is

 *              hardware-enabled.

 *

	/*

	 * Ensure that we have a valid GPE number and that there is some way

	 * of handling the GPE (handler or a GPE method). In other words, we

	 * won't allow a valid GPE to be enabled if there is no way to handle it.

 Poll edge-triggered GPEs to handle existing events */

/*******************************************************************************

 *

 * FUNCTION:    acpi_disable_gpe

 *

 * PARAMETERS:  gpe_device      - Parent GPE Device. NULL for GPE0/GPE1

 *              gpe_number      - GPE level within the GPE block

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Remove a reference to a GPE. When the last reference is

 *              removed, only then is the GPE disabled (for runtime GPEs), or

 *              the GPE mask bit disabled (for wake GPEs)

 *

 Ensure that we have a valid GPE number */

/*******************************************************************************

 *

 * FUNCTION:    acpi_set_gpe

 *

 * PARAMETERS:  gpe_device          - Parent GPE Device. NULL for GPE0/GPE1

 *              gpe_number          - GPE level within the GPE block

 *              action              - ACPI_GPE_ENABLE or ACPI_GPE_DISABLE

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Enable or disable an individual GPE. This function bypasses

 *              the reference count mechanism used in the acpi_enable_gpe(),

 *              acpi_disable_gpe() interfaces.

 *              This API is typically used by the GPE raw handler mode driver

 *              to switch between the polling mode and the interrupt mode after

 *              the driver has enabled the GPE.

 *              The APIs should be invoked in this order:

 *               acpi_enable_gpe()            <- Ensure the reference count > 0

 *               acpi_set_gpe(ACPI_GPE_DISABLE) <- Enter polling mode

 *               acpi_set_gpe(ACPI_GPE_ENABLE) <- Leave polling mode

 *               acpi_disable_gpe()           <- Decrease the reference count

 *

 * Note: If a GPE is shared by 2 silicon components, then both the drivers

 *       should support GPE polling mode or disabling the GPE for long period

 *       for one driver may break the other. So use it with care since all

 *       firmware _Lxx/_Exx handlers currently rely on the GPE interrupt mode.

 *

 Ensure that we have a valid GPE number */

 Perform the action */

/*******************************************************************************

 *

 * FUNCTION:    acpi_mask_gpe

 *

 * PARAMETERS:  gpe_device          - Parent GPE Device. NULL for GPE0/GPE1

 *              gpe_number          - GPE level within the GPE block

 *              is_masked           - Whether the GPE is masked or not

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Unconditionally mask/unmask the an individual GPE, ex., to

 *              prevent a GPE flooding.

 *

 Ensure that we have a valid GPE number */

/*******************************************************************************

 *

 * FUNCTION:    acpi_mark_gpe_for_wake

 *

 * PARAMETERS:  gpe_device          - Parent GPE Device. NULL for GPE0/GPE1

 *              gpe_number          - GPE level within the GPE block

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Mark a GPE as having the ability to wake the system. Simply

 *              sets the ACPI_GPE_CAN_WAKE flag.

 *

 * Some potential callers of acpi_setup_gpe_for_wake may know in advance that

 * there won't be any notify handlers installed for device wake notifications

 * from the given GPE (one example is a button GPE in Linux). For these cases,

 * acpi_mark_gpe_for_wake should be used instead of acpi_setup_gpe_for_wake.

 * This will set the ACPI_GPE_CAN_WAKE flag for the GPE without trying to

 * setup implicit wake notification for it (since there's no handler method).

 *

 Ensure that we have a valid GPE number */

 Mark the GPE as a possible wake event */

/*******************************************************************************

 *

 * FUNCTION:    acpi_setup_gpe_for_wake

 *

 * PARAMETERS:  wake_device         - Device associated with the GPE (via _PRW)

 *              gpe_device          - Parent GPE Device. NULL for GPE0/GPE1

 *              gpe_number          - GPE level within the GPE block

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Mark a GPE as having the ability to wake the system. This

 *              interface is intended to be used as the host executes the

 *              _PRW methods (Power Resources for Wake) in the system tables.

 *              Each _PRW appears under a Device Object (The wake_device), and

 *              contains the info for the wake GPE associated with the

 *              wake_device.

 *

 Parameter Validation */

		/*

		 * By forcing wake_device to be valid, we automatically enable the

		 * implicit notify feature on all hosts.

 Handle root object case */

 Validate wake_device is of type Device */

	/*

	 * Allocate a new notify object up front, in case it is needed.

	 * Memory allocation while holding a spinlock is a big no-no

	 * on some hosts.

 Ensure that we have a valid GPE number */

	/*

	 * If there is no method or handler for this GPE, then the

	 * wake_device will be notified whenever this GPE fires. This is

	 * known as an "implicit notify". Note: The GPE is assumed to be

	 * level-triggered (for windows compatibility).

		/*

		 * This is the first device for implicit notify on this GPE.

		 * Just set the flags here, and enter the NOTIFY block below.

		/*

		 * A reference to this GPE has been added during the GPE block

		 * initialization, so drop it now to prevent the GPE from being

		 * permanently enabled and clear its ACPI_GPE_AUTO_ENABLED flag.

	/*

	 * If we already have an implicit notify on this GPE, add

	 * this device to the notify list.

 Ensure that the device is not already in the list */

 Add this device to the notify list for this GPE */

 Mark the GPE as a possible wake event */

 Delete the notify object if it was not used above */

/*******************************************************************************

 *

 * FUNCTION:    acpi_set_gpe_wake_mask

 *

 * PARAMETERS:  gpe_device      - Parent GPE Device. NULL for GPE0/GPE1

 *              gpe_number      - GPE level within the GPE block

 *              action              - Enable or Disable

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Set or clear the GPE's wakeup enable mask bit. The GPE must

 *              already be marked as a WAKE GPE.

 *

	/*

	 * Ensure that we have a valid GPE number and that this GPE is in

	 * fact a wake GPE

 Perform the action */

/*******************************************************************************

 *

 * FUNCTION:    acpi_clear_gpe

 *

 * PARAMETERS:  gpe_device      - Parent GPE Device. NULL for GPE0/GPE1

 *              gpe_number      - GPE level within the GPE block

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Clear an ACPI event (general purpose)

 *

 Ensure that we have a valid GPE number */

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_gpe_status

 *

 * PARAMETERS:  gpe_device          - Parent GPE Device. NULL for GPE0/GPE1

 *              gpe_number          - GPE level within the GPE block

 *              event_status        - Where the current status of the event

 *                                    will be returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Get the current status of a GPE (signalled/not_signalled)

 *

 Ensure that we have a valid GPE number */

 Obtain status on the requested GPE number */

/*******************************************************************************

 *

 * FUNCTION:    acpi_gispatch_gpe

 *

 * PARAMETERS:  gpe_device          - Parent GPE Device. NULL for GPE0/GPE1

 *              gpe_number          - GPE level within the GPE block

 *

 * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED

 *

 * DESCRIPTION: Detect and dispatch a General Purpose Event to either a function

 *              (e.g. EC) or method (e.g. _Lxx/_Exx) handler.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_finish_gpe

 *

 * PARAMETERS:  gpe_device          - Namespace node for the GPE Block

 *                                    (NULL for FADT defined GPEs)

 *              gpe_number          - GPE level within the GPE block

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Clear and conditionally re-enable a GPE. This completes the GPE

 *              processing. Intended for use by asynchronous host-installed

 *              GPE handlers. The GPE is only re-enabled if the enable_for_run bit

 *              is set in the GPE info.

 *

 Ensure that we have a valid GPE number */

/******************************************************************************

 *

 * FUNCTION:    acpi_disable_all_gpes

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Disable and clear all GPEs in all GPE blocks

 *

/******************************************************************************

 *

 * FUNCTION:    acpi_enable_all_runtime_gpes

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Enable all "runtime" GPEs, in all GPE blocks

 *

/******************************************************************************

 *

 * FUNCTION:    acpi_enable_all_wakeup_gpes

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Enable all "wakeup" GPEs and disable all of the other GPEs, in

 *              all GPE blocks.

 *

/******************************************************************************

 *

 * FUNCTION:    acpi_any_gpe_status_set

 *

 * PARAMETERS:  gpe_skip_number      - Number of the GPE to skip

 *

 * RETURN:      Whether or not the status bit is set for any GPE

 *

 * DESCRIPTION: Check the status bits of all enabled GPEs, except for the one

 *              represented by the "skip" argument, and return TRUE if any of

 *              them is set or FALSE otherwise.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_install_gpe_block

 *

 * PARAMETERS:  gpe_device          - Handle to the parent GPE Block Device

 *              gpe_block_address   - Address and space_ID

 *              register_count      - Number of GPE register pairs in the block

 *              interrupt_number    - H/W interrupt for the block

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create and Install a block of GPE registers. The GPEs are not

 *              enabled here.

 *

 Validate the parent device */

	/*

	 * For user-installed GPE Block Devices, the gpe_block_base_number

	 * is always zero

 Install block in the device_object attached to the node */

		/*

		 * No object, create a new one (Device nodes do not always have

		 * an attached object)

 Remove local reference to the object */

 Now install the GPE block in the device_object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_remove_gpe_block

 *

 * PARAMETERS:  gpe_device          - Handle to the parent GPE Block Device

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Remove a previously installed block of GPE registers

 *

 Validate the parent device */

 Get the device_object attached to the node */

 Delete the GPE block (but not the device_object) */

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_gpe_device

 *

 * PARAMETERS:  index               - System GPE index (0-current_gpe_count)

 *              gpe_device          - Where the parent GPE Device is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Obtain the GPE device associated with the input index. A NULL

 *              gpe device indicates that the gpe number is contained in one of

 *              the FADT-defined gpe blocks. Otherwise, the GPE block device.

 *

 Setup and walk the GPE list */

 !ACPI_REDUCED_HARDWARE */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: nsprepkg - Validation of package objects for predefined names

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_check_package

 *

 * PARAMETERS:  info                - Method execution information block

 *              return_object_ptr   - Pointer to the object returned from the

 *                                    evaluation of a method or object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Check a returned package object for the correct count and

 *              correct type of all sub-objects.

 *

 The package info for this name is in the next table entry */

	/*

	 * For variable-length Packages, we can safely remove all embedded

	 * and trailing NULL package elements

 Extract package count and elements array */

	/*

	 * Most packages must have at least one element. The only exception

	 * is the variable-length package (ACPI_PTYPE1_VAR).

	/*

	 * Decode the type of the expected package contents

	 *

	 * PTYPE1 packages contain no subpackages

	 * PTYPE2 packages contain subpackages

		/*

		 * The package count is fixed and there are no subpackages

		 *

		 * If package is too small, exit.

		 * If package is larger than expected, issue warning but continue

 Validate all elements of the returned package */

		/*

		 * The package count is variable, there are no subpackages, and all

		 * elements must be of the same type

		/*

		 * The package count is variable, there are no subpackages. There are

		 * a fixed number of required elements, and a variable number of

		 * optional elements.

		 *

		 * Check if package is at least as large as the minimum required

 Variable number of sub-objects */

 These are the required package elements (0, 1, or 2) */

 These are the optional package elements */

 First element is the (Integer) revision */

 Examine the subpackages */

 First element is the (Integer) count of subpackages to follow */

		/*

		 * Count cannot be larger than the parent package length, but allow it

		 * to be smaller. The >= accounts for the Integer above.

 Examine the subpackages */

		/*

		 * These types all return a single Package that consists of a

		 * variable number of subpackages.

		 *

		 * First, ensure that the first element is a subpackage. If not,

		 * the BIOS may have incorrectly returned the object as a single

		 * package instead of a Package of Packages (a common error if

		 * there is only one entry). We may be able to repair this by

		 * wrapping the returned Package with a new outer Package.

 Create the new outer package and populate it */

 Update locals to point to the new package (of 1 element) */

 Examine the subpackages */

		/*

		 * Returns a variable list of packages, each with a variable list

		 * of objects.

 The package must contain pairs of (UUID + type) */

 Validate length of the UUID buffer */

 Should not get here if predefined info table is correct */

 Error exit for the case with an incorrect package count */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_check_package_list

 *

 * PARAMETERS:  info            - Method execution information block

 *              package         - Pointer to package-specific info for method

 *              elements        - Element list of parent package. All elements

 *                                of this list should be of type Package.

 *              count           - Count of subpackages

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Examine a list of subpackages

 *

	/*

	 * Validate each subpackage in the parent Package

	 *

	 * NOTE: assumes list of subpackages contains no NULL elements.

	 * Any NULL elements should have been removed by earlier call

	 * to acpi_ns_remove_null_elements.

 Each sub-object must be of type Package */

 Examine the different types of expected subpackages */

 Each subpackage has a fixed number of elements */

			/*

			 * Each subpackage has a fixed number of elements and an

			 * optional element

			/*

			 * Each subpackage has a fixed or variable number of elements

 Each subpackage has a fixed length */

 Check the type of each subpackage element */

 Each subpackage has a variable but minimum length */

 Check the type of each subpackage element */

			/*

			 * First element is the (Integer) count of elements, including

			 * the count field (the ACPI name is num_elements)

			/*

			 * Make sure package is large enough for the Count and is

			 * is as large as the minimum size

				/*

				 * Either the num_entries element was originally zero or it was

				 * a NULL element and repaired to an Integer of value zero.

				 * In either case, repair it by setting num_entries to be the

				 * actual size of the subpackage.

 Check the type of each subpackage element */

 Should not get here, type was validated by caller */

 The subpackage count was smaller than required */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_custom_package

 *

 * PARAMETERS:  info                - Method execution information block

 *              elements            - Pointer to the package elements array

 *              count               - Element count for the package

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Check a returned package object for the correct count and

 *              correct type of all sub-objects.

 *

 * NOTE: Currently used for the _BIX method only. When needed for two or more

 * methods, probably a detect/dispatch mechanism will be required.

 *

 Get version number, must be Integer */

 Version 1 */

 Version 0 */

 Validate all elements of the returned package */

 Version 1 has a single trailing integer */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_check_package_elements

 *

 * PARAMETERS:  info            - Method execution information block

 *              elements        - Pointer to the package elements array

 *              type1           - Object type for first group

 *              count1          - Count for first group

 *              type2           - Object type for second group

 *              count2          - Count for second group

 *              start_index     - Start of the first group of elements

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Check that all elements of a package are of the correct object

 *              type. Supports up to two groups of different object types.

 *

	/*

	 * Up to two groups of package elements are supported by the data

	 * structure. All elements in each group must be of the same type.

	 * The second group can have a count of zero.

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: utids - support for device Ids - HID, UID, CID, SUB, CLS

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_execute_HID

 *

 * PARAMETERS:  device_node         - Node for the device

 *              return_id           - Where the string HID is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Executes the _HID control method that returns the hardware

 *              ID of the device. The HID is either an 32-bit encoded EISAID

 *              Integer or a String. A string is always returned. An EISAID

 *              is converted to a string.

 *

 *              NOTE: Internal function, no parameter validation

 *

 Get the size of the String to be returned, includes null terminator */

 Allocate a buffer for the HID */

 Area for the string starts after PNP_DEVICE_ID struct */

 Convert EISAID to a string or simply copy existing string */

 On exit, we must delete the return object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_execute_UID

 *

 * PARAMETERS:  device_node         - Node for the device

 *              return_id           - Where the string UID is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Executes the _UID control method that returns the unique

 *              ID of the device. The UID is either a 64-bit Integer (NOT an

 *              EISAID) or a string. Always returns a string. A 64-bit integer

 *              is converted to a decimal string.

 *

 *              NOTE: Internal function, no parameter validation

 *

 Get the size of the String to be returned, includes null terminator */

 Allocate a buffer for the UID */

 Area for the string starts after PNP_DEVICE_ID struct */

 Convert an Integer to string, or just copy an existing string */

 On exit, we must delete the return object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_execute_CID

 *

 * PARAMETERS:  device_node         - Node for the device

 *              return_cid_list     - Where the CID list is returned

 *

 * RETURN:      Status, list of CID strings

 *

 * DESCRIPTION: Executes the _CID control method that returns one or more

 *              compatible hardware IDs for the device.

 *

 *              NOTE: Internal function, no parameter validation

 *

 * A _CID method can return either a single compatible ID or a package of

 * compatible IDs. Each compatible ID can be one of the following:

 * 1) Integer (32 bit compressed EISA ID) or

 * 2) String (PCI ID format, e.g. "PCI\VEN_vvvv&DEV_dddd&SUBSYS_ssssssss")

 *

 * The Integer CIDs are converted to string format by this function.

 *

 Evaluate the _CID method for this device */

	/*

	 * Get the count and size of the returned _CIDs. _CID can return either

	 * a Package of Integers/Strings or a single Integer or String.

	 * Note: This section also validates that all CID elements are of the

	 * correct type (Integer or String).

 Single Integer or String CID */

 String lengths include null terminator */

	/*

	 * Now that we know the length of the CIDs, allocate return buffer:

	 * 1) Size of the base structure +

	 * 2) Size of the CID PNP_DEVICE_ID array +

	 * 3) Size of the actual CID strings

 Area for CID strings starts after the CID PNP_DEVICE_ID array */

 Copy/convert the CIDs to the return buffer */

 Convert the Integer (EISAID) CID to a string */

 ACPI_TYPE_STRING */

 Copy the String CID from the returned object */

 Finish the CID list */

 On exit, we must delete the _CID return object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_execute_CLS

 *

 * PARAMETERS:  device_node         - Node for the device

 *              return_id           - Where the _CLS is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Executes the _CLS control method that returns PCI-defined

 *              class code of the device. The _CLS value is always a package

 *              containing PCI class information as a list of integers.

 *              The returned string has format "BBSSPP", where:

 *                BB = Base-class code

 *                SS = Sub-class code

 *                PP = Programming Interface code

 *

 Get the size of the String to be returned, includes null terminator */

 Allocate a buffer for the CLS */

 Area for the string starts after PNP_DEVICE_ID struct */

 Simply copy existing string */

 On exit, we must delete the return object */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: rscreate - Create resource lists/tables

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_buffer_to_resource

 *

 * PARAMETERS:  aml_buffer          - Pointer to the resource byte stream

 *              aml_buffer_length   - Length of the aml_buffer

 *              resource_ptr        - Where the converted resource is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Convert a raw AML buffer to a resource list

 *

	/*

	 * Note: we allow AE_AML_NO_RESOURCE_END_TAG, since an end tag

	 * is not required here.

 Get the required length for the converted resource */

 Allocate a buffer for the converted resource */

 Perform the AML-to-Resource conversion */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_create_resource_list

 *

 * PARAMETERS:  aml_buffer          - Pointer to the resource byte stream

 *              output_buffer       - Pointer to the user's buffer

 *

 * RETURN:      Status: AE_OK if okay, else a valid acpi_status code

 *              If output_buffer is not large enough, output_buffer_length

 *              indicates how large output_buffer should be, else it

 *              indicates how may u8 elements of output_buffer are valid.

 *

 * DESCRIPTION: Takes the byte stream returned from a _CRS, _PRS control method

 *              execution and parses the stream to create a linked list

 *              of device resources.

 *

 Params already validated, so we don't re-validate here */

	/*

	 * Pass the aml_buffer into a module that can calculate

	 * the buffer size needed for the linked list

 Validate/Allocate/Clear caller buffer */

 Do the conversion */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_create_pci_routing_table

 *

 * PARAMETERS:  package_object          - Pointer to a package containing one

 *                                        of more ACPI_OPERAND_OBJECTs

 *              output_buffer           - Pointer to the user's buffer

 *

 * RETURN:      Status  AE_OK if okay, else a valid acpi_status code.

 *              If the output_buffer is too small, the error will be

 *              AE_BUFFER_OVERFLOW and output_buffer->Length will point

 *              to the size buffer needed.

 *

 * DESCRIPTION: Takes the union acpi_operand_object package and creates a

 *              linked list of PCI interrupt descriptions

 *

 * NOTE: It is the caller's responsibility to ensure that the start of the

 * output buffer is aligned properly (if necessary).

 *

 Params already validated, so we don't re-validate here */

 Get the required buffer length */

 Validate/Allocate/Clear caller buffer */

	/*

	 * Loop through the ACPI_INTERNAL_OBJECTS - Each object should be a

	 * package that in turn contains an u64 Address, a u8 Pin,

	 * a Name, and a u8 source_index.

		/*

		 * Point user_prt past this current structure

		 *

		 * NOTE: On the first iteration, user_prt->Length will

		 * be zero because we cleared the return buffer earlier

		/*

		 * Fill in the Length field with the information we have at this

		 * point. The minus four is to subtract the size of the u8

		 * Source[4] member because it is added below.

 Each subpackage must be of length 4 */

		/*

		 * Dereference the subpackage.

		 * The sub_object_list will now point to an array of the four IRQ

		 * elements: [Address, Pin, Source, source_index]

 1) First subobject: Dereference the PRT.Address */

 2) Second subobject: Dereference the PRT.Pin */

		/*

		 * 3) Third subobject: Dereference the PRT.source_name

		 * The name may be unresolved (slack mode), so allow a null object

 Use *remaining* length of the buffer as max for pathname */

 +1 to include null terminator */

				/*

				 * Add to the Length field the length of the string

				 * (add 1 for terminator)

				/*

				 * If this is a number, then the Source Name is NULL, since

				 * the entire buffer was zeroed out, we can leave this alone.

				 *

				 * Add to the Length field the length of the u32 NULL

 Now align the current length */

 4) Fourth subobject: Dereference the PRT.source_index */

 Point to the next union acpi_operand_object in the top level package */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_create_aml_resources

 *

 * PARAMETERS:  resource_list           - Pointer to the resource list buffer

 *              output_buffer           - Where the AML buffer is returned

 *

 * RETURN:      Status  AE_OK if okay, else a valid acpi_status code.

 *              If the output_buffer is too small, the error will be

 *              AE_BUFFER_OVERFLOW and output_buffer->Length will point

 *              to the size buffer needed.

 *

 * DESCRIPTION: Converts a list of device resources to an AML bytestream

 *              to be used as input for the _SRS control method.

 *

 Params already validated, no need to re-validate here */

 Get the buffer size needed for the AML byte stream */

 Validate/Allocate/Clear caller buffer */

 Do the conversion */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exserial - field_unit support for serial address spaces

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_read_gpio

 *

 * PARAMETERS:  obj_desc            - The named field to read

 *              buffer              - Where the return data is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Read from a named field that references a Generic Serial Bus

 *              field

 *

	/*

	 * For GPIO (general_purpose_io), the Address will be the bit offset

	 * from the previous Connection() operator, making it effectively a

	 * pin number index. The bit_length is the length of the field, which

	 * is thus the number of pins.

 Lock entire transaction if requested */

 Perform the read */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_write_gpio

 *

 * PARAMETERS:  source_desc         - Contains data to write. Expect to be

 *                                    an Integer object.

 *              obj_desc            - The named field

 *              result_desc         - Where the return value is returned, if any

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Write to a named field that references a General Purpose I/O

 *              field.

 *

	/*

	 * For GPIO (general_purpose_io), we will bypass the entire field

	 * mechanism and handoff the bit address and bit width directly to

	 * the handler. The Address will be the bit offset

	 * from the previous Connection() operator, making it effectively a

	 * pin number index. The bit_length is the length of the field, which

	 * is thus the number of pins.

 Lock entire transaction if requested */

 Perform the write */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_read_serial_bus

 *

 * PARAMETERS:  obj_desc            - The named field to read

 *              return_buffer       - Where the return value is returned, if any

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Read from a named field that references a serial bus

 *              (SMBus, IPMI, or GSBus).

 *

	/*

	 * This is an SMBus, GSBus or IPMI read. We must create a buffer to

	 * hold the data and then directly access the region handler.

	 *

	 * Note: SMBus and GSBus protocol value is passed in upper 16-bits

	 * of Function

	 *

	 * Common buffer format:

	 *     Status;    (Byte 0 of the data buffer)

	 *     Length;    (Byte 1 of the data buffer)

	 *     Data[x-1]: (Bytes 2-x of the arbitrary length data buffer)

 Add header length to get the full size of the buffer */

 Create the local transfer buffer that is returned to the caller */

 Lock entire transaction if requested */

 Call the region handler for the write-then-read */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_write_serial_bus

 *

 * PARAMETERS:  source_desc         - Contains data to write

 *              obj_desc            - The named field

 *              return_buffer       - Where the return value is returned, if any

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Write to a named field that references a serial bus

 *              (SMBus, IPMI, GSBus).

 *

	/*

	 * This is an SMBus, GSBus or IPMI write. We will bypass the entire

	 * field mechanism and handoff the buffer directly to the handler.

	 * For these address spaces, the buffer is bidirectional; on a

	 * write, return data is returned in the same buffer.

	 *

	 * Source must be a buffer of sufficient size, these are fixed size:

	 * ACPI_SMBUS_BUFFER_SIZE, or ACPI_IPMI_BUFFER_SIZE.

	 *

	 * Note: SMBus and GSBus protocol type is passed in upper 16-bits

	 * of Function

	 *

	 * Common buffer format:

	 *     Status;    (Byte 0 of the data buffer)

	 *     Length;    (Byte 1 of the data buffer)

	 *     Data[x-1]: (Bytes 2-x of the arbitrary length data buffer)

 Add header length to get the full size of the buffer */

 Create the transfer/bidirectional/return buffer */

 Copy the input buffer data to the transfer buffer */

 Lock entire transaction if requested */

	/*

	 * Perform the write (returns status and perhaps data in the

	 * same buffer)

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: dsobject - Dispatcher object management routines

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_build_internal_object

 *

 * PARAMETERS:  walk_state      - Current walk state

 *              op              - Parser object to be translated

 *              obj_desc_ptr    - Where the ACPI internal object is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Translate a parser Op object to the equivalent namespace object

 *              Simple objects are any objects other than a package object!

 *

		/*

		 * This is a named object reference. If this name was

		 * previously looked up in the namespace, it was stored in

		 * this op. Otherwise, go ahead and look it up now

 Check if we are resolving a named reference within a package */

				/*

				 * We won't resolve package elements here, we will do this

				 * after all ACPI tables are loaded into the namespace. This

				 * behavior supports both forward references to named objects

				 * and external references to objects in other tables.

 Create and init a new internal ACPI object */

	/*

	 * Handling for unresolved package reference elements.

	 * These are elements that are namepaths.

			/*

			 * Name was unresolved above.

			 * Get the prefix node for later lookup

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_build_internal_buffer_obj

 *

 * PARAMETERS:  walk_state      - Current walk state

 *              op              - Parser object to be translated

 *              buffer_length   - Length of the buffer

 *              obj_desc_ptr    - Where the ACPI internal object is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Translate a parser Op package object to the equivalent

 *              namespace object

 *

	/*

	 * If we are evaluating a Named buffer object "Name (xxxx, Buffer)".

	 * The buffer object already exists (from the NS node), otherwise it must

	 * be created.

 Create a new buffer object */

	/*

	 * Second arg is the buffer data (optional) byte_list can be either

	 * individual bytes or a string initializer. In either case, a

	 * byte_list appears in the AML.

 skip first arg */

	/*

	 * The buffer length (number of bytes) will be the larger of:

	 * 1) The specified buffer length and

	 * 2) The length of the initializer byte list

 Allocate the buffer */

 Initialize buffer from the byte_list (if present) */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_create_node

 *

 * PARAMETERS:  walk_state      - Current walk state

 *              node            - NS Node to be initialized

 *              op              - Parser object to be translated

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create the object to be associated with a namespace node

 *

	/*

	 * Because of the execution pass through the non-control-method

	 * parts of the table, we can arrive here twice. Only init

	 * the named object node the first time through

 No arguments, there is nothing to do */

 Build an internal object for the argument(s) */

 Re-type the object according to its argument */

 Attach obj to node */

 Remove local reference to the object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_init_object_from_op

 *

 * PARAMETERS:  walk_state      - Current walk state

 *              op              - Parser op used to init the internal object

 *              opcode          - AML opcode associated with the object

 *              ret_obj_desc    - Namespace object to be initialized

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Initialize a namespace object from a parser Op and its

 *              associated arguments. The namespace object is a more compact

 *              representation of the Op and its arguments.

 *

 Unknown opcode */

 Perform per-object initialization */

		/*

		 * Defer evaluation of Buffer term_arg operand

		/*

		 * Defer evaluation of Package term_arg operand and all

		 * package elements. (01/2017): We defer the element

		 * resolution to allow forward references from the package

		 * in order to provide compatibility with other ACPI

		 * implementations.

			/*

			 * Resolve AML Constants here - AND ONLY HERE!

			 * All constants are integers.

			 * We mark the integer with a flag that indicates that it started

			 * life as a constant -- so that stores to constants will perform

			 * as expected (noop). zero_op is used as a placeholder for optional

			 * target operands.

 Truncate value if we are executing from a 32-bit ACPI table */

 Warn if we found a 64-bit constant in a 32-bit table */

		/*

		 * The string is contained in the ACPI table, don't ever try

		 * to delete it

 Local ID (0-7) is (AML opcode - base AML_FIRST_LOCAL_OP) */

 Arg ID (0-6) is (AML opcode - base AML_FIRST_ARG_OP) */

 Object name or Debug object */

 Node was saved in Op */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: dbinput - user front-end to the AML debugger

 *

 Local prototypes */

/*

 * Top-level debugger commands.

 *

 * This list of commands must match the string table below it

 Second parameter is the required argument count */

/*

 * Help for all debugger commands. First argument is the number of lines

 * of help to output for the command.

 *

 * Note: Some commands are not supported by the kernel-level version of

 * the debugger.

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_match_command_help

 *

 * PARAMETERS:  command             - Command string to match

 *              help                - Help table entry to attempt match

 *

 * RETURN:      TRUE if command matched, FALSE otherwise

 *

 * DESCRIPTION: Attempt to match a command in the help table in order to

 *              print help information for a single command.

 *

 Valid commands in the help table begin with a couple of spaces */

 Match command name (full command or substring) */

 Print the appropriate number of help lines */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_command_info

 *

 * PARAMETERS:  command             - Command string to match

 *              display_all         - Display all matching commands, or just

 *                                    the first one (substring match)

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display help information for a Debugger command.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_help

 *

 * PARAMETERS:  command             - Optional command string to display help.

 *                                    if not specified, all debugger command

 *                                    help strings are displayed

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display help for a single debugger command, or all of them.

 *

 No argument to help, display help for all commands */

 Display help for all commands that match the substring */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_get_next_token

 *

 * PARAMETERS:  string          - Command buffer

 *              next            - Return value, end of next token

 *

 * RETURN:      Pointer to the start of the next token.

 *

 * DESCRIPTION: Command line parsing. Get the next token on the command line

 *

 At end of buffer? */

 Remove any spaces at the beginning, ignore blank lines */

 This is a quoted string, scan until closing quote */

 Find end of string */

 This is the start of a buffer, scan until closing paren */

 Find end of buffer */

 This is the start of a field unit, scan until closing brace */

 Find end of buffer */

 This is the start of a package, scan until closing bracket */

 Find end of package (closing bracket) */

 Handle String package elements */

 Find end of string */

 A nested package declaration */

 Found final package closing bracket */

 Find end of token */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_get_line

 *

 * PARAMETERS:  input_buffer        - Command line buffer

 *

 * RETURN:      Count of arguments to the command

 *

 * DESCRIPTION: Get the next command line from the user. Gets entire line

 *              up to the next newline

 *

 Uppercase the actual command */

 Number of args only */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_match_command

 *

 * PARAMETERS:  user_command            - User command line

 *

 * RETURN:      Index into command array, -1 if not found

 *

 * DESCRIPTION: Search command array for a command match

 *

 Command not recognized */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_command_dispatch

 *

 * PARAMETERS:  input_buffer        - Command line buffer

 *              walk_state          - Current walk

 *              op                  - Current (executing) parse op

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Command dispatcher.

 *

 If acpi_terminate has been called, terminate this thread */

 Find command and add to the history buffer */

	/*

	 * We don't want to add the !! command to the history buffer. It

	 * would cause an infinite loop because it would always be the

	 * previous command.

 Verify that we have the minimum number of params */

 Decode and dispatch the command */

 ! command */

 !! command */

 Hardware simulation commands. */

 !ACPI_REDUCED_HARDWARE */

 File I/O commands. */

 User space commands. */

		/*

		 * TBD: [Restructure] Need some way to re-initialize without

		 * re-creating the semaphores!

  acpi_initialize (NULL); */

 Debug test commands. */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_execute_thread

 *

 * PARAMETERS:  context         - Not used

 *

 * RETURN:      None

 *

 * DESCRIPTION: Debugger execute thread. Waits for a command line, then

 *              simply dispatches it.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_user_commands

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Command line execution for the AML debugger. Commands are

 *              matched and dispatched here.

 *

 TBD: [Restructure] Need a separate command line buffer for step mode */

 Wait the readiness of the command */

 Just call to the command line interpreter */

 Notify the completion of the command */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: dbnames - Debugger commands for the acpi namespace

 *

 Local prototypes */

/*

 * Arguments for the Objects command

 * These object types map directly to the ACPI_TYPES

 Must be null terminated */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_set_scope

 *

 * PARAMETERS:  name                - New scope path

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Set the "current scope" as maintained by this utility.

 *              The scope is used as a prefix to ACPI paths.

 *

 Validate new scope from the root */

 Validate new scope relative to old scope */

 Build the final pathname */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_dump_namespace

 *

 * PARAMETERS:  start_arg       - Node to begin namespace dump

 *              depth_arg       - Maximum tree depth to be dumped

 *

 * RETURN:      None

 *

 * DESCRIPTION: Dump entire namespace or a subtree. Each node is displayed

 *              with type and other information.

 *

 No argument given, just start at the root and dump entire namespace */

 Now we can check for the depth argument */

 Display the subtree */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_dump_namespace_paths

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Dump entire namespace with full object pathnames and object

 *              type information. Alternative to "namespace" command.

 *

 Display the entire namespace */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_dump_namespace_by_owner

 *

 * PARAMETERS:  owner_arg       - Owner ID whose nodes will be displayed

 *              depth_arg       - Maximum tree depth to be dumped

 *

 * RETURN:      None

 *

 * DESCRIPTION: Dump elements of the namespace that are owned by the owner_id.

 *

 Now we can check for the depth argument */

 Display the subtree */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_walk_and_match_name

 *

 * PARAMETERS:  Callback from walk_namespace

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Find a particular name/names within the namespace. Wildcards

 *              are supported -- '?' matches any character.

 *

 Check for a name match */

 Wildcard support */

 No match, just exit */

 Get the full pathname to this object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_find_name_in_namespace

 *

 * PARAMETERS:  name_arg        - The 4-character ACPI name to find.

 *                                wildcards are supported.

 *

 * RETURN:      None

 *

 * DESCRIPTION: Search the namespace for a given name (with wildcards)

 *

 Pad out name with underscores as necessary to create a 4-char name */

 Walk the namespace from the root */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_walk_for_predefined_names

 *

 * PARAMETERS:  Callback from walk_namespace

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Detect and display predefined ACPI names (names that start with

 *              an underscore)

 *

 If method returns a package, the info is in the next table entry */

 Check that the declared argument count matches the ACPI spec */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_check_predefined_names

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Validate all predefined names in the namespace

 *

 Search all nodes in namespace */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_walk_for_object_counts

 *

 * PARAMETERS:  Callback from walk_namespace

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Display short info about objects in the namespace

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_walk_for_fields

 *

 * PARAMETERS:  Callback from walk_namespace

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Display short info about objects in the namespace

 *

 Get and display the full pathname to this object */

	/*

	 * Since this is a field unit, surround the output in braces

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_walk_for_specific_objects

 *

 * PARAMETERS:  Callback from walk_namespace

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Display short info about objects in the namespace

 *

 Get and display the full pathname to this object */

 Dump short info about the object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_objects

 *

 * PARAMETERS:  obj_type_arg        - Type of object to display

 *              display_count_arg   - Max depth to display

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display objects in the namespace of the requested type

 *

 No argument means display summary/count of all object types */

 Walk the namespace from the root */

 Get the object type */

 Walk the namespace from the root */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_fields

 *

 * PARAMETERS:  obj_type_arg        - Type of object to display

 *              display_count_arg   - Max depth to display

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display objects in the namespace of the requested type

 *

 Walk the namespace from the root */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_integrity_walk

 *

 * PARAMETERS:  Callback from walk_namespace

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Examine one NS node for valid values.

 *

 Verify the NS node, and dereference aliases */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_check_integrity

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Check entire namespace for data structure integrity

 *

 Search all nodes in namespace */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_walk_for_references

 *

 * PARAMETERS:  Callback from walk_namespace

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Check if this namespace object refers to the target object

 *              that is passed in as the context value.

 *

 * Note: Currently doesn't check subobjects within the Node's object

 *

 Check for match against the namespace node itself */

 Check for match against the object attached to the node */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_find_references

 *

 * PARAMETERS:  object_arg      - String with hex value of the object

 *

 * RETURN:      None

 *

 * DESCRIPTION: Search namespace for all references to the input object

 *

 Convert string to object pointer */

 Search all nodes in namespace */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_bus_walk

 *

 * PARAMETERS:  Callback from walk_namespace

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Display info about device objects that have a corresponding

 *              _PRT method.

 *

 Exit if there is no _PRT under this device */

 Get the full path to this device object */

 Display the full path */

 _PRT info */

 Dump _ADR, _HID, _UID, _CID */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_get_bus_info

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display info about system buses.

 *

 Search all nodes in namespace */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: dbcmds - Miscellaneous debug commands and output routines

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_convert_to_node

 *

 * PARAMETERS:  in_string           - String to convert

 *

 * RETURN:      Pointer to a NS node

 *

 * DESCRIPTION: Convert a string to a valid NS pointer. Handles numeric or

 *              alphanumeric strings.

 *

 Numeric argument, convert */

 Make sure pointer is valid NS node */

		/*

		 * Alpha argument: The parameter is a name string that must be

		 * resolved to a Namespace object.

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_sleep

 *

 * PARAMETERS:  object_arg          - Desired sleep state (0-5). NULL means

 *                                    invoke all possible sleep states.

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Simulate sleep/wake sequences

 *

 Null input (no arguments) means to invoke all sleep states */

 Convert argument to binary and invoke the sleep state */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_do_one_sleep_state

 *

 * PARAMETERS:  sleep_state         - Desired sleep state (0-5)

 *

 * RETURN:      None

 *

 * DESCRIPTION: Simulate a sleep/wake sequence

 *

 Validate parameter */

 Get the values for the sleep type registers (for display only) */

 Invoke the various sleep/wake interfaces */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_locks

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display information about internal mutexes.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_table_info

 *

 * PARAMETERS:  table_arg           - Name of table to be displayed

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display information about loaded tables. Current

 *              implementation displays all loaded tables.

 *

 Header */

 Walk the entire root table list */

 Index and Table ID */

 Decode the table flags */

 Make sure that the table is mapped */

 Dump the table header */

 If the pointer is null, the table has been unloaded */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_unload_acpi_table

 *

 * PARAMETERS:  object_name         - Namespace pathname for an object that

 *                                    is owned by the table to be unloaded

 *

 * RETURN:      None

 *

 * DESCRIPTION: Unload an ACPI table, via any namespace node that is owned

 *              by the table.

 *

 Translate name to an Named object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_send_notify

 *

 * PARAMETERS:  name                - Name of ACPI object where to send notify

 *              value               - Value of the notify to send.

 *

 * RETURN:      None

 *

 * DESCRIPTION: Send an ACPI notification. The value specified is sent to the

 *              named object as an ACPI notify.

 *

 Translate name to an Named object */

 Dispatch the notify if legal */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_interfaces

 *

 * PARAMETERS:  action_arg          - Null, "install", or "remove"

 *              interface_name_arg  - Name for install/remove options

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display or modify the global _OSI interface list

 *

 If no arguments, just display current interface list */

 If action_arg exists, so must interface_name_arg */

 Uppercase the action for match below */

 install - install an interface */

 remove - remove an interface */

 Invalid action_arg */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_template

 *

 * PARAMETERS:  buffer_arg          - Buffer name or address

 *

 * RETURN:      None

 *

 * DESCRIPTION: Dump a buffer that contains a resource template

 *

 Translate buffer_arg to an Named object */

 We must have a buffer object */

 Attempt to convert the raw buffer to a resource list */

 Now we can dump the resource list */

/*******************************************************************************

 *

 * FUNCTION:    acpi_dm_compare_aml_resources

 *

 * PARAMETERS:  aml1_buffer         - Contains first resource list

 *              aml1_buffer_length  - Length of first resource list

 *              aml2_buffer         - Contains second resource list

 *              aml2_buffer_length  - Length of second resource list

 *

 * RETURN:      None

 *

 * DESCRIPTION: Compare two AML resource lists, descriptor by descriptor (in

 *              order to isolate a miscompare to an individual resource)

 *

 Compare overall buffer sizes (may be different due to size rounding) */

 Walk the descriptor lists, comparing each descriptor */

 Get the lengths of each descriptor */

 Check for descriptor length match */

 Check for descriptor byte match */

 Exit on end_tag descriptor */

 Point to next descriptor in each buffer */

/*******************************************************************************

 *

 * FUNCTION:    acpi_dm_test_resource_conversion

 *

 * PARAMETERS:  node                - Parent device node

 *              name                - resource method name (_CRS)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Compare the original AML with a conversion of the AML to

 *              internal resource list, then back to AML.

 *

 Get the original _CRS AML resource template */

 Get the AML resource template, converted to internal resource structs */

 Convert internal resource list to external AML resource template */

 Compare original AML to the newly created AML resource list */

 Cleanup and exit */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_resource_callback

 *

 * PARAMETERS:  acpi_walk_resource_callback

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Simple callback to exercise acpi_walk_resources and

 *              acpi_walk_resource_buffer.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_device_resources

 *

 * PARAMETERS:  acpi_walk_callback

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Display the _PRT/_CRS/_PRS resources for a device object.

 *

 Get handles to the resource methods for this device */

 Nothing to do */

 Prepare for a return object of arbitrary size */

 _PRT */

 _CRS */

 This code exercises the acpi_walk_resources interface */

 Get the _CRS resource list (test ALLOCATE buffer) */

 This code exercises the acpi_walk_resource_buffer interface */

 Dump the _CRS resource list */

		/*

		 * Perform comparison of original AML to newly created AML. This

		 * tests both the AML->Resource conversion and the Resource->AML

		 * conversion.

 Execute _SRS with the resource list */

 _PRS */

 _AEI */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_resources

 *

 * PARAMETERS:  object_arg          - String object name or object pointer.

 *                                    NULL or "*" means "display resources for

 *                                    all devices"

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display the resource objects associated with a device.

 *

 Asterisk means "display resources for all devices" */

 Convert string to object pointer */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_generate_gpe

 *

 * PARAMETERS:  gpe_arg             - Raw GPE number, ascii string

 *              block_arg           - GPE block number, ascii string

 *                                    0 or 1 for FADT GPE blocks

 *

 * RETURN:      None

 *

 * DESCRIPTION: Simulate firing of a GPE

 *

	/*

	 * If no block arg, or block arg == 0 or 1, use the FADT-defined

	 * GPE blocks.

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_generate_sci

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Simulate an SCI -- just call the SCI dispatch.

 *

 !ACPI_REDUCED_HARDWARE */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_trace

 *

 * PARAMETERS:  enable_arg          - ENABLE/AML to enable tracer

 *                                    DISABLE to disable tracer

 *              method_arg          - Method to trace

 *              once_arg            - Whether trace once

 *

 * RETURN:      None

 *

 * DESCRIPTION: Control method tracing facility

 *

 Inherit current console settings */

 Restrict console output to trace points only */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: utbuffer - Buffer dump routines

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_dump_buffer

 *

 * PARAMETERS:  buffer              - Buffer to dump

 *              count               - Amount to dump, in bytes

 *              display             - BYTE, WORD, DWORD, or QWORD display:

 *                                      DB_BYTE_DISPLAY

 *                                      DB_WORD_DISPLAY

 *                                      DB_DWORD_DISPLAY

 *                                      DB_QWORD_DISPLAY

 *              base_offset         - Beginning buffer offset (display only)

 *

 * RETURN:      None

 *

 * DESCRIPTION: Generic dump buffer in both hex and ascii.

 *

 Nasty little dump buffer routine! */

 Print current offset */

 Print 16 hex chars */

 Dump fill spaces */

 Default is BYTE display */

		/*

		 * Print the ASCII equivalent characters but watch out for the bad

		 * unprintable ones (printable chars are 0x20 through 0x7E)

				/*

				 * Add comment characters so rest of line is ignored when

				 * compiled

 ");

 Done with that line. */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_debug_dump_buffer

 *

 * PARAMETERS:  buffer              - Buffer to dump

 *              count               - Amount to dump, in bytes

 *              display             - BYTE, WORD, DWORD, or QWORD display:

 *                                      DB_BYTE_DISPLAY

 *                                      DB_WORD_DISPLAY

 *                                      DB_DWORD_DISPLAY

 *                                      DB_QWORD_DISPLAY

 *              component_ID        - Caller's component ID

 *

 * RETURN:      None

 *

 * DESCRIPTION: Generic dump buffer in both hex and ascii.

 *

 Only dump the buffer if tracing is enabled */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_dump_buffer_to_file

 *

 * PARAMETERS:  file                - File descriptor

 *              buffer              - Buffer to dump

 *              count               - Amount to dump, in bytes

 *              display             - BYTE, WORD, DWORD, or QWORD display:

 *                                      DB_BYTE_DISPLAY

 *                                      DB_WORD_DISPLAY

 *                                      DB_DWORD_DISPLAY

 *                                      DB_QWORD_DISPLAY

 *              base_offset         - Beginning buffer offset (display only)

 *

 * RETURN:      None

 *

 * DESCRIPTION: Generic dump buffer in both hex and ascii to a file.

 *

 Nasty little dump buffer routine! */

 Print current offset */

 Print 16 hex chars */

 Dump fill spaces */

 Default is BYTE display */

		/*

		 * Print the ASCII equivalent characters but watch out for the bad

		 * unprintable ones (printable chars are 0x20 through 0x7E)

 Done with that line. */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: dsopcode - Dispatcher support for regions and fields

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_initialize_region

 *

 * PARAMETERS:  obj_handle      - Region namespace node

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Front end to ev_initialize_region

 *

 Namespace is NOT locked */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_init_buffer_field

 *

 * PARAMETERS:  aml_opcode      - create_xxx_field

 *              obj_desc        - buffer_field object

 *              buffer_desc     - Host Buffer

 *              offset_desc     - Offset into buffer

 *              length_desc     - Length of field (CREATE_FIELD_OP only)

 *              result_desc     - Where to store the result

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Perform actual initialization of a buffer field

 *

 Host object must be a Buffer */

	/*

	 * The last parameter to all of these opcodes (result_desc) started

	 * out as a name_string, and should therefore now be a NS node

	 * after resolution in acpi_ex_resolve_operands().

	/*

	 * Setup the Bit offsets and counts, according to the opcode

 Offset is in bits, count is in bits */

 Must have a valid (>0) bit count */

 Offset is in bits, Field is one bit */

 Offset is in bytes, field is one byte */

 Offset is in bytes, field is one word */

 Offset is in bytes, field is one dword */

 Offset is in bytes, field is one qword */

 Entire field must fit within the current length of the buffer */

	/*

	 * Initialize areas of the field object that are common to all fields

	 * For field_flags, use LOCK_RULE = 0 (NO_LOCK),

	 * UPDATE_RULE = 0 (UPDATE_PRESERVE)

 Reference count for buffer_desc inherits obj_desc count */

 Always delete the operands */

 On failure, delete the result descriptor */

 Result descriptor */

 Now the address and length are valid for this buffer_field */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_eval_buffer_field_operands

 *

 * PARAMETERS:  walk_state      - Current walk

 *              op              - A valid buffer_field Op object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Get buffer_field Buffer and Index

 *              Called from acpi_ds_exec_end_op during buffer_field parse tree walk

 *

	/*

	 * This is where we evaluate the address and length fields of the

	 * create_xxx_field declaration

 next_op points to the op that holds the Buffer */

 Evaluate/create the address and length operands */

 Resolve the operands */

 Initialize the Buffer Field */

 NOTE: Slightly different operands for this opcode */

 All other, create_xxx_field opcodes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_eval_region_operands

 *

 * PARAMETERS:  walk_state      - Current walk

 *              op              - A valid region Op object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Get region address and length

 *              Called from acpi_ds_exec_end_op during op_region parse tree walk

 *

	/*

	 * This is where we evaluate the address and length fields of the

	 * op_region declaration

 next_op points to the op that holds the space_ID */

 next_op points to address op */

 Evaluate/create the address and length operands */

 Resolve the length and address operands to numbers */

	/*

	 * Get the length operand and save it

	 * (at Top of stack)

 A zero-length operation region is unusable. Just warn */

	/*

	 * Get the address and save it

	 * (at top of stack - 1)

 Now the address and length are valid for this opregion */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_eval_table_region_operands

 *

 * PARAMETERS:  walk_state      - Current walk

 *              op              - A valid region Op object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Get region address and length.

 *              Called from acpi_ds_exec_end_op during data_table_region parse

 *              tree walk.

 *

	/*

	 * This is where we evaluate the Signature string, oem_id string,

	 * and oem_table_id string of the Data Table Region declaration

 next_op points to Signature string op */

	/*

	 * Evaluate/create the Signature string, oem_id string,

	 * and oem_table_id string operands

	/*

	 * Resolve the Signature string, oem_id string,

	 * and oem_table_id string operands

 Find the ACPI table */

 Now the address and length are valid for this opregion */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_eval_data_object_operands

 *

 * PARAMETERS:  walk_state      - Current walk

 *              op              - A valid data_object Op object

 *              obj_desc        - data_object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Get the operands and complete the following data object types:

 *              Buffer, Package.

 *

 The first operand (for all of these data objects) is the length */

	/*

	 * Set proper index into operand stack for acpi_ds_obj_stack_push

	 * invoked inside acpi_ds_create_operand.

 Ignore if child is not valid */

 Extract length operand */

 Cleanup for length operand */

	/*

	 * Create the actual data object

		/*

		 * Return the object in the walk_state, unless the parent is a package -

		 * in this case, the return object will be stored in the parse tree

		 * for the package.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_eval_bank_field_operands

 *

 * PARAMETERS:  walk_state      - Current walk

 *              op              - A valid bank_field Op object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Get bank_field bank_value

 *              Called from acpi_ds_exec_end_op during bank_field parse tree walk

 *

	/*

	 * This is where we evaluate the bank_value field of the

	 * bank_field declaration

 next_op points to the op that holds the Region */

 next_op points to the op that holds the Bank Register */

 next_op points to the op that holds the Bank Value */

	/*

	 * Set proper index into operand stack for acpi_ds_obj_stack_push

	 * invoked inside acpi_ds_create_operand.

	 *

	 * We use walk_state->Operands[0] to store the evaluated bank_value

	/*

	 * Get the bank_value operand and save it

	 * (at Top of stack)

 Arg points to the start Bank Field */

 Ignore OFFSET and ACCESSAS terms here */

 Move to next field in the list */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: evmisc - Miscellaneous event manager support functions

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_is_notify_object

 *

 * PARAMETERS:  node            - Node to check

 *

 * RETURN:      TRUE if notifies allowed on this object

 *

 * DESCRIPTION: Check type of node for a object that supports notifies.

 *

 *              TBD: This could be replaced by a flag bit in the node.

 *

		/*

		 * These are the ONLY objects that can receive ACPI notifications

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_queue_notify_request

 *

 * PARAMETERS:  node            - NS node for the notified object

 *              notify_value    - Value from the Notify() request

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Dispatch a device notification event to a previously

 *              installed handler.

 *

 Are Notifies allowed on this object? */

 Get the correct notify list type (System or Device) */

 Get the notify object attached to the namespace Node */

 We have an attached object, Get the correct handler list */

	/*

	 * If there is no notify handler (Global or Local)

	 * for this object, just ignore the notify

 Setup notify info and schedule the notify dispatcher */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_notify_dispatch

 *

 * PARAMETERS:  context         - To be passed to the notify handler

 *

 * RETURN:      None.

 *

 * DESCRIPTION: Dispatch a device notification event to a previously

 *              installed handler.

 *

 Invoke a global notify handler if installed */

 Now invoke the local notify handler(s) if any are installed */

 All done with the info object */

/******************************************************************************

 *

 * FUNCTION:    acpi_ev_terminate

 *

 * PARAMETERS:  none

 *

 * RETURN:      none

 *

 * DESCRIPTION: Disable events and free memory allocated for table storage.

 *

		/*

		 * Disable all event-related functionality. In all cases, on error,

		 * print a message but obviously we don't abort.

 Disable all fixed events */

 Disable all GPEs in all GPE blocks */

 Remove SCI handlers */

 Deallocate all handler objects installed within GPE info structs */

 Return to original mode if necessary */

 !ACPI_REDUCED_HARDWARE */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: tbxfroot - Find the root ACPI table (RSDT)

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_get_rsdp_length

 *

 * PARAMETERS:  rsdp                - Pointer to RSDP

 *

 * RETURN:      Table length

 *

 * DESCRIPTION: Get the length of the RSDP

 *

 BAD Signature */

 "Length" field is available if table version >= 2 */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_validate_rsdp

 *

 * PARAMETERS:  rsdp                - Pointer to unvalidated RSDP

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Validate the RSDP (ptr)

 *

	/*

	 * The signature and checksum must both be correct

	 *

	 * Note: Sometimes there exists more than one RSDP in memory; the valid

	 * RSDP has a valid checksum, all others have an invalid checksum.

 Nope, BAD Signature */

 Check the standard checksum */

 Check extended checksum if table version >= 2 */

/*******************************************************************************

 *

 * FUNCTION:    acpi_find_root_pointer

 *

 * PARAMETERS:  table_address           - Where the table pointer is returned

 *

 * RETURN:      Status, RSDP physical address

 *

 * DESCRIPTION: Search lower 1Mbyte of memory for the root system descriptor

 *              pointer structure. If it is found, set *RSDP to point to it.

 *

 * NOTE1:       The RSDP must be either in the first 1K of the Extended

 *              BIOS Data Area or between E0000 and FFFFF (From ACPI Spec.)

 *              Only a 32-bit physical address is necessary.

 *

 * NOTE2:       This function is always available, regardless of the

 *              initialization state of the rest of ACPI.

 *

 1a) Get the location of the Extended BIOS Data Area (EBDA) */

 Convert segment part to physical address */

 EBDA present? */

		/*

		 * 1b) Search EBDA paragraphs (EBDA is required to be a

		 *     minimum of 1K length)

 Return the physical address */

	/*

	 * 2) Search upper memory: 16-byte boundaries in E0000h-FFFFFh

 Return the physical address */

 A valid RSDP was not found */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_scan_memory_for_rsdp

 *

 * PARAMETERS:  start_address       - Starting pointer for search

 *              length              - Maximum length to search

 *

 * RETURN:      Pointer to the RSDP if found, otherwise NULL.

 *

 * DESCRIPTION: Search a block of memory for the RSDP signature

 *

 Search from given start address for the requested length */

 The RSDP signature and checksum must both be correct */

 Sig and checksum valid, we have found a real RSDP */

 No sig match or bad checksum, keep searching */

 Searched entire block, no RSDP was found */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: tbutils - ACPI Table utilities

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_initialize_facs

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create a permanent mapping for the FADT and save it in a global

 *              for accessing the Global Lock and Firmware Waking Vector

 *

 If Hardware Reduced flag is set, there is no FACS */

 If there is no FACS, just continue. There was already an error msg */

 !ACPI_REDUCED_HARDWARE */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_check_dsdt_header

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Quick compare to check validity of the DSDT. This will detect

 *              if the DSDT has been replaced from outside the OS and/or if

 *              the DSDT header has been corrupted.

 *

 Compare original length and checksum to current values */

 Disable further error messages */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_copy_dsdt

 *

 * PARAMETERS:  table_index         - Index of installed table to copy

 *

 * RETURN:      The copied DSDT

 *

 * DESCRIPTION: Implements a subsystem option to copy the DSDT to local memory.

 *              Some very bad BIOSs are known to either corrupt the DSDT or

 *              install a new, bad DSDT. This copy works around the problem.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_get_root_table_entry

 *

 * PARAMETERS:  table_entry         - Pointer to the RSDT/XSDT table entry

 *              table_entry_size    - sizeof 32 or 64 (RSDT or XSDT)

 *

 * RETURN:      Physical address extracted from the root table

 *

 * DESCRIPTION: Get one root table entry. Handles 32-bit and 64-bit cases on

 *              both 32-bit and 64-bit platforms

 *

 * NOTE:        acpi_physical_address is 32-bit on 32-bit platforms, 64-bit on

 *              64-bit platforms.

 *

	/*

	 * Get the table physical address (32-bit for RSDT, 64-bit for XSDT):

	 * Note: Addresses are 32-bit aligned (not 64) in both RSDT and XSDT

		/*

		 * 32-bit platform, RSDT: Return 32-bit table entry

		 * 64-bit platform, RSDT: Expand 32-bit to 64-bit and return

		/*

		 * 32-bit platform, XSDT: Truncate 64-bit to 32-bit and return

		 * 64-bit platform, XSDT: Move (unaligned) 64-bit to local,

		 *  return 64-bit

 Will truncate 64-bit address to 32 bits, issue warning */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_parse_root_table

 *

 * PARAMETERS:  rsdp_address        - Pointer to the RSDP

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to parse the Root System Description

 *              Table (RSDT or XSDT)

 *

 * NOTE:        Tables are mapped (not copied) for efficiency. The FACS must

 *              be mapped and cannot be copied because it contains the actual

 *              memory location of the ACPI Global Lock.

 *

 Map the entire RSDP and extract the address of the RSDT or XSDT */

 Use XSDT if present and not overridden. Otherwise, use RSDT */

		/*

		 * RSDP contains an XSDT (64-bit physical addresses). We must use

		 * the XSDT if the revision is > 1 and the XSDT pointer is present,

		 * as per the ACPI specification.

 Root table is an RSDT (32-bit physical addresses) */

	/*

	 * It is not possible to map more than one entry in some environments,

	 * so unmap the RSDP here before mapping other tables

 Map the RSDT/XSDT table header to get the full table length */

	/*

	 * Validate length of the table, and map entire table.

	 * Minimum length table must contain at least one entry.

 Validate the root table checksum */

 Get the number of entries and pointer to first entry */

 Initialize the root table array from the RSDT/XSDT */

 Get the table physical address (32-bit for RSDT, 64-bit for XSDT) */

 Skip NULL entries in RSDT/XSDT */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_get_table

 *

 * PARAMETERS:  table_desc          - Table descriptor

 *              out_table           - Where the pointer to the table is returned

 *

 * RETURN:      Status and pointer to the requested table

 *

 * DESCRIPTION: Increase a reference to a table descriptor and return the

 *              validated table pointer.

 *              If the table descriptor is an entry of the root table list,

 *              this API must be invoked with ACPI_MTX_TABLES acquired.

 *

 Table need to be "VALIDATED" */

		/*

		 * Detect validation_count overflows to ensure that the warning

		 * message will only be printed once.

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_put_table

 *

 * PARAMETERS:  table_desc          - Table descriptor

 *

 * RETURN:      None

 *

 * DESCRIPTION: Decrease a reference to a table descriptor and release the

 *              validated table pointer if no references.

 *              If the table descriptor is an entry of the root table list,

 *              this API must be invoked with ACPI_MTX_TABLES acquired.

 *

		/*

		 * Detect validation_count underflows to ensure that the warning

		 * message will only be printed once.

 Table need to be "INVALIDATED" */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: nseval - Object evaluation, includes control method execution

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_evaluate

 *

 * PARAMETERS:  info            - Evaluation info block, contains these fields

 *                                and more:

 *                  prefix_node     - Prefix or Method/Object Node to execute

 *                  relative_path   - Name of method to execute, If NULL, the

 *                                    Node is the object to execute

 *                  parameters      - List of parameters to pass to the method,

 *                                    terminated by NULL. Params itself may be

 *                                    NULL if no parameters are being passed.

 *                  parameter_type  - Type of Parameter list

 *                  return_object   - Where to put method's return value (if

 *                                    any). If NULL, no value is returned.

 *                  flags           - ACPI_IGNORE_RETURN_VALUE to delete return

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute a control method or return the current value of an

 *              ACPI namespace object.

 *

 * MUTEX:       Locks interpreter

 *

		/*

		 * Get the actual namespace node for the target object if we

		 * need to. Handles these cases:

		 *

		 * 1) Null node, valid pathname from root (absolute path)

		 * 2) Node and valid pathname (path relative to Node)

		 * 3) Node, Null pathname

	/*

	 * For a method alias, we must grab the actual method node so that

	 * proper scoping context will be established before execution.

 Complete the info block initialization */

 Get info if we have a predefined name (_HID, etc.) */

 Get the full pathname to the object, for use in warning messages */

 Optional object evaluation log */

 Count the number of arguments being passed in */

 Warn on impossible argument count */

	/*

	 * For predefined names: Check that the declared argument count

	 * matches the ACPI spec -- otherwise this is a BIOS error.

	/*

	 * For all names: Check that the incoming argument count for

	 * this method/object matches the actual ASL/AML definition.

 For predefined names: Typecheck all incoming arguments */

	/*

	 * Three major evaluation cases:

	 *

	 * 1) Object types that cannot be evaluated by definition

	 * 2) The object is a control method -- execute it

	 * 3) The object is not a method -- just return it's current value

		/*

		 * 1) Disallow evaluation of these object types. For these,

		 *    object evaluation is undefined.

		/*

		 * 2) Object is a control method - execute it

 Verify that there is a method object associated with this node */

		/*

		 * Any namespace deletion must acquire both the namespace and

		 * interpreter locks to ensure that no thread is using the portion of

		 * the namespace that is being deleted.

		 *

		 * Execute the method via the interpreter. The interpreter is locked

		 * here before calling into the AML parser

		/*

		 * 3) All other non-method objects -- get the current object value

		/*

		 * Some objects require additional resolution steps (e.g., the Node

		 * may be a field that must be read, etc.) -- we can't just grab

		 * the object out of the node.

		 *

		 * Use resolve_node_to_value() to get the associated value.

		 *

		 * NOTE: we can get away with passing in NULL for a walk state because

		 * the Node is guaranteed to not be a reference to either a method

		 * local or a method argument (because this interface is never called

		 * from a running method.)

		 *

		 * Even though we do not directly invoke the interpreter for object

		 * resolution, we must lock it because we could access an op_region.

		 * The op_region access code assumes that the interpreter is locked.

 TBD: resolve_node_to_value has a strange interface, fix */

 Always has a "return value" */

	/*

	 * For predefined names, check the return value against the ACPI

	 * specification. Some incorrect return value types are repaired.

 Check if there is a return value that must be dealt with */

 If caller does not want the return value, delete it */

 Map AE_CTRL_RETURN_VALUE to AE_OK, we are done with it */

 If return_object exists, delete it */

 Optional object evaluation log */

	/*

	 * Namespace was unlocked by the handling acpi_ns* function, so we

	 * just free the pathname and return

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: nsalloc - Namespace allocation and deletion utilities

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_create_node

 *

 * PARAMETERS:  name            - Name of the new node (4 char ACPI name)

 *

 * RETURN:      New namespace node (Null on failure)

 *

 * DESCRIPTION: Create a namespace node

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_delete_node

 *

 * PARAMETERS:  node            - Node to be deleted

 *

 * RETURN:      None

 *

 * DESCRIPTION: Delete a namespace node. All node deletions must come through

 *              here. Detaches any attached objects, including any attached

 *              data. If a handler is associated with attached data, it is

 *              invoked before the node is deleted.

 *

 Detach an object if there is one */

	/*

	 * Delete an attached data object list if present (objects that were

	 * attached via acpi_attach_data). Note: After any normal object is

	 * detached above, the only possible remaining object(s) are data

	 * objects, in a linked list.

 Invoke the attached data deletion handler if present */

 Special case for the statically allocated root node */

 Now we can delete the node */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_remove_node

 *

 * PARAMETERS:  node            - Node to be removed/deleted

 *

 * RETURN:      None

 *

 * DESCRIPTION: Remove (unlink) and delete a namespace node

 *

 Find the node that is the previous peer in the parent's child list */

 Node is not first child, unlink it */

		/*

		 * Node is first child (has no previous peer).

		 * Link peer list to parent

 Delete the node and any attached objects */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_install_node

 *

 * PARAMETERS:  walk_state      - Current state of the walk

 *              parent_node     - The parent of the new Node

 *              node            - The new Node to install

 *              type            - ACPI object type of the new Node

 *

 * RETURN:      None

 *

 * DESCRIPTION: Initialize a new namespace node and install it amongst

 *              its peers.

 *

 *              Note: Current namespace lookup is linear search. This appears

 *              to be sufficient as namespace searches consume only a small

 *              fraction of the execution time of the ACPI subsystem.

 *

 Parent */

 New Child */

		/*

		 * Get the owner ID from the Walk state. The owner ID is used to

		 * track table deletion and deletion of objects created by methods.

			/*

			 * A method is creating a new node that is not a child of the

			 * method (it is non-local). Mark the executing method as having

			 * modified the namespace. This is used for cleanup when the

			 * method exits.

 Link the new entry into the parent and existing children */

 Add node to the end of the peer list */

 Init the new entry */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_delete_children

 *

 * PARAMETERS:  parent_node     - Delete this objects children

 *

 * RETURN:      None.

 *

 * DESCRIPTION: Delete all children of the parent object. In other words,

 *              deletes a "scope".

 *

 Deallocate all children at this level */

 Grandchildren should have all been deleted already */

		/*

		 * Delete this child node and move on to the next child in the list.

		 * No need to unlink the node since we are deleting the entire branch.

 Clear the parent's child pointer */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_delete_namespace_subtree

 *

 * PARAMETERS:  parent_node     - Root of the subtree to be deleted

 *

 * RETURN:      None.

 *

 * DESCRIPTION: Delete a subtree of the namespace. This includes all objects

 *              stored within the subtree.

 *

 Lock namespace for possible update */

	/*

	 * Traverse the tree of objects until we bubble back up

	 * to where we started.

 Get the next node in this scope (NULL if none) */

 Found a child node - detach any attached object */

 Check if this node has any children */

				/*

				 * There is at least one child of this node,

				 * visit the node

			/*

			 * No more children of this parent node.

			 * Move up to the grandparent.

			/*

			 * Now delete all of the children of this parent

			 * all at the same time.

 New "last child" is this parent node */

 Move up the tree to the grandparent */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_delete_namespace_by_owner

 *

 * PARAMETERS:  owner_id    - All nodes with this owner will be deleted

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Delete entries within the namespace that are owned by a

 *              specific ID. Used to delete entire ACPI tables. All

 *              reference counts are updated.

 *

 * MUTEX:       Locks namespace during deletion walk.

 *

 Lock namespace for possible update */

	/*

	 * Traverse the tree of nodes until we bubble back up

	 * to where we started.

		/*

		 * Get the next child of this parent node. When child_node is NULL,

		 * the first child of the parent is returned

 Found a matching child node - detach any attached object */

 Check if this node has any children */

				/*

				 * There is at least one child of this node,

				 * visit the node

			/*

			 * No more children of this parent node.

			 * Move up to the grandparent.

 New "last child" is this parent node */

 Move up the tree to the grandparent */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: utalloc - local memory allocation routines

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_os_allocate_zeroed

 *

 * PARAMETERS:  size                - Size of the allocation

 *

 * RETURN:      Address of the allocated memory on success, NULL on failure.

 *

 * DESCRIPTION: Subsystem equivalent of calloc. Allocate and zero memory.

 *              This is the default implementation. Can be overridden via the

 *              USE_NATIVE_ALLOCATE_ZEROED flag.

 *

 Clear the memory block */

 !USE_NATIVE_ALLOCATE_ZEROED */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_create_caches

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create all local caches

 *

 Object Caches, for frequently used objects */

	/*

	 * For use with the ASL-/ASL+ option. This cache keeps track of regular

	 * 0xA9 0x01 comments.

	/*

	 * This cache keeps track of the starting addresses of where the comments

	 * lie. This helps prevent duplication of comments.

	/*

	 * This cache will be used for nodes that represent files.

 Memory allocation lists */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_delete_caches

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Purge and delete all local caches

 *

 Debug only - display leftover memory allocation, if any */

 Free memory lists */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_validate_buffer

 *

 * PARAMETERS:  buffer              - Buffer descriptor to be validated

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Perform parameter validation checks on an struct acpi_buffer

 *

 Obviously, the structure pointer must be valid */

 Special semantics for the length */

 Length is valid, the buffer pointer must be also */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_initialize_buffer

 *

 * PARAMETERS:  buffer              - Buffer to be validated

 *              required_length     - Length needed

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Validate that the buffer is of the required length or

 *              allocate a new buffer. Returned buffer is always zeroed.

 *

 Parameter validation */

	/*

	 * Buffer->Length is used as both an input and output parameter. Get the

	 * input actual length and set the output required buffer length.

	/*

	 * The input buffer length contains the actual buffer length, or the type

	 * of buffer to be allocated by this routine.

 Return the exception (and the required buffer length) */

		/*

		 * Allocate a new buffer. We directectly call acpi_os_allocate here to

		 * purposefully bypass the (optionally enabled) internal allocation

		 * tracking mechanism since we only want to track internal

		 * allocations. Note: The caller should use acpi_os_free to free this

		 * buffer created via ACPI_ALLOCATE_BUFFER.

 Allocate a new buffer with local interface to allow tracking */

 Existing buffer: Validate the size of the buffer */

 Validate allocation from above or input buffer pointer */

 Have a valid buffer, clear it */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exprep - ACPI AML field prep utilities

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_generate_access

 *

 * PARAMETERS:  field_bit_offset    - Start of field within parent region/buffer

 *              field_bit_length    - Length of field in bits

 *              region_length       - Length of parent in bytes

 *

 * RETURN:      Field granularity (8, 16, 32 or 64) and

 *              byte_alignment (1, 2, 3, or 4)

 *

 * DESCRIPTION: Generate an optimal access width for fields defined with the

 *              any_acc keyword.

 *

 * NOTE: Need to have the region_length in order to check for boundary

 *       conditions (end-of-region). However, the region_length is a deferred

 *       operation. Therefore, to complete this implementation, the generation

 *       of this access width must be deferred until the region length has

 *       been evaluated.

 *

 Round Field start offset and length to "minimal" byte boundaries */

	/*

	 * Iterative search for the maximum access width that is both aligned

	 * and does not go beyond the end of the region

	 *

	 * Start at byte_acc and work upwards to qword_acc max. (1,2,4,8 bytes)

		/*

		 * 1) Round end offset up to next access boundary and make sure that

		 *    this does not go beyond the end of the parent region.

		 * 2) When the Access width is greater than the field_byte_length, we

		 *    are done. (This does not optimize for the perfectly aligned

		 *    case yet).

 Single access is optimal */

			/*

			 * Fits in the region, but requires more than one read/write.

			 * try the next wider access on next iteration

 Field does not fit in the region at all */

			/*

			 * This width goes beyond the end-of-region, back off to

			 * previous access

	/*

	 * Could not read/write field with one operation,

	 * just use max access width

 ACPI_UNDER_DEVELOPMENT */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_decode_field_access

 *

 * PARAMETERS:  obj_desc            - Field object

 *              field_flags         - Encoded fieldflags (contains access bits)

 *              return_byte_alignment - Where the byte alignment is returned

 *

 * RETURN:      Field granularity (8, 16, 32 or 64) and

 *              byte_alignment (1, 2, 3, or 4)

 *

 * DESCRIPTION: Decode the access_type bits of a field definition.

 *

 Temp until we pass region_length as parameter */

 ACPI 2.0 (SMBus Buffer) */

 ACPI 2.0 */

 Invalid field access type */

		/*

		 * buffer_field access can be on any byte boundary, so the

		 * byte_alignment is always 1 byte -- regardless of any byte_alignment

		 * implied by the field access type.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_prep_common_field_object

 *

 * PARAMETERS:  obj_desc            - The field object

 *              field_flags         - Access, lock_rule, and update_rule.

 *                                    The format of a field_flag is described

 *                                    in the ACPI specification

 *              field_attribute     - Special attributes (not used)

 *              field_bit_position  - Field start position

 *              field_bit_length    - Field length in number of bits

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Initialize the areas of the field object that are common

 *              to the various types of fields. Note: This is very "sensitive"

 *              code because we are solving the general case for field

 *              alignment.

 *

	/*

	 * Note: the structure being initialized is the

	 * ACPI_COMMON_FIELD_INFO;  No structure fields outside of the common

	 * area are initialized by this procedure.

	/*

	 * Decode the access type so we can compute offsets. The access type gives

	 * two pieces of information - the width of each field access and the

	 * necessary byte_alignment (address granularity) of the access.

	 *

	 * For any_acc, the access_bit_width is the largest width that is both

	 * necessary and possible in an attempt to access the whole field in one

	 * I/O operation. However, for any_acc, the byte_alignment is always one

	 * byte.

	 *

	 * For all Buffer Fields, the byte_alignment is always one byte.

	 *

	 * For all other access types (Byte, Word, Dword, Qword), the Bitwidth is

	 * the same (equivalent) as the byte_alignment.

 Setup width (access granularity) fields (values are: 1, 2, 4, 8) */

	/*

	 * base_byte_offset is the address of the start of the field within the

	 * region. It is the byte address of the first *datum* (field-width data

	 * unit) of the field. (i.e., the first datum that contains at least the

	 * first *bit* of the field.)

	 *

	 * Note: byte_alignment is always either equal to the access_bit_width or 8

	 * (Byte access), and it defines the addressing granularity of the parent

	 * region or buffer.

	/*

	 * start_field_bit_offset is the offset of the first bit of the field within

	 * a field datum.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_prep_field_value

 *

 * PARAMETERS:  info    - Contains all field creation info

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Construct an object of type union acpi_operand_object with a

 *              subtype of def_field and connect it to the parent Node.

 *

 Parameter validation */

 Allocate a new field object */

 Initialize areas of the object that are common to all fields */

 Initialize areas of the object that are specific to the field type */

 Fields specific to generic_serial_bus fields */

 Allow full data read from EC address space */

 Maximum byte width supported is 255 */

 An additional reference for the attached objects */

		/*

		 * Remember location in AML stream of the field unit

		 * opcode and operands -- since the bank_value

		 * operands must be evaluated.

 Get the Index and Data registers */

 An additional reference for the attached objects */

		/*

		 * April 2006: Changed to match MS behavior

		 *

		 * The value written to the Index register is the byte offset of the

		 * target field in units of the granularity of the index_field

		 *

		 * Previously, the value was calculated as an index in terms of the

		 * width of the Data register, as below:

		 *

		 *      obj_desc->index_field.Value = (u32)

		 *          (Info->field_bit_position / ACPI_MUL_8 (

		 *              obj_desc->Field.access_byte_width));

		 *

		 * February 2006: Tried value as a byte offset:

		 *      obj_desc->index_field.Value = (u32)

		 *          ACPI_DIV_8 (Info->field_bit_position);

 No other types should get here */

	/*

	 * Store the constructed descriptor (obj_desc) into the parent Node,

	 * preserving the current type of that named_obj.

 Remove local reference to the object */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: utxferror - Various error/warning output functions

 *

/*

 * This module is used for the in-kernel ACPICA as well as the ACPICA

 * tools/applications.

 Entire module */

/*******************************************************************************

 *

 * FUNCTION:    acpi_error

 *

 * PARAMETERS:  module_name         - Caller's module name (for error output)

 *              line_number         - Caller's line number (for error output)

 *              format              - Printf format string + additional args

 *

 * RETURN:      None

 *

 * DESCRIPTION: Print "ACPI Error" message with module/line/version info

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_exception

 *

 * PARAMETERS:  module_name         - Caller's module name (for error output)

 *              line_number         - Caller's line number (for error output)

 *              status              - Status value to be decoded/formatted

 *              format              - Printf format string + additional args

 *

 * RETURN:      None

 *

 * DESCRIPTION: Print an "ACPI Error" message with module/line/version

 *              info as well as decoded acpi_status.

 *

 For AE_OK, just print the message */

/*******************************************************************************

 *

 * FUNCTION:    acpi_warning

 *

 * PARAMETERS:  module_name         - Caller's module name (for warning output)

 *              line_number         - Caller's line number (for warning output)

 *              format              - Printf format string + additional args

 *

 * RETURN:      None

 *

 * DESCRIPTION: Print "ACPI Warning" message with module/line/version info

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_info

 *

 * PARAMETERS:  format              - Printf format string + additional args

 *

 * RETURN:      None

 *

 * DESCRIPTION: Print generic "ACPI:" information message. There is no

 *              module/line/version info in order to keep the message simple.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_bios_error

 *

 * PARAMETERS:  module_name         - Caller's module name (for error output)

 *              line_number         - Caller's line number (for error output)

 *              format              - Printf format string + additional args

 *

 * RETURN:      None

 *

 * DESCRIPTION: Print "ACPI Firmware Error" message with module/line/version

 *              info

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_bios_exception

 *

 * PARAMETERS:  module_name         - Caller's module name (for error output)

 *              line_number         - Caller's line number (for error output)

 *              status              - Status value to be decoded/formatted

 *              format              - Printf format string + additional args

 *

 * RETURN:      None

 *

 * DESCRIPTION: Print an "ACPI Firmware Error" message with module/line/version

 *              info as well as decoded acpi_status.

 *

 For AE_OK, just print the message */

/*******************************************************************************

 *

 * FUNCTION:    acpi_bios_warning

 *

 * PARAMETERS:  module_name         - Caller's module name (for warning output)

 *              line_number         - Caller's line number (for warning output)

 *              format              - Printf format string + additional args

 *

 * RETURN:      None

 *

 * DESCRIPTION: Print "ACPI Firmware Warning" message with module/line/version

 *              info

 *

 ACPI_NO_ERROR_MESSAGES */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: uttrack - Memory allocation tracking routines (debug only)

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*

 * These procedures are used for tracking memory leaks in the subsystem, and

 * they get compiled out when the ACPI_DBG_TRACK_ALLOCATIONS is not set.

 *

 * Each memory allocation is tracked via a doubly linked list. Each

 * element contains the caller's component, module name, function name, and

 * line number. acpi_ut_allocate and acpi_ut_allocate_zeroed call

 * acpi_ut_track_allocation to add an element to the list; deletion

 * occurs in the body of acpi_ut_free.

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_create_list

 *

 * PARAMETERS:  cache_name      - Ascii name for the cache

 *              object_size     - Size of each cached object

 *              return_cache    - Where the new cache object is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create a local memory list for tracking purposed

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_allocate_and_track

 *

 * PARAMETERS:  size                - Size of the allocation

 *              component           - Component type of caller

 *              module              - Source file name of caller

 *              line                - Line number of caller

 *

 * RETURN:      Address of the allocated memory on success, NULL on failure.

 *

 * DESCRIPTION: The subsystem's equivalent of malloc.

 *

 Check for an inadvertent size of zero bytes */

 Report allocation error */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_allocate_zeroed_and_track

 *

 * PARAMETERS:  size                - Size of the allocation

 *              component           - Component type of caller

 *              module              - Source file name of caller

 *              line                - Line number of caller

 *

 * RETURN:      Address of the allocated memory on success, NULL on failure.

 *

 * DESCRIPTION: Subsystem equivalent of calloc.

 *

 Check for an inadvertent size of zero bytes */

 Report allocation error */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_free_and_track

 *

 * PARAMETERS:  allocation          - Address of the memory to deallocate

 *              component           - Component type of caller

 *              module              - Source file name of caller

 *              line                - Line number of caller

 *

 * RETURN:      None

 *

 * DESCRIPTION: Frees the memory at Allocation

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_find_allocation

 *

 * PARAMETERS:  allocation              - Address of allocated memory

 *

 * RETURN:      Three cases:

 *              1) List is empty, NULL is returned.

 *              2) Element was found. Returns Allocation parameter.

 *              3) Element was not found. Returns position where it should be

 *                  inserted into the list.

 *

 * DESCRIPTION: Searches for an element in the global allocation tracking list.

 *              If the element is not found, returns the location within the

 *              list where the element should be inserted.

 *

 *              Note: The list is ordered by larger-to-smaller addresses.

 *

 *              This global list is used to detect memory leaks in ACPICA as

 *              well as other issues such as an attempt to release the same

 *              internal object more than once. Although expensive as far

 *              as cpu time, this list is much more helpful for finding these

 *              types of issues than using memory leak detectors outside of

 *              the ACPICA code.

 *

	/*

	 * Search for the address.

	 *

	 * Note: List is ordered by larger-to-smaller addresses, on the

	 * assumption that a new allocation usually has a larger address

	 * than previous allocations.

 Check for end-of-list */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_track_allocation

 *

 * PARAMETERS:  allocation          - Address of allocated memory

 *              size                - Size of the allocation

 *              alloc_type          - MEM_MALLOC or MEM_CALLOC

 *              component           - Component type of caller

 *              module              - Source file name of caller

 *              line                - Line number of caller

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Inserts an element into the global allocation tracking list.

 *

	/*

	 * Search the global list for this address to make sure it is not

	 * already present. This will catch several kinds of problems.

 Fill in the instance data */

 Insert at list head */

 Insert after element */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_remove_allocation

 *

 * PARAMETERS:  allocation          - Address of allocated memory

 *              component           - Component type of caller

 *              module              - Source file name of caller

 *              line                - Line number of caller

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Deletes an element from the global allocation tracking list.

 *

 No allocations! */

 Unlink */

 Mark the segment as deleted */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_dump_allocation_info

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Print some info about the outstanding allocations.

 *

/*

	struct acpi_memory_list         *mem_list;

/*

	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,

		("%30s: %4d (%3d Kb)\n", "Current allocations",

		mem_list->current_count,

		ROUND_UP_TO_1K (mem_list->current_size)));



	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,

		("%30s: %4d (%3d Kb)\n", "Max concurrent allocations",

		mem_list->max_concurrent_count,

		ROUND_UP_TO_1K (mem_list->max_concurrent_size)));



	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,

		("%30s: %4d (%3d Kb)\n", "Total (all) internal objects",

		running_object_count,

		ROUND_UP_TO_1K (running_object_size)));



	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,

		("%30s: %4d (%3d Kb)\n", "Total (all) allocations",

		running_alloc_count,

		ROUND_UP_TO_1K (running_alloc_size)));



	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,

		("%30s: %4d (%3d Kb)\n", "Current Nodes",

		acpi_gbl_current_node_count,

		ROUND_UP_TO_1K (acpi_gbl_current_node_size)));



	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,

		("%30s: %4d (%3d Kb)\n", "Max Nodes",

		acpi_gbl_max_concurrent_node_count,

		ROUND_UP_TO_1K ((acpi_gbl_max_concurrent_node_count *

			sizeof (struct acpi_namespace_node)))));

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_dump_allocations

 *

 * PARAMETERS:  component           - Component(s) to dump info for.

 *              module              - Module to dump info for. NULL means all.

 *

 * RETURN:      None

 *

 * DESCRIPTION: Print a list of all outstanding allocations.

 *

	/*

	 * Walk the allocation list.

 Ignore allocated objects that are in a cache */

 Optional object hex dump */

 Validate the descriptor type using Type field and length */

 Not a valid descriptor type */

 Display additional info for the major descriptor types */

 Print summary */

 ACPI_DBG_TRACK_ALLOCATIONS */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: uteval - Object evaluation

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_evaluate_object

 *

 * PARAMETERS:  prefix_node         - Starting node

 *              path                - Path to object from starting node

 *              expected_return_types - Bitmap of allowed return types

 *              return_desc         - Where a return value is stored

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Evaluates a namespace object and verifies the type of the

 *              return object. Common code that simplifies accessing objects

 *              that have required return objects of fixed types.

 *

 *              NOTE: Internal function, no parameter validation

 *

 Allocate the evaluation information block */

 Evaluate the object/method */

 Did we get a return object? */

 Map the return object type to the bitmapped type */

		/*

		 * We received a return object, but one was not expected. This can

		 * happen frequently if the "implicit return" feature is enabled.

		 * Just delete the return object and return AE_OK.

 Is the return object one of the expected types? */

 On error exit, we must delete the return object */

 Object type is OK, return it */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_evaluate_numeric_object

 *

 * PARAMETERS:  object_name         - Object name to be evaluated

 *              device_node         - Node for the device

 *              value               - Where the value is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Evaluates a numeric namespace object for a selected device

 *              and stores result in *Value.

 *

 *              NOTE: Internal function, no parameter validation

 *

 Get the returned Integer */

 On exit, we must delete the return object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_execute_STA

 *

 * PARAMETERS:  device_node         - Node for the device

 *              flags               - Where the status flags are returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Executes _STA for selected device and stores results in

 *              *Flags. If _STA does not exist, then the device is assumed

 *              to be present/functional/enabled (as per the ACPI spec).

 *

 *              NOTE: Internal function, no parameter validation

 *

			/*

			 * if _STA does not exist, then (as per the ACPI specification),

			 * the returned flags will indicate that the device is present,

			 * functional, and enabled.

 Extract the status flags */

 On exit, we must delete the return object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_execute_power_methods

 *

 * PARAMETERS:  device_node         - Node for the device

 *              method_names        - Array of power method names

 *              method_count        - Number of methods to execute

 *              out_values          - Where the power method values are returned

 *

 * RETURN:      Status, out_values

 *

 * DESCRIPTION: Executes the specified power methods for the device and returns

 *              the result(s).

 *

 *              NOTE: Internal function, no parameter validation

 *

		/*

		 * Execute the power method (_sx_d or _sx_w). The only allowable

		 * return type is an Integer.

 Delete the return object */

 At least one value is valid */

 Ignore if not found */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: dbxface - AML Debugger external interfaces

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_start_command

 *

 * PARAMETERS:  walk_state      - Current walk

 *              op              - Current executing Op, from AML interpreter

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Enter debugger command loop

 *

 TBD: [Investigate] are there namespace locking issues here? */

 acpi_ut_release_mutex (ACPI_MTX_NAMESPACE); */

 Go into the command loop and await next user command */

 Notify the completion of the command */

 Wait the readiness of the command */

 acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE); */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_signal_break_point

 *

 * PARAMETERS:  walk_state      - Current walk

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Called for AML_BREAKPOINT_OP

 *

	/*

	 * Set the single-step flag. This will cause the debugger (if present)

	 * to break to the console within the AML debugger at the start of the

	 * next AML instruction.

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_get_display_op

 *

 * PARAMETERS:  walk_state      - Current walk

 *              op              - Current executing op (from aml interpreter)

 *

 * RETURN:      Opcode to display

 *

 * DESCRIPTION: Find the opcode to display during single stepping

 *

			/*

			 * We are executing the predicate of an IF or WHILE statement

			 * Search upwards for the containing IF or WHILE so that the

			 * entire predicate can be displayed.

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_single_step

 *

 * PARAMETERS:  walk_state      - Current walk

 *              op              - Current executing op (from aml interpreter)

 *              opcode_class    - Class of the current AML Opcode

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Called just before execution of an AML opcode.

 *

 Check the abort flag */

 Check for single-step breakpoint */

 Check if the breakpoint has been reached or passed */

 Hit the breakpoint, resume single step, reset breakpoint */

 Check for user breakpoint (Must be on exact Aml offset) */

	/*

	 * Check if this is an opcode that we are interested in --

	 * namely, opcodes that have arguments

 constants, literals, etc. do nothing */

 All other opcodes -- continue */

	/*

	 * Under certain debug conditions, display this opcode and its operands

		/*

		 * Display this op (and only this op - zero out the NEXT field

		 * temporarily, and disable parser trace output for the duration of

		 * the display because we don't want the extraneous debug output)

 Now we can disassemble and display it */

		/*

		 * The AML Disassembler is not configured - at least we can

		 * display the opcode value and name

 Restore everything */

 If we are not single stepping, just continue executing the method */

	/*

	 * If we are executing a step-to-call command,

	 * Check if this is a method call.

 Not a method call, just keep executing */

 Found a method call, stop executing */

	/*

	 * If the next opcode is a method call, we will "step over" it

	 * by default.

 Force no more single stepping while executing called method */

		/*

		 * Set the breakpoint on/before the call, it will stop execution

		 * as soon as we return

 Must be non-zero! */

 User commands complete, continue execution of the interrupted method */

/*******************************************************************************

 *

 * FUNCTION:    acpi_initialize_debugger

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Init and start debugger

 *

 Init globals */

 Initial scope is the root */

 Initialize user commands loop */

	/*

	 * If configured for multi-thread support, the debug executor runs in

	 * a separate thread so that the front end can be in another address

	 * space, environment, or even another machine.

 These were created with one unit, grab it */

 Create the debug execution thread to execute commands */

/*******************************************************************************

 *

 * FUNCTION:    acpi_terminate_debugger

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Stop debugger

 *

 Terminate the AML Debugger */

 Wait the AML Debugger threads */

 Ensure that debug output is now disabled */

/*******************************************************************************

 *

 * FUNCTION:    acpi_set_debugger_thread_id

 *

 * PARAMETERS:  thread_id       - Debugger thread ID

 *

 * RETURN:      None

 *

 * DESCRIPTION: Set debugger thread ID

 *

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exregion - ACPI default op_region (address space) handlers

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_system_memory_space_handler

 *

 * PARAMETERS:  function            - Read or Write operation

 *              address             - Where in the space to read or write

 *              bit_width           - Field width in bits (8, 16, or 32)

 *              value               - Pointer to in or out value

 *              handler_context     - Pointer to Handler's context

 *              region_context      - Pointer to context specific to the

 *                                    accessed region

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Handler for the System Memory address space (Op Region)

 *

 Validate and translate the bit width */

	/*

	 * Hardware does not support non-aligned data transfers, we must verify

	 * the request.

	/*

	 * Does the request fit into the cached memory mapping?

	 * Is 1) Address below the current mapping? OR

	 *    2) Address beyond the current mapping?

		/*

		 * The request cannot be resolved by the current memory mapping.

		 *

		 * Look for an existing saved mapping covering the address range

		 * at hand.  If found, save it as the current one and carry out

		 * the access.

 Create a new mappings list entry */

		/*

		 * October 2009: Attempt to map from the requested address to the

		 * end of the region. However, we will never map more than one

		 * page, nor will we cross a page boundary.

		/*

		 * If mapping the entire remaining portion of the region will cross

		 * a page boundary, just map up to the page boundary, do not cross.

		 * On some systems, crossing a page boundary while mapping regions

		 * can cause warnings if the pages have different attributes

		 * due to resource management.

		 *

		 * This has the added benefit of constraining a single mapping to

		 * one page, which is similar to the original code that used a 4k

		 * maximum window.

 Create a new mapping starting at the address given */

 Save the physical address and mapping size */

		/*

		 * Add the new entry to the mappigs list and save it as the

		 * current mapping.

	/*

	 * Generate a logical pointer corresponding to the address we want to

	 * access

	/*

	 * Perform the memory read or write

	 *

	 * Note: For machines that do not support non-aligned transfers, the target

	 * address was checked for alignment above. We do not attempt to break the

	 * transfer up into smaller (byte-size) chunks because the AML specifically

	 * asked for a transfer width that the hardware may require.

 bit_width was already validated */

 bit_width was already validated */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_system_io_space_handler

 *

 * PARAMETERS:  function            - Read or Write operation

 *              address             - Where in the space to read or write

 *              bit_width           - Field width in bits (8, 16, or 32)

 *              value               - Pointer to in or out value

 *              handler_context     - Pointer to Handler's context

 *              region_context      - Pointer to context specific to the

 *                                    accessed region

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Handler for the System IO address space (Op Region)

 *

 Decode the function parameter */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_pci_config_space_handler

 *

 * PARAMETERS:  function            - Read or Write operation

 *              address             - Where in the space to read or write

 *              bit_width           - Field width in bits (8, 16, or 32)

 *              value               - Pointer to in or out value

 *              handler_context     - Pointer to Handler's context

 *              region_context      - Pointer to context specific to the

 *                                    accessed region

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Handler for the PCI Config address space (Op Region)

 *

	/*

	 *  The arguments to acpi_os(Read|Write)pci_configuration are:

	 *

	 *  pci_segment is the PCI bus segment range 0-31

	 *  pci_bus     is the PCI bus number range 0-255

	 *  pci_device  is the PCI device number range 0-31

	 *  pci_function is the PCI device function number

	 *  pci_register is the Config space register range 0-255 bytes

	 *

	 *  value - input value for write, output address for read

	 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_cmos_space_handler

 *

 * PARAMETERS:  function            - Read or Write operation

 *              address             - Where in the space to read or write

 *              bit_width           - Field width in bits (8, 16, or 32)

 *              value               - Pointer to in or out value

 *              handler_context     - Pointer to Handler's context

 *              region_context      - Pointer to context specific to the

 *                                    accessed region

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Handler for the CMOS address space (Op Region)

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_pci_bar_space_handler

 *

 * PARAMETERS:  function            - Read or Write operation

 *              address             - Where in the space to read or write

 *              bit_width           - Field width in bits (8, 16, or 32)

 *              value               - Pointer to in or out value

 *              handler_context     - Pointer to Handler's context

 *              region_context      - Pointer to context specific to the

 *                                    accessed region

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Handler for the PCI bar_target address space (Op Region)

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_data_table_space_handler

 *

 * PARAMETERS:  function            - Read or Write operation

 *              address             - Where in the space to read or write

 *              bit_width           - Field width in bits (8, 16, or 32)

 *              value               - Pointer to in or out value

 *              handler_context     - Pointer to Handler's context

 *              region_context      - Pointer to context specific to the

 *                                    accessed region

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Handler for the Data Table address space (Op Region)

 *

	/*

	 * Perform the memory read or write. The bit_width was already

	 * validated.

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: utprint - Formatted printing routines

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_bound_string_length

 *

 * PARAMETERS:  string              - String with boundary

 *              count               - Boundary of the string

 *

 * RETURN:      Length of the string. Less than or equal to Count.

 *

 * DESCRIPTION: Calculate the length of a string with boundary.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_bound_string_output

 *

 * PARAMETERS:  string              - String with boundary

 *              end                 - Boundary of the string

 *              c                   - Character to be output to the string

 *

 * RETURN:      Updated position for next valid character

 *

 * DESCRIPTION: Output a character into a string with boundary check.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_put_number

 *

 * PARAMETERS:  string              - Buffer to hold reverse-ordered string

 *              number              - Integer to be converted

 *              base                - Base of the integer

 *              upper               - Whether or not using upper cased digits

 *

 * RETURN:      Updated position for next valid character

 *

 * DESCRIPTION: Convert an integer into a string, note that, the string holds a

 *              reversed ordered number without the trailing zero.

 *

 *(Pos++) = '0'; */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_scan_number

 *

 * PARAMETERS:  string              - String buffer

 *              number_ptr          - Where the number is returned

 *

 * RETURN:      Updated position for next valid character

 *

 * DESCRIPTION: Scan a string for a decimal integer.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_print_number

 *

 * PARAMETERS:  string              - String buffer

 *              number              - The number to be converted

 *

 * RETURN:      Updated position for next valid character

 *

 * DESCRIPTION: Print a decimal integer into a string.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_format_number

 *

 * PARAMETERS:  string              - String buffer with boundary

 *              end                 - Boundary of the string

 *              number              - The number to be converted

 *              base                - Base of the integer

 *              width               - Field width

 *              precision           - Precision of the integer

 *              type                - Special printing flags

 *

 * RETURN:      Updated position for next valid character

 *

 * DESCRIPTION: Print an integer into a string with any base and any precision.

 *

 Parameter validation */

 Calculate size according to sign and prefix */

 Generate full string in reverse order */

 Printing 100 using %2d gives "100", not "00" */

 Output the string */

/*******************************************************************************

 *

 * FUNCTION:    vsnprintf

 *

 * PARAMETERS:  string              - String with boundary

 *              size                - Boundary of the string

 *              format              - Standard printf format

 *              args                - Argument list

 *

 * RETURN:      Number of bytes actually written.

 *

 * DESCRIPTION: Formatted output to a string using argument list pointer.

 *

 Process sign */

 Process width */

 Process precision */

 Process qualifier */

/*******************************************************************************

 *

 * FUNCTION:    snprintf

 *

 * PARAMETERS:  string              - String with boundary

 *              size                - Boundary of the string

 *              Format, ...         - Standard printf format

 *

 * RETURN:      Number of bytes actually written.

 *

 * DESCRIPTION: Formatted output to a string.

 *

/*******************************************************************************

 *

 * FUNCTION:    sprintf

 *

 * PARAMETERS:  string              - String with boundary

 *              Format, ...         - Standard printf format

 *

 * RETURN:      Number of bytes actually written.

 *

 * DESCRIPTION: Formatted output to a string.

 *

/*******************************************************************************

 *

 * FUNCTION:    vprintf

 *

 * PARAMETERS:  format              - Standard printf format

 *              args                - Argument list

 *

 * RETURN:      Number of bytes actually written.

 *

 * DESCRIPTION: Formatted output to stdout using argument list pointer.

 *

/*******************************************************************************

 *

 * FUNCTION:    printf

 *

 * PARAMETERS:  Format, ...         - Standard printf format

 *

 * RETURN:      Number of bytes actually written.

 *

 * DESCRIPTION: Formatted output to stdout.

 *

/*******************************************************************************

 *

 * FUNCTION:    vfprintf

 *

 * PARAMETERS:  file                - File descriptor

 *              format              - Standard printf format

 *              args                - Argument list

 *

 * RETURN:      Number of bytes actually written.

 *

 * DESCRIPTION: Formatted output to a file using argument list pointer.

 *

/*******************************************************************************

 *

 * FUNCTION:    fprintf

 *

 * PARAMETERS:  file                - File descriptor

 *              Format, ...         - Standard printf format

 *

 * RETURN:      Number of bytes actually written.

 *

 * DESCRIPTION: Formatted output to a file.

 *

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: utcopy - Internal to external object translation utilities

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_copy_isimple_to_esimple

 *

 * PARAMETERS:  internal_object     - Source object to be copied

 *              external_object     - Where to return the copied object

 *              data_space          - Where object data is returned (such as

 *                                    buffer and string data)

 *              buffer_space_used   - Length of data_space that was used

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to copy a simple internal object to

 *              an external object.

 *

 *              The data_space buffer is assumed to have sufficient space for

 *              the object.

 *

	/*

	 * Check for NULL object case (could be an uninitialized

	 * package element)

 Always clear the external object */

	/*

	 * In general, the external object will be the same type as

	 * the internal object

 However, only a limited number of external types are supported */

 This is an object reference. */

			/*

			 * For namepath, return the object handle ("reference")

			 * We are referring to the namespace node

 All other reference types are unsupported */

		/*

		 * There is no corresponding external object type

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_copy_ielement_to_eelement

 *

 * PARAMETERS:  acpi_pkg_callback

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Copy one package element to another package element

 *

		/*

		 * This is a simple or null object

		/*

		 * Build the package object

		/*

		 * Pass the new package object back to the package walk routine

		/*

		 * Save space for the array of objects (Package elements)

		 * update the buffer length counter

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_copy_ipackage_to_epackage

 *

 * PARAMETERS:  internal_object     - Pointer to the object we are returning

 *              buffer              - Where the object is returned

 *              space_used          - Where the object length is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to place a package object in a user

 *              buffer. A package object by definition contains other objects.

 *

 *              The buffer is assumed to have sufficient space for the object.

 *              The caller must have verified the buffer length needed using

 *              the acpi_ut_get_object_size function before calling this function.

 *

	/*

	 * First package at head of the buffer

	/*

	 * Free space begins right after the first package

	/*

	 * Leave room for an array of ACPI_OBJECTS in the buffer

	 * and move the free space past it

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_copy_iobject_to_eobject

 *

 * PARAMETERS:  internal_object     - The internal object to be converted

 *              ret_buffer          - Where the object is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to build an API object to be returned

 *              to the caller.

 *

		/*

		 * Package object:  Copy all subobjects (including

		 * nested packages)

		/*

		 * Build a simple object (no nested objects)

		/*

		 * build simple does not include the object size in the length

		 * so we add it in here

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_copy_esimple_to_isimple

 *

 * PARAMETERS:  external_object     - The external object to be converted

 *              ret_internal_object - Where the internal object is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function copies an external object to an internal one.

 *              NOTE: Pointers can be copied, we don't need to copy data.

 *              (The pointers have to be valid in our address space no matter

 *              what we do with them!)

 *

	/*

	 * Simple types supported are: String, Buffer, Integer

 This is the case for a NULL object */

 All other types are not supported */

 Must COPY string and buffer contents */

 Mark buffer data valid */

 An incoming reference is defined to be a namespace node */

 Other types can't get here */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_copy_epackage_to_ipackage

 *

 * PARAMETERS:  external_object     - The external object to be converted

 *              internal_object     - Where the internal object is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Copy an external package object to an internal package.

 *              Handles nested packages.

 *

 Create the package object */

	/*

	 * Recursive implementation. Probably ok, since nested external

	 * packages as parameters should be very rare.

 Truncate package and delete it */

 Mark package data valid */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_copy_eobject_to_iobject

 *

 * PARAMETERS:  external_object     - The external object to be converted

 *              internal_object     - Where the internal object is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Converts an external object to an internal object.

 *

		/*

		 * Build a simple object (no nested objects)

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_copy_simple_object

 *

 * PARAMETERS:  source_desc         - The internal object to be copied

 *              dest_desc           - New target object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Simple copy of one internal object to another. Reference count

 *              of the destination object is preserved.

 *

 Save fields from destination that we don't want to overwrite */

	/*

	 * Copy the entire source object over the destination object.

	 * Note: Source can be either an operand object or namespace node.

 Restore the saved fields */

 New object is not static, regardless of source */

 Handle the objects with extra data */

		/*

		 * Allocate and copy the actual buffer if and only if:

		 * 1) There is a valid buffer pointer

		 * 2) The buffer has a length > 0

 Copy the actual buffer data */

		/*

		 * Allocate and copy the actual string if and only if:

		 * 1) There is a valid string pointer

		 * (Pointer to a NULL string is allowed)

 Copy the actual string data */

		/*

		 * We copied the reference object, so we now must add a reference

		 * to the object pointed to by the reference

		 *

		 * DDBHandle reference (from Load/load_table) is a special reference,

		 * it does not have a Reference.Object, so does not need to

		 * increase the reference count

		/*

		 * We copied the Region Handler, so we now must add a reference

		/*

		 * For Mutex and Event objects, we cannot simply copy the underlying

		 * OS object. We must create a new one.

 Nothing to do for other simple objects */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_copy_ielement_to_ielement

 *

 * PARAMETERS:  acpi_pkg_callback

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Copy one package element to another package element

 *

 A null source object indicates a (legal) null package element */

			/*

			 * This is a simple object, just copy it

 Pass through a null element */

		/*

		 * This object is a package - go down another nesting level

		 * Create and build the package object

 Pass the new package object back to the package walk routine */

 Store the object pointer in the parent package object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_copy_ipackage_to_ipackage

 *

 * PARAMETERS:  source_obj      - Pointer to the source package object

 *              dest_obj        - Where the internal object is returned

 *              walk_state      - Current Walk state descriptor

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to copy an internal package object

 *              into another internal package object.

 *

	/*

	 * Create the object array and walk the source package tree

	/*

	 * Copy the package element-by-element by walking the package "tree".

	 * This handles nested packages of arbitrary depth.

 On failure, delete the destination package object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_copy_iobject_to_iobject

 *

 * PARAMETERS:  source_desc         - The internal object to be copied

 *              dest_desc           - Where the copied object is returned

 *              walk_state          - Current walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Copy an internal object to a new internal object

 *

 Create the top level object */

 Copy the object and possible subobjects */

 Delete the allocated object if copy failed */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: nsxfname - Public interfaces to the ACPI subsystem

 *                         ACPI Namespace oriented interfaces

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/******************************************************************************

 *

 * FUNCTION:    acpi_get_handle

 *

 * PARAMETERS:  parent          - Object to search under (search scope).

 *              pathname        - Pointer to an asciiz string containing the

 *                                name

 *              ret_handle      - Where the return handle is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This routine will search for a caller specified name in the

 *              name space. The caller can restrict the search region by

 *              specifying a non NULL parent. The parent value is itself a

 *              namespace handle.

 *

 Parameter Validation */

 Convert a parent handle to a prefix node */

	/*

	 * Valid cases are:

	 * 1) Fully qualified pathname

	 * 2) Parent + Relative pathname

	 *

	 * Error for <null Parent + relative path>

 Pathname is fully qualified (starts with '\') */

 Special case for root-only, since we can't search for it */

 Relative path with null prefix is disallowed */

 Find the Node and convert to a handle */

/******************************************************************************

 *

 * FUNCTION:    acpi_get_name

 *

 * PARAMETERS:  handle          - Handle to be converted to a pathname

 *              name_type       - Full pathname or single segment

 *              buffer          - Buffer for returned path

 *

 * RETURN:      Pointer to a string containing the fully qualified Name.

 *

 * DESCRIPTION: This routine returns the fully qualified name associated with

 *              the Handle parameter. This and the acpi_pathname_to_handle are

 *              complementary functions.

 *

 Parameter validation */

	/*

	 * Wants the single segment ACPI name.

	 * Validate handle and convert to a namespace Node

 Get the full pathname (From the namespace root) */

 Get the single name */

/******************************************************************************

 *

 * FUNCTION:    acpi_ns_copy_device_id

 *

 * PARAMETERS:  dest                - Pointer to the destination PNP_DEVICE_ID

 *              source              - Pointer to the source PNP_DEVICE_ID

 *              string_area         - Pointer to where to copy the dest string

 *

 * RETURN:      Pointer to the next string area

 *

 * DESCRIPTION: Copy a single PNP_DEVICE_ID, including the string data.

 *

 Create the destination PNP_DEVICE_ID */

 Copy actual string and return a pointer to the next string area */

/******************************************************************************

 *

 * FUNCTION:    acpi_get_object_info

 *

 * PARAMETERS:  handle              - Object Handle

 *              return_buffer       - Where the info is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Returns information about an object as gleaned from the

 *              namespace node and possibly by running several standard

 *              control methods (Such as in the case of a device.)

 *

 * For Device and Processor objects, run the Device _HID, _UID, _CID,

 * _CLS, _ADR, _sx_w, and _sx_d methods.

 *

 * Note: Allocates the return buffer, must be freed by the caller.

 *

 * Note: This interface is intended to be used during the initial device

 * discovery namespace traversal. Therefore, no complex methods can be

 * executed, especially those that access operation regions. Therefore, do

 * not add any additional methods that could cause problems in this area.

 * Because of this reason support for the following methods has been removed:

 * 1) _SUB method was removed (11/2015)

 * 2) _STA method was removed (02/2018)

 *

 Parameter validation */

 Get the namespace node data while the namespace is locked */

		/*

		 * Get extra info for ACPI Device/Processor objects only:

		 * Run the Device _HID, _UID, _CLS, and _CID methods.

		 *

		 * Note: none of these methods are required, so they may or may

		 * not be present for this device. The Info->Valid bitfield is used

		 * to indicate which methods were found and run successfully.

 Execute the Device._HID method */

 Execute the Device._UID method */

 Execute the Device._CID method */

 Add size of CID strings and CID pointer array */

 Execute the Device._CLS method */

	/*

	 * Now that we have the variable-length data, we can allocate the

	 * return buffer

 Get the fixed-length data */

		/*

		 * Get extra info for ACPI Device/Processor objects only:

		 * Run the _ADR and, sx_w, and _sx_d methods.

		 *

		 * Notes: none of these methods are required, so they may or may

		 * not be present for this device. The Info->Valid bitfield is used

		 * to indicate which methods were found and run successfully.

 Execute the Device._ADR method */

 Execute the Device._sx_w methods */

 Execute the Device._sx_d methods */

	/*

	 * Create a pointer to the string area of the return buffer.

	 * Point to the end of the base struct acpi_device_info structure.

 Point past the CID PNP_DEVICE_ID array */

	/*

	 * Copy the HID, UID, and CIDs to the return buffer. The variable-length

	 * strings are copied to the reserved area at the end of the buffer.

	 *

	 * For HID and CID, check if the ID is a PCI Root Bridge.

 Copy each CID */

 Copy the fixed-length data */

/******************************************************************************

 *

 * FUNCTION:    acpi_install_method

 *

 * PARAMETERS:  buffer         - An ACPI table containing one control method

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Install a control method into the namespace. If the method

 *              name already exists in the namespace, it is overwritten. The

 *              input buffer must contain a valid DSDT or SSDT containing a

 *              single control method.

 *

 Parameter validation */

 Table must be a DSDT or SSDT */

 First AML opcode in the table must be a control method */

 Extract method information from the raw AML */

	/*

	 * Allocate resources up-front. We don't want to have to delete a new

	 * node from the namespace if we cannot allocate memory.

 Lock namespace for acpi_ns_lookup, we may be creating a new node */

 The lookup either returns an existing node or creates a new one */

 ns_lookup */

 Node existed previously, make sure it is a method node */

 Copy the method AML to the local buffer */

 Initialize the method object with the new method's information */

	/*

	 * Now that it is complete, we can attach the new method object to

	 * the method Node (detaches/deletes any existing object)

	/*

	 * Flag indicates AML buffer is dynamic, must be deleted later.

	 * Must be set only after attach above.

 Remove local reference to the method object */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: rsdumpinfo - Tables used to display resource descriptors.

 *

/*******************************************************************************

 *

 * Resource Descriptor info tables

 *

 * Note: The first table entry must be a Title or Literal and must contain

 * the table length (number of table entries)

 *

/*

 * Tables used for common address descriptor flag fields

/*

 * Table used to dump _PRT contents

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: rsutils - Utilities for the resource manager

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_decode_bitmask

 *

 * PARAMETERS:  mask            - Bitmask to decode

 *              list            - Where the converted list is returned

 *

 * RETURN:      Count of bits set (length of list)

 *

 * DESCRIPTION: Convert a bit mask into a list of values

 *

 Decode the mask bits */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_encode_bitmask

 *

 * PARAMETERS:  list            - List of values to encode

 *              count           - Length of list

 *

 * RETURN:      Encoded bitmask

 *

 * DESCRIPTION: Convert a list of values to an encoded bitmask

 *

 Encode the list into a single bitmask */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_move_data

 *

 * PARAMETERS:  destination         - Pointer to the destination descriptor

 *              source              - Pointer to the source descriptor

 *              item_count          - How many items to move

 *              move_type           - Byte width

 *

 * RETURN:      None

 *

 * DESCRIPTION: Move multiple data items from one descriptor to another. Handles

 *              alignment issues and endian issues if necessary, as configured

 *              via the ACPI_MOVE_* macros. (This is why a memcpy is not used)

 *

 One move per item */

			/*

			 * For the 8-bit case, we can perform the move all at once

			 * since there are no alignment or endian issues

			/*

			 * 16-, 32-, and 64-bit cases must use the move macros that perform

			 * endian conversion and/or accommodate hardware that cannot perform

			 * misaligned memory transfers

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_set_resource_length

 *

 * PARAMETERS:  total_length        - Length of the AML descriptor, including

 *                                    the header and length fields.

 *              aml                 - Pointer to the raw AML descriptor

 *

 * RETURN:      None

 *

 * DESCRIPTION: Set the resource_length field of an AML

 *              resource descriptor, both Large and Small descriptors are

 *              supported automatically. Note: Descriptor Type field must

 *              be valid.

 *

 Length is the total descriptor length minus the header length */

 Length is stored differently for large and small descriptors */

 Large descriptor -- bytes 1-2 contain the 16-bit length */

		/*

		 * Small descriptor -- bits 2:0 of byte 0 contain the length

		 * Clear any existing length, preserving descriptor type bits

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_set_resource_header

 *

 * PARAMETERS:  descriptor_type     - Byte to be inserted as the type

 *              total_length        - Length of the AML descriptor, including

 *                                    the header and length fields.

 *              aml                 - Pointer to the raw AML descriptor

 *

 * RETURN:      None

 *

 * DESCRIPTION: Set the descriptor_type and resource_length fields of an AML

 *              resource descriptor, both Large and Small descriptors are

 *              supported automatically

 *

 Set the Resource Type */

 Set the Resource Length */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_strcpy

 *

 * PARAMETERS:  destination         - Pointer to the destination string

 *              source              - Pointer to the source string

 *

 * RETURN:      String length, including NULL terminator

 *

 * DESCRIPTION: Local string copy that returns the string length, saving a

 *              strcpy followed by a strlen.

 *

 Return string length including the NULL terminator */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_get_resource_source

 *

 * PARAMETERS:  resource_length     - Length field of the descriptor

 *              minimum_length      - Minimum length of the descriptor (minus

 *                                    any optional fields)

 *              resource_source     - Where the resource_source is returned

 *              aml                 - Pointer to the raw AML descriptor

 *              string_ptr          - (optional) where to store the actual

 *                                    resource_source string

 *

 * RETURN:      Length of the string plus NULL terminator, rounded up to native

 *              word boundary

 *

 * DESCRIPTION: Copy the optional resource_source data from a raw AML descriptor

 *              to an internal resource descriptor

 *

	/*

	 * resource_source is present if the length of the descriptor is longer

	 * than the minimum length.

	 *

	 * Note: Some resource descriptors will have an additional null, so

	 * we add 1 to the minimum length.

 Get the resource_source_index */

			/*

			 * String destination pointer is not specified; Set the String

			 * pointer to the end of the current resource_source structure.

		/*

		 * In order for the Resource length to be a multiple of the native

		 * word, calculate the length of the string (+1 for NULL terminator)

		 * and expand to the next word multiple.

		 *

		 * Zero the entire area of the buffer.

 Copy the resource_source string to the destination */

 resource_source is not present */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_set_resource_source

 *

 * PARAMETERS:  aml                 - Pointer to the raw AML descriptor

 *              minimum_length      - Minimum length of the descriptor (minus

 *                                    any optional fields)

 *              resource_source     - Internal resource_source



 *

 * RETURN:      Total length of the AML descriptor

 *

 * DESCRIPTION: Convert an optional resource_source from internal format to a

 *              raw AML resource descriptor

 *

 Non-zero string length indicates presence of a resource_source */

 Point to the end of the AML descriptor */

 Copy the resource_source_index */

 Copy the resource_source string */

		/*

		 * Add the length of the string (+ 1 for null terminator) to the

		 * final descriptor length

 Return the new total length of the AML descriptor */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_get_prt_method_data

 *

 * PARAMETERS:  node            - Device node

 *              ret_buffer      - Pointer to a buffer structure for the

 *                                results

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to get the _PRT value of an object

 *              contained in an object specified by the handle passed in

 *

 *              If the function fails an appropriate status will be returned

 *              and the contents of the callers buffer is undefined.

 *

 Parameters guaranteed valid by caller */

 Execute the method, no parameters */

	/*

	 * Create a resource linked list from the byte stream buffer that comes

	 * back from the _CRS method execution.

 On exit, we must delete the object returned by evaluate_object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_get_crs_method_data

 *

 * PARAMETERS:  node            - Device node

 *              ret_buffer      - Pointer to a buffer structure for the

 *                                results

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to get the _CRS value of an object

 *              contained in an object specified by the handle passed in

 *

 *              If the function fails an appropriate status will be returned

 *              and the contents of the callers buffer is undefined.

 *

 Parameters guaranteed valid by caller */

 Execute the method, no parameters */

	/*

	 * Make the call to create a resource linked list from the

	 * byte stream buffer that comes back from the _CRS method

	 * execution.

 On exit, we must delete the object returned by evaluateObject */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_get_prs_method_data

 *

 * PARAMETERS:  node            - Device node

 *              ret_buffer      - Pointer to a buffer structure for the

 *                                results

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to get the _PRS value of an object

 *              contained in an object specified by the handle passed in

 *

 *              If the function fails an appropriate status will be returned

 *              and the contents of the callers buffer is undefined.

 *

 Parameters guaranteed valid by caller */

 Execute the method, no parameters */

	/*

	 * Make the call to create a resource linked list from the

	 * byte stream buffer that comes back from the _CRS method

	 * execution.

 On exit, we must delete the object returned by evaluateObject */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_get_aei_method_data

 *

 * PARAMETERS:  node            - Device node

 *              ret_buffer      - Pointer to a buffer structure for the

 *                                results

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to get the _AEI value of an object

 *              contained in an object specified by the handle passed in

 *

 *              If the function fails an appropriate status will be returned

 *              and the contents of the callers buffer is undefined.

 *

 Parameters guaranteed valid by caller */

 Execute the method, no parameters */

	/*

	 * Make the call to create a resource linked list from the

	 * byte stream buffer that comes back from the _CRS method

	 * execution.

 On exit, we must delete the object returned by evaluateObject */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_get_method_data

 *

 * PARAMETERS:  handle          - Handle to the containing object

 *              path            - Path to method, relative to Handle

 *              ret_buffer      - Pointer to a buffer structure for the

 *                                results

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to get the _CRS or _PRS value of an

 *              object contained in an object specified by the handle passed in

 *

 *              If the function fails an appropriate status will be returned

 *              and the contents of the callers buffer is undefined.

 *

 Parameters guaranteed valid by caller */

 Execute the method, no parameters */

	/*

	 * Make the call to create a resource linked list from the

	 * byte stream buffer that comes back from the method

	 * execution.

 On exit, we must delete the object returned by evaluate_object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_set_srs_method_data

 *

 * PARAMETERS:  node            - Device node

 *              in_buffer       - Pointer to a buffer structure of the

 *                                parameter

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to set the _SRS of an object contained

 *              in an object specified by the handle passed in

 *

 *              If the function fails an appropriate status will be returned

 *              and the contents of the callers buffer is undefined.

 *

 * Note: Parameters guaranteed valid by caller

 *

 Allocate and initialize the evaluation information block */

	/*

	 * The in_buffer parameter will point to a linked list of

	 * resource parameters. It needs to be formatted into a

	 * byte stream to be sent in as an input parameter to _SRS

	 *

	 * Convert the linked list into a byte stream

 Create and initialize the method parameter object */

		/*

		 * Must free the buffer allocated above (otherwise it is freed

		 * later)

 Execute the method, no return value is expected */

 Clean up and return the status from acpi_ns_evaluate */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: evgpe - General Purpose Event handling and dispatch

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Entire module */

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_update_gpe_enable_mask

 *

 * PARAMETERS:  gpe_event_info          - GPE to update

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Updates GPE register enable mask based upon whether there are

 *              runtime references to this GPE

 *

 Clear the run bit up front */

 Set the mask bit only if there are references to this GPE */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_enable_gpe

 *

 * PARAMETERS:  gpe_event_info          - GPE to enable

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Enable a GPE.

 *

 Enable the requested GPE */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_mask_gpe

 *

 * PARAMETERS:  gpe_event_info          - GPE to be blocked/unblocked

 *              is_masked               - Whether the GPE is masked or not

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Unconditionally mask/unmask a GPE during runtime.

 *

 Perform the action */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_add_gpe_reference

 *

 * PARAMETERS:  gpe_event_info          - Add a reference to this GPE

 *              clear_on_enable         - Clear GPE status before enabling it

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Add a reference to a GPE. On the first reference, the GPE is

 *              hardware-enabled.

 *

 Enable on first reference */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_remove_gpe_reference

 *

 * PARAMETERS:  gpe_event_info          - Remove a reference to this GPE

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Remove a reference to a GPE. When the last reference is

 *              removed, the GPE is hardware-disabled.

 *

 Disable on last reference */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_low_get_gpe_info

 *

 * PARAMETERS:  gpe_number          - Raw GPE number

 *              gpe_block           - A GPE info block

 *

 * RETURN:      A GPE event_info struct. NULL if not a valid GPE (The gpe_number

 *              is not within the specified GPE block)

 *

 * DESCRIPTION: Returns the event_info struct associated with this GPE. This is

 *              the low-level implementation of ev_get_gpe_event_info.

 *

	/*

	 * Validate that the gpe_number is within the specified gpe_block.

	 * (Two steps)

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_get_gpe_event_info

 *

 * PARAMETERS:  gpe_device          - Device node. NULL for GPE0/GPE1

 *              gpe_number          - Raw GPE number

 *

 * RETURN:      A GPE event_info struct. NULL if not a valid GPE

 *

 * DESCRIPTION: Returns the event_info struct associated with this GPE.

 *              Validates the gpe_block and the gpe_number

 *

 *              Should be called only when the GPE lists are semaphore locked

 *              and not subject to change.

 *

 A NULL gpe_device means use the FADT-defined GPE block(s) */

 Examine GPE Block 0 and 1 (These blocks are permanent) */

 The gpe_number was not in the range of either FADT GPE block */

 A Non-NULL gpe_device means this is a GPE Block Device */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_gpe_detect

 *

 * PARAMETERS:  gpe_xrupt_list      - Interrupt block for this interrupt.

 *                                    Can have multiple GPE blocks attached.

 *

 * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED

 *

 * DESCRIPTION: Detect if any GP events have occurred. This function is

 *              executed at interrupt level.

 *

 Check for the case where there are no GPEs */

	/*

	 * We need to obtain the GPE lock for both the data structs and registers

	 * Note: Not necessary to obtain the hardware lock, since the GPE

	 * registers are owned by the gpe_lock.

 Examine all GPE blocks attached to this interrupt level */

		/*

		 * Read all of the 8-bit GPE status and enable registers in this GPE

		 * block, saving all of them. Find all currently active GP events.

 Get the next status/enable pair */

			/*

			 * Optimization: If there are no GPEs enabled within this

			 * register, we can safely ignore the entire register.

 Now look at the individual GPEs in this byte register */

 Detect and dispatch one GPE bit */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_asynch_execute_gpe_method

 *

 * PARAMETERS:  Context (gpe_event_info) - Info for this GPE

 *

 * RETURN:      None

 *

 * DESCRIPTION: Perform the actual execution of a GPE control method. This

 *              function is called from an invocation of acpi_os_execute and

 *              therefore does NOT execute at interrupt level - so that

 *              the control method itself is not executed in the context of

 *              an interrupt handler.

 *

 Do the correct dispatch - normal method or implicit notify */

		/*

		 * Implicit notify.

		 * Dispatch a DEVICE_WAKE notify to the appropriate handler.

		 * NOTE: the request is queued for execution after this method

		 * completes. The notify handlers are NOT invoked synchronously

		 * from this thread -- because handlers may in turn run other

		 * control methods.

		 *

		 * June 2012: Expand implicit notify mechanism to support

		 * notifies on multiple device objects.

 Allocate the evaluation information block */

			/*

			 * Invoke the GPE Method (_Lxx, _Exx) i.e., evaluate the

			 * _Lxx/_Exx control method that corresponds to this GPE

 Should never happen */

 Defer enabling of GPE until all notify handlers are done */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_asynch_enable_gpe

 *

 * PARAMETERS:  Context (gpe_event_info) - Info for this GPE

 *              Callback from acpi_os_execute

 *

 * RETURN:      None

 *

 * DESCRIPTION: Asynchronous clear/enable for GPE. This allows the GPE to

 *              complete (i.e., finish execution of Notify)

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_finish_gpe

 *

 * PARAMETERS:  gpe_event_info      - Info for this GPE

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Clear/Enable a GPE. Common code that is used after execution

 *              of a GPE method or a synchronous or asynchronous GPE handler.

 *

		/*

		 * GPE is level-triggered, we clear the GPE status bit after

		 * handling the event.

	/*

	 * Enable this GPE, conditionally. This means that the GPE will

	 * only be physically enabled if the enable_mask bit is set

	 * in the event_info.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_detect_gpe

 *

 * PARAMETERS:  gpe_device          - Device node. NULL for GPE0/GPE1

 *              gpe_event_info      - Info for this GPE

 *              gpe_number          - Number relative to the parent GPE block

 *

 * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED

 *

 * DESCRIPTION: Detect and dispatch a General Purpose Event to either a function

 *              (e.g. EC) or method (e.g. _Lxx/_Exx) handler.

 * NOTE:        GPE is W1C, so it is possible to handle a single GPE from both

 *              task and irq context in parallel as long as the process to

 *              detect and mask the GPE is atomic.

 *              However the atomicity of ACPI_GPE_DISPATCH_RAW_HANDLER is

 *              dependent on the raw handler itself.

 *

 Get the info block for the entire GPE register */

 Get the register bitmask for this GPE */

 GPE currently enabled (enable bit == 1)? */

 GPE currently active (status bit == 1)? */

 Check if there is anything active at all in this GPE */

 Invoke global event handler if present */

 Found an active GPE */

 Dispatch the event to a raw handler */

		/*

		 * There is no protection around the namespace node

		 * and the GPE handler to ensure a safe destruction

		 * because:

		 * 1. The namespace node is expected to always

		 *    exist after loading a table.

		 * 2. The GPE handler is expected to be flushed by

		 *    acpi_os_wait_events_complete() before the

		 *    destruction.

 Dispatch the event to a standard handler or method. */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_gpe_dispatch

 *

 * PARAMETERS:  gpe_device          - Device node. NULL for GPE0/GPE1

 *              gpe_event_info      - Info for this GPE

 *              gpe_number          - Number relative to the parent GPE block

 *

 * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED

 *

 * DESCRIPTION: Dispatch a General Purpose Event to either a function (e.g. EC)

 *              or method (e.g. _Lxx/_Exx) handler.

 *

	/*

	 * Always disable the GPE so that it does not keep firing before

	 * any asynchronous activity completes (either from the execution

	 * of a GPE method or an asynchronous GPE handler.)

	 *

	 * If there is no handler or method to run, just disable the

	 * GPE and leave it disabled permanently to prevent further such

	 * pointless events from firing.

	/*

	 * If edge-triggered, clear the GPE status bit now. Note that

	 * level-triggered events are cleared after the GPE is serviced.

	/*

	 * Dispatch the GPE to either an installed handler or the control

	 * method associated with this GPE (_Lxx or _Exx). If a handler

	 * exists, we invoke it and do not attempt to run the method.

	 * If there is neither a handler nor a method, leave the GPE

	 * disabled.

 Invoke the installed handler (at interrupt level) */

 If requested, clear (if level-triggered) and re-enable the GPE */

		/*

		 * Execute the method associated with the GPE

		 * NOTE: Level-triggered GPEs are cleared after the method completes.

		/*

		 * No handler or method to run!

		 * 03/2010: This case should no longer be possible. We will not allow

		 * a GPE to be enabled if it has no handler or method.

 !ACPI_REDUCED_HARDWARE */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: utnonansi - Non-ansi C library functions

 *

/*

 * Non-ANSI C library functions - strlwr, strupr, stricmp, and "safe"

 * string functions.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_strlwr (strlwr)

 *

 * PARAMETERS:  src_string      - The source string to convert

 *

 * RETURN:      None

 *

 * DESCRIPTION: Convert a string to lowercase

 *

 Walk entire string, lowercasing the letters */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_strupr (strupr)

 *

 * PARAMETERS:  src_string      - The source string to convert

 *

 * RETURN:      None

 *

 * DESCRIPTION: Convert a string to uppercase

 *

 Walk entire string, uppercasing the letters */

/******************************************************************************

 *

 * FUNCTION:    acpi_ut_stricmp (stricmp)

 *

 * PARAMETERS:  string1             - first string to compare

 *              string2             - second string to compare

 *

 * RETURN:      int that signifies string relationship. Zero means strings

 *              are equal.

 *

 * DESCRIPTION: Case-insensitive string compare. Implementation of the

 *              non-ANSI stricmp function.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_safe_strcpy, acpi_ut_safe_strcat, acpi_ut_safe_strncat

 *

 * PARAMETERS:  Adds a "DestSize" parameter to each of the standard string

 *              functions. This is the size of the Destination buffer.

 *

 * RETURN:      TRUE if the operation would overflow the destination buffer.

 *

 * DESCRIPTION: Safe versions of standard Clib string functions. Ensure that

 *              the result of the operation will not overflow the output string

 *              buffer.

 *

 * NOTE:        These functions are typically only helpful for processing

 *              user input and command lines. For most ACPICA code, the

 *              required buffer length is precisely calculated before buffer

 *              allocation, so the use of these functions is unnecessary.

 *

 Always terminate destination string */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: psscope - Parser scope stack management routines

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_get_parent_scope

 *

 * PARAMETERS:  parser_state        - Current parser state object

 *

 * RETURN:      Pointer to an Op object

 *

 * DESCRIPTION: Get parent of current op being parsed

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_has_completed_scope

 *

 * PARAMETERS:  parser_state        - Current parser state object

 *

 * RETURN:      Boolean, TRUE = scope completed.

 *

 * DESCRIPTION: Is parsing of current argument complete?  Determined by

 *              1) AML pointer is at or beyond the end of the scope

 *              2) The scope argument count has reached zero.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_init_scope

 *

 * PARAMETERS:  parser_state        - Current parser state object

 *              root                - the Root Node of this new scope

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Allocate and init a new scope object

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_push_scope

 *

 * PARAMETERS:  parser_state        - Current parser state object

 *              op                  - Current op to be pushed

 *              remaining_args      - List of args remaining

 *              arg_count           - Fixed or variable number of args

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Push current op to begin parsing its argument

 *

 Push onto scope stack */

 Multiple arguments */

 Single argument */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_pop_scope

 *

 * PARAMETERS:  parser_state        - Current parser state object

 *              op                  - Where the popped op is returned

 *              arg_list            - Where the popped "next argument" is

 *                                    returned

 *              arg_count           - Count of objects in arg_list

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Return to parsing a previous op

 *

 Only pop the scope if there is in fact a next scope */

 Return to parsing previous op */

 All done with this scope state structure */

 Empty parse stack, prepare to fetch next opcode */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_cleanup_scope

 *

 * PARAMETERS:  parser_state        - Current parser state object

 *

 * RETURN:      None

 *

 * DESCRIPTION: Destroy available list, remaining stack levels, and return

 *              root scope

 *

 Delete anything on the scope stack */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: rsirq - IRQ resource descriptors

 *

/*******************************************************************************

 *

 * acpi_rs_get_irq

 *

 Get the IRQ mask (bytes 1:2) */

 Set default flags (others are zero) */

 Get the descriptor length (2 or 3 for IRQ descriptor) */

 All done if no flag byte present in descriptor */

 Get flags: Triggering[0], Polarity[3], Sharing[4], Wake[5] */

/*******************************************************************************

 *

 * acpi_rs_set_irq

 *

 Start with a default descriptor of length 3 */

 Convert interrupt list to 16-bit IRQ bitmask */

 Set flags: Triggering[0], Polarity[3], Sharing[4], Wake[5] */

	/*

	 * All done if the output descriptor length is required to be 3

	 * (i.e., optimization to 2 bytes cannot be attempted)

 Set length to 2 bytes (no flags byte) */

	/*

	 * All done if the output descriptor length is required to be 2.

	 *

	 * TBD: Perhaps we should check for error if input flags are not

	 * compatible with a 2-byte descriptor.

 Reset length to 3 bytes (descriptor with flags byte) */

	/*

	 * Check if the flags byte is necessary. Not needed if the flags are:

	 * ACPI_EDGE_SENSITIVE, ACPI_ACTIVE_HIGH, ACPI_EXCLUSIVE

 We can optimize to a 2-byte irq_no_flags() descriptor */

/*******************************************************************************

 *

 * acpi_rs_convert_ext_irq

 *

	/*

	 * Flags: Producer/Consumer[0], Triggering[1], Polarity[2],

	 *        Sharing[3], Wake[4]

 IRQ Table length (Byte4) */

 Copy every IRQ in the table, each is 32 bits */

 Optional resource_source (Index and String) */

/*******************************************************************************

 *

 * acpi_rs_convert_dma

 *

 Flags: transfer preference, bus mastering, channel speed */

 DMA channel mask bits */

/*******************************************************************************

 *

 * acpi_rs_convert_fixed_dma

 *

	/*

	 * These fields are contiguous in both the source and destination:

	 * request_lines

	 * Channels

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exutils - interpreter/scanner utilities

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*

 * DEFINE_AML_GLOBALS is tested in amlcode.h

 * to determine whether certain global names should be "defined" or only

 * "declared" in the current compilation. This enhances maintainability

 * by enabling a single header file to embody all knowledge of the names

 * in question.

 *

 * Exactly one module of any executable should #define DEFINE_GLOBALS

 * before #including the header files which use this convention. The

 * names in question will be defined and initialized in that module,

 * and declared as extern in all other modules which #include those

 * header files.

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_enter_interpreter

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Enter the interpreter execution region. Failure to enter

 *              the interpreter region is a fatal system error. Used in

 *              conjunction with exit_interpreter.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_exit_interpreter

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Exit the interpreter execution region. This is the top level

 *              routine used to exit the interpreter when all processing has

 *              been completed, or when the method blocks.

 *

 * Cases where the interpreter is unlocked internally:

 *      1) Method will be blocked on a Sleep() AML opcode

 *      2) Method will be blocked on an Acquire() AML opcode

 *      3) Method will be blocked on a Wait() AML opcode

 *      4) Method will be blocked to acquire the global lock

 *      5) Method will be blocked waiting to execute a serialized control

 *          method that is currently executing

 *      6) About to invoke a user-installed opregion handler

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_truncate_for32bit_table

 *

 * PARAMETERS:  obj_desc        - Object to be truncated

 *

 * RETURN:      TRUE if a truncation was performed, FALSE otherwise.

 *

 * DESCRIPTION: Truncate an ACPI Integer to 32 bits if the execution mode is

 *              32-bit, as determined by the revision of the DSDT.

 *

	/*

	 * Object must be a valid number and we must be executing

	 * a control method. Object could be NS node for AML_INT_NAMEPATH_OP.

		/*

		 * We are executing in a 32-bit ACPI table. Truncate

		 * the value to 32 bits by zeroing out the upper 32-bit field

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_acquire_global_lock

 *

 * PARAMETERS:  field_flags           - Flags with Lock rule:

 *                                      always_lock or never_lock

 *

 * RETURN:      None

 *

 * DESCRIPTION: Obtain the ACPI hardware Global Lock, only if the field

 *              flags specify that it is to be obtained before field access.

 *

 Only use the lock if the always_lock bit is set */

 Attempt to get the global lock, wait forever */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_release_global_lock

 *

 * PARAMETERS:  field_flags           - Flags with Lock rule:

 *                                      always_lock or never_lock

 *

 * RETURN:      None

 *

 * DESCRIPTION: Release the ACPI hardware Global Lock

 *

 Only use the lock if the always_lock bit is set */

 Release the global lock */

 Report the error, but there isn't much else we can do */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_digits_needed

 *

 * PARAMETERS:  value           - Value to be represented

 *              base            - Base of representation

 *

 * RETURN:      The number of digits.

 *

 * DESCRIPTION: Calculate the number of digits needed to represent the Value

 *              in the given Base (Radix)

 *

 u64 is unsigned, so we don't worry about a '-' prefix */

 Count the digits in the requested base */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_eisa_id_to_string

 *

 * PARAMETERS:  out_string      - Where to put the converted string (8 bytes)

 *              compressed_id   - EISAID to be converted

 *

 * RETURN:      None

 *

 * DESCRIPTION: Convert a numeric EISAID to string representation. Return

 *              buffer must be large enough to hold the string. The string

 *              returned is always exactly of length ACPI_EISAID_STRING_SIZE

 *              (includes null terminator). The EISAID is always 32 bits.

 *

 The EISAID should be a 32-bit integer */

 Swap ID to big-endian to get contiguous bits */

 First 3 bytes are uppercase letters. Next 4 bytes are hexadecimal */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_integer_to_string

 *

 * PARAMETERS:  out_string      - Where to put the converted string. At least

 *                                21 bytes are needed to hold the largest

 *                                possible 64-bit integer.

 *              value           - Value to be converted

 *

 * RETURN:      Converted string in out_string

 *

 * DESCRIPTION: Convert a 64-bit integer to decimal string representation.

 *              Assumes string buffer is large enough to hold the string. The

 *              largest string is (ACPI_MAX64_DECIMAL_DIGITS + 1).

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_pci_cls_to_string

 *

 * PARAMETERS:  out_string      - Where to put the converted string (7 bytes)

 *              class_code      - PCI class code to be converted (3 bytes)

 *

 * RETURN:      Converted string in out_string

 *

 * DESCRIPTION: Convert 3-bytes PCI class code to string representation.

 *              Return buffer must be large enough to hold the string. The

 *              string returned is always exactly of length

 *              ACPI_PCICLS_STRING_SIZE (includes null terminator).

 *

 All 3 bytes are hexadecimal */

/*******************************************************************************

 *

 * FUNCTION:    acpi_is_valid_space_id

 *

 * PARAMETERS:  space_id            - ID to be validated

 *

 * RETURN:      TRUE if space_id is a valid/supported ID.

 *

 * DESCRIPTION: Validate an operation region space_ID.

 *

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: utresdecode - Resource descriptor keyword strings

 *

/*

 * Strings used to decode resource descriptors.

 * Used by both the disassembler and the debugger resource dump routines

 ACPI 5.0 */

 ACPI 5.0 */

 GPIO connection type */

 Serial bus type */

 UNKNOWN serial bus type */",

 I2C serial bus access mode */

 I2C serial bus slave mode */

 SPI serial bus wire mode */

 SPI serial clock phase */

 SPI serial bus clock polarity */

 SPI serial bus device polarity */

 UART serial bus endian */

 UART serial bus bits per byte */

 UNKNOWN Bits per byte */",

 UNKNOWN Bits per byte */",

 UNKNOWN Bits per byte */"

 UART serial bus stop bits */

 UART serial bus flow control */

 UNKNOWN flow control keyword */"

 UART serial bus parity type */

 UNKNOWN parity keyword */",

 UNKNOWN parity keyword */",

 UNKNOWN parity keyword */"

 pin_config type */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: utobject - ACPI object create/delete/size/cache routines

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_create_internal_object_dbg

 *

 * PARAMETERS:  module_name         - Source file name of caller

 *              line_number         - Line number of caller

 *              component_id        - Component type of caller

 *              type                - ACPI Type of the new object

 *

 * RETURN:      A new internal object, null on failure

 *

 * DESCRIPTION: Create and initialize a new internal object.

 *

 * NOTE:        We always allocate the worst-case object descriptor because

 *              these objects are cached, and we want them to be

 *              one-size-satisfies-any-request. This in itself may not be

 *              the most memory efficient, but the efficiency of the object

 *              cache should more than make up for this!

 *

 Allocate the raw object descriptor */

 These types require a secondary object */

 Link the second object to the first */

 All others have no secondary object */

 Save the object type in the object descriptor */

 Init the reference count */

 Any per-type initialization should go here */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_create_package_object

 *

 * PARAMETERS:  count               - Number of package elements

 *

 * RETURN:      Pointer to a new Package object, null on failure

 *

 * DESCRIPTION: Create a fully initialized package object

 *

 Create a new Package object */

	/*

	 * Create the element array. Count+1 allows the array to be null

	 * terminated.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_create_integer_object

 *

 * PARAMETERS:  initial_value       - Initial value for the integer

 *

 * RETURN:      Pointer to a new Integer object, null on failure

 *

 * DESCRIPTION: Create an initialized integer object

 *

 Create and initialize a new integer object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_create_buffer_object

 *

 * PARAMETERS:  buffer_size            - Size of buffer to be created

 *

 * RETURN:      Pointer to a new Buffer object, null on failure

 *

 * DESCRIPTION: Create a fully initialized buffer object

 *

 Create a new Buffer object */

 Create an actual buffer only if size > 0 */

 Allocate the actual buffer */

 Complete buffer object initialization */

 Return the new buffer descriptor */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_create_string_object

 *

 * PARAMETERS:  string_size         - Size of string to be created. Does not

 *                                    include NULL terminator, this is added

 *                                    automatically.

 *

 * RETURN:      Pointer to a new String object

 *

 * DESCRIPTION: Create a fully initialized string object

 *

 Create a new String object */

	/*

	 * Allocate the actual string buffer -- (Size + 1) for NULL terminator.

	 * NOTE: Zero-length strings are NULL terminated

 Complete string object initialization */

 Return the new string descriptor */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_valid_internal_object

 *

 * PARAMETERS:  object              - Object to be validated

 *

 * RETURN:      TRUE if object is valid, FALSE otherwise

 *

 * DESCRIPTION: Validate a pointer to be of type union acpi_operand_object

 *

 Check for a null pointer */

 Check the descriptor type field */

 The object appears to be a valid union acpi_operand_object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_allocate_object_desc_dbg

 *

 * PARAMETERS:  module_name         - Caller's module name (for error output)

 *              line_number         - Caller's line number (for error output)

 *              component_id        - Caller's component ID (for error output)

 *

 * RETURN:      Pointer to newly allocated object descriptor. Null on error

 *

 * DESCRIPTION: Allocate a new object descriptor. Gracefully handle

 *              error conditions.

 *

 Mark the descriptor type */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_delete_object_desc

 *

 * PARAMETERS:  object          - An Acpi internal object to be deleted

 *

 * RETURN:      None.

 *

 * DESCRIPTION: Free an ACPI object descriptor or add it to the object cache

 *

 Object must be of type union acpi_operand_object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_simple_object_size

 *

 * PARAMETERS:  internal_object    - An ACPI operand object

 *              obj_length         - Where the length is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to determine the space required to

 *              contain a simple object for return to an external user.

 *

 *              The length includes the object structure plus any additional

 *              needed space.

 *

 Start with the length of the (external) Acpi object */

 A NULL object is allowed, can be a legal uninitialized package element */

	/*

		 * Object is NULL, just return the length of union acpi_object

		 * (A NULL union acpi_object is an object of all zeroes.)

 A Namespace Node should never appear here */

 A namespace node should never get here */

	/*

	 * The final length depends on the object type

	 * Strings and Buffers are packed right up against the parent object and

	 * must be accessed bytewise or there may be alignment problems on

	 * certain processors

 No extra data for these types */

			/*

			 * Get the actual length of the full pathname to this object.

			 * The reference will be converted to the pathname to the object

			/*

			 * No other reference opcodes are supported.

			 * Notably, Locals and Args are not supported, but this may be

			 * required eventually.

	/*

	 * Account for the space required by the object rounded up to the next

	 * multiple of the machine word size. This keeps each object aligned

	 * on a machine word boundary. (preventing alignment faults on some

	 * machines.)

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_element_length

 *

 * PARAMETERS:  acpi_pkg_callback

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Get the length of one package element.

 *

		/*

		 * Simple object - just get the size (Null object/entry is handled

		 * here also) and sum it into the running package length

 Package object - nothing much to do here, let the walk handle it */

 No other types allowed */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_package_object_size

 *

 * PARAMETERS:  internal_object     - An ACPI internal object

 *              obj_length          - Where the length is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to determine the space required to

 *              contain a package object for return to an external user.

 *

 *              This is moderately complex since a package contains other

 *              objects including packages.

 *

	/*

	 * We have handled all of the objects in all levels of the package.

	 * just add the length of the package objects themselves.

	 * Round up to the next machine word.

 Return the total package length */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_object_size

 *

 * PARAMETERS:  internal_object     - An ACPI internal object

 *              obj_length          - Where the length will be returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to determine the space required to

 *              contain an object for return to an API user.

 *

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: dswexec - Dispatcher method execution callbacks;

 *                        dispatch to interpreter.

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*

 * Dispatch table for opcode classes

/*****************************************************************************

 *

 * FUNCTION:    acpi_ds_get_predicate_value

 *

 * PARAMETERS:  walk_state      - Current state of the parse tree walk

 *              result_obj      - if non-zero, pop result from result stack

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Get the result of a predicate evaluation

 *

	/*

	 * Result of predicate evaluation must be an Integer

	 * object. Implicitly convert the argument if necessary.

 Truncate the predicate to 32-bits if necessary */

	/*

	 * Save the result of the predicate evaluation on

	 * the control stack

		/*

		 * Predicate is FALSE, we will just toss the

		 * rest of the package

 Predicate can be used for an implicit return value */

 Break to debugger to display result */

	/*

	 * Delete the predicate result object (we know that

	 * we don't need it anymore)

/*****************************************************************************

 *

 * FUNCTION:    acpi_ds_exec_begin_op

 *

 * PARAMETERS:  walk_state      - Current state of the parse tree walk

 *              out_op          - Where to return op if a new one is created

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Descending callback used during the execution of control

 *              methods. This is where most operators and operands are

 *              dispatched to the interpreter.

 *

	/*

	 * If the previous opcode was a conditional, this opcode

	 * must be the beginning of the associated predicate.

	 * Save this knowledge in the current scope descriptor

 Save start of predicate */

 We want to send namepaths to the load code */

	/*

	 * Handle the opcode based upon the opcode type

			/*

			 * Found a named object declaration during method execution;

			 * we must enter this object into the namespace. The created

			 * object is temporary and will be deleted upon completion of

			 * the execution of this method.

			 *

			 * Note 10/2010: Except for the Scope() op. This opcode does

			 * not actually create a new object, it refers to an existing

			 * object. However, for Scope(), we want to indeed open a

			 * new scope.

 Nothing to do here during method execution */

/*****************************************************************************

 *

 * FUNCTION:    acpi_ds_exec_end_op

 *

 * PARAMETERS:  walk_state      - Current state of the parse tree walk

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Ascending callback used during the execution of control

 *              methods. The only thing we really need to do here is to

 *              notice the beginning of IF, ELSE, and WHILE blocks.

 *

 Init the walk state */

 Call debugger for single step support (DEBUG build only) */

 Decode the Opcode Class */

 Constants, literals, etc. */

 Most operators with arguments */

 Build resolved operand stack */

		/*

		 * All opcodes require operand resolution, with the only exceptions

		 * being the object_type and size_of operators.

 Resolve all operands */

			/*

			 * Dispatch the request to the appropriate interpreter handler

			 * routine. There is one routine per opcode "type" based upon the

			 * number of opcode arguments and return type.

			/*

			 * Treat constructs of the form "Store(LocalX,LocalX)" as noops when the

			 * Local is uninitialized.

 Always delete the argument objects and clear the operand stack */

		/*

		 * If a result object was returned from above, push it on the

		 * current result stack

 Type 1 opcode, IF/ELSE/WHILE/NOOP */

 1 Operand, 0 external_result, 0 internal_result */

			/*

			 * If the method is referenced from within a package

			 * declaration, it is not a invocation of the method, just

			 * a reference to it.

			/*

			 * (AML_METHODCALL) Op->Asl.Value.Arg->Asl.Node contains

			 * the method Node pointer

 next_op points to the op that holds the method name */

 next_op points to first argument op */

			/*

			 * Get the method's arguments and put them on the operand stack

			/*

			 * Since the operands will be passed to another control method,

			 * we must resolve all local references here (Local variables,

			 * arguments to *this* method, etc.)

 On error, clear all resolved operands */

			/*

			 * Tell the walk loop to preempt this running method and

			 * execute the new method

			/*

			 * Return now; we don't want to disturb anything,

			 * especially the operand count!

			/*

			 * acpi_exec support for namespace initialization file (initialize

			 * buffer_fields in this code.)

				/*

				 * Put the Node on the object stack (Contains the ACPI Name

				 * of this object)

			/*

			 * If a result object was returned from above, push it on the

			 * current result stack

	/*

	 * ACPI 2.0 support for 64-bit integers: Truncate numeric

	 * result value if we are executing from a 32-bit ACPI table

	/*

	 * Check if we just completed the evaluation of a

	 * conditional predicate

 Break to debugger to display result */

		/*

		 * Delete the result op if and only if:

		 * Parent will not use the result -- such as any

		 * non-nested type2 op in a method (parent will be method)

 Invoke exception handler on error */

 Always clear the object stack */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exstore - AML Interpreter object store support

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_store

 *

 * PARAMETERS:  *source_desc        - Value to be stored

 *              *dest_desc          - Where to store it. Must be an NS node

 *                                    or union acpi_operand_object of type

 *                                    Reference;

 *              walk_state          - Current walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Store the value described by source_desc into the location

 *              described by dest_desc. Called by various interpreter

 *              functions to store the result of an operation into

 *              the destination operand -- not just simply the actual "Store"

 *              ASL operator.

 *

 Validate parameters */

 dest_desc can be either a namespace node or an ACPI object */

		/*

		 * Dest is a namespace node,

		 * Storing an object into a Named node.

 Destination object must be a Reference or a Constant object */

 Allow stores to Constants -- a Noop as per ACPI spec */

 Destination is not a Reference object */

	/*

	 * Examine the Reference class. These cases are handled:

	 *

	 * 1) Store to Name (Change the object associated with a name)

	 * 2) Store to an indexed area of a Buffer or Package

	 * 3) Store to a Method Local or Arg

	 * 4) Store to the debug object

 Storing an object into a Name "container" */

 Storing to an Index (pointer into a packager or buffer) */

 Store to a method local/arg  */

		/*

		 * Storing to the Debug object causes the value stored to be

		 * displayed and otherwise has no effect -- see ACPI Specification

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_store_object_to_index

 *

 * PARAMETERS:  *source_desc            - Value to be stored

 *              *dest_desc              - Named object to receive the value

 *              walk_state              - Current walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Store the object to indexed Buffer or Package element

 *

	/*

	 * Destination must be a reference pointer, and

	 * must point to either a buffer or a package

		/*

		 * Storing to a package element. Copy the object and replace

		 * any existing object with the new object. No implicit

		 * conversion is performed.

		 *

		 * The object at *(index_desc->Reference.Where) is the

		 * element within the package that is to be modified.

		 * The parent package object is at index_desc->Reference.Object

 This is a DDBHandle, just add a reference to it */

 Normal object, copy it */

 Decrement reference count by the ref count of the parent package */

 Increment ref count by the ref count of the parent package-1 */

		/*

		 * Store into a Buffer or String (not actually a real buffer_field)

		 * at a location defined by an Index.

		 *

		 * The first 8-bit element of the source object is written to the

		 * 8-bit Buffer location defined by the Index destination object,

		 * according to the ACPI 2.0 specification.

		/*

		 * Make sure the target is a Buffer or String. An error should

		 * not happen here, since the reference_object was constructed

		 * by the INDEX_OP code.

		/*

		 * The assignment of the individual elements will be slightly

		 * different for each source type.

 Use the least-significant byte of the integer */

 Note: Takes advantage of common string/buffer fields */

 All other types are invalid */

 Store the source value into the target buffer byte */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_store_object_to_node

 *

 * PARAMETERS:  source_desc             - Value to be stored

 *              node                    - Named object to receive the value

 *              walk_state              - Current walk state

 *              implicit_conversion     - Perform implicit conversion (yes/no)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Store the object to the named object.

 *

 * The assignment of an object to a named object is handled here.

 * The value passed in will replace the current value (if any)

 * with the input value.

 *

 * When storing into an object the data is converted to the

 * target object type then stored in the object. This means

 * that the target object type (for an initialized target) will

 * not be changed by a store operation. A copy_object can change

 * the target type, however.

 *

 * The implicit_conversion flag is set to NO/FALSE only when

 * storing to an arg_x -- as per the rules of the ACPI spec.

 *

 * Assumes parameters are already validated.

 *

 Get current type of the node, and object attached to Node */

 Only limited target types possible for everything except copy_object */

		/*

		 * Only copy_object allows all object types to be overwritten. For

		 * target_ref(s), there are restrictions on the object types that

		 * are allowed.

		 *

		 * Allowable operations/typing for Store:

		 *

		 * 1) Simple Store

		 *      Integer     --> Integer (Named/Local/Arg)

		 *      String      --> String  (Named/Local/Arg)

		 *      Buffer      --> Buffer  (Named/Local/Arg)

		 *      Package     --> Package (Named/Local/Arg)

		 *

		 * 2) Store with implicit conversion

		 *      Integer     --> String or Buffer  (Named)

		 *      String      --> Integer or Buffer (Named)

		 *      Buffer      --> Integer or String (Named)

			/*

			 * Here, can only store a package to an existing package.

			 * Storing a package to a Local/Arg is OK, and handled

			 * elsewhere.

	/*

	 * Resolve the source object to an actual value

	 * (If it is a reference object)

 Do the actual store operation */

		/*

		 * The simple data types all support implicit source operand

		 * conversion before the store.

			/*

			 * However, copy_object and Stores to arg_x do not perform

			 * an implicit conversion, as per the ACPI specification.

			 * A direct store is performed instead.

 Store with implicit source operand conversion support */

			/*

			 * Store the new new_desc as the new value of the Name, and set

			 * the Name's type to that of the value being stored in it.

			 * source_desc reference count is incremented by attach_object.

			 *

			 * Note: This may change the type of the node if an explicit

			 * store has been performed such that the node/object type

			 * has been changed.

		/*

		 * For all fields, always write the source data to the target

		 * field. Any required implicit source operand conversion is

		 * performed in the function below as necessary. Note, field

		 * objects must retain their original type permanently.

		/*

		 * copy_object operator: No conversions for all other types.

		 * Instead, directly store a copy of the source object.

		 *

		 * This is the ACPI spec-defined behavior for the copy_object

		 * operator. (Note, for this default case, all normal

		 * Store/Target operations exited above with an error).

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_store_direct_to_node

 *

 * PARAMETERS:  source_desc             - Value to be stored

 *              node                    - Named object to receive the value

 *              walk_state              - Current walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: "Store" an object directly to a node. This involves a copy

 *              and an attach.

 *

 Copy the source object to a new object */

 Attach the new object to the node */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: dbutils - AML debugger utilities

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_match_argument

 *

 * PARAMETERS:  user_argument           - User command line

 *              arguments               - Array of commands to match against

 *

 * RETURN:      Index into command array or ACPI_TYPE_NOT_FOUND if not found

 *

 * DESCRIPTION: Search command array for a command match

 *

 Argument not recognized */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_set_output_destination

 *

 * PARAMETERS:  output_flags        - Current flags word

 *

 * RETURN:      None

 *

 * DESCRIPTION: Set the current destination for debugger output. Also sets

 *              the debug output level accordingly.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_dump_external_object

 *

 * PARAMETERS:  obj_desc        - External ACPI object to dump

 *              level           - Nesting level.

 *

 * RETURN:      None

 *

 * DESCRIPTION: Dump the contents of an ACPI external object

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_prep_namestring

 *

 * PARAMETERS:  name            - String to prepare

 *

 * RETURN:      None

 *

 * DESCRIPTION: Translate all forward slashes and dots to backslashes.

 *

 Convert a leading forward slash to a backslash */

 Ignore a leading backslash, this is the root prefix */

 Convert all slash path separators to dots */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_local_ns_lookup

 *

 * PARAMETERS:  name            - Name to lookup

 *

 * RETURN:      Pointer to a namespace node, null on failure

 *

 * DESCRIPTION: Lookup a name in the ACPI namespace

 *

 * Note: Currently begins search from the root. Could be enhanced to use

 * the current prefix (scope) node as the search beginning point.

 *

 Build an internal namestring */

	/*

	 * Lookup the name.

	 * (Uses root node as the search starting point)

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_uint32_to_hex_string

 *

 * PARAMETERS:  value           - The value to be converted to string

 *              buffer          - Buffer for result (not less than 11 bytes)

 *

 * RETURN:      None

 *

 * DESCRIPTION: Convert the unsigned 32-bit value to the hexadecimal image

 *

 * NOTE: It is the caller's responsibility to ensure that the length of buffer

 *       is sufficient.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_second_pass_parse

 *

 * PARAMETERS:  root            - Root of the parse tree

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Second pass parse of the ACPI tables. We need to wait until

 *              second pass to parse the control methods

 *

 Create a new walk state for the parse */

 Init the Walk State */

 Perform the AML parse */

 TBD: [Investigate] this isn't quite the right thing to do! */

			/*

			 *

			 * Method = (ACPI_DEFERRED_OP *) Op;

			 * Status = acpi_ps_parse_aml (Op, Method->Body, Method->body_length);

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_dump_buffer

 *

 * PARAMETERS:  address             - Pointer to the buffer

 *

 * RETURN:      None

 *

 * DESCRIPTION: Print a portion of a buffer

 *

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: nsobject - Utilities for objects attached to namespace

 *                         table entries

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_attach_object

 *

 * PARAMETERS:  node                - Parent Node

 *              object              - Object to be attached

 *              type                - Type of object, or ACPI_TYPE_ANY if not

 *                                    known

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Record the given object as the value associated with the

 *              name whose acpi_handle is passed. If Object is NULL

 *              and Type is ACPI_TYPE_ANY, set the name as having no value.

 *              Note: Future may require that the Node->Flags field be passed

 *              as a parameter.

 *

 * MUTEX:       Assumes namespace is locked

 *

	/*

	 * Parameter validation

 Invalid handle */

 Null object */

 Not a name handle */

 Check if this object is already attached */

 If null object, we will just install it */

	/*

	 * If the source object is a namespace Node with an attached object,

	 * we will use that (attached) object

		/*

		 * Value passed is a name handle and that name has a

		 * non-null value. Use that name's value and type.

	/*

	 * Otherwise, we will use the parameter object, but we must type

	 * it first

 Use the given type */

 Detach an existing attached object if present */

		/*

		 * Must increment the new value's reference count

		 * (if it is an internal object)

		/*

		 * Handle objects with multiple descriptors - walk

		 * to the end of the descriptor list

 Install the object at the front of the object list */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_detach_object

 *

 * PARAMETERS:  node           - A Namespace node whose object will be detached

 *

 * RETURN:      None.

 *

 * DESCRIPTION: Detach/delete an object associated with a namespace node.

 *              if the object is an allocated object, it is freed.

 *              Otherwise, the field is simply cleared.

 *

 Free the dynamic aml buffer */

 Clear the Node entry in all cases */

 Unlink object from front of possible object list */

 Handle possible 2-descriptor object */

		/*

		 * Detach the object from any data objects (which are still held by

		 * the namespace node)

 Reset the node type to untyped */

 Remove one reference on the object (and all subobjects) */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_get_attached_object

 *

 * PARAMETERS:  node             - Namespace node

 *

 * RETURN:      Current value of the object field from the Node whose

 *              handle is passed

 *

 * DESCRIPTION: Obtain the object attached to a namespace node.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_get_secondary_object

 *

 * PARAMETERS:  node             - Namespace node

 *

 * RETURN:      Current value of the object field from the Node whose

 *              handle is passed.

 *

 * DESCRIPTION: Obtain a secondary object associated with a namespace node.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_attach_data

 *

 * PARAMETERS:  node            - Namespace node

 *              handler         - Handler to be associated with the data

 *              data            - Data to be attached

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Low-level attach data. Create and attach a Data object.

 *

 We only allow one attachment per handler */

 Create an internal object for the data */

 Install the data object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_detach_data

 *

 * PARAMETERS:  node            - Namespace node

 *              handler         - Handler associated with the data

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Low-level detach data. Delete the data node, but the caller

 *              is responsible for the actual data.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_get_attached_data

 *

 * PARAMETERS:  node            - Namespace node

 *              handler         - Handler associated with the data

 *              data            - Where the data is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Low level interface to obtain data previously associated with

 *              a namespace node.

 *

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: nsrepair - Repair for objects returned by predefined methods

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * This module attempts to repair or convert objects returned by the

 * predefined methods to an object type that is expected, as per the ACPI

 * specification. The need for this code is dictated by the many machines that

 * return incorrect types for the standard predefined methods. Performing these

 * conversions here, in one place, eliminates the need for individual ACPI

 * device drivers to do the same. Note: Most of these conversions are different

 * than the internal object conversion routines used for implicit object

 * conversion.

 *

 * The following conversions can be performed as necessary:

 *

 * Integer -> String

 * Integer -> Buffer

 * String  -> Integer

 * String  -> Buffer

 * Buffer  -> Integer

 * Buffer  -> String

 * Buffer  -> Package of Integers

 * Package -> Package of one Package

 *

 * Additional conversions that are available:

 *  Convert a null return or zero return value to an end_tag descriptor

 *  Convert an ASCII string to a Unicode buffer

 *

 * An incorrect standalone object is wrapped with required outer package

 *

 * Additional possible repairs:

 * Required package elements that are NULL replaced by Integer/String/Buffer

 *

 Local prototypes */

/*

 * Special but simple repairs for some names.

 *

 * 2nd argument: Unexpected types that can be repaired

 Resource descriptor conversions */

 Object reference conversions */

 Unicode conversions */

 Table terminator */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_simple_repair

 *

 * PARAMETERS:  info                - Method execution information block

 *              expected_btypes     - Object types expected

 *              package_index       - Index of object within parent package (if

 *                                    applicable - ACPI_NOT_PACKAGE_ELEMENT

 *                                    otherwise)

 *              return_object_ptr   - Pointer to the object returned from the

 *                                    evaluation of a method or object

 *

 * RETURN:      Status. AE_OK if repair was successful.

 *

 * DESCRIPTION: Attempt to repair/convert a return object of a type that was

 *              not expected.

 *

	/*

	 * Special repairs for certain names that are in the repair table.

	 * Check if this name is in the list of repairable names.

 A fatal error occurred during a conversion */

	/*

	 * Do not perform simple object repair unless the return type is not

	 * expected.

	/*

	 * At this point, we know that the type of the returned object was not

	 * one of the expected types for this predefined name. Attempt to

	 * repair the object by converting it to one of the expected object

	 * types for this predefined name.

	/*

	 * If there is no return value, check if we require a return value for

	 * this predefined name. Either one return value is expected, or none,

	 * for both methods and other objects.

	 *

	 * Try to fix if there was no return object. Warning if failed to fix.

 Repair was successful */

		/*

		 * A package is expected. We will wrap the existing object with a

		 * new package object. It is often the case that if a variable-length

		 * package is required, but there is only a single object needed, the

		 * BIOS will return that object instead of wrapping it with a Package

		 * object. Note: after the wrapping, the package will be validated

		 * for correct contents (expected object type or types).

			/*

			 * The original object just had its reference count

			 * incremented for being inserted into the new package.

 New Package object */

 We cannot repair this object */

 Object was successfully repaired */

 Update reference count of new object */

 Delete old object, install the new return object */

/******************************************************************************

 *

 * FUNCTION:    acpi_ns_match_simple_repair

 *

 * PARAMETERS:  node                - Namespace node for the method/object

 *              return_btype        - Object type that was returned

 *              package_index       - Index of object within parent package (if

 *                                    applicable - ACPI_NOT_PACKAGE_ELEMENT

 *                                    otherwise)

 *

 * RETURN:      Pointer to entry in repair table. NULL indicates not found.

 *

 * DESCRIPTION: Check an object name against the repairable object list.

 *

 Search info table for a repairable predefined method/object name */

 Check if we can actually repair this name/type combination */

 Name was not found in the repair table */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_repair_null_element

 *

 * PARAMETERS:  info                - Method execution information block

 *              expected_btypes     - Object types expected

 *              package_index       - Index of object within parent package (if

 *                                    applicable - ACPI_NOT_PACKAGE_ELEMENT

 *                                    otherwise)

 *              return_object_ptr   - Pointer to the object returned from the

 *                                    evaluation of a method or object

 *

 * RETURN:      Status. AE_OK if repair was successful.

 *

 * DESCRIPTION: Attempt to repair a NULL element of a returned Package object.

 *

 No repair needed if return object is non-NULL */

	/*

	 * Attempt to repair a NULL element of a Package object. This applies to

	 * predefined names that return a fixed-length package and each element

	 * is required. It does not apply to variable-length packages where NULL

	 * elements are allowed, especially at the end of the package.

 Need an integer - create a zero-value integer */

 Need a string - create a NULL string */

 Need a buffer - create a zero-length buffer */

 Error for all other expected types */

 Set the reference count according to the parent Package object */

/******************************************************************************

 *

 * FUNCTION:    acpi_ns_remove_null_elements

 *

 * PARAMETERS:  info                - Method execution information block

 *              package_type        - An acpi_return_package_types value

 *              obj_desc            - A Package object

 *

 * RETURN:      None.

 *

 * DESCRIPTION: Remove all NULL package elements from packages that contain

 *              a variable number of subpackages. For these types of

 *              packages, NULL elements can be safely removed.

 *

	/*

	 * We can safely remove all NULL elements from these package types:

	 * PTYPE1_VAR packages contain a variable number of simple data types.

	 * PTYPE2 packages contain a variable number of subpackages.

 Examine all elements of the package object, remove nulls */

 Update parent package if any null elements were removed */

 NULL terminate list and update the package count */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_wrap_with_package

 *

 * PARAMETERS:  info                - Method execution information block

 *              original_object     - Pointer to the object to repair.

 *              obj_desc_ptr        - The new package object is returned here

 *

 * RETURN:      Status, new object in *obj_desc_ptr

 *

 * DESCRIPTION: Repair a common problem with objects that are defined to

 *              return a variable-length Package of sub-objects. If there is

 *              only one sub-object, some BIOS code mistakenly simply declares

 *              the single object instead of a Package with one sub-object.

 *              This function attempts to repair this error by wrapping a

 *              Package object around the original object, creating the

 *              correct and expected Package with one sub-object.

 *

 *              Names that can be repaired in this manner include:

 *              _ALR, _CSD, _HPX, _MLS, _PLD, _PRT, _PSS, _TRT, _TSS,

 *              _BCL, _DOD, _FIX, _Sx

 *

	/*

	 * Create the new outer package and populate it. The new

	 * package will have a single element, the lone sub-object.

 Return the new object in the object pointer */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: tbxfload - Table load/unload external interfaces

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_load_tables

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Load the ACPI tables from the RSDT/XSDT

 *

	/*

	 * Install the default operation region handlers. These are the

	 * handlers that are defined by the ACPI specification to be

	 * "always accessible" -- namely, system_memory, system_IO, and

	 * PCI_Config. This also means that no _REG methods need to be

	 * run for these address spaces. We need to have these handlers

	 * installed before any AML code can be executed, especially any

	 * module-level code (11/2015).

	 * Note that we allow OSPMs to install their own region handlers

	 * between acpi_initialize_subsystem() and acpi_load_tables() to use

	 * their customized default region handlers.

 Load the namespace from the tables */

 Don't let single failures abort the load */

	/*

	 * Initialize the objects in the namespace that remain uninitialized.

	 * This runs the executable AML that may be part of the declaration of

	 * these name objects:

	 *     operation_regions, buffer_fields, Buffers, and Packages.

	 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_load_namespace

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Load the namespace from the DSDT and all SSDTs/PSDTs found in

 *              the RSDT/XSDT.

 *

	/*

	 * Load the namespace. The DSDT is required, but any SSDT and

	 * PSDT tables are optional. Verify the DSDT.

	/*

	 * Save the DSDT pointer for simple access. This is the mapped memory

	 * address. We must take care here because the address of the .Tables

	 * array can change dynamically as tables are loaded at run-time. Note:

	 * .Pointer field is not validated until after call to acpi_tb_validate_table.

	/*

	 * Optionally copy the entire DSDT to local memory (instead of simply

	 * mapping it.) There are some BIOSs that corrupt or replace the original

	 * DSDT, creating the need for this option. Default is FALSE, do not copy

	 * the DSDT.

	/*

	 * Save the original DSDT header for detection of table corruption

	 * and/or replacement of the DSDT from outside the OS.

 Load and parse tables */

 Load any SSDT or PSDT tables. Note: Loop leaves tables locked */

 Ignore errors while loading tables, get as many as possible */

 Indicate at least one failure */

/*******************************************************************************

 *

 * FUNCTION:    acpi_install_table

 *

 * PARAMETERS:  address             - Address of the ACPI table to be installed.

 *              physical            - Whether the address is a physical table

 *                                    address or not

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Dynamically install an ACPI table.

 *              Note: This function should only be invoked after

 *                    acpi_initialize_tables() and before acpi_load_tables().

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_load_table

 *

 * PARAMETERS:  table               - Pointer to a buffer containing the ACPI

 *                                    table to be loaded.

 *              table_idx           - Pointer to a u32 for storing the table

 *                                    index, might be NULL

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Dynamically load an ACPI table from the caller's buffer. Must

 *              be a valid ACPI table with a valid ACPI table header.

 *              Note1: Mainly intended to support hotplug addition of SSDTs.

 *              Note2: Does not copy the incoming table. User is responsible

 *              to ensure that the table is not deleted or unmapped.

 *

 Parameter validation */

 Install the table and load it into the namespace */

 Complete the initialization/resolution of new objects */

/*******************************************************************************

 *

 * FUNCTION:    acpi_unload_parent_table

 *

 * PARAMETERS:  object              - Handle to any namespace object owned by

 *                                    the table to be unloaded

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Via any namespace object within an SSDT or OEMx table, unloads

 *              the table and deletes all namespace objects associated with

 *              that table. Unloading of the DSDT is not allowed.

 *              Note: Mainly intended to support hotplug removal of SSDTs.

 *

 Parameter validation */

	/*

	 * The node owner_id is currently the same as the parent table ID.

	 * However, this could change in the future.

 owner_id==0 means DSDT is the owner. DSDT cannot be unloaded */

 Must acquire the table lock during this operation */

 Find the table in the global table list */

		/*

		 * Allow unload of SSDT and OEMx tables only. Do not allow unload

		 * of the DSDT. No other types of tables should get here, since

		 * only these types can contain AML and thus are the only types

		 * that can create namespace objects.

/*******************************************************************************

 *

 * FUNCTION:    acpi_unload_table

 *

 * PARAMETERS:  table_index         - Index as returned by acpi_load_table

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Via the table_index representing an SSDT or OEMx table, unloads

 *              the table and deletes all namespace objects associated with

 *              that table. Unloading of the DSDT is not allowed.

 *              Note: Mainly intended to support hotplug removal of SSDTs.

 *

 table_index==1 means DSDT is the owner. DSDT cannot be unloaded */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: tbfind   - find table

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_find_table

 *

 * PARAMETERS:  signature           - String with ACPI table signature

 *              oem_id              - String with the table OEM ID

 *              oem_table_id        - String with the OEM Table ID

 *              table_index         - Where the table index is returned

 *

 * RETURN:      Status and table index

 *

 * DESCRIPTION: Find an ACPI table (in the RSDT/XSDT) that matches the

 *              Signature, OEM ID and OEM Table ID. Returns an index that can

 *              be used to get the table header or entire table.

 *

 Validate the input table signature */

 Don't allow the OEM strings to be too long */

 Normalize the input strings */

 Search for the table */

 Not the requested table */

 Table with matching signature has been found */

 Table is not currently mapped, map it */

 Check for table match on all IDs */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exsystem - Interface to OS services

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_system_wait_semaphore

 *

 * PARAMETERS:  semaphore       - Semaphore to wait on

 *              timeout         - Max time to wait

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Implements a semaphore wait with a check to see if the

 *              semaphore is available immediately. If it is not, the

 *              interpreter is released before waiting.

 *

 We must wait, so unlock the interpreter */

 Reacquire the interpreter */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_system_wait_mutex

 *

 * PARAMETERS:  mutex           - Mutex to wait on

 *              timeout         - Max time to wait

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Implements a mutex wait with a check to see if the

 *              mutex is available immediately. If it is not, the

 *              interpreter is released before waiting.

 *

 We must wait, so unlock the interpreter */

 Reacquire the interpreter */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_system_do_stall

 *

 * PARAMETERS:  how_long        - The amount of time to stall,

 *                                in microseconds

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Suspend running thread for specified amount of time.

 *              Note: ACPI specification requires that Stall() does not

 *              relinquish the processor, and delays longer than 100 usec

 *              should use Sleep() instead. We allow stalls up to 255 usec

 *              for compatibility with other interpreters and existing BIOSs.

 *

 255 microseconds */

		/*

		 * Longer than 255 usec, this is an error

		 *

		 * (ACPI specifies 100 usec as max, but this gives some slack in

		 * order to support existing BIOSs)

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_system_do_sleep

 *

 * PARAMETERS:  how_long        - The amount of time to sleep,

 *                                in milliseconds

 *

 * RETURN:      None

 *

 * DESCRIPTION: Sleep the running thread for specified amount of time.

 *

 Since this thread will sleep, we must release the interpreter */

	/*

	 * For compatibility with other ACPI implementations and to prevent

	 * accidental deep sleeps, limit the sleep time to something reasonable.

 And now we must get the interpreter again */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_system_signal_event

 *

 * PARAMETERS:  obj_desc        - The object descriptor for this op

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Provides an access point to perform synchronization operations

 *              within the AML.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_system_wait_event

 *

 * PARAMETERS:  time_desc       - The 'time to delay' object descriptor

 *              obj_desc        - The object descriptor for this op

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Provides an access point to perform synchronization operations

 *              within the AML. This operation is a request to wait for an

 *              event.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_system_reset_event

 *

 * PARAMETERS:  obj_desc        - The object descriptor for this op

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Reset an event to a known state.

 *

	/*

	 * We are going to simply delete the existing semaphore and

	 * create a new one!

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: utmath - Integer math support routines

 *

 Structures used only for 64-bit divide */

/*

 * Optional support for 64-bit double-precision integer multiply and shift.

 * This code is configurable and is implemented in order to support 32-bit

 * kernel environments where a 64-bit double-precision math library is not

 * available.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_short_multiply

 *

 * PARAMETERS:  multiplicand        - 64-bit multiplicand

 *              multiplier          - 32-bit multiplier

 *              out_product         - Pointer to where the product is returned

 *

 * DESCRIPTION: Perform a short multiply.

 *

	/*

	 * The Product is 64 bits, the carry is always 32 bits,

	 * and is generated by the second multiply.

 Return only what was requested */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_short_shift_left

 *

 * PARAMETERS:  operand             - 64-bit shift operand

 *              count               - 32-bit shift count

 *              out_result          - Pointer to where the result is returned

 *

 * DESCRIPTION: Perform a short left shift.

 *

 Return only what was requested */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_short_shift_right

 *

 * PARAMETERS:  operand             - 64-bit shift operand

 *              count               - 32-bit shift count

 *              out_result          - Pointer to where the result is returned

 *

 * DESCRIPTION: Perform a short right shift.

 *

 Return only what was requested */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_short_multiply

 *

 * PARAMETERS:  See function headers above

 *

 * DESCRIPTION: Native version of the ut_short_multiply function.

 *

 Return only what was requested */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_short_shift_left

 *

 * PARAMETERS:  See function headers above

 *

 * DESCRIPTION: Native version of the ut_short_shift_left function.

 *

 Return only what was requested */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_short_shift_right

 *

 * PARAMETERS:  See function headers above

 *

 * DESCRIPTION: Native version of the ut_short_shift_right function.

 *

 Return only what was requested */

/*

 * Optional support for 64-bit double-precision integer divide. This code

 * is configurable and is implemented in order to support 32-bit kernel

 * environments where a 64-bit double-precision math library is not available.

 *

 * Support for a more normal 64-bit divide/modulo (with check for a divide-

 * by-zero) appears after this optional section of code.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_short_divide

 *

 * PARAMETERS:  dividend            - 64-bit dividend

 *              divisor             - 32-bit divisor

 *              out_quotient        - Pointer to where the quotient is returned

 *              out_remainder       - Pointer to where the remainder is returned

 *

 * RETURN:      Status (Checks for divide-by-zero)

 *

 * DESCRIPTION: Perform a short (maximum 64 bits divided by 32 bits)

 *              divide and modulo. The result is a 64-bit quotient and a

 *              32-bit remainder.

 *

 Always check for a zero divisor */

	/*

	 * The quotient is 64 bits, the remainder is always 32 bits,

	 * and is generated by the second divide.

 Return only what was requested */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_divide

 *

 * PARAMETERS:  in_dividend         - Dividend

 *              in_divisor          - Divisor

 *              out_quotient        - Pointer to where the quotient is returned

 *              out_remainder       - Pointer to where the remainder is returned

 *

 * RETURN:      Status (Checks for divide-by-zero)

 *

 * DESCRIPTION: Perform a divide and modulo.

 *

 Always check for a zero divisor */

		/*

		 * 1) Simplest case is where the divisor is 32 bits, we can

		 * just do two divides

		/*

		 * The quotient is 64 bits, the remainder is always 32 bits,

		 * and is generated by the second divide.

		/*

		 * 2) The general case where the divisor is a full 64 bits

		 * is more difficult

 Normalize the operands (shift until the divisor is < 32 bits) */

 Partial divide */

		/*

		 * The quotient is always 32 bits, and simply requires

		 * adjustment. The 64-bit remainder must be generated.

 Return only what was requested */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_short_divide, acpi_ut_divide

 *

 * PARAMETERS:  See function headers above

 *

 * DESCRIPTION: Native versions of the ut_divide functions. Use these if either

 *              1) The target is a 64-bit platform and therefore 64-bit

 *                 integer math is supported directly by the machine.

 *              2) The target is a 32-bit or 16-bit platform, and the

 *                 double-precision integer math library is available to

 *                 perform the divide.

 *

 Always check for a zero divisor */

 Return only what was requested */

 Always check for a zero divisor */

 Return only what was requested */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: nsutils - Utilities for accessing ACPI namespace, accessing

 *                        parents and siblings and Scope manipulation

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_print_node_pathname

 *

 * PARAMETERS:  node            - Object

 *              message         - Prefix message

 *

 * DESCRIPTION: Print an object's full namespace pathname

 *              Manages allocation/freeing of a pathname buffer

 *

 Convert handle to full pathname and print it (with supplied message) */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_get_type

 *

 * PARAMETERS:  node        - Parent Node to be examined

 *

 * RETURN:      Type field from Node whose handle is passed

 *

 * DESCRIPTION: Return the type of a Namespace node

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_local

 *

 * PARAMETERS:  type        - A namespace object type

 *

 * RETURN:      LOCAL if names must be found locally in objects of the

 *              passed type, 0 if enclosing scopes should be searched

 *

 * DESCRIPTION: Returns scope rule for the given object type.

 *

 Type code out of range  */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_get_internal_name_length

 *

 * PARAMETERS:  info            - Info struct initialized with the

 *                                external name pointer.

 *

 * RETURN:      None

 *

 * DESCRIPTION: Calculate the length of the internal (AML) namestring

 *              corresponding to the external (ASL) namestring.

 *

	/*

	 * For the internal name, the required length is 4 bytes per segment,

	 * plus 1 each for root_prefix, multi_name_prefix_op, segment count,

	 * trailing null (which is not really needed, but no there's harm in

	 * putting it there)

	 *

	 * strlen() + 1 covers the first name_seg, which has no path separator

 Skip redundant root_prefix, like \\_SB.PCI0.SBRG.EC0 */

 Handle Carat prefixes */

	/*

	 * Determine the number of ACPI name "segments" by counting the number of

	 * path separators within the string. Start with one segment since the

	 * segment count is [(# separators) + 1], and zero separators is ok.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_build_internal_name

 *

 * PARAMETERS:  info            - Info struct fully initialized

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Construct the internal (AML) namestring

 *              corresponding to the external (ASL) namestring.

 *

 Setup the correct prefixes, counts, and pointers */

		/*

		 * Not fully qualified.

		 * Handle Carats first, then append the name segments

 Build the name (minus path separators) */

 Pad the segment with underscore(s) if segment is short */

 Convert the character to uppercase and save it */

 Now we must have a path separator, or the pathname is bad */

 Move on the next segment */

 Terminate the string */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_internalize_name

 *

 * PARAMETERS:  *external_name          - External representation of name

 *              **Converted name        - Where to return the resulting

 *                                        internal represention of the name

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Convert an external representation (e.g. "\_PR_.CPU0")

 *              to internal form (e.g. 5c 2f 02 5f 50 52 5f 43 50 55 30)

 *

 Get the length of the new internal name */

 We need a segment to store the internal  name */

 Build the name */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_externalize_name

 *

 * PARAMETERS:  internal_name_length - Length of the internal name below

 *              internal_name       - Internal representation of name

 *              converted_name_length - Where the length is returned

 *              converted_name      - Where the resulting external name

 *                                    is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Convert internal name (e.g. 5c 2f 02 5f 50 52 5f 43 50 55 30)

 *              to its external (printable) form (e.g. "\_PR_.CPU0")

 *

 Check for a prefix (one '\' | one or more '^') */

	/*

	 * Check for object names. Note that there could be 0-255 of these

	 * 4-byte elements.

 <count> 4-byte names */

 Two 4-byte names */

 null_name */

 one 4-byte name */

	/*

	 * Calculate the length of converted_name, which equals the length

	 * of the prefix, length of all object names, length of any required

	 * punctuation ('.') between object names, plus the NULL terminator.

	/*

	 * Check to see if we're still in bounds. If not, there's a problem

	 * with internal_name (invalid format).

 Build the converted_name */

 Copy and validate the 4-char name segment */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_validate_handle

 *

 * PARAMETERS:  handle          - Handle to be validated and typecast to a

 *                                namespace node.

 *

 * RETURN:      A pointer to a namespace node

 *

 * DESCRIPTION: Convert a namespace handle to a namespace node. Handles special

 *              cases for the root node.

 *

 * NOTE: Real integer handles would allow for more verification

 *       and keep all pointers within this subsystem - however this introduces

 *       more overhead and has not been necessary to this point. Drivers

 *       holding handles are typically notified before a node becomes invalid

 *       due to a table unload.

 *

 Parameter validation */

 We can at least attempt to verify the handle */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_terminate

 *

 * PARAMETERS:  none

 *

 * RETURN:      none

 *

 * DESCRIPTION: free memory allocated for namespace and ACPI table storage.

 *

	/*

	 * Free the entire namespace -- all nodes and all objects

	 * attached to the nodes

 Delete any objects attached to the root node */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_opens_scope

 *

 * PARAMETERS:  type        - A valid namespace type

 *

 * RETURN:      NEWSCOPE if the passed type "opens a name scope" according

 *              to the ACPI specification, else 0

 *

 type code out of range  */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_get_node_unlocked

 *

 * PARAMETERS:  *pathname   - Name to be found, in external (ASL) format. The

 *                            \ (backslash) and ^ (carat) prefixes, and the

 *                            . (period) to separate segments are supported.

 *              prefix_node  - Root of subtree to be searched, or NS_ALL for the

 *                            root of the name space. If Name is fully

 *                            qualified (first s8 is '\'), the passed value

 *                            of Scope will not be accessed.

 *              flags       - Used to indicate whether to perform upsearch or

 *                            not.

 *              return_node - Where the Node is returned

 *

 * DESCRIPTION: Look up a name relative to a given scope and return the

 *              corresponding Node. NOTE: Scope can be null.

 *

 * MUTEX:       Doesn't locks namespace

 *

 Simplest case is a null pathname */

 Quick check for a reference to the root */

 Convert path to internal representation */

 Setup lookup scope (search starting point) */

 Lookup the name in the namespace */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_get_node

 *

 * PARAMETERS:  *pathname   - Name to be found, in external (ASL) format. The

 *                            \ (backslash) and ^ (carat) prefixes, and the

 *                            . (period) to separate segments are supported.

 *              prefix_node  - Root of subtree to be searched, or NS_ALL for the

 *                            root of the name space. If Name is fully

 *                            qualified (first s8 is '\'), the passed value

 *                            of Scope will not be accessed.

 *              flags       - Used to indicate whether to perform upsearch or

 *                            not.

 *              return_node - Where the Node is returned

 *

 * DESCRIPTION: Look up a name relative to a given scope and return the

 *              corresponding Node. NOTE: Scope can be null.

 *

 * MUTEX:       Locks namespace

 *

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: tbdata - Table manager data structure functions

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_compare_tables

 *

 * PARAMETERS:  table_desc          - Table 1 descriptor to be compared

 *              table_index         - Index of table 2 to be compared

 *

 * RETURN:      TRUE if both tables are identical.

 *

 * DESCRIPTION: This function compares a table with another table that has

 *              already been installed in the root table list.

 *

	/*

	 * Check for a table match on the entire table length,

	 * not just the header.

 Release the acquired table */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_init_table_descriptor

 *

 * PARAMETERS:  table_desc              - Table descriptor

 *              address                 - Physical address of the table

 *              flags                   - Allocation flags of the table

 *              table                   - Pointer to the table

 *

 * RETURN:      None

 *

 * DESCRIPTION: Initialize a new table descriptor

 *

	/*

	 * Initialize the table descriptor. Set the pointer to NULL, since the

	 * table is not fully mapped at this time.

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_acquire_table

 *

 * PARAMETERS:  table_desc          - Table descriptor

 *              table_ptr           - Where table is returned

 *              table_length        - Where table length is returned

 *              table_flags         - Where table allocation flags are returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Acquire an ACPI table. It can be used for tables not

 *              maintained in the acpi_gbl_root_table_list.

 *

 Table is not valid yet */

 Fill the return values */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_release_table

 *

 * PARAMETERS:  table               - Pointer for the table

 *              table_length        - Length for the table

 *              table_flags         - Allocation flags for the table

 *

 * RETURN:      None

 *

 * DESCRIPTION: Release a table. The inverse of acpi_tb_acquire_table().

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_acquire_temp_table

 *

 * PARAMETERS:  table_desc          - Table descriptor to be acquired

 *              address             - Address of the table

 *              flags               - Allocation flags of the table

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function validates the table header to obtain the length

 *              of a table and fills the table descriptor to make its state as

 *              "INSTALLED". Such a table descriptor is only used for verified

 *              installation.

 *

 Get the length of the full table from the header */

 Table is not valid yet */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_release_temp_table

 *

 * PARAMETERS:  table_desc          - Table descriptor to be released

 *

 * RETURN:      Status

 *

 * DESCRIPTION: The inverse of acpi_tb_acquire_temp_table().

 *

	/*

	 * Note that the .Address is maintained by the callers of

	 * acpi_tb_acquire_temp_table(), thus do not invoke acpi_tb_uninstall_table()

	 * where .Address will be freed.

/******************************************************************************

 *

 * FUNCTION:    acpi_tb_validate_table

 *

 * PARAMETERS:  table_desc          - Table descriptor

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to validate the table, the returned

 *              table descriptor is in "VALIDATED" state.

 *

 Validate the table if necessary */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_invalidate_table

 *

 * PARAMETERS:  table_desc          - Table descriptor

 *

 * RETURN:      None

 *

 * DESCRIPTION: Invalidate one internal ACPI table, this is the inverse of

 *              acpi_tb_validate_table().

 *

 Table must be validated */

/******************************************************************************

 *

 * FUNCTION:    acpi_tb_validate_temp_table

 *

 * PARAMETERS:  table_desc          - Table descriptor

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to validate the table, the returned

 *              table descriptor is in "VALIDATED" state.

 *

		/*

		 * Only validates the header of the table.

		 * Note that Length contains the size of the mapping after invoking

		 * this work around, this value is required by

		 * acpi_tb_release_temp_table().

		 * We can do this because in acpi_init_table_descriptor(), the Length

		 * field of the installed descriptor is filled with the actual

		 * table length obtaining from the table header.

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_check_duplication

 *

 * PARAMETERS:  table_desc          - Table descriptor

 *              table_index         - Where the table index is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Avoid installing duplicated tables. However table override and

 *              user aided dynamic table load is allowed, thus comparing the

 *              address of the table is not sufficient, and checking the entire

 *              table content is required.

 *

 Check if table is already registered */

 Do not compare with unverified tables */

		/*

		 * Check for a table match on the entire table length,

		 * not just the header.

		/*

		 * Note: the current mechanism does not unregister a table if it is

		 * dynamically unloaded. The related namespace entries are deleted,

		 * but the table remains in the root table list.

		 *

		 * The assumption here is that the number of different tables that

		 * will be loaded is actually small, and there is minimal overhead

		 * in just keeping the table in case it is needed again.

		 *

		 * If this assumption changes in the future (perhaps on large

		 * machines with many table load/unload operations), tables will

		 * need to be unregistered when they are unloaded, and slots in the

		 * root table list should be reused when empty.

 Table is still loaded, this is an error */

 Indicate no duplication to the caller */

/******************************************************************************

 *

 * FUNCTION:    acpi_tb_verify_temp_table

 *

 * PARAMETERS:  table_desc          - Table descriptor

 *              signature           - Table signature to verify

 *              table_index         - Where the table index is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This function is called to validate and verify the table, the

 *              returned table descriptor is in "VALIDATED" state.

 *              Note that 'TableIndex' is required to be set to !NULL to

 *              enable duplication check.

 *

 Validate the table */

 If a particular signature is expected (DSDT/FACS), it must match */

 Verify the checksum */

 Avoid duplications */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_resize_root_table_list

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Expand the size of global table array

 *

 allow_resize flag is a parameter to acpi_initialize_tables */

 Increase the Table Array size */

 Copy and free the previous table array */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_get_next_table_descriptor

 *

 * PARAMETERS:  table_index         - Where table index is returned

 *              table_desc          - Where table descriptor is returned

 *

 * RETURN:      Status and table index/descriptor.

 *

 * DESCRIPTION: Allocate a new ACPI table entry to the global table list

 *

 Ensure that there is room for the table in the Root Table List */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_terminate

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Delete all internal ACPI tables

 *

 Delete the individual tables */

	/*

	 * Delete the root table array if allocated locally. Array cannot be

	 * mapped, so we don't need to check for that flag.

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_delete_namespace_by_owner

 *

 * PARAMETERS:  table_index         - Table index

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Delete all namespace objects created when this table was loaded.

 *

 The table index does not exist */

 Get the owner ID for this table, used to delete namespace nodes */

	/*

	 * Need to acquire the namespace writer lock to prevent interference

	 * with any concurrent namespace walks. The interpreter must be

	 * released during the deletion since the acquisition of the deletion

	 * lock may block, and also since the execution of a namespace walk

	 * must be allowed to use the interpreter.

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_allocate_owner_id

 *

 * PARAMETERS:  table_index         - Table index

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Allocates owner_id in table_desc

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_release_owner_id

 *

 * PARAMETERS:  table_index         - Table index

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Releases owner_id in table_desc

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_get_owner_id

 *

 * PARAMETERS:  table_index         - Table index

 *              owner_id            - Where the table owner_id is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: returns owner_id for the ACPI table

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_is_table_loaded

 *

 * PARAMETERS:  table_index         - Index into the root table

 *

 * RETURN:      Table Loaded Flag

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_set_table_loaded_flag

 *

 * PARAMETERS:  table_index         - Table index

 *              is_loaded           - TRUE if table is loaded, FALSE otherwise

 *

 * RETURN:      None

 *

 * DESCRIPTION: Sets the table loaded flag to either TRUE or FALSE.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_load_table

 *

 * PARAMETERS:  table_index             - Table index

 *              parent_node             - Where table index is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Load an ACPI table

 *

	/*

	 * Note: Now table is "INSTALLED", it must be validated before

	 * using.

	/*

	 * Update GPEs for any new _Lxx/_Exx methods. Ignore errors. The host is

	 * responsible for discovering any new wake GPEs by running _PRW methods

	 * that may have been loaded by this table.

 Invoke table handler */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_install_and_load_table

 *

 * PARAMETERS:  address                 - Physical address of the table

 *              flags                   - Allocation flags of the table

 *              override                - Whether override should be performed

 *              table_index             - Where table index is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Install and load an ACPI table

 *

 Install the table and load it into the namespace */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_unload_table

 *

 * PARAMETERS:  table_index             - Table index

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Unload an ACPI table

 *

 Ensure the table is still loaded */

 Invoke table handler */

 Delete the portion of the namespace owned by this table */

/*******************************************************************************

 *

 * FUNCTION:    acpi_tb_notify_table

 *

 * PARAMETERS:  event               - Table event

 *              table               - Validated table pointer

 *

 * RETURN:      None

 *

 * DESCRIPTION: Notify a table event to the users.

 *

 Invoke table handler if present */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exoparg1 - AML execution - opcodes with 1 argument

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*!

 * Naming convention for AML interpreter execution routines.

 *

 * The routines that begin execution of AML opcodes are named with a common

 * convention based upon the number of arguments, the number of target operands,

 * and whether or not a value is returned:

 *

 *      AcpiExOpcode_xA_yT_zR

 *

 * Where:

 *

 * xA - ARGUMENTS:    The number of arguments (input operands) that are

 *                    required for this opcode type (0 through 6 args).

 * yT - TARGETS:      The number of targets (output operands) that are required

 *                    for this opcode type (0, 1, or 2 targets).

 * zR - RETURN VALUE: Indicates whether this opcode type returns a value

 *                    as the function return (0 or 1).

 *

 * The AcpiExOpcode* functions are called via the Dispatcher component with

 * fully resolved operands.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_opcode_0A_0T_1R

 *

 * PARAMETERS:  walk_state          - Current state (contains AML opcode)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute operator with no operands, one return value

 *

 Examine the AML opcode */

  Timer () */

 Create a return object of type Integer */

  Unknown opcode  */

 Delete return object on error */

 Save the return value */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_opcode_1A_0T_0R

 *

 * PARAMETERS:  walk_state          - Current state (contains AML opcode)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute Type 1 monadic operator with numeric operand on

 *              object stack

 *

 Examine the AML opcode */

  Release (mutex_object) */

  Reset (event_object) */

  Signal (event_object) */

  Sleep (msec_time) */

  Stall (usec_time) */

  Unload (Handle) */

  Unknown opcode  */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_opcode_1A_1T_0R

 *

 * PARAMETERS:  walk_state          - Current state (contains AML opcode)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute opcode with one argument, one target, and no

 *              return value.

 *

 Examine the AML opcode */

 Unknown opcode */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_opcode_1A_1T_1R

 *

 * PARAMETERS:  walk_state          - Current state (contains AML opcode)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute opcode with one argument, one target, and a

 *              return value.

 *

 Examine the AML opcode */

 Create a return object of type Integer for these opcodes */

 Not (Operand, Result)  */

 find_set_left_bit (Operand, Result) */

			/*

			 * Acpi specification describes Integer type as a little

			 * endian unsigned value, so this boundary condition is valid.

 find_set_right_bit (Operand, Result) */

			/*

			 * The Acpi specification describes Integer type as a little

			 * endian unsigned value, so this boundary condition is valid.

 Since the bit position is one-based, subtract from 33 (65) */

 from_bcd (BCDValue, Result) */

			/*

			 * The 64-bit ACPI integer can hold 16 4-bit BCD characters

			 * (if table is 32-bit, integer can hold 8 BCD characters)

			 * Convert each 4-bit BCD value

 Convert each BCD digit (each is one nybble wide) */

 Get the least significant 4-bit BCD digit */

 Check the range of the digit */

 Sum the digit into the result with the current power of 10 */

 Shift to next BCD digit */

 Next power of 10 */

 to_bcd (Operand, Result) */

 Each BCD digit is one nybble wide */

				/*

				 * Insert the BCD digit that resides in the

				 * remainder from above

 Overflow if there is any data left in Digit */

 cond_ref_of (source_object, Result) */

			/*

			 * This op is a little strange because the internal return value is

			 * different than the return value stored in the result descriptor

			 * (There are really two return values)

				/*

				 * This means that the object does not exist in the namespace,

				 * return FALSE

 Get the object reference, store it, and remove our reference */

 The object exists in the namespace, return TRUE */

 No other opcodes get here */

 Store (Source, Target) */

		/*

		 * A store operand is typically a number, string, buffer or lvalue

		 * Be careful about deleting the source object,

		 * since the object itself may have been stored.

 It is possible that the Store already produced a return object */

			/*

			 * Normally, we would remove a reference on the Operand[0]

			 * parameter; But since it is being used as the internal return

			 * object (meaning we would normally increment it), the two

			 * cancel out, and we simply don't do anything.

 Prevent deletion */

		/*

		 * ACPI 2.0 Opcodes

 copy_object (Source, Target) */

 to_decimal_string (Data, Result) */

 No conversion performed, add ref to handle return value */

 to_hex_string (Data, Result) */

 No conversion performed, add ref to handle return value */

 to_buffer (Data, Result) */

 No conversion performed, add ref to handle return value */

 to_integer (Data, Result) */

 Perform "explicit" conversion */

 No conversion performed, add ref to handle return value */

 shift_left_bit (Source, bit_num) */

 shift_right_bit (Source, bit_num) */

 These are two obsolete opcodes */

 Unknown opcode */

 Store the return value computed above into the target object */

 Delete return object on error */

 Save return object on success */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_opcode_1A_0T_1R

 *

 * PARAMETERS:  walk_state          - Current state (contains AML opcode)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute opcode with one argument, no target, and a return value

 *

 Examine the AML opcode */

 LNot (Operand) */

		/*

		 * Set result to ONES (TRUE) if Value == 0. Note:

		 * return_desc->Integer.Value is initially == 0 (FALSE) from above.

 Decrement (Operand)  */

 Increment (Operand)  */

		/*

		 * Create a new integer. Can't just get the base integer and

		 * increment it because it may be an Arg or Field.

		/*

		 * Since we are expecting a Reference operand, it can be either a

		 * NS Node or an internal object.

 Internal reference object - prevent deletion */

		/*

		 * Convert the Reference operand to an Integer (This removes a

		 * reference on the Operand[0] object)

		 *

		 * NOTE:  We use LNOT_OP here in order to force resolution of the

		 * reference operand to an actual integer.

		/*

		 * temp_desc is now guaranteed to be an Integer object --

		 * Perform the actual increment or decrement

 Finished with this Integer object */

		/*

		 * Store the result back (indirectly) through the original

		 * Reference object

 object_type (source_object) */

		/*

		 * Note: The operand is not resolved at this point because we want to

		 * get the associated object, not its value. For example, we don't

		 * want to resolve a field_unit to its value, we want the actual

		 * field_unit object.

 Get the type of the base object */

 Allocate a descriptor to hold the type. */

 size_of (source_object) */

		/*

		 * Note: The operand is not resolved at this point because we want to

		 * get the associated object, not its value.

 Get the base object */

		/*

		 * The type of the base object must be integer, buffer, string, or

		 * package. All others are not supported.

		 *

		 * NOTE: Integer is not specifically supported by the ACPI spec,

		 * but is supported implicitly via implicit operand conversion.

		 * rather than bother with conversion, we just use the byte width

		 * global (4 or 8 bytes).

 Buffer arguments may not be evaluated at this point */

 Package arguments may not be evaluated at this point */

		/*

		 * Now that we have the size of the object, create a result

		 * object to hold the value

 ref_of (source_object) */

 deref_of (obj_reference | String) */

 Check for a method local or argument, or standalone String */

				/*

				 * This is a deref_of (local_x | arg_x)

				 *

				 * Must resolve/dereference the local/arg reference first

 Set Operand[0] to the value of the local/arg */

					/*

					 * Delete our reference to the input object and

					 * point to the object just retrieved

 Get the object to which the reference refers */

 Must be an Index op - handled below */

				/*

				 * This is a deref_of (String). The string is a reference

				 * to a named ACPI object.

				 *

				 * 1) Find the owning Node

				 * 2) Dereference the node to an actual object. Could be a

				 *    Field, so we need to resolve the node to a value.

 Operand[0] may have changed from the code above */

			/*

			 * This is a deref_of (object_reference)

			 * Get the actual object from the Node (This is the dereference).

			 * This case may only happen when a local_x or arg_x is

			 * dereferenced above, or for references to device and

			 * thermal objects.

 These types have no node subobject, return the NS node */

 For most types, get the object attached to the node */

			/*

			 * This must be a reference object produced by either the

			 * Index() or ref_of() operator

				/*

				 * The target type for the Index operator must be

				 * either a Buffer or a Package

					/*

					 * Create a new object that contains one element of the

					 * buffer -- the element pointed to by the index.

					 *

					 * NOTE: index into a buffer is NOT a pointer to a

					 * sub-buffer of the main buffer, it is only a pointer to a

					 * single element (byte) of the buffer!

					 *

					 * Since we are returning the value of the buffer at the

					 * indexed location, we don't need to add an additional

					 * reference to the buffer itself.

					/*

					 * Return the referenced element of the package. We must

					 * add another reference to the referenced object, however.

						/*

						 * Element is NULL, do not allow the dereference.

						 * This provides compatibility with other ACPI

						 * implementations.

					/*

					 * June 2013:

					 * buffer_fields/field_units require additional resolution

 Add another reference to the object */

 Delete return object on error */

 Save return object on success */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: rsserial - GPIO/serial_bus resource descriptors

 *

/*******************************************************************************

 *

 * acpi_rs_convert_gpio

 *

	/*

	 * These fields are contiguous in both the source and destination:

	 * revision_id

	 * connection_type

	/*

	 * These fields are contiguous in both the source and destination:

	 * drive_strength

	 * debounce_timeout

 Pin Table */

 Resource Source */

 Vendor Data */

/*******************************************************************************

 *

 * acpi_rs_convert_pinfunction

 *

 Pin Table */

	/*

	 * It is OK to use GPIO operations here because none of them refer GPIO

	 * structures directly but instead use offsets given here.

 Resource Source */

 Vendor Data */

/*******************************************************************************

 *

 * acpi_rs_convert_csi2_serial_bus

 *

 Vendor data */

 Resource Source */

/*******************************************************************************

 *

 * acpi_rs_convert_i2c_serial_bus

 *

 Vendor data */

 Resource Source */

 I2C bus type specific */

/*******************************************************************************

 *

 * acpi_rs_convert_spi_serial_bus

 *

 Vendor data */

 Resource Source */

 Spi bus type specific  */

/*******************************************************************************

 *

 * acpi_rs_convert_uart_serial_bus

 *

 Vendor data */

 Resource Source */

 Uart bus type specific  */

/*******************************************************************************

 *

 * acpi_rs_convert_pin_config

 *

 Pin Table */

	/*

	 * It is OK to use GPIO operations here because none of them refer GPIO

	 * structures directly but instead use offsets given here.

 Resource Source */

 Vendor Data */

/*******************************************************************************

 *

 * acpi_rs_convert_pin_group

 *

 Pin Table */

	/*

	 * It is OK to use GPIO operations here because none of them refer GPIO

	 * structures directly but instead use offsets given here.

 Resource Label */

 Vendor Data */

/*******************************************************************************

 *

 * acpi_rs_convert_pin_group_function

 *

 Resource Source */

 Resource Source Label */

 Vendor Data */

/*******************************************************************************

 *

 * acpi_rs_convert_pin_group_config

 *

 Resource Source */

 Resource Source Label */

 Vendor Data */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: utdecode - Utility decoding routines (value-to-string)

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*

 * Properties of the ACPI Object Types, both internal and external.

 * The table is indexed by values of acpi_object_type

 00 Any              */

 01 Number           */

 02 String           */

 03 Buffer           */

 04 Package          */

 05 field_unit       */

 06 Device           */

 07 Event            */

 08 Method           */

 09 Mutex            */

 10 Region           */

 11 Power            */

 12 Processor        */

 13 Thermal          */

 14 buffer_field     */

 15 ddb_handle       */

 16 Debug Object     */

 17 def_field        */

 18 bank_field       */

 19 index_field      */

 20 Reference        */

 21 Alias            */

 22 method_alias     */

 23 Notify           */

 24 Address Handler  */

 25 Resource Desc    */

 26 Resource Field   */

 27 Scope            */

 28 Extra            */

 29 Data             */

 30 Invalid          */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_region_name

 *

 * PARAMETERS:  Space ID            - ID for the region

 *

 * RETURN:      Decoded region space_id name

 *

 * DESCRIPTION: Translate a Space ID into a name string (Debug only)

 *

 Region type decoding */

 0x00 */

 0x01 */

 0x02 */

 0x03 */

 0x04 */

 0x05 */

 0x06 */

 0x07 */

 0x08 */

 0x09 */

 0x0A */

 0x0B */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_event_name

 *

 * PARAMETERS:  event_id            - Fixed event ID

 *

 * RETURN:      Decoded event ID name

 *

 * DESCRIPTION: Translate a Event ID into a name string (Debug only)

 *

 Event type decoding */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_type_name

 *

 * PARAMETERS:  type                - An ACPI object type

 *

 * RETURN:      Decoded ACPI object type name

 *

 * DESCRIPTION: Translate a Type ID into a name string (Debug only)

 *

/*

 * Elements of acpi_gbl_ns_type_names below must match

 * one-to-one with values of acpi_object_type

 *

 * The type ACPI_TYPE_ANY (Untyped) is used as a "don't care" when searching;

 * when stored in a table it really means that we have thus far seen no

 * evidence to indicate what type is actually going to be stored for this

 & entry.

 Printable names of the ACPI object types */

 00 */ "Untyped",

 01 */ "Integer",

 02 */ "String",

 03 */ "Buffer",

 04 */ "Package",

 05 */ "FieldUnit",

 06 */ "Device",

 07 */ "Event",

 08 */ "Method",

 09 */ "Mutex",

 10 */ "Region",

 11 */ "Power",

 12 */ "Processor",

 13 */ "Thermal",

 14 */ "BufferField",

 15 */ "DdbHandle",

 16 */ "DebugObject",

 17 */ "RegionField",

 18 */ "BankField",

 19 */ "IndexField",

 20 */ "Reference",

 21 */ "Alias",

 22 */ "MethodAlias",

 23 */ "Notify",

 24 */ "AddrHandler",

 25 */ "ResourceDesc",

 26 */ "ResourceFld",

 27 */ "Scope",

 28 */ "Extra",

 29 */ "Data",

 30 */ "Invalid"

 These descriptor types share a common area */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_node_name

 *

 * PARAMETERS:  object               - A namespace node

 *

 * RETURN:      ASCII name of the node

 *

 * DESCRIPTION: Validate the node and return the node's ACPI name.

 *

 Must return a string of exactly 4 characters == ACPI_NAMESEG_SIZE */

 Check for Root node */

 Descriptor must be a namespace node */

	/*

	 * Ensure name is valid. The name was validated/repaired when the node

	 * was created, but make sure it has not been corrupted.

 Return the name */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_descriptor_name

 *

 * PARAMETERS:  object               - An ACPI object

 *

 * RETURN:      Decoded name of the descriptor type

 *

 * DESCRIPTION: Validate object and return the descriptor type

 *

 Printable names of object descriptor types */

 00 */ "Not a Descriptor",

 01 */ "Cached Object",

 02 */ "State-Generic",

 03 */ "State-Update",

 04 */ "State-Package",

 05 */ "State-Control",

 06 */ "State-RootParseScope",

 07 */ "State-ParseScope",

 08 */ "State-WalkScope",

 09 */ "State-Result",

 10 */ "State-Notify",

 11 */ "State-Thread",

 12 */ "Tree Walk State",

 13 */ "Parse Tree Op",

 14 */ "Operand Object",

 15 */ "Namespace Node"

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_reference_name

 *

 * PARAMETERS:  object               - An ACPI reference object

 *

 * RETURN:      Decoded name of the type of reference

 *

 * DESCRIPTION: Decode a reference object sub-type to a string.

 *

 Printable names of reference object sub-types */

 00 */ "Local",

 01 */ "Argument",

 02 */ "RefOf",

 03 */ "Index",

 04 */ "DdbHandle",

 05 */ "Named Object",

 06 */ "Debug"

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_mutex_name

 *

 * PARAMETERS:  mutex_id        - The predefined ID for this mutex.

 *

 * RETURN:      Decoded name of the internal mutex

 *

 * DESCRIPTION: Translate a mutex ID into a name string (Debug only)

 *

 Names for internal mutex objects, used for debug output */

/*

 * Strings and procedures used for debug only

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_notify_name

 *

 * PARAMETERS:  notify_value    - Value from the Notify() request

 *

 * RETURN:      Decoded name for the notify value

 *

 * DESCRIPTION: Translate a Notify Value to a notify namestring.

 *

 Names for Notify() values, used for debug output */

 00 */ "Bus Check",

 01 */ "Device Check",

 02 */ "Device Wake",

 03 */ "Eject Request",

 04 */ "Device Check Light",

 05 */ "Frequency Mismatch",

 06 */ "Bus Mode Mismatch",

 07 */ "Power Fault",

 08 */ "Capabilities Check",

 09 */ "Device PLD Check",

 0A */ "Reserved",

 0B */ "System Locality Update",

 0C */ "Reserved (was previously Shutdown Request)",

 Reserved in ACPI 6.0 */

 0D */ "System Resource Affinity Update",

 0E */ "Heterogeneous Memory Attributes Update",

 ACPI 6.2 */

 0F */ "Error Disconnect Recover"

 ACPI 6.3 */

 80 */ "Status Change",

 81 */ "Information Change",

 82 */ "Device-Specific Change",

 83 */ "Device-Specific Change",

 84 */ "Reserved"

 80 */ "Performance Capability Change",

 81 */ "C-State Change",

 82 */ "Throttling Capability Change",

 83 */ "Guaranteed Change",

 84 */ "Minimum Excursion"

 80 */ "Thermal Status Change",

 81 */ "Thermal Trip Point Change",

 82 */ "Thermal Device List Change",

 83 */ "Thermal Relationship Change",

 84 */ "Reserved"

 00 - 0F are "common to all object types" (from ACPI Spec) */

 10 - 7F are reserved */

 80 - 84 are per-object-type */

 84 - BF are device-specific */

 C0 and above are hardware-specific */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_argument_type_name

 *

 * PARAMETERS:  arg_type            - an ARGP_* parser argument type

 *

 * RETURN:      Decoded ARGP_* type

 *

 * DESCRIPTION: Decode an ARGP_* parser type, as defined in the amlcode.h file,

 *              and used in the acopcode.h file. For example, ARGP_TERMARG.

 *              Used for debug only.

 *

 00 */ "Unknown ARGP",

 01 */ "ByteData",

 02 */ "ByteList",

 03 */ "CharList",

 04 */ "DataObject",

 05 */ "DataObjectList",

 06 */ "DWordData",

 07 */ "FieldList",

 08 */ "Name",

 09 */ "NameString",

 0A */ "ObjectList",

 0B */ "PackageLength",

 0C */ "SuperName",

 0D */ "Target",

 0E */ "TermArg",

 0F */ "TermList",

 10 */ "WordData",

 11 */ "QWordData",

 12 */ "SimpleName",

 13 */ "NameOrRef"

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_valid_object_type

 *

 * PARAMETERS:  type            - Object type to be validated

 *

 * RETURN:      TRUE if valid object type, FALSE otherwise

 *

 * DESCRIPTION: Validate an object type

 *

 Note: Assumes all TYPEs are contiguous (external/local) */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: dbobject - ACPI object decode and display

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_dump_method_info

 *

 * PARAMETERS:  status          - Method execution status

 *              walk_state      - Current state of the parse tree walk

 *

 * RETURN:      None

 *

 * DESCRIPTION: Called when a method has been aborted because of an error.

 *              Dumps the method execution stack, and the method locals/args,

 *              and disassembles the AML opcode that failed.

 *

 There are no locals or arguments for the module-level code case */

 Ignore control codes, they are not errors */

 We may be executing a deferred opcode */

	/*

	 * If there is no Thread, we are not actually executing a method.

	 * This can happen when the iASL compiler calls the interpreter

	 * to perform constant folding.

 Display the method locals and arguments */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_decode_internal_object

 *

 * PARAMETERS:  obj_desc        - Object to be displayed

 *

 * RETURN:      None

 *

 * DESCRIPTION: Short display of an internal object. Numbers/Strings/Buffers.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_decode_node

 *

 * PARAMETERS:  node        - Object to be displayed

 *

 * RETURN:      None

 *

 * DESCRIPTION: Short display of a namespace node

 *

 These types have no attached object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_display_internal_object

 *

 * PARAMETERS:  obj_desc        - Object to be displayed

 *              walk_state      - Current walk state

 *

 * RETURN:      None

 *

 * DESCRIPTION: Short display of an internal object

 *

 Decode the object type */

 Decode the ACPI object type */

 Decode the reference */

 Reference can be to a Node or an Operand object */

 Unknown reference class */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_decode_locals

 *

 * PARAMETERS:  walk_state      - State for current method

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display all locals for the currently running control method

 *

 There are no locals for the module-level code case */

 Are any locals actually set? */

 If any are set, only display the ones that are set */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_decode_arguments

 *

 * PARAMETERS:  walk_state      - State for current method

 *

 * RETURN:      None

 *

 * DESCRIPTION: Display all arguments for the currently running control method

 *

 There are no arguments for the module-level code case */

 Are any arguments actually set? */

 If any are set, only display the ones that are set */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: evxfevnt - External Interfaces, ACPI event disable/enable

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Entire module */

/*******************************************************************************

 *

 * FUNCTION:    acpi_enable

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Transfers the system into ACPI mode.

 *

 ACPI tables must be present */

 If the Hardware Reduced flag is set, machine is always in acpi mode */

 Check current mode */

 Transition to ACPI mode */

 Sanity check that transition succeeded */

 100 usec */

/*******************************************************************************

 *

 * FUNCTION:    acpi_disable

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Transfers the system into LEGACY (non-ACPI) mode.

 *

 If the Hardware Reduced flag is set, machine is always in acpi mode */

 Transition to LEGACY mode */

/*******************************************************************************

 *

 * FUNCTION:    acpi_enable_event

 *

 * PARAMETERS:  event           - The fixed eventto be enabled

 *              flags           - Reserved

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Enable an ACPI event (fixed)

 *

 If Hardware Reduced flag is set, there are no fixed events */

 Decode the Fixed Event */

	/*

	 * Enable the requested fixed event (by writing a one to the enable

	 * register bit)

 Make sure that the hardware responded */

/*******************************************************************************

 *

 * FUNCTION:    acpi_disable_event

 *

 * PARAMETERS:  event           - The fixed event to be disabled

 *              flags           - Reserved

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Disable an ACPI event (fixed)

 *

 If Hardware Reduced flag is set, there are no fixed events */

 Decode the Fixed Event */

	/*

	 * Disable the requested fixed event (by writing a zero to the enable

	 * register bit)

/*******************************************************************************

 *

 * FUNCTION:    acpi_clear_event

 *

 * PARAMETERS:  event           - The fixed event to be cleared

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Clear an ACPI event (fixed)

 *

 If Hardware Reduced flag is set, there are no fixed events */

 Decode the Fixed Event */

	/*

	 * Clear the requested fixed event (By writing a one to the status

	 * register bit)

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_event_status

 *

 * PARAMETERS:  event           - The fixed event

 *              event_status    - Where the current status of the event will

 *                                be returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Obtains and returns the current status of the event

 *

 Decode the Fixed Event */

 Fixed event currently can be dispatched? */

 Fixed event currently enabled? */

 Fixed event currently active? */

 !ACPI_REDUCED_HARDWARE */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exstoren - AML Interpreter object store support,

 *                        Store to Node (namespace object)

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_resolve_object

 *

 * PARAMETERS:  source_desc_ptr     - Pointer to the source object

 *              target_type         - Current type of the target

 *              walk_state          - Current walk state

 *

 * RETURN:      Status, resolved object in source_desc_ptr.

 *

 * DESCRIPTION: Resolve an object. If the object is a reference, dereference

 *              it and return the actual object in the source_desc_ptr.

 *

 Ensure we have a Target that can be stored to */

		/*

		 * These cases all require only Integers or values that

		 * can be converted to Integers (Strings or Buffers)

		/*

		 * Stores into a Field/Region or into a Integer/Buffer/String

		 * are all essentially the same. This case handles the

		 * "interchangeable" types Integer, String, and Buffer.

 Resolve a reference object first */

 For copy_object, no further validation necessary */

 Must have a Integer, Buffer, or String */

 Conversion successful but still not a valid type */

		/*

		 * All aliases should have been resolved earlier, during the

		 * operand resolution phase.

		/*

		 * All other types than Alias and the various Fields come here,

		 * including the untyped case - ACPI_TYPE_ANY.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_store_object_to_object

 *

 * PARAMETERS:  source_desc         - Object to store

 *              dest_desc           - Object to receive a copy of the source

 *              new_desc            - New object if dest_desc is obsoleted

 *              walk_state          - Current walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: "Store" an object to another object. This may include

 *              converting the source type to the target type (implicit

 *              conversion), and a copy of the value of the source to

 *              the target.

 *

 *              The Assignment of an object to another (not named) object

 *              is handled here.

 *              The Source passed in will replace the current value (if any)

 *              with the input value.

 *

 *              When storing into an object the data is converted to the

 *              target object type then stored in the object. This means

 *              that the target object type (for an initialized target) will

 *              not be changed by a store operation.

 *

 *              This module allows destination types of Number, String,

 *              Buffer, and Package.

 *

 *              Assumes parameters are already validated. NOTE: source_desc

 *              resolution (from a reference object) must be performed by

 *              the caller if necessary.

 *

		/*

		 * There is no destination object (An uninitialized node or

		 * package element), so we can simply copy the source object

		 * creating a new destination object

		/*

		 * The source type does not match the type of the destination.

		 * Perform the "implicit conversion" of the source to the current type

		 * of the target as per the ACPI specification.

		 *

		 * If no conversion performed, actual_src_desc = source_desc.

		 * Otherwise, actual_src_desc is a temporary object to hold the

		 * converted object.

			/*

			 * No conversion was performed. Return the source_desc as the

			 * new object.

	/*

	 * We now have two objects of identical types, and we can perform a

	 * copy of the *value* of the source object.

 Truncate value if we are executing from a 32-bit ACPI table */

		/*

		 * All other types come here.

 Delete the intermediate (temporary) source object */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: utstate - state object support procedures

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_push_generic_state

 *

 * PARAMETERS:  list_head           - Head of the state stack

 *              state               - State object to push

 *

 * RETURN:      None

 *

 * DESCRIPTION: Push a state object onto a state stack

 *

 Push the state object onto the front of the list (stack) */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_pop_generic_state

 *

 * PARAMETERS:  list_head           - Head of the state stack

 *

 * RETURN:      The popped state object

 *

 * DESCRIPTION: Pop a state object from a state stack

 *

 Remove the state object at the head of the list (stack) */

 Update the list head */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_create_generic_state

 *

 * PARAMETERS:  None

 *

 * RETURN:      The new state object. NULL on failure.

 *

 * DESCRIPTION: Create a generic state object. Attempt to obtain one from

 *              the global state cache;  If none available, create a new one.

 *

 Initialize */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_create_thread_state

 *

 * PARAMETERS:  None

 *

 * RETURN:      New Thread State. NULL on failure

 *

 * DESCRIPTION: Create a "Thread State" - a flavor of the generic state used

 *              to track per-thread info during method execution

 *

 Create the generic state object */

 Init fields specific to the update struct */

 Check for invalid thread ID - zero is very bad, it will break things */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_create_update_state

 *

 * PARAMETERS:  object          - Initial Object to be installed in the state

 *              action          - Update action to be performed

 *

 * RETURN:      New state object, null on failure

 *

 * DESCRIPTION: Create an "Update State" - a flavor of the generic state used

 *              to update reference counts and delete complex objects such

 *              as packages.

 *

 Create the generic state object */

 Init fields specific to the update struct */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_create_pkg_state

 *

 * PARAMETERS:  object          - Initial Object to be installed in the state

 *              action          - Update action to be performed

 *

 * RETURN:      New state object, null on failure

 *

 * DESCRIPTION: Create a "Package State"

 *

 Create the generic state object */

 Init fields specific to the update struct */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_create_control_state

 *

 * PARAMETERS:  None

 *

 * RETURN:      New state object, null on failure

 *

 * DESCRIPTION: Create a "Control State" - a flavor of the generic state used

 *              to support nested IF/WHILE constructs in the AML.

 *

 Create the generic state object */

 Init fields specific to the control struct */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_delete_generic_state

 *

 * PARAMETERS:  state               - The state object to be deleted

 *

 * RETURN:      None

 *

 * DESCRIPTION: Release a state object to the state cache. NULL state objects

 *              are ignored.

 *

 Ignore null state */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: nsconvert - Object conversions for objects returned by

 *                          predefined methods

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_convert_to_integer

 *

 * PARAMETERS:  original_object     - Object to be converted

 *              return_object       - Where the new converted object is returned

 *

 * RETURN:      Status. AE_OK if conversion was successful.

 *

 * DESCRIPTION: Attempt to convert a String/Buffer object to an Integer.

 *

 String-to-Integer conversion */

 Buffer-to-Integer conversion. Max buffer size is 64 bits. */

 Extract each buffer byte to create the integer */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_convert_to_string

 *

 * PARAMETERS:  original_object     - Object to be converted

 *              return_object       - Where the new converted object is returned

 *

 * RETURN:      Status. AE_OK if conversion was successful.

 *

 * DESCRIPTION: Attempt to convert a Integer/Buffer object to a String.

 *

		/*

		 * Integer-to-String conversion. Commonly, convert

		 * an integer of value 0 to a NULL string. The last element of

		 * _BIF and _BIX packages occasionally need this fix.

 Allocate a new NULL string object */

		/*

		 * Buffer-to-String conversion. Use a to_string

		 * conversion, no transform performed on the buffer data. The best

		 * example of this is the _BIF method, where the string data from

		 * the battery is often (incorrectly) returned as buffer object(s).

 Allocate a new string object */

		/*

		 * Copy the raw buffer data with no transform. String is already NULL

		 * terminated at Length+1.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_convert_to_buffer

 *

 * PARAMETERS:  original_object     - Object to be converted

 *              return_object       - Where the new converted object is returned

 *

 * RETURN:      Status. AE_OK if conversion was successful.

 *

 * DESCRIPTION: Attempt to convert a Integer/String/Package object to a Buffer.

 *

		/*

		 * Integer-to-Buffer conversion.

		 * Convert the Integer to a packed-byte buffer. _MAT and other

		 * objects need this sometimes, if a read has been performed on a

		 * Field object that is less than or equal to the global integer

		 * size (32 or 64 bits).

 String-to-Buffer conversion. Simple data copy */

		/*

		 * This case is often seen for predefined names that must return a

		 * Buffer object with multiple DWORD integers within. For example,

		 * _FDE and _GTM. The Package can be converted to a Buffer.

 All elements of the Package must be integers */

 Create the new buffer object to replace the Package */

 Copy the package elements (integers) to the buffer as DWORDs */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_convert_to_unicode

 *

 * PARAMETERS:  scope               - Namespace node for the method/object

 *              original_object     - ASCII String Object to be converted

 *              return_object       - Where the new converted object is returned

 *

 * RETURN:      Status. AE_OK if conversion was successful.

 *

 * DESCRIPTION: Attempt to convert a String object to a Unicode string Buffer.

 *

 If a Buffer was returned, it must be at least two bytes long */

	/*

	 * The original object is an ASCII string. Convert this string to

	 * a unicode buffer.

 Create a new buffer object for the Unicode data */

 Convert ASCII to Unicode */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_convert_to_resource

 *

 * PARAMETERS:  scope               - Namespace node for the method/object

 *              original_object     - Object to be converted

 *              return_object       - Where the new converted object is returned

 *

 * RETURN:      Status. AE_OK if conversion was successful

 *

 * DESCRIPTION: Attempt to convert a Integer object to a resource_template

 *              Buffer.

 *

	/*

	 * We can fix the following cases for an expected resource template:

	 * 1. No return value (interpreter slack mode is disabled)

	 * 2. A "Return (Zero)" statement

	 * 3. A "Return empty buffer" statement

	 *

	 * We will return a buffer containing a single end_tag

	 * resource descriptor.

 We can only repair an Integer==0 */

 Additional checks can be added in the future */

 Create the new buffer object for the resource descriptor */

 Initialize the Buffer with a single end_tag descriptor */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_convert_to_reference

 *

 * PARAMETERS:  scope               - Namespace node for the method/object

 *              original_object     - Object to be converted

 *              return_object       - Where the new converted object is returned

 *

 * RETURN:      Status. AE_OK if conversion was successful

 *

 * DESCRIPTION: Attempt to convert a Integer object to a object_reference.

 *              Buffer.

 *

 Convert path into internal presentation */

 Find the namespace node */

 Check if we are resolving a named reference within a package */

 Create and init a new internal ACPI object */

	/*

	 * Increase reference of the object if needed (the object is likely a

	 * null for device nodes).

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: psopinfo - AML opcode information functions and dispatch tables

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_get_opcode_info

 *

 * PARAMETERS:  opcode              - The AML opcode

 *

 * RETURN:      A pointer to the info about the opcode.

 *

 * DESCRIPTION: Find AML opcode description based on the opcode.

 *              NOTE: This procedure must ALWAYS return a valid pointer!

 *

	/*

	 * Detect normal 8-bit opcode or extended 16-bit opcode

 Simple (8-bit) opcode: 0-255, can't index beyond table  */

 Valid extended (16-bit) opcode */

 Unknown AML opcode */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_get_opcode_name

 *

 * PARAMETERS:  opcode              - The AML opcode

 *

 * RETURN:      A pointer to the name of the opcode (ASCII String)

 *              Note: Never returns NULL.

 *

 * DESCRIPTION: Translate an opcode into a human-readable string

 *

 Always guaranteed to return a valid pointer */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_get_argument_count

 *

 * PARAMETERS:  op_type             - Type associated with the AML opcode

 *

 * RETURN:      Argument count

 *

 * DESCRIPTION: Obtain the number of expected arguments for an AML opcode

 *

/*

 * This table is directly indexed by the opcodes It returns

 * an index into the opcode table (acpi_gbl_aml_op_info)

              0     1     2     3     4     5     6     7  */

              8     9     A     B     C     D     E     F  */

 0x00 */ 0x00, 0x01, _UNK, _UNK, _UNK, _UNK, 0x02, _UNK,

 0x08 */ 0x03, _UNK, 0x04, 0x05, 0x06, 0x07, 0x6E, _UNK,

 0x10 */ 0x08, 0x09, 0x0a, 0x6F, 0x0b, 0x81, _UNK, _UNK,

 0x18 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0x20 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0x28 */ _UNK, _UNK, _UNK, _UNK, _UNK, 0x63, _PFX, _PFX,

 0x30 */ 0x67, 0x66, 0x68, 0x65, 0x69, 0x64, 0x6A, 0x7D,

 0x38 */ 0x7F, 0x80, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0x40 */ _UNK, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC,

 0x48 */ _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC,

 0x50 */ _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC,

 0x58 */ _ASC, _ASC, _ASC, _UNK, _PFX, _UNK, _PFX, _ASC,

 0x60 */ 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,

 0x68 */ 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, _UNK,

 0x70 */ 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22,

 0x78 */ 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a,

 0x80 */ 0x2b, 0x2c, 0x2d, 0x2e, 0x70, 0x71, 0x2f, 0x30,

 0x88 */ 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x72,

 0x90 */ 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x73, 0x74,

 0x98 */ 0x75, 0x76, _UNK, _UNK, 0x77, 0x78, 0x79, 0x7A,

 0xA0 */ 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x60, 0x61,

 0xA8 */ 0x62, 0x82, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0xB0 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0xB8 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0xC0 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0xC8 */ _UNK, _UNK, _UNK, _UNK, 0x44, _UNK, _UNK, _UNK,

 0xD0 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0xD8 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0xE0 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0xE8 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0xF0 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0xF8 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, 0x45,

/*

 * This table is indexed by the second opcode of the extended opcode

 * pair. It returns an index into the opcode table (acpi_gbl_aml_op_info)

              0     1     2     3     4     5     6     7  */

              8     9     A     B     C     D     E     F  */

 0x00 */ _UNK, 0x46, 0x47, _UNK, _UNK, _UNK, _UNK, _UNK,

 0x08 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0x10 */ _UNK, _UNK, 0x48, 0x49, _UNK, _UNK, _UNK, _UNK,

 0x18 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, 0x7B,

 0x20 */ 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51,

 0x28 */ 0x52, 0x53, 0x54, _UNK, _UNK, _UNK, _UNK, _UNK,

 0x30 */ 0x55, 0x56, 0x57, 0x7e, _UNK, _UNK, _UNK, _UNK,

 0x38 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0x40 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0x48 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0x50 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0x58 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0x60 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0x68 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0x70 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0x78 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,

 0x80 */ 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,

 0x88 */ 0x7C,

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: dsmethod - Parser/Interpreter interface - control method parsing

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_auto_serialize_method

 *

 * PARAMETERS:  node                        - Namespace Node of the method

 *              obj_desc                    - Method object attached to node

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Parse a control method AML to scan for control methods that

 *              need serialization due to the creation of named objects.

 *

 * NOTE: It is a bit of overkill to mark all such methods serialized, since

 * there is only a problem if the method actually blocks during execution.

 * A blocking operation is, for example, a Sleep() operation, or any access

 * to an operation region. However, it is probably not possible to easily

 * detect whether a method will block or not, so we simply mark all suspicious

 * methods as serialized.

 *

 * NOTE2: This code is essentially a generic routine for parsing a single

 * control method.

 *

 Create/Init a root op for the method parse tree */

 Create and initialize a new walk state */

 Parse the method, scan for creation of named objects */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_detect_named_opcodes

 *

 * PARAMETERS:  walk_state      - Current state of the parse tree walk

 *              out_op          - Unused, required for parser interface

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Descending callback used during the loading of ACPI tables.

 *              Currently used to detect methods that must be marked serialized

 *              in order to avoid problems with the creation of named objects.

 *

 We are only interested in opcodes that create a new name */

	/*

	 * At this point, we know we have a Named object opcode.

	 * Mark the method as serialized. Later code will create a mutex for

	 * this method to enforce serialization.

	 *

	 * Note, ACPI_METHOD_IGNORE_SYNC_LEVEL flag means that we will ignore the

	 * Sync Level mechanism for this method, even though it is now serialized.

	 * Otherwise, there can be conflicts with existing ASL code that actually

	 * uses sync levels.

 Abort the parse, no need to examine this method any further */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_method_error

 *

 * PARAMETERS:  status          - Execution status

 *              walk_state      - Current state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Called on method error. Invoke the global exception handler if

 *              present, dump the method data if the debugger is configured

 *

 *              Note: Allows the exception handler to change the status code

 *

 Ignore AE_OK and control exception codes */

 Invoke the global exception handler */

 Exit the interpreter, allow handler to execute methods */

		/*

		 * Handler can map the exception code to anything it wants, including

		 * AE_OK, in which case the executing method will not be aborted.

 Display method locals/args if debugger is present */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_create_method_mutex

 *

 * PARAMETERS:  obj_desc            - The method object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create a mutex object for a serialized control method

 *

 Create the new mutex object */

 Create the actual OS Mutex */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_begin_method_execution

 *

 * PARAMETERS:  method_node         - Node of the method

 *              obj_desc            - The method object

 *              walk_state          - current state, NULL if not yet executing

 *                                    a method.

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Prepare a method for execution. Parses the method if necessary,

 *              increments the thread count, and waits at the method semaphore

 *              for clearance to execute.

 *

 Prevent wraparound of thread count */

	/*

	 * If this method is serialized, we need to acquire the method mutex.

		/*

		 * Create a mutex for the method if it is defined to be Serialized

		 * and a mutex has not already been created. We defer the mutex creation

		 * until a method is actually executed, to minimize the object count

		/*

		 * The current_sync_level (per-thread) must be less than or equal to

		 * the sync level of the method. This mechanism provides some

		 * deadlock prevention.

		 *

		 * If the method was auto-serialized, we just ignore the sync level

		 * mechanism, because auto-serialization of methods can interfere

		 * with ASL code that actually uses sync levels.

		 *

		 * Top-level method invocation has no walk state at this point

		/*

		 * Obtain the method mutex if necessary. Do not acquire mutex for a

		 * recursive call.

			/*

			 * Acquire the method mutex. This releases the interpreter if we

			 * block (and reacquires it before it returns)

 Update the mutex and walk info and save the original sync_level */

				/*

				 * Update the current sync_level only if this is not an auto-

				 * serialized method. In the auto case, we have to ignore

				 * the sync level for the method mutex (created for the

				 * auto-serialization) because we have no idea of what the

				 * sync level should be. Therefore, just ignore it.

 Always increase acquisition depth */

	/*

	 * Allocate an Owner ID for this method, only if this is the first thread

	 * to begin concurrent execution. We only need one owner_id, even if the

	 * method is invoked recursively.

	/*

	 * Increment the method parse tree thread count since it has been

	 * reentered one more time (even if it is the same thread)

 On error, must release the method mutex (if present) */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_call_control_method

 *

 * PARAMETERS:  thread              - Info for this thread

 *              this_walk_state     - Current walk state

 *              op                  - Current Op to be walked

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Transfer execution to a called control method

 *

	/*

	 * Get the namespace entry for the control method we are about to call

 Init for new method, possibly wait on method mutex */

 Begin method parse/execution. Create a new walk state */

	/*

	 * The resolved arguments were put on the previous walk state's operand

	 * stack. Operands on the previous walk state stack always

	 * start at index 0. Also, null terminate the list of arguments

	/*

	 * Allocate and initialize the evaluation information block

	 * TBD: this is somewhat inefficient, should change interface to

	 * ds_init_aml_walk. For now, keeps this struct off the CPU stack

	/*

	 * Delete the operands on the previous walkstate operand stack

	 * (they were copied to new objects)

 Clear the operand stack */

 Optional object evaluation log */

 Invoke an internal method if necessary */

 On error, we must terminate the method properly */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_restart_control_method

 *

 * PARAMETERS:  walk_state          - State for preempted method (caller)

 *              return_desc         - Return value from the called method

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Restart a method that was preempted by another (nested) method

 *              invocation. Handle the return value (if any) from the callee.

 *

 Did the called method return a value? */

 Is the implicit return object the same as the return desc? */

 Are we actually going to use the return value? */

 Save the return value from the previous method */

			/*

			 * Save as THIS method's return value in case it is returned

			 * immediately to yet another method

		/*

		 * The following code is the optional support for the so-called

		 * "implicit return". Some AML code assumes that the last value of the

		 * method is "implicitly" returned to the caller, in the absence of an

		 * explicit return value.

		 *

		 * Just save the last result of the method as the return value.

		 *

		 * NOTE: this is optional because the ASL language does not actually

		 * support this behavior.

			/*

			 * Delete the return value if it will not be used by the

			 * calling method or remove one reference if the explicit return

			 * is the same as the implicit return value.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_terminate_control_method

 *

 * PARAMETERS:  method_desc         - Method object

 *              walk_state          - State associated with the method

 *

 * RETURN:      None

 *

 * DESCRIPTION: Terminate a control method. Delete everything that the method

 *              created, delete all locals and arguments, and delete the parse

 *              tree if requested.

 *

 * MUTEX:       Interpreter is locked

 *

 method_desc is required, walk_state is optional */

 Delete all arguments and locals */

		/*

		 * Delete any namespace objects created anywhere within the

		 * namespace by the execution of this method. Unless:

		 * 1) This method is a module-level executable code method, in which

		 *    case we want make the objects permanent.

		 * 2) There are other threads executing the method, in which case we

		 *    will wait until the last thread has completed.

 Delete any direct children of (created by) this method */

			/*

			 * Delete any objects that were created by this method

			 * elsewhere in the namespace (if any were created).

			 * Use of the ACPI_METHOD_MODIFIED_NAMESPACE optimizes the

			 * deletion such that we don't have to perform an entire

			 * namespace walk for every control method execution.

		/*

		 * If method is serialized, release the mutex and restore the

		 * current sync level for this thread

 Acquisition Depth handles recursive calls */

 Decrement the thread count on the method */

 Are there any other threads currently executing this method? */

		/*

		 * Additional threads. Do not release the owner_id in this case,

		 * we immediately reuse it for the next thread executing this method

 This is the only executing thread for this method */

		/*

		 * Support to dynamically change a method from not_serialized to

		 * Serialized if it appears that the method is incorrectly written and

		 * does not support multiple thread execution. The best example of this

		 * is if such a method creates namespace objects and blocks. A second

		 * thread will fail with an AE_ALREADY_EXISTS exception.

		 *

		 * This code is here because we must wait until the last thread exits

		 * before marking the method as serialized.

			/*

			 * Method tried to create an object twice and was marked as

			 * "pending serialized". The probable cause is that the method

			 * cannot handle reentrancy.

			 *

			 * The method was created as not_serialized, but it tried to create

			 * a named object and then blocked, causing the second thread

			 * entrance to begin and then fail. Workaround this problem by

			 * marking the method permanently as Serialized when the last

			 * thread exits here.

 No more threads, we can free the owner_id */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: nsload - namespace loading/expanding/contracting procedures

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_load_table

 *

 * PARAMETERS:  table_index     - Index for table to be loaded

 *              node            - Owning NS node

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Load one ACPI table into the namespace

 *

 If table already loaded into namespace, just return */

	/*

	 * Parse the table and load the namespace with all named

	 * objects found within. Control methods are NOT parsed

	 * at this time. In fact, the control methods cannot be

	 * parsed until the entire namespace is loaded, because

	 * if a control method makes a forward reference (call)

	 * to another control method, we can't continue parsing

	 * because we don't know how many arguments to parse next!

		/*

		 * On error, delete any namespace objects created by this table.

		 * We cannot initialize these objects, so delete them. There are

		 * a couple of especially bad cases:

		 * AE_ALREADY_EXISTS - namespace collision.

		 * AE_NOT_FOUND - the target of a Scope operator does not

		 * exist. This target of Scope must already exist in the

		 * namespace, as per the ACPI specification.

	/*

	 * Now we can parse the control methods. We always parse

	 * them here for a sanity check, and if configured for

	 * just-in-time parsing, we delete the control method

	 * parse trees.

/*******************************************************************************

 *

 * FUNCTION:    acpi_load_namespace

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Load the name space from what ever is pointed to by DSDT.

 *              (DSDT points to either the BIOS or a buffer.)

 *

 There must be at least a DSDT installed */

	/*

	 * Load the namespace. The DSDT is required,

	 * but the SSDT and PSDT tables are optional.

 Ignore exceptions from these */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_delete_subtree

 *

 * PARAMETERS:  start_handle        - Handle in namespace where search begins

 *

 * RETURNS      Status

 *

 * DESCRIPTION: Walks the namespace starting at the given handle and deletes

 *              all objects, entries, and scopes in the entire subtree.

 *

 *              Namespace/Interpreter should be locked or the subsystem should

 *              be in shutdown before this routine is called.

 *

	/*

	 * Traverse the tree of objects until we bubble back up

	 * to where we started.

 Attempt to get the next object in this scope */

 Did we get a new object? */

 Check if this object has any children */

				/*

				 * There is at least one child of this object,

				 * visit the object

			/*

			 * No more children in this object, go back up to

			 * the object's parent

 Delete all children now */

 Now delete the starting object, and we are done */

/*******************************************************************************

 *

 *  FUNCTION:       acpi_ns_unload_name_space

 *

 *  PARAMETERS:     handle          - Root of namespace subtree to be deleted

 *

 *  RETURN:         Status

 *

 *  DESCRIPTION:    Shrinks the namespace, typically in response to an undocking

 *                  event. Deletes an entire subtree starting from (and

 *                  including) the given handle.

 *

 Parameter validation */

 This function does the real work */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: nswalk - Functions for walking the ACPI namespace

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_get_next_node

 *

 * PARAMETERS:  parent_node         - Parent node whose children we are

 *                                    getting

 *              child_node          - Previous child that was found.

 *                                    The NEXT child will be returned

 *

 * RETURN:      struct acpi_namespace_node - Pointer to the NEXT child or NULL if

 *                                    none is found.

 *

 * DESCRIPTION: Return the next peer node within the namespace. If Handle

 *              is valid, Scope is ignored. Otherwise, the first node

 *              within Scope is returned.

 *

 It's really the parent's _scope_ that we want */

 Otherwise just return the next peer */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_get_next_node_typed

 *

 * PARAMETERS:  type                - Type of node to be searched for

 *              parent_node         - Parent node whose children we are

 *                                    getting

 *              child_node          - Previous child that was found.

 *                                    The NEXT child will be returned

 *

 * RETURN:      struct acpi_namespace_node - Pointer to the NEXT child or NULL if

 *                                    none is found.

 *

 * DESCRIPTION: Return the next peer node within the namespace. If Handle

 *              is valid, Scope is ignored. Otherwise, the first node

 *              within Scope is returned.

 *

 If any type is OK, we are done */

 next_node is NULL if we are at the end-of-list */

 Must search for the node -- but within this scope only */

 If type matches, we are done */

 Otherwise, move on to the next peer node */

 Not found */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_walk_namespace

 *

 * PARAMETERS:  type                - acpi_object_type to search for

 *              start_node          - Handle in namespace where search begins

 *              max_depth           - Depth to which search is to reach

 *              flags               - Whether to unlock the NS before invoking

 *                                    the callback routine

 *              descending_callback - Called during tree descent

 *                                    when an object of "Type" is found

 *              ascending_callback  - Called during tree ascent

 *                                    when an object of "Type" is found

 *              context             - Passed to user function(s) above

 *              return_value        - from the user_function if terminated

 *                                    early. Otherwise, returns NULL.

 * RETURNS:     Status

 *

 * DESCRIPTION: Performs a modified depth-first walk of the namespace tree,

 *              starting (and ending) at the node specified by start_handle.

 *              The callback function is called whenever a node that matches

 *              the type parameter is found. If the callback function returns

 *              a non-zero value, the search is terminated immediately and

 *              this value is returned to the caller.

 *

 *              The point of this procedure is to provide a generic namespace

 *              walk routine that can be called from multiple places to

 *              provide multiple services; the callback function(s) can be

 *              tailored to each task, whether it is a print function,

 *              a compare function, etc.

 *

 Special case for the namespace Root Node */

 Null child means "get first node" */

	/*

	 * Traverse the tree of nodes until we bubble back up to where we

	 * started. When Level is zero, the loop is done because we have

	 * bubbled up to (and passed) the original parent handle (start_entry)

 Found next child, get the type if we are not searching for ANY */

		/*

		 * Ignore all temporary namespace nodes (created during control

		 * method execution) unless told otherwise. These temporary nodes

		 * can cause a race condition because they can be deleted during

		 * the execution of the user function (if the namespace is

		 * unlocked before invocation of the user function.) Only the

		 * debugger namespace dump will examine the temporary nodes.

 Type must match requested type */

			/*

			 * Found a matching node, invoke the user callback function.

			 * Unlock the namespace if flag is set.

			/*

			 * Invoke the user function, either descending, ascending,

			 * or both.

 Just keep going */

 Exit now, with OK status */

 All others are valid exceptions */

		/*

		 * Depth first search: Attempt to go down another level in the

		 * namespace if we are allowed to. Don't go any further if we have

		 * reached the caller specified maximum depth or if the user

		 * function has specified that the maximum depth has been reached.

 There is at least one child of this node, visit it */

 No more children, re-visit this node */

 No more children, visit peers */

 No peers, re-visit parent */

			/*

			 * No more children of this node (acpi_ns_get_next_node failed), go

			 * back upwards in the namespace tree to the node's parent.

 Complete walk, not terminated by user function */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: dsdebug - Parser/Interpreter interface - debugging

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_print_node_pathname

 *

 * PARAMETERS:  node            - Object

 *              message         - Prefix message

 *

 * DESCRIPTION: Print an object's full namespace pathname

 *              Manages allocation/freeing of a pathname buffer

 *

 Convert handle to full pathname and print it (with supplied message) */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_dump_method_stack

 *

 * PARAMETERS:  status          - Method execution status

 *              walk_state      - Current state of the parse tree walk

 *              op              - Executing parse op

 *

 * RETURN:      None

 *

 * DESCRIPTION: Called when a method has been aborted because of an error.

 *              Dumps the method execution stack.

 *

 Ignore control codes, they are not errors */

 We may be executing a deferred opcode */

	/*

	 * If there is no Thread, we are not actually executing a method.

	 * This can happen when the iASL compiler calls the interpreter

	 * to perform constant folding.

 Display exception and method name */

 Display stack of executing methods */

 Walk list of linked walk states */

 First method is the currently executing method */

 Display currently executing ASL statement */

 More verbose if not module-level code */

			/*

			 * This method has called another method

			 * NOTE: the method call parse subtree is already deleted at

			 * this point, so we cannot disassemble the method invocation.

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: uterror - Various internal error/warning output functions

 *

/*

 * This module contains internal error functions that may

 * be configured out.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_predefined_warning

 *

 * PARAMETERS:  module_name     - Caller's module name (for error output)

 *              line_number     - Caller's line number (for error output)

 *              pathname        - Full pathname to the node

 *              node_flags      - From Namespace node for the method/object

 *              format          - Printf format string + additional args

 *

 * RETURN:      None

 *

 * DESCRIPTION: Warnings for the predefined validation module. Messages are

 *              only emitted the first time a problem with a particular

 *              method/object is detected. This prevents a flood of error

 *              messages for methods that are repeatedly evaluated.

 *

	/*

	 * Warning messages for this method/object will be disabled after the

	 * first time a validation fails or an object is successfully repaired.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_predefined_info

 *

 * PARAMETERS:  module_name     - Caller's module name (for error output)

 *              line_number     - Caller's line number (for error output)

 *              pathname        - Full pathname to the node

 *              node_flags      - From Namespace node for the method/object

 *              format          - Printf format string + additional args

 *

 * RETURN:      None

 *

 * DESCRIPTION: Info messages for the predefined validation module. Messages

 *              are only emitted the first time a problem with a particular

 *              method/object is detected. This prevents a flood of

 *              messages for methods that are repeatedly evaluated.

 *

	/*

	 * Warning messages for this method/object will be disabled after the

	 * first time a validation fails or an object is successfully repaired.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_predefined_bios_error

 *

 * PARAMETERS:  module_name     - Caller's module name (for error output)

 *              line_number     - Caller's line number (for error output)

 *              pathname        - Full pathname to the node

 *              node_flags      - From Namespace node for the method/object

 *              format          - Printf format string + additional args

 *

 * RETURN:      None

 *

 * DESCRIPTION: BIOS error message for predefined names. Messages

 *              are only emitted the first time a problem with a particular

 *              method/object is detected. This prevents a flood of

 *              messages for methods that are repeatedly evaluated.

 *

	/*

	 * Warning messages for this method/object will be disabled after the

	 * first time a validation fails or an object is successfully repaired.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_prefixed_namespace_error

 *

 * PARAMETERS:  module_name         - Caller's module name (for error output)

 *              line_number         - Caller's line number (for error output)

 *              prefix_scope        - Scope/Path that prefixes the internal path

 *              internal_path       - Name or path of the namespace node

 *              lookup_status       - Exception code from NS lookup

 *

 * RETURN:      None

 *

 * DESCRIPTION: Print error message with the full pathname constructed this way:

 *

 *                  prefix_scope_node_full_path.externalized_internal_path

 *

 * NOTE:        10/2017: Treat the major ns_lookup errors as firmware errors

 *

	/*

	 * Main cases:

	 * 1) Object creation, object must not already exist

	 * 2) Object lookup, object must exist

 Concatenate the prefix path and the internal path */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_namespace_error

 *

 * PARAMETERS:  module_name         - Caller's module name (for error output)

 *              line_number         - Caller's line number (for error output)

 *              internal_name       - Name or path of the namespace node

 *              lookup_status       - Exception code from NS lookup

 *

 * RETURN:      None

 *

 * DESCRIPTION: Print error message with the full pathname for the NS node.

 *

 There is a non-ascii character in the name */

 Convert path to external format */

 Print target name */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_method_error

 *

 * PARAMETERS:  module_name         - Caller's module name (for error output)

 *              line_number         - Caller's line number (for error output)

 *              message             - Error message to use on failure

 *              prefix_node         - Prefix relative to the path

 *              path                - Path to the node (optional)

 *              method_status       - Execution status

 *

 * RETURN:      None

 *

 * DESCRIPTION: Print error message with the full pathname for the method.

 *

 ACPI_NO_ERROR_MESSAGES */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: tbxface - ACPI table-oriented external interfaces

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_allocate_root_table

 *

 * PARAMETERS:  initial_table_count - Size of initial_table_array, in number of

 *                                    struct acpi_table_desc structures

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Allocate a root table array. Used by iASL compiler and

 *              acpi_initialize_tables.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_initialize_tables

 *

 * PARAMETERS:  initial_table_array - Pointer to an array of pre-allocated

 *                                    struct acpi_table_desc structures. If NULL, the

 *                                    array is dynamically allocated.

 *              initial_table_count - Size of initial_table_array, in number of

 *                                    struct acpi_table_desc structures

 *              allow_resize        - Flag to tell Table Manager if resize of

 *                                    pre-allocated array is allowed. Ignored

 *                                    if initial_table_array is NULL.

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Initialize the table manager, get the RSDP and RSDT/XSDT.

 *

 * NOTE:        Allows static allocation of the initial table array in order

 *              to avoid the use of dynamic memory in confined environments

 *              such as the kernel boot sequence where it may not be available.

 *

 *              If the host OS memory managers are initialized, use NULL for

 *              initial_table_array, and the table will be dynamically allocated.

 *

	/*

	 * Setup the Root Table Array and allocate the table array

	 * if requested

 Root Table Array has been statically allocated by the host */

 Get the address of the RSDP */

	/*

	 * Get the root table (RSDT or XSDT) and extract all entries to the local

	 * Root Table Array. This array contains the information of the RSDT/XSDT

	 * in a common, more usable format.

/*******************************************************************************

 *

 * FUNCTION:    acpi_reallocate_root_table

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Reallocate Root Table List into dynamic memory. Copies the

 *              root list from the previously provided scratch area. Should

 *              be called once dynamic memory allocation is available in the

 *              kernel.

 *

	/*

	 * If there are tables unverified, it is required to reallocate the

	 * root table list to clean up invalid table entries. Otherwise only

	 * reallocate the root table list if the host provided a static buffer

	 * for the table array in the call to acpi_initialize_tables().

	/*

	 * Ensure OS early boot logic, which is required by some hosts. If the

	 * table state is reported to be wrong, developers should fix the

	 * issue by invoking acpi_put_table() for the reported table during the

	 * early stage.

		/*

		 * Now it's safe to do full table validation. We can do deferred

		 * table initialization here once the flag is set.

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_table_header

 *

 * PARAMETERS:  signature           - ACPI signature of needed table

 *              instance            - Which instance (for SSDTs)

 *              out_table_header    - The pointer to the where the table header

 *                                    is returned

 *

 * RETURN:      Status and a copy of the table header

 *

 * DESCRIPTION: Finds and returns an ACPI table header. Caller provides the

 *              memory where a copy of the header is to be returned

 *              (fixed length).

 *

 Parameter validation */

 Walk the root table list */

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_table

 *

 * PARAMETERS:  signature           - ACPI signature of needed table

 *              instance            - Which instance (for SSDTs)

 *              out_table           - Where the pointer to the table is returned

 *

 * RETURN:      Status and pointer to the requested table

 *

 * DESCRIPTION: Finds and verifies an ACPI table. Table must be in the

 *              RSDT/XSDT.

 *              Note that an early stage acpi_get_table() call must be paired

 *              with an early stage acpi_put_table() call. otherwise the table

 *              pointer mapped by the early stage mapping implementation may be

 *              erroneously unmapped by the late stage unmapping implementation

 *              in an acpi_put_table() invoked during the late stage.

 *

 Parameter validation */

	/*

	 * Note that the following line is required by some OSPMs, they only

	 * check if the returned table is NULL instead of the returned status

	 * to determined if this function is succeeded.

 Walk the root table list */

/*******************************************************************************

 *

 * FUNCTION:    acpi_put_table

 *

 * PARAMETERS:  table               - The pointer to the table

 *

 * RETURN:      None

 *

 * DESCRIPTION: Release a table returned by acpi_get_table() and its clones.

 *              Note that it is not safe if this function was invoked after an

 *              uninstallation happened to the original table descriptor.

 *              Currently there is no OSPMs' requirement to handle such

 *              situations.

 *

 Walk the root table list */

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_table_by_index

 *

 * PARAMETERS:  table_index         - Table index

 *              out_table           - Where the pointer to the table is returned

 *

 * RETURN:      Status and pointer to the requested table

 *

 * DESCRIPTION: Obtain a table by an index into the global table list. Used

 *              internally also.

 *

 Parameter validation */

	/*

	 * Note that the following line is required by some OSPMs, they only

	 * check if the returned table is NULL instead of the returned status

	 * to determined if this function is succeeded.

 Validate index */

/*******************************************************************************

 *

 * FUNCTION:    acpi_install_table_handler

 *

 * PARAMETERS:  handler         - Table event handler

 *              context         - Value passed to the handler on each event

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Install a global table event handler.

 *

 Don't allow more than one handler */

 Install the handler */

/*******************************************************************************

 *

 * FUNCTION:    acpi_remove_table_handler

 *

 * PARAMETERS:  handler         - Table event handler that was installed

 *                                previously.

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Remove a table event handler

 *

 Make sure that the installed handler is the same */

 Remove the handler */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: rsdump - AML debugger support for resource structures.

 *

/*

 * All functions in this module are used by the AML Debugger only

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_dump_resource_list

 *

 * PARAMETERS:  resource_list       - Pointer to a resource descriptor list

 *

 * RETURN:      None

 *

 * DESCRIPTION: Dispatches the structure to the correct dump routine.

 *

 Check if debug output enabled */

 Walk list and dump all resource descriptors (END_TAG terminates) */

 Validate Type before dispatch */

 Sanity check the length. It must not be zero, or we loop forever */

 Dump the resource descriptor */

 Point to the next resource structure */

 Exit when END_TAG descriptor is reached */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_dump_irq_list

 *

 * PARAMETERS:  route_table     - Pointer to the routing table to dump.

 *

 * RETURN:      None

 *

 * DESCRIPTION: Print IRQ routing table

 *

 Check if debug output enabled */

 Dump all table elements, Exit on zero length element */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_dump_descriptor

 *

 * PARAMETERS:  resource            - Buffer containing the resource

 *              table               - Table entry to decode the resource

 *

 * RETURN:      None

 *

 * DESCRIPTION: Dump a resource descriptor based on a dump table entry.

 *

 First table entry must contain the table length (# of table entries) */

			/*

			 * Optional resource title

 Strings */

 Data items, 8/16/32/64 bit */

 Flags: 1-bit and 2-bit flags supported */

			/*

			 * Short byte list (single line output) for DMA and IRQ resources

			 * Note: The list length is obtained from the previous table entry

			/*

			 * Short byte list (single line output) for GPIO vendor data

			 * Note: The list length is obtained from the previous table entry

			/*

			 * Long byte list for Vendor resource data

			 * Note: The list length is obtained from the previous table entry

			/*

			 * Dword list for Extended Interrupt resources

			 * Note: The list length is obtained from the previous table entry

			/*

			 * Word list for GPIO Pin Table

			 * Note: The list length is obtained from the previous table entry

			/*

			 * Common flags for all Address resources

			/*

			 * Optional resource_source for Address resources

			/*

			 * resource_label

			/*

			 * resource_source_label

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_dump_resource_source

 *

 * PARAMETERS:  resource_source     - Pointer to a Resource Source struct

 *

 * RETURN:      None

 *

 * DESCRIPTION: Common routine for dumping the optional resource_source and the

 *              corresponding resource_source_index.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_dump_resource_label

 *

 * PARAMETERS:  title              - Title of the dumped resource field

 *              resource_label     - Pointer to a Resource Label struct

 *

 * RETURN:      None

 *

 * DESCRIPTION: Common routine for dumping the resource_label

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_dump_address_common

 *

 * PARAMETERS:  resource        - Pointer to an internal resource descriptor

 *

 * RETURN:      None

 *

 * DESCRIPTION: Dump the fields that are common to all Address resource

 *              descriptors

 *

 Decode the type-specific flags */

 Decode the general flags */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_out*

 *

 * PARAMETERS:  title       - Name of the resource field

 *              value       - Value of the resource field

 *

 * RETURN:      None

 *

 * DESCRIPTION: Miscellaneous helper functions to consistently format the

 *              output of the resource dump routines

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_dump*List

 *

 * PARAMETERS:  length      - Number of elements in the list

 *              data        - Start of the list

 *

 * RETURN:      None

 *

 * DESCRIPTION: Miscellaneous functions to dump lists of raw data

 *

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: hwgpe - Low level GPE enable/disable/clear functions

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Entire module */

 Local prototypes */

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_gpe_read

 *

 * PARAMETERS:  value               - Where the value is returned

 *              reg                 - GPE register structure

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Read from a GPE register in either memory or IO space.

 *

 * LIMITATIONS: <These limitations also apply to acpi_hw_gpe_write>

 *      space_ID must be system_memory or system_IO.

 *

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_gpe_write

 *

 * PARAMETERS:  value               - Value to be written

 *              reg                 - GPE register structure

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Write to a GPE register in either memory or IO space.

 *

/******************************************************************************

 *

 * FUNCTION:	acpi_hw_get_gpe_register_bit

 *

 * PARAMETERS:	gpe_event_info	    - Info block for the GPE

 *

 * RETURN:	Register mask with a one in the GPE bit position

 *

 * DESCRIPTION: Compute the register mask for this GPE. One bit is set in the

 *              correct position for the input GPE.

 *

/******************************************************************************

 *

 * FUNCTION:	acpi_hw_low_set_gpe

 *

 * PARAMETERS:	gpe_event_info	    - Info block for the GPE to be disabled

 *		action		    - Enable or disable

 *

 * RETURN:	Status

 *

 * DESCRIPTION: Enable or disable a single GPE in the parent enable register.

 *              The enable_mask field of the involved GPE register must be

 *              updated by the caller if necessary.

 *

 Get the info block for the entire GPE register */

 Get current value of the enable register that contains this GPE */

 Set or clear just the bit that corresponds to this GPE */

 Only enable if the corresponding enable_mask bit is set */

 Write the updated enable mask */

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_clear_gpe

 *

 * PARAMETERS:  gpe_event_info      - Info block for the GPE to be cleared

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Clear the status bit for a single GPE.

 *

 Get the info block for the entire GPE register */

	/*

	 * Write a one to the appropriate bit in the status register to

	 * clear this GPE.

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_get_gpe_status

 *

 * PARAMETERS:  gpe_event_info      - Info block for the GPE to queried

 *              event_status        - Where the GPE status is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Return the status of a single GPE.

 *

 GPE currently handled? */

 Get the info block for the entire GPE register */

 Get the register bitmask for this GPE */

 GPE currently enabled? (enabled for runtime?) */

 GPE currently masked? (masked for runtime?) */

 GPE enabled for wake? */

 GPE currently enabled (enable bit == 1)? */

 GPE currently active (status bit == 1)? */

 Set return value */

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_gpe_enable_write

 *

 * PARAMETERS:  enable_mask         - Bit mask to write to the GPE register

 *              gpe_register_info   - Gpe Register info

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Write the enable mask byte to the given GPE register.

 *

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_disable_gpe_block

 *

 * PARAMETERS:  gpe_xrupt_info      - GPE Interrupt info

 *              gpe_block           - Gpe Block info

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Disable all GPEs within a single GPE block

 *

 Examine each GPE Register within the block */

 Disable all GPEs in this register */

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_clear_gpe_block

 *

 * PARAMETERS:  gpe_xrupt_info      - GPE Interrupt info

 *              gpe_block           - Gpe Block info

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Clear status bits for all GPEs within a single GPE block

 *

 Examine each GPE Register within the block */

 Clear status on all GPEs in this register */

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_enable_runtime_gpe_block

 *

 * PARAMETERS:  gpe_xrupt_info      - GPE Interrupt info

 *              gpe_block           - Gpe Block info

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Enable all "runtime" GPEs within a single GPE block. Includes

 *              combination wake/run GPEs.

 *

 NOTE: assumes that all GPEs are currently disabled */

 Examine each GPE Register within the block */

 Enable all "runtime" GPEs in this register */

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_enable_wakeup_gpe_block

 *

 * PARAMETERS:  gpe_xrupt_info      - GPE Interrupt info

 *              gpe_block           - Gpe Block info

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Enable all "wake" GPEs within a single GPE block. Includes

 *              combination wake/run GPEs.

 *

 Examine each GPE Register within the block */

		/*

		 * Enable all "wake" GPEs in this register and disable the

		 * remaining ones.

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_get_gpe_block_status

 *

 * PARAMETERS:  gpe_xrupt_info      - GPE Interrupt info

 *              gpe_block           - Gpe Block info

 *              context             - GPE list walk context data

 *

 * RETURN:      Success

 *

 * DESCRIPTION: Produce a combined GPE status bits mask for the given block.

 *

 Examine each GPE Register within the block */

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_disable_all_gpes

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Disable and clear all GPEs in all GPE blocks

 *

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_enable_all_runtime_gpes

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Enable all "runtime" GPEs, in all GPE blocks

 *

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_enable_all_wakeup_gpes

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Enable all "wakeup" GPEs, in all GPE blocks

 *

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_check_all_gpes

 *

 * PARAMETERS:  gpe_skip_device      - GPE devoce of the GPE to skip

 *              gpe_skip_number      - Number of the GPE to skip

 *

 * RETURN:      Combined status of all GPEs

 *

 * DESCRIPTION: Check all enabled GPEs in all GPE blocks, except for the one

 *              represented by the "skip" arguments, and return TRUE if the

 *              status bit is set for at least one of them of FALSE otherwise.

 *

 !ACPI_REDUCED_HARDWARE */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: psloop - Main AML parse loop

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*

 * Parse the AML and build an operation tree as most interpreters, (such as

 * Perl) do. Parsing is done by hand rather than with a YACC generated parser

 * to tightly constrain stack and dynamic memory usage. Parsing is kept

 * flexible and the code fairly compact by parsing based on a list of AML

 * opcode templates in aml_op_info[].

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_get_arguments

 *

 * PARAMETERS:  walk_state          - Current state

 *              aml_op_start        - Op start in AML

 *              op                  - Current Op

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Get arguments for passed Op.

 *

 AML_BYTEDATA_ARG */

 AML_WORDDATA_ARG */

 AML_DWORDATA_ARG */

 AML_QWORDATA_ARG */

 AML_ASCIICHARLIST_ARG */

 Fill in constant or string argument directly */

 AML_NAMESTRING_ARG */

		/*

		 * Op is not a constant or string, append each argument to the Op

 Special processing for certain opcodes */

			/*

			 * Skip parsing of control method because we don't have enough

			 * info in the first pass to parse it correctly.

			 *

			 * Save the length and address of the body

 Skip body of method */

				/*

				 * Skip parsing of Buffers and Packages because we don't have

				 * enough info in the first pass to parse them correctly.

 Skip body */

 No action for all other opcodes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_parse_loop

 *

 * PARAMETERS:  walk_state          - Current state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Parse AML (pointed to by the current parser state) and return

 *              a tree of ops.

 *

 current op */

 We are restarting a preempted control method */

			/*

			 * We must check if a predicate to an IF or WHILE statement

			 * was just completed

				/*

				 * A predicate was just completed, get the value of the

				 * predicate and branch based on that value

 We were in the middle of an op */

 Iterative parsing loop, while there is more AML to process: */

				/*

				 * ACPI_PARSE_MODULE_LEVEL means that we are loading a table by

				 * executing it as a control method. However, if we encounter

				 * an error while loading the table, we need to keep trying to

				 * load the table rather than aborting the table load. Set the

				 * status to AE_OK to proceed with the table load.

					/*

					 * If the scope/device op fails to parse, skip the body of

					 * the scope op because the parse failure indicates that

					 * the device may not exist.

					/*

					 * Determine the opcode length before skipping the opcode.

					 * An opcode can be 1 byte or 2 bytes in length.

		/*

		 * Start arg_count at zero because we don't know if there are

		 * any args yet

 Are there any arguments that must be processed? */

 Get arguments */

					/*

					 * If the if/while op fails to parse, we will skip parsing

					 * the body of the op.

 Check for arguments that need to be processed */

			/*

			 * There are arguments (complex ones), push Op and

			 * prepare for argument

		/*

		 * All arguments have been processed -- Op is complete,

		 * prepare for next

				/*

				 * Skip parsing of control method or opregion body,

				 * because we don't have enough info in the first pass

				 * to parse them correctly.

				 *

				 * Completed parsing an op_region declaration, we now

				 * know the length.

			/*

			 * Backup to beginning of create_XXXfield declaration (1 for

			 * Opcode)

			 *

			 * body_length is unknown until we parse the body

			/*

			 * Backup to beginning of bank_field declaration

			 *

			 * body_length is unknown until we parse the body

 This op complete, notify the dispatcher */

				/*

				 * ACPI_PARSE_MODULE_LEVEL flag means that we

				 * are currently loading a table by executing

				 * it as a control method. However, if we

				 * encounter an error while loading the table,

				 * we need to keep trying to load the table

				 * rather than aborting the table load (setting

				 * the status to AE_OK continues the table

				 * load). If we get a failure at this point, it

				 * means that the dispatcher got an error while

				 * trying to execute the Op.

 while parser_state->Aml */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: evregion - Operation Region support

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_initialize_op_regions

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute _REG methods for all Operation Regions that have

 *              an installed default region handler.

 *

 Run the _REG methods for op_regions in each default address space */

		/*

		 * Make sure the installed handler is the DEFAULT handler. If not the

		 * default, the _REG methods will have already been run (when the

		 * handler was installed)

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_address_space_dispatch

 *

 * PARAMETERS:  region_obj          - Internal region object

 *              field_obj           - Corresponding field. Can be NULL.

 *              function            - Read or Write operation

 *              region_offset       - Where in the region to read or write

 *              bit_width           - Field width in bits (8, 16, 32, or 64)

 *              value               - Pointer to in or out value, must be

 *                                    a full 64-bit integer

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Dispatch an address space or operation region access to

 *              a previously installed handler.

 *

 * NOTE: During early initialization, we always install the default region

 * handlers for Memory, I/O and PCI_Config. This ensures that these operation

 * region address spaces are always available as per the ACPI specification.

 * This is especially needed in order to support the execution of

 * module-level AML code during loading of the ACPI tables.

 *

 Ensure that there is a handler associated with this region */

	/*

	 * It may be the case that the region has never been initialized.

	 * Some types of regions require special init code

 This region has not been initialized yet, do it */

 No initialization routine, exit with error */

		/*

		 * We must exit the interpreter because the region setup will

		 * potentially execute control methods (for example, the _REG method

		 * for this region)

 Re-enter the interpreter */

 Check for failure of the Region Setup */

 Region initialization may have been completed by region_setup */

			/*

			 * Save the returned context for use in all accesses to

			 * the handler for this particular region

 We have everything we need, we can invoke the address space handler */

		/*

		 * For handlers other than the default (supplied) handlers, we must

		 * exit the interpreter because the handler *might* block -- we don't

		 * know what it will do, so we can't hold the lock on the interpreter.

	/*

	 * Special handling for generic_serial_bus and general_purpose_io:

	 * There are three extra parameters that must be passed to the

	 * handler via the context:

	 *   1) Connection buffer, a resource template from Connection() op

	 *   2) Length of the above buffer

	 *   3) Actual access length from the access_as() op

	 *

	 * Since we pass these extra parameters via the context, which is

	 * shared between threads, we must lock the context to avoid these

	 * parameters being changed from another thread before the handler

	 * has completed running.

	 *

	 * In addition, for general_purpose_io, the Address and bit_width fields

	 * are defined as follows:

	 *   1) Address is the pin number index of the field (bit offset from

	 *      the previous Connection)

	 *   2) bit_width is the actual bit length of the field (number of pins)

 Get the Connection (resource_template) buffer */

 Call the handler */

		/*

		 * Special case for an EC timeout. These are seen so frequently

		 * that an additional error message is helpful

		/*

		 * We just returned from a non-default handler, we must re-enter the

		 * interpreter

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_detach_region

 *

 * PARAMETERS:  region_obj          - Region Object

 *              acpi_ns_is_locked   - Namespace Region Already Locked?

 *

 * RETURN:      None

 *

 * DESCRIPTION: Break the association between the handler and the region

 *              this is a two way association.

 *

 Get the address handler from the region object */

 This region has no handler, all done */

 Find this region in the handler's list */

 Is this the correct Region? */

 This is it, remove it from the handler's list */

 Must clear field */

 Now stop region accesses by executing the _REG method */

			/*

			 * If the region has been activated, call the setup handler with

			 * the deactivate notification

				/*

				 * region_context should have been released by the deactivate

				 * operation. We don't need access to it anymore here.

 Init routine may fail, Just ignore errors */

			/*

			 * Remove handler reference in the region

			 *

			 * NOTE: this doesn't mean that the region goes away, the region

			 * is just inaccessible as indicated to the _REG method

			 *

			 * If the region is on the handler's list, this must be the

			 * region's handler

 Walk the linked list of handlers */

 Prevent infinite loop if list is corrupted */

 If we get here, the region was not in the handler's region list */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_attach_region

 *

 * PARAMETERS:  handler_obj         - Handler Object

 *              region_obj          - Region Object

 *              acpi_ns_is_locked   - Namespace Region Already Locked?

 *

 * RETURN:      None

 *

 * DESCRIPTION: Create the association between the handler and the region

 *              this is a two way association.

 *

 Install the region's handler */

 Link this region to the front of the handler's list */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_execute_reg_method

 *

 * PARAMETERS:  region_obj          - Region object

 *              function            - Passed to _REG: On (1) or Off (0)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute _REG method for a region

 *

	/*

	 * Find any "_REG" method associated with this region definition.

	 * The method should always be updated as this function may be

	 * invoked after a namespace change.

		/*

		 * The _REG method is optional and there can be only one per

		 * region definition. This will be executed when the handler is

		 * attached or removed.

 _REG(DISCONNECT) should be paired with _REG(CONNECT) */

 Allocate and initialize the evaluation information block */

	/*

	 * The _REG method has two arguments:

	 *

	 * arg0 - Integer:

	 *  Operation region space ID Same value as region_obj->Region.space_id

	 *

	 * arg1 - Integer:

	 *  connection status 1 for connecting the handler, 0 for disconnecting

	 *  the handler (Passed as a parameter)

 Terminate list */

 Execute the method, no return value */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_execute_reg_methods

 *

 * PARAMETERS:  node            - Namespace node for the device

 *              space_id        - The address space ID

 *              function        - Passed to _REG: On (1) or Off (0)

 *

 * RETURN:      None

 *

 * DESCRIPTION: Run all _REG methods for the input Space ID;

 *              Note: assumes namespace is locked, or system init time.

 *

	/*

	 * These address spaces do not need a call to _REG, since the ACPI

	 * specification defines them as: "must always be accessible". Since

	 * they never change state (never become unavailable), no need to ever

	 * call _REG on them. Also, a data_table is not a "real" address space,

	 * so do not call _REG. September 2018.

	/*

	 * Run all _REG methods for all Operation Regions for this space ID. This

	 * is a separate walk in order to handle any interdependencies between

	 * regions and _REG methods. (i.e. handlers must be installed for all

	 * regions of this Space ID before we can run any _REG methods)

	/*

	 * Special case for EC and GPIO: handle "orphan" _REG methods with

	 * no region.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_reg_run

 *

 * PARAMETERS:  walk_namespace callback

 *

 * DESCRIPTION: Run _REG method for region objects of the requested spaceID

 *

 Convert and validate the device handle */

	/*

	 * We only care about regions and objects that are allowed to have

	 * address space handlers

 Check for an existing internal object */

 No object, just exit */

 Object is a Region */

 This region is for a different address space, just ignore it */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ev_execute_orphan_reg_method

 *

 * PARAMETERS:  device_node         - Namespace node for an ACPI device

 *              space_id            - The address space ID

 *

 * RETURN:      None

 *

 * DESCRIPTION: Execute an "orphan" _REG method that appears under an ACPI

 *              device. This is a _REG method that has no corresponding region

 *              within the device's scope. ACPI tables depending on these

 *              "orphan" _REG methods have been seen for both EC and GPIO

 *              Operation Regions. Presumably the Windows ACPI implementation

 *              always calls the _REG method independent of the presence of

 *              an actual Operation Region with the correct address space ID.

 *

 *  MUTEX:      Assumes the namespace is locked

 *

 Namespace is currently locked, must release */

 Get a handle to a _REG method immediately under the EC device */

 There is no _REG method present */

	/*

	 * Execute the _REG method only if there is no Operation Region in

	 * this scope with the Embedded Controller space ID. Otherwise, it

	 * will already have been executed. Note, this allows for Regions

	 * with other space IDs to be present; but the code below will then

	 * execute the _REG method with the embedded_control space_ID argument.

 Do not execute the _REG */

 Evaluate the _REG(space_id,Connect) method */

 We ignore all errors from above, don't care */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: dswstate - Dispatcher parse tree walk management routines

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_result_pop

 *

 * PARAMETERS:  object              - Where to return the popped object

 *              walk_state          - Current Walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Pop an object off the top of this walk's result stack

 *

 Incorrect state of result stack */

 Empty result stack */

 Return object of the top element and clean that top element result stack */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_result_push

 *

 * PARAMETERS:  object              - Where to return the popped object

 *              walk_state          - Current Walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Push an object onto the current result stack

 *

 Extend the result stack */

 Assign the address of object to the top free element of result stack */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_result_stack_push

 *

 * PARAMETERS:  walk_state          - Current Walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Push an object onto the walk_state result stack

 *

 Check for stack overflow */

 Increase the length of the result stack by the length of frame */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_result_stack_pop

 *

 * PARAMETERS:  walk_state          - Current Walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Pop an object off of the walk_state result stack

 *

 Check for stack underflow */

 Decrease the length of result stack by the length of frame */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_obj_stack_push

 *

 * PARAMETERS:  object              - Object to push

 *              walk_state          - Current Walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Push an object onto this walk's object/operand stack

 *

 Check for stack overflow */

 Put the object onto the stack */

 For the usual order of filling the operand stack */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_obj_stack_pop

 *

 * PARAMETERS:  pop_count           - Number of objects/entries to pop

 *              walk_state          - Current Walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Pop this walk's object stack. Objects on the stack are NOT

 *              deleted by this routine.

 *

 Check for stack underflow */

 Just set the stack entry to null */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_obj_stack_pop_and_delete

 *

 * PARAMETERS:  pop_count           - Number of objects/entries to pop

 *              walk_state          - Current Walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Pop this walk's object stack and delete each object that is

 *              popped off.

 *

 Pop the stack and delete an object if present in this stack entry */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_get_current_walk_state

 *

 * PARAMETERS:  thread          - Get current active state for this Thread

 *

 * RETURN:      Pointer to the current walk state

 *

 * DESCRIPTION: Get the walk state that is at the head of the list (the "current"

 *              walk state.)

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_push_walk_state

 *

 * PARAMETERS:  walk_state      - State to push

 *              thread          - Thread state object

 *

 * RETURN:      None

 *

 * DESCRIPTION: Place the Thread state at the head of the state list

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_pop_walk_state

 *

 * PARAMETERS:  thread      - Current thread state

 *

 * RETURN:      A walk_state object popped from the thread's stack

 *

 * DESCRIPTION: Remove and return the walkstate object that is at the head of

 *              the walk stack for the given walk list. NULL indicates that

 *              the list is empty.

 *

 Next walk state becomes the current walk state */

		/*

		 * Don't clear the NEXT field, this serves as an indicator

		 * that there is a parent WALK STATE

		 * Do Not: walk_state->Next = NULL;

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_create_walk_state

 *

 * PARAMETERS:  owner_id        - ID for object creation

 *              origin          - Starting point for this walk

 *              method_desc     - Method object

 *              thread          - Current thread state

 *

 * RETURN:      Pointer to the new walk state.

 *

 * DESCRIPTION: Allocate and initialize a new walk state. The current walk

 *              state is set to this new state.

 *

 Init the method args/local */

 Put the new state at the head of the walk list */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_init_aml_walk

 *

 * PARAMETERS:  walk_state      - New state to be initialized

 *              op              - Current parse op

 *              method_node     - Control method NS node, if any

 *              aml_start       - Start of AML

 *              aml_length      - Length of AML

 *              info            - Method info block (params, etc.)

 *              pass_number     - 1, 2, or 3

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Initialize a walk state for a pass 1 or 2 parse tree walk

 *

 The next_op of the next_walk will be the beginning of the method */

 Push start scope on scope stack and make it current  */

 Init the method arguments */

		/*

		 * Setup the current scope.

		 * Find a Named Op that has a namespace node associated with it.

		 * search upwards from this Op. Current scope is the first

		 * Op with a namespace node.

 Push start scope on scope stack and make it current  */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_delete_walk_state

 *

 * PARAMETERS:  walk_state      - State to delete

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Delete a walk state including all internal data structures

 *

 There should not be any open scopes */

 Always must free any linked control states */

 Always must free any linked parse states */

 Always must free any stacked result states */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: hwvalid - I/O request validation

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*

 * Protected I/O ports. Some ports are always illegal, and some are

 * conditionally illegal. This table must remain ordered by port address.

 *

 * The table is used to implement the Microsoft port access rules that

 * first appeared in Windows XP. Some ports are always illegal, and some

 * ports are only illegal if the BIOS calls _OSI with a win_XP string or

 * later (meaning that the BIOS itelf is post-XP.)

 *

 * This provides ACPICA with the desired port protections and

 * Microsoft compatibility.

 *

 * Description of port entries:

 *  DMA:   DMA controller

 *  PIC0:  Programmable Interrupt Controller (8259A)

 *  PIT1:  System Timer 1

 *  PIT2:  System Timer 2 failsafe

 *  RTC:   Real-time clock

 *  CMOS:  Extended CMOS

 *  DMA1:  DMA 1 page registers

 *  DMA1L: DMA 1 Ch 0 low page

 *  DMA2:  DMA 2 page registers

 *  DMA2L: DMA 2 low page refresh

 *  ARBC:  Arbitration control

 *  SETUP: Reserved system board setup

 *  POS:   POS channel select

 *  PIC1:  Cascaded PIC

 *  IDMA:  ISA DMA

 *  ELCR:  PIC edge/level registers

 *  PCI:   PCI configuration space

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_validate_io_request

 *

 * PARAMETERS:  Address             Address of I/O port/register

 *              bit_width           Number of bits (8,16,32)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Validates an I/O request (address/length). Certain ports are

 *              always illegal and some ports are only illegal depending on

 *              the requests the BIOS AML code makes to the predefined

 *              _OSI method.

 *

 Supported widths are 8/16/32 */

 Maximum 16-bit address in I/O space */

 Exit if requested address is not within the protected port table */

 Check request against the list of protected I/O ports */

		/*

		 * Check if the requested address range will write to a reserved

		 * port. There are four cases to consider:

		 *

		 * 1) Address range is contained completely in the port address range

		 * 2) Address range overlaps port range at the port range start

		 * 3) Address range overlaps port range at the port range end

		 * 4) Address range completely encompasses the port range

 Port illegality may depend on the _OSI calls made by the BIOS */

 Finished if address range ends before the end of this port */

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_read_port

 *

 * PARAMETERS:  Address             Address of I/O port/register to read

 *              Value               Where value (data) is returned

 *              Width               Number of bits

 *

 * RETURN:      Status and value read from port

 *

 * DESCRIPTION: Read data from an I/O port or register. This is a front-end

 *              to acpi_os_read_port that performs validation on both the port

 *              address and the length.

 *

 Truncate address to 16 bits if requested */

 Validate the entire request and perform the I/O */

	/*

	 * There has been a protection violation within the request. Fall

	 * back to byte granularity port I/O and ignore the failing bytes.

	 * This provides compatibility with other ACPI implementations.

 Validate and read one byte */

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_write_port

 *

 * PARAMETERS:  Address             Address of I/O port/register to write

 *              Value               Value to write

 *              Width               Number of bits

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Write data to an I/O port or register. This is a front-end

 *              to acpi_os_write_port that performs validation on both the port

 *              address and the length.

 *

 Truncate address to 16 bits if requested */

 Validate the entire request and perform the I/O */

	/*

	 * There has been a protection violation within the request. Fall

	 * back to byte granularity port I/O and ignore the failing bytes.

	 * This provides compatibility with other ACPI implementations.

 Validate and write one byte */

/******************************************************************************

 *

 * FUNCTION:    acpi_hw_validate_io_block

 *

 * PARAMETERS:  Address             Address of I/O port/register blobk

 *              bit_width           Number of bits (8,16,32) in each register

 *              count               Number of registers in the block

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Validates a block of I/O ports/registers.

 *

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: rslist - Linked list utilities

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_convert_aml_to_resources

 *

 * PARAMETERS:  acpi_walk_aml_callback

 *              resource_ptr            - Pointer to the buffer that will

 *                                        contain the output structures

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Convert an AML resource to an internal representation of the

 *              resource that is aligned and easier to access.

 *

	/*

	 * Check that the input buffer and all subsequent pointers into it

	 * are aligned on a native word boundary. Most important on IA64

 Get the appropriate conversion info table */

 This is an I2C, SPI, UART, or CSI2 serial_bus descriptor */

 Convert the AML byte stream resource to a local resource struct */

 Point to the next structure in the output buffer */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_convert_resources_to_aml

 *

 * PARAMETERS:  resource            - Pointer to the resource linked list

 *              aml_size_needed     - Calculated size of the byte stream

 *                                    needed from calling acpi_rs_get_aml_length()

 *                                    The size of the output_buffer is

 *                                    guaranteed to be >= aml_size_needed

 *              output_buffer       - Pointer to the buffer that will

 *                                    contain the byte stream

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Takes the resource linked list and parses it, creating a

 *              byte stream of resources in the caller's output buffer

 *

 Walk the resource descriptor list, convert each descriptor */

 Validate the (internal) Resource Type */

 Sanity check the length. It must not be zero, or we loop forever */

 Perform the conversion */

 This is an I2C, SPI, UART or CSI2 serial_bus descriptor */

 Perform final sanity check on the new AML resource descriptor */

 Check for end-of-list, normal exit */

 An End Tag indicates the end of the input Resource Template */

		/*

		 * Extract the total length of the new descriptor and set the

		 * Aml to point to the next (output) resource descriptor

 Point to the next input resource descriptor */

 Completed buffer, but did not find an end_tag resource descriptor */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: psxface - Parser external interfaces

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local Prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_debug_trace

 *

 * PARAMETERS:  method_name     - Valid ACPI name string

 *              debug_level     - Optional level mask. 0 to use default

 *              debug_layer     - Optional layer mask. 0 to use default

 *              flags           - bit 1: one shot(1) or persistent(0)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: External interface to enable debug tracing during control

 *              method execution

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_execute_method

 *

 * PARAMETERS:  info            - Method info block, contains:

 *                  node            - Method Node to execute

 *                  obj_desc        - Method object

 *                  parameters      - List of parameters to pass to the method,

 *                                    terminated by NULL. Params itself may be

 *                                    NULL if no parameters are being passed.

 *                  return_object   - Where to put method's return value (if

 *                                    any). If NULL, no value is returned.

 *                  parameter_type  - Type of Parameter list

 *                  return_object   - Where to put method's return value (if

 *                                    any). If NULL, no value is returned.

 *                  pass_number     - Parse or execute pass

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute a control method

 *

 Quick validation of DSDT header */

 Validate the Info and method Node */

 Init for new method, wait on concurrency semaphore */

	/*

	 * The caller "owns" the parameters, so give each one an extra reference

	/*

	 * Execute the method. Performs parse simultaneously

 Create and init a Root Node */

 Create and initialize a new walk state */

 Invoke an internal method if necessary */

 Cleanup states */

	/*

	 * Start method evaluation with an implicit return of zero.

	 * This is done for Windows compatibility.

 Parse the AML */

 walk_state was deleted by parse_aml */

 Take away the extra reference that we gave the parameters above */

 Exit now if error above */

	/*

	 * If the method has returned an object, signal this to the caller with

	 * a control exception code

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_execute_table

 *

 * PARAMETERS:  info            - Method info block, contains:

 *              node            - Node to where the is entered into the

 *                                namespace

 *              obj_desc        - Pseudo method object describing the AML

 *                                code of the entire table

 *              pass_number     - Parse or execute pass

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute a table

 *

 Create and init a Root Node */

 Create and initialize a new walk state */

 Info->Node is the default location to load the table  */

	/*

	 * Parse the AML, walk_state will be deleted by parse_aml

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_update_parameter_list

 *

 * PARAMETERS:  info            - See struct acpi_evaluate_info

 *                                (Used: parameter_type and Parameters)

 *              action          - Add or Remove reference

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Update reference count on all method parameter objects

 *

 Update reference count for each parameter */

 Ignore errors, just do them all */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: utresrc - Resource management utilities

 *

/*

 * Base sizes of the raw AML resource descriptors, indexed by resource type.

 * Zero indicates a reserved (and therefore invalid) resource type.

 Small descriptors */

 Large descriptors */

/*

 * Resource types, used to validate the resource length field.

 * The length of fixed-length types must match exactly, variable

 * lengths must meet the minimum required length, etc.

 * Zero indicates a reserved (and therefore invalid) resource type.

 Small descriptors */

 04 IRQ */

 05 DMA */

 06 start_dependent_functions */

 07 end_dependent_functions */

 08 IO */

 09 fixed_IO */

 0A fixed_DMA */

 0E vendor_short */

 0F end_tag */

 Large descriptors */

 01 Memory24 */

 02 generic_register */

 04 vendor_long */

 05 Memory32 */

 06 memory32_fixed */

 07 Dword* address */

 08 Word* address */

 09 extended_IRQ */

 0A Qword* address */

 0B Extended* address */

 0C Gpio* */

 0D pin_function */

 0E *serial_bus */

 0F pin_config */

 10 pin_group */

 11 pin_group_function */

 12 pin_group_config */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_walk_aml_resources

 *

 * PARAMETERS:  walk_state          - Current walk info

 * PARAMETERS:  aml                 - Pointer to the raw AML resource template

 *              aml_length          - Length of the entire template

 *              user_function       - Called once for each descriptor found. If

 *                                    NULL, a pointer to the end_tag is returned

 *              context             - Passed to user_function

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Walk a raw AML resource list(buffer). User function called

 *              once for each resource found.

 *

 The absolute minimum resource template is one end_tag descriptor */

 Point to the end of the resource template buffer */

 Walk the byte list, abort on any invalid descriptor type or length */

 Validate the Resource Type and Resource Length */

			/*

			 * Exit on failure. Cannot continue because the descriptor

			 * length may be bogus also.

 Get the length of this descriptor */

 Invoke the user function */

 An end_tag descriptor terminates this resource template */

			/*

			 * There must be at least one more byte in the buffer for

			 * the 2nd byte of the end_tag

			/*

			 * Don't attempt to perform any validation on the 2nd byte.

			 * Although all known ASL compilers insert a zero for the 2nd

			 * byte, it can also be a checksum (as per the ACPI spec),

			 * and this is occasionally seen in the field. July 2017.

 Return the pointer to the end_tag if requested */

 Normal exit */

 Did not find an end_tag descriptor */

 Insert an end_tag anyway. acpi_rs_get_list_length always leaves room */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_validate_resource

 *

 * PARAMETERS:  walk_state          - Current walk info

 *              aml                 - Pointer to the raw AML resource descriptor

 *              return_index        - Where the resource index is returned. NULL

 *                                    if the index is not required.

 *

 * RETURN:      Status, and optionally the Index into the global resource tables

 *

 * DESCRIPTION: Validate an AML resource descriptor by checking the Resource

 *              Type and Resource Length. Returns an index into the global

 *              resource information/dispatch tables for later use.

 *

	/*

	 * 1) Validate the resource_type field (Byte 0)

	/*

	 * Byte 0 contains the descriptor name (Resource Type)

	 * Examine the large/small bit in the resource header

 Verify the large resource type (name) against the max */

		/*

		 * Large Resource Type -- bits 6:0 contain the name

		 * Translate range 0x80-0x8B to index range 0x10-0x1B

		/*

		 * Small Resource Type -- bits 6:3 contain the name

		 * Shift range to index range 0x00-0x0F

	/*

	 * Check validity of the resource type, via acpi_gbl_resource_types.

	 * Zero indicates an invalid resource.

	/*

	 * Validate the resource_length field. This ensures that the length

	 * is at least reasonable, and guarantees that it is non-zero.

 Validate based upon the type of resource - fixed length or variable */

 Fixed length resource, length must match exactly */

 Variable length resource, length must be at least the minimum */

 Small variable length resource, length can be (Min) or (Min-1) */

 Shouldn't happen (because of validation earlier), but be sure */

 Validate the bus_type field */

 Optionally return the resource table index */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_resource_type

 *

 * PARAMETERS:  aml             - Pointer to the raw AML resource descriptor

 *

 * RETURN:      The Resource Type with no extraneous bits (except the

 *              Large/Small descriptor bit -- this is left alone)

 *

 * DESCRIPTION: Extract the Resource Type/Name from the first byte of

 *              a resource descriptor.

 *

	/*

	 * Byte 0 contains the descriptor name (Resource Type)

	 * Examine the large/small bit in the resource header

 Large Resource Type -- bits 6:0 contain the name */

 Small Resource Type -- bits 6:3 contain the name */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_resource_length

 *

 * PARAMETERS:  aml             - Pointer to the raw AML resource descriptor

 *

 * RETURN:      Byte Length

 *

 * DESCRIPTION: Get the "Resource Length" of a raw AML descriptor. By

 *              definition, this does not include the size of the descriptor

 *              header or the length field itself.

 *

	/*

	 * Byte 0 contains the descriptor name (Resource Type)

	 * Examine the large/small bit in the resource header

 Large Resource type -- bytes 1-2 contain the 16-bit length */

 Small Resource type -- bits 2:0 of byte 0 contain the length */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_resource_header_length

 *

 * PARAMETERS:  aml             - Pointer to the raw AML resource descriptor

 *

 * RETURN:      Length of the AML header (depends on large/small descriptor)

 *

 * DESCRIPTION: Get the length of the header for this resource.

 *

 Examine the large/small bit in the resource header */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_descriptor_length

 *

 * PARAMETERS:  aml             - Pointer to the raw AML resource descriptor

 *

 * RETURN:      Byte length

 *

 * DESCRIPTION: Get the total byte length of a raw AML descriptor, including the

 *              length of the descriptor header and the length field itself.

 *              Used to walk descriptor lists.

 *

	/*

	 * Get the Resource Length (does not include header length) and add

	 * the header length (depends on if this is a small or large resource)

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_get_resource_end_tag

 *

 * PARAMETERS:  obj_desc        - The resource template buffer object

 *              end_tag         - Where the pointer to the end_tag is returned

 *

 * RETURN:      Status, pointer to the end tag

 *

 * DESCRIPTION: Find the end_tag resource descriptor in an AML resource template

 *              Note: allows a buffer length of zero.

 *

 Allow a buffer length of zero */

 Validate the template and get a pointer to the end_tag */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Name: hwtimer.c - ACPI Power Management Timer Interface

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Entire module */

/******************************************************************************

 *

 * FUNCTION:    acpi_get_timer_resolution

 *

 * PARAMETERS:  resolution          - Where the resolution is returned

 *

 * RETURN:      Status and timer resolution

 *

 * DESCRIPTION: Obtains resolution of the ACPI PM Timer (24 or 32 bits).

 *

/******************************************************************************

 *

 * FUNCTION:    acpi_get_timer

 *

 * PARAMETERS:  ticks               - Where the timer value is returned

 *

 * RETURN:      Status and current timer value (ticks)

 *

 * DESCRIPTION: Obtains current value of ACPI PM Timer (in ticks).

 *

 ACPI 5.0A: PM Timer is optional */

 ACPI PM Timer is defined to be 32 bits (PM_TMR_LEN) */

/******************************************************************************

 *

 * FUNCTION:    acpi_get_timer_duration

 *

 * PARAMETERS:  start_ticks         - Starting timestamp

 *              end_ticks           - End timestamp

 *              time_elapsed        - Where the elapsed time is returned

 *

 * RETURN:      Status and time_elapsed

 *

 * DESCRIPTION: Computes the time elapsed (in microseconds) between two

 *              PM Timer time stamps, taking into account the possibility of

 *              rollovers, the timer resolution, and timer frequency.

 *

 *              The PM Timer's clock ticks at roughly 3.6 times per

 *              _microsecond_, and its clock continues through Cx state

 *              transitions (unlike many CPU timestamp counters) -- making it

 *              a versatile and accurate timer.

 *

 *              Note that this function accommodates only a single timer

 *              rollover. Thus for 24-bit timers, this function should only

 *              be used for calculating durations less than ~4.6 seconds

 *              (~20 minutes for 32-bit timers) -- calculations below:

 *

 *              2**24 Ticks / 3,600,000 Ticks/Sec = 4.66 sec

 *              2**32 Ticks / 3,600,000 Ticks/Sec = 1193 sec or 19.88 minutes

 *

 ACPI 5.0A: PM Timer is optional */

	/*

	 * Compute Tick Delta:

	 * Handle (max one) timer rollovers on 24-bit versus 32-bit timers.

 24-bit Timer */

 32-bit Timer */

	/*

	 * Compute Duration (Requires a 64-bit multiply and divide):

	 *

	 * time_elapsed (microseconds) =

	 *  (delta_ticks * ACPI_USEC_PER_SEC) / ACPI_PM_TIMER_FREQUENCY;

 !ACPI_REDUCED_HARDWARE */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exresolv - AML Interpreter object resolution

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_resolve_to_value

 *

 * PARAMETERS:  **stack_ptr         - Points to entry on obj_stack, which can

 *                                    be either an (union acpi_operand_object *)

 *                                    or an acpi_handle.

 *              walk_state          - Current method state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Convert Reference objects to values

 *

	/*

	 * The entity pointed to by the stack_ptr can be either

	 * 1) A valid union acpi_operand_object, or

	 * 2) A struct acpi_namespace_node (named_obj)

	/*

	 * Object on the stack may have changed if acpi_ex_resolve_object_to_value()

	 * was called (i.e., we can't use an _else_ here.)

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_resolve_object_to_value

 *

 * PARAMETERS:  stack_ptr       - Pointer to an internal object

 *              walk_state      - Current method state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Retrieve the value from an internal object. The Reference type

 *              uses the associated AML opcode to determine the value.

 *

 This is an object of type union acpi_operand_object */

			/*

			 * Get the local from the method's state info

			 * Note: this increments the local's object reference count

			/*

			 * Now we can delete the original Reference Object and

			 * replace it with the resolved value

 Just return - do not dereference */

 If method call or copy_object - do not dereference */

 Otherwise, dereference the package_index to a package element */

					/*

					 * Valid object descriptor, copy pointer to return value

					 * (i.e., dereference the package index)

					 * Delete the ref object, increment the returned object

					/*

					 * A NULL object descriptor means an uninitialized element of

					 * the package, can't dereference it

 Invalid reference object */

 Just leave the object as-is, do not dereference */

 Reference to a named object */

 Dereference the name */

 These node types do not have 'real' subobjects */

 Get the object pointed to by the namespace node */

 Remove a reference to the original operand, then override */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_resolve_multiple

 *

 * PARAMETERS:  walk_state          - Current state (contains AML opcode)

 *              operand             - Starting point for resolution

 *              return_type         - Where the object type is returned

 *              return_desc         - Where the resolved object is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Return the base object and type. Traverse a reference list if

 *              necessary to get to the base object.

 *

 Operand can be either a namespace node or an operand descriptor */

 If we had an Alias node, use the attached object for type info */

 These types have no attached subobject */

 All other types require a subobject */

 If type is anything other than a reference, we are done */

	/*

	 * For reference objects created via the ref_of, Index, or Load/load_table

	 * operators, we need to get to the base object (as per the ACPI

	 * specification of the object_type and size_of operators). This means

	 * traversing the list of possibly many nested references.

 Dereference the reference pointer */

 AML_INT_NAMEPATH_OP */

 All "References" point to a NS node */

 Get the attached object */

 No object, use the NS node type */

 Check for circular references */

 Get the type of this reference (index into another object) */

			/*

			 * The main object is a package, we want to get the type

			 * of the individual package element that is referenced by

			 * the index.

			 *

			 * This could of course in turn be another reference object.

 NULL package elements are allowed */

 Uninitialized */

 The Debug Object is of type "DebugObject" */

	/*

	 * Now we are guaranteed to have an object that has not been created

	 * via the ref_of or Index operators.

 Convert internal types to external types */

 Per ACPI Specification, Scope is untyped */

 No change to Type required */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: dswscope - Scope stack manipulation

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/****************************************************************************

 *

 * FUNCTION:    acpi_ds_scope_stack_clear

 *

 * PARAMETERS:  walk_state      - Current state

 *

 * RETURN:      None

 *

 * DESCRIPTION: Pop (and free) everything on the scope stack except the

 *              root scope object (which remains at the stack top.)

 *

 Pop a scope off the stack */

/****************************************************************************

 *

 * FUNCTION:    acpi_ds_scope_stack_push

 *

 * PARAMETERS:  node            - Name to be made current

 *              type            - Type of frame being pushed

 *              walk_state      - Current state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Push the current scope on the scope stack, and make the

 *              passed Node current.

 *

 Invalid scope   */

 Make sure object type is valid */

 Allocate a new scope object */

 Init new scope object */

 Push new scope object onto stack */

/****************************************************************************

 *

 * FUNCTION:    acpi_ds_scope_stack_pop

 *

 * PARAMETERS:  walk_state      - Current state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Pop the scope stack once.

 *

	/*

	 * Pop scope info object off the stack.

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exresop - AML Interpreter operand/object resolution

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_check_object_type

 *

 * PARAMETERS:  type_needed         Object type needed

 *              this_type           Actual object type

 *              Object              Object pointer

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Check required type against actual type

 *

 All types OK, so we don't perform any typechecks */

		/*

		 * Allow the AML "Constant" opcodes (Zero, One, etc.) to be reference

		 * objects and thus allow them to be targets. (As per the ACPI

		 * specification, a store to a constant is a noop.)

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_resolve_operands

 *

 * PARAMETERS:  opcode              - Opcode being interpreted

 *              stack_ptr           - Pointer to the operand stack to be

 *                                    resolved

 *              walk_state          - Current state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Convert multiple input operands to the types required by the

 *              target operator.

 *

 *      Each 5-bit group in arg_types represents one required

 *      operand and indicates the required Type. The corresponding operand

 *      will be converted to the required type if possible, otherwise we

 *      abort with an exception.

 *

	/*

	 * Normal exit is with (arg_types == 0) at end of argument list.

	 * Function will return an exception from within the loop upon

	 * finding an entry which is not (or cannot be converted

	 * to) the required type; if stack underflows; or upon

	 * finding a NULL stack entry (which should not happen).

 Extract useful items */

 Decode the descriptor type */

 Namespace Node */

			/*

			 * Resolve an alias object. The construction of these objects

			 * guarantees that there is only one level of alias indirection;

			 * thus, the attached object is always the aliased namespace node

 ACPI internal object */

 Check for bad acpi_object_type */

 Validate the Reference */

 ddb_handle from LOAD_OP or LOAD_TABLE_OP */

 Reference to a named object */

 Invalid descriptor */

 Get one argument type, point to the next */

		/*

		 * Handle cases where the object does not need to be

		 * resolved to a value

 Can be a String or Reference */

				/*

				 * String found - the string references a named object and

				 * must be resolved to a node

			/*

			 * Else not a string - fall through to the normal Reference

			 * case below

 References: */

 Allows implicit conversion rules before store */

 No implicit conversion before store to target */

 Name, Local, or arg - no implicit conversion  */

			/*

			 * Need an operand of type ACPI_TYPE_LOCAL_REFERENCE

			 * A Namespace Node is OK as-is

 Store operator only */

			/*

			 * We don't want to resolve index_op reference objects during

			 * a store because this would be an implicit de_ref_of operation.

			 * Instead, we just want to store the reference object.

			 * -- All others must be resolved below.

 All cases covered above */

		/*

		 * Resolve this object to a value

 Get the resolved object */

		/*

		 * Check the resulting object (value) type

			/*

			 * For the simple cases, only one type of resolved object

			 * is allowed

 Need an operand of type ACPI_TYPE_MUTEX */

 Need an operand of type ACPI_TYPE_EVENT */

 Package */

 Need an operand of type ACPI_TYPE_PACKAGE */

 Any operand type will do */

 Need an operand of type ACPI_TYPE_DDB_HANDLE */

			/*

			 * The more complex cases allow multiple resolved object types

			/*

			 * Need an operand of type ACPI_TYPE_INTEGER, but we can

			 * implicitly convert from a STRING or BUFFER.

			 *

			 * Known as "Implicit Source Operand Conversion"

			/*

			 * Need an operand of type ACPI_TYPE_BUFFER,

			 * But we can implicitly convert from a STRING or INTEGER

			 * aka - "Implicit Source Operand Conversion"

			/*

			 * Need an operand of type ACPI_TYPE_STRING,

			 * But we can implicitly convert from a BUFFER or INTEGER

			 * aka - "Implicit Source Operand Conversion"

 Need an operand of type INTEGER, STRING or BUFFER */

 Valid operand */

 Need an operand of type STRING or BUFFER */

 Valid operand */

 Highest priority conversion is to type Buffer */

			/*

			 * ARGI_DATAOBJECT is only used by the size_of operator.

			 * Need a buffer, string, package, or ref_of reference.

			 *

			 * The only reference allowed here is a direct reference to

			 * a namespace node.

 Valid operand */

 Need a buffer or package or (ACPI 2.0) String */

 Valid operand */

 Used by Load() only */

			/*

			 * Need an operand of type REGION or a BUFFER

			 * (which could be a resolved region field)

 Valid operand */

 Used by the Store() operator only */

 Valid operand */

					/*

					 * Enable original behavior of Store(), allowing any

					 * and all objects as the source operand. The ACPI

					 * spec does not allow this, however.

 Allow store of any object to the Debug object */

 Unknown type */

		/*

		 * Make sure that the original object was resolved to the

		 * required object type (Simple cases only).

		/*

		 * If more operands needed, decrement stack_ptr to point

		 * to next operand on stack

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: utdebug - Debug print/trace routines

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_init_stack_ptr_trace

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Save the current CPU stack pointer at subsystem startup

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_track_stack_ptr

 *

 * PARAMETERS:  None

 *

 * RETURN:      None

 *

 * DESCRIPTION: Save the current CPU stack pointer

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_trim_function_name

 *

 * PARAMETERS:  function_name       - Ascii string containing a procedure name

 *

 * RETURN:      Updated pointer to the function name

 *

 * DESCRIPTION: Remove the "Acpi" prefix from the function name, if present.

 *              This allows compiler macros such as __func__ to be used

 *              with no change to the debug output.

 *

 All Function names are longer than 4 chars, check is safe */

 This is the case where the original source has not been modified */

 This is the case where the source has been 'linuxized' */

/*******************************************************************************

 *

 * FUNCTION:    acpi_debug_print

 *

 * PARAMETERS:  requested_debug_level - Requested debug print level

 *              line_number         - Caller's line number (for error output)

 *              function_name       - Caller's procedure name

 *              module_name         - Caller's module name

 *              component_id        - Caller's component ID

 *              format              - Printf format field

 *              ...                 - Optional printf arguments

 *

 * RETURN:      None

 *

 * DESCRIPTION: Print error message with prefix consisting of the module name,

 *              line number, and component ID.

 *

 Check if debug output enabled */

	/*

	 * Thread tracking and context switch notification

	/*

	 * Display the module name, current line number, thread ID (if requested),

	 * current procedure nesting level, and the current procedure name

	/*

	 * For acpi_exec/iASL only, emit the thread ID and nesting level.

	 * Note: nesting level is really only useful during a single-thread

	 * execution. Otherwise, multiple threads will keep resetting the

	 * level.

/*******************************************************************************

 *

 * FUNCTION:    acpi_debug_print_raw

 *

 * PARAMETERS:  requested_debug_level - Requested debug print level

 *              line_number         - Caller's line number

 *              function_name       - Caller's procedure name

 *              module_name         - Caller's module name

 *              component_id        - Caller's component ID

 *              format              - Printf format field

 *              ...                 - Optional printf arguments

 *

 * RETURN:      None

 *

 * DESCRIPTION: Print message with no headers. Has same interface as

 *              debug_print so that the same macros can be used.

 *

 Check if debug output enabled */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_trace

 *

 * PARAMETERS:  line_number         - Caller's line number

 *              function_name       - Caller's procedure name

 *              module_name         - Caller's module name

 *              component_id        - Caller's component ID

 *

 * RETURN:      None

 *

 * DESCRIPTION: Function entry trace. Prints only if TRACE_FUNCTIONS bit is

 *              set in debug_level

 *

 Check if enabled up-front for performance */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_trace_ptr

 *

 * PARAMETERS:  line_number         - Caller's line number

 *              function_name       - Caller's procedure name

 *              module_name         - Caller's module name

 *              component_id        - Caller's component ID

 *              pointer             - Pointer to display

 *

 * RETURN:      None

 *

 * DESCRIPTION: Function entry trace. Prints only if TRACE_FUNCTIONS bit is

 *              set in debug_level

 *

 Check if enabled up-front for performance */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_trace_str

 *

 * PARAMETERS:  line_number         - Caller's line number

 *              function_name       - Caller's procedure name

 *              module_name         - Caller's module name

 *              component_id        - Caller's component ID

 *              string              - Additional string to display

 *

 * RETURN:      None

 *

 * DESCRIPTION: Function entry trace. Prints only if TRACE_FUNCTIONS bit is

 *              set in debug_level

 *

 Check if enabled up-front for performance */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_trace_u32

 *

 * PARAMETERS:  line_number         - Caller's line number

 *              function_name       - Caller's procedure name

 *              module_name         - Caller's module name

 *              component_id        - Caller's component ID

 *              integer             - Integer to display

 *

 * RETURN:      None

 *

 * DESCRIPTION: Function entry trace. Prints only if TRACE_FUNCTIONS bit is

 *              set in debug_level

 *

 Check if enabled up-front for performance */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_exit

 *

 * PARAMETERS:  line_number         - Caller's line number

 *              function_name       - Caller's procedure name

 *              module_name         - Caller's module name

 *              component_id        - Caller's component ID

 *

 * RETURN:      None

 *

 * DESCRIPTION: Function exit trace. Prints only if TRACE_FUNCTIONS bit is

 *              set in debug_level

 *

 Check if enabled up-front for performance */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_status_exit

 *

 * PARAMETERS:  line_number         - Caller's line number

 *              function_name       - Caller's procedure name

 *              module_name         - Caller's module name

 *              component_id        - Caller's component ID

 *              status              - Exit status code

 *

 * RETURN:      None

 *

 * DESCRIPTION: Function exit trace. Prints only if TRACE_FUNCTIONS bit is

 *              set in debug_level. Prints exit status also.

 *

 Check if enabled up-front for performance */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_value_exit

 *

 * PARAMETERS:  line_number         - Caller's line number

 *              function_name       - Caller's procedure name

 *              module_name         - Caller's module name

 *              component_id        - Caller's component ID

 *              value               - Value to be printed with exit msg

 *

 * RETURN:      None

 *

 * DESCRIPTION: Function exit trace. Prints only if TRACE_FUNCTIONS bit is

 *              set in debug_level. Prints exit value also.

 *

 Check if enabled up-front for performance */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_ptr_exit

 *

 * PARAMETERS:  line_number         - Caller's line number

 *              function_name       - Caller's procedure name

 *              module_name         - Caller's module name

 *              component_id        - Caller's component ID

 *              ptr                 - Pointer to display

 *

 * RETURN:      None

 *

 * DESCRIPTION: Function exit trace. Prints only if TRACE_FUNCTIONS bit is

 *              set in debug_level. Prints exit value also.

 *

 Check if enabled up-front for performance */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_str_exit

 *

 * PARAMETERS:  line_number         - Caller's line number

 *              function_name       - Caller's procedure name

 *              module_name         - Caller's module name

 *              component_id        - Caller's component ID

 *              string              - String to display

 *

 * RETURN:      None

 *

 * DESCRIPTION: Function exit trace. Prints only if TRACE_FUNCTIONS bit is

 *              set in debug_level. Prints exit value also.

 *

 Check if enabled up-front for performance */

/*******************************************************************************

 *

 * FUNCTION:    acpi_trace_point

 *

 * PARAMETERS:  type                - Trace event type

 *              begin               - TRUE if before execution

 *              aml                 - Executed AML address

 *              pathname            - Object path

 *              pointer             - Pointer to the related object

 *

 * RETURN:      None

 *

 * DESCRIPTION: Interpreter execution trace.

 *

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: rsaddr - Address resource descriptors (16/32/64)

 *

/*******************************************************************************

 *

 * acpi_rs_convert_address16 - All WORD (16-bit) address resources

 *

 Resource Type, General Flags, and Type-Specific Flags */

	/*

	 * These fields are contiguous in both the source and destination:

	 * Address Granularity

	 * Address Range Minimum

	 * Address Range Maximum

	 * Address Translation Offset

	 * Address Length

 Optional resource_source (Index and String) */

/*******************************************************************************

 *

 * acpi_rs_convert_address32 - All DWORD (32-bit) address resources

 *

 Resource Type, General Flags, and Type-Specific Flags */

	/*

	 * These fields are contiguous in both the source and destination:

	 * Address Granularity

	 * Address Range Minimum

	 * Address Range Maximum

	 * Address Translation Offset

	 * Address Length

 Optional resource_source (Index and String) */

/*******************************************************************************

 *

 * acpi_rs_convert_address64 - All QWORD (64-bit) address resources

 *

 Resource Type, General Flags, and Type-Specific Flags */

	/*

	 * These fields are contiguous in both the source and destination:

	 * Address Granularity

	 * Address Range Minimum

	 * Address Range Maximum

	 * Address Translation Offset

	 * Address Length

 Optional resource_source (Index and String) */

/*******************************************************************************

 *

 * acpi_rs_convert_ext_address64 - All Extended (64-bit) address resources

 *

 Resource Type, General Flags, and Type-Specific Flags */

 Revision ID */

	/*

	 * These fields are contiguous in both the source and destination:

	 * Address Granularity

	 * Address Range Minimum

	 * Address Range Maximum

	 * Address Translation Offset

	 * Address Length

	 * Type-Specific Attribute

/*******************************************************************************

 *

 * acpi_rs_convert_general_flags - Flags common to all address descriptors

 *

 Resource Type (Memory, Io, bus_number, etc.) */

 General flags - Consume, Decode, min_fixed, max_fixed */

/*******************************************************************************

 *

 * acpi_rs_convert_mem_flags - Flags common to Memory address descriptors

 *

 Memory-specific flags */

/*******************************************************************************

 *

 * acpi_rs_convert_io_flags - Flags common to I/O address descriptors

 *

 I/O-specific flags */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_get_address_common

 *

 * PARAMETERS:  resource            - Pointer to the internal resource struct

 *              aml                 - Pointer to the AML resource descriptor

 *

 * RETURN:      TRUE if the resource_type field is OK, FALSE otherwise

 *

 * DESCRIPTION: Convert common flag fields from a raw AML resource descriptor

 *              to an internal resource descriptor

 *

 Validate the Resource Type */

 Get the Resource Type and General Flags */

 Get the Type-Specific Flags (Memory and I/O descriptors only) */

 Generic resource type, just grab the type_specific byte */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_set_address_common

 *

 * PARAMETERS:  aml                 - Pointer to the AML resource descriptor

 *              resource            - Pointer to the internal resource struct

 *

 * RETURN:      None

 *

 * DESCRIPTION: Convert common flag fields from a resource descriptor to an

 *              AML descriptor

 *

 Set the Resource Type and General Flags */

 Set the Type-Specific Flags (Memory and I/O descriptors only) */

 Generic resource type, just copy the type_specific byte */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: utascii - Utility ascii functions

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_valid_nameseg

 *

 * PARAMETERS:  name            - The name or table signature to be examined.

 *                                Four characters, does not have to be a

 *                                NULL terminated string.

 *

 * RETURN:      TRUE if signature is has 4 valid ACPI characters

 *

 * DESCRIPTION: Validate an ACPI table signature.

 *

 Validate each character in the signature */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_valid_name_char

 *

 * PARAMETERS:  char            - The character to be examined

 *              position        - Byte position (0-3)

 *

 * RETURN:      TRUE if the character is valid, FALSE otherwise

 *

 * DESCRIPTION: Check for a valid ACPI character. Must be one of:

 *              1) Upper case alpha

 *              2) numeric

 *              3) underscore

 *

 *              We allow a '!' as the last character because of the ASF! table

 *

 Allow a '!' in the last position */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_check_and_repair_ascii

 *

 * PARAMETERS:  name                - Ascii string

 *              count               - Number of characters to check

 *

 * RETURN:      None

 *

 * DESCRIPTION: Ensure that the requested number of characters are printable

 *              Ascii characters. Sets non-printable and null chars to <space>.

 *

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: utlock - Reader/Writer lock interfaces

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_create_rw_lock

 *              acpi_ut_delete_rw_lock

 *

 * PARAMETERS:  lock                - Pointer to a valid RW lock

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Reader/writer lock creation and deletion interfaces.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_acquire_read_lock

 *              acpi_ut_release_read_lock

 *

 * PARAMETERS:  lock                - Pointer to a valid RW lock

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Reader interfaces for reader/writer locks. On acquisition,

 *              only the first reader acquires the write mutex. On release,

 *              only the last reader releases the write mutex. Although this

 *              algorithm can in theory starve writers, this should not be a

 *              problem with ACPICA since the subsystem is infrequently used

 *              in comparison to (for example) an I/O system.

 *

 Acquire the write lock only for the first reader */

 Release the write lock only for the very last reader */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_acquire_write_lock

 *              acpi_ut_release_write_lock

 *

 * PARAMETERS:  lock                - Pointer to a valid RW lock

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Writer interfaces for reader/writer locks. Simply acquire or

 *              release the writer mutex associated with the lock. Acquisition

 *              of the lock is fully exclusive and will block all readers and

 *              writers until it is released.

 *

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exoparg2 - AML execution - opcodes with 2 arguments

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*!

 * Naming convention for AML interpreter execution routines.

 *

 * The routines that begin execution of AML opcodes are named with a common

 * convention based upon the number of arguments, the number of target operands,

 * and whether or not a value is returned:

 *

 *      AcpiExOpcode_xA_yT_zR

 *

 * Where:

 *

 * xA - ARGUMENTS:    The number of arguments (input operands) that are

 *                    required for this opcode type (1 through 6 args).

 * yT - TARGETS:      The number of targets (output operands) that are required

 *                    for this opcode type (0, 1, or 2 targets).

 * zR - RETURN VALUE: Indicates whether this opcode type returns a value

 *                    as the function return (0 or 1).

 *

 * The AcpiExOpcode* functions are called via the Dispatcher component with

 * fully resolved operands.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_opcode_2A_0T_0R

 *

 * PARAMETERS:  walk_state          - Current walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute opcode with two arguments, no target, and no return

 *              value.

 *

 * ALLOCATION:  Deletes both operands

 *

 Examine the opcode */

 Notify (notify_object, notify_value) */

 The first operand is a namespace node */

 Second value is the notify value */

 Are notifies allowed on this object? */

		/*

		 * Dispatch the notify to the appropriate handler

		 * NOTE: the request is queued for execution after this method

		 * completes. The notify handlers are NOT invoked synchronously

		 * from this thread -- because handlers may in turn run other

		 * control methods.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_opcode_2A_2T_1R

 *

 * PARAMETERS:  walk_state          - Current walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute a dyadic operator (2 operands) with 2 output targets

 *              and one implicit return value.

 *

 Execute the opcode */

 Divide (Dividend, Divisor, remainder_result quotient_result) */

 Quotient to return_desc1, remainder to return_desc2 */

 Store the results to the target reference operands */

	/*

	 * Since the remainder is not returned indirectly, remove a reference to

	 * it. Only the quotient is returned indirectly.

 Delete the return object */

 Save return object (the remainder) on success */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_opcode_2A_1T_1R

 *

 * PARAMETERS:  walk_state          - Current walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute opcode with two arguments, one target, and a return

 *              value.

 *

 Execute the opcode */

 All simple math opcodes (add, etc.) */

 Mod (Dividend, Divisor, remainder_result (ACPI 2.0) */

 return_desc will contain the remainder */

 Concatenate (Data1, Data2, Result) */

 to_string (Buffer, Length, Result) (ACPI 2.0) */

		/*

		 * Input object is guaranteed to be a buffer at this point (it may have

		 * been converted.)  Copy the raw buffer data to a new object of

		 * type String.

		/*

		 * Get the length of the new string. It is the smallest of:

		 * 1) Length of the input buffer

		 * 2) Max length as specified in the to_string operator

		 * 3) Length of input buffer up to a zero byte (null terminator)

		 *

		 * NOTE: A length of zero is ok, and will create a zero-length, null

		 *       terminated string.

 Length of input buffer */

 Length operand */

 Null terminator */

 Allocate a new string object */

		/*

		 * Copy the raw buffer data with no transform.

		 * (NULL terminated already)

 concatenate_res_template (Buffer, Buffer, Result) (ACPI 2.0) */

 Index (Source Index Result) */

 Create the internal return object */

 Initialize the Index reference object */

		/*

		 * At this point, the Source operand is a String, Buffer, or Package.

		 * Verify that the index is within range.

 Failure means that the Index was beyond the end of the object */

		/*

		 * Save the target object and add a reference to it for the life

		 * of the index

 Store the reference to the Target */

 Return the reference */

		/*

		 * Store the result of the operation (which is now in return_desc) into

		 * the Target descriptor.

 Delete return object on error */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_opcode_2A_0T_1R

 *

 * PARAMETERS:  walk_state          - Current walk state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute opcode with 2 arguments, no target, and a return value

 *

 Create the internal return object */

 Execute the Opcode */

 logical_op (Operand0, Operand1) */

 logical_op (Operand0, Operand1) */

 Acquire (mutex_object, Timeout) */

 TRUE = Acquire timed out */

 Wait (event_object, Timeout) */

 TRUE, Wait timed out */

	/*

	 * Set return value to according to logical_result. logical TRUE (all ones)

	 * Default is FALSE (zero)

 Delete return object on error */

 Save return object on success */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: nsdump - table dumping routines for debug

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_print_pathname

 *

 * PARAMETERS:  num_segments        - Number of ACPI name segments

 *              pathname            - The compressed (internal) path

 *

 * RETURN:      None

 *

 * DESCRIPTION: Print an object's full namespace pathname

 *

 Check if debug output enabled */

 Print the entire name */

 Not used at this time, perhaps later */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_dump_pathname

 *

 * PARAMETERS:  handle              - Object

 *              msg                 - Prefix message

 *              level               - Desired debug level

 *              component           - Caller's component ID

 *

 * RETURN:      None

 *

 * DESCRIPTION: Print an object's full namespace pathname

 *              Manages allocation/freeing of a pathname buffer

 *

 Do this only if the requested debug level and component are enabled */

 Convert handle to a full pathname and print it (with supplied message) */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_dump_one_object

 *

 * PARAMETERS:  obj_handle          - Node to be dumped

 *              level               - Nesting level of the handle

 *              context             - Passed into walk_namespace

 *              return_value        - Not used

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Dump a single Node

 *              This procedure is a user_function called by acpi_ns_walk_namespace.

 *

 Is output enabled? */

 Check if the owner matches */

 Indent the object according to the level */

 Check the node type and name */

 Now we can print out the pertinent information */

 Temp nodes are those nodes created by a control method */

 No attached object. Some types should always have an object */

 Dump some of the buffer */

 Common field handling */

 No attached object, we are done */

 Name is a Method and its AML offset/length are set */

 If debug turned off, done */

 If there is an attached object, display it */

 Dump attached objects */

 Decode the type of attached object and dump the contents */

 If value is NOT an internal object, we are done */

 Valid object, get the pointer to next level, if any */

			/*

			 * NOTE: takes advantage of common fields between string/buffer

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_dump_objects

 *

 * PARAMETERS:  type                - Object type to be dumped

 *              display_type        - 0 or ACPI_DISPLAY_SUMMARY

 *              max_depth           - Maximum depth of dump. Use ACPI_UINT32_MAX

 *                                    for an effectively unlimited depth.

 *              owner_id            - Dump only objects owned by this ID. Use

 *                                    ACPI_UINT32_MAX to match all owners.

 *              start_handle        - Where in namespace to start/end search

 *

 * RETURN:      None

 *

 * DESCRIPTION: Dump typed objects within the loaded namespace. Uses

 *              acpi_ns_walk_namespace in conjunction with acpi_ns_dump_one_object.

 *

	/*

	 * Just lock the entire namespace for the duration of the dump.

	 * We don't want any changes to the namespace during this time,

	 * especially the temporary nodes since we are going to display

	 * them also.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_dump_one_object_path, acpi_ns_get_max_depth

 *

 * PARAMETERS:  obj_handle          - Node to be dumped

 *              level               - Nesting level of the handle

 *              context             - Passed into walk_namespace

 *              return_value        - Not used

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Dump the full pathname to a namespace object. acp_ns_get_max_depth

 *              computes the maximum nesting depth in the namespace tree, in

 *              order to simplify formatting in acpi_ns_dump_one_object_path.

 *              These procedures are user_functions called by acpi_ns_walk_namespace.

 *

 Ignore bad node during namespace walk */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_dump_object_paths

 *

 * PARAMETERS:  type                - Object type to be dumped

 *              display_type        - 0 or ACPI_DISPLAY_SUMMARY

 *              max_depth           - Maximum depth of dump. Use ACPI_UINT32_MAX

 *                                    for an effectively unlimited depth.

 *              owner_id            - Dump only objects owned by this ID. Use

 *                                    ACPI_UINT32_MAX to match all owners.

 *              start_handle        - Where in namespace to start/end search

 *

 * RETURN:      None

 *

 * DESCRIPTION: Dump full object pathnames within the loaded namespace. Uses

 *              acpi_ns_walk_namespace in conjunction with acpi_ns_dump_one_object_path.

 *

	/*

	 * Just lock the entire namespace for the duration of the dump.

	 * We don't want any changes to the namespace during this time,

	 * especially the temporary nodes since we are going to display

	 * them also.

 Get the max depth of the namespace tree, for formatting later */

 Now dump the entire namespace */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_dump_entry

 *

 * PARAMETERS:  handle              - Node to be dumped

 *              debug_level         - Output level

 *

 * RETURN:      None

 *

 * DESCRIPTION: Dump a single Node

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_dump_tables

 *

 * PARAMETERS:  search_base         - Root of subtree to be dumped, or

 *                                    NS_ALL to dump the entire namespace

 *              max_depth           - Maximum depth of dump. Use INT_MAX

 *                                    for an effectively unlimited depth.

 *

 * RETURN:      None

 *

 * DESCRIPTION: Dump the name space, or a portion of it.

 *

		/*

		 * If the name space has not been initialized,

		 * there is nothing to dump.

 Entire namespace */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: utstrsuppt - Support functions for string-to-integer conversion

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_convert_octal_string

 *

 * PARAMETERS:  string                  - Null terminated input string

 *              return_value_ptr        - Where the converted value is returned

 *

 * RETURN:      Status and 64-bit converted integer

 *

 * DESCRIPTION: Performs a base 8 conversion of the input string to an

 *              integer value, either 32 or 64 bits.

 *

 * NOTE:        Maximum 64-bit unsigned octal value is 01777777777777777777777

 *              Maximum 32-bit unsigned octal value is 037777777777

 *

 Convert each ASCII byte in the input string */

		/*

		 * Character must be ASCII 0-7, otherwise:

		 * 1) Runtime: terminate with no error, per the ACPI spec

		 * 2) Compiler: return an error

 Convert and insert this octal digit into the accumulator */

 Always return the value that has been accumulated */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_convert_decimal_string

 *

 * PARAMETERS:  string                  - Null terminated input string

 *              return_value_ptr        - Where the converted value is returned

 *

 * RETURN:      Status and 64-bit converted integer

 *

 * DESCRIPTION: Performs a base 10 conversion of the input string to an

 *              integer value, either 32 or 64 bits.

 *

 * NOTE:        Maximum 64-bit unsigned decimal value is 18446744073709551615

 *              Maximum 32-bit unsigned decimal value is 4294967295

 *

 Convert each ASCII byte in the input string */

		/*

		 * Character must be ASCII 0-9, otherwise:

		 * 1) Runtime: terminate with no error, per the ACPI spec

		 * 2) Compiler: return an error

 Convert and insert this decimal digit into the accumulator */

 Always return the value that has been accumulated */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_convert_hex_string

 *

 * PARAMETERS:  string                  - Null terminated input string

 *              return_value_ptr        - Where the converted value is returned

 *

 * RETURN:      Status and 64-bit converted integer

 *

 * DESCRIPTION: Performs a base 16 conversion of the input string to an

 *              integer value, either 32 or 64 bits.

 *

 * NOTE:        Maximum 64-bit unsigned hex value is 0xFFFFFFFFFFFFFFFF

 *              Maximum 32-bit unsigned hex value is 0xFFFFFFFF

 *

 Convert each ASCII byte in the input string */

		/*

		 * Character must be ASCII A-F, a-f, or 0-9, otherwise:

		 * 1) Runtime: terminate with no error, per the ACPI spec

		 * 2) Compiler: return an error

 Convert and insert this hex digit into the accumulator */

 Always return the value that has been accumulated */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_remove_leading_zeros

 *

 * PARAMETERS:  string                  - Pointer to input ASCII string

 *

 * RETURN:      Next character after any leading zeros. This character may be

 *              used by the caller to detect end-of-string.

 *

 * DESCRIPTION: Remove any leading zeros in the input string. Return the

 *              next character after the final ASCII zero to enable the caller

 *              to check for the end of the string (NULL terminator).

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_remove_whitespace

 *

 * PARAMETERS:  string                  - Pointer to input ASCII string

 *

 * RETURN:      Next character after any whitespace. This character may be

 *              used by the caller to detect end-of-string.

 *

 * DESCRIPTION: Remove any leading whitespace in the input string. Return the

 *              next character after the final ASCII zero to enable the caller

 *              to check for the end of the string (NULL terminator).

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_detect_hex_prefix

 *

 * PARAMETERS:  string                  - Pointer to input ASCII string

 *

 * RETURN:      TRUE if a "0x" prefix was found at the start of the string

 *

 * DESCRIPTION: Detect and remove a hex "0x" prefix

 *

 String is past leading 0x */

 Not a hex string */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_remove_hex_prefix

 *

 * PARAMETERS:  string                  - Pointer to input ASCII string

 *

 * RETURN:      none

 *

 * DESCRIPTION: Remove a hex "0x" prefix

 *

 Go past the leading 0x */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_detect_octal_prefix

 *

 * PARAMETERS:  string                  - Pointer to input ASCII string

 *

 * RETURN:      True if an octal "0" prefix was found at the start of the

 *              string

 *

 * DESCRIPTION: Detect and remove an octal prefix (zero)

 *

 Go past the leading 0 */

 Not an octal string */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_insert_digit

 *

 * PARAMETERS:  accumulated_value       - Current value of the integer value

 *                                        accumulator. The new value is

 *                                        returned here.

 *              base                    - Radix, either 8/10/16

 *              ascii_digit             - ASCII single digit to be inserted

 *

 * RETURN:      Status and result of the convert/insert operation. The only

 *              possible returned exception code is numeric overflow of

 *              either the multiply or add conversion operations.

 *

 * DESCRIPTION: Generic conversion and insertion function for all bases:

 *

 *              1) Multiply the current accumulated/converted value by the

 *              base in order to make room for the new character.

 *

 *              2) Convert the new character to binary and add it to the

 *              current accumulated value.

 *

 *              Note: The only possible exception indicates an integer

 *              overflow (AE_NUMERIC_OVERFLOW)

 *

 Make room in the accumulated value for the incoming digit */

 Add in the new digit, and store the sum to the accumulated value */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_strtoul_multiply64

 *

 * PARAMETERS:  multiplicand            - Current accumulated converted integer

 *              base                    - Base/Radix

 *              out_product             - Where the product is returned

 *

 * RETURN:      Status and 64-bit product

 *

 * DESCRIPTION: Multiply two 64-bit values, with checking for 64-bit overflow as

 *              well as 32-bit overflow if necessary (if the current global

 *              integer width is 32).

 *

 Exit if either operand is zero */

	/*

	 * Check for 64-bit overflow before the actual multiplication.

	 *

	 * Notes: 64-bit division is often not supported on 32-bit platforms

	 * (it requires a library function), Therefore ACPICA has a local

	 * 64-bit divide function. Also, Multiplier is currently only used

	 * as the radix (8/10/16), to the 64/32 divide will always work.

 Check for 32-bit overflow if necessary */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_strtoul_add64

 *

 * PARAMETERS:  addend1                 - Current accumulated converted integer

 *              digit                   - New hex value/char

 *              out_sum                 - Where sum is returned (Accumulator)

 *

 * RETURN:      Status and 64-bit sum

 *

 * DESCRIPTION: Add two 64-bit values, with checking for 64-bit overflow as

 *              well as 32-bit overflow if necessary (if the current global

 *              integer width is 32).

 *

 Check for 64-bit overflow before the actual addition */

 Check for 32-bit overflow if necessary */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: nsarguments - Validation of args for ACPI predefined methods

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_check_argument_types

 *

 * PARAMETERS:  info            - Method execution information block

 *

 * RETURN:      None

 *

 * DESCRIPTION: Check the incoming argument count and all argument types

 *              against the argument type list for a predefined name.

 *

	/*

	 * If not a predefined name, cannot typecheck args, because

	 * we have no idea what argument types are expected.

	 * Also, ignore typecheck if warnings/errors if this method

	 * has already been evaluated at least once -- in order

	 * to suppress repetitive messages.

 Typecheck all arguments */

 No typechecking for ACPI_TYPE_ANY */

 Prevent any additional typechecking for this method */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_check_acpi_compliance

 *

 * PARAMETERS:  pathname        - Full pathname to the node (for error msgs)

 *              node            - Namespace node for the method/object

 *              predefined      - Pointer to entry in predefined name table

 *

 * RETURN:      None

 *

 * DESCRIPTION: Check that the declared parameter count (in ASL/AML) for a

 *              predefined name is what is expected (matches what is defined in

 *              the ACPI specification for this predefined name.)

 *

 Get the ACPI-required arg count from the predefined info table */

	/*

	 * If this object is not a control method, we can check if the ACPI

	 * spec requires that it be a method.

 Object requires args, must be implemented as a method */

 Object requires no args and no return value, must be a method */

	/*

	 * This is a control method.

	 * Check that the ASL/AML-defined parameter count for this method

	 * matches the ACPI-required parameter count

	 *

	 * Some methods are allowed to have a "minimum" number of args (_SCP)

	 * because their definition in ACPI has changed over time.

	 *

	 * Note: These are BIOS errors in the declaration of the object

/*******************************************************************************

 *

 * FUNCTION:    acpi_ns_check_argument_count

 *

 * PARAMETERS:  pathname        - Full pathname to the node (for error msgs)

 *              node            - Namespace node for the method/object

 *              user_param_count - Number of args passed in by the caller

 *              predefined      - Pointer to entry in predefined name table

 *

 * RETURN:      None

 *

 * DESCRIPTION: Check that incoming argument count matches the declared

 *              parameter count (in the ASL/AML) for an object.

 *

		/*

		 * Not a predefined name. Check the incoming user argument count

		 * against the count that is specified in the method/object.

		/*

		 * This is a control method. Check the parameter count.

		 * We can only check the incoming argument count against the

		 * argument count declared for the method in the ASL/AML.

		 *

		 * Emit a message if too few or too many arguments have been passed

		 * by the caller.

		 *

		 * Note: Too many arguments will not cause the method to

		 * fail. However, the method will fail if there are too few

		 * arguments and the method attempts to use one of the missing ones.

	/*

	 * This is a predefined name. Validate the user-supplied parameter

	 * count against the ACPI specification. We don't validate against

	 * the method itself because what is important here is that the

	 * caller is in conformance with the spec. (The arg count for the

	 * method was checked against the ACPI spec earlier.)

	 *

	 * Some methods are allowed to have a "minimum" number of args (_SCP)

	 * because their definition in ACPI has changed over time.

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: excreate - Named object creation

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_create_alias

 *

 * PARAMETERS:  walk_state           - Current state, contains operands

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create a new named alias

 *

 Get the source/alias operands (both namespace nodes) */

		/*

		 * Dereference an existing alias so that we don't create a chain

		 * of aliases. With this code, we guarantee that an alias is

		 * always exactly one level of indirection away from the

		 * actual aliased name.

 Ensure that the target node is valid */

 Construct the alias object (a namespace node) */

		/*

		 * Control method aliases need to be differentiated with

		 * a special type

		/*

		 * All other object types.

		 *

		 * The new alias has the type ALIAS and points to the original

		 * NS node, not the object itself.

 Since both operands are Nodes, we don't need to delete them */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_create_event

 *

 * PARAMETERS:  walk_state          - Current state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create a new event object

 *

	/*

	 * Create the actual OS semaphore, with zero initial units -- meaning

	 * that the event is created in an unsignalled state

 Attach object to the Node */

	/*

	 * Remove local reference to the object (on error, will cause deletion

	 * of both object and semaphore if present.)

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_create_mutex

 *

 * PARAMETERS:  walk_state          - Current state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create a new mutex object

 *

 *              Mutex (Name[0], sync_level[1])

 *

 Create the new mutex object */

 Create the actual OS Mutex */

 Init object and attach to NS node */

	/*

	 * Remove local reference to the object (on error, will cause deletion

	 * of both object and semaphore if present.)

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_create_region

 *

 * PARAMETERS:  aml_start           - Pointer to the region declaration AML

 *              aml_length          - Max length of the declaration AML

 *              space_id            - Address space ID for the region

 *              walk_state          - Current state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create a new operation region object

 *

 Get the Namespace Node */

	/*

	 * If the region object is already attached to this node,

	 * just return

	/*

	 * Space ID must be one of the predefined IDs, or in the user-defined

	 * range

		/*

		 * Print an error message, but continue. We don't want to abort

		 * a table load for this exception. Instead, if the region is

		 * actually used at runtime, abort the executing method.

 Create the region descriptor */

	/*

	 * Remember location in AML stream of address & length

	 * operands since they need to be evaluated at run time.

 Init the region from the operands */

 Install the new region object in the parent Node */

 Remove local reference to the object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_create_processor

 *

 * PARAMETERS:  walk_state          - Current state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create a new processor object and populate the fields

 *

 *              Processor (Name[0], cpu_ID[1], pblock_addr[2], pblock_length[3])

 *

 Create the processor object */

 Initialize the processor object from the operands */

 Install the processor object in the parent Node */

 Remove local reference to the object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_create_power_resource

 *

 * PARAMETERS:  walk_state          - Current state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create a new power_resource object and populate the fields

 *

 *              power_resource (Name[0], system_level[1], resource_order[2])

 *

 Create the power resource object */

 Initialize the power object from the operands */

 Install the  power resource object in the parent Node */

 Remove local reference to the object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_create_method

 *

 * PARAMETERS:  aml_start       - First byte of the method's AML

 *              aml_length      - AML byte count for this method

 *              walk_state      - Current state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create a new method object

 *

 Create a new method object */

 Save the method's AML pointer and length  */

	/*

	 * Disassemble the method flags. Split off the arg_count, Serialized

	 * flag, and sync_level for efficiency.

	/*

	 * Get the sync_level. If method is serialized, a mutex will be

	 * created for this method when it is parsed.

		/*

		 * ACPI 1.0: sync_level = 0

		 * ACPI 2.0: sync_level = sync_level in method declaration

 Attach the new object to the method Node */

 Remove local reference to the object */

 Remove a reference to the operand */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Name: hwesleep.c - ACPI Hardware Sleep/Wake Support functions for the

 *                    extended FADT-V5 sleep registers.

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_hw_execute_sleep_method

 *

 * PARAMETERS:  method_pathname     - Pathname of method to execute

 *              integer_argument    - Argument to pass to the method

 *

 * RETURN:      None

 *

 * DESCRIPTION: Execute a sleep/wake related method with one integer argument

 *              and no return value.

 *

 One argument, integer_argument; No return value expected */

/*******************************************************************************

 *

 * FUNCTION:    acpi_hw_extended_sleep

 *

 * PARAMETERS:  sleep_state         - Which sleep state to enter

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Enter a system sleep state via the extended FADT sleep

 *              registers (V5 FADT).

 *              THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED

 *

 Extended sleep registers must be valid */

 Clear wake status (WAK_STS) */

	/*

	 * Set the SLP_TYP and SLP_EN bits.

	 *

	 * Note: We only use the first value returned by the \_Sx method

	 * (acpi_gbl_sleep_type_a) - As per ACPI specification.

 Flush caches, as per ACPI specification */

 Wait for transition back to Working State */

/*******************************************************************************

 *

 * FUNCTION:    acpi_hw_extended_wake_prep

 *

 * PARAMETERS:  sleep_state         - Which sleep state we just exited

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Perform first part of OS-independent ACPI cleanup after

 *              a sleep. Called with interrupts ENABLED.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_hw_extended_wake

 *

 * PARAMETERS:  sleep_state         - Which sleep state we just exited

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Perform OS-independent ACPI cleanup after a sleep

 *              Called with interrupts ENABLED.

 *

 Ensure enter_sleep_state_prep -> enter_sleep_state ordering */

 Execute the wake methods */

	/*

	 * Some BIOS code assumes that WAK_STS will be cleared on resume

	 * and use it to determine whether the system is rebooting or

	 * resuming. Clear WAK_STS for compatibility.

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: utxfinit - External interfaces for ACPICA initialization

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 For acpi_exec only */

/*******************************************************************************

 *

 * FUNCTION:    acpi_initialize_subsystem

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Initializes all global variables. This is the first function

 *              called, so any early initialization belongs here.

 *

 Initialize the OS-Dependent layer */

 Initialize all globals used by the subsystem */

 Create the default mutex objects */

	/*

	 * Initialize the namespace manager and

	 * the root of the namespace tree

 Initialize the global OSI interfaces list with the static names */

/*******************************************************************************

 *

 * FUNCTION:    acpi_enable_subsystem

 *

 * PARAMETERS:  flags               - Init/enable Options

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Completes the subsystem initialization including hardware.

 *              Puts system into ACPI mode if it isn't already.

 *

	/*

	 * The early initialization phase is complete. The namespace is loaded,

	 * and we can now support address spaces other than Memory, I/O, and

	 * PCI_Config.

 Enable ACPI mode */

	/*

	 * Obtain a permanent mapping for the FACS. This is required for the

	 * Global Lock and the Firmware Waking Vector

	/*

	 * Initialize ACPI Event handling (Fixed and General Purpose)

	 *

	 * Note1: We must have the hardware and events initialized before we can

	 * execute any control methods safely. Any control method can require

	 * ACPI hardware support, so the hardware must be fully initialized before

	 * any method execution!

	 *

	 * Note2: Fixed events are initialized and enabled here. GPEs are

	 * initialized, but cannot be enabled until after the hardware is

	 * completely initialized (SCI and global_lock activated) and the various

	 * initialization control methods are run (_REG, _STA, _INI) on the

	 * entire namespace.

	/*

	 * Install the SCI handler and Global Lock handler. This completes the

	 * hardware initialization.

 !ACPI_REDUCED_HARDWARE */

/*******************************************************************************

 *

 * FUNCTION:    acpi_initialize_objects

 *

 * PARAMETERS:  flags               - Init/enable Options

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Completes namespace initialization by initializing device

 *              objects and executing AML code for Regions, buffers, etc.

 *

	/*

	 * 05/2019: Removed, initialization now happens at both object

	 * creation and table load time

	/*

	 * Initialize the objects that remain uninitialized. This

	 * runs the executable AML that may be part of the

	 * declaration of these objects: operation_regions, buffer_fields,

	 * bank_fields, Buffers, and Packages.

	/*

	 * Initialize all device/region objects in the namespace. This runs

	 * the device _STA and _INI methods and region _REG methods.

	/*

	 * Empty the caches (delete the cached objects) on the assumption that

	 * the table load filled them up more than they will be at runtime --

	 * thus wasting non-paged memory.

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exstorob - AML object store support, store to object

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_store_buffer_to_buffer

 *

 * PARAMETERS:  source_desc         - Source object to copy

 *              target_desc         - Destination object of the copy

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Copy a buffer object to another buffer object.

 *

 If Source and Target are the same, just return */

 We know that source_desc is a buffer by now */

	/*

	 * If target is a buffer of length zero or is a static buffer,

	 * allocate a new buffer of the proper length

 Copy source buffer to target buffer */

 Clear existing buffer and copy in the new one */

		/*

		 * NOTE: ACPI versions up to 3.0 specified that the buffer must be

		 * truncated if the string is smaller than the buffer. However, "other"

		 * implementations of ACPI never did this and thus became the defacto

		 * standard. ACPI 3.0A changes this behavior such that the buffer

		 * is no longer truncated.

		/*

		 * OBSOLETE BEHAVIOR:

		 * If the original source was a string, we must truncate the buffer,

		 * according to the ACPI spec. Integer-to-Buffer and Buffer-to-Buffer

		 * copy must not truncate the original buffer.

 Set the new length of the target */

 Truncate the source, copy only what will fit */

 Copy flags */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_store_string_to_string

 *

 * PARAMETERS:  source_desc         - Source object to copy

 *              target_desc         - Destination object of the copy

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Copy a String object to another String object

 *

 If Source and Target are the same, just return */

 We know that source_desc is a string by now */

	/*

	 * Replace existing string value if it will fit and the string

	 * pointer is not a static pointer (part of an ACPI table)

		/*

		 * String will fit in existing non-static buffer.

		 * Clear old string and copy in the new one

		/*

		 * Free the current buffer, then allocate a new buffer

		 * large enough to hold the value

 Only free if not a pointer into the DSDT */

 Set the new target length */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exconvrt - Object conversion routines

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_convert_to_integer

 *

 * PARAMETERS:  obj_desc            - Object to be converted. Must be an

 *                                    Integer, Buffer, or String

 *              result_desc         - Where the new Integer object is returned

 *              implicit_conversion - Used for string conversion

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Convert an ACPI Object to an integer.

 *

 No conversion necessary */

 Note: Takes advantage of common buffer/string fields */

	/*

	 * Convert the buffer/string to an integer. Note that both buffers and

	 * strings are treated as raw data - we don't convert ascii to hex for

	 * strings.

	 *

	 * There are two terminating conditions for the loop:

	 * 1) The size of an integer has been reached, or

	 * 2) The end of the buffer or string has been reached

 String conversion is different than Buffer conversion */

		/*

		 * Convert string to an integer - for most cases, the string must be

		 * hexadecimal as per the ACPI specification. The only exception (as

		 * of ACPI 3.0) is that the to_integer() operator allows both decimal

		 * and hexadecimal strings (hex prefixed with "0x").

		 *

		 * Explicit conversion is used only by to_integer.

		 * All other string-to-integer conversions are implicit conversions.

 Check for zero-length buffer */

 Transfer no more than an integer's worth of data */

		/*

		 * Convert buffer to an integer - we simply grab enough raw data

		 * from the buffer to fill an integer

			/*

			 * Get next byte and shift it into the Result.

			 * Little endian is used, meaning that the first byte of the buffer

			 * is the LSB of the integer

 No other types can get here */

 Create a new integer */

 Save the Result */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_convert_to_buffer

 *

 * PARAMETERS:  obj_desc        - Object to be converted. Must be an

 *                                Integer, Buffer, or String

 *              result_desc     - Where the new buffer object is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Convert an ACPI Object to a Buffer

 *

 No conversion necessary */

		/*

		 * Create a new Buffer object.

		 * Need enough space for one integer

 Copy the integer to the buffer, LSB first */

		/*

		 * Create a new Buffer object

		 * Size will be the string length

		 *

		 * NOTE: Add one to the string length to include the null terminator.

		 * The ACPI spec is unclear on this subject, but there is existing

		 * ASL/AML code that depends on the null being transferred to the new

		 * buffer.

 Copy the string to the buffer */

 Mark buffer initialized */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_convert_to_ascii

 *

 * PARAMETERS:  integer         - Value to be converted

 *              base            - ACPI_STRING_DECIMAL or ACPI_STRING_HEX

 *              string          - Where the string is returned

 *              data_width      - Size of data item to be converted, in bytes

 *

 * RETURN:      Actual string length

 *

 * DESCRIPTION: Convert an ACPI Integer to a hex or decimal string

 *

 Setup max length for the decimal number */

 No leading zeros */

 Divide by nth factor of 10 */

 Handle leading zeros */

 hex_length: 2 ascii hex chars per data byte */

 Get one hex digit, most significant digits first */

	/*

	 * Since leading zeros are suppressed, we must check for the case where

	 * the integer equals 0

	 *

	 * Finally, null terminate the string and return the length

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_convert_to_string

 *

 * PARAMETERS:  obj_desc        - Object to be converted. Must be an

 *                                Integer, Buffer, or String

 *              result_desc     - Where the string object is returned

 *              type            - String flags (base and conversion type)

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Convert an ACPI Object to a string. Supports both implicit

 *              and explicit conversions and related rules.

 *

 No conversion necessary */

			/*

			 * From to_decimal_string, integer source.

			 *

			 * Make room for the maximum decimal number size

 Two hex string characters for each integer byte */

		/*

		 * Create a new String

		 * Need enough space for one ASCII integer (plus null terminator)

 Convert integer to string */

 Null terminate at the correct place */

 Setup string length, base, and separator */

 Used by to_decimal_string */

			/*

			 * Explicit conversion from the to_decimal_string ASL operator.

			 *

			 * From ACPI: "If the input is a buffer, it is converted to a

			 * a string of decimal values separated by commas."

			/*

			 * Calculate the final string length. Individual string values

			 * are variable length (include separator for each)

			/*

			 * Implicit buffer-to-string conversion

			 *

			 * From the ACPI spec:

			 * "The entire contents of the buffer are converted to a string of

			 * two-character hexadecimal numbers, each separated by a space."

			 *

			 * Each hex number is prefixed with 0x (11/2018)

			/*

			 * Explicit conversion from the to_hex_string ASL operator.

			 *

			 * From ACPI: "If Data is a buffer, it is converted to a string of

			 * hexadecimal values separated by commas."

			 *

			 * Each hex number is prefixed with 0x (11/2018)

		/*

		 * Create a new string object and string buffer

		 * (-1 because of extra separator included in string_length from above)

		 * Allow creation of zero-length strings from zero-length buffers.

		/*

		 * Convert buffer bytes to hex or decimal values

		 * (separated by commas or spaces)

 Emit 0x prefix for explicit/implicit hex conversion */

 Each digit is separated by either a comma or space */

		/*

		 * Null terminate the string

		 * (overwrites final comma/space from above)

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_convert_to_target_type

 *

 * PARAMETERS:  destination_type    - Current type of the destination

 *              source_desc         - Source object to be converted.

 *              result_desc         - Where the converted object is returned

 *              walk_state          - Current method state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Implements "implicit conversion" rules for storing an object.

 *

 Default behavior */

	/*

	 * If required by the target,

	 * perform implicit conversion on the source before we store it.

 Handles Increment, Decrement cases */

			/*

			 * Named field can always handle conversions

 No conversion allowed for these types */

			/*

			 * These types require an Integer operand. We can convert

			 * a Buffer or a String to an Integer if necessary.

			/*

			 * The operand must be a String. We can convert an

			 * Integer or Buffer if necessary

			/*

			 * The operand must be a Buffer. We can convert an

			 * Integer or String if necessary

		/*

		 * create_xxxx_field cases - we are storing the field object into the name

	/*

	 * Source-to-Target conversion semantics:

	 *

	 * If conversion to the target type cannot be performed, then simply

	 * overwrite the target with the new object and type.

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: exnames - interpreter/scanner name load/execute

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_allocate_name_string

 *

 * PARAMETERS:  prefix_count        - Count of parent levels. Special cases:

 *                                    (-1)==root,  0==none

 *              num_name_segs       - count of 4-character name segments

 *

 * RETURN:      A pointer to the allocated string segment. This segment must

 *              be deleted by the caller.

 *

 * DESCRIPTION: Allocate a buffer for a name string. Ensure allocated name

 *              string is long enough, and set up prefix if any.

 *

	/*

	 * Allow room for all \ and ^ prefixes, all segments and a multi_name_prefix.

	 * Also, one byte for the null terminator.

	 * This may actually be somewhat longer than needed.

 Special case for root */

	/*

	 * Allocate a buffer for the name.

	 * This buffer must be deleted by the caller!

 Set up Root or Parent prefixes if needed */

 Set up Dual or Multi prefixes if needed */

 Set up multi prefixes   */

 Set up dual prefixes */

	/*

	 * Terminate string following prefixes. acpi_ex_name_segment() will

	 * append the segment(s)

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_name_segment

 *

 * PARAMETERS:  in_aml_address  - Pointer to the name in the AML code

 *              name_string     - Where to return the name. The name is appended

 *                                to any existing string to form a namepath

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Extract an ACPI name (4 bytes) from the AML byte stream

 *

	/*

	 * If first character is a digit, then we know that we aren't looking

	 * at a valid name segment

 Valid name segment  */

 Found 4 valid characters */

		/*

		 * First character was not a valid name character,

		 * so we are looking at something other than a name.

		/*

		 * Segment started with one or more valid characters, but fewer than

		 * the required 4

/*******************************************************************************

 *

 * FUNCTION:    acpi_ex_get_name_string

 *

 * PARAMETERS:  data_type           - Object type to be associated with this

 *                                    name

 *              in_aml_address      - Pointer to the namestring in the AML code

 *              out_name_string     - Where the namestring is returned

 *              out_name_length     - Length of the returned string

 *

 * RETURN:      Status, namestring and length

 *

 * DESCRIPTION: Extract a full namepath from the AML byte stream,

 *              including any prefixes.

 *

 Disallow prefixes for types associated with field_unit names */

		/*

		 * data_type is not a field name.

		 * Examine first character of name for root or parent prefix operators

			/*

			 * Remember that we have a root_prefix --

			 * see comment in acpi_ex_allocate_name_string()

 Increment past possibly multiple parent prefixes */

 Not a prefix character */

 Examine first character of name for name segment prefix operator */

 Indicate that we processed a prefix */

 Fetch count of segments remaining in name path */

 Indicate that we processed a prefix */

 null_name valid as of 8-12-98 ASL/AML Grammar Update */

 Consume the NULL byte */

 Name segment string */

 Ran out of segments after processing a prefix */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: dsfield - Dispatcher field routines

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_create_external_region (iASL Disassembler only)

 *

 * PARAMETERS:  lookup_status   - Status from ns_lookup operation

 *              op              - Op containing the Field definition and args

 *              path            - Pathname of the region

 *  `           walk_state      - Current method state

 *              node            - Where the new region node is returned

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Add region to the external list if NOT_FOUND. Create a new

 *              region node/object.

 *

	/*

	 * Table disassembly:

	 * operation_region not found. Generate an External for it, and

	 * insert the name into the namespace.

 Must create and install a region object for the new node */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_create_buffer_field

 *

 * PARAMETERS:  op                  - Current parse op (create_XXField)

 *              walk_state          - Current state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute the create_field operators:

 *              create_bit_field_op,

 *              create_byte_field_op,

 *              create_word_field_op,

 *              create_dword_field_op,

 *              create_qword_field_op,

 *              create_field_op     (all of which define a field in a buffer)

 *

	/*

	 * Get the name_string argument (name of the new buffer_field)

 For create_field, name is the 4th argument */

 For all other create_XXXField operators, name is the 3rd argument */

 Execute flag should always be set when this function is entered */

 Creating new namespace node, should not already exist */

		/*

		 * Mark node temporary if we are executing a normal control

		 * method. (Don't mark if this is a module-level code method)

 Enter the name_string into the namespace */

	/*

	 * We could put the returned object (Node) on the object stack for later,

	 * but for now, we will put it in the "op" object that the parser uses,

	 * so we can get it again at the end of this scope.

	/*

	 * If there is no object attached to the node, this node was just created

	 * and we need to create the field object. Otherwise, this was a lookup

	 * of an existing node and we don't want to create the field object again.

	/*

	 * The Field definition is not fully parsed at this time.

	 * (We must save the address of the AML for the buffer and index operands)

 Create the buffer field object */

	/*

	 * Remember location in AML stream of the field unit opcode and operands

	 * -- since the buffer and index operands must be evaluated.

 Attach constructed field descriptors to parent node */

 Remove local reference to the object */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_get_field_names

 *

 * PARAMETERS:  info            - create_field info structure

 *              walk_state      - Current method state

 *              arg             - First parser arg for the field name list

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Process all named fields in a field declaration. Names are

 *              entered into the namespace.

 *

 First field starts at bit zero */

 Process all elements in the field list (of parse nodes) */

		/*

		 * Four types of field elements are handled:

		 * 1) name - Enters a new named field into the namespace

		 * 2) offset - specifies a bit offset

		 * 3) access_as - changes the access mode/attributes

		 * 4) connection - Associate a resource template with the field

			/*

			 * Get new access_type, access_attribute, and access_length fields

			 * -- to be used for all field units that follow, until the

			 * end-of-field or another access_as keyword is encountered.

			 * NOTE. These three bytes are encoded in the integer value

			 * of the parseop for convenience.

			 *

			 * In field_flags, preserve the flag bits other than the

			 * ACCESS_TYPE bits.

 access_type (byte_acc, word_acc, etc.) */

 access_attribute (attrib_quick, attrib_byte, etc.) */

 access_length (for serial/buffer protocols) */

			/*

			 * Clear any previous connection. New connection is used for all

			 * fields that follow, similar to access_as

			/*

			 * A Connection() is either an actual resource descriptor (buffer)

			 * or a named reference to a resource template

 Lookup the Connection() namepath, it should already exist */

 Lookup the name, it should already exist */

				/*

				 * If there is no object attached to the node, this node was

				 * just created and we need to create the field object.

				 * Otherwise, this was a lookup of an existing node and we

				 * don't want to create the field object again.

 Keep track of bit position for the next field */

 Index relative to previous Connection() */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_create_field

 *

 * PARAMETERS:  op              - Op containing the Field definition and args

 *              region_node     - Object for the containing Operation Region

 *  `           walk_state      - Current method state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create a new field in the specified operation region

 *

 First arg is the name of the parent op_region (must already exist) */

 Second arg is the field flags */

 Each remaining arg is a Named Field */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_init_field_objects

 *

 * PARAMETERS:  op              - Op containing the Field definition and args

 *  `           walk_state      - Current method state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: For each "Field Unit" name in the argument list that is

 *              part of the field declaration, enter the name into the

 *              namespace.

 *

 Execute flag should always be set when this function is entered */

 bank_field Op is deferred, just return OK */

	/*

	 * Get the field_list argument for this opcode. This is the start of the

	 * list of field elements.

 Creating new namespace node(s), should not already exist */

	/*

	 * Mark node(s) temporary if we are executing a normal control

	 * method. (Don't mark if this is a module-level code method)

	/*

	 * Walk the list of entries in the field_list

	 * Note: field_list can be of zero length. In this case, Arg will be NULL.

		/*

		 * Ignore OFFSET/ACCESSAS/CONNECTION terms here; we are only interested

		 * in the field names in order to enter them into the namespace.

 Name already exists, just ignore this error */

 Get the next field element in the list */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_create_bank_field

 *

 * PARAMETERS:  op              - Op containing the Field definition and args

 *              region_node     - Object for the containing Operation Region

 *              walk_state      - Current method state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create a new bank field in the specified operation region

 *

 First arg is the name of the parent op_region (must already exist) */

 Second arg is the Bank Register (Field) (must already exist) */

	/*

	 * Third arg is the bank_value

	 * This arg is a term_arg, not a constant

	 * It will be evaluated later, by acpi_ds_eval_bank_field_operands

 Fourth arg is the field flags */

 Each remaining arg is a Named Field */

	/*

	 * Use Info.data_register_node to store bank_field Op

	 * It's safe because data_register_node will never be used when create

	 * bank field \we store aml_start and aml_length in the bank_field Op for

	 * late evaluation. Used in acpi_ex_prep_field_value(Info)

	 *

	 * TBD: Or, should we add a field in struct acpi_create_field_info, like

	 * "void *ParentOp"?

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_create_index_field

 *

 * PARAMETERS:  op              - Op containing the Field definition and args

 *              region_node     - Object for the containing Operation Region

 *  `           walk_state      - Current method state

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Create a new index field in the specified operation region

 *

 First arg is the name of the Index register (must already exist) */

 Second arg is the data register (must already exist) */

 Next arg is the field flags */

 Each remaining arg is a Named Field */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: nsxfobj - Public interfaces to the ACPI subsystem

 *                         ACPI Object oriented interfaces

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_type

 *

 * PARAMETERS:  handle          - Handle of object whose type is desired

 *              ret_type        - Where the type will be placed

 *

 * RETURN:      Status

 *

 * DESCRIPTION: This routine returns the type associated with a particular

 *              handle

 *

 Parameter Validation */

 Special case for the predefined Root Node (return type ANY) */

 Convert and validate the handle */

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_parent

 *

 * PARAMETERS:  handle          - Handle of object whose parent is desired

 *              ret_handle      - Where the parent handle will be placed

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Returns a handle to the parent of the object represented by

 *              Handle.

 *

 Special case for the predefined Root Node (no parent) */

 Convert and validate the handle */

 Get the parent entry */

 Return exception if parent is null */

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_next_object

 *

 * PARAMETERS:  type            - Type of object to be searched for

 *              parent          - Parent object whose children we are getting

 *              last_child      - Previous child that was found.

 *                                The NEXT child will be returned

 *              ret_handle      - Where handle to the next object is placed

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Return the next peer object within the namespace. If Handle is

 *              valid, Scope is ignored. Otherwise, the first object within

 *              Scope is returned.

 *

 Parameter validation */

 If null handle, use the parent */

 Start search at the beginning of the specified scope */

 Non-null handle, ignore the parent */

 Convert and validate the handle */

 Internal function does the real work */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: dbexec - debugger control method execution

 *

 Local prototypes */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_delete_objects

 *

 * PARAMETERS:  count               - Count of objects in the list

 *              objects             - Array of ACPI_OBJECTs to be deleted

 *

 * RETURN:      None

 *

 * DESCRIPTION: Delete a list of ACPI_OBJECTS. Handles packages and nested

 *              packages via recursion.

 *

 Recursive call to delete package elements */

 Free the elements array */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_execute_method

 *

 * PARAMETERS:  info            - Valid info segment

 *              return_obj      - Where to put return object

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute a control method. Used to evaluate objects via the

 *              "EXECUTE" or "EVALUATE" commands.

 *

 Pass through any command-line arguments */

 Get arguments passed on the command line */

 Convert input string (token) to an actual union acpi_object */

 Prepare for a return object of arbitrary size */

 Do the actual method execution */

 Clear the abort and fall back to the debugger prompt */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_execute_setup

 *

 * PARAMETERS:  info            - Valid method info

 *

 * RETURN:      None

 *

 * DESCRIPTION: Setup info segment prior to method execution

 *

 Concatenate the current scope to the supplied name */

 No single step, allow redirection to a file */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_get_outstanding_allocations

 *

 * PARAMETERS:  None

 *

 * RETURN:      Current global allocation count minus cache entries

 *

 * DESCRIPTION: Determine the current number of "outstanding" allocations --

 *              those allocations that have not been freed and also are not

 *              in one of the various object caches.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_execution_walk

 *

 * PARAMETERS:  WALK_CALLBACK

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Execute a control method. Name is relative to the current

 *              scope.

 *

 Do the actual method execution */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_execute

 *

 * PARAMETERS:  name                - Name of method to execute

 *              args                - Parameters to the method

 *              Types               -

 *              flags               - single step/no single step

 *

 * RETURN:      None

 *

 * DESCRIPTION: Execute a control method. Name is relative to the current

 *              scope. Function used for the "EXECUTE", "EVALUATE", and

 *              "ALL" commands

 *

	/*

	 * Allow one execution to be performed by debugger or single step

	 * execution will be dead locked by the interpreter mutexes.

 Memory allocation tracking */

 Subcommand to Execute all predefined names in the namespace */

 Command (ALL <nameseg>) to execute all methods of a particular name */

 Get the NS node, determines existence also */

	/*

	 * Allow any handlers in separate threads to complete.

	 * (Such as Notify handlers invoked from AML executed above).

 Memory allocation tracking */

 Display a return object, if any */

 Dump a _PLD buffer if present */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_method_thread

 *

 * PARAMETERS:  context             - Execution info segment

 *

 * RETURN:      None

 *

 * DESCRIPTION: Debugger execute thread. Waits for a command line, then

 *              simply dispatches it.

 *

	/*

	 * acpi_gbl_db_method_info.Arguments will be passed as method arguments.

	 * Prevent acpi_gbl_db_method_info from being modified by multiple threads

	 * concurrently.

	 *

	 * Note: The arguments we are passing are used by the ASL test suite

	 * (aslts). Do not change them without updating the tests.

 Signal our completion */

 Do signal for main thread once only */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_single_execution_thread

 *

 * PARAMETERS:  context                 - Method info struct

 *

 * RETURN:      None

 *

 * DESCRIPTION: Create one thread and execute a method

 *

 Display a return object, if any */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_create_execution_thread

 *

 * PARAMETERS:  method_name_arg         - Control method to execute

 *              arguments               - Array of arguments to the method

 *              types                   - Corresponding array of object types

 *

 * RETURN:      None

 *

 * DESCRIPTION: Create a single thread to evaluate a namespace object. Handles

 *              arguments passed on command line for control methods.

 *

 Setup method arguments, up to 7 (0-6) */

 Get the NS node, determines existence also */

/*******************************************************************************

 *

 * FUNCTION:    acpi_db_create_execution_threads

 *

 * PARAMETERS:  num_threads_arg         - Number of threads to create

 *              num_loops_arg           - Loop count for the thread(s)

 *              method_name_arg         - Control method to execute

 *

 * RETURN:      None

 *

 * DESCRIPTION: Create threads to execute method(s)

 *

 Get the arguments */

	/*

	 * Create the semaphore for synchronization of

	 * the created threads with the main thread.

	/*

	 * Create the semaphore for synchronization

	 * between the created threads.

 Array to store IDs of threads */

 Setup the context to be passed to each thread */

 Init arguments to be passed to method */

 Get the NS node, determines existence also */

 Create the threads */

 Wait for all threads to complete */

 Cleanup and exit */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: psparse - Parser top level AML parse routines

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*

 * Parse the AML and build an operation tree as most interpreters,

 * like Perl, do. Parsing is done by hand rather than with a YACC

 * generated parser to tightly constrain stack and dynamic memory

 * usage. At the same time, parsing is kept flexible and the code

 * fairly compact by parsing based on a list of AML opcode

 * templates in aml_op_info[]

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_get_opcode_size

 *

 * PARAMETERS:  opcode          - An AML opcode

 *

 * RETURN:      Size of the opcode, in bytes (1 or 2)

 *

 * DESCRIPTION: Get the size of the current opcode.

 *

 Extended (2-byte) opcode if > 255 */

 Otherwise, just a single byte opcode */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_peek_opcode

 *

 * PARAMETERS:  parser_state        - A parser state object

 *

 * RETURN:      Next AML opcode

 *

 * DESCRIPTION: Get next AML opcode (without incrementing AML pointer)

 *

 Extended opcode, get the second opcode byte */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_complete_this_op

 *

 * PARAMETERS:  walk_state      - Current State

 *              op              - Op to complete

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Perform any cleanup at the completion of an Op.

 *

 Check for null Op, can happen if AML code is corrupt */

 OK for now */

 Delete this op and the subtree below it if asked to */

 Make sure that we only delete this subtree */

 Nothing more to do */

		/*

		 * Check if we need to replace the operator and its subtree

		 * with a return value op (placeholder op)

			/*

			 * These opcodes contain term_arg operands. The current

			 * op must be replaced by a placeholder return op

			/*

			 * These opcodes contain term_arg operands. The current

			 * op must be replaced by a placeholder return op

 We must unlink this op from the parent tree */

 This op is the first in the list */

 Search the parent list */

 Traverse all siblings in the parent's argument list */

 Now we can actually delete the subtree rooted at Op */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_next_parse_state

 *

 * PARAMETERS:  walk_state          - Current state

 *              op                  - Current parse op

 *              callback_status     - Status from previous operation

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Update the parser state based upon the return exception from

 *              the parser callback.

 *

		/*

		 * A control method was terminated via a RETURN statement.

		 * The walk of this method is complete.

		/*

		 * Predicate of an IF was true, and we are at the matching ELSE.

		 * Just close out this package

		/*

		 * Either an IF/WHILE Predicate was false or we encountered a BREAK

		 * opcode. In both cases, we do not execute the rest of the

		 * package;  We simply close out the parent (finishing the walk of

		 * this branch of the tree) and continue execution at the parent

		 * level.

 In the case of a BREAK, just force a predicate (if any) to FALSE */

 A method call (invocation) -- transfer control */

 Will return value (if any) be used by the caller? */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ps_parse_aml

 *

 * PARAMETERS:  walk_state      - Current state

 *

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Parse raw AML and return a tree of ops

 *

 Create and initialize a new thread state */

 Executing a control method - additional cleanup */

	/*

	 * If executing a method, the starting sync_level is this method's

	 * sync_level

	/*

	 * This global allows the AML debugger to get a handle to the currently

	 * executing control method.

	/*

	 * Execute the walk loop as long as there is a valid Walk State. This

	 * handles nested control method invocations without recursion.

			/*

			 * The parse_loop executes AML until the method terminates

			 * or calls another method.

 Optional object evaluation log */

			/*

			 * A method call was detected.

			 * Transfer control to the called control method

			/*

			 * If the transfer to the new method method call worked,

			 * a new walk state was created -- get it

 Either the method parse or actual execution failed */

 Check for possible multi-thread reentrancy problem */

				/*

				 * Method is not serialized and tried to create an object

				 * twice. The probable cause is that the method cannot

				 * handle reentrancy. Mark as "pending serialized" now, and

				 * then mark "serialized" when the last thread exits.

 We are done with this walk, move on to the parent if any */

 Reset the current scope to the beginning of scope stack */

		/*

		 * If we just returned from the execution of a control method or if we

		 * encountered an error during the method parse phase, there's lots of

		 * cleanup to do

 Delete this walk state and all linked control states */

 Check if we have restarted a preempted walk */

				/*

				 * There is another walk state, restart it.

				 * If the method return value is not used by the parent,

				 * The object is deleted

					/*

					 * In slack mode execution, if there is no return value

					 * we should implicitly return zero (0) as a default value.

 Restart the calling control method */

					/*

					 * We have a valid return value, delete any implicit

					 * return value.

 On error, delete any return object or implicit return */

		/*

		 * Just completed a 1st-level method, save the final internal return

		 * value (if any)

 NULL if no return value */

 Caller doesn't want it, must delete it */

 Caller doesn't want it, must delete it */

 Normal exit */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: dscontrol - Support for execution control opcodes -

 *                          if/else/while/return

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_exec_begin_control_op

 *

 * PARAMETERS:  walk_list       - The list that owns the walk stack

 *              op              - The control Op

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Handles all control ops encountered during control method

 *              execution.

 *

		/*

		 * If this is an additional iteration of a while loop, continue.

		 * There is no need to allocate a new control state.

 Reset the state to start-of-loop */

		/*

		 * IF/WHILE: Create a new control state to manage these

		 * constructs. We need to manage these as a stack, in order

		 * to handle nesting.

		/*

		 * Save a pointer to the predicate for multiple executions

		 * of a loop

 Push the control state on this walk's control stack */

 Predicate is in the state object */

 If predicate is true, the IF was executed, ignore ELSE part */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ds_exec_end_control_op

 *

 * PARAMETERS:  walk_list       - The list that owns the walk stack

 *              op              - The control Op

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Handles all control ops encountered during control method

 *              execution.

 *

		/*

		 * Save the result of the predicate in case there is an

		 * ELSE to come

		/*

		 * Pop the control state that was created at the start

		 * of the IF and free it

 Predicate was true, the body of the loop was just executed */

			/*

			 * This infinite loop detection mechanism allows the interpreter

			 * to escape possibly infinite loops. This can occur in poorly

			 * written AML when the hardware does not respond within a while

			 * loop and the loop does not implement a timeout.

			/*

			 * Go back and evaluate the predicate and maybe execute the loop

			 * another time

 Predicate was false, terminate this while loop */

 Pop this control state and free it */

		/*

		 * One optional operand -- the return value

		 * It can be either an immediate operand or a result that

		 * has been bubbled up the tree

 Since we have a real Return(), delete any implicit return */

 Return statement has an immediate operand */

			/*

			 * If value being returned is a Reference (such as

			 * an arg or local), resolve it now because it may

			 * cease to exist at the end of the method.

			/*

			 * Get the return value and save as the last result

			 * value. This is the only place where walk_state->return_desc

			 * is set to anything other than zero!

 Since we have a real Return(), delete any implicit return */

			/*

			 * The return value has come from a previous calculation.

			 *

			 * If value being returned is a Reference (such as

			 * an arg or local), resolve it now because it may

			 * cease to exist at the end of the method.

			 *

			 * Allow references created by the Index operator to return

			 * unchanged.

 No return operand */

 End the control method execution right now */

 Just do nothing! */

 Call to the OSL in case OS wants a piece of the action */

 ACPI 2.0 */

 Pop and delete control states until we find a while */

 No while found? */

 Was: walk_state->aml_last_while = walk_state->control_state->Control.aml_predicate_start; */

 Return status depending on opcode */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: psopcode - Parser/Interpreter opcode information table

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * NAME:        acpi_gbl_aml_op_info

 *

 * DESCRIPTION: Opcode table. Each entry contains <opcode, type, name, operands>

 *              The name is a simple ascii string, the operand specifier is an

 *              ascii string with one letter per operand. The letter specifies

 *              the operand type.

 *

/*

 * Summary of opcode types/flags

 *



 Opcodes that have associated namespace objects (AML_NSOBJECT flag)



	AML_SCOPE_OP

	AML_DEVICE_OP

	AML_THERMAL_ZONE_OP

	AML_METHOD_OP

	AML_POWER_RESOURCE_OP

	AML_PROCESSOR_OP

	AML_FIELD_OP

	AML_INDEX_FIELD_OP

	AML_BANK_FIELD_OP

	AML_NAME_OP

	AML_ALIAS_OP

	AML_MUTEX_OP

	AML_EVENT_OP

	AML_REGION_OP

	AML_CREATE_FIELD_OP

	AML_CREATE_BIT_FIELD_OP

	AML_CREATE_BYTE_FIELD_OP

	AML_CREATE_WORD_FIELD_OP

	AML_CREATE_DWORD_FIELD_OP

	AML_CREATE_QWORD_FIELD_OP

	AML_INT_NAMEDFIELD_OP

	AML_INT_METHODCALL_OP

	AML_INT_NAMEPATH_OP



  Opcodes that are "namespace" opcodes (AML_NSOPCODE flag)



	AML_SCOPE_OP

	AML_DEVICE_OP

	AML_THERMAL_ZONE_OP

	AML_METHOD_OP

	AML_POWER_RESOURCE_OP

	AML_PROCESSOR_OP

	AML_FIELD_OP

	AML_INDEX_FIELD_OP

	AML_BANK_FIELD_OP

	AML_NAME_OP

	AML_ALIAS_OP

	AML_MUTEX_OP

	AML_EVENT_OP

	AML_REGION_OP

	AML_INT_NAMEDFIELD_OP



  Opcodes that have an associated namespace node (AML_NSNODE flag)



	AML_SCOPE_OP

	AML_DEVICE_OP

	AML_THERMAL_ZONE_OP

	AML_METHOD_OP

	AML_POWER_RESOURCE_OP

	AML_PROCESSOR_OP

	AML_NAME_OP

	AML_ALIAS_OP

	AML_MUTEX_OP

	AML_EVENT_OP

	AML_REGION_OP

	AML_CREATE_FIELD_OP

	AML_CREATE_BIT_FIELD_OP

	AML_CREATE_BYTE_FIELD_OP

	AML_CREATE_WORD_FIELD_OP

	AML_CREATE_DWORD_FIELD_OP

	AML_CREATE_QWORD_FIELD_OP

	AML_INT_NAMEDFIELD_OP

	AML_INT_METHODCALL_OP

	AML_INT_NAMEPATH_OP



  Opcodes that define named ACPI objects (AML_NAMED flag)



	AML_SCOPE_OP

	AML_DEVICE_OP

	AML_THERMAL_ZONE_OP

	AML_METHOD_OP

	AML_POWER_RESOURCE_OP

	AML_PROCESSOR_OP

	AML_NAME_OP

	AML_ALIAS_OP

	AML_MUTEX_OP

	AML_EVENT_OP

	AML_REGION_OP

	AML_INT_NAMEDFIELD_OP



  Opcodes that contain executable AML as part of the definition that

  must be deferred until needed



	AML_METHOD_OP

	AML_VARIABLE_PACKAGE_OP

	AML_CREATE_FIELD_OP

	AML_CREATE_BIT_FIELD_OP

	AML_CREATE_BYTE_FIELD_OP

	AML_CREATE_WORD_FIELD_OP

	AML_CREATE_DWORD_FIELD_OP

	AML_CREATE_QWORD_FIELD_OP

	AML_REGION_OP

	AML_BUFFER_OP



  Field opcodes



	AML_CREATE_FIELD_OP

	AML_FIELD_OP

	AML_INDEX_FIELD_OP

	AML_BANK_FIELD_OP



  Field "Create" opcodes



	AML_CREATE_FIELD_OP

	AML_CREATE_BIT_FIELD_OP

	AML_CREATE_BYTE_FIELD_OP

	AML_CREATE_WORD_FIELD_OP

	AML_CREATE_DWORD_FIELD_OP

	AML_CREATE_QWORD_FIELD_OP



/*

 * Master Opcode information table. A summary of everything we know about each

 * opcode, all in one place.

! [Begin] no source code translation */

 Index           Name                 Parser Args               Interpreter Args                ObjectType                    Class                      Type                  Flags */

 00 */ ACPI_OP("Zero", ARGP_ZERO_OP, ARGI_ZERO_OP, ACPI_TYPE_INTEGER,

 01 */ ACPI_OP("One", ARGP_ONE_OP, ARGI_ONE_OP, ACPI_TYPE_INTEGER,

 02 */ ACPI_OP("Alias", ARGP_ALIAS_OP, ARGI_ALIAS_OP,

 03 */ ACPI_OP("Name", ARGP_NAME_OP, ARGI_NAME_OP, ACPI_TYPE_ANY,

 04 */ ACPI_OP("ByteConst", ARGP_BYTE_OP, ARGI_BYTE_OP,

 05 */ ACPI_OP("WordConst", ARGP_WORD_OP, ARGI_WORD_OP,

 06 */ ACPI_OP("DwordConst", ARGP_DWORD_OP, ARGI_DWORD_OP,

 07 */ ACPI_OP("String", ARGP_STRING_OP, ARGI_STRING_OP,

 08 */ ACPI_OP("Scope", ARGP_SCOPE_OP, ARGI_SCOPE_OP,

 09 */ ACPI_OP("Buffer", ARGP_BUFFER_OP, ARGI_BUFFER_OP,

 0A */ ACPI_OP("Package", ARGP_PACKAGE_OP, ARGI_PACKAGE_OP,

 0B */ ACPI_OP("Method", ARGP_METHOD_OP, ARGI_METHOD_OP,

 0C */ ACPI_OP("Local0", ARGP_LOCAL0, ARGI_LOCAL0,

 0D */ ACPI_OP("Local1", ARGP_LOCAL1, ARGI_LOCAL1,

 0E */ ACPI_OP("Local2", ARGP_LOCAL2, ARGI_LOCAL2,

 0F */ ACPI_OP("Local3", ARGP_LOCAL3, ARGI_LOCAL3,

 10 */ ACPI_OP("Local4", ARGP_LOCAL4, ARGI_LOCAL4,

 11 */ ACPI_OP("Local5", ARGP_LOCAL5, ARGI_LOCAL5,

 12 */ ACPI_OP("Local6", ARGP_LOCAL6, ARGI_LOCAL6,

 13 */ ACPI_OP("Local7", ARGP_LOCAL7, ARGI_LOCAL7,

 14 */ ACPI_OP("Arg0", ARGP_ARG0, ARGI_ARG0,

 15 */ ACPI_OP("Arg1", ARGP_ARG1, ARGI_ARG1,

 16 */ ACPI_OP("Arg2", ARGP_ARG2, ARGI_ARG2,

 17 */ ACPI_OP("Arg3", ARGP_ARG3, ARGI_ARG3,

 18 */ ACPI_OP("Arg4", ARGP_ARG4, ARGI_ARG4,

 19 */ ACPI_OP("Arg5", ARGP_ARG5, ARGI_ARG5,

 1A */ ACPI_OP("Arg6", ARGP_ARG6, ARGI_ARG6,

 1B */ ACPI_OP("Store", ARGP_STORE_OP, ARGI_STORE_OP, ACPI_TYPE_ANY,

 1C */ ACPI_OP("RefOf", ARGP_REF_OF_OP, ARGI_REF_OF_OP, ACPI_TYPE_ANY,

 1D */ ACPI_OP("Add", ARGP_ADD_OP, ARGI_ADD_OP, ACPI_TYPE_ANY,

 1E */ ACPI_OP("Concatenate", ARGP_CONCAT_OP, ARGI_CONCAT_OP,

 1F */ ACPI_OP("Subtract", ARGP_SUBTRACT_OP, ARGI_SUBTRACT_OP,

 20 */ ACPI_OP("Increment", ARGP_INCREMENT_OP, ARGI_INCREMENT_OP,

 21 */ ACPI_OP("Decrement", ARGP_DECREMENT_OP, ARGI_DECREMENT_OP,

 22 */ ACPI_OP("Multiply", ARGP_MULTIPLY_OP, ARGI_MULTIPLY_OP,

 23 */ ACPI_OP("Divide", ARGP_DIVIDE_OP, ARGI_DIVIDE_OP,

 24 */ ACPI_OP("ShiftLeft", ARGP_SHIFT_LEFT_OP, ARGI_SHIFT_LEFT_OP,

 25 */ ACPI_OP("ShiftRight", ARGP_SHIFT_RIGHT_OP, ARGI_SHIFT_RIGHT_OP,

 26 */ ACPI_OP("And", ARGP_BIT_AND_OP, ARGI_BIT_AND_OP, ACPI_TYPE_ANY,

 27 */ ACPI_OP("NAnd", ARGP_BIT_NAND_OP, ARGI_BIT_NAND_OP,

 28 */ ACPI_OP("Or", ARGP_BIT_OR_OP, ARGI_BIT_OR_OP, ACPI_TYPE_ANY,

 29 */ ACPI_OP("NOr", ARGP_BIT_NOR_OP, ARGI_BIT_NOR_OP, ACPI_TYPE_ANY,

 2A */ ACPI_OP("XOr", ARGP_BIT_XOR_OP, ARGI_BIT_XOR_OP, ACPI_TYPE_ANY,

 2B */ ACPI_OP("Not", ARGP_BIT_NOT_OP, ARGI_BIT_NOT_OP, ACPI_TYPE_ANY,

 2C */ ACPI_OP("FindSetLeftBit", ARGP_FIND_SET_LEFT_BIT_OP,

 2D */ ACPI_OP("FindSetRightBit", ARGP_FIND_SET_RIGHT_BIT_OP,

 2E */ ACPI_OP("DerefOf", ARGP_DEREF_OF_OP, ARGI_DEREF_OF_OP,

 2F */ ACPI_OP("Notify", ARGP_NOTIFY_OP, ARGI_NOTIFY_OP,

 30 */ ACPI_OP("SizeOf", ARGP_SIZE_OF_OP, ARGI_SIZE_OF_OP,

 31 */ ACPI_OP("Index", ARGP_INDEX_OP, ARGI_INDEX_OP, ACPI_TYPE_ANY,

 32 */ ACPI_OP("Match", ARGP_MATCH_OP, ARGI_MATCH_OP, ACPI_TYPE_ANY,

 33 */ ACPI_OP("CreateDWordField", ARGP_CREATE_DWORD_FIELD_OP,

 34 */ ACPI_OP("CreateWordField", ARGP_CREATE_WORD_FIELD_OP,

 35 */ ACPI_OP("CreateByteField", ARGP_CREATE_BYTE_FIELD_OP,

 36 */ ACPI_OP("CreateBitField", ARGP_CREATE_BIT_FIELD_OP,

 37 */ ACPI_OP("ObjectType", ARGP_OBJECT_TYPE_OP, ARGI_OBJECT_TYPE_OP,

 38 */ ACPI_OP("LAnd", ARGP_LAND_OP, ARGI_LAND_OP, ACPI_TYPE_ANY,

 39 */ ACPI_OP("LOr", ARGP_LOR_OP, ARGI_LOR_OP, ACPI_TYPE_ANY,

 3A */ ACPI_OP("LNot", ARGP_LNOT_OP, ARGI_LNOT_OP, ACPI_TYPE_ANY,

 3B */ ACPI_OP("LEqual", ARGP_LEQUAL_OP, ARGI_LEQUAL_OP,

 3C */ ACPI_OP("LGreater", ARGP_LGREATER_OP, ARGI_LGREATER_OP,

 3D */ ACPI_OP("LLess", ARGP_LLESS_OP, ARGI_LLESS_OP, ACPI_TYPE_ANY,

 3E */ ACPI_OP("If", ARGP_IF_OP, ARGI_IF_OP, ACPI_TYPE_ANY,

 3F */ ACPI_OP("Else", ARGP_ELSE_OP, ARGI_ELSE_OP, ACPI_TYPE_ANY,

 40 */ ACPI_OP("While", ARGP_WHILE_OP, ARGI_WHILE_OP, ACPI_TYPE_ANY,

 41 */ ACPI_OP("Noop", ARGP_NOOP_OP, ARGI_NOOP_OP, ACPI_TYPE_ANY,

 42 */ ACPI_OP("Return", ARGP_RETURN_OP, ARGI_RETURN_OP,

 43 */ ACPI_OP("Break", ARGP_BREAK_OP, ARGI_BREAK_OP, ACPI_TYPE_ANY,

 44 */ ACPI_OP("BreakPoint", ARGP_BREAK_POINT_OP, ARGI_BREAK_POINT_OP,

 45 */ ACPI_OP("Ones", ARGP_ONES_OP, ARGI_ONES_OP, ACPI_TYPE_INTEGER,

 Prefixed opcodes (Two-byte opcodes with a prefix op) */

 46 */ ACPI_OP("Mutex", ARGP_MUTEX_OP, ARGI_MUTEX_OP, ACPI_TYPE_MUTEX,

 47 */ ACPI_OP("Event", ARGP_EVENT_OP, ARGI_EVENT_OP, ACPI_TYPE_EVENT,

 48 */ ACPI_OP("CondRefOf", ARGP_COND_REF_OF_OP, ARGI_COND_REF_OF_OP,

 49 */ ACPI_OP("CreateField", ARGP_CREATE_FIELD_OP,

 4A */ ACPI_OP("Load", ARGP_LOAD_OP, ARGI_LOAD_OP, ACPI_TYPE_ANY,

 4B */ ACPI_OP("Stall", ARGP_STALL_OP, ARGI_STALL_OP, ACPI_TYPE_ANY,

 4C */ ACPI_OP("Sleep", ARGP_SLEEP_OP, ARGI_SLEEP_OP, ACPI_TYPE_ANY,

 4D */ ACPI_OP("Acquire", ARGP_ACQUIRE_OP, ARGI_ACQUIRE_OP,

 4E */ ACPI_OP("Signal", ARGP_SIGNAL_OP, ARGI_SIGNAL_OP,

 4F */ ACPI_OP("Wait", ARGP_WAIT_OP, ARGI_WAIT_OP, ACPI_TYPE_ANY,

 50 */ ACPI_OP("Reset", ARGP_RESET_OP, ARGI_RESET_OP, ACPI_TYPE_ANY,

 51 */ ACPI_OP("Release", ARGP_RELEASE_OP, ARGI_RELEASE_OP,

 52 */ ACPI_OP("FromBCD", ARGP_FROM_BCD_OP, ARGI_FROM_BCD_OP,

 53 */ ACPI_OP("ToBCD", ARGP_TO_BCD_OP, ARGI_TO_BCD_OP, ACPI_TYPE_ANY,

 54 */ ACPI_OP("Unload", ARGP_UNLOAD_OP, ARGI_UNLOAD_OP,

 55 */ ACPI_OP("Revision", ARGP_REVISION_OP, ARGI_REVISION_OP,

 56 */ ACPI_OP("Debug", ARGP_DEBUG_OP, ARGI_DEBUG_OP,

 57 */ ACPI_OP("Fatal", ARGP_FATAL_OP, ARGI_FATAL_OP, ACPI_TYPE_ANY,

 58 */ ACPI_OP("OperationRegion", ARGP_REGION_OP, ARGI_REGION_OP,

 59 */ ACPI_OP("Field", ARGP_FIELD_OP, ARGI_FIELD_OP, ACPI_TYPE_ANY,

 5A */ ACPI_OP("Device", ARGP_DEVICE_OP, ARGI_DEVICE_OP,

 5B */ ACPI_OP("Processor", ARGP_PROCESSOR_OP, ARGI_PROCESSOR_OP,

 5C */ ACPI_OP("PowerResource", ARGP_POWER_RES_OP, ARGI_POWER_RES_OP,

 5D */ ACPI_OP("ThermalZone", ARGP_THERMAL_ZONE_OP,

 5E */ ACPI_OP("IndexField", ARGP_INDEX_FIELD_OP, ARGI_INDEX_FIELD_OP,

 5F */ ACPI_OP("BankField", ARGP_BANK_FIELD_OP, ARGI_BANK_FIELD_OP,

 Internal opcodes that map to invalid AML opcodes */

 60 */ ACPI_OP("LNotEqual", ARGP_LNOTEQUAL_OP, ARGI_LNOTEQUAL_OP,

 61 */ ACPI_OP("LLessEqual", ARGP_LLESSEQUAL_OP, ARGI_LLESSEQUAL_OP,

 62 */ ACPI_OP("LGreaterEqual", ARGP_LGREATEREQUAL_OP,

 63 */ ACPI_OP("-NamePath-", ARGP_NAMEPATH_OP, ARGI_NAMEPATH_OP,

 64 */ ACPI_OP("-MethodCall-", ARGP_METHODCALL_OP, ARGI_METHODCALL_OP,

 65 */ ACPI_OP("-ByteList-", ARGP_BYTELIST_OP, ARGI_BYTELIST_OP,

 66 */ ACPI_OP("-ReservedField-", ARGP_RESERVEDFIELD_OP,

 67 */ ACPI_OP("-NamedField-", ARGP_NAMEDFIELD_OP, ARGI_NAMEDFIELD_OP,

 68 */ ACPI_OP("-AccessField-", ARGP_ACCESSFIELD_OP,

 69 */ ACPI_OP("-StaticString", ARGP_STATICSTRING_OP,

 6A */ ACPI_OP("-Return Value-", ARG_NONE, ARG_NONE, ACPI_TYPE_ANY,

 6B */ ACPI_OP("-UNKNOWN_OP-", ARG_NONE, ARG_NONE, ACPI_TYPE_INVALID,

 6C */ ACPI_OP("-ASCII_ONLY-", ARG_NONE, ARG_NONE, ACPI_TYPE_ANY,

 6D */ ACPI_OP("-PREFIX_ONLY-", ARG_NONE, ARG_NONE, ACPI_TYPE_ANY,

 ACPI 2.0 opcodes */

 6E */ ACPI_OP("QwordConst", ARGP_QWORD_OP, ARGI_QWORD_OP,

 6F */ ACPI_OP("Package", 
 70 */ ACPI_OP("ConcatenateResTemplate", ARGP_CONCAT_RES_OP,

 71 */ ACPI_OP("Mod", ARGP_MOD_OP, ARGI_MOD_OP, ACPI_TYPE_ANY,

 72 */ ACPI_OP("CreateQWordField", ARGP_CREATE_QWORD_FIELD_OP,

 73 */ ACPI_OP("ToBuffer", ARGP_TO_BUFFER_OP, ARGI_TO_BUFFER_OP,

 74 */ ACPI_OP("ToDecimalString", ARGP_TO_DEC_STR_OP,

 75 */ ACPI_OP("ToHexString", ARGP_TO_HEX_STR_OP, ARGI_TO_HEX_STR_OP,

 76 */ ACPI_OP("ToInteger", ARGP_TO_INTEGER_OP, ARGI_TO_INTEGER_OP,

 77 */ ACPI_OP("ToString", ARGP_TO_STRING_OP, ARGI_TO_STRING_OP,

 78 */ ACPI_OP("CopyObject", ARGP_COPY_OP, ARGI_COPY_OP,

 79 */ ACPI_OP("Mid", ARGP_MID_OP, ARGI_MID_OP, ACPI_TYPE_ANY,

 7A */ ACPI_OP("Continue", ARGP_CONTINUE_OP, ARGI_CONTINUE_OP,

 7B */ ACPI_OP("LoadTable", ARGP_LOAD_TABLE_OP, ARGI_LOAD_TABLE_OP,

 7C */ ACPI_OP("DataTableRegion", ARGP_DATA_REGION_OP,

 7D */ ACPI_OP("[EvalSubTree]", ARGP_SCOPE_OP, ARGI_SCOPE_OP,

 ACPI 3.0 opcodes */

 7E */ ACPI_OP("Timer", ARGP_TIMER_OP, ARGI_TIMER_OP, ACPI_TYPE_ANY,

 ACPI 5.0 opcodes */

 7F */ ACPI_OP("-ConnectField-", ARGP_CONNECTFIELD_OP,

 80 */ ACPI_OP("-ExtAccessField-", ARGP_CONNECTFIELD_OP,

 ACPI 6.0 opcodes */

 81 */ ACPI_OP("External", ARGP_EXTERNAL_OP, ARGI_EXTERNAL_OP,

 82 */ ACPI_OP("Comment", ARGP_COMMENT_OP, ARGI_COMMENT_OP,

! [End] no source code translation !*/

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: rsmisc - Miscellaneous resource descriptors

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_convert_aml_to_resource

 *

 * PARAMETERS:  resource            - Pointer to the resource descriptor

 *              aml                 - Where the AML descriptor is returned

 *              info                - Pointer to appropriate conversion table

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Convert an external AML resource descriptor to the corresponding

 *              internal resource descriptor

 *

 Each internal resource struct is expected to be 32-bit aligned */

 Extract the resource Length field (does not include header length) */

	/*

	 * First table entry must be ACPI_RSC_INITxxx and must contain the

	 * table length (# of table entries)

		/*

		 * Source is the external AML byte stream buffer,

		 * destination is the internal resource descriptor

			/*

			 * Get the resource type and the initial (minimum) length

			/*

			 * Mask and shift the flag bit

			/*

			 * Mask and shift the flag bits

			/*

			 * Mask and shift the flag bits

			/*

			 * Mask and shift the flag bits

			/*

			 * Vendor data is optional (length/offset may both be zero)

			 * Examine vendor data length field first

 Use vendor offset to get resource source length */

 No vendor data to worry about */

			/*

			 * Raw data move. Use the Info value field unless item_count has

			 * been previously initialized via a COUNT opcode

 Generate and set the PIN data pointer */

 Copy the PIN data */

 Generate and set the resource_source string pointer */

 Copy the resource_source string */

 Generate and set the Vendor Data pointer */

 Copy the Vendor Data */

 Generate and set the resource_source string pointer */

 Copy the resource_source string */

			/*

			 * Common handler for address descriptor flags

			/*

			 * Optional resource_source (Index and String)

			/*

			 * Optional resource_source (Index and String). This is the more

			 * complicated case used by the Interrupt() macro

			/*

			 * 8-bit encoded bitmask (DMA macro)

			/*

			 * 16-bit encoded bitmask (IRQ macro)

			/*

			 * control - Exit conversion if not equal

 Round the resource struct length up to the next boundary (32 or 64) */

/*******************************************************************************

 *

 * FUNCTION:    acpi_rs_convert_resource_to_aml

 *

 * PARAMETERS:  resource            - Pointer to the resource descriptor

 *              aml                 - Where the AML descriptor is returned

 *              info                - Pointer to appropriate conversion table

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Convert an internal resource descriptor to the corresponding

 *              external AML resource descriptor.

 *

	/*

	 * First table entry must be ACPI_RSC_INITxxx and must contain the

	 * table length (# of table entries)

		/*

		 * Source is the internal resource descriptor,

		 * destination is the external AML byte stream buffer

			/*

			 * Clear the flag byte

			/*

			 * Mask and shift the flag bit

			/*

			 * Mask and shift the flag bits

			/*

			 * Mask and shift the flag bits

			/*

			 * Mask and shift the flag bits

 Set resource source string length */

 Compute offset for the Vendor Data */

 Set vendor offset only if there is vendor data */

 Used for both resource_source string and vendor_data */

 Set the Resource Type, General Flags, and Type-Specific Flags */

			/*

			 * Optional resource_source (Index and String)

			/*

			 * Optional resource_source (Index and String). This is the more

			 * complicated case used by the Interrupt() macro

			/*

			 * 8-bit encoded bitmask (DMA macro)

			/*

			 * 16-bit encoded bitmask (IRQ macro)

			/*

			 * control - Exit conversion if less than or equal

			/*

			 * control - Exit conversion if not equal

			/*

			 * control - Exit conversion if equal

 Previous resource validations */

	/*

	 * Only [active_high, edge_sensitive] or [active_low, level_sensitive]

	 * polarity/trigger interrupts are allowed (ACPI spec, section

	 * "IRQ Format"), so 0x00 and 0x09 are illegal.

 Must have at least one IRQ */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/******************************************************************************

 *

 * Module Name: utxface - External interfaces, miscellaneous utility functions

 *

 * Copyright (C) 2000 - 2021, Intel Corp.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_terminate

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Shutdown the ACPICA subsystem and release all resources.

 *

 Shutdown and free all resources */

 Free the mutex objects */

 Now we can shutdown the OS-dependent layer */

/*******************************************************************************

 *

 * FUNCTION:    acpi_subsystem_status

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status of the ACPI subsystem

 *

 * DESCRIPTION: Other drivers that use the ACPI subsystem should call this

 *              before making any other calls, to ensure the subsystem

 *              initialized successfully.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_system_info

 *

 * PARAMETERS:  out_buffer      - A buffer to receive the resources for the

 *                                device

 *

 * RETURN:      status          - the status of the call

 *

 * DESCRIPTION: This function is called to get information about the current

 *              state of the ACPI subsystem. It will return system information

 *              in the out_buffer.

 *

 *              If the function fails an appropriate status will be returned

 *              and the value of out_buffer is undefined.

 *

 Parameter validation */

 Validate/Allocate/Clear caller buffer */

	/*

	 * Populate the return buffer

 System flags (ACPI capabilities) */

 Timer resolution - 24 or 32 bits  */

 Clear the reserved fields */

 Current debug levels */

/*******************************************************************************

 *

 * FUNCTION:    acpi_get_statistics

 *

 * PARAMETERS:  stats           - Where the statistics are returned

 *

 * RETURN:      status          - the status of the call

 *

 * DESCRIPTION: Get the contents of the various system counters

 *

 Parameter validation */

 Various interrupt-based event counters */

 Other counters */

/*****************************************************************************

 *

 * FUNCTION:    acpi_install_initialization_handler

 *

 * PARAMETERS:  handler             - Callback procedure

 *              function            - Not (currently) used, see below

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Install an initialization handler

 *

 * TBD: When a second function is added, must save the Function also.

 *

/*****************************************************************************

 *

 * FUNCTION:    acpi_purge_cached_objects

 *

 * PARAMETERS:  None

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Empty all caches (delete the cached objects)

 *

/*****************************************************************************

 *

 * FUNCTION:    acpi_install_interface

 *

 * PARAMETERS:  interface_name      - The interface to install

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Install an _OSI interface to the global list

 *

 Parameter validation */

 Check if the interface name is already in the global list */

		/*

		 * The interface already exists in the list. This is OK if the

		 * interface has been marked invalid -- just clear the bit.

 New interface name, install into the global list */

/*****************************************************************************

 *

 * FUNCTION:    acpi_remove_interface

 *

 * PARAMETERS:  interface_name      - The interface to remove

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Remove an _OSI interface from the global list

 *

 Parameter validation */

/*****************************************************************************

 *

 * FUNCTION:    acpi_install_interface_handler

 *

 * PARAMETERS:  handler             - The _OSI interface handler to install

 *                                    NULL means "remove existing handler"

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Install a handler for the predefined _OSI ACPI method.

 *              invoked during execution of the internal implementation of

 *              _OSI. A NULL handler simply removes any existing handler.

 *

/*****************************************************************************

 *

 * FUNCTION:    acpi_update_interfaces

 *

 * PARAMETERS:  action              - Actions to be performed during the

 *                                    update

 *

 * RETURN:      Status

 *

 * DESCRIPTION: Update _OSI interface strings, disabling or enabling OS vendor

 *              string or/and feature group strings.

 *

/*****************************************************************************

 *

 * FUNCTION:    acpi_check_address_range

 *

 * PARAMETERS:  space_id            - Address space ID

 *              address             - Start address

 *              length              - Length

 *              warn                - TRUE if warning on overlap desired

 *

 * RETURN:      Count of the number of conflicts detected.

 *

 * DESCRIPTION: Check if the input address range overlaps any of the

 *              ASL operation region address ranges.

 *

 !ACPI_ASL_COMPILER */

/*******************************************************************************

 *

 * FUNCTION:    acpi_decode_pld_buffer

 *

 * PARAMETERS:  in_buffer           - Buffer returned by _PLD method

 *              length              - Length of the in_buffer

 *              return_buffer       - Where the decode buffer is returned

 *

 * RETURN:      Status and the decoded _PLD buffer. User must deallocate

 *              the buffer via ACPI_FREE.

 *

 * DESCRIPTION: Decode the bit-packed buffer returned by the _PLD method into

 *              a local struct that is much more useful to an ACPI driver.

 *

 Parameter validation */

 First 32-bit DWord */

 Second 32-bit DWord */

 Third 32-bit DWord */

 Fourth 32-bit DWord */

 Fifth 32-bit DWord (Revision 2 of _PLD) */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*******************************************************************************

 *

 * Module Name: utstrtoul64 - String-to-integer conversion support for both

 *                            64-bit and 32-bit integers

 *

/*******************************************************************************

 *

 * This module contains the top-level string to 64/32-bit unsigned integer

 * conversion functions:

 *

 *  1) A standard strtoul() function that supports 64-bit integers, base

 *     8/10/16, with integer overflow support. This is used mainly by the

 *     iASL compiler, which implements tighter constraints on integer

 *     constants than the runtime (interpreter) integer-to-string conversions.

 *  2) Runtime "Explicit conversion" as defined in the ACPI specification.

 *  3) Runtime "Implicit conversion" as defined in the ACPI specification.

 *

 * Current users of this module:

 *

 *  iASL        - Preprocessor (constants and math expressions)

 *  iASL        - Main parser, conversion of constants to integers

 *  iASL        - Data Table Compiler parser (constants and math expressions)

 *  interpreter - Implicit and explicit conversions, GPE method names

 *  interpreter - Repair code for return values from predefined names

 *  debugger    - Command line input string conversion

 *  acpi_dump   - ACPI table physical addresses

 *  acpi_exec   - Support for namespace overrides

 *

 * Notes concerning users of these interfaces:

 *

 * acpi_gbl_integer_byte_width is used to set the 32/64 bit limit for explicit

 * and implicit conversions. This global must be set to the proper width.

 * For the core ACPICA code, the width depends on the DSDT version. For the

 * acpi_ut_strtoul64 interface, all conversions are 64 bits. This interface is

 * used primarily for iASL, where the default width is 64 bits for all parsers,

 * but error checking is performed later to flag cases where a 64-bit constant

 * is wrongly defined in a 32-bit DSDT/SSDT.

 *

 * In ACPI, the only place where octal numbers are supported is within

 * the ASL language itself. This is implemented via the main acpi_ut_strtoul64

 * interface. According the ACPI specification, there is no ACPI runtime

 * support (explicit/implicit) for octal string conversions.

 *

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_strtoul64

 *

 * PARAMETERS:  string                  - Null terminated input string,

 *                                        must be a valid pointer

 *              return_value            - Where the converted integer is

 *                                        returned. Must be a valid pointer

 *

 * RETURN:      Status and converted integer. Returns an exception on a

 *              64-bit numeric overflow

 *

 * DESCRIPTION: Convert a string into an unsigned integer. Always performs a

 *              full 64-bit conversion, regardless of the current global

 *              integer width. Supports Decimal, Hex, and Octal strings.

 *

 * Current users of this function:

 *

 *  iASL        - Preprocessor (constants and math expressions)

 *  iASL        - Main ASL parser, conversion of ASL constants to integers

 *  iASL        - Data Table Compiler parser (constants and math expressions)

 *  interpreter - Repair code for return values from predefined names

 *  acpi_dump   - ACPI table physical addresses

 *  acpi_exec   - Support for namespace overrides

 *

 Default is decimal */

 A NULL return string returns a value of zero */

	/*

	 * 1) Check for a hex constant. A "0x" prefix indicates base 16.

	/*

	 * 2) Check for an octal constant, defined to be a leading zero

	 * followed by sequence of octal digits (0-7)

 Return value 0 */

	/*

	 * Force a full 64-bit conversion. The caller (usually iASL) must

	 * check for a 32-bit overflow later as necessary (If current mode

	 * is 32-bit, meaning a 32-bit DSDT).

	/*

	 * Perform the base 8, 10, or 16 conversion. A 64-bit numeric overflow

	 * will return an exception (to allow iASL to flag the statement).

 Only possible exception from above is a 64-bit overflow */

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_implicit_strtoul64

 *

 * PARAMETERS:  string                  - Null terminated input string,

 *                                        must be a valid pointer

 *

 * RETURN:      Converted integer

 *

 * DESCRIPTION: Perform a 64-bit conversion with restrictions placed upon

 *              an "implicit conversion" by the ACPI specification. Used by

 *              many ASL operators that require an integer operand, and support

 *              an automatic (implicit) conversion from a string operand

 *              to the final integer operand. The major restriction is that

 *              only hex strings are supported.

 *

 * -----------------------------------------------------------------------------

 *

 * Base is always 16, either with or without the 0x prefix. Decimal and

 * Octal strings are not supported, as per the ACPI specification.

 *

 * Examples (both are hex values):

 *      Add ("BA98", Arg0, Local0)

 *      Subtract ("0x12345678", Arg1, Local1)

 *

 * Conversion rules as extracted from the ACPI specification:

 *

 *  The converted integer is initialized to the value zero.

 *  The ASCII string is always interpreted as a hexadecimal constant.

 *

 *  1)  According to the ACPI specification, a "0x" prefix is not allowed.

 *      However, ACPICA allows this as an ACPI extension on general

 *      principle. (NO ERROR)

 *

 *  2)  The conversion terminates when the size of an integer is reached

 *      (32 or 64 bits). There are no numeric overflow conditions. (NO ERROR)

 *

 *  3)  The first non-hex character terminates the conversion and returns

 *      the current accumulated value of the converted integer (NO ERROR).

 *

 *  4)  Conversion of a null (zero-length) string to an integer is

 *      technically not allowed. However, ACPICA allows this as an ACPI

 *      extension. The conversion returns the value 0. (NO ERROR)

 *

 * NOTE: There are no error conditions returned by this function. At

 * the minimum, a value of zero is returned.

 *

 * Current users of this function:

 *

 *  interpreter - All runtime implicit conversions, as per ACPI specification

 *  iASL        - Data Table Compiler parser (constants and math expressions)

 *

	/*

	 * Per the ACPI specification, only hexadecimal is supported for

	 * implicit conversions, and the "0x" prefix is "not allowed".

	 * However, allow a "0x" prefix as an ACPI extension.

	/*

	 * Ignore overflow as per the ACPI specification. This is implemented by

	 * ignoring the return status from the conversion function called below.

	 * On overflow, the input string is simply truncated.

/*******************************************************************************

 *

 * FUNCTION:    acpi_ut_explicit_strtoul64

 *

 * PARAMETERS:  string                  - Null terminated input string,

 *                                        must be a valid pointer

 *

 * RETURN:      Converted integer

 *

 * DESCRIPTION: Perform a 64-bit conversion with the restrictions placed upon

 *              an "explicit conversion" by the ACPI specification. The

 *              main restriction is that only hex and decimal are supported.

 *

 * -----------------------------------------------------------------------------

 *

 * Base is either 10 (default) or 16 (with 0x prefix). Octal (base 8) strings

 * are not supported, as per the ACPI specification.

 *

 * Examples:

 *      to_integer ("1000")     Decimal

 *      to_integer ("0xABCD")   Hex

 *

 * Conversion rules as extracted from the ACPI specification:

 *

 *  1)  The input string is either a decimal or hexadecimal numeric string.

 *      A hex value must be prefixed by "0x" or it is interpreted as decimal.

 *

 *  2)  The value must not exceed the maximum of an integer value

 *      (32 or 64 bits). The ACPI specification states the behavior is

 *      "unpredictable", so ACPICA matches the behavior of the implicit

 *      conversion case. There are no numeric overflow conditions. (NO ERROR)

 *

 *  3)  Behavior on the first non-hex character is not defined by the ACPI

 *      specification (for the to_integer operator), so ACPICA matches the

 *      behavior of the implicit conversion case. It terminates the

 *      conversion and returns the current accumulated value of the converted

 *      integer. (NO ERROR)

 *

 *  4)  Conversion of a null (zero-length) string to an integer is

 *      technically not allowed. However, ACPICA allows this as an ACPI

 *      extension. The conversion returns the value 0. (NO ERROR)

 *

 * NOTE: There are no error conditions returned by this function. At the

 * minimum, a value of zero is returned.

 *

 * Current users of this function:

 *

 *  interpreter - Runtime ASL to_integer operator, as per the ACPI specification

 *

 Default is decimal */

	/*

	 * Only Hex and Decimal are supported, as per the ACPI specification.

	 * A "0x" prefix indicates hex; otherwise decimal is assumed.

	/*

	 * Ignore overflow as per the ACPI specification. This is implemented by

	 * ignoring the return status from the conversion functions called below.

	 * On overflow, the input string is simply truncated.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * X86 ACPI Utility Functions

 *

 * Copyright (C) 2017 Hans de Goede <hdegoede@redhat.com>

 *

 * Based on various non upstream patches to support the CHT Whiskey Cove PMIC:

 * Copyright (C) 2013-2015 Intel Corporation. All rights reserved.

/*

 * Some ACPI devices are hidden (status == 0x0) in recent BIOS-es because

 * some recent Windows drivers bind to one device but poke at multiple

 * devices at the same time, so the others get hidden.

 *

 * Some BIOS-es (temporarily) hide specific APCI devices to work around Windows

 * driver bugs. We use DMI matching to match known cases of this.

 *

 * We work around this by always reporting ACPI_STA_DEFAULT for these

 * devices. Note this MUST only be done for devices where this is safe.

 *

 * This forcing of devices to be present is limited to specific CPU (SoC)

 * models both to avoid potentially causing trouble on other models and

 * because some HIDs are re-used on different SoCs for completely

 * different devices.

 Optional */

	/*

	 * Bay / Cherry Trail PWM directly poked by GPU driver in win10,

	 * but Linux uses a separate PWM driver, harmless if not used.

 Lenovo Yoga Book uses PWM2 for keyboard backlight control */

	/*

	 * The INT0002 device is necessary to clear wakeup interrupt sources

	 * on Cherry Trail devices, without it we get nobody cared IRQ msgs.

	/*

	 * On the Dell Venue 11 Pro 7130 and 7139, the DSDT hides

	 * the touchscreen ACPI device until a certain time

	 * after _SB.PCI0.GFX0.LCD.LCD1._ON gets called has passed

	 * *and* _STA has been called at least 3 times since.

	/*

	 * The GPD win BIOS dated 20170221 has disabled the accelerometer, the

	 * drivers sometimes cause crashes under Windows and this is how the

	 * manufacturer has solved this :| Note that the the DMI data is less

	 * generic then it seems, a board_vendor of "AMI Corporation" is quite

	 * rare and a board_name of "Default String" also is rare.

	 *

	 * Unfortunately the GPD pocket also uses these strings and its BIOS

	 * was copy-pasted from the GPD win, so it has a disabled KIOX000A

	 * node which we should not enable, thus we also check the BIOS date.

/*

 * AMD systems from Renoir and Lucienne *require* that the NVME controller

 * is put into D3 over a Modern Standby / suspend-to-idle cycle.

 *

 * This is "typically" accomplished using the `StorageD3Enable`

 * property in the _DSD that is checked via the `acpi_storage_d3` function

 * but this property was introduced after many of these systems launched

 * and most OEM systems don't have it in their BIOS.

 *

 * The Microsoft documentation for StorageD3Enable mentioned that Windows has

 * a hardcoded allowlist for D3 support, which was used for these platforms.

 *

 * This allows quirking on Linux in a similar fashion.

 Renoir */

 Lucienne */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * apple.c - Apple ACPI quirks

 * Copyright (C) 2017 Lukas Wunner <lukas@wunner.de>

 Apple _DSM device properties GUID */

/**

 * acpi_extract_apple_properties - retrieve and convert Apple _DSM properties

 * @adev: ACPI device for which to retrieve the properties

 *

 * Invoke Apple's custom _DSM once to check the protocol version and once more

 * to retrieve the properties.  They are marshalled up in a single package as

 * alternating key/value elements, unlike _DSD which stores them as a package

 * of 2-element packages.  Convert to _DSD format and make them available under

 * the primary fwnode.

 newsize = key length + value length of each tuple */

 skip invalid properties */

 newsize += top-level package + 3 objects for each key/value tuple */

 layout: top-level package | packages | key/value tuples | strings */

 index into newprops */

 count valid properties */

 SPDX-License-Identifier: GPL-2.0

/*

 * Architecture-specific ACPI-based support for suspend-to-idle.

 *

 * Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

 * Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>

 * Author: Shyam Sundar S K <Shyam-sundar.S-k@amd.com>

 *

 * On platforms supporting the Low Power S0 Idle interface there is an ACPI

 * device object with the PNP0D80 compatible device ID (System Power Management

 * Controller) and a specific _DSM method under it.  That method, if present,

 * can be used to indicate to the platform that the OS is transitioning into a

 * low-power state in which certain types of activity are not desirable or that

 * it is leaving such a state, which allows the platform to adjust its operation

 * mode accordingly.

 Microsoft platform agnostic UUID */

 AMD */

 Device constraint entry structure */

 Constraint package structure */

 AMD Constraint package structure */

 version */

 Check if the _DSM is present and as expected. */

		/* AMD0004, AMD0005, AMDI0005:

		 * - Should use rev_id 0x0

		 * - function mask > 0x3: Should use AMD method, but has off by one bug

		 * - function mask = 0x3: Should use Microsoft method

		 * AMDI0006:

		 * - should use rev_id 0x0

		 * - function mask = 0x3: Should use Microsoft method

		 * AMDI0007:

		 * - Should use rev_id 0x2

		 * - Should only use AMD method

function evaluation failed

	/*

	 * Use suspend-to-idle by default if the default suspend mode was not

	 * set from the command line.

	/*

	 * Some Intel based LPS0 systems, like ASUS Zenbook UX430UNR/i7-8550U don't

	 * use intel-hid or intel-vbtn but require the EC GPE to be enabled while

	 * suspended for certain wakeup devices to work, so mark it as wakeup-capable.

	 *

	 * Only enable on !AMD as enabling this universally causes problems for a number

	 * of AMD based systems.

 Screen off */

 LPS0 entry */

 modern standby entry */

 Modern standby exit */

 LPS0 exit */

 Screen on */

 CONFIG_SUSPEND */

/*

 *  File Attributes for DIO Devices

 *

 *  Copyright (C) 2004 Jochen Friedrich

 *

 *  Loosely based on drivers/pci/pci-sysfs.c and drivers/zorro/zorro-sysfs.c

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License.  See the file COPYING in the main directory of this archive

 *  for more details.

 show configuration fields */

 current configuration's attributes */

/*

 *  DIO Driver Services

 *

 *  Copyright (C) 2004 Jochen Friedrich

 *

 *  Loosely based on drivers/pci/pci-driver.c and drivers/zorro/zorro-driver.c

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License.  See the file COPYING in the main directory of this archive

 *  for more details.

/**

 *  dio_match_device - Tell if a DIO device structure has a matching DIO device id structure

 *  @ids: array of DIO device id structures to search in

 *  @d: the DIO device structure to match against

 *

 *  Used by a driver to check whether a DIO device present in the

 *  system is in its list of supported devices. Returns the matching

 *  dio_device_id structure or %NULL if there is no match.

/**

 *  dio_register_driver - register a new DIO driver

 *  @drv: the driver structure to register

 *

 *  Adds the driver structure to the list of registered drivers

 *  Returns zero or a negative error value.

 initialize common driver fields */

 register with core */

/**

 *  dio_unregister_driver - unregister a DIO driver

 *  @drv: the driver structure to unregister

 *

 *  Deletes the driver structure from the list of registered DIO drivers,

 *  gives it a chance to clean up by calling its remove() function for

 *  each device it was responsible for, and marks those devices as

 *  driverless.

/**

 *  dio_bus_match - Tell if a DIO device structure has a matching DIO device id structure

 *  @dev: the DIO device structure to match against

 *  @drv: the &device_driver that points to the array of DIO device id structures to search

 *

 *  Used by the driver core to check whether a DIO device present in the

 *  system is in a driver's list of supported devices. Returns 1 if supported,

 *  and 0 if there is no match.

 SPDX-License-Identifier: GPL-2.0

/* Code to support devices on the DIO and DIO-II bus

 * Copyright (C) 05/1998 Peter Maydell <pmaydell@chiark.greenend.org.uk>

 * Copyright (C) 2004 Jochen Friedrich <jochen@scram.de>

 * 

 * This code has basically these routines at the moment:

 * int dio_find(u_int deviceid)

 *    Search the list of DIO devices and return the select code

 *    of the next unconfigured device found that matches the given device ID.

 *    Note that the deviceid parameter should be the encoded ID.

 *    This means that framebuffers should pass it as 

 *    DIO_ENCODE_ID(DIO_ID_FBUFFER,DIO_ID2_TOPCAT)

 *    (or whatever); everybody else just uses DIO_ID_FOOBAR.

 * unsigned long dio_scodetophysaddr(int scode)

 *    Return the physical address corresponding to the given select code.

 * int dio_scodetoipl(int scode)

 *    Every DIO card has a fixed interrupt priority level. This function 

 *    returns it, whatever it is.

 * const char *dio_scodetoname(int scode)

 *    Return a character string describing this board [might be "" if 

 *    not CONFIG_DIO_CONSTANTS]

 * void dio_config_board(int scode)     mark board as configured in the list

 * void dio_unconfig_board(int scode)   mark board as no longer configured

 *

 * This file is based on the way the Amiga port handles Zorro II cards, 

 * although we aren't so complicated...

 kmalloc() */

 readb() */

 DIO range */

 DIO-II range */

 not a real config option yet! */

/* We associate each numeric ID with an appropriate descriptive string

 * using a constant array of these structs.

 * FIXME: we should be able to arrange to throw away most of the strings

 * using the initdata stuff. Then we wouldn't need to worry about 

 * carrying them around...

 * I think we do this by copying them into newly kmalloc()ed memory and 

 * marking the names[] array as .initdata ?

 useful macro */

 return pointer to a constant string describing the board with given ID */

 CONFIG_DIO_CONSTANTS */

	/* Called to find a DIO device before the full bus scan has run.

	 * Only used by the console driver.

 no board present at that select code */

/* This is the function that scans the DIO space and works out what

 * hardware is actually present.

 Initialize the DIO bus */ 

 Request all resources */

 Register all devices */

 primary, secondary ID bytes */

 no board present at that select code */

 Found a board, allocate it an entry in the list */

 read the ID byte(s) and encode if necessary. */

/* Bear in mind that this is called in the very early stages of initialisation

 * in order to get the address of the serial port for the console...

 SPDX-License-Identifier: GPL-2.0-or-later

/* Low-level parallel port routines for built-in port on SGI IP32

 *

 * Author: Arnaud Giersch <arnaud.giersch@free.fr>

 *

 * Based on parport_pc.c by

 *	Phil Blundell, Tim Waugh, Jose Renau, David Campbell,

 *	Andrea Arcangeli, et al.

 *

 * Thanks to Ilya A. Volynets-Evenbakh for his help.

 *

 * Copyright (C) 2005, 2006 Arnaud Giersch.

/* Current status:

 *

 *	Basic SPP and PS2 modes are supported.

 *	Support for parallel port IRQ is present.

 *	Hardware SPP (a.k.a. compatibility), EPP, and ECP modes are

 *	supported.

 *	SPP/ECP FIFO can be driven in PIO or DMA mode.  PIO mode can work with

 *	or without interrupt support.

 *

 *	Hardware ECP mode is not fully implemented (ecp_read_data and

 *	ecp_write_addr are actually missing).

 *

 * To do:

 *

 *	Fully implement ECP mode.

 *	EPP and ECP mode need to be tested.  I currently do not own any

 *	peripheral supporting these extended mode, and cannot test them.

 *	If DMA mode works well, decide if support for PIO FIFO modes should be

 *	dropped.

 *	Use the io{read,write} family functions when they become available in

 *	the linux-mips.org tree.  Note: the MIPS specific functions readsb()

 *	and writesb() are to be translated by ioread8_rep() and iowrite8_rep()

 *	respectively.

/* The built-in parallel port on the SGI 02 workstation (a.k.a. IP32) is an

 * IEEE 1284 parallel port driven by a Texas Instrument TL16PIR552PH chip[1].

 * This chip supports SPP, bidirectional, EPP and ECP modes.  It has a 16 byte

 * FIFO buffer and supports DMA transfers.

 *

 * [1] http://focus.ti.com/docs/prod/folders/print/tl16pir552.html

 *

 * Theoretically, we could simply use the parport_pc module.  It is however

 * not so simple.  The parport_pc code assumes that the parallel port

 * registers are port-mapped.  On the O2, they are memory-mapped.

 * Furthermore, each register is replicated on 256 consecutive addresses (as

 * it is for the built-in serial ports on the same chip).

--- Some configuration defines ---------------------------------------*/

/* DEBUG_PARPORT_IP32

 *	0	disable debug

 *	1	standard level: pr_debug1 is enabled

 *	2	parport_ip32_dump_state is enabled

 *	>=3	verbose level: pr_debug is enabled

 0 (disabled) for production */

----------------------------------------------------------------------*/

/* Setup DEBUG macros.  This is done before any includes, just in case we

 * activate pr_debug() with DEBUG_PARPORT_IP32 >= 3.

 enable pr_debug() in kernel.h */

--- Global variables -------------------------------------------------*/

 Verbose probing on by default for debugging. */

 Default prefix for printk */

/*

 * These are the module parameters:

 * @features:		bit mask of features to enable/disable

 *			(all enabled by default)

 * @verbose_probing:	log chit-chat during initialization

 We do not support more than one port. */

 Timing constants for FIFO modes.  */

 milliseconds */

 microseconds */

--- I/O register definitions -----------------------------------------*/

/**

 * struct parport_ip32_regs - virtual addresses of parallel port registers

 * @data:	Data Register

 * @dsr:	Device Status Register

 * @dcr:	Device Control Register

 * @eppAddr:	EPP Address Register

 * @eppData0:	EPP Data Register 0

 * @eppData1:	EPP Data Register 1

 * @eppData2:	EPP Data Register 2

 * @eppData3:	EPP Data Register 3

 * @ecpAFifo:	ECP Address FIFO

 * @fifo:	General FIFO register.  The same address is used for:

 *		- cFifo, the Parallel Port DATA FIFO

 *		- ecpDFifo, the ECP Data FIFO

 *		- tFifo, the ECP Test FIFO

 * @cnfgA:	Configuration Register A

 * @cnfgB:	Configuration Register B

 * @ecr:	Extended Control Register

 Device Status Register */

 PARPORT_STATUS_BUSY */

 PARPORT_STATUS_ACK */

 PARPORT_STATUS_PAPEROUT */

 PARPORT_STATUS_SELECT */

 PARPORT_STATUS_ERROR */

 specific to TL16PIR552 */

 #define DSR_reserved		(1U << 1) */

 EPP timeout */

 Device Control Register */

 #define DCR_reserved		(1U << 7) | (1U <<  6) */

 direction */

 interrupt on nAck */

 PARPORT_CONTROL_SELECT */

 PARPORT_CONTROL_INIT */

 PARPORT_CONTROL_AUTOFD */

 PARPORT_CONTROL_STROBE */

 ECP Configuration Register A */

 #define CNFGA_reserved	(1U << 3) */

 ECP Configuration Register B */

 Extended Control Register */

 #define ECR_MODE_reserved	(05U << ECR_MODE_SHIFT) */

--- Private data -----------------------------------------------------*/

/**

 * enum parport_ip32_irq_mode - operation mode of interrupt handler

 * @PARPORT_IP32_IRQ_FWD:	forward interrupt to the upper parport layer

 * @PARPORT_IP32_IRQ_HERE:	interrupt is handled locally

/**

 * struct parport_ip32_private - private stuff for &struct parport

 * @regs:		register addresses

 * @dcr_cache:		cached contents of DCR

 * @dcr_writable:	bit mask of writable DCR bits

 * @pword:		number of bytes per PWord

 * @fifo_depth:		number of PWords that FIFO will hold

 * @readIntrThreshold:	minimum number of PWords we can read

 *			if we get an interrupt

 * @writeIntrThreshold:	minimum number of PWords we can write

 *			if we get an interrupt

 * @irq_mode:		operation mode of interrupt handler for this port

 * @irq_complete:	mutex used to wait for an interrupt to occur

--- Debug code -------------------------------------------------------*/

/*

 * pr_debug1 - print debug messages

 *

 * This is like pr_debug(), but is defined for %DEBUG_PARPORT_IP32 >= 1

 DEBUG_PARPORT_IP32 < 1 */

/*

 * pr_trace, pr_trace1 - trace function calls

 * @p:		pointer to &struct parport

 * @fmt:	printk format string

 * @...:	parameters for format string

 *

 * Macros used to trace function calls.  The given string is formatted after

 * function name.  pr_trace() uses pr_debug(), and pr_trace1() uses

 * pr_debug1().  __pr_trace() is the low-level macro and is not to be used

 * directly.

/*

 * __pr_probe, pr_probe - print message if @verbose_probing is true

 * @p:		pointer to &struct parport

 * @fmt:	printk format string

 * @...:	parameters for format string

 *

 * For new lines, use pr_probe().  Use __pr_probe() for continued lines.

/*

 * parport_ip32_dump_state - print register status of parport

 * @p:		pointer to &struct parport

 * @str:	string to add in message

 * @show_ecp_config:	shall we dump ECP configuration registers too?

 *

 * This function is only here for debugging purpose, and should be used with

 * care.  Reading the parallel port registers may have undesired side effects.

 * Especially if @show_ecp_config is true, the parallel port is resetted.

 * This function is only defined if %DEBUG_PARPORT_IP32 >= 2.

 DEBUG_PARPORT_IP32 < 2 */

/*

 * CHECK_EXTRA_BITS - track and log extra bits

 * @p:		pointer to &struct parport

 * @b:		byte to inspect

 * @m:		bit mask of authorized bits

 *

 * This is used to track and log extra bits that should not be there in

 * parport_ip32_write_control() and parport_ip32_frob_control().  It is only

 * defined if %DEBUG_PARPORT_IP32 >= 1.

 DEBUG_PARPORT_IP32 < 1 */

--- IP32 parallel port DMA operations --------------------------------*/

/**

 * struct parport_ip32_dma_data - private data needed for DMA operation

 * @dir:	DMA direction (from or to device)

 * @buf:	buffer physical address

 * @len:	buffer length

 * @next:	address of next bytes to DMA transfer

 * @left:	number of bytes remaining

 * @ctx:	next context to write (0: context_a; 1: context_b)

 * @irq_on:	are the DMA IRQs currently enabled?

 * @lock:	spinlock to protect access to the structure

/**

 * parport_ip32_dma_setup_context - setup next DMA context

 * @limit:	maximum data size for the context

 *

 * The alignment constraints must be verified in caller function, and the

 * parameter @limit must be set accordingly.

		/* Note: ctxreg is "volatile" here only because

		 * mace->perif.ctrl.parport.context_a and context_b are

	/* If there is nothing more to send, disable IRQs to avoid to

	 * face an IRQ storm which can lock the machine.  Disable them

/**

 * parport_ip32_dma_interrupt - DMA interrupt handler

 * @irq:	interrupt number

 * @dev_id:	unused

/**

 * parport_ip32_dma_start - begins a DMA transfer

 * @p:		partport to work on

 * @dir:	DMA direction: DMA_TO_DEVICE or DMA_FROM_DEVICE

 * @addr:	pointer to data buffer

 * @count:	buffer size

 *

 * Calls to parport_ip32_dma_start() and parport_ip32_dma_stop() must be

 * correctly balanced.

	/* FIXME - add support for DMA_FROM_DEVICE.  In this case, buffer must

 Reset DMA controller */

 DMA IRQs should normally be enabled */

 Prepare DMA pointers */

 Setup DMA direction and first two contexts */

 Single transfer should not cross a 4K page boundary */

 Real start of DMA transfer */

/**

 * parport_ip32_dma_stop - ends a running DMA transfer

 * @p:		partport to work on

 *

 * Calls to parport_ip32_dma_start() and parport_ip32_dma_stop() must be

 * correctly balanced.

 {[0] = res_a, [1] = res_b} */

 Disable IRQs */

	/* Force IRQ synchronization, even if the IRQs were disabled

 Stop DMA transfer */

 Adjust residue (parport_ip32_dma.left) */

 Reset DMA controller, and re-enable IRQs */

/**

 * parport_ip32_dma_get_residue - get residue from last DMA transfer

 *

 * Returns the number of bytes remaining from last DMA transfer.

/**

 * parport_ip32_dma_register - initialize DMA engine

 *

 * Returns zero for success.

 Reset DMA controller */

 Request IRQs */

 FIXME - what is this IRQ for? */

/**

 * parport_ip32_dma_unregister - release and free resources for DMA engine

--- Interrupt handlers and associates --------------------------------*/

/**

 * parport_ip32_wakeup - wakes up code waiting for an interrupt

 * @p:		pointer to &struct parport

/**

 * parport_ip32_interrupt - interrupt handler

 * @irq:	interrupt number

 * @dev_id:	pointer to &struct parport

 *

 * Caught interrupts are forwarded to the upper parport layer if IRQ_mode is

 * %PARPORT_IP32_IRQ_FWD.

--- Some utility function to manipulate ECR register -----------------*/

/**

 * parport_ip32_read_econtrol - read contents of the ECR register

 * @p:		pointer to &struct parport

/**

 * parport_ip32_write_econtrol - write new contents to the ECR register

 * @p:		pointer to &struct parport

 * @c:		new value to write

/**

 * parport_ip32_frob_econtrol - change bits from the ECR register

 * @p:		pointer to &struct parport

 * @mask:	bit mask of bits to change

 * @val:	new value for changed bits

 *

 * Read from the ECR, mask out the bits in @mask, exclusive-or with the bits

 * in @val, and write the result to the ECR.

/**

 * parport_ip32_set_mode - change mode of ECP port

 * @p:		pointer to &struct parport

 * @mode:	new mode to write in ECR

 *

 * ECR is reset in a sane state (interrupts and DMA disabled), and placed in

 * mode @mode.  Go through PS2 mode if needed.

 We have to go through PS2 mode */

--- Basic functions needed for parport -------------------------------*/

/**

 * parport_ip32_read_data - return current contents of the DATA register

 * @p:		pointer to &struct parport

/**

 * parport_ip32_write_data - set new contents for the DATA register

 * @p:		pointer to &struct parport

 * @d:		new value to write

/**

 * parport_ip32_read_status - return current contents of the DSR register

 * @p:		pointer to &struct parport

/**

 * __parport_ip32_read_control - return cached contents of the DCR register

 * @p:		pointer to &struct parport

 use soft copy */

/**

 * __parport_ip32_write_control - set new contents for the DCR register

 * @p:		pointer to &struct parport

 * @c:		new value to write

 only writable bits */

 update soft copy */

/**

 * __parport_ip32_frob_control - change bits from the DCR register

 * @p:		pointer to &struct parport

 * @mask:	bit mask of bits to change

 * @val:	new value for changed bits

 *

 * This is equivalent to read from the DCR, mask out the bits in @mask,

 * exclusive-or with the bits in @val, and write the result to the DCR.

 * Actually, the cached contents of the DCR is used.

/**

 * parport_ip32_read_control - return cached contents of the DCR register

 * @p:		pointer to &struct parport

 *

 * The return value is masked so as to only return the value of %DCR_STROBE,

 * %DCR_AUTOFD, %DCR_nINIT, and %DCR_SELECT.

/**

 * parport_ip32_write_control - set new contents for the DCR register

 * @p:		pointer to &struct parport

 * @c:		new value to write

 *

 * The value is masked so as to only change the value of %DCR_STROBE,

 * %DCR_AUTOFD, %DCR_nINIT, and %DCR_SELECT.

/**

 * parport_ip32_frob_control - change bits from the DCR register

 * @p:		pointer to &struct parport

 * @mask:	bit mask of bits to change

 * @val:	new value for changed bits

 *

 * This differs from __parport_ip32_frob_control() in that it only allows to

 * change the value of %DCR_STROBE, %DCR_AUTOFD, %DCR_nINIT, and %DCR_SELECT.

/**

 * parport_ip32_disable_irq - disable interrupts on the rising edge of nACK

 * @p:		pointer to &struct parport

/**

 * parport_ip32_enable_irq - enable interrupts on the rising edge of nACK

 * @p:		pointer to &struct parport

/**

 * parport_ip32_data_forward - enable host-to-peripheral communications

 * @p:		pointer to &struct parport

 *

 * Enable the data line drivers, for 8-bit host-to-peripheral communications.

/**

 * parport_ip32_data_reverse - enable peripheral-to-host communications

 * @p:		pointer to &struct parport

 *

 * Place the data bus in a high impedance state, if @p->modes has the

 * PARPORT_MODE_TRISTATE bit set.

/**

 * parport_ip32_init_state - for core parport code

 * @dev:	pointer to &struct pardevice

 * @s:		pointer to &struct parport_state to initialize

/**

 * parport_ip32_save_state - for core parport code

 * @p:		pointer to &struct parport

 * @s:		pointer to &struct parport_state to save state to

/**

 * parport_ip32_restore_state - for core parport code

 * @p:		pointer to &struct parport

 * @s:		pointer to &struct parport_state to restore state from

--- EPP mode functions -----------------------------------------------*/

/**

 * parport_ip32_clear_epp_timeout - clear Timeout bit in EPP mode

 * @p:		pointer to &struct parport

 *

 * Returns 1 if the Timeout bit is clear, and 0 otherwise.

 To clear timeout some chips require double read */

 Some reset by writing 1 */

 Others by writing 0 */

/**

 * parport_ip32_epp_read - generic EPP read function

 * @eppreg:	I/O register to read from

 * @p:		pointer to &struct parport

 * @buf:	buffer to store read data

 * @len:	length of buffer @buf

 * @flags:	may be PARPORT_EPP_FAST

/**

 * parport_ip32_epp_write - generic EPP write function

 * @eppreg:	I/O register to write to

 * @p:		pointer to &struct parport

 * @buf:	buffer of data to write

 * @len:	length of buffer @buf

 * @flags:	may be PARPORT_EPP_FAST

/**

 * parport_ip32_epp_read_data - read a block of data in EPP mode

 * @p:		pointer to &struct parport

 * @buf:	buffer to store read data

 * @len:	length of buffer @buf

 * @flags:	may be PARPORT_EPP_FAST

/**

 * parport_ip32_epp_write_data - write a block of data in EPP mode

 * @p:		pointer to &struct parport

 * @buf:	buffer of data to write

 * @len:	length of buffer @buf

 * @flags:	may be PARPORT_EPP_FAST

/**

 * parport_ip32_epp_read_addr - read a block of addresses in EPP mode

 * @p:		pointer to &struct parport

 * @buf:	buffer to store read data

 * @len:	length of buffer @buf

 * @flags:	may be PARPORT_EPP_FAST

/**

 * parport_ip32_epp_write_addr - write a block of addresses in EPP mode

 * @p:		pointer to &struct parport

 * @buf:	buffer of data to write

 * @len:	length of buffer @buf

 * @flags:	may be PARPORT_EPP_FAST

--- ECP mode functions (FIFO) ----------------------------------------*/

/**

 * parport_ip32_fifo_wait_break - check if the waiting function should return

 * @p:		pointer to &struct parport

 * @expire:	timeout expiring date, in jiffies

 *

 * parport_ip32_fifo_wait_break() checks if the waiting function should return

 * immediately or not.  The break conditions are:

 *	- expired timeout;

 *	- a pending signal;

 *	- nFault asserted low.

 * This function also calls cond_resched().

/**

 * parport_ip32_fwp_wait_polling - wait for FIFO to empty (polling)

 * @p:		pointer to &struct parport

 *

 * Returns the number of bytes that can safely be written in the FIFO.  A

 * return value of zero means that the calling function should terminate as

 * fast as possible.

		/* Check FIFO state.  We do nothing when the FIFO is nor full,

		 * nor empty.  It appears that the FIFO full bit is not always

		 * reliable, the FIFO state is sometimes wrongly reported, and

 FIFO is empty, fill it up */

 Wait a moment... */

 while (1) */

/**

 * parport_ip32_fwp_wait_interrupt - wait for FIFO to empty (interrupt-driven)

 * @p:		pointer to &struct parport

 *

 * Returns the number of bytes that can safely be written in the FIFO.  A

 * return value of zero means that the calling function should terminate as

 * fast as possible.

 Initialize mutex used to take interrupts into account */

 Enable serviceIntr */

		/* Enabling serviceIntr while the FIFO is empty does not

		 * always generate an interrupt, so check for emptiness

			/* FIFO is not empty: wait for an interrupt or a

 Disable serviceIntr */

 Check FIFO state */

 FIFO is empty, fill it up */

			/* FIFO is not empty, but we know that can safely push

		/* FIFO is not empty, and we did not get any interrupt.

		 * Either it's time to check for nFault, or a signal is

		 * pending.  This is verified in

 while (1) */

/**

 * parport_ip32_fifo_write_block_pio - write a block of data (PIO mode)

 * @p:		pointer to &struct parport

 * @buf:	buffer of data to write

 * @len:	length of buffer @buf

 *

 * Uses PIO to write the contents of the buffer @buf into the parallel port

 * FIFO.  Returns the number of bytes that were actually written.  It can work

 * with or without the help of interrupts.  The parallel port must be

 * correctly initialized before calling parport_ip32_fifo_write_block_pio().

 Transmission should be stopped */

/**

 * parport_ip32_fifo_write_block_dma - write a block of data (DMA mode)

 * @p:		pointer to &struct parport

 * @buf:	buffer of data to write

 * @len:	length of buffer @buf

 *

 * Uses DMA to write the contents of the buffer @buf into the parallel port

 * FIFO.  Returns the number of bytes that were actually written.  The

 * parallel port must be correctly initialized before calling

 * parport_ip32_fifo_write_block_dma().

 DMA transfer just finished */

/**

 * parport_ip32_fifo_write_block - write a block of data

 * @p:		pointer to &struct parport

 * @buf:	buffer of data to write

 * @len:	length of buffer @buf

 *

 * Uses PIO or DMA to write the contents of the buffer @buf into the parallel

 * p FIFO.  Returns the number of bytes that were actually written.

		/* FIXME - Maybe some threshold value should be set for @len

/**

 * parport_ip32_drain_fifo - wait for FIFO to empty

 * @p:		pointer to &struct parport

 * @timeout:	timeout, in jiffies

 *

 * This function waits for FIFO to empty.  It returns 1 when FIFO is empty, or

 * 0 if the timeout @timeout is reached before, or if a signal is pending.

 Busy wait for approx. 200us */

	/* Poll slowly.  Polling interval starts with 1 millisecond, and is

 msecs */

/**

 * parport_ip32_get_fifo_residue - reset FIFO

 * @p:		pointer to &struct parport

 * @mode:	current operation mode (ECR_MODE_PPF or ECR_MODE_ECP)

 *

 * This function resets FIFO, and returns the number of bytes remaining in it.

	/* FIXME - We are missing one byte if the printer is off-line.  I

	 * don't know how to detect this.  It looks that the full bit is not

	 * always reliable.  For the moment, the problem is avoided in most

	 * cases by testing for BUSY in parport_ip32_compat_write_data().

		/* Stop all transfers.

		 *

		 * Microsoft's document instructs to drive DCR_STROBE to 0,

		 * but it doesn't work (at least in Compatibility mode, not

		 * tested in ECP mode).  Switching directly to Test mode (as

		 * in parport_pc) is not an option: it does confuse the port,

		 * ECP service interrupts are no more working after that.  A

		 * hard reset is then needed to revert to a sane state.

		 *

		 * Let's hope that the FIFO is really stuck and that the

		 * peripheral doesn't wake up now.

 Fill up FIFO */

 Now reset the FIFO */

 Host recovery for ECP mode */

 Adjust residue if needed */

	/* Don't care about partial PWords since we do not support

 Back to forward PS2 mode. */

/**

 * parport_ip32_compat_write_data - write a block of data in SPP mode

 * @p:		pointer to &struct parport

 * @buf:	buffer of data to write

 * @len:	length of buffer @buf

 * @flags:	ignored

	/* Special case: a timeout of zero means we cannot call schedule().

 Reset FIFO, go in forward mode, and disable ackIntEn */

 Wait for peripheral to become ready */

 Avoid to flood the logs */

 Wait FIFO to empty.  Timeout is proportional to FIFO_depth.  */

 Check for a potential residue */

 Then, wait for BUSY to get low. */

 Reset FIFO */

/*

 * FIXME - Insert here parport_ip32_ecp_read_data().

/**

 * parport_ip32_ecp_write_data - write a block of data in ECP mode

 * @p:		pointer to &struct parport

 * @buf:	buffer of data to write

 * @len:	length of buffer @buf

 * @flags:	ignored

	/* Special case: a timeout of zero means we cannot call schedule().

 Negotiate to forward mode if necessary. */

 Event 47: Set nInit high. */

 Event 49: PError goes high. */

 Reset FIFO, go in forward mode, and disable ackIntEn */

 Wait for peripheral to become ready */

 Avoid to flood the logs */

 Wait FIFO to empty.  Timeout is proportional to FIFO_depth.  */

 Check for a potential residue */

 Then, wait for BUSY to get low. */

 Reset FIFO */

/*

 * FIXME - Insert here parport_ip32_ecp_write_addr().

--- Default parport operations ---------------------------------------*/

--- Device detection -------------------------------------------------*/

/**

 * parport_ip32_ecp_supported - check for an ECP port

 * @p:		pointer to the &parport structure

 *

 * Returns 1 if an ECP port is found, and 0 otherwise.  This function actually

 * checks if an Extended Control Register seems to be present.  On successful

 * return, the port is placed in SPP mode.

/**

 * parport_ip32_fifo_supported - check for FIFO parameters

 * @p:		pointer to the &parport structure

 *

 * Check for FIFO parameters of an Extended Capabilities Port.  Returns 1 on

 * success, and 0 otherwise.  Adjust FIFO parameters in the parport structure.

 * On return, the port is placed in SPP mode.

 Configuration mode */

 Find out PWord size */

 Check for compression support */

 Reset FIFO and go in test mode (no interrupt, no DMA) */

 FIFO must be empty now */

 Find out FIFO depth. */

 FIFO full */

 Enable interrupts */

	/* Find out writeIntrThreshold: number of PWords we know we can write

 writeIntrThreshold reached */

 FIFO empty before the last byte? */

 FIFO must be empty now */

 Reset FIFO */

 Set reverse direction (must be in PS2 mode) */

 Test FIFO, no interrupt, no DMA */

 Enable interrupts */

	/* Find out readIntrThreshold: number of PWords we can read if we get

 readIntrThreshold reached */

 Reset ECR */

--- Initialization code ----------------------------------------------*/

/**

 * parport_ip32_make_isa_registers - compute (ISA) register addresses

 * @regs:	pointer to &struct parport_ip32_regs to fill

 * @base:	base address of standard and EPP registers

 * @base_hi:	base address of ECP registers

 * @regshift:	how much to shift register offset by

 *

 * Compute register addresses, according to the ISA standard.  The addresses

 * of the standard and EPP registers are computed from address @base.  The

 * addresses of the ECP registers are computed from address @base_hi.

/**

 * parport_ip32_probe_port - probe and register IP32 built-in parallel port

 *

 * Returns the new allocated &parport structure.  On error, an error code is

 * encoded in return value with the ERR_PTR function.

 regshift */);

 Probe port. */

	/* We found what looks like a working ECR register.  Simply assume

 Disable hardware modes depending on a working FIFO. */

 DMA is not needed if FIFO is not supported.  */

 Request IRQ */

 DMA cannot work without interrupts. */

 Allocate DMA resources */

 arbitrary value != PARPORT_DMA_NONE */

 Enable compatibility FIFO mode */

 Set up access functions to use EPP hardware. */

 Enable ECP FIFO mode */

 FIXME - not implemented */

		p->ops->ecp_read_data  = parport_ip32_ecp_read_data; */

		p->ops->ecp_write_addr = parport_ip32_ecp_write_addr; */

 Initialize the port with sensible values */

 Print out what we found */

/**

 * parport_ip32_unregister_port - unregister a parallel port

 * @p:		pointer to the &struct parport

 *

 * Unregisters a parallel port and free previously allocated resources

 * (memory, IRQ, ...).

/**

 * parport_ip32_init - module initialization function

/**

 * parport_ip32_exit - module termination function

--- Module stuff -----------------------------------------------------*/

 update in parport_ip32_init() too */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *      Low-level parallel-support for PC-style hardware integrated in the 

 *	LASI-Controller (on GSC-Bus) for HP-PARISC Workstations

 *

 *	(C) 1999-2001 by Helge Deller <deller@gmx.de>

 * 

 * based on parport_pc.c by 

 * 	    Grant Guenther <grant@torque.net>

 * 	    Phil Blundell <philb@gnu.org>

 *          Tim Waugh <tim@cyberelk.demon.co.uk>

 *	    Jose Renau <renau@acm.org>

 *          David Campbell

 *          Andrea Arcangeli

 undef for production */

/*

 * Clear TIMEOUT BIT in EPP MODE

 *

 * This is also used in SPP detection.

 To clear timeout some chips require double read */

 Some reset by writing 1 */

 Others by writing 0 */

/*

 * Access functions.

 *

 * Most of these aren't static because they may be used by the

 * parport_xxx_yyy macros.  extern __inline__ versions of several

 * of these are in parport_gsc.h.

 --- Mode detection ------------------------------------- */

/*

 * Checks for port existence, all ports support SPP MODE

	/*

	 * first clear an eventually pending EPP timeout 

	 * I (sailer@ife.ee.ethz.ch) have an SMSC chipset

	 * that does not even respond to SPP cycles if an EPP

	 * timeout is pending

 Do a simple read-write test to make sure the port exists. */

	/* Is there a control register that we can read from?  Some

	 * ports don't allow reads, so read_control just returns a

	 * software copy. Some ports _do_ allow reads, so bypass the

	 * software copy here.  In addition, some bits aren't

	/* Try the data register.  The data lines aren't tri-stated at

/* Detect PS/2 support.

 *

 * Bit 5 (0x20) sets the PS/2 data direction; setting this high

 * allows us to read data from the data lines.  In theory we would get back

 * 0xff but any peripheral attached to the port may drag some or all of the

 * lines down to zero.  So if we get back anything that isn't the contents

 * of the data register we deem PS/2 support to be present. 

 *

 * Some SPP ports have "half PS/2" ability - you can't turn off the line

 * drivers, but an external peripheral with sufficiently beefy drivers of

 * its own can overpower them and assert its own levels onto the bus, from

 * where they can then be read back as normal.  Ports with this property

 * and the right type of device attached are likely to fail the SPP test,

 * (as they will appear to have stuck bits) and so the fact that they might

 * be misdetected here is rather academic. 

 try to tri-state the buffer */

 cancel input mode */

 --- Initialisation code -------------------------------- */

 No port. */

	if (p->dma == PARPORT_DMA_AUTO) /* To use DMA, giving the irq

		printmode(ECP);

		printmode(DMA);

 Done probing.  Now put the port into a sensible start-up state. */

	/* Now that we've told the sharing engine about the port, and

	   found out its characteristics, let the high-level drivers

	/* some older machines with ASP-chip don't support

	 * the enhanced parport modes.

 Initialize bidirectional-mode (0x10) & data-tranfer-mode #1 (0x20) */

 PARPORT_IRQ_NONE */ PARPORT_DMA_NONE, dev);

 hope no-one cached it */

 SPDX-License-Identifier: GPL-2.0-only

/* parport_sunbpp.c: Parallel-port routines for SBUS

 * 

 * Author: Derrick J. Brashear <shadow@dementia.org>

 *

 * based on work by:

 *          Phil Blundell <philb@gnu.org>

 *          Tim Waugh <tim@cyberelk.demon.co.uk>

 *	    Jose Renau <renau@acm.org>

 *          David Campbell <campbell@tirian.che.curtin.edu.au>

 *          Grant Guenther <grant@torque.net>

 *          Eddie C. Dost <ecd@skynet.be>

 *          Stephen Williams (steve@icarus.com)

 *          Gus Baldauf (gbaldauf@ix.netcom.com)

 *          Peter Zaitcev

 *          Tom Dyas

 *

 * Updated to new SBUS device framework: David S. Miller <davem@davemloft.net>

 * 

 OpenProm Library */

 BPP uses LSI 64854 for DMA */

/*

 * IEEE-1284 implementation for parport.

 *

 * Authors: Phil Blundell <philb@gnu.org>

 *          Carsten Gross <carsten@sol.wohnheim.uni-ulm.de>

 *	    Jose Renau <renau@acm.org>

 *          Tim Waugh <tim@cyberelk.demon.co.uk> (largely rewritten)

 *

 * This file is responsible for IEEE 1284 negotiation, and for handing

 * read/write requests to low-level drivers.

 *

 * Any part of this program may be used in documents licensed under

 * the GNU Free Documentation License, Version 1.1 or any later version

 * published by the Free Software Foundation.

 *

 * Various hacks, Fred Barnes <frmb2@ukc.ac.uk>, 04/2000

 undef me for production */

 Don't want a garbled console */

/* Make parport_wait_peripheral wake up.

/**

 *	parport_wait_event - wait for an event on a parallel port

 *	@port: port to wait on

 *	@timeout: time to wait (in jiffies)

 *

 *	This function waits for up to @timeout jiffies for an

 *	interrupt to occur on a parallel port.  If the port timeout is

 *	set to zero, it returns immediately.

 *

 *	If an interrupt occurs before the timeout period elapses, this

 *	function returns zero immediately.  If it times out, it returns

 *	one.  An error code less than zero indicates an error (most

 *	likely a pending signal), and the calling code should finish

 *	what it's doing as soon as it can.

		/* Zero timeout is special, and we can't down() the

 Timed out. */

/**

 *	parport_poll_peripheral - poll status lines

 *	@port: port to watch

 *	@mask: status lines to watch

 *	@result: desired values of chosen status lines

 *	@usec: timeout

 *

 *	This function busy-waits until the masked status lines have

 *	the desired values, or until the timeout period elapses.  The

 *	@mask and @result parameters are bitmasks, with the bits

 *	defined by the constants in parport.h: %PARPORT_STATUS_BUSY,

 *	and so on.

 *

 *	This function does not call schedule(); instead it busy-waits

 *	using udelay().  It currently has a resolution of 5usec.

 *

 *	If the status lines take on the desired values before the

 *	timeout period elapses, parport_poll_peripheral() returns zero

 *	immediately.  A return value greater than zero indicates

 *	a timeout.  An error code (less than zero) indicates an error,

 *	most likely a signal that arrived, and the caller should

 *	finish what it is doing as soon as possible.

 Zero return code is success, >0 is timeout. */

/**

 *	parport_wait_peripheral - wait for status lines to change in 35ms

 *	@port: port to watch

 *	@mask: status lines to watch

 *	@result: desired values of chosen status lines

 *

 *	This function waits until the masked status lines have the

 *	desired values, or until 35ms have elapsed (see IEEE 1284-1994

 *	page 24 to 25 for why this value in particular is hardcoded).

 *	The @mask and @result parameters are bitmasks, with the bits

 *	defined by the constants in parport.h: %PARPORT_STATUS_BUSY,

 *	and so on.

 *

 *	The port is polled quickly to start off with, in anticipation

 *	of a fast response from the peripheral.  This fast polling

 *	time is configurable (using /proc), and defaults to 500usec.

 *	If the timeout for this port (see parport_set_timeout()) is

 *	zero, the fast polling time is 35ms, and this function does

 *	not call schedule().

 *

 *	If the timeout for this port is non-zero, after the fast

 *	polling fails it uses parport_wait_event() to wait for up to

 *	10ms, waking up if an interrupt occurs.

 usecs of fast polling */

		/* A zero timeout is "special": busy wait for the

	/* Fast polling.

	 *

	 * This should be adjustable.

	 * How about making a note (in the device structure) of how long

	 * it takes, so we know for next time?

		/* We may be in an interrupt handler, so we can't poll

 40ms of slow polling. */

		/* Wait for 10ms (or until an interrupt occurs if

			/* parport_wait_event didn't time out, but the

			 * peripheral wasn't actually ready either.

 Terminate a negotiated mode. */

 EPP terminates differently. */

 Terminate from EPP mode. */

 Event 68: Set nInit low */

 Event 69: Set nInit high, nSelectIn low */

 In ECP we can only terminate from fwd idle phase. */

 Event 47: Set nInit high */

 Event 49: PError goes high */

 Terminate from all other modes. */

 Event 22: Set nSelectIn low, nAutoFd high */

 Event 24: nAck goes low */

 Event 25: Set nAutoFd low */

 Event 27: nAck goes high */

 Event 29: Set nAutoFd high */

 IEEE1284 support */

/**

 *	parport_negotiate - negotiate an IEEE 1284 mode

 *	@port: port to use

 *	@mode: mode to negotiate to

 *

 *	Use this to negotiate to a particular IEEE 1284 transfer mode.

 *	The @mode parameter should be one of the constants in

 *	parport.h starting %IEEE1284_MODE_xxx.

 *

 *	The return value is 0 if the peripheral has accepted the

 *	negotiation to the mode specified, -1 if the peripheral is not

 *	IEEE 1284 compliant (or not present), or 1 if the peripheral

 *	has rejected the negotiation.

 Is there anything to do? */

 Is the difference just an address-or-not bit? */

 Go to compatibility forward idle mode */

 Compatibility mode: no negotiation. */

 FIXME (implement BECP) */

 request extensibility link */

 Start off with nStrobe and nAutoFd high, and nSelectIn low */

 Event 0: Set data */

 Shouldn't need to wait this long. */

 Event 1: Set nSelectIn high, nAutoFd low */

 Event 2: PError, Select, nFault go high, nAck goes low */

 Timeout */

 Not IEEE1284 compliant */

 Event 3: Set nStrobe low */

 Event 4: Set nStrobe and nAutoFd high */

 Event 6: nAck goes high */

 This shouldn't really happen with a compliant device. */

 xflag should be high for all modes other than nibble (0). */

 Mode not supported. */

 More to do if we've requested extensibility link. */

 Event 51: Set nStrobe low */

 Event 52: nAck goes low */

 This peripheral is _very_ slow. */

 Event 53: Set nStrobe high */

 Event 55: nAck goes high */

			/* This shouldn't really happen with a compliant

 Event 54: Peripheral sets XFlag to reflect support */

 xflag should be high. */

 Extended mode not supported. */

 Any further setup is left to the caller. */

 Mode is supported */

 But ECP is special */

 Event 30: Set nAutoFd low */

 Event 31: PError goes high. */

 IEEE1284 support */

/* Acknowledge that the peripheral has data available.

 * Events 18-20, in order to get from Reverse Idle phase

 * to Host Busy Data Available.

 * This will most likely be called from an interrupt.

 * Returns zero if data was available.

 Event 18 didn't happen. */

 Event 20: nAutoFd goes high. */

 IEEE1284 support */

 Handle an interrupt. */

		/* An interrupt in this phase means that data

 IEEE1284 support */

/**

 *	parport_write - write a block of data to a parallel port

 *	@port: port to write to

 *	@buffer: data buffer (in kernel space)

 *	@len: number of bytes of data to transfer

 *

 *	This will write up to @len bytes of @buffer to the port

 *	specified, using the IEEE 1284 transfer mode most recently

 *	negotiated to (using parport_negotiate()), as long as that

 *	mode supports forward transfers (host to peripheral).

 *

 *	It is the caller's responsibility to ensure that the first

 *	@len bytes of @buffer are valid.

 *

 *	This function returns the number of bytes transferred (if zero

 *	or positive), or else an error code.

 Ignore the device-ID-request bit and the address bit. */

 Use the mode we're in. */

		/* The caller has specified that it must be emulated,

 IEEE1284 support */

/**

 *	parport_read - read a block of data from a parallel port

 *	@port: port to read from

 *	@buffer: data buffer (in kernel space)

 *	@len: number of bytes of data to transfer

 *

 *	This will read up to @len bytes of @buffer to the port

 *	specified, using the IEEE 1284 transfer mode most recently

 *	negotiated to (using parport_negotiate()), as long as that

 *	mode supports reverse transfers (peripheral to host).

 *

 *	It is the caller's responsibility to ensure that the first

 *	@len bytes of @buffer are available to write to.

 *

 *	This function returns the number of bytes transferred (if zero

 *	or positive), or else an error code.

 Ignore the device-ID-request bit and the address bit. */

 Use the mode we're in. */

		/* if we can tri-state use BYTE mode instead of NIBBLE mode,

		 * if that fails, revert to NIBBLE mode -- ought to store somewhere

		 * the device's ability to do BYTE mode reverse transfers, so we don't

		 * end up needlessly calling negotiate(BYTE) repeately..  (fb)

 got into BYTE mode OK */

 to NIBBLE */

 IEEE1284 support */

/**

 *	parport_set_timeout - set the inactivity timeout for a device

 *	@dev: device on a port

 *	@inactivity: inactivity timeout (in jiffies)

 *

 *	This sets the inactivity timeout for a particular device on a

 *	port.  This affects functions like parport_wait_peripheral().

 *	The special value 0 means not to call schedule() while dealing

 *	with this device.

 *

 *	The return value is the previous inactivity timeout.

 *

 *	Any callers of parport_wait_event() for this device are woken

 *	up.

 Exported symbols for modules. */

/*======================================================================



    A driver for PCMCIA parallel port adapters



    (specifically, for the Quatech SPP-100 EPP card: other cards will

    probably require driver tweaks)

    

    parport_cs.c 1.29 2002/10/11 06:57:41



    The contents of this file are subject to the Mozilla Public

    License Version 1.1 (the "License"); you may not use this file

    except in compliance with the License. You may obtain a copy of

    the License at http://www.mozilla.org/MPL/



    Software distributed under the License is distributed on an "AS

    IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or

    implied. See the License for the specific language governing

    rights and limitations under the License.



    The initial developer of the original code is David A. Hinds

    <dahinds@users.sourceforge.net>.  Portions created by David A. Hinds

    are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.



    Alternatively, the contents of this file may be used under the

    terms of the GNU General Public License version 2 (the "GPL"), in

    which case the provisions of the GPL are applicable instead of the

    above.  If you wish to allow the use of your version of this file

    only under the terms of the GPL and not to allow others to use

    your version of this file under the MPL, indicate your decision

    by deleting the provisions above and replace them with the notice

    and other provisions required by the GPL.  If you do not delete

    the provisions above, a recipient may use your version of this

    file under either the MPL or the GPL.

    

====================================================================*/

 Module parameters */

====================================================================*/

 Create new parport device */

 parport_attach */

 parport_detach */

 parport_config */

 parport_cs_release */

/*

 * Parallel-port resource manager code.

 *

 * Authors: David Campbell <campbell@tirian.che.curtin.edu.au>

 *          Tim Waugh <tim@cyberelk.demon.co.uk>

 *          Jose Renau <renau@acm.org>

 *          Philip Blundell <philb@gnu.org>

 *	    Andrea Arcangeli

 *

 * based on work by Grant Guenther <grant@torque.net>

 *          and Philip Blundell

 *

 * Any part of this program may be used in documents licensed under

 * the GNU Free Documentation License, Version 1.1 or any later version

 * published by the Free Software Foundation.

 undef for production */

 list of all allocated ports, sorted by ->number */

 What you can do to a port that's gone away.. */

 data */

 control */

 status */

 enable_irq */

 disable_irq */

 data_forward */

 data_reverse */

 init_state */

 epp */

 ecp */

 compat */

 nibble */

 byte */

 if driver has not defined a custom probe */

 if driver defined its own probe */

/*

 * iterates through all the drivers registered with the bus and sends the port

 * details to the match_port callback of the driver, so that the driver can

 * know about the new port that just registered with the bus and decide if it

 * wants to use this new port.

 Call attach(port) for each registered driver. */

 caller has exclusive registration_lock */

	/*

	 * call the driver_check function of the drivers registered in

	 * new device model

 Call detach(port) for each registered driver. */

 caller has exclusive registration_lock */

	/*

	 * call the detach function of the drivers registered in

	 * new device model

 Ask kmod for some lowlevel drivers. */

	/*

	 * There is no actual module called this: you should set

	 * up an alias for modutils.

/*

 * iterates through all the devices connected to the bus and sends the device

 * details to the match_port callback of the driver, so that the driver can

 * know what are all the ports that are connected to the bus and choose the

 * port to which it wants to register its device.

 only send ports, do not send other devices connected to bus */

/*

 * Iterates through all the devices connected to the bus and return 1

 * if the device is a parallel port.

/**

 *	__parport_register_driver - register a parallel port device driver

 *	@drv: structure describing the driver

 *	@owner: owner module of drv

 *	@mod_name: module name string

 *

 *	This can be called by a parallel port device driver in order

 *	to receive notifications about ports being found in the

 *	system, as well as ports no longer available.

 *

 *	If devmodel is true then the new device model is used

 *	for registration.

 *

 *	The @drv structure is allocated by the caller and must not be

 *	deallocated until after calling parport_unregister_driver().

 *

 *	If using the non device model:

 *	The driver's attach() function may block.  The port that

 *	attach() is given will be valid for the duration of the

 *	callback, but if the driver wants to take a copy of the

 *	pointer it must call parport_get_port() to do so.  Calling

 *	parport_register_device() on that port will do this for you.

 *

 *	The driver's detach() function may block.  The port that

 *	detach() is given will be valid for the duration of the

 *	callback, but if the driver wants to take a copy of the

 *	pointer it must call parport_get_port() to do so.

 *

 *

 *	Returns 0 on success. The non device model will always succeeds.

 *	but the new device model can fail and will return the error code.

 using device model */

 initialize common driver fields */

	/*

	 * check if bus has any parallel port registered, if

	 * none is found then load the lowlevel driver.

/**

 *	parport_unregister_driver - deregister a parallel port device driver

 *	@drv: structure describing the driver that was given to

 *	      parport_register_driver()

 *

 *	This should be called by a parallel port device driver that

 *	has registered itself using parport_register_driver() when it

 *	is about to be unloaded.

 *

 *	When it returns, the driver's attach() routine will no longer

 *	be called, and for each port that attach() was called for, the

 *	detach() routine will have been called.

 *

 *	All the driver's attach() and detach() calls are guaranteed to have

 *	finished by the time this function returns.

/**

 *	parport_get_port - increment a port's reference count

 *	@port: the port

 *

 *	This ensures that a struct parport pointer remains valid

 *	until the matching parport_put_port() call.

/**

 *	parport_put_port - decrement a port's reference count

 *	@port: the port

 *

 *	This should be called once for each call to parport_get_port(),

 *	once the port is no longer needed. When the reference count reaches

 *	zero (port is no longer used), free_port is called.

/**

 *	parport_register_port - register a parallel port

 *	@base: base I/O address

 *	@irq: IRQ line

 *	@dma: DMA channel

 *	@ops: pointer to the port driver's port operations structure

 *

 *	When a parallel port (lowlevel) driver finds a port that

 *	should be made available to parallel port device drivers, it

 *	should call parport_register_port().  The @base, @irq, and

 *	@dma parameters are for the convenience of port drivers, and

 *	for ports where they aren't meaningful needn't be set to

 *	anything special.  They can be altered afterwards by adjusting

 *	the relevant members of the parport structure that is returned

 *	and represents the port.  They should not be tampered with

 *	after calling parport_announce_port, however.

 *

 *	If there are parallel port device drivers in the system that

 *	have registered themselves using parport_register_driver(),

 *	they are not told about the port at this time; that is done by

 *	parport_announce_port().

 *

 *	The @ops structure is allocated by the caller, and must not be

 *	deallocated before calling parport_remove_port().

 *

 *	If there is no memory to allocate a new parport structure,

 *	this function will return %NULL.

 Init our structure */

 Search for the lowest free parport number. */

	/*

	 * Now that the portnum is known finish doing the Init.

 assume the worst */

/**

 *	parport_announce_port - tell device drivers about a parallel port

 *	@port: parallel port to announce

 *

 *	After a port driver has registered a parallel port with

 *	parport_register_port, and performed any necessary

 *	initialisation or adjustments, it should call

 *	parport_announce_port() in order to notify all device drivers

 *	that have called parport_register_driver().  Their attach()

 *	functions will be called, with @port as the parameter.

 Analyse the IEEE1284.3 topology of the port. */

 Let drivers know that new port(s) has arrived. */

/**

 *	parport_remove_port - deregister a parallel port

 *	@port: parallel port to deregister

 *

 *	When a parallel port driver is forcibly unloaded, or a

 *	parallel port becomes inaccessible, the port driver must call

 *	this function in order to deal with device drivers that still

 *	want to use it.

 *

 *	The parport structure associated with the port has its

 *	operations structure replaced with one containing 'null'

 *	operations that return errors or just don't do anything.

 *

 *	Any drivers that have registered themselves using

 *	parport_register_driver() are notified that the port is no

 *	longer accessible by having their detach() routines called

 *	with @port as the parameter.

 Spread the word. */

 Forget the IEEE1284.3 topology of the port. */

/**

 *	parport_register_dev_model - register a device on a parallel port

 *	@port: port to which the device is attached

 *	@name: a name to refer to the device

 *	@par_dev_cb: struct containing callbacks

 *	@id: device number to be given to the device

 *

 *	This function, called by parallel port device drivers,

 *	declares that a device is connected to a port, and tells the

 *	system all it needs to know.

 *

 *	The struct pardev_cb contains pointer to callbacks. preemption

 *	callback function, @preempt, is called when this device driver

 *	has claimed access to the port but another device driver wants

 *	to use it.  It is given, @private, as its parameter, and should

 *	return zero if it is willing for the system to release the port

 *	to another driver on its behalf. If it wants to keep control of

 *	the port it should return non-zero, and no action will be taken.

 *	It is good manners for the driver to try to release the port at

 *	the earliest opportunity after its preemption callback rejects a

 *	preemption attempt. Note that if a preemption callback is happy

 *	for preemption to go ahead, there is no need to release the

 *	port; it is done automatically. This function may not block, as

 *	it may be called from interrupt context. If the device driver

 *	does not support preemption, @preempt can be %NULL.

 *

 *	The wake-up ("kick") callback function, @wakeup, is called when

 *	the port is available to be claimed for exclusive access; that

 *	is, parport_claim() is guaranteed to succeed when called from

 *	inside the wake-up callback function.  If the driver wants to

 *	claim the port it should do so; otherwise, it need not take

 *	any action.  This function may not block, as it may be called

 *	from interrupt context.  If the device driver does not want to

 *	be explicitly invited to claim the port in this way, @wakeup can

 *	be %NULL.

 *

 *	The interrupt handler, @irq_func, is called when an interrupt

 *	arrives from the parallel port.  Note that if a device driver

 *	wants to use interrupts it should use parport_enable_irq(),

 *	and can also check the irq member of the parport structure

 *	representing the port.

 *

 *	The parallel port (lowlevel) driver is the one that has called

 *	request_irq() and whose interrupt handler is called first.

 *	This handler does whatever needs to be done to the hardware to

 *	acknowledge the interrupt (for PC-style ports there is nothing

 *	special to be done).  It then tells the IEEE 1284 code about

 *	the interrupt, which may involve reacting to an IEEE 1284

 *	event depending on the current IEEE 1284 phase.  After this,

 *	it calls @irq_func.  Needless to say, @irq_func will be called

 *	from interrupt context, and may not block.

 *

 *	The %PARPORT_DEV_EXCL flag is for preventing port sharing, and

 *	so should only be used when sharing the port with other device

 *	drivers is impossible and would lead to incorrect behaviour.

 *	Use it sparingly!  Normally, @flags will be zero.

 *

 *	This function returns a pointer to a structure that represents

 *	the device on the port, or %NULL if there is not enough memory

 *	to allocate space for that structure.

 An exclusive device is registered. */

			/*

			 * If a device is already registered and this new

			 * device wants exclusive access, then no need to

			 * continue as we can not grant exclusive access to

			 * this device.

 Chain this onto the list */

	/*

	 * This function must not run from an irq handler so we don' t need

	 * to clear irq on the local CPU. -arca

	wmb();	/*

		 * Make sure that tmp->next is written before it's

		 * added to the list; see comments marked 'no locking

		 * required'

	/*

	 * This has to be run as last thing since init_state may need other

	 * pardevice fields. -arca

/**

 *	parport_unregister_device - deregister a device on a parallel port

 *	@dev: pointer to structure representing device

 *

 *	This undoes the effect of parport_register_device().

	/*

	 * Make sure we haven't left any pointers around in the wait

	 * list.

/**

 *	parport_find_number - find a parallel port by number

 *	@number: parallel port number

 *

 *	This returns the parallel port with the specified number, or

 *	%NULL if there is none.

 *

 *	There is an implicit parport_get_port() done already; to throw

 *	away the reference to the port that parport_find_number()

 *	gives you, use parport_put_port().

/**

 *	parport_find_base - find a parallel port by base address

 *	@base: base I/O address

 *

 *	This returns the parallel port with the specified base

 *	address, or %NULL if there is none.

 *

 *	There is an implicit parport_get_port() done already; to throw

 *	away the reference to the port that parport_find_base()

 *	gives you, use parport_put_port().

/**

 *	parport_claim - claim access to a parallel port device

 *	@dev: pointer to structure representing a device on the port

 *

 *	This function will not block and so can be used from interrupt

 *	context.  If parport_claim() succeeds in claiming access to

 *	the port it returns zero and the port is available to use.  It

 *	may fail (returning non-zero) if the port is in use by another

 *	driver and that driver is not willing to relinquish control of

 *	the port.

 Preempt any current device */

			/*

			 * I think we'll actually deadlock rather than

			 * get here, but just in case..

 Can't fail from now on, so mark ourselves as no longer waiting.  */

 Take ourselves out of the wait list again.  */

 Now we do the change of devices */

 If it's a mux port, select it. */

 FIXME */

 If it's a daisy chain device, select it. */

 This could be lazier. */

 IEEE1284.3 support */

 Restore control registers */

	/*

	 * If this is the first time we tried to claim the port, register an

	 * interest.  This is only allowed for devices sleeping in

	 * parport_claim_or_block(), or those with a wakeup function.

 The cad_lock is still held for writing here */

 First add ourselves to the end of the wait list. */

/**

 *	parport_claim_or_block - claim access to a parallel port device

 *	@dev: pointer to structure representing a device on the port

 *

 *	This behaves like parport_claim(), but will block if necessary

 *	to wait for the port to be free.  A return value of 1

 *	indicates that it slept; 0 means that it succeeded without

 *	needing to sleep.  A negative error code indicates failure.

	/*

	 * Signal to parport_claim() that we can wait even without a

	 * wakeup function.

 Try to claim the port.  If this fails, we need to sleep.  */

		/*

		 * FIXME!!! Use the proper locking for dev->waiting,

		 * and make this use the "wait_event_interruptible()"

		 * interfaces. The cli/sti that used to be here

		 * did nothing.

		 *

		 * See also parport_release()

		/*

		 * If dev->waiting is clear now, an interrupt

		 * gave us the port and we would deadlock if we slept.

/**

 *	parport_release - give up access to a parallel port device

 *	@dev: pointer to structure representing parallel port device

 *

 *	This function cannot fail, but it should not be called without

 *	the port claimed.  Similarly, if the port is already claimed

 *	you should not try claiming it again.

 Make sure that dev is the current device */

 If this is on a mux port, deselect it. */

 FIXME */

 If this is a daisy device, deselect it. */

 Save control registers */

	/*

	 * If anybody is waiting, find out who's been there longest and

	 * then wake them up. (Note: no locking required)

 !!! LOCKING IS NEEDED HERE */

 sleeping in claim_or_block */

 racy but no matter */

	/*

	 * Nobody was waiting, so walk the list to see if anyone is

	 * interested in being woken up. (Note: no locking required)

 !!! LOCKING IS NEEDED HERE */

 SPDX-License-Identifier: GPL-2.0-only

/* Low-level parallel port routines for the Atari builtin port

 *

 * Author: Andreas Schwab <schwab@issan.informatik.uni-dortmund.de>

 *

 * Based on parport_amiga.c.

 *

 * The built-in Atari parallel port provides one port at a fixed address

 * with 8 output data lines (D0 - D7), 1 output control line (STROBE)

 * and 1 input status line (BUSY) able to cause an interrupt.

 Soundchip port B as output. */

 Soundchip port A/B as output. */

 STROBE high. */

 MFP port I0 as input. */

 MFP port I0 interrupt on high->low edge. */

 SPDX-License-Identifier: GPL-2.0

/* IEEE-1284 operations for parport.

 *

 * This file is for generic IEEE 1284 operations.  The idea is that

 * they are used by the low-level drivers.  If they have a special way

 * of doing something, they can provide their own routines (and put

 * the function pointers in port->ops); if not, they can just use these

 * as a fallback.

 *

 * Note: Make no assumptions about hardware or architecture in this file!

 *

 * Author: Tim Waugh <tim@cyberelk.demon.co.uk>

 * Fixed AUTOFD polarity in ecp_forward_to_reverse().  Fred Barnes, 1999

 * Software emulated EPP fixes, Fred Barnes, 04/2001.

 undef me for production */

 Don't want a garbled console */

/***                                *

 * One-way data transfer functions. *

 Compatibility mode. */

 Wait until the peripheral's ready */

 Is the peripheral ready yet? */

 Skip the loop */

 Is the peripheral upset? */

				/* If nFault is asserted (i.e. no

				 * error) and PAPEROUT and SELECT are

				 * just red herrings, give the driver

				 * a chance to check it's happy with

 Have we run out of time? */

			/* Yield the port for a while.  If this is the

                           first time around the loop, don't let go of

                           the port.  This way, we find out if we have

 We must have the device claimed here */

 Is there a signal pending? */

 Wait longer next time. */

 Write the character to the data lines. */

 Pulse strobe. */

 strobe */

 hold */

 Assume the peripheral received it. */

 Let another process run if it needs to. */

 Nibble mode. */

 in nibbles */

 Does the error line indicate end of data? */

 Event 7: Set nAutoFd low. */

 Event 9: nAck goes low. */

 Timeout -- no more data? */

 Read a nibble. */

 Event 10: Set nAutoFd high. */

 Event 11: nAck goes high. */

 Timeout -- no more data? */

 Second nibble */

 Read the last nibble without checking data avail. */

 Go to reverse idle phase. */

 IEEE1284 support */

 Byte mode. */

 Data available? */

 Event 14: Place data bus in high impedance state. */

 Event 7: Set nAutoFd low. */

 Event 9: nAck goes low. */

 Timeout -- no more data? */

 Event 10: Set nAutoFd high */

 Event 11: nAck goes high. */

 Timeout -- no more data? */

 Event 16: Set nStrobe low. */

 Event 17: Set nStrobe high. */

 Read the last byte without checking data avail. */

 Go to reverse idle phase. */

 IEEE1284 support */

/***              *

 * ECP Functions. *

 Event 38: Set nAutoFd low */

 Event 39: Set nInit low to initiate bus reversal */

 Event 40: PError goes low */

 Event 47: Set nInit high */

 Event 49: PError goes high */

 IEEE1284 support */

 ECP mode, forward channel, data. */

 HostAck high (data, not command) */

 Time for Host Transfer Recovery (page 41 of IEEE1284) */

 It's buggered. */

 Peripheral hasn't accepted the data. */

 IEEE1284 support */

 ECP mode, reverse channel, data. */

 shut gcc up */

 Set HostAck low to start accepting data. */

		/* Event 43: Peripheral sets nAck low. It can take as

			/* The peripheral hasn't given us data in

			   35ms.  If we have data to give back to the

			/* If we've used up all the time we were allowed,

 Yield the port for a while. */

 We must have the device claimed here. */

 Is there a signal pending? */

 Is this a command? */

			/* The last byte was a run-length count, so

 Read the data. */

		/* If this is a channel command, rather than an RLE

 Are we allowed to read that many bytes? */

 Event 44: Set HostAck high, acknowledging handshake. */

 Event 45: The peripheral has 35ms to set nAck high. */

			/* It's gone wrong.  Return what data we have

 Event 46: Set HostAck low and accept the data. */

 If we just read a run-length count, fetch the data. */

 If this is the byte after a run-length count, decompress. */

 Normal data byte. */

 IEEE1284 support */

 ECP mode, forward channel, commands. */

 HostAck low (command, not data) */

 Time for Host Transfer Recovery (page 41 of IEEE1284) */

 It's buggered. */

 Peripheral hasn't accepted the data. */

 IEEE1284 support */

/***              *

 * EPP functions. *

 EPP mode, forward channel, data. */

 set EPP idle state (just to make sure) with strobe low */

 Event 62: Write data and set autofd low */

 Event 58: wait for busy (nWait) to go high */

 Event 63: set nAutoFd (nDStrb) high */

 Event 60: wait for busy (nWait) to go low */

 Event 61: set strobe (nWrite) high */

 EPP mode, reverse channel, data. */

 set EPP idle state (just to make sure) with strobe high */

 Event 67: set nAutoFd (nDStrb) low */

 Event 58: wait for Busy to go high */

 Event 63: set nAutoFd (nDStrb) high */

 Event 60: wait for Busy to go low */

 EPP mode, forward channel, addresses. */

 set EPP idle state (just to make sure) with strobe low */

 Event 56: Write data and set nAStrb low. */

 Event 58: wait for busy (nWait) to go high */

 Event 59: set nAStrb high */

 Event 60: wait for busy (nWait) to go low */

 Event 61: set strobe (nWrite) high */

 EPP mode, reverse channel, addresses. */

 Set EPP idle state (just to make sure) with strobe high */

 Event 64: set nSelectIn (nAStrb) low */

 Event 58: wait for Busy to go high */

 Event 59: set nSelectIn (nAStrb) high */

 Event 60: wait for Busy to go low */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Support for common PCI multi-I/O cards (which is most of them)

 *

 * Copyright (C) 2001  Tim Waugh <twaugh@redhat.com>

 *

 * Multi-function PCI cards are supposed to present separate logical

 * devices on the bus.  A common thing to do seems to be to just use

 * one logical device with lots of base address registers for both

 * parallel ports and serial ports.  This driver is for dealing with

 * that.

 each element directly indexed from enum list, above */

	struct { /* BAR (base address registers) numbers in the config

		int hi; /* -1 if not there, >6 for offset-method (max

	/* If set, this is called immediately after pci_enable_device.

	 * If it returns non-zero, no probing will take place and the

	/* If set, this is called after probing for ports.  If 'failed'

 the rule described below doesn't hold for this device */

		/*

		 * Netmos uses the subdevice ID to indicate the number of parallel

		 * and serial ports.  The form is 0x00PS, where <P> is the number of

		 * parallel ports and <S> is the number of serial ports.

 titan_110l */		{ 1, { { 3, -1 }, } },

 titan_210l */		{ 1, { { 3, -1 }, } },

 netmos_9xx5_combo */		{ 1, { { 2, -1 }, }, netmos_parallel_init },

 netmos_9855 */		{ 1, { { 0, -1 }, }, netmos_parallel_init },

 netmos_9855_2p */		{ 2, { { 0, -1 }, { 2, -1 }, } },

 netmos_9900 */		{1, { { 3, 4 }, }, netmos_parallel_init },

 netmos_9900_2p */		{2, { { 0, 1 }, { 3, 4 }, } },

 netmos_99xx_1p */		{1, { { 0, 1 }, } },

 avlab_1s1p     */		{ 1, { { 1, 2}, } },

 avlab_1s2p     */		{ 2, { { 1, 2}, { 3, 4 },} },

 avlab_2s1p     */		{ 1, { { 2, 3}, } },

 siig_1s1p_10x */		{ 1, { { 3, 4 }, } },

 siig_2s1p_10x */		{ 1, { { 4, 5 }, } },

 siig_2p1s_20x */		{ 2, { { 1, 2 }, { 3, 4 }, } },

 siig_1s1p_20x */		{ 1, { { 1, 2 }, } },

 siig_2s1p_20x */		{ 1, { { 2, 3 }, } },

 timedia_4078a */		{ 1, { { 2, -1 }, } },

 timedia_4079h */             { 1, { { 2, 3 }, } },

 timedia_4085h */             { 2, { { 2, -1 }, { 4, -1 }, } },

 timedia_4088a */             { 2, { { 2, 3 }, { 4, 5 }, } },

 timedia_4089a */             { 2, { { 2, 3 }, { 4, 5 }, } },

 timedia_4095a */             { 2, { { 2, 3 }, { 4, 5 }, } },

 timedia_4096a */             { 2, { { 2, 3 }, { 4, 5 }, } },

 timedia_4078u */             { 1, { { 2, -1 }, } },

 timedia_4079a */             { 1, { { 2, 3 }, } },

 timedia_4085u */             { 2, { { 2, -1 }, { 4, -1 }, } },

 timedia_4079r */             { 1, { { 2, 3 }, } },

 timedia_4079s */             { 1, { { 2, 3 }, } },

 timedia_4079d */             { 1, { { 2, 3 }, } },

 timedia_4079e */             { 1, { { 2, 3 }, } },

 timedia_4079f */             { 1, { { 2, 3 }, } },

 timedia_9079a */             { 1, { { 2, 3 }, } },

 timedia_9079b */             { 1, { { 2, 3 }, } },

 timedia_9079c */             { 1, { { 2, 3 }, } },

 wch_ch353_1s1p*/             { 1, { { 1, -1}, } },

 wch_ch353_2s1p*/             { 1, { { 2, -1}, } },

 wch_ch382_0s1p*/		{ 1, { { 2, -1}, } },

 wch_ch382_2s1p*/             { 1, { { 2, -1}, } },

 brainboxes_5s1p */           { 1, { { 3, -1 }, } },

 sunix_4008a */		{ 1, { { 1, 2 }, } },

 sunix_5069a */		{ 1, { { 1, 2 }, } },

 sunix_5079a */		{ 1, { { 1, 2 }, } },

 sunix_5099a */		{ 1, { { 1, 2 }, } },

 PCI cards */

 PCI_VENDOR_ID_AVLAB/Intek21 has another bunch of cards ...*/

 PCI_VENDOR_ID_TIMEDIA/SUNIX has many differing cards ...*/

 WCH CARDS */

 BrainBoxes PX272/PX306 MIO card */

 Sunix boards */

 terminate list */

/*

 * This table describes the serial "geometry" of these boards.  Any

 * quirks for these can be found in drivers/serial/8250_pci.c

 *

 * Cards not tested are marked n/t

 * If you have one of these cards and it works for you, please tell me..

 n/t */

 parallel only */ 
 parallel only */ 
 n/t */

 n/t */

 n/t */

 Register the serial port(s) of a PCI card. */

 Register the parallel port(s) of a PCI card. */

			io_lo += hi; /* Reinterpret the meaning of

                                        "hi" as an offset (see SYBA

 TODO: test if sharing interrupts works */

 Serial ports

 Parallel ports

 FIXME: What about parport? */

 FIXME: What about parport? */

 SPDX-License-Identifier: GPL-2.0-only

/* Low-level parallel port routines for the Amiga built-in port

 *

 * Author: Joerg Dorchain <joerg@dorchain.net>

 *

 * This is a complete rewrite of the code, but based heaviy upon the old

 * lp_intern. code.

 *

 * The built-in Amiga parallel port provides one port at a fixed address

 * with 8 bidirectional data lines (D0 - D7) and 3 bidirectional status

 * lines (BUSY, POUT, SEL), 1 output control line /STROBE (raised automatically

 * in hardware when the data register is accessed), and 1 input control line

 * /ACK, able to cause an interrupt, but both not directly settable by

 * software.

 Triggers also /STROBE. This behavior cannot be changed */

 Triggers also /STROBE. This behavior cannot be changed */

	/* fake value: interrupt enable, select in, no reset,

 No implementation possible */

 Busy */

 PaperOut */

 Selected */

 the rest is not connected or handled autonomously in hardware */

 all pins output */

 all pins input */

 ----------- Initialisation code --------------------------------- */

 XXX: set operating mode */

 SPDX-License-Identifier: GPL-2.0-only

/* Low-level parallel-port routines for 8255-based PC-style hardware.

 *

 * Authors: Phil Blundell <philb@gnu.org>

 *          Tim Waugh <tim@cyberelk.demon.co.uk>

 *	    Jose Renau <renau@acm.org>

 *          David Campbell

 *          Andrea Arcangeli

 *

 * based on work by Grant Guenther <grant@torque.net> and Phil Blundell.

 *

 * Cleaned up include files - Russell King <linux@arm.uk.linux.org>

 * DMA support - Bert De Jonghe <bert@sophis.be>

 * Many ECP bugs fixed.  Fred Barnes & Jamie Lokier, 1999

 * More PCI support now conditional on CONFIG_PCI, 03/2001, Paul G.

 * Various hacks, Fred Barnes, 04/2001

 * Updated probing logic - Adam Belay <ambx1@neo.rr.com>

/* This driver should work with any hardware that is broadly compatible

 * with that in the IBM PC.  This applies to the majority of integrated

 * I/O chipsets that are commonly available.  The expected register

 * layout is:

 *

 *	base+0		data

 *	base+1		status

 *	base+2		control

 *

 * In addition, there are some optional registers:

 *

 *	base+3		EPP address

 *	base+4		EPP data

 *	base+0x400	ECP config A

 *	base+0x401	ECP config B

 *	base+0x402	ECP control

 *

 * All registers are 8 bits wide and read/write.  If your hardware differs

 * only in register addresses (eg because your registers are on 32-bit

 * word boundaries) then you can alter the constants in parport_pc.h to

 * accommodate this.

 *

 * Note that the ECP registers may not start at offset 0x400 for PCI cards,

 * but rather will start at port->base_hi.

 ECR modes */

 For Super-IO chips autodetection */

 frob_control, but for ECR */

/* Safely change the mode bits in the ECR

   Returns:

	    0    : Success

	   -EBUSY: Could not drain FIFO in some finite amount of time,

		   mode not changed!

 Bits <7:5> contain the mode. */

		/* This mode resets the FIFO, so we may

 Parallel Port FIFO mode */

 ECP Parallel Port mode */

 Busy wait for 200us */

 Poll slowly. */

 The FIFO is stuck. */

 We have to go through mode 001 */

 Set the mode. */

 FIFO support */

/*

 * Clear TIMEOUT BIT in EPP MODE

 *

 * This is also used in SPP detection.

 To clear timeout some chips require double read */

 Some reset by writing 1 */

 Others by writing 0 */

/*

 * Access functions.

 *

 * Most of these aren't static because they may be used by the

 * parport_xxx_yyy macros.  extern __inline__ versions of several

 * of these are in parport_pc.h.

 Set ackIntEn */

	s->u.pc.ecr = 0x34; /* NetMos chip can cause problems 0x24;

		/* use knowledge about data lines..:

		 *  nFault is 0 if there is at least 1 byte in the Warp's FIFO

		 *  pError is 1 if there are 16 bytes in the Warp's FIFO

 can grab 16 bytes from warp fifo */

 grab single byte from the warp fifo */

 EPP timeout should never occur... */

 EPP timeout */

 IEEE 1284 support */

 80 usecs */

 We don't want to be interrupted every character. */

 set nErrIntrEn and serviceIntr */

 Forward mode. */

 Must be in PS2 mode */

 Can't yield the port. */

 Anyone else waiting for the port? */

 FIFO is full. Wait for interrupt. */

 Clear serviceIntr */

 Timed out. */

 Can't fail now. */

 FIFO is empty. Blast it full. */

 Adjust the poll time. */

 Half-full(call me an optimist) */

 max 64k per DMA transfer */

 If it would cross a 64k boundary, cap it at the end. */

		/* above 16 MB we use a bounce buffer as ISA-DMA

 sizeof(priv->dma_buf) */

 We don't want to be interrupted every character. */

 set nErrIntrEn and serviceIntr */

 Forward mode. */

 Must be in PS2 mode */

 bounce buffer ! */

 Set DMA mode */

 Clear serviceIntr */

 assume DMA will be successful */

 Wait for interrupt. */

 Timed out. */

 Is serviceIntr set? */

 Can't yield the port. */

 Anyone else waiting for the port? */

 update for possible DMA residue ! */

 Maybe got here through break, so adjust for DMA residue! */

 Turn off DMA mode */

 Parallel Port FIFO mode (ECP chipsets) */

	/* Special case: a timeout of zero means we cannot call schedule().

 Set up parallel port FIFO mode.*/

 Must be in PS2 mode */

 Parallel port FIFO */

 Write the data to the FIFO. */

 Finish up. */

	/* For some hardware we don't want to touch the mode until

	 * the FIFO is empty, so allow 4 seconds for each position

	 * in the fifo.

 Wait for the FIFO to empty */

 Prevent further data transfer. */

 Adjust for the contents of the FIFO. */

 Full up. */

 Reset the FIFO and return to PS2 mode. */

 ECP */

	/* Special case: a timeout of zero means we cannot call schedule().

 Switch to forward mode if necessary. */

 Event 47: Set nInit high. */

 Event 49: PError goes high. */

 Set up ECP parallel port mode.*/

 Must be in PS2 mode */

 ECP FIFO */

 Write the data to the FIFO. */

 Finish up. */

	/* For some hardware we don't want to touch the mode until

	 * the FIFO is empty, so allow 4 seconds for each position

	 * in the fifo.

 Wait for the FIFO to empty */

 Prevent further data transfer. */

 Adjust for the contents of the FIFO. */

 Full up. */

 Reset the FIFO and return to PS2 mode. */

 Host transfer recovery. */

 Must be in PS2 mode */

 IEEE 1284 support */

 Allowed to use FIFO/DMA */

/*

 *	******************************************

 *	INITIALISATION AND MODULE STUFF BELOW HERE

 *	******************************************

/* GCC is not inlining extern inline function later overwritten to non-inline,

 Super-IO chipset detection, Winbond, SMSC */

		/* The documentation calls DMA and IRQ-Lines by letters, so

		   the board maker can/will wire them

	/* Heuristics !  BIOS setup for this mainboard device limits

	   the choices to standard settings, i.e. io-address and IRQ

	   are related, however DMA can be 1 or 3, assume DMA_A=DMA1,

 if active */

 0 */

 5 */

	/* The registers are called compatible-PnP because the

	   register layout is modelled after ISA-PnP, the access

 Register 7: Select Logical Device */

 LD1 is Parallel Port */

 the settings can be interrogated later ... */

		/* simple heuristics, we happened to read some

	/* Values are from public data sheets pdf files, I can just

		/* simple heuristics, we happened to read some

 Save original value */

 First probe without key */

	outb(key, io);     /* Write Magic Sequence to EFER, extended

 Write EFIR, extended function index register */

 Read EFDR, extended function data register */

 Magic Seal */

 in case we poked some entirely different hardware */

 protection against false positives */

 Save original values */

 First probe without the key */

	outb(key, io);     /* Write Magic Byte to EFER, extended

 Write EFIR, extended function index register */

 Read EFDR, extended function data register */

 Magic Seal */

 in case we poked some entirely different hardware */

 protection against false positives */

 Save original value */

 First probe without the key */

	outb(key, io);     /* Write Magic Sequence to EFER, extended

 Write EFIR, extended function index register */

 Read EFDR, extended function data register */

 Magic Seal */

 in case we poked some entirely different hardware */

 protection against false positives */

 Save original value */

 Parallel Port */

 BOOT 0x80 off */

 Lock */

 Oops, sorry to disturb */

 CONFIG_PARPORT_PC_SUPERIO */

 --- Mode detection ------------------------------------- */

/*

 * Checks for port existence, all ports support SPP MODE

 * Returns:

 *         0           :  No parallel port at this address

 *  PARPORT_MODE_PCSPP :  SPP port detected

 *                        (if the user specified an ioport himself,

 *                         this shall always be the case!)

 *

	/*

	 * first clear an eventually pending EPP timeout

	 * I (sailer@ife.ee.ethz.ch) have an SMSC chipset

	 * that does not even respond to SPP cycles if an EPP

	 * timeout is pending

 Do a simple read-write test to make sure the port exists. */

	/* Is there a control register that we can read from?  Some

	 * ports don't allow reads, so read_control just returns a

	 * software copy. Some ports _do_ allow reads, so bypass the

	 * software copy here.  In addition, some bits aren't

		/* That didn't work, but the user thinks there's a

	/* Try the data register.  The data lines aren't tri-stated at

		/* Didn't work, but the user is convinced this is the

	/* It's possible that we can't read the control register or

/* Check for ECR

 *

 * Old style XT ports alias io ports every 0x400, hence accessing ECR

 * on these cards actually accesses the CTR.

 *

 * Modern cards don't do this but reading from ECR will return 0xff

 * regardless of what is written here if the card does NOT support

 * ECP.

 *

 * We first check to see if ECR is the same as CTR.  If not, the low

 * two bits of ECR aren't writable, so we check by writing ECR and

 * reading it back to see if it's what we expect.

 Toggle bit 1 */

 Sure that no ECR register exists */

 Go to mode 000 */

/* Detect PS/2 support.

 *

 * Bit 5 (0x20) sets the PS/2 data direction; setting this high

 * allows us to read data from the data lines.  In theory we would get back

 * 0xff but any peripheral attached to the port may drag some or all of the

 * lines down to zero.  So if we get back anything that isn't the contents

 * of the data register we deem PS/2 support to be present.

 *

 * Some SPP ports have "half PS/2" ability - you can't turn off the line

 * drivers, but an external peripheral with sufficiently beefy drivers of

 * its own can overpower them and assert its own levels onto the bus, from

 * where they can then be read back as normal.  Ports with this property

 * and the right type of device attached are likely to fail the SPP test,

 * (as they will appear to have stuck bits) and so the fact that they might

 * be misdetected here is rather academic.

 try to tri-state the buffer */

 cancel input mode */

 Translate ECP intrLine to ISA irq value */

 If there is no ECR, we have no hope of supporting ECP. */

 Find out FIFO depth */

 Reset FIFO */

 TEST FIFO */

	/*

	 * Using LGS chipset it uses ECR register, but

	 * it doesn't support ECP or FIFO MODE

 Find out writeIntrThreshold */

		/* Number of bytes we know we can write if we get an

 Find out readIntrThreshold */

 Reset FIFO and enable PS2 */

 Must be in PS2 mode */

 Test FIFO */

 Number of bytes we can read if we get an interrupt. */

 Reset FIFO */

 Configuration mode */

 Assume 1 */

 Go back to mode 000 */

 store value of ECR */

 Phony EPP in ECP. */

 return ECR into the inital state */

 Check whether the device is legacy, not PCI or PCMCIA. Only legacy is known to be affected. */

 CONFIG_X86_32 */

 EPP mode detection  */

	/*

	 * Theory:

	 *	Bit 0 of STR is the EPP timeout bit, this bit is 0

	 *	when EPP is possible and is set high when an EPP timeout

	 *	occurs (EPP uses the HALT line to stop the CPU while it does

	 *	the byte transfer, an EPP timeout occurs if the attached

	 *	device fails to respond after 10 micro seconds).

	 *

	 *	This bit is cleared by either reading it (National Semi)

	 *	or writing a 1 to the bit (SMC, UMC, WinBond), others ???

	 *	This bit is always high in non EPP modes.

 If EPP timeout bit clear then EPP available */

 No way to clear timeout */

 Check for Intel bug. */

 Set up access functions to use EPP hardware. */

 Search for SMC style EPP+ECP mode */

 Set up access functions to use ECP+EPP hardware. */

 No IEEE 1284 support */

 Don't bother probing for modes we know we won't use. */

 No IEEE 1284 support */

 --- IRQ detection -------------------------------------- */

 Only if supports ECP mode */

 Configuration MODE */

 Reset FIFO */

 If Full FIFO sure that writeIntrThreshold is generated */

/*

 * This detection seems that only works in National Semiconductors

 * This doesn't work in SMC, LGS, and Winbond

	/* Device isn't expecting an EPP read

	 * and generates an IRQ.

 Advanced detection */

 Don't even try to do this. */

/* We will attempt to share interrupt requests since other devices

 * such as sound cards and network cards seem to like using the

 * printer IRQs.

 *

 * When ECP is available we can autoprobe for IRQs.

 * NOTE: If we can autoprobe it, we can register the IRQ.

 --- DMA detection -------------------------------------- */

 Only if chipset conforms to ECP ISA Interface Standard */

	/* 000: Indicates jumpered 8-bit DMA if read-only.

 ask ECP chipset first */

		/* ask known Super-IO chips proper, although these

		   claim ECP compatible, some don't report their DMA

 --- Initialisation code -------------------------------- */

		/* We need a physical device to attach to, but none was

 a misnomer, actually - it's allocate and reserve parport number */

 No port. */

	if (p->dma == PARPORT_DMA_AUTO) /* To use DMA, giving the irq

 currently broken, but working on it.. (FB) */

 p->ops->ecp_read_data = parport_pc_ecp_read_block_pio; */

 IEEE 1284 support */

 We can't use the DMA channel after all. */

 Allowed to use FIFO/DMA */

 CONFIG_PARPORT_1284 */

 If No ECP release the ports grabbed above. */

 Likewise for EEP ports */

 Done probing.  Now put the port into a sensible start-up state. */

		/*

		 * Put the ECP detected port in PS2 mode.

		 * Do this also for ports that have ECR but don't do ECP.

	/* Now that we've told the sharing engine about the port, and

	   found out its characteristics, let the high-level drivers

 hope no-one cached it */

 ITE support maintained by Rich Liu <richliu@poorman.org> */

 make sure which one chip */

 SET SPP&EPP , Parallel Port NO DMA , Enable All Function */

 SET Parallel IRQ */

 Let the user (or defaults) steer us away from interrupts */

	/*

	 * Release the resource so that parport_pc_probe_port can get it.

/* VIA 8231 support by Pavel Fedin <sonic_amiga@rambler.ru>

 Data for two known VIA chips */

	/*

	 * unlock super i/o configuration

 Bits 1-0: Parallel Port Mode / Enable */

 Bit 5: EPP+ECP enable; bit 7: PS/2 bidirectional port enable */

 Parallel Port I/O Base Address, bits 9-2 */

	/*

	 * lock super i/o configuration

 Bits 7-4: PnP Routing for Parallel Port IRQ */

 Bits 3-2: PnP Routing for Parallel Port DMA */

		/* if ECP not enabled, DMA is not enabled, assumed

 Let the user (or defaults) steer us away from interrupts and DMA */

 filter bogus IRQs */

 do nothing */

 finally, do the probe with values obtained */

 Via VT82C686A motherboard Super I/O */

 Via VT8231 south bridge integrated Super IO */

 each element directly indexed from enum list, above */

/* each element directly indexed from enum list, above

	struct { /* BAR (base address registers) numbers in the config

 -1 if not there, >6 for offset-method (max BAR is 6) */

	/* If set, this is called immediately after pci_enable_device.

	 * If it returns non-zero, no probing will take place and the

	/* If set, this is called after probing for ports.  If 'failed'

 siig_1p_10x */		{ 1, { { 2, 3 }, } },

 siig_2p_10x */		{ 2, { { 2, 3 }, { 4, 5 }, } },

 siig_1p_20x */		{ 1, { { 0, 1 }, } },

 siig_2p_20x */		{ 2, { { 0, 1 }, { 2, 3 }, } },

 lava_parallel */		{ 1, { { 0, -1 }, } },

 lava_parallel_dual_a */	{ 1, { { 0, -1 }, } },

 lava_parallel_dual_b */	{ 1, { { 0, -1 }, } },

 boca_ioppar */		{ 1, { { 0, -1 }, } },

 plx_9050 */			{ 2, { { 4, -1 }, { 5, -1 }, } },

 timedia_4006a */             { 1, { { 0, -1 }, } },

 timedia_4014  */             { 2, { { 0, -1 }, { 2, -1 }, } },

 timedia_4008a */             { 1, { { 0, 1 }, } },

 timedia_4018  */             { 2, { { 0, 1 }, { 2, 3 }, } },

 timedia_9018a */             { 2, { { 0, 1 }, { 2, 3 }, } },

					/* SYBA uses fixed offsets in

 syba_2p_epp AP138B */	{ 2, { { 0, 0x078 }, { 0, 0x178 }, } },

 syba_1p_ecp W83787 */	{ 1, { { 0, 0x078 }, } },

 titan_010l */		{ 1, { { 3, -1 }, } },

 avlab_1p		*/	{ 1, { { 0, 1}, } },

 avlab_2p		*/	{ 2, { { 0, 1}, { 2, 3 },} },

	/* The Oxford Semi cards are unusual: 954 doesn't support ECP,

 oxsemi_952 */		{ 1, { { 0, 1 }, } },

 oxsemi_954 */		{ 1, { { 0, -1 }, } },

 oxsemi_840 */		{ 1, { { 0, 1 }, } },

 oxsemi_pcie_pport */		{ 1, { { 0, 1 }, } },

 aks_0100 */                  { 1, { { 0, -1 }, } },

 mobility_pp */		{ 1, { { 0, 1 }, } },

 The netmos entries below are untested */

 netmos_9705 */               { 1, { { 0, -1 }, } },

 netmos_9715 */               { 2, { { 0, 1 }, { 2, 3 },} },

 netmos_9755 */               { 2, { { 0, 1 }, { 2, 3 },} },

 netmos_9805 */		{ 1, { { 0, 1 }, } },

 netmos_9815 */		{ 2, { { 0, 1 }, { 2, 3 }, } },

 netmos_9901 */               { 1, { { 0, -1 }, } },

 netmos_9865 */               { 1, { { 0, -1 }, } },

 quatech_sppxp100 */		{ 1, { { 0, 1 }, } },

 wch_ch382l */		{ 1, { { 2, -1 }, } },

 Super-IO onboard chips */

 PCI cards */

 PCI_VENDOR_ID_TIMEDIA/SUNIX has many differing cards ...*/

 PCI_VENDOR_ID_AVLAB/Intek21 has another bunch of cards ...*/

 AFAVLAB_TK9902 */

 NetMos communication controllers */

 Quatech SPPXP-100 Parallel port PCI ExpressCard */

 WCH CH382L PCI-E single parallel port card */

 terminate list */

 This is an onboard Super-IO and has already been probed */

 This is a PCI card */

			io_lo += hi; /* Reinterpret the meaning of

					"hi" as an offset (see SYBA

 TODO: test if sharing interrupts works */

 number of devices found */

 CONFIG_PCI */

 Standard LPT Printer Port */

 ECP Printer Port */

 we only need the pnp layer to activate the device, at least for now */

 CONFIG_PNP */

	/* Always succeed, the actual probing is done in

 This is called by parport_pc_find_nonpci_ports (in asm/parport.h) */

/* This function is called by parport_pc_init if the user didn't

 * specify any ports to probe.  Its job is to find some ports.  Order

 * is important here -- we want ISA ports to be registered first,

 * followed by PCI cards (for least surprise), but before that we want

 * to do chipset-specific tests for some onboard ports that we know

 * about.

 *

 * autoirq is PARPORT_IRQ_NONE, PARPORT_IRQ_AUTO, or PARPORT_IRQ_PROBEONLY

 * autodma is PARPORT_DMA_NONE or PARPORT_DMA_AUTO

 Onboard SuperIO chipsets that show themselves on the PCI bus. */

 PnP ports, skip detection if SuperIO already found them */

 ISA ports and whatever (see asm/parport.h). */

/*

 *	Piles of crap below pretend to be a parser for module and kernel

 *	parameters.  Say "thank you" to whoever had come up with that

 *	syntax and keep in mind that code below is a cleaned up version.

 The user can make us use any IRQs or DMAs we find. */

/*

 * Acceptable parameters:

 *

 * parport=0

 * parport=auto

 * parport=0xBASE[,IRQ[,DMA]]

 *

 * IRQ/DMA may be numeric or 'auto' or 'none'

 Disable parport if "parport=0" in cmdline */

/*

 * Acceptable parameters:

 *

 * parport_init_mode=[spp|ps2|epp|ecp|ecpepp]

 "Parser" ends here */

 Only probe the ports we were given. */

/*

 * IEEE 1284.3 Parallel port daisy chain and multiplexor code

 * 

 * Copyright (C) 1999, 2000  Tim Waugh <tim@cyberelk.demon.co.uk>

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License

 * as published by the Free Software Foundation; either version

 * 2 of the License, or (at your option) any later version.

 *

 * ??-12-1998: Initial implementation.

 * 31-01-1999: Make port-cloning transparent.

 * 13-02-1999: Move DeviceID technique from parport_probe.

 * 13-03-1999: Get DeviceID from non-IEEE 1284.3 devices too.

 * 22-02-2000: Count devices that are actually detected.

 *

 * Any part of this program may be used in documents licensed under

 * the GNU Free Documentation License, Version 1.1 or any later version

 * published by the Free Software Foundation.

 Forward-declaration of lower-level functions. */

 Add a device to the discovered topology. */

 Clone a parport (actually, make an alias). */

/* Discover the IEEE1284.3 topology on a port -- muxes and daisy chains.

0*/"th", "st", "nd", "rd", "th" };

		/*

		 * flag should be marked true first as

		 * parport_register_driver() might try to load the low

		 * level driver which will lead to announcing new ports

		 * and which will again come back here at

		 * parport_daisy_init()

	/* Because this is called before any other devices exist,

	/* If mux present on normal port, need to create new

 don't be fooled: a mux must have 2 or 4 ports. */

 Leave original as port zero. */

 Clone the port. */

			/* Analyse that port too.  We won't recurse

			   forever because of the 'port->muxport < 0'

 Count the potential legacy device at the end. */

 Find out the legacy device's IEEE 1284 device ID. */

		/* No devices were detected.  Perhaps they are in some

                   funny state; let's try to reset them and see if

 Forget about devices on a physical port. */

	/* Gaps in the numbering could be handled better.  How should

           someone enumerate through all IEEE1284.3 devices in the

/**

 *	parport_open - find a device by canonical device number

 *	@devnum: canonical device number

 *	@name: name to associate with the device

 *

 *	This function is similar to parport_register_device(), except

 *	that it locates a device by its number rather than by the port

 *	it is attached to.

 *

 *	All parameters except for @devnum are the same as for

 *	parport_register_device().  The return value is the same as

 *	for parport_register_device().

 Check that there really is a device to select. */

 No corresponding device. */

/**

 *	parport_close - close a device opened with parport_open()

 *	@dev: device to close

 *

 *	This is to parport_open() as parport_unregister_device() is to

 *	parport_register_device().

 Send a daisy-chain-style CPP command packet. */

 Send a mux-style CPP command packet. */

 For these modes we should switch to EPP mode:

 For these modes we should switch to ECP mode:

 Nothing was told for BECP in Daisy chain specification.

 May be it's wise to use ECP?

 Others use compat mode

		/* See if this device thought it was the last in the

		/* We are seeing pass through status now. We see

		   last_dev from next device or if last_dev does not

		   work status lines from some non-daisy chain

 Ask the new devices to introduce themselves. */

 SPDX-License-Identifier: GPL-2.0-only

/* Low-level parallel port routines for the Multiface 3 card

 *

 * Author: Joerg Dorchain <joerg@dorchain.net>

 *

 * (C) The elitist m68k Users(TM)

 *

 * based on the existing parport_amiga and lp_mfc

 *

 *

 * From the MFC3 documentation:

 * 

 * Miscellaneous PIA Details

 * -------------------------

 * 

 * 	The two open-drain interrupt outputs /IRQA and /IRQB are routed to

 * /INT2 of the Z2 bus.

 * 

 * 	The CPU data bus of the PIA (D0-D7) is connected to D8-D15 on the Z2

 * bus. This means that any PIA registers are accessed at even addresses.

 * 

 * Centronics Pin Connections for the PIA

 * --------------------------------------

 * 

 * 	The following table shows the connections between the PIA and the

 * Centronics interface connector. These connections implement a single, but

 * very complete, Centronics type interface. The Pin column gives the pin

 * numbers of the PIA. The Centronics pin numbers can be found in the section

 * "Parallel Connectors".

 * 

 * 

 *    Pin | PIA | Dir | Centronics Names

 * -------+-----+-----+---------------------------------------------------------

 *     19 | CB2 | --> | /STROBE (aka /DRDY)

 *  10-17 | PBx | <-> | DATA0 - DATA7

 *     18 | CB1 | <-- | /ACK

 *     40 | CA1 | <-- | BUSY

 *      3 | PA1 | <-- | PAPER-OUT (aka POUT)

 *      4 | PA2 | <-- | SELECTED (aka SEL)

 *      9 | PA7 | --> | /INIT (aka /RESET or /INPUT-PRIME)

 *      6 | PA4 | <-- | /ERROR (aka /FAULT)

 *      7 | PA5 | --> | DIR (aka /SELECT-IN)

 *      8 | PA6 | --> | /AUTO-FEED-XT

 *     39 | CA2 | --> | open

 *      5 | PA3 | <-- | /ACK (same as CB1!)

 *      2 | PA0 | <-- | BUSY (same as CA1!)

 * -------+-----+-----+---------------------------------------------------------

 * 

 * Should be enough to understand some of the driver.

 *

 * Per convention for normal use the port registers are visible.

 * If you need the data direction registers, restore the value in the

 * control register.

 Maximum Number of Cards supported */

 for trigger readds */

 clears irq bit */

 Triggers also /STROBE.*/

 clears interrupt bit. Triggers also /STROBE. */

 XXX: What is SELECP? */

 /SELECT_IN */

 INITP */

 AUTOLF */

 Strobe */

 Handled directly by hardware */;

 /INITP */

 /AUTOLF */

 /SELECT_IN */

 Busy */

 PaperOut */

 Selected */

 Ack */

 /ERROR */

 Board caused interrupt */

 clear irq bit */

 make data direction register visible */

 all pins output */

 make data register visible - default */

 make data direction register visible */

 all pins input */

 make data register visible - default */

 ----------- Initialisation code --------------------------------- */

 all data pins output */

 reading clears interrupt */

 /RESET,  /DIR ,/AUTO-FEED output */

 reset printer */

 XXX: set operating mode */

 SPDX-License-Identifier: GPL-2.0

/*

 * Parallel port device probing code

 *

 * Authors:    Carsten Gross, carsten@sol.wohnheim.uni-ulm.de

 *             Philip Blundell <philb@gnu.org>

 Get rid of trailing blanks */

				/* if it speaks printer language, it's

	/* If the device didn't tell us its class, maybe we have managed to

/* Read up to count-1 bytes of device id. Terminate buffer with

 * '\0'. Buffer begins with two Device ID length bytes as given by

 First two bytes are MSB,LSB of inclusive length. */

	/* Some devices wrongly send LE length, and some send it two

 Don't try lengths of 0x100 and 0x200 as 1 and 2 */

		/* Some devices don't truly implement Device ID, but

		 * just return constant nibble forever. This catches

	/* Try to respect the given ID length despite all the bugs in

	 * the ID length. Read according to shortest possible ID

		/* This might end reading the Device ID too

		 * soon. Hopefully the needed fields were already in

		 * the first 256 bytes or so that we must have read so

 Buffer not large enough, read to end of buffer. */

		/* Read the whole ID since some devices would not

		 * otherwise give back the Device ID from beginning

	/* In addition, there are broken devices out there that don't

	   even finish off with a semi-colon. We do not need to care

 Get Std 1284 Device ID. */

	/* Negotiate to compatibility mode, and then to device ID

	 * mode. (This so that we start form beginning of device ID if

 SPDX-License-Identifier: GPL-2.0

/* Sysctl interface for parport devices.

 * 

 * Authors: David Campbell

 *          Tim Waugh <tim@cyberelk.demon.co.uk>

 *          Philip Blundell <philb@gnu.org>

 *          Andrea Arcangeli

 *          Riccardo Facchetti <fizban@tin.it>

 *

 * based on work by Grant Guenther <grant@torque.net>

 *              and Philip Blundell

 *

 * Cleaned up include files - Russell King <linux@arm.uk.linux.org>

 can't happen anyway */

 permissions stop this */

 IEEE1284.3 support. */

 permissions prevent this anyway */

 permissions prevent this anyway */

 permissions prevent this anyway */

 permissions prevent this anyway */

 IEEE 1284 support */

 no sysctl or no procfs*/

 SPDX-License-Identifier: GPL-2.0-only

/* linux/drivers/parport/parport_ax88796.c

 *

 * (c) 2005,2006 Simtec Electronics

 *	Ben Dooks <ben@simtec.co.uk>

 initialise the port controls */

 request irq */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Sony MemoryStick Pro storage support

 *

 *  Copyright (C) 2007 Alex Dubov <oakad@yahoo.com>

 *

 * Special thanks to Carlos Corbacho for providing various MemoryStick cards

 * that made this driver possible.

	/* Default request setup function for data access method preferred by

	 * this host instance.

** Block device ***/

** Information ***/

** Protocol handlers ***/

/*

 * Functions prefixed with "h_" are protocol callbacks. They can be called from

 * interrupt context. Return value of 0 means that request processing is still

 * ongoing, while special error value of -EAGAIN means that current request is

 * finished (and request processor should come back some time later).

** Transfer setup functions for different access methods. ***/

/** Setup data transfer request for SET_CMD TPC with arguments in card

 *  registers.

 *

 *  @card    Current media instance

 *  @offset  Target data offset in bytes

 *  @length  Required transfer length in bytes.

 ISO C90 warning precludes direct initialization for now. */

** Data transfer ***/

 Nothing to do - not really an error */

** Initialization ***/

/* Memory allocated for attributes by this function should be freed by

 * mspro_block_data_clear, no matter if the initialization process succeeded

 * or failed.

	/* While normally physical device offsets, represented here by

	 * attr_offset and attr_len will be of large numeric types, we can be

	 * sure, that attributes are close enough to the beginning of the

	 * device, to save ourselves some trouble.

 CONFIG_MEMSTICK_UNSAFE_RESUME */

 CONFIG_PM */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  ms_block.c - Sony MemoryStick (legacy) storage support



 *  Copyright (C) 2013 Maxim Levitsky <maximlevitsky@gmail.com>

 *

 * Minor portions of the driver were copied from mspro_block.c which is

 * Copyright (C) 2007 Alex Dubov <oakad@yahoo.com>

/*

 * Copies section of 'sg_from' starting from offset 'offset' and with length

 * 'len' To another scatterlist of to_nents enties

/*

 * Compares section of 'sg' starting from offset 'offset' and with length 'len'

 * to linear buffer of length 'len' at address 'buffer'

 * Returns 0 if equal and  -1 otherwice

/* Get zone at which block with logical address 'lba' lives

 * Flash is broken into zones.

 * Each zone consists of 512 eraseblocks, out of which in first

 * zone 494 are used and 496 are for all following zones.

 * Therefore zone #0 hosts blocks 0-493, zone #1 blocks 494-988, etc...

 Get zone of physical block. Trivial */

 Debug test to validate free block counts */

 Mark physical block as used */

 No races because all IO is single threaded */

 Mark physical block as free */

 No races because all IO is single threaded */

 Invalidate current register window */

 Start a state machine */

 State machines call that to exit */

 Invalidate reg window on errors */

 read INT register */

 Read a register */

 Write a card register */

 Handler for absence of IO */

/*

 * This function is a handler for reads of one page from device.

 * Writes output to msb->current_sg, takes sector address from msb->reg.param

 * Can also be used to read extra data only. Set params accordintly.

		/* msb_write_regs sometimes "fails" because it needs to update

		 * the reg window, and thus it returns request for that.

		 * Then we stay in this state and retry

		/* If dont actually need to send the int read request (only in

		 * serial mode), then just fall through

 read the status register to understand source of the INT_ERR */

 Skip that state if we only read the oob */

/*

 * Handler of writes of exactly one block.

 * Takes address from msb->regs.param.

 * Writes same extra data to blocks, also taken

 * from msb->regs.extra

 * Returns -EBADMSG if write fails due to uncorrectable error, or -EIO if

 * device refuses to take the command or something else

	/* HACK: Jmicon handling of TPCs between 8 and

	 *	sizeof(memstick_request.data) is broken due to hardware

	 *	bug in PIO mode that is used for these TPCs

	 *	Therefore split the write

 errors mean out of here, and fast... */

 for last page we need to poll CED */

 for non-last page we need BREQ before writing next chunk */

/*

 * This function is used to send simple IO requests to device that consist

 * of register write + command

 HACK: see h_msb_write_block */

 write param register*/

 Small handler for card reset */

 This handler is used to do serial->parallel switch */

 Set the parallel interface on memstick side */

		 /* Set parallel interface on our side + send a dummy request

		  * to see if card responds

 Reset the card, to guard against hw errors beeing treated as bad blocks */

 Reset the card */

 Set parallel mode */

 Attempts to switch interface to parallel mode */

 Changes overwrite flag on a page */

 Erases one physical block */

 Reads one page from device */

 Mark bad pages */

 Reads oob of page only */

 Reads a block and compares it with data contained in scatterlist orig_sg */

 Writes exectly one block + oob */

		/* Sector we just wrote to is assumed erased since its pba

		 * was erased. If it wasn't erased, write will succeed

		 * and will just clear the bits that were set in the block

		 * thus test that what we have written,

		 * matches what we expect.

		 * We do trust the blocks that we erased

 Finds a free block for write replacement */

 Converts endiannes in the boot block for easy use */

 Read the buffer */

 Process the bad block table */

 can't trust the page if we can't read the oob */

 Skip bad blocks */

 Skip system/drm blocks */

 Erase temporary tables */

 Block has LBA not according to zoning*/

 No collisions - great */

 Read all missing pages in cache */

 Bad pages are copied with 00 page status */

 Write the cache now */

 Mark invalid pages */

 If we need to write different block */

/* Emulated geometry table

 * This table content isn't that importaint,

 * One could put here different values, providing that they still

 * cover whole disk.

 * 64 MB entry is what windows reports for my 64M memstick

        size sectors cylynders  heads */

 Load information about the card */

	/* Due to a bug in Jmicron driver written by Alex Dubov,

	 * its serial mode barely works,

	 * so we switch to parallel mode right away

 Read the boot page */

 Save intersting attributes from boot page */

 this isn't supported by linux at all, anyway*/

 Now we can switch the interface */

 Read the bad block table */

 *drum roll* Scan the media */

 process the request */

set of used disk numbers */

 protects against races in open/release */

 Kick cache flush anyway, its harmless */

 Registers the block device */

 Take care of unhandled + new requests from now on */

 Remove the disk */

 CONFIG_PM */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Sony MemoryStick support

 *

 *  Copyright (C) 2007 Alex Dubov <oakad@yahoo.com>

 *

 * Special thanks to Carlos Corbacho for providing various MemoryStick cards

 * that made this driver possible.

 CONFIG_PM */

/**

 * memstick_detect_change - schedule media detection on memstick host

 * @host - host to use

/**

 * memstick_next_req - called by host driver to obtain next request to process

 * @host - host to use

 * @mrq - pointer to stick the request to

 *

 * Host calls this function from idle state (*mrq == NULL) or after finishing

 * previous request (*mrq should point to it). If previous request was

 * unsuccessful, it is retried for predetermined number of times. Return value

 * of 0 means that new request was assigned to the host.

/**

 * memstick_new_req - notify the host that some requests are pending

 * @host - host to use

/**

 * memstick_init_req_sg - set request fields needed for bulk data transfer

 * @mrq - request to use

 * @tpc - memstick Transport Protocol Command

 * @sg - TPC argument

/**

 * memstick_init_req - set request fields needed for short data transfer

 * @mrq - request to use

 * @tpc - memstick Transport Protocol Command

 * @buf - TPC argument buffer

 * @length - TPC argument size

 *

 * The intended use of this function (transfer of data items several bytes

 * in size) allows us to just copy the value between request structure and

 * user supplied buffer.

/*

 * Functions prefixed with "h_" are protocol callbacks. They can be called from

 * interrupt context. Return value of 0 means that request processing is still

 * ongoing, while special error value of -EAGAIN means that current request is

 * finished (and request processor should come back some time later).

/**

 * memstick_set_rw_addr - issue SET_RW_REG_ADDR request and wait for it to

 *                        complete

 * @card - media device to use

/**

 * memstick_alloc_host - allocate a memstick_host structure

 * @extra: size of the user private data to allocate

 * @dev: parent device of the host

/**

 * memstick_add_host - start request processing on memstick host

 * @host - host to use

/**

 * memstick_remove_host - stop request processing on memstick host

 * @host - host to use

/**

 * memstick_free_host - free memstick host

 * @host - host to use

/**

 * memstick_suspend_host - notify bus driver of host suspension

 * @host - host to use

/**

 * memstick_resume_host - notify bus driver of host resumption

 * @host - host to use

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  TI FlashMedia driver

 *

 *  Copyright (C) 2007 Alex Dubov <oakad@yahoo.com>

 *

 * Special thanks to Carlos Corbacho for providing various MemoryStick cards

 * that made this driver possible.

/*

 * Some control bits of TIFM appear to conform to Sony's reference design,

 * so I'm just assuming they all are.

 Hardware flags */

 Called from interrupt handler */

 Called from interrupt handler */

 also affected by media detection mechanism */

 CONFIG_PM */

 SPDX-License-Identifier: GPL-2.0-only

/* Realtek USB Memstick Card Interface driver

 *

 * Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.

 *

 * Author:

 *   Roger Tseng <rogerable@realtek.com>

 Print MS host internal registers */

 MS_CFG to MS_INT_REG */

 CARD_SHARE_MODE to CARD_GPIO */

 CARD_PULL_CTLx */

 CARD_DATA_SOURCE, CARD_SELECT, CARD_CLK_EN, CARD_PWR_CTL */

 power-on delay */

	/* Since we use rtsx_usb's resume callback to runtime resume its

	 * children to implement remote wakeup signaling, this causes

	 * rtsx_usb_ms' runtime resume callback runs after its suspend

	 * callback:

	 * rtsx_usb_ms_suspend()

	 * rtsx_usb_resume()

	 *   -> rtsx_usb_ms_runtime_resume()

	 *     -> memstick_detect_change()

	 *

	 * rtsx_usb_suspend()

	 *

	 * To avoid this, skip runtime resume/suspend if system suspend is

	 * underway.

 CONFIG_PM_SLEEP */

 CONFIG_PM */

 Check pending MS card changes */

 Clear the pending */

	/* Balance possible unbalanced usage count

	 * e.g. unconditional module removal

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  jmb38x_ms.c - JMicron jmb38x MemoryStick card reader

 *

 *  Copyright (C) 2008 Alex Dubov <oakad@yahoo.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2010 - Maxim Levitsky

 * driver for Ricoh memstick readers

/**

 * memstick_debug_get_tpc_name - debug helper that returns string for

 * a TPC number

 Read a register*/

 Write a register */

 Reads a big endian DWORD register */

 Writes a big endian DWORD register */

 Set specific bits in a register (little endian) */

 Clear specific bits in a register (little endian) */

 Wait for status bits while checking for errors */

 Enable/disable device */

 Power up the card */

 Perform a reset */

 Power down the card */

 Set serial/parallel mode */

 Set serial mode */

 This setting should be set _before_ switch TPC */

 Set the parallel mode now */

 Perform a controller reset without powering down the card */

 Disable all hardware interrupts */

 Disable & ACK all interrupts */

 Tests if there is an CRC error */

 Ensure that FIFO is ready for use */

 Activates the DMA transfer from to FIFO */

 Ack interrupts (just in case) + enable them */

 Set DMA address */

 Enable the DMA */

 Cleanups DMA related settings */

 This is only a precation */

 Test if hardware supports DMA */

 Transfers fifo contents in/out using DMA */

 TODO: hidden assumption about nenth beeing always 1 */

 Wait for DMA completion */

/*

 * Writes the FIFO in 4 byte chunks.

 * If length isn't 4 byte aligned, rest of the data if put to a fifo

 * to be written later

 * Use r592_flush_fifo_write to flush that fifo when writing for the

 * last time

 flush spill from former write */

 write full dwords */

 put remaining bytes to the spill */

 Flushes the temporary FIFO used to make aligned DWORD writes */

 intentionally ignore __must_check return code */

/*

 * Read a fifo in 4 bytes chunks.

 * If input doesn't fit the buffer, it places bytes of last dword in spill

 * buffer, so that they don't get lost on last read, just throw these away.

 Read from last spill */

 Reads dwords from FIFO */

 Transfers actual data using PIO. */

 Do the transfer fifo<->memory*/

 Write last few non aligned bytes*/

 Executes one TPC (data is read/written from small or large fifo) */

 Ensure that FIFO can hold the input data */

 Set IO direction */

 Transfer write data */

 Trigger the TPC */

 Wait for TPC completion */

 Test IO errors */

 Read data from FIFO */

	/* read INT reg. This can be shortened with shifts, but that way

 Main request processing thread */

 Reprogram chip to detect change in card state */

 eg, if card is detected, arm it to detect removal, and vice versa */

 Timer routine that fires 1 second after last card detection event, */

 Interrupt handler */

 Ack the interrupts */

 Get the IRQ status minus bits that aren't enabled */

	/* Due to limitation of memstick core, we don't look at bits that

 External inteface: set settings */

 External interface: submit requests */

 Main entry */

 Allocate memory */

 pci initialization */

 Host initialization */

 This is just a precation, so don't fail */

	/* Stop the processing thread.

 SPDX-License-Identifier: GPL-2.0-or-later

/* Realtek PCI-Express Memstick Card Interface driver

 *

 * Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.

 *

 * Author:

 *   Wei WANG <wei_wang@realsil.com.cn>

 Print MS host internal registers */

 Wait ms power stable */

 CONFIG_PM */

 CONFIG_PM */

 sentinel */

 SPDX-License-Identifier: GPL-2.0

/*

 * driver.c - device id matching, driver model, etc.

 *

 * Copyright 2002 Adam Belay <ambx1@neo.rr.com>

 we only need to compare the last 4 chars */

 Suspend callbacks */

 Hibernate callbacks */

/**

 * pnp_add_id - adds an EISA id to the specified device

 * @dev: pointer to the desired device

 * @id: pointer to an EISA id string

 SPDX-License-Identifier: GPL-2.0

/*

 * support.c - standard functions for the use of pnp protocol drivers

 *

 * Copyright 2003 Adam Belay <ambx1@neo.rr.com>

 * Copyright (C) 2008 Hewlett-Packard Development Company, L.P.

 *	Bjorn Helgaas <bjorn.helgaas@hp.com>

/**

 * pnp_is_active - Determines if a device is active based on its current

 *	resources

 * @dev: pointer to the desired PnP device

	/*

	 * I don't think this is very reliable because pnp_disable_dev()

	 * only clears out auto-assigned resources.

/*

 * Functionally similar to acpi_ex_eisa_id_to_string(), but that's

 * buried in the ACPI CA, and we can't depend on it being present.

	/*

	 * According to the specs, the first three characters are five-bit

	 * compressed ASCII, and the left-over high order bit should be zero.

	 * However, the Linux ISAPNP code historically used six bits for the

	 * first character, and there seem to be IDs that depend on that,

	 * e.g., "nEC8241" in the Linux 8250_pnp serial driver and the

	 * FreeBSD sys/pc98/cbus/sio_cbus.c driver.

 SPDX-License-Identifier: GPL-2.0

/*

 * card.c - contains functions for managing groups of PnP devices

 *

 * Copyright 2002 Adam Belay <ambx1@neo.rr.com>

 Recovery */

/**

 * pnp_add_card_id - adds an EISA id to the specified card

 * @id: pointer to a pnp_id structure

 * @card: pointer to the desired card

/**

 * pnp_add_card - adds a PnP card to the PnP Layer

 * @card: pointer to the card to add

	/* we wait until now to add devices in order to ensure the drivers

	 * will be able to use all of the related devices on the card

 match with card drivers */

/**

 * pnp_remove_card - removes a PnP card from the PnP Layer

 * @card: pointer to the card to remove

/**

 * pnp_add_card_device - adds a device to the specified card

 * @card: pointer to the card to add to

 * @dev: pointer to the device to add

/**

 * pnp_remove_card_device- removes a device from the specified card

 * @dev: pointer to the device to remove

/**

 * pnp_request_card_device - Searches for a PnP device under the specified card

 * @clink: pointer to the card link, cannot be NULL

 * @id: pointer to a PnP ID structure that explains the rules for finding the device

 * @from: Starting place to search from. If NULL it will start from the beginning.

/**

 * pnp_release_card_device - call this when the driver no longer needs the device

 * @dev: pointer to the PnP device structure

/*

 * suspend/resume callbacks

/**

 * pnp_register_card_driver - registers a PnP card driver with the PnP Layer

 * @drv: pointer to the driver to register

 this will disable auto matching */

/**

 * pnp_unregister_card_driver - unregisters a PnP card driver from the PnP Layer

 * @drv: pointer to the driver to unregister

 SPDX-License-Identifier: GPL-2.0

/*

 * system.c - a driver for reserving pnp system resources

 *

 * Some code is based on pnpbios_core.c

 * Copyright 2002 Adam Belay <ambx1@neo.rr.com>

 * (c) Copyright 2007 Hewlett-Packard Development Company, L.P.

 *	Bjorn Helgaas <bjorn.helgaas@hp.com>

 General ID for reserving resources */

 memory controller */

	/*

	 * Failures at this point are usually harmless. pci quirks for

	 * example do reserve stuff they know about too, so we may well

	 * have double reservations.

 disabled */

			/*

			 * Below 0x100 is only standard PC hardware

			 * (pics, kbd, timer, dma, ...)

			 * We should not get resource conflicts there,

			 * and the kernel reserves these anyway

			 * (see arch/i386/kernel/setup.c).

			 * So, do nothing

 invalid */

/*

 * Reserve motherboard resources after PCI claim BARs,

 * but before PCI assign resources for uninitialized PCI devices

 SPDX-License-Identifier: GPL-2.0

/*

 * resource.c - Contains functions for registering and analyzing resource information

 *

 * based on isapnp.c resource management (c) Jaroslav Kysela <perex@perex.cz>

 * Copyright 2003 Adam Belay <ambx1@neo.rr.com>

 * Copyright (C) 2008 Hewlett-Packard Development Company, L.P.

 *	Bjorn Helgaas <bjorn.helgaas@hp.com>

 reserve (don't use) some IRQ */

 reserve (don't use) some DMA */

 reserve (don't use) some I/O region */

 reserve (don't use) some memory region */

/*

 * option registration

/*

 * resource validity checking

 Two ranges conflict if one doesn't end before the other starts */

 if the resource doesn't exist, don't complain about it */

	/* check if the resource is already in use, skip if the

 check if the resource is reserved */

 check for internal conflicts */

 check for conflicts with other pnp devices */

 if the resource doesn't exist, don't complain about it */

	/* check if the resource is already in use, skip if the

 check if the resource is reserved */

 check for internal conflicts */

 check for conflicts with other pnp devices */

	/*

	 * See pci_setup_device() and ata_pci_sff_activate_host() for

	 * similar IDE legacy detection.

 discard revision ID */

		/*

		 * Unless both channels are native-PCI mode only,

		 * treat the compatibility IRQs as busy.

 if the resource doesn't exist, don't complain about it */

 check if the resource is valid */

 check if the resource is reserved */

 check for internal conflicts */

 check if the resource is being used by a pci device */

	/* check if the resource is already in use, skip if the

 check for conflicts with other pnp devices */

 if the resource doesn't exist, don't complain about it */

 check if the resource is valid */

 check if the resource is reserved */

 check for internal conflicts */

	/* check if the resource is already in use, skip if the

 check for conflicts with other pnp devices */

 CONFIG_ISA_DMA_API */

/*

 * Determine whether the specified resource is a possible configuration

 * for this device.

 format is: pnp_reserve_irq=irq1[,irq2] .... */

 format is: pnp_reserve_dma=dma1[,dma2] .... */

 format is: pnp_reserve_io=io1,size1[,io2,size2] .... */

 format is: pnp_reserve_mem=mem1,size1[,mem2,size2] .... */

 SPDX-License-Identifier: GPL-2.0

/*

 * manager.c - Resource Management, Conflict Resolution, Activation and Disabling of Devices

 *

 * based on isapnp.c resource management (c) Jaroslav Kysela <perex@perex.cz>

 * Copyright 2003 Adam Belay <ambx1@neo.rr.com>

 * Copyright (C) 2008 Hewlett-Packard Development Company, L.P.

 *	Bjorn Helgaas <bjorn.helgaas@hp.com>

 when the resource already exists, set its resource bits from rule */

 ??? rule->flags restricted to 8 bits, all tests bogus ??? */

 IRQ priority: this table is good for i386 */

 TBD: need check for >16 IRQ */

 DMA priority: this table is good for i386 */

 CONFIG_ISA_DMA_API */

/**

 * pnp_assign_resources - assigns resources to the device based on the specified dependent number

 * @dev: pointer to the desired device

 * @set: the dependent function number

/**

 * pnp_auto_config_dev - automatically assigns resources to a device

 * @dev: pointer to the desired device

/**

 * pnp_start_dev - low-level start of the PnP device

 * @dev: pointer to the desired device

 *

 * assumes that resources have already been allocated

/**

 * pnp_stop_dev - low-level disable of the PnP device

 * @dev: pointer to the desired device

 *

 * does not free resources

/**

 * pnp_activate_dev - activates a PnP device for use

 * @dev: pointer to the desired device

 *

 * does not validate or set resources so be careful.

 ensure resources are allocated */

/**

 * pnp_disable_dev - disables device

 * @dev: pointer to the desired device

 *

 * inform the correct pnp protocol so that resources can be used by other devices

 release the resources so that other devices can use them */

 SPDX-License-Identifier: GPL-2.0

/*

 *  This file contains quirk handling code for PnP devices

 *  Some devices do not report all their resources, and need to have extra

 *  resources added. This is most easily accomplished at initialisation time

 *  when building up the resource structure for the first time.

 *

 *  Copyright (c) 2000 Peter Denison <peterd@pnd-pc.demon.co.uk>

 *  Copyright (C) 2008 Hewlett-Packard Development Company, L.P.

 *	Bjorn Helgaas <bjorn.helgaas@hp.com>

 *

 *  Heavily based on PCI quirks handling which is

 *

 *  Copyright (c) 1999 Martin Mares <mj@ucw.cz>

	/*

	 * Add two extra ioport regions (at offset 0x400 and 0x800 from the

	 * one given) to every dependent option set.

	/*

	 * The default range on the OPL port for these devices is 0x388-0x388.

	 * Here we increase that range so that two such cards can be

	 * auto-configured.

	/*

	 * Some BIOSes have PNP motherboard devices with resources that

	 * partially overlap PCI BARs.  The PNP system driver claims these

	 * motherboard resources, which prevents the normal PCI driver from

	 * requesting them later.

	 *

	 * This patch disables the PNP resources that conflict with PCI BARs

	 * so they won't be claimed by the PNP system driver.

				/*

				 * If the PNP region doesn't overlap the PCI

				 * region at all, there's no problem.

				/*

				 * If the PNP region completely encloses (or is

				 * at least as large as) the PCI region, that's

				 * also OK.  For example, this happens when the

				 * PNP device describes a bridge with PCI

				 * behind it.

				/*

				 * Otherwise, the PNP region overlaps *part* of

				 * the PCI region, and that might prevent a PCI

				 * driver from requesting its resources.

 Device IDs of parts that have 32KB MCH space */

 Ivy Bridge */

 Haswell-ULT */

 Haswell */

 Broadwell */

	/*

	 * MCHBAR is not an architected PCI BAR, so MCH space is usually

	 * reported as a PNP0C02 resource.  The MCH space was originally

	 * 16KB, but is 32KB in newer parts.  Some BIOSes still report a

	 * PNP0C02 resource that is only 16KB, which means the rest of the

	 * MCH space is consumed but unreported.

	/*

	 * Read MCHBAR for Host Member Mapped Register Range Base

	 * https://www-ssl.intel.com/content/www/us/en/processors/core/4th-gen-core-family-desktop-vol-2-datasheet

	 * Sec 3.1.12.

 no overlap */

 exact match */

/*

 *  PnP Quirks

 *  Cards or devices that need some tweaking due to incomplete resource info

 Soundblaster awe io port quirk */

 CMI 8330 interrupt and dma fix */

 Soundblaster audio device io port range quirk */

 Add IRQ-optional MPU options */

 PnP resources that might overlap PCI BARs */

 SPDX-License-Identifier: GPL-2.0

/*

 * core.c - contains all core device and protocol registration functions

 *

 * Copyright 2002 Adam Belay <ambx1@neo.rr.com>

/*

 * ACPI or PNPBIOS should tell us about all platform devices, so we can

 * skip some blind probes.  ISAPNP typically enumerates only plug-in ISA

 * devices, not built-in things like COM ports.

/**

 * pnp_register_protocol - adds a pnp protocol to the pnp layer

 * @protocol: pointer to the corresponding pnp_protocol structure

 *

 *  Ex protocols: ISAPNP, PNPBIOS, etc

 assign the lowest unused number */

/**

 * pnp_unregister_protocol - removes a pnp protocol from the pnp layer

 * @protocol: pointer to the corresponding pnp_protocol structure

/*

 * pnp_add_device - adds a pnp device to the pnp layer

 * @dev: pointer to dev to add

 *

 *  adds to driver model, name database, fixups, interface, etc.

 SPDX-License-Identifier: GPL-2.0

/*

 * interface.c - contains everything related to the user interface

 *

 * Some code, especially possible resource dumping is based on isapnp_proc.c (c) Jaroslav Kysela <perex@perex.cz>

 * Copyright 2002 Adam Belay <ambx1@neo.rr.com>

 * Copyright (C) 2008 Hewlett-Packard Development Company, L.P.

 *	Bjorn Helgaas <bjorn.helgaas@hp.com>

 pointer to begin of buffer */

 current position in buffer */

 current size */

 total length of buffer */

 stop flag */

 error code */

 TBD: allow for disabled resources */

 TBD: allow for additional flags, e.g., IORESOURCE_WINDOW */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * pnpacpi -- PnP ACPI driver

 *

 * Copyright (c) 2004 Matthieu Castet <castet.matthieu@free.fr>

 * Copyright (c) 2004 Li Shaohua <shaohua.li@intel.com>

 * Copyright (C) 2008 Hewlett-Packard Development Company, L.P.

 *	Bjorn Helgaas <bjorn.helgaas@hp.com>

 Set a default value ? */

 Set a default value ? */

/*

 * Allocated Resources

/*

 * Device CSRs that do not appear in PCI config space should be described

 * via ACPI.  This would normally be done with Address Space Descriptors

 * marked as "consumer-only," but old versions of Windows and Linux ignore

 * the producer/consumer flag, so HP invented a vendor-defined resource to

 * describe the location and size of CSR space.

 byte_length includes uuid_subtype and uuid */

			/*

			 * The IRQ encoder puts a single interrupt in each

			 * descriptor, so if a _CRS descriptor has more than

			 * one interrupt, we won't be able to re-encode it.

		/*

		 * If the resource is GpioInt() type then extract the IRQ

		 * from GPIO resource and fill it into IRQ resource type.

 serial bus connections (I2C/SPI/UART) are not pnp */

/*

 * Set resource

 resource will pointer the end resource now */

 Note: pnp_assign_dma will copy pnp_dma->flags into p->flags */

 Note: pnp_assign_port copies pnp_port->flags into p->flags */

 Correct? */

 Note: pnp_assign_mem copies pnp_mem->flags into p->flags */

 pnpacpi_build_resource_template allocates extra mem */

 other type */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * pnpacpi -- PnP ACPI driver

 *

 * Copyright (c) 2004 Matthieu Castet <castet.matthieu@free.fr>

 * Copyright (c) 2004 Li Shaohua <shaohua.li@intel.com>

/*

 * Compatible Device IDs

 acpi_unregister_gsi(pnp_irq(dev, 0)); */

 continue even if acpi_device_set_power() fails */

		/*

		 * acpi_device_set_power() can fail (keyboard port can't be

		 * powered-down?), and in any case, our return value is ignored

		 * by pnp_bus_suspend().  Hence we don't revert the wakeup

		 * setting if the set_power fails.

 Skip devices that are already bound */

	/*

	 * If a PnPacpi device is not present , the device

	 * driver should not be loaded.

 .enabled means the device can decode the resources */

 clear out the damaged flags */

 SPDX-License-Identifier: GPL-2.0

/*

 * bioscalls.c - the lowlevel layer of the PnPBIOS driver

/*

 * These are some opcodes for a "static asmlinkage"

 * As this code is *not* executed inside the linux kernel segment, but in a

 * alias at offset 0, we need a far return that can not be compiled by

 * default (please, prove me wrong! this is *really* ugly!)

 * This is the only way to get the bios to return into the kernel code,

 * because the bios code runs in 16 bit protected mode and therefore can only

 * return to the caller if the call is within the first 64kB, and the linux

 * kernel begins at offset 3GB...

/*

 * At some point we want to use this stack frame pointer to unwind

 * after PnP BIOS oopses.

/*

 * Support Functions

	/*

	 * PnP BIOSes are generally not terribly re-entrant.

	 * Also, don't rely on them to save everything correctly.

 On some boxes IRQ's during PnP BIOS calls are deadly.  */

 The lock prevents us bouncing CPU here */

 If we get here and this is set then the PnP BIOS faulted on us. */

/*

 * PnP BIOS Low Level Calls

/*

 * Call PnP BIOS with function 0x00, "get number of system device nodes"

/*

 * Note that some PnP BIOSes (e.g., on Sony Vaio laptops) die a horrible

 * death if they are asked to access the "current" configuration.

 * Therefore, if it's a matter of indifference, it's better to call

 * get_dev_node() and set_dev_node() with boot=1 rather than with boot=0.

/* 

 * Call PnP BIOS with function 0x01, "get system device node"

 * Input: *nodenum = desired node,

 *        boot = whether to get nonvolatile boot (!=0)

 *               or volatile current (0) config

 * Output: *nodenum=next node or 0xff if no more nodes

/*

 * Call PnP BIOS with function 0x02, "set system device node"

 * Input: *nodenum = desired node, 

 *        boot = whether to set nonvolatile boot (!=0)

 *               or volatile current (0) config

 Update devlist */

/*

 * Call PnP BIOS with function 0x05, "get docking station information"

/*

 * Call PnP BIOS with function 0x0a, "get statically allocated resource

 * information"

/*

 * Call PnP BIOS with function 0x40, "get isa pnp configuration structure"

/*

 * Call PnP BIOS with function 0x41, "get ESCD info"

/*

 * Call PnP BIOS function 0x42, "read ESCD"

 * nvram_base is determined by calling escd_info

 SPDX-License-Identifier: GPL-2.0

/*

 * rsparser.c - parses and encodes pnpbios resource data streams

 CONFIG_PCI */

 standard resource tags */

/*

 * Resource Data Stream Format:

 *

 * Allocated Resources (required)

 * end tag ->

 * Resource Configuration Options (optional)

 * end tag ->

 * Compitable Device IDs (optional)

 * final end tag ->

/*

 * Allocated Resources

 determine the type of tag */

 large tag */

 small tag */

 ignore this for now */

 do nothing */

 do nothing */

 an unknown tag */

 continue to the next tag */

/*

 * Resource Configuration Options

 determine the type of tag */

 large tag */

 small tag */

 do nothing */

 an unknown tag */

 continue to the next tag */

/*

 * Compatible Device IDs

 determine the type of tag */

 large tag */

 small tag */

 compatible ID */

 an unknown tag */

 continue to the next tag */

/*

 * Allocated Resource Encoding

 determine the type of tag */

 large tag */

 small tag */

 do nothing */

 an unknown tag */

 continue to the next tag */

/*

 * Core Parsing Functions

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * pnpbios -- PnP BIOS driver

 *

 * This driver provides access to Plug-'n'-Play services provided by

 * the PnP BIOS firmware, described in the following documents:

 *   Plug and Play BIOS Specification, Version 1.0A, 5 May 1994

 *   Plug and Play BIOS Clarification Paper, 6 October 1994

 *     Compaq Computer Corporation, Phoenix Technologies Ltd., Intel Corp.

 * 

 * Originally (C) 1998 Christian Schmidt <schmidt@digadd.de>

 * Modifications (C) 1998 Tom Lees <tom@lpsg.demon.co.uk>

 * Minor reorganizations by David Hinds <dahinds@users.sourceforge.net>

 * Further modifications (C) 2001, 2002 by:

 *   Alan Cox <alan@redhat.com>

 *   Thomas Hood

 *   Brian Gerst <bgerst@didntduck.org>

 *

 * Ported to the PnP Layer and several additional improvements (C) 2002

 * by Adam Belay <ambx1@neo.rr.com>

/* Change Log

 *

 * Adam Belay - <ambx1@neo.rr.com> - March 16, 2003

 * rev 1.01	Only call pnp_bios_dev_node_info once

 *		Added pnpbios_print_status

 *		Added several new error messages and info messages

 *		Added pnpbios_interface_attach_device

 *		integrated core and proc init system

 *		Introduced PNPMODE flags

 *		Removed some useless includes

/*

 *

 * PnP BIOS INTERFACE

 *

/*

 *

 * DOCKING FUNCTIONS

 *

/*

 * (Much of this belongs in a shared routine somewhere)

	/* FIXME: if there are actual users of this, it should be

	 * integrated into the driver core and use the usual infrastructure

	 * like sysfs and uevents

 minimal command environment */

 hint that policy agent should enter no-stdout debug mode */

	/* extensible set of named bus-specific parameters,

	 * supporting multiple driver selection algorithms.

 action:  add, remove */

 Report the ident for the dock */

/*

 * Poll the PnP docking at regular intervals

		/*

		 * Poll every 2 seconds

			/*

			 * No dock to manage

 large tag */

 PnP Layer support */

 check if the device is already added */

 clear out the damaged flags */

		/* eventually we will want to use PNPMODE_STATIC here but for now

		 * dynamic will help us catch buggy bioses to add to the blacklist.

/*

 *

 * INIT AND EXIT

 *

 PnP BIOS signature: "$PnP" */

	/*

	 * Search the defined area (0xf0000-0xffff0) for a valid PnP BIOS

	 * structure and, if one is found, sets up the selectors and

	 * entry points

 PnPBIOS GPF on boot */

 PnPBIOS GPF on boot */

 CONFIG_ACPI */

 scan the system for pnpbios support */

 make preparations for bios calls */

 read the node info */

 register with the pnp layer */

 start the proc interface */

 scan for pnpbios devices */

 Start the kernel thread later: */

 SPDX-License-Identifier: GPL-2.0

/*

 * /proc/bus/pnp interface for Plug and Play devices

 *

 * Written by David Hinds, dahinds@users.sourceforge.net

 * Modified by Thomas Hood

 *

 * The .../devices and .../<node> and .../boot/<node> files are

 * utilized by the lspnp and setpnp utilities, supplied with the

 * pcmcia-cs package.

 *     http://pcmcia-cs.sourceforge.net

 *

 * The .../escd file is utilized by the lsescd utility written by

 * Gunther Mayer.

 *

 * The .../legacy_device_resources file is not used yet.

 *

 * The other files are human-readable.

 sanity check */

 sanity check */

/*

 * When this is called, pnpbios functions are assumed to

 * work and the pnpbios_dont_use_current_config flag

 * should already have been set to the appropriate value

 SPDX-License-Identifier: GPL-2.0

/*

 * compat.c - A series of functions to make it easier to convert drivers that use

 *            the old isapnp APIs. If possible use the new APIs instead.

 *

 * Copyright 2002 Adam Belay <ambx1@neo.rr.com>

 look for a logical device from all cards */

 something is wrong */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  ISA Plug & Play support

 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>

 *

 *  Changelog:

 *  2000-01-01	Added quirks handling for buggy hardware

 *		Peter Denison <peterd@pnd-pc.demon.co.uk>

 *  2000-06-14	Added isapnp_probe_devs() and isapnp_activate_dev()

 *		Christoph Hellwig <hch@infradead.org>

 *  2001-06-03  Added release_region calls to correspond with

 *		request_region calls when a failure occurs.  Also

 *		added KERN_* constants to printk() calls.

 *  2001-11-07  Added isapnp_{,un}register_driver calls along the lines

 *              of the pci driver interface

 *              Kai Germaschewski <kai.germaschewski@gmx.de>

 *  2002-06-06  Made the use of dma channel 0 configurable

 *              Gerald Teschl <gerald.teschl@univie.ac.at>

 *  2002-10-06  Ported to PnP Layer - Adam Belay <ambx1@neo.rr.com>

 *  2003-08-11	Resource Management Updates - Adam Belay <ambx1@neo.rr.com>

 Disable ISA PnP */

 Read Data Port */

 reset all PnP cards (deactivate) */

 verbose mode */

 short tags */

 long tags */

 Logical device control and configuration registers */

 byte */

 4 * dword */

 8 * word */

 2 * word */

 2 * byte */

/*

 * Sizes of ISAPNP logical device configuration register sets.

 * See PNP-ISA-v1.0a.pdf, Appendix A.

 some prototypes */

 place all pnp cards in wait-for-key state */

 PRESDI */

 minimum is 4 */

		/*

		 *      We cannot use NE2000 probe spaces for ISAPnP or we

		 *      will lock up machines.

 Set read port address */

/*

 *	Perform an isolation. The port selection code now tries to avoid

 *	"dangerous to read" ports.

 Control: reset CSN and conditionally everything else too */

/*

 *  Isolate (assign uniqued CSN) to all ISA PnP devices.

/*

 *  Read one tag from stream.

 invalid tag */

 large item */

 probably invalid data */

/*

 *  Skip specified number of bytes from stream.

/*

 *  Parse logical device tag.

/*

 *  Add IRQ resource to resources list.

/*

 *  Add DMA resource to resources list.

/*

 *  Add port resource to resources list.

/*

 *  Add fixed port resource to resources list.

/*

 *  Add memory resource to resources list.

/*

 *  Add 32-bit memory resource to resources list.

/*

 *  Add 32-bit fixed memory resource to resources list.

/*

 *  Parse card name for ISA PnP device.

 clean whitespace from end of string */

/*

 *  Parse resource map for logical device.

 silently ignore */

 who use unicode for hardware identification? */

/*

 *  Parse resource map for ISA PnP card.

 silently ignore */

 who use unicode for hardware identification? */

/*

 *  Build device list for all present ISA PnP devices.

/*

 *  Basic configuration routines.

 to avoid malfunction when the isapnptools package is used */

 we must set RDP to our value again */

 it is possible to set RDP only in the isolation phase */

   Jens Thoms Toerring <Jens.Toerring@physik.fu-berlin.de> */

 clear CSN of card */

 is this necessary? */

 bring card into sleep state */

 bring card into isolation state */

 reset the RDP port */

 delay 1000us */

 reset CSN to previous value */

 is this necessary? */

/*

 *  Initialization.

 FIXME: We aren't handling 32bit mems properly here */

	/*

	 *      Print a message. The existing ISAPnP code is hanging machines

	 *      so let the user know where.

 format is: noisapnp */

 format is: isapnp=rdp,reset,skip_pci_scan,verbose */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  ISA Plug & Play support

 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>

 SPDX-License-Identifier: GPL-2.0

/*

 * NVM helpers

 *

 * Copyright (C) 2020, Intel Corporation

 * Author: Mika Westerberg <mika.westerberg@linux.intel.com>

/**

 * tb_nvm_alloc() - Allocate new NVM structure

 * @dev: Device owning the NVM

 *

 * Allocates new NVM structure with unique @id and returns it. In case

 * of error returns ERR_PTR().

/**

 * tb_nvm_add_active() - Adds active NVMem device to NVM

 * @nvm: NVM structure

 * @size: Size of the active NVM in bytes

 * @reg_read: Pointer to the function to read the NVM (passed directly to the

 *	      NVMem device)

 *

 * Registers new active NVmem device for @nvm. The @reg_read is called

 * directly from NVMem so it must handle possible concurrent access if

 * needed. The first parameter passed to @reg_read is @nvm structure.

 * Returns %0 in success and negative errno otherwise.

/**

 * tb_nvm_write_buf() - Write data to @nvm buffer

 * @nvm: NVM structure

 * @offset: Offset where to write the data

 * @val: Data buffer to write

 * @bytes: Number of bytes to write

 *

 * Helper function to cache the new NVM image before it is actually

 * written to the flash. Copies @bytes from @val to @nvm->buf starting

 * from @offset.

/**

 * tb_nvm_add_non_active() - Adds non-active NVMem device to NVM

 * @nvm: NVM structure

 * @size: Size of the non-active NVM in bytes

 * @reg_write: Pointer to the function to write the NVM (passed directly

 *	       to the NVMem device)

 *

 * Registers new non-active NVmem device for @nvm. The @reg_write is called

 * directly from NVMem so it must handle possible concurrent access if

 * needed. The first parameter passed to @reg_write is @nvm structure.

 * Returns %0 in success and negative errno otherwise.

/**

 * tb_nvm_free() - Release NVM and its resources

 * @nvm: NVM structure to release

 *

 * Releases NVM and the NVMem devices if they were registered.

/**

 * tb_nvm_read_data() - Read data from NVM

 * @address: Start address on the flash

 * @buf: Buffer where the read data is copied

 * @size: Size of the buffer in bytes

 * @retries: Number of retries if block read fails

 * @read_block: Function that reads block from the flash

 * @read_block_data: Data passsed to @read_block

 *

 * This is a generic function that reads data from NVM or NVM like

 * device.

 *

 * Returns %0 on success and negative errno otherwise.

/**

 * tb_nvm_write_data() - Write data to NVM

 * @address: Start address on the flash

 * @buf: Buffer where the data is copied from

 * @size: Size of the buffer in bytes

 * @retries: Number of retries if the block write fails

 * @write_block: Function that writes block to the flash

 * @write_block_data: Data passwd to @write_block

 *

 * This is generic function that writes data to NVM or NVM like device.

 *

 * Returns %0 on success and negative errno otherwise.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Thunderbolt driver - NHI driver

 *

 * The NHI (native host interface) is the pci device that allows us to send and

 * receive frames from the thunderbolt bus.

 *

 * Copyright (c) 2014 Andreas Noever <andreas.noever@gmail.com>

 * Copyright (C) 2018, Intel Corporation

/*

 * Minimal number of vectors when we use MSI-X. Two for control channel

 * Rx/Tx and the rest four are for cross domain DMA paths.

 ms */

/*

 * ring_interrupt_active() - activate/deactivate interrupts for a single ring

 *

 * ring->nhi->lock must be held.

			/*

			 * Ask the hardware to clear interrupt status

			 * bits automatically since we already know

			 * which interrupt was triggered.

/*

 * nhi_disable_interrupts() - disable interrupts for all rings

 *

 * Use only during init and shutdown.

 disable interrupts */

 clear interrupt status bits */

 ring helper methods */

	/*

	 * The other 16-bits in the register is read-only and writes to it

	 * are ignored by the hardware so we can save one ioread32() by

	 * filling the read-only bits with zeroes.

 See ring_iowrite_cons() above for explanation */

/*

 * ring_write_descriptors() - post frames from ring->queue to the controller

 *

 * ring->lock is held.

/*

 * ring_work() - progress completed frames

 *

 * If the ring is shutting down then all frames are marked as canceled and

 * their callbacks are invoked.

 *

 * Otherwise we collect all completed frame from the ring buffer, write new

 * frame to the ring buffer and invoke the callbacks for the completed frames.

  Move all frames to done and mark them as canceled. */

 allow callbacks to schedule new work */

		/*

		 * The callback may reenqueue or delete frame.

		 * Do not hold on to it.

/**

 * tb_ring_poll() - Poll one completed frame from the ring

 * @ring: Ring to poll

 *

 * This function can be called when @start_poll callback of the @ring

 * has been called. It will read one completed frame from the ring and

 * return it to the caller. Returns %NULL if there is no more completed

 * frames.

 Both @nhi->lock and @ring->lock should be held */

/**

 * tb_ring_poll_complete() - Re-start interrupt for the ring

 * @ring: Ring to re-start the interrupt

 *

 * This will re-start (unmask) the ring interrupt once the user is done

 * with polling.

		/*

		 * Automatically allocate HopID from the non-reserved

		 * range 1 .. hop_count - 1.

/**

 * tb_ring_alloc_tx() - Allocate DMA ring for transmit

 * @nhi: Pointer to the NHI the ring is to be allocated

 * @hop: HopID (ring) to allocate

 * @size: Number of entries in the ring

 * @flags: Flags for the ring

/**

 * tb_ring_alloc_rx() - Allocate DMA ring for receive

 * @nhi: Pointer to the NHI the ring is to be allocated

 * @hop: HopID (ring) to allocate. Pass %-1 for automatic allocation.

 * @size: Number of entries in the ring

 * @flags: Flags for the ring

 * @e2e_tx_hop: Transmit HopID when E2E is enabled in @flags

 * @sof_mask: Mask of PDF values that start a frame

 * @eof_mask: Mask of PDF values that end a frame

 * @start_poll: If not %NULL the ring will call this function when an

 *		interrupt is triggered and masked, instead of callback

 *		in each Rx frame.

 * @poll_data: Optional data passed to @start_poll

/**

 * tb_ring_start() - enable a ring

 * @ring: Ring to start

 *

 * Must not be invoked in parallel with tb_ring_stop().

 Means 4096 */

 time releated ? */

	/*

	 * Now that the ring valid bit is set we can configure E2E if

	 * enabled for the ring.

/**

 * tb_ring_stop() - shutdown a ring

 * @ring: Ring to stop

 *

 * Must not be invoked from a callback.

 *

 * This method will disable the ring. Further calls to

 * tb_ring_tx/tb_ring_rx will return -ESHUTDOWN until ring_stop has been

 * called.

 *

 * All enqueued frames will be canceled and their callbacks will be executed

 * with frame->canceled set to true (on the callback thread). This method

 * returns only after all callback invocations have finished.

	/*

	 * schedule ring->work to invoke callbacks on all remaining frames.

/*

 * tb_ring_free() - free ring

 *

 * When this method returns all invocations of ring->callback will have

 * finished.

 *

 * Ring must be stopped.

 *

 * Must NOT be called from ring_frame->callback!

	/*

	 * Dissociate the ring from the NHI. This also ensures that

	 * nhi_interrupt_work cannot reschedule ring->work.

	/*

	 * ring->work can no longer be scheduled (it is scheduled only

	 * by nhi_interrupt_work, ring_stop and ring_msix). Wait for it

	 * to finish before freeing the ring.

/**

 * nhi_mailbox_cmd() - Send a command through NHI mailbox

 * @nhi: Pointer to the NHI structure

 * @cmd: Command to send

 * @data: Data to be send with the command

 *

 * Sends mailbox command to the firmware running on NHI. Returns %0 in

 * case of success and negative errno in case of failure.

/**

 * nhi_mailbox_mode() - Return current firmware operation mode

 * @nhi: Pointer to the NHI structure

 *

 * The function reads current firmware operation mode using NHI mailbox

 * registers and returns it to the caller.

 Suppress uninitialized usage warning. */

 current interrupt type 0: TX, 1: RX, 2: RX overflow */

	/*

	 * Starting at REG_RING_NOTIFY_BASE there are three status bitfields

	 * (TX, RX, RX overflow). We iterate over the bits and read a new

	 * dwords as required. The registers are cleared on read.

	/*

	 * If power rails are sustainable for wakeup from S4 this

	 * property is set by the BIOS.

 Throttling is specified in 256ns increments */

	/*

	 * Configure interrupt throttling for all vectors even if we

	 * only use few.

	/*

	 * Check that the device is still there. It may be that the user

	 * unplugged last device which causes the host controller to go

	 * away on PCs.

	/*

	 * If we were runtime suspended when system suspend started,

	 * schedule runtime resume now. It should bring the domain back

	 * to functional state.

	/*

	 * We have to release the irq before calling flush_work. Otherwise an

	 * already executing IRQ handler could call schedule_work again.

	/*

	 * Intel hardware supports auto clear of the interrupt status

	 * reqister right after interrupt is being issued.

 In case someone left them on. */

	/*

	 * The NHI has 16 MSI-X vectors or a single MSI. We first try to

	 * get all MSI-X vectors and if we succeed, each ring will have

	 * one MSI-X. If for some reason that does not work out, we

	 * fallback to a single MSI.

	/*

	 * USB4 case is simple. If we got control of any of the

	 * capabilities, we use software CM.

	/*

	 * Either firmware based CM is running (we did not get control

	 * from the firmware) or this is pre-USB4 PC so try first

	 * firmware CM and then fallback to software CM.

 cannot fail - table is allocated bin pcim_iomap_regions */

		/*

		 * At this point the RX/TX rings might already have been

		 * activated. Do a proper shutdown.

/*

 * The tunneled pci bridges are siblings of us. Use resume_noirq to reenable

 * the tunnels asap. A corresponding pci quirk blocks the downstream bridges

 * resume_noirq until we are done.

	.freeze_noirq = nhi_freeze_noirq,  /*

					    * we just disable hotplug, the

					    * pci-tunnels stay alive.

	/*

	 * We have to specify class, the TB bridges use the same device and

	 * vendor (sub)id on gen 1 and gen 2 controllers.

 Thunderbolt 3 */

 Any USB4 compliant host */

 SPDX-License-Identifier: GPL-2.0

/*

 * Thunderbolt driver - switch/port utility functions

 *

 * Copyright (c) 2014 Andreas Noever <andreas.noever@gmail.com>

 * Copyright (C) 2018, Intel Corporation

 Switch NVM support */

/*

 * Hold NVM authentication failure status per switch This information

 * needs to stay around even when the switch gets power cycled so we

 * keep it separately.

	/*

	 * FARB pointer must point inside the image and must at least

	 * contain parts of the digital section we will be reading here.

 Digital section start should be aligned to 4k page */

	/*

	 * Read digital section size and check that it also fits inside

	 * the image.

		/*

		 * Make sure the device ID in the image matches the one

		 * we read from the switch config space.

 Write CSS headers first */

 Skip headers in the image */

	/*

	 * Root switch NVM upgrade requires that we disconnect the

	 * existing paths first (in case it is not in safe mode

	 * already).

		/*

		 * The host controller goes away pretty soon after this if

		 * everything goes well so getting timeout is expected.

		/*

		 * Any error from update auth operation requires power

		 * cycling of the host router.

	/*

	 * From safe mode we can get out by just power cycling the

	 * switch.

 Power cycle is required */

	/*

	 * Poll here for the authentication status. It takes some time

	 * for the device to respond (we get timeout for a while). Once

	 * we get response the device needs to be power cycled in order

	 * to the new NVM to be taken into use.

	/*

	 * During host router NVM upgrade we should not allow root port to

	 * go into D3cold because some root ports cannot trigger PME

	 * itself. To be on the safe side keep the root port in D0 during

	 * the whole upgrade process.

		/*

		 * USB4 devices must support NVM operations but it is

		 * optional for hosts. Therefore we query the NVM sector

		 * size here and if it is supported assume NVM

		 * operations are implemented.

 Thunderbolt 2 and 3 devices support NVM through DMA port */

	/*

	 * Since writing the NVM image might require some special steps,

	 * for example when CSS headers are written, we cache the image

	 * locally here and handle the special cases when the user asks

	 * us to authenticate the image.

	/*

	 * The NVM format of non-Intel hardware is not known so

	 * currently restrict NVM upgrade for Intel hardware. We may

	 * relax this in the future when we learn other NVM formats.

	/*

	 * If the switch is in safe-mode the only accessible portion of

	 * the NVM is the non-active one where userspace is expected to

	 * write new functional NVM.

 Remove authentication status in case the switch is unplugged */

 port utility functions */

/**

 * tb_port_state() - get connectedness state of a port

 * @port: the port to check

 *

 * The port must have a TB_CAP_PHY (i.e. it should be a real port).

 *

 * Return: Returns an enum tb_port_state on success or an error code on failure.

/**

 * tb_wait_for_port() - wait for a port to become ready

 * @port: Port to wait

 * @wait_if_unplugged: Wait also when port is unplugged

 *

 * Wait up to 1 second for a port to reach state TB_PORT_UP. If

 * wait_if_unplugged is set then we also wait if the port is in state

 * TB_PORT_UNPLUGGED (it takes a while for the device to be registered after

 * switch resume). Otherwise we only wait if a device is registered but the link

 * has not yet been established.

 *

 * Return: Returns an error code on failure. Returns 0 if the port is not

 * connected or failed to reach state TB_PORT_UP within one second. Returns 1

 * if the port is connected and in state TB_PORT_UP.

 used during resume */

		/*

		 * After plug-in the state is TB_PORT_CONNECTING. Give it some

		 * time.

/**

 * tb_port_add_nfc_credits() - add/remove non flow controlled credits to port

 * @port: Port to add/remove NFC credits

 * @credits: Credits to add/remove

 *

 * Change the number of NFC credits allocated to @port by @credits. To remove

 * NFC credits pass a negative amount of credits.

 *

 * Return: Returns 0 on success or an error code on failure.

	/*

	 * USB4 restricts programming NFC buffers to lane adapters only

	 * so skip other ports.

/**

 * tb_port_clear_counter() - clear a counter in TB_CFG_COUNTER

 * @port: Port whose counters to clear

 * @counter: Counter index to clear

 *

 * Return: Returns 0 on success or an error code on failure.

/**

 * tb_port_unlock() - Unlock downstream port

 * @port: Port to unlock

 *

 * Needed for USB4 but can be called for any CIO/USB4 ports. Makes the

 * downstream router accessible for CM.

/**

 * tb_port_enable() - Enable lane adapter

 * @port: Port to enable (can be %NULL)

 *

 * This is used for lane 0 and 1 adapters to enable it.

/**

 * tb_port_disable() - Disable lane adapter

 * @port: Port to disable (can be %NULL)

 *

 * This is used for lane 0 and 1 adapters to disable it.

/*

 * tb_init_port() - initialize a port

 *

 * This is a helper method for tb_switch_alloc. Does not check or initialize

 * any downstream switches.

 *

 * Return: Returns 0 on success or an error code on failure.

 Control adapter does not have configuration space */

 Port 0 is the switch itself and has no PHY. */

		/*

		 * USB4 ports the buffers allocated for the control path

		 * can be read from the path config space. Legacy

		 * devices we use hard-coded value.

	/*

	 * NHI can use HopIDs 1-max for other adapters HopIDs 0-7 are

	 * reserved.

/**

 * tb_port_alloc_in_hopid() - Allocate input HopID from port

 * @port: Port to allocate HopID for

 * @min_hopid: Minimum acceptable input HopID

 * @max_hopid: Maximum acceptable input HopID

 *

 * Return: HopID between @min_hopid and @max_hopid or negative errno in

 * case of error.

/**

 * tb_port_alloc_out_hopid() - Allocate output HopID from port

 * @port: Port to allocate HopID for

 * @min_hopid: Minimum acceptable output HopID

 * @max_hopid: Maximum acceptable output HopID

 *

 * Return: HopID between @min_hopid and @max_hopid or negative errno in

 * case of error.

/**

 * tb_port_release_in_hopid() - Release allocated input HopID from port

 * @port: Port whose HopID to release

 * @hopid: HopID to release

/**

 * tb_port_release_out_hopid() - Release allocated output HopID from port

 * @port: Port whose HopID to release

 * @hopid: HopID to release

/**

 * tb_next_port_on_path() - Return next port for given port on a path

 * @start: Start port of the walk

 * @end: End port of the walk

 * @prev: Previous port (%NULL if this is the first)

 *

 * This function can be used to walk from one port to another if they

 * are connected through zero or more switches. If the @prev is dual

 * link port, the function follows that link and returns another end on

 * that same link.

 *

 * If the @end port has been reached, return %NULL.

 *

 * Domain tb->lock must be held when this function is called.

 Walk down the topology if next == prev */

			/*

			 * Keep the same link if prev and next are both

			 * dual link ports.

/**

 * tb_port_get_link_speed() - Get current link speed

 * @port: Port to check (USB4 or CIO)

 *

 * Returns link speed in Gb/s or negative errno in case of failure.

/**

 * tb_port_get_link_width() - Get current link width

 * @port: Port to check (USB4 or CIO)

 *

 * Returns link width. Return values can be 1 (Single-Lane), 2 (Dual-Lane)

 * or negative errno in case of failure.

/**

 * tb_port_lane_bonding_enable() - Enable bonding on port

 * @port: port to enable

 *

 * Enable bonding by setting the link width of the port and the other

 * port in case of dual link port. Does not wait for the link to

 * actually reach the bonded state so caller needs to call

 * tb_port_wait_for_link_width() before enabling any paths through the

 * link to make sure the link is in expected state.

 *

 * Return: %0 in case of success and negative errno in case of error

	/*

	 * Enable lane bonding for both links if not already enabled by

	 * for example the boot firmware.

/**

 * tb_port_lane_bonding_disable() - Disable bonding on port

 * @port: port to disable

 *

 * Disable bonding by setting the link width of the port and the

 * other port in case of dual link port.

 *

/**

 * tb_port_wait_for_link_width() - Wait until link reaches specific width

 * @port: Port to wait for

 * @width: Expected link width (%1 or %2)

 * @timeout_msec: Timeout in ms how long to wait

 *

 * Should be used after both ends of the link have been bonded (or

 * bonding has been disabled) to wait until the link actually reaches

 * the expected state. Returns %-ETIMEDOUT if the @width was not reached

 * within the given timeout, %0 if it did.

/**

 * tb_port_update_credits() - Re-read port total credits

 * @port: Port to update

 *

 * After the link is bonded (or bonding was disabled) the port total

 * credits may change, so this function needs to be called to re-read

 * the credits. Updates also the second lane adapter.

/*

 * Returns true if the port had something (router, XDomain) connected

 * before suspend.

		/*

		 * For disconnected downstream lane adapters start lane

		 * initialization now so we detect future connects.

		 *

		 * For XDomain start the lane initialzation now so the

		 * link gets re-established.

		 *

		 * This is only needed for non-USB4 ports.

/**

 * tb_port_is_enabled() - Is the adapter port enabled

 * @port: Port to check

/**

 * tb_usb3_port_is_enabled() - Is the USB3 adapter port enabled

 * @port: USB3 adapter port to check

/**

 * tb_usb3_port_enable() - Enable USB3 adapter port

 * @port: USB3 adapter port to enable

 * @enable: Enable/disable the USB3 adapter

/**

 * tb_pci_port_is_enabled() - Is the PCIe adapter port enabled

 * @port: PCIe port to check

/**

 * tb_pci_port_enable() - Enable PCIe adapter port

 * @port: PCIe port to enable

 * @enable: Enable/disable the PCIe adapter

/**

 * tb_dp_port_hpd_is_active() - Is HPD already active

 * @port: DP out port to check

 *

 * Checks if the DP OUT adapter port has HDP bit already set.

/**

 * tb_dp_port_hpd_clear() - Clear HPD from DP IN port

 * @port: Port to clear HPD

 *

 * If the DP IN port has HDP set, this function can be used to clear it.

/**

 * tb_dp_port_set_hops() - Set video/aux Hop IDs for DP port

 * @port: DP IN/OUT port to set hops

 * @video: Video Hop ID

 * @aux_tx: AUX TX Hop ID

 * @aux_rx: AUX RX Hop ID

 *

 * Programs specified Hop IDs for DP IN/OUT port.

/**

 * tb_dp_port_is_enabled() - Is DP adapter port enabled

 * @port: DP adapter port to check

/**

 * tb_dp_port_enable() - Enables/disables DP paths of a port

 * @port: DP IN/OUT port

 * @enable: Enable/disable DP path

 *

 * Once Hop IDs are programmed DP paths can be enabled or disabled by

 * calling this function.

 switch utility functions */

/**

 * tb_switch_reset() - reconfigure route, enable and send TB_CFG_PKG_RESET

 * @sw: Switch to reset

 *

 * Return: Returns 0 on success or an error code on failure.

/*

 * tb_plug_events_active() - enable/disable plug events on a switch

 *

 * Also configures a sane plug_events_delay of 255ms.

 *

 * Return: Returns 0 on success or an error code on failure.

 First children */

 Disapprove switch */

 Approve switch */

 Challenge switch */

		/*

		 * Notify status change to the userspace, informing the new

		 * value of /sys/bus/thunderbolt/devices/.../authorized.

/*

 * Currently all lanes must run at the same speed but we expose here

 * both directions to allow possible asymmetric links in the future.

/*

 * Currently link has same amount of lanes both directions (1 or 2) but

 * expose them separately to allow possible asymmetric links in the future.

 If NVMem devices are not yet added */

 Always clear the authentication status */

 Device is hub if it has any downstream ports */

/*

 * Currently only need to provide the callbacks. Everything else is handled

 * in the connection manager.

		/*

		 * For unknown switches assume generation to be 1 to be

		 * on the safe side.

/**

 * tb_switch_alloc() - allocate a switch

 * @tb: Pointer to the owning domain

 * @parent: Parent device for this switch

 * @route: Route string for this switch

 *

 * Allocates and initializes a switch. Will not upload configuration to

 * the switch. For that you need to call tb_switch_configure()

 * separately. The returned switch should be released by calling

 * tb_switch_put().

 *

 * Return: Pointer to the allocated switch or ERR_PTR() in case of

 * failure.

 Unlock the downstream port so we can access the switch below */

 configure switch */

 Make sure we do not exceed maximum topology limit */

 initialize ports */

 minimum setup for tb_find_cap and tb_drom_read to work */

 Control port does not need HopID allocation */

 Root switch is always authorized */

/**

 * tb_switch_alloc_safe_mode() - allocate a switch that is in safe mode

 * @tb: Pointer to the owning domain

 * @parent: Parent device for this switch

 * @route: Route string for this switch

 *

 * This creates a switch in safe mode. This means the switch pretty much

 * lacks all capabilities except DMA configuration port before it is

 * flashed with a valid NVM firmware.

 *

 * The returned switch must be released by calling tb_switch_put().

 *

 * Return: Pointer to the allocated switch or ERR_PTR() in case of failure

/**

 * tb_switch_configure() - Uploads configuration to the switch

 * @sw: Switch to configure

 *

 * Call this function before the switch is added to the system. It will

 * upload configuration to the switch and makes it available for the

 * connection manager to use. Can be called to the switch again after

 * resume from low power states to re-initialize it.

 *

 * Return: %0 in case of success and negative errno in case of failure

		/*

		 * For USB4 devices, we need to program the CM version

		 * accordingly so that it knows to expose all the

		 * additional capabilities.

 Enumerate the switch */

 Enumerate the switch */

		/*

		 * The newer controllers include fused UUID as part of

		 * link controller specific registers

		/*

		 * ICM generates UUID based on UID and fills the upper

		 * two words with ones. This is not strictly following

		 * UUID format but we want to be compatible with it so

		 * we do the same here.

 Only root switch can be upgraded */

		/*

		 * DMA port is the only thing available when the switch

		 * is in safe mode.

 Root switch DMA port requires running firmware */

	/*

	 * If there is status already set then authentication failed

	 * when the dma_port_flash_update_auth() returned. Power cycling

	 * is not needed (it was done already) so only thing we do here

	 * is to unblock runtime PM of the root port.

	/*

	 * Check status of the previous flash authentication. If there

	 * is one we need to power cycle the switch in any case to make

	 * it functional again.

 Now we can allow root port to suspend again */

	/*

	 * We return error here which causes the switch adding failure.

	 * It should appear back after power cycle is complete.

 Check for the subordinate port */

 Link them if not already done so (by DROM) */

 Notify userspace that there is possible link attribute change */

/**

 * tb_switch_lane_bonding_enable() - Enable lane bonding

 * @sw: Switch to enable lane bonding

 *

 * Connection manager can call this function to enable lane bonding of a

 * switch. If conditions are correct and both switches support the feature,

 * lanes are bonded. It is safe to call this to any switch.

/**

 * tb_switch_lane_bonding_disable() - Disable lane bonding

 * @sw: Switch whose lane bonding to disable

 *

 * Disables lane bonding between @sw and parent. This can be called even

 * if lanes were not bonded originally.

	/*

	 * It is fine if we get other errors as the router might have

	 * been unplugged.

/**

 * tb_switch_configure_link() - Set link configured

 * @sw: Switch whose link is configured

 *

 * Sets the link upstream from @sw configured (from both ends) so that

 * it will not be disconnected when the domain exits sleep. Can be

 * called for any switch.

 *

 * It is recommended that this is called after lane bonding is enabled.

 *

 * Returns %0 on success and negative errno in case of error.

/**

 * tb_switch_unconfigure_link() - Unconfigure link

 * @sw: Switch whose link is unconfigured

 *

 * Sets the link unconfigured so the @sw will be disconnected if the

 * domain exists sleep.

/**

 * tb_switch_add() - Add a switch to the domain

 * @sw: Switch to add

 *

 * This is the last step in adding switch to the domain. It will read

 * identification information from DROM and initializes ports so that

 * they can be used to connect other switches. The switch will be

 * exposed to the userspace when this function successfully returns. To

 * remove and release the switch, call tb_switch_remove().

 *

 * Return: %0 in case of success and negative errno in case of failure

	/*

	 * Initialize DMA control port now before we read DROM. Recent

	 * host controllers have more complete DROM on NVM that includes

	 * vendor and model identification strings which we then expose

	 * to the userspace. NVM can be accessed through DMA

	 * configuration based mailbox.

 read drom */

	/*

	 * Thunderbolt routers do not generate wakeups themselves but

	 * they forward wakeups from tunneled protocols, so enable it

	 * here.

/**

 * tb_switch_remove() - Remove and release a switch

 * @sw: Switch to remove

 *

 * This will remove the switch from the domain and release it after last

 * reference count drops to zero. If there are switches connected below

 * this switch, they will be removed as well.

 port 0 is the switch itself and never has a remote */

 Remove any downstream retimers */

/**

 * tb_sw_set_unplugged() - set is_unplugged on switch and downstream switches

 * @sw: Router to mark unplugged

	/*

	 * Check for UID of the connected switches except for root

	 * switch which we assume cannot be removed.

		/*

		 * Check first that we can still read the switch config

		 * space. It may be that there is now another domain

		 * connected.

 Disable wakes */

 check for surviving downstream switches */

			/*

			 * Always unlock the port so the downstream

			 * switch/domain is accessible.

/**

 * tb_switch_suspend() - Put a switch to sleep

 * @sw: Switch to suspend

 * @runtime: Is this runtime suspend or system sleep

 *

 * Suspends router and all its children. Enables wakes according to

 * value of @runtime and then sets sleep bit for the router. If @sw is

 * host router the domain is ready to go to sleep once this function

 * returns.

 Trigger wake when something is plugged in/out */

/**

 * tb_switch_query_dp_resource() - Query availability of DP resource

 * @sw: Switch whose DP resource is queried

 * @in: DP IN port

 *

 * Queries availability of DP resource for DP tunneling using switch

 * specific means. Returns %true if resource is available.

/**

 * tb_switch_alloc_dp_resource() - Allocate available DP resource

 * @sw: Switch whose DP resource is allocated

 * @in: DP IN port

 *

 * Allocates DP resource for DP tunneling. The resource must be

 * available for this to succeed (see tb_switch_query_dp_resource()).

 * Returns %0 in success and negative errno otherwise.

/**

 * tb_switch_dealloc_dp_resource() - De-allocate DP resource

 * @sw: Switch whose DP resource is de-allocated

 * @in: DP IN port

 *

 * De-allocates DP resource that was previously allocated for DP

 * tunneling.

 Root switch is matched only by depth */

/**

 * tb_switch_find_by_link_depth() - Find switch by link and depth

 * @tb: Domain the switch belongs

 * @link: Link number the switch is connected

 * @depth: Depth of the switch in link

 *

 * Returned switch has reference count increased so the caller needs to

 * call tb_switch_put() when done with the switch.

/**

 * tb_switch_find_by_uuid() - Find switch by UUID

 * @tb: Domain the switch belongs

 * @uuid: UUID to look for

 *

 * Returned switch has reference count increased so the caller needs to

 * call tb_switch_put() when done with the switch.

/**

 * tb_switch_find_by_route() - Find switch by route string

 * @tb: Domain the switch belongs

 * @route: Route string to look for

 *

 * Returned switch has reference count increased so the caller needs to

 * call tb_switch_put() when done with the switch.

/**

 * tb_switch_find_port() - return the first port of @type on @sw or NULL

 * @sw: Switch to find the port from

 * @type: Port type to look for

 SPDX-License-Identifier: GPL-2.0

/*

 * NHI specific operations

 *

 * Copyright (C) 2019, Intel Corporation

 * Author: Mika Westerberg <mika.westerberg@linux.intel.com>

 Ice Lake specific NHI operations */

 ms */

	/*

	 * The Thunderbolt host controller is present always in Ice Lake

	 * but the firmware may not be loaded and running (depending

	 * whether there is device connected and so on). Each time the

	 * controller is used we need to "Force Power" it first and wait

	 * for the firmware to indicate it is up and running. This "Force

	 * Power" is really not about actually powering on/off the

	 * controller so it is accessible even if "Force Power" is off.

	 *

	 * The actual power management happens inside shared ACPI power

	 * resources using standard ACPI methods.

 Wait until the firmware tells it is up and running */

 Clear the valid bit */

 Program the same value for both snoop and no-snoop */

		/*

		 * If there is no device connected we need to perform

		 * both: a handshake through LC mailbox and force power

		 * down before entering D3.

 SPDX-License-Identifier: GPL-2.0

/*

 * USB4 port device

 *

 * Copyright (C) 2021, Intel Corporation

 * Author: Mika Westerberg <mika.westerberg@linux.intel.com>

 Offline mode works only for ports that are not connected */

 Must be in offline mode already */

	/*

	 * Always need some platform help to cycle the modes so that

	 * retimers can be accessed through the sideband.

/**

 * usb4_port_device_add() - Add USB4 port device

 * @port: Lane 0 adapter port to add the USB4 port

 *

 * Creates and registers a USB4 port device for @port. Returns the new

 * USB4 port device pointer or ERR_PTR() in case of error.

/**

 * usb4_port_device_remove() - Removes USB4 port device

 * @usb4: USB4 port device

 *

 * Unregisters the USB4 port device from the system. The device will be

 * released when the last reference is dropped.

/**

 * usb4_port_device_resume() - Resumes USB4 port device

 * @usb4: USB4 port device

 *

 * Used to resume USB4 port device after sleep state.

 SPDX-License-Identifier: GPL-2.0

/*

 * Thunderbolt XDomain discovery protocol support

 *

 * Copyright (C) 2017, Intel Corporation

 * Authors: Michael Jamet <michael.jamet@intel.com>

 *          Mika Westerberg <mika.westerberg@linux.intel.com>

 ms */

 ms */

/*

 * Serializes access to the properties and protocol handlers below. If

 * you need to take both this lock and the struct tb_xdomain lock, take

 * this one first.

 Properties exposed to the remote domains */

 Additional protocol handlers */

 UUID for XDomain discovery protocol: b638d70e-42ff-40bb-97c2-90e2c0b2ff07 */

 Make sure route matches */

 Check that the XDomain protocol matches */

/**

 * tb_xdomain_response() - Send a XDomain response message

 * @xd: XDomain to send the message

 * @response: Response to send

 * @size: Size of the response

 * @type: PDF type of the response

 *

 * This can be used to send a XDomain response message to the other

 * domain. No response for the message is expected.

 *

 * Return: %0 in case of success and negative errno in case of failure

/**

 * tb_xdomain_request() - Send a XDomain request

 * @xd: XDomain to send the request

 * @request: Request to send

 * @request_size: Size of the request in bytes

 * @request_type: PDF type of the request

 * @response: Response is copied here

 * @response_size: Expected size of the response in bytes

 * @response_type: Expected PDF type of the response

 * @timeout_msec: Timeout in milliseconds to wait for the response

 *

 * This function can be used to send XDomain control channel messages to

 * the other domain. The function waits until the response is received

 * or when timeout triggers. Whichever comes first.

 *

 * Return: %0 in case of success and negative errno in case of failure

		/*

		 * Package length includes the whole payload without the

		 * XDomain header. Validate first that the package is at

		 * least size of the response structure.

		/*

		 * First time allocate block that has enough space for

		 * the whole properties block.

	/*

	 * Currently we expect all requests to be directed to us. The

	 * protocol supports forwarding, though which we might add

	 * support later on.

/**

 * tb_register_protocol_handler() - Register protocol handler

 * @handler: Handler to register

 *

 * This allows XDomain service drivers to hook into incoming XDomain

 * messages. After this function is called the service driver needs to

 * be able to handle calls to callback whenever a package with the

 * registered protocol is received.

/**

 * tb_unregister_protocol_handler() - Unregister protocol handler

 * @handler: Handler to unregister

 *

 * Removes the previously registered protocol handler.

	/*

	 * If the local property block is not up-to-date, rebuild it now

	 * based on the global property template.

 Fill in non-static properties now */

 Release the previous block */

 Assign new one */

		/*

		 * Since the properties have been changed, let's update

		 * the xdomain related to this connection as well in

		 * case there is a change in services it offers.

/**

 * tb_register_service_driver() - Register XDomain service driver

 * @drv: Driver to register

 *

 * Registers new service driver from @drv to the bus.

/**

 * tb_unregister_service_driver() - Unregister XDomain service driver

 * @drv: Driver to unregister

 *

 * Unregisters XDomain service driver from the bus.

	/*

	 * It should be null terminated but anything else is pretty much

	 * allowed.

 Full buffer size except new line and null termination */

 Fill in standard properties */

	/*

	 * First remove all services that are not available anymore in

	 * the updated property block.

 Then re-enumerate properties creating new services as we go */

 If the service exists already we are fine */

 Required properties */

	/*

	 * USB4 inter-domain spec suggests using 15 as HopID if the

	 * other end does not announce it in a property. This is for

	 * TBT3 compatibility.

 Optional properties */

	/*

	 * If the UUID is different, there is another domain connected

	 * so mark this one unplugged and wait for the connection

	 * manager to replace it.

 First time fill in the missing UUID */

 Now we can start the normal properties exchange */

 Give up now */

 Only accept newer generation properties */

 Release the existing one */

	/*

	 * Now the device should be ready enough so we can add it to the

	 * bus and let userspace know about it. If the device is already

	 * registered, we notify the userspace that it has changed.

 Start exchanging properties with the other host */

/**

 * tb_xdomain_alloc() - Allocate new XDomain object

 * @tb: Domain where the XDomain belongs

 * @parent: Parent device (the switch through the connection to the

 *	    other domain is reached).

 * @route: Route string used to reach the other domain

 * @local_uuid: Our local domain UUID

 * @remote_uuid: UUID of the other domain (optional)

 *

 * Allocates new XDomain structure and returns pointer to that. The

 * object must be released by calling tb_xdomain_put().

 Make sure the downstream domain is accessible */

	/*

	 * This keeps the DMA powered on as long as we have active

	 * connection to another host.

/**

 * tb_xdomain_add() - Add XDomain to the bus

 * @xd: XDomain to add

 *

 * This function starts XDomain discovery protocol handshake and

 * eventually adds the XDomain to the bus. After calling this function

 * the caller needs to call tb_xdomain_remove() in order to remove and

 * release the object regardless whether the handshake succeeded or not.

 Start exchanging properties with the other host */

/**

 * tb_xdomain_remove() - Remove XDomain from the bus

 * @xd: XDomain to remove

 *

 * This will stop all ongoing configuration work and remove the XDomain

 * along with any services from the bus. When the last reference to @xd

 * is released the object will be released as well.

	/*

	 * Undo runtime PM here explicitly because it is possible that

	 * the XDomain was never added to the bus and thus device_del()

	 * is not called for it (device_del() would handle this otherwise).

/**

 * tb_xdomain_lane_bonding_enable() - Enable lane bonding on XDomain

 * @xd: XDomain connection

 *

 * Lane bonding is disabled by default for XDomains. This function tries

 * to enable bonding by first enabling the port and waiting for the CL0

 * state.

 *

 * Return: %0 in case of success and negative errno in case of error.

/**

 * tb_xdomain_lane_bonding_disable() - Disable lane bonding

 * @xd: XDomain connection

 *

 * Lane bonding is disabled by default for XDomains. If bonding has been

 * enabled, this function can be used to disable it.

/**

 * tb_xdomain_alloc_in_hopid() - Allocate input HopID for tunneling

 * @xd: XDomain connection

 * @hopid: Preferred HopID or %-1 for next available

 *

 * Returns allocated HopID or negative errno. Specifically returns

 * %-ENOSPC if there are no more available HopIDs. Returned HopID is

 * guaranteed to be within range supported by the input lane adapter.

 * Call tb_xdomain_release_in_hopid() to release the allocated HopID.

/**

 * tb_xdomain_alloc_out_hopid() - Allocate output HopID for tunneling

 * @xd: XDomain connection

 * @hopid: Preferred HopID or %-1 for next available

 *

 * Returns allocated HopID or negative errno. Specifically returns

 * %-ENOSPC if there are no more available HopIDs. Returned HopID is

 * guaranteed to be within range supported by the output lane adapter.

 * Call tb_xdomain_release_in_hopid() to release the allocated HopID.

/**

 * tb_xdomain_release_in_hopid() - Release input HopID

 * @xd: XDomain connection

 * @hopid: HopID to release

/**

 * tb_xdomain_release_out_hopid() - Release output HopID

 * @xd: XDomain connection

 * @hopid: HopID to release

/**

 * tb_xdomain_enable_paths() - Enable DMA paths for XDomain connection

 * @xd: XDomain connection

 * @transmit_path: HopID we are using to send out packets

 * @transmit_ring: DMA ring used to send out packets

 * @receive_path: HopID the other end is using to send packets to us

 * @receive_ring: DMA ring used to receive packets from @receive_path

 *

 * The function enables DMA paths accordingly so that after successful

 * return the caller can send and receive packets using high-speed DMA

 * path. If a transmit or receive path is not needed, pass %-1 for those

 * parameters.

 *

 * Return: %0 in case of success and negative errno in case of error

/**

 * tb_xdomain_disable_paths() - Disable DMA paths for XDomain connection

 * @xd: XDomain connection

 * @transmit_path: HopID we are using to send out packets

 * @transmit_ring: DMA ring used to send out packets

 * @receive_path: HopID the other end is using to send packets to us

 * @receive_ring: DMA ring used to receive packets from @receive_path

 *

 * This does the opposite of tb_xdomain_enable_paths(). After call to

 * this the caller is not expected to use the rings anymore. Passing %-1

 * as path/ring parameter means don't care. Normally the callers should

 * pass the same values here as they do when paths are enabled.

 *

 * Return: %0 in case of success and negative errno in case of error

/**

 * tb_xdomain_find_by_uuid() - Find an XDomain by UUID

 * @tb: Domain where the XDomain belongs to

 * @uuid: UUID to look for

 *

 * Finds XDomain by walking through the Thunderbolt topology below @tb.

 * The returned XDomain will have its reference count increased so the

 * caller needs to call tb_xdomain_put() when it is done with the

 * object.

 *

 * This will find all XDomains including the ones that are not yet added

 * to the bus (handshake is still in progress).

 *

 * The caller needs to hold @tb->lock.

/**

 * tb_xdomain_find_by_link_depth() - Find an XDomain by link and depth

 * @tb: Domain where the XDomain belongs to

 * @link: Root switch link number

 * @depth: Depth in the link

 *

 * Finds XDomain by walking through the Thunderbolt topology below @tb.

 * The returned XDomain will have its reference count increased so the

 * caller needs to call tb_xdomain_put() when it is done with the

 * object.

 *

 * This will find all XDomains including the ones that are not yet added

 * to the bus (handshake is still in progress).

 *

 * The caller needs to hold @tb->lock.

/**

 * tb_xdomain_find_by_route() - Find an XDomain by route string

 * @tb: Domain where the XDomain belongs to

 * @route: XDomain route string

 *

 * Finds XDomain by walking through the Thunderbolt topology below @tb.

 * The returned XDomain will have its reference count increased so the

 * caller needs to call tb_xdomain_put() when it is done with the

 * object.

 *

 * This will find all XDomains including the ones that are not yet added

 * to the bus (handshake is still in progress).

 *

 * The caller needs to hold @tb->lock.

 We expect the packet is at least size of the header */

	/*

	 * Handle XDomain discovery protocol packets directly here. For

	 * other protocols (based on their UUID) we call registered

	 * handlers in turn.

/**

 * tb_register_property_dir() - Register property directory to the host

 * @key: Key (name) of the directory to add

 * @dir: Directory to add

 *

 * Service drivers can use this function to add new property directory

 * to the host available properties. The other connected hosts are

 * notified so they can re-read properties of this host if they are

 * interested.

 *

 * Return: %0 on success and negative errno on failure

/**

 * tb_unregister_property_dir() - Removes property directory from host

 * @key: Key (name) of the directory

 * @dir: Directory to remove

 *

 * This will remove the existing directory from this host and notify the

 * connected hosts about the change.

	/*

	 * Initialize standard set of properties without any service

	 * directories. Those will be added by service drivers

	 * themselves when they are loaded.

	 *

	 * Rest of the properties are filled dynamically based on these

	 * when the P2P connection is made.

 SPDX-License-Identifier: GPL-2.0

/*

 * Thunderbolt DMA configuration based mailbox support

 *

 * Copyright (C) 2017, Intel Corporation

 * Authors: Michael Jamet <michael.jamet@intel.com>

 *          Mika Westerberg <mika.westerberg@linux.intel.com>

 ms */

/**

 * struct tb_dma_port - DMA control port

 * @sw: Switch the DMA port belongs to

 * @port: Switch port number where DMA capability is found

 * @base: Start offset of the mailbox registers

 * @buf: Temporary buffer to store a single block

/*

 * When the switch is in safe mode it supports very little functionality

 * so we don't validate that much here.

	/*

	 * The DMA (NHI) port is either 3, 5 or 7 depending on the

	 * controller. Try all of them.

/**

 * dma_port_alloc() - Finds DMA control port from a switch pointed by route

 * @sw: Switch from where find the DMA port

 *

 * Function checks if the switch NHI port supports DMA configuration

 * based mailbox capability and if it does, allocates and initializes

 * DMA port structure. Returns %NULL if the capabity was not found.

 *

 * The DMA control port is functional also when the switch is in safe

 * mode.

/**

 * dma_port_free() - Release DMA control port structure

 * @dma: DMA control port

 Write the block to MAIL_DATA registers */

 CSS header write is always done to the same magic address */

/**

 * dma_port_flash_read() - Read from active flash region

 * @dma: DMA control port

 * @address: Address relative to the start of active region

 * @buf: Buffer where the data is read

 * @size: Size of the buffer

/**

 * dma_port_flash_write() - Write to non-active flash region

 * @dma: DMA control port

 * @address: Address relative to the start of non-active region

 * @buf: Data to write

 * @size: Size of the buffer

 *

 * Writes block of data to the non-active flash region of the switch. If

 * the address is given as %DMA_PORT_CSS_ADDRESS the block is written

 * using CSS command.

/**

 * dma_port_flash_update_auth() - Starts flash authenticate cycle

 * @dma: DMA control port

 *

 * Starts the flash update authentication cycle. If the image in the

 * non-active area was valid, the switch starts upgrade process where

 * active and non-active area get swapped in the end. Caller should call

 * dma_port_flash_update_auth_status() to get status of this command.

 * This is because if the switch in question is root switch the

 * thunderbolt host controller gets reset as well.

/**

 * dma_port_flash_update_auth_status() - Reads status of update auth command

 * @dma: DMA control port

 * @status: Status code of the operation

 *

 * The function checks if there is status available from the last update

 * auth command. Returns %0 if there is no status and no further

 * action is required. If there is status, %1 is returned instead and

 * @status holds the failure code.

 *

 * Negative return means there was an error reading status from the

 * switch.

 Check if the status relates to flash update auth */

 Reset is needed in any case */

/**

 * dma_port_power_cycle() - Power cycles the switch

 * @dma: DMA control port

 *

 * Triggers power cycle to the switch.

 SPDX-License-Identifier: GPL-2.0

/*

 * Thunderbolt/USB4 retimer support.

 *

 * Copyright (C) 2020, Intel Corporation

 * Authors: Kranthi Kuntala <kranthi.kuntala@intel.com>

 *	    Mika Westerberg <mika.westerberg@linux.intel.com>

	/*

	 * FARB pointer must point inside the image and must at least

	 * contain parts of the digital section we will be reading here.

 Digital section start should be aligned to 4k page */

	/*

	 * Read digital section size and check that it also fits inside

	 * the image.

	/*

	 * Make sure the device ID in the image matches the retimer

	 * hardware.

 Skip headers in the image */

	/*

	 * Check the status now if we still can access the retimer. It

	 * is expected that the below fails.

 Always clear status */

	/*

	 * Check that it supports NVM operations. If not then don't add

	 * the device at all.

/**

 * tb_retimer_scan() - Scan for on-board retimers under port

 * @port: USB4 port to scan

 * @add: If true also registers found retimers

 *

 * Brings the sideband into a state where retimers can be accessed.

 * Then Tries to enumerate on-board retimers connected to @port. Found

 * retimers are registered as children of @port if @add is set.  Does

 * not scan for cable retimers for now.

	/*

	 * Send broadcast RT to make sure retimer indices facing this

	 * port are set.

	/*

	 * Enable sideband channel for each retimer. We can do this

	 * regardless whether there is device connected or not.

	/*

	 * Before doing anything else, read the authentication status.

	 * If the retimer has it set, store it for the new retimer

	 * device instance.

		/*

		 * Last retimer is true only for the last on-board

		 * retimer (the one connected directly to the Type-C

		 * port).

 Add on-board retimers if they do not exist already */

/**

 * tb_retimer_remove_all() - Remove all retimers under port

 * @port: USB4 port whose retimers to remove

 *

 * This removes all previously added retimers under @port.

 SPDX-License-Identifier: GPL-2.0

/*

 * Internal Thunderbolt Connection Manager. This is a firmware running on

 * the Thunderbolt host controller performing most of the low-level

 * handling.

 *

 * Copyright (C) 2017, Intel Corporation

 * Authors: Michael Jamet <michael.jamet@intel.com>

 *          Mika Westerberg <mika.westerberg@linux.intel.com>

 ms */

 ms */

/**

 * struct usb4_switch_nvm_auth - Holds USB4 NVM_AUTH status

 * @reply: Reply from ICM firmware is placed here

 * @request: Request that is sent to ICM firmware

 * @icm: Pointer to ICM private data

/**

 * struct icm - Internal connection manager private data

 * @request_lock: Makes sure only one message is send to ICM at time

 * @rescan_work: Work used to rescan the surviving switches after resume

 * @upstream_port: Pointer to the PCIe upstream port this host

 *		   controller is connected. This is only set for systems

 *		   where ICM needs to be started manually

 * @vnd_cap: Vendor defined capability where PCIe2CIO mailbox resides

 *	     (only set when @upstream_port is not %NULL)

 * @safe_mode: ICM is in safe mode

 * @max_boot_acl: Maximum number of preboot ACL entries (%0 if not supported)

 * @rpm: Does the controller support runtime PM (RTD3)

 * @can_upgrade_nvm: Can the NVM firmware be upgrade on this controller

 * @proto_version: Firmware protocol version

 * @last_nvm_auth: Last USB4 router NVM_AUTH result (or %NULL if not set)

 * @veto: Is RTD3 veto in effect

 * @is_supported: Checks if we can support ICM on this controller

 * @cio_reset: Trigger CIO reset

 * @get_mode: Read and return the ICM firmware mode (optional)

 * @get_route: Find a route string for given switch

 * @save_devices: Ask ICM to save devices to ACL when suspending (optional)

 * @driver_ready: Send driver ready message to ICM

 * @set_uuid: Set UUID for the root switch (optional)

 * @device_connected: Handle device connected ICM message

 * @device_disconnected: Handle device disconnected ICM message

 * @xdomain_connected: Handle XDomain connected ICM message

 * @xdomain_disconnected: Handle XDomain disconnected ICM message

 * @rtd3_veto: Handle RTD3 veto notification ICM message

 Intel Vendor specific structure */

/*

 * If rescan is queued to run (we are resuming), postpone it to give the

 * firmware some more time to send device connected notifications for next

 * devices in the chain.

 Keep the domain powered while veto is in effect */

 Allow the domain suspend now */

 Use larger timeout as establishing tunnels can take some time */

 Link the two switches now */

 Disconnect from parent */

 Re-connect via updated port*/

 Update with the new addressing information */

 This switch still exists */

 Runtime resume is now complete */

		/*

		 * On resume ICM will send us connected events for the

		 * devices that still are present. However, that

		 * information might have changed for example by the

		 * fact that a switch on a dual-link connection might

		 * have been enumerated using the other link now. Make

		 * sure our book keeping matches that.

			/*

			 * It was enumerated through another link so update

			 * route string accordingly.

		/*

		 * User connected the same switch to another physical

		 * port or to another part of the topology. Remove the

		 * existing switch now before adding the new one.

	/*

	 * If the switch was not found by UUID, look for a switch on

	 * same physical port (taking possible link aggregation into

	 * account) and depth. If we found one it is definitely a stale

	 * one so remove it first.

 Remove existing XDomain connection if found */

		/*

		 * If we find an existing XDomain connection remove it

		 * now. We need to go through login handshake and

		 * everything anyway to be able to re-establish the

		 * connection.

	/*

	 * Look if there already exists an XDomain in the same place

	 * than the new one and in that case remove it because it is

	 * most likely another host that got disconnected.

	/*

	 * If the user disconnected a switch during suspend and

	 * connected another host to the same port, remove the switch

	 * first.

	/*

	 * If the connection is through one or multiple devices, the

	 * XDomain device is removed along with them so it is fine if we

	 * cannot find it here.

	/*

	 * Currently we don't use the QoS information coming with the

	 * device connected message so simply just ignore that extra

	 * packet for now.

 Update the switch if it is still in the same place */

 Another switch with the same address */

 XDomain connection with the same address */

 An existing xdomain with the same address */

	/*

	 * If the user disconnected a switch during suspend and

	 * connected another host to the same port, remove the switch

	 * first.

	/*

	 * Starting from Alpine Ridge we can use ICM on Apple machines

	 * as well. We just need to reset and re-enable it first.

	 * However, only start it if explicitly asked by the user.

	/*

	 * Find the upstream PCIe port in case we need to do reset

	 * through its vendor specific registers.

 Map empty entries to null UUID */

 Upper two DWs are always one's */

			/*

			 * Map null UUID to the empty (all one) entries

			 * for ICM.

 Two high DWs need to be set to all one */

 Ice Lake always supports RTD3 */

	/*

	 * When the domain is stopped we flush its workqueue but before

	 * that the root switch is removed. In that case we should treat

	 * the queued events as being canceled.

	/*

	 * Hold on here until the switch config space is accessible so

	 * that we can read root switch config successfully.

 Put ARC to wait for CIO reset event to happen */

 Re-start ARC */

 Trigger CIO reset now */

 Check if the ICM firmware is already running */

 Wait until the ICM firmware tells us it is up and running */

 Check that the ICM firmware is running */

	/*

	 * Read link status of both null ports belonging to a single

	 * physical port.

 If they are both up we need to reset them now */

 Wait a bit and then re-enable both ports */

 Ask ICM to accept all Thunderbolt devices */

	/*

	 * Reset both physical ports if there is anything connected to

	 * them already.

thunderbolttechnology.net/updates.\n");

	/*

	 * Make sure the number of supported preboot ACL matches what we

	 * expect or disable the whole feature.

/*

 * Mark all switches (except root switch) below this one unplugged. ICM

 * firmware will send us an updated list of switches after we have send

 * it driver ready command. If a switch is not in that list it will be

 * removed when we perform rescan.

	/*

	 * Signal this and switches below for rpm_complete because

	 * tb_switch_remove() calls pm_runtime_get_sync() that then waits

	 * for it.

	/*

	 * If RTD3 was vetoed before we entered system suspend allow it

	 * again now before driver ready is sent. Firmware sends a new RTD3

	 * veto if it is still the case after we have sent it driver ready

	 * command.

	/*

	 * Now all existing children should be resumed, start events

	 * from ICM to get updated status.

	/*

	 * We do not get notifications of devices that have been

	 * unplugged during suspend so schedule rescan to clean them up

	 * if any.

	/*

	 * We can reuse the same resume functionality than with system

	 * suspend.

	/*

	 * USB4 router operation proxy is supported in firmware if the

	 * protocol version is 3 or higher.

	/*

	 * NVM_AUTH is a special USB4 proxy operation that does not

	 * return immediately so handle it separately.

 Falcon Ridge */

 Alpine Ridge */

 Titan Ridge */

 Ice Lake */

		/*

		 * NVM upgrade has not been tested on Apple systems and

		 * they don't provide images publicly either. To be on

		 * the safe side prevent root switch NVM upgrade on Macs

		 * for now.

 SPDX-License-Identifier: GPL-2.0

/*

 * Thunderbolt driver - quirks

 *

 * Copyright (c) 2020 Mario Limonciello <mario.limonciello@dell.com>

 Dell WD19TB supports self-authentication on unplug */

	/*

	 * Intel Goshen Ridge NVM 27 and before report wrong number of

	 * DP buffers.

/**

 * tb_check_quirks() - Check for quirks to apply

 * @sw: Thunderbolt switch

 *

 * Apply any quirks for the Thunderbolt controller.

 SPDX-License-Identifier: GPL-2.0

/*

 * Thunderbolt driver - bus logic (NHI independent)

 *

 * Copyright (c) 2014 Andreas Noever <andreas.noever@gmail.com>

 * Copyright (C) 2019, Intel Corporation

 ms */

/**

 * struct tb_cm - Simple Thunderbolt connection manager

 * @tunnel_list: List of active tunnels

 * @dp_resources: List of available DP resources for DP tunneling

 * @hotplug_active: tb_handle_hotplug will stop progressing plug

 *		    events and exit if this is not set (it needs to

 *		    acquire the lock one more time). Used to drain wq

 *		    after cfg has been paused.

 * @remove_work: Work used to remove any unplugged routers after

 *		 runtime resume

 enumeration & hot plug handling */

 Clear children resources first */

 Keep the domain from powering down */

	/*

	 * XDomain paths currently only support single lane so we must

	 * disable the other lane according to USB4 spec.

 If it is already enabled in correct mode, don't touch it */

/**

 * tb_find_unused_port() - return the first inactive port on @sw

 * @sw: Switch to find the port on

 * @type: Port type to look for

 Pick the router that is deepest in the topology */

 Can't be the host router */

 Find the downstream USB4 port that leads to this router */

 Find the corresponding host router USB3 downstream port */

 Find the minimum available bandwidth over all links */

 Mb/s */

 Leave 10% guard band */

		/*

		 * Find all DP tunnels that cross the port and reduce

		 * their consumed bandwidth from the available.

		/*

		 * If USB3 is tunneled from the host router down to the

		 * branch leading to port we need to take USB3 consumed

		 * bandwidth into account regardless whether it actually

		 * crosses the port.

	/*

	 * Calculate available bandwidth for the first hop USB3 tunnel.

	 * That determines the whole USB3 bandwidth for this branch.

	/*

	 * Look up available down port. Since we are chaining it should

	 * be found right above this switch.

		/*

		 * Check first that the parent switch has its upstream USB3

		 * port enabled. Otherwise the chain is not complete and

		 * there is no point setting up a new tunnel.

 Make all unused bandwidth available for the new tunnel */

/*

 * tb_scan_switch() - scan for and initialize downstream switches

/*

 * tb_scan_port() - check for and initialize switches below port

		return; /*

			 * Downstream switch is reachable through two ports.

			 * Only scan on the primary port (link_nr == 0).

		/*

		 * If there is an error accessing the connected switch

		 * it may be connected to another domain. Also we allow

		 * the other domain to be connected to a max depth switch.

	/*

	 * If there was previously another domain connected remove it

	 * first.

	/*

	 * Do not send uevents until we have discovered all existing

	 * tunnels and know which switches were authorized already by

	 * the boot firmware.

	/*

	 * At the moment Thunderbolt 2 and beyond (devices with LC) we

	 * can support runtime PM.

 Link the switches using both links if available */

 Enable lane bonding if supported */

 Set the link configured */

 Scan upstream retimers */

	/*

	 * Create USB 3.x tunnels only when the switch is plugged to the

	 * domain. This is because we scan the domain also during discovery

	 * and want to discover existing USB 3.x tunnels before we create

	 * any new.

		/*

		 * In case of DP tunnel make sure the DP IN resource is

		 * deallocated properly.

 Now we can allow the domain to runtime suspend again */

		/*

		 * PCIe and DMA tunnels do not consume guaranteed

		 * bandwidth.

/*

 * tb_free_invalid_tunnels() - destroy tunnels of devices that have gone away

/*

 * tb_free_unplugged_children() - traverse hierarchy and free unplugged switches

	/*

	 * To keep plugging devices consistently in the same PCIe

	 * hierarchy, do mapping here for switch downstream PCIe ports.

		/*

		 * Hard-coded Thunderbolt port to PCIe down port mapping

		 * per controller.

 Validate the hard-coding */

		/*

		 * Keep the DP tunnel under the topology starting from

		 * the same host router downstream port.

	/*

	 * Find pair of inactive DP IN and DP OUT adapters and then

	 * establish a DP tunnel between them.

	/*

	 * DP stream needs the domain to be active so runtime resume

	 * both ends of the tunnel.

	 *

	 * This should bring the routers in the middle active as well

	 * and keeps the domain from runtime suspending while the DP

	 * tunnel is active.

 Make all unused USB3 bandwidth available for the new DP tunnel */

	/*

	 * See if there is another DP OUT port that can be used for

	 * to create another tunnel.

 Look for suitable DP IN <-> DP OUT pairs now */

	/*

	 * Tear down all DP tunnels and release their resources. They

	 * will be re-established after resume based on plug events.

	/*

	 * Look up available down port. Since we are chaining it should

	 * be found right above this switch.

 hotplug handling */

/*

 * tb_handle_hotplug() - handle hotplug event

 *

 * Executes on tb->wq.

 Bring the domain back from sleep if it was suspended */

 during init, suspend or shutdown */

 Maybe we can create another DP tunnel */

			/*

			 * Service drivers are unbound during

			 * tb_xdomain_remove() so setting XDomain as

			 * unplugged here prevents deadlock if they call

			 * tb_xdomain_disable_paths(). We will tear down

			 * all the tunnels below.

/*

 * tb_schedule_hotplug_handler() - callback function for the control channel

 *

 * Delegates to tb_handle_hotplug.

 tunnels are only present after everything has been initialized */

		/*

		 * DMA tunnels require the driver to be functional so we

		 * tear them down. Other protocol tunnels can be left

		 * intact.

 signal tb_handle_hotplug to quit */

		/*

		 * If we found that the switch was already setup by the

		 * boot firmware, mark it as authorized now before we

		 * send uevent to userspace.

	/*

	 * ICM firmware upgrade needs running firmware and in native

	 * mode that is not available so disable firmware upgrade of the

	 * root switch.

 All USB4 routers support runtime PM */

 Announce the switch to the world */

 Enable TMU if it is off */

 Full scan to discover devices added before the driver was loaded. */

 Find out tunnels created by the boot firmware */

	/*

	 * If the boot firmware did not create USB 3.x tunnels create them

	 * now for the whole topology.

 Add DP IN resources for the root switch */

 Make the discovered switches available to the userspace */

 Allow tb_handle_hotplug to progress events */

 signal tb_handle_hotplug to quit */

 No need to restore if the router is already unplugged */

 remove any pci devices the firmware might have setup */

		/*

		 * the pcie links need some time to get going.

		 * 100ms works for me...

 Allow tb_handle_hotplug to progress events */

	/*

	 * Release any unplugged XDomains and if there is a case where

	 * another domain is swapped in place of unplugged XDomain we

	 * need to run another rescan.

	/*

	 * Schedule cleanup of any unplugged devices. Run this in a

	 * separate thread to avoid possible deadlock if the device

	 * removal runtime resumes the unplugged device.

/*

 * During suspend the Thunderbolt controller is reset and all PCIe

 * tunnels are lost. The NHI driver will try to reestablish all tunnels

 * during resume. This adds device links between the tunneled PCIe

 * downstream ports and the NHI so that the device core will make sure

 * NHI is resumed first before the rest.

	/*

	 * For each hotplug downstream port, create add device link

	 * back to NHI so that PCIe tunnels can be re-established after

	 * sleep.

 SPDX-License-Identifier: GPL-2.0

/*

 * Thunderbolt bus support

 *

 * Copyright (C) 2017, Intel Corporation

 * Author: Mika Westerberg <mika.westerberg@linux.intel.com>

	/*

	 * Make sure the value is not bigger than tb->nboot_acl * UUID

	 * length + commas and optional "\n". Also the smallest allowable

	 * string is tb->nboot_acl * ",".

 Notify userspace about the change */

 Only meaningful if authorization is supported */

	/*

	 * Kernel DMA protection is a feature where Thunderbolt security is

	 * handled natively using IOMMU. It is enabled when IOMMU is

	 * enabled and ACPI DMAR table has DMAR_PLATFORM_OPT_IN set.

/**

 * tb_domain_alloc() - Allocate a domain

 * @nhi: Pointer to the host controller

 * @timeout_msec: Control channel timeout for non-raw messages

 * @privsize: Size of the connection manager private data

 *

 * Allocates and initializes a new Thunderbolt domain. Connection

 * managers are expected to call this and then fill in @cm_ops

 * accordingly.

 *

 * Call tb_domain_put() to release the domain before it has been added

 * to the system.

 *

 * Return: allocated domain structure on %NULL in case of error

	/*

	 * Make sure the structure sizes map with that the hardware

	 * expects because bit-fields are being used.

/**

 * tb_domain_add() - Add domain to the system

 * @tb: Domain to add

 *

 * Starts the domain and adds it to the system. Hotplugging devices will

 * work after this has been returned successfully. In order to remove

 * and release the domain after this function has been called, call

 * tb_domain_remove().

 *

 * Return: %0 in case of success and negative errno in case of error

	/*

	 * tb_schedule_hotplug_handler may be called as soon as the config

	 * channel is started. Thats why we have to hold the lock here.

 Start the domain */

 This starts event processing */

/**

 * tb_domain_remove() - Removes and releases a domain

 * @tb: Domain to remove

 *

 * Stops the domain, removes it from the system and releases all

 * resources once the last reference has been released.

 Stop the domain control traffic */

/**

 * tb_domain_suspend_noirq() - Suspend a domain

 * @tb: Domain to suspend

 *

 * Suspends all devices in the domain and stops the control channel.

	/*

	 * The control channel interrupt is left enabled during suspend

	 * and taking the lock here prevents any events happening before

	 * we actually have stopped the domain and the control channel.

/**

 * tb_domain_resume_noirq() - Resume a domain

 * @tb: Domain to resume

 *

 * Re-starts the control channel, and resumes all devices connected to

 * the domain.

/**

 * tb_domain_disapprove_switch() - Disapprove switch

 * @tb: Domain the switch belongs to

 * @sw: Switch to disapprove

 *

 * This will disconnect PCIe tunnel from parent to this @sw.

 *

 * Return: %0 on success and negative errno in case of failure.

/**

 * tb_domain_approve_switch() - Approve switch

 * @tb: Domain the switch belongs to

 * @sw: Switch to approve

 *

 * This will approve switch by connection manager specific means. In

 * case of success the connection manager will create PCIe tunnel from

 * parent to @sw.

 The parent switch must be authorized before this one */

/**

 * tb_domain_approve_switch_key() - Approve switch and add key

 * @tb: Domain the switch belongs to

 * @sw: Switch to approve

 *

 * For switches that support secure connect, this function first adds

 * key to the switch NVM using connection manager specific means. If

 * adding the key is successful, the switch is approved and connected.

 *

 * Return: %0 on success and negative errno in case of failure.

 The parent switch must be authorized before this one */

/**

 * tb_domain_challenge_switch_key() - Challenge and approve switch

 * @tb: Domain the switch belongs to

 * @sw: Switch to approve

 *

 * For switches that support secure connect, this function generates

 * random challenge and sends it to the switch. The switch responds to

 * this and if the response matches our random challenge, the switch is

 * approved and connected.

 *

 * Return: %0 on success and negative errno in case of failure.

 The parent switch must be authorized before this one */

 The returned HMAC must match the one we calculated */

/**

 * tb_domain_disconnect_pcie_paths() - Disconnect all PCIe paths

 * @tb: Domain whose PCIe paths to disconnect

 *

 * This needs to be called in preparation for NVM upgrade of the host

 * controller. Makes sure all PCIe paths are disconnected.

 *

 * Return %0 on success and negative errno in case of error.

/**

 * tb_domain_approve_xdomain_paths() - Enable DMA paths for XDomain

 * @tb: Domain enabling the DMA paths

 * @xd: XDomain DMA paths are created to

 * @transmit_path: HopID we are using to send out packets

 * @transmit_ring: DMA ring used to send out packets

 * @receive_path: HopID the other end is using to send packets to us

 * @receive_ring: DMA ring used to receive packets from @receive_path

 *

 * Calls connection manager specific method to enable DMA paths to the

 * XDomain in question.

 *

 * Return: 0% in case of success and negative errno otherwise. In

 * particular returns %-ENOTSUPP if the connection manager

 * implementation does not support XDomains.

/**

 * tb_domain_disconnect_xdomain_paths() - Disable DMA paths for XDomain

 * @tb: Domain disabling the DMA paths

 * @xd: XDomain whose DMA paths are disconnected

 * @transmit_path: HopID we are using to send out packets

 * @transmit_ring: DMA ring used to send out packets

 * @receive_path: HopID the other end is using to send packets to us

 * @receive_ring: DMA ring used to receive packets from @receive_path

 *

 * Calls connection manager specific method to disconnect DMA paths to

 * the XDomain in question.

 *

 * Return: 0% in case of success and negative errno otherwise. In

 * particular returns %-ENOTSUPP if the connection manager

 * implementation does not support XDomains.

/**

 * tb_domain_disconnect_all_paths() - Disconnect all paths for the domain

 * @tb: Domain whose paths are disconnected

 *

 * This function can be used to disconnect all paths (PCIe, XDomain) for

 * example in preparation for host NVM firmware upgrade. After this is

 * called the paths cannot be established without resetting the switch.

 *

 * Return: %0 in case of success and negative errno otherwise.

 SPDX-License-Identifier: GPL-2.0

/*

 * Thunderbolt driver - capabilities lookup

 *

 * Copyright (c) 2014 Andreas Noever <andreas.noever@gmail.com>

 * Copyright (C) 2018, Intel Corporation

	/*

	 * Legacy devices need to have TMU access enabled before port

	 * space can be fully accessed.

	/*

	 * When reading from next capability pointer location in port

	 * config space the read data is not cleared on LR. To avoid

	 * reading stale data on next read perform one dummy read after

	 * port capabilities are walked.

/**

 * tb_port_next_cap() - Return next capability in the linked list

 * @port: Port to find the capability for

 * @offset: Previous capability offset (%0 for start)

 *

 * Returns dword offset of the next capability in port config space

 * capability list and returns it. Passing %0 returns the first entry in

 * the capability list. If no next capability is found returns %0. In case

 * of failure returns negative errno.

/**

 * tb_port_find_cap() - Find port capability

 * @port: Port to find the capability for

 * @cap: Capability to look

 *

 * Returns offset to start of capability or %-ENOENT if no such

 * capability was found. Negative errno is returned if there was an

 * error.

/**

 * tb_switch_next_cap() - Return next capability in the linked list

 * @sw: Switch to find the capability for

 * @offset: Previous capability offset (%0 for start)

 *

 * Finds dword offset of the next capability in router config space

 * capability list and returns it. Passing %0 returns the first entry in

 * the capability list. If no next capability is found returns %0. In case

 * of failure returns negative errno.

/**

 * tb_switch_find_cap() - Find switch capability

 * @sw: Switch to find the capability for

 * @cap: Capability to look

 *

 * Returns offset to start of capability or %-ENOENT if no such

 * capability was found. Negative errno is returned if there was an

 * error.

/**

 * tb_switch_find_vse_cap() - Find switch vendor specific capability

 * @sw: Switch to find the capability for

 * @vsec: Vendor specific capability to look

 *

 * Functions enumerates vendor specific capabilities (VSEC) of a switch

 * and returns offset when capability matching @vsec is found. If no

 * such capability is found returns %-ENOENT. In case of error returns

 * negative errno.

 SPDX-License-Identifier: GPL-2.0

/*

 * Debugfs interface

 *

 * Copyright (C) 2020, Intel Corporation

 * Authors: Gil Fine <gil.fine@intel.com>

 *	    Mika Westerberg <mika.westerberg@linux.intel.com>

	/*

	 * For Adapter/Router configuration space:

	 * Short format is: offset value\n

	 *		    v[0]   v[1]

	 * Long format as produced from the read side:

	 * offset relative_offset cap_id vs_cap_id value\n

	 * v[0]   v[1]            v[2]   v[3]      v[4]

	 *

	 * For Counter configuration space:

	 * Short format is: offset\n

	 *		    v[0]

	 * Long format as produced from the read side:

	 * offset relative_offset counter_id value\n

	 * v[0]   v[1]            v[2]       v[3]

 In case of Counters, clear counter, "val" content is NA */

 User did hardware changes behind the driver's back */

 If written delimiter only, clear all counters in one shot */

 Only USB4 has the additional registers */

 NHI and lane adapters have entry for path 0 */

/**

 * tb_switch_debugfs_init() - Add debugfs entries for router

 * @sw: Pointer to the router

 *

 * Adds debugfs directories and files for given router.

/**

 * tb_switch_debugfs_remove() - Remove all router debugfs entries

 * @sw: Pointer to the router

 *

 * Removes all previously added debugfs entries under this router.

/**

 * tb_service_debugfs_init() - Add debugfs directory for service

 * @svc: Thunderbolt service pointer

 *

 * Adds debugfs directory for service.

/**

 * tb_service_debugfs_remove() - Remove service debugfs directory

 * @svc: Thunderbolt service pointer

 *

 * Removes the previously created debugfs directory for @svc.

 SPDX-License-Identifier: GPL-2.0

/*

 * KUnit tests

 *

 * Copyright (C) 2020, Intel Corporation

 * Author: Mika Westerberg <mika.westerberg@linux.intel.com>

 Link them */

 Bonding is used */

 No connection between host and dev */

 Other direction */

	/*

	 * Walks from Host PCIe downstream port to Device #1 PCIe

	 * upstream port.

	 *

	 *   [Host]

	 *   1 |

	 *   1 |

	 *  [Device]

 Walk both directions */

	/*

	 * Walks from Host DP IN to Device #2 DP OUT.

	 *

	 *           [Host]

	 *            1 |

	 *            1 |

	 *         [Device #1]

	 *       3 /

	 *      1 /

	 * [Device #2]

 Walk both directions */

	/*

	 * Walks from Host DP IN to Device #3 DP OUT.

	 *

	 *           [Host]

	 *            1 |

	 *            1 |

	 *         [Device #1]

	 *       3 /   | 5  \ 7

	 *      1 /    |     \ 1

	 * [Device #2] |    [Device #4]

	 *             | 1

	 *         [Device #3]

 Walk both directions */

	/*

	 * Walks from Device #3 DP IN to Device #9 DP OUT.

	 *

	 *           [Host]

	 *            1 |

	 *            1 |

	 *         [Device #1]

	 *       3 /   | 5  \ 7

	 *      1 /    |     \ 1

	 * [Device #2] |    [Device #5]

	 *    5 |      | 1         \ 7

	 *    1 |  [Device #4]      \ 1

	 * [Device #3]             [Device #6]

	 *                       3 /

	 *                      1 /

	 *                    [Device #7]

	 *                  3 /      | 5

	 *                 1 /       |

	 *               [Device #8] | 1

	 *                       [Device #9]

 Walk both directions */

	/*

	 * Walks from Device #6 DP IN to Device #12 DP OUT.

	 *

	 *          [Host]

	 *         1 /  \ 3

	 *        1 /    \ 1

	 * [Device #1]   [Device #7]

	 *     3 |           | 3

	 *     1 |           | 1

	 * [Device #2]   [Device #8]

	 *     3 |           | 3

	 *     1 |           | 1

	 * [Device #3]   [Device #9]

	 *     3 |           | 3

	 *     1 |           | 1

	 * [Device #4]   [Device #10]

	 *     3 |           | 3

	 *     1 |           | 1

	 * [Device #5]   [Device #11]

	 *     3 |           | 3

	 *     1 |           | 1

	 * [Device #6]   [Device #12]

 Walk both directions */

 Not connected to anything */

	/*

	 * PCIe path from host to device using lane 0.

	 *

	 *   [Host]

	 *   3 |: 4

	 *   1 |: 2

	 *  [Device]

	/*

	 * DP Video path from host to device using lane 1. Paths like

	 * these are only used with Thunderbolt 1 devices where lane

	 * bonding is not possible. USB4 specifically does not allow

	 * paths like this (you either use lane 0 where lane 1 is

	 * disabled or both lanes are bonded).

	 *

	 *   [Host]

	 *   1 :| 2

	 *   1 :| 2

	 *  [Device]

	/*

	 * DP Video path from host to device 3 using lane 1.

	 *

	 *    [Host]

	 *    1 :| 2

	 *    1 :| 2

	 *  [Device #1]

	 *    7 :| 8

	 *    1 :| 2

	 *  [Device #2]

	 *    5 :| 6

	 *    1 :| 2

	 *  [Device #3]

	/*

	 * DP Video path from device 3 to host using lane 1.

	 *

	 *    [Host]

	 *    1 :| 2

	 *    1 :| 2

	 *  [Device #1]

	 *    7 :| 8

	 *    1 :| 2

	 *  [Device #2]

	 *    5 :| 6

	 *    1 :| 2

	 *  [Device #3]

	/*

	 * DP Video path from host to device 4 where first and last link

	 * is bonded.

	 *

	 *    [Host]

	 *    1 |

	 *    1 |

	 *  [Device #1]

	 *    7 :| 8

	 *    1 :| 2

	 *  [Device #2]

	 *    5 :| 6

	 *    1 :| 2

	 *  [Device #3]

	 *    3 |

	 *    1 |

	 *  [Device #4]

	/*

	 * DP Video path from device 4 to host where first and last link

	 * is bonded.

	 *

	 *    [Host]

	 *    1 |

	 *    1 |

	 *  [Device #1]

	 *    7 :| 8

	 *    1 :| 2

	 *  [Device #2]

	 *    5 :| 6

	 *    1 :| 2

	 *  [Device #3]

	 *    3 |

	 *    1 |

	 *  [Device #4]

	/*

	 * Create PCIe tunnel between host and two devices.

	 *

	 *   [Host]

	 *    1 |

	 *    1 |

	 *  [Device #1]

	 *    5 |

	 *    1 |

	 *  [Device #2]

	/*

	 * Create DP tunnel between Host and Device

	 *

	 *   [Host]

	 *   1 |

	 *   1 |

	 *  [Device]

	/*

	 * Create DP tunnel from Host DP IN to Device #4 DP OUT.

	 *

	 *           [Host]

	 *            1 |

	 *            1 |

	 *         [Device #1]

	 *       3 /   | 5  \ 7

	 *      1 /    |     \ 1

	 * [Device #2] |    [Device #4]

	 *             | 1

	 *         [Device #3]

	/*

	 * Create DP tunnel from Device #2 DP IN to Device #5 DP OUT.

	 *

	 *          [Host]

	 *           3 |

	 *           1 |

	 *         [Device #1]

	 *       3 /   | 5  \ 7

	 *      1 /    |     \ 1

	 * [Device #2] |    [Device #4]

	 *             | 1

	 *         [Device #3]

	 *             | 5

	 *             | 1

	 *         [Device #5]

	/*

	 * Creates DP tunnel from Device #6 to Device #12.

	 *

	 *          [Host]

	 *         1 /  \ 3

	 *        1 /    \ 1

	 * [Device #1]   [Device #7]

	 *     3 |           | 3

	 *     1 |           | 1

	 * [Device #2]   [Device #8]

	 *     3 |           | 3

	 *     1 |           | 1

	 * [Device #3]   [Device #9]

	 *     3 |           | 3

	 *     1 |           | 1

	 * [Device #4]   [Device #10]

	 *     3 |           | 3

	 *     1 |           | 1

	 * [Device #5]   [Device #11]

	 *     3 |           | 3

	 *     1 |           | 1

	 * [Device #6]   [Device #12]

 First hop */

 Middle */

 Last */

	/*

	 * Create USB3 tunnel between host and two devices.

	 *

	 *   [Host]

	 *    1 |

	 *    1 |

	 *  [Device #1]

	 *          \ 7

	 *           \ 1

	 *         [Device #2]

	/*

	 *          [Host]

	 *           3 |

	 *           1 |

	 *         [Device #1]

	 *       3 /   | 5  \ 7

	 *      1 /    |     \ 1

	 * [Device #2] |    [Device #4]

	 *             | 1

	 *         [Device #3]

	 *             | 5

	 *             | 1

	 *         [Device #5]

	/*

	 * Create DMA tunnel from NHI to port 1 and back.

	 *

	 *   [Host 1]

	 *    1 ^ In HopID 1 -> Out HopID 8

	 *      |

	 *      v In HopID 8 -> Out HopID 1

	 * ............ Domain border

	 *      |

	 *   [Host 2]

 RX path */

 TX path */

	/*

	 * Create DMA RX tunnel from port 1 to NHI.

	 *

	 *   [Host 1]

	 *    1 ^

	 *      |

	 *      | In HopID 15 -> Out HopID 2

	 * ............ Domain border

	 *      |

	 *   [Host 2]

 RX path */

	/*

	 * Create DMA TX tunnel from NHI to port 1.

	 *

	 *   [Host 1]

	 *    1 | In HopID 2 -> Out HopID 15

	 *      |

	 *      v

	 * ............ Domain border

	 *      |

	 *   [Host 2]

 TX path */

	/*

	 * Create DMA tunnel from NHI to Device #2 port 3 and back.

	 *

	 *   [Host 1]

	 *    1 ^ In HopID 1 -> Out HopID x

	 *      |

	 *    1 | In HopID x -> Out HopID 1

	 *  [Device #1]

	 *         7 \

	 *          1 \

	 *         [Device #2]

	 *           3 | In HopID x -> Out HopID 8

	 *             |

	 *             v In HopID 8 -> Out HopID x

	 * ............ Domain border

	 *             |

	 *          [Host 2]

 RX path */

 TX path */

 Video (main) path */

 AUX TX */

 AUX RX */

 DMA RX */

 DMA TX */

	/*

	 * Create three DMA tunnels through the same ports. With the

	 * default buffers we should be able to create two and the last

	 * one fails.

	 *

	 * For default host we have following buffers for DMA:

	 *

	 *   120 - (2 + 2 * (1 + 0) + 32 + 64 + spare) = 20

	 *

	 * For device we have following:

	 *

	 *  120 - (2 + 2 * (1 + 18) + 14 + 32 + spare) = 34

	 *

	 * spare = 14 + 1 = 15

	 *

	 * So on host the first tunnel gets 14 and the second gets the

	 * remaining 1 and then we run out of buffers.

	/*

	 * Release the first DMA tunnel. That should make 14 buffers

	 * available for the next tunnel.

	/*

	 * Create PCIe, 2 x DP, USB 3.x and two DMA tunnels from host to

	 * device. Expectation is that all these can be established with

	 * the default credit allocation found in Intel hardware.

 "UXD" v1 */

 Root directory length */

 "vend" */

 "orid" */

 "v" R 1 */

 Immediate value, ! Vendor ID */

 "vend" */

 "orid" */

 "t" R 3 */

 Text leaf offset, (Apple Inc.) */

 "devi" */

 "ceid" */

 "v" R 1 */

 Immediate value, ! Device ID */

 "devi" */

 "ceid" */

 "t" R 3 */

 Text leaf offset, (Macintosh) */

 "devi" */

 "cerv" */

 "v" R 1 */

 Immediate value, Device Revision */

 "netw" */

 "ork" */

 "D" R 20 */

 Directory data offset, (Network Directory) */

 "Appl" */

 "e In" */

 "c." ! */

 "Maci" */

 "ntos" */

 "h" */

 padding */

 Directory UUID, Network Directory */

 Directory UUID, Network Directory */

 Directory UUID, Network Directory */

 Directory UUID, Network Directory */

 "prtc" */

 "id" */

 "v" R 1 */

 Immediate value, Network Protocol ID */

 "prtc" */

 "vers" */

 "v" R 1 */

 Immediate value, Network Protocol Version */

 "prtc" */

 "revs" */

 "v" R 1 */

 Immediate value, Network Protocol Revision */

 "prtc" */

 "stns" */

 "v" R 1 */

 Immediate value, Network Protocol Settings */

 Compare the structures */

 Compare the resulting property block */

 SPDX-License-Identifier: GPL-2.0

/*

 * Thunderbolt link controller support

 *

 * Copyright (C) 2019, Intel Corporation

 * Author: Mika Westerberg <mika.westerberg@linux.intel.com>

/**

 * tb_lc_read_uuid() - Read switch UUID from link controller common register

 * @sw: Switch whose UUID is read

 * @uuid: UUID is placed here

 Start of port LC registers */

 Resolve correct lane */

/**

 * tb_lc_configure_port() - Let LC know about configured port

 * @port: Port that is set as configured

 *

 * Sets the port configured for power management purposes.

/**

 * tb_lc_unconfigure_port() - Let LC know about unconfigured port

 * @port: Port that is set as configured

 *

 * Sets the port unconfigured for power management purposes.

 Resolve correct lane */

/**

 * tb_lc_configure_xdomain() - Inform LC that the link is XDomain

 * @port: Switch downstream port connected to another host

 *

 * Sets the lane configured for XDomain accordingly so that the LC knows

 * about this. Returns %0 in success and negative errno in failure.

/**

 * tb_lc_unconfigure_xdomain() - Unconfigure XDomain from port

 * @port: Switch downstream port that was connected to another host

 *

 * Unsets the lane XDomain configuration.

/**

 * tb_lc_start_lane_initialization() - Start lane initialization

 * @port: Device router lane 0 adapter

 *

 * Starts lane initialization for @port after the router resumed from

 * sleep. Should be called for those downstream lane adapters that were

 * not connected (tb_lc_configure_port() was not called) before sleep.

 *

 * Returns %0 in success and negative errno in case of failure.

	/*

	 * Enable wake on PCIe and USB4 (wake coming from another

	 * router).

/**

 * tb_lc_set_wake() - Enable/disable wake

 * @sw: Switch whose wakes to configure

 * @flags: Wakeup flags (%0 to disable)

 *

 * For each LC sets wake bits accordingly.

 Figure out number of link controllers */

 For each link controller set sleep bit */

/**

 * tb_lc_set_sleep() - Inform LC that the switch is going to sleep

 * @sw: Switch to set sleep

 *

 * Let the switch link controllers know that the switch is going to

 * sleep.

 Figure out number of link controllers */

 For each link controller set sleep bit */

/**

 * tb_lc_lane_bonding_possible() - Is lane bonding possible towards switch

 * @sw: Switch to check

 *

 * Checks whether conditions for lane bonding from parent to @sw are

 * possible.

 The first DP IN port is sink 0 and second is sink 1 */

	/*

	 * Sink is available for CM/SW to use if the allocation valie is

	 * either 0 or 1.

/**

 * tb_lc_dp_sink_query() - Is DP sink available for DP IN port

 * @sw: Switch whose DP sink is queried

 * @in: DP IN port to check

 *

 * Queries through LC SNK_ALLOCATION registers whether DP sink is available

 * for the given DP IN port or not.

	/*

	 * For older generations sink is always available as there is no

	 * allocation mechanism.

/**

 * tb_lc_dp_sink_alloc() - Allocate DP sink

 * @sw: Switch whose DP sink is allocated

 * @in: DP IN port the DP sink is allocated for

 *

 * Allocate DP sink for @in via LC SNK_ALLOCATION registers. If the

 * resource is available and allocation is successful returns %0. In all

 * other cases returs negative errno. In particular %-EBUSY is returned if

 * the resource was not available.

/**

 * tb_lc_dp_sink_dealloc() - De-allocate DP sink

 * @sw: Switch whose DP sink is de-allocated

 * @in: DP IN port whose DP sink is de-allocated

 *

 * De-allocate DP sink from @in using LC SNK_ALLOCATION registers.

 Needs to be owned by CM/SW */

/**

 * tb_lc_force_power() - Forces LC to be powered on

 * @sw: Thunderbolt switch

 *

 * This is useful to let authentication cycle pass even without

 * a Thunderbolt link present.

 SPDX-License-Identifier: GPL-2.0

/*

 * Thunderbolt driver - control channel and configuration commands

 *

 * Copyright (c) 2014 Andreas Noever <andreas.noever@gmail.com>

 * Copyright (C) 2018, Intel Corporation

/**

 * struct tb_ctl - Thunderbolt control channel

 * @nhi: Pointer to the NHI structure

 * @tx: Transmit ring

 * @rx: Receive ring

 * @frame_pool: DMA pool for control messages

 * @rx_packets: Received control messages

 * @request_queue_lock: Lock protecting @request_queue

 * @request_queue: List of outstanding requests

 * @running: Is the control channel running at the moment

 * @timeout_msec: Default timeout for non-raw control messages

 * @callback: Callback called when hotplug message is received

 * @callback_data: Data passed to @callback

 Serializes access to request kref_get/put */

/**

 * tb_cfg_request_alloc() - Allocates a new config request

 *

 * This is refcounted object so when you are done with this, call

 * tb_cfg_request_put() to it.

/**

 * tb_cfg_request_get() - Increase refcount of a request

 * @req: Request whose refcount is increased

/**

 * tb_cfg_request_put() - Decrease refcount and possibly release the request

 * @req: Request whose refcount is decreased

 *

 * Call this function when you are done with the request. When refcount

 * goes to %0 the object is released.

 utility functions */

 check frame, TODO: frame flags */

 check header */

	/*

	 * We cannot check addr->port as it is set to the upstream port of the

	 * sender.

 will be updated later for cfg_read/write */

		/* Port is not connected. This can happen during surprise

		/*

		 * Invalid cfg_space/offset/length combination in

		 * cfg_read/cfg_write.

		/*

		 * - The route contains a non-existent port.

		 * - The route contains a non-PHY port (e.g. PCIe).

		 * - The port in cfg_read/cfg_write does not exist.

 5,6,7,9 and 11 are also valid error codes */

 RX/TX handling */

/*

 * tb_cfg_tx() - transmit a packet on the control channel

 *

 * len must be a multiple of four.

 *

 * Return: Returns 0 on success or an error code on failure.

 required for le->be conversion */

 checksum is 4 bytes */

 ring is stopped */

/*

 * tb_ctl_handle_event() - acknowledge a plug event, invoke ctl->callback

	tb_ring_rx(pkg->ctl->rx, &pkg->frame); /*

					     * We ignore failures during stop.

					     * All rx packets are referenced

					     * from ctl->rx_packets, so we do

					     * not loose them.

		return; /*

			 * ring is stopped, packet is referenced from

			 * ctl->rx_packets.

 remove checksum */

	/*

	 * The received packet will be processed only if there is an

	 * active request and that the packet is what is expected. This

	 * prevents packets such as replies coming after timeout has

	 * triggered from messing with the active requests.

/**

 * tb_cfg_request() - Start control request not waiting for it to complete

 * @ctl: Control channel to use

 * @req: Request to start

 * @callback: Callback called when the request is completed

 * @callback_data: Data to be passed to @callback

 *

 * This queues @req on the given control channel without waiting for it

 * to complete. When the request completes @callback is called.

/**

 * tb_cfg_request_cancel() - Cancel a control request

 * @req: Request to cancel

 * @err: Error to assign to the request

 *

 * This function can be used to cancel ongoing request. It will wait

 * until the request is not active anymore.

/**

 * tb_cfg_request_sync() - Start control request and wait until it completes

 * @ctl: Control channel to use

 * @req: Request to start

 * @timeout_msec: Timeout how long to wait @req to complete

 *

 * Starts a control request and waits until it completes. If timeout

 * triggers the request is canceled before function returns. Note the

 * caller needs to make sure only one message for given switch is active

 * at a time.

 public interface, alloc/start/stop/free */

/**

 * tb_ctl_alloc() - allocate a control channel

 * @nhi: Pointer to NHI

 * @timeout_msec: Default timeout used with non-raw control messages

 * @cb: Callback called for plug events

 * @cb_data: Data passed to @cb

 *

 * cb will be invoked once for every hot plug event.

 *

 * Return: Returns a pointer on success or NULL on failure.

/**

 * tb_ctl_free() - free a control channel

 * @ctl: Control channel to free

 *

 * Must be called after tb_ctl_stop.

 *

 * Must NOT be called from ctl->callback.

 free RX packets */

/**

 * tb_cfg_start() - start/resume the control channel

 * @ctl: Control channel to start

 is used to ack hotplug packets, start first */

/**

 * tb_ctrl_stop() - pause the control channel

 * @ctl: Control channel to stop

 *

 * All invocations of ctl->callback will have finished after this method

 * returns.

 *

 * Must NOT be called from ctl->callback.

 public interface, commands */

/**

 * tb_cfg_ack_plug() - Ack hot plug/unplug event

 * @ctl: Control channel to use

 * @route: Router that originated the event

 * @port: Port where the hot plug/unplug happened

 * @unplug: Ack hot plug or unplug

 *

 * Call this as response for hot plug/unplug event to ack it.

 * Returns %0 on success or an error code on failure.

 Now make sure it is in expected format */

 Always complete when first response is received */

/**

 * tb_cfg_reset() - send a reset packet and wait for a response

 * @ctl: Control channel pointer

 * @route: Router string for the router to send reset

 *

 * If the switch at route is incorrectly configured then we will not receive a

 * reply (even though the switch will reset). The caller should check for

 * -ETIMEDOUT and attempt to reconfigure the switch.

/**

 * tb_cfg_read_raw() - read from config space into buffer

 * @ctl: Pointer to the control channel

 * @buffer: Buffer where the data is read

 * @route: Route string of the router

 * @port: Port number when reading from %TB_CFG_PORT, %0 otherwise

 * @space: Config space selector

 * @offset: Dword word offset of the register to start reading

 * @length: Number of dwords to read

 * @timeout_msec: Timeout in ms how long to wait for the response

 *

 * Reads from router config space without translating the possible error.

 Wait a bit (arbitrary time) until we send a retry */

/**

 * tb_cfg_write() - write from buffer into config space

 * @ctl: Pointer to the control channel

 * @buffer: Data to write

 * @route: Route string of the router

 * @port: Port number when writing to %TB_CFG_PORT, %0 otherwise

 * @space: Config space selector

 * @offset: Dword word offset of the register to start writing

 * @length: Number of dwords to write

 * @timeout_msec: Timeout in ms how long to wait for the response

 *

 * Writes to router config space without translating the possible error.

 Wait a bit (arbitrary time) until we send a retry */

	/*

	 * For unimplemented ports access to port config space may return

	 * TB_CFG_ERROR_INVALID_CONFIG_SPACE (alternatively their type is

	 * set to TB_TYPE_INACTIVE). In the former case return -ENODEV so

	 * that the caller can mark the port as disabled.

 Success */

 Thunderbolt error, tb_error holds the actual number */

 Success */

 Thunderbolt error, tb_error holds the actual number */

/**

 * tb_cfg_get_upstream_port() - get upstream port number of switch at route

 * @ctl: Pointer to the control channel

 * @route: Route string of the router

 *

 * Reads the first dword from the switches TB_CFG_SWITCH config area and

 * returns the port number from which the reply originated.

 *

 * Return: Returns the upstream port number on success or an error code on

 * failure.

 SPDX-License-Identifier: GPL-2.0

/*

 * DMA traffic test driver

 *

 * Copyright (C) 2020, Intel Corporation

 * Authors: Isaac Hazan <isaac.hazan@intel.com>

 *	    Mika Westerberg <mika.westerberg@linux.intel.com>

/**

 * struct dma_test - DMA test device driver private data

 * @svc: XDomain service the driver is bound to

 * @xd: XDomain the service belongs to

 * @rx_ring: Software ring holding RX frames

 * @rx_hopid: HopID used for receiving frames

 * @tx_ring: Software ring holding TX frames

 * @tx_hopid: HopID used for sending fames

 * @packets_to_send: Number of packets to send

 * @packets_to_receive: Number of packets to receive

 * @packets_sent: Actual number of packets sent

 * @packets_received: Actual number of packets received

 * @link_speed: Expected link speed (Gb/s), %0 to use whatever is negotiated

 * @link_width: Expected link width (Gb/s), %0 to use whatever is negotiated

 * @crc_errors: Number of CRC errors during the test run

 * @buffer_overflow_errors: Number of buffer overflow errors during the test

 *			    run

 * @result: Result of the last run

 * @error_code: Error code of the last run

 * @complete: Used to wait for the Rx to complete

 * @lock: Lock serializing access to this structure

 * @debugfs_dir: dentry of this dma_test

 DMA test property directory UUID: 3188cd10-6523-4a5a-a682-fdca07a248d8 */

	/*

	 * If we are both sender and receiver (traffic goes over a

	 * special loopback dongle) enable E2E flow control. This avoids

	 * losing packets.

 means 4096 */

	/*

	 * No need to do anything special here. If userspace is writing

	 * to the test attribute when suspend started, it comes out from

	 * wait_for_completion_interruptible() with -ERESTARTSYS and the

	 * DMA test fails tearing down the rings. Once userspace is

	 * thawed the kernel restarts the write syscall effectively

	 * re-running the test.

 SPDX-License-Identifier: GPL-2.0

/*

 * USB4 specific functionality

 *

 * Copyright (C) 2019, Intel Corporation

 * Authors: Mika Westerberg <mika.westerberg@linux.intel.com>

 *	    Rajmohan Mani <rajmohan.mani@intel.com>

	/*

	 * If the connection manager implementation provides USB4 router

	 * operation proxy callback, call it here instead of running the

	 * operation natively.

		/*

		 * If the proxy was not supported then run the native

		 * router operation instead.

 Check for any connected downstream ports for USB4 wake */

/**

 * usb4_switch_setup() - Additional setup for USB4 device

 * @sw: USB4 router to setup

 *

 * USB4 routers need additional settings in order to enable all the

 * tunneling. This function enables USB and PCIe tunneling if it can be

 * enabled (e.g the parent switch also supports them). If USB tunneling

 * is not available for some reason (like that there is Thunderbolt 3

 * switch upstream) then the internal xHCI controller is enabled

 * instead.

	/*

	 * Only enable PCIe tunneling if the parent router supports it

	 * and it is not disabled.

		/*

		 * xHCI can be enabled if PCIe tunneling is supported

		 * and the parent does not have any USB3 dowstream

		 * adapters (so we cannot do USB 3.x tunneling).

 TBT3 supported by the CM */

 Tunneling configuration is ready now */

/**

 * usb4_switch_read_uid() - Read UID from USB4 router

 * @sw: USB4 router

 * @uid: UID is stored here

 *

 * Reads 64-bit UID from USB4 router config space.

/**

 * usb4_switch_drom_read() - Read arbitrary bytes from USB4 router DROM

 * @sw: USB4 router

 * @address: Byte address inside DROM to start reading

 * @buf: Buffer where the DROM content is stored

 * @size: Number of bytes to read from DROM

 *

 * Uses USB4 router operations to read router DROM. For devices this

 * should always work but for hosts it may return %-EOPNOTSUPP in which

 * case the host router does not have DROM.

/**

 * usb4_switch_lane_bonding_possible() - Are conditions met for lane bonding

 * @sw: USB4 router

 *

 * Checks whether conditions are met so that lane bonding can be

 * established with the upstream router. Call only for device routers.

/**

 * usb4_switch_set_wake() - Enabled/disable wake

 * @sw: USB4 router

 * @flags: Wakeup flags (%0 to disable)

 *

 * Enables/disables router to wake up from sleep.

	/*

	 * Enable wakes coming from all USB4 downstream ports (from

	 * child routers). For device routers do this also for the

	 * upstream USB4 port.

	/*

	 * Enable wakes from PCIe, USB 3.x and DP on this router. Only

	 * needed for device routers.

/**

 * usb4_switch_set_sleep() - Prepare the router to enter sleep

 * @sw: USB4 router

 *

 * Sets sleep bit for the router. Returns when the router sleep ready

 * bit has been asserted.

 Set sleep bit and wait for sleep ready to be asserted */

/**

 * usb4_switch_nvm_sector_size() - Return router NVM sector size

 * @sw: USB4 router

 *

 * If the router supports NVM operations this function returns the NVM

 * sector size in bytes. If NVM operations are not supported returns

 * %-EOPNOTSUPP.

/**

 * usb4_switch_nvm_read() - Read arbitrary bytes from router NVM

 * @sw: USB4 router

 * @address: Starting address in bytes

 * @buf: Read data is placed here

 * @size: How many bytes to read

 *

 * Reads NVM contents of the router. If NVM is not supported returns

 * %-EOPNOTSUPP.

/**

 * usb4_switch_nvm_set_offset() - Set NVM write offset

 * @sw: USB4 router

 * @address: Start offset

 *

 * Explicitly sets NVM write offset. Normally when writing to NVM this

 * is done automatically by usb4_switch_nvm_write().

 *

 * Returns %0 in success and negative errno if there was a failure.

/**

 * usb4_switch_nvm_write() - Write to the router NVM

 * @sw: USB4 router

 * @address: Start address where to write in bytes

 * @buf: Pointer to the data to write

 * @size: Size of @buf in bytes

 *

 * Writes @buf to the router NVM using USB4 router operations. If NVM

 * write is not supported returns %-EOPNOTSUPP.

/**

 * usb4_switch_nvm_authenticate() - Authenticate new NVM

 * @sw: USB4 router

 *

 * After the new NVM has been written via usb4_switch_nvm_write(), this

 * function triggers NVM authentication process. The router gets power

 * cycled and if the authentication is successful the new NVM starts

 * running. In case of failure returns negative errno.

 *

 * The caller should call usb4_switch_nvm_authenticate_status() to read

 * the status of the authentication after power cycle. It should be the

 * first router operation to avoid the status being lost.

	/*

	 * The router is power cycled once NVM_AUTH is started so it is

	 * expected to get any of the following errors back.

/**

 * usb4_switch_nvm_authenticate_status() - Read status of last NVM authenticate

 * @sw: USB4 router

 * @status: Status code of the operation

 *

 * The function checks if there is status available from the last NVM

 * authenticate router operation. If there is status then %0 is returned

 * and the status code is placed in @status. Returns negative errno in case

 * of failure.

 *

 * Must be called before any other router operation.

 Check that the opcode is correct */

/**

 * usb4_switch_credits_init() - Read buffer allocation parameters

 * @sw: USB4 router

 *

 * Reads @sw buffer allocation parameters and initializes @sw buffer

 * allocation fields accordingly. Specifically @sw->credits_allocation

 * is set to %true if these parameters can be used in tunneling.

 *

 * Returns %0 on success and negative errno otherwise.

	/*

	 * Validate the buffer allocation preferences. If we find

	 * issues, log a warning and fall back using the hard-coded

	 * values.

 Host router must report baMaxHI */

 Must have DP buffer allocation (multiple USB4 ports) */

	/*

	 * Buffer allocation passed the validation so we can use it in

	 * path creation.

/**

 * usb4_switch_query_dp_resource() - Query availability of DP IN resource

 * @sw: USB4 router

 * @in: DP IN adapter

 *

 * For DP tunneling this function can be used to query availability of

 * DP IN resource. Returns true if the resource is available for DP

 * tunneling, false otherwise.

	/*

	 * If DP resource allocation is not supported assume it is

	 * always available.

/**

 * usb4_switch_alloc_dp_resource() - Allocate DP IN resource

 * @sw: USB4 router

 * @in: DP IN adapter

 *

 * Allocates DP IN resource for DP tunneling using USB4 router

 * operations. If the resource was allocated returns %0. Otherwise

 * returns negative errno, in particular %-EBUSY if the resource is

 * already allocated.

/**

 * usb4_switch_dealloc_dp_resource() - Releases allocated DP IN resource

 * @sw: USB4 router

 * @in: DP IN adapter

 *

 * Releases the previously allocated DP IN resource.

 Assume port is primary */

/**

 * usb4_switch_map_pcie_down() - Map USB4 port to a PCIe downstream adapter

 * @sw: USB4 router

 * @port: USB4 port

 *

 * USB4 routers have direct mapping between USB4 ports and PCIe

 * downstream adapters where the PCIe topology is extended. This

 * function returns the corresponding downstream PCIe adapter or %NULL

 * if no such mapping was possible.

 Find PCIe down port matching usb4_port */

/**

 * usb4_switch_map_usb3_down() - Map USB4 port to a USB3 downstream adapter

 * @sw: USB4 router

 * @port: USB4 port

 *

 * USB4 routers have direct mapping between USB4 ports and USB 3.x

 * downstream adapters where the USB 3.x topology is extended. This

 * function returns the corresponding downstream USB 3.x adapter or

 * %NULL if no such mapping was possible.

 Find USB3 down port matching usb4_port */

/**

 * usb4_switch_add_ports() - Add USB4 ports for this router

 * @sw: USB4 router

 *

 * For USB4 router finds all USB4 ports and registers devices for each.

 * Can be called to any router.

 *

 * Return %0 in case of success and negative errno in case of failure.

/**

 * usb4_switch_remove_ports() - Removes USB4 ports from this router

 * @sw: USB4 router

 *

 * Unregisters previously registered USB4 ports.

/**

 * usb4_port_unlock() - Unlock USB4 downstream port

 * @port: USB4 port to unlock

 *

 * Unlocks USB4 downstream port so that the connection manager can

 * access the router below this port.

/**

 * usb4_port_configure() - Set USB4 port configured

 * @port: USB4 router

 *

 * Sets the USB4 link to be configured for power management purposes.

/**

 * usb4_port_unconfigure() - Set USB4 port unconfigured

 * @port: USB4 router

 *

 * Sets the USB4 link to be unconfigured for power management purposes.

/**

 * usb4_port_configure_xdomain() - Configure port for XDomain

 * @port: USB4 port connected to another host

 *

 * Marks the USB4 port as being connected to another host. Returns %0 in

 * success and negative errno in failure.

/**

 * usb4_port_unconfigure_xdomain() - Unconfigure port for XDomain

 * @port: USB4 port that was connected to another host

 *

 * Clears USB4 port from being marked as XDomain.

 Check results */

/**

 * usb4_port_router_offline() - Put the USB4 port to offline mode

 * @port: USB4 port

 *

 * This function puts the USB4 port into offline mode. In this mode the

 * port does not react on hotplug events anymore. This needs to be

 * called before retimer access is done when the USB4 links is not up.

 *

 * Returns %0 in case of success and negative errno if there was an

 * error.

/**

 * usb4_port_router_online() - Put the USB4 port back to online

 * @port: USB4 port

 *

 * Makes the USB4 port functional again.

/**

 * usb4_port_enumerate_retimers() - Send RT broadcast transaction

 * @port: USB4 port

 *

 * This forces the USB4 port to send broadcast RT transaction which

 * makes the retimers on the link to assign index to themselves. Returns

 * %0 in case of success and negative errno if there was an error.

/**

 * usb4_port_retimer_set_inbound_sbtx() - Enable sideband channel transactions

 * @port: USB4 port

 * @index: Retimer index

 *

 * Enables sideband channel transations on SBTX. Can be used when USB4

 * link does not go up, for example if there is no device connected.

	/*

	 * Per the USB4 retimer spec, the retimer is not required to

	 * send an RT (Retimer Transaction) response for the first

	 * SET_INBOUND_SBTX command

/**

 * usb4_port_retimer_read() - Read from retimer sideband registers

 * @port: USB4 port

 * @index: Retimer index

 * @reg: Sideband register to read

 * @buf: Data from @reg is stored here

 * @size: Number of bytes to read

 *

 * Function reads retimer sideband registers starting from @reg. The

 * retimer is connected to @port at @index. Returns %0 in case of

 * success, and read data is copied to @buf. If there is no retimer

 * present at given @index returns %-ENODEV. In any other failure

 * returns negative errno.

/**

 * usb4_port_retimer_write() - Write to retimer sideband registers

 * @port: USB4 port

 * @index: Retimer index

 * @reg: Sideband register to write

 * @buf: Data that is written starting from @reg

 * @size: Number of bytes to write

 *

 * Writes retimer sideband registers starting from @reg. The retimer is

 * connected to @port at @index. Returns %0 in case of success. If there

 * is no retimer present at given @index returns %-ENODEV. In any other

 * failure returns negative errno.

/**

 * usb4_port_retimer_is_last() - Is the retimer last on-board retimer

 * @port: USB4 port

 * @index: Retimer index

 *

 * If the retimer at @index is last one (connected directly to the

 * Type-C port) this function returns %1. If it is not returns %0. If

 * the retimer is not present returns %-ENODEV. Otherwise returns

 * negative errno.

/**

 * usb4_port_retimer_nvm_sector_size() - Read retimer NVM sector size

 * @port: USB4 port

 * @index: Retimer index

 *

 * Reads NVM sector size (in bytes) of a retimer at @index. This

 * operation can be used to determine whether the retimer supports NVM

 * upgrade for example. Returns sector size in bytes or negative errno

 * in case of error. Specifically returns %-ENODEV if there is no

 * retimer at @index.

/**

 * usb4_port_retimer_nvm_set_offset() - Set NVM write offset

 * @port: USB4 port

 * @index: Retimer index

 * @address: Start offset

 *

 * Exlicitly sets NVM write offset. Normally when writing to NVM this is

 * done automatically by usb4_port_retimer_nvm_write().

 *

 * Returns %0 in success and negative errno if there was a failure.

/**

 * usb4_port_retimer_nvm_write() - Write to retimer NVM

 * @port: USB4 port

 * @index: Retimer index

 * @address: Byte address where to start the write

 * @buf: Data to write

 * @size: Size in bytes how much to write

 *

 * Writes @size bytes from @buf to the retimer NVM. Used for NVM

 * upgrade. Returns %0 if the data was written successfully and negative

 * errno in case of failure. Specifically returns %-ENODEV if there is

 * no retimer at @index.

/**

 * usb4_port_retimer_nvm_authenticate() - Start retimer NVM upgrade

 * @port: USB4 port

 * @index: Retimer index

 *

 * After the new NVM image has been written via usb4_port_retimer_nvm_write()

 * this function can be used to trigger the NVM upgrade process. If

 * successful the retimer restarts with the new NVM and may not have the

 * index set so one needs to call usb4_port_enumerate_retimers() to

 * force index to be assigned.

	/*

	 * We need to use the raw operation here because once the

	 * authentication completes the retimer index is not set anymore

	 * so we do not get back the status now.

/**

 * usb4_port_retimer_nvm_authenticate_status() - Read status of NVM upgrade

 * @port: USB4 port

 * @index: Retimer index

 * @status: Raw status code read from metadata

 *

 * This can be called after usb4_port_retimer_nvm_authenticate() and

 * usb4_port_enumerate_retimers() to fetch status of the NVM upgrade.

 *

 * Returns %0 if the authentication status was successfully read. The

 * completion metadata (the result) is then stored into @status. If

 * reading the status fails, returns negative errno.

/**

 * usb4_port_retimer_nvm_read() - Read contents of retimer NVM

 * @port: USB4 port

 * @index: Retimer index

 * @address: NVM address (in bytes) to start reading

 * @buf: Data read from NVM is stored here

 * @size: Number of bytes to read

 *

 * Reads retimer NVM and copies the contents to @buf. Returns %0 if the

 * read was successful and negative errno in case of failure.

 * Specifically returns %-ENODEV if there is no retimer at @index.

/**

 * usb4_usb3_port_max_link_rate() - Maximum support USB3 link rate

 * @port: USB3 adapter port

 *

 * Return maximum supported link rate of a USB3 adapter in Mb/s.

 * Negative errno in case of error.

/**

 * usb4_usb3_port_actual_link_rate() - Established USB3 link rate

 * @port: USB3 adapter port

 *

 * Return actual established link rate of a USB3 adapter in Mb/s. If the

 * link is not up returns %0 and negative errno in case of failure.

	/*

	 * We can use val here directly as the CMR bit is in the same place

	 * as HCA. Just mask out others.

 1 uframe is 1/8 ms (125 us) -> 1 / 8000 s */

/**

 * usb4_usb3_port_allocated_bandwidth() - Bandwidth allocated for USB3

 * @port: USB3 adapter port

 * @upstream_bw: Allocated upstream bandwidth is stored here

 * @downstream_bw: Allocated downstream bandwidth is stored here

 *

 * Stores currently allocated USB3 bandwidth into @upstream_bw and

 * @downstream_bw in Mb/s. Returns %0 in case of success and negative

 * errno in failure.

 Read the used scale, hardware default is 0 */

/**

 * usb4_usb3_port_allocate_bandwidth() - Allocate bandwidth for USB3

 * @port: USB3 adapter port

 * @upstream_bw: New upstream bandwidth

 * @downstream_bw: New downstream bandwidth

 *

 * This can be used to set how much bandwidth is allocated for the USB3

 * tunneled isochronous traffic. @upstream_bw and @downstream_bw are the

 * new values programmed to the USB3 adapter allocation registers. If

 * the values are lower than what is currently consumed the allocation

 * is set to what is currently consumed instead (consumed bandwidth

 * cannot be taken away by CM). The actual new values are returned in

 * @upstream_bw and @downstream_bw.

 *

 * Returns %0 in case of success and negative errno if there was a

 * failure.

 Don't allow it go lower than what is consumed */

/**

 * usb4_usb3_port_release_bandwidth() - Release allocated USB3 bandwidth

 * @port: USB3 adapter port

 * @upstream_bw: New allocated upstream bandwidth

 * @downstream_bw: New allocated downstream bandwidth

 *

 * Releases USB3 allocated bandwidth down to what is actually consumed.

 * The new bandwidth is returned in @upstream_bw and @downstream_bw.

 *

 * Returns 0% in success and negative errno in case of failure.

	/*

	 * Always keep 1000 Mb/s to make sure xHCI has at least some

	 * bandwidth available for isochronous traffic.

 SPDX-License-Identifier: GPL-2.0

/*

 * ACPI support

 *

 * Copyright (C) 2020, Intel Corporation

 * Author: Mika Westerberg <mika.westerberg@linux.intel.com>

 It needs to reference this NHI */

	/*

	 * Try to find physical device walking upwards to the hierarcy.

	 * We need to do this because the xHCI driver might not yet be

	 * bound so the USB3 SuperSpeed ports are not yet created.

	/*

	 * Check that the device is PCIe. This is because USB3

	 * SuperSpeed ports have this property and they are not power

	 * managed with the xHCI and the SuperSpeed hub so we create the

	 * link from xHCI instead.

	/*

	 * Check that this actually matches the type of device we

	 * expect. It should either be xHCI or PCIe root/downstream

	 * port.

/**

 * tb_acpi_add_links() - Add device links based on ACPI description

 * @nhi: Pointer to NHI

 *

 * Goes over ACPI namespace finding tunneled ports that reference to

 * @nhi ACPI node. For each reference a device link is added. The link

 * is automatically removed by the driver core.

	/*

	 * Find all devices that have usb4-host-controller interface

	 * property that references to this NHI.

/**

 * tb_acpi_is_native() - Did the platform grant native TBT/USB4 control

 *

 * Returns %true if the platform granted OS native control over

 * TBT/USB4. In this case software based connection manager can be used,

 * otherwise there is firmware based connection manager running.

/**

 * tb_acpi_may_tunnel_usb3() - Is USB3 tunneling allowed by the platform

 *

 * When software based connection manager is used, this function

 * returns %true if platform allows native USB3 tunneling.

/**

 * tb_acpi_may_tunnel_dp() - Is DisplayPort tunneling allowed by the platform

 *

 * When software based connection manager is used, this function

 * returns %true if platform allows native DP tunneling.

/**

 * tb_acpi_may_tunnel_pcie() - Is PCIe tunneling allowed by the platform

 *

 * When software based connection manager is used, this function

 * returns %true if platform allows native PCIe tunneling.

/**

 * tb_acpi_is_xdomain_allowed() - Are XDomain connections allowed

 *

 * When software based connection manager is used, this function

 * returns %true if platform allows XDomain connections.

 UUID for retimer _DSM: e0053122-795b-4122-8a5e-57be1d26acb3 */

 Check if we are already powered on (and in correct mode) */

/**

 * tb_acpi_power_on_retimers() - Call platform to power on retimers

 * @port: USB4 port

 *

 * Calls platform to turn on power to all retimers behind this USB4

 * port. After this function returns successfully the caller can

 * continue with the normal retimer flows (as specified in the USB4

 * spec). Note if this returns %-EBUSY it means the type-C port is in

 * non-USB4/TBT mode (there is non-USB4/TBT device connected).

 *

 * This should only be called if the USB4/TBT link is not up.

 *

 * Returns %0 on success.

/**

 * tb_acpi_power_off_retimers() - Call platform to power off retimers

 * @port: USB4 port

 *

 * This is the opposite of tb_acpi_power_on_retimers(). After returning

 * successfully the normal operations with the @port can continue.

 *

 * Returns %0 on success.

	/*

	 * Device routers exists under the downstream facing USB4 port

	 * of the parent router. Their _ADR is always 0.

	/*

	 * The Thunderbolt/USB4 hierarchy looks like following:

	 *

	 * Device (NHI)

	 *   Device (HR)		// Host router _ADR == 0

	 *      Device (DFP0)		// Downstream port _ADR == lane 0 adapter

	 *        Device (DR)		// Device router _ADR == 0

	 *          Device (UFP)	// Upstream port _ADR == lane 0 adapter

	 *      Device (DFP1)		// Downstream port _ADR == lane 0 adapter number

	 *

	 * At the moment we bind the host router to the corresponding

	 * Linux device.

 SPDX-License-Identifier: GPL-2.0

/*

 * Thunderbolt driver - eeprom access

 *

 * Copyright (c) 2014 Andreas Noever <andreas.noever@gmail.com>

 * Copyright (C) 2018, Intel Corporation

/*

 * tb_eeprom_ctl_write() - write control word

/*

 * tb_eeprom_ctl_write() - read control word

/*

 * tb_eeprom_active - enable rom access

 *

 * WARNING: Always disable access after usage. Otherwise the controller will

 * fail to reprobe.

/*

 * tb_eeprom_transfer - transfer one bit

 *

 * If TB_EEPROM_IN is passed, then the bit can be retrieved from ctl->data_in.

 * If TB_EEPROM_OUT is passed, then ctl->data_out will be written.

/*

 * tb_eeprom_out - write one byte to the bus

/*

 * tb_eeprom_in - read one byte from the bus

/*

 * tb_eeprom_get_drom_offset - get drom offset within eeprom

/*

 * tb_eeprom_read_n - read count bytes from offset into val

 BYTE 0 */

 checksum for uid */

 BYTES 1-8 */

 BYTES 9-12 */

 checksum for data_len bytes starting at byte 13 */

 BYTE 13 */

 should be <= 1 */

 BYTES 16-21 - Only for TBT DROM, nonexistent in USB4 DROM */

 force unsigned to prevent "one-bit signed bitfield" warning */

 only valid if type is TB_DROM_ENTRY_PORT */

 BYTES 0-1 */

 BYTE 2 */

 BYTE 3 */

 BYTES 4 - 5 TODO decode */

 BYTES 6-7, TODO: verify (find hardware that has these set) */

 USB4 product descriptor */

/**

 * tb_drom_read_uid_only() - Read UID directly from DROM

 * @sw: Router whose UID to read

 * @uid: UID is placed here

 *

 * Does not use the cached copy in sw->drom. Used during resume to check switch

 * identity.

 read uid */

 Length includes 2 bytes header so remove it before copy */

	/*

	 * Some DROMs list more ports than the controller actually has

	 * so we skip those but allow the parser to continue.

/*

 * tb_drom_parse_entries - parse the linked list of drom entries

 *

 * Drom must have been copied to sw->drom.

/*

 * tb_drom_copy_efi - copy drom supplied by EFI to sw->drom if present

 Size includes CRC8 + UID + CRC32 */

	/*

	 * Read UID from the minimal DROM because the one in NVM is just

	 * a placeholder.

 Size includes CRC8 + UID + CRC32 */

/**

 * tb_drom_read() - Copy DROM to sw->drom and parse it

 * @sw: Router whose DROM to read and parse

 *

 * This function reads router DROM and if successful parses the entries and

 * populates the fields in @sw accordingly. Can be called for any router

 * generation.

 *

 * Returns %0 in case of success and negative errno otherwise.

		/*

		 * Apple's NHI EFI driver supplies a DROM for the root switch

		 * in a device property. Use it if available.

 Non-Apple hardware has the DROM as part of NVM */

		/*

		 * USB4 hosts may support reading DROM through router

		 * operations.

			/*

			 * The root switch contains only a dummy drom

			 * (header only, no entries). Hardcode the

			 * configuration here.

 If the DROM parsing fails, wait a moment and retry once */

 SPDX-License-Identifier: GPL-2.0

/*

 * Thunderbolt driver - path/tunnel functionality

 *

 * Copyright (c) 2014 Andreas Noever <andreas.noever@gmail.com>

 * Copyright (C) 2019, Intel Corporation

/**

 * tb_path_discover() - Discover a path

 * @src: First input port of a path

 * @src_hopid: Starting HopID of a path (%-1 if don't care)

 * @dst: Expected destination port of the path (%NULL if don't care)

 * @dst_hopid: HopID to the @dst (%-1 if don't care)

 * @last: Last port is filled here if not %NULL

 * @name: Name of the path

 *

 * Follows a path starting from @src and @src_hopid to the last output

 * port of the path. Allocates HopIDs for the visited ports. Call

 * tb_path_free() to release the path and allocated HopIDs when the path

 * is not needed anymore.

 *

 * Note function discovers also incomplete paths so caller should check

 * that the @dst port is the expected one. If it is not, the path can be

 * cleaned up by calling tb_path_deactivate() before tb_path_free().

 *

 * Return: Discovered path on success, %NULL in case of failure

		/*

		 * For incomplete paths the intermediate HopID can be

		 * different from the one used by the protocol adapter

		 * so in that case find a path that ends on @dst with

		 * matching @dst_hopid. That should give us the correct

		 * HopID for the @src.

 If the hop is not enabled we got an incomplete path */

/**

 * tb_path_alloc() - allocate a thunderbolt path between two ports

 * @tb: Domain pointer

 * @src: Source port of the path

 * @src_hopid: HopID used for the first ingress port in the path

 * @dst: Destination port of the path

 * @dst_hopid: HopID used for the last egress port in the path

 * @link_nr: Preferred link if there are dual links on the path

 * @name: Name of the path

 *

 * Creates path between two ports starting with given @src_hopid. Reserves

 * HopIDs for each port (they can be different from @src_hopid depending on

 * how many HopIDs each port already have reserved). If there are dual

 * links on the path, prioritizes using @link_nr but takes into account

 * that the lanes may be bonded.

 *

 * Return: Returns a tb_path on success or NULL on failure.

 Check that src and dst are reachable */

 Each hop takes two ports */

 When lanes are bonded primary link must be used */

		/*

		 * Pick up right port when going from non-bonded to

		 * bonded or from bonded to non-bonded.

				/*

				 * Use primary link when going from

				 * non-bonded to bonded.

				/*

				 * If out port is not bonded follow

				 * link_nr.

/**

 * tb_path_free() - free a path

 * @path: Path to free

 *

 * Frees a path. The path does not need to be deactivated.

 Disable the path */

 Already disabled */

 Wait until it is drained */

				/*

				 * Clear flow control. Protocol adapters

				 * IFC and ISE bits are vendor defined

				 * in the USB4 spec so we clear them

				 * only for pre-USB4 adapters.

/**

 * tb_path_activate() - activate a path

 * @path: Path to activate

 *

 * Activate a path starting with the last hop and iterating backwards. The

 * caller must fill path->hops before calling tb_path_activate().

 *

 * Return: Returns 0 on success or an error code on failure.

 Clear counters. */

 Add non flow controlled credits. */

 Activate hops. */

 If it is left active deactivate it first */

 dword 0 */

 dword 1 */

/**

 * tb_path_is_invalid() - check whether any ports on the path are invalid

 * @path: Path to check

 *

 * Return: Returns true if the path is invalid, false otherwise.

/**

 * tb_path_port_on_path() - Does the path go through certain port

 * @path: Path to check

 * @port: Switch to check

 *

 * Goes over all hops on path and checks if @port is any of them.

 * Direction does not matter.

 SPDX-License-Identifier: GPL-2.0

/*

 * Thunderbolt Time Management Unit (TMU) support

 *

 * Copyright (C) 2019, Intel Corporation

 * Authors: Mika Westerberg <mika.westerberg@linux.intel.com>

 *	    Rajmohan Mani <rajmohan.mani@intel.com>

 Root switch does not have upstream directionality */

/**

 * tb_switch_tmu_init() - Initialize switch TMU structures

 * @sw: Switch to initialized

 *

 * This function must be called before other TMU related functions to

 * makes the internal structures are filled in correctly. Does not

 * change any hardware configuration.

/**

 * tb_switch_tmu_post_time() - Update switch local time

 * @sw: Switch whose time to update

 *

 * Updates switch local time using time posting procedure.

 Need to be able to read the grand master time */

 Convert to nanoseconds (drop fractional part) */

 Tell the switch that time sync is disrupted for a while */

	/*

	 * Write the Grandmaster time to the Post Local Time registers

	 * of the new switch.

	/*

	 * Have the new switch update its local time (by writing 1 to

	 * the post_time registers) and wait for the completion of the

	 * same (post_time register becomes 0). This means the time has

	 * been converged properly.

/**

 * tb_switch_tmu_disable() - Disable TMU of a switch

 * @sw: Switch whose TMU to disable

 *

 * Turns off TMU of @sw if it is enabled. If not enabled does nothing.

 Already disabled? */

 The switch may be unplugged so ignore any errors */

/**

 * tb_switch_tmu_enable() - Enable TMU on a switch

 * @sw: Switch whose TMU to enable

 *

 * Enables TMU of a switch to be in bi-directional, HiFi mode. In this mode

 * all tunneling should work.

 Change mode to bi-directional */

 SPDX-License-Identifier: GPL-2.0

/*

 * Thunderbolt driver - Tunneling support

 *

 * Copyright (c) 2014 Andreas Noever <andreas.noever@gmail.com>

 * Copyright (C) 2019, Intel Corporation

 PCIe adapters use always HopID of 8 for both directions */

 USB3 adapters use always HopID of 8 for both directions */

 DP adapters use HopID 8 for AUX and 9 for Video */

 Minimum number of credits needed for PCIe path */

/*

 * Number of credits we try to allocate for each DMA path if not limited

 * by the host router baMaxHI.

 Minimum number of credits for DMA path */

/**

 * tb_available_credits() - Available credits for PCIe and DMA

 * @port: Lane adapter to check

 * @max_dp_streams: If non-%NULL stores maximum number of simultaneous DP

 *		    streams possible through this lane adapter

 Add some credits for potential second DMA tunnel */

		/*

		 * Maximum number of DP streams possible through the

		 * lane adapter.

/**

 * tb_tunnel_discover_pci() - Discover existing PCIe tunnels

 * @tb: Pointer to the domain structure

 * @down: PCIe downstream adapter

 *

 * If @down adapter is active, follows the tunnel to the PCIe upstream

 * adapter and back. Returns the discovered tunnel or %NULL if there was

 * no tunnel.

	/*

	 * Discover both paths even if they are not complete. We will

	 * clean them up by calling tb_tunnel_deactivate() below in that

	 * case.

 Just disable the downstream port */

 Validate that the tunnel is complete */

/**

 * tb_tunnel_alloc_pci() - allocate a pci tunnel

 * @tb: Pointer to the domain structure

 * @up: PCIe upstream adapter port

 * @down: PCIe downstream adapter port

 *

 * Allocate a PCI tunnel. The ports must be of type TB_TYPE_PCIE_UP and

 * TB_TYPE_PCIE_DOWN.

 *

 * Return: Returns a tb_tunnel on success or NULL on failure.

 Titan Ridge DP adapters need the same treatment as USB4 */

 Both ends need to support this */

 Tunneling removes the DP 8b/10b encoding */

 Mb/s, lanes */

 25920 Mb/s */

 17280 Mb/s */

 12960 Mb/s */

 8640 Mb/s */

 8640 Mb/s */

 6480 Mb/s */

 5184 Mb/s */

 4320 Mb/s */

 4320 Mb/s */

 2592 Mb/s */

 2160 Mb/s */

 1296 Mb/s */

	/*

	 * Find a combination that can fit into max_bw and does not

	 * exceed the maximum rate and lanes supported by the DP OUT and

	 * DP IN adapters.

	/*

	 * Copy DP_LOCAL_CAP register to DP_REMOTE_CAP register for

	 * newer generation hardware.

	/*

	 * Perform connection manager handshake between IN and OUT ports

	 * before capabilities exchange can take place.

 Read both DP_LOCAL_CAP registers */

 Write IN local caps to OUT remote caps */

	/*

	 * If the tunnel bandwidth is limited (max_bw is set) then see

	 * if we need to reduce bandwidth to fit there.

		/*

		 * Set new rate and number of lanes before writing it to

		 * the IN port remote caps.

		/*

		 * Wait for DPRX done. Normally it should be already set

		 * for active tunnel.

		/*

		 * Read from the copied remote cap so that we take into

		 * account if capabilities were reduced during exchange.

 No bandwidth management for legacy devices  */

		/*

		 * Read the number of currently allocated NFC credits

		 * from the lane adapter. Since we only use them for DP

		 * tunneling we can use that to figure out how many DP

		 * tunnels already go through the lane adapter.

/**

 * tb_tunnel_discover_dp() - Discover existing Display Port tunnels

 * @tb: Pointer to the domain structure

 * @in: DP in adapter

 *

 * If @in adapter is active, follows the tunnel to the DP out adapter

 * and back. Returns the discovered tunnel or %NULL if there was no

 * tunnel.

 *

 * Return: DP tunnel or %NULL if no tunnel found.

 Just disable the DP IN port */

 Validate that the tunnel is complete */

/**

 * tb_tunnel_alloc_dp() - allocate a Display Port tunnel

 * @tb: Pointer to the domain structure

 * @in: DP in adapter port

 * @out: DP out adapter port

 * @max_up: Maximum available upstream bandwidth for the DP tunnel (%0

 *	    if not limited)

 * @max_down: Maximum available downstream bandwidth for the DP tunnel

 *	      (%0 if not limited)

 *

 * Allocates a tunnel between @in and @out that is capable of tunneling

 * Display Port traffic.

 *

 * Return: Returns a tb_tunnel on success or NULL on failure.

		/*

		 * Need to have at least TB_MIN_DMA_CREDITS, otherwise

		 * DMA path cannot be established.

 Path from lane adapter to NHI */

	/*

	 * First lane adapter is the one connected to the remote host.

	 * We don't tunnel other traffic over this link so can use all

	 * the credits (except the ones reserved for control traffic).

 Path from NHI to lane adapter */

/**

 * tb_tunnel_alloc_dma() - allocate a DMA tunnel

 * @tb: Pointer to the domain structure

 * @nhi: Host controller port

 * @dst: Destination null port which the other domain is connected to

 * @transmit_path: HopID used for transmitting packets

 * @transmit_ring: NHI ring number used to send packets towards the

 *		   other domain. Set to %-1 if TX path is not needed.

 * @receive_path: HopID used for receiving packets

 * @receive_ring: NHI ring number used to receive packets from the

 *		  other domain. Set to %-1 if RX path is not needed.

 *

 * Return: Returns a tb_tunnel on success or NULL on failure.

/**

 * tb_tunnel_match_dma() - Match DMA tunnel

 * @tunnel: Tunnel to match

 * @transmit_path: HopID used for transmitting packets. Pass %-1 to ignore.

 * @transmit_ring: NHI ring number used to send packets towards the

 *		   other domain. Pass %-1 to ignore.

 * @receive_path: HopID used for receiving packets. Pass %-1 to ignore.

 * @receive_ring: NHI ring number used to receive packets from the

 *		  other domain. Pass %-1 to ignore.

 *

 * This function can be used to match specific DMA tunnel, if there are

 * multiple DMA tunnels going through the same XDomain connection.

 * Returns true if there is match and false otherwise.

	/*

	 * PCIe tunneling, if enabled, affects the USB3 bandwidth so

	 * take that it into account here.

 Use maximum link rate if the link valid is not set */

	/*

	 * 90% of the max rate can be allocated for isochronous

	 * transfers.

 No need to reclaim if already at maximum */

 Don't go lower than what is already allocated */

 If no changes no need to do more */

/**

 * tb_tunnel_discover_usb3() - Discover existing USB3 tunnels

 * @tb: Pointer to the domain structure

 * @down: USB3 downstream adapter

 *

 * If @down adapter is active, follows the tunnel to the USB3 upstream

 * adapter and back. Returns the discovered tunnel or %NULL if there was

 * no tunnel.

	/*

	 * Discover both paths even if they are not complete. We will

	 * clean them up by calling tb_tunnel_deactivate() below in that

	 * case.

 Just disable the downstream port */

 Validate that the tunnel is complete */

		/*

		 * Read the initial bandwidth allocation for the first

		 * hop tunnel.

/**

 * tb_tunnel_alloc_usb3() - allocate a USB3 tunnel

 * @tb: Pointer to the domain structure

 * @up: USB3 upstream adapter port

 * @down: USB3 downstream adapter port

 * @max_up: Maximum available upstream bandwidth for the USB3 tunnel (%0

 *	    if not limited).

 * @max_down: Maximum available downstream bandwidth for the USB3 tunnel

 *	      (%0 if not limited).

 *

 * Allocate an USB3 tunnel. The ports must be of type @TB_TYPE_USB3_UP and

 * @TB_TYPE_USB3_DOWN.

 *

 * Return: Returns a tb_tunnel on success or %NULL on failure.

	/*

	 * Check that we have enough bandwidth available for the new

	 * USB3 tunnel.

 Only 90% can be allocated for USB3 isochronous transfers */

/**

 * tb_tunnel_free() - free a tunnel

 * @tunnel: Tunnel to be freed

 *

 * Frees a tunnel. The tunnel does not need to be deactivated.

/**

 * tb_tunnel_is_invalid - check whether an activated path is still valid

 * @tunnel: Tunnel to check

/**

 * tb_tunnel_restart() - activate a tunnel after a hardware reset

 * @tunnel: Tunnel to restart

 *

 * Return: 0 on success and negative errno in case if failure

	/*

	 * Make sure all paths are properly disabled before enabling

	 * them again.

/**

 * tb_tunnel_activate() - activate a tunnel

 * @tunnel: Tunnel to activate

 *

 * Return: Returns 0 on success or an error code on failure.

/**

 * tb_tunnel_deactivate() - deactivate a tunnel

 * @tunnel: Tunnel to deactivate

/**

 * tb_tunnel_port_on_path() - Does the tunnel go through port

 * @tunnel: Tunnel to check

 * @port: Port to check

 *

 * Returns true if @tunnel goes through @port (direction does not matter),

 * false otherwise.

/**

 * tb_tunnel_consumed_bandwidth() - Return bandwidth consumed by the tunnel

 * @tunnel: Tunnel to check

 * @consumed_up: Consumed bandwidth in Mb/s from @dst_port to @src_port.

 *		 Can be %NULL.

 * @consumed_down: Consumed bandwidth in Mb/s from @src_port to @dst_port.

 *		   Can be %NULL.

 *

 * Stores the amount of isochronous bandwidth @tunnel consumes in

 * @consumed_up and @consumed_down. In case of success returns %0,

 * negative errno otherwise.

/**

 * tb_tunnel_release_unused_bandwidth() - Release unused bandwidth

 * @tunnel: Tunnel whose unused bandwidth to release

 *

 * If tunnel supports dynamic bandwidth management (USB3 tunnels at the

 * moment) this function makes it to release all the unused bandwidth.

 *

 * Returns %0 in case of success and negative errno otherwise.

/**

 * tb_tunnel_reclaim_available_bandwidth() - Reclaim available bandwidth

 * @tunnel: Tunnel reclaiming available bandwidth

 * @available_up: Available upstream bandwidth (in Mb/s)

 * @available_down: Available downstream bandwidth (in Mb/s)

 *

 * Reclaims bandwidth from @available_up and @available_down and updates

 * the variables accordingly (e.g decreases both according to what was

 * reclaimed by the tunnel). If nothing was reclaimed the values are

 * kept as is.

 SPDX-License-Identifier: GPL-2.0

/*

 * Thunderbolt XDomain property support

 *

 * Copyright (C) 2017, Intel Corporation

 * Authors: Michael Jamet <michael.jamet@intel.com>

 *          Mika Westerberg <mika.westerberg@linux.intel.com>

 Force null termination */

 Length includes UUID */

/**

 * tb_property_parse_dir() - Parses properties from given property block

 * @block: Property block to parse

 * @block_len: Number of dword elements in the property block

 *

 * This function parses the XDomain properties data block into format that

 * can be traversed using the helper functions provided by this module.

 * Upon success returns the parsed directory. In case of error returns

 * %NULL. The resulting &struct tb_property_dir needs to be released by

 * calling tb_property_free_dir() when not needed anymore.

 *

 * The @block is expected to be root directory.

/**

 * tb_property_create_dir() - Creates new property directory

 * @uuid: UUID used to identify the particular directory

 *

 * Creates new, empty property directory. If @uuid is %NULL then the

 * directory is assumed to be root directory.

/**

 * tb_property_free_dir() - Release memory allocated for property directory

 * @dir: Directory to release

 *

 * This will release all the memory the directory occupies including all

 * descendants. It is OK to pass %NULL @dir, then the function does

 * nothing.

 Reserve dword padding after each directory */

	/*

	 * The structure of property block looks like following. Leaf

	 * data/text is included right after the directory and each

	 * directory follows each other (even nested ones).

	 *

	 * +----------+ <-- start_offset

	 * |  header  | <-- root directory header

	 * +----------+ ---

	 * |  entry 0 | -^--------------------.

	 * +----------+  |                    |

	 * |  entry 1 | -|--------------------|--.

	 * +----------+  |                    |  |

	 * |  entry 2 | -|-----------------.  |  |

	 * +----------+  |                 |  |  |

	 * :          :  |  dir_len        |  |  |

	 * .          .  |                 |  |  |

	 * :          :  |                 |  |  |

	 * +----------+  |                 |  |  |

	 * |  entry n |  v                 |  |  |

	 * +----------+ <-- data_offset    |  |  |

	 * |  data 0  | <------------------|--'  |

	 * +----------+                    |     |

	 * |  data 1  | <------------------|-----'

	 * +----------+                    |

	 * | 00000000 | padding            |

	 * +----------+ <-- dir_end <------'

	 * |   UUID   | <-- directory UUID (child directory)

	 * +----------+

	 * |  entry 0 |

	 * +----------+

	 * |  entry 1 |

	 * +----------+

	 * :          :

	 * .          .

	 * :          :

	 * +----------+

	 * |  entry n |

	 * +----------+

	 * |  data 0  |

	 * +----------+

	 *

	 * We use dir_end to hold pointer to the end of the directory. It

	 * will increase as we add directories and each directory should be

	 * added starting from previous dir_end.

 Write headers first */

/**

 * tb_property_format_dir() - Formats directory to the packed XDomain format

 * @dir: Directory to format

 * @block: Property block where the packed data is placed

 * @block_len: Length of the property block

 *

 * This function formats the directory to the packed format that can be

 * then send over the thunderbolt fabric to receiving host. Returns %0 in

 * case of success and negative errno on faulure. Passing %NULL in @block

 * returns number of entries the block takes.

/**

 * tb_property_copy_dir() - Take a deep copy of directory

 * @dir: Directory to copy

 *

 * This function takes a deep copy of @dir and returns back the copy. In

 * case of error returns %NULL. The resulting directory needs to be

 * released by calling tb_property_free_dir().

/**

 * tb_property_add_immediate() - Add immediate property to directory

 * @parent: Directory to add the property

 * @key: Key for the property

 * @value: Immediate value to store with the property

/**

 * tb_property_add_data() - Adds arbitrary data property to directory

 * @parent: Directory to add the property

 * @key: Key for the property

 * @buf: Data buffer to add

 * @buflen: Number of bytes in the data buffer

 *

 * Function takes a copy of @buf and adds it to the directory.

 Need to pad to dword boundary */

/**

 * tb_property_add_text() - Adds string property to directory

 * @parent: Directory to add the property

 * @key: Key for the property

 * @text: String to add

 *

 * Function takes a copy of @text and adds it to the directory.

 Need to pad to dword boundary */

/**

 * tb_property_add_dir() - Adds a directory to the parent directory

 * @parent: Directory to add the property

 * @key: Key for the property

 * @dir: Directory to add

/**

 * tb_property_remove() - Removes property from a parent directory

 * @property: Property to remove

 *

 * Note memory for @property is released as well so it is not allowed to

 * touch the object after call to this function.

/**

 * tb_property_find() - Find a property from a directory

 * @dir: Directory where the property is searched

 * @key: Key to look for

 * @type: Type of the property

 *

 * Finds and returns property from the given directory. Does not recurse

 * into sub-directories. Returns %NULL if the property was not found.

/**

 * tb_property_get_next() - Get next property from directory

 * @dir: Directory holding properties

 * @prev: Previous property in the directory (%NULL returns the first)

/*

 *  linux/drivers/message/fusion/mptfc.c

 *      For use with LSI PCI chip/adapter(s)

 *      running LSI Fusion MPT (Message Passing Technology) firmware.

 *

 *  Copyright (c) 1999-2008 LSI Corporation

 *  (mailto:DL-MPTFusionLinux@lsi.com)

 *

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

    This program is free software; you can redistribute it and/or modify

    it under the terms of the GNU General Public License as published by

    the Free Software Foundation; version 2 of the License.



    This program is distributed in the hope that it will be useful,

    but WITHOUT ANY WARRANTY; without even the implied warranty of

    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

    GNU General Public License for more details.



    NO WARRANTY

    THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

    CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

    LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

    solely responsible for determining the appropriateness of using and

    distributing the Program and assumes all risks associated with its

    exercise of rights under this Agreement, including but not limited to

    the risks and costs of program errors, damage to or loss of data,

    programs or equipment, and unavailability or interruption of operations.



    DISCLAIMER OF LIABILITY

    NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

    DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

    USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

    HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES



    You should have received a copy of the GNU General Public License

    along with this program; if not, write to the Free Software

    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 for mdelay */

 notifier code */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 Command line args */

 reasonable default */

 scsi-mid layer global parmeter is max_report_luns, which is 511 */

/****************************************************************************

 * Supported hardware

 Terminating entry */

 seconds */

 Get FC Device Page 0 header */

 save data */

 save addr */

 sort array */

 call caller's func for each targ */

 not currently usable */

	/*

	 * board data structure already normalized to platform endianness

	 * shifted to avoid unaligned access on 64 bit architecture

 scan list looking for a match */

 match */

 allocate one */

 add/update pg0 data */

 MPT_RPORT_INFO_FLAGS_REGISTERED - rport not previously deleted */

 may have been reset by user */

			/*

			 * if already mapped, remap here.  If not mapped,

			 * target_alloc will allocate vtarget and map,

			 * slave_alloc will fill in vdevice from vtarget.

 scan will be scheduled once rport becomes a target */

/*

 *	OS entry point to allow for host driver to free allocated memory

 *	Called if no device present or device being unloaded

 better be! */

/*

 *	OS entry point to allow host driver to alloc memory

 *	for each scsi target. Called once per device the bus scan.

 *	Return non-zero if allocation fails.

 better be! */

/*

 *	mptfc_dump_lun_info

 *	@ioc

 *	@rport

 *	@sdev

 *

/*

 *	OS entry point to allow host driver to alloc memory

 *	for each scsi device. Called once per device the bus scan.

 *	Return non-zero if allocation fails.

 *	Init memory once per LUN.

 dd_data is null until finished adding target */

/*

 *	mptfc_display_port_link_speed - displaying link speed

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@portnum: IOC Port number

 *	@pp0dest: port page0 data payload

 *

/*

 *	mptfc_GetFcPortPage0 - Fetch FCPort config Page0.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@portnum: IOC Port number

 *

 *	Return: 0 for success

 *	-ENOMEM if no memory available

 *		-EPERM if not allowed due to ISR context

 *		-EAGAIN if no msg frames currently available

 *		-EFAULT for non-successful reply or no reply (timeout)

 *		-EINVAL portnum arg out of range (hardwired to two elements)

 Get FCPort Page 0 header */

 save the data */

			/*

			 *	Normalize endianness of structure data,

			 *	by byte-swapping all > 1 byte fields!

			/*

			 * if still doing discovery,

			 * hang loose a while until finished

 get fcport page 1 header */

 get fcport page 1 header */

 don't know what to do as only one scsi (fc) host was allocated */

 reset about to happen, delete (block) all rports */

 won't sleep */

 start by tagging all ports as missing */

	/*

	 * now rescan devices known to adapter,

	 * will reregister existing rports

 refresh */

 delete devices still missing */

 if newly missing, delete it */

 won't sleep */

	/*  Added sanity check on readiness of the MPT adapter.

	/*  Sanity check - ensure at least 1 port is INITIATOR capable

	/* Attach the SCSI Host to the IOC structure

 set 16 byte cdb's */

	/* Required entry.

	/* Verify that we won't exceed the maximum

	 * number of chain buffers

	 * We can optimize:  ZZ = req_sz/sizeof(SGE)

	 * For 32bit SGE's:

	 *  numSGE = 1 + (ZZ-1)*(maxChain -1) + ZZ

	 *               + (req_sz - 64)/sizeof(SGE)

	 * A slightly different algorithm is required for

	 * 64bit SGEs.

 Reset this value */

	/* SCSI needs scsi_cmnd lookup table!

	 * (with size equal to req_depth*PtrSz!)

 initialize workqueue */

	/*

	 *  Pre-fetch FC port WWN and stuff...

	 *  (FCPortPage0_t stuff)

	/*

	 * scan for rports -

	 *	by doing it via the workqueue, some locking is eliminated

 MPT_IOC_POST_RESET */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mptfc_init - Register MPT adapter(s) as SCSI host(s) with SCSI mid-layer.

 *

 *	Returns 0 for success, non-zero for failure.

 sanity check module parameters */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mptfc_remove - Remove fc infrastructure for devices

 *	@pdev: Pointer to pci_dev structure

 *

 destroy workqueue */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mptfc_exit - Unregisters MPT adapter(s)

 *

/*

 *  linux/drivers/message/fusion/mptbase.c

 *      This is the Fusion MPT base driver which supports multiple

 *      (SCSI + LAN) specialized protocol drivers.

 *      For use with LSI PCI chip/adapter(s)

 *      running LSI Fusion MPT (Message Passing Technology) firmware.

 *

 *  Copyright (c) 1999-2008 LSI Corporation

 *  (mailto:DL-MPTFusionLinux@lsi.com)

 *

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

    This program is free software; you can redistribute it and/or modify

    it under the terms of the GNU General Public License as published by

    the Free Software Foundation; version 2 of the License.



    This program is distributed in the hope that it will be useful,

    but WITHOUT ANY WARRANTY; without even the implied warranty of

    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

    GNU General Public License for more details.



    NO WARRANTY

    THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

    CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

    LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

    solely responsible for determining the appropriateness of using and

    distributing the Program and assumes all risks associated with its

    exercise of rights under this Agreement, including but not limited to

    the risks and costs of program errors, damage to or loss of data,

    programs or equipment, and unavailability or interruption of operations.



    DISCLAIMER OF LIABILITY

    NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

    DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

    USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

    HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES



    You should have received a copy of the GNU General Public License

    along with this program; if not, write to the Free Software

    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *  cmd line parameters

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *  Public data...

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *  Private data...

 Adapter link list */

 Callback lookup table */

 Protocol driver class lookup table */

 Event handler lookup table */

 Reset handler lookup table */

/*

 *  Driver Callback Index's

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *  Forward protos...

 module entry point */

/**

 *	mpt_get_cb_idx - obtain cb_idx for registered driver

 *	@dclass: class driver enum

 *

 *	Returns cb_idx, or zero means it wasn't found

/**

 * mpt_is_discovery_complete - determine if discovery has completed

 * @ioc: per adatper instance

 *

 * Returns 1 when discovery completed, else zero.

/**

 *  mpt_remove_dead_ioc_func - kthread context to remove dead ioc

 * @arg: input argument, used to derive ioc

 *

 * Return 0 if controller is removed from pci subsystem.

 * Return -1 for other case.

/**

 *	mpt_fault_reset_work - work performed on workq after ioc fault

 *	@work: input argument, used to derive ioc

 *

		/*

		 * Call mptscsih_flush_pending_cmds callback so that we

		 * flush all pending commands back to OS.

		 * This call is required to aovid deadlock at block layer.

		 * Dead IOC will fail to do diag reset,and this call is safe

		 * since dead ioc will never return any command back from HW.

Remove the Dead Host */

 don't rearm timer */

	/*

	 * Take turns polling alternate controller

 rearm the timer */

/*

 *  Process turbo (context) reply...

		/*

		 *  Blind set of mf to NULL here was fatal

		 *  after lan_reply says "freeme"

		 *  Fix sort of combined with an optimization here;

		 *  added explicit check for case where lan_reply

		 *  was just returning 1 and doing nothing else.

		 *  For this case skip the callback, but set up

		 *  proper mf value first here:-)

  Check for (valid) IO callback!  */

	/* non-TURBO reply!  Hmmm, something may be up...

	 *  Newest turbo reply mechanism; get address

	 *  via left shift 1 (get rid of MPI_ADDRESS_REPLY_A_BIT)!

	/* Map DMA address of reply header to cpu address.

	 * pa is 32 bits - but the dma address may be 32 or 64 bits

	 * get offset based only only the low addresses

	 /*  Check/log IOC log info

  Check for (valid) IO callback!  */

  Flush (non-TURBO) reply with a WRITE!  */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_interrupt - MPT adapter (IOC) specific interrupt handler.

 *	@irq: irq number (not used)

 *	@bus_id: bus identifier cookie == pointer to MPT_ADAPTER structure

 *

 *	This routine is registered via the request_irq() kernel API call,

 *	and handles all interrupts generated from a specific MPT adapter

 *	(also referred to as a IO Controller or IOC).

 *	This routine must clear the interrupt from the adapter and does

 *	so by reading the reply FIFO.  Multiple replies may be processed

 *	per single call to this routine.

 *

 *	This routine handles register-level access of the adapter but

 *	dispatches (calls) a protocol-specific callback routine to handle

 *	the protocol-specific details of the MPT request completion.

	/*

	 *  Drain the reply FIFO!

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mptbase_reply - MPT base driver's callback routine

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@req: Pointer to original MPT request frame

 *	@reply: Pointer to MPT reply frame (NULL if TurboReply)

 *

 *	MPT base driver's callback routine; all base driver

 *	"internal" request/reply processing is routed here.

 *	Currently used for EventNotification and EventAck handling.

 *

 *	Returns 1 indicating original alloc'd request frame ptr

 *	should be freed, or 0 if it shouldn't.

	/*

	 *	Conditionally tell caller to free the original

	 *	EventNotification/EventAck/unexpected request frame!

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_register - Register protocol-specific main callback handler.

 *	@cbfunc: callback function pointer

 *	@dclass: Protocol driver's class (%MPT_DRIVER_CLASS enum value)

 *	@func_name: call function's name

 *

 *	This routine is called by a protocol-specific driver (SCSI host,

 *	LAN, SCSI target) to register its reply callback routine.  Each

 *	protocol-specific driver must do this before it will be able to

 *	use any IOC resources, such as obtaining request frames.

 *

 *	NOTES: The SCSI protocol driver currently calls this routine thrice

 *	in order to register separate callbacks; one for "normal" SCSI IO;

 *	one for MptScsiTaskMgmt requests; one for Scan/DV requests.

 *

 *	Returns u8 valued "handle" in the range (and S.O.D. order)

 *	{N,...,7,6,5,...,1} if successful.

 *	A return value of MPT_MAX_PROTOCOL_DRIVERS (including zero!) should be

 *	considered an error by the caller.

	/*

	 *  Search for empty callback slot in this order: {N,...,7,6,5,...,1}

	 *  (slot/handle 0 is reserved!)

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_deregister - Deregister a protocol drivers resources.

 *	@cb_idx: previously registered callback handle

 *

 *	Each protocol-specific driver should call this routine when its

 *	module is unloaded.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_event_register - Register protocol-specific event callback handler.

 *	@cb_idx: previously registered (via mpt_register) callback handle

 *	@ev_cbfunc: callback function

 *

 *	This routine can be called by one or more protocol-specific drivers

 *	if/when they choose to be notified of MPT events.

 *

 *	Returns 0 for success.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_event_deregister - Deregister protocol-specific event callback handler

 *	@cb_idx: previously registered callback handle

 *

 *	Each protocol-specific driver should call this routine

 *	when it does not (or can no longer) handle events,

 *	or when its module is unloaded.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_reset_register - Register protocol-specific IOC reset handler.

 *	@cb_idx: previously registered (via mpt_register) callback handle

 *	@reset_func: reset function

 *

 *	This routine can be called by one or more protocol-specific drivers

 *	if/when they choose to be notified of IOC resets.

 *

 *	Returns 0 for success.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_reset_deregister - Deregister protocol-specific IOC reset handler.

 *	@cb_idx: previously registered callback handle

 *

 *	Each protocol-specific driver should call this routine

 *	when it does not (or can no longer) handle IOC reset handling,

 *	or when its module is unloaded.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_device_driver_register - Register device driver hooks

 *	@dd_cbfunc: driver callbacks struct

 *	@cb_idx: MPT protocol driver index

 call per pci device probe entry point */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_device_driver_deregister - DeRegister device driver hooks

 *	@cb_idx: MPT protocol driver index

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_get_msg_frame - Obtain an MPT request frame from the pool

 *	@cb_idx: Handle of registered MPT protocol driver

 *	@ioc: Pointer to MPT adapter structure

 *

 *	Obtain an MPT request frame from the pool (of 1024) that are

 *	allocated per MPT adapter.

 *

 *	Returns pointer to a MPT request frame or %NULL if none are available

 *	or IOC is not active.

 Request index */

 validate handle and ioc identifier */

 If interrupts are not attached, do not return a request frame */

 byte */

 u16! */

 Default, will be changed if necessary in SG generation */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_put_msg_frame - Send a protocol-specific MPT request frame to an IOC

 *	@cb_idx: Handle of registered MPT protocol driver

 *	@ioc: Pointer to MPT adapter structure

 *	@mf: Pointer to MPT request frame

 *

 *	This routine posts an MPT request frame to the request post FIFO of a

 *	specific MPT adapter.

 Request index */

 ensure values are reset properly! */

 byte */

 u16! */

/**

 *	mpt_put_msg_frame_hi_pri - Send a hi-pri protocol-specific MPT request frame

 *	@cb_idx: Handle of registered MPT protocol driver

 *	@ioc: Pointer to MPT adapter structure

 *	@mf: Pointer to MPT request frame

 *

 *	Send a protocol-specific MPT request frame to an IOC using

 *	hi-priority request queue.

 *

 *	This routine posts an MPT request frame to the request post FIFO of a

 *	specific MPT adapter.

 Request index */

 ensure values are reset properly! */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_free_msg_frame - Place MPT request frame back on FreeQ.

 *	@ioc: Pointer to MPT adapter structure

 *	@mf: Pointer to MPT request frame

 *

 *	This routine places a MPT request frame back on the MPT adapter's

 *	FreeQ.

  Put Request back on FreeQ!  */

 signature to know if this mf is freed */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_add_sge - Place a simple 32 bit SGE at address pAddr.

 *	@pAddr: virtual address for SGE

 *	@flagslength: SGE flags and data transfer length

 *	@dma_addr: Physical address

 *

 *	This routine places a MPT request frame back on the MPT adapter's

 *	FreeQ.

/**

 *	mpt_add_sge_64bit - Place a simple 64 bit SGE at address pAddr.

 *	@pAddr: virtual address for SGE

 *	@flagslength: SGE flags and data transfer length

 *	@dma_addr: Physical address

 *

 *	This routine places a MPT request frame back on the MPT adapter's

 *	FreeQ.

/**

 *	mpt_add_sge_64bit_1078 - Place a simple 64 bit SGE at address pAddr (1078 workaround).

 *	@pAddr: virtual address for SGE

 *	@flagslength: SGE flags and data transfer length

 *	@dma_addr: Physical address

 *

 *	This routine places a MPT request frame back on the MPT adapter's

 *	FreeQ.

	/*

	 * 1078 errata workaround for the 36GB limitation

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_add_chain - Place a 32 bit chain SGE at address pAddr.

 *	@pAddr: virtual address for SGE

 *	@next: nextChainOffset value (u32's)

 *	@length: length of next SGL segment

 *	@dma_addr: Physical address

 *

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_add_chain_64bit - Place a 64 bit chain SGE at address pAddr.

 *	@pAddr: virtual address for SGE

 *	@next: nextChainOffset value (u32's)

 *	@length: length of next SGL segment

 *	@dma_addr: Physical address

 *

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_send_handshake_request - Send MPT request via doorbell handshake method.

 *	@cb_idx: Handle of registered MPT protocol driver

 *	@ioc: Pointer to MPT adapter structure

 *	@reqBytes: Size of the request in bytes

 *	@req: Pointer to MPT request frame

 *	@sleepFlag: Use schedule if CAN_SLEEP else use udelay.

 *

 *	This routine is used exclusively to send MptScsiTaskMgmt

 *	requests since they are required to be sent via doorbell handshake.

 *

 *	NOTE: It is the callers responsibility to byte-swap fields in the

 *	request which are greater than 1 byte in size.

 *

 *	Returns 0 for success, non-zero for failure.

	/* State is known to be good upon entering

	 * this function so issue the bus reset

	 * request.

	/*

	 * Emulate what mpt_put_msg_frame() does /wrt to sanity

	 * setting cb_idx/req_idx.  But ONLY if this request

	 * is in proper (pre-alloc'd) request buffer range...

 Make sure there are no doorbells */

 Wait for IOC doorbell int */

 Read doorbell and check for active bit */

 Send request via doorbell handshake */

 Make sure there are no doorbells */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 * mpt_host_page_access_control - control the IOC's Host Page Buffer access

 * @ioc: Pointer to MPT adapter structure

 * @access_control_value: define bits below

 * @sleepFlag: Specifies whether the process can sleep

 *

 * Provides mechanism for the host driver to control the IOC's

 * Host Page Buffer access.

 *

 * Access Control Value - bits[15:12]

 * 0h Reserved

 * 1h Enable Access { MPI_DB_HPBAC_ENABLE_ACCESS }

 * 2h Disable Access { MPI_DB_HPBAC_DISABLE_ACCESS }

 * 3h Free Buffer { MPI_DB_HPBAC_FREE_BUFFER }

 *

 * Returns 0 for success, non-zero for failure.

 return if in use */

 Wait for IOC to clear Doorbell Status bit */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_host_page_alloc - allocate system memory for the fw

 *	@ioc: Pointer to pointer to IOC adapter

 *	@ioc_init: Pointer to ioc init config page

 *

 *	If we already allocated memory in past, then resend the same pointer.

 *	Returns 0 for success, non-zero for failure.

 fw doesn't need any host buffers */

 spin till we get enough memory */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_verify_adapter - Given IOC identifier, set pointer to its adapter structure.

 *	@iocid: IOC unique identifier (integer)

 *	@iocpp: Pointer to pointer to IOC adapter

 *

 *	Given a unique IOC identifier, set pointer to the associated MPT

 *	adapter structure.

 *

 *	Returns iocid and sets iocpp if iocid is found.

 *	Returns -1 if iocid is not found.

/**

 *	mpt_get_product_name - returns product string

 *	@vendor: pci vendor id

 *	@device: pci device id

 *	@revision: pci revision id

 *

 *	Returns product string displayed when driver loads,

 *	in /proc/mpt/summary and /sysfs/class/scsi_host/host<X>/version_product

 *

/**

 *	mpt_mapresources - map in memory mapped io

 *	@ioc: Pointer to pointer to IOC adapter

 *

 Get I/O space! */

 Get memmap */

 Get logical ptr for PciMem0 space */

mem = ioremap(mem_phys, msize);*/

 Save Port IO values in case we need to do downloadboot */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_attach - Install a PCI intelligent MPT adapter.

 *	@pdev: Pointer to pci_dev structure

 *	@id: PCI device ID information

 *

 *	This routine performs all the steps necessary to bring the IOC of

 *	a MPT adapter to a OPERATIONAL state.  This includes registering

 *	memory regions, registering the interrupt, and allocating request

 *	and reply memory pools.

 *

 *	This routine also pre-fetches the LAN MAC address of a Fibre Channel

 *	MPT adapter.

 *

 *	Returns 0 for success, non-zero for failure.

 *

 *	TODO: Add support for polled controllers

	/*

	 * set initial debug level

	 * (refer to mptdebug.h)

	 *

	/*

	 * Setting up proper handlers for scatter gather handling

 avoid div by zero! */

	/* Initialize the event logging.

 None */

	/* Initialize SCSI Config Data structure

	/* Initialize the fc rport list head.

 Find lookup slot. */

 Initialize workqueue */

			/* 929X Chip Fix. Set Split transactions level

		 	* for PCIX. Set MOST bits to zero.

			/* 929XL Chip Fix. Set MMRBC to 0x08.

		/* 919X Chip Fix. Set Split transactions level

		 * for PCIX. Set MOST bits to zero.

		/* 1030 Chip Fix. Disable Split transactions

		 * for PCIX. Set MOST bits to zero if Rev < C0( = 8).

 Disable all! */

 Set IOC ptr in the pcidev's driver data. */

 Set lookup ptr. */

	/* Check for "bound ports" (929, 929X, 1030, 1035) to reduce redundant resets.

 call per device driver probe entry point */

	/*

	 *  Create "/proc/mpt/iocN" subdirectory entry for each MPT adapter.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_detach - Remove a PCI intelligent MPT adapter.

 *	@pdev: Pointer to pci_dev structure

	/*

	 * Stop polling ioc for fault condition

 call per device driver remove entry point */

 Disable interrupts! */

 Clear any lingering interrupt */

/**************************************************************************

 * Power Management

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_suspend - Fusion MPT base driver suspend routine.

 *	@pdev: Pointer to pci_dev structure

 *	@state: new state to enter

 put ioc into READY_STATE */

 disable interrupts */

 Clear any lingering interrupt */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_resume - Fusion MPT base driver resume routine.

 *	@pdev: Pointer to pci_dev structure

	/*

	 * Errata workaround for SAS pci express:

	 * Upon returning to the D0 state, the contents of the doorbell will be

	 * stale data, and this will incorrectly signal to the host driver that

	 * the firmware is ready to process mpt commands.   The workaround is

	 * to issue a diagnostic reset.

 bring ioc to operational state */

		/* make sure we only call the relevant reset handler

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_do_ioc_recovery - Initialize or recover MPT adapter.

 *	@ioc: Pointer to MPT adapter structure

 *	@reason: Event word / reason

 *	@sleepFlag: Use schedule if CAN_SLEEP else use udelay.

 *

 *	This routine performs all the steps necessary to bring the IOC

 *	to a OPERATIONAL state.

 *

 *	This routine also pre-fetches the LAN MAC address of a Fibre Channel

 *	MPT adapter.

 *

 *	Returns:

 *		 0 for success

 *		-1 if failed to get board READY

 *		-2 if READY but IOCFacts Failed

 *		-3 if READY but PrimeIOCFifos Failed

 *		-4 if READY but IOCInit Failed

 *		-5 if failed to enable_device and/or request_selected_regions

 *		-6 if failed to upload firmware

 Disable reply interrupts (also blocks FreeQ) */

			/* Disable alt-IOC's reply interrupts

			 *  (and FreeQ) for a bit

 (re)Enable alt-IOC! (reply interrupt, FreeQ) */

	/* hard_reset_done = 0 if a soft reset was performed

	 * and 1 if a hard reset was performed.

 Get IOC facts! Allow 5 retries */

			/* Retry - alt IOC was initialized once

	/*

	 * Device is reset now. It must have de-asserted the interrupt line

	 * (if it was asserted) and it should be safe to register for the

	 * interrupt now.

 ?? */

	/* Prime reply & request queues!

	 * (mucho alloc's) Must be done prior to

	 * init as upper addresses are needed for init.

	 * If fails, continue with alt-ioc processing

	/* May need to check/upload firmware & data here!

	 * If fails, continue with alt-ioc processing

 NEW!

			/* Controller is not operational, cannot do upload

						/*

						 * Maintain only one pointer to FW memory

						 * so there will not be two attempt to

						 * downloadboot onboard dual function

						 * chips (mpt_adapter_disable,

						 * mpt_diag_reset)

	/*  Enable MPT base driver management of EventNotification

	 *  and EventAck handling.

 1=Enable */

 Enable! (reply interrupt) */

 alt ioc */

 (re)Enable alt-IOC! (reply interrupt) */

	/*	Add additional "reason" check before call to GetLanConfigPages

	 *	(combined with GetIoUnitPage2 call).  This prevents a somewhat

	 *	recursive scenario; GetLanConfigPages times out, timer expired

	 *	routine calls HardResetHandler, which calls into here again,

	 *	and we try GetLanConfigPages again...

		/*

		 * Initialize link list for inactive raid volumes.

 clear persistency table */

			/* Find IM volumes

			/* Check, and possibly reset, the coalescing value

				/*

				 *  Pre-fetch the ports LAN MAC address!

				 *  (LANPage1_t stuff)

			/* Get NVRAM and adapter maximums from SPP 0 and 2

			/* Get version and length of SDP 1

			/* Find IM volumes

			/* Check, and possibly reset, the coalescing value

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_detect_bound_ports - Search for matching PCI bus/dev_function

 *	@ioc: Pointer to MPT adapter structure

 *	@pdev: Pointer to (struct pci_dev) structure

 *

 *	Search for PCI bus/dev_function which matches

 *	PCI bus/dev_function (+/-1) for newly discovered 929,

 *	929X, 1030 or 1035.

 *

 *	If match on PCI dev_function +/-1 is found, bind the two MPT adapters

 *	using alt_ioc pointer fields in their %MPT_ADAPTER structures.

 Paranoia checks */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_adapter_disable - Disable misbehaving MPT adapter.

 *	@ioc: Pointer to MPT adapter structure

	/*

	 * Put the controller into ready state (if its not already)

 Disable adapter interrupts! */

 Clear any lingering interrupt */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_adapter_dispose - Free all resources associated with an MPT adapter

 *	@ioc: Pointer to MPT adapter structure

 *

 *	This routine unregisters h/w resources and frees all alloc'd memory

 *	associated with a MPT adapter structure.

  Zap the adapter lookup ptr!  */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	MptDisplayIocCapabilities - Disply IOC's capabilities.

 *	@ioc: Pointer to MPT adapter structure

	/*

	 *  This would probably evoke more questions than it's worth

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	MakeIocReady - Get IOC to a READY state, using KickStart if needed.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@force: Force hard KickStart of IOC

 *	@sleepFlag: Specifies whether the process can sleep

 *

 *	Returns:

 *		 1 - DIAG reset and READY

 *		 0 - READY initially OR soft reset and READY

 *		-1 - Any failure on KickStart

 *		-2 - Msg Unit Reset Failed

 *		-3 - IO Unit Reset Failed

 *		-4 - IOC owned by a PEER

 Get current [raw] IOC state  */

	/*

	 *	Check to see if IOC got left/stuck in doorbell handshake

	 *	grip of death.  If so, hard reset the IOC.

 Is it already READY? */

	/*

	 *	Check to see if IOC is in FAULT state.

	/*

	 *	Hmmm...  Did it get left operational?

		/* Check WhoInit.

		 * If PCI Peer, exit.

		 * Else, if no fault conditions are present, issue a MessageUnitReset

		 * Else, fall through to KickStart case

	/*

	 *  Loop here waiting for IOC to come READY.

 5 seconds */

			/*

			 *  BIOS or previous driver load left IOC in OP state.

			 *  Reset messaging FIFOs.

			/*

			 *  Something is wrong.  Try to get IOC back

			 *  to a known state.

 1 msec delay */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_GetIocState - Get the current state of a MPT adapter.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@cooked: Request raw or cooked IOC state

 *

 *	Returns all IOC Doorbell register bits if cooked==0, else just the

 *	Doorbell bits in MPI_IOC_STATE_MASK.

  Get!  */

  Save!  */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	GetIocFacts - Send IOCFacts request to MPT adapter.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@sleepFlag: Specifies whether the process can sleep

 *	@reason: If recovery, only update facts.

 *

 *	Returns 0 for success, non-zero for failure.

 IOC *must* NOT be in RESET state! */

 Destination (reply area)... */

 Request area (get_facts on the stack right now!) */

 Assert: All other get_facts fields are zero! */

	/* No non-zero fields in the get_facts request are greater than

	 * 1 byte in size, so we can just fire it off as is.

seconds*/, sleepFlag);

	/*

	 * Now byte swap (GRRR) the necessary fields before any further

	 * inspection of reply contents.

	 *

	 * But need to do some sanity checks on MsgLength (byte) field

	 * to make sure we don't zero IOC's req_sz!

 Did we get a valid reply? */

			/*

			 * If not been here, done that, save off first WhoInit value

 CHECKME! IOCStatus, IOCLogInfo */

		/*

		 * FC f/w version changed between 1.1 and 1.2

		 *	Old: u16{Major(4),Minor(4),SubMinor(8)}

		 *	New: u32{Major(8),Minor(8),Unit(8),Dev(8)}

			/*

			 *	Handle old FC f/w style, convert to new...

		/*

		 * Handle NEW (!) IOCFactsReply fields in MPI-1.01.xx

		 * Older MPI-1.00.xx struct had 13 dwords, and enlarged

		 * to 14 in MPI-1.01.0x.

  Something is wrong!  */

			/*

			 * Set values for this IOC's request & reply frame sizes,

			 * and request & reply queue depths...

 Get port facts! */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	GetPortFacts - Send PortFacts request to MPT adapter.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@portnum: Port number

 *	@sleepFlag: Specifies whether the process can sleep

 *

 *	Returns 0 for success, non-zero for failure.

 IOC *must* NOT be in RESET state! */

 Destination (reply area)...  */

 Request area (get_pfacts on the stack right now!) */

 Assert: All other get_pfacts fields are zero! */

	/* No non-zero fields in the get_pfacts request are greater than

	 * 1 byte in size, so we can just fire it off as is.

seconds*/, sleepFlag);

 Did we get a valid reply? */

 Now byte swap the necessary fields in the response. */

	/*

	 * Place all the devices on channels

	 *

	 * (for debuging)

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	SendIocInit - Send IOCInit request to MPT adapter.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@sleepFlag: Specifies whether the process can sleep

 *

 *	Send IOCInit followed by PortEnable to bring IOC to OPERATIONAL state.

 *

 *	Returns 0 for success, non-zero for failure.

	/* If we are in a recovery mode and we uploaded the FW image,

	 * then this pointer is not NULL. Skip the upload a second time.

	 * Set this flag if cached_fw set for either IOC.

 set MsgVersion and HeaderVersion host driver was built with

 in BYTES */

		/* Save the upper 32-bits of the request

		 * (reply) and sense buffers.

 Force 32-bit addressing */

seconds*/, sleepFlag);

	/* No need to byte swap the multibyte fields in the reply

	 * since we don't even look at its contents.

	/* YIKES!  SUPER IMPORTANT!!!

	 *  Poll IocState until _OPERATIONAL while IOC is doing

	 *  LoopInit and TargetDiscovery!

 60 seconds */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	SendPortEnable - Send PortEnable request to MPT adapter port.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@portnum: Port number to enable

 *	@sleepFlag: Specifies whether the process can sleep

 *

 *	Send PortEnable to bring IOC to OPERATIONAL state.

 *

 *	Returns 0 for success, non-zero for failure.

  Destination...  */

	port_enable.ChainOffset = 0;		*/

	port_enable.MsgFlags = 0;		*/

	port_enable.MsgContext = 0;		*/

	/* RAID FW may take a long time to enable

seconds*/, sleepFlag);

seconds*/, sleepFlag);

/**

 *	mpt_alloc_fw_memory - allocate firmware memory

 *	@ioc: Pointer to MPT_ADAPTER structure

 *      @size: total FW bytes

 *

 *	If memory has already been allocated, the same (cached) value

 *	is returned.

 *

 *	Return 0 if successful, or non-zero for failure

 use already allocated memory */

 use alt_ioc's memory */

/**

 *	mpt_free_fw_memory - free firmware memory

 *	@ioc: Pointer to MPT_ADAPTER structure

 *

 *	If alt_img is NULL, delete from ioc structure.

 *	Else, delete a secondary image in same format.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_do_upload - Construct and Send FWUpload request to MPT adapter port.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@sleepFlag: Specifies whether the process can sleep

 *

 *	Returns 0 for success, >0 for handshake failure

 *		<0 for fw upload failure.

 *

 *	Remark: If bound IOC and a successful FWUpload was performed

 *	on the bound IOC, the second image is discarded

 *	and memory is free'd. Both channels must upload to prevent

 *	IOC from running in degraded mode.

	/* If the image size is 0, we are done.

seconds*/, sleepFlag);

		/* Handshake transfer was complete and successful.

		 * Check the Reply Frame.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_downloadboot - DownloadBoot code

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@pFwHeader: Pointer to firmware header info

 *	@sleepFlag: Specifies whether the process can sleep

 *

 *	FwDownloadBoot requires Programmed IO access.

 *

 *	Returns 0 for success

 *		-1 FW Image size is 0

 *		-2 No valid cached_fw Pointer

 *		<0 for fw upload failure.

 wait 1 msec */

 wait .1 sec */

 Set the DiagRwEn and Disable ARM bits */

	/* Write the LoadStartAddress to the DiagRw Address Register

	 * using Programmed IO

 Write the IopResetVectorRegAddr */

 Write the IopResetVectorValue */

	/* Clear the internal flash bad bit - autoincrementing register,

	 * so must do two writes.

		/*

		 * 1030 and 1035 H/W errata, workaround to access

		 * the ClearFlashBadSignatureBit

 if((ioc->bus_type == SAS) || (ioc->bus_type == FC)) */ {

 wait 1 msec */

 Write 0xFF to reset the sequencer */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	KickStart - Perform hard reset of MPT adapter.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@force: Force hard reset

 *	@sleepFlag: Specifies whether the process can sleep

 *

 *	This routine places MPT adapter in diagnostic mode via the

 *	WriteSequence register, and then performs a hard reset of adapter

 *	via the Diagnostic register.

 *

 *	Inputs:   sleepflag - CAN_SLEEP (non-interrupt thread)

 *			or NO_SLEEP (interrupt thread, use mdelay)

 *		  force - 1 if doorbell active, board fault state

 *				board operational, IOC_RECOVERY or

 *				IOC_BRINGUP and there is an alt_ioc.

 *			  0 else

 *

 *	Returns:

 *		 1 - hard reset, READY

 *		 0 - no reset due to History bit, READY

 *		-1 - no reset due to History bit but not READY

 *		     OR reset but failed to come READY

 *		-2 - no reset, could not enter DIAG mode

 *		-3 - reset but bad FW bit

		/* Always issue a Msg Unit Reset first. This will clear some

		 * SCSI bus hang conditions.

 2 seconds */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_diag_reset - Perform hard reset of the adapter.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@ignore: Set if to honor and clear to ignore

 *		the reset history bit

 *	@sleepFlag: CAN_SLEEP if called in a non-interrupt thread,

 *		else set to NO_SLEEP (use mdelay instead)

 *

 *	This routine places the adapter in diagnostic mode via the

 *	WriteSequence register and then performs a hard reset of adapter

 *	via the Diagnostic register. Adapter should be in ready state

 *	upon successful completion.

 *

 *	Returns:  1  hard reset successful

 *		  0  no reset performed because reset history bit set

 *		 -2  enabling diagnostic mode failed

 *		 -3  diagnostic reset failed

 Pointer to FW */

 Clear any existing interrupts */

		/*

		 * Call each currently registered protocol IOC reset handler

		 * with pre-reset indication.

		 * NOTE: If we're doing _IOC_BRINGUP, there can be no

		 * MptResetHandlers[] registered yet.

 wait 1 sec */

 Use "Diagnostic reset" method! (only thing available!) */

	/* Do the reset if we are told to ignore the reset history

	 * or if the reset history is 0

			/* Write magic sequence to WriteSequence register

			 * Loop until in diagnostic mode

 wait 100 msec */

		/*

		 * Disable the ARM (Bug fix)

		 *

		/*

		 * Now hit the reset bit in the Diagnostic register

		 * (THE BIG HAMMER!) (Clears DRWE bit).

		/*

		 * Call each currently registered protocol IOC reset handler

		 * with pre-reset indication.

		 * NOTE: If we're doing _IOC_BRINGUP, there can be no

		 * MptResetHandlers[] registered yet.

			/* If the DownloadBoot operation fails, the

			 * IOC will be left unusable. This is a fatal error

			 * case.  _diag_reset will return < 0

 wait 1 sec */

			/* Wait for FW to reload and for board

			 * to go to the READY state.

			 * Maximum wait is 60 seconds.

			 * If fail, no error will check again

			 * with calling program.

 wait 1 sec */

	/* Clear RESET_HISTORY bit!  Place board in the

	 * diagnostic mode to update the diag register.

		/* Write magic sequence to WriteSequence register

		 * Loop until in diagnostic mode

 wait 100 msec */

	/* Disable Diagnostic Mode

	/* Check FW reload status flags.

	/*

	 * Reset flag that says we've enabled event notification

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	SendIocReset - Send IOCReset request to MPT adapter.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@reset_type: reset type, expected values are

 *	%MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET or %MPI_FUNCTION_IO_UNIT_RESET

 *	@sleepFlag: Specifies whether the process can sleep

 *

 *	Send IOCReset request to the MPT adapter.

 *

 *	Returns 0 for success, non-zero for failure.

	/* FW ACK'd request, wait for READY state

 15 seconds */

 1 msec delay */

	/* TODO!

	 *  Cleanup all event stuff for this IOC; re-issue EventNotification

	 *  request if needed.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	initChainBuffers - Allocate memory for and initialize chain buffers

 *	@ioc: Pointer to MPT_ADAPTER structure

 *

 *	Allocates memory for and initializes chain buffers,

 *	chain buffer control arrays and spinlock.

	/* ReqToChain size must equal the req_depth

	 * index = req_idx

	/* ChainToChain size must equal the total number

	 * of chain buffers to be allocated.

	 * index = chain_idx

	 *

	 * Calculate the number of chain buffers needed(plus 1) per I/O

	 * then multiply the maximum number of simultaneous cmds

	 *

	 * num_sge = num sge in request frame + last chain buffer

	 * scale = num sge per chain buffer if no chain element

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	PrimeIocFifos - Initialize IOC request and reply FIFOs.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *

 *	This routine allocates memory for the MPT reply and request frame

 *	pools (if necessary), and primes the IOC reply FIFO with

 *	reply frames.

 *

 *	Returns 0 for success, non-zero for failure.

  Prime reply FIFO...  */

		/*

		 * 1078 errata workaround for the 36GB limitation

Reseting DMA mask to 64 bit*/

 chain buffer pool size */

  Request FIFO - WE manage this!  */

		/* Initialize the free chain Q.

		/* Post the chain buffers to the FreeChainQ.

		/* Initialize Request frames linked list

  Queue REQUESTs *internally*!  */

	/* Post Reply frames to FIFO

  Write each address to the IOC!  */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_handshake_req_reply_wait - Send MPT request to and receive reply

 *	from IOC via doorbell handshake method.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@reqBytes: Size of the request in bytes

 *	@req: Pointer to MPT request frame

 *	@replyBytes: Expected size of the reply in bytes

 *	@u16reply: Pointer to area where reply should be written

 *	@maxwait: Max wait time for a reply (in seconds)

 *	@sleepFlag: Specifies whether the process can sleep

 *

 *	NOTES: It is the callers responsibility to byte-swap fields in the

 *	request which are greater than 1 byte in size.  It is also the

 *	callers responsibility to byte-swap response fields which are

 *	greater than 1 byte in size.

 *

 *	Returns 0 for success, non-zero for failure.

	/*

	 * Get ready to cache a handshake reply

	/*

	 * Make sure there are no doorbells (WRITE 0 to IntStatus reg),

	 * then tell IOC that we want to handshake a request of N words.

	 * (WRITE u32val to Doorbell reg).

	/*

	 * Wait for IOC's doorbell handshake int

 Read doorbell and check for active bit */

	/*

	 * Clear doorbell int (WRITE 0 to IntStatus reg),

	 * then wait for IOC to ACKnowledge that it's ready for

	 * our handshake request.

		/*

		 * Stuff request words via doorbell handshake,

		 * with ACK from IOC for each.

		/*

		 * Wait for completion of doorbell handshake reply from the IOC

		/*

		 * Copy out the cached reply...

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	WaitForDoorbellAck - Wait for IOC doorbell handshake acknowledge

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@howlong: How long to wait (in seconds)

 *	@sleepFlag: Specifies whether the process can sleep

 *

 *	This routine waits (up to ~2 seconds max) for IOC doorbell

 *	handshake ACKnowledge, indicated by the IOP_DOORBELL_STATUS

 *	bit in its IntStatus register being clear.

 *

 *	Returns a negative value on failure, else wait loop count.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	WaitForDoorbellInt - Wait for IOC to set its doorbell interrupt bit

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@howlong: How long to wait (in seconds)

 *	@sleepFlag: Specifies whether the process can sleep

 *

 *	This routine waits (up to ~2 seconds max) for IOC doorbell interrupt

 *	(MPI_HIS_DOORBELL_INTERRUPT) to be set in the IntStatus register.

 *

 *	Returns a negative value on failure, else wait loop count.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	WaitForDoorbellReply - Wait for and capture an IOC handshake reply.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@howlong: How long to wait (in seconds)

 *	@sleepFlag: Specifies whether the process can sleep

 *

 *	This routine polls the IOC for a handshake reply, 16 bits at a time.

 *	Reply is cached to IOC private area large enough to hold a maximum

 *	of 128 bytes of reply data.

 *

 *	Returns a negative value on failure, else size of reply in WORDS.

	/*

	 * Get first two u16's so we can look at IOC's intended reply MsgLength

	/*

	 * If no error (and IOC said MsgLength is > 0), piece together

	 * reply 16 bits at a time.

 don't overflow our IOC hs_reply[] buffer! */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	GetLanConfigPages - Fetch LANConfig pages.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *

 *	Return: 0 for success

 *	-ENOMEM if no memory available

 *		-EPERM if not allowed due to ISR context

 *		-EAGAIN if no msg frames currently available

 *		-EFAULT for non-successful reply or no reply (timeout)

 Get LAN Page 0 header */

 save the data */

			/* FIXME!

			 *	Normalize endianness of structure data,

			 *	by byte-swapping all > 1 byte fields!

 Get LAN Page 1 header */

 save the data */

		/* FIXME!

		 *	Normalize endianness of structure data,

		 *	by byte-swapping all > 1 byte fields!

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mptbase_sas_persist_operation - Perform operation on SAS Persistent Table

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@persist_opcode: see below

 *

 *	===============================  ======================================

 *	MPI_SAS_OP_CLEAR_NOT_PRESENT     Free all persist TargetID mappings for

 *					 devices not currently present.

 *	MPI_SAS_OP_CLEAR_ALL_PERSISTENT  Clear al persist TargetID mappings

 *	===============================  ======================================

 *

 *	NOTE: Don't use not this function during interrupt time.

 *

 *	Returns 0 for success, non-zero error

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 init the internal cmd struct */

 insure garbage is not sent to fw */

	/* Get a MF for this command.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	GetIoUnitPage2 - Retrieve BIOS version and boot order information.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *

 *	Returns: 0 for success

 *	-ENOMEM if no memory available

 *		-EPERM if not allowed due to ISR context

 *		-EAGAIN if no msg frames currently available

 *		-EFAULT for non-successful reply or no reply (timeout)

 Get the page header */

 Read the config page */

 If Good, save data */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_GetScsiPortSettings - read SCSI Port Page 0 and 2

 *	@ioc: Pointer to a Adapter Strucutre

 *	@portnum: IOC port number

 *

 *	Return: -EFAULT if read of config page header fails

 *			or if no nvram

 *	If read of SCSI Port Page 0 fails,

 *		NVRAM = MPT_HOST_NVRAM_INVALID  (0xFFFFFFFF)

 *		Adapter settings: async, narrow

 *		Return 1

 *	If read of SCSI Port Page 2 fails,

 *		Adapter settings valid

 *		NVRAM = MPT_HOST_NVRAM_INVALID  (0xFFFFFFFF)

 *		Return 1

 *	Else

 *		Both valid

 *		Return 0

 *	CHECK - what type of locking mechanisms should be used????

	/* Allocate memory

	/* Invalidate NVRAM information

	/* Read SPP0 header, allocate memory, then read page.

 use default */

				/* Save the Port Page 0 data

				/* Update the minSyncFactor based on bus type.

	/* SCSI Port Page 2 - Read the header then the page.

		/* Allocate memory and read SCSI Port Page 2

				/* Nvram data is left with INVALID mark

				/* This is an ATTO adapter, read Page2 accordingly

				/* Save the Port Page 2 data

				 * (reformat into a 32bit quantity)

				  /* Translate ATTO device flags to LSI format

				/*

				 * Save "Set to Avoid SCSI Bus Resets" flag

				/* Save the Port Page 2 data

				 * (reformat into a 32bit quantity)

	/* Update Adapter limits with those from NVRAM

	 * Comment: Don't need to do this. Target performance

	 * parameters will never exceed the adapters limits.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_readScsiDevicePageHeaders - save version and length of SDP1

 *	@ioc: Pointer to a Adapter Strucutre

 *	@portnum: IOC port number

 *

 *	Return: -EFAULT if read of config page header fails

 *		or 0 if success.

	/* Read the SCSI Device Page 1 header

/**

 * mpt_inactive_raid_list_free - This clears this link list.

 * @ioc : pointer to per adapter structure

/**

 * mpt_inactive_raid_volumes - sets up link list of phy_disk_nums for devices belonging in an inactive volume

 *

 * @ioc : pointer to per adapter structure

 * @channel : volume channel

 * @id : volume target id

/**

 *	mpt_raid_phys_disk_pg0 - returns phys disk page zero

 *	@ioc: Pointer to a Adapter Structure

 *	@phys_disk_num: io unit unique phys disk num generated by the ioc

 *	@phys_disk: requested payload data returned

 *

 *	Return:

 *	0 on success

 *	-EFAULT if read of config page header fails or data pointer not NULL

 *	-ENOMEM if pci_alloc failed

/**

 *	mpt_raid_phys_disk_get_num_paths - returns number paths associated to this phys_num

 *	@ioc: Pointer to a Adapter Structure

 *	@phys_disk_num: io unit unique phys disk num generated by the ioc

 *

 *	Return:

 *	returns number paths

/**

 *	mpt_raid_phys_disk_pg1 - returns phys disk page 1

 *	@ioc: Pointer to a Adapter Structure

 *	@phys_disk_num: io unit unique phys disk num generated by the ioc

 *	@phys_disk: requested payload data returned

 *

 *	Return:

 *	0 on success

 *	-EFAULT if read of config page header fails or data pointer not NULL

 *	-ENOMEM if pci_alloc failed

/**

 *	mpt_findImVolumes - Identify IDs of hidden disks and RAID Volumes

 *	@ioc: Pointer to a Adapter Strucutre

 *

 *	Return:

 *	0 on success

 *	-EFAULT if read of config page header fails or data pointer not NULL

 *	-ENOMEM if pci_alloc failed

	/* Free the old page

	/* Read IOCP2 header then the page.

	/* Free the old page

	/* There is at least one physical disk.

	 * Read and save IOC Page 3

	/* Read Header good, alloc memory

	/* Read the Page and save the data

	 * into malloc'd memory.

	/* Read and save IOC Page 4

 Allow 4 additional SEP's */

	/* Read the Page into dma memory.

	/* Check the Coalescing Timeout in IOC Page 1

	/* Read Header good, alloc memory

	/* Read the Page and check coalescing timeout

				/* Write NVRAM and current

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	SendEventNotification - Send EventNotification (on or off) request to adapter

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@EvSwitch: Event switch flags

 *	@sleepFlag: Specifies whether the process can sleep

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	SendEventAck - Send EventAck request to MPT adapter.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@evnp: Pointer to original EventNotification request

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_config - Generic function to issue config message

 *	@ioc:   Pointer to an adapter structure

 *	@pCfg:  Pointer to a configuration structure. Struct contains

 *		action, page address, direction, physical address

 *		and pointer to a configuration page header

 *		Page header is updated.

 *

 *	Returns 0 for success

 *	-EAGAIN if no msg frames currently available

 *	-EFAULT for non-successful reply or no reply (timeout)

 don't send a config page during diag reset */

 don't send if no chance of success */

 init the internal cmd struct */

	/* Get and Populate a free Frame

 Assume page type is not extended and clear "reserved" fields. */

		/* Page Length must be treated as a reserved field for the

		 * extended header.

	/* Add a SGE to the config request.

 attempt one retry for a timed out command */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_ioc_reset - Base cleanup for hard reset

 *	@ioc: Pointer to the adapter structure

 *	@reset_phase: Indicates pre- or post-reset functionality

 *

 *	Remark: Frees resources with internally generated commands.

 wake up mptbase_cmds */

 wake up taskmgmt_cmds */

 currently means nothing really */

 { */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	procfs (%MPT_PROCFS_MPTBASEDIR/...) support stuff...

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	procmpt_create - Create %MPT_PROCFS_MPTBASEDIR entries.

 *

 *	Returns 0 for success, non-zero for failure.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	procmpt_destroy - Tear down %MPT_PROCFS_MPTBASEDIR entries.

 *

 *	Returns 0 for success, non-zero for failure.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	Handles read request from /proc/mpt/summary or /proc/mpt/iocN/summary.

	if (ioc->facts.IOCExceptions & MPI_IOCFACTS_EXCEPT_CONFIG_CHECKSUM_FAIL)

		seq_printf(m, "  CONFIG_CHECKSUM_FAIL!");

	/*

	 *  Rounding UP to nearest 4-kB boundary here...

 per-port info */

 CONFIG_PROC_FS } */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 Month */

 Day */

 insider hack! */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_print_ioc_summary - Write ASCII summary of IOC to a buffer.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@buffer: Pointer to buffer where IOC summary info should be written

 *	@size: Pointer to number of bytes we wrote (set by this routine)

 *	@len: Offset at which to start writing in buffer

 *	@showlan: Display LAN stuff?

 *

 *	This routine writes (english readable) ASCII text, which represents

 *	a summary of IOC information, to a buffer.

	/*

	 *  Shorter summary of attached ioc's...

 "FwRev=" or somesuch */

	/*

	 *  Shorter summary of attached ioc's...

 "FwRev=" or somesuch */

/**

 *	mpt_set_taskmgmt_in_progress_flag - set flags associated with task management

 *	@ioc: Pointer to MPT_ADAPTER structure

 *

 *	Returns 0 for SUCCESS or -1 if FAILED.

 *

 *	If -1 is return, then it was not possible to set the flags

/**

 *	mpt_clear_taskmgmt_in_progress_flag - clear flags associated with task management

 *	@ioc: Pointer to MPT_ADAPTER structure

 *

/**

 *	mpt_halt_firmware - Halts the firmware if it is operational and panic

 *	the kernel

 *	@ioc: Pointer to MPT_ADAPTER structure

 *

/**

 *	mpt_SoftResetHandler - Issues a less expensive reset

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@sleepFlag: Indicates if sleep or schedule must be called.

 *

 *	Returns 0 for SUCCESS or -1 if FAILED.

 *

 *	Message Unit Reset - instructs the IOC to reset the Reply Post and

 *	Free FIFO's. All the Message Frames on Reply Free FIFO are discarded.

 *	All posted buffers are freed, and event notification is turned off.

 *	IOC doesn't reply to any outstanding request. This will transfer IOC

 *	to READY state.

 Disable reply interrupts (also blocks FreeQ) */

 Get IOC facts! Allow 5 retries */

	/*

	 * At this point, we know soft reset succeeded.

 otherwise, hard reset coming */

/**

 *	mpt_Soft_Hard_ResetHandler - Try less expensive reset

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@sleepFlag: Indicates if sleep or schedule must be called.

 *

 *	Returns 0 for SUCCESS or -1 if FAILED.

 *	Try for softreset first, only if it fails go for expensive

 *	HardReset.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	Reset Handling

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_HardResetHandler - Generic reset handler

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@sleepFlag: Indicates if sleep or schedule must be called.

 *

 *	Issues SCSI Task Management call based on input arg values.

 *	If TaskMgmt fails, returns associated SCSI request.

 *

 *	Remark: _HardResetHandler can be invoked from an interrupt thread (timer)

 *	or a non-interrupt thread.  In the former, must not call schedule().

 *

 *	Note: A return of -1 is a FATAL error case, as it means a

 *	FW reload/initialization failed.

 *

 *	Returns 0 for SUCCESS or -1 if FAILED.

	/* Reset the adapter. Prevent more than 1 call to

	 * mpt_do_ioc_recovery at any instant in time.

	/* The SCSI driver needs to adjust timeouts on all current

	 * commands prior to the diagnostic reset being issued.

	 * Prevents timeouts occurring during a diagnostic reset...very bad.

	 * For all other protocol drivers, this is a no-op.

	/*

	 *  MPT base "custom" events may be added here...

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	ProcessEventNotification - Route EventNotificationReply to all event handlers

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@pEventReply: Pointer to EventNotification reply frame

 *	@evHandlers: Pointer to integer, number of event handlers

 *

 *	Routes a received EventNotificationReply to all currently registered

 *	event handlers.

 *	Returns sum of event handlers return values.

	/*

	 *  Do platform normalization of values

	/*

	 *  Do general / base driver event processing

 0A */

 CHECKME! What if evState unexpectedly says OFF (0)? */

 Update EventState field in cached IocFacts */

	/*

	 * Should this event be logged? Events are written sequentially.

	 * When buffer is full, start again at the top.

	/*

	 *  Call each currently registered protocol event handler.

 FIXME?  Examine results here? */

	/*

	 *  If needed, send (a single) EventAck.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_fc_log_info - Log information returned from Fibre Channel IOC.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@log_info: U32 LogInfo reply word from the IOC

 *

 *	Refer to lsi/mpi_log_fc.h.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_spi_log_info - Log information returned from SCSI Parallel IOC.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@log_info: U32 LogInfo word from the IOC

 *

 *	Refer to lsi/sp_log.h.

 strings for sas loginfo */

 00h */

 01h */

 02h */

 00h */

 01h */

 02h */

 03h */

 04h */

 05h */

 06h */

 07h */

 00h */

 01h */

 02h */

 03h */

 04h */

 05h */

 06h */

 07h */

 08h */

 09h */

 0Ah */

 0Bh */

 0Ch */

 0Dh */

 0Eh */

 0Fh */

 10h */

 11h */

 12h */

 13h */

 14h */

 15h */

 16h */

 17h */

 18h */

 19h */

 1Ah */

 1Bh */

 1Ch */

 1Dh */

 1Eh */

 1Fh */

 20h */

 00h */

 00h */

 01h */

 02h */

 03h */

 04h */

 05h */

 06h */

 07h */

 00h */

 01h */

 02h */

 03h */

 04h */

 05h */

 06h */

 07h */

 08h */

 09h */

 0Ah */

 0Bh */

 0Ch */

 0Dh */

 0Eh */

 0Fh */

 10h */

 11h */

 12h */

 13h */

 14h */

 15h */

 16h */

 17h */

 18h */

 19h */

 1Ah */

 1Bh */

 1Ch */

 1Dh */

 1Eh */

 1Fh */

 20h */

 21h */

 22h */

 23h */

 24h */

 25h */

 26h */

 27h */

 28h */

 29h */

 2Ah */

 2Bh */

 2Ch */

 2Dh */

 2Eh */

 2Fh */

 30h */

 31h */

 32h */

 33h */

 34h */

 35h */

 36h */

 37h */

 38h */

 39h */

 3Ah */

 3Bh */

 3Ch */

 3Dh */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_sas_log_info - Log information returned from SAS IOC.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@log_info: U32 LogInfo reply word from the IOC

 *	@cb_idx: callback function's handle

 *

 *	Refer to lsi/mpi_log_sas.h.

SAS*/) &&

 IOP */

 PL */

 IR */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mpt_iocstatus_info_config - IOCSTATUS information for config pages

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@ioc_status: U32 IOCStatus word from IOC

 *	@mf: Pointer to MPT request frame

 *

 *	Refer to lsi/mpi.h.

	/*

	 * ignore invalid page messages for GET_NEXT_HANDLE

 0x0020 */

 0x0021 */

 0x0022 */

 0x0023 */

 0x0024 */

 0x0025 */

/**

 *	mpt_iocstatus_info - IOCSTATUS information returned from IOC.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@ioc_status: U32 IOCStatus word from IOC

 *	@mf: Pointer to MPT request frame

 *

 *	Refer to lsi/mpi.h.

***************************************************************************/

  Common IOCStatus values for all replies                                 */

***************************************************************************/

 0x0001 */

 0x0002 */

 0x0003 */

 0x0004 */

 0x0005 */

 0x0006 */

 0x0007 */

 0x0008 */

***************************************************************************/

  Config IOCStatus values                                                 */

***************************************************************************/

 0x0020 */

 0x0021 */

 0x0022 */

 0x0023 */

 0x0024 */

 0x0025 */

***************************************************************************/

  SCSIIO Reply (SPI, FCP, SAS) initiator values                           */

                                                                          */

  Look at mptscsih_iocstatus_info_scsiio in mptscsih.c */

                                                                          */

***************************************************************************/

 0x0040 */

 0x0045 */

 0x0041 */

 0x0042 */

 0x0043 */

 0x0044 */

 0x0046 */

 0x0047 */

 0x0048 */

 0x0049 */

 0x004A */

 0x004B */

 0x004C */

***************************************************************************/

  SCSI Target values                                                      */

***************************************************************************/

 0x0060 */

 0x0061 */

 0x0062 */

 0x0063 */

 0x0064 */

 0x0065 */

 0x006A */

 0x006B */

 0x006D */

 0x006E */

 0x006F */

 0x0070 */

 0x0071 */

***************************************************************************/

  Fibre Channel Direct Access values                                      */

***************************************************************************/

 0x0066 */

 0x0067 */

 0x0068 */

 0x0069 */

 0x006C */

***************************************************************************/

  LAN values                                                              */

***************************************************************************/

 0x0080 */

 0x0081 */

 0x0082 */

 0x0083 */

 0x0084 */

 0x0085 */

 0x0086 */

 0x0087 */

***************************************************************************/

  Serial Attached SCSI values                                             */

***************************************************************************/

 0x0090 */

 0x0090 */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	fusion_init - Fusion MPT base driver initialization routine.

 *

 *	Returns 0 for success, non-zero for failure.

	/*  Register ourselves (mptbase) in order to facilitate

	 *  EventNotification handling.

	/* Register for hard reset handling callbacks.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	fusion_exit - Perform driver unload cleanup.

 *

 *	This routine frees all resources associated with each MPT adapter

 *	and removes all %MPT_PROCFS_MPTBASEDIR entries.

/*

 *  linux/drivers/message/fusion/mptspi.c

 *      For use with LSI PCI chip/adapter(s)

 *      running LSI Fusion MPT (Message Passing Technology) firmware.

 *

 *  Copyright (c) 1999-2008 LSI Corporation

 *  (mailto:DL-MPTFusionLinux@lsi.com)

 *

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

    This program is free software; you can redistribute it and/or modify

    it under the terms of the GNU General Public License as published by

    the Free Software Foundation; version 2 of the License.



    This program is distributed in the hope that it will be useful,

    but WITHOUT ANY WARRANTY; without even the implied warranty of

    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

    GNU General Public License for more details.



    NO WARRANTY

    THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

    CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

    LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

    solely responsible for determining the appropriateness of using and

    distributing the Program and assumes all risks associated with its

    exercise of rights under this Agreement, including but not limited to

    the risks and costs of program errors, damage to or loss of data,

    programs or equipment, and unavailability or interruption of operations.



    DISCLAIMER OF LIABILITY

    NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

    DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

    USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

    HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES



    You should have received a copy of the GNU General Public License

    along with this program; if not, write to the Free Software

    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 for mdelay */

 notifier code */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 Command line args */

 Used only for internal commands */

/**

 * 	mptspi_setTargetNegoParms  - Update the target negotiation parameters

 *	@hd: Pointer to a SCSI Host Structure

 *	@target: per target private data

 *	@sdev: SCSI device

 *

 * 	Update the target negotiation parameters based on the the Inquiry

 *	data, adapter capabilities, and NVRAM settings.

			/* If RAID, never disable QAS

			 * else if non RAID, do not disable

			 *   QAS if bit 1 is set

			 * bit 1 QAS support, non-raid only

			 * bit 0 IU support

	/* Update tflags based on NVRAM settings. (SCSI only)

			/* Ensure factor is set to the

			 * maximum of: adapter, nvram, inquiry

	/* Make sure data is consistent

	/* Save the data to the target structure.

	/* Disable unused features.

		/* Disable QAS in a mixed configuration case

/**

 * 	mptspi_writeIOCPage4  - write IOC Page 4

 *	@hd: Pointer to a SCSI Host Structure

 *	@channel: channel number

 *	@id: write IOC Page4 for this ID & Bus

 *

 *	Return: -EAGAIN if unable to obtain a Message Frame

 *		or 0 if success.

 *

 *	Remark: We do not wait for a return, write pages sequentially.

	/* Get a MF for this command.

	/* Set the request and the data pointers.

	 * Place data at end of MF.

	/* Complete the request frame (same for all requests).

	/* Add a SGE to the config request.

/**

 *	mptspi_initTarget - Target, LUN alloc/free functionality.

 *	@hd: Pointer to MPT_SCSI_HOST structure

 *	@vtarget: per target private data

 *	@sdev: SCSI device

 *

 *	NOTE: It's only SAFE to call this routine if data points to

 *	sane & valid STANDARD INQUIRY data!

 *

 *	Allocate and initialize memory for this target.

 *	Save inquiry data.

 *

	/* Is LUN supported? If so, upper 2 bits will be 0

	* in first byte of inquiry data.

		/* Treat all Processors as SAF-TE if

/**

 *	mptspi_is_raid - Determines whether target is belonging to volume

 *	@hd: Pointer to a SCSI HOST structure

 *	@id: target device id

 *

 *	Return:

 *		non-zero = true

 *		zero = false

 *

 The real channel for this device is zero */

 The actual physdisknum (for RAID passthrough) */

/**

 *	mptspi_print_write_nego - negotiation parameters debug info that is being sent

 *	@hd: Pointer to a SCSI HOST structure

 *	@starget: SCSI target

 *	@ii: negotiation parameters

 *

/**

 *	mptspi_print_read_nego - negotiation parameters debug info that is being read

 *	@hd: Pointer to a SCSI HOST structure

 *	@starget: SCSI target

 *	@ii: negotiation parameters

 *

 No SPI parameters for RAID devices */

	/*

	if (ioc->spi_data.sdp0length & 1)

		size += size + 4;

	size += 2048;

	/* Get and Populate a free Frame

 Reserved for this action */

 no DV on RAID devices */

 If this is a piece of a RAID, then quiesce first */

 Will this be the last lun on a non-raid device? */

 Async Narrow */

 don't allow updating nego parameters on RAID devices */

 Turn on inline data padding for TAPE when running U320 */

 only want to search RAID components */

		/* The id is the raid PhysDiskNum, even if

/****************************************************************************

 * Supported hardware

 Terminating entry */

/*

 * renegotiate for a given target

/*

 * spi module reset handler

	/* only try to do a renegotiation if we're properly set up

/*

 * spi module resume handler

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	mptspi_probe - Installs scsi devices per bus.

 *	@pdev: Pointer to pci_dev structure

 *

 *	Returns 0 for success, non-zero for failure.

 *

	/*  Added sanity check on readiness of the MPT adapter.

	/*  Sanity check - ensure at least 1 port is INITIATOR capable

	/* VMWare emulation doesn't properly implement WRITE_SAME

	/* Attach the SCSI Host to the IOC structure

 set 16 byte cdb's */

	/* Yikes!  This is important!

	 * Otherwise, by default, linux

	 * only scans target IDs 0-7!

	 * pfactsN->MaxDevices unreliable

	 * (not supported in early

	 *	versions of the FW).

	 * max_id = 1 + actual max id,

	 * max_lun = 1 + actual last lun,

	 *	see hosts.h :o(

	/*

	 * If RAID Firmware Detected, setup virtual channel

	/* Required entry.

	/* Verify that we won't exceed the maximum

	 * number of chain buffers

	 * We can optimize:  ZZ = req_sz/sizeof(SGE)

	 * For 32bit SGE's:

	 *  numSGE = 1 + (ZZ-1)*(maxChain -1) + ZZ

	 *               + (req_sz - 64)/sizeof(SGE)

	 * A slightly different algorithm is required for

	 * 64bit SGEs.

 Reset this value */

	/* SCSI needs scsi_cmnd lookup table!

	 * (with size equal to req_depth*PtrSz!)

	/* Some versions of the firmware don't support page 0; without

	/*

	 * issue internal bus reset

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mptspi_init - Register MPT adapter(s) as SCSI host(s) with SCSI mid-layer.

 *

 *	Returns 0 for success, non-zero for failure.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mptspi_exit - Unregisters MPT adapter(s)

/*

 *  linux/drivers/message/fusion/mptctl.c

 *      mpt Ioctl driver.

 *      For use with LSI PCI chip/adapters

 *      running LSI Fusion MPT (Message Passing Technology) firmware.

 *

 *  Copyright (c) 1999-2008 LSI Corporation

 *  (mailto:DL-MPTFusionLinux@lsi.com)

 *

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

    This program is free software; you can redistribute it and/or modify

    it under the terms of the GNU General Public License as published by

    the Free Software Foundation; version 2 of the License.



    This program is distributed in the hope that it will be useful,

    but WITHOUT ANY WARRANTY; without even the implied warranty of

    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

    GNU General Public License for more details.



    NO WARRANTY

    THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

    CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

    LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

    solely responsible for determining the appropriateness of using and

    distributing the Program and assumes all risks associated with its

    exercise of rights under this Agreement, including but not limited to

    the risks and costs of program errors, damage to or loss of data,

    programs or equipment, and unavailability or interruption of operations.



    DISCLAIMER OF LIABILITY

    NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

    DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

    USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

    HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES



    You should have received a copy of the GNU General Public License

    along with this program; if not, write to the Free Software

    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 for mdelay */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 * Function prototypes. Called from OS entry point mptctl_ioctl.

 * arg contents specific to function.

/*

 * Private function calls.

/*

 * Reset Handler cleanup function

/*

 * Event Handler function

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 * Scatter gather list (SGL) sizes and limits...

#define MAX_SCSI_FRAGS	9

#define MAX_CHAIN_FRAGS	64

#define MAX_CHAIN_FRAGS	(15+15+15+16)

  Define max sg LIST bytes ( == (#frags + #chains) * 8 bytes each)

  Works out to: 592d bytes!     (9+1)*8 + 4*(15+1)*8

                  ^----------------- 80 + 512

 linux only seems to ever give 128kB MAX contiguous (GFP_USER) mem bytes */

 Default timeout value (seconds) */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mptctl_syscall_down - Down the MPT adapter syscall semaphore.

 *	@ioc: Pointer to MPT adapter

 *	@nonblock: boolean, non-zero if O_NONBLOCK is set

 *

 *	All of the ioctl commands can potentially sleep, which is illegal

 *	with a spinlock held, thus we perform mutual exclusion here.

 *

 *	Returns negative errno on error, or zero for success.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *  This is the callback for any message we have posted. The message itself

 *  will be returned to the message pool when we return from the IRQ

 *

 *  This runs in irq context so be short and sweet.

	/*

	 * Handling continuation of the same reply. Processing the first

	 * reply, and eating the other replys that come later.

	/* We are done, issue wake up

 Now wait for the command to complete */

 return failure */

 return failure */

 return failure */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/* mptctl_timeout_expired

 *

 * Expecting an interrupt, however timed out.

 *

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/* mptctl_ioc_reset

 *

 * Clean-up functionality. Used only if there has been a

 * reload of the FW due.

 *

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 ASYNC Event Notification Support */

	/* Raise SIGIO for persistent events.

	 * TODO - this define is not in MPI spec yet,

	 * but they plan to set it to 0x21

	/* This flag is set after SIGIO was raised, and

	 * remains set until the application has read

	 * the event log via ioctl=MPTEVENTREPORT

	/* Signal only for the events that are

	 * requested for by the application

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *  MPT ioctl handler

 *  cmd - specify the particular IOCTL command to be issued

 *  arg - data specific to the command. Must not be null.

 (-6) No such device or address */

	/* Verify intended MPT adapter - set iocnum and the adapter

	 * pointer (iocp)

	/* Handle those commands that are just returning

	 * information stored in the driver.

	 * These commands should never time out and are unaffected

	 * by TM and FW reloads.

	/* All of these commands require an interrupt or

	 * are unknown/illegal.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 * MPT FW download function.  Cast the arg into the mpt_fw_xfer structure.

 * This structure contains: iocnum, firmware length (bytes),

 *      pointer to user space memory where the fw image is stored.

 *

 * Outputs:	None.

 * Return:	0 if successful

 *		-EFAULT if data unavailable

 *		-ENXIO  if no such device

 *		-EAGAIN if resource problem

 *		-ENOMEM if no memory for SGE

 *		-EMLINK if too many chain buffers required

 *		-EBADRQC if adapter does not support FW download

 *		-EBUSY if adapter is busy

 *		-ENOMSG if FW upload returned bad status

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 * FW Download engine.

 * Outputs:	None.

 * Return:	0 if successful

 *		-EFAULT if data unavailable

 *		-ENXIO  if no such device

 *		-EAGAIN if resource problem

 *		-ENOMEM if no memory for SGE

 *		-EMLINK if too many chain buffers required

 *		-EBADRQC if adapter does not support FW download

 *		-EBUSY if adapter is busy

 *		-ENOMSG if FW upload returned bad status

	/*  Valid device. Get a message frame and construct the FW download message.

	/*

	 * Construct f/w download request

	/* Set up the Transaction SGE.

	/* Add the SGL

	/*

	 * Need to kmalloc area(s) for holding firmware image bytes.

	 * But we need to do it piece meal, using a proper

	 * scatter gather list (with 128kB MAX hunks).

	 *

	 * A practical limit here might be # of sg hunks that fit into

	 * a single IOC request frame; 12 or 8 (see below), so:

	 * For FC9xx: 12 x 128kB == 1.5 mB (max)

	 * For C1030:  8 x 128kB == 1   mB (max)

	 * We could support chaining, but things get ugly(ier:)

	 *

	 * Set the sge_offset to the start of the sgl (bytes).

 IOC will READ from sys mem */

	/*

	 * We should only need SGL with 2 simple_32bit entries (up to 256 kB)

	 * for FC9xx f/w image, but calculate max number of sge hunks

	 * we can fit into a request frame, and limit ourselves to that.

	 * (currently no chain support)

	 * maxfrags = (Request Size - FWdownload Size ) / Size of 32 bit SGE

	 *	Request		maxfrags

	 *	128		12

	 *	96		8

	 *	64		4

	/*

	 * Parse SG list, copying sgl itself,

	 * plus f/w image hunks from user space as we go...

		/* Get the SGE type: 0 - TCSGE, 3 - Chain, 1 - Simple SGE

		 * Skip everything but Simple. If simple, copy from

		 *	user space into kernel space.

		 * Note: we should not have anything but Simple as

		 *	Chain SGE are illegal.

	/*

	 * Finally, perform firmware download.

 Now wait for the command to complete */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 * SGE Allocation routine

 *

 * Inputs:	bytes - number of bytes to be transferred

 *		sgdir - data direction

 *		sge_offset - offset (in bytes) from the start of the request

 *			frame to the first SGE

 *		ioc - pointer to the mptadapter

 * Outputs:	frags - number of scatter gather elements

 *		blp - point to the buflist pointer

 *		sglbuf_dma - pointer to the (dma) sgl

 * Returns:	Null if failes

 *		pointer to the (virtual) sgl if successful.

 pointer to array of SGE */

 and chain buffers */

 kernel routine */

 avoid kernel warning msg!

 phys addr

 initialization */

	/* Allocate and initialize an array of kernel

	 * structures for the SG elements.

	/* Allocate a single block of memory to store the sg elements and

	 * the chain buffers.  The calling routine is responsible for

	 * copying the data in this array into the correct place in the

	 * request and chain buffers.

	/* At start:

	 *	sgl = sglbuf = point to beginning of sg buffer

	 *	buflist_ent = 0 = first kernel structure

	 *	sg_spill = number of SGE that can be written before the first

	 *		chain element.

	 *

 Need to chain? */

 overflow check... */

 GRRRRR... */

 Last sge fixup: set LE+eol+eob bits */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 * Routine to free the SGL elements.

 eob */

 skip ignore/chain. */

 we're at eob! */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	mptctl_getiocinfo - Query the host adapter for IOC information.

 *	@arg: User space argument

 *

 * Outputs:	None.

 * Return:	0 if successful

 *		-EFAULT if data unavailable

 *		-ENODEV  if no such device/adapter

	/* Add of PCI INFO results in unaligned access for

	 * IA64 and Sparc. Reset long to int. Return no PCI

	 * data for obsolete format.

 obsolete */

 Verify the data transfer size is correct. */

	/* Fill in the data and return the structure to the calling

	 * program

		/* Get the PCI bus, device, and function numbers for the IOC

		/* Get the PCI bus, device, function and segment ID numbers

	/* Get number of devices

	/* Set the BIOS and FW Version

	/* Set the Version Strings.

	/* Copy the data from kernel memory to user memory

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	mptctl_gettargetinfo - Query the host adapter for target information.

 *	@arg: User space argument

 *

 * Outputs:	None.

 * Return:	0 if successful

 *		-EFAULT if data unavailable

 *		-ENODEV  if no such device/adapter

	/* Fill in the data and return the structure to the calling

	 * program

	/* struct mpt_ioctl_targetinfo does not contain sufficient space

	 * for the target structures so when the IOCTL is called, there is

	 * not sufficient stack space for the structure. Allocate memory,

	 * populate the memory, copy back to the user, then free memory.

	 * targetInfo format:

	 * bits 31-24: reserved

	 *      23-16: LUN

	 *      15- 8: Bus Number

	 *       7- 0: Target ID

	/* Get number of devices

	/* Copy part of the data from kernel memory to user memory

	/* Copy the remaining data from kernel memory to user memory

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/* MPT IOCTL Test function.

 *

 * Outputs:	None.

 * Return:	0 if successful

 *		-EFAULT if data unavailable

 *		-ENODEV  if no such device/adapter

	/* Fill in the data and return the structure to the calling

	 * program

	/* Copy the data from kernel memory to user memory

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	mptctl_eventquery - Query the host adapter for the event types

 *	that are being logged.

 *	@arg: User space argument

 *

 * Outputs:	None.

 * Return:	0 if successful

 *		-EFAULT if data unavailable

 *		-ENODEV  if no such device/adapter

	/* Copy the data from kernel memory to user memory

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

		/* Have not yet allocated memory - do so now.

	/* Update the IOC event logging flag.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

	/* If fewer than 1 event is requested, there must have

	 * been some type of error.

 reset this flag so SIGIO can restart */

	/* Copy the data from kernel memory to user memory

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

	/* If caching FW, Free the old FW image

	/* Allocate memory for the new FW image

	/* Copy the data from user memory to kernel space

	/* Update IOCFactsReply

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/* MPT IOCTL MPTCOMMAND function.

 * Cast the arg into the mpt_ioctl_mpt_command structure.

 *

 * Outputs:	None.

 * Return:	0 if successful

 *		-EBUSY  if previous command timeout and IOC reset is not complete.

 *		-EFAULT if data unavailable

 *		-ENODEV if no such device/adapter

 *		-ETIME	if timer expires

 *		-ENOMEM if memory allocation error

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/* Worker routine for the IOCTL MPTCOMMAND and MPTCOMMAND32 (sparc) commands.

 *

 * Outputs:	None.

 * Return:	0 if successful

 *		-EBUSY  if previous command timeout and IOC reset is not complete.

 *		-EFAULT if data unavailable

 *		-ENODEV if no such device/adapter

 *		-ETIME	if timer expires

 *		-ENOMEM if memory allocation error

 *		-EPERM if SCSI I/O and target is untagged

 data In buffer */

 data Out buffer */

 Num SG elements */

	/* bufIn and bufOut are used for user to kernel space transfers

 Basic sanity checks to prevent underflows or integer overflows */

	/* Verify that the final request frame will not be too large.

	/* Get a free request frame and save the message context.

	/* Copy the request frame

	 * Reset the saved message context.

	 * Request frame in user space

	/* Verify that this request is allowed.

			/* verify that app has not requested

			 *	more sense data than driver

			 *	can provide, if so, reset this parameter

			 * set the sense buffer pointer low address

			 * update the control field to specify Q type

			/* Have the IOCTL driver set the direction based

			 * on the dataOutSize (ordering issue with Sparc).

		/* Check mf->PassthruFlags to determine if

		 * transfer is ImmediateMode or not.

		 * Immediate mode returns data in the ReplyFrame.

		 * Else, we are sending request and response data

		 * in two SGLs at the end of the mf.

		/* Just add a SGE

			/* verify that app has not requested

			 *	more sense data than driver

			 *	can provide, if so, reset this parameter

			 * set the sense buffer pointer low address

			 * update the control field to specify Q type

			/* All commands to physical devices are tagged

			/* Have the IOCTL driver set the direction based

			 * on the dataOutSize (ordering issue with Sparc).

			/* Verify that all entries in the IOC INIT match

			 * existing setup (and in LE format).

		/*

		 * MPI_FUNCTION_PORT_ENABLE

		 * MPI_FUNCTION_TARGET_CMD_BUFFER_POST

		 * MPI_FUNCTION_TARGET_ASSIST

		 * MPI_FUNCTION_TARGET_STATUS_SEND

		 * MPI_FUNCTION_TARGET_MODE_ABORT

		 * MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET

		 * MPI_FUNCTION_IO_UNIT_RESET

		 * MPI_FUNCTION_HANDSHAKE

		 * MPI_FUNCTION_REPLY_FRAME_REMOVAL

		 * MPI_FUNCTION_EVENT_NOTIFICATION

		 *  (driver handles event notification)

		 * MPI_FUNCTION_EVENT_ACK

		/*  What to do with these???  CHECK ME!!!

			MPI_FUNCTION_FC_LINK_SRVC_BUF_POST

			MPI_FUNCTION_FC_LINK_SRVC_RSP

			MPI_FUNCTION_FC_ABORT

			MPI_FUNCTION_LAN_SEND

			MPI_FUNCTION_LAN_RECEIVE

		 	MPI_FUNCTION_LAN_RESET

	/* Add the SGL ( at most one data in SGE and one data out SGE )

	 * In the case of two SGE's - the data out (write) will always

	 * preceede the data in (read) SGE. psgList is used to free the

	 * allocated memory.

 Set up the dataOut memory allocation */

				/* Set up this SGE.

				 * Copy to MF and to sglbuf

				/* Copy user data to kernel space.

				/* Set up this SGE

				 * Copy to MF and to sglbuf

		/* Add a NULL SGE

 Now wait for the command to complete */

	/* If a valid reply frame, copy to the user.

	 * Offset 2: reply length in U32's

	/* If valid sense data, copy to user.

	/* If the overall status is _GOOD and data in, copy data

	 * to user.

	/* Free the allocated memory.

	/* mf is null if command issued successfully

	 * otherwise, failure occurred after mf acquired.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/* Prototype Routine for the HOST INFO command.

 *

 * Outputs:	None.

 * Return:	0 if successful

 *		-EFAULT if data unavailable

 *		-EBUSY  if previous command timeout and IOC reset is not complete.

 *		-ENODEV if no such device/adapter

 *		-ETIME	if timer expires

 *		-ENOMEM if memory allocation error

	/* Reset long to int. Should affect IA64 and SPARC only

 obsolete */

	/* Fill in the data and return the structure to the calling

	 * program

	/* Save the SCSI host no. if

	 * SCSI driver loaded

 Reformat the fw_version into a string */

	/* Issue a config request to get the device serial number

 read */

 Issue the second config page request */

	/* 

	 * Gather ISTWI(Industry Standard Two Wire Interface) Data

	/*

	 *ISTWI Data Definition

	 * pbuf[0] = FW_VERSION = 0x4

	 * pbuf[1] = Bay Count = 6 or 4 or 2, depending on

	 *  the config, you should be seeing one out of these three values

	 * pbuf[2] = Drive Installed Map = bit pattern depend on which

	 *   bays have drives in them

	 * pbuf[3] = Checksum (0x100 = (byte0 + byte2 + byte3)

	/* Copy the data from kernel memory to user memory

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/* Prototype Routine for the TARGET INFO command.

 *

 * Outputs:	None.

 * Return:	0 if successful

 *		-EFAULT if data unavailable

 *		-EBUSY  if previous command timeout and IOC reset is not complete.

 *		-ENODEV if no such device/adapter

 *		-ETIME	if timer expires

 *		-ENOMEM if memory allocation error

	/*  There is nothing to do for FCP parts.

       /* Get the data transfer speeds

	/* Set defaults

	/* Get the target error parameters

 Issue the second config page request */

	/* Copy the data from kernel memory to user memory

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 Verify intended MPT adapter */

 Verify intended MPT adapter */

 Copy data to karg */

	/* Pass new structure to do_mpt_command

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	mptctl_probe - Installs ioctl devices per bus.

 *	@pdev: Pointer to pci_dev structure

 *

 *	Returns 0 for success, non-zero for failure.

 *

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	mptctl_remove - Removed ioctl devices

 *	@pdev: Pointer to pci_dev structure

 *

 *

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 Register this device */

	/*

	 *  Install our handler

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 De-register event handler from base module */

 De-register reset handler from base module */

 De-register callback handler from base module */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *  linux/drivers/message/fusion/mptscsih.c

 *      For use with LSI PCI chip/adapter(s)

 *      running LSI Fusion MPT (Message Passing Technology) firmware.

 *

 *  Copyright (c) 1999-2008 LSI Corporation

 *  (mailto:DL-MPTFusionLinux@lsi.com)

 *

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

    This program is free software; you can redistribute it and/or modify

    it under the terms of the GNU General Public License as published by

    the Free Software Foundation; version 2 of the License.



    This program is distributed in the hope that it will be useful,

    but WITHOUT ANY WARRANTY; without even the implied warranty of

    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

    GNU General Public License for more details.



    NO WARRANTY

    THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

    CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

    LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

    solely responsible for determining the appropriateness of using and

    distributing the Program and assumes all risks associated with its

    exercise of rights under this Agreement, including but not limited to

    the risks and costs of program errors, damage to or loss of data,

    programs or equipment, and unavailability or interruption of operations.



    DISCLAIMER OF LIABILITY

    NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

    DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

    USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

    HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES



    You should have received a copy of the GNU General Public License

    along with this program; if not, write to the Free Software

    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 for mdelay */

 notifier code */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *  Other private/forward protos...

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	mptscsih_getFreeChainBuffer - Function to get a free chain

 *	from the MPT_SCSI_HOST FreeChainQ.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@req_idx: Index of the SCSI IO request frame. (output)

 *

 *	return SUCCESS or FAILED

 mptscsih_getFreeChainBuffer() */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	mptscsih_AddSGE - Add a SGE (plus chain buffers) to the

 *	SCSIIORequest_t Message Frame.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@SCpnt: Pointer to scsi_cmnd structure

 *	@pReq: Pointer to SCSIIORequest_t structure

 *

 *	Returns ...

	/* Map the data portion, if any.

	 * sges_left  = 0 if no data transfer.

	/* Handle the SG case.

	/* Prior to entering this loop - the following must be set

	 * current MF:  sgeOffset (bytes)

	 *              chainSge (Null if original MF is not a chain buffer)

	 *              sg_done (num SGE done for this MF)

	/* Get first (num - 1) SG elements

	 * Skip any SG entries with a length of 0

	 * NOTE: at finish, sg and psge pointed to NEXT data/location positions

 Get next SG element from the OS */

 Get next SG element from the OS */

		/* Add last element, end of buffer and end of list flags.

		/* Add last SGE and set termination flags.

		 * Note: Last SGE may have a length of 0 - which should be ok.

			/* The current buffer is a chain buffer,

			 * but there is not another one.

			 * Update the chain element

			 * Offset and Length fields.

			/* The current buffer is the original MF

			 * and there is no Chain buffer.

		/* At least one chain buffer is needed.

		 * Complete the first MF

		 *  - last SGE element, set the LastElement bit

		 *  - set ChainOffset (words) for orig MF

		 *             (OR finish previous MF chain buffer)

		 *  - update MFStructPtr ChainIndex

		 *  - Populate chain element

		 * Also

		 * Loop until done.

		/* Set LAST_ELEMENT flag for last non-chain element

		 * in the buffer. Since psge points at the NEXT

		 * SGE element, go back one SGE element, update the flags

		 * and reset the pointer. (Note: sgflags & thisxfer are already

		 * set properly).

			/* The current buffer is a chain buffer.

			 * chainSge points to the previous Chain Element.

			 * Update its chain element Offset and Length (must

			 * include chain element size) fields.

			 * Old chain element is now complete.

			/* The original MF buffer requires a chain buffer -

			 * set the offset.

			 * Last element in this MF is a chain element.

		/* NOTE: psge points to the beginning of the chain element

		 * in current buffer. Get a chain buffer.

		/* Update the tracking arrays.

		 * If chainSge == NULL, update ReqToChain, else ChainToChain

		/* Populate the chainSGE for the current buffer.

		 * - Set chain buffer pointer to psge and fill

		 *   out the Address and Flags fields.

		/* Start the SGE for the next buffer

		/* Start the SGE for the next buffer

 mptscsih_AddSGE() */

	/* Not supported for hidden raid components

/**

 *	mptscsih_info_scsiio - debug print info on reply frame

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@sc: original scsi cmnd pointer

 *	@pScsiReply: Pointer to MPT reply frame

 *

 *	MPT_DEBUG_REPLY needs to be enabled to obtain this info

 *

 *	Refer to lsi/mpi.h.

	/*

	 *  Look for + dump FCP ResponseInfo[]!

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	mptscsih_io_done - Main SCSI IO callback routine registered to

 *	Fusion MPT (base) driver

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@mf: Pointer to original MPT request frame

 *	@r: Pointer to MPT reply frame (NULL if TurboReply)

 *

 *	This routine is called from mpt.c::mpt_interrupt() at the completion

 *	of any SCSI IO request.

 *	This routine is registered with the Fusion MPT (base) driver at driver

 *	load/init time via the mpt_register() API call.

 *

 *	Returns 1 indicating alloc'd request frame ptr should be freed.

	/* Special case, where already freed message frame is received from

	 * Firmware. It happens with Resetting IOC.

	 * Return immediately. Do not care

		/* Remark: writeSDP1 will use the ScsiDoneCtx

		 * If a SCSI I/O cmd, device disabled by OS and

		 * completion done. Cannot touch sc struct. Just free mem.

 Set default reply as OK */

 special context reply handling */

		/*

		 *  if we get a data underrun indication, yet no data was

		 *  transferred and the SCSI status indicates that the

		 *  command was never started, change the data underrun

		 *  to success

		/*

		 *  Look for + dump FCP ResponseInfo[]!

 0x0002 */

 0x0006 */

			/* CHECKME!

			 * Maybe: DRIVER_BUSY | SUGGEST_RETRY | DID_SOFT_ERROR (retry)

			 * But not: DID_BUS_BUSY lest one risk

			 * killing interrupt handler:-(

 0x0041 */

 0x0042 */

 0x0043 */

 Spoof to SCSI Selection Timeout! */

 else fibre, just stall until rescan event */

 0x004B */

					    /* flag the device as being in

					     * device removal delay so we can

					     * notify the midlayer to hold off

				/*

				 * The FC IOC may kill a request for variety of

				 * reasons, some of which may be recovered by a

				 * retry, some which are unlikely to be

				 * recovered. Return DID_ERROR instead of

				 * DID_RESET to permit retry of the command,

				 * just not an infinite number of them

			/*

			 * Allow non-SAS & non-NEXUS_LOSS to drop into below code

 0x0048 */

			/* Linux handles an unsolicited DID_RESET better

			 * than an unsolicited DID_ABORT.

 0x004C */

 0x0049 */

 Sufficient data transfer occurred */

 0x0045 */

			/*

			 *  Do upfront check for valid SenseData and give it

			 *  precedence!

				/*

				 * For an Errata on LSI53C1030

				 * When the length of request data

				 * and transfer data are different

				 * with result of command (READ or VERIFY),

				 * DID_SOFT_ERROR is set.

					/* What to do?

  Not real sure here either...  */

			/* Report Queue Full

 0x0044 */

 0x0040 */

 0x0000 */

				/*

				 * For potential trouble on LSI53C1030.

				 * (date:2007.xx.)

				 * It is checked whether the length of

				 * request data is equal to

				 * the length of transfer and residual.

				 * MEDIUM_ERROR is set by incorrect data.

				/*

				 * If running against circa 200003dd 909 MPT f/w,

				 * may get this (AUTOSENSE_VALID) for actual TASK_SET_FULL

				 * (QUEUE_FULL) returned from device! --> get 0x0000?128

				 * and with SenseBytes set to 0.

				/*

				 * What to do?

  Not real sure here either...  */

				/* Device Inq. data indicates that it supports

				 * QTags, but rejects QTag messages.

				 * This command completed OK.

				 *

			/* Add handling of:

			 * Reservation Conflict, Busy,

			 * Command Terminated, CHECK

 0x0047 */

 0x0001 */

 0x0003 */

 0x0004 */

 0x0005 */

 0x0007 */

 0x0008 */

 0x0046 */

 0x004A */

			/*

			 * What to do?

 switch(status) */

 end of address reply case */

 Unmap the DMA buffers, if any. */

 Issue the command callback */

 Free Chain buffers */

/*

 *	mptscsih_flush_running_cmds - For each command found, search

 *		Scsi_Host instance taskQ and reply to OS.

 *		Called only if recovering from a FW reload.

 *	@hd: Pointer to a SCSI HOST structure

 *

 *	Returns: None.

 *

 *	Must be called while new I/Os are being queued.

/*

 *	mptscsih_search_running_cmds - Delete any commands associated

 *		with the specified target and lun. Function called only

 *		when a lun is disable by mid-layer.

 *		Do NOT access the referenced scsi_cmnd structure or

 *		members. Will cause either a paging or NULL ptr error.

 *		(BUT, BUT, BUT, the code does reference it! - mdr)

 *      @hd: Pointer to a SCSI HOST structure

 *	@vdevice: per device private data

 *

 *	Returns: None.

 *

 *	Called from slave_destroy.

			/* If the device is a hidden raid component, then its

			 * expected that the mf->function will be RAID_SCSI_IO

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	mptscsih_report_queue_full - Report QUEUE_FULL status returned

 *	from a SCSI target device.

 *	@sc: Pointer to scsi_cmnd structure

 *	@pScsiReply: Pointer to SCSIIOReply_t

 *	@pScsiReq: Pointer to original SCSI request

 *

 *	This routine periodically reports QUEUE_FULL status returned from a

 *	SCSI target device.  It reports this to the console via kernel

 *	printk() API call, not more than once every 10 seconds.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	mptscsih_remove - Removed scsi devices

 *	@pdev: Pointer to pci_dev structure

 *

 *

	/* NULL the Scsi_Host pointer

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	mptscsih_shutdown - reboot notifier

 *

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	mptscsih_suspend - Fusion MPT scsi driver suspend routine.

 *

 *

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	mptscsih_resume - Fusion MPT scsi driver resume routine.

 *

 *

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mptscsih_info - Return information about MPT adapter

 *	@SChost: Pointer to Scsi_Host structure

 *

 *	(linux scsi_host_template.info routine)

 *

 *	Returns pointer to buffer where information was written.

 4Kb */, GFP_KERNEL)) == NULL)

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mptscsih_qcmd - Primary Fusion MPT SCSI initiator IO start routine.

 *	@SCpnt: Pointer to scsi_cmnd structure

 *

 *	(linux scsi_host_template.queuecommand routine)

 *	This is the primary SCSI IO start routine.  Create a MPI SCSIIORequest

 *	from a linux scsi_cmnd request and send it to the IOC.

 *

 *	Returns 0. (rtn value discarded by linux scsi mid-layer)

	/*

	 *  Put together a MPT SCSI request...

	/*    TUR's being issued with scsictl=0x02000000 (DATA_IN)!

	 *    Seems we may receive a buffer (datalen>0) even when there

	 *    will be no data transfer!  GRRRRR...

 DATA IN  (host<--ioc<--dev) */

 DATA OUT (host-->ioc-->dev) */

	/* Default to untagged. Once a target structure has been allocated,

	 * use the Inquiry data to determine if device supports tagged.

	/* Use the above information to set up the message frame

	/*

	 *  Write SCSI CDB into the message

 DataLength */

 SenseBuffer low address */

	/* Now add the SG list

	 * Always have a SGE even if null length.

 Add a NULL SGE */

 Add a 32 or 64 bit SGE */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	mptscsih_freeChainBuffers - Function to free chain buffers associated

 *	with a SCSI IO request

 *	@hd: Pointer to the MPT_SCSI_HOST instance

 *	@req_idx: Index of the SCSI IO request frame.

 *

 *	Called if SG chain buffer allocation fails and mptscsih callbacks.

 *	No return.

	/* Get the first chain index and reset

	 * tracker state.

 Save the next chain buffer index */

		/* Free this chain buffer and reset

		 * tracker

 handle next */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	Reset Handling

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mptscsih_IssueTaskMgmt - Generic send Task Management function.

 *	@hd: Pointer to MPT_SCSI_HOST structure

 *	@type: Task Management type

 *	@channel: channel number for task management

 *	@id: Logical Target ID for reset (if appropriate)

 *	@lun: Logical Unit for reset (if appropriate)

 *	@ctx2abort: Context for the task to be aborted (if appropriate)

 *	@timeout: timeout for task management control

 *

 *	Remark: _HardResetHandler can be invoked from an interrupt thread (timer)

 *	or a non-interrupt thread.  In the former, must not call schedule().

 *

 *	Not all fields are meaningfull for all task types.

 *

 *	Returns 0 for SUCCESS, or FAILED.

 *

	/* DOORBELL ACTIVE check is not required if

	*  MPI_IOCFACTS_CAPABILITY_HIGH_PRI_Q is supported.

	/* Return Fail to calling function if no message frames available.

	/* Format the Request

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mptscsih_abort - Abort linux scsi_cmnd routine, new_eh variant

 *	@SCpnt: Pointer to scsi_cmnd structure, IO to be aborted

 *

 *	(linux scsi_host_template.eh_abort_handler routine)

 *

 *	Returns SUCCESS or FAILED.

	/* If we can't locate our host adapter structure, return FAILED status.

	/* Task aborts are not supported for hidden raid components.

	/* Task aborts are not supported for volumes.

	/* Find this command

		/* Cmd not found in ScsiLookup.

		 * Do OS callback.

	/* Most important!  Set TaskMsgContext to SCpnt's MsgContext!

	 * (the IO to be ABORT'd)

	 *

	 * NOTE: Since we do not byteswap MsgContext, we do not

	 *	 swap it here either.  It is an opaque cookie to

	 *	 the controller, so it does not matter. -DaveM

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mptscsih_dev_reset - Perform a SCSI TARGET_RESET!  new_eh variant

 *	@SCpnt: Pointer to scsi_cmnd structure, IO which reset is due to

 *

 *	(linux scsi_host_template.eh_dev_reset_handler routine)

 *

 *	Returns SUCCESS or FAILED.

	/* If we can't locate our host adapter structure, return FAILED status.

	/* Target reset to hidden raid component is not supported

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mptscsih_bus_reset - Perform a SCSI BUS_RESET!	new_eh variant

 *	@SCpnt: Pointer to scsi_cmnd structure, IO which reset is due to

 *

 *	(linux scsi_host_template.eh_bus_reset_handler routine)

 *

 *	Returns SUCCESS or FAILED.

	/* If we can't locate our host adapter structure, return FAILED status.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mptscsih_host_reset - Perform a SCSI host adapter RESET (new_eh variant)

 *	@SCpnt: Pointer to scsi_cmnd structure, IO which reset is due to

 *

 *	(linux scsi_host_template.eh_host_reset_handler routine)

 *

 *	Returns SUCCESS or FAILED.

  If we can't locate the host to reset, then we failed. */

 make sure we have no outstanding commands at this stage */

	/*  If our attempts to reset the host failed, then return a failed

	 *  status.  The host will be taken off line by the SCSI mid-layer.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mptscsih_taskmgmt_complete - Registered with Fusion MPT base driver

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@mf: Pointer to SCSI task mgmt request frame

 *	@mr: Pointer to SCSI task mgmt reply frame

 *

 *	This routine is called from mptbase.c::mpt_interrupt() at the completion

 *	of any SCSI task management request.

 *	This routine is registered with the MPT (base) driver at driver

 *	load/init time via the mpt_register() API call.

 *

 *	Returns 1 indicating alloc'd request frame ptr should be freed.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	This is anyones guess quite frankly.

	/*

	 * Handle extended translation size for logical drives

	 * > 1Gb

 return result */

/* Search IOC page 3 to determine if this is hidden physical disk

 *

	/*

	 * Check if dual path

	/*

	 * Check inactive list for matching phys disks

	/*

	 * Check if dual path

	/*

	 * Check inactive list for matching phys disks

/*

 *	OS entry point to allow for host driver to free allocated memory

 *	Called if no device present or device being unloaded

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	mptscsih_change_queue_depth - This function will set a devices queue depth

 *	@sdev: per scsi_device pointer

 *	@qdepth: requested queue depth

 *

 *	Adding support for new 'change_queue_depth' api.

/*

 *	OS entry point to adjust the queue_depths on a per-device basis.

 *	Called once per device the bus scan. Use it to force the queue_depth

 *	member to 1 if a device does not support Q tags.

 *	Return non-zero if fails.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *  Private routines...

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/* Utility function to copy sense data from the scsi_cmnd buffer

 * to the FC and SCSI target structures.

 *

	/* Get target structure

 Copy the sense received into the scsi command block. */

		/* Log SMART data (asc = 0x5D, non-IM case only) if required.

/**

 * mptscsih_get_scsi_lookup - retrieves scmd entry

 * @ioc: Pointer to MPT_ADAPTER structure

 * @i: index into the array

 *

 * Returns the scsi_cmd pointer

/**

 * mptscsih_getclear_scsi_lookup -  retrieves and clears scmd entry from ScsiLookup[] array list

 * @ioc: Pointer to MPT_ADAPTER structure

 * @i: index into the array

 *

 * Returns the scsi_cmd pointer

 *

/**

 * mptscsih_set_scsi_lookup - write a scmd entry into the ScsiLookup[] array list

 *

 * @ioc: Pointer to MPT_ADAPTER structure

 * @i: index into the array

 * @scmd: scsi_cmnd pointer

 *

/**

 * SCPNT_TO_LOOKUP_IDX - searches for a given scmd in the ScsiLookup[] array list

 * @ioc: Pointer to MPT_ADAPTER structure

 * @sc: scsi_cmnd pointer

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 currently means nothing really */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 currently means nothing really */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *  Bus Scan and Domain Validation functionality ...

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *	mptscsih_scandv_complete - Scan and DV callback routine registered

 *	to Fustion MPT (base) driver.

 *

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@mf: Pointer to original MPT request frame

 *	@mr: Pointer to MPT reply frame (NULL if TurboReply)

 *

 *	This routine is called from mpt.c::mpt_interrupt() at the completion

 *	of any SCSI IO request.

 *	This routine is registered with the Fusion MPT (base) driver at driver

 *	load/init time via the mpt_register() API call.

 *

 *	Returns 1 indicating alloc'd request frame ptr should be freed.

 *

 *	Remark: Sets a completion code and (possibly) saves sense data

 *	in the IOC member localReply structure.

 *	Used ONLY for DV and other internal commands.

/**

 *	mptscsih_get_completion_code - get completion code from MPT request

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@req: Pointer to original MPT request frame

 *	@reply: Pointer to MPT reply frame (NULL if TurboReply)

 *

 0x0043 */

 0x0046 */

 0x0048 */

 0x004B */

 0x004C */

 0x0045 */

 0x0040 */

 0x0000 */

 0x0047 */

 switch(status) */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mptscsih_do_cmd - Do internal command.

 *	@hd: MPT_SCSI_HOST pointer

 *	@io: INTERNAL_CMD pointer.

 *

 *	Issue the specified internally generated command and do command

 *	specific cleanup. For bus scan / DV only.

 *	NOTES: If command is Inquiry and status is good,

 *	initialize a target structure, save the data

 *

 *	Remark: Single threaded access only.

 *

 *	Return:

 *		< 0 if an illegal command or no resources

 *

 *		   0 if good

 *

 *		 > 0 if command complete but some type of completion error.

 don't send internal command during diag reset */

	/* Set command specific information

Spin up the disk */

		CDB[1] = 0x02;	/* set immediate bit */

 Error Case */

	/* Get and Populate a free Frame

	 * MsgContext set in mpt_get_msg_frame call

 Get the request index */

 for debug */

 MsgContext set in mpt_get_msg_fram call  */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	mptscsih_synchronize_cache - Send SYNCHRONIZE_CACHE to all disks.

 *	@hd: Pointer to a SCSI HOST structure

 *	@vdevice: virtual target device

 *

 *	Uses the ISR, but with special processing.

 *	MUST be single-threaded.

 *

	/* Ignore hidden raid components, this is handled when the command

	 * is sent to the volume

	/* Following parameters will not change

	 * in this routine.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *  linux/drivers/message/fusion/mptlan.c

 *      IP Over Fibre Channel device driver.

 *      For use with LSI Fibre Channel PCI chip/adapters

 *      running LSI Fusion MPT (Message Passing Technology) firmware.

 *

 *  Copyright (c) 2000-2008 LSI Corporation

 *  (mailto:DL-MPTFusionLinux@lsi.com)

 *

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

    This program is free software; you can redistribute it and/or modify

    it under the terms of the GNU General Public License as published by

    the Free Software Foundation; version 2 of the License.



    This program is distributed in the hope that it will be useful,

    but WITHOUT ANY WARRANTY; without even the implied warranty of

    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

    GNU General Public License for more details.



    NO WARRANTY

    THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

    CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

    LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

    solely responsible for determining the appropriateness of using and

    distributing the Program and assumes all risks associated with its

    exercise of rights under this Agreement, including but not limited to

    the risks and costs of program errors, damage to or loss of data,

    programs or equipment, and unavailability or interruption of operations.



    DISCLAIMER OF LIABILITY

    NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

    DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

    USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

    HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES



    You should have received a copy of the GNU General Public License

    along with this program; if not, write to the Free Software

    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 * Define statements used for debugging

#define MPT_LAN_IO_DEBUG

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 * MPT LAN message sizes without variable part.

/*

 *  Fusion MPT LAN private structures

 Port number in the IOC. This is not a Unix network port! */

 number of unused buckets on IOC */

 Send more when this many left */

 Free Tx Context list */

 Free Rx Context list */

 Receive BufferControl structs */

 Send BufferControl structs */

 Max buckets to send to IOC */

 IOC's Tx queue len */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *  Forward protos...

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *  Fusion MPT LAN private data

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/**

 *	lan_reply - Handle all data sent from the hardware.

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@mf: Pointer to original MPT request frame (NULL if TurboReply)

 *	@reply: Pointer to MPT reply frame

 *

 *	Returns 1 indicating original alloc'd request frame ptr

 *	should be freed, or 0 if it shouldn't.

	dioprintk((KERN_INFO MYNAM "@lan_reply: mf = %p, reply = %p\n",

			mf, reply));

 NOTE!  (Optimization) First case here is now caught in

  mptbase.c::mpt_interrupt() routine and callcack here

  is now skipped for this case!

			dioprintk((KERN_INFO MYNAM "/lan_reply: "

				  "MessageContext turbo reply received\n"));

			dioprintk((MYNAM "/lan_reply: "

				  "calling mpt_lan_send_reply (turbo)\n"));

 Potential BUG here?

	FreeReqFrame = mpt_lan_send_turbo(dev, tmsg);

  If/when mpt_lan_send_turbo would return 1 here,

  calling routine (mptbase.c|mpt_interrupt)

  would Oops because mf has already been set

  to NULL.  So after return from this func,

  mpt_interrupt() will attempt to put (NULL) mf ptr

  item back onto its adapter FreeQ - Oops!:-(

  It's Ok, since mpt_lan_send_turbo() *currently*

  always returns 0, but..., just in case:

			dioprintk((KERN_INFO MYNAM "@lan_reply: "

				  "rcv-Turbo = %08x\n", tmsg));

 CHECKME!  Hmmm...  FreeReqFrame is 0 here; is that right? */

	msg = (u32 *) reply;

	dioprintk((KERN_INFO MYNAM "@lan_reply: msg = %08x %08x %08x %08x\n",

		  le32_to_cpu(msg[0]), le32_to_cpu(msg[1]),

		  le32_to_cpu(msg[2]), le32_to_cpu(msg[3])));

	dioprintk((KERN_INFO MYNAM "@lan_reply: Function = %02xh\n",

		  reply->u.hdr.Function));

		/* Just a default reply. Might want to check it to

		 * make sure that everything went ok.

		/*  _EVENT_NOTIFICATION should NOT come down this path any more.

		 *  Should be routed to mpt_lan_event_process(), but just in case...

 CHECKME!  Hmmm...  FreeReqFrame is 0 here; is that right? */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 Reset Rx Free Tail index and re-populate the queue. */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 00 */

 01 */

 02 */

 03 */

 04 */

 05 */

 06 */

		/* Ok, do we need to do anything here? As far as

		   I can tell, this is when a new device gets added

 07 */

 08 */

 09 */

 0A */

	/*

	 *  NOTE: pEvent->AckRequired handling now done in mptbase.c;

	 *  Do NOT do it here now!

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

*/	dlprintk((KERN_INFO MYNAM "/lo: txfidx contains - "));

*/	for (i = 0; i < priv->tx_max_out; i++)

*/		dlprintk((" %xh", priv->mpt_txfidx[i]));

*/	dlprintk(("\n"));

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/* Send a LanReset message to the FW. This should result in the FW returning

/*		dlprintk((KERN_ERR MYNAM "/reset: Evil funkiness abounds! "

		"Unable to allocate a request frame.\n"));

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

*/			dlprintk((KERN_INFO MYNAM "/lan_close: bucket %05x "

*/				  "is still out\n", i));

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 Tx timeout handler. */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

static inline int

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 Add check for Loginfo Flag in IOCStatus */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

	dioprintk((KERN_INFO MYNAM ": %s/%s: Creating new msg frame (send).\n",

			IOC_AND_NETDEV_NAMES_s_s(dev)));

	/* Set the mac.raw pointer, since this apparently isn't getting

	 * done before we get the skb. Pull the data pointer past the mac data.

 Message Header */

 Transaction Context Element */

 No Flags, 8 bytes of Details, 32bit Context (bloody turbo replies) */

	dioprintk((KERN_INFO MYNAM ": %s/%s: BC = %08x, skb = %p, buff = %p\n",

			IOC_AND_NETDEV_NAMES_s_s(dev),

			ctx, skb, skb->data));

	/* If we ever decide to send more than one Simple SGE per LANSend, then

	   we will need to make sure that LAST_ELEMENT only gets set on the

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 * @priority: 0 = put it on the timer queue, 1 = put it on the immediate queue

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

static inline int

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

*/	dlprintk((KERN_INFO MYNAM "/receive_post_reply: "

		dlprintk((KERN_INFO MYNAM ": %s: dev_name = %s\n",

				IOC_AND_NETDEV_NAMES_s_s(dev)));

		dlprintk((KERN_INFO MYNAM "@rpr[2], priv = %p, buckets_out addr = %p",

				priv, &(priv->buckets_out)));

		dlprintk((KERN_INFO MYNAM "@rpr[2] TC + 3\n"));

	for (i = 0; i < priv->max_buckets_out; i++)

		if (priv->RcvCtl[i].skb != NULL)

			dlprintk((KERN_INFO MYNAM "@rpr: bucket %03x "

				  "is still out\n", i));

/*	dlprintk((KERN_INFO MYNAM "/receive_post_reply: freed %d buckets\n",

		  count));

*/	dlprintk((KERN_INFO MYNAM "@receive_post_reply: %d buckets "

*/		  "remaining, %d received back since sod.\n",

*/		  atomic_read(&priv->buckets_out), priv->total_received));

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

	if (offset != 0) {

		printk (KERN_INFO MYNAM ": %s/%s: Got a ReceivePostReply "

			"w/ PacketOffset %u\n",

				IOC_AND_NETDEV_NAMES_s_s(dev),

				offset);

	}

		dioprintk((KERN_INFO MYNAM ": %s/%s: Multiple buckets returned "

			"for single packet, concatenating...\n",

				IOC_AND_NETDEV_NAMES_s_s(dev)));

			dioprintk((KERN_INFO MYNAM ": %s/%s: Buckets = %d, len = %u\n",

					IOC_AND_NETDEV_NAMES_s_s(dev),

					i, l));

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 Simple SGE's only at the moment */

*/			printk (KERN_WARNING MYNAM "/%s: No buckets posted\n",

*/				__func__);

/*	printk(KERN_INFO MYNAM ": posting buckets\n   ");

 *	for (i = 0; i < j + 2; i ++)

 *	    printk (" %08x", le32_to_cpu(msg[i]));

 *	printk ("\n");

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

  Grab pre-fetched LANPage1 stuff. :-) */

	/* The Tx queue is 127 deep on the 909.

	 * Give ourselves some breathing room.

 MTU range: 96 - 65280 */

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

	/* Strip the SNAP header from ARP packets since we don't

	 * pass them through to the 802.2/SNAP layers.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *  linux/drivers/message/fusion/mptsas.c

 *      For use with LSI PCI chip/adapter(s)

 *      running LSI Fusion MPT (Message Passing Technology) firmware.

 *

 *  Copyright (c) 1999-2008 LSI Corporation

 *  (mailto:DL-MPTFusionLinux@lsi.com)

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

    This program is free software; you can redistribute it and/or modify

    it under the terms of the GNU General Public License as published by

    the Free Software Foundation; version 2 of the License.



    This program is distributed in the hope that it will be useful,

    but WITHOUT ANY WARRANTY; without even the implied warranty of

    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

    GNU General Public License for more details.



    NO WARRANTY

    THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

    CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

    LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

    solely responsible for determining the appropriateness of using and

    distributing the Program and assumes all risks associated with its

    exercise of rights under this Agreement, including but not limited to

    the risks and costs of program errors, damage to or loss of data,

    programs or equipment, and unavailability or interruption of operations.



    DISCLAIMER OF LIABILITY

    NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

    DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

    USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

    HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES



    You should have received a copy of the GNU General Public License

    along with this program; if not, write to the Free Software

    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 for mdelay */

/*

 * Reserved channel for integrated raid

 scsi-mid layer global parameter is max_report_luns, which is 511 */

 Used only for internal commands */

 inhibit sas firmware event handling */

 enable sas firmware event handling */

 queue a sas firmware event */

 requeue a sas firmware event */

 free memory associated to a sas firmware event */

/* walk the firmware event queue, and either stop or wait for

 flush the target_reset_list */

/*

 * mptsas_find_portinfo_by_handle

 *

 * This function should be called with the sas_topology_mutex already held

/**

 *	mptsas_find_portinfo_by_sas_address - find and return portinfo for

 *		this sas_address

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@sas_address: expander sas address

 *

 *	This function should be called with the sas_topology_mutex already held.

 *

 *	Return: %NULL if not found.

/*

 * Returns true if there is a scsi end device

 no mutex */

/**

 *	mptsas_add_device_component - adds a new device component to our lists

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@channel: channel number

 *	@id: Logical Target ID for reset (if appropriate)

 *	@sas_address: expander sas address

 *	@device_info: specific bits (flags) for devices

 *	@slot: enclosure slot ID

 *	@enclosure_logical_id: enclosure WWN

 *

	/*

	 * Delete all matching devices out of the list

	/*

	 * Set Firmware mapping

	/*

	 * Set OS mapping

/**

 *	mptsas_add_device_component_by_fw - adds a new device component by FW ID

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@channel: channel number

 *	@id: Logical Target ID

 *

/**

 *	mptsas_add_device_component_starget_ir - Handle Integrated RAID, adding each individual device to list

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@starget: SCSI target for this SCSI device

 *

 assumption that all volumes on channel = 0 */

	/*

	 * Adding entry for hidden components

	/*

	 * Delete all matching devices out of the list

/**

 *	mptsas_add_device_component_starget - adds a SCSI target device component

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@starget: SCSI target for this SCSI device

 *

/**

 *	mptsas_del_device_component_by_os - Once a device has been removed, we mark the entry in the list as being cached

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@channel: os mapped id's

 *	@id: Logical Target ID

 *

	/*

	 * Set is_cached flag

/**

 *	mptsas_del_device_components - Cleaning the list

 *	@ioc: Pointer to MPT_ADAPTER structure

 *

/*

 * mptsas_setup_wide_ports

 *

 * Updates for new and existing narrow/wide port configuration

 * in the sas_topology

		/*

		 * Removing a phy from a port, letting the last

		 * phy be removed by firmware events.

	/*

	 * Populate and refresh the tree

		/*

		 * Forming a port

			/*

			 * Adding a phy to a port

/**

 * mptsas_find_vtarget - find a virtual target device (FC LUN device or

 *				SCSI target device)

 *

 * @ioc: Pointer to MPT_ADAPTER structure

 * @channel: channel number

 * @id: Logical Target ID

 *

/**

 * mptsas_target_reset - Issues TARGET_RESET to end device using

 *			 handshaking method

 *

 * @ioc: Pointer to MPT_ADAPTER structure

 * @channel: channel number

 * @id: Logical Target ID for reset

 *

 * Return: (1) success

 *         (0) failure

 *

	/* Format the Request

/**

 * mptsas_target_reset_queue - queue a target reset

 *

 * @ioc: Pointer to MPT_ADAPTER structure

 * @sas_event_data: SAS Device Status Change Event data

 *

 * Receive request for TARGET_RESET after receiving a firmware

 * event NOT_RESPONDING_EVENT, then put command in link list

 * and queue if task_queue already in use.

 *

 block IO */

/**

 * mptsas_schedule_target_reset- send pending target reset

 * @iocp: per adapter object

 *

 * This function will delete scheduled target reset from the list and

 * try to send next target reset. This will be called from completion

 * context of any Task management command.

	/*

	 * issue target reset to next device in the queue

/**

 *	mptsas_taskmgmt_complete - complete SAS task management function

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@mf: MPT message frame

 *	@mr: SCSI Task Management Reply structure ptr (may be %NULL)

 *

 *	Completion for TARGET_RESET after NOT_RESPONDING_EVENT, enable work

 *	queue to finish off removing device from upper layers, then send next

 *	TARGET_RESET in the queue.

	/*

	 * retry target reset

	/*

	 * enable work queue to remove device from upper layers

/**

 * mptsas_ioc_reset - issue an IOC reset for this reset phase

 *

 * @ioc: Pointer to MPT_ADAPTER structure

 * @reset_phase: id of phase of reset

 *

/**

 * enum device_state - TUR device state

 * @DEVICE_RETRY: need to retry the TUR

 * @DEVICE_ERROR: TUR return error, don't add device

 * @DEVICE_READY: device can be added

 *

 read */

 save config data */

/**

 *	mptsas_add_end_device - report a new end device to sas transport layer

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@phy_info: describes attached device

 *

 *	return (0) success (1) failure

 *

 non-fatal: an rphy can be added later */

/**

 *	mptsas_del_end_device - report a deleted end device to sas transport layer

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@phy_info: describes attached device

 *

/**

 * mptsas_firmware_event_work - work thread for processing fw events

 * @work: work queue payload containing info describing the event

 * Context: user

 *

 special rescan topology handling */

 events handling turned off during host reset */

	/*

	 * RAID volumes placed beyond the last expected port.

	 * Ignore sending sas mode pages in that case..

	/*

	 * RAID volumes placed beyond the last expected port.

			/*

			 * Exposing hidden raid components

			/*

			 * Exposing hidden raid components

/**

 *	mptsas_eh_timed_out - resets the scsi_cmnd timeout

 *		if the device under question is currently in the

 *		device removal delay.

 *	@sc: scsi command that the midlayer is about to time out

 *

	/* In case if IOC is in reset from internal context.

	*  Do not execute EEH for the same IOC. SML should to reset timer.

 FIXME: only have link errors on local phys */

 page number 1*/;

 read */

 FIXME: fusion doesn't allow non-local phy reset */

 not implemented for expanders */

 a reply frame is expected */

 process the completed Reply Message Frame */

 do we need to support multiple segments? */

 request */

 response */

 read */

 read */

 Get Phy Pg 0 for each Phy. */

 read */

 read */

 save config data */

 read */

 save config data */

 0x41 */

 0x01 */

/**

  * mptsas_exp_repmanufacture_info - sets expander manufacturer info

  * @ioc: per adapter object

  * @sas_address: expander sas address

  * @edev: the sas_expander_device object

  *

  * For an edge expander or a fanout expander:

  * fills in the sas_expander_device object when SMP port is created.

  *

  * Return: 0 for success, non-zero for failure.

	/*

	 * Fill in Phy Initiator Port Protocol.

	 * Bits 6:3, more than one bit can be set, fall through cases.

	/*

	 * Fill in Phy Target Port Protocol.

	 * Bits 10:7, more than one bit can be set, fall through cases.

	/*

	 * Fill in Attached device type.

	/*

	 * Set Negotiated link rate.

	/*

	 * Set Max hardware link rate.

	/*

	 * Set Max programmed link rate.

	/*

	 * Set Min hardware link rate.

	/*

	 * Set Min programmed link rate.

		/*

		 * Let the hotplug_work thread handle processing

		 * the adding/removing of devices that occur

		 * after start of day.

	/* If the device exists, verify it wasn't previously flagged

 expander sas address */

/**

 * mptsas_delete_expander_siblings - remove siblings attached to expander

 * @ioc: Pointer to MPT_ADAPTER structure

 * @parent: the parent port_info object

 * @expander: the expander port_info object

 backlink rphy */

			/*

			Delete this expander even if the expdevpage is exists

			because the parent expander is already deleted

/**

 *	mptsas_expander_delete - remove this expander

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@port_info: expander port_info struct

 *	@force: Flag to forcefully delete the expander

 *

 see if expander is still there before deleting */

	/*

	 * Obtain the port_info instance to the parent port

	/*

	 * Delete rphys in the parent that point

	 * to this expander.

	/*

	 * free link

/**

 * mptsas_send_expander_event - expanders events

 * @fw_event: event data

 *

 *

 * This function handles adding, removing, and refreshing

 * device handles within the expander objects.

/**

 * mptsas_expander_add - adds a newly discovered expander

 * @ioc: Pointer to MPT_ADAPTER structure

 * @handle: device handle

 *

 devices, logical volumes */

 delete device */

 expanders */

/**

 *	mptsas_probe_expanders - adding expanders

 *	@ioc: Pointer to MPT_ADAPTER structure

 *

 refreshing handles */

		/* If there is no FW B_T mapping for this device then continue

/**

 *	mptsas_scan_sas_topology - scans new SAS topology

 *	  (part of probe or rescan)

 *	@ioc: Pointer to MPT_ADAPTER structure

 *

	/*

	  Reporting RAID volumes.

 if hidden raid component, look for the volume id */

/**

 *	mptsas_find_phyinfo_by_phys_disk_num - find phyinfo for the

 *	  specified @phys_disk_num

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@phys_disk_num: (hot plug) physical disk number (for RAID support)

 *	@channel: channel number

 *	@id: Logical Target ID

 *

 dual port support */

 entry no longer valid */

	/*

	 * Extra code to handle RAID0 case, where the sas_address is not updated

	 * in phys_disk_page_1 when hotswapped

		/* If there is no FW B_T mapping for this device then continue

/*

 * Work queue thread to handle SAS hotplug events

		/* If there is no FW B_T mapping for this device then break

 Device hot plug */

		/* If there is no FW B_T mapping for this device then break

		/* If there is no FW B_T mapping for this device then break

 TODO */

 TODO */

 block IO */

 block IO */

 block IO */

/**

 *	mptsas_issue_tm - send mptsas internal tm request

 *	@ioc: Pointer to MPT_ADAPTER structure

 *	@type: Task Management type

 *	@channel: channel number for task management

 *	@id: Logical Target ID for reset (if appropriate)

 *	@lun: Logical unit for reset (if appropriate)

 *	@task_context: Context for the task to be aborted

 *	@timeout: timeout for task management control

 *	@issue_reset: set to 1 on return if reset is needed, else 0

 *

 *	Return: 0 on success or -1 on failure.

 *

 return failure */

 Now wait for the command to complete */

 return failure */

 return failure */

/**

 *	mptsas_broadcast_primitive_work - Handle broadcast primitives

 *	@fw_event: work queue payload containing info describing the event

 *

 *	This will be handled in workqueue context.

 skip hidden raid components */

 skip hidden raid components */

/*

 * mptsas_send_ir2_event - handle exposing hidden disk when

 * an inactive raid volume is added

 *

 * @ioc: Pointer to MPT_ADAPTER structure

 * @ir2_data

 *

 events turned off due to host reset or driver unloading */

/* Delete a volume when no longer listed in ioc pg2

	/*  Added sanity check on readiness of the MPT adapter.

	/*  Sanity check - ensure at least 1 port is INITIATOR capable

	/* Attach the SCSI Host to the IOC structure

 set 16 byte cdb's */

	/* Required entry.

	/* Verify that we won't exceed the maximum

	 * number of chain buffers

	 * We can optimize:  ZZ = req_sz/sizeof(SGE)

	 * For 32bit SGE's:

	 *  numSGE = 1 + (ZZ-1)*(maxChain -1) + ZZ

	 *               + (req_sz - 64)/sizeof(SGE)

	 * A slightly different algorithm is required for

	 * 64bit SGEs.

 Reset this value */

	/* SCSI needs scsi_cmnd lookup table!

	 * (with size equal to req_depth*PtrSz!)

 older firmware doesn't support expander events */

 Terminating entry */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018, Intel Corporation. */

/* This provides a net_failover interface for paravirtual drivers to

 * provide an alternate datapath by exporting APIs to create and

 * destroy a upper 'net_failover' netdev. The upper dev manages the

 * original paravirtual interface as a 'standby' netdev and uses the

 * generic failover infrastructure to register and manage a direct

 * attached VF as a 'primary' netdev. This enables live migration of

 * a VM with direct attached VF by failing over to the paravirtual

 * datapath when the VF is unplugged.

 *

 * Some of the netdev management routines are based on bond/team driver as

 * this driver provides active-backup functionality similar to those drivers.

 Try xmit via primary netdev followed by standby netdev */

 Save the original txq to restore before passing to the driver */

/* fold stats, assuming all rtnl_link_stats64 fields are u64, but

 * that some drivers can provide 32bit values only.

 detects if this particular field is 32bit only */

		/* filter anomalies, some drivers reset their stats

		 * at down/up events.

/* Called when slave dev is injecting data into network stack.

 * Change the associated network device from lower dev to failover dev.

 * note: already called with rcu_read_lock

	/* We want to allow only a direct attached VF device as a primary

	 * netdev. As there is no easy way to check for a VF device, restrict

	 * this to a pci device.

 Align MTU of slave with failover dev */

	/* We need to bring up the slave after the rename by udev in case

	 * open failed with EBUSY when it was registered.

/**

 * net_failover_create - Create and register a failover instance

 *

 * @standby_dev: standby netdev

 *

 * Creates a failover netdev and registers a failover instance for a standby

 * netdev. Used by paravirtual drivers that use 3-netdev model.

 * The failover netdev acts as a master device and controls 2 slave devices -

 * the original standby netdev and a VF netdev with the same MAC gets

 * registered as primary netdev.

 *

 * Return: pointer to failover instance

	/* Alloc at least 2 queues, for now we are going with 16 assuming

	 * that VF devices being enslaved won't have too many queues.

 Initialize the device options */

 don't acquire failover netdev's netif_tx_lock when transmitting */

 Don't allow failover devices to change network namespaces. */

/**

 * net_failover_destroy - Destroy a failover instance

 *

 * @failover: pointer to failover instance

 *

 * Unregisters any slave netdevs associated with the failover instance by

 * calling failover_slave_unregister().

 * unregisters the failover instance itself and finally frees the failover

 * netdev. Used by paravirtual drivers that use 3-netdev model.

 *

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2007 Patrick McHardy <kaber@trash.net>

 *

 * The code this is based on carried the following copyright notice:

 * ---

 * (C) Copyright 2001-2006

 * Alex Zeffertt, Cambridge Broadband Ltd, ajz@cambridgebroadband.com

 * Re-worked by Ben Greear <greearb@candelatech.com>

 * ---

 Hash Ethernet address */

 only want 6 bytes */

	/* Now that we are unhashed it is safe to change the device

	 * address without confusing packet delivery.

	/* Test to see if the specified address is

	 * currently in use by the underlying device or

	 * another macvlan.

 frame comes from an external address */

 flood to everyone except source */

			/*

			 * flood only to VEPA ports, bridge ports

			 * already saw the frame on the way out.

 called under rcu_read_lock() from netif_receive_skb */

 Packets from dev_loopback_xmit() do not have L2 header, bail out */

 forward to original port. */

 send to other bridge ports directly */

 send to lowerdev first for its network taps */

	/* Attempt to populate accel_priv which is used to offload the L2

	 * forwarding requests for unicast packets.

	/* If earlier attempt to offload failed, or accel_priv is not

	 * populated we must add the unicast address to the lower device.

 Just copy in the new address */

 Rehash and update the device filters */

		/* Since addr_change isn't set, we are here due to lower

		 * device change.  Save the lower-dev address so we can

		 * restore it later.

 If the addresses are the same, this is a no-op */

	/* This is slightly inaccurate as we're including the subscription

	 * list of vlan->lowerdev too.

	 *

	 * Bug alert: This only works if everyone has the same broadcast

	 * address as lowerdev.  As soon as someone changes theirs this

	 * will break.

	 *

	 * However, this is already broken as when you change your broadcast

	 * address we don't get called.

	 *

	 * The solution is to maintain a list of broadcast addresses like

	 * we do for uc/mc, if you care.

/*

 * macvlan network devices have devices nesting below it and are a special

 * "super class" of normal network devices; split their locks off into a

 * separate class since they always nest.

			/* rx_errors & tx_dropped are u32, updated

			 * without syncp protection.

	/* Support unicast filter only on passthru devices.

	 * Multicast filter should be allowed on all devices.

	/* Support unicast filter only on passthru devices.

	 * Multicast filter should be allowed on all devices.

 CONFIG_NET_POLL_CONTROLLER */

	/* After this point, no packet can schedule bc_work anymore,

	 * but we need to cancel it and purge left skbs if any.

	/* If the lower device address has been changed by passthru

	 * macvlan, put it back.

/*

 * reconfigure list of remote source mac address

 * (only for macvlan devices in source mode)

 * Note regarding alignment: all netlink data is aligned to 4 Byte, which

 * suffices for both ether_addr_copy and ether_addr_equal_64bits usage.

	/* When creating macvlans or macvtaps on top of other macvlans - use

	 * the real device as the lowerdev.

 MTU range: 68 - lowerdev->max_mtu */

 Only 1 macvlan device can be created in passthru mode */

		/* The macvlan port must be not created this time,

		 * still goto destroy_macvlan_port for readability.

 macvlan_uninit would free the macvlan port */

	/* the macvlan port may be freed by macvlan_uninit when fail to register.

	 * so we destroy the macvlan port only when it's valid.

 Validate mode, but don't set yet: setting flags may fail. */

 Passthrough mode can't be set or cleared dynamically */

 IFLA_MACVLAN_MACADDR_DATA */

 IFLA_MACVLAN_MODE */

 IFLA_MACVLAN_FLAGS */

 IFLA_MACVLAN_MACADDR_COUNT */

 IFLA_MACVLAN_MACADDR */

 IFLA_MACVLAN_BC_QUEUE_LEN */

 IFLA_MACVLAN_BC_QUEUE_LEN_USED */

 common fields */

 twiddle thumbs on netns device moves */

 Forbid underlying device to change its type. */

 Propagate to all vlans */

 SPDX-License-Identifier: GPL-2.0-only

	/* That's rather a softlimit here, which, of course,

	 * can be altered. Not a real MTU, but what is to be

	 * expected in most cases.

/*



	mii.c: MII interface library



	Maintained by Jeff Garzik <jgarzik@pobox.com>

	Copyright 2001,2002 Jeff Garzik



	Various code came from myson803.c and other files by

	Donald Becker.  Copyright:



		Written 1998-2002 by Donald Becker.



		This software may be used and distributed according

		to the terms of the GNU General Public License (GPL),

		incorporated herein by reference.  Drivers based on

		or derived from this code fall under the GPL and must

		retain the authorship, copyright and license notice.

		This file is not a complete program and may only be

		used when the entire operating system is licensed

		under the GPL.



		The author may be reached as becker@scyld.com, or C/O

		Scyld Computing Corporation

		410 Severn Ave., Suite 210

		Annapolis MD 21403





/**

 * mii_ethtool_gset - get settings that are specified in @ecmd

 * @mii: MII interface

 * @ecmd: requested ethtool_cmd

 *

 * The @ecmd parameter is expected to have been cleared before calling

 * mii_ethtool_gset().

 only supports twisted-pair */

 only supports internal transceiver */

 this isn't fully supported at higher layers */

 ignore maxtxpkt, maxrxpkt for now */

/**

 * mii_ethtool_get_link_ksettings - get settings that are specified in @cmd

 * @mii: MII interface

 * @cmd: requested ethtool_link_ksettings

 *

 * The @cmd parameter is expected to have been cleared before calling

 * mii_ethtool_get_link_ksettings().

 only supports twisted-pair */

 this isn't fully supported at higher layers */

 ignore maxtxpkt, maxrxpkt for now */

/**

 * mii_ethtool_sset - set settings that are specified in @ecmd

 * @mii: MII interface

 * @ecmd: requested ethtool_cmd

 *

 * Returns 0 for success, negative on error.

 ignore supported, maxtxpkt, maxrxpkt */

 advertise only what has been requested */

 turn on autonegotiation, and force a renegotiate */

 turn off auto negotiation, set speed and duplexity */

/**

 * mii_ethtool_set_link_ksettings - set settings that are specified in @cmd

 * @mii: MII interfaces

 * @cmd: requested ethtool_link_ksettings

 *

 * Returns 0 for success, negative on error.

 ignore supported, maxtxpkt, maxrxpkt */

 advertise only what has been requested */

 turn on autonegotiation, and force a renegotiate */

 turn off auto negotiation, set speed and duplexity */

/**

 * mii_check_gmii_support - check if the MII supports Gb interfaces

 * @mii: the MII interface

/**

 * mii_link_ok - is link status up/ok

 * @mii: the MII interface

 *

 * Returns 1 if the MII reports link status up/ok, 0 otherwise.

 first, a dummy read, needed to latch some MII phys */

/**

 * mii_nway_restart - restart NWay (autonegotiation) for this interface

 * @mii: the MII interface

 *

 * Returns 0 on success, negative on error.

 if autoneg is off, it's an error */

/**

 * mii_check_link - check MII link status

 * @mii: MII interface

 *

 * If the link status changed (previous != current), call

 * netif_carrier_on() if current link status is Up or call

 * netif_carrier_off() if current link status is Down.

/**

 * mii_check_media - check the MII interface for a carrier/speed/duplex change

 * @mii: the MII interface

 * @ok_to_print: OK to print link up/down messages

 * @init_media: OK to save duplex mode in @mii

 *

 * Returns 1 if the duplex mode changed, 0 if not.

 * If the media type is forced, always returns 0.

 check current and old link status */

	/* if carrier state did not change, this is a "bounce",

	 * just exit as everything is already set correctly

 duplex did not change */

 no carrier, nothing much to do */

 duplex did not change */

	/*

	 * we have carrier, see who's on the other end

 duplex did not change */

 get MII advertise and LPA values */

 figure out media and duplex from advertise and LPA values */

 duplex changed */

 duplex did not change */

/**

 * generic_mii_ioctl - main MII ioctl interface

 * @mii_if: the MII interface

 * @mii_data: MII ioctl data structure

 * @cmd: MII ioctl command

 * @duplex_chg_out: pointer to @duplex_changed status if there was no

 *	ioctl error

 *

 * Returns 0 on success, negative on error.

 do nothing */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * mdio.c: Generic support for MDIO-compatible transceivers

 * Copyright 2006-2009 Solarflare Communications Inc.

/**

 * mdio45_probe - probe for an MDIO (clause 45) device

 * @mdio: MDIO interface

 * @prtad: Expected PHY address

 *

 * This sets @prtad and @mmds in the MDIO interface if successful.

 * Returns 0 on success, negative on error.

	/* Assume PHY must have at least one of PMA/PMD, WIS, PCS, PHY

 Is this MMD present? */

 It should tell us about all the other MMDs */

/**

 * mdio_set_flag - set or clear flag in an MDIO register

 * @mdio: MDIO interface

 * @prtad: PHY address

 * @devad: MMD address

 * @addr: Register address

 * @mask: Mask for flag (single bit set)

 * @sense: New value of flag

 *

 * This debounces changes: it does not write the register if the flag

 * already has the proper value.  Returns 0 on success, negative on error.

/**

 * mdio45_links_ok - is link status up/OK

 * @mdio: MDIO interface

 * @mmd_mask: Mask for MMDs to check

 *

 * Returns 1 if the PHY reports link status up/OK, 0 otherwise.

 * @mmd_mask is normally @mdio->mmds, but if loopback is enabled

 * the MMDs being bypassed should be excluded from the mask.

 Use absence of XGMII faults in lieu of link state */

 Reset the latched status and fault flags */

 Check the current status and fault flags */

/**

 * mdio45_nway_restart - restart auto-negotiation for this interface

 * @mdio: MDIO interface

 *

 * Returns 0 on success, negative on error.

/**

 * mdio45_ethtool_gset_npage - get settings for ETHTOOL_GSET

 * @mdio: MDIO interface

 * @ecmd: Ethtool request structure

 * @npage_adv: Modes currently advertised on next pages

 * @npage_lpa: Modes advertised by link partner on next pages

 *

 * The @ecmd parameter is expected to have been cleared before calling

 * mdio45_ethtool_gset_npage().

 *

 * Since the CSRs for auto-negotiation using next pages are not fully

 * standardised, this function does not attempt to decode them.  The

 * caller must pass them in.

 All the other defined modes are flavours of optical */

		/* If AN is complete and successful, report best common

 Report forced settings */

 10GBASE-T MDI/MDI-X */

 It's complicated... */

/**

 * mdio45_ethtool_ksettings_get_npage - get settings for ETHTOOL_GLINKSETTINGS

 * @mdio: MDIO interface

 * @cmd: Ethtool request structure

 * @npage_adv: Modes currently advertised on next pages

 * @npage_lpa: Modes advertised by link partner on next pages

 *

 * The @cmd parameter is expected to have been cleared before calling

 * mdio45_ethtool_ksettings_get_npage().

 *

 * Since the CSRs for auto-negotiation using next pages are not fully

 * standardised, this function does not attempt to decode them.  The

 * caller must pass them in.

 All the other defined modes are flavours of optical */

		/* If AN is complete and successful, report best common

		 * mode, otherwise report best advertised mode.

 Report forced settings */

 10GBASE-T MDI/MDI-X */

 It's complicated... */

/**

 * mdio_mii_ioctl - MII ioctl interface for MDIO (clause 22 or 45) PHYs

 * @mdio: MDIO interface

 * @mii_data: MII ioctl data structure

 * @cmd: MII ioctl command

 *

 * Returns 0 on success, negative on error.

 Validate/convert cmd to one of SIOC{G,S}MIIREG */

 Validate/convert phy_id */

 Remap commonly-used MII registers. */

 SPDX-License-Identifier: GPL-2.0-or-later

/* MHI Network driver - Network over MHI bus

 *

 * Copyright (C) 2020 Linaro Ltd <loic.poulain@linaro.org>

 Feed the rx buffer pool */

 Carrier is established via out-of-band channel (e.g. qmi) */

 No header */

 This is non-paged skb chaining using frag_list */

			/* Packet can not fit in one MHI buffer and has been

			 * split over multiple MHI transfers, do re-aggregation.

			 * That usually means the device side MTU is larger than

			 * the host side MTU/MRU. Since this is not optimal,

			 * print a warning (once).

 MHI layer stopping/resetting the DL channel */

 Unknown error, simply drop */

 Aggregate the final fragment */

 Refill if RX buffers queue becomes low */

	/* Hardware has consumed the buffer, so free the skb (which is not

	 * freed by the MHI stack) and perform accounting.

 MHI layer stopping/resetting the UL channel */

		/* Do not hog the CPU if rx buffers are consumed faster than

		 * queued (unlikely).

 If we're still starved of rx buffers, reschedule later */

 Start MHI channels */

 Number of transfer descriptors determines size of the queue */

 Hardware accelerated data PATH (to modem IPA), protocol agnostic */

 Software data PATH (to modem CPU) */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * vrf.c: device driver to encapsulate a VRF space

 *

 * Copyright (c) 2015 Cumulus Networks. All rights reserved.

 * Copyright (c) 2015 Shrijeet Mukherjee <shm@cumulusnetworks.com>

 * Copyright (c) 2015 David Ahern <dsa@cumulusnetworks.com>

 *

 * Based on dummy, team and ipvlan drivers

 default preference for FIB rules */

	/* shared_tables:

	 * count how many distinct tables do not comply with the strict mode

	 * requirement.

	 * shared_tables value must be 0 in order to enable the strict mode.

	 *

	 * example of the evolution of shared_tables:

	 *                                                        | time

	 * add  vrf0 --> table 100        shared_tables = 0       | t0

	 * add  vrf1 --> table 101        shared_tables = 0       | t1

	 * add  vrf2 --> table 100        shared_tables = 1       | t2

	 * add  vrf3 --> table 100        shared_tables = 1       | t3

	 * add  vrf4 --> table 101        shared_tables = 2       v t4

	 *

	 * shared_tables is a "step function" (or "staircase function")

	 * and it is increased by one when the second vrf is associated to a

	 * table.

	 *

	 * at t2, vrf0 and vrf2 are bound to table 100: shared_tables = 1.

	 *

	 * at t3, another dev (vrf3) is bound to the same table 100 but the

	 * value of shared_tables is still 1.

	 * This means that no matter how many new vrfs will register on the

	 * table 100, the shared_tables will not increase (considering only

	 * table 100).

	 *

	 * at t4, vrf4 is bound to table 101, and shared_tables = 2.

	 *

	 * Looking at the value of shared_tables we can immediately know if

	 * the strict_mode can or cannot be enforced. Indeed, strict_mode

	 * can be enforced iff shared_tables = 0.

	 *

	 * Conversely, shared_tables is decreased when a vrf is de-associated

	 * from a table with exactly two associated vrfs.

 VRFs registered to this table */

 per netns vrf data */

 protected by rtnl lock */

 entry in vrf_map_elem */

 called with rtnl lock held */

	/* we pre-allocate elements used in the spin-locked section (so that we

	 * keep the spinlock as short as possible).

	/* we already have an entry in the vrf_map, so it means there is (at

	 * least) a vrf registered on the specific table.

 vrfs cannot share the same table */

 clean-up, if needed */

 called with rtnl lock held */

 no one will refer to this element anymore */

 return the vrf device index associated with the table_id */

/* by default VRF devices do not have a qdisc and are expected

 * to be created with only a single queue.

/* Local traffic destined to local address. Reinsert the packet to rx

 * path, similar to loopback handling.

	/* set pkt_type to avoid skb hitting packet taps twice -

	 * once on Tx and again in Rx processing

 needed to match OIF rule */

	/* if dst.dev is the VRF device again this is locally originated traffic

	 * destined to a local address. Short circuit to Rx path.

 strip the ethernet header added for pass through VRF device */

 based on ip_local_out; can't use it b/c the dst is switched pointing to us */

 needed to match OIF rule */

	/* if dst.dev is the VRF device again this is locally originated traffic

	 * destined to a local address. Short circuit to Rx path.

 strip the ethernet header added for pass through VRF device */

 modelled after ip6_finish_output2 */

 modelled after ip6_output */

/* set dst on skb to send packet to us via dev_xmit path. Allows

 * packet to go through device based features such as qdisc, netfilter

 * hooks and packet sockets with skb->dev set to vrf device.

 don't divert link scope packets */

 holding rtnl */

	/* move dev in dst's to loopback so this VRF device can be deleted

	 * - based on dst_ifdown

 IPv6 can be CONFIG enabled and then disabled runtime */

 create a dst for routing packets out a VRF device */

 modelled after ip_finish_output2 */

 Be paranoid, rather than too clever. */

 if crossing protocols, can not use the cached header */

/* set dst on skb to send packet to us via dev_xmit path. Allows

 * packet to go through device based features such as qdisc, netfilter

 * hooks and packet sockets with skb->dev set to vrf device.

 don't divert multicast or local broadcast */

 called with rcu lock held */

 holding rtnl */

	/* move dev in dst's to loopback so this VRF device can be deleted

	 * - based on dst_ifdown

 create a dst for routing packets out through a VRF device */

*************************** device handling ********************/

 cycle interface to flush neighbor cache and move routes across tables */

	/* do not allow loopback device to be enslaved to a VRF.

	 * The vrf device acts as the loopback for the vrf.

 inverse of do_vrf_add_slave */

 create the default dst which points back to us */

 similarly, oper state is irrelevant; set to up to avoid confusion */

 kfree_skb(skb) handled by nf code */

	/* in general, we do not know if there is enough space in the head of

	 * the packet for hosting the mac header.

 no space in the skb head */

	/* we set the ethernet destination and the source addresses to the

	 * address of the VRF device.

	/* the destination address of the Ethernet frame corresponds to the

	 * address set on the VRF interface; therefore, the packet is intended

	 * to be processed locally.

/* prepare and add the mac header to the packet if it was not set previously.

 * In this way, packet sniffers such as tcpdump can parse the packet correctly.

 * If the mac header was already set, the original mac header is left

 * untouched and the function returns immediately.

/* neighbor handling is done with actual device; do not want

 * to flip skb->dev for those ndisc packets. This really fails

 * for multiple next protocols (e.g., NEXTHDR_HOP). But it is

 * a start.

	/* loopback, multicast & non-ND link-local traffic; do not push through

	 * packet taps again. Reset pkt_type for upper layers to process skb.

	 * For strict packets with a source LLA, determine the dst using the

	 * original ifindex.

 if packet is NDISC then keep the ingress interface */

	/* loopback traffic; do not push through packet taps again.

	 * Reset pkt_type for upper layers to process skb

 called with rcu lock held */

/* send to link-local or multicast address via interface enslaved to

 * VRF device. Force lookup to VRF table without changing flow struct

 * Note: Caller to this function must hold rcu_read_lock() and no refcnt

 * is taken on the dst by this function.

	/* VRF device does not have a link-local address and

	 * sending packets to link-local or mcast addresses over

	 * a VRF device does not make sense

 FRA_L3MDEV */

 FRA_PRIORITY */

 FRA_PROTOCOL */

 rule only needs to appear once */

 fib_nl_{new,del}rule handling looks for net from skb->sk */

 Initialize the device structure. */

 Fill in device structure with ethernet-generic values. */

 don't acquire vrf device's netif_tx_lock when transmitting */

 don't allow vrf devices to change network namespaces. */

 does not make sense for a VLAN to be added to a vrf device */

 enable offload features */

 default to no qdisc; user can add if desired */

	/* VRF devices do not care about MTU, but if the MTU is set

	 * too low then the ipv4 and ipv6 protocols are disabled

	 * which breaks networking.

	/* mapping between table_id and vrf;

	 * note: such binding could not be done in the dev init function

	 * because dev->ifindex id is not available yet.

 IFLA_VRF_TABLE */

 IFLA_VRF_PORT_TABLE */

 only care about unregister events to drop slave references */

 disable strict mode */

			/* we cannot allow strict_mode because there are some

			 * vrfs that share one or more tables.

		/* no tables are shared among vrfs, so we can go back

		 * to 1:1 association between a vrf with its table.

 set by the vrf_netns_init */

 init the extra1 parameter with the reference to current netns */

 Initialize per network namespace state */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/net/macsec.c - MACsec device

 *

 * Copyright (c) 2015 Sabrina Dubroca <sd@queasysnail.net>

 SecTAG length = macsec_eth_header without the optional SCI */

 SecTAG */

 optional */

 end station */

 SCI present */

 epon */

 encryption */

 changed text */

 association number */

 minimum secure data length deemed "not short", see IEEE 802.1AE-2006 9.7 */

/**

 * struct macsec_dev - private data

 * @secy: SecY config

 * @real_dev: pointer to underlying netdevice

 * @stats: MACsec device stats

 * @secys: linked list of SecY's on the underlying device

 * @gro_cells: pointer to the Generic Receive Offload cell

 * @offload: status of offloading on the MACsec device

/**

 * struct macsec_rxh_data - rx_handler private argument

 * @secys: linked list of SecY's on this underlying device

 Fill SecTAG according to IEEE 802.1AE-2006 10.5.3 */

 with GCM, C/E clear for !encrypt, both set for encrypt */

 Checks if a MACsec interface is being offloaded to an hardware engine */

 Checks if underlying layers implement MACsec offloading functions. */

/* Returns a pointer to the MACsec ops struct if any and updates the MACsec

 * context device reference if provided.

 validate MACsec packet according to IEEE 802.1AE-2018 9.12 */

 a) It comprises at least 17 octets */

 b) MACsec EtherType: already checked */

 c) V bit is clear */

 d) ES or SCB => !SC */

 e) Bits 7 and 8 of octet 4 of the SecTAG are clear */

 rx.pn != 0 if not XPN (figure 10-5 with 802.11AEbw-2013 amendment) */

 length check, f) g) h) i) */

 10.5.1 TX SA assignment */

	/* Now perform replay protection check again

	 * (see IEEE 802.1AE-2006 figure 10-5)

 10.6.5 */

 Instead of "pn >=" - to support pn overflow in xpn

		/* confidentiality: ethernet + macsec header

		 * authenticated, encrypted payload

 integrity only: all headers + data authenticated */

		/* decryption/authentication failed

		 * 10.6 if validateFrames is disabled, deliver anyway

 Deliver to the uncontrolled port by default */

		/* If h/w offloading is enabled, HW decodes frames and strips

		 * the SecTAG, so we have to deduce which port to deliver to.

 exact match, divert skb to this port */

 multicast frame, deliver on this port too */

		/* 10.6 If the management control validateFrames is not

		 * Strict, frames without a SecTAG are received, counted, and

		 * delivered to the Controlled Port

 deliver on this port */

	/* Frames with a SecTAG that has the TCI E bit set but the C

	 * bit clear are discarded, as this reserved encoding is used

	 * to identify frames with a SecTAG that are not to be

	 * delivered to the Controlled Port.

 now, pull the extra length */

 ethernet header is part of crypto processing */

 10.6.1 if the SA is not in use */

		/* If validateFrames is Strict or the C bit in the

		 * SecTAG is set, discard

		/* not Strict, the frame (with the SecTAG and ICV

		 * removed) is delivered to the Controlled Port.

 First, PN check to avoid decrypting obviously wrong packets */

 Disabled && !changed text => skip validation */

 the decrypt callback needs the reference */

 10.6.1 if the SC is not found */

		/* If validateFrames is Strict or the C bit in the

		 * SecTAG is set, discard

		/* not strict, the frame (with the SecTAG and ICV

		 * removed) is delivered to the Controlled Port.

 Pick a sync gcm(aes) cipher to ensure order is preserved. */

 Offloads an operation to a device driver */

	/* Phase I: prepare. The drive should fail here if there are going to be

	 * issues in the commit phase.

 Phase II: commit. This step cannot fail. */

 This should never happen: commit is not allowed to fail */

 If h/w offloading is available, propagate to the device */

 If h/w offloading is available, propagate to the device */

 If h/w offloading is available, propagate to the device */

 If h/w offloading is available, propagate to the device */

 If h/w offloading is available, propagate to the device */

 If h/w offloading is available, propagate to the device */

 If h/w offloading is available, propagate to the device */

 If h/w offloading is available, propagate to the device */

 Check if the offloading mode is supported by the underlying layers */

 Check if the net device is busy. */

	/* Check if the device already has rules configured: we do not support

	 * rules migration.

	/* Force features update, since they are different for SW MACSec and

	 * HW offloading cases.

 If h/w offloading is available, propagate to the device */

 If h/w offloading is available, propagate to the device */

 If h/w offloading is available, propagate to the device */

 If h/w offloading is available, propagate to the device */

 If h/w offloading is available, propagate to the device */

 protected by RTNL */

 10.5 */

/* If h/w offloading is enabled, use real device features save for

 *   VLAN_FEATURES - they require additional ops

 *   HW_MACSEC - no reason to report it

 If h/w offloading is available, propagate to the device */

 If h/w offloading is available, propagate to the device */

 If h/w offloading is available, propagate to the device */

	/* Keep a copy of unmodified secy and tx_sc, in case the offload

	 * propagation fails, to revert macsec_changelink_common.

 If h/w offloading is available, propagate to the device */

 If h/w offloading is available, propagate to the device */

 MACsec offloading is off by default */

 Check if the offloading mode is supported by the underlying layers */

	/* need to be already registered so that ->init has run and

	 * the MAC addr is set

 If h/w offloading is available, propagate to the device */

 IFLA_MACSEC_SCI */

 IFLA_MACSEC_ICV_LEN */

 IFLA_MACSEC_CIPHER_SUITE */

 IFLA_MACSEC_WINDOW */

 IFLA_MACSEC_ENCODING_SA */

 IFLA_MACSEC_ENCRYPT */

 IFLA_MACSEC_PROTECT */

 IFLA_MACSEC_INC_SCI */

 IFLA_MACSEC_ES */

 IFLA_MACSEC_SCB */

 IFLA_MACSEC_REPLAY_PROTECT */

 IFLA_MACSEC_VALIDATION */

 SPDX-License-Identifier: GPL-2.0-or-later

 sb1000.c: A General Instruments SB1000 driver for linux. */

/*

	Written 1998 by Franco Venturi.



	Copyright 1998 by Franco Venturi.

	Copyright 1994,1995 by Donald Becker.

	Copyright 1993 United States Government as represented by the

	Director, National Security Agency.



	This driver is for the General Instruments SB1000 (internal SURFboard)



	The author may be reached as fventuri@mediaone.net





	Changes:



	981115 Steven Hirsch <shirsch@adelphia.net>



	Linus changed the timer interface.  Should work on all recent

	development kernels.



	980608 Steven Hirsch <shirsch@adelphia.net>



	Small changes to make it work with 2.1.x kernels. Hopefully,

	nothing major will change before official release of Linux 2.2.



	Merged with 2.2 - Alan Cox

 for SIOGCM/SIOSCM stuff */

 for udelay() */

 SB1000 Maximum Receive Unit */

 octects */

 prototypes for Linux interface */

 SB1000 hardware routines to be used during open/configuration phases */

 SB1000 hardware routines to be used during frame rx interrupt */

 SB1000 commands for open/configuration */

 SB1000 commands for frame rx interrupt */

 mem_start holds the second I/O address */

	/*

	 * The SB1000 is an rx-only cable modem device.  The uplink is a modem

	 * and we do not want to arp on it.

 hardware address is 0:0:serial_number */

/*

 * SB1000 hardware routines to be used during open/configuration phases

 Card Wait For Busy Clear (cannot be used during an interrupt) */

 a little sleep */

 Card Wait For Ready (cannot be used during an interrupt) */

 a little sleep */

 Card Send Command (cannot be used during an interrupt) */

/*

 * SB1000 hardware routines to be used during frame rx interrupt

 Card Wait For Ready (to be used during frame rx) */

 Card Wait For Ready Clear (to be used during frame rx) */

 Card Send Command (to be used during frame rx) */

 Card Read Status (to be used during frame rx) */

 Issue Read Command (to be used during frame rx) */

/*

 * SB1000 commands for open/configuration

 reset SB1000 card */

 check SB1000 firmware CRC */

 check CRC */

 get SB1000 firmware version */

 get SB1000 frequency */

 set SB1000 frequency */

 get SB1000 PIDs */

 set SB1000 PIDs */

/*

 * SB1000 commands for frame rx interrupt

/* receive a single frame and assemble datagram

 * (this is the heart of the interrupt routine)

 SB1000 frame constants */

 XXXDEBUG */

 decide if it is a good or bad frame */

 new datagram */

 get data length */

 XXXDEBUG */

 compute size to allocate for datagram */

 continuation of previous datagram */

 datagram completed: send to upper level */

 mem_start holds the second I/O address */

/*

 * Linux interface functions

 mem_start holds the second I/O address */

 initialize sb1000 */

 initialize private data before board can catch interrupts */

 Activate board and check firmware version */

 Always succeed */

 mem_start holds the second I/O address */

 get statistics */

 get firmware version */

 get frequency */

 set frequency */

 get PIDs */

 set PIDs */

 set session_id, frame_id and pkt_type too */

 transmit function: do nothing since SB1000 can't send anything out */

 sb1000 can't xmit datagrams */

 SB1000 interrupt handler. */

 mem_start holds the second I/O address */

 is it a good interrupt? */

 SB1000_DELAY */

 mem_start holds the second I/O address */

 If we don't do this, we can't re-insmod it later. */

 free rx_skb's if needed */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  TUN - Universal TUN/TAP device driver.

 *  Copyright (C) 1999-2002 Maxim Krasnyansky <maxk@qualcomm.com>

 *

 *  $Id: tun.c,v 1.15 2002/03/01 02:44:24 maxk Exp $

/*

 *  Changes:

 *

 *  Mike Kershaw <dragorn@kismetwireless.net> 2005/08/14

 *    Add TUNSETLINK ioctl to set the link encapsulation

 *

 *  Mark Smith <markzzzsmith@yahoo.com.au>

 *    Use eth_random_addr() for tap MAC address.

 *

 *  Harald Roelle <harald.roelle@ifi.lmu.de>  2004/04/20

 *    Fixes in packet dropping, queue length setting and queue wakeup.

 *    Increased default tx queue length.

 *    Added ethtool API.

 *    Minor cleanups

 *

 *  Daniel Podlejski <underley@underley.eu.org>

 *    Modifications for 2.3.99-pre5 kernel.

 TUN device flags */

/* IFF_ATTACH_QUEUE is never stored in device flags,

 * overload it to mean fasync when stored there.

 High bits in flags field are unused. */

 Number of addrs. Zero means disabled */

 Mask of the hashed addrs */

/* MAX_TAP_QUEUES 256 is chosen to allow rx/tx queues to be equal

/* A tun_file connects an open character device to a tuntap netdevice. It

 * also contains all socket related structures (except sock_fprog and tap_filter)

 * to serve as one transmit queue for tuntap device. The sock_fprog and

 * tap_filter were kept in tun_struct since they were used for filtering for the

 * netdevice not for a specific queue (at least I didn't see the requirement for

 * this).

 *

 * RCU usage:

 * The tun_file and tun_struct are loosely coupled, the pointer from one to the

 * other can only be read while rcu_read_lock or rtnl_lock is held.

 only used for fasnyc */

 Protects access to the above napi */

/* Since the socket were moved to tun_file, to preserve the behavior of persist

 * device, socket filter, sndbuf and vnet header size were restore when the

 * file were attached to a persist device.

 protected by rtnl lock */

 CONFIG_TUN_VNET_CROSS_LE */

 TODO: keep queueing to old queue until it's empty? */

/* Save the hash received in the stack receive path and update the

 * flow_hash table accordingly.

/* We try to identify a flow through its rxhash. The reason that

 * we do not check rxq no. is because some cards(e.g 82599), chooses

 * the rxq based on the txq where the last packet of the flow comes. As

 * the userspace application move between processors, we may get a

 * different rxq no. here.

 use multiply and shift instead of expensive divide */

 Drop read queue */

 Drop read queue */

 Re-attach the filter to persist device */

 Re-attach detached tfile, updating XDP queue_index */

 Setup XDP RX-queue info, for new tfile getting attached */

	/* device is allowed to go away first, so no need to hold extra

	 * refcnt.

	/* Publish tfile->tun and tun->tfiles only after we've fully

	 * initialized tfile; otherwise we risk using half-initialized

	 * object.

 TAP filtering */

 Disabled */

	/* The filter is updated without holding any locks. Which is

	 * perfectly safe. We disable it first and in the worst

 Use first set of addresses as an exact filter */

	/* Remaining multicast addresses are hashed,

 no filter */

	/* For ALLMULTI just set the mask to all ones.

 Now enable the filter */

 Return the number of exact filters */

 Returns: 0 - drop, !=0 - accept */

	/* Cannot use eth_hdr(skb) here because skb_mac_hdr() is incorrect

 Exact match */

 Inexact match (multicast only) */

/*

 * Checks whether the packet is accepted or not.

 * Returns: 0 - drop, !=0 - accept

 Network device part of the driver */

 Net device detach from fd. */

 Net device open. */

 Net device close. */

 Net device start xmit */

		/* Select queue was not called for the skbuff, so we extract the

		 * RPS hash and save it into the flow_table here.

 Net device start xmit */

 Drop packet if interface is not attached */

	/* Drop if the filter does not like it.

	 * This is a noop if the filter is disabled.

	/* Orphan the skb - required as we might hang on to it

	 * for indefinite time.

 NETIF_F_LLTX requires to do our own update of trans_start */

 Notify and wake up reader process */

	/*

	 * This callback is supposed to deal with mc filter in

	 * _rx_ path and has nothing to do with the _tx_ path.

	 * In rx path we always accept everything userspace gives us.

 Notify and wake up reader process */

 Caller will free/return all frames */

		/* Encode the XDP flag into lowest bit for consumer to differ

		 * XDP buffer from sk_buff.

 Initialize net device. */

 Point-to-Point TUN Device */

 Zero header length */

 Ethernet TAP Device */

 Character device part */

 Poll */

	/* Make sure SOCKWQ_ASYNC_NOSPACE is set if not writable to

	 * guarantee EPOLLOUT to be raised by either here or

	 * tun_sock_write_space(). Then process could get notification

	 * after it writes to a down device and meets -EIO.

 frees skb and all frags allocated with napi_alloc_frag() */

/* prepad is the amount to reserve at front.  len is length after that.

 Under a page?  Don't bother with paged skb. */

	/* There's a small window that XDP may be set after the check

	 * of xdp_prog above, this should be rare and for simplicity

	 * we do XDP on skb in case the headroom is not enough.

 Get packet from user space buffer */

		/* There are 256 bytes to be copied in skb, so there is

		 * enough room for skb expand head in case it is used.

		 * The rest of the buffer is mapped from userspace.

		/* For the packet that is not easy to be processed

		 * (e.g gso or jumbo packet), we will do it at after

		 * skb was created with generic XDP routine.

			/* tun_napi_alloc_frags() enforces a layout for the skb.

			 * If zerocopy is enabled, then this layout will be

			 * overwritten by zerocopy_sg_from_iter().

 copy skb_ubuf_info for callback when skb has no error */

	/* Compute the costly rx hash only if needed for flow updates.

	 * We may get a very small possibility of OOO during switching, not

	 * worth to optimize.

 Exercise flow dissector code path. */

 Put packet to the user space buffer */

 Packet will be striped */

 caller is in process context, */

 Read frames from ring */

	/* We clear tstats so that tun_set_iff() can tell if

	 * tun_free_netdev() has been called from register_netdevice().

 We prefer our own queue length */

/* Trivial set of netlink ops to allow deleting tun or tap

 * device with netlink.

 OWNER */

 GROUP */

 TYPE */

 PI */

 VNET_HDR */

 PERSIST */

 MULTI_QUEUE */

 NUM_QUEUES */

 NUM_DISABLED_QUEUES */

	/* No need to disable preemption here since this function is

	 * always called with bh disabled

 Ops structure to mimic raw sockets with tun */

			/* One or more queue has already been attached, no need

			 * to initialize the device again.

 Set dev type */

 TUN device */

 TAP device */

		/* free_netdev() won't check refcnt, to avoid race

		 * with dev_put() we need publish tun after registration.

	/* Make sure persistent devices do not get stuck in

	 * xoff state.

	/* We are here because register_netdevice() has failed.

	 * If register_netdevice() already called tun_free_netdev()

	 * while dealing with the error, dev->stats has been cleared.

/* This is like a cut-down ethtool ops, except done via tun fd so no

	/* This gives the user a way to test for new features in future by

 Return correct value for tun->dev->addr_len based on tun->dev->type. */

		/* Currently this just means: "what IFF flags are valid?".

		 * This is needed because we never checked for invalid flags on

		 * TUNSETIFF.

 Disable/Enable checksum */

 [unimplemented] */

		/* Disable/Enable persist mode. Keep an extra reference to the

		 * module to prevent the module being unprobed.

 Set owner of the device */

 Set group of the device */

 Only allow setting the type when the interface is down */

 Can be set only for TAPs */

 Get hw address */

 Set hw address */

 Can be set only for TAPs */

 Can be set only for TAPs */

	/*

	 * compat_ifreq is shorter than ifreq, so we must not access beyond

	 * the end of that structure. All fields that are used in this

	 * driver are compatible though, we don't need to convert the

	 * contents.

 CONFIG_COMPAT */

 ethtool interface */

/* Get an underlying socket object from tun file.  Returns error unless file is

 * attached to a device.  The returned object works like a packet socket, it

 * can be used for sock_sendmsg/sock_recvmsg.  The caller is responsible for

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Variables for dealing with macvtaps device numbers.

	/* Since macvlan supports all offloads by default, make

	 * tap support all offloads also.

	/* Register callbacks for rx/tx drops accounting and updating

	 * net_device features

	/* Don't put anything that may fail after macvlan_common_newlink

	 * because we can't undo what it does.

		/* Create the device node here after the network device has

		 * been registered but before register_netdevice has

		 * finished running.

 vlan->minor == 0 if NETDEV_REGISTER above failed */

 SPDX-License-Identifier: GPL-2.0-or-later

 Copyright (c) 2021 Taehee Yoo <ap420073@gmail.com> */

 Lock for source_gc_list */

	/* tunnel->lock was acquired outside of amt_del_group()

	 * But rcu_read_lock() was acquired too so It's safe.

/* If a source timer expires with a router filter-mode for the group of

 * INCLUDE, the router concludes that traffic from this particular

 * source is no longer desired on the attached network, and deletes the

 * associated source record.

		/* When a router filter-mode for a group is EXCLUDE,

		 * source records are only deleted when the group timer expires

/* RFC 3810 - 7.2.2.  Definition of Filter Timers

 *

 *  Router Mode          Filter Timer         Actions/Comments

 *  -----------       -----------------       ----------------

 *

 *    INCLUDE             Not Used            All listeners in

 *                                            INCLUDE mode.

 *

 *    EXCLUDE             Timer > 0           At least one listener

 *                                            in EXCLUDE mode.

 *

 *    EXCLUDE             Timer == 0          No more listeners in

 *                                            EXCLUDE mode for the

 *                                            multicast address.

 *                                            If the Requested List

 *                                            is empty, delete

 *                                            Multicast Address

 *                                            Record.  If not, switch

 *                                            to INCLUDE filter mode;

 *                                            the sources in the

 *                                            Requested List are

 *                                            moved to the Include

 *                                            List, and the Exclude

 *                                            List is deleted.

 Not Used */

/* Non-existant group is created as INCLUDE {empty}:

 *

 * RFC 3376 - 5.1. Action on Change of Interface State

 *

 * If no interface state existed for that multicast address before

 * the change (i.e., the change consisted of creating a new

 * per-interface record), or if no state exists after the change

 * (i.e., the change consisted of deleting a per-interface record),

 * then the "non-existent" state is considered to have a filter mode

 * of INCLUDE and an empty source list.

 Gateway only passes IGMP/MLD packets */

 Do not forward unexpected query */

 Delete old sources */

 switch from new to old */

/* Router State   Report Rec'd New Router State

 * ------------   ------------ ----------------

 * EXCLUDE (X,Y)  IS_IN (A)    EXCLUDE (X+A,Y-A)

 *

 * -----------+-----------+-----------+

 *            |    OLD    |    NEW    |

 * -----------+-----------+-----------+

 *    FWD     |     X     |    X+A    |

 * -----------+-----------+-----------+

 *    D_FWD   |     Y     |    Y-A    |

 * -----------+-----------+-----------+

 *    NONE    |           |     A     |

 * -----------+-----------+-----------+

 *

 * a) Received sources are NONE/NEW

 * b) All NONE will be deleted by amt_cleanup_srcs().

 * c) All OLD will be deleted by amt_cleanup_srcs().

 * d) After delete, NEW source will be switched to OLD.

 A*B */

 A+B */

 A-B */

 B-A */

/* Router State   Report Rec'd New Router State        Actions

 * ------------   ------------ ----------------        -------

 * INCLUDE (A)    IS_IN (B)    INCLUDE (A+B)           (B)=GMI

 Update IS_IN (B) as FWD/NEW */

 Update INCLUDE (A) as NEW */

 (B)=GMI */

/* State        Actions

 * ------------   ------------ ----------------        -------

 * EXCLUDE (X,Y)  IS_IN (A)    EXCLUDE (X+A,Y-A)       (A)=GMI

 Update (A) in (X, Y) as NONE/NEW */

 Update FWD/OLD as FWD/NEW */

 Update IS_IN (A) as FWD/NEW */

 Update EXCLUDE (, Y-A) as D_FWD_NEW */

/* Router State   Report Rec'd  New Router State         Actions

 * ------------   ------------  ----------------         -------

 * INCLUDE (A)    IS_EX (B)     EXCLUDE (A*B,B-A)        (B-A)=0

 *                                                       Delete (A-B)

 *                                                       Group Timer=GMI

 EXCLUDE(A*B, ) */

 EXCLUDE(, B-A) */

 (B-A)=0 */

 Group Timer=GMI */

 Delete (A-B) will be worked by amt_cleanup_srcs(). */

/* Router State   Report Rec'd  New Router State	Actions

 * ------------   ------------  ----------------	-------

 * EXCLUDE (X,Y)  IS_EX (A)     EXCLUDE (A-Y,Y*A)	(A-X-Y)=GMI

 *							Delete (X-A)

 *							Delete (Y-A)

 *							Group Timer=GMI

 EXCLUDE (A-Y, ) */

 EXCLUDE (, Y*A ) */

 (A-X-Y)=GMI */

 Group Timer=GMI */

 Delete (X-A), (Y-A) will be worked by amt_cleanup_srcs(). */

/* Router State   Report Rec'd New Router State        Actions

 * ------------   ------------ ----------------        -------

 * INCLUDE (A)    TO_IN (B)    INCLUDE (A+B)           (B)=GMI

 *						       Send Q(G,A-B)

 Update TO_IN (B) sources as FWD/NEW */

 Update INCLUDE (A) sources as NEW */

 (B)=GMI */

/* Router State   Report Rec'd New Router State        Actions

 * ------------   ------------ ----------------        -------

 * EXCLUDE (X,Y)  TO_IN (A)    EXCLUDE (X+A,Y-A)       (A)=GMI

 *						       Send Q(G,X-A)

 *						       Send Q(G)

 Update TO_IN (A) sources as FWD/NEW */

 Update EXCLUDE(X,) sources as FWD/NEW */

		/* EXCLUDE (, Y-A)

		 * (A) are already switched to FWD_NEW.

		 * So, D_FWD/OLD -> D_FWD/NEW is okay.

		/* (A)=GMI

		 * Only FWD_NEW will have (A) sources.

/* Router State   Report Rec'd New Router State        Actions

 * ------------   ------------ ----------------        -------

 * INCLUDE (A)    TO_EX (B)    EXCLUDE (A*B,B-A)       (B-A)=0

 *						       Delete (A-B)

 *						       Send Q(G,A*B)

 *						       Group Timer=GMI

 EXCLUDE (A*B, ) */

 EXCLUDE (, B-A) */

 (B-A)=0 */

 Group Timer=GMI */

 Delete (A-B) will be worked by amt_cleanup_srcs(). */

/* Router State   Report Rec'd New Router State        Actions

 * ------------   ------------ ----------------        -------

 * EXCLUDE (X,Y)  TO_EX (A)    EXCLUDE (A-Y,Y*A)       (A-X-Y)=Group Timer

 *						       Delete (X-A)

 *						       Delete (Y-A)

 *						       Send Q(G,A-Y)

 *						       Group Timer=GMI

 Update (A-X-Y) as NONE/OLD */

 EXCLUDE (A-Y, ) */

 EXCLUDE (, Y*A) */

 Group Timer=GMI */

 Delete (X-A), (Y-A) will be worked by amt_cleanup_srcs(). */

/* Router State   Report Rec'd New Router State        Actions

 * ------------   ------------ ----------------        -------

 * INCLUDE (A)    ALLOW (B)    INCLUDE (A+B)	       (B)=GMI

 INCLUDE (A+B) */

 (B)=GMI */

/* Router State   Report Rec'd New Router State        Actions

 * ------------   ------------ ----------------        -------

 * EXCLUDE (X,Y)  ALLOW (A)    EXCLUDE (X+A,Y-A)       (A)=GMI

 EXCLUDE (X+A, ) */

 EXCLUDE (, Y-A) */

		/* (A)=GMI

		 * All (A) source are now FWD/NEW status.

/* Router State   Report Rec'd New Router State        Actions

 * ------------   ------------ ----------------        -------

 * INCLUDE (A)    BLOCK (B)    INCLUDE (A)             Send Q(G,A*B)

 INCLUDE (A) */

/* Router State   Report Rec'd New Router State        Actions

 * ------------   ------------ ----------------        -------

 * EXCLUDE (X,Y)  BLOCK (A)    EXCLUDE (X+(A-Y),Y)     (A-X-Y)=Group Timer

 *						       Send Q(G,A-Y)

 (A-X-Y)=Group Timer */

 EXCLUDE (X, ) */

 EXCLUDE (X+(A-Y) */

 EXCLUDE (, Y) */

/* RFC 3376

 * 7.3.2. In the Presence of Older Version Group Members

 *

 * When Group Compatibility Mode is IGMPv2, a router internally

 * translates the following IGMPv2 messages for that group to their

 * IGMPv3 equivalents:

 *

 * IGMPv2 Message                IGMPv3 Equivalent

 * --------------                -----------------

 * Report                        IS_EX( {} )

 * Leave                         TO_IN( {} )

/* RFC 3376

 * 7.3.2. In the Presence of Older Version Group Members

 *

 * When Group Compatibility Mode is IGMPv2, a router internally

 * translates the following IGMPv2 messages for that group to their

 * IGMPv3 equivalents:

 *

 * IGMPv2 Message                IGMPv3 Equivalent

 * --------------                -----------------

 * Report                        IS_EX( {} )

 * Leave                         TO_IN( {} )

 caller held tunnel->lock */

/* RFC 3810

 * 8.3.2. In the Presence of MLDv1 Multicast Address Listeners

 *

 * When Multicast Address Compatibility Mode is MLDv2, a router acts

 * using the MLDv2 protocol for that multicast address.  When Multicast

 * Address Compatibility Mode is MLDv1, a router internally translates

 * the following MLDv1 messages for that multicast address to their

 * MLDv2 equivalents:

 *

 * MLDv1 Message                 MLDv2 Equivalent

 * --------------                -----------------

 * Report                        IS_EX( {} )

 * Done                          TO_IN( {} )

/* RFC 3810

 * 8.3.2. In the Presence of MLDv1 Multicast Address Listeners

 *

 * When Multicast Address Compatibility Mode is MLDv2, a router acts

 * using the MLDv2 protocol for that multicast address.  When Multicast

 * Address Compatibility Mode is MLDv1, a router internally translates

 * the following MLDv1 messages for that multicast address to their

 * MLDv2 equivalents:

 *

 * MLDv1 Message                 MLDv2 Equivalent

 * --------------                -----------------

 * Report                        IS_EX( {} )

 * Done                          TO_IN( {} )

 caller held tunnel->lock */

 Mark socket as an encapsulation socket */

 shutdown */

 IFLA_AMT_MODE */

 IFLA_AMT_RELAY_PORT */

 IFLA_AMT_GATEWAY_PORT */

 IFLA_AMT_LINK */

 IFLA_MAX_TUNNELS */

 IFLA_AMT_DISCOVERY_IP */

 IFLA_AMT_REMOTE_IP */

 IFLA_AMT_LOCAL_IP */

/*

 * Equalizer Load-balancer for serial network interfaces.

 *

 * (c) Copyright 1995 Simon "Guru Aleph-Null" Janes

 * NCM: Network and Communications Management, Inc.

 *

 * (c) Copyright 2002 David S. Miller (davem@redhat.com)

 *

 *	This software may be used and distributed according to the terms

 *	of the GNU General Public License, incorporated herein by reference.

 *

 * The author may be reached as simon@ncm.com, or C/O

 *    NCM

 *    Attn: Simon Janes

 *    6803 Whittier Ave

 *    McLean VA 22101

 *    Phone: 1-703-847-0040 ext 103

/*

 * Sources:

 *   skeleton.c by Donald Becker.

 * Inspirations:

 *   The Harried and Overworked Alan Cox

 * Conspiracies:

 *   The Alan Cox and Mike McLagan plot to get someone else to do the code,

 *   which turned out to be me.

/*

 * $Log: eql.c,v $

 * Revision 1.2  1996/04/11 17:51:52  guru

 * Added one-line eql_remove_slave patch.

 *

 * Revision 1.1  1996/04/11 17:44:17  guru

 * Initial revision

 *

 * Revision 3.13  1996/01/21  15:17:18  alan

 * tx_queue_len changes.

 * reformatted.

 *

 * Revision 3.12  1995/03/22  21:07:51  anarchy

 * Added capable() checks on configuration.

 * Moved header file.

 *

 * Revision 3.11  1995/01/19  23:14:31  guru

 * 		      slave_load = (ULONG_MAX - (ULONG_MAX / 2)) -

 * 			(priority_Bps) + bytes_queued * 8;

 *

 * Revision 3.10  1995/01/19  23:07:53  guru

 * back to

 * 		      slave_load = (ULONG_MAX - (ULONG_MAX / 2)) -

 * 			(priority_Bps) + bytes_queued;

 *

 * Revision 3.9  1995/01/19  22:38:20  guru

 * 		      slave_load = (ULONG_MAX - (ULONG_MAX / 2)) -

 * 			(priority_Bps) + bytes_queued * 4;

 *

 * Revision 3.8  1995/01/19  22:30:55  guru

 *       slave_load = (ULONG_MAX - (ULONG_MAX / 2)) -

 * 			(priority_Bps) + bytes_queued * 2;

 *

 * Revision 3.7  1995/01/19  21:52:35  guru

 * printk's trimmed out.

 *

 * Revision 3.6  1995/01/19  21:49:56  guru

 * This is working pretty well. I gained 1 K/s in speed.. now it's just

 * robustness and printk's to be diked out.

 *

 * Revision 3.5  1995/01/18  22:29:59  guru

 * still crashes the kernel when the lock_wait thing is woken up.

 *

 * Revision 3.4  1995/01/18  21:59:47  guru

 * Broken set-bit locking snapshot

 *

 * Revision 3.3  1995/01/17  22:09:18  guru

 * infinite sleep in a lock somewhere..

 *

 * Revision 3.2  1995/01/15  16:46:06  guru

 * Log trimmed of non-pertinent 1.x branch messages

 *

 * Revision 3.1  1995/01/15  14:41:45  guru

 * New Scheduler and timer stuff...

 *

 * Revision 1.15  1995/01/15  14:29:02  guru

 * Will make 1.14 (now 1.15) the 3.0 branch, and the 1.12 the 2.0 branch, the one

 * with the dumber scheduler

 *

 * Revision 1.14  1995/01/15  02:37:08  guru

 * shock.. the kept-new-versions could have zonked working

 * stuff.. shudder

 *

 * Revision 1.13  1995/01/15  02:36:31  guru

 * big changes

 *

 * 	scheduler was torn out and replaced with something smarter

 *

 * 	global names not prefixed with eql_ were renamed to protect

 * 	against namespace collisions

 *

 * 	a few more abstract interfaces were added to facilitate any

 * 	potential change of datastructure.  the driver is still using

 * 	a linked list of slaves.  going to a heap would be a bit of

 * 	an overkill.

 *

 * 	this compiles fine with no warnings.

 *

 * 	the locking mechanism and timer stuff must be written however,

 * 	this version will not work otherwise

 *

 * Sorry, I had to rewrite most of this for 2.5.x -DaveM

	/*

	 *	Now we undo some of the things that eth_setup does

	 * 	that we don't like

 set to 576 in if_eql.h */

 Hands them off fast */

 XXX We should force this off automatically for the user. */

 4 usually... */

	/*

	 *	The timer has to be stopped first before we start hacking away

	 *	at the data structure it scans every so often...

 to be implemented */

 queue->lock must be held */

 Make a pass to set the best slave. */

		/* Go through the slave list once, updating best_slave

		 * whenever a new best_load is found.

 We found a dead slave, kill it. */

/*

 *	Private ioctl functions

 queue->lock must be held */

 queue->lock must be held */

 slave is not a master & not already a slave: */

 SPDX-License-Identifier: GPL-2.0-or-later

/* drivers/net/ifb.c:



	The purpose of this driver is to provide a device that allows

	for sharing of resources:



	1) qdiscs/policies that are per device as opposed to system wide.

	ifb allows for a device which can be redirected to thus providing

	an impression of sharing.



	2) Allows for queueing incoming traffic for shaping instead of

	dropping.



	The original concept is based on what is known as the IMQ

	driver initially written by Martin Devera, later rewritten

	by Patrick McHardy and then maintained by Andre Correa.



	You need the tc action  mirror or redirect to feed this device

	packets.





	Authors:	Jamal Hadi Salim (2005)



 Skip tc and netfilter to prevent redirection loop. */

 Initialize the device structure. */

 Fill in device structure with ethernet-generic values. */

/* Number of ifb devices to be set up by this module.

 * Note that these legacy devices have one queue.

 * Prefer something like : ip link add ifb10 numtxqueues 8 type ifb

 SPDX-License-Identifier: GPL-2.0

/* Bareudp: UDP  tunnel encasulation for different Payload types like

 * MPLS, NSH, IP, etc.

 * Copyright (c) 2019 Nokia, Inc.

 * Authors:  Martin Varghese, <martin.varghese@nokia.com>

 per-network namespace private data for this module */

 Pseudo network device */

 netns for packet i/o */

 netdev for bareudp tunnel */

 bareudp node  on namespace list */

 Consume bad packet */

 Open UDP socket */

 Create new listen socket if needed */

 Mark socket as an encapsulation socket */

 Info for udev, that this is a virtual tunnel endpoint */

 Initialize the device structure. */

 IFLA_BAREUDP_PORT */

 IFLA_BAREUDP_ETHERTYPE */

 IFLA_BAREUDP_SRCPORT_MIN */

 IFLA_BAREUDP_MULTIPROTO_MODE */

 unregister the devices gathered above */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * INET		An implementation of the TCP/IP protocol suite for the LINUX

 *		operating system.  INET is implemented using the  BSD Socket

 *		interface as the means of communication with the user level.

 *

 *		Pseudo-driver for the loopback interface.

 *

 * Version:	@(#)loopback.c	1.0.4b	08/16/93

 *

 * Authors:	Ross Biro

 *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>

 *		Donald Becker, <becker@scyld.com>

 *

 *		Alan Cox	:	Fixed oddments for NET3.014

 *		Alan Cox	:	Rejig for NET3.029 snap #3

 *		Alan Cox	:	Fixed NET3.029 bugs and sped up

 *		Larry McVoy	:	Tiny tweak to double performance

 *		Alan Cox	:	Backed out LMV's tweak - the linux mm

 *					can't take it...

 *              Michael Griffith:       Don't bother computing the checksums

 *                                      on packets received on the loopback

 *                                      interface.

 *		Alexey Kuznetsov:	Potential hang under some extreme

 *					cases removed.

 For the statistics structure. */

 For ARPHRD_ETHER */

/* blackhole_netdev - a device used for dsts that are marked expired!

 * This is global device (instead of per-net-ns) since it's not needed

 * to be per-ns and gets initialized at boot time.

/* The higher levels take care of making this non-reentrant (it's

 * called with bh's disabled).

 do not fool net_timestamp_check() with various clock bases */

	/* Before queueing this packet to netif_rx(),

	 * make sure dst is refcounted.

 14	*/

 14	*/

 6	*/

 0x0001*/

/* The loopback device is special. There is only one instance

 * per network namespace.

 Setup and register the loopback device. */

 Registered in net/core/dev.c */

 blackhole netdevice */

/* This is a dst-dummy device used specifically for invalidated

 * DSTs and unlike loopback, this is not per-ns.

 Setup and register the blackhole_netdev. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * rionet - Ethernet driver over RapidIO messaging services

 *

 * Copyright 2005 MontaVista Software, Inc.

 * Matt Porter <mporter@kernel.crashing.org>

 net info access lock */

 number of active peers */

			/*

			 * If the target device was removed from the list of

			 * active peers but we still have TX packets targeting

			 * it just report sending a packet to the target

			 * (without actual packet transfer).

 dma unmap single */

 Initialize inbound message ring */

 Send a join message */

 Set up private area */

 Set the default MAC address */

 MTU range: 68 - 4082 */

	/*

	 * If first time through this net, make sure local device is rionet

	 * capable and setup netdev (this step will be skipped in later probes

	 * on the same net).

 Allocate our net_device structure */

	/*

	 * If the remote device has mailbox/doorbell capabilities,

	 * add it to the peer list.

 If netdev is already opened, send join request to new peer */

 terminate list */

 the rio_mport_interface is used to handle local mport devices */

 SPDX-License-Identifier: GPL-2.0-only

/* dummy.c: a dummy net driver



	The purpose of this driver is to provide a device to point a

	route through, but not to actually transmit packets.



	Why?  If you have a machine whose only connection is an occasional

	PPP/SLIP/PLIP link, you can only connect to your own hostname

	when the link is up.  Otherwise you have to use localhost.

	This isn't very consistent.



	One solution is to set up a dummy link using PPP/SLIP/PLIP,

	but this seems (to me) too much overhead for too little gain.

	This driver provides a small alternative. Thus you can do



	[when not running slip]

		ifconfig dummy slip.addr.ess.here up

	[to go to slip]

		ifconfig dummy down

		dip whatever



	This was written by looking at Donald Becker's skeleton driver

	and the loopback driver.  I then threw away anything that didn't

	apply!	Thanks to Alan Cox for the key clue on what to do with

	misguided packets.



			Nick Holloway, 27th May 1994

	[I tweaked this explanation a little but that's all]

			Alan Cox, 30th May 1994

 fake multicast ability */

 Initialize the device structure. */

 Fill in device structure with ethernet-generic values. */

 Number of dummy devices to be set up by this module. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * GENEVE: Generic Network Virtualization Encapsulation

 *

 * Copyright (c) 2015 Red Hat, Inc.

 per-network namespace private data for this module */

 Pseudo network device */

 vni hash table for IPv4 socket */

 vni hash table for IPv6 socket */

 netns for packet i/o */

 netdev for geneve tunnel */

 IPv4 socket used for geneve tunnel */

 IPv6 socket used for geneve tunnel */

 geneve's per namespace list */

 Convert 64 bit tunnel ID to 24 bit VNI. */

 Find the device for this VNI */

 Find the device for this VNI */

 outer IP header... */

 outer IPv6 header... */

 geneve receive/decap routine */

 Update tunnel dst according to Geneve options. */

		/* Drop packets w/ critical options,

		 * since we don't support any...

 Ignore packet loops (and multicast echo) */

 Consume bad packet */

 Setup stats when device is created */

 Callback from net/ipv4/udp.c to receive packets */

 Need UDP and Geneve header to be present */

 Return packets with reserved bits set */

 Consume bad packet */

 Callback from net/ipv{4,6}/udp.c to check that we have a tunnel for errors */

 Open UDP socket */

 Create new listen socket if needed */

 Initialize the geneve udp offloads structure */

 Mark socket as an encapsulation socket */

 is this necessary? */

 is this necessary? */

 Info for udev, that this is a virtual tunnel endpoint */

/* Calls the ndo_udp_tunnel_add of the caller in order to

 * supply the listening GENEVE udp ports. Callers are expected

 * to implement the ndo_udp_tunnel_add.

 Initialize the device structure. */

 MTU range: 68 - (something less than 65535) */

	/* The max_mtu calculation does not take account of GENEVE

	 * options, to avoid excluding potentially valid

	 * configurations. This will be further reduced by IPvX hdr size.

 make enough headroom for basic scenario */

/* Quiesces the geneve device data path for both TX and RX.

 *

 * On transmit geneve checks for non-NULL geneve_sock before it proceeds.

 * So, if we set that socket to NULL under RCU and wait for synchronize_net()

 * to complete for the existing set of in-flight packets to be transmitted,

 * then we would have quiesced the transmit data path. All the future packets

 * will get dropped until we unquiesce the data path.

 *

 * On receive geneve dereference the geneve_sock stashed in the socket. So,

 * if we set that to NULL under RCU and wait for synchronize_net() to

 * complete, then we would have quiesced the receive data path.

 Resumes the geneve device data path for both TX and RX. */

	/* If the geneve device is configured for metadata (or externally

	 * controlled, for example, OVS), then nothing can be changed.

 Start with the existing info. */

 IFLA_GENEVE_ID */

 IFLA_GENEVE_REMOTE{6} */

 IFLA_GENEVE_TTL */

 IFLA_GENEVE_TOS */

 IFLA_GENEVE_DF */

 IFLA_GENEVE_LABEL */

 IFLA_GENEVE_PORT */

 IFLA_GENEVE_COLLECT_METADATA */

 IFLA_GENEVE_UDP_CSUM */

 IFLA_GENEVE_UDP_ZERO_CSUM6_TX */

 IFLA_GENEVE_UDP_ZERO_CSUM6_RX */

 IFLA_GENEVE_TTL_INHERIT */

	/* openvswitch users expect packet sizes to be unrestricted,

	 * so set the largest MTU we can.

 gather any geneve devices that were moved into this ns */

 now gather any other geneve devices that were created in this ns */

		/* If geneve->dev is in the same netns, it was already added

		 * to the list by the previous loop.

 unregister the devices gathered above */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * VXLAN: Virtual eXtensible Local Area Network

 *

 * Copyright (c) 2012-2013 Vyatta Inc.

 5 min */

 rescan interval */

/* UDP port for VXLAN traffic.

 * The IANA assigned port is 4789, but the Linux default is 8472

 * for compatibility with early adopters.

 per-network namespace private data for this module */

 Forwarding table entry */

 linked list of entries */

 jiffies */

 see ndm_state */

 see ndm_flags and below */

 salt for hash table */

 !CONFIG_IPV6 */

 Virtual Network hash table head */

 Socket hash table head */

/* First remote destination for a forwarding entry.

 * Guaranteed to be non-NULL because remotes are never deleted.

/* Find VXLAN socket based on network namespace, address family, UDP port,

 * enabled unshareable flags and socket device binding (see l3mdev with

 * non-default VRF).

 For flow based devices, map all packets to VNI 0 */

 Look up VNI in a per net namespace table */

 Fill in neighbour message in skbuff. */

 NDA_LLADDR */

 NDA_DST */

 NDA_PORT */

 NDA_VNI */

 NDA_IFINDEX */

 NDA_LINK_NETNSID */

 -EMSGSIZE implies BUG in vxlan_nlmsg_size() */

 goes to NDA_DST */

 Hash Ethernet address */

 only want 6 bytes */

 use 1 byte of OUI and 3 bytes of NIC */

 Hash chain to use given mac address */

 Look up Ethernet address in forwarding table */

 caller should hold vxlan->hash_lock */

 Replace destination of unicast mac */

 Add/update destinations for multicast */

 pull vxlan header */

	/* Sets 'skb->inner_mac_header' since we are always called with

	 * 'skb->encapsulation' set.

 check nexthop group family */

	/* Do not allow an externally learned entry to take over an entry added

	 * by the user.

 Only change unicasts */

 Disallow replace to add a multicast entry */

 Add new entry to forwarding table -- assumes lock held */

 Add static entry (via netlink) */

 struct net *net = dev_net(vxlan->dev); */

	/* remove a destination if it's not the only one on the list,

	 * otherwise destroy the fdb entry

 Delete entry (via netlink) */

 Dump forwarding table */

/* Watch incoming packets to learn mapping between Ethernet address

 * and Tunnel endpoint.

 * Return true if packet is bogus and should be dropped.

 Don't migrate static entries, drop packets */

 Don't override an fdb with nexthop with a learnt entry */

 learned new entry */

 close off race between vxlan_flush and incoming packets */

 See if multicast group is already in use by other ID */

	/* The vxlan_sock is only used by dev, leaving group has

	 * no effect on other vxlan devices.

/* Update multicast group membership when first VNI on

 * multicast address is brought up

 Inverse of vxlan_igmp_join when last VNI is brought down */

 In flow-based mode, GBP is carried in dst_metadata */

 Need to have Next Protocol set for interfaces in GPE mode. */

	/* "The initial version is 0. If a receiver does not support the

	 * version indicated it MUST drop the packet.

	/* "When the O bit is set to 1, the packet is an OAM packet and OAM

	 * processing MUST occur." However, we don't implement OAM

	 * processing, thus drop the packet.

 Ignore packet loops (and multicast echo) */

 Get address from the outer IP header */

 Callback from net/ipv4/udp.c to receive packets */

 Need UDP and VXLAN header to be present */

 VNI flag always required to be set */

 Return non vxlan pkt */

	/* For backwards compatibility, only allow reserved fields to be

	 * used by VXLAN extensions if explicitly requested.

	/* Note that GBP and GPE can never be active together. This is

	 * ensured in vxlan_dev_configure.

		/* If there are any unprocessed flags remaining treat

		 * this as a malformed packet. This behavior diverges from

		 * VXLAN RFC (RFC7348) which stipulates that bits in reserved

		 * in reserved fields are to be ignored. The approach here

		 * maintains compatibility with previous stack code, and also

		 * is more robust and provides a little more security in

		 * adding extensions to VXLAN.

 Consume bad packet */

 Callback from net/ipv{4,6}/udp.c to check that we have a VNI for errors */

 sha */

 tha */

 bridge-local neighbor */

 opt hdr + ETH_ALEN for target */

 Ethernet header */

 IPv6 header */

 Neighbor Advertisement */

 bridge-local neighbor */

 Need space for new headers (invalidates iph ptr) */

 Bypass encapsulation if the destination is local */

	/* IPv6 rt-flags are checked against RTF_LOCAL, but the value of

	 * RTF_LOCAL is equal to RTCF_LOCAL. So to keep code simple

	 * we can use RTCF_LOCAL which works for ipv4 and ipv6 route entry.

 Bypass encapsulation if the destination is local */

 short-circuited back to local bridge */

 Bypass encapsulation if the destination is local */

/* Transmit local packets over Vxlan

 *

 * Outer IP header inherits ECN and DF from inner header.

 * Outer UDP destination is the VXLAN assigned port.

 *           source port is based on hash of flow

 Walk the forwarding table and purge stale entries */

 Setup stats when device is created */

 Start ageing timer and join group when device is brought up */

 Purge the forwarding table */

 the all_zeros_mac entry is deleted at vxlan_uninit */

 Cleanup timer and forwarding table on shutdown */

 Stub, nothing needs to be done. */

	/* This check is different than dev->max_mtu, because it looks at

	 * the lowerdev->mtu, rather than the static dev->max_mtu

 !CONFIG_IPV6 */

 Info for udev, that this is a virtual tunnel endpoint */

/* Calls the ndo_udp_tunnel_add of the caller in order to

 * supply the listening VXLAN udp ports. Callers are expected

 * to implement the ndo_udp_tunnel_add.

 Initialize the device structure. */

 MTU range: 68 - 65535 */

 Open UDP socket */

 Create new listen socket if needed */

 Mark socket as an encapsulation socket. */

		/* For now, allow GPE only together with

		 * COLLECT_METADATA. This can be relaxed later; in such

		 * case, the other side of the PtP link will have to be

		 * provided.

 Unless IPv6 is explicitly requested, assume IPv4 */

 IANA VXLAN-GPE port */

 create an fdb entry for a valid default destination */

 notify default fdb entry */

	/* unregister_netdevice() destroys the default FDB entry with deletion

	 * notification. But the addition notification was not sent yet, so

	 * destroy the entry by hand here.

 Set/clear flags based on attribute */

 if changelink operation, start with old existing cfg */

 TODO: respect scope id */

 default to learn on a new device */

 handle default dst entry */

 IFLA_VXLAN_ID */

 IFLA_VXLAN_GROUP{6} */

 IFLA_VXLAN_LINK */

 IFLA_VXLAN_LOCAL{6} */

 IFLA_VXLAN_TTL */

 IFLA_VXLAN_TTL_INHERIT */

 IFLA_VXLAN_TOS */

 IFLA_VXLAN_DF */

 IFLA_VXLAN_LABEL */

 IFLA_VXLAN_LEARNING */

 IFLA_VXLAN_PROXY */

 IFLA_VXLAN_RSC */

 IFLA_VXLAN_L2MISS */

 IFLA_VXLAN_L3MISS */

 IFLA_VXLAN_COLLECT_METADATA */

 IFLA_VXLAN_AGEING */

 IFLA_VXLAN_LIMIT */

 IFLA_VXLAN_PORT */

 IFLA_VXLAN_UDP_CSUM */

 IFLA_VXLAN_UDP_ZERO_CSUM6_TX */

 IFLA_VXLAN_UDP_ZERO_CSUM6_RX */

 IFLA_VXLAN_REMCSUM_TX */

 IFLA_VXLAN_REMCSUM_RX */

		/* In case we created vxlan device with carrier

		 * and we loose the carrier due to module unload

		 * we also need to remove vxlan device. In other

		 * cases, it's not necessary and remote_ifindex

		 * is 0 here, so no matches.

		/* If vxlan->dev is in the same netns, it has already been added

		 * to the list by the previous loop.

 rcu_barrier() is called by netns */

 SPDX-License-Identifier: GPL-2.0

/*

 * Networking over Thunderbolt cable using Apple ThunderboltIP protocol

 *

 * Copyright (C) 2017, Intel Corporation

 * Authors: Amir Levy <amir.jer.levy@intel.com>

 *          Michael Jamet <michael.jamet@intel.com>

 *          Mika Westerberg <mika.westerberg@linux.intel.com>

 Protocol timeouts in ms */

 Rx packets need to hold space for skb_shared_info */

/**

 * struct thunderbolt_ip_frame_header - Header for each Thunderbolt frame

 * @frame_size: size of the data with the frame

 * @frame_index: running index on the frames

 * @frame_id: ID of the frame to match frames to specific packet

 * @frame_count: how many frames assembles a full packet

 *

 * Each data frame passed to the high-speed DMA ring has this header. If

 * the XDomain network directory announces that %TBNET_MATCH_FRAGS_ID is

 * supported then @frame_id is filled, otherwise it stays %0.

/**

 * struct tbnet - ThunderboltIP network driver private data

 * @svc: XDomain service the driver is bound to

 * @xd: XDomain the service blongs to

 * @handler: ThunderboltIP configuration protocol handler

 * @dev: Networking device

 * @napi: NAPI structure for Rx polling

 * @stats: Network statistics

 * @skb: Network packet that is currently processed on Rx path

 * @command_id: ID used for next configuration protocol packet

 * @login_sent: ThunderboltIP login message successfully sent

 * @login_received: ThunderboltIP login message received from the remote

 *		    host

 * @local_transmit_path: HopID we are using to send out packets

 * @remote_transmit_path: HopID the other end is using to send packets to us

 * @connection_lock: Lock serializing access to @login_sent,

 *		     @login_received and @transmit_path.

 * @login_retries: Number of login retries currently done

 * @login_work: Worker to send ThunderboltIP login packets

 * @connected_work: Worker that finalizes the ThunderboltIP connection

 *		    setup and enables DMA paths for high speed data

 *		    transfers

 * @disconnect_work: Worker that handles tearing down the ThunderboltIP

 *		     connection

 * @rx_hdr: Copy of the currently processed Rx frame. Used when a

 *	    network packet consists of multiple Thunderbolt frames.

 *	    In host byte order.

 * @rx_ring: Software ring holding Rx frames

 * @frame_id: Frame ID use for next Tx packet

 *            (if %TBNET_MATCH_FRAGS_ID is supported in both ends)

 * @tx_ring: Software ring holding Tx frames

 Network property directory UUID: c66189ca-1cce-4195-bdb8-49592e5f5a4f */

 ThunderboltIP protocol UUID: 798f589e-3616-8a47-97c6-5664a920c8dd */

 Length does not include route_hi/lo and length_sn fields */

 Make sure the packet is for us */

			/* If we reached the number of max retries or

			 * previous logout, schedule another round of

			 * login retries

		/* Allocate page (order > 0) so that it can hold maximum

		 * ThunderboltIP frame (4kB) and the additional room for

		 * SKB shared info required by build_skb().

 Return buffer to the ring */

	/* Both logins successful so enable the high-speed DMA paths and

	 * start the network device queue.

 Should be greater than just header i.e. contains data */

	/* In case we're in the middle of packet, validate the frame

	 * header based on first fragment of the packet.

 Check the frame count fits the count field */

		/* Check the frame identifiers are incremented correctly,

		 * and id is matching.

 Start of packet, validate the frame header */

		/* Return some buffers to hardware, one at a time is too

		 * slow so allocate MAX_SKB_FRAGS buffers at the same

		 * time.

 Re-enable the ring interrupt */

		/* No need to calculate checksum so we just update the

		 * total frame count and sync the frames for DMA.

	/* Data points on the beginning of packet.

	 * Check is the checksum absolute place in the packet.

	 * ipcso will update IP checksum.

	 * tucso will update TCP/UPD checksum.

	/* First frame was headers, rest of the frames contain data.

	 * Calculate checksum over each frame.

	/* Checksum is finally calculated and we don't touch the memory

	 * anymore, so DMA sync the frames now.

 If overall packet is bigger than the frame data size */

				/* Copy data onto Tx buffer data with

				 * full frame size then break and go to

				 * next frame

 Ensure all fragments have been processed */

 Map and then unmap quickly */

 In case the remaining data_len is smaller than a frame */

 We can re-use the buffers */

 Unicast and locally administered MAC */

	/* ThunderboltIP takes advantage of TSO packets but instead of

	 * segmenting them we just split the packet into Thunderbolt

	 * frames (maximum payload size of each frame is 4084 bytes) and

	 * calculate checksum over the whole packet here.

	 *

	 * The receiving side does the opposite if the host OS supports

	 * LRO, otherwise it needs to split the large packet into MTU

	 * sized smaller packets.

	 *

	 * In order to receive large packets from the networking stack,

	 * we need to announce support for most of the offloading

	 * features here.

 MTU range: 68 - 65522 */

	/* Currently only announce support for match frags ID (bit 1). Bit 0

	 * is reserved for full E2E flow control which we do not support at

	 * the moment.

 SPDX-License-Identifier: GPL-2.0-only

 CONFIG_TUN_VNET_CROSS_LE */

/*

 * RCU usage:

 * The tap_queue and the macvlan_dev are loosely coupled, the

 * pointers from one to the other can only be read while rcu_read_lock

 * or rtnl is held.

 *

 * Both the file and the macvlan_dev hold a reference on the tap_queue

 * through sock_hold(&q->sk). When the macvlan_dev goes away first,

 * q->vlan becomes inaccessible. When the files gets closed,

 * tap_get_queue() fails.

 *

 * There may still be references to the struct sock inside of the

 * queue from outbound SKBs, but these never reference back to the

 * file or the dev. The data structure is freed through __sk_free

 * when both our references and any pending SKBs are gone.

 Requires RTNL */

/*

 * The file owning the queue got closed, give up both

 * the reference that the files holds as well as the

 * one from the macvlan_dev if that still exists.

 *

 * Using the spinlock makes sure that we don't get

 * to the queue again after destroying it.

/*

 * Select a queue based on the rxq of the device on which this packet

 * arrived. If the incoming device is not mq, calculate a flow hash

 * to select a queue. If all fails, find the first available queue.

 * Cache vlan->numvtaps since it can become zero during the execution

 * of this function.

	/* Access to taps array is protected by rcu, but access to numvtaps

	 * isn't. Below we use it to lookup a queue, but treat it as a hint

	 * and validate that the result isn't NULL - in case we are

	 * racing against queue removal.

 Check if we can use flow to select a queue */

/*

 * The net_device is going away, give up the reference

 * that it holds on all queues and safely set the pointer

 * from the queues to NULL.

 guarantee that any future tap_set_queue will fail */

	/* Apply the forward feature mask so that we perform segmentation

	 * according to users wishes.  This only works if VNET_HDR is

	 * enabled.

		/* If we receive a partial checksum and the tap side

		 * doesn't support checksum offload, compute the checksum.

		 * Note: it doesn't matter which checksum feature to

		 *	  check, we either support them all or none.

 Count errors/drops only here, thus don't care about args. */

	/*

	 * so far only KVM virtio_net uses tap, enable zero copy between

	 * guest kernel and host kernel when lower device supports zerocopy

	 *

	 * The macvlan supports zerocopy iff the lower device supports zero

	 * copy so we don't have to look at the lower device directly.

 tap_sock_destruct() will take care of freeing ptr_ring */

 Under a page?  Don't bother with paged skb. */

 Neighbour code has some assumptions on HH_DATA_MOD alignment */

 Get packet from user space buffer */

 Move network header to the right position for VLAN tagged packets */

 copy skb_ubuf_info for callback when skb has no error */

 Put packet to the user space buffer */

 Read frames from the queue */

 Nothing to read, let's sleep */

	/* tun/tap driver inverts the usage for TSO offloads, where

	 * setting the TSO bit means that the userspace wants to

	 * accept TSO frames and turning it off means that user space

	 * does not support TSO.

	 * For tap, we have to invert it to mean the same thing.

	 * When user space turns off TSO, we turn off GSO/LRO so that

	 * user-space will not receive TSO frames.

	/* tap_features are the same as features on tun/tap and

	 * reflect user expectations.

/*

 * provide compatibility with generic tun/tap interface

 ignore the name, just look at flags */

 let the user check for future flags */

 Move network header to the right position for VLAN tagged packets */

 Ops structure to mimic raw sockets with tun */

/* Get an underlying socket object from tun file.  Returns error unless file is

 * attached to a device.  The returned object works like a packet socket, it

 * can be used for sock_sendmsg/sock_recvmsg.  The caller is responsible for

/*

 * This file is provided under a dual BSD/GPLv2 license.  When using or

 *   redistributing this file, you may do so under either license.

 *

 *   GPL LICENSE SUMMARY

 *

 *   Copyright(c) 2012 Intel Corporation. All rights reserved.

 *   Copyright (C) 2015 EMC Corporation. All Rights Reserved.

 *

 *   This program is free software; you can redistribute it and/or modify

 *   it under the terms of version 2 of the GNU General Public License as

 *   published by the Free Software Foundation.

 *

 *   BSD LICENSE

 *

 *   Copyright(c) 2012 Intel Corporation. All rights reserved.

 *   Copyright (C) 2015 EMC Corporation. All Rights Reserved.

 *

 *   Redistribution and use in source and binary forms, with or without

 *   modification, are permitted provided that the following conditions

 *   are met:

 *

 *     * Redistributions of source code must retain the above copyright

 *       notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copy

 *       notice, this list of conditions and the following disclaimer in

 *       the documentation and/or other materials provided with the

 *       distribution.

 *     * Neither the name of Intel Corporation nor the names of its

 *       contributors may be used to endorse or promote products derived

 *       from this software without specific prior written permission.

 *

 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS

 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT

 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR

 *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT

 *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,

 *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT

 *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,

 *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY

 *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE

 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 * PCIe NTB Network Linux driver

 *

 * Contact Information:

 * Jon Mason <jon.mason@intel.com>

 Time in usecs for tx resource reaper */

 Number of descriptors to free before resuming tx */

 Number of descriptors still available before stop upper layer tx */

	/* Make sure to see the latest value of ntb_transport_tx_free_entry()

	 * since the queue was last started.

		/* Make sure anybody stopping the queue after this sees the new

		 * value of ntb_transport_tx_free_entry()

 check for next submit */

		/* Make sure anybody stopping the queue after this sees the new

		 * value of ntb_transport_tx_free_entry()

 Add some empty rx bufs */

 Bring down the link and dispose of posted rx entries */

/*

 * Virtual network driver for conversing with remote driver backends.

 *

 * Copyright (c) 2002-2005, K A Fraser

 * Copyright (c) 2005, XenSource Ltd

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License version 2

 * as published by the Free Software Foundation; or, when distributed

 * separately from the Linux kernel or incorporated into other

 * software packages, subject to the following license:

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this source file (the "Software"), to deal in the Software without

 * restriction, including without limitation the rights to use, copy, modify,

 * merge, publish, distribute, sublicense, and/or sell copies of the Software,

 * and to permit persons to whom the Software is furnished to do so, subject to

 * the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * all copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING

 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS

 * IN THE SOFTWARE.

 Module parameters */

 Minimum number of Rx slots (includes slot for GSO metadata). */

 Queue name is interface name with "-qNNN" appended */

 IRQ name is queue name with "-tx" or "-rx" appended */

 Queue ID, 0-based */

 DEVNAME-qN */

	/* Split event channels support, tx_* == rx_* when using

	 * single event channel.

 Only used when split event channels support is enabled */

 DEVNAME-qN-tx */

 DEVNAME-qN-rx */

	/*

	 * {tx,rx}_skbs store outstanding skbuffs. Free tx_skb entries

	 * are linked from tx_skb_freelist through tx_link.

 Multi-queue support */

 Statistics */

 XDP state */

 Is device behaving sane? */

/*

 * Access macros for acquiring freeing slots in tx_skbs[].

 Align ip header to a 16 bytes boundary */

	/* Try again later if there are not enough requests or skb allocation

	 * failed.

	 * Enough requests is quantified as the sum of newly created slots and

	 * the unconsumed slots at the backend.

 Ensure we see responses up to 'rp'. */

 Last request on ring page */

 Last request local copy*/

 convenient aliases */

	/*

	 * Put the request in the pending queue, it will be set to be pending

	 * when the producer index is about to be raised.

 Skip unused frames from start of page */

/*

 * Count how many ring slots are required to send this skb. Each frag

 * might be a compound page.

 Skip unused frames from start of page */

 First, check if there is only one queue */

 Drop the packet if no queues are set up */

 Determine which queue to transmit this SKB on */

	/* If skb->len is too big for wire format, drop skb and alert

	 * user about misconfiguration.

	/* The first req should be at least ETH_HLEN size or the packet will be

	 * dropped by netback.

 First request for the linear area. */

 local packet? */

 remote but checksummed. */

 Optional extra info after the first request. */

 Requests for the rest of the linear area. */

 Requests for all the frags. */

 First request has the packet length. */

 timestamp packet in software */

 Note: It is not safe to access skb after xennet_tx_buf_gc()! */

		/*

		 * This definitely indicates a bug, either in this driver or in

		 * the backend driver. In future this should flag the bad

		 * situation to the system controller to reboot the backend.

 currently only a single page contains data */

 drop the frame */

 Header must be checked, and gso_segs computed. */

	/*

	 * A GSO SKB must be CHECKSUM_PARTIAL. However some buggy

	 * peers can fail to set NETRXF_csum_blank when sending a GSO

	 * frame. In this case force the SKB to CHECKSUM_PARTIAL and

	 * recalculate the partial checksum.

 A non-CHECKSUM_PARTIAL SKB does not require setup. */

 Ethernet work: Delayed to here as it peeks the header. */

 Pass it up. */

 Ensure we see queued responses up to 'rp'. */

 Skip over entries which are actually freelist references */

		/* gnttab_end_foreign_access() needs a page ref until

		 * foreign access is ended (which may be deferred).

 Poll each queue */

 avoid the race with XDP headroom adjustment */

	/*

         * Assume that all hw features are available for now. This set

         * will be adjusted by the call to netdev_update_features() in

         * xennet_connect() which is the earliest point where we can

         * negotiate with the backend regarding supported features.

/*

 * Entry point to this code when a new device is created.  Allocate the basic

 * structures and the ring buffers for communication with the backend, and

 * inform the backend of the appropriate details for those.

 This frees the page as a side-effect */

 End access and free the pages */

/*

 * We are reconnecting to the backend, due to a suspend/resume, or a backend

 * driver restart.  We tear down our netif structure and recreate it, but

 * leave the device-layer structures intact so that this is transparent to the

 * rest of the kernel.

	/* setup single event channel if

	 *  a) feature-split-event-channels == 0

	 *  b) feature-split-event-channels == 1 but failed to setup

	/* If we fail to setup netfront, it is safe to just revoke access to

	 * granted pages because backend is not accessing it at this point.

/* Queue-specific initialisation

 * This used to be done in xennet_create_dev() but must now

 * be run per-queue.

 Initialise tx_skb_freelist as a free chain containing every entry. */

 Clear out rx_skbs */

 A grant for every tx ring slot */

 A grant for every rx ring slot */

	/* Write the queue-specific keys into XenStore in the traditional

	 * way for a single queue, or in a queue subkeys for multiple

	 * queues.

 Choose the correct place to write the keys */

 Write ring references */

	/* Write event channels; taking into account both shared

	 * and split event channel scenarios.

 Shared event channel */

 Split event channels */

 use page pool recycling instead of buddy allocator */

 Common code used when first setting up, and when resuming. */

 Check if backend supports multiple queues */

 Check feature-split-event-channels */

 Read mac addr. */

 set the current xen-netfront xdp state */

 For the case of a reconnect reset the "broken" indicator. */

 Create shared ring, alloc event channel -- for each queue */

 Write the number of queues */

 flat */

 Write the keys for each queue */

 hierarchical */

 The remaining keys are not queue-specific */

 talk_to_netback() sets the correct number of queues */

	/*

	 * All public and private state should now be sane.  Get

	 * ready to start sending and receiving packets and give the driver

	 * domain a kick because we've probably just requeued some

	 * packets.

/*

 * Callback received when the backend's state changes.

 Missed the backend's CLOSING state */

 rxbuf_min and rxbuf_max are no longer configurable. */

 CONFIG_SYSFS */

	/* Allow as many queues as there are CPUs inut max. 8 if user has not

	 * specified a value.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  linux/drivers/net/netconsole.c

 *

 *  Copyright (C) 2001  Ingo Molnar <mingo@redhat.com>

 *

 *  This file contains the implementation of an IRQ-safe, crash-safe

 *  kernel console implementation that outputs kernel messages to the

 *  network.

 *

 * Modification history:

 *

 * 2001-09-17    started by Ingo Molnar.

 * 2003-08-11    2.6 port by Matt Mackall

 *               simplified options

 *               generic card hooks

 *               works non-modular

 * 2003-09-07    rewritten with netpoll api

/****************************************************************

 *

 MODULE */

 Linked list of all configured targets */

 This needs to be a spinlock because write_msg() cannot sleep */

/*

 * Console driver for extended netconsoles.  Registered on the first use to

 * avoid unnecessarily enabling ext message formatting.

/**

 * struct netconsole_target - Represents a configured netconsole target.

 * @list:	Links this target into the target_list.

 * @item:	Links us into the configfs subsystem hierarchy.

 * @enabled:	On / off knob to enable / disable target.

 *		Visible from userspace (read-write).

 *		We maintain a strict 1:1 correspondence between this and

 *		whether the corresponding netpoll is active or inactive.

 *		Also, other parameters of a target may be modified at

 *		runtime only when it is disabled (enabled == 0).

 * @extended:	Denotes whether console is extended or not.

 * @np:		The netpoll structure for this target.

 *		Contains the other userspace visible parameters:

 *		dev_name	(read-write)

 *		local_port	(read-write)

 *		remote_port	(read-write)

 *		local_ip	(read-write)

 *		remote_ip	(read-write)

 *		local_mac	(read-only)

 *		remote_mac	(read-write)

/*

 * Targets that were created by parsing the boot/module option string

 * do not exist in the configfs hierarchy (and have NULL names) and will

 * never go away, so make these a no-op for them.

 !CONFIG_NETCONSOLE_DYNAMIC */

/*

 * No danger of targets going away from under us when dynamic

 * reconfigurability is off.

 CONFIG_NETCONSOLE_DYNAMIC */

 Allocate new target (from boot/module param) and setup netpoll for it */

	/*

	 * Allocate and initialize with defaults.

	 * Note that these targets get their config_item fields zeroed-out.

 Parse parameters and setup netpoll */

 Cleanup netpoll for given target (from boot/module param) and free it */

/*

 * Our subsystem hierarchy is:

 *

 * /sys/kernel/config/netconsole/

 *				|

 *				<target>/

 *				|	enabled

 *				|	dev_name

 *				|	local_port

 *				|	remote_port

 *				|	local_ip

 *				|	remote_ip

 *				|	local_mac

 *				|	remote_mac

 *				|

 *				<target>/...

/*

 * Attribute operations for netconsole_target.

/*

 * This one is special -- targets created through the configfs interface

 * are not enabled (and the corresponding netpoll activated) by default.

 * The user is expected to set the desired parameters first (which

 * would enable him to dynamically add new netpoll targets for new

 * network interfaces as and when they come up).

 true */

		/*

		 * Skip netpoll_parse_options() -- all the attributes are

		 * already configured via configfs. Just print them out.

 false */

		/* We need to disable the netconsole before cleaning it up

		 * otherwise we might end up in write_msg() with

		 * nt->np.dev == NULL and nt->enabled == true

 Get rid of possible trailing newline from echo(1) */

/*

 * Item operations and type for netconsole_target.

/*

 * Group operations and type for netconsole_subsys.

	/*

	 * Allocate and initialize with defaults.

	 * Target is disabled at creation (!enabled).

 Initialize the config_item member */

 Adding, but it is disabled */

	/*

	 * The target may have never been enabled, or was manually disabled

	 * before being removed so netpoll may have already been cleaned up.

 The netconsole configfs subsystem */

 CONFIG_NETCONSOLE_DYNAMIC */

 Handle network interface device notifications */

				/* rtnl_lock already held

				 * we might sleep in __netpoll_cleanup()

/**

 * send_ext_msg_udp - send extended log message to target

 * @nt: target to send message to

 * @msg: extended log message to send

 * @msg_len: length of message

 *

 * Transfer extended log @msg to @nt.  If @msg is longer than

 * MAX_PRINT_CHUNK, it'll be split and transmitted in multiple chunks with

 * ncfrag header field added to identify them.

 protected by target_list_lock */

 need to insert extra header fields, detect header and body */

	/*

	 * Transfer multiple chunks with the following extra header.

	 * "ncfrag=<byte-offset>/<total-bytes>"

 Avoid taking lock and disabling interrupts unnecessarily */

			/*

			 * We nest this inside the for-each-target loop above

			 * so that we're able to get as much logging out to

			 * at least one target if we die inside here, instead

			 * of unnecessarily keeping all targets in lock-step.

 starts disabled, registered on first use */

 Dump existing printks when we register */

	/*

	 * Remove all targets and destroy them (only targets created

	 * from the boot/module option exist here). Skipping the list

	 * lock is safe here, and netpoll_cleanup() will sleep.

	/*

	 * Targets created via configfs pin references on our module

	 * and would first be rmdir(2)'ed from userspace. We reach

	 * here only when they are already destroyed, and only those

	 * created from the boot/module option are left, so remove and

	 * destroy them. Skipping the list lock is safe here, and

	 * netpoll_cleanup() will sleep.

/*

 * Use late_initcall to ensure netconsole is

 * initialized after network device driver if built-in.

 *

 * late_initcall() and module_init() are identical if built as module.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * PHY drivers for the sungem ethernet driver.

 *

 * This file could be shared with other drivers.

 *

 * (c) 2002-2007, Benjamin Herrenscmidt (benh@kernel.crashing.org)

 *

 * TODO:

 *  - Add support for PHYs that provide an IRQ line

 *  - Eventually moved the entire polling state machine in

 *    there (out of the eth driver), so that it can easily be

 *    skipped on PHYs that implement it in hardware.

 *  - On LXT971 & BCM5201, Apple uses some chip specific regs

 *    to read the link status. Figure out why and if it makes

 *    sense to do the same (magic aneg ?)

 *  - Apple has some additional power management code for some

 *    Broadcom PHYs that they "hide" from the OpenSource version

 *    of darwin, still need to reverse engineer that

 Link modes of the BCM5400 PHY */

 No link */

 10BT Half Duplex */

 10BT Full Duplex */

 100BT Half Duplex */

 100BT Half Duplex */

 100BT Full Duplex*/

 1000BT */

 1000BT */

 Configure for gigabit full duplex */

 Reset and configure cascaded 10/100 PHY */

 Commented out in Darwin... someone has those dawn docs ? */

		/* Some revisions of 5401 appear to need this

		 * initialisation sequence to disable, according

		 * to OF, "tap power management"

		 *

		 * WARNING ! OF and Darwin don't agree on the

		 * register addresses. OF seem to interpret the

		 * register numbers below as decimal

		 *

		 * Note: This should (and does) match tg3_init_5401phy_dsp

		 *       in the tg3.c driver. -DaveM

 Configure for gigabit full duplex */

 Reset and configure cascaded 10/100 PHY */

 Commented out in Darwin... someone has those dawn docs ? */

	/* Here's some more Apple black magic to setup

	 * some voltage stuffs.

	/* Here, Apple seems to want to reset it, do

	 * it as well

 Reset and configure cascaded 10/100 PHY */

 Setup standard advertise */

 Start/Restart aneg */

 First reset the PHY */

 Select speed & duplex */

	/* On non-aneg, we assume what we put in BMCR is the speed,

	 * though magic-aneg shouldn't prevent this case from occurring

 Revision 0 of 5421 needs some fixups */

		/* This is borrowed from MacOS

 Pick up some init code from OF for K2 version */

 Check if we can enable automatic low power */

 Enable automatic low-power */

 CONFIG_PPC_PMAC */

 Setup standard advertise */

 Setup 1000BT advertise */

 Start/Restart aneg */

 First reset the PHY */

 Select speed & duplex */

 XXX Should we set the sungem to GII now on 1000BT ?

	/* On non-aneg, we assume what we put in BMCR is the speed,

	 * though magic-aneg shouldn't prevent this case from occurring

 magic init sequence for rev 0 */

 find out in what mode we are */

 try to find out whether we have a link */

 find out in what mode we are */

 find out whether we are running half- or full duplex */

 enable fiber mode */

 LEDs active in both modes, autosense prio = fiber */

 switch off fibre autoneg */

 find out in what mode we are */

 find out whether we have a link */

 find out in what mode we are */

 find out whether we are running half- or full duplex */

 select fiber mode, enable 1000 base-X registers */

 enable fiber with no autonegotiation */

 enable fiber with autonegotiation */

 Setup standard advertise */

	/* Setup 1000BT advertise & enable crossover detect

	 * XXX How do we advertise 1000BT ? Darwin source is

	 * confusing here, they read from specific control and

	 * write to control... Someone has specs for those

	 * beasts ?

 Start/Restart aneg */

 Select speed & duplex */

	/* I'm not sure about the one below, again, Darwin source is

	 * quite confusing and I lack chip specs

	/* Disable crossover. Again, the way Apple does it is strange,

	 * though I don't assume they are wrong ;)

 XXX Should we set the sungem to GII now on 1000BT ?

	/* On non-aneg, we assume what we put in BMCR is the speed,

	 * though magic-aneg shouldn't prevent this case from occurring

/* On gigabit capable PHYs, we advertise Pause support but not asym pause

 * support for now as I'm not sure it's supported and Darwin doesn't do

 * it neither. --BenH.

 Broadcom BCM 5201 */

 Broadcom BCM 5221 */

 Broadcom BCM 5241 */

 Broadcom BCM 5400 */

 Broadcom BCM 5401 */

 Broadcom BCM 5411 */

 Broadcom BCM 5421 */

 Broadcom BCM 5421 built-in K2 */

 Broadcom BCM 5462 built-in Vesta */

 Marvell 88E1101 amd 88E1111 */

/* two revs in darwin for the 88e1101 ... I could use a datasheet

 * to get the proper names...

 Generic implementation for most 10/100 PHYs */

	/* We do not reset the mii_phy structure as the driver

	 * may re-probe the PHY regulary

 Take PHY out of isloate mode and reset it. */

 Read ID and find matching entry */

 Should never be NULL (we have a generic entry), but... */

 SPDX-License-Identifier: GPL-2.0-or-later

/* GTP according to GSM TS 09.60 / 3GPP TS 29.060

 *

 * (C) 2012-2014 by sysmocom - s.f.m.c. GmbH

 * (C) 2016 by Pablo Neira Ayuso <pablo@netfilter.org>

 *

 * Author: Harald Welte <hwelte@sysmocom.de>

 *	   Pablo Neira Ayuso <pablo@netfilter.org>

 *	   Andreas Schultz <aschultz@travelping.com>

 An active session for the subscriber. */

 One instance of the GTP device. */

 Resolve a PDP context structure based on the 64bit TID. */

 Resolve a PDP context structure based on the 32bit TEI. */

 Resolve a PDP context based on IPv4 address of MS. */

/* Check if the inner IP address in this packet is assigned to any

 * existing mobile subscriber.

 Get rid of the GTP + UDP headers. */

	/* Now that the UDP and the GTP header have been removed, set up the

	 * new network header. This is required by the upper layer to

	 * calculate the transport header.

 1 means pass up to the stack, -1 means drop and 0 means decapsulated. */

	/* From 29.060: "This field shall be present if and only if any one or

	 * more of the S, PN and E flags are set.".

	 *

	 * If any of the bit is set, then the remaining ones also have to be

	 * set.

 Make sure the header is larger enough, including extensions. */

/* UDP encapsulation receive handler. See net/ipv4/udp.c.

 * Return codes: 0: success, <0: error, >0: pass up to userspace UDP socket.

 Shouldn't happen. */

 v0, GTP-non-prime. */

	/* Bits    8  7  6  5  4  3  2	1

	 *	  +--+--+--+--+--+--+--+--+

	 *	  |version |PT| 0| E| S|PN|

	 *	  +--+--+--+--+--+--+--+--+

	 *	    0  0  1  1	1  0  0  0

 v1, GTP-non-prime. */

	/* TODO: Support for extension header, sequence number and N-PDU.

	 *	 Update the length field if any of them is available.

	/* Read the IP destination address and resolve the PDP context.

	 * Prepend PDP header with TEI/TID from PDP ctx.

 This is similar to tnl_update_pmtu(). */

 Ensure there is sufficient headroom. */

 PDP context lookups in gtp_build_skb_*() need rcu read-side lock. */

 Zero header length. */

 IFLA_GTP_PDP_HASHSIZE */

 IFLA_GTP_ROLE */

	/* Examine the link attributes and figure out which network namespace

	 * we are talking about.

 Check if there's an existing gtpX device to configure */

		/* According to TS 09.60, sections 7.5.1 and 7.5.2, the flow

		 * label needs to be the same for uplink and downlink packets,

		 * so let's annotate this.

		/* TS 09.60: "The flow label identifies unambiguously a GTP

		 * flow.". We use the tid for this instead, I cannot find a

		 * situation in which this doesn't unambiguosly identify the

		 * PDP context.

 SPDX-License-Identifier: GPL-2.0-only

 Virtio transport max packet size plus header */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  drivers/net/veth.c

 *

 *  Copyright (C) 2007 OpenVZ http://openvz.org, SWsoft Inc

 *

 * Author: Pavel Emelianov <xemul@openvz.org>

 * Ethtool interface from: Eric W. Biederman <ebiederm@xmission.com>

 *

 xdp */

 points to xdp_napi when the latter is initialized */

/*

 * ethtool interface

 general routines */

 Write ptr_ring before reading rx_notify_masked */

/* return true if the specified skb has chances of GRO aggregation

 * Don't strive for accuracy, but try to avoid GRO overhead in the most

 * common scenarios.

 * When XDP is enabled, all traffic is considered eligible, as the xmit

 * device has TSO off.

 * When TSO is enabled on the xmit device, we are likely interested only

 * in UDP aggregation, explicitly check for that if the skb is suspected

 * - the sock_wfree destructor is used by UDP, ICMP and XDP sockets -

 * to belong to locally generated UDP traffic.

		/* The napi pointer is available when an XDP program is

		 * attached or when GRO is enabled

		 * Don't bother with napi/GRO if the skb can't be aggregated

 fake multicast ability */

 Callers must be under RCU read side. */

	/* The napi pointer is set if NAPI is enabled, which ensures that

	 * xdp_ring is initialized on receive side and the peer device is up.

 xdp_ring is initialized on receive side? */

 frames array contains VETH_XDP_BATCH at most */

 SKB "head" area always have tailroom for skb_shared_info */

 check if bpf_xdp_adjust_head was used */

 check if bpf_xdp_adjust_tail was used */

 positive on grow, negative on shrink */

 ndo_xdp_xmit */

 XDP_PASS */

 ndo_start_xmit */

 Write rx_notify_masked before reading ptr_ring */

 Save original mem info as it can be overwritten */

				/* user-space did not require GRO, but adding XDP

				 * is supposed to get GRO working

		/* if user-space did not require GRO, since adding XDP

		 * enabled it, clear it now

		/* these channels are freshly initialized, napi is not on there even

		 * when GRO is requeste

 on error always delete the newly added napis */

 sanity check. Upper bounds are already enforced by the caller */

 avoid braking XDP, if that is enabled */

 turn device off */

 try to allocate new resurces, as needed*/

		/* this error condition could happen only if rx and tx change

		 * in opposite directions (e.g. tx nr raises, rx nr decreases)

		 * and we can't do anything to fully restore the original

		 * status

		/* note that we need to swap the arguments WRT the enable part

		 * to identify the range we have to disable

	/* veth only receives frames when its peer sends one

	 * Since it has nothing to do with disabling irqs, we are guaranteed

	 * never to have pending data when we poll for it so

	 * there is nothing to do here.

	 *

	 * We need this though so netpoll recognizes us as an interface that

	 * supports polling, which enables bridge devices in virt setups to

	 * still use netconsole

 CONFIG_NET_POLL_CONTROLLER */

/*

 * netlink interface

	/*

	 * create and register peer first

	/* keep GRO disabled by default to be consistent with the established

	 * veth behavior

	/*

	 * register dev last

	 *

	 * note, that since we've registered new device the dev's name

	 * should be re-allocated

	/*

	 * tie the deviced together

 nothing to do */

	/* Note : dellink() is called from default_device_exit_batch(),

	 * before a rcu_synchronize() point. The devices are guaranteed

	 * not being freed before one RCU grace period.

 enforce the same queue limit as rtnl_create_link */

/*

 * init/fini

 SPDX-License-Identifier: GPL-2.0-or-later

/* A network driver using virtio.

 *

 * Copyright 2007 Rusty Russell <rusty@rustcorp.com.au> IBM Corporation

#define DEBUG

 FIXME: MTU in config. */

 Amount of XDP headroom to prepend to packets for use by xdp_adjust_head */

 Separating two types of XDP xmit */

/* RX packet size EWMA. The average packet size is used to determine the packet

 * buffer size when refilling RX rings. As the entire RX ring may be refilled

 * at once, the weight is chosen so that the EWMA will be insensitive to short-

 * term, transient changes in packet size.

 Internal representation of a send virtqueue */

 Virtqueue associated with this send _queue */

 TX: fragments + linear part + virtio header */

 Name of the send queue: output.$index */

 Internal representation of a receive virtqueue */

 Virtqueue associated with this receive_queue */

 Chain pages by the private ptr. */

 Average packet length for mergeable receive buffers. */

 Page frag for packet buffer allocation. */

 RX: fragments + linear part + virtio header */

 Min single buffer size for mergeable buffers case. */

 Name of this receive queue: input.$index */

 Control VQ buffers: protected by the rtnl lock */

 Max # of queue pairs supported by the device */

 # of queue pairs currently used by the driver */

 # of XDP queue pairs currently used by the driver */

 xdp_queue_pairs may be 0, when xdp is already loaded. So add this. */

 I like... big packets and I cannot lie! */

 Host will merge rx buffers for big packets (shake it! shake it!) */

 Has control virtqueue */

 Host can handle any s/g split between our header and packet data */

 Packet virtio header size */

 Work struct for refilling if we run low on memory. */

 Work struct for config space updates */

 Does the affinity hint is set for virtqueues? */

 CPU hotplug instances for online & dead */

 Ethtool settings */

 failover when STANDBY feature enabled */

	/*

	 * hdr is in a separate sg buffer, and data sg buffer shares same page

	 * with this header sg. This padding makes next sg 16 byte aligned

	 * after the header.

/* Converting between virtqueue no. and kernel tx/rx queue no.

 * 0:rx0 1:tx0 2:rx1 3:tx1 ... 2N:rxN 2N+1:txN 2N+2:cvq

/*

 * private is used to chain pages for big packets, put the whole

 * most recent used list in the beginning for reuse

 Find end of list, sew whole thing into vi->rq.pages. */

 clear private here, it is used to chain pages */

 Suppress further interrupts. */

 We were probably waiting for more output buffers. */

 Called from bottom half context */

	/* If headroom is not 0, there is an offset between the beginning of the

	 * data and the allocated space, otherwise the data and the allocated

	 * space are aligned.

	 *

	 * Buffers with headroom use PAGE_SIZE as alloc size, see

	 * add_recvbuf_mergeable() + get_mergeable_buf_len()

 copy small packet so we can reuse these pages */

 copy small packet so we can reuse these pages for small data */

	/* Copy all frame if it fits skb->head, otherwise

	 * we let virtio_net_hdr_to_skb() and GRO pull headers as needed.

	/*

	 * Verify that we can indeed put this data into a skb.

	 * This is here to handle cases when the device erroneously

	 * tries to receive more than is possible. This is usually

	 * the case of a broken device.

 hdr_valid means no XDP, so we can copy the vnet header */

 Make room for virtqueue hdr (also change xdpf->headroom?) */

 Zero header and leave csum up to XDP layers */

 Caller handle free/refcnt */

/* when vi->curr_queue_pairs > nr_cpu_ids, the txq/sq is only used for xdp tx on

 * the current cpu, so it does not need to be locked.

 *

 * Here we use marco instead of inline functions because we have to deal with

 * three issues at the same time: 1. the choice of sq. 2. judge and execute the

 * lock/unlock of txq 3. make sparse happy. It is difficult for two inline

 * functions to perfectly solve these three problems at the same time.

	/* Only allow ndo_xdp_xmit if XDP is loaded on dev, as this

	 * indicate XDP resources have been successfully allocated.

 Free up any pending old buffers before queueing new ones. */

/* We copy the packet for XDP in the following cases:

 *

 * 1) Packet is scattered across multiple rx buffers.

 * 2) Headroom space is insufficient.

 *

 * This is inefficient but it's a temporary condition that

 * we hit right after XDP is enabled and until queue is refilled

 * with large buffers with sufficient headroom - so it should affect

 * at most queue size packets.

 * Afterwards, the conditions to enable

 * XDP should preclude the underlying device from sending packets

 * across multiple buffers (num_buf > 1), and we make sure buffers

 * have enough headroom.

		/* guard against a misconfigured or uncooperative backend that

		 * is sending packet larger than the MTU.

 Headroom does not contribute to packet length */

 Recalculate length in case bpf program changed it */

 keep zeroed vnet hdr since XDP is loaded */

		/* Transient failure which in theory could occur if

		 * in-flight packets from before XDP was enabled reach

		 * the receive path after XDP is loaded.

		/* Buffers with headroom use PAGE_SIZE as alloc size,

		 * see add_recvbuf_mergeable() + get_mergeable_buf_len()

		/* This happens when rx buffer size is underestimated

		 * or headroom is not enough because of the buffer

		 * was refilled before XDP is set. This should only

		 * happen for the first several packets, so we don't

		 * care much about its performance.

 linearize data for XDP */

		/* Allow consuming headroom but reserve enough space to push

		 * the descriptor on if we get an XDP_TX return code.

			/* recalculate offset to account for any header

			 * adjustments and minus the metasize to copy the

			 * metadata in page_to_skb(). Note other cases do not

			 * build an skb and avoid using offset

			/* recalculate len if xdp.data, xdp.data_end or

			 * xdp.data_meta were adjusted

 We can only create skb based on xdp_page. */

/* Unlike mergeable buffers, all buffers are allocated to the

 * same size, except for the headroom. For this reason we do

 * not need to use  mergeable_len_to_ctx here - it is enough

 * to store the headroom as the context ignoring the truesize.

 page in rq->sg[MAX_SKB_FRAGS + 1] is list tail */

 chain new page in list head to match sg */

 rq->sg[0], rq->sg[1] share the same page */

 a separated rq->sg[0] for header - required in case !any_header_sg */

 rq->sg[1] for data packet, from offset */

 chain first in list head */

	/* Extra tailroom is needed to satisfy XDP's assumption. This

	 * means rx frags coalescing won't work, but consider we've

	 * disabled GSO for XDP, it won't be a big issue.

 advance address leaving hole at front of pkt */

		/* To avoid internal fragmentation, if there is very likely not

		 * enough space for another buffer, add the remaining space to

		 * the current buffer.

/*

 * Returns false if we couldn't fill entirely (OOM).

 *

 * Normally run in the receive path, but can also be run from ndo_open

 * before we're receiving packets, or from refill_work which is

 * careful to disable receiving (using napi_disable).

	/* If all buffers were filled by other side before we napi_enabled, we

	 * won't get another interrupt, so process any outstanding packets now.

	 * Call local_bh_enable after to trigger softIRQ processing.

	/* Tx napi touches cachelines on the cpu handling tx interrupts. Only

	 * enable the feature if this is likely affine with the transmit path.

		/* In theory, this can happen: if we don't get any buffers in

		 * we will *never* try to fill again.

	/* Avoid overhead when no packets have been processed

	 * happens when called speculatively from start_xmit.

 Out of packets? */

 Make sure we have some buffers: if oom use wq. */

 We don't need to enable cb for XDP */

	/* Even if we can, don't push here yet as this would skew

 Pull header back to avoid skew in tx bytes calculations. */

 Free up any pending old buffers before queueing new ones. */

 timestamp packet in software */

 Try to transmit */

 This should not happen! */

 Don't wait up for transmitted skbs to be freed. */

	/* If running out of space, stop queue to avoid getting packets that we

	 * are then unable to transmit.

	 * An alternative would be to force queuing layer to requeue the skb by

	 * returning NETDEV_TX_BUSY. However, NETDEV_TX_BUSY should not be

	 * returned in a normal path of operation: it means that driver is not

	 * maintaining the TX queue stop/start state properly, and causes

	 * the stack to do a non-trivial amount of useless work.

	 * Since most packets only take 1 or 2 ring slots, stopping the queue

	 * early means 16 slots are typically wasted.

 More just got used, free them then recheck. */

/*

 * Send command via the control virtqueue and check status.  Commands

 * supported by the hypervisor, as indicated by feature bits, should

 * never fail unless improperly formatted.

 Caller should know better */

 Add header */

 Add return status. */

	/* Spin for a response, the kick causes an ioport write, trapping

	 * into the hypervisor, so the request should be handled immediately.

 Naturally, this has an atomicity problem. */

 virtnet_open() will refill when device is going to up. */

 Make sure refill_work doesn't re-enable napi! */

 We can't dynamically set ndo_set_rx_mode, so return gracefully */

 MAC filter - use one buffer for both lists */

 Store the unicast list and count in the front of the buffer */

 multicast list and count fill the end */

 TODO: Eliminate OOO packets during switching */

	/* We don't support separate rx/tx channels.

	 * We don't allow setting 'other' channels.

	/* For now we don't support modifying channels while XDP is loaded

	 * also when XDP is loaded all RX queues have XDP programs so we only

	 * need to check a single RX queue.

 Make sure no work handler is accessing the device */

 XDP requires extra queues for XDP_TX */

 Make sure NAPI is not using any XDP TX queues for RX. */

 Ignore unknown (future) status bits */

	/* We called __netif_napi_del(),

	 * we need to respect an RCU grace period before freeing vi->rq

/* How large should a single buffer be so a queue full of these can fit at

 * least one full packet?

 * Logic below assumes the mergeable buffer header is used.

	/* We expect 1 RX virtqueue followed by 1 TX virtqueue, followed by

	 * possible N-1 RX/TX queue pairs used in multiqueue mode, followed by

	 * possible control vq.

 Allocate space for find_vqs parameters */

 Parameters for control virtqueue, if any */

 Allocate/initialize parameters for send/receive virtqueues */

 run here: ret == 0. */

 Allocate send & receive queues */

 Find if host supports multiqueue virtio_net device */

 We need at least 2 queue's */

 Allocate ourselves a network device with room for our info */

 Set up network device as normal. */

 Do we support "hardware" checksums? */

 This opens up the world of extra features. */

 Individual feature bits: what can host handle? */

 (!csum && gso) case will be fixed by register_netdev() */

 MTU range: 68 - 65535 */

 Configuration may specify what MAC to use.  Otherwise random. */

 Set up our device-specific information */

 If we can receive ANY GSO packets, we must allocate large ones. */

			/* Should never trigger: MTU was previously validated

			 * in virtnet_validate.

 TODO: size buffers correctly in this case. */

 Enable multiqueue by default */

 Allocate/initialize the rx/tx queues, and invoke find_vqs */

	/* Assume link up if device can't report link status,

 Free unused buffers in both send and recv, if any. */

 Make sure no work handler is accessing the device. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * INET		An implementation of the TCP/IP protocol suite for the LINUX

 *		operating system.  INET is implemented using the  BSD Socket

 *		interface as the means of communication with the user level.

 *

 *		Holds initial configuration information for devices.

 *

 * Version:	@(#)Space.c	1.0.7	08/12/93

 *

 * Authors:	Ross Biro

 *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>

 *		Donald J. Becker, <becker@scyld.com>

 *

 * Changelog:

 *		Stephen Hemminger (09/2003)

 *		- get rid of pre-linked dev list, dynamic device allocation

 *		Paul Gortmaker (03/2002)

 *		- struct init cleanup, enable multiple ISA autoprobes.

 *		Arnaldo Carvalho de Melo <acme@conectiva.com.br> - 09/1999

 *		- fix sbni: s/device/net_device/

 *		Paul Gortmaker (06/98):

 *		 - sort probes in a sane way, make sure all (safe) probes

 *		   get run once & failed autoprobes don't autoprobe again.

/*

 * This structure holds boot-time configured netdevice settings. They

 * are then used in the device probing.

/******************************************************************************

 *

 *		      Device Boot-time Settings Routines

 *

 Boot time configuration table */

/**

 *	netdev_boot_setup_add	- add new setup entry

 *	@name: name of the device

 *	@map: configured settings for the device

 *

 *	Adds new setup entry to the dev_boot_setup list.  The function

 *	returns 0 on error and 1 on success.  This is a generic routine to

 *	all netdevices.

/**

 * netdev_boot_setup_check	- check boot time settings

 * @dev: the netdevice

 *

 * Check boot time settings for the device.

 * The found settings are set for the device to be used

 * later in the device probing.

 * Returns 0 if no settings found, 1 if they are.

/**

 * netdev_boot_base	- get address from boot time settings

 * @prefix: prefix for network device

 * @unit: id for network device

 *

 * Check boot time settings for the base address of device.

 * The found settings are set for the device to be used

 * later in the device probing.

 * Returns 0 if no settings found.

	/*

	 * If device already registered then return base of 1

	 * to indicate not to probe for this interface

/*

 * Saves at boot time configured settings for any netdevice.

 Save settings */

 Add new entry to the list */

/* A unified ethernet device probe.  This is the easiest way to have every

 * ethernet adaptor have the name "eth[0123...]".

 non-zero if autoprobe has failed */

/* ISA probes that touch addresses < 0x400 (including those that also

 * look for EISA/PCI cards in addition to ISA cards).

 ISA (use ne2k-pci for PCI cards) */

 ISA/VLB (use pcnet32 for PCI cards) */

/* Unified ethernet device probe, segmented per architecture and

 * per bus interface. This drives the legacy devices only for now.

  Statically configured drivers -- order matters here. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Xenbus code for netif backend

 *

 * Copyright (C) 2005 Rusty Russell <rusty@rustcorp.com.au>

 * Copyright (C) 2005 XenSource Ltd

 don't allow partial writes and check the length */

 CONFIG_DEBUG_FS */

/*

 * Handle the creation of the hotplug script environment.  We add the script

 * and vif variables to the environment, for the benefit of the vif-* hotplug

 * scripts.

 CONFIG_DEBUG_FS */

		/* At this point some of the handlers may still be active

		 * so we need to have additional synchronization here.

	/* If we are waiting for a hotplug script then defer the

	 * actual xenbus state change.

/* Handle backend state transitions:

 *

 * The backend state starts in Initialising and the following transitions are

 * allowed.

 *

 * Initialising -> InitWait -> Connected

 *          \

 *           \        ^    \         |

 *            \       |     \        |

 *             \      |      \       |

 *              \     |       \      |

 *               \    |        \     |

 *                \   |         \    |

 *                 V  |          V   V

 *

 *                  Closed  <-> Closing

 *

 * The state argument specifies the eventual state of the backend and the

 * function transitions to that state via the shortest path.

/*

 * Callback received when the frontend's state changes.

 if not online */

 Default to unlimited bandwidth. */

 Complete any pending state change */

 Not interested in this watch anymore. */

 The frontend does not have a control ring */

	/* Check whether the frontend requested multiple queues

	 * and read the number requested.

 buggy or malicious guest */

 Use the number of queues requested by the frontend */

			/* xenvif_init_queue() cleans up after itself on

			 * failure, but we need to clean up any previously

			 * initialised queues. Set num_queues to i so that

			 * earlier queues can be destroyed using the regular

			 * disconnect logic.

			/* connect_data_rings() cleans up after itself on

			 * failure, but we need to clean up after

			 * xenvif_init_queue() here, and also clean up any

			 * previously initialised queues.

 CONFIG_DEBUG_FS */

	/* Initialisation completed, tell core driver the number of

	 * active queues.

 Clean up existing queues */

 sufficient for "/queue-NNN" */

	/* If the frontend requested 1 queue, or we have fallen back

	 * to single queue due to lack of frontend support for multi-

	 * queue, expect the remaining XenStore keys in the toplevel

	 * directory. Otherwise, expect them in a subdirectory called

	 * queue-N.

 Try split event channels first, then single event channel. */

 Map the shared frame, irq etc. */

 Regular return falls through with err == 0 */

		/* - Reduce drain timeout to poll more frequently for

		 *   Rx requests.

		 * - Disable Rx stall detection.

/*

 * Entry point to this code when a new device is created.  Allocate the basic

 * structures and switch to InitWait.

 We support partial checksum setup for IPv6 packets */

 We support rx-copy path. */

 we can adjust a headroom for netfront XDP processing */

		/* We don't support rx-flip path (except old guests who

		 * don't grok this feature flag).

 We support dynamic multicast-control. */

	/* Split event channels support, this is optional so it is not

	 * put inside the above loop.

 Multi-queue support: This is an optional feature. */

 This kicks hotplug scripts, so do it immediately. */

/*

 * Copyright (c) 2016 Citrix Systems Inc.

 * Copyright (c) 2002-2005, K A Fraser

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License version 2

 * as published by the Free Software Foundation; or, when distributed

 * separately from the Linux kernel or incorporated into other

 * software packages, subject to the following license:

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this source file (the "Software"), to deal in the Software without

 * restriction, including without limitation the rights to use, copy, modify,

 * merge, publish, distribute, sublicense, and/or sell copies of the Software,

 * and to permit persons to whom the Software is furnished to do so, subject to

 * the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * all copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING

 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS

 * IN THE SOFTWARE.

		/* Make sure event is visible before we check prod

		 * again.

		/* If the copy failed, overwrite the status field in

		 * the corresponding response.

 Push responses for all completed packets. */

 frag == -1 => frag_iter->head */

 Reset packet state. */

 All responses are ready to be pushed. */

 Advance to next frag? */

 Extras must go after the first data slot */

 Flush any pending copies and complete all skbs. */

/* Wait until the guest Rx thread has work.

 *

 * The timeout needs to be adjusted based on the current head of the

 * queue (and not just the head at the beginning).  In particular, if

 * the queue is initially empty an infinite timeout is used and this

 * needs to be reduced when a skb is queued.

 *

 * This cannot be done with wait_event_timeout() because it only

 * calculates the timeout once.

 At least one queue has stalled? Disable the carrier. */

 Reset Rx stall detection. */

 All queues are ready? Enable the carrier. */

		/* This frontend is found to be rogue, disable it in

		 * kthread context. Currently this is only set when

		 * netback finds out frontend sends malformed packet,

		 * but we cannot disable the interface in softirq

		 * context so we defer it here, if this thread is

		 * associated with queue 0.

		/* If the guest hasn't provided any Rx slots for a

		 * while it's probably not responsive, drop the

		 * carrier so packets are dropped earlier.

		/* Queued packets may have foreign pages from other

		 * domains.  These cannot be queued indefinitely as

		 * this would starve guests of grant refs and transmit

		 * slots.

 Bin any remaining skbs */

/*

 * Back-end of the driver for virtual network devices. This portion of the

 * driver exports a 'unified' network-device interface that can be accessed

 * by any operating system that implements a compatible front end. A

 * reference front-end implementation can be found in:

 *  drivers/net/xen-netfront.c

 *

 * Copyright (c) 2002-2005, K A Fraser

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License version 2

 * as published by the Free Software Foundation; or, when distributed

 * separately from the Linux kernel or incorporated into other

 * software packages, subject to the following license:

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this source file (the "Software"), to deal in the Software without

 * restriction, including without limitation the rights to use, copy, modify,

 * merge, publish, distribute, sublicense, and/or sell copies of the Software,

 * and to permit persons to whom the Software is furnished to do so, subject to

 * the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * all copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING

 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS

 * IN THE SOFTWARE.

/* Provide an option to disable split event channels at load time as

 * event channels are limited resource. Split event channels are

 * enabled by default.

/* The time that packets can stay on the guest Rx internal queue

 * before they are dropped.

/* The length of time before the frontend is considered unresponsive

 * because it isn't providing Rx slots.

/*

 * This is the maximum slots a skb can have. If a guest sends a skb

 * which exceeds this limit it is considered malicious.

/* The amount to copy out of the first guest Tx slot into the skb's

 * linear area.  If the first slot has more data, it will be mapped

 * and put into the first frag.

 *

 * This is sized to avoid pulling headers from the frags for most

 * TCP/IP packets.

 This is the maximum number of flows in the hash cache. */

/* The module parameter tells that we have to put data

 * for xen-netfront with the XDP_PACKET_HEADROOM offset

 * needed for XDP processing

/* Find the containing VIF's structure from a pointer in pending_tx_info array

	/*

	 * Allow a burst big enough to transmit a jumbo packet of up to 128kB.

	 * Otherwise the interface can seize up due to insufficient credit.

 Take care that adding a new chunk of credit doesn't wrap to zero. */

 wrapped: clamp to ULONG_MAX */

 only the first frag can have extras */

 Disable the vif from queue 0's kthread */

		/* This guest is really using too many slots and

		 * considered malicious.

		/* Xen network protocol had implicit dependency on

		 * MAX_SKB_FRAGS. XEN_NETBK_LEGACY_SLOTS_MAX is set to

		 * the historical MAX_SKB_FRAGS value 18 to honor the

		 * same behavior as before. Any packet using more than

		 * 18 slots but less than fatal_skb_slots slots is

		 * dropped

		/* If the guest submitted a frame >= 64 KiB then

		 * first->size overflowed and following slots will

		 * appear to be larger than the frame.

		 *

		 * This cannot be fatal error as there are buggy

		 * frontends that do this.

		 *

		 * Consume all slots and drop the packet.

 Packets passed to netif_rx() must have some headroom. */

 Initialize it here to avoid later surprises */

 Skip first skb fragment if it is on same page as header fragment. */

	/* This always points to the shinfo of the skb being checked, which

	 * could be either the first or the one on the frag_list

	/* If this is non-NULL, we are currently checking the frag_list skb, and

	 * this points to the shinfo of the first one

 Check status of header. */

 The first frag might still have this slot mapped */

 Check error status: if okay then remember grant handle. */

 Had a previous error? Invalidate this fragment. */

				/* If the mapping of the first frag was OK, but

				 * the header's copy failed, and they are

				 * sharing a slot, send an error

 Error on this fragment: respond to client with an error. */

 Not the first error? Preceding frags already invalidated. */

		/* First error: if the header haven't shared a slot with the

		 * first frag, release it as well.

 Invalidate preceding fragments of this skb. */

		/* And if we found the error while checking the frag_list, unmap

		 * the first skb's frags

 Remember the error: invalidate all subsequent fragments. */

 If this is not the first frag, chain it to the previous*/

 Take an extra reference to offset network stack's put_page */

 gso_segs will be calculated later */

	/* A GSO SKB must be CHECKSUM_PARTIAL. However some buggy

	 * peers can fail to set NETRXF_csum_blank when sending a GSO

	 * frame. In this case force the SKB to CHECKSUM_PARTIAL and

	 * recalculate the partial checksum.

 A non-CHECKSUM_PARTIAL SKB does not require setup. */

 Timer could already be pending in rare cases. */

 Passed the point where we can replenish credit? */

 Still too big to send right now? Set a callback. */

/* No locking is required in xenvif_mcast_add/del() as they are

 * only ever invoked from NAPI poll. An RCU list is used because

 * xenvif_mcast_match() is called asynchronously, during start_xmit.

	/* No need for locking or RCU here. NAPI poll and TX queue

	 * are stopped.

 Ensure that we see the request before we copy it. */

 Credit-based scheduling. */

 No crossing a page as the payload mustn't fragment. */

		/* At this point shinfo->nr_frags is in fact the number of

		 * slots, which can be as large as XEN_NETBK_LEGACY_SLOTS_MAX.

 Failure in xenvif_set_skb_gso is fatal. */

/* Consolidate skb with a frag_list into a brand new one with local pages on

 * frags. Returns 0 or -ENOMEM if can't allocate new pages.

 Subtract frags size, we will correct it later */

 create a brand new frags array and coalesce there */

 Release all the original (foreign) frags. */

 increase inflight counter to offset decrement in callback */

 Fill the skb with the new (local) frags. */

 Check the remap error code. */

			/* If there was an error, xenvif_tx_check_gop is

			 * expected to release all the frags which were mapped,

			 * so kfree_skb shouldn't do it again

 Append the packet payload as a fragment. */

 Schedule a response immediately. */

 Copied all the bits from the frag list -- free it. */

 We have to set this flag to trigger the callback */

		/* If the packet is GSO then we will have just set up the

		 * transport header offset in checksum_setup so it's now

		 * straightforward to calculate gso_segs.

 GSO implies having the L4 header. */

		/* Set this flag right before netif_receive_skb, otherwise

		 * someone might think this packet already left netback, and

		 * do a skb_copy_ubufs while we are still in control of the

		 * skb. E.g. the __pskb_pull_tail earlier can do such thing.

	/* This is the only place where we grab this lock, to protect callbacks

	 * from each other.

		/* Sync with xenvif_tx_dealloc_action:

		 * insert idx then incr producer.

 Free up any grants we have finished using */

		/* Ensure we see all indices enqueued by all

		 * xenvif_zerocopy_callback().

 Called after netfront has transmitted */

	/* Release the pending index before pusing the Tx response so

	 * its available before a new Tx request is pushed by the

	 * frontend.

	/* Dealloc thread must remain running until all inflight

	 * packets complete.

 Unmap anything remaining*/

 Make sure we can see requests before we process them. */

	/* Allow as many queues as there are CPUs but max. 8 if user has not

	 * specified a value.

 CONFIG_DEBUG_FS */

 CONFIG_DEBUG_FS */

/*

 * Copyright (c) 2016 Citrix Systems Inc.

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License version 2

 * as published by the Free Softare Foundation; or, when distributed

 * separately from the Linux kernel or incorporated into other

 * software packages, subject to the following license:

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this source file (the "Software"), to deal in the Software without

 * restriction, including without limitation the rights to use, copy, modify,

 * merge, publish, distribute, sublicense, and/or sell copies of the Software,

 * and to permit persons to whom the Software is furnished to do so, subject to

 * the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * all copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING

 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS

 * IN THE SOFTWARE.

 Make sure we don't add duplicate entries */

	/* Quick rejection test: If the network protocol doesn't

	 * correspond to any enabled hash type then there's no point

	 * in parsing the packet header.

 Clear any remaining key octets */

 CONFIG_DEBUG_FS */

/*

 * Network-device interface management.

 *

 * Copyright (c) 2004-2005, Keir Fraser

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License version 2

 * as published by the Free Software Foundation; or, when distributed

 * separately from the Linux kernel or incorporated into other

 * software packages, subject to the following license:

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this source file (the "Software"), to deal in the Software without

 * restriction, including without limitation the rights to use, copy, modify,

 * merge, publish, distribute, sublicense, and/or sell copies of the Software,

 * and to permit persons to whom the Software is furnished to do so, subject to

 * the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * all copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING

 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS

 * IN THE SOFTWARE.

 Number of bytes allowed on the internal guest Rx queue. */

/* This function is used to set SKBFL_ZEROCOPY_ENABLE as well as

 * increasing the inflight counter. We need to increase the inflight

 * counter because core driver calls into xenvif_zerocopy_callback

 * which calls xenvif_skb_zerocopy_complete.

	/* Wake the dealloc thread _after_ decrementing inflight_packets so

	 * that if kthread_stop() has already been called, the dealloc thread

	 * does not wait forever with nothing to wake it.

	/* This vif is rogue, we pretend we've there is nothing to do

	 * for this vif to deschedule it from NAPI. But this interface

	 * will be turned off in thread context later.

		/* If the queue is rate-limited, it shall be

		 * rescheduled in the timer callback.

	/* If queues are not set up internally - always return 0

	/* Drop the packet if queues are not set up.

	 * This handler should be called inside an RCU read section

	 * so we don't need to enter it here explicitly.

 Obtain the queue to be used to transmit this packet */

 Drop the packet if queue is not ready */

	/* If there is no hash algorithm configured then make sure there

	 * is no hash information in the socket buffer otherwise it

	 * would be incorrectly forwarded to the frontend.

 Aggregate tx and rx stats from each queue */

	/* If (sent != success + fail), there are probably packets never

	 * freed up properly!

	/* Number of packets exceeding MAX_SKB_FRAG slots. You should use

	 * a guest with the same MAX_SKB_FRAG

	/* Allocate a netdev with the max. supported number of queues.

	 * When the guest selects the desired number, it will be updated

	 * via netif_set_real_num_*_queues().

 Start out with no queues. */

	/*

	 * Initialise a dummy MAC address. We choose the numerically

	 * largest non-broadcast address to prevent the address getting

	 * stolen by an Ethernet bridge for STP purposes.

	 * (FE:FF:FF:FF:FF:FF)

	/* If ballooning is disabled, this will consume real memory, so you

	 * better enable it. The long term solution would be to use just a

	 * bunch of valid page descriptors, without dependency on ballooning

	/*

	 * Take a reference to the task in order to prevent it from being freed

	 * if the thread function returns before kthread_stop is called.

 feature-split-event-channels == 0 */

 feature-split-event-channels == 1 */

 discard queued packets */

/* Reverse the relevant parts of xenvif_init_queue().

 * Used for queue teardown from xenvif_free(), and on the

 * error handling paths in xenbus.c:connect().

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * rrunner.c: Linux driver for the Essential RoadRunner HIPPI board.

 *

 * Copyright (C) 1998-2002 by Jes Sorensen, <jes@wildopensource.com>.

 *

 * Thanks to Essential Communication for providing us with hardware

 * and very comprehensive documentation without which I would not have

 * been able to write this driver. A special thank you to John Gibbon

 * for sorting out the legal issues, with the NDA, allowing the code to

 * be released under the GPL.

 *

 * Thanks to Jayaram Bhat from ODS/Essential for fixing some of the

 * stupid bugs in my code.

 *

 * Softnet support and various other patches from Val Henson of

 * ODS/Essential.

 *

 * PCI DMA mapping code partly based on work by Francois Romieu.

/*

 * Implementation notes:

 *

 * The DMA engine only allows for DMA within physical 64KB chunks of

 * memory. The current approach of the driver (and stack) is to use

 * linear blocks of memory for the skbuffs. However, as the data block

 * is always the first part of the skb and skbs are 2^n aligned so we

 * are guarantted to get the whole block within one 64KB align 64KB

 * chunk.

 *

 * On the long term, relying on being able to allocate 64KB linear

 * chunks of memory is not feasible and the skb handling code and the

 * stack will need to know about I/O vectors or something similar.

 display version info if adapter is found */

 set display flag to TRUE so that */

 we only display this string ONCE */

	/*

	 * Remap the MMIO regs into kernel space.

	/*

	 * Don't access any register before this point!

	/*

	 * Need to add a case for little-endian 64-bit hosts here.

/*

 * Commands are considered to be slow, thus there is no reason to

 * inline this.

	/*

	 * This is temporary - it will go away in the final version.

	 * We probably also want to make this function inline.

/*

 * Reset the board in a sensible manner. The NIC is already halted

 * when we get here and a spin-lock is held.

	/*

	 * Don't worry, this is just black magic.

/*

 * Why 32 ? is this not cache line size dependent?

/*

 * Read a string from the EEPROM.

/*

 * Shortcut to read one word (4 bytes) out of the EEPROM and convert

 * it to our CPU byte-order.

/*

 * Write a string to the EEPROM.

 *

 * This is only called when the firmware is not running.

		/*

		 * Only try to write the data if it is not the same

		 * value already.

	/*

	 * Read the hardware address from the eeprom.  The HW address

	 * is not really necessary for HIPPI but awfully convenient.

	 * The pointer arithmetic to put it in dev_addr is ugly, but

	 * Donald Becker does it this way for the GigE version of this

	 * card and it's shorter and more portable than any

	 * other method I've seen.  -VAL

	/*

	 * Set dirty_tx before we start receiving interrupts, otherwise

	 * the interrupt handler might think it is supposed to process

	 * tx ints before we are up and running, which may cause a null

	 * pointer access in the int handler.

 Tuning values */

		/*

		 * Sanity test to see if we conflict with the DMA

		 * limitations of the Roadrunner.

	/*

	 * Now start the FirmWare.

	/*

	 * Give the FirmWare time to chew on the `get running' command.

	/*

	 * We might have gotten here because we are out of memory,

	 * make sure we release everything we allocated before failing

/*

 * All events are considered to be slow (RX/TX ints do not generate

 * events) and are handled here, outside the main interrupt handler,

 * to reduce the size of the handler.

		/*

		 * TX events.

		/*

		 * RX events.

			/* Label packet to be dropped.

			 * Actual dropping occurs in rx

			 * handling.

			 *

			 * The index of packet we get to drop is

			 * the index of the packet following

			 * the bad packet. -kbf

 send it up */

	/*

	 * Order here is important.  We must handle events

	 * before doing anything else in order to catch

	 * such things as LLRC errors, etc -kbf

			/* Due to occational firmware TX producer/consumer out

			 * of sync. error need to check entry in ring -kbf

	/* Set the timer to switch to check for link beat and perhaps switch

 5 sec. watchdog */

	/*

	 * Lock to make sure we are not cleaning up while another CPU

	 * is handling interrupts.

	/*

	 * We probably need to deal with tbusy here to prevent overruns.

	/*

	 * We don't need the lock before we are actually going to start

	 * fiddling with the control blocks.

 include IFIELD */

/*

 * Read the firmware out of the EEPROM and put it into the SRAM

 * (or from user space - later)

 *

 * This operation requires the NIC to be halted and is performed with

 * interrupts disabled and with the spinlock hold.

	/*

	 * First wipe the entire SRAM, otherwise we might run into all

	 * kinds of trouble ... sigh, this took almost all afternoon

	 * to track down ;-(

/*

 * Routines to compress and uncompress tcp packets (for transmission

 * over low speed serial lines).

 *

 * Copyright (c) 1989 Regents of the University of California.

 * All rights reserved.

 *

 * Redistribution and use in source and binary forms are permitted

 * provided that the above copyright notice and this paragraph are

 * duplicated in all such forms and that any documentation,

 * advertising materials, and other materials related to such

 * distribution and use acknowledge that the software was developed

 * by the University of California, Berkeley.  The name of the

 * University may not be used to endorse or promote products derived

 * from this software without specific prior written permission.

 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR

 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED

 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

 *

 *	Van Jacobson (van@helios.ee.lbl.gov), Dec 31, 1989:

 *	- Initial distribution.

 *

 *

 * modified for KA9Q Internet Software Package by

 * Katie Stevens (dkstevens@ucdavis.edu)

 * University of California, Davis

 * Computing Services

 *	- 01-31-90	initial adaptation (from 1.19)

 *	PPP.05	02-15-90 [ks]

 *	PPP.08	05-02-90 [ks]	use PPP protocol field to signal compression

 *	PPP.15	09-90	 [ks]	improve mbuf handling

 *	PPP.16	11-02	 [karn]	substantially rewritten to use NOS facilities

 *

 *	- Feb 1991	Bill_Simpson@um.cc.umich.edu

 *			variable number of conversation slots

 *			allow zero or one slots

 *			separate routines

 *			status display

 *	- Jul 1994	Dmitry Gorodchanin

 *			Fixes for memory leaks.

 *      - Oct 1994      Dmitry Gorodchanin

 *                      Modularization.

 *	- Jan 1995	Bjorn Ekwall

 *			Use ip_fast_csum from ip.h

 *	- July 1995	Christos A. Polyzols

 *			Spotted bug in tcp option checking

 *

 *

 *	This module is a difficult issue. It's clearly inet code but it's also clearly

 *	driver code belonging close to PPP and SLIP

 Entire module is for IP only */

/* Allocate compression data structure

 *	slots must be in range 0 to 255 (zero meaning no compression)

 * Returns pointer to structure or ERR_PTR() on error.

	/*

	 * don't accept any packets with implicit index until we get

	 * one with an explicit index.  Otherwise the uncompress code

	 * will try to use connection 255, which is almost certainly

	 * out of range

 Free a compression data structure */

 Put a short in host order into a char array in network order */

 Encode a number */

 Pull a 16-bit integer in host order from buffer in network byte order */

 Decode a number */

 pull16 returns -1 on error */

 -1 if PULLCHAR returned error */

/*

 * icp and isize are the original packet.

 * ocp is a place to put a copy if necessary.

 * cpp is initially a pointer to icp.  If the copy is used,

 *    change it to ocp.

	/*

	 *	Don't play with runt packets.

 Bail if this packet isn't TCP, or is an IP fragment */

 Send as regular IP */

	/*  Bail if the TCP packet isn't `compressible' (i.e., ACK isn't set or

	 *  some other control bit is set). Also uncompressible if

	 *  it's a runt.

 TCP connection stuff; send as regular IP */

	/*

	 * Packet is compressible -- we're going to send either a

	 * COMPRESSED_TCP or UNCOMPRESSED_TCP packet.  Either way,

	 * we need to locate (or create) the connection state.

	 *

	 * States are kept in a circularly linked list with

	 * xmit_oldest pointing to the end of the list.  The

	 * list is kept in lru order by moving a state to the

	 * head of the list whenever it is referenced.  Since

	 * the list is short and, empirically, the connection

	 * we want is almost always near the front, we locate

	 * states via linear search.  If we don't find a state

	 * for the datagram, the oldest state is (re-)used.

 if current equal oldest, at end of list */

	/*

	 * Didn't find it -- re-use oldest cstate.  Send an

	 * uncompressed packet that tells the other side what

	 * connection number we're using for this conversation.

	 *

	 * Note that since the state list is circular, the oldest

	 * state points to the newest and we only need to set

	 * xmit_oldest to update the lru linkage.

	/*

	 * Found it -- move to the front on the connection list.

 found at most recently used */

 found at least recently used */

 more than 2 elements */

	/*

	 * Make sure that only what we expect to change changed.

	 * Check the following:

	 * IP protocol version, header length & type of service.

	 * The "Don't fragment" bit.

	 * The time-to-live field.

	 * The TCP header length.

	 * IP options, if any.

	 * TCP options, if any.

	 * If any of these things are different between the previous &

	 * current datagram, we send the current datagram `uncompressed'.

	/*

	 * Figure out which of the changing fields changed.  The

	 * receiver expects changes in the order: urgent, window,

	 * ack, seq (the order minimizes the number of temporaries

	 * needed in this section of code).

		/* argh! URG not set but urp changed -- a sensible

		 * implementation should never do this but RFC793

		 * doesn't prohibit the change so we have to deal

	case 0:	/* Nothing changed. If this packet contains data and the

		 * last one didn't, this is probably a data packet following

		 * an ack (normal on an interactive connection) and we send

		 * it compressed.  Otherwise it's probably a retransmit,

		 * retransmitted ack or window probe.  Send it uncompressed

		 * in case the other side missed the compressed version.

		/* actual changes match one of our special case encodings --

		 * send packet uncompressed.

 special case for echoed terminal traffic */

 special case for data xfer */

	/* Grab the cksum before we overwrite it below.  Then update our

	 * state with this packet's header.

	/* We want to use the original packet as our compressed packet.

	 * (cp - new_seq) is the number of bytes we need for compressed

	 * sequence numbers.  In addition we need one byte for the change

	 * mask, one for the connection id and two for the tcp checksum.

	 * So, (cp - new_seq) + 4 bytes of header are needed.

 deltaS is now the size of the change section of the compressed header */

 Write list of deltas */

	/* Update connection state cs & send uncompressed packet (i.e.,

	 * a regular ip/tcp packet but with the 'conversation id' we hope

	 * to use on future compressed packets in the protocol field).

 We've got a compressed packet; read the change byte */

		/* Make sure the state index is in range, then grab the state.

		 * If we have a good state index, clear the 'discard' flag.

 Read conn index */

 Check if the cstate is initialized */

		/* this packet has an implicit state index.  If we've

		 * had a line error since the last time we got an

/*

 * we can use the same number for the length of the saved header and

 * the current one, because the packet wouldn't have been sent

 * as compressed unless the options were the same as the previous one

 Echoed terminal traffic */

 Unidirectional data */

	/*

	 * At this point, cp points to the first byte of data in the

	 * packet.  Put the reconstructed TCP and IP headers back on the

	 * packet.  Recalculate IP checksum (but not TCP checksum).

 The packet is shorter than a legal IP header */

 Peek at the IP header's IHL field to find its length */

 The IP header length field is too small */

 Bad IP header checksum; discard */

 Update local state */

	/* Put headers back on packet

	 * Neither header checksum is recalculated

 CONFIG_INET */

 CONFIG_INET */

 VJ header compression */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * slip.c	This module implements the SLIP protocol for kernel-based

 *		devices like TTY.  It interfaces between a raw TTY, and the

 *		kernel's INET protocol layers.

 *

 * Version:	@(#)slip.c	0.8.3	12/24/94

 *

 * Authors:	Laurence Culhane, <loz@holmes.demon.co.uk>

 *		Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>

 *

 * Fixes:

 *		Alan Cox	: 	Sanity checks and avoid tx overruns.

 *					Has a new sl->mtu field.

 *		Alan Cox	: 	Found cause of overrun. ifconfig sl0

 *					mtu upwards. Driver now spots this

 *					and grows/shrinks its buffers(hack!).

 *					Memory leak if you run out of memory

 *					setting up a slip driver fixed.

 *		Matt Dillon	:	Printable slip (borrowed from NET2E)

 *	Pauline Middelink	:	Slip driver fixes.

 *		Alan Cox	:	Honours the old SL_COMPRESSED flag

 *		Alan Cox	:	KISS AX.25 and AXUI IP support

 *		Michael Riepe	:	Automatic CSLIP recognition added

 *		Charles Hedrick :	CSLIP header length problem fix.

 *		Alan Cox	:	Corrected non-IP cases of the above.

 *		Alan Cox	:	Now uses hardware type as per FvK.

 *		Alan Cox	:	Default to 192.168.0.0 (RFC 1597)

 *		A.N.Kuznetsov	:	dev_tint() recursion fix.

 *	Dmitry Gorodchanin	:	SLIP memory leaks

 *      Dmitry Gorodchanin      :       Code cleanup. Reduce tty driver

 *                                      buffering from 4096 to 256 bytes.

 *                                      Improving SLIP response time.

 *                                      CONFIG_SLIP_MODE_SLIP6.

 *                                      ifconfig sl? up & down now works

 *					correctly.

 *					Modularization.

 *              Alan Cox        :       Oops - fix AX.25 buffer lengths

 *      Dmitry Gorodchanin      :       Even more cleanups. Preserve CSLIP

 *                                      statistics. Include CSLIP code only

 *                                      if it really needed.

 *		Alan Cox	:	Free slhc buffers in the right place.

 *		Alan Cox	:	Allow for digipeated IP over AX.25

 *		Matti Aarnio	:	Dynamic SLIP devices, with ideas taken

 *					from Jim Freeman's <jfree@caldera.com>

 *					dynamic PPP devices.  We do NOT kfree()

 *					device entries, just reg./unreg. them

 *					as they are needed.  We kfree() them

 *					at module cleanup.

 *					With MODULE-loading ``insmod'', user

 *					can issue parameter:  slip_maxdev=1024

 *					(Or how much he/she wants.. Default

 *					is 256)

 *	Stanislav Voronyi	:	Slip line checking, with ideas taken

 *					from multislip BSDI driver which was

 *					written by Igor Chechik, RELCOM Corp.

 *					Only algorithms have been ported to

 *					Linux SLIP driver.

 *	Vitaly E. Lavrov	:	Sane behaviour on tty hangup.

 *	Alexey Kuznetsov	:	Cleanup interfaces to tty & netdevice

 *					modules.

/********************************

*  Buffer administration routines:

*	sl_alloc_bufs()

*	sl_free_bufs()

*	sl_realloc_bufs()

*

* NOTE: sl_realloc_bufs != sl_free_bufs + sl_alloc_bufs, because

*	sl_realloc_bufs provides strong atomicity and reallocation

*	on actively running device.

/*

   Allocate channel buffers.

	/*

	 * Allocate the SLIP frame buffers:

	 *

	 * rbuff	Receive buffer.

	 * xbuff	Transmit buffer.

	 * cbuff        Temporary compression buffer.

	/*

	 * allow for arrival of larger UDP packets, even if we say not to

	 * also fixes a bug in which SunOS sends 512-byte packets even with

	 * an MSS of 128

 Cleanup */

 Free a SLIP channel buffers. */

 Free all SLIP frame buffers. */

/*

   Reallocate slip channel buffers.

/*

 * allow for arrival of larger UDP packets, even if we say not to

 * also fixes a bug in which SunOS sends 512-byte packets even with

 * an MSS of 128

 Set the "sending" flag.  This must be atomic hence the set_bit. */

 Clear the "sending" flag.  This must be atomic, hence the ASM. */

 Send one completely decapsulated IP datagram to the IP layer. */

 ignore compressed packets when CSLIP is off */

			/* make sure we've reserved enough space for uncompress

 turn on header compression */

 SL_INCLUDE_CSLIP */

 Encapsulate one IP datagram and stuff into a TTY queue. */

 Sigh, shouldn't occur BUT ... */

	/* Order of next two lines is *very* important.

	 * When we are sending a little amount of data,

	 * the transfer may be completed inside the ops->write()

	 * routine, because it's running with interrupts enabled.

	 * In this case we *never* got WRITE_WAKEUP event,

	 * if we did not request it before write operation.

	 *       14 Oct 1994  Dmitry Gorodchanin.

 VSV */

 reset outfill flag */

 Write out any remaining transmit buffer. Scheduled when tty is writable */

 First make sure we're connected. */

		/* Now serial buffer is almost free & we can start

/*

 * Called by the driver when there's room for more data.

 * Schedule the transmit.

		/* May be we must check transmitter timeout here ?

		 *      14 Oct 1994 Dmitry Gorodchanin.

 20 sec timeout not reached */

 Encapsulate an IP datagram and kick it into a TTY queue. */

/******************************************

 *   Routines looking at netdevice side.

 Netdevice UP -> DOWN routine */

 TTY discipline is running. */

 Netdevice DOWN -> UP routine */

 Netdevice change MTU request */

 Netdevice get statistics request */

 Generic compressed statistics */

 Are we really still needs this? */

 Netdevice register callback */

	/*

	 *	Finish setting up the DEVICE info.

 Hook the destructor so we can free slip devices at the right point in time */

 MTU range: 68 - 65534 */

 New-style flags. */

/******************************************

  Routines looking at TTY side.

/*

 * Handle the 'receiver data ready' interrupt.

 * This function is called by the 'tty_io' module in the kernel when

 * a block of SLIP data has been received, which can now be decapsulated

 * and sent on to some IP layer for further processing. This will not

 * be re-entered while running but other ldisc functions may be called

 * in parallel

 Read the characters out of the buffer */

/************************************

 *  slip_open helper routines.

 Collect hanged up channels */

 Find a free SLIP channel, and link in this `tty' line. */

 Sorry, too many, all slots in use */

 Initialize channel control data */

 initialize timer_list struct */

/*

 * Open the high-level part of the SLIP channel.

 * This function is called by the TTY module when the

 * SLIP line discipline is called for.  Because we are

 * sure the tty line exists, we only have to link it to

 * a free SLIP channel...

 *

 * Called in process context serialized from other ldisc calls.

	/* RTnetlink lock is misused here to serialize concurrent

	   opens of slip channels. There are better ways, but it is

	   the simplest one.

 Collect hanged up channels. */

 First make sure we're not already connected. */

 OK.  Find a free SLIP channel to use. */

 Perform the low-level SLIP initialization. */

 Done.  We have linked the TTY line to a channel. */

 We don't flow control */

 TTY layer expects 0 on success */

 do not call free_netdev before rtnl_unlock */

 Count references from TTY module */

/*

 * Close down a SLIP channel.

 * This means flushing out any pending queues, and then returning. This

 * call is serialized against other ldisc functions.

 *

 * We also use this method fo a hangup event

 First make sure we're connected. */

 VSV = very important to remove timers */

 Flush network side */

 This will complete via sl_free_netdev */

 /************************************************************************

  *			STANDARD SLIP ENCAPSULATION		  	 *

	/*

	 * Send an initial END character to flush out any

	 * data that may have accumulated in the receiver

	 * due to line noise.

	/*

	 * For each byte in the packet, send the appropriate

	 * character sequence, according to the SLIP protocol.

 drop keeptest bit = VSV */

/************************************************************************

 *			 6 BIT SLIP ENCAPSULATION			*

	/*

	 * Send an initial END character to flush out any

	 * data that may have accumulated in the receiver

	 * due to line noise.

	/*

	 * Encode the packet into printable ascii characters

 drop keeptest bit = VSV */

 CONFIG_SLIP_MODE_SLIP6 */

 Perform I/O control on an active SLIP channel. */

 First make sure we're connected. */

 return -EINVAL; */

 VSV changes start here */

 max for unchar */

 max for unchar */

 VSV changes end */

 VSV changes start here */

/* function sl_siocdevprivate called from net/core/dev.c

   to allow get/set outfill/keepalive parameter

 Allocation failed ?? */

 max for unchar */

 max for unchar */

		/* Resolve race condition, when ioctl'ing hanged up

		   and opened by another process device.

 VSV changes end */

 Sanity */

 Fill in our line protocol discipline, and register it */

	/* First of all: check for active disciplines and hangup them.

	/* FIXME: hangup is async so we should wait when doing this second

/*

 * This is start of the code for multislip style line checking

 * added by Stanislav Voronyi. All changes before marked VSV

 no packets were transmitted, do outfill */

 put END into tty queue. Is it right ??? */

 if device busy no outfill */

 keepalive still high :(, we must hangup */

 outfill timer must be deleted too */

 this must hangup tty & close slip */

 I think we need not something else */

 SPDX-License-Identifier: GPL-2.0-or-later

/* Copyright (c) 2014 Mahesh Bandewar <maheshb@google.com>

 New mode is L3S */

 Old mode was L3S */

 Undo the flags changes that have been done so far. */

 NETIF_F_GSO_ENCAP_ALL NETIF_F_GSO_SOFTWARE Newly added */

		/* Turn-on broadcast bit irrespective of address family,

		 * since broadcast is deferred to a work-queue, hence no

		 * impact on fast-path processing.

 u32 values are updated without syncp protection. */

	/* TODO Probably use a different field than dev_addr so that the

	 * mac-address on the virtual device is portable and can be carried

	 * while the packets use the mac-addr on the physical device.

 both ipvlan and ipvtap devices use the same netdev_ops */

 IFLA_IPVLAN_MODE */

 IFLA_IPVLAN_FLAGS */

 Only two bits are used at this moment. */

 Also both flags can't be active at the same time. */

 Exit early if the underlying link is invalid or busy */

	/* TODO Probably put random address here to be presented to the

	 * world but keep using the physical-dev address for the outgoing

	 * packets.

 ipvlan_init() would have created the port, if required */

	/* If the port-id base is at the MAX value, then wrap it around and

	 * begin from 0x1 again. This may be due to a busy system where lots

	 * of slaves are getting created and deleted.

	/* Since L2 address is shared among all IPvlan slaves including

	 * master, use unique 16 bit dev-ids to diffentiate among them.

	 * Assign IDs between 0x1 and 0xFFFE (used by the master) to each

	 * slave link [see addrconf_ifid_eui48()].

 Increment id-base to the next slot for the future assignment */

	/* Flags are per port and latest update overrides. User has

	 * to be consistent in setting it just like the mode attribute.

 Forbid underlying device to change its type. */

 the caller must held the addrs lock */

	/* If the interface is not up, the address will be added to the hash

	 * list by ipvlan_open.

 SPDX-License-Identifier: GPL-2.0-or-later

/* Copyright (c) 2014 Mahesh Bandewar <maheshb@google.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/* Copyright (c) 2014 Mahesh Bandewar <maheshb@google.com>

 Only Neighbour Solicitation pkts need different treatment */

 Need to access the ipv6 address in body */

 If the packet originated here, send it out. */

	/* Only packets exchanged between two local slaves need to have

	 * device-up check as well as skb-share check.

		/* Make sure that the NeighborSolicitation ICMPv6 packets

		 * are handled to avoid DAD issue.

	/* The ipvlan is a pseudo-L2 device, so the packets that we receive

	 * will have L2; which need to discarded and processed further

	 * in the net-ns of the main-device.

		/* In this mode we dont care about

	/* Record that the deferred packet is from TX or RX path. By

	 * looking at mac-addresses on packet will lead to erronus decisions.

	 * (This would be true for a loopback-mode on master device or a

	 * hair-pin mode of the switch.)

		/* Packet definitely does not belong to any of the

		 * virtual devices, but the dest is local. So forward

		 * the skb for the main-dev. At the RX side we just return

		 * RX_PASS for it to be processed further on the stack.

 Should not reach here */

			/* External frames are queued for device local

			 * distribution, but a copy is given to master

			 * straight away to avoid sending duplicates later

			 * when work-queue processes this frame. This is

			 * achieved by returning RX_HANDLER_PASS.

 Perform like l3 mode for non-multicast packet */

 Should not reach here */

 SPDX-License-Identifier: GPL-2.0-only

	/* Since macvlan supports all offloads by default, make

	 * tap support all offloads also.

	/* Don't put anything that may fail after macvlan_common_newlink

	 * because we can't undo what it does.

		/* Create the device node here after the network device has

		 * been registered but before register_netdevice has

		 * finished running.

 vlan->minor == 0 if NETDEV_REGISTER above failed */

 SPDX-License-Identifier: GPL-2.0

/* MOXA ART Ethernet (RTL8201CP) MDIO interface driver

 *

 * Copyright (C) 2013 Jonas Jensen <jonas.jensen@gmail.com>

 REG_PHY_CTRL */

 init write sequence (auto cleared)*/

 REG_PHY_WRITE_DATA */

	/* Setting PHY_MAC_INTERRUPT here even if it has no effect,

	 * of_mdiobus_register() sets these PHY_POLL.

	 * Ideally, the interrupt from MAC controller could be used to

	 * detect link state changes, not polling, i.e. if there was

	 * a way phy_driver could set PHY_HAS_INTERRUPT but have that

	 * interrupt handled in ethernet drivercode.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2009-2016 Cavium, Inc.

		/* If it is not an OF node we cannot handle it yet, so

		 * exit the loop.

 End of table. */

 SPDX-License-Identifier: GPL-2.0

/*

 * MDIO I2C bridge

 *

 * Copyright (C) 2015-2016 Russell King

 *

 * Network PHYs can appear on I2C buses when they are part of SFP module.

 * This driver exposes these PHYs to the networking PHY code, allowing

 * our PHY drivers access to these PHYs, and so allowing configuration

 * of their settings.

/*

 * I2C bus addresses 0x50 and 0x51 are normally an EEPROM, which is

 * specified to be present in SFP modules.  These correspond with PHY

 * addresses 16 and 17.  Disallow access to these "phy" addresses.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2016 Broadcom

 Disable external mdio master access */

		/* use rate adjust regs to derive the mdio's operating

		 * frequency from the specified core clock

/* start_miim_ops- Program and start MDIO transaction over mdio bus.

 * @base: Base address

 * @phyid: phyid of the selected bus.

 * @reg: register offset to be read/written.

 * @val :0 if read op else value to be written in @reg;

 * @op: Operation that need to be carried out.

 *      MDIO_CTRL_READ_OP: Read transaction.

 *      MDIO_CTRL_WRITE_OP: Write transaction.

 *

 * Return value: Successful Read operation returns read reg values and write

 *      operation returns 0. Failure operation returns negative error code.

 Write val at reg offset */

 select bus and its properties */

		/* For backward compatibility in case the

		 * base address is specified with an offset.

 SPDX-License-Identifier: GPL-2.0+

/* MDIO bus multiplexer using kernel multiplexer subsystem

 *

 * Copyright 2019 NXP

/**

 * mdio_mux_multiplexer_switch_fn - This function is called by the mdio-mux

 *                                  layer when it thinks the mdio bus

 *                                  multiplexer needs to switch.

 * @current_child:  current value of the mux register.

 * @desired_child: value of the 'reg' property of the target child MDIO node.

 * @data: Private data used by this switch_fn passed to mdio_mux_init function

 *        via mdio_mux_init(.., .., .., .., data, ..).

 *

 * The first time this function is called, current_child == -1.

 * If current_child == desired_child, then the mux is already set to the

 * correct bus.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2009-2016 Cavium, Inc.

 MDIO_CLAUSE_45_ADDRESS */

		/* Wait 1000 clocks so we don't saturate the RSL bus

		 * doing reads.

 MDIO_CLAUSE_22_READ */

 MDIO_CLAUSE_45_READ */

		/* Wait 1000 clocks so we don't saturate the RSL bus

		 * doing reads.

 MDIO_CLAUSE_22_WRITE */

 MDIO_CLAUSE_45_WRITE */

		/* Wait 1000 clocks so we don't saturate the RSL bus

		 * doing reads.

 SPDX-License-Identifier: GPL-2.0

/*

 * Allwinner EMAC MDIO interface driver

 *

 * Copyright 2012-2013 Stefan Roese <sr@denx.de>

 * Copyright 2013 Maxime Ripard <maxime.ripard@free-electrons.com>

 *

 * Based on the Linux driver provided by Allwinner:

 * Copyright (C) 1997  Sten Wang

 issue the phy address and reg */

 pull up the phy io line */

 Wait read complete */

 push down the phy io line */

 and read data */

 issue the phy address and reg */

 pull up the phy io line */

 Wait read complete */

 push down the phy io line */

 and write data */

 Deprecated */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2009-2015 Cavium, Inc.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * fwnode helpers for the MDIO (Ethernet PHY) API

 *

 * This file provides helper functions for extracting PHY device information

 * out of the fwnode and using it to populate an mii_bus.

	/* Associate the fwnode with the device structure so it

	 * can be looked up later

	/* All data is now stored in the phy struct;

	 * register it

		/* Associate the fwnode with the device structure so it

		 * can be looked up later.

 All data is now stored in the phy struct, so register it */

	/* phy->mii_ts may already be defined by the PHY driver. A

	 * mii_timestamper probed via the device tree will still have

	 * precedence.

 SPDX-License-Identifier: GPL-2.0

/*

 * Simple memory-mapped device MDIO MUX driver

 *

 * Author: Timur Tabi <timur@freescale.com>

 *

 * Copyright 2012 Freescale Semiconductor, Inc.

/*

 * MDIO multiplexing switch function

 *

 * This function is called by the mdio-mux layer when it thinks the mdio bus

 * multiplexer needs to switch.

 *

 * 'current_child' is the current value of the mux register (masked via

 * s->mask).

 *

 * 'desired_child' is the value of the 'reg' property of the target child MDIO

 * node.

 *

 * The first time this function is called, current_child == -1.

 *

 * If current_child == desired_child, then the mux is already set to the

 * correct bus.

	/*

	 * Verify that the 'reg' property of each child MDIO bus does not

	 * set any bits outside of the 'mask'.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2011, 2012 Cavium, Inc.

 Legacy compatible property. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ACPI helpers for the MDIO (Ethernet PHY) API

 *

 * This file provides helper functions for extracting PHY device information

 * out of the ACPI ASL and using it to populate an mii_bus.

/**

 * acpi_mdiobus_register - Register mii_bus and create PHYs from the ACPI ASL.

 * @mdio: pointer to mii_bus structure

 * @fwnode: pointer to fwnode of MDIO bus. This fwnode is expected to represent

 * an ACPI device object corresponding to the MDIO bus and its children are

 * expected to correspond to the PHY devices on that bus.

 *

 * This function registers the mii_bus structure and registers a phy_device

 * for each child node of @fwnode.

 Mask out all PHYs from auto probing. */

 Loop over the child nodes and register a phy_device for each PHY */

 SPDX-License-Identifier: GPL-2.0

/* Qualcomm IPQ8064 MDIO interface driver

 *

 * Copyright (C) 2019 Christian Lamparter <chunkeey@gmail.com>

 * Copyright (C) 2020 Ansuel Smith <ansuelsmth@gmail.com>

 MII address register definitions */

 NSS_GMAC0_BASE */

 Reject clause 45 */

 Reject clause 45 */

	/* For the specific reg 31 extra time is needed or the next

	 * read will produce garbage data.

 the mdio lock is used by any user of this mdio driver */

 SPDX-License-Identifier: GPL-2.0

 Reversed from USB PCAPs, no idea what these mean. */

 SPDX-License-Identifier: GPL-2.0

/*

 * GPIO based MDIO bitbang driver.

 * Supports OpenFirmware.

 *

 * Copyright (c) 2008 CSE Semaphore Belgium.

 *  by Laurent Pinchart <laurentp@cse-semaphore.com>

 *

 * Copyright (C) 2008, Paulius Zaleckas <paulius.zaleckas@teltonika.lt>

 *

 * Based on earlier work by

 *

 * Copyright (c) 2003 Intracom S.A.

 *  by Pantelis Antoniou <panto@intracom.gr>

 *

 * 2005 (c) MontaVista Software, Inc.

 * Vitaly Bordug <vbordug@ru.mvista.com>

		/* Separate output pin. Always set its value to high

		 * when changing direction. If direction is input,

		 * assume the pin serves as pull-up. If direction is

		 * output, the default value is high.

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2011, 2012 Cavium, Inc.

 List of our children linked through their next fields. */

/*

 * The parent bus' lock is used to order access to the switch_fn.

/*

 * The parent bus' lock is used to order access to the switch_fn.

 SPDX-License-Identifier: GPL-2.0-or-later

 Copyright (C) 2019 IBM Corp. */

 Just clause 22 for the moment */

 Just clause 22 for the moment */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Hisilicon Fast Ethernet MDIO Bus Driver

 *

 * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.

 SPDX-License-Identifier: GPL-2.0

/*

 * Bitbanged MDIO support.

 *

 * Author: Scott Wood <scottwood@freescale.com>

 * Copyright (c) 2007 Freescale Semiconductor

 *

 * Based on CPM2 MDIO code which is:

 *

 * Copyright (c) 2003 Intracom S.A.

 *  by Pantelis Antoniou <panto@intracom.gr>

 *

 * 2005 (c) MontaVista Software, Inc.

 * Vitaly Bordug <vbordug@ru.mvista.com>

/* Minimum MDC period is 400 ns, plus some margin for error.  MDIO_DELAY

 * is done twice per period.

/* The PHY may take up to 300 ns to produce data, plus some margin

 * for error.

 MDIO must already be configured as output. */

 MDIO must already be configured as input. */

 MDIO must already be configured as output. */

 MDIO must already be configured as input. */

/* Utility to send the preamble, address, and

 * register (common to read and write).

	/*

	 * Send a 32 bit preamble ('1's) with an extra '1' bit for good

	 * measure.  The IEEE spec says this is a PHY optional

	 * requirement.  The AMD 79C874 requires one after power up and

	 * one after a MII communications error.  This means that we are

	 * doing more preambles than we need, but it is safer and will be

	 * much more robust.

	/* send the start bit (01) and the read opcode (10) or write (01).

	   Clause 45 operation uses 00 for the start and 11, 10 for

/* In clause 45 mode all commands are prefixed by MDIO_ADDR to specify the

   lower 16 bits of the 21 bit address. This transfer is done identically to a

   MDIO_WRITE except for a different code. To enable clause 45 mode or

   MII_ADDR_C45 into the address. Theoretically clause 45 and normal devices

   can exist on the same bus. Normal devices should ignore the MDIO_ADDR

 send the turnaround (10) */

	/* check the turnaround bit: the PHY should be driving it to zero, if this

	 * PHY is listed in phy_ignore_ta_mask as having broken TA, skip that

		/* PHY didn't drive TA low -- flush any bits it

		 * may be trying to send.

 send the turnaround (10) */

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/*

 * Driver for the MDIO interface of Microsemi network switches.

 *

 * Author: Alexandre Belloni <alexandre.belloni@bootlin.com>

 * Copyright (c) 2017 Microsemi Corporation

/* When high resolution timers aren't built-in: we can't use usleep_range() as

 * we would sleep way too long. Use udelay() instead.

 This resource is optional */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Broadcom BCM6368 mdiomux bus controller driver

 *

 * Copyright (C) 2021 lvaro Fernndez Rojas <noltari@gmail.com>

	/*

	 * Just ioremap, as this MDIO block is usually integrated into an

	 * Ethernet MAC controller register range

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0+

/* Applied Micro X-Gene SoC MDIO Driver

 *

 * Copyright (c) 2016, Applied Micro Circuits Corporation

 * Author: Iyappan Subramanian <isubramanian@apm.com>

 Mask out all PHYs from auto probing. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * OF helpers for the MDIO (Ethernet PHY) API

 *

 * Copyright (c) 2009 Secret Lab Technologies, Ltd.

 *

 * This file provides helper functions for extracting PHY device information

 * out of the OpenFirmware device tree and using it to populate an mii_bus.

 in microseconds */

/* Extract the clause 22 phy ID from the compatible string of the form

	/* Associate the OF node with the device structure so it

	 * can be looked up later.

 All data is now stored in the mdiodev struct; register it. */

/* The following is a list of PHY compatible strings which appear in

 * some DTBs. The compatible string is never matched against a PHY

 * driver, so is pointless. We only expect devices which are not PHYs

 * to have a compatible string, so they can be matched to an MDIO

 * driver.  Encourage users to upgrade their DT blobs to remove these.

/*

 * Return true if the child node is for a phy. It must either:

 * o Compatible string of "ethernet-phy-idX.X"

 * o Compatible string of "ethernet-phy-ieee802.3-c45"

 * o Compatible string of "ethernet-phy-ieee802.3-c22"

 * o In the white list above (and issue a warning)

 * o No compatibility string

 *

 * A device which is not a phy is expected to have a compatible string

 * indicating what sort of device it is.

/**

 * of_mdiobus_register - Register mii_bus and create PHYs from the device tree

 * @mdio: pointer to mii_bus structure

 * @np: pointer to device_node of MDIO bus.

 *

 * This function registers the mii_bus structure and registers a phy_device

 * for each child node of @np.

 Do not continue if the node is disabled */

	/* Mask out all PHYs from auto probing.  Instead the PHYs listed in

 Get bus level PHY reset GPIO details */

 Register the MDIO bus */

 Loop over the child nodes and register a phy_device for each phy */

 auto scan for PHYs with empty reg property */

 Skip PHYs with reg property set */

 skip already registered PHYs */

 be noisy to encourage people to set reg property */

				/* -ENODEV is the return code that PHYLIB has

				 * standardized on to indicate that bus

				 * scanning should continue.

/**

 * of_mdio_find_device - Given a device tree node, find the mdio_device

 * @np: pointer to the mdio_device's device tree node

 *

 * If successful, returns a pointer to the mdio_device with the embedded

 * struct device refcount incremented by one, or NULL on failure.

 * The caller should call put_device() on the mdio_device after its use

/**

 * of_phy_find_device - Give a PHY node, find the phy_device

 * @phy_np: Pointer to the phy's device tree node

 *

 * If successful, returns a pointer to the phy_device with the embedded

 * struct device refcount incremented by one, or NULL on failure.

/**

 * of_phy_connect - Connect to the phy described in the device tree

 * @dev: pointer to net_device claiming the phy

 * @phy_np: Pointer to device tree node for the PHY

 * @hndlr: Link state callback for the network device

 * @flags: flags to pass to the PHY

 * @iface: PHY data interface type

 *

 * If successful, returns a pointer to the phy_device with the embedded

 * struct device refcount incremented by one, or NULL on failure. The

 * refcount must be dropped by calling phy_disconnect() or phy_detach().

 refcount is held by phy_connect_direct() on success */

/**

 * of_phy_get_and_connect

 * - Get phy node and connect to the phy described in the device tree

 * @dev: pointer to net_device claiming the phy

 * @np: Pointer to device tree node for the net_device claiming the phy

 * @hndlr: Link state callback for the network device

 *

 * If successful, returns a pointer to the phy_device with the embedded

 * struct device refcount incremented by one, or NULL on failure. The

 * refcount must be dropped by calling phy_disconnect() or phy_detach().

/*

 * of_phy_is_fixed_link() and of_phy_register_fixed_link() must

 * support two DT bindings:

 * - the old DT binding, where 'fixed-link' was a property with 5

 *   cells encoding various information about the fixed PHY

 * - the new DT binding, where 'fixed-link' is a sub-node of the

 *   Ethernet device.

 New binding */

 Old binding */

 status is zeroed, namely its .link member */

 New binding */

 Old binding */

 of_phy_find_device() */

 fixed_phy_register() */

 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause

 Copyright (c) 2015, The Linux Foundation. All rights reserved. */

 Copyright (c) 2020 Sartura Ltd. */

 0 = Clause 22, 1 = Clause 45 */

 MDIO clock source frequency is fixed to 100M */

 Clause 45 support */

 Enter Clause 45 mode */

 issue the phy address and mmd */

 issue reg */

 Enter Clause 22 mode */

 issue the phy address and reg */

 issue read command */

 Wait read complete */

 Read and return data */

 Clause 45 support */

 Enter Clause 45 mode */

 issue the phy address and mmd */

 issue reg */

 Enter Clause 22 mode */

 issue the phy address and reg */

 issue write data */

 issue write command */

 Wait write complete */

	/* To indicate CMN_PLL that ethernet_ldo has been ready if platform resource 1

	 * is specified in the device tree.

 Configure MDIO clock source frequency if clock is specified in the device tree */

 The platform resource is provided on the chipset IPQ5018 */

 This resource is optional */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015 Broadcom Corporation

 loop for 1s */

 Prepare the read operation */

 Prepare the write operation */

 restore the mii clock configuration */

 CONFIG_PM_SLEEP */

 sentinel */ },

 SPDX-License-Identifier: GPL-2.0

/* Copyright (c) 2019 Baylibre, SAS.

 * Author: Jerome Brunet <jbrunet@baylibre.com>

 Apply both enable an reset */

 Clear the reset to let PLL lock */

	/* Poll on the digital lock instead of the usual analog lock

	 * This is done because bit 31 is unreliable on some SoC. Bit

	 * 31 may indicate that the PLL is not lock even though the clock

	 * is actually running

 Apply PLL HW settings */

 Enable the phy clock */

 Initialize ephy control */

 Reset the mdio bus mux */

 Disable the phy clock if enabled */

 get the mux parents */

 create the input mux */

 create the pll */

 Make sure the device registers are clocked */

 Register PLL in CCF */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Broadcom UniMAC MDIO bus controller driver

 *

 * Copyright (C) 2014-2017 Broadcom

	/* MIPS chips strapped for BE will automagically configure the

	 * peripheral registers for CPU-native byte order.

 Prepare the read operation */

 Start MDIO transaction */

	/* Some broken devices are known not to release the line during

	 * turn-around, e.g: Broadcom BCM53125 external switches, so check for

	 * that condition here and ignore the MDIO controller read failure

	 * indication.

 Prepare the write operation */

/* Workaround for integrated BCM7xxx Gigabit PHYs which have a problem with

 * their internal MDIO management controller making them fail to successfully

 * be read from or written to for the first transaction.  We insert a dummy

 * BMSR read here to make sure that phy_get_device() and get_phy_id() can

 * correctly read the PHY MII_PHYSID1/2 registers and successfully register a

 * PHY device for this peripheral.

 *

 * Once the PHY driver is registered, we can workaround subsequent reads from

 * there (e.g: during system-wide power management).

 *

 * bus->reset is invoked before mdiobus_scan during mdiobus_register and is

 * therefore the right location to stick that workaround. Since we do not want

 * to read from non-existing PHYs, we either use bus->phy_mask or do a manual

 * Device Tree scan to limit the search area.

 Keep the hardware default values */

	/* The MDIO clock is the reference clock (typically 250Mhz) divided by

	 * 2 x (MDIO_CLK_DIV + 1)

	/* Just ioremap, as this MDIO block is usually integrated into an

	 * Ethernet MAC controller register range

 sentinel */ },

 SPDX-License-Identifier: GPL-2.0-or-later

 $Id: plip.c,v 1.3.6.2 1997/04/16 15:07:56 phil Exp $ */

 PLIP: A parallel port "network" driver for Linux. */

 This driver is for parallel port with 5-bit cable (LapLink (R) cable). */

/*

 * Authors:	Donald Becker <becker@scyld.com>

 *		Tommy Thorn <thorn@daimi.aau.dk>

 *		Tanabe Hiroyasu <hiro@sanpo.t.u-tokyo.ac.jp>

 *		Alan Cox <gw4pts@gw4pts.ampr.org>

 *		Peter Bauer <100136.3530@compuserve.com>

 *		Niibe Yutaka <gniibe@mri.co.jp>

 *		Nimrod Zimerman <zimerman@mailandnews.com>

 *

 * Enhancements:

 *		Modularization and ifreq/ifmap support by Alan Cox.

 *		Rewritten by Niibe Yutaka.

 *		parport-sharing awareness code by Philip Blundell.

 *		SMP locking by Niibe Yutaka.

 *		Support for parallel ports with no IRQ (poll mode),

 *		Modifications to use the parallel port API

 *		by Nimrod Zimerman.

 *

 * Fixes:

 *		Niibe Yutaka

 *		  - Module initialization.

 *		  - MTU fix.

 *		  - Make sure other end is OK, before sending a packet.

 *		  - Fix immediate timer problem.

 *

 *		Al Viro

 *		  - Changed {enable,disable}_irq handling to make it work

 *		    with new ("stack") semantics.

/*

 * Original version and the name 'PLIP' from Donald Becker <becker@scyld.com>

 * inspired by Russ Nelson's parallel port packet driver.

 *

 * NOTE:

 *     Tanabe Hiroyasu had changed the protocol, and it was in Linux v1.0.

 *     Because of the necessity to communicate to DOS machines with the

 *     Crynwr packet driver, Peter Bauer changed the protocol again

 *     back to original protocol.

 *

 *     This version follows original PLIP protocol.

 *     So, this PLIP can't communicate the PLIP of Linux v1.0.

/*

 *     To use with DOS box, please do (Turn on ARP switch):

 *	# ifconfig plip[0-2] arp

/*

  Sources:

	Ideas and protocols came from Russ Nelson's <nelson@crynwr.com>

	"parallel.asm" parallel port packet driver.



  The "Crynwr" parallel port standard specifies the following protocol:

    Trigger by sending nibble '0x8' (this causes interrupt on other end)

    count-low octet

    count-high octet

    ... data octets

    checksum octet

  Each octet is sent as <wait for rx. '0x1?'> <send 0x10+(octet&0x0F)>

			<wait for rx. '0x0?'> <send 0x00+((octet>>4)&0x0F)>



  The packet is encapsulated as if it were ethernet.



  The cable used is a de facto standard parallel null cable -- sold as

  a "LapLink" cable by various places.  You'll need a 12-conductor cable to

  make one yourself.  The wiring is:

    SLCTIN	17 - 17

    GROUND	25 - 25

    D0->ERROR	2 - 15		15 - 2

    D1->SLCT	3 - 13		13 - 3

    D2->PAPOUT	4 - 12		12 - 4

    D3->ACK	5 - 10		10 - 5

    D4->BUSY	6 - 11		11 - 6

  Do not connect the other pins.  They are

    D5,D6,D7 are 7,8,9

    STROBE is 1, FEED is 14, INIT is 16

    extra grounds are 18,19,20,21,22,23,24

 Maximum number of devices to support. */

 Use 0 for production, 1 for verification, >2 for debug */

 In micro second */

 Connection time out = PLIP_TRIGGER_WAIT * PLIP_DELAY_UNIT usec */

 Nibble time out = PLIP_NIBBLE_WAIT * PLIP_DELAY_UNIT usec */

 Bottom halves */

 Interrupt handler */

 Functions for DEV methods */

/* Entry point of PLIP driver.

   Probe the hardware, and register/initialize the driver.



   PLIP is rather weird, because of the way it interacts with the parport

   system.  It is _not_ initialised from Space.c.  Instead, plip_init()

   is called, and that function makes up a "struct net_device" for each port, and

   then calls us here.



 Then, override parts of it */

 Initialize constants */

 Initialize task queue structures */

/* Bottom half handler for the delayed request.

   This routine is kicked by do_timer().

 Forward declarations of internal routines */

 Bottom half handler of PLIP. */

	/*

	 * This is tricky. If we got here from the beginning of send (either

	 * with ERROR or HS_TIMEOUT) we have IRQ enabled. Otherwise it's

	 * already disabled. With the old variant of {enable,disable}_irq()

	 * extra disable_irq() was a no-op. Now it became mortal - it's

	 * unbalanced and thus we'll never re-enable IRQ (until rmmod plip,

	 * that is). So we have to treat HS_TIMEOUT and ERROR from send

	 * in a special way.

 Timeout */

 Try again later */

 Transmission was interrupted. */

 Timeout */

 Try again later */

/* PLIP_RECEIVE --- receive a byte(two nibbles)

 send ACK */

 send ACK */

/*

 *	Determine the packet's protocol ID. The rule here is that we

 *	assume 802.3 if the type field is short enough to be a length.

 *	This is normal practice and works for any 'now in use' protocol.

 *

 *	PLIP is ethernet ish but the daddr might not be valid if unicast.

 *	PLIP fortunately has no bus architecture (its Point-to-point).

 *

 *	We can't fix the daddr thing as that quirk (more bug) is embedded

 *	in far too many old systems not all even running Linux.

	/*

	 *	This ALLMULTI check should be redundant by 1.4

	 *	so don't forget to remove it.

	/*

	 *	This is a magic hack to spot IPX packets. Older Novell breaks

	 *	the protocol design and runs IPX over 802.3 without an 802.2 LLC

	 *	layer. We look for FFFF which isn't a used 802.2 SSAP/DSAP. This

	 *	won't work for fault tolerant netware but does for the rest.

	/*

	 *	Real 802.2 LLC

 PLIP_RECEIVE_PACKET --- receive a packet */

 Don't need to synchronize irq, as we can safely ignore it */

 send ACK */

 collision, here dev->tbusy == 1 */

 Malloc up new buffer. */

 Align IP on 16 byte boundaries */

 Inform the upper layer for the arrival of a packet. */

 Close the connection. */

/* PLIP_SEND --- send a byte (two nibbles)

 PLIP_SEND_PACKET --- send a packet */

 Trigger remote rx interrupt. */

 Interrupted. */

					/* Interrupted.

					   We don't need to enable irq,

					/* Yes, we do. New variant of

					   {enable,disable}_irq *counts*

 Close the connection */

 PLIP_ERROR --- wait till other end settled */

 Handle the parallel port interrupts. */

		/* May occur because there is race condition

		   around test and set of dev->interrupt.

 We may need to grab the bus */

 Any address will do - we take the first */

/* Open/initialize the board.  This is called (in the current kernel)

   sometime after booting when the 'ifconfig' program is run.



   This routine gets exclusive access to the parallel port by allocating

   its IRQ line.

 Grab the port */

 Clear the data port. */

 Enable rx interrupt. */

 Initialize the state machine. */

	/* Fill in the MAC-level header.

	   We used to abuse dev->broadcast to store the point-to-point

	   MAC address, but we no longer do it. Instead, we fetch the

	   interface address whenever it is needed, which is cheap enough

	   because we use the hh_cache. Actually, abusing dev->broadcast

	   didn't work, because when using plip_open the point-to-point

	   address isn't yet known.

	   PLIP doesn't have a real MAC address, but we need it to be

	   DOS compatible, and to properly support taps (otherwise,

	   when the device address isn't identical to the address of a

		/* Any address will do - we take the first. We already

		   have the first two bytes filled with 0xfc, from

 The inverse routine to plip_open (). */

 Reset. */

 Stand our ground if a datagram is on the wire */

 Remember that we released the bus */

 Why are we being woken up? */

 bus_owner is already set (but why?) */

 Don't need the port when the interface is down */

 Clear the data port. */

/* plip_attach() is called (by the parport code) when a port is

/* plip_detach() is called (by the parport code) when a port is

 Nothing to do */

 Ugh. */

 disable driver on "plip=" or "plip=0" */

 !MODULE */

/*

 * originally based on the dummy device.

 *

 * Copyright 1999, Thomas Davis, tadavis@lbl.gov.

 * Licensed under the GPL. Based on dummy.c, and eql.c devices.

 *

 * bonding.c: an Ethernet Bonding driver

 *

 * This is useful to talk to a Cisco EtherChannel compatible equipment:

 *	Cisco 5500

 *	Sun Trunking (Solaris)

 *	Alteon AceDirector Trunks

 *	Linux Bonding

 *	and probably many L2 switches ...

 *

 * How it works:

 *    ifconfig bond0 ipaddress netmask up

 *      will setup a network device, with an ip address.  No mac address

 *	will be assigned at this time.  The hw mac address will come from

 *	the first slave bonded to the channel.  All slaves will then use

 *	this hw mac address.

 *

 *    ifconfig bond0 down

 *         will release all slaves, marking them as down.

 *

 *    ifenslave bond0 eth0

 *	will attach eth0 to bond0 as a slave.  eth0 hw mac address will either

 *	a: be used as initial mac address

 *	b: if a hw mac address already is there, eth0's hw mac address

 *	   will then be set from bond0.

 *

---------------------------- Module parameters ----------------------------*/

 monitor all links that often (in milliseconds). <=0 disables monitoring */

----------------------------- Global variables ----------------------------*/

-------------------------- Forward declarations ---------------------------*/

---------------------------- General routines -----------------------------*/

/**

 * bond_dev_queue_xmit - Prepare skb for xmit.

 *

 * @bond: bond device that got this skb for tx.

 * @skb: hw accel VLAN tagged skb to transmit

 * @slave_dev: slave that is supposed to xmit this skbuff

		/* vlan+srcmac is not supported with XDP as in most cases the 802.1q

		 * payload is not in the packet due to hardware offload.

---------------------------------- VLAN -----------------------------------*/

/* In the following 2 functions, bond_vlan_rx_add_vid and bond_vlan_rx_kill_vid,

 * We don't protect the slave list iteration with a lock because:

 * a. This operation is performed in IOCTL context,

 * b. The operation is protected by the RTNL semaphore in the 8021q code,

 * c. Holding a lock with BH disabled while directly calling a base driver

 *    entry point is generally a BAD idea.

 *

 * The design of synchronization/protection for this operation in the 8021q

 * module is good for one or more VLAN devices over a single physical device

 * and cannot be extended for a teaming solution like bonding, so there is a

 * potential race condition here where a net device from the vlan group might

 * be referenced (either by a base driver or the 8021q code) while it is being

 * removed from the system. However, it turns out we're not making matters

 * worse, and if it works for regular VLAN usage it will work here too.

/**

 * bond_vlan_rx_add_vid - Propagates adding an id to slaves

 * @bond_dev: bonding net device that got called

 * @proto: network protocol ID

 * @vid: vlan id being added

 unwind to the slave that failed */

/**

 * bond_vlan_rx_kill_vid - Propagates deleting an id to slaves

 * @bond_dev: bonding net device that got called

 * @proto: network protocol ID

 * @vid: vlan id being removed

---------------------------------- XFRM -----------------------------------*/

/**

 * bond_ipsec_add_sa - program device with a security association

 * @xs: pointer to transformer state struct

/**

 * bond_ipsec_del_sa - clear out this specific SA

 * @xs: pointer to transformer state struct

/**

 * bond_ipsec_offload_ok - can this packet use the xfrm hw offload

 * @skb: current data packet

 * @xs: pointer to transformer state struct

 CONFIG_XFRM_OFFLOAD */

------------------------------- Link status -------------------------------*/

/* Set the carrier state for the master according to the state of its

 * slaves.  If any slaves are up, the master is up.  In 802.3ad mode,

 * do special 802.3ad magic.

 *

 * Returns zero if carrier state does not change, nonzero if it does.

/* Get link speed and duplex from the slave's base driver

 * using ethtool. If for some reason the call fails or the

 * values are invalid, set speed and duplex to -1,

 * and return. Return 1 if speed or duplex settings are

 * UNKNOWN; 0 otherwise.

/* if <dev> supports MII link status reporting, check its link status.

 *

 * We either do MII/ETHTOOL ioctls, or check netif_carrier_ok(),

 * depending upon the setting of the use_carrier parameter.

 *

 * Return either BMSR_LSTATUS, meaning that the link is up (or we

 * can't tell and just pretend it is), or 0, meaning that the link is

 * down.

 *

 * If reporting is non-zero, instead of faking link up, return -1 if

 * both ETHTOOL and MII ioctls fail (meaning the device does not

 * support them).  If use_carrier is set, return whatever it says.

 * It'd be nice if there was a good way to tell if a driver supports

 * netif_carrier, but there really isn't.

 Try to get link status using Ethtool first. */

 Ethtool can't be used, fallback to MII ioctls. */

		/* TODO: set pointer to correct ioctl on a per team member

		 *       bases to make this more efficient. that is, once

		 *       we determine the correct ioctl, we will always

		 *       call it and not the others for that team

		 *       member.

		/* We cannot assume that SIOCGMIIPHY will also read a

		 * register; not all network drivers (e.g., e100)

		 * support that.

 Yes, the mii is overlaid on the ifreq.ifr_ifru */

	/* If reporting, report that either there's no ndo_eth_ioctl,

	 * or both SIOCGMIIREG and get_link failed (meaning that we

	 * cannot report link status).  If not reporting, pretend

	 * we're ok.

----------------------------- Multicast list ------------------------------*/

 Push the promiscuity flag down to appropriate slaves */

 Push the allmulti flag down to all slaves */

/* Retrieve the list of registered multicast addresses for the bonding

 * device and retransmit an IGMP JOIN request to the current active

 * slave.

 Flush bond's hardware addresses from slave */

 del lacpdu mc addr from mc list */

--------------------------- Active slave change ---------------------------*/

/* Update the hardware address list and promisc/allmulti for the new and

 * old active slaves (if any).  Modes that are not using primary keep all

 * slaves up date at all times; only the modes that use primary need to call

 * this function to swap these settings during a failover.

 FIXME: Signal errors upstream. */

/**

 * bond_set_dev_addr - clone slave's address to bond

 * @bond_dev: bond net device

 * @slave_dev: slave net device

 *

 * Should be called with RTNL held.

/* bond_do_fail_over_mac

 *

 * Perform special MAC address swapping for fail_over_mac settings

 *

 * Called with RTNL

		/* if new_active && old_active, swap them

		 * if just old_active, do nothing (going to no active slave)

		 * if just new_active, set new_active to bond's MAC

 At this point, prim and curr are both up */

/**

 * bond_find_best_slave - select the best available slave to be the active one

 * @bond: our bonding struct

/**

 * bond_change_active_slave - change the active slave into the specified one

 * @bond: our bonding struct

 * @new_active: the new slave to make the active one

 *

 * Set the new slave to the bond's settings and unset them on the old

 * curr_active_slave.

 * Setting include flags, mc-list, promiscuity, allmulti, etc.

 *

 * If @new's link state is %BOND_LINK_BACK we'll set it to %BOND_LINK_UP,

 * because it is apparently the best available slave we have, even though its

 * updelay hasn't timed out yet.

 *

 * Caller must hold RTNL.

 CONFIG_XFRM_OFFLOAD */

 CONFIG_XFRM_OFFLOAD */

	/* resend IGMP joins since active slave has changed or

	 * all were sent on curr_active_slave.

	 * resend only if bond is brought up with the affected

	 * bonding modes and the retransmission is enabled

/**

 * bond_select_active_slave - select a new active slave, if needed

 * @bond: our bonding struct

 *

 * This functions should be called when one of the following occurs:

 * - The old curr_active_slave has been released or lost its link.

 * - The primary_slave has got its link back.

 * - A slave has got its link back and there's no old curr_active_slave.

 *

 * Caller must hold RTNL.

---------------------------------- IOCTL ----------------------------------*/

 CONFIG_XFRM_OFFLOAD */

 CONFIG_XFRM_OFFLOAD */

 CONFIG_XFRM_OFFLOAD */

/* On bonding slaves other than the currently active slave, suppress

 * duplicates except for alb non-mcast/bcast.

	/*

	 * For packets determined by bond_should_deliver_exact_match() call to

	 * be suppressed we want to make an exception for link-local packets.

	 * This is necessary for e.g. LLDP daemons to be able to monitor

	 * inactive slave links without being forced to bind to them

	 * explicitly.

	 *

	 * At the same time, packets that are passed to the bonding master

	 * (including link-local ones) can have their originating interface

	 * determined via PACKET_ORIGDEV socket option.

 enslave device <slave> to bond device <master> */

 already in-use? */

 vlan challenged mutual exclusion */

 no need to lock since we're protected by rtnl_lock */

	/* Old ifenslave binaries are no longer supported.  These can

	 * be identified with moderate accuracy by the state of the slave:

	 * the current ifenslave will set the interface down prior to

	 * enslaving it; the old ifenslave will not.

	/* set bonding device ether type by slave - bonding netdevices are

	 * created with ether_setup, so when the slave type is not ARPHRD_ETHER

	 * there is a need to override some of the type dependent attribs/funcs.

	 *

	 * bond ether type mutual exclusion - don't allow slaves of dissimilar

	 * ether type (eg ARPHRD_ETHER and ARPHRD_INFINIBAND) share the same bond

 Flush unicast and multicast addresses */

	/* If this is the first slave, then we need to set the master's hardware

	 * address to be the same as the slave's.

	/* Set the new_slave's queue_id to be zero.  Queue ID mapping

	 * is set via sysfs or module option if desired.

 Save slave's original mtu and then set it to match the bond */

	/* Save slave's original ("permanent") mac address for modes

	 * that need it, and for restoring it upon release, and then

	 * set it to the master's address

		/* Set slave to master's mac address.  The application already

		 * set the master's mac address to that of the first slave

 set slave flag before open to prevent IPv6 addrconf */

 open the slave since the application closed it */

 initialize slave stats */

		/* bond_alb_init_slave() must be called before all other stages since

		 * it might fail and we do not want to have to undo everything

			/* miimon is set but a bonded network driver

			 * does not support ETHTOOL/MII and

			 * arp_interval is not set.  Note: if

			 * use_carrier is enabled, we will never go

			 * here (because netif_carrier is always

			 * supported); thus, we don't need to change

			 * the messages for netif_carrier.

 unable get link status using mii/ethtool */

 check for initial state */

 if there is a primary slave, remember it */

		/* in 802.3ad mode, the internal mechanism

		 * will activate the slaves in the selected

		 * aggregator

 if this is the first slave */

			/* Initialize AD with the number of times that the AD timer is called in 1 second

			 * can be called only after the mac address of the bond is set

 always active in trunk mode */

		/* In trunking mode there is little meaning to curr_active_slave

		 * anyway (it holds no special properties of the bond device),

		 * so we can change it without calling change_active_interface()

 switch(bond_mode) */

	/* If the mode uses primary, then the following is handled by

	 * bond_change_active_slave().

 set promiscuity level to new slave */

 set allmulti level to new slave */

 add lacpdu mc addr to mc list */

 ndo_bpf() sets extack error message */

 enslave is successful */

 Undo stages on error */

 either primary_slave or curr_active_slave might've changed */

		/* XXX TODO - fom follow mode needs to change master's

		 * MAC if this slave's MAC is in use by the bond, or at

		 * least print a warning.

 Enslave of first slave has failed and we need to fix master's mac */

/* Try to release the slave device <slave> from the bond device <master>

 * It is legal to access curr_active_slave without a lock because all the function

 * is RTNL-locked. If "all" is true it means that the function is being called

 * while destroying a bond interface and all slaves are being released.

 *

 * The rules for slave state should be:

 *   for Active/Backup:

 *     Active stays on all backups go down

 *   for Bonded connections:

 *     The first up interface should be left on and all others downed.

 slave is not a slave or master is not master of this slave */

 not a slave of this bond */

 recompute stats just before removing the slave */

	/* unregister rx_handler early so bond_handle_frame wouldn't be called

	 * for this slave anymore.

		/* Must be called only after the slave has been

		 * detached from the list and the curr_active_slave

		 * has been cleared (if our_slave == old_current),

		 * but before a new active slave is selected.

		/* Note that we hold RTNL over this sequence, so there

		 * is no concern that another slave add/remove event

		 * will interfere.

	/* If the mode uses primary, then this case was handled above by

	 * bond_change_active_slave(..., NULL)

		/* unset promiscuity level from slave

		 * NOTE: The NETDEV_CHANGEADDR call above may change the value

		 * of the IFF_PROMISC flag in the bond_dev, but we need the

		 * value of that flag before that change, as that was the value

		 * when this slave was attached, so we cache at the start of the

		 * function and use it here. Same goes for ALLMULTI below

 unset allmulti level from slave */

 close slave before restoring its mac address */

 restore original ("permanent") mac address */

 A wrapper used because of ndo_del_link */

/* First release a slave and then destroy the bond if no more slaves are left.

 * Must be under rtnl_lock when this function is called.

-------------------------------- Monitoring -------------------------------*/

 called with rcu_read_lock() */

 recovered before downdelay expired */

			/* For 802.3ad mode, check current slave speed and

			 * duplex again in case its port was disabled after

			 * invalid speed/duplex reporting but recovered before

			 * link monitoring could make a decision on the actual

			 * link status

 prevent it from being the active one */

 make it immediately active */

/* bond_mii_monitor

 *

 * Really a wrapper that splits the mii monitor into two phases: an

 * inspection, then (if inspection indicates something needs to be done)

 * an acquisition of appropriate locks followed by a commit phase to

 * implement whatever link state changes are indicated.

 Race avoidance with bond_close cancel of workqueue */

 might sleep, hold no other locks */

/* We go to the (large) trouble of VLAN tagging ARP frames because

 * switches in VLAN mode (especially if ports are configured as

 * "native" to a VLAN) might not pass non-tagged frames.

 Go through all the tags backwards and add them to the packet */

 Set the outer tag */

/* Validate the device path between the @start_dev and the @end_dev.

 * The path is valid if the @end_dev is reachable through device

 * stacking.

 * When the path is validated, collect any vlan information in the

 * path.

 Find out through which dev should the packet go */

			/* there's no route to target - try to send arp

			 * probe to generate any traffic (arp_validate=0)

 bond device itself */

 Not our device - skip */

	/* We 'trust' the received ARP enough to validate it if:

	 *

	 * (a) the slave receiving the ARP is active (which includes the

	 * current ARP slave, if any), or

	 *

	 * (b) the receiving slave isn't active, but there is a currently

	 * active slave and it received valid arp reply(s) after it became

	 * the currently active slave, or

	 *

	 * (c) there is an ARP slave that sent an ARP during the prior ARP

	 * interval, and we receive an ARP reply on any slave.  We accept

	 * these because switch FDB update delays may deliver the ARP

	 * reply to a slave other than the sender of the ARP request.

	 *

	 * Note: for (b), backup slaves are receiving the broadcast ARP

	 * request, not a reply.  This request passes from the sending

	 * slave through the L2 switch(es) to the receiving slave.  Since

	 * this is checking the request, sip/tip are swapped for

	 * validation.

	 *

	 * This is done to avoid endless looping when we can't reach the

	 * arp_ip_target and fool ourselves with our own arp requests.

/* function to verify if we're in the arp_interval timeslice, returns true if

 * (last_act - arp_interval) <= jiffies <= (last_act + mod * arp_interval +

 * arp_interval/2) . the arp_interval/2 is needed for really fast networks.

/* This function is called regularly to monitor each slave's link

 * ensuring that traffic is being sent and received when arp monitoring

 * is used in load-balancing mode. if the adapter has been dormant, then an

 * arp is transmitted to generate traffic. see activebackup_arp_monitor for

 * arp monitoring in active backup mode.

	/* see if any of the previous devices are up now (i.e. they have

	 * xmt and rcv traffic). the curr_active_slave does not come into

	 * the picture unless it is null. also, slave->last_link_up is not

	 * needed here because we send an arp on each slave and give a slave

	 * as long as it needs to get the tx/rx within the delta.

	 * TODO: what about up/down delay in arp mode? it wasn't here before

	 *       so it can wait

				/* primary_slave has no meaning in round-robin

				 * mode. the window of a slave being up and

				 * curr_active_slave being null after enslaving

				 * is closed.

 slave->link == BOND_LINK_UP */

			/* not all switches will respond to an arp request

			 * when the source ip is 0, so don't take the link down

			 * if we don't know our ip yet

		/* note: if switch is in round-robin mode, all links

		 * must tx arp to ensure all links rx an arp - otherwise

		 * links may oscillate or not come up at all; if switch is

		 * in something like xor mode, there is nothing we can

		 * do - all replies will be rx'ed on same link causing slaves

		 * to be unstable during low/no traffic periods

/* Called to inspect slaves for active-backup mode ARP monitor link state

 * changes.  Sets proposed link state in slaves to specify what action

 * should take place for the slave.  Returns 0 if no changes are found, >0

 * if changes to link states must be committed.

 *

 * Called with rcu_read_lock held.

		/* Give slaves 2*delta after being enslaved or made

		 * active.  This avoids bouncing, as the last receive

		 * times need a full ARP monitor cycle to be updated.

		/* Backup slave is down if:

		 * - No current_arp_slave AND

		 * - more than 3*delta since last receive AND

		 * - the bond has an IP address

		 *

		 * Note: a non-null current_arp_slave indicates

		 * the curr_active_slave went down and we are

		 * searching for a new one; under this condition

		 * we only take the curr_active_slave down - this

		 * gives each slave a chance to tx/rx traffic

		 * before being taken out

		/* Active slave is down if:

		 * - more than 2*delta since transmitting OR

		 * - (more than 2*delta since receive AND

		 *    the bond has an IP address)

/* Called to commit link state changes noted by inspection step of

 * active-backup mode ARP monitor.

 *

 * Called with RTNL hold.

			/* A slave has just been enslaved and has become

			 * the current active slave.

/* Send ARP probes for active-backup mode ARP monitor.

 *

 * Called with rcu_read_lock held.

	/* if we don't have a curr_active_slave, search for the next available

	 * backup slave from the current_arp_slave and make it the candidate

	 * for becoming the curr_active_slave

		/* if the link state is up at this point, we

		 * mark it down - this can happen if we have

		 * simultaneous link failures and

		 * reselect_active_interface doesn't make this

		 * one the current slave so it is still marked

		 * up when it is actually down

 Race avoidance with bond_close flush of workqueue */

-------------------------- netdev event handling --------------------------*/

 Change device name */

 CONFIG_XFRM_OFFLOAD */

	/* A netdev event can be generated while enslaving a device

	 * before netdev_rx_handler_register is called in which case

	 * slave will be NULL

		/* For 802.3ad mode only:

		 * Getting invalid Speed/Duplex values here will put slave

		 * in weird state. Mark it as link-fail if the link was

		 * previously up or link-down if it hasn't yet come up, and

		 * let link-monitoring (miimon) set it right when correct

		 * speeds/duplex are available.

		/* Refresh slave-array if applicable!

		 * If the setup does not use miimon or arpmon (mode-specific!),

		 * then these events will not cause the slave-array to be

		 * refreshed. This will cause xmit to use a slave that is not

		 * usable. Avoid such situation by refeshing the array at these

		 * events. If these (miimon/arpmon) parameters are configured

		 * then array gets refreshed twice and that should be fine!

		/* TODO: Should slaves be allowed to

		 * independently alter their MTU?  For

		 * an active-backup bond, slaves need

		 * not be the same type of device, so

		 * MTUs may vary.  For other modes,

		 * slaves arguably should have the

		 * same MTUs. To do this, we'd need to

		 * take over the slave's change_mtu

		 * function for the duration of their

		 * servitude.

 we don't care if we don't have primary set */

 slave's name changed - he's no longer primary */

 we have a new primary slave */

 we didn't change primary - exit */

 Propagate to master device */

/* bond_netdev_event: handle netdev notifier chain events.

 *

 * This function receives events for the netdev chain.  The caller (an

 * ioctl handler calling blocking_notifier_call_chain) holds the necessary

 * locks for us to safely manipulate the slave devices (RTNL lock,

 * dev_probe_lock).

---------------------------- Hashing Policies -----------------------------*/

/* Helper to access data in a packet, with or without a backing skb.

 * If skb is given the data is linearized if necessary via pskb_may_pull.

 L2 hash helper */

 Extract the appropriate headers based on bond's xmit policy */

	/* ICMP error packets contains at least 8 bytes of the header

	 * of the packet which generated the error. Use this information

	 * to correlate ICMP error packets within the same flow which

	 * generated the error.

 discard lowest hash bit to deal with the common even ports pattern */

/* Generate hash based on xmit policy. If @skb is given it is used to linearize

 * the data as required, but this function can be used without it if the data is

 * known to be linear (e.g. with xdp_buff).

/**

 * bond_xmit_hash - generate a hash value based on the xmit policy

 * @bond: bonding device

 * @skb: buffer to use for headers

 *

 * This function will extract the necessary headers from the skb buffer and use

 * them to generate a hash based on the xmit_policy set in the bonding device

/**

 * bond_xmit_hash_xdp - generate a hash value based on the xmit policy

 * @bond: bonding device

 * @xdp: buffer to use for headers

 *

 * The XDP variant of bond_xmit_hash.

-------------------------- Device entry points ----------------------------*/

 reset slave->backup and slave->inactive */

		/* bond_alb_initialize must be called before the timer

		 * is started.

 link check interval, in milliseconds. */

 arp interval, in milliseconds. */

 register to receive LACPDUs */

/* fold stats, assuming all rtnl_link_stats64 fields are u64, but

 * that some drivers can provide 32bit values only.

 detects if this particular field is 32bit only */

		/* filter anomalies, some drivers reset their stats

		 * at down/up events.

 save off the slave stats for the next run */

		/* We do this again just in case we were called by SIOCGMIIREG

		 * instead of SIOCGMIIPHY.

	/* TODO: find another way [1] to implement this.

	 * Passing a zeroed structure is fragile,

	 * but at least we do not pass garbage.

	 *

	 * [1] One way would be that ndo_neigh_setup() never touch

	 *     struct neigh_parms, but propagate the new neigh_setup()

	 *     back to ___neigh_create() / neigh_parms_alloc()

/* The bonding ndo_neigh_setup is called at init time beofre any

 * slave exists. So we must declare proxy setup function which will

 * be used at run time to resolve the actual slave neigh param setup.

 *

 * It's also called by master devices (such as vlans) to setup their

 * underlying devices. In that case - do nothing, we're already set up from

 * our init.

 modify only our neigh_parms */

 Change the MTU of all of a master's slaves to match the master */

			/* If we failed to set the slave's mtu to the new value

			 * we must abort the operation even in ACTIVE_BACKUP

			 * mode, because if we allow the backup slaves to have

			 * different mtu values than the active slave we'll

			 * need to change their mtu when doing a failover. That

			 * means changing their mtu from timer context, which

			 * is probably not a good idea.

 unwind from head to the slave that failed */

/* Change HW address

 *

 * Note that many devices must be down to change the HW address, and

 * downing the master releases all slaves.  We can make bonds full of

 * bonding devices to test this, however.

	/* If fail_over_mac is enabled, do nothing and return success.

	 * Returning an error causes ifenslave to fail.

			/* TODO: consider downing the slave

			 * and retry ?

			 * User should expect communications

			 * breakage anyway until ARP finish

			 * updating, so...

 success */

 unwind from head to the slave that failed */

/**

 * bond_get_slave_by_id - get xmit slave with slave_id

 * @bond: bonding device that is transmitting

 * @slave_id: slave id up to slave_cnt-1 through which to transmit

 *

 * This function tries to get slave with slave_id but in case

 * it fails, it tries to find the first available slave for transmission.

 Here we start from the slave with slave_id */

 Here we start from the first slave up to slave_id */

 no slave that can tx has been found */

/**

 * bond_rr_gen_slave_id - generate slave id based on packets_per_slave

 * @bond: bonding device to use

 *

 * Based on the value of the bonding device's packets_per_slave parameter

 * this function generates a slave id, which is usually used as the next

 * slave to transmit through.

	/* Start with the curr_active_slave that joined the bond as the

	 * default for sending IGMP traffic.  For failover purposes one

	 * needs to maintain some consistency for the interface that will

	 * send the join/membership reports.  The curr_active_slave found

	 * will send all of this type of traffic.

 See comment on IGMP in bond_xmit_roundrobin_slave_get() */

/* In active-backup mode, we know that bond->curr_active_slave is always valid if

 * the bond has a usable interface.

/* Use this to update slave_array when (a) it's not appropriate to update

 * slave_array right away (note that update_slave_array() may sleep)

 * and / or (b) RTNL is not held.

 Slave array work handler. Holds only RTNL */

	/* Rare situation where caller has asked to skip a specific

	 * slave but allocation failed (most likely!). BTW this is

	 * only possible when the call is initiated from

	 * __bond_release_one(). In this situation; overwrite the

	 * skipslave entry in the array with the last entry from the

	 * array to avoid a situation where the xmit path may choose

	 * this to-be-skipped slave to send a packet out.

/* Build the usable slaves array in control path for modes that use xmit-hash

 * to determine the slave interface -

 * (a) BOND_MODE_8023AD

 * (b) BOND_MODE_XOR

 * (c) (BOND_MODE_TLB || BOND_MODE_ALB) && tlb_dynamic_lb == 0

 *

 * The caller is expected to hold RTNL only and NO other lock!

			/* No active aggragator means it's not safe to use

			 * the previous array.

/* Use this Xmit function for 3AD as well as XOR modes. The current

 * usable slave array is formed in the control path. The xmit function

 * just calculates hash and sends the packet out.

 in broadcast mode, we send everything to all usable interfaces. */

------------------------- Device initialization ---------------------------*/

 Lookup the slave that corresponds to a qid */

 Find out if any slaves have the same mapping as this skb. */

 If the slave isn't UP, use default transmit policy. */

	/* This helper function exists to help dev_pick_tx get the correct

	 * destination queue.  Using a helper function skips a call to

	 * skb_tx_hash and will put the skbs in the queue we expect on their

	 * way down to the bonding driver.

 Save the original txq to restore before passing to the driver */

 Should never happen, mode already checked */

 AF_INET */

/**

 * bond_sk_hash_l34 - generate a hash value based on the socket's L3 and L4 fields

 * @sk: socket to use for headers

 *

 * This function will extract the necessary field from the socket and use

 * them to generate a hash based on the LAYER34 xmit_policy.

 * Assumes that sk is a TCP or UDP socket.

 L4 */

 L3 */

 Should never happen, mode already checked */

	/* If we risk deadlock from transmitting this in the

	 * netpoll path, tell netpoll to queue the frame for later tx

 Caller needs to hold rcu_read_lock() */

 Should never happen. Mode guarded by bond_xdp_check() */

	/* If error happened on the first frame then we can pass the error up, otherwise

	 * report the number of frames that were xmitted.

 ndo_bpf() sets extack error message */

 unwind the program changes */

 do not overwrite original error */

	/* Since bond_slave_can_tx returns false for all inactive or down slaves, we

	 * do not need to check mode.  Though link speed might not represent

	 * the true receive or transmit bandwidth (not all modes are symmetric)

	 * this is an accurate maximum.

 Initialize pointers */

 Initialize the device entry points */

 Initialize the device options */

 set up xfrm device ops (only supported in active-backup right now) */

 CONFIG_XFRM_OFFLOAD */

 don't acquire bond device's netif_tx_lock when transmitting */

	/* By default, we declare the bond to be fully

	 * VLAN hardware accelerated capable. Special

	 * care is taken in the various xmit functions

	 * when there are slaves that are not hw accel

	 * capable

 Don't allow bond devices to change network namespaces. */

 Only enable XFRM features if this is an active-backup config */

 CONFIG_XFRM_OFFLOAD */

/* Destroy a bonding device.

 * Must be under rtnl_lock when this function is called.

 Release the bonded slaves */

------------------------- Module initialization ---------------------------*/

 Convert string parameters. */

 reset values for 802.3ad/TLB/ALB */

			/* just warn the user the up/down delay will have

			 * no effect since miimon is zero...

 don't allow arp monitoring */

 not a complete check, but good enough to catch mistakes */

 don't allow arping if no arp_ip_target given... */

		/* miimon and arp_interval not set, we need one so things

		 * work as expected, see bonding.txt for details

		/* currently, using a primary only makes sense

		 * in active backup, TLB or ALB modes

 fill params struct with the proper values */

		/* reciprocal_packets_per_slave is unused if

		 * packets_per_slave is 0 or 1, just initialize it

 Called from registration process */

 Ensure valid dev_addr */

/* Create a new bond based on the specified name and bonding parameters.

 * If name is NULL, obtain a suitable "bond%d" name for us.

 * Caller must NOT hold rtnl_lock; we need to release it here before we

 * set up our sysfs entries.

	/*

	 * Initialize rx_hashtbl_used_head to RLB_NULL_INDEX.

	 * It is set to 0 by default which is wrong.

 Kill off any bonds created after unregistering bond rtnl ops */

 Make sure we don't have an imbalance on our netpoll blocking */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright(c) 2004-2005 Intel Corporation. All rights reserved.

/* "show" function for the bond_masters attribute.

 * The class parameter is ignored.

 not enough space for another interface name */

 eat the leftover space */

/* "store" function for the bond_masters attribute.  This is what

 * creates and deletes entire bonds.

 *

 * The class parameter is ignored.

 IFNAMSIZ*/

	/* Always return either count or an error.  If you return 0, you'll

	 * get called forever, which is bad.

 class attribute for bond_masters file.  This ends up in /sys/class/net */

 Generic "store" method for bonding sysfs option setting */

 Show the slaves in the current bond. */

 not enough space for another interface name */

 eat the leftover space */

 Show the bonding mode. */

 Show the bonding transmit hash method. */

 Show arp_validate. */

 Show arp_all_targets. */

 Show fail_over_mac. */

 Show the arp timer interval. */

 Show the arp targets. */

 eat the leftover space */

 Show the up and down delays. */

 Show the LACP activity and interval. */

 Show the number of peer notifications to send after a failover event. */

 Show the MII monitor interval. */

 Show the primary slave. */

 Show the primary_reselect flag. */

 Show the use_carrier flag. */

 Show currently active_slave. */

 Show link status of the bond interface. */

 Show current 802.3ad aggregator ID. */

 Show number of active 802.3ad ports. */

 Show current 802.3ad actor key. */

 Show current 802.3ad partner key. */

 Show current 802.3ad partner mac. */

 Show the queue_ids of the slaves in the current bond. */

 not enough space for another interface_name:queue_id pair */

 eat the leftover space */

 Show the all_slaves_active flag. */

 Show the number of IGMP membership reports to send on link failure */

/* Initialize sysfs.  This sets up the bonding_masters file in

 * /sys/class/net.

	/* Permit multiple loads of the module by ignoring failures to

	 * create the bonding_masters sysfs file.  Bonding devices

	 * created by second or subsequent loads of the module will

	 * not be listed in, or controllable by, bonding_masters, but

	 * will have the usual "bonding" sysfs directory.

	 *

	 * This is done to preserve backwards compatibility for

	 * initscripts/sysconfig, which load bonding multiple times to

	 * configure multiple bonding devices.

 Is someone being kinky and naming a device bonding_master? */

 Remove /sys/class/net/bonding_masters. */

/* Initialize sysfs for each bond.  This sets up and registers

 * the 'bondctl' directory for each individual bond under /sys/class/net.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/net/bond/bond_options.c - bonding options

 * Copyright (c) 2013 Jiri Pirko <jiri@resnulli.us>

 * Copyright (c) 2013 Scott Feldman <sfeldma@cumulusnetworks.com>

 Searches for an option by name */

 Searches for a value in opt's values[] table */

 Searches for a value in opt's values[] table which matches the flagmask */

/* If maxval is missing then there's no range to check. In case minval is

 * missing then it's considered to be 0.

/**

 * bond_opt_parse - parse option value

 * @opt: the option to parse against

 * @val: value to parse

 *

 * This function tries to extract the value from @val and check if it's

 * a possible match for the option and returns NULL if a match isn't found,

 * or the struct_opt_value that matched. It also strips the new line from

 * @val->string if it's present.

 No parsing if the option wants a raw val */

 ULLONG_MAX is used to bypass string processing */

		/* The following code extracts the string to match or the value

		 * and sets checkval appropriately

 Check for exact match */

 Found an exact match */

 Possible range match */

 Check opt's dependencies against bond mode and currently set options */

 sometimes RAWVAL opts may have new lines */

/**

 * __bond_opt_set - set a bonding option

 * @bond: target bond device

 * @option: option to set

 * @val: value to set it to

 *

 * This function is used to change the bond's option value, it can be

 * used for both enabling/changing an option and for disabling it. RTNL lock

 * must be obtained before calling this function.

/**

 * __bond_opt_set_notify - set a bonding option

 * @bond: target bond device

 * @option: option to set

 * @val: value to set it to

 *

 * This function is used to change the bond's option value and trigger

 * a notification to user sapce. It can be used for both enabling/changing

 * an option and for disabling it. RTNL lock must be obtained before calling

 * this function.

/**

 * bond_opt_tryset_rtnl - try to acquire rtnl and call __bond_opt_set

 * @bond: target bond device

 * @option: option to set

 * @buf: value to set it to

 *

 * This function tries to acquire RTNL without blocking and if successful

 * calls __bond_opt_set. It is mainly used for sysfs option manipulation.

/**

 * bond_opt_get - get a pointer to an option

 * @option: option for which to return a pointer

 *

 * This function checks if option is valid and if so returns a pointer

 * to its entry in the bond_opts[] option array.

 disable arp monitoring */

 set miimon to default value */

 don't cache arp_validate between modes */

 IFNAMSIZ */

 check to see if we are clearing active */

 do nothing */

/* There are two tricky bits here.  First, if MII monitoring is activated, then

 * we must disable ARP monitoring.  Second, if the timer isn't running, we must

 * start it.

		/* If the interface is up, we may need to fire off

		 * the MII timer. If the interface is down, the

		 * timer will get fired off when the open function

		 * is called.

/* Set up, down and peer notification delays. These must be multiples

 * of the MII monitoring value, and are stored internally as the

 * multiplier. Thus, we must translate to MS for the real world.

/* There are two tricky bits here.  First, if ARP monitoring is activated, then

 * we must disable MII monitoring.  Second, if the ARP timer isn't running,

 * we must start it.

		/* If the interface is up, we may need to fire off

		 * the ARP timer.  If the interface is down, the

		 * timer will get fired off when the open function

		 * is called.

 arp_validate can be set only in active-backup mode */

 dup */

 first free slot */

 check to see if we are clearing primary */

		/* reciprocal_packets_per_slave is unused if

		 * packets_per_slave is 0 or 1, just initialize it

 delim will point to queue id if successful */

	/* Terminate string that points to device name and bump it

	 * up one, so we can read the queue id there.

 Check buffer length, valid ifname and queue id */

 Get the pointer to that interface if it exists */

 Search for thes slave and check for duplicate qids */

			/* We don't need to check the matching

			 * slave for dups, since we're overwriting it

 Actually set the qids for the slave */

 IFNAMSIZ*/

 should not run here. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*	Sysfs attributes of bond slaves

 *

 *      Copyright (c) 2014 Scott Feldman <sfeldma@cumulusnetworks.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.

 sender hardware address */

 sender IP address */

 target hardware address */

 target IP address */

 Forward declaration */

********************** tlb specific functions ***************************/

 clear slave from tx_hashtbl */

 skip this if we've already freed the tx hash table */

 Must be called before starting the monitor timer */

 Must be called only after all slaves have been released */

 Convert to Megabit per sec */

 Bytes to bits */

 Find the slave with the largest gap */

	/* We don't need to disable softirq here, because

	 * tlb_choose_channel() is only called by bond_alb_xmit()

	 * which already has softirq disabled.

********************** rlb specific functions ***************************/

/* when an ARP REPLY is received from a client update its info

 * in the rx_hashtbl

 update the clients MAC address */

	/* We received an ARP from arp->ip_src.

	 * We might have used this IP address previously (on the bonding host

	 * itself or on a system that is bridged together with the bond).

	 * However, if arp->mac_src is different than what is stored in

	 * rx_hashtbl, some other host is now using the IP and we must prevent

	 * sending out client updates with this IP address and the old MAC

	 * address.

	 * Clean up all hash table entries that have this address as ip_src but

	 * have a different mac_src.

 update rx hash table for this ARP */

 Caller must hold rcu_read_lock() */

	/* we didn't find anything after the current or we have something

	 * better before and up to the current slave

 Caller must hold RTNL, rcu_read_lock is obtained only to silence checkers */

/* teach the switch the mac of a disabled slave

 * on the primary for fault tolerance

 *

 * Caller must hold RTNL

/* slave being removed should not be active at this point

 *

 * Caller must hold rtnl.

 clear slave from rx_hashtbl */

					/* A slave has been removed from the

					 * table because it is either disabled

					 * or being released. We must retry the

					 * update to avoid clients from not

					 * being updated & disconnecting when

					 * there is stress

 there is no active slave */

 sends ARP REPLIES that update the clients that need updating */

	/* do not update the entries again until this counter is zero so that

	 * not to confuse the clients.

 The slave was assigned a new mac address - update the clients */

 update the team's flag only after the whole iteration */

 fasten the change */

 mark all clients using src_ip to be updated */

		/* update all clients using this src_ip, that are not assigned

		 * to the team's address (curr_active_slave) and have a known

		 * unicast mac address.

 the entry is already assigned to this client */

 update mac address from arp */

			/* the entry is already assigned to some other client,

			 * move the old client to primary (curr_active_slave) so

			 * that the new client can be assigned to this entry.

 assign a new slave */

			/* ip_src is going to be updated,

			 * fix the src hash list

		/* arp->mac_dst is broadcast for arp requests.

		 * will be updated with clients actual unicast mac address

		 * upon receiving an arp reply.

/* chooses (and returns) transmit channel for arp reply

 * does not choose channel for other arp types since they are

 * sent on the curr_active_slave

	/* Don't modify or load balance ARPs that do not originate locally

	 * (e.g.,arrive via a bridge).

 the arp must be sent on the selected rx channel */

		/* Create an entry in the rx_hashtbl for this client as a

		 * place holder.

		 * When the arp reply is received the entry will be updated

		 * with the correct unicast address of the client.

		/* The ARP reply packets must be delayed so that

		 * they can cancel out the influence of the ARP request.

		/* arp requests are broadcast and are sent on the primary

		 * the arp request will collapse all clients on the subnet to

		 * the primary slave. We must register these clients to be

		 * updated with their assigned mac.

 update the team's flag only after the whole iteration */

 Caller must hold mode_lock */

 unlink a rlb hash table entry from the src list */

 is prev_index pointing to the head of this list? */

/* add the rx_hashtbl[ip_dst_hash] entry to the list

 * of entries with identical ip_src_hash

/* deletes all rx_hashtbl entries with arp->ip_src if their mac_src does

 * not match arp->mac_src

 register to receive ARPs */

********************** tlb/rlb shared functions *********************/

	/* If this is a macvlan device, then only send updates

	 * when strict_match is turned off.

 send untagged */

	/* loop through all devices and see if we need to send a packet

	 * for that device.

	/* for rlb each slave must have a unique hw mac addresses so that

	 * each slave will receive packets destined to a different mac

/* Swap MAC addresses between two slaves.

 *

 * Called with RTNL held, and no other locks.

/* Send learning packets after MAC address swap.

 *

 * Called with RTNL and no other locks

 fasten the change in the switch */

			/* inform the clients that the mac address

			 * has changed

			/* inform the clients that the mac address

			 * has changed

 A disabled slave was assigned an active mac addr */

/**

 * alb_change_hw_addr_on_detach

 * @bond: bonding we're working on

 * @slave: the slave that was just detached

 *

 * We assume that @slave was already detached from the slave list.

 *

 * If @slave's permanent hw address is different both from its current

 * address and from @bond's address, then somewhere in the bond there's

 * a slave that has @slave's permanet address as its current address.

 * We'll make sure that slave no longer uses @slave's permanent address.

 *

 * Caller must hold RTNL and no other locks

/**

 * alb_handle_addr_collision_on_attach

 * @bond: bonding we're working on

 * @slave: the slave that was just attached

 *

 * checks uniqueness of slave's mac address and handles the case the

 * new slave uses the bonds mac address.

 *

 * If the permanent hw address of @slave is @bond's hw address, we need to

 * find a different hw address to give @slave, that isn't in use by any other

 * slave in the bond. This address must be, of course, one of the permanent

 * addresses of the other slaves.

 *

 * We go over the slave list, and for each slave there we compare its

 * permanent hw address with the current address of all the other slaves.

 * If no match was found, then we've found a slave with a permanent address

 * that isn't used by any other slave in the bond, so we can assign it to

 * @slave.

 *

 * assumption: this function is called before @slave is attached to the

 *	       bond slave list.

 this is the first slave */

	/* if slave's mac address differs from bond's mac address

	 * check uniqueness of slave's mac address against the other

	 * slaves in the bond.

		/* Try setting slave mac to bond address and fall-through

		 * to code handling that situation below...

	/* The slave's address is equal to the address of the bond.

	 * Search for a spare address in the bond for this slave.

			/* no slave has tmp_slave1's perm addr

			 * as its curr addr

/**

 * alb_set_mac_address

 * @bond: bonding we're working on

 * @addr: MAC address to set

 *

 * In TLB mode all slaves are configured to the bond's hw address, but set

 * their dev_addr field to different addresses (based on their permanent hw

 * addresses).

 *

 * For each slave, this function sets the interface to the new address and then

 * changes its dev_addr field to its previous value.

 *

 * Unwinding assumes bond's mac address has not yet changed.

 save net_device's current hw address */

 restore net_device's hw address */

 unwind from head to the slave that failed */

*********************** exported alb functions ************************/

 unbalanced or unassigned, send through primary */

 no suitable interface, frame not sent */

 Do not TX balance any multicast or broadcast */

		/* IPv6 doesn't really use broadcast mac address, but leave

		 * that here just in case.

		/* IPv6 uses all-nodes multicast as an equivalent to

		 * broadcasts in IPv4.

		/* Additionally, DAD probes should not be tx-balanced as that

		 * will lead to false positives for duplicate addresses and

		 * prevent address configuration from working.

			/*

			 * do_tx_balance means we are free to select the tx_slave

			 * So we do exactly what tlb would do for hash selection

 send learning packets */

			/* If updating current_active, use all currently

			 * user mac addresses (!strict_match).  Otherwise, only

			 * use mac of the slave device.

			 * In RLB mode, we always use strict matches.

 rebalance tx traffic */

			/* dev_set_promiscuity requires rtnl and

			 * nothing else.  Avoid race with bond_close.

			/* If the primary was set to promiscuous mode

			 * because a slave was disabled then

			 * it can now leave promiscuous mode.

 check if clients need updating */

/* assumption: called before the slave is attached to the bond

 * and not locked by the bond lock

 order a rebalance ASAP */

/* Remove slave from tlb and rlb hash tables, and fix up MAC addresses

 * if necessary.

 *

 * Caller must hold RTNL and no other locks

 order a rebalance ASAP */

			/* If the updelay module parameter is smaller than the

			 * forwarding delay of the switch the rebalance will

			 * not work because the rebalance arp replies will

			 * not be forwarded to the clients..

/**

 * bond_alb_handle_active_change - assign new curr_active_slave

 * @bond: our bonding struct

 * @new_slave: new slave to assign

 *

 * Set the bond->curr_active_slave to @new_slave and handle

 * mac address swapping and promiscuity changes as needed.

 *

 * Caller must hold RTNL

	/* set the new curr_active_slave to the bonds mac address

	 * i.e. swap mac addresses of old curr_active_slave and new curr_active_slave

	/* Arrange for swap_slave and new_slave to temporarily be

	 * ignored so we can mess with their MAC addresses without

	 * fear of interference from transmit activity.

	/* in TLB mode, the slave might flip down/up with the old dev_addr,

	 * and thus filter bond->dev_addr's packets, so force bond's mac

 we don't care if it can't change its mac, best effort */

 curr_active_slave must be set before calling alb_swap_mac_addr */

 swap mac address */

 set the new_slave to the bond mac address */

 Called with RTNL */

	/* If there is no curr_active_slave there is nothing else to do.

	 * Otherwise we'll need to pass the new address to it and handle

	 * duplications.

 inform clients mac address has changed */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/net/bond/bond_netlink.c - Netlink interface for bonding

 * Copyright (c) 2013 Jiri Pirko <jiri@resnulli.us>

 * Copyright (c) 2013 Scott Feldman <sfeldma@cumulusnetworks.com>

 IFLA_BOND_SLAVE_STATE */

 IFLA_BOND_SLAVE_MII_STATUS */

 IFLA_BOND_SLAVE_LINK_FAILURE_COUNT */

 IFLA_BOND_SLAVE_PERM_HWADDR */

 IFLA_BOND_SLAVE_QUEUE_ID */

 IFLA_BOND_SLAVE_AD_AGGREGATOR_ID */

 IFLA_BOND_SLAVE_AD_ACTOR_OPER_PORT_STATE */

 IFLA_BOND_SLAVE_AD_PARTNER_OPER_PORT_STATE */

 queue_id option setting expects slave_name:queue_id */

 IFLA_BOND_MODE */

 IFLA_BOND_ACTIVE_SLAVE */

 IFLA_BOND_MIIMON */

 IFLA_BOND_UPDELAY */

 IFLA_BOND_DOWNDELAY */

 IFLA_BOND_USE_CARRIER */

 IFLA_BOND_ARP_INTERVAL */

 IFLA_BOND_ARP_IP_TARGET */

 IFLA_BOND_ARP_VALIDATE */

 IFLA_BOND_ARP_ALL_TARGETS */

 IFLA_BOND_PRIMARY */

 IFLA_BOND_PRIMARY_RESELECT */

 IFLA_BOND_FAIL_OVER_MAC */

 IFLA_BOND_XMIT_HASH_POLICY */

 IFLA_BOND_RESEND_IGMP */

 IFLA_BOND_NUM_PEER_NOTIF */

 IFLA_BOND_ALL_SLAVES_ACTIVE */

 IFLA_BOND_MIN_LINKS */

 IFLA_BOND_LP_INTERVAL */

 IFLA_BOND_PACKETS_PER_SLAVE */

 IFLA_BOND_AD_LACP_ACTIVE */

 IFLA_BOND_AD_LACP_RATE */

 IFLA_BOND_AD_SELECT */

 IFLA_BOND_AD_INFO */

 IFLA_BOND_AD_INFO_AGGREGATOR */

 IFLA_BOND_AD_INFO_NUM_PORTS */

 IFLA_BOND_AD_INFO_ACTOR_KEY */

 IFLA_BOND_AD_INFO_PARTNER_KEY*/

 IFLA_BOND_AD_INFO_PARTNER_MAC*/

 IFLA_BOND_AD_ACTOR_SYS_PRIO */

 IFLA_BOND_AD_USER_PORT_KEY */

 IFLA_BOND_AD_ACTOR_SYSTEM */

 IFLA_BOND_TLB_DYNAMIC_LB */

 IFLA_BOND_PEER_NOTIF_DELAY */

	.get_num_rx_queues	= bond_get_num_tx_queues, /* Use the same number

 SPDX-License-Identifier: GPL-2.0

 ARP information */

/* Create the bonding directory under /proc/net, if doesn't exist yet.

 * Caller must hold rtnl_lock.

/* Destroy the bonding directory under /proc/net, if empty.

 * Caller must hold rtnl_lock.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.

 General definitions */

 Timer definitions (43.4.4 in the 802.3ad standard) */

/* Port Variables definitions used by the State Machines (43.4.7 in the

 * 802.3ad standard)

/* Port Key definitions

 * key is determined according to the link speed, duplex and

 * user key (which is yet not supported)

 *           --------------------------------------------------------------

 * Port key  | User key (10 bits)           | Speed (5 bits)      | Duplex|

 *           --------------------------------------------------------------

 *           |15                           6|5                   1|0

 compare MAC addresses */

 ================= main 802.3ad protocol functions ================== */

 ================= api to bonding and kernel code ================== */

/**

 * __get_bond_by_port - get the port's bonding struct

 * @port: the port we're looking at

 *

 * Return @port's bonding struct, or %NULL if it can't be found.

/**

 * __get_first_agg - get the first aggregator in the bond

 * @port: the port we're looking at

 *

 * Return the aggregator of the first slave in @bond, or %NULL if it can't be

 * found.

 * The caller must hold RCU or RTNL lock.

 If there's no bond for this port, or bond has no slaves */

/**

 * __agg_has_partner - see if we have a partner

 * @agg: the agregator we're looking at

 *

 * Return nonzero if aggregator has a partner (denoted by a non-zero ether

 * address for the partner). Return 0 if not.

/**

 * __disable_port - disable the port's slave

 * @port: the port we're looking at

/**

 * __enable_port - enable the port's slave, if it's up

 * @port: the port we're looking at

/**

 * __port_is_enabled - check if the port's slave is in active state

 * @port: the port we're looking at

/**

 * __get_agg_selection_mode - get the aggregator selection mode

 * @port: the port we're looking at

 *

 * Get the aggregator selection mode. Can be %STABLE, %BANDWIDTH or %COUNT.

/**

 * __check_agg_selection_timer - check if the selection timer has expired

 * @port: the port we're looking at

/**

 * __get_link_speed - get a port's speed

 * @port: the port we're looking at

 *

 * Return @port's speed in 802.3ad enum format. i.e. one of:

 *     0,

 *     %AD_LINK_SPEED_10MBPS,

 *     %AD_LINK_SPEED_100MBPS,

 *     %AD_LINK_SPEED_1000MBPS,

 *     %AD_LINK_SPEED_2500MBPS,

 *     %AD_LINK_SPEED_5000MBPS,

 *     %AD_LINK_SPEED_10000MBPS

 *     %AD_LINK_SPEED_14000MBPS,

 *     %AD_LINK_SPEED_20000MBPS

 *     %AD_LINK_SPEED_25000MBPS

 *     %AD_LINK_SPEED_40000MBPS

 *     %AD_LINK_SPEED_50000MBPS

 *     %AD_LINK_SPEED_56000MBPS

 *     %AD_LINK_SPEED_100000MBPS

 *     %AD_LINK_SPEED_200000MBPS

 *     %AD_LINK_SPEED_400000MBPS

	/* this if covers only a special case: when the configuration starts

	 * with link down, it sets the speed to 0.

	 * This is done in spite of the fact that the e100 driver reports 0

	 * to be compatible with MVT in the future.

 unknown speed value from ethtool. shouldn't happen */

/**

 * __get_duplex - get a port's duplex

 * @port: the port we're looking at

 *

 * Return @port's duplex in 802.3ad bitmask format. i.e.:

 *     0x01 if in full duplex

 *     0x00 otherwise

	/* handling a special case: when the configuration starts with

	 * link down, it sets the duplex to 0.

 Conversions */

/**

 * __ad_timer_to_ticks - convert a given timer type to AD module ticks

 * @timer_type:	which timer to operate

 * @par: timer parameter. see below

 *

 * If @timer_type is %current_while_timer, @par indicates long/short timer.

 * If @timer_type is %periodic_timer, @par is one of %FAST_PERIODIC_TIME,

 *						     %SLOW_PERIODIC_TIME.

 to silence the compiler */

 for rx machine usage */

 for local churn machine */

 for periodic machine */

 long timeout */

 for remote churn machine */

 for selection machine */

 ================= ad_rx_machine helper functions ================== */

/**

 * __choose_matched - update a port's matched variable from a received lacpdu

 * @lacpdu: the lacpdu we've received

 * @port: the port we're looking at

 *

 * Update the value of the matched variable, using parameter values from a

 * newly received lacpdu. Parameter values for the partner carried in the

 * received PDU are compared with the corresponding operational parameter

 * values for the actor. Matched is set to TRUE if all of these parameters

 * match and the PDU parameter partner_state.aggregation has the same value as

 * actor_oper_port_state.aggregation and lacp will actively maintain the link

 * in the aggregation. Matched is also set to TRUE if the value of

 * actor_state.aggregation in the received PDU is set to FALSE, i.e., indicates

 * an individual link and lacp will actively maintain the link. Otherwise,

 * matched is set to FALSE. LACP is considered to be actively maintaining the

 * link if either the PDU's actor_state.lacp_activity variable is TRUE or both

 * the actor's actor_oper_port_state.lacp_activity and the PDU's

 * partner_state.lacp_activity variables are TRUE.

 *

 * Note: the AD_PORT_MATCHED "variable" is not specified by 802.3ad; it is

 * used here to implement the language from 802.3ad 43.4.9 that requires

 * recordPDU to "match" the LACPDU parameters to the stored values.

	/* check if all parameters are alike

	 * or this is individual link(aggregation == FALSE)

	 * then update the state machine Matched variable.

/**

 * __record_pdu - record parameters from a received lacpdu

 * @lacpdu: the lacpdu we've received

 * @port: the port we're looking at

 *

 * Record the parameter values for the Actor carried in a received lacpdu as

 * the current partner operational parameter values and sets

 * actor_oper_port_state.defaulted to FALSE.

		/* record the new parameter values for the partner

		 * operational

 set actor_oper_port_state.defaulted to FALSE */

		/* set the partner sync. to on if the partner is sync,

		 * and the port is matched

/**

 * __record_default - record default parameters

 * @port: the port we're looking at

 *

 * This function records the default parameter values for the partner carried

 * in the Partner Admin parameters as the current partner operational parameter

 * values and sets actor_oper_port_state.defaulted to TRUE.

 record the partner admin parameters */

 set actor_oper_port_state.defaulted to true */

/**

 * __update_selected - update a port's Selected variable from a received lacpdu

 * @lacpdu: the lacpdu we've received

 * @port: the port we're looking at

 *

 * Update the value of the selected variable, using parameter values from a

 * newly received lacpdu. The parameter values for the Actor carried in the

 * received PDU are compared with the corresponding operational parameter

 * values for the ports partner. If one or more of the comparisons shows that

 * the value(s) received in the PDU differ from the current operational values,

 * then selected is set to FALSE and actor_oper_port_state.synchronization is

 * set to out_of_sync. Otherwise, selected remains unchanged.

		/* check if any parameter is different then

		 * update the state machine selected variable.

/**

 * __update_default_selected - update a port's Selected variable from Partner

 * @port: the port we're looking at

 *

 * This function updates the value of the selected variable, using the partner

 * administrative parameter values. The administrative values are compared with

 * the corresponding operational parameter values for the partner. If one or

 * more of the comparisons shows that the administrative value(s) differ from

 * the current operational values, then Selected is set to FALSE and

 * actor_oper_port_state.synchronization is set to OUT_OF_SYNC. Otherwise,

 * Selected remains unchanged.

		/* check if any parameter is different then

		 * update the state machine selected variable.

/**

 * __update_ntt - update a port's ntt variable from a received lacpdu

 * @lacpdu: the lacpdu we've received

 * @port: the port we're looking at

 *

 * Updates the value of the ntt variable, using parameter values from a newly

 * received lacpdu. The parameter values for the partner carried in the

 * received PDU are compared with the corresponding operational parameter

 * values for the Actor. If one or more of the comparisons shows that the

 * value(s) received in the PDU differ from the current operational values,

 * then ntt is set to TRUE. Otherwise, ntt remains unchanged.

 validate lacpdu and port */

		/* check if any parameter is different then

		 * update the port->ntt.

/**

 * __agg_ports_are_ready - check if all ports in an aggregator are ready

 * @aggregator: the aggregator we're looking at

 *

		/* scan all ports in this aggregator to verfy if they are

		 * all ready.

/**

 * __set_agg_ports_ready - set value of Ready bit in all ports of an aggregator

 * @aggregator: the aggregator we're looking at

 * @val: Should the ports' ready bit be set on or off

 *

/**

 * __get_agg_bandwidth - get the total bandwidth of an aggregator

 * @aggregator: the aggregator we're looking at

 *

 to silence the compiler */

/**

 * __get_active_agg - get the current active aggregator

 * @aggregator: the aggregator we're looking at

 *

 * Caller must hold RCU lock.

/**

 * __update_lacpdu_from_port - update a port's lacpdu fields

 * @port: the port we're looking at

	/* update current actual Actor parameters

	 * lacpdu->subtype                   initialized

	 * lacpdu->version_number            initialized

	 * lacpdu->tlv_type_actor_info       initialized

	 * lacpdu->actor_information_length  initialized

	/* lacpdu->reserved_3_1              initialized

	 * lacpdu->tlv_type_partner_info     initialized

	 * lacpdu->partner_information_length initialized

	/* lacpdu->reserved_3_2              initialized

	 * lacpdu->tlv_type_collector_info   initialized

	 * lacpdu->collector_information_length initialized

	 * collector_max_delay                initialized

	 * reserved_12[12]                   initialized

	 * tlv_type_terminator               initialized

	 * terminator_length                 initialized

	 * reserved_50[50]                   initialized

 ================= main 802.3ad protocol code ========================= */

/**

 * ad_lacpdu_send - send out a lacpdu packet on a given port

 * @port: the port we're looking at

 *

 * Returns:   0 on success

 *          < 0 on error

	/* Note: source address is set to be the member's PERMANENT address,

	 * because we use it to identify loopback lacpdus in receive.

/**

 * ad_marker_send - send marker information/response on a given port

 * @port: the port we're looking at

 * @marker: marker data to send

 *

 * Returns:   0 on success

 *          < 0 on error

	/* Note: source address is set to be the member's PERMANENT address,

	 * because we use it to identify loopback MARKERs in receive.

/**

 * ad_mux_machine - handle a port's mux state machine

 * @port: the port we're looking at

 * @update_slave_arr: Does slave array need update?

	/* keep current State Machine state to compare later if it was

	 * changed

 if SELECTED or STANDBY */

 if SELECTED == FALSE return to DETACH state */

				/* in order to withhold the Selection Logic to

				 * check all ports READY_N value every callback

				 * cycle to update ready variable, we check

				 * READY_N and update READY here

 check if the wait_while_timer expired */

			/* in order to withhold the selection logic to check

			 * all ports READY_N value every callback cycle to

			 * update ready variable, we check READY_N and update

			 * READY here

			/* if the wait_while_timer expired, and the port is

			 * in READY state, move to ATTACHED state

			/* check also if agg_select_timer expired (so the

			 * edable port will take place only after this timer)

 if UNSELECTED or STANDBY */

				/* in order to withhold the selection logic to

				 * check all ports READY_N value every callback

				 * cycle to update ready variable, we check

				 * READY_N and update READY here

				/* if port state hasn't changed make

				 * sure that a collecting distributing

				 * port in an active aggregator is enabled

 check if the state machine was changed */

/**

 * ad_rx_machine - handle a port's rx State Machine

 * @lacpdu: the lacpdu we've received

 * @port: the port we're looking at

 *

 * If lacpdu arrived, stop previous timer (if exists) and set the next state as

 * CURRENT. If timer expired set the state machine in the proper state.

 * In other cases, this function checks if we need to switch to other state.

	/* keep current State Machine state to compare later if it was

	 * changed

 check if state machine should change state */

 first, check if port was reinitialized */

 check if port is not enabled */

 check if new lacpdu arrived */

 if timer is on, and if it is expired */

 if no lacpdu arrived and no timer is on */

 check if the State machine was changed or new lacpdu arrived */

			/* Reset of the Synchronization flag (Standard 43.4.12)

			 * This reset cause to disable this port in the

			 * COLLECTING_DISTRIBUTING state of the mux machine in

			 * case of EXPIRED even if LINK_DOWN didn't arrive for

			 * the port.

 detect loopback situation */

/**

 * ad_churn_machine - handle port churn's state machine

 * @port: the port we're looking at

 *

/**

 * ad_tx_machine - handle a port's tx state machine

 * @port: the port we're looking at

	/* check if tx timer expired, to verify that we do not send more than

	 * 3 packets per second

 check if there is something to send */

				/* mark ntt as false, so it will not be sent

				 * again until demanded

		/* restart tx timer(to verify that we will not exceed

		 * AD_MAX_TX_IN_SECOND

/**

 * ad_periodic_machine - handle a port's periodic state machine

 * @port: the port we're looking at

 * @bond_params: bond parameters we will use

 *

 * Turn ntt flag on priodically to perform periodic transmission of lacpdu's.

 keep current state machine state to compare later if it was changed */

 check if port was reinitialized */

 check if state machine should change state */

 check if periodic state machine expired */

 if expired then do tx */

			/* If not expired, check if there is some new timeout

			 * parameter from the partner state

 check if the state machine was changed */

 decrement 1 tick we lost in the PERIODIC_TX cycle */

 decrement 1 tick we lost in the PERIODIC_TX cycle */

/**

 * ad_port_selection_logic - select aggregation groups

 * @port: the port we're looking at

 * @update_slave_arr: Does slave array need update?

 *

 * Select aggregation groups, and assign each port for it's aggregetor. The

 * selection logic is called in the inititalization (after all the handshkes),

 * and after every lacpdu receive (if selected is off).

 if the port is already Selected, do nothing */

 if the port is connected to other aggregator, detach it */

 detach the port from its former aggregator */

				/* if it is the first port attached to the

				 * aggregator

					/* not the first port attached to the

					 * aggregator

				/* clear the port's relations to this

				 * aggregator

				/* if the aggregator is empty, clear its

				 * parameters, and set it ready to be attached

			/* meaning: the port was related to an aggregator

			 * but was not on the aggregator port list

 search on all aggregators for a suitable aggregator for this port */

 keep a free aggregator for later use(if needed) */

 check if current aggregator suits us */

 if all parameters match AND */

 partner answers */

 but is not individual OR */

 attach to the founded aggregator */

 mark this port as selected */

	/* the port couldn't find an aggregator - attach it to a new

	 * aggregator

 assign port a new aggregator */

			/* update the new aggregator's parameters

			 * if port was responsed from the end-user

 if port is full duplex */

 mark this port as selected */

	/* if all aggregator's ports are READY_N == TRUE, set ready=TRUE

	 * in all aggregator's ports, else set ready=FALSE in all

	 * aggregator's ports

/* Decide if "agg" is a better choice for the new active aggregator that

 * the current best, according to the ad_select policy.

	/* 0. If no best, select current.

	 *

	 * 1. If the current agg is not individual, and the best is

	 *    individual, select current.

	 *

	 * 2. If current agg is individual and the best is not, keep best.

	 *

	 * 3. Therefore, current and best are both individual or both not

	 *    individual, so:

	 *

	 * 3a. If current agg partner replied, and best agg partner did not,

	 *     select current.

	 *

	 * 3b. If current agg partner did not reply and best agg partner

	 *     did reply, keep best.

	 *

	 * 4.  Therefore, current and best both have partner replies or

	 *     both do not, so perform selection policy:

	 *

	 * BOND_AD_COUNT: Select by count of ports.  If count is equal,

	 *     select by bandwidth.

	 *

	 * BOND_AD_STABLE, BOND_AD_BANDWIDTH: Select by bandwidth.

/**

 * ad_agg_selection_logic - select an aggregation group for a team

 * @agg: the aggregator we're looking at

 * @update_slave_arr: Does slave array need update?

 *

 * It is assumed that only one aggregator may be selected for a team.

 *

 * The logic of this function is to select the aggregator according to

 * the ad_select policy:

 *

 * BOND_AD_STABLE: select the aggregator with the most ports attached to

 * it, and to reselect the active aggregator only if the previous

 * aggregator has no more ports related to it.

 *

 * BOND_AD_BANDWIDTH: select the aggregator with the highest total

 * bandwidth, and reselect whenever a link state change takes place or the

 * set of slaves in the bond changes.

 *

 * BOND_AD_COUNT: select the aggregator with largest number of ports

 * (slaves), and reselect whenever a link state change takes place or the

 * set of slaves in the bond changes.

 *

 * FIXME: this function MUST be called with the first agg in the bond, or

 * __get_active_agg() won't work correctly. This function should be better

 * called with the bond itself, and retrieve the first agg from it.

		/* For the STABLE policy, don't replace the old active

		 * aggregator if it's still active (it has an answering

		 * partner) or if both the best and active don't have an

		 * answering partner.

 if there is new best aggregator, activate it */

 check if any partner replies */

		/* disable the ports that were related to the former

		 * active_aggregator

 Slave array needs update. */

	/* if the selected aggregator is of join individuals

	 * (partner_system is NULL), enable their ports

/**

 * ad_clear_agg - clear a given aggregator's parameters

 * @aggregator: the aggregator we're looking at

/**

 * ad_initialize_agg - initialize a given aggregator's parameters

 * @aggregator: the aggregator we're looking at

/**

 * ad_initialize_port - initialize a given port's parameters

 * @port: the port we're looking at

 * @lacp_fast: boolean. whether fast periodic should be used

 private parameters */

/**

 * ad_enable_collecting_distributing - enable a port's transmit/receive

 * @port: the port we're looking at

 * @update_slave_arr: Does slave array need update?

 *

 * Enable @port if it's in an active aggregator

 Slave array needs update */

/**

 * ad_disable_collecting_distributing - disable a port's transmit/receive

 * @port: the port we're looking at

 * @update_slave_arr: Does slave array need update?

 Slave array needs an update */

/**

 * ad_marker_info_received - handle receive of a Marker information frame

 * @marker_info: Marker info received

 * @port: the port we're looking at

 copy the received marker data to the response marker */

 change the marker subtype to marker response */

 send the marker response */

/**

 * ad_marker_response_received - handle receive of a marker response frame

 * @marker: marker PDU received

 * @port: the port we're looking at

 *

 * This function does nothing since we decided not to implement send and handle

 * response for marker PDU's, in this stage, but only to respond to marker

 * information.

 DO NOTHING, SINCE WE DECIDED NOT TO IMPLEMENT THIS FEATURE FOR NOW */

 ========= AD exported functions to the main bonding code ========= */

 Check aggregators status in team every T seconds */

/**

 * bond_3ad_initiate_agg_selection - initate aggregator selection

 * @bond: bonding struct

 * @timeout: timeout value to set

 *

 * Set the aggregation selection timer, to initiate an agg selection in

 * the very near future.  Called during first initialization, and during

 * any down to up transitions of the bond.

/**

 * bond_3ad_initialize - initialize a bond's 802.3ad parameters and structures

 * @bond: bonding struct to work on

 * @tick_resolution: tick duration (millisecond resolution)

 *

 * Can be called only after the mac address of the bond is set.

 check that the bond is not initialized yet */

		/* initialize how many times this module is called in one

		 * second (should be about every 100ms)

/**

 * bond_3ad_bind_slave - initialize a slave's port

 * @slave: slave struct to work on

 *

 * Returns:   0 on success

 *          < 0 on error

 check that the slave has not been initialized yet. */

 port initialization */

		/* key is determined according to the link speed, duplex and

		 * user key

 actor system is the bond's system */

		/* tx timer(to verify that no more than MAX_TX_IN_SECOND

		 * lacpdu's are sent in one second)

 aggregator initialization */

/**

 * bond_3ad_unbind_slave - deinitialize a slave's port

 * @slave: slave struct to work on

 *

 * Search for the aggregator that is related to this port, remove the

 * aggregator and assign another aggregator for other port related to it

 * (if any), and remove the port.

 Ignore this value as caller updates array */

 Sync against bond_3ad_state_machine_handler() */

 if slave is null, the whole port is not initialized */

 Tell the partner that this port is not suitable for aggregation */

 check if this aggregator is occupied */

		/* check if there are other ports related to this aggregator

		 * except the port related to this slave(thats ensure us that

		 * there is a reason to search for new aggregator, and that we

		 * will find one

 find new aggregator for the related port(s) */

				/* if the new aggregator is empty, or it is

				 * connected to our port only

			/* if new aggregator found, copy the aggregator's

			 * parameters and connect the related lag_ports to the

			 * new aggregator

				/* update the information that is written on

				 * the ports about the aggregator

			/* in case that the only port related to this

			 * aggregator is the one we want to remove

 select new active aggregator */

 find the aggregator that this port is connected to */

 search the port in the aggregator's related ports */

				/* the aggregator found - detach the port from

				 * this aggregator

 select new active aggregator */

/**

 * bond_3ad_update_ad_actor_settings - reflect change of actor settings to ports

 * @bond: bonding struct to work on

 *

 * If an ad_actor setting gets changed we need to update the individual port

 * settings so the bond device will use the new values when it gets upped.

/**

 * bond_3ad_state_machine_handler - handle state machines timeout

 * @work: work context to fetch bonding struct to work on from

 *

 * The state machine handling concept in this module is to check every tick

 * which state machine should operate any function. The execution order is

 * round robin, so when we have an interaction between state machines, the

 * reply of one to each other might be delayed until next tick.

 *

 * This function also complete the initialization when the agg_select_timer

 * times out, and it selects an aggregator for the ports that are yet not

 * related to any aggregator, and selects the active aggregator for a bond.

	/* Lock to protect data accessed by all (e.g., port->sm_vars) and

	 * against running with bond_3ad_unbind_slave. ad_rx_machine may run

	 * concurrently due to incoming LACPDU as well.

 check if there are any slaves */

 check if agg_select_timer timer after initialize is timed out */

 select the active aggregator for the bond */

 for each port run the state machines */

 turn off the BEGIN bit, since we already handled it */

/**

 * bond_3ad_rx_indication - handle a received frame

 * @lacpdu: received lacpdu

 * @slave: slave struct to work on

 *

 * It is assumed that frames that were sent on this NIC don't returned as new

 * received frames (loopback). Since only the payload is given to this

 * function, it check for loopback.

 Protect against concurrent state machines */

		/* No need to convert fields to Little Endian since we

		 * don't use the marker's fields.

/**

 * ad_update_actor_keys - Update the oper / admin keys for a port based on

 * its current speed and duplex settings.

 *

 * @port: the port we'are looking at

 * @reset: Boolean to just reset the speed and the duplex part of the key

 *

 * The logic to change the oper / admin keys is:

 * (a) A full duplex port can participate in LACP with partner.

 * (b) When the speed is changed, LACP need to be reinitiated.

 Only 'duplex' port participates in LACP */

 Speed change restarts LACP state-machine */

/**

 * bond_3ad_adapter_speed_duplex_changed - handle a slave's speed / duplex

 * change indication

 *

 * @slave: slave struct to work on

 *

 * Handle reselection of aggregator (if needed) for this port.

 if slave is null, the whole port is not initialized */

/**

 * bond_3ad_handle_link_change - handle a slave's link status change indication

 * @slave: slave struct to work on

 * @link: whether the link is now up or down

 *

 * Handle reselection of aggregator (if needed) for this port.

 if slave is null, the whole port is not initialized */

	/* on link down we are zeroing duplex and speed since

	 * some of the adaptors(ce1000.lan) report full duplex/speed

	 * instead of N/A(duplex) / 0(speed).

	 *

	 * on link up we are forcing recheck on the duplex and speed since

	 * some of he adaptors(ce1000.lan) report.

 link has failed */

	/* RTNL is held and mode_lock is released so it's safe

	 * to update slave_array here.

/**

 * bond_3ad_set_carrier - set link state for bonding master

 * @bond: bonding structure

 *

 * if we have an active aggregator, we're up, if not, we're down.

 * Presumes that we cannot have an active aggregator if there are

 * no slaves with link up.

 *

 * This behavior complies with IEEE 802.3 section 43.3.9.

 *

 * Called by bond_set_carrier(). Return zero if carrier state does not

 * change, nonzero if it does.

 are enough slaves available to consider link up? */

/**

 * __bond_3ad_get_active_agg_info - get information of the active aggregator

 * @bond: bonding struct to work on

 * @ad_info: ad_info struct to fill with the bond's info

 *

 * Returns:   0 on success

 *          < 0 on error

/**

 * bond_3ad_update_lacp_rate - change the lacp rate

 * @bond: bonding struct

 *

 * When modify lacp_rate parameter via sysfs,

 * update actor_oper_port_state of each port.

 *

 * Hold bond->mode_lock,

 * so we can modify port->actor_oper_port_state,

 * no matter bond is up or down.

 BOND_3AD_STAT_LACPDU_RX */

 BOND_3AD_STAT_LACPDU_TX */

 BOND_3AD_STAT_LACPDU_UNKNOWN_RX */

 BOND_3AD_STAT_LACPDU_ILLEGAL_RX */

 BOND_3AD_STAT_MARKER_RX */

 BOND_3AD_STAT_MARKER_TX */

 BOND_3AD_STAT_MARKER_RESP_RX */

 BOND_3AD_STAT_MARKER_RESP_TX */

 BOND_3AD_STAT_MARKER_UNKNOWN_RX */

 SPDX-License-Identifier: GPL-2.0

 Show RLB hash table */

 !CONFIG_DEBUG_FS */

 CONFIG_DEBUG_FS */

 SPDX-License-Identifier: GPL-2.0-or-later

/*	(c) Copyright 1998 Alan Cox <alan@lxorguk.ukuu.org.uk>

 *	(c) Copyright 2000, 2001 Red Hat Inc

 *

 *	Development of this driver was funded by Equiinet Ltd

 *			http://www.equiinet.com

 *

 *	ChangeLog:

 *

 *	Asynchronous mode dropped for 2.2. For 2.5 we will attempt the

 *	unification of all the Z85x30 asynchronous drivers for real.

 *

 *	DMA now uses get_free_page as kmalloc buffers may span a 64K

 *	boundary.

 *

 *	Modified for SMP safety and SMP locking by Alan Cox

 *					<alan@lxorguk.ukuu.org.uk>

 *

 *	Performance

 *

 *	Z85230:

 *	Non DMA you want a 486DX50 or better to do 64Kbits. 9600 baud

 *	X.25 is not unrealistic on all machines. DMA mode can in theory

 *	handle T1/E1 quite nicely. In practice the limit seems to be about

 *	512Kbit->1Mbit depending on motherboard.

 *

 *	Z85C30:

 *	64K will take DMA, 9600 baud X.25 should be ok.

 *

 *	Z8530:

 *	Synchronous mode without DMA is unlikely to pass about 2400 baud.

/**

 *	z8530_read_port - Architecture specific interface function

 *	@p: port to read

 *

 *	Provided port access methods. The Comtrol SV11 requires no delays

 *	between accesses and uses PC I/O. Some drivers may need a 5uS delay

 *

 *	In the longer term this should become an architecture specific

 *	section so that this can become a generic driver interface for all

 *	platforms. For now we only handle PC I/O ports with or without the

 *	dread 5uS sanity delay.

 *

 *	The caller must hold sufficient locks to avoid violating the horrible

 *	5uS delay rule.

 gcc should figure this out efficiently ! */

/**

 *	z8530_write_port - Architecture specific interface function

 *	@p: port to write

 *	@d: value to write

 *

 *	Write a value to a port with delays if need be. Note that the

 *	caller must hold locks to avoid read/writes from other contexts

 *	violating the 5uS rule

 *

 *	In the longer term this should become an architecture specific

 *	section so that this can become a generic driver interface for all

 *	platforms. For now we only handle PC I/O ports with or without the

 *	dread 5uS sanity delay.

/**

 *	read_zsreg - Read a register from a Z85230

 *	@c: Z8530 channel to read from (2 per chip)

 *	@reg: Register to read

 *	FIXME: Use a spinlock.

 *

 *	Most of the Z8530 registers are indexed off the control registers.

 *	A read is done by writing to the control register and reading the

 *	register back.  The caller must hold the lock

/**

 *	read_zsdata - Read the data port of a Z8530 channel

 *	@c: The Z8530 channel to read the data port from

 *

 *	The data port provides fast access to some things. We still

 *	have all the 5uS delays to worry about.

/**

 *	write_zsreg - Write to a Z8530 channel register

 *	@c: The Z8530 channel

 *	@reg: Register number

 *	@val: Value to write

 *

 *	Write a value to an indexed register. The caller must hold the lock

 *	to honour the irritating delay rules. We know about register 0

 *	being fast to access.

 *

 *      Assumes c->lock is held.

/**

 *	write_zsctrl - Write to a Z8530 control register

 *	@c: The Z8530 channel

 *	@val: Value to write

 *

 *	Write directly to the control register on the Z8530

/**

 *	write_zsdata - Write to a Z8530 control register

 *	@c: The Z8530 channel

 *	@val: Value to write

 *

 *	Write directly to the data register on the Z8530

/*	Register loading parameters for a dead port

/*	Register loading parameters for currently supported circuit types

/*	Data clocked by telco end. This is the correct data for the UK

 *	"kilostream" service, and most other similar services.

 No vector */

 Disable interrupts */

MARKIDLE ??*/

/*	As above but for enhanced chips.

 No vector */

 Disable interrupts */

 MARKIDLE?? */

 Extended mode AUTO TX and EOM*/

/**

 *	z8530_flush_fifo - Flush on chip RX FIFO

 *	@c: Channel to flush

 *

 *	Flush the receive FIFO. There is no specific option for this, we

 *	blindly read bytes and discard them. Reading when there is no data

 *	is harmless. The 8530 has a 4 byte FIFO, the 85230 has 8 bytes.

 *

 *	All locking is handled for the caller. On return data may still be

 *	present if it arrived during the flush.

/**

 *	z8530_rtsdtr - Control the outgoing DTS/RTS line

 *	@c: The Z8530 channel to control;

 *	@set: 1 to set, 0 to clear

 *

 *	Sets or clears DTR/RTS on the requested line. All locking is handled

 *	by the caller. For now we assume all boards use the actual RTS/DTR

 *	on the chip. Apparently one or two don't. We'll scream about them

 *	later.

/**

 *	z8530_rx - Handle a PIO receive event

 *	@c: Z8530 channel to process

 *

 *	Receive handler for receiving in PIO mode. This is much like the

 *	async one but not quite the same or as complex

 *

 *	Note: Its intended that this handler can easily be separated from

 *	the main code to run realtime. That'll be needed for some machines

 *	(eg to ever clock 64kbits on a sparc ;)).

 *

 *	The RT_LOCK macros don't do anything now. Keep the code covered

 *	by them as short as possible in all circumstances - clocks cost

 *	baud. The interrupt handler is assumed to be atomic w.r.t. to

 *	other code - this is true in the RT case too.

 *

 *	We only cover the sync cases for this. If you want 2Mbit async

 *	do it yourself but consider medical assistance first. This non DMA

 *	synchronous mode is portable code. The DMA mode assumes PCI like

 *	ISA DMA

 *

 *	Called with the device lock held

 FIFO empty ? */

		/*	Overrun ?

			/*	Error ?

 Rewind the buffer and return */

 printk("crc error\n"); */

 Shove the frame upstream */

				/*	Drop the lock for RX processing, or

				 *	there are deadlocks

	/*	Clear irq

/**

 *	z8530_tx - Handle a PIO transmit event

 *	@c: Z8530 channel to process

 *

 *	Z8530 transmit interrupt handler for the PIO mode. The basic

 *	idea is to attempt to keep the FIFO fed. We fill as many bytes

 *	in as possible, its quite possible that we won't keep up with the

 *	data rate otherwise.

 FIFO full ? */

		/*	Shovel out the byte

 We are about to underflow */

	/*	End of frame TX - fire another one

/**

 *	z8530_status - Handle a PIO status exception

 *	@chan: Z8530 channel to process

 *

 *	A status event occurred in PIO synchronous mode. There are several

 *	reasons the chip will bother us here. A transmit underrun means we

 *	failed to feed the chip fast enough and just broke a packet. A DCD

 *	change is a line up or down.

		printk("%s: Tx underrun.\n", chan->dev->name); */

/**

 *	z8530_dma_rx - Handle a DMA RX event

 *	@chan: Channel to handle

 *

 *	Non bus mastering DMA interfaces for the Z8x30 devices. This

 *	is really pretty PC specific. The DMA mode means that most receive

 *	events are handled by the DMA hardware. We get a kick here only if

 *	a frame ended.

 Special condition check only */

 Fire up the next one */

 DMA is off right now, drain the slow way */

/**

 *	z8530_dma_tx - Handle a DMA TX event

 *	@chan:	The Z8530 channel to handle

 *

 *	We have received an interrupt while doing DMA transmissions. It

 *	shouldn't happen. Scream loudly if it does.

 This shouldn't occur in DMA mode */

/**

 *	z8530_dma_status - Handle a DMA status exception

 *	@chan: Z8530 channel to process

 *

 *	A status event occurred on the Z8530. We receive these for two reasons

 *	when in DMA mode. Firstly if we finished a packet transfer we get one

 *	and kick the next packet out. Secondly we may see a DCD change.

 *

/**

 *	z8530_rx_clear - Handle RX events from a stopped chip

 *	@c: Z8530 channel to shut up

 *

 *	Receive interrupt vectors for a Z8530 that is in 'parked' mode.

 *	For machines with PCI Z85x30 cards, or level triggered interrupts

 *	(eg the MacII) we must clear the interrupt cause or die.

	/*	Data and status bytes

	/*	Clear irq

/**

 *	z8530_tx_clear - Handle TX events from a stopped chip

 *	@c: Z8530 channel to shut up

 *

 *	Transmit interrupt vectors for a Z8530 that is in 'parked' mode.

 *	For machines with PCI Z85x30 cards, or level triggered interrupts

 *	(eg the MacII) we must clear the interrupt cause or die.

/**

 *	z8530_status_clear - Handle status events from a stopped chip

 *	@chan: Z8530 channel to shut up

 *

 *	Status interrupt vectors for a Z8530 that is in 'parked' mode.

 *	For machines with PCI Z85x30 cards, or level triggered interrupts

 *	(eg the MacII) we must clear the interrupt cause or die.

/**

 *	z8530_interrupt - Handle an interrupt from a Z8530

 *	@irq: Interrupt number

 *	@dev_id: The Z8530 device that is interrupting.

 *

 *	A Z85[2]30 device has stuck its hand in the air for attention.

 *	We scan both the channels on the chip for events and then call

 *	the channel specific call backs for each channel that has events.

 *	We have to use callback functions because the two channels can be

 *	in different modes.

 *

 *	Locking is done for the handlers. Note that locking is done

 *	at the chip level (the 5uS delay issue is per chip not per

 *	channel). c->lock for both channels points to dev->lock

		/* This holds the IRQ status. On the 8530 you must read it

		 * from chan A even though it applies to the whole chip

		/* Now walk the chip and see what it is wanting - it may be

		 * an IRQ for someone else remember

 Ok all done */

/**

 *	z8530_sync_open - Open a Z8530 channel for PIO

 *	@dev:	The network interface we are using

 *	@c:	The Z8530 channel to open in synchronous PIO mode

 *

 *	Switch a Z8530 into synchronous mode without DMA assist. We

 *	raise the RTS/DTR and commence network operation.

 This loads the double buffer up */

 Load the frame ring */

 Load the backup frame */

/**

 *	z8530_sync_close - Close a PIO Z8530 channel

 *	@dev: Network device to close

 *	@c: Z8530 channel to disassociate and move to idle

 *

 *	Close down a Z8530 interface and switch its interrupt handlers

 *	to discard future events.

/**

 *	z8530_sync_dma_open - Open a Z8530 for DMA I/O

 *	@dev: The network device to attach

 *	@c: The Z8530 channel to configure in sync DMA mode.

 *

 *	Set up a Z85x30 device for synchronous DMA in both directions. Two

 *	ISA DMA channels must be available for this to work. We assume ISA

 *	DMA driven I/O and PC limits on access.

	/*	Load the DMA interfaces up

	/*	Allocate the DMA flip buffers. Limit by page size.

	 *	Everyone runs 1500 mtu or less on wan links so this

	 *	should be fine.

	/*	Enable DMA control mode

	/*	TX DMA via DIR/REQ

	/*	RX DMA via W/Req

	/*	DMA interrupts

	/*	Set up the DMA configuration

	/*	Select the DMA interrupt handlers

/**

 *	z8530_sync_dma_close - Close down DMA I/O

 *	@dev: Network device to detach

 *	@c: Z8530 channel to move into discard mode

 *

 *	Shut down a DMA mode synchronous interface. Halt the DMA, and

 *	free the buffers.

	/*	Disable the PC DMA channels

	/*	Disable DMA control mode

/**

 *	z8530_sync_txdma_open - Open a Z8530 for TX driven DMA

 *	@dev: The network device to attach

 *	@c: The Z8530 channel to configure in sync DMA mode.

 *

 *	Set up a Z85x30 device for synchronous DMA transmission. One

 *	ISA DMA channel must be available for this to work. The receive

 *	side is run in PIO mode, but then it has the bigger FIFO.

	/*	Allocate the DMA flip buffers. Limit by page size.

	 *	Everyone runs 1500 mtu or less on wan links so this

	 *	should be fine.

	/*	Load the PIO receive ring

	/*	Load the DMA interfaces up

	/*	Enable DMA control mode

	/*	TX DMA via DIR/REQ

	/*	Set up the DMA configuration

	/*	Select the DMA interrupt handlers

/**

 *	z8530_sync_txdma_close - Close down a TX driven DMA channel

 *	@dev: Network device to detach

 *	@c: Z8530 channel to move into discard mode

 *

 *	Shut down a DMA/PIO split mode synchronous interface. Halt the DMA,

 *	and  free the buffers.

	/*	Disable the PC DMA channels

	/*	Disable DMA control mode

/*	Name strings for Z8530 chips. SGI claim to have a 130, Zilog deny

 *	it exists...

/**

 *	z8530_describe - Uniformly describe a Z8530 port

 *	@dev: Z8530 device to describe

 *	@mapping: string holding mapping type (eg "I/O" or "Mem")

 *	@io: the port value in question

 *

 *	Describe a Z8530 in a standard format. We must pass the I/O as

 *	the port offset isn't predictable. The main reason for this function

 *	is to try and get a common format of report.

/*	Locked operation part of the z8530 init code

	/* NOP the interrupt handlers first - we might get a

	 * floating IRQ transition when we reset the chip

 Reset the chip */

 Now check its valid */

	/*	See the application note.

	/*	If we can set the low bit of R15 then

	 *	the chip is enhanced.

 This C30 versus 230 detect is from Klaus Kudielka's dmascc */

 Put a char in the fifo */

 Has a FIFO */

 Z85C30, 1 byte FIFO */

	/*	The code assumes R7' and friends are

	 *	off. Use write_zsext() for these and keep

	 *	this bit clear.

	/*	At this point it looks like the chip is behaving

/**

 *	z8530_init - Initialise a Z8530 device

 *	@dev: Z8530 device to initialise.

 *

 *	Configure up a Z8530/Z85C30 or Z85230 chip. We check the device

 *	is present, identify the type and then program it to hopefully

 *	keep quite and behave. This matters a lot, a Z8530 in the wrong

 *	state will sometimes get into stupid modes generating 10Khz

 *	interrupt streams and the like.

 *

 *	We set the interrupt handler up to discard any events, in case

 *	we get them during reset or setp.

 *

 *	Return 0 for success, or a negative value indicating the problem

 *	in errno form.

 Set up the chip level lock */

/**

 *	z8530_shutdown - Shutdown a Z8530 device

 *	@dev: The Z8530 chip to shutdown

 *

 *	We set the interrupt handlers to silence any interrupts. We then

 *	reset the chip and wait 100uS to be sure the reset completed. Just

 *	in case the caller then tries to do stuff.

 *

 *	This is called without the lock held

 Reset the chip */

 We must lock the udelay, the chip is offlimits here */

/**

 *	z8530_channel_load - Load channel data

 *	@c: Z8530 channel to configure

 *	@rtable: table of register, value pairs

 *	FIXME: ioctl to allow user uploaded tables

 *

 *	Load a Z8530 channel up from the system data. We use +16 to

 *	indicate the "prime" registers. The value 255 terminates the

 *	table.

/**

 *	z8530_tx_begin - Begin packet transmission

 *	@c: The Z8530 channel to kick

 *

 *	This is the speed sensitive side of transmission. If we are called

 *	and no buffer is being transmitted we commence the next buffer. If

 *	nothing is queued we idle the sync.

 *

 *	Note: We are handling this code path in the interrupt path, keep it

 *	fast or bad things will happen.

 *

 *	Called with the lock held.

 Idle on */

			/*	Check if we crapped out.

			/*	FIXME. DMA is broken for the original 8530,

			 *	on the older parts we need to set a flag and

			 *	wait for a further TX interrupt to fire this

			 *	stage off

			/*	These two are needed by the 8530/85C30

			 *	and must be issued when idling.

 ABUNDER off */

	/*	Since we emptied tx_skb we can ask for more

/**

 *	z8530_tx_done - TX complete callback

 *	@c: The channel that completed a transmit.

 *

 *	This is called when we complete a packet send. We wake the queue,

 *	start the next packet going and then free the buffer of the existing

 *	packet. This code is fairly timing sensitive.

 *

 *	Called with the register lock held.

 Actually this can happen.*/

/**

 *	z8530_null_rx - Discard a packet

 *	@c: The channel the packet arrived on

 *	@skb: The buffer

 *

 *	We point the receive handler at this function when idle. Instead

 *	of processing the frames we get to throw them away.

/**

 *	z8530_rx_done - Receive completion callback

 *	@c: The channel that completed a receive

 *

 *	A new packet is complete. Our goal here is to get back into receive

 *	mode as fast as possible. On the Z85230 we could change to using

 *	ESCC mode, but on the older chips we have no choice. We flip to the

 *	new buffer immediately in DMA mode so that the DMA of the next

 *	frame can occur while we are copying the previous buffer to an sk_buff

 *

 *	Called with the lock held

	/*	Is our receive engine in DMA mode

		/*	Save the ready state and the buffer currently

		 *	being used as the DMA target

		/*	Complete this DMA. Necessary to find the length

 Shit happens.. */

		/*	Normal case: the other slot is free, start the next DMA

		 *	into it immediately.

			/* Stop any frames that we missed the head of

			 * from passing

			/* Can't occur as we dont reenable the DMA irq until

			 * after the flip is done

		/*	Shove the old buffer into an sk_buff. We can't DMA

		 *	directly into one on a PC - it might be above the 16Mb

		 *	boundary. Optimisation - we could check to see if we

		 *	can avoid the copy. Optimisation 2 - make the memcpy

		 *	a copychecksum.

		/*	The game we play for non DMA is similar. We want to

		 *	get the controller set up for the next packet as fast

		 *	as possible. We potentially only have one byte + the

		 *	fifo length for this. Thus we want to flip to the new

		 *	buffer and then mess around copying and allocating

		 *	things. For the current case it doesn't matter but

		 *	if you build a system where the sync irq isn't blocked

		 *	by the kernel IRQ disable then you need only block the

		 *	sync IRQ for the RT_LOCK area.

		 *

	/*	If we received a frame we must now process it.

/**

 *	spans_boundary - Check a packet can be ISA DMA'd

 *	@skb: The buffer to check

 *

 *	Returns true if the buffer cross a DMA boundary on a PC. The poor

 *	thing can only DMA within a 64K block not across the edges of it.

 If the 64K bit is different.. */

/**

 *	z8530_queue_xmit - Queue a packet

 *	@c: The channel to use

 *	@skb: The packet to kick down the channel

 *

 *	Queue a packet for transmission. Because we have rather

 *	hard to hit interrupt latencies for the Z85230 per packet

 *	even in DMA mode we do the flip to DMA buffer if needed here

 *	not in the IRQ.

 *

 *	Called from the network code. The lock is not held at this

 *	point.

 PC SPECIFIC - DMA limits */

	/*	If we will DMA the transmit and its gone over the ISA bus

	 *	limit, then copy to the flip buffer

		/*	Send the flip buffer, and flip the flippy bit.

		 *	We don't care which is used when just so long as

		 *	we never use the same buffer twice in a row. Since

		 *	only one buffer can be going out at a time the other

		 *	has to be safe.

 Flip temp buffer */

/*	Module support

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Hitachi SCA HD64570 driver for Linux

 *

 * Copyright (C) 1998-2003 Krzysztof Halasa <khc@pm.waw.pl>

 *

 * Source of information: Hitachi HD64570 SCA User's Manual

 *

 * We use the following SCA memory map:

 *

 * Packet buffer descriptor rings - starting from winbase or win0base:

 * rx_ring_buffers * sizeof(pkt_desc) = logical channel #0 RX ring

 * tx_ring_buffers * sizeof(pkt_desc) = logical channel #0 TX ring

 * rx_ring_buffers * sizeof(pkt_desc) = logical channel #1 RX ring (if used)

 * tx_ring_buffers * sizeof(pkt_desc) = logical channel #1 TX ring (if used)

 *

 * Packet data buffers - starting from winbase + buff_offset:

 * rx_ring_buffers * HDLC_MAX_MRU     = logical channel #0 RX buffers

 * tx_ring_buffers * HDLC_MAX_MRU     = logical channel #0 TX buffers

 * rx_ring_buffers * HDLC_MAX_MRU     = logical channel #0 RX buffers (if used)

 * tx_ring_buffers * HDLC_MAX_MRU     = logical channel #0 TX buffers (if used)

 called with "X + 1" etc.

 Descriptor offset always fits in 16 bits */

 DMA disable - to halt state */

 software ABORT - to initial state */

 current desc addr */

 pointer base */

 clear frame end interrupt counter */

 Receive */

 set buffer length */

 Chain mode, Multi-frame */

 DMA enable */

 Transmit */

 Chain mode, Multi-frame */

 enable underflow interrupts */

 MSCI interrupt service */

 read MSCI ST1 status */

 Reset MSCI TX underrun and CDCD status bit */

 TX Underrun error detected */

 select pkt_desc table page back */

 Receive DMA interrupt service */

 read DMA Status */

 Reset DSR status bits */

 Dropped one or more frames */

 No frame received */

 partial frame received */

 received last fragment */

 Set new error descriptor address */

 make sure RX DMA is enabled */

 Transmit DMA interrupt service */

 read DMA Status */

 Reset DSR status bits */

 Transmitter is/will_be sending this frame */

 Free descriptor */

 Restore original page */

 Try lower br for better accuracy*/

 brv = 2^9 = 512 max in specs */

 Baud Rate = CLOCK_BASE / TMC / 2^BR */

 For baud=CLOCK_BASE we use tmc=1 br=0 */

 tmc=0 means 256 - low baud rates */

 Minimum clock rate */

 8bit = 0 */

 baud divisor - time constant*/

 Set BRG bits */

 no address field check */

 flag character 0x7E */

 Allow at least 8 bytes before requesting RX DMA operation */

 TX with higher priority and possibly with shorter transfers */

 +1=RXRDY/DMA activation condition*/

 = TXRDY/DMA activation condition*/

 +1=TXRDY/DMA deactiv condition */

/* We're using the following interrupts:

 * - TXINT (DMAC completed all transmisions, underrun or DCD change)

 * - all DMA interrupts

 MSCI TX INT and RX INT A IRQ enable */

 TXINT and RXINT */

 enable DMA IRQ */

 Restore registers */

 reset channel */

 disable MSCI interrupts */

 disable DMA interrupts */

 Restore original page */

 DEBUG_RINGS */

 previous xmit should stop queue */

 select pkt_desc table page back */

 Enable TX DMA */

 allow 1 packet gap */

 Round RAM size to 32 bits, fill from end to start */

 select last window */

 NEED_DETECT_RAM */

 Wait Control */

 DMA Master disable */

 DMA priority */

 DMA disable - to halt state */

 DMA Master enable */

