 SPDX-License-Identifier: GPL-2.0-only

/*

 * I2C IIO driver for Bosch BMA400 triaxial acceleration sensor.

 *

 * Copyright 2019 Dan Robertson <dan@dlrobertson.com>

 *

 * I2C address is either 0x14 or 0x15 depending on SDO

 SPDX-License-Identifier: GPL-2.0-only

/*

 * IIO accel core driver for Freescale MMA7455L 3-axis 10-bit accelerometer

 * Copyright 2015 Joachim Eastwood <manabian@gmail.com>

 *

 * UNSUPPORTED hardware features:

 *  - 8-bit mode with different scales

 *  - INT1/INT2 interrupts

 *  - Offset calibration

 *  - Events

/*

 * When MMA7455 is used in 10-bit it has a fullscale of -8g

 * corresponding to raw value -512. The userspace interface

 * uses m/s^2 and we declare micro units.

 * So scale factor is given by:

 *       g * 8 * 1e6 / 512 = 153228.90625, with g = 9.80665

	/*

	 * Used to reorganize data.  Will ensure correct alignment of

	 * the timestamp if present

 In 10-bit mode there is only one scale available */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * IIO driver for the 3-axis accelerometer Domintech ARD10.

 *

 * Copyright (c) 2016 Hans de Goede <hdegoede@redhat.com>

 * Copyright (c) 2012 Domintech Technology Co., Ltd

 AFEN set 1, ATM[2:0]=b'000 (normal), EN_Z/Y/X/T=1 */

 ODR[3:0]=b'0111 (100Hz), CCK[3:0]=b'0100 (204.8kHZ) */

 INTC[6:5]=b'00 */

 TAP1/TAP2 Average 2 */

 Offsets into the buffer read in dmard10_read_raw() */

/*

 * a value of + or -128 corresponds to + or - 1G

 * scale = 9.81 / 128 = 0.076640625

 Init sequence taken from the android driver */

 1. Powerdown reset */

	/*

	 * 2. ACTR => Standby mode => Download OTP to parameter reg =>

	 *    Standby mode => Reset data path => Standby mode

 3. OSCA_EN = 1, TSTO = b'000 (INT1 = normal, TEST0 = normal) */

 4. AFEN = 1 (AFE will powerdown after ADC) */

 DLYC, no delay timing */

 INTD=1 push-pull, INTA=1 active high, AUTOT=1 */

 5. Activation mode */

 Shutdown sequence taken from the android driver */

		/*

		 * Read 8 bytes starting at the REG_STADR register, trying to

		 * read the individual X, Y, Z registers will always read 0.

 These 2 registers have special POR reset values used for id */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * IIO driver for the 3-axis accelerometer Domintech DMARD09.

 *

 * Copyright (c) 2016, Jelle van der Waa <jelle@vdwaa.nl>

		/*

		 * Read from the DMAR09_REG_STAT register, since the chip

		 * caches reads from the individual X, Y, Z registers.

 Remove lower 3 bits and sign extend */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Core IIO driver for Bosch BMA400 triaxial acceleration sensor.

 *

 * Copyright 2019 Dan Robertson <dan@dlrobertson.com>

 *

 * TODO:

 *  - Support for power management

 *  - Support events and interrupts

 *  - Create channel for step count

 *  - Create channel for sensor time

/*

 * The G-range selection may be one of 2g, 4g, 8, or 16g. The scale may

 * be selected with the acc_range bits of the ACC_CONFIG1 register.

 * NB: This buffer is populated in the device init.

/*

 * See the ACC_CONFIG1 section of the datasheet.

 * NB: This buffer is populated in the device init.

 See the ACC_CONFIG0 section of the datasheet */

 data register lock */

	/*

	 * The formula for the TEMP_DATA register in the datasheet

	 * is: x * 0.5 + 23

 bulk read two registers, with the base being the LSB register */

		/*

		 * Runs at a fixed rate in low-power mode. See section 4.3

		 * in the datasheet.

		/*

		 * In normal mode the ODR can be found in the ACC_CONFIG1

		 * register.

 Note this works because MIN_WHOLE_HZ is odd */

 preserve the range and normal mode osr */

	/*

	 * The oversampling ratio is stored in a different register

	 * based on the power-mode. In normal mode the OSR is stored

	 * in ACC_CONFIG1. In low-power mode it is stored in

	 * ACC_CONFIG0.

	/*

	 * The oversampling ratio is stored in a different register

	 * based on the power-mode.

 Note this works because BMA400_SCALE_MIN is odd */

 Preserve the low-power oversample ratio etc */

	/*

	 * Update our cached osr and odr based on the new

	 * power-mode.

 Try to read chip_id register. It must return 0x90. */

		/*

		 * TODO: The datasheet waits 1500us here in the example, but

		 * lists 2/ODR as the wakeup time.

	/*

	 * Once the interrupt engine is supported we might use the

	 * data_src_reg, but for now ensure this is set to the

	 * variable ODR filter selectable by the sample frequency

	 * channel.

			/*

			 * Runs at a fixed sampling frequency. See Section 4.4

			 * of the datasheet.

		/*

		 * TODO: We could avoid this logic and returning -EINVAL here if

		 * we set both the low-power and normal mode OSR registers when

		 * we configure the device.

		/*

		 * The sample frequency is readonly for the temperature

		 * register and a fixed value in low-power mode.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ADXL345 3-Axis Digital Accelerometer SPI driver

 *

 * Copyright (c) 2017 Eva Rachel Retuya <eraretuya@gmail.com>

 Setting bits 7 and 6 enables multiple-byte read */

 Bail out if max_speed_hz exceeds 5 MHz */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * IIO accel I2C driver for Freescale MMA7455L 3-axis 10-bit accelerometer

 * Copyright 2015 Joachim Eastwood <manabian@gmail.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * Driver for older Chrome OS EC accelerometer

 *

 * Copyright 2017 Google, Inc

 *

 * This driver uses the memory mapper cros-ec interface to communicate

 * with the Chrome OS EC about accelerometer data or older commands.

 * Accelerometer access is presented through iio sysfs.

/*

 * Sensor scale hard coded at 10 bits per g, computed as:

 * g / (2^10 - 1) = 0.009586168; with g = 9.80665 m.s^-2

/*

 * Sensor frequency is hard-coded to 10Hz.

	/*

	 * Read all sensor data through a command.

	 * Save sensor_num, it is assumed to stay.

 Calibration not supported. */

	/*

	 * Do nothing but don't return an error code to allow calibration

	 * script to work.

/**

 * cros_ec_accel_legacy_read_avail() - get available values

 * @indio_dev:		pointer to state information for device

 * @chan:	channel specification structure table

 * @vals:	list of available values

 * @type:	type of data returned

 * @length:	number of data returned in the array

 * @mask:	specifies which values to be requested

 *

 * Return:	an error code or IIO_AVAIL_LIST

/*

 * Present the channel using HTML5 standard:

 * need to invert X and Y and invert some lid axis.

 The lid sensor needs to be presented inverted. */

 SPDX-License-Identifier: GPL-2.0

/*

 * mma8452.c - Support for following Freescale / NXP 3-axis accelerometers:

 *

 * device name	digital output	7-bit I2C slave address (pin selectable)

 * ---------------------------------------------------------------------

 * MMA8451Q	14 bit		0x1c / 0x1d

 * MMA8452Q	12 bit		0x1c / 0x1d

 * MMA8453Q	10 bit		0x1c / 0x1d

 * MMA8652FC	12 bit		0x1d

 * MMA8653FC	10 bit		0x1d

 * FXLS8471Q	14 bit		0x1e / 0x1d / 0x1c / 0x1f

 *

 * Copyright 2015 Martin Kepplinger <martink@posteo.de>

 * Copyright 2014 Peter Meerwald <pmeerw@pmeerw.net>

 *

 *

 * TODO: orientation events

 MSB first */

 50 Hz sample frequency */

 Ensure correct alignment of time stamp when present */

 /**

  * struct mma8452_event_regs - chip specific data related to events

  * @ev_cfg:			event config register address

  * @ev_cfg_ele:			latch bit in event config register

  * @ev_cfg_chan_shift:		number of the bit to enable events in X

  *				direction; in event config register

  * @ev_src:			event source register address

  * @ev_ths:			event threshold register address

  * @ev_ths_mask:		mask for the threshold value

  * @ev_count:			event count (period) register address

  *

  * Since not all chips supported by the driver support comparing high pass

  * filtered data for events (interrupts), different interrupt sources are

  * used for different chips and the relevant registers are included here.

/**

 * struct mma_chip_info - chip specific data

 * @chip_id:			WHO_AM_I register's value

 * @channels:			struct iio_chan_spec matching the device's

 *				capabilities

 * @num_channels:		number of channels

 * @mma_scales:			scale factors for converting register values

 *				to m/s^2; 3 modes: 2g, 4g, 8g; 2 integers

 *				per mode: m/s^2 and micro m/s^2

 * @all_events:			all events supported by this chip

 * @enabled_events:		event flags enabled and handled by this driver

 replace trailing space by newline */

 Datasheet table: step time "Relationship with the ODR" (sample frequency) */

 normal */

 l p l n */

 high res*/

 l p */

 Datasheet table "High-Pass Filter Cutoff Options" */

 normal */

 800 Hz sample */

 400 Hz sample */

 200 Hz sample */

 100 Hz sample */

 50 Hz sample */

 12.5 Hz sample */

 6.25 Hz sample */

 1.56 Hz sample */

 low noise low power */

 high resolution */

 low power */

 Datasheet table "MODS Oversampling modes averaging values at each ODR" */

 800 Hz, 400 Hz, ... , 1.56 Hz */

 normal */

 low power low noise */

 high resolution */

 low power */

 returns >0 if active, 0 if in standby and <0 on error */

 config can only be changed when in standby */

 returns >0 if in freefall mode, 0 if not or <0 if an error occurred */

/*

 * Threshold is configured in fixed 8G/127 steps regardless of

 * currently selected scale for measurement.

		/*

		 * Hardware has fullscale of -2G, -4G, -8G corresponding to

		 * raw value -8192 for 14 bit, -2048 for 12 bit or -512 for 10

		 * bit.

		 * The userspace interface uses m/s^2 and we declare micro units

		 * So scale factor for 12 bit here is given by:

		 *	g * N * 1000000 / 2048 for N = 2, 4, 8 and g=9.80665

		/*

		 * Although we enable the interrupt sources once and for

		 * all here the event detection itself is not enabled until

		 * userspace asks for it by mma8452_write_event_config()

		/*

		 * Although we enable the interrupt sources once and for

		 * all here the event detection itself is not enabled until

		 * userspace asks for it by mma8452_write_event_config()

		/*

		 * Although we enable the interrupt sources once and for

		 * all here the event detection itself is not enabled until

		 * userspace asks for it by mma8452_write_event_config()

		/*

		 * Although we enable the interrupt sources once and for

		 * all here the event detection itself is not enabled until

		 * userspace asks for it by mma8452_write_event_config()

		/*

		 * Although we enable the interrupt sources once and for

		 * all here the event detection itself is not enabled until

		 * userspace asks for it by mma8452_write_event_config()

 I2C comm reset */

	/*

	 * By default set transient threshold to max to avoid events if

	 * enabling without configuring threshold.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * BMA220 Digital triaxial acceleration sensor driver

 *

 * Copyright (c) 2016,2020 Intel Corporation.

 Ensure timestamp is naturally aligned. */

 Make sure the chip is powered on */

	/**

	 * The chip can be suspended/woken up by a simple register read.

	 * So, we need up to 2 register reads of the suspend register

	 * to make sure that the device is in the desired state.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (C) 2014, Samsung Electronics Co. Ltd. All Rights Reserved.

 ssp registering should be done after all iio setup */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Murata SCA3300 3-axis industrial accelerometer

 *

 * Copyright (c) 2021 Vaisala Oyj. All rights reserved.

 Device mode register */

 Last register in map */

 Device status and mask */

 Device ID */

 Device return status and mask */

/**

 * struct sca3300_data - device data

 * @spi: SPI device structure

 * @lock: Data buffer lock

 * @scan: Triggered buffer. Four channel 16-bit data + 64-bit timestamp

 * @txbuf: Transmit buffer

 * @rxbuf: Receive buffer

 Consecutive requests min. 10 us delay (Datasheet section 5.1.2) */

 inverted crc value as described in device data sheet */

 get return status */

	/*

	 * Return status error is cleared after reading status register once,

	 * expect EINVAL here.

 BIT(7) for write operation */

 freq. change is possible only for mode 3 and 4 */

 handled, but bailing out due to errors */

/*

 * sca3300_init - Device init sequence. See datasheet rev 2 section

 * 4.2 Start-Up Sequence for details.

	/*

	 * Wait 1ms after SW-reset command.

	 * Wait 15ms for settling of signal paths.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ADXL355 3-Axis Digital Accelerometer IIO core driver

 *

 * Copyright (c) 2021 Puranjay Mohan <puranjay12@gmail.com>

 *

 * Datasheet: https://www.analog.com/media/en/technical-documentation/data-sheets/adxl354_adxl355.pdf

 ADXL355 Register Definitions */

 lock to protect op_mode */

	/*

	 * Perform a software reset to make sure the device is in a consistent

	 * state after start-up.

		/*

		 * The datasheet defines an intercept of 1885 LSB at 25 degC

		 * and a slope of -9.05 LSB/C. The following formula can be used

		 * to find the temperature:

		 * Temp = ((RAW - 1885)/(-9.05)) + 25 but this doesn't follow

		 * the format of the IIO which is Temp = (RAW + OFFSET) * SCALE.

		 * Hence using some rearranging we get the scale as -110.497238

		 * and offset as -2111.25.

		/*

		 * At +/- 2g with 20-bit resolution, scale is given in datasheet

		 * as 3.9ug/LSB = 0.0000039 * 9.80665 = 0.00003824593 m/s^2.

 Values are stored in a 2D matrix */

 Values are stored in a 2D matrix */

	/*

	 * data->buffer is used both for triggered buffer support

	 * and read/write_raw(), hence, it has to be zeroed here before usage.

	/*

	 * The acceleration data is 24 bits and big endian. It has to be saved

	 * in 32 bits, hence, it is saved in the 2nd byte of the 4 byte buffer.

	 * The buf array is 14 bytes as it includes 3x4=12 bytes for

	 * accelaration data of x, y, and z axis. It also includes 2 bytes for

	 * temperature data.

	/*

	 * TODO: Would be good to move it to the generic version.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ADXL345 3-Axis Digital Accelerometer I2C driver

 *

 * Copyright (c) 2017 Eva Rachel Retuya <eraretuya@gmail.com>

 *

 * 7-bit I2C slave address: 0x1D (ALT ADDRESS pin tied to VDDIO) or

 * 0x53 (ALT ADDRESS pin grounded)

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * ADIS16209 Dual-Axis Digital Inclinometer and Accelerometer

 *

 * Copyright 2010 Analog Devices Inc.

 Data Output Register Definitions */

 Output, auxiliary ADC input */

 Output, temperature */

 Output, +/- 90 degrees X-axis inclination */

 Output, +/-180 vertical rotational position */

/*

 * Calibration Register Definitions.

 * Acceleration, inclination or rotation offset null.

 Alarm Register Definitions */

 Data-ready polarity: 1 = active high, 0 = active low */

 Power supply above 3.625 V */

 Power supply below 2.975 V */

 0.30518 mV */

 0.6105 mV */

			/*

			 * IIO base unit for sensitivity of accelerometer

			 * is milli g.

			 * 1 LSB represents 0.244 mg.

			/*

			 * IIO base units for rotation are degrees.

			 * 1 LSB represents 0.025 milli degrees.

		/*

		 * The raw ADC value is 0x4FE when the temperature

		 * is 45 degrees and the scale factor per milli

		 * degree celcius is -470.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HID Sensors Driver

 * Copyright (c) 2012, Intel Corporation.

 Ensure timestamp is naturally aligned */

 Channel definitions */

 Channel definitions */

 Adjust channel real bits based on report descriptor */

 Real storage bits will change based on the report desc. */

 Maximum size of a sample to capture is u32 */

 Channel read_raw handler */

 Channel write_raw handler */

 Function to push data to buffer */

 Callback handler to send event after all samples are received and captured */

 Capture samples in local storage */

 Parse report which is specific to an usage id*/

 Function to initialize the processing for usage id */

 Function to deinitialize the processing for usage id */

 Format: HID-SENSOR-usage_id_in_hex_lowercase */

 gravity sensor */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-only

/*

 * STMicroelectronics accelerometers driver

 *

 * Copyright 2012-2013 STMicroelectronics Inc.

 *

 * Denis Ciocca <denis.ciocca@st.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ADXL313 3-Axis Digital Accelerometer

 *

 * Copyright (c) 2021 Lucas Stankus <lucas.p.stankus@gmail.com>

 *

 * Datasheet: https://www.analog.com/media/en/technical-documentation/data-sheets/ADXL313.pdf

 Setting bits 7 and 6 enables multiple-byte read */

 SPDX-License-Identifier: GPL-2.0

/*

 * 3-axis accelerometer driver supporting following Bosch-Sensortec chips:

 *  - BMI088

 *

 * Copyright (c) 2018-2021, Topic Embedded Products

 Available OSR (over sampling rate) sets the 3dB cut-off frequency */

 Available ODR (output data rates) in Hz */

 shared DMA safe buffer */

 All registers below 0x40 are volatile, except the CHIP ID. */

 Mark the RESET as volatile too, it is self-clearing */

 Enable accelerometer and temperature sensor */

 Datasheet recommends to wait at least 5ms before communication */

 Disable suspend mode */

 Recommended at least 1ms before further communication */

 Enable suspend mode */

 Recommended at least 1ms before further communication */

 Disable accelerometer and temperature sensor */

 Datasheet recommends to wait at least 5ms before communication */

 data->buffer is cacheline aligned */

 Offset applies before scale */

 0.125 degrees per LSB */

 Do a dummy read to enable SPI interface, won't harm I2C */

	/*

	 * Reset chip to get it in a known good state. A delay of 1ms after

	 * reset is required according to the data sheet

 Do a dummy read again after a reset to enable the SPI interface */

 Read chip ID */

 Validate chip ID */

 Enable runtime PM */

 We need ~6ms to startup, so set the delay to 6 seconds */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * 3-axis accelerometer driver supporting many I2C Bosch-Sensortec chips

 * Copyright (c) 2014, Intel Corporation.

/*

 * The DUAL250E ACPI device for 360° hinges type 2-in-1s with 1 accelerometer

 * in the display and 1 in the hinge has an ACPI-method (DSM) to tell the

 * ACPI code about the angle between the 2 halves. This will make the ACPI

 * code enable/disable the keyboard and touchpad. We need to call this to avoid

 * the keyboard being disabled when the 2-in-1 is turned-on or resumed while

 * fully folded into tablet mode (which gets detected with a HALL-sensor).

 * If we don't call this then the keyboard won't work even when the 2-in-1 is

 * changed to be used in laptop mode after the power-on / resume.

 *

 * This DSM takes 2 angles, selected by setting aux0 to 0 or 1, these presumably

 * define the angle between the gravity vector measured by the accelerometer in

 * the display (aux0=0) resp. the base (aux0=1) and some reference vector.

 * The 2 angles get subtracted from each other so the reference vector does

 * not matter and we can simply leave the second angle at 0.

	/*

	 * Note this triggers the following warning:

	 * "ACPI Warning: \_SB.PCI0.I2C2.ACC1._DSM: Argument #4 type mismatch -

	 *                Found [Buffer], ACPI requires [Package]"

	 * This is unavoidable since the _DSM implementation expects a "naked"

	 * buffer, so wrapping it in a package will _not_ work.

	/*

	 * The EC must see a change for it to re-enable the kbd, so first

	 * set the angle to 270° (tent/stand mode) and then change it to

	 * 90° (laptop mode).

 The EC needs some time to notice the angle being changed */

	/*

	 * Delay the bmc150_acpi_enable_keyboard() call till after the system

	 * resume has completed, otherwise it will not work.

/*

 * Some acpi_devices describe 2 accelerometers in a single ACPI device,

 * try instantiating a second i2c_client for an I2cSerialBusV2 ACPI resource

 * with index 1.

	/*

	 * The 2nd accel sits in the base of 2-in-1s. The suffix is static, as

	 * there should never be more then 1 ACPI node with 2 accelerometers.

	/*

	 * The !id check avoids recursion when probe() gets called

	 * for the second client.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Common code for Freescale MMA955x Intelligent Sensor Platform drivers

 * Copyright (c) 2014, Intel Corporation.

 Command masks for mailbox write command */

 Mailbox read command */

 Error-Status codes returned in mailbox read command */

 GPIO Application */

 Sleep/Wake application */

 AFE application */

 Reset/Suspend/Clear application */

/*

 * A response is composed of:

 * - control registers: MB0-3

 * - data registers: MB4-31

 *

 * A request is composed of:

 * - mbox to write to (always 0)

 * - control registers: MB1-4

 * - data registers: MB5-31

 us */

 Always 0. */

	/*

	 * See Section 5.3.1 of the MMA955xL Software Reference Manual.

	 *

	 * Bit 7: reserved, always 0

	 * Bits 6-4: command

	 * Bits 3-0: upper bits of register offset

	/*

	 * See Section 5.3.3 of the MMA955xL Software Reference Manual.

	 *

	 * Bit 7: COCO

	 * Bits 6-0: Error code.

/**

 * mma9551_read_config_byte() - read 1 configuration byte

 * @client:	I2C client

 * @app_id:	Application ID

 * @reg:	Application register

 * @val:	Pointer to store value read

 *

 * Read one configuration byte from the device using MMA955xL command format.

 * Commands to the MMA955xL platform consist of a write followed

 * by one or more reads.

 *

 * Locking note: This function must be called with the device lock held.

 * Locking is not handled inside the function. Callers should ensure they

 * serialize access to the HW.

 *

 * Returns: 0 on success, negative value on failure.

/**

 * mma9551_write_config_byte() - write 1 configuration byte

 * @client:	I2C client

 * @app_id:	Application ID

 * @reg:	Application register

 * @val:	Value to write

 *

 * Write one configuration byte from the device using MMA955xL command format.

 * Commands to the MMA955xL platform consist of a write followed by one or

 * more reads.

 *

 * Locking note: This function must be called with the device lock held.

 * Locking is not handled inside the function. Callers should ensure they

 * serialize access to the HW.

 *

 * Returns: 0 on success, negative value on failure.

/**

 * mma9551_read_status_byte() - read 1 status byte

 * @client:	I2C client

 * @app_id:	Application ID

 * @reg:	Application register

 * @val:	Pointer to store value read

 *

 * Read one status byte from the device using MMA955xL command format.

 * Commands to the MMA955xL platform consist of a write followed by one or

 * more reads.

 *

 * Locking note: This function must be called with the device lock held.

 * Locking is not handled inside the function. Callers should ensure they

 * serialize access to the HW.

 *

 * Returns: 0 on success, negative value on failure.

/**

 * mma9551_read_config_word() - read 1 config word

 * @client:	I2C client

 * @app_id:	Application ID

 * @reg:	Application register

 * @val:	Pointer to store value read

 *

 * Read one configuration word from the device using MMA955xL command format.

 * Commands to the MMA955xL platform consist of a write followed by one or

 * more reads.

 *

 * Locking note: This function must be called with the device lock held.

 * Locking is not handled inside the function. Callers should ensure they

 * serialize access to the HW.

 *

 * Returns: 0 on success, negative value on failure.

/**

 * mma9551_write_config_word() - write 1 config word

 * @client:	I2C client

 * @app_id:	Application ID

 * @reg:	Application register

 * @val:	Value to write

 *

 * Write one configuration word from the device using MMA955xL command format.

 * Commands to the MMA955xL platform consist of a write followed by one or

 * more reads.

 *

 * Locking note: This function must be called with the device lock held.

 * Locking is not handled inside the function. Callers should ensure they

 * serialize access to the HW.

 *

 * Returns: 0 on success, negative value on failure.

/**

 * mma9551_read_status_word() - read 1 status word

 * @client:	I2C client

 * @app_id:	Application ID

 * @reg:	Application register

 * @val:	Pointer to store value read

 *

 * Read one status word from the device using MMA955xL command format.

 * Commands to the MMA955xL platform consist of a write followed by one or

 * more reads.

 *

 * Locking note: This function must be called with the device lock held.

 * Locking is not handled inside the function. Callers should ensure they

 * serialize access to the HW.

 *

 * Returns: 0 on success, negative value on failure.

/**

 * mma9551_read_config_words() - read multiple config words

 * @client:	I2C client

 * @app_id:	Application ID

 * @reg:	Application register

 * @len:	Length of array to read (in words)

 * @buf:	Array of words to read

 *

 * Read multiple configuration registers (word-sized registers).

 *

 * Locking note: This function must be called with the device lock held.

 * Locking is not handled inside the function. Callers should ensure they

 * serialize access to the HW.

 *

 * Returns: 0 on success, negative value on failure.

/**

 * mma9551_read_status_words() - read multiple status words

 * @client:	I2C client

 * @app_id:	Application ID

 * @reg:	Application register

 * @len:	Length of array to read (in words)

 * @buf:	Array of words to read

 *

 * Read multiple status registers (word-sized registers).

 *

 * Locking note: This function must be called with the device lock held.

 * Locking is not handled inside the function. Callers should ensure they

 * serialize access to the HW.

 *

 * Returns: 0 on success, negative value on failure.

/**

 * mma9551_write_config_words() - write multiple config words

 * @client:	I2C client

 * @app_id:	Application ID

 * @reg:	Application register

 * @len:	Length of array to write (in words)

 * @buf:	Array of words to write

 *

 * Write multiple configuration registers (word-sized registers).

 *

 * Locking note: This function must be called with the device lock held.

 * Locking is not handled inside the function. Callers should ensure they

 * serialize access to the HW.

 *

 * Returns: 0 on success, negative value on failure.

/**

 * mma9551_update_config_bits() - update bits in register

 * @client:	I2C client

 * @app_id:	Application ID

 * @reg:	Application register

 * @mask:	Mask for the bits to update

 * @val:	Value of the bits to update

 *

 * Update bits in the given register using a bit mask.

 *

 * Locking note: This function must be called with the device lock held.

 * Locking is not handled inside the function. Callers should ensure they

 * serialize access to the HW.

 *

 * Returns: 0 on success, negative value on failure.

/**

 * mma9551_gpio_config() - configure gpio

 * @client:	I2C client

 * @pin:	GPIO pin to configure

 * @app_id:	Application ID

 * @bitnum:	Bit number of status register being assigned to the GPIO pin.

 * @polarity:	The polarity parameter is described in section 6.2.2, page 66,

 *		of the Software Reference Manual.  Basically, polarity=0 means

 *		the interrupt line has the same value as the selected bit,

 *		while polarity=1 means the line is inverted.

 *

 * Assign a bit from an application’s status register to a specific GPIO pin.

 *

 * Locking note: This function must be called with the device lock held.

 * Locking is not handled inside the function. Callers should ensure they

 * serialize access to the HW.

 *

 * Returns: 0 on success, negative value on failure.

	/*

	 * Pin 6 is configured by regs 0x00 and 0x01, pin 7 by 0x02 and

	 * 0x03, and so on.

/**

 * mma9551_read_version() - read device version information

 * @client:	I2C client

 *

 * Read version information and print device id and firmware version.

 *

 * Locking note: This function must be called with the device lock held.

 * Locking is not handled inside the function. Callers should ensure they

 * serialize access to the HW.

 *

 * Returns: 0 on success, negative value on failure.

/**

 * mma9551_set_device_state() - sets HW power mode

 * @client:	I2C client

 * @enable:	Use true to power on device, false to cause the device

 *		to enter sleep.

 *

 * Set power on/off for device using the Sleep/Wake Application.

 * When enable is true, power on chip and enable doze mode.

 * When enable is false, enter sleep mode (device remains in the

 * lowest-power mode).

 *

 * Locking note: This function must be called with the device lock held.

 * Locking is not handled inside the function. Callers should ensure they

 * serialize access to the HW.

 *

 * Returns: 0 on success, negative value on failure.

/**

 * mma9551_set_power_state() - sets runtime PM state

 * @client:	I2C client

 * @on:		Use true to power on device, false to power off

 *

 * Resume or suspend the device using Runtime PM.

 * The device will suspend after the autosuspend delay.

 *

 * Returns: 0 on success, negative value on failure.

/**

 * mma9551_sleep() - sleep

 * @freq:	Application frequency

 *

 * Firmware applications run at a certain frequency on the

 * device. Sleep for one application cycle to make sure the

 * application had time to run once and initialize set values.

/**

 * mma9551_read_accel_chan() - read accelerometer channel

 * @client:	I2C client

 * @chan:	IIO channel

 * @val:	Pointer to the accelerometer value read

 * @val2:	Unused

 *

 * Read accelerometer value for the specified channel.

 *

 * Locking note: This function must be called with the device lock held.

 * Locking is not handled inside the function. Callers should ensure they

 * serialize access to the HW.

 *

 * Returns: IIO_VAL_INT on success, negative value on failure.

/**

 * mma9551_read_accel_scale() - read accelerometer scale

 * @val:	Pointer to the accelerometer scale (int value)

 * @val2:	Pointer to the accelerometer scale (micro value)

 *

 * Read accelerometer scale.

 *

 * Returns: IIO_VAL_INT_PLUS_MICRO.

/**

 * mma9551_app_reset() - reset application

 * @client:	I2C client

 * @app_mask:	Application to reset

 *

 * Reset the given application (using the Reset/Suspend/Clear

 * Control Application)

 *

 * Returns: 0 on success, negative value on failure.

 SPDX-License-Identifier: GPL-2.0+

/*

 * ADXL372 3-Axis Digital Accelerometer I2C driver

 *

 * Copyright 2018 Analog Devices Inc.

 Starting with the 3rd revision an I2C chip bug was fixed */

 SPDX-License-Identifier: GPL-2.0-only

 SPDX-License-Identifier: GPL-2.0-only

/*

 * sca3000_core.c -- support VTI sca3000 series accelerometers via SPI

 *

 * Copyright (c) 2009 Jonathan Cameron <jic23@kernel.org>

 *

 * See industrialio/accels/sca3000.h for comments.

 All reads done using register decrement so no need to directly access LSBs */

 Temp read untested - the e05 doesn't have the sensor */

/*

 * Free fall detection triggers an interrupt if the acceleration

 * is below a threshold for equivalent of 25cm drop

/*

 * In motion detection mode the accelerations are band pass filtered

 * (approx 1 - 25Hz) and then a programmable threshold used to trigger

 * and interrupt.

 Used to allow access to multiplexed registers */

 Only available for SCA3000-D03 and SCA3000-D01 */

/*

 * BE VERY CAREFUL WITH THIS, IF 3 BITS ARE NOT SET the device

 * will not function

/*

 * Control which motion detector interrupts are on.

 * For now only OR combinations are supported.

 Currently unsupported */

/*

 * Some control registers of complex access methods requiring this register to

 * be used to remove a lock.

 Values of multiplexed registers (write to ctrl_data after select) */

/*

 * Measurement modes available on some sca3000 series chips. Code assumes others

 * may become available in the future.

 *

 * Bypass - Bypass the low-pass filter in the signal channel so as to increase

 *          signal bandwidth.

 *

 * Narrow - Narrow low-pass filtering of the signal channel and half output

 *          data rate by decimation.

 *

 * Wide - Widen low-pass filtering of signal channel to increase bandwidth

/**

 * struct sca3000_state - device instance state information

 * @us:			the associated spi device

 * @info:			chip variant information

 * @last_timestamp:		the timestamp of the last event

 * @mo_det_use_count:		reference counter for the motion detection unit

 * @lock:			lock used to protect elements of sca3000_state

 *				and the underlying device state.

 * @tx:			dma-able transmit buffer

 * @rx:			dma-able receive buffer

 Can these share a cacheline ? */

/**

 * struct sca3000_chip_info - model dependent parameters

 * @scale:			scale * 10^-6

 * @temp_output:		some devices have temperature sensors.

 * @measurement_mode_freq:	normal mode sampling frequency

 * @measurement_mode_3db_freq:	3db cutoff frequency of the low pass filter for

 * the normal measurement mode.

 * @option_mode_1:		first optional mode. Not all models have one

 * @option_mode_1_freq:		option mode 1 sampling frequency

 * @option_mode_1_3db_freq:	3db cutoff frequency of the low pass filter for

 * the first option mode.

 * @option_mode_2:		second optional mode. Not all chips have one

 * @option_mode_2_freq:		option mode 2 sampling frequency

 * @option_mode_2_3db_freq:	3db cutoff frequency of the low pass filter for

 * the second option mode.

 * @mot_det_mult_xz:		Bit wise multipliers to calculate the threshold

 * for motion detection in the x and z axis.

 * @mot_det_mult_y:		Bit wise multipliers to calculate the threshold

 * for motion detection in the y axis.

 *

 * This structure is used to hold information about the functionality of a given

 * sca3000 variant.

/*

 * Note where option modes are not defined, the chip simply does not

 * support any.

 * Other chips in the sca3000 series use i2c and are not included here.

 *

 * Some of these devices are only listed in the family data sheet and

 * do not actually appear to be available.

/**

 * sca3000_reg_lock_on() - test if the ctrl register lock is on

 * @st: Driver specific device instance data.

 *

 * Lock must be held.

/**

 * __sca3000_unlock_reg_lock() - unlock the control registers

 * @st: Driver specific device instance data.

 *

 * Note the device does not appear to support doing this in a single transfer.

 * This should only ever be used as part of ctrl reg read.

 * Lock must be held before calling this

/**

 * sca3000_write_ctrl_reg() - write to a lock protect ctrl register

 * @st: Driver specific device instance data.

 * @sel: selects which registers we wish to write to

 * @val: the value to be written

 *

 * Certain control registers are protected against overwriting by the lock

 * register and use a shared write address. This function allows writing of

 * these registers.

 * Lock must be held.

 Set the control select register */

 Write the actual value into the register */

/**

 * sca3000_read_ctrl_reg() - read from lock protected control register.

 * @st: Driver specific device instance data.

 * @ctrl_reg: Which ctrl register do we want to read.

 *

 * Lock must be held.

 Set the control select register */

/**

 * sca3000_print_rev() - sysfs interface to read the chip revision number

 * @indio_dev: Device instance specific generic IIO data.

 * Driver specific device instance data can be obtained via

 * via iio_priv(indio_dev)

/*

 * Note the hack in the number of bits to pretend we have 2 more than

 * we do in the fifo.

 Fake channel */

 No buffer support */

 Fake channel */

/**

 * __sca3000_get_base_freq() - obtain mode specific base frequency

 * @st: Private driver specific device instance specific state.

 * @info: chip type specific information.

 * @base_freq: Base frequency for the current measurement mode.

 *

 * lock must be held

/**

 * sca3000_read_raw_samp_freq() - read_raw handler for IIO_CHAN_INFO_SAMP_FREQ

 * @st: Private driver specific device instance specific state.

 * @val: The frequency read back.

 *

 * lock must be held

/**

 * sca3000_write_raw_samp_freq() - write_raw handler for IIO_CHAN_INFO_SAMP_FREQ

 * @st: Private driver specific device instance specific state.

 * @val: The frequency desired.

 *

 * lock must be held

 mask bottom 2 bits - only ones that are relevant */

 get the temperature when available */

 temperature */

/**

 * sca3000_read_av_freq() - sysfs function to get available frequencies

 * @dev: Device structure for this device.

 * @attr: Description of the attribute.

 * @buf: Incoming string

 *

 * The later modes are only relevant to the ring buffer - and depend on current

 * mode. Note that data sheet gives rather wide tolerances for these so integer

 * division will give good enough answer and not all chips have them specified

 * at all.

/*

 * Should only really be registered if ring buffer support is compiled in.

 * Does no harm however and doing it right would add a fair bit of complexity

/*

 * sca3000_read_event_value() - query of a threshold or period

/**

 * sca3000_write_event_value() - control of threshold and period

 * @indio_dev: Device instance specific IIO information.

 * @chan: Description of the channel for which the event is being

 * configured.

 * @type: The type of event being configured, here magnitude rising

 * as everything else is read only.

 * @dir: Direction of the event (here rising)

 * @info: What information about the event are we configuring.

 * Here the threshold only.

 * @val: Integer part of the value being written..

 * @val2: Non integer part of the value being written. Here always 0.

/**

 * sca3000_ring_int_process() - ring specific interrupt handling.

 * @val: Value of the interrupt status register.

 * @indio_dev: Device instance specific IIO device structure.

		/*

		 * num_available is the total number of samples available

		 * i.e. number of time points * number of channels.

			/*

			 * Dirty hack to cover for 11 bit in fifo, 13 bit

			 * direct reading.

			 *

			 * In theory the bottom two bits are undefined.

			 * In reality they appear to always be 0.

/**

 * sca3000_event_handler() - handling ring and non ring events

 * @irq: The irq being handled.

 * @private: struct iio_device pointer for the device.

 *

 * Ring related interrupt handler. Depending on event, push to

 * the ring buffer event chrdev or the event one.

 *

 * This function is complicated by the fact that the devices can signify ring

 * and non ring events via the same interrupt line and they can only

 * be distinguished via a read of the relevant status register.

	/*

	 * Could lead if badly timed to an extra read of status reg,

	 * but ensures no interrupt is missed.

/*

 * sca3000_read_event_config() what events are enabled

 read current value of mode register */

		/*

		 * Motion detection mode cannot run at the same time as

		 * acceleration data being read.

 only supporting logical or's for now */

 read current value of mode register */

 if off and should be on */

 if on and should be off */

	/*

	 * First read the motion detector config to find out if

	 * this axis is on

 if off and should be on */

 read current value of mode register */

 if off and should be on */

 if on and should be off */

/**

 * sca3000_write_event_config() - simple on off control for motion detector

 * @indio_dev: IIO device instance specific structure. Data specific to this

 * particular driver may be accessed via iio_priv(indio_dev).

 * @chan: Description of the channel whose event we are configuring.

 * @type: The type of event.

 * @dir: The direction of the event.

 * @state: Desired state of event being configured.

 *

 * This is a per axis control, but enabling any will result in the

 * motion detector unit being enabled.

 * N.B. enabling motion detector stops normal data acquisition.

 * There is a complexity in knowing which mode to return to when

 * this mode is disabled.  Currently normal mode is assumed.

/**

 * sca3000_hw_ring_preenable() - hw ring buffer preenable function

 * @indio_dev: structure representing the IIO device. Device instance

 * specific state can be accessed via iio_priv(indio_dev).

 *

 * Very simple enable function as the chip will allows normal reads

 * during ring buffer operation so as long as it is indeed running

 * before we notify the core, the precise ordering does not matter.

 Enable the 50% full interrupt */

 Disable the 50% full interrupt */

/**

 * sca3000_clean_setup() - get the device into a predictable state

 * @st: Device instance specific private data structure

 *

 * Devices use flash memory to store many of the register values

 * and hence can come up in somewhat unpredictable states.

 * Hence reset everything on driver load.

 Ensure all interrupts have been acknowledged */

 Turn off all motion detection channels */

 Disable ring buffer */

 Enable interrupts, relevant to mode and set up as active low */

	/*

	 * Select normal measurement mode, free fall off, ring off

	 * Ring in 12 bit mode - it is fine to overwrite reserved bits 3,5

	 * as that occurs in one of the example on the datasheet

 Must ensure no interrupts can be generated after this! */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Freescale MMA9553L Intelligent Pedometer driver

 * Copyright (c) 2014, Intel Corporation.

 Pedometer configuration registers (R/W) */

 Pedometer status registers (R-only) */

 Pedometer events are always mapped to this pin. */

 Bitnum used for GPIO configuration = bit number in high status byte */

 Hz */

/*

 * The internal activity level must be stable for ACTTHD samples before

 * ACTIVITY is updated. The ACTIVITY variable contains the current activity

 * level and is updated every time a step is detected or once a second

 * if there are no steps.

/*

 * Autonomously suspend pedometer if acceleration vector magnitude

 * is near 1g (4096 at 0.244 mg/LSB resolution) for 30 seconds.

 0,9 g */

 1,1 g */

 Status register - activity field  */

	/*

	 * 1. Serialize access to HW (requested by mma9551_core API).

	 * 2. Serialize sequences that power on/off the device and access HW.

	/*

	 * This is used for all features that depend on step count:

	 * step count, distance, speed, calories.

 Reinitializes the pedometer with current configuration values */

	/*

	 * If both step detector and activity are enabled, use the MRGFL bit.

	 * This bit is the logical OR of the SUSPCHG, STEPCHG, and ACTCHG flags.

 Reset */

 Save initial values for activity and stepcnt */

	/*

	 * Read all the pedometer configuration registers. This is used as

	 * a device identification command to differentiate the MMA9553L

	 * from the MMA9550L.

 Reset GPIO */

 Init config registers */

	/*

	 * Clear the activity debounce counter when the activity level changes,

	 * so that the confidence level applies for any activity level.

	/*

	 * The HW only counts steps and other dependent

	 * parameters (speed, distance, calories, activity)

	 * if power is on (from enabling an event or the

	 * step counter).

			/*

			 * The device does not support confidence value levels,

			 * so we will always have 100% for current activity and

			 * 0% for the others.

 m/h */

 Cal or kcal */

 m/h to m/s */

 0.000277 */

 Cal or kcal to J */

 cm to m */

 m to cm */

			/*

			 * Set to 0 to disable step filtering. If the value

			 * specified is greater than 6, then 6 will be used.

			/*

			 * If set to a value greater than 5, then 5 will be

			 * used. Warning: Do not set SPDPRD to 0 or 1 as

			 * this may cause undesirable behavior.

			/*

			 * The device does not support confidence value levels.

			 * We set an average of 50%.

	/*

	 * HW expects 0 for female and 1 for male,

	 * while iio index is 0 for male and 1 for female.

	/*

	 * Since we only configure the interrupt pin when an

	 * event is enabled, we are sure we have at least

	 * one event enabled at this point.

 ev_activity can be NULL if activity == ACTIVITY_UNKNOWN */

 SPDX-License-Identifier: GPL-2.0

/*

 * MS5611 pressure and temperature sensor driver

 *

 * Copyright (c) Tomasz Duszynski <tduszyns@gmail.com>

 *

 * Data sheet:

 *  http://www.meas-spec.com/downloads/MS5611-01BA03.pdf

 *  http://www.meas-spec.com/downloads/MS5607-02BA03.pdf

 *

 Ensure buffer elements are naturally aligned */

 Enable attached regulator if any. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * SPI interface for the BMP280 driver

 *

 * Inspired by the older BMP085 driver drivers/misc/bmp085-spi.c

	/*

	 * The SPI register address (= full register address without bit 7) and

	 * the write command (bit7 = RW = '0')

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Murata ZPA2326 I2C pressure and temperature sensor driver

 *

 * Copyright (c) 2016 Parrot S.A.

 *

 * Author: Gregor Boirie <gregor.boirie@parrot.com>

/*

 * read_flag_mask:

 *   - address bit 7 must be set to request a register read operation

 Identification register bit 1 mirrors device address bit 0. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HID Sensors Driver

 * Copyright (c) 2014, Intel Corporation.

 Channel definitions */

 Adjust channel real bits based on report descriptor */

 Real storage bits will change based on the report desc. */

 Maximum size of a sample to capture is u32 */

 Channel read_raw handler */

 Channel write_raw handler */

 Callback handler to send event after all samples are received and captured */

 Capture samples in local storage */

 Parse report which is specific to an usage id*/

 Function to initialize the processing for usage id */

 Function to deinitialize the processing for usage id */

 Format: HID-SENSOR-usage_id_in_hex_lowercase */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0

/*

 * MS5611 pressure and temperature sensor driver (SPI bus)

 *

 * Copyright (c) Tomasz Duszynski <tduszyns@gmail.com>

 *

	/*

	 * Warning: &osr->cmd MUST be aligned on a word boundary since used as

	 * 2nd argument (void*) of spi_write_then_read.

 SPDX-License-Identifier: GPL-2.0-only

 SPDX-License-Identifier: GPL-2.0

/*

 * All Sensors DLH series low voltage digital pressure sensors

 *

 * Copyright (c) 2019 AVL DiTEST GmbH

 *   Tomislav Denis <tomislav.denis@avl.com>

 *

 * Datasheet: https://www.allsensors.com/cad/DS-0355_Rev_B.PDF

 Commands */

 Status bits */

 DLH  data format */

 DLH  timings */

 digital offset factor */

 full scale span (inch H2O) */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2010 Christoph Mair <christoph.mair@gmail.com>

 * Copyright (c) 2012 Bosch Sensortec GmbH

 * Copyright (c) 2012 Unixphere AB

 * Copyright (c) 2014 Intel Corporation

 * Copyright (c) 2016 Linus Walleij <linus.walleij@linaro.org>

 *

 * Driver for Bosch Sensortec BMP180 and BMP280 digital pressure sensor.

 *

 * Datasheet:

 * https://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST-BMP180-DS000-121.pdf

 * https://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST-BMP280-DS001-12.pdf

 * https://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST-BME280_DS001-11.pdf

 For irq_get_irq_data() */

/*

 * These enums are used for indexing into the array of calibration

 * coefficients for BMP180.

 See datasheet Section 4.2.2. */

 in microseconds */

 log of base 2 of oversampling rate */

	/*

	 * Carryover value from temperature conversion, used in pressure

	 * calculation.

/*

 * These enums are used for indexing into the array of compensation

 * parameters for BMP280.

 Read temperature calibration values. */

 Toss the temperature calibration data into the entropy pool */

 Read pressure calibration values. */

 Toss the pressure calibration data into the entropy pool */

	/*

	 * Read humidity calibration values.

	 * Due to some odd register addressing we cannot just

	 * do a big bulk read. Instead, we have to read each Hx

	 * value separately and sometimes do some bit shifting...

	 * Humidity data is only available on BME280.

/*

 * Returns humidity in percent, resolution is 0.01 percent. Output value of

 * "47445" represents 47445/1024 = 46.333 %RH.

 *

 * Taken from BME280 datasheet, Section 4.2.3, "Compensation formula".

/*

 * Returns temperature in DegC, resolution is 0.01 DegC.  Output value of

 * "5123" equals 51.23 DegC.  t_fine carries fine temperature as global

 * value.

 *

 * Taken from datasheet, Section 3.11.3, "Compensation formula".

/*

 * Returns pressure in Pa as unsigned 32 bit integer in Q24.8 format (24

 * integer bits and 8 fractional bits).  Output value of "24674867"

 * represents 24674867/256 = 96386.2 Pa = 963.862 hPa

 *

 * Taken from datasheet, Section 3.11.3, "Compensation formula".

 reading was skipped */

	/*

	 * val might be NULL if we're called by the read_press routine,

	 * who only cares about the carry over t_fine value.

 Read and compensate temperature so we get a reading of t_fine. */

 reading was skipped */

 Read and compensate temperature so we get a reading of t_fine. */

 reading was skipped */

	/*

	 * Oversampling of humidity must be set before oversampling of

	 * temperature/pressure is set to become effective.

		/*

		 * If we have a completion interrupt, use it, wait up to

		 * 100ms. The longest conversion time listed is 76.5 ms for

		 * advanced resolution mode.

 The value of this bit reset to "0" after conversion is complete */

 None of the words has the value 0 or 0xFFFF */

 Toss the calibration data into the entropy pool */

/*

 * Returns temperature in DegC, resolution is 0.1 DegC.

 * t_fine carries fine temperature as global value.

 *

 * Taken from datasheet, Section 3.5, "Calculating pressure and temperature".

	/*

	 * val might be NULL if we're called by the read_press routine,

	 * who only cares about the carry over t_fine value.

/*

 * Returns pressure in Pa, resolution is 1 Pa.

 *

 * Taken from datasheet, Section 3.5, "Calculating pressure and temperature".

 Read and compensate temperature so we get a reading of t_fine. */

 Bail out without IRQ but keep the driver in place */

 Bring up regulators */

 Wait to make sure we started up properly */

 Bring chip out of reset if there is an assigned GPIO line */

 Deassert the signal */

	/*

	 * Some chips have calibration parameters "programmed into the devices'

	 * non-volatile memory during production". Let's read them out at probe

	 * time once. They will not change.

	/*

	 * Attempt to grab an optional EOC IRQ - only the BMP085 has this

	 * however as it happens, the BMP085 shares the chip ID of BMP180

	 * so we look for an IRQ if we have that.

 Enable runtime PM */

	/*

	 * Set autosuspend to two orders of magnitude larger than the

	 * start-up time.

 CONFIG_PM */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Murata ZPA2326 pressure and temperature sensor IIO driver

 *

 * Copyright (c) 2016 Parrot S.A.

 *

 * Author: Gregor Boirie <gregor.boirie@parrot.com>

/**

 * DOC: ZPA2326 theory of operations

 *

 * This driver supports %INDIO_DIRECT_MODE and %INDIO_BUFFER_TRIGGERED IIO

 * modes.

 * A internal hardware trigger is also implemented to dispatch registered IIO

 * trigger consumers upon "sample ready" interrupts.

 *

 * ZPA2326 hardware supports 2 sampling mode: one shot and continuous.

 *

 * A complete one shot sampling cycle gets device out of low power mode,

 * performs pressure and temperature measurements, then automatically switches

 * back to low power mode. It is meant for on demand sampling with optimal power

 * saving at the cost of lower sampling rate and higher software overhead.

 * This is a natural candidate for IIO read_raw hook implementation

 * (%INDIO_DIRECT_MODE). It is also used for triggered buffering support to

 * ensure explicit synchronization with external trigger events

 * (%INDIO_BUFFER_TRIGGERED).

 *

 * The continuous mode works according to a periodic hardware measurement

 * process continuously pushing samples into an internal hardware FIFO (for

 * pressure samples only). Measurement cycle completion may be signaled by a

 * "sample ready" interrupt.

 * Typical software sequence of operations :

 * - get device out of low power mode,

 * - setup hardware sampling period,

 * - at end of period, upon data ready interrupt: pop pressure samples out of

 *   hardware FIFO and fetch temperature sample

 * - when no longer needed, stop sampling process by putting device into

 *   low power mode.

 * This mode is used to implement %INDIO_BUFFER_TRIGGERED mode if device tree

 * declares a valid interrupt line. In this case, the internal hardware trigger

 * drives acquisition.

 *

 * Note that hardware sampling frequency is taken into account only when

 * internal hardware trigger is attached as the highest sampling rate seems to

 * be the most energy efficient.

 *

 * TODO:

 *   preset pressure threshold crossing / IIO events ;

 *   differential pressure sampling ;

 *   hardware samples averaging.

 200 ms should be enough for the longest conversion time in one-shot mode. */

 There should be a 1 ms delay (Tpup) after getting out of reset. */

/**

 * struct zpa2326_frequency - Hardware sampling frequency descriptor

 * @hz : Frequency in Hertz.

 * @odr: Output Data Rate word as expected by %ZPA2326_CTRL_REG3_REG.

/*

 * Keep these in strict ascending order: last array entry is expected to

 * correspond to the highest sampling frequency.

 Return the highest hardware sampling frequency available. */

/**

 * struct zpa2326_private - Per-device internal private state

 * @timestamp:  Buffered samples ready datum.

 * @regmap:     Underlying I2C / SPI bus adapter used to abstract slave register

 *              accesses.

 * @result:     Allows sampling logic to get completion status of operations

 *              that interrupt handlers perform asynchronously.

 * @data_ready: Interrupt handler uses this to wake user context up at sampling

 *              operation completion.

 * @trigger:    Optional hardware / interrupt driven trigger used to notify

 *              external devices a new sample is ready.

 * @waken:      Flag indicating whether or not device has just been powered on.

 * @irq:        Optional interrupt line: negative or zero if not declared into

 *              DT, in which case sampling logic keeps polling status register

 *              to detect completion.

 * @frequency:  Current hardware sampling frequency.

 * @vref:       Power / voltage reference.

 * @vdd:        Power supply.

/**

 * zpa2326_enable_device() - Enable device, i.e. get out of low power mode.

 * @indio_dev: The IIO device associated with the hardware to enable.

 *

 * Required to access complete register space and to perform any sampling

 * or control operations.

 *

 * Return: Zero when successful, a negative error code otherwise.

/**

 * zpa2326_sleep() - Disable device, i.e. switch to low power mode.

 * @indio_dev: The IIO device associated with the hardware to disable.

 *

 * Only %ZPA2326_DEVICE_ID_REG and %ZPA2326_CTRL_REG0_REG registers may be

 * accessed once device is in the disabled state.

 *

 * Return: Zero when successful, a negative error code otherwise.

/**

 * zpa2326_reset_device() - Reset device to default hardware state.

 * @indio_dev: The IIO device associated with the hardware to reset.

 *

 * Disable sampling and empty hardware FIFO.

 * Device must be enabled before reset, i.e. not in low power mode.

 *

 * Return: Zero when successful, a negative error code otherwise.

/**

 * zpa2326_start_oneshot() - Start a single sampling cycle, i.e. in one shot

 *                           mode.

 * @indio_dev: The IIO device associated with the sampling hardware.

 *

 * Device must have been previously enabled and configured for one shot mode.

 * Device will be switched back to low power mode at end of cycle.

 *

 * Return: Zero when successful, a negative error code otherwise.

/**

 * zpa2326_power_on() - Power on device to allow subsequent configuration.

 * @indio_dev: The IIO device associated with the sampling hardware.

 * @private:   Internal private state related to @indio_dev.

 *

 * Sampling will be disabled, preventing strange things from happening in our

 * back. Hardware FIFO content will be cleared.

 * When successful, device will be left in the enabled state to allow further

 * configuration.

 *

 * Return: Zero when successful, a negative error code otherwise.

/**

 * zpa2326_power_off() - Power off device, i.e. disable attached power

 *                       regulators.

 * @indio_dev: The IIO device associated with the sampling hardware.

 * @private:   Internal private state related to @indio_dev.

 *

 * Return: Zero when successful, a negative error code otherwise.

/**

 * zpa2326_config_oneshot() - Setup device for one shot / on demand mode.

 * @indio_dev: The IIO device associated with the sampling hardware.

 * @irq:       Optional interrupt line the hardware uses to notify new data

 *             samples are ready. Negative or zero values indicate no interrupts

 *             are available, meaning polling is required.

 *

 * Output Data Rate is configured for the highest possible rate so that

 * conversion time and power consumption are reduced to a minimum.

 * Note that hardware internal averaging machinery (not implemented in this

 * driver) is not applicable in this mode.

 *

 * Device must have been previously enabled before calling

 * zpa2326_config_oneshot().

 *

 * Return: Zero when successful, a negative error code otherwise.

 Setup highest available Output Data Rate for one shot mode. */

 Request interrupt when new sample is available. */

/**

 * zpa2326_clear_fifo() - Clear remaining entries in hardware FIFO.

 * @indio_dev: The IIO device associated with the sampling hardware.

 * @min_count: Number of samples present within hardware FIFO.

 *

 * @min_count argument is a hint corresponding to the known minimum number of

 * samples currently living in the FIFO. This allows to reduce the number of bus

 * accesses by skipping status register read operation as long as we know for

 * sure there are still entries left.

 *

 * Return: Zero when successful, a negative error code otherwise.

		/*

		 * No hint: read status register to determine whether FIFO is

		 * empty or not.

 Fifo is empty: nothing to trash. */

 Clear FIFO. */

		/*

		 * A single fetch from pressure MSB register is enough to pop

		 * values out of FIFO.

			/*

			 * We know for sure there are at least min_count entries

			 * left in FIFO. Skip status register read.

/**

 * zpa2326_dequeue_pressure() - Retrieve the most recent pressure sample from

 *                              hardware FIFO.

 * @indio_dev: The IIO device associated with the sampling hardware.

 * @pressure:  Sampled pressure output.

 *

 * Note that ZPA2326 hardware FIFO stores pressure samples only.

 *

 * Return: Zero when successful, a negative error code otherwise.

		/*

		 * Fifo overrun : first sample dequeued from FIFO is the

		 * newest.

 Hardware FIFO may hold no more than 16 pressure samples. */

	/*

	 * Fifo has not overflown : retrieve newest sample. We need to pop

	 * values out until FIFO is empty : last fetched pressure is the newest.

	 * In nominal cases, we should find a single queued sample only.

		/*

		 * Samples were pushed by hardware during previous rounds but we

		 * didn't consume them fast enough: inform user.

/**

 * zpa2326_fill_sample_buffer() - Enqueue new channel samples to IIO buffer.

 * @indio_dev: The IIO device associated with the sampling hardware.

 * @private:   Internal private state related to @indio_dev.

 *

 * Return: Zero when successful, a negative error code otherwise.

 Get current pressure from hardware FIFO. */

 Get current temperature. */

	/*

	 * Now push samples using timestamp stored either :

	 *   - by hardware interrupt handler if interrupt is available: see

	 *     zpa2326_handle_irq(),

	 *   - or oneshot completion polling machinery : see

	 *     zpa2326_trigger_handler().

 Userspace changed autosuspend delay. */

/**

 * zpa2326_resume() - Request the PM layer to power supply the device.

 * @indio_dev: The IIO device associated with the sampling hardware.

 *

 * Return:

 *  < 0 - a negative error code meaning failure ;

 *    0 - success, device has just been powered up ;

 *    1 - success, device was already powered.

		/*

		 * Device was already power supplied: get it out of low power

		 * mode and inform caller.

 Inform caller device has just been brought back to life. */

/**

 * zpa2326_suspend() - Schedule a power down using autosuspend feature of PM

 *                     layer.

 * @indio_dev: The IIO device associated with the sampling hardware.

 *

 * Device is switched to low power mode at first to save power even when

 * attached regulator is a "dummy" one.

 !CONFIG_PM */

 !CONFIG_PM */

/**

 * zpa2326_handle_irq() - Process hardware interrupts.

 * @irq:  Interrupt line the hardware uses to notify new data has arrived.

 * @data: The IIO device associated with the sampling hardware.

 *

 * Timestamp buffered samples as soon as possible then schedule threaded bottom

 * half.

 *

 * Return: Always successful.

 Timestamping needed for buffered sampling only. */

/**

 * zpa2326_handle_threaded_irq() - Interrupt bottom-half handler.

 * @irq:  Interrupt line the hardware uses to notify new data has arrived.

 * @data: The IIO device associated with the sampling hardware.

 *

 * Mainly ensures interrupt is caused by a real "new sample available"

 * condition. This relies upon the ability to perform blocking / sleeping bus

 * accesses to slave's registers. This is why zpa2326_handle_threaded_irq() is

 * called from within a thread, i.e. not called from hard interrupt context.

 *

 * When device is using its own internal hardware trigger in continuous sampling

 * mode, data are available into hardware FIFO once interrupt has occurred. All

 * we have to do is to dispatch the trigger, which in turn will fetch data and

 * fill IIO buffer.

 *

 * When not using its own internal hardware trigger, the device has been

 * configured in one-shot mode either by an external trigger or the IIO read_raw

 * hook. This means one of the latter is currently waiting for sampling

 * completion, in which case we must simply wake it up.

 *

 * See zpa2326_trigger_handler().

 *

 * Return:

 *   %IRQ_NONE - no consistent interrupt happened ;

 *   %IRQ_HANDLED - there was new samples available.

	/*

	 * Are we using our own internal trigger in triggered buffer mode, i.e.,

	 * currently working in continuous sampling mode ?

	/*

	 * Device works according to a level interrupt scheme: reading interrupt

	 * status de-asserts interrupt line.

 Data ready is the only interrupt source we requested. */

		/*

		 * Interrupt happened but no new sample available: likely caused

		 * by spurious interrupts, in which case, returning IRQ_NONE

		 * allows to benefit from the generic spurious interrupts

		 * handling.

 New sample available: dispatch internal trigger consumers. */

		/*

		 * Internal hardware trigger has been scheduled above : it will

		 * fetch data on its own.

	/*

	 * Wake up direct or externaly triggered buffer mode waiters: see

	 * zpa2326_sample_oneshot() and zpa2326_trigger_handler().

/**

 * zpa2326_wait_oneshot_completion() - Wait for oneshot data ready interrupt.

 * @indio_dev: The IIO device associated with the sampling hardware.

 * @private:   Internal private state related to @indio_dev.

 *

 * Return: Zero when successful, a negative error code otherwise.

		/*

		 * Interrupt handler completed before timeout: return operation

		 * status.

 Clear all interrupts just to be sure. */

 Timed out. */

		/*

		 * Platform declared no interrupt line: device will be polled

		 * for data availability.

 Request handler to be scheduled into threaded interrupt context. */

/**

 * zpa2326_poll_oneshot_completion() - Actively poll for one shot data ready.

 * @indio_dev: The IIO device associated with the sampling hardware.

 *

 * Loop over registers content to detect end of sampling cycle. Used when DT

 * declared no valid interrupt lines.

 *

 * Return: Zero when successful, a negative error code otherwise.

	/*

	 * At least, 100 ms is needed for the device to complete its one-shot

	 * cycle.

 Poll for conversion completion in hardware. */

 One-shot bit self clears at conversion end. */

 Prevent from waiting forever : let's time out. */

	/*

	 * In oneshot mode, pressure sample availability guarantees that

	 * temperature conversion has also completed : just check pressure

	 * status bit to keep things simple.

 No sample available. */

/**

 * zpa2326_fetch_raw_sample() - Retrieve a raw sample and convert it to CPU

 *                              endianness.

 * @indio_dev: The IIO device associated with the sampling hardware.

 * @type:      Type of measurement / channel to fetch from.

 * @value:     Sample output.

 *

 * Return: Zero when successful, a negative error code otherwise.

 Temperature is a 16 bits wide little-endian signed int. */

/**

 * zpa2326_sample_oneshot() - Perform a complete one shot sampling cycle.

 * @indio_dev: The IIO device associated with the sampling hardware.

 * @type:      Type of measurement / channel to fetch from.

 * @value:     Sample output.

 *

 * Return: Zero when successful, a negative error code otherwise.

		/*

		 * We were already power supplied. Just clear hardware FIFO to

		 * get rid of samples acquired during previous rounds (if any).

		 * Sampling operation always generates both temperature and

		 * pressure samples. The latter are always enqueued into

		 * hardware FIFO. This may lead to situations were pressure

		 * samples still sit into FIFO when previous cycle(s) fetched

		 * temperature data only.

		 * Hence, we need to clear hardware FIFO content to prevent from

		 * getting outdated values at the end of current cycle.

		/*

		 * We have just been power supplied, i.e. device is in default

		 * "out of reset" state, meaning we need to reconfigure it

		 * entirely.

 Start a sampling cycle in oneshot mode. */

 Wait for sampling cycle to complete. */

 Retrieve raw sample value and convert it to CPU endianness. */

/**

 * zpa2326_trigger_handler() - Perform an IIO buffered sampling round in one

 *                             shot mode.

 * @irq:  The software interrupt assigned to @data

 * @data: The IIO poll function dispatched by external trigger our device is

 *        attached to.

 *

 * Bottom-half handler called by the IIO trigger to which our device is

 * currently attached. Allows us to synchronize this device buffered sampling

 * either with external events (such as timer expiration, external device sample

 * ready, etc...) or with its own interrupt (internal hardware trigger).

 *

 * When using an external trigger, basically run the same sequence of operations

 * as for zpa2326_sample_oneshot() with the following hereafter. Hardware FIFO

 * is not cleared since already done at buffering enable time and samples

 * dequeueing always retrieves the most recent value.

 *

 * Otherwise, when internal hardware trigger has dispatched us, just fetch data

 * from hardware FIFO.

 *

 * Fetched data will pushed unprocessed to IIO buffer since samples conversion

 * is delegated to userspace in buffered mode (endianness, etc...).

 *

 * Return:

 *   %IRQ_NONE - no consistent interrupt happened ;

 *   %IRQ_HANDLED - there was new samples available.

	/*

	 * We have been dispatched, meaning we are in triggered buffer mode.

	 * Using our own internal trigger implies we are currently in continuous

	 * hardware sampling mode.

 On demand sampling : start a one shot cycle. */

 Wait for sampling cycle to complete. */

 No interrupt available: poll for completion. */

 Only timestamp sample once it is ready. */

 Interrupt handlers will timestamp for us. */

 Enqueue to IIO buffer / userspace. */

 Don't switch to low power if sampling continuously. */

 Inform attached trigger we are done. */

/**

 * zpa2326_preenable_buffer() - Prepare device for configuring triggered

 *                              sampling

 * modes.

 * @indio_dev: The IIO device associated with the sampling hardware.

 *

 * Basically power up device.

 * Called with IIO device's lock held.

 *

 * Return: Zero when successful, a negative error code otherwise.

 Tell zpa2326_postenable_buffer() if we have just been powered on. */

/**

 * zpa2326_postenable_buffer() - Configure device for triggered sampling.

 * @indio_dev: The IIO device associated with the sampling hardware.

 *

 * Basically setup one-shot mode if plugging external trigger.

 * Otherwise, let internal trigger configure continuous sampling :

 * see zpa2326_set_trigger_state().

 *

 * If an error is returned, IIO layer will call our postdisable hook for us,

 * i.e. no need to explicitly power device off here.

 * Called with IIO device's lock held.

 *

 * Called with IIO device's lock held.

 *

 * Return: Zero when successful, a negative error code otherwise.

		/*

		 * We were already power supplied. Just clear hardware FIFO to

		 * get rid of samples acquired during previous rounds (if any).

		/*

		 * We are using an external trigger and we have just been

		 * powered up: reconfigure one-shot mode.

/**

 * zpa2326_set_trigger_state() - Start / stop continuous sampling.

 * @trig:  The trigger being attached to IIO device associated with the sampling

 *         hardware.

 * @state: Tell whether to start (true) or stop (false)

 *

 * Basically enable / disable hardware continuous sampling mode.

 *

 * Called with IIO device's lock held at postenable() or predisable() time.

 *

 * Return: Zero when successful, a negative error code otherwise.

		/*

		 * Switch trigger off : in case of failure, interrupt is left

		 * disabled in order to prevent handler from accessing released

		 * resources.

		/*

		 * As device is working in continuous mode, handlers may be

		 * accessing resources we are currently freeing...

		 * Prevent this by disabling interrupt handlers and ensure

		 * the device will generate no more interrupts unless explicitly

		 * required to, i.e. by restoring back to default one shot mode.

		/*

		 * Disable continuous sampling mode to restore settings for

		 * one shot / direct sampling operations.

		/*

		 * Now that device won't generate interrupts on its own,

		 * acknowledge any currently active interrupts (may happen on

		 * rare occasions while stopping continuous mode).

		/*

		 * Re-enable interrupts only if we can guarantee the device will

		 * generate no more interrupts to prevent handlers from

		 * accessing released resources.

		/*

		 * Switch trigger on : start continuous sampling at required

		 * frequency.

 Enable interrupt if getting out of reset. */

 Enable continuous sampling at specified frequency. */

/**

 * zpa2326_init_managed_trigger() - Create interrupt driven / hardware trigger

 *                          allowing to notify external devices a new sample is

 *                          ready.

 * @parent:    Hardware sampling device @indio_dev is a child of.

 * @indio_dev: The IIO device associated with the sampling hardware.

 * @private:   Internal private state related to @indio_dev.

 * @irq:       Optional interrupt line the hardware uses to notify new data

 *             samples are ready. Negative or zero values indicate no interrupts

 *             are available, meaning polling is required.

 *

 * Only relevant when DT declares a valid interrupt line.

 *

 * Return: Zero when successful, a negative error code otherwise.

 Basic setup. */

 Register to triggers space. */

 Check if requested frequency is supported. */

 Don't allow changing frequency if buffered sampling is ongoing. */

 Expose supported hardware sampling frequencies (Hz) through sysfs. */

			/*

			 * Pressure resolution is 1/64 Pascal. Scale to kPascal

			 * as required by IIO ABI.

			/*

			 * Temperature follows the equation:

			 *     Temp[degC] = Tempcode * 0.00649 - 176.83

			 * where:

			 *     Tempcode is composed the raw sampled 16 bits.

			 *

			 * Hence, to produce a temperature in milli-degrees

			 * Celsius according to IIO ABI, we need to apply the

			 * following equation to raw samples:

			 *     Temp[milli degC] = (Tempcode + Offset) * Scale

			 * where:

			 *     Offset = -176.83 / 0.00649

			 *     Scale = 0.00649 * 1000

 Allocate space to hold IIO device internal state. */

 Setup for userspace synchronous on demand sampling. */

 Set default hardware sampling frequency to highest rate supported. */

	/*

	 * Plug device's underlying bus abstraction : this MUST be set before

	 * registering interrupt handlers since an interrupt might happen if

	 * power up sequence is not properly applied.

 Power up to check device ID and perform initial hardware setup. */

 Read id register to check we are talking to the right slave. */

 Setup done : go sleeping. Device will be awaken upon user request. */

 Put to sleep just in case power regulators are "dummy" ones. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ms5637.c - Support for Measurement-Specialties MS5637, MS5805

 *            MS5837 and MS8607 pressure & temperature sensor

 *

 * Copyright (c) 2015 Measurement-Specialties

 *

 * (7-bit I2C slave address 0x76)

 *

 * Datasheet:

 *  http://www.meas-spec.com/downloads/MS5637-02BA03.pdf

 * Datasheet:

 *  http://www.meas-spec.com/downloads/MS5805-02BA01.pdf

 * Datasheet:

 *  http://www.meas-spec.com/downloads/MS5837-30BA.pdf

 * Datasheet:

 *  http://www.meas-spec.com/downloads/MS8607-02BA01.pdf

 in milli °C */

 in kPa */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * STMicroelectronics pressures driver

 *

 * Copyright 2013 STMicroelectronics Inc.

 *

 * Denis Ciocca <denis.ciocca@st.com>

/*

 * About determining pressure scaling factors

 * ------------------------------------------

 *

 * Datasheets specify typical pressure sensitivity so that pressure is computed

 * according to the following equation :

 *     pressure[mBar] = raw / sensitivity

 * where :

 *     raw          the 24 bits long raw sampled pressure

 *     sensitivity  a scaling factor specified by the datasheet in LSB/mBar

 *

 * IIO ABI expects pressure to be expressed as kPascal, hence pressure should be

 * computed according to :

 *     pressure[kPascal] = pressure[mBar] / 10

 *                       = raw / (sensitivity * 10)                          (1)

 *

 * Finally, st_press_read_raw() returns pressure scaling factor as an

 * IIO_VAL_INT_PLUS_NANO with a zero integral part and "gain" as decimal part.

 * Therefore, from (1), "gain" becomes :

 *     gain = 10^9 / (sensitivity * 10)

 *          = 10^8 / sensitivity

 *

 * About determining temperature scaling factors and offsets

 * ---------------------------------------------------------

 *

 * Datasheets specify typical temperature sensitivity and offset so that

 * temperature is computed according to the following equation :

 *     temp[Celsius] = offset[Celsius] + (raw / sensitivity)

 * where :

 *     raw          the 16 bits long raw sampled temperature

 *     offset       a constant specified by the datasheet in degree Celsius

 *                  (sometimes zero)

 *     sensitivity  a scaling factor specified by the datasheet in LSB/Celsius

 *

 * IIO ABI expects temperature to be expressed as milli degree Celsius such as

 * user space should compute temperature according to :

 *     temp[mCelsius] = temp[Celsius] * 10^3

 *                    = (offset[Celsius] + (raw / sensitivity)) * 10^3

 *                    = ((offset[Celsius] * sensitivity) + raw) *

 *                      (10^3 / sensitivity)                                 (2)

 *

 * IIO ABI expects user space to apply offset and scaling factors to raw samples

 * according to :

 *     temp[mCelsius] = (OFFSET + raw) * SCALE

 * where :

 *     OFFSET an arbitrary constant exposed by device

 *     SCALE  an arbitrary scaling factor exposed by device

 *

 * Matching OFFSET and SCALE with members of (2) gives :

 *     OFFSET = offset[Celsius] * sensitivity                                (3)

 *     SCALE  = 10^3 / sensitivity                                           (4)

 *

 * st_press_read_raw() returns temperature scaling factor as an

 * IIO_VAL_FRACTIONAL with a 10^3 numerator and "gain2" as denominator.

 * Therefore, from (3), "gain2" becomes :

 *     gain2 = sensitivity

 *

 * When declared within channel, i.e. for a non zero specified offset,

 * st_press_read_raw() will return the latter as an IIO_VAL_FRACTIONAL such as :

 *     numerator = OFFSET * 10^3

 *     denominator = 10^3

 * giving from (4):

 *     numerator = offset[Celsius] * 10^3 * sensitivity

 *               = offset[mCelsius] * gain2

 Default pressure sensitivity */

 Default temperature sensitivity */

 FULLSCALE */

 LPS001WP pressure resolution */

 LPS001WP temperature resolution */

 LPS001WP pressure gain */

 LPS001WP pressure and temp L addresses */

 LPS25H pressure and temp L addresses */

 LPS22HB temperature sensitivity */

		/*

		 * CUSTOM VALUES FOR LPS331AP SENSOR

		 * See LPS331AP datasheet:

		 * http://www2.st.com/resource/en/datasheet/lps331ap.pdf

				/*

				 * Pressure and temperature sensitivity values

				 * as defined in table 3 of LPS331AP datasheet.

		/*

		 * CUSTOM VALUES FOR LPS001WP SENSOR

				/*

				 * Pressure and temperature resolution values

				 * as defined in table 3 of LPS001WP datasheet.

		/*

		 * CUSTOM VALUES FOR LPS25H SENSOR

		 * See LPS25H datasheet:

		 * http://www2.st.com/resource/en/datasheet/lps25h.pdf

				/*

				 * Pressure and temperature sensitivity values

				 * as defined in table 3 of LPS25H datasheet.

		/*

		 * CUSTOM VALUES FOR LPS22HB SENSOR

		 * See LPS22HB datasheet:

		 * http://www2.st.com/resource/en/datasheet/lps22hb.pdf

				/*

				 * Pressure and temperature sensitivity values

				 * as defined in table 3 of LPS22HB datasheet.

		/*

		 * CUSTOM VALUES FOR LPS22HH SENSOR

		 * See LPS22HH datasheet:

		 * http://www2.st.com/resource/en/datasheet/lps22hh.pdf

				/*

				 * Pressure and temperature sensitivity values

				 * as defined in table 3 of LPS22HH datasheet.

/*

 * st_press_get_settings() - get sensor settings from device name

 * @name: device name buffer reference.

 *

 * Return: valid reference on success, NULL otherwise.

	/*

	 * Skip timestamping channel while declaring available channels to

	 * common st_sensor layer. Look at st_sensors_get_buffer_element() to

	 * see how timestamps are explicitly pushed as last samples block

	 * element.

 Some devices don't support a data ready pin. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2020 InvenSense, Inc.

 *

 * Driver for InvenSense ICP-1010xx barometric pressure and temperature sensor.

 *

 * Datasheet:

 * http://www.invensense.com/wp-content/uploads/2018/01/DS-000186-ICP-101xx-v1.2.pdf

 Low power mode: 1x sampling */

 Normal mode: 2x sampling */

 Low noise mode: 4x sampling */

 Ultra low noise mode: 8x sampling */

 direct command-response without waiting */

 transfer command write */

 transfer response read if needed */

 process read words with crc checking */

 switch into OTP read mode */

 read 4 calibration values */

 read and check id */

 read calibration data from OTP */

 reset chip */

 compute p_lut values */

 compute a, b, c factors */

	/*

	 * pressure_Pa = a + (b / (c + raw_pressure))

	 * pressure_mPa = 1000 * pressure_Pa

 mPa to kPa */

 1000 * 175°C / 65536 in m°C */

 1000 * -45°C in m°C */

 oversampling is always positive and a power of 2 */

 has to be done before the first i2c communication */

 enable runtime pm with autosuspend delay of 2s */

 reset chip */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * mpl115.c - Support for Freescale MPL115A pressure/temperature sensor

 *

 * Copyright (c) 2014 Peter Meerwald <pmeerw@pmeerw.net>

 *

 * TODO: shutdown pin

 pressure ADC output value, MSB first, 10 bit */

 temperature ADC output value, MSB first, 10 bit */

 12 bit integer, 3 bit fraction */

 2 bit integer, 13 bit fraction */

 1 bit integer, 14 bit fraction */

 0 bit integer, 13 bit fraction */

 convert temperature and pressure */

 see Freescale AN3785 */

 compensated pressure with 4 fractional bits */

 temperature -5.35 C / LSB, 472 LSB is 25 C */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 - Marcin Malagowski <mrc@bourne.st>

 = 0x0666 (10% of u14) */

 = 0x3999 (90% of u14) */

 gage [kPa] */

 differential [kPa] */

 gage [psi] */

 differential [psi] */

 mbar & kPa variants */

 psi variants (1 psi ~ 6895 Pa) */

	/*

	 * bus-dependent MEASURE_REQUEST length.

	 * If no SMBUS_QUICK support, need to send dummy byte

 model-dependent values (calculated on probe) */

 to kPa */

 differential */

 mbar & kPa variants (abp060m [60 mbar] == abp006k [6 kPa]) */

    gage: */

    differential: */

 psi variants */

    gage: */

    differential: */

 empty */ },

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Freescale MPL115A2 pressure/temperature sensor

 *

 * Copyright (c) 2014 Peter Meerwald <pmeerw@pmeerw.net>

 *

 * (7-bit I2C slave address 0x60)

 *

 * Datasheet: http://www.nxp.com/files/sensors/doc/data_sheet/MPL115A2.pdf

 SPDX-License-Identifier: GPL-2.0-only

/*

 * t5403.c - Support for EPCOS T5403 pressure/temperature sensor

 *

 * Copyright (c) 2014 Peter Meerwald <pmeerw@pmeerw.net>

 *

 * (7-bit I2C slave address 0x77)

 *

 * TODO: end-of-conversion irq

 data, LSB first, 16 bit */

 10 calibration coeff., LSB first, 16 bit */

 I2C slave address, 0x77 */

 command bits */

 conversion time: 2, 8, 16, 66 ms */

 0 .. pressure, 1 .. temperature measurement */

 start conversion */

 wakeup time in ms */

 see EPCOS application note */

 see EPCOS application note */

 SPDX-License-Identifier: GPL-2.0

/*

 * MS5611 pressure and temperature sensor driver (I2C bus)

 *

 * Copyright (c) Tomasz Duszynski <tduszyns@gmail.com>

 *

 * 7-bit I2C slave addresses:

 *

 * 0x77 (CSB pin low)

 * 0x76 (CSB pin high)

 *

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Murata ZPA2326 SPI pressure and temperature sensor driver

 *

 * Copyright (c) 2016 Parrot S.A.

 *

 * Author: Gregor Boirie <gregor.boirie@parrot.com>

/*

 * read_flag_mask:

 *   - address bit 7 must be set to request a register read operation

 *   - address bit 6 must be set to request register address auto increment

	/*

	 * Enforce SPI slave settings to prevent from DT misconfiguration.

	 *

	 * Clock is idle high. Sampling happens on trailing edge, i.e., rising

	 * edge. Maximum bus frequency is 1 MHz. Registers are 8 bits wide.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * STMicroelectronics pressures driver

 *

 * Copyright 2013 STMicroelectronics Inc.

 *

 * Denis Ciocca <denis.ciocca@st.com>

/*

 * For new single-chip sensors use <device_name> as compatible string.

 * For old single-chip devices keep <device_name>-press to maintain

 * compatibility

 SPDX-License-Identifier: GPL-2.0+

 Copyright IBM Corp 2019

/*

 * The DPS310 is a barometric pressure and temperature sensor.

 * Currently only reading a single temperature is supported by

 * this driver.

 *

 * https://www.infineon.com/dgdl/?fileId=5546d462576f34750157750826c42242

 *

 * Temperature calculation:

 *   c0 * 0.5 + c1 * T_raw / kT °C

 *

 * TODO:

 *  - Optionally support the FIFO

 Make sure sleep time is <= 20ms for usleep_range */

 Silently handle error in rate value here */

/*

 * These values (defined in the spec) indicate how to scale the raw register

 * values for each level of precision available.

 Lock for sequential HW access functions */

 To be called after checking the COEF_RDY bit in MEAS_CFG */

 Read all sensor calibration coefficients from the COEF registers. */

	/*

	 * Calculate temperature calibration coefficients c0 and c1. The

	 * numbers are 12-bit 2's complement numbers.

	/*

	 * Calculate pressure calibration coefficients. c00 and c10 are 20 bit

	 * 2's complement numbers, while the rest are 16 bit 2's complement

	 * numbers.

	/*

	 * Scale factor is bottom 4 bits of the register, but 1111 is

	 * reserved so just grab bottom three

 Called with lock held */

 Called with lock held */

 Called with lock held */

 Called with lock held */

 Poll for sensor readiness; base the timeout upon the sample rate. */

 Called with lock held */

 Poll for sensor readiness; base the timeout upon the sample rate. */

 No documentation available on the registers below */

 No documentation available on this register */

 Refresh temp if it's ready, otherwise just use the latest value */

 Section 4.9.1 of the DPS310 spec; algebra'd to avoid underflow */

 Kernel lacks a div64_s64_rem function; denoms are all positive */

 Increase precision and calculate the remainder sum */

 Convert Pa to KPa per IIO ABI */

 Obtain inverse-scaled offset */

 Add the offset to the unscaled temperature */

 Convert to milliCelsius and scale the temperature */

 No documentation available on this register */

/*

 * Some verions of chip will read temperatures in the ~60C range when

 * its actually ~20C. This is the manufacturer recommended workaround

 * to correct the issue. The registers used below are undocumented.

	/*

	 * If bit 1 is set then the device is okay, and the workaround does not

	 * need to be applied

 Register to run the device reset when the device is removed */

	/*

	 * Set up pressure sensor in single sample, one measurement per second

	 * mode

	/*

	 * Set up external (MEMS) temperature sensor in single sample, one

	 * measurement per second mode

 Temp and pressure shifts are disabled when PRC <= 8 */

 MEAS_CFG doesn't update correctly unless first written with 0 */

 Turn on temperature and pressure measurement in the background */

	/*

	 * Calibration coefficients required for reporting temperature.

	 * They are available 40ms after the device has started

 SPDX-License-Identifier: GPL-2.0-only

/*

 * hp206c.c - HOPERF HP206C precision barometer and altimeter sensor

 *

 * Copyright (c) 2016, Intel Corporation.

 *

 * (7-bit I2C slave address 0x76)

 *

 * Datasheet:

 *  http://www.hoperf.com/upload/sensor/HP206C_DataSheet_EN_V2.0.pdf

 I2C commands: */

 Maximum spin for DEV_RDY */

 Data from Table 5 in datasheet. */

 Spin for max 160ms until DEV_RDY is 1, or return error. */

 Do a soft reset */

				/* 20 significant bits are provided.

				 * Extend sign over the rest.

 Do a soft reset on probe */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2016 Marek Vasut <marex@denx.de>

 *

 * Driver for Hope RF HP03 digital temperature and pressure sensor.

/*

 * The HP03 sensor occupies two fixed I2C addresses:

 *  0x50 ... read-only EEPROM with calibration data

 *  0x77 ... read-write ADC for pressure and temperature

 D1 in datasheet */

 D2 in datasheet */

 kPa */

 Deg. C */

 Wait for conversion to finish */

 Sample coefficients from EEPROM */

 Sample Temperature and Pressure */

 The Cx coefficients and Temp/Pressure values are MSB first. */

 Coefficient voodoo from the HP03 datasheet. */

 A-value */

 B-value */

	/*

	 * Allocate another device for the on-sensor EEPROM,

	 * which has it's dedicated I2C address and contains

	 * the calibration constants for the sensor.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * STMicroelectronics pressures driver

 *

 * Copyright 2013 STMicroelectronics Inc.

 *

 * Denis Ciocca <denis.ciocca@st.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Freescale MPL115A1 pressure/temperature sensor

 *

 * Copyright (c) 2016 Akinobu Mita <akinobu.mita@gmail.com>

 *

 * Datasheet: http://www.nxp.com/files/sensors/doc/data_sheet/MPL115A1.pdf

 SPDX-License-Identifier: GPL-2.0-only

/*

 * STMicroelectronics pressures driver

 *

 * Copyright 2013 STMicroelectronics Inc.

 *

 * Denis Ciocca <denis.ciocca@st.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * mpl3115.c - Support for Freescale MPL3115A2 pressure/temperature sensor

 *

 * Copyright (c) 2013 Peter Meerwald <pmeerw@pmeerw.net>

 *

 * (7-bit I2C slave address 0x60)

 *

 * TODO: FIFO buffer, altimeter mode, oversampling, continuous mode,

 * interrupts, user offset correction, raw mode

 MSB first, 20 bit */

 MSB first, 12 bit */

 software reset */

 initiate measurement */

 continuous measurement */

 64x oversampling */

 trigger measurement */

 wait for data ready, i.e. OST cleared */

 in 0.25 pascal / LSB */

 in 0.0625 celsius / LSB */

 want kilopascal */

	/*

	 * 32-bit channel + 16-bit channel + padding + ts

	 * Note that it is possible for only one of the first 2

	 * channels to be enabled. If that happens, the first element

	 * of the buffer may be either 16 or 32-bits.  As such we cannot

	 * use a simple structure definition to express this data layout.

 software reset, I2C transfer is aborted (fails) */

 SPDX-License-Identifier: GPL-2.0

/*

 * cros_ec_baro - Driver for barometer sensor behind CrosEC.

 *

 * Copyright (C) 2017 Google, Inc

/*

 * One channel for pressure, the other for timestamp.

 State data for ec_sensors iio driver. */

 Shared by all sensors */

 scale * in_pressure_raw --> kPa */

 Always roundup, so caller gets at least what it asks for. */

 Common part */

 Sensor specific */

 Timestamp */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * SRF04: ultrasonic sensor for distance measuring by using GPIOs

 *

 * Copyright (c) 2017 Andreas Klinger <ak@it-klinger.de>

 *

 * For details about the device see:

 * https://www.robot-electronics.co.uk/htm/srf04tech.htm

 *

 * the measurement cycle as timing diagram looks like:

 *

 *          +---+

 * GPIO     |   |

 * trig:  --+   +------------------------------------------------------

 *          ^   ^

 *          |<->|

 *         udelay(trigger_pulse_us)

 *

 * ultra           +-+ +-+ +-+

 * sonic           | | | | | |

 * burst: ---------+ +-+ +-+ +-----------------------------------------

 *                           .

 * ultra                     .              +-+ +-+ +-+

 * sonic                     .              | | | | | |

 * echo:  ----------------------------------+ +-+ +-+ +----------------

 *                           .                        .

 *                           +------------------------+

 * GPIO                      |                        |

 * echo:  -------------------+                        +---------------

 *                           ^                        ^

 *                           interrupt                interrupt

 *                           (ts_rising)              (ts_falling)

 *                           |<---------------------->|

 *                              pulse time measured

 *                              --> one round trip of ultra sonic waves

	/*

	 * just one read-echo-cycle can take place at a time

	 * ==> lock against concurrent reading calls

 it should not take more than 20 ms until echo is rising */

 it cannot take more than 50 ms until echo is falling */

	/*

	 * measuring more than 6,45 meters is beyond the capabilities of

	 * the supported sensors

	 * ==> filter out invalid results for not measuring echos of

	 *     another us sensor

	 *

	 * formula:

	 *         distance     6,45 * 2 m

	 * time = ---------- = ------------ = 40438871 ns

	 *          speed         319 m/s

	 *

	 * using a minimum speed at -20 °C of 319 m/s

	/*

	 * the speed as function of the temperature is approximately:

	 *

	 * speed = 331,5 + 0,6 * Temp

	 *   with Temp in °C

	 *   and speed in m/s

	 *

	 * use 343,5 m/s as ultrasonic speed at 20 °C here in absence of the

	 * temperature

	 *

	 * therefore:

	 *             time     343,5     time * 106

	 * distance = ------ * ------- = ------------

	 *             10^6         2         617176

	 *   with time in ns

	 *   and distance in mm (one way)

	 *

	 * because we limit to 6,45 meters the multiplication with 106 just

	 * fits into 32 bit

		/*

		 * theoretical maximum resolution is 3 mm

		 * 1 LSB is 1 mm

 SPDX-License-Identifier: GPL-2.0+

/*

 * mb1232.c - Support for MaxBotix I2CXL-MaxSonar-EZ series ultrasonic

 *   ranger with i2c interface

 * actually tested with mb1232 type

 *

 * Copyright (c) 2019 Andreas Klinger <ak@it-klinger.de>

 *

 * For details about the device see:

 * https://www.maxbotix.com/documents/I2CXL-MaxSonar-EZ_Datasheet.pdf

 registers of MaxSonar device */

 Command for reading range */

 Command 1 for changing address */

 Command 2 for changing address */

	/*

	 * optionally a gpio can be used to announce when ranging has

	 * finished

	 * since we are just using the falling trigger of it we request

	 * only the interrupt for announcing when data is ready to be read

 Ensure correct alignment of data to push to IIO buffer */

 it cannot take more than 100 ms */

 use simple sleep if announce irq is not connected */

 check for not returning misleading error codes */

 1 LSB is 1 cm */

 usage of interrupt is optional */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 Intel Corporation

 *

 * Driver for Semtech's SX9500 capacitive proximity/button solution.

 * Datasheet available at

 * <http://www.semtech.com/images/datasheet/sx9500.pdf>.

 Register definitions. */

 Write this to REG_RESET to do a soft reset. */

/*

 * These serve for identifying IRQ source in the IRQ_SRC register, and

 * also for masking the IRQs in the IRQ_MSK register.

	/*

	 * Last reading of the proximity status for each channel.  We

	 * only send an event to user space when this changes.

 Remember enabled channels and sample rate during suspend. */

/*

 * All allocated registers are readable, so we just list unallocated

 * ones.

 Bit is already active, nothing to do. */

 There are more users, do not deactivate. */

/*

 * If we have no interrupt support, we have to wait for a scan period

 * after enabling a channel to get a result.

	/*

	 * Even if no event is enabled, we need to wake the thread to

	 * clear the interrupt state by reading SX9500_REG_IRQ_SRC.  It

	 * is not possible to do that here because regmap_read takes a

	 * mutex.

 No change on this channel. */

 Shield enabled, small range. */

 x8 gain, 167kHz frequency, finest resolution. */

 Doze enabled, 2x scan period doze, no raw filter. */

 Average threshold. */

		/*

		 * Debouncer off, lowest average negative filter,

		 * highest average positive filter.

 Proximity detection threshold: 280 */

		/*

		 * No automatic compensation, compensate each pin

		 * independently, proximity hysteresis: 32, close

		 * debouncer off, far debouncer off.

 No stuck timeout, no periodic compensation. */

 Scan period: 30ms, all sensors disabled. */

 Activate all channels and perform an initial compensation. */

	/*

	 * Some platforms have a bug in ACPI GPIO description making IRQ

	 * GPIO to be output only. Ask the GPIO core to ignore this limit.

	/*

	 * Scan period doesn't matter because when all the sensors are

	 * deactivated the device is in sleep mode.

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0+

/*

 * as3935.c - Support for AS3935 Franklin lightning sensor

 *

 * Copyright (C) 2014, 2017-2018

 * Author: Matt Ranostay <matt.ranostay@konsulko.com>

 Ensure timestamp is naturally aligned */

 storm out of range */

	/*

	 * Delay work for >2 milliseconds after an interrupt to allow

	 * estimated distance to recalculated.

 Be sure lightning event interrupt is specified */

 sentinel */ },

 SPDX-License-Identifier: GPL-2.0

/*

 * isl29501.c: ISL29501 Time of Flight sensor driver.

 *

 * Copyright (C) 2018

 * Author: Mathieu Othacehe <m.othacehe@gmail.com>

 *

 * 7-bit I2C slave address: 0x57

 Control, setting and status registers */

 Sampling control registers */

 Closed loop calibration registers */

 Analog control registers */

 Commands */

 Ambiant light and temperature corrections */

 Data output registers */

 Exact representation of correction coefficients. */

	/*

	 * Correction coefficients are represented under

	 * mantissa * 2^exponent form, where mantissa and exponent

	 * are stored in two separate registers of the sensor.

	 *

	 * Compute and return the lowest exponent such as:

	 *	     mantissa = value / 2^exponent

	 *

	 *  where mantissa < max_mantissa.

 Store the correction coefficient under its exact form. */

		/*

		 * Find the highest exponent needed to represent

		 * correction coefficients.

		/*

		 * Represent every correction coefficient under

		 * mantissa * 2^max_exponent form and force the

		 * writing of those coefficients on the sensor.

 0.07 ms */

 0.14 ms */

 0.28 ms */

 0.57 ms */

 1.14 ms */

 2.28 ms */

 4.55 ms */

 9.11 ms */

 18.2 ms */

 36.4 ms */

 72.81 ms */

 145.28 ms */

 distance = raw_distance * 33.31 / 65536 (m) */

 phase = raw_phase * 2pi / 65536 (rad) */

 light = raw_light * 35 / 10000 (mA) */

 temperature = raw_temperature * 125 / 100000 (milli °C) */

 freq = 1 / (0.000450 * (sample_time + 1) * 10^-6) */

 sample_freq = 1 / (0.000450 * (sample_time + 1) * 10^-6) */

 1x16-bit + naturally aligned ts */

 SPDX-License-Identifier: GPL-2.0+

/*

 * pulsedlight-lidar-lite-v2.c - Support for PulsedLight LIDAR sensor

 *

 * Copyright (C) 2015, 2017-2018

 * Author: Matt Ranostay <matt.ranostay@konsulko.com>

 *

 * TODO: interrupt mode, and signal strength reporting

 Ensure timestamp is naturally aligned */

	/*

	 * Device needs a STOP condition between address write, and data read

	 * so in turn i2c_smbus_read_byte_data cannot be used

 start sample */

 return -EINVAL since laser is likely pointed out of range */

 sample ready to read */

 regulator and FPGA needs settling time */

 SPDX-License-Identifier: GPL-2.0

/*

 * Support for ST VL53L0X FlightSense ToF Ranging Sensor on a i2c bus.

 *

 * Copyright (C) 2016 STMicroelectronics Imaging Division.

 * Copyright (C) 2018 Song Qiang <songqiang1304521@gmail.com>

 * Copyright (C) 2020 Ivan Drobyshevskyi <drobyshevskyi@gmail.com>

 *

 * Datasheet available at

 * <https://www.st.com/resource/en/datasheet/vl53l0x.pdf>

 *

 * Default 7-bit i2c slave address 0x29.

 *

 * TODO: FIFO buffer, continuous mode, range selection, sensor ID check.

 Values should be between 30~1200 in millimeters. */

 usage of interrupt is optional */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2018 Google LLC.

 *

 * Driver for Semtech's SX9310/SX9311 capacitive proximity/button solution.

 * Based on SX9500 driver and Semtech driver using the input framework

 * <https://my.syncplicity.com/share/teouwsim8niiaud/

 *          linux-driver-SX9310_NoSmartHSensing>.

 * Reworked in April 2019 by Evan Green <evgreen@chromium.org>

 * and in January 2020 by Daniel Campello <campello@chromium.org>.

 Register definitions. */

 Each increment of the slope register is 0.0078125. */

 4 hardware channels, as defined in STAT0: COMB, CS2, CS1 and CS0. */

 Serialize access to registers and channel configuration */

	/*

	 * Last reading of the proximity status for each channel.

	 * We only send an event to user space when this changes.

 Ensure correct alignment of timestamp when present. */

 Remember enabled channels and sample rate during suspend. */

 CS0 */

 CS1 */

 CS2 */

 COMB */

/*

 * Each entry contains the integer part (val) and the fractional part, in micro

 * seconds. It conforms to the IIO output IIO_VAL_INT_PLUS_MICRO.

 0000: Min (no idle time) */

 0001: 15 ms */

 0010: 30 ms (Typ.) */

 0011: 45 ms */

 0100: 60 ms */

 0101: 90 ms */

 0110: 120 ms */

 0111: 200 ms */

 1000: 400 ms */

 1001: 600 ms */

 1010: 800 ms */

 1011: 1 s */

 1100: 2 s */

 1101: 3 s */

 1110: 4 s */

 1111: 5 s */

/*

 * If we have no interrupt support, we have to wait for a scan period

 * after enabling a channel to get a result.

 regval is at most 5 */

	/*

	 * Even if no event is enabled, we need to wake the thread to clear the

	 * interrupt state by reading SX9310_REG_IRQ_SRC.

	 * It is not possible to do that here because regmap_read takes a mutex.

 Read proximity state on all channels */

	/*

	 * Only iterate over channels with changes on proximity status that have

	 * events enabled.

 If the state hasn't changed, there's nothing to do. */

	/*

	 * The lower 4 bits should not be set as it enable sensors measurements.

	 * Turning the detection on before the configuration values are set to

	 * good values can cause the device to return erroneous readings.

 Activate all channels and perform an initial compensation. */

 run the compensation phase on all channels */

 Powers of 2, except for a gap between 16 and 64 */

 power-up time is ~1ms. */

 Clear reset interrupt state by reading SX9310_REG_IRQ_SRC. */

 Program some sane defaults. */

 Must wait for Tpor time after initial power up */

		/*

		 * Lots of i2c transfers in probe + over 200 ms waiting in

		 * sx9310_init_compensation() mean a slow probe; prefer async

		 * so we don't delay boot if we're builtin to the kernel.

 SPDX-License-Identifier: GPL-2.0

/*

 * Driver for cros-ec proximity sensor exposed through MKBP switch

 *

 * Copyright 2021 Google LLC.

 Unknown to start */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * rfd77402.c - Support for RF Digital RFD77402 Time-of-Flight (distance) sensor

 *

 * Copyright 2017 Peter Meerwald-Stadler <pmeerw@pmeerw.net>

 *

 * 7-bit I2C slave address 0x4c

 *

 * TODO: interrupt

 * https://media.digikey.com/pdf/Data%20Sheets/RF%20Digital%20PDFs/RFD77402.pdf

 Interrupt Control Status Register */

 magic configuration values from datasheet */

 Serialize reads from the sensor */

 1 LSB is 1 mm */

 configure INT pad as push-pull, active low */

 I2C configuration */

 set initialization */

 set initialization */

 known chip ids */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Support for Vishay VCNL3020 proximity sensor on i2c bus.

 * Based on Vishay VCNL4000 driver code.

 Command register */

 Product ID and Revision ID */

 Rate of Proximity Measurement */

 IR LED current for proximity mode */

 Proximity result register, MSB */

 Proximity result register, LSB */

 Interrupt Control Register */

 High byte of low threshold value */

 Low byte of low threshold value */

 High byte of high threshold value */

 Low byte of high threshold value */

 Interrupt Status Register */

 Proximity Modulator Timing Adjustment */

 Bit masks for COMMAND register */

 proximity data ready? */

#define VCNL_PS_OD		BIT(3) /* start on-demand proximity

					* measurement

 Enables periodic proximity measurement */

 Enables state machine and LP oscillator for self timed  measurements */

 Bit masks for ICR */

 Enable interrupts on low or high thresholds */

 Bit masks for ISR */

 High threshold hit */

 Low threshold hit */

/**

 * struct vcnl3020_data - vcnl3020 specific data.

 * @regmap:	device register map.

 * @dev:	vcnl3020 device.

 * @rev:	revision id.

 * @lock:	lock for protecting access to device hardware registers.

 * @buf:	DMA safe __be16 buffer.

/**

 * struct vcnl3020_property - vcnl3020 property.

 * @name:	property name.

 * @reg:	i2c register offset.

 * @conversion_func:	conversion function.

	/*

	 * An example of conversion from uA to reg val:

	 * 200000 uA == 200 mA == 20

 Protect against event capture. */

 wait for data to become ready */

 high & low result bytes read */

 Protect against event capture. */

 16 bit word/ low * high */

 Enable periodic measurement of proximity data. */

	/*

	 * Enable interrupts on threshold, for proximity data by

	 * default.

 Clear interrupt flag bit */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * PING: ultrasonic sensor for distance measuring by using only one GPIOs

 *

 * Copyright (c) 2019 Andreas Klinger <ak@it-klinger.de>

 *

 * For details about the devices see:

 * http://parallax.com/sites/default/files/downloads/28041-LaserPING-2m-Rangefinder-Guide.pdf

 * http://parallax.com/sites/default/files/downloads/28015-PING-Documentation-v1.6.pdf

 *

 * the measurement cycle as timing diagram looks like:

 *

 * GPIO      ___              ________________________

 * ping:  __/   \____________/                        \________________

 *          ^   ^            ^                        ^

 *          |<->|            interrupt                interrupt

 *         udelay(5)         (ts_rising)              (ts_falling)

 *                           |<---------------------->|

 *                           .  pulse time measured   .

 *                           .  --> one round trip of ultra sonic waves

 * ultra                     .                        .

 * sonic            _   _   _.                        .

 * burst: _________/ \_/ \_/ \_________________________________________

 *                                                    .

 * ultra                                              .

 * sonic                                     _   _   _.

 * echo:  __________________________________/ \_/ \_/ \________________

 length of trigger pulse */

 support error code in */

   pulse width of laser */

   ping sensors */

 timeout in ns */

 3 meters */

 2 meters plus error codes */

	/*

	 * just one read-echo-cycle can take place at a time

	 * ==> lock against concurrent reading calls

 it should not take more than 20 ms until echo is rising */

 it cannot take more than 50 ms until echo is falling */

	/*

	 * read error code of laser ping sensor and give users chance to

	 * figure out error by using dynamic debuggging

	/*

	 * the speed as function of the temperature is approximately:

	 *

	 * speed = 331,5 + 0,6 * Temp

	 *   with Temp in °C

	 *   and speed in m/s

	 *

	 * use 343,5 m/s as ultrasonic speed at 20 °C here in absence of the

	 * temperature

	 *

	 * therefore:

	 *             time     343,5     time * 232

	 * distance = ------ * ------- = ------------

	 *             10^6         2        1350800

	 *   with time in ns

	 *   and distance in mm (one way)

	 *

	 * because we limit to 3 meters the multiplication with 232 just

	 * fits into 32 bit

		/*

		 * maximum resolution in datasheet is 1 mm

		 * 1 LSB is 1 mm

 SPDX-License-Identifier: GPL-2.0-only

/*

 * srf08.c - Support for Devantech SRFxx ultrasonic ranger

 *           with i2c interface

 * actually supported are srf02, srf08, srf10

 *

 * Copyright (c) 2016, 2017 Andreas Klinger <ak@it-klinger.de>

 *

 * For details about the device see:

 * https://www.robot-electronics.co.uk/htm/srf08tech.html

 * https://www.robot-electronics.co.uk/htm/srf10tech.htm

 * https://www.robot-electronics.co.uk/htm/srf02tech.htm

 registers of SRF08 device */

 Command Register */

 Max Gain Register: 0 .. 31 */

 Range Register: 0 .. 255 */

 Software Revision */

 Light Sensor during last echo */

 Range of first echo received */

 Range of first echo received */

 Ranging Mode - Result in cm */

 default value of Range in mm */

	/*

	 * Gain in the datasheet is called sensitivity here to distinct it

	 * from the gain used with amplifiers of adc's

 max. Range in mm */

 Ensure timestamp is naturally aligned */

 Sensor-Type */

 Chip-specific information */

/*

 * in the documentation one can read about the "Gain" of the device

 * which is used here for amplifying the signal and filtering out unwanted

 * ones.

 * But with ADC's this term is already used differently and that's why it

 * is called "Sensitivity" here.

	/*

	 * we read here until a correct version number shows up as

	 * suggested by the documentation

	 *

	 * with an ultrasonic speed of 343 m/s and a roundtrip of it

	 * sleep the expected duration and try to read from the device

	 * if nothing useful is read try it in a shorter grid

	 *

	 * polling for not more than 20 ms should be enough

 check if a valid version number is read */

 1 LSB is 1 cm */

/*

 * set the range of the sensor to an even multiple of 43 mm

 * which corresponds to 1 LSB in the register

 *

 * register value    corresponding range

 *         0x00             43 mm

 *         0x01             86 mm

 *         0x02            129 mm

 *         ...

 *         0xFF          11008 mm

/*

 * srf02 don't have an adjustable range or sensitivity,

 * so we don't need attributes at all

		/*

		 * set default range of device in mm here

		 * these register values cannot be read from the hardware

		 * therefore set driver specific default values

		 *

		 * srf02 don't have a default value so it'll be omitted

		/*

		 * set default sensitivity of device here

		 * these register values cannot be read from the hardware

		 * therefore set driver specific default values

		 *

		 * srf02 don't have a default value so it'll be omitted

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Common library for ADIS16XXX devices

 *

 * Copyright 2012 Analog Devices Inc.

 *   Author: Lars-Peter Clausen <lars@metafoo.de>

/**

 * devm_adis_setup_buffer_and_trigger() - Sets up buffer and trigger for

 *					  the managed adis device

 * @adis: The adis device

 * @indio_dev: The IIO device

 * @trigger_handler: Optional trigger handler, may be NULL.

 *

 * Returns 0 on success, a negative error code otherwise.

 *

 * This function sets up the buffer and trigger for a adis devices.  If

 * 'trigger_handler' is NULL the default trigger handler will be used. The

 * default trigger handler will simply read the registers assigned to the

 * currently active channels.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ADIS16480 and similar IMUs driver

 *

 * Copyright 2012 Analog Devices Inc.

 Same address on each page */

/*

 * External clock scaling in PPS mode.

 * Available only for ADIS1649x devices

 total number of segments in burst */

 spi max speed in burst mode */

 Each filter coefficent bank spans two pages */

 ADIS16480_REG_FNCTIO_CTRL */

 Alignment needed for the timestamp */

	/*

	 * When using PPS mode, the input clock needs to be scaled so that we have an IMU

	 * sample rate between (optimally) 4000 and 4250. After this, we can use the

	 * decimation filter to lower the sampling rate in order to get what the user wants.

	 * Optimally, the user sample rate is a multiple of both the IMU sample rate and

	 * the input clock. Hence, calculating the sync_scale dynamically gives us better

	 * chances of achieving a perfect/integer value for DEC_RATE. The math here is:

	 *	1. lcm of the input clock and the desired output rate.

	 *	2. get the highest multiple of the previous result lower than the adis max rate.

	 *	3. The last result becomes the IMU sample rate. Use that to calculate SYNC_SCALE

	 *	   and DEC_RATE (to get the user output rate)

		/*

		 * If lcm is bigger than the IMU maximum sampling rate there's no perfect

		 * solution. In this case, we get the highest multiple of the input clock

		 * lower than the IMU max sample rate.

		/*

		 * This is not an hard requirement but it's not advised to run the IMU

		 * with a sample rate lower than 4000Hz due to possible undersampling

		 * issues. However, there are users that might really want to take the risk.

		 * Hence, we provide a module parameter for them. If set, we allow sample

		 * rates lower than 4KHz. By default, we won't allow this and we just roundup

		 * the rate to the next multiple of the input clock bigger than 4KHz. This

		 * is done like this as in some cases (when DEC_RATE is 0) might give

		 * us the closest value to the one desired by the user...

 0.0001 gauss */

			/*

			 * +85 degrees Celsius = temp_max_scale

			 * +25 degrees Celsius = 0

			 * LSB, 25 degrees Celsius  = 60 / temp_max_scale

			/*

			 * max scale is 1310 mbar

			 * max raw value is 32767 shifted for 32bits

 1310mbar = 131 kPa */

 Only the temperature channel has a offset */

 25 degree Celsius = 0x0000 */

		/*

		 * Typically we do IIO_RAD_TO_DEGREE in the denominator, which

		 * is exactly the same as IIO_DEGREE_TO_RAD in numerator, since

		 * it gives better approximation. However, in this case we

		 * cannot do it since it would not fit in a 32bit variable.

 5.65 milli degree Celsius */

 5.65 milli degree Celsius */

 5.65 milli degree Celsius */

 5.65 milli degree Celsius */

 14.285 milli degree Celsius */

 12.5 milli degree Celsius */

 20 elements of 16bits */

 12.5 milli degree Celsius */

 20 elements of 16bits */

 12.5 milli degree Celsius */

 20 elements of 16bits */

 12.5 milli degree Celsius */

 20 elements of 16bits */

 12.5 milli degree Celsius */

 20 elements of 16bits */

 12.5 milli degree Celsius */

 20 elements of 16bits */

	/*

	 * After making the burst request, the response can have one or two

	 * 16-bit responses containing the BURST_ID depending on the sclk. If

	 * clk > 3.6MHz, then we will have two BURST_ID in a row. If clk < 3MHZ,

	 * we have only one. To manage that variation, we use the transition from the

	 * BURST_ID to the SYS_E_FLAG register, which will not be equal to 0xA5A5. If

	 * we not find this variation in the first 4 segments, then the data should

	 * not be valid.

		/*

		 * When burst mode is used, temperature is the first data

		 * channel in the sequence, but the temperature scan index

		 * is 10.

 The lower register data is sequenced first */

 Disable data ready since the default after reset is on */

	/*

	 * Get the interrupt from the devicetre by reading the interrupt-names

	 * property. If it is not specified, use DIO1 pin as default.

	 * According to the datasheet, the factory default assigns DIO2 as data

	 * ready signal. However, in the previous versions of the driver, DIO1

	 * pin was used. So, we should leave it as is since some devices might

	 * be expecting the interrupt on the wrong physical pin.

	/*

	 * Get the interrupt line behaviour. The data ready polarity can be

	 * configured as positive or negative, corresponding to

	 * IRQ_TYPE_EDGE_RISING or IRQ_TYPE_EDGE_FALLING respectively.

 Default */

 Write the data ready configuration to the FNCTIO_CTRL register */

	/*

	 * Each DIOx pin supports only one function at a time. When a single pin

	 * has two assignments, the enable bit for a lower priority function

	 * automatically resets to zero (disabling the lower priority function).

 Only ADIS1649x devices support pps ext clock mode */

 micro */

			/*

			 * In PPS mode, the IMU sample rate is the clk_freq * sync_scale. Hence,

			 * default the IMU sample rate to the highest multiple of the input clock

			 * lower than the IMU max sample rate. The internal sample rate is the

			 * max...

 SPDX-License-Identifier: GPL-2.0+

/*

 * ADIS16460 IMU driver

 *

 * Copyright 2019 Analog Devices Inc.

 50 milli degrees Celsius/LSB */

 25 degrees Celsius = 0x0000 */

	/*

	 * storing the value in rad/degree and the scale in degree

	 * gives us the result in rad and better precession than

	 * storing the scale directly in rad.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Common library for ADIS16XXX devices

 *

 * Copyright 2012 Analog Devices Inc.

 *   Author: Lars-Peter Clausen <lars@metafoo.de>

 We cannot mask the interrupt so ensure it's not enabled at request */

	/*

	 * Typically this devices have data ready either on the rising edge or

	 * on the falling edge of the data ready pin. This checks enforces that

	 * one of those is set in the drivers... It defaults to

	 * IRQF_TRIGGER_RISING for backward compatibility with devices that

	 * don't support changing the pin polarity.

/**

 * devm_adis_probe_trigger() - Sets up trigger for a managed adis device

 * @adis: The adis device

 * @indio_dev: The IIO device

 *

 * Returns 0 on success or a negative error code

 SPDX-License-Identifier: GPL-2.0

/*

 * FXOS8700 - NXP IMU (accelerometer plus magnetometer)

 *

 * IIO core driver for FXOS8700, with support for I2C/SPI busses

 *

 * TODO: Buffer, trigger, and IRQ support

 Register Definitions */

 Bit definitions for FXOS8700_CTRL_REG1 */

 Bit definitions for FXOS8700_M_CTRL_REG1 */

 Bit definitions for FXOS8700_M_CTRL_REG2 */

 from table 6 in datasheet */

 Regmap info */

 scan indexes follow DATA register order */

 must be last */

/*

 * Accellerometer and magnetometer have the same ODR options, set in the

 * CTRL_REG1 register. ODR is halved when using both sensors at once in

 * hybrid mode.

 Magnetometer is locked at 1200uT */

 Block read 6 bytes of device output registers to avoid data loss */

 Convert axis to buffer index */

 Convert to native endianness */

		/*

		 * The device must be in standby mode to change any of the

		 * other fields within CTRL_REG1

	/*

	 * The device must be in standby mode to change any of the other fields

	 * within CTRL_REG1

 Set max oversample ratio (OSR) and both devices active */

 Disable and rst min/max measurements & threshold */

 Max ODR (800Hz individual or 400Hz hybrid), active mode */

 Set for max full-scale range (+/-8G) */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * adis16400.c	support Analog Devices ADIS16400/5

 *		3d 2g Linear Accelerometers,

 *		3d Gyroscopes,

 *		3d Magnetometers via SPI

 *

 * Copyright (c) 2009 Manuel Stahl <manuel.stahl@iis.fraunhofer.de>

 * Copyright (c) 2007 Jonathan Cameron <jic23@kernel.org>

 * Copyright (c) 2011 Analog Devices Inc.

 ms */

 ms */

 Flash memory write count */

 Power supply measurement */

 X-axis gyroscope output */

 Y-axis gyroscope output */

 Z-axis gyroscope output */

 X-axis accelerometer output */

 Y-axis accelerometer output */

 Z-axis accelerometer output */

 X-axis magnetometer measurement */

 Y-axis magnetometer measurement */

 Z-axis magnetometer measurement */

 Temperature output */

 Auxiliary ADC measurement */

 X-axis gyroscope temperature measurement */

 Y-axis gyroscope temperature measurement */

 Z-axis gyroscope temperature measurement */

 X axis inclinometer output measurement */

 Y axis inclinometer output measurement */

 Auxiliary ADC measurement */

 Barometric pressure output */

 Temperature output */

 Calibration parameters */

 X-axis gyroscope bias offset factor */

 Y-axis gyroscope bias offset factor */

 Z-axis gyroscope bias offset factor */

 X-axis acceleration bias offset factor */

 Y-axis acceleration bias offset factor */

 Z-axis acceleration bias offset factor */

 X-axis magnetometer, hard-iron factor */

 Y-axis magnetometer, hard-iron factor */

 Z-axis magnetometer, hard-iron factor */

 X-axis magnetometer, soft-iron factor */

 Y-axis magnetometer, soft-iron factor */

 Z-axis magnetometer, soft-iron factor */

 Auxiliary digital input/output control */

 Miscellaneous control */

 Internal sample period (rate) control */

 Dynamic range and digital filter control */

 Sleep mode control */

 System status */

 Alarm functions */

 System command */

 Alarm 1 amplitude threshold */

 Alarm 2 amplitude threshold */

 Alarm 1 sample size */

 Alarm 2 sample size */

 Alarm control */

 Auxiliary DAC data */

 Lot identification code 1 */

 Lot identification code 2 */

 Product identifier */

 Serial number, lot specific */

 MSC_CTRL */

 SMPL_PRD */

 DIAG_STAT */

 GLOB_CMD */

 SLP_CNT */

 set_freq() & get_freq() need to avoid using ADIS lib's state lock */

/**

 * struct adis16400_state - device instance specific data

 * @variant:	chip variant info

 * @filt_int:	integer part of requested filter frequency

 * @adis:	adis device

 * @avail_scan_mask:	NULL terminated array of bitmaps of channels

 *			that must be enabled together

/* At the moment triggers are only used for ring buffer

 * filling. This may change!

 Special case */

 Not a valid setting */

 Power down the device */

 use low spi speed for init if the device has a slow mode */

 use high spi speed if possible */

		/*

		 * Need to cache values so we can update if the frequency

		 * changes.

 Work out update to current value */

 2.418 mV */

 805.8 uV */

 0.5 mgauss */

 20 uBar = 0.002kPascal */

 currently only temperature */

 Need both the number of taps and the sampling frequency */

		/*

		 * The size here is always larger than, or equal to the true

		 * size of the channel data. This may result in a larger copy

		 * than necessary, but as the target buffer will be

		 * buffer->scan_bytes this will be safe.

 IS_ENABLED(CONFIG_IIO_BUFFER) */

 0.05 deg/s */

 0.14 C */

 25 C = 0x00 */

 0.05 deg/s */

 1 mg */

 0.06785 C */

 25 C = 0x00 */

 0.07326 deg/s */

 0.002522 g */

 0.1453 C */

 25 C = 0x00 */

 0.05 deg/s */

 3.333 mg */

 0.136 C */

 25 C = 0x00 */

 0.05 deg/s */

 0.333 mg */

 0.136 C */

 25 C = 0x00 */

 0.05 deg/s */

 1 mg */

 0.136 C */

 25 C = 0x00 */

 0.2 deg/s */

 3.333 mg */

 0.136 C */

 25 C = 0x00 */

 0.05 deg/s */

 3.333 mg */

 0.14 C */

 25 C = 0x00 */

 0.01 deg/s */

 1/4000 g */

 0.07386 C */

 31 C = 0x00 */

 0.04 deg/s */

 1/1200 g */

 0.07386 C */

 31 C = 0x00 */

 setup the industrialio driver allocated elements */

 Get the device into a sane initial state */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * KMX61 - Kionix 6-axis Accelerometer/Magnetometer

 *

 * Copyright (c) 2014, Intel Corporation.

 *

 * IIO driver for KMX61 (7-bit I2C slave address 0x0E or 0x0F).

/*

 * three 16-bit accelerometer output registers for X/Y/Z axis

 * we use only XOUT_L as a base register, all other addresses

 * can be obtained by applying an offset and are provided here

 * only for clarity.

/*

 * one 16-bit temperature output register

/*

 * three 16-bit magnetometer output registers for X/Y/Z axis

 KMX61 devices */

 serialize access to non-atomic ops, e.g set_mode */

 standby state */

 power state */

 config bits */

 accelerometer specific data */

 magnetometer specific data */

/**

 * kmx61_set_mode() - set KMX61 device operating mode

 * @data: kmx61 device private data pointer

 * @mode: bitmask, indicating operating mode for @device

 * @device: bitmask, indicating device for which @mode needs to be set

 * @update: update stby bits stored in device's private  @data

 *

 * For each sensor (accelerometer/magnetometer) there are two operating modes

 * STANDBY and OPERATION. Neither accel nor magn can be disabled independently

 * if they are both enabled. Internal sensors state is saved in acc_stby and

 * mag_stby members of driver's private @data.

 To change ODR, accel and magn must be in STDBY */

 set accel 12bit, 4g range */

	/*

	 * set output data rate for wake up (motion detection) function

	 * to match data rate for accelerometer sampling

 set acc/magn to OPERATION mode */

/**

 * kmx61_set_power_state() - set power state for kmx61 @device

 * @data: kmx61 device private pointer

 * @on: power state to be set for @device

 * @device: bitmask indicating device for which @on state needs to be set

 *

 * Notice that when ACC power state needs to be set to ON and MAG is in

 * OPERATION then we know that kmx61_runtime_resume was already called

 * so we must set ACC OPERATION mode here. The same happens when MAG power

 * state needs to be set to ON and ACC is in OPERATION.

 14 bits res, 1465 microGauss per magn count */

 SPDX-License-Identifier: GPL-2.0

/*

 * FXOS8700 - NXP IMU, SPI bits

 SPDX-License-Identifier: GPL-2.0

/*

 * FXOS8700 - NXP IMU, I2C bits

 *

 * 7-bit I2C slave address determined by SA1 and SA0 logic level

 * inputs represented in the following table:

 *      SA1  |  SA0  |  Slave Address

 *      0    |  0    |  0x1E

 *      0    |  1    |  0x1D

 *      1    |  0    |  0x1C

 *      1    |  1    |  0x1F

 SPDX-License-Identifier: GPL-2.0

/*

 * ADIS16475 IMU driver

 *

 * Copyright 2019 Analog Devices Inc.

 number of data elements in burst mode */

 spi max speed in brust mode */

 Alignment needed for the timestamp */

	/*

	 * When using sync scaled mode, the input clock needs to be scaled so that we have

	 * an IMU sample rate between (optimally) 1900 and 2100. After this, we can use the

	 * decimation filter to lower the sampling rate in order to get what the user wants.

	 * Optimally, the user sample rate is a multiple of both the IMU sample rate and

	 * the input clock. Hence, calculating the sync_scale dynamically gives us better

	 * chances of achieving a perfect/integer value for DEC_RATE. The math here is:

	 *	1. lcm of the input clock and the desired output rate.

	 *	2. get the highest multiple of the previous result lower than the adis max rate.

	 *	3. The last result becomes the IMU sample rate. Use that to calculate SYNC_SCALE

	 *	   and DEC_RATE (to get the user output rate)

		/*

		 * If lcm is bigger than the IMU maximum sampling rate there's no perfect

		 * solution. In this case, we get the highest multiple of the input clock

		 * lower than the IMU max sample rate.

		/*

		 * This is not an hard requirement but it's not advised to run the IMU

		 * with a sample rate lower than 4000Hz due to possible undersampling

		 * issues. However, there are users that might really want to take the risk.

		 * Hence, we provide a module parameter for them. If set, we allow sample

		 * rates lower than 4KHz. By default, we won't allow this and we just roundup

		 * the rate to the next multiple of the input clock bigger than 4KHz. This

		 * is done like this as in some cases (when DEC_RATE is 0) might give

		 * us the closest value to the one desired by the user...

	/*

	 * If decimation is used, then gyro and accel data will have meaningful

	 * bits on the LSB registers. This info is used on the trigger handler.

 The values are approximated. */

 Filter disabled, full BW (~720Hz) */

	/*

	 * If FIR is used, then gyro and accel data will have meaningful

	 * bits on the LSB registers. This info is used on the trigger handler.

 pulse sync not supported */

 pulse sync not supported */

 pulse sync not supported */

 pulse sync not supported */

 pulse sync not supported */

 pulse sync not supported */

 pulse sync not supported */

 extra 6 elements for low gyro and accel */

		/*

		 * In 32-bit mode we need extra 2 bytes for all gyro

		 * and accel channels.

 Remove the extra bits */

 offset until the first element after gyro and accel */

		/*

		 * When burst mode is used, system flags is the first data

		 * channel in the sequence, but the scan index is 7.

			/*

			 * The first 2 bytes on the received data are the

			 * DIAG_STAT reg, hence the +1 offset here...

 upper 16 */

 lower 16 */

				/*

				 * Don't bother in doing the manual read if the

				 * device supports burst32. burst32 will be

				 * enabled in the next call to

				 * adis16475_burst32_check()...

 lower not used */

	/*

	 * We only check the burst mode at the end of the current capture since

	 * it takes a full data ready cycle for the device to update the burst

	 * array.

 default to internal clk */

 All the other modes require external input signal */

			/*

			 * In sync scaled mode, the IMU sample rate is the clk_freq * sync_scale.

			 * Hence, default the IMU sample rate to the highest multiple of the input

			 * clock lower than the IMU max sample rate. The optimal range is

			 * 1900-2100 sps...

	/*

	 * Keep in mind that the mask for the clk modes in adis1650*

	 * chips is different (1100 instead of 11100). However, we

	 * are not configuring BIT(4) in these chips and the default

	 * value is 0, so we are fine in doing the below operations.

	 * I'm keeping this for simplicity and avoiding extra variables

	 * in chip_info.

	/*

	 * It is possible to configure the data ready polarity. Furthermore, we

	 * need to update the adis struct if we want data ready as active low.

	/*

	 * There is a delay writing to any bits written to the MSC_CTRL

	 * register. It should not be bigger than 200us, so 250 should be more

	 * than enough!

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Common library for ADIS16XXX devices

 *

 * Copyright 2012 Analog Devices Inc.

 *   Author: Lars-Peter Clausen <lars@metafoo.de>

/**

 * __adis_write_reg() - write N bytes to register (unlocked version)

 * @adis: The adis device

 * @reg: The address of the lower of the two registers

 * @value: The value to write to device (up to 4 bytes)

 * @size: The size of the @value (in bytes)

/**

 * __adis_read_reg() - read N bytes from register (unlocked version)

 * @adis: The adis device

 * @reg: The address of the lower of the two registers

 * @val: The value read back from the device

 * @size: The size of the @val buffer

/**

 * __adis_update_bits_base() - ADIS Update bits function - Unlocked version

 * @adis: The adis device

 * @reg: The address of the lower of the two registers

 * @mask: Bitmask to change

 * @val: Value to be written

 * @size: Size of the register to update

 *

 * Updates the desired bits of @reg in accordance with @mask and @val.

/**

 * adis_enable_irq() - Enable or disable data ready IRQ

 * @adis: The adis device

 * @enable: Whether to enable the IRQ

 *

 * Returns 0 on success, negative error code otherwise

/**

 * __adis_check_status() - Check the device for error conditions (unlocked)

 * @adis: The adis device

 *

 * Returns 0 on success, a negative error code otherwise

/**

 * __adis_reset() - Reset the device (unlocked version)

 * @adis: The adis device

 *

 * Returns 0 on success, a negative error code otherwise

/**

 * __adis_initial_startup() - Device initial setup

 * @adis: The adis device

 *

 * The function performs a HW reset via a reset pin that should be specified

 * via GPIOLIB. If no pin is configured a SW reset will be performed.

 * The RST pin for the ADIS devices should be configured as ACTIVE_LOW.

 *

 * After the self-test operation is performed, the function will also check

 * that the product ID is as expected. This assumes that drivers providing

 * 'prod_id_reg' will also provide the 'prod_id'.

 *

 * Returns 0 if the device is operational, a negative error code otherwise.

 *

 * This function should be called early on in the device initialization sequence

 * to ensure that the device is in a sane and known state and that it is usable.

 check if the device has rst pin low */

 bring device out of reset */

	/*

	 * don't bother calling this if we can't unmask the IRQ as in this case

	 * the IRQ is most likely not yet requested and we will request it

	 * with 'IRQF_NO_AUTOEN' anyways.

/**

 * adis_single_conversion() - Performs a single sample conversion

 * @indio_dev: The IIO device

 * @chan: The IIO channel

 * @error_mask: Mask for the error bit

 * @val: Result of the conversion

 *

 * Returns IIO_VAL_INT on success, a negative error code otherwise.

 *

 * The function performs a single conversion on a given channel and post

 * processes the value accordingly to the channel spec. If a error_mask is given

 * the function will check if the mask is set in the returned raw value. If it

 * is set the function will perform a self-check. If the device does not report

 * a error bit in the channels raw value set error_mask to 0.

/**

 * adis_init() - Initialize adis device structure

 * @adis:	The adis device

 * @indio_dev:	The iio device

 * @spi:	The spi device

 * @data:	Chip specific data

 *

 * Returns 0 on success, a negative error code otherwise.

 *

 * This function must be called, before any other adis helper function may be

 * called.

 Need to set the page before first read/write */

 Page will always be 0 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * STMicroelectronics LSM9DS0 IMU driver

 *

 * Copyright (C) 2021, Intel Corporation

 *

 * Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * STMicroelectronics LSM9DS0 IMU driver

 *

 * Copyright (C) 2021, Intel Corporation

 *

 * Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

 Regulators not mandatory, but if requested we should enable them. */

 Setup accelerometer device */

 Setup magnetometer device */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * STMicroelectronics LSM9DS0 IMU driver

 *

 * Copyright (C) 2021, Intel Corporation

 *

 * Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * BMI160 - Bosch IMU, I2C bits

 *

 * Copyright (c) 2016, Intel Corporation.

 *

 * 7-bit I2C slave address is:

 *      - 0x68 if SDO is pulled to GND

 *      - 0x69 if SDO is pulled to VDDIO

 SPDX-License-Identifier: GPL-2.0

/*

 * BMI160 - Bosch IMU, SPI bits

 *

 * Copyright (c) 2016, Intel Corporation.

 *

 SPDX-License-Identifier: GPL-2.0

/*

 * BMI160 - Bosch IMU (accel, gyro plus external magnetometer)

 *

 * Copyright (c) 2016, Intel Corporation.

 * Copyright (c) 2019, Martin Kelly.

 *

 * IIO core driver for BMI160, with support for I2C/SPI busses

 *

 * TODO: magnetometer, hardware FIFO

 X axis data low byte address, the rest can be obtained using axis offset */

 INT1 and INT2 are in the opposite order as in INT_OUT_CTRL! */

 scan indexes follow DATA register order */

 must be last */

 LSB byte register for X-axis */

	/*

	 * We need to wait after writing before we can write again. See the

	 * datasheet, page 93.

	/*

	 * Enable the requested pin with the right settings:

	 * - Push-pull/open-drain

	 * - Active low/high

	 * - Edge/level triggered

 Default is push-pull. */

 Set the pin to input mode with no latching. */

 Map interrupts to the requested pin. */

 Use INT1 if possible, otherwise fall back to INT2. */

 Level-triggered, active-low is the default if we set all zeroes. */

	/*

	 * CS rising edge is needed before starting SPI, so do a dummy read

	 * See Section 3.2.1, page 86 of the datasheet

/*

 * STMicroelectronics st_lsm6dsx i2c controller driver

 *

 * i2c controller embedded in lsm6dx series can connect up to four

 * slave devices using accelerometer sensor as trigger for i2c

 * read/write operations. Current implementation relies on SLV0 channel

 * for slave configuration and SLV{1,2,3} to read data and push them into

 * the hw FIFO

 *

 * Copyright (C) 2018 Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>

 *

 * Permission to use, copy, modify, and/or distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

 *

 LIS2MDL */

 1500 uG/LSB */

 LIS3MDL */

 4000 uG/LSB */

 8000 uG/LSB */

 12000 uG/LSB */

 16000 uG/LSB */

 set 10ms as minimum timeout for i2c slave configuration */

/*

 * st_lsm6dsx_shub_read_output - read i2c controller register

 *

 * Read st_lsm6dsx i2c controller register

/*

 * st_lsm6dsx_shub_write_reg - write i2c controller register

 *

 * Write st_lsm6dsx i2c controller register

 enable acc sensor as trigger */

/*

 * st_lsm6dsx_shub_read - read data from slave device register

 *

 * Read data from slave device register. SLV0 is used for

 * one-shot read operation

 do not overwrite aux_sens */

/*

 * st_lsm6dsx_shub_write - write data to slave device register

 *

 * Write data from slave device register. SLV0 is used for

 * one-shot write operation

 use SLV{1,2,3} for FIFO read operations */

 do not overwrite aux_sens */

 read wai slave register */

 reset SLV0 channel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * STMicroelectronics st_lsm6dsx sensor driver

 *

 * The ST LSM6DSx IMU MEMS series consists of 3D digital accelerometer

 * and 3D digital gyroscope system-in-package with a digital I2C/SPI serial

 * interface standard output.

 * LSM6DSx IMU MEMS series has a dynamic user-selectable full-scale

 * acceleration range of +-2/+-4/+-8/+-16 g and an angular rate range of

 * +-125/+-245/+-500/+-1000/+-2000 dps

 * LSM6DSx series has an integrated First-In-First-Out (FIFO) buffer

 * allowing dynamic batching of sensor data.

 * LSM9DSx series is similar but includes an additional magnetometer, handled

 * by a different driver.

 *

 * Supported sensors:

 * - LSM6DS3:

 *   - Accelerometer/Gyroscope supported ODR [Hz]: 12.5, 26, 52, 104, 208, 416

 *   - Accelerometer supported full-scale [g]: +-2/+-4/+-8/+-16

 *   - Gyroscope supported full-scale [dps]: +-125/+-245/+-500/+-1000/+-2000

 *   - FIFO size: 8KB

 *

 * - LSM6DS3H/LSM6DSL/LSM6DSM/ISM330DLC/LSM6DS3TR-C:

 *   - Accelerometer/Gyroscope supported ODR [Hz]: 12.5, 26, 52, 104, 208, 416

 *   - Accelerometer supported full-scale [g]: +-2/+-4/+-8/+-16

 *   - Gyroscope supported full-scale [dps]: +-125/+-245/+-500/+-1000/+-2000

 *   - FIFO size: 4KB

 *

 * - LSM6DSO/LSM6DSOX/ASM330LHH/LSM6DSR/ISM330DHCX/LSM6DST/LSM6DSOP:

 *   - Accelerometer/Gyroscope supported ODR [Hz]: 12.5, 26, 52, 104, 208, 416,

 *     833

 *   - Accelerometer supported full-scale [g]: +-2/+-4/+-8/+-16

 *   - Gyroscope supported full-scale [dps]: +-125/+-245/+-500/+-1000/+-2000

 *   - FIFO size: 3KB

 *

 * - LSM9DS1/LSM6DS0:

 *   - Accelerometer supported ODR [Hz]: 10, 50, 119, 238, 476, 952

 *   - Accelerometer supported full-scale [g]: +-2/+-4/+-8/+-16

 *   - Gyroscope supported ODR [Hz]: 15, 60, 119, 238, 476, 952

 *   - Gyroscope supported full-scale [dps]: +-245/+-500/+-2000

 *   - FIFO size: 32

 *

 * Copyright 2016 STMicroelectronics Inc.

 *

 * Lorenzo Bianconi <lorenzo.bianconi@st.com>

 * Denis Ciocca <denis.ciocca@st.com>

 25us */

 1LSB = 2B */

 1LSB = 2B */

 1LSB = 2B */

		/*

		 * ext devices can run at different odr respect to

		 * accel sensor

		/*

		 * i2c embedded controller relies on the accelerometer sensor as

		 * bus read/write trigger so we need to enable accel device

		 * at odr = max(accel_odr, ext_odr) in order to properly

		 * communicate with i2c slave devices

 device already configured */

 should never occur */

 Enable wakeup interrupt */

 do not enable events if they are already enabled */

 only turn off sensor if no events is enabled */

 stop here if no changes have been made */

 configure aux sensors */

 enable hw timestamp generation if necessary */

 enable high resolution for hw ts timer if necessary */

 enable ts queueing in FIFO if necessary */

 calibrate timestamp sensitivity */

		/*

		 * linearize the AN5192 formula:

		 * 1 / (1 + x) ~= 1 - x (Taylor’s Series)

		 * ttrim[s] = 1 / (40000 * (1 + 0.0015 * val))

		 * ttrim[ns] ~= 25000 - 37.5 * val

		 * ttrim[ns] ~= 25000 - (37500 * val) / 1000

	/*

	 * flush hw FIFO before device reset in order to avoid

	 * possible races on interrupt line 1. If the first interrupt

	 * line is asserted during hw reset the device will work in

	 * I3C-only mode (if it is supported)

 device sw reset */

 reload trimming parameter */

 enable Block Data Update */

 enable FIFO watermak interrupt */

 enable Latched interrupts for device events */

 enable clear on read for latched interrupts */

 enable drdy-mas if available */

	/*

	 * If we are using edge IRQs, new samples can arrive while

	 * processing current interrupt since there are no hw

	 * guarantees the irq line stays "low" long enough to properly

	 * detect the new interrupt. In this case the new sample will

	 * be missed.

	 * Polling FIFO status register allow us to read new

	 * samples even if the interrupt arrives while processing

	 * previous data and the timeslot where the line is "low" is

	 * too short to be properly detected.

 vdd-vddio power regulators */

 Enable wake from IRQ */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * STMicroelectronics st_lsm6dsx spi driver

 *

 * Copyright 2016 STMicroelectronics Inc.

 *

 * Lorenzo Bianconi <lorenzo.bianconi@st.com>

 * Denis Ciocca <denis.ciocca@st.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018 Synopsys, Inc. and/or its affiliates.

 *

 * Author: Vitor Soares <vitor.soares@synopsys.com>

 sentinel */ },

 SPDX-License-Identifier: GPL-2.0-only

/*

 * STMicroelectronics st_lsm6dsx FIFO buffer library driver

 *

 * LSM6DS3/LSM6DS3H/LSM6DSL/LSM6DSM/ISM330DLC/LSM6DS3TR-C:

 * The FIFO buffer can be configured to store data from gyroscope and

 * accelerometer. Samples are queued without any tag according to a

 * specific pattern based on 'FIFO data sets' (6 bytes each):

 *  - 1st data set is reserved for gyroscope data

 *  - 2nd data set is reserved for accelerometer data

 * The FIFO pattern changes depending on the ODRs and decimation factors

 * assigned to the FIFO data sets. The first sequence of data stored in FIFO

 * buffer contains the data of all the enabled FIFO data sets

 * (e.g. Gx, Gy, Gz, Ax, Ay, Az), then data are repeated depending on the

 * value of the decimation factor and ODR set for each FIFO data set.

 *

 * LSM6DSO/LSM6DSOX/ASM330LHH/LSM6DSR/LSM6DSRX/ISM330DHCX/LSM6DST/LSM6DSOP:

 * The FIFO buffer can be configured to store data from gyroscope and

 * accelerometer. Each sample is queued with a tag (1B) indicating data

 * source (gyroscope, accelerometer, hw timer).

 *

 * FIFO supported modes:

 *  - BYPASS: FIFO disabled

 *  - CONTINUOUS: FIFO enabled. When the buffer is full, the FIFO index

 *    restarts from the beginning and the oldest sample is overwritten

 *

 * Copyright 2016 STMicroelectronics Inc.

 *

 * Lorenzo Bianconi <lorenzo.bianconi@st.com>

 * Denis Ciocca <denis.ciocca@st.com>

 update fifo decimators and sample in pattern */

	/*

	 * update hw ts decimator if necessary. Decimator for hw timestamp

	 * is always 1 or 0 in order to have a ts sample for each data

	 * sample in FIFO

 reset hw ts counter */

		/*

		 * store enable buffer timestamp as reference for

		 * hw timestamp

 reset hw ts counter */

/*

 * Set max bulk read to ST_LSM6DSX_MAX_WORD_LEN/ST_LSM6DSX_MAX_TAGGED_WORD_LEN

 * in order to avoid a kmalloc for each bus access

/**

 * st_lsm6dsx_read_fifo() - hw FIFO read routine

 * @hw: Pointer to instance of struct st_lsm6dsx_hw.

 *

 * Read samples from the hw FIFO and push them to IIO buffers.

 *

 * Return: Number of bytes read from the FIFO

		/*

		 * Data are written to the FIFO with a specific pattern

		 * depending on the configured ODRs. The first sequence of data

		 * stored in FIFO contains the data of all enabled sensors

		 * (e.g. Gx, Gy, Gz, Ax, Ay, Az, Ts), then data are repeated

		 * depending on the value of the decimation factor set for each

		 * sensor.

		 *

		 * Supposing the FIFO is storing data from gyroscope and

		 * accelerometer at different ODRs:

		 *   - gyroscope ODR = 208Hz, accelerometer ODR = 104Hz

		 * Since the gyroscope ODR is twice the accelerometer one, the

		 * following pattern is repeated every 9 samples:

		 *   - Gx, Gy, Gz, Ax, Ay, Az, Ts, Gx, Gy, Gz, Ts, Gx, ..

				/*

				 * hw timestamp is 3B long and it is stored

				 * in FIFO using 6B as 4th FIFO data set

				 * according to this schema:

				 * B0 = ts[15:8], B1 = ts[23:16], B3 = ts[7:0]

				/*

				 * check if hw timestamp engine is going to

				 * reset (the sensor generates an interrupt

				 * to signal the hw timestamp will reset in

				 * 1.638s)

 invalid sample during bootstrap phase */

	/*

	 * EXT_TAG are managed in FIFO fashion so ST_LSM6DSX_EXT0_TAG

	 * corresponds to the first enabled channel, ST_LSM6DSX_EXT1_TAG

	 * to the second one and ST_LSM6DSX_EXT2_TAG to the last enabled

	 * channel

/**

 * st_lsm6dsx_read_tagged_fifo() - tagged hw FIFO read routine

 * @hw: Pointer to instance of struct st_lsm6dsx_hw.

 *

 * Read samples from the hw FIFO and push them to IIO buffers.

 *

 * Return: Number of bytes read from the FIFO

	/*

	 * Alignment needed as this can ultimately be passed to a

	 * call to iio_push_to_buffers_with_timestamp() which

	 * must be passed a buffer that is aligned to 8 bytes so

	 * as to allow insertion of a naturally aligned timestamp.

				/*

				 * hw timestamp is 4B long and it is stored

				 * in FIFO according to this schema:

				 * B0 = ts[7:0], B1 = ts[15:8], B2 = ts[23:16],

				 * B3 = ts[31:24]

				/*

				 * check if hw timestamp engine is going to

				 * reset (the sensor generates an interrupt

				 * to signal the hw timestamp will reset in

				 * 1.638s)

 SPDX-License-Identifier: GPL-2.0-only

/*

 * STMicroelectronics st_lsm6dsx i2c driver

 *

 * Copyright 2016 STMicroelectronics Inc.

 *

 * Lorenzo Bianconi <lorenzo.bianconi@st.com>

 * Denis Ciocca <denis.ciocca@st.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

* Copyright (C) 2012 Invensense, Inc.

/**

 *  inv_mpu6050_update_period() - Update chip internal period estimation

 *

 *  @st:		driver state

 *  @timestamp:		the interrupt timestamp

 *  @nb:		number of data set in the fifo

 *

 *  This function uses interrupt timestamps to estimate the chip period and

 *  to choose the data timestamp to come.

 Period boundaries for accepting timestamp */

 not initialized, forced to use it_timestamp */

		/*

		 * Validate the use of it timestamp by checking if interrupt

		 * has been delayed.

		 * nb > 1 means interrupt was delayed for more than 1 sample,

		 * so it's obviously not good.

		 * Compute the chip period between 2 interrupts for validating.

 update chip period and use it timestamp */

		/*

		 * Manage case of multiple samples in the fifo (nb > 1):

		 * compute timestamp corresponding to the first sample using

		 * estimated chip period.

 save it timestamp */

/**

 *  inv_mpu6050_get_timestamp() - Return the current data timestamp

 *

 *  @st:		driver state

 *  @return:		current data timestamp

 *

 *  This function returns the current data timestamp and prepares for next one.

 return current data timestamp and increment */

 disable fifo and reenable it */

/*

 * inv_mpu6050_read_fifo() - Transfer data from hardware FIFO to KFIFO.

 ack interrupt and check status */

	/*

	 * read fifo_count register to know how many bytes are inside the FIFO

	 * right now

	/*

	 * Handle fifo overflow by resetting fifo.

	 * Reset if there is only 3 data set free remaining to mitigate

	 * possible delay between reading fifo count and fifo data.

 compute and process all complete datum */

 skip first samples if needed */

 Flush HW and SW FIFOs. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019 TDK-InvenSense, Inc.

/*

 * MPU9xxx magnetometer are AKM chips on I2C aux bus

 * MPU9150 is AK8975

 * MPU9250 is AK8963

 init magnetometer chip */

 check whoami */

 software reset for MPU925x only */

 read fuse ROM data */

 switch back to power-down */

	/*

	 * Sensor sentivity

	 * 1 uT = 0.01 G and value is in micron (1e6)

	 * sensitvity = x uT * 0.01 * 1e6

 sensor sensitivity is 0.3 uT */

 sensor sensitivity in 16 bits mode: 0.15 uT */

	/*

	 * Sensitivity adjustement and scale to Gauss

	 *

	 * Hadj = H * (((ASA - 128) * 0.5 / 128) + 1)

	 * Factor simplification:

	 * Hadj = H * ((ASA + 128) / 256)

	 *

	 * raw_to_gauss = Hadj * sensitivity

/**

 * inv_mpu_magn_probe() - probe and setup magnetometer chip

 * @st: driver internal state

 *

 * Returns 0 on success, a negative error code otherwise

 *

 * It is probing the chip and setting up all needed i2c transfers.

 * Noop if there is no magnetometer in the chip.

 quit if chip is not supported */

 configure i2c master aux port */

 check and init mag chip */

	/*

	 * configure mpu i2c master accesses

	 * i2c SLV0: read sensor data, 7 bytes data(6)-ST2

	 * Byte swap data to store them in big-endian in impair address groups

 i2c SLV1: launch single measurement */

 add 16 bits mode for MPU925x */

/**

 * inv_mpu_magn_set_rate() - set magnetometer sampling rate

 * @st: driver internal state

 * @fifo_rate: mpu set fifo rate

 *

 * Returns 0 on success, a negative error code otherwise

 *

 * Limit sampling frequency to the maximum value supported by the

 * magnetometer chip. Resulting in duplicated data for higher frequencies.

 * Noop if there is no magnetometer in the chip.

 quit if chip is not supported */

	/*

	 * update i2c master delay to limit mag sampling to max frequency

	 * compute fifo_rate divider d: rate = fifo_rate / (d + 1)

/**

 * inv_mpu_magn_set_orient() - fill magnetometer mounting matrix

 * @st: driver internal state

 *

 * Returns 0 on success, a negative error code otherwise

 *

 * Fill magnetometer mounting matrix using the provided chip matrix.

 fill magnetometer orientation */

 x <- y */

 y <- x */

 z <- -z */

			/*

			 * The value is negated according to one of the following

			 * rules:

			 *

			 * 1) Drop leading minus.

			 * 2) Leave 0 as is.

			 * 3) Add leading minus.

/**

 * inv_mpu_magn_read() - read magnetometer data

 * @st: driver internal state

 * @axis: IIO modifier axis value

 * @val: store corresponding axis value

 *

 * Returns 0 on success, a negative error code otherwise

 quit if chip is not supported */

 Mag data: XH,XL,YH,YL,ZH,ZL */

 check i2c status and read raw data */

 SPDX-License-Identifier: GPL-2.0-only

/*

* Copyright (C) 2015 Intel Corporation Inc.

/*

 * device id table is used to identify what device can be

 * supported by this driver

 SPDX-License-Identifier: GPL-2.0-only

/*

 * inv_mpu_acpi: ACPI processing for creating client devices

 * Copyright (c) 2015, Intel Corporation.

 Add more matching tables here..*/

 Not a MPU6500 primary */

 Tell the ACPI core that we already copied this address */

 Add more matched product processing here */

 No matching DMI, so create device on INV6XX type */

 no secondary addr, which is OK */

 SPDX-License-Identifier: GPL-2.0-only

/*

* Copyright (C) 2012 Invensense, Inc.

 no i2c auxiliary bus on the chip */

	/*

	 * MPU9xxx magnetometer support requires to disable i2c auxiliary bus.

	 * To ensure backward compatibility with existing setups, do not disable

	 * i2c auxiliary bus if it used.

	 * Check for i2c-gate node in devicetree and set magnetometer disabled.

	 * Only MPU6500 is supported by ACPI, no need to check.

 enable i2c bypass when using i2c auxiliary bus */

/**

 *  inv_mpu_probe() - probe function.

 *  @client:          i2c client.

 *  @id:              i2c device id.

 *

 *  Returns 0 on success, a negative error code otherwise.

 declare i2c auxiliary bus */

/*

 * device id table is used to identify what device can be

 * supported by this driver

 SPDX-License-Identifier: GPL-2.0-only

/*

* Copyright (C) 2012 Invensense, Inc.

/*

 * this is the gyro scale translated from dynamic range plus/minus

 * {250, 500, 1000, 2000} to rad/s

/*

 * this is the accel scale translated from dynamic range plus/minus

 * {2, 4, 8, 16} to m/s^2

 Indexed by enum inv_devices */

 old chips: switch clock manually */

 automatic clock switching, nothing to do */

 delete useless requests */

 turn on/off temperature sensor */

 update user_crtl for driving magnetometer */

 manage accel & gyro engines */

 compute power management 2 current value */

 update to new requested value */

 switch clock to internal when turning gyro off */

 update sensors engine */

 compute required time to have sensors stabilized */

 switch clock to PLL when turning gyro on */

/*

 *  inv_mpu6050_set_lpf_regs() - set low pass filter registers, chip dependent

 *

 *  MPU60xx/MPU9150 use only 1 register for accelerometer + gyroscope

 *  MPU6500 and above have a dedicated register for accelerometer

 set accel lpf */

 old chips, nothing to do */

 set FIFO size to maximum value */

/*

 *  inv_mpu6050_init_config() - Initialize hardware, disable FIFO.

 *

 *  Initial configuration:

 *  FSR: ± 2000DPS

 *  DLPF: 20Hz

 *  FIFO rate: 50Hz

 *  Clock source: Gyro PLL

	/*

	 * Internal chip period is 1ms (1kHz).

	 * Let's use at the beginning the theorical value before measuring

	 * with interrupt timestamps.

 magn chip init, noop if not present in the chip */

 compute sample period */

 need to wait 2 periods to have first valid sample */

 wait 1 period for first sample availability */

 temperature sensor work only with accel and/or gyro */

 wait 1 period for first sample availability */

 frequency is limited for magnetometer */

 need to wait 2 periods to have first valid sample */

	/*

	 * we should only update scale when the chip is disabled, i.e.

	 * not running

/*

 *  inv_mpu6050_set_lpf() - set low pass filer based on fifo rate.

 *

 *                  Based on the Nyquist principle, the bandwidth of the low

 *                  pass filter must not exceed the signal sampling rate divided

 *                  by 2, or there would be aliasing.

 *                  This function basically search for the correct low pass

 *                  parameters based on the fifo rate, e.g, sampling frequency.

 *

 *  lpf is set automatically when setting sampling rate to avoid any aliases.

/*

 * inv_mpu6050_fifo_rate_store() - Set fifo rate.

 compute the chip sample rate divider */

 compute back the fifo rate to handle truncation cases */

 update rate for magn, noop if not present in chip */

/*

 * inv_fifo_rate_show() - Get the current sampling rate.

/*

 * inv_attr_show() - calling this function will show current

 *                    parameters.

 *

 * Deprecated in favor of IIO mounting matrix API.

 *

 * See inv_get_mount_matrix()

	/*

	 * In MPU6050, the two matrix are the same because gyro and accel

	 * are integrated in one chip

/**

 * inv_mpu6050_validate_trigger() - validate_trigger callback for invensense

 *                                  MPU6050 device.

 * @indio_dev: The IIO device

 * @trig: The new trigger

 *

 * Returns: 0 if the 'trig' matches the trigger registered by the MPU6050

 * device, -EINVAL otherwise.

 3-axis accel */

 3-axis gyro */

 6-axis accel + gyro */

 Magnetometer resolution is 13 bits */

 Magnetometer resolution is 16 bits */

 3-axis accel */

 3-axis gyro */

 3-axis magn */

 6-axis accel + gyro */

 6-axis accel + magn */

 6-axis gyro + magn */

 9-axis accel + gyro + magn */

 3-axis accel + temp (mandatory) */

 3-axis gyro + temp (mandatory) */

 6-axis accel + gyro + temp (mandatory) */

/*

 * The user can choose any frequency between INV_MPU6050_MIN_FIFO_RATE and

 * INV_MPU6050_MAX_FIFO_RATE, but only these frequencies are matched by the

 * low-pass filter. Specifically, each of these sampling rates are about twice

 * the bandwidth of a corresponding low-pass filter, which should eliminate

 * aliasing following the Nyquist principle. By picking a frequency different

 * from these, the user risks aliasing effects.

 Deprecated: kept for userspace backward compatibility. */

 deprecated */

 deprecated */

/*

 *  inv_check_and_setup_chip() - check and setup chip.

 check chip self-identification */

 check whoami against all possible values */

 reset to make sure previous state are not there */

 reset signal path (required for spi connection) */

	/*

	 * Turn power on. After reset, the sleep bit could be on

	 * or off depending on the OTP settings. Turning power on

	 * make it in a definite state as well as making the hardware

	 * state align with the software state

 Give the device a little bit of time to start up. */

 Doesn't really matter, use the default */

 rising or both-edge

 fill magnetometer orientation */

 power is turned on inside check chip type*/

 name will be NULL when enumerated via ACPI */

 requires parent device set in indio_dev */

 chip init is done, turning on runtime power management */

	/*

	 * Use magnetometer inside the chip only if there is no i2c

	 * auxiliary device in use. Otherwise Going back to 6-axis only.

		/*

		 * The driver currently only supports buffered capture with its

		 * own trigger. So no IRQ, no trigger, no buffer

 SPDX-License-Identifier: GPL-2.0-only

/*

* Copyright (C) 2012 Invensense, Inc.

	/*

	 * If the MPU6050 is just used as a trigger, then the scan mask

	 * is not allocated so we simply enable the temperature channel

	 * as a dummy and bail out.

 no magnetometer if i2c auxiliary bus is used */

 mag first sample is always not ready, skip it */

 reset FIFO */

 enable sensor output to FIFO */

 enable FIFO reading */

 enable interrupt */

 restore user_ctrl for disabling FIFO reading */

/**

 *  inv_mpu6050_set_enable() - enable chip functions.

 *  @indio_dev:	Device driver instance.

 *  @enable: enable/disable

		/*

		 * In case autosuspend didn't trigger, turn off first not

		 * required sensors.

/**

 * inv_mpu_data_rdy_trigger_set_state() - set data ready interrupt state

 * @trig: Trigger instance

 * @state: Desired trigger state

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019 TDK-InvenSense, Inc.

/*

 * i2c master auxiliary bus transfer function.

 * Requires the i2c operations to be correctly setup before.

 use 50hz frequency for xfer */

 set sample rate */

 start i2c master */

 wait for xfer: 1 period + half-period margin */

 stop i2c master */

 restore sample rate */

/**

 * inv_mpu_aux_init() - init i2c auxiliary bus

 * @st: driver internal state

 *

 * Returns 0 on success, a negative error code otherwise.

 configure i2c master */

 configure i2c master delay */

/**

 * inv_mpu_aux_read() - read register function for i2c auxiliary bus

 * @st: driver internal state.

 * @addr: chip i2c Address

 * @reg: chip register address

 * @val: buffer for storing read bytes

 * @size: number of bytes to read

 *

 *  Returns 0 on success, a negative error code otherwise.

 setup i2c SLV0 control: i2c addr, register, enable + size */

 do i2c xfer */

 disable i2c slave */

 check i2c status */

 read data in registers */

/**

 * inv_mpu_aux_write() - write register function for i2c auxiliary bus

 * @st: driver internal state.

 * @addr: chip i2c Address

 * @reg: chip register address

 * @val: 1 byte value to write

 *

 *  Returns 0 on success, a negative error code otherwise.

 setup i2c SLV0 control: i2c addr, register, value, enable + size */

 do i2c xfer */

 disable i2c slave */

 check i2c status */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2020 Invensense, Inc.

 internal chip period is 32kHz, 31250ns */

 allow a jitter of +/- 2% */

 compute min and max periods accepted */

 Add a new value inside an accumulator and update the estimate value */

 compute the mean of all stored values, use 0 as empty slot */

 initial odr for sensor after reset is 1kHz */

 current multiplier and period values after reset */

 new set multiplier is the one from chip initialization */

 use theoretical value for chip period */

 enable timestamp register */

 when FIFO is on, prevent odr change if one is already pending */

 check that period is acceptable */

 update chip internal period estimation */

 update interrupt timestamp and compute chip and sensor periods */

 compute period: delta time divided by number of samples */

 update sensor period if chip internal period is updated */

 no previous data, compute theoritical value from interrupt */

 elapsed time: sensor period * sensor samples number */

 if interrupt interval is valid, sync with interrupt timestamp */

 compute measured fifo_period */

 delta time between last sample and last interrupt */

 if there are multiple samples, go back to first one */

 compute maximal adjustment value */

 update to new multiplier and update period */

	/*

	 * After ODR change the time interval with the previous sample is

	 * undertermined (depends when the change occures). So we compute the

	 * timestamp from the current interrupt using the new FIFO period, the

	 * total number of samples and the current sample numero.

 compute measured fifo period */

 computes time interval between interrupt and this sample */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2020 InvenSense, Inc.

 setup interface registers */

 set slew rates for I2C and SPI */

 disable SPI bus */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2020 Invensense, Inc.

/*

 * IIO buffer data: size must be a power of 2 and timestamp aligned

 * 16 bytes: 6 bytes acceleration, 2 bytes temperature, 8 bytes timestamp

 3-axis accel + temperature */

 enable accelerometer sensor and FIFO write */

 enable temp sensor */

 enable accel sensor */

 update data FIFO write */

 sleep maximum required time */

 enable accel sensor */

 read accel register data */

 IIO format int + nano */

 +/- 16G => 0.004788403 m/s-2 */

 +/- 8G => 0.002394202 m/s-2 */

 +/- 4G => 0.001197101 m/s-2 */

 +/- 2G => 0.000598550 m/s-2 */

 IIO format int + micro */

 12.5Hz */

 25Hz */

 50Hz */

 100Hz */

 200Hz */

 1kHz */

 2kHz */

 4kHz */

/*

 * Calibration bias values, IIO range format int + micro.

 * Value is limited to +/-1g coded on 12 bits signed. Step is 0.5mg.

 min: -10.042010 m/s² */

 step: 0.004903 m/s² */

 max: 10.037106 m/s² */

 12 bits signed value */

	/*

	 * convert raw offset to g then to m/s²

	 * 12 bits signed raw step 0.5mg to g: 5 / 10000

	 * g to m/s²: 9.806650

	 * result in micro (1000000)

	 * (offset * 5 * 9.806650 * 1000000) / 10000

 for rounding, add + or - divisor (10000) divided by 2 */

 inv_icm42600_accel_calibbias: min - step - max in micro */

	/*

	 * convert m/s² to g then to raw value

	 * m/s² to g: 1 / 9.806650

	 * g to raw 12 bits signed, step 0.5mg: 10000 / 5

	 * val in micro (1000000)

	 * val * 10000 / (9.806650 * 1000000 * 5)

 for rounding, add + or - divisor (9806650 * 5) divided by 2 */

 clamp value limited to 12 bits signed */

 OFFSET_USER4 register is shared */

 OFFSET_USER7 register is shared */

 OFFSET_USER7 register is shared */

 parse all fifo packets */

 quit if error or FIFO is empty */

 skip packet if no accel data or data is invalid */

 update odr */

 buffer is copied to userspace, zeroing it to avoid any data leak */

 convert 8 bits FIFO temperature in high resolution format */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2020 Invensense, Inc.

/*

 * IIO buffer data: size must be a power of 2 and timestamp aligned

 * 16 bytes: 6 bytes angular velocity, 2 bytes temperature, 8 bytes timestamp

 3-axis gyro + temperature */

 enable gyroscope sensor and FIFO write */

 enable temp sensor */

 enable gyro sensor */

 update data FIFO write */

 sleep maximum required time */

 enable gyro sensor */

 read gyro register data */

 IIO format int + nano */

 +/- 2000dps => 0.001065264 rad/s */

 +/- 1000dps => 0.000532632 rad/s */

 +/- 500dps => 0.000266316 rad/s */

 +/- 250dps => 0.000133158 rad/s */

 +/- 125dps => 0.000066579 rad/s */

 +/- 62.5dps => 0.000033290 rad/s */

 +/- 31.25dps => 0.000016645 rad/s */

 +/- 15.625dps => 0.000008322 rad/s */

 IIO format int + micro */

 12.5Hz */

 25Hz */

 50Hz */

 100Hz */

 200Hz */

 1kHz */

 2kHz */

 4kHz */

/*

 * Calibration bias values, IIO range format int + nano.

 * Value is limited to +/-64dps coded on 12 bits signed. Step is 1/32 dps.

 min: -1.117010721 rad/s */

 step: 0.000545415 rad/s */

 max: 1.116465306 rad/s */

 12 bits signed value */

	/*

	 * convert raw offset to dps then to rad/s

	 * 12 bits signed raw max 64 to dps: 64 / 2048

	 * dps to rad: Pi / 180

	 * result in nano (1000000000)

	 * (offset * 64 * Pi * 1000000000) / (2048 * 180)

 for rounding, add + or - divisor (2048 * 180) divided by 2 */

 inv_icm42600_gyro_calibbias: min - step - max in nano */

	/*

	 * convert rad/s to dps then to raw value

	 * rad to dps: 180 / Pi

	 * dps to raw 12 bits signed, max 64: 2048 / 64

	 * val in nano (1000000000)

	 * val * 180 * 2048 / (Pi * 1000000000 * 64)

 for rounding, add + or - divisor (3141592653 * 64) divided by 2 */

 clamp value limited to 12 bits signed */

 OFFSET_USER1 register is shared */

 OFFSET_USER1 register is shared */

 OFFSET_USER4 register is shared */

 parse all fifo packets */

 quit if error or FIFO is empty */

 skip packet if no gyro data or data is invalid */

 update odr */

 buffer is copied to userspace, zeroing it to avoid any data leak */

 convert 8 bits FIFO temperature in high resolution format */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2020 Invensense, Inc.

 FIFO header: 1 byte */

 FIFO empty */

 handle odr flags */

 accel + gyro */

 accel only */

 gyro only */

 invalid packet if here */

 update only FIFO EN bits */

/**

 * inv_icm42600_buffer_update_watermark - update watermark FIFO threshold

 * @st:	driver internal state

 *

 * Returns 0 on success, a negative error code otherwise.

 *

 * FIFO watermark threshold is computed based on the required watermark values

 * set for gyro and accel sensors. Since watermark is all about acceptable data

 * latency, use the smallest setting between the 2. It means choosing the

 * smallest latency but this is not as simple as choosing the smallest watermark

 * value. Latency depends on watermark and ODR. It requires several steps:

 * 1) compute gyro and accel latencies and choose the smallest value.

 * 2) adapt the choosen latency so that it is a multiple of both gyro and accel

 *    ones. Otherwise it is possible that you don't meet a requirement. (for

 *    example with gyro @100Hz wm 4 and accel @100Hz with wm 6, choosing the

 *    value of 4 will not meet accel latency requirement because 6 is not a

 *    multiple of 4. You need to use the value 2.)

 * 3) Since all periods are multiple of each others, watermark is computed by

 *    dividing this computed latency by the smallest period, which corresponds

 *    to the FIFO frequency. Beware that this is only true because we are not

 *    using 500Hz frequency which is not a multiple of the others.

 compute sensors latency, depending on sensor watermark and odr */

 use us for odr to avoid overflow using 32 bits values */

 0 value for watermark means that the sensor is turned off */

 compute the smallest latency that is a multiple of both */

 use the shortest period */

 all this works because periods are multiple of each others */

 compute watermark value in bytes */

 changing FIFO watermark requires to turn off watermark interrupt */

 restore watermark interrupt */

/*

 * update_scan_mode callback is turning sensors on and setting data FIFO enable

 * bits.

 exit if FIFO is already on */

 set FIFO threshold interrupt */

 flush FIFO data */

 set FIFO in streaming mode */

 workaround: first read of FIFO count after reset is always 0 */

 increase FIFO on counter */

 exit if there are several sensors using the FIFO */

 set FIFO in bypass mode */

 flush FIFO data */

 disable FIFO threshold interrupt */

 decrease FIFO on counter */

 if FIFO is off, turn temperature off */

 sleep maximum required time */

 reset all samples counters */

 compute maximum FIFO read size */

 read FIFO count value */

 check and clamp FIFO count value */

 read all FIFO data in internal buffer */

 compute number of samples for each sensor */

 handle gyroscope timestamp and FIFO data parsing */

 handle accelerometer timestamp and FIFO data parsing */

	/*

	 * Default FIFO configuration (bits 7 to 5)

	 * - use invalid value

	 * - FIFO count in bytes

	 * - FIFO count in big endian

	/*

	 * Enable FIFO partial read and continuous watermark interrupt.

	 * Disable all FIFO EN bits.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2020 Invensense, Inc.

	/*

	 * T°C = (temp / 132.48) + 25

	 * Tm°C = 1000 * ((temp * 100 / 13248) + 25)

	 * scale: 100000 / 13248 ~= 7.548309

	 * offset: 25000

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2020 Invensense, Inc.

 chip initial default configuration */

 reserved values */

 8kHz */

 4kHz */

 2kHz */

 1kHz */

 200Hz */

 100Hz */

 50Hz */

 25Hz */

 12.5Hz */

 6.25Hz */

 3.125Hz */

 1.5625Hz */

 500Hz */

 if nothing changed, exit */

 compute required wait time for sensors to stabilize */

 temperature stabilization time */

 accel startup time */

 block any register write for at least 200 µs */

 gyro startup time */

 block any register write for at least 200 µs */

 gyro stop time */

 deferred sleep value if sleep pointer is provided or direct sleep */

 Sanitize missing values with current values */

 set ACCEL_CONFIG0 register (accel fullscale & odr) */

 set GYRO_ACCEL_CONFIG0 register (accel filter) */

 set PWR_MGMT0 register (accel sensor mode) */

 sanitize missing values with current values */

 set GYRO_CONFIG0 register (gyro fullscale & odr) */

 set GYRO_ACCEL_CONFIG0 register (gyro filter) */

 set PWR_MGMT0 register (gyro sensor mode) */

 set PWR_MGMT0 register (gyro & accel sensor mode, temp enabled) */

 set GYRO_CONFIG0 register (gyro fullscale & odr) */

 set ACCEL_CONFIG0 register (accel fullscale & odr) */

 set GYRO_ACCEL_CONFIG0 register (gyro & accel filters) */

 update internal conf */

/**

 *  inv_icm42600_setup() - check and setup chip

 *  @st:	driver internal state

 *  @bus_setup:	callback for setting up bus specific registers

 *

 *  Returns 0 on success, a negative error code otherwise.

 check chip self-identification value */

 reset to make sure previous state are not there */

 set chip bus configuration */

 sensor data in big-endian (default) */

 FIFO full */

 FIFO threshold reached */

/**

 * inv_icm42600_irq_init() - initialize int pin and interrupt handler

 * @st:		driver internal state

 * @irq:	irq number

 * @irq_type:	irq trigger type

 * @open_drain:	true if irq is open drain, false for push-pull

 *

 * Returns 0 on success, a negative error code otherwise.

 configure INT1 interrupt: default is active low on edge */

 Deassert async reset for proper INT pin operation (cf datasheet) */

 wait a little for supply ramp */

 get irq properties, set trigger falling by default */

 setup chip registers */

 setup runtime power management */

/*

 * Suspend saves sensors state and turns everything off.

 * Check first if runtime suspend has not already done the job.

 disable FIFO data streaming */

/*

 * System resume gets the system back on and restores the sensors state.

 * Manually put runtime power management in system active state.

 restore sensors state */

 restore FIFO data streaming */

 Runtime suspend will turn off sensors that are enabled by iio devices. */

 disable all sensors */

 Sensors are enabled by iio devices, no need to turn them back on here. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2020 InvenSense, Inc.

 setup interface registers */

 set slew rates for I2C and SPI */

 disable i2c bus */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2011 Jonathan Cameron

 *

 * Companion module to the iio simple dummy example driver.

 * The purpose of this is to generate 'fake' event interrupts thus

 * allowing that driver's code to be as close as possible to that of

 * a normal driver talking to hardware.  The approach used here

 * is not intended to be general and just happens to work for this

 * particular use case.

 Fiddly bit of faking and irq without hardware */

/**

 * struct iio_dummy_eventgen - event generator specific state

 * @regs: irq regs we are faking

 * @lock: protect the evgen state

 * @inuse: mask of which irqs are connected

 * @irq_sim: interrupt simulator

 * @base: base of irq range

 * @irq_sim_domain: irq simulator domain

 We can only ever have one instance of this 'device' */

/**

 * iio_dummy_evgen_get_irq() - get an evgen provided irq for a device

 *

 * This function will give a free allocated irq to a client device.

 * That irq can then be caused to 'fire' by using the associated sysfs file.

/**

 * iio_dummy_evgen_release_irq() - give the irq back.

 * @irq: irq being returned to the pool

 *

 * Used by client driver instances to give the irqs back when they disconnect

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2011 Jonathan Cameron

 *

 * Buffer handling elements of industrial I/O reference driver.

 * Uses the kfifo buffer.

 *

 * To test without hardware use the sysfs trigger.

 Some fake data */

/**

 * iio_simple_dummy_trigger_h() - the trigger handler function

 * @irq: the interrupt number

 * @p: private data - always a pointer to the poll func.

 *

 * This is the guts of buffered capture. On a trigger event occurring,

 * if the pollfunc is attached then this handler is called as a threaded

 * interrupt (and hence may sleep). It is responsible for grabbing data

 * from the device and pushing it into the associated buffer.

		/*

		 * Three common options here:

		 * hardware scans: certain combinations of channels make

		 *   up a fast read.  The capture will consist of all of them.

		 *   Hence we just call the grab data function and fill the

		 *   buffer without processing.

		 * software scans: can be considered to be random access

		 *   so efficient reading is just a case of minimal bus

		 *   transactions.

		 * software culled hardware scans:

		 *   occasionally a driver may process the nearest hardware

		 *   scan to avoid storing elements that are not desired. This

		 *   is the fiddliest option by far.

		 * Here let's pretend we have random access. And the values are

		 * in the constant table fakedata.

 random access read from the 'device' */

	/*

	 * Tell the core we are done with this trigger and ready for the

	 * next one.

/**

 * iio_simple_dummy_unconfigure_buffer() - release buffer resources

 * @indio_dev: device instance state

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2011 Jonathan Cameron

 *

 * A reference industrial I/O driver to illustrate the functionality available.

 *

 * There are numerous real drivers to illustrate the finer points.

 * The purpose of this driver is to provide a driver with far more comments

 * and explanatory notes than any 'real' driver would have.

 * Anyone starting out writing an IIO driver should first make sure they

 * understand all of this driver except those bits specifically marked

 * as being present to allow us to 'fake' the presence of hardware.

/**

 * struct iio_dummy_accel_calibscale - realworld to register mapping

 * @val: first value in read_raw - here integer part.

 * @val2: second value in read_raw etc - here micro part.

 * @regval: register value - magic device specific numbers.

 what would be written to hardware */

 0.000100 */

 0.000133 */

 733.000013 */

/*

 * simple event - triggered when value rises above

 * a threshold

/*

 * simple step detect event - triggered when a step is detected

/*

 * simple transition event - triggered when the reported running confidence

 * value rises above a threshold value

/*

 * simple transition event - triggered when the reported walking confidence

 * value falls under a threshold value

/*

 * iio_dummy_channels - Description of available channels

 *

 * This array of structures tells the IIO core about what the device

 * actually provides for a given channel.

 indexed ADC channel in_voltage0_raw etc */

 Channel has a numeric index of 0 */

 What other information is available? */

		/*

		 * in_voltage0_raw

		 * Raw (unscaled no bias removal etc) measurement

		 * from the device.

		/*

		 * in_voltage0_offset

		 * Offset for userspace to apply prior to scale

		 * when converting to standard units (microvolts)

		/*

		 * in_voltage0_scale

		 * Multipler for userspace to apply post offset

		 * when converting to standard units (microvolts)

		/*

		 * sampling_frequency

		 * The frequency in Hz at which the channels are sampled

 The ordering of elements in the buffer via an enum */

 Description of storage in buffer */

 unsigned */

 13 bits */

 16 bits used for storage */

 zero shift */

 CONFIG_IIO_SIMPLE_DUMMY_EVENTS */

 Differential ADC channel in_voltage1-voltage2_raw etc*/

		/*

		 * Indexing for differential channels uses channel

		 * for the positive part, channel2 for the negative.

		/*

		 * in_voltage1-voltage2_raw

		 * Raw (unscaled no bias removal etc) measurement

		 * from the device.

		/*

		 * in_voltage-voltage_scale

		 * Shared version of scale - shared by differential

		 * input channels of type IIO_VOLTAGE.

		/*

		 * sampling_frequency

		 * The frequency in Hz at which the channels are sampled

 Description of storage in buffer */

 signed */

 12 bits */

 16 bits used for storage */

 zero shift */

 Differential ADC channel in_voltage3-voltage4_raw etc*/

	/*

	 * 'modified' (i.e. axis specified) acceleration channel

	 * in_accel_z_raw

 Channel 2 is use for modifiers */

		/*

		 * Internal bias and gain correction values. Applied

		 * by the hardware or driver prior to userspace

		 * seeing the readings. Typically part of hardware

		 * calibration.

 Description of storage in buffer */

 signed */

 16 bits */

 16 bits used for storage */

 zero shift */

	/*

	 * Convenience macro for timestamps. 4 is the index in

	 * the buffer.

 DAC channel out_voltage0_raw */

 No buffer support */

 No buffer support */

 CONFIG_IIO_SIMPLE_DUMMY_EVENTS */

 No buffer support */

 CONFIG_IIO_SIMPLE_DUMMY_EVENTS */

 No buffer support */

 CONFIG_IIO_SIMPLE_DUMMY_EVENTS */

/**

 * iio_dummy_read_raw() - data read function.

 * @indio_dev:	the struct iio_dev associated with this device instance

 * @chan:	the channel whose data is to be read

 * @val:	first element of returned value (typically INT)

 * @val2:	second element of returned value (typically MICRO)

 * @mask:	what we actually want to read as per the info_mask_*

 *		in iio_chan_spec.

 magic value - channel value read */

 Set integer part to cached value */

 only single ended adc -> 7 */

 only single ended adc -> 0.001333 */

 all differential adc -> 0.000001344 */

 only the acceleration axis - read from cache */

/**

 * iio_dummy_write_raw() - data write function.

 * @indio_dev:	the struct iio_dev associated with this device instance

 * @chan:	the channel whose data is to be written

 * @val:	first element of value to set (typically INT)

 * @val2:	second element of value to set (typically MICRO)

 * @mask:	what we actually want to write as per the info_mask_*

 *		in iio_chan_spec.

 *

 * Note that all raw writes are assumed IIO_VAL_INT and info mask elements

 * are assumed to be IIO_INT_PLUS_MICRO unless the callback write_raw_get_fmt

 * in struct iio_info is provided by the driver.

 Locking not required as writing single value */

 Compare against table - hard matching here */

/*

 * Device type specific information.

 CONFIG_IIO_SIMPLE_DUMMY_EVENTS */

/**

 * iio_dummy_init_device() - device instance specific init

 * @indio_dev: the iio device structure

 *

 * Most drivers have one of these to set up default values,

 * reset the device to known state etc.

/**

 * iio_dummy_probe() - device instance probe

 * @name: name of this instance.

 *

 * Arguments are bus type specific.

 * I2C: iio_dummy_probe(struct i2c_client *client,

 *                      const struct i2c_device_id *id)

 * SPI: iio_dummy_probe(struct spi_device *spi)

	/*

	 * With hardware: Set the parent device.

	 * parent = &spi->dev;

	 * parent = &client->dev;

	/*

	 * Allocate an IIO device.

	 *

	 * This structure contains all generic state

	 * information about the device instance.

	 * It also has a region (accessed by iio_priv()

	 * for chip specific state information.

	 /*

	 * Make the iio_dev struct available to remove function.

	 * Bus equivalents

	 * i2c_set_clientdata(client, indio_dev);

	 * spi_set_drvdata(spi, indio_dev);

	/*

	 * Set the device name.

	 *

	 * This is typically a part number and obtained from the module

	 * id table.

	 * e.g. for i2c and spi:

	 *    indio_dev->name = id->name;

	 *    indio_dev->name = spi_get_device_id(spi)->name;

 Provide description of available channels */

	/*

	 * Provide device type specific interface functions and

	 * constant data.

 Specify that device provides sysfs type interfaces */

/**

 * iio_dummy_remove() - device instance removal function

 * @swd: pointer to software IIO device abstraction

 *

 * Parameters follow those of iio_dummy_probe for buses.

	/*

	 * Get a pointer to the device instance iio_dev structure

	 * from the bus subsystem. E.g.

	 * struct iio_dev *indio_dev = i2c_get_clientdata(client);

	 * struct iio_dev *indio_dev = spi_get_drvdata(spi);

 Unregister the device */

 Device specific code to power down etc */

 Buffered capture related cleanup */

 Free all structures */

/*

 * module_iio_sw_device_driver() -  device driver registration

 *

 * Varies depending on bus type of the device. As there is no device

 * here, call probe directly. For information on device registration

 * i2c:

 * Documentation/i2c/writing-clients.rst

 * spi:

 * Documentation/spi/spi-summary.rst

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2011 Jonathan Cameron

 *

 * Event handling elements of industrial I/O reference driver.

 Evgen 'fakes' interrupt events for this example */

/**

 * iio_simple_dummy_read_event_config() - is event enabled?

 * @indio_dev: the device instance data

 * @chan: channel for the event whose state is being queried

 * @type: type of the event whose state is being queried

 * @dir: direction of the vent whose state is being queried

 *

 * This function would normally query the relevant registers or a cache to

 * discover if the event generation is enabled on the device.

/**

 * iio_simple_dummy_write_event_config() - set whether event is enabled

 * @indio_dev: the device instance data

 * @chan: channel for the event whose state is being set

 * @type: type of the event whose state is being set

 * @dir: direction of the vent whose state is being set

 * @state: whether to enable or disable the device.

 *

 * This function would normally set the relevant registers on the devices

 * so that it generates the specified event. Here it just sets up a cached

 * value.

	/*

	 *  Deliberately over the top code splitting to illustrate

	 * how this is done when multiple events exist.

/**

 * iio_simple_dummy_read_event_value() - get value associated with event

 * @indio_dev: device instance specific data

 * @chan: channel for the event whose value is being read

 * @type: type of the event whose value is being read

 * @dir: direction of the vent whose value is being read

 * @info: info type of the event whose value is being read

 * @val: value for the event code.

 * @val2: unused

 *

 * Many devices provide a large set of events of which only a subset may

 * be enabled at a time, with value registers whose meaning changes depending

 * on the event enabled. This often means that the driver must cache the values

 * associated with each possible events so that the right value is in place when

 * the enabled event is changed.

/**

 * iio_simple_dummy_write_event_value() - set value associate with event

 * @indio_dev: device instance specific data

 * @chan: channel for the event whose value is being set

 * @type: type of the event whose value is being set

 * @dir: direction of the vent whose value is being set

 * @info: info type of the event whose value is being set

 * @val: the value to be set.

 * @val2: unused

/**

 * iio_simple_dummy_event_handler() - identify and pass on event

 * @irq: irq of event line

 * @private: pointer to device instance state.

 *

 * This handler is responsible for querying the device to find out what

 * event occurred and for then pushing that event towards userspace.

 * Here only one event occurs so we push that directly on with locally

 * grabbed timestamp.

/**

 * iio_simple_dummy_events_register() - setup interrupt handling for events

 * @indio_dev: device instance data

 *

 * This function requests the threaded interrupt to handle the events.

 * Normally the irq is a hardware interrupt and the number comes

 * from board configuration files.  Here we get it from a companion

 * module that fakes the interrupt for us. Note that module in

 * no way forms part of this example. Just assume that events magically

 * appear via the provided interrupt.

 Fire up event source - normally not present */

/**

 * iio_simple_dummy_events_unregister() - tidy up interrupt handling on remove

 * @indio_dev: device instance data

 Not part of normal driver */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * The industrial I/O periodic hrtimer trigger driver

 *

 * Copyright (C) Intuitive Aerial AB

 * Written by Marten Svanfeldt, marten@intuitiveaerial.com

 * Copyright (C) 2012, Analog Devices Inc.

 *	Author: Lars-Peter Clausen <lars@metafoo.de>

 * Copyright (C) 2015, Intel Corporation

 Defined locally, not in time64.h yet. */

 default sampling frequency - 100Hz */

 mHz */

 Hz */

 uHz */

 nS */

 cancel the timer after unreg to make sure no one rearms it */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) STMicroelectronics 2016

 *

 * Author: Benjamin Gaignard <benjamin.gaignard@st.com>

 *

 List the triggers created by each timer */

 List the triggers accepted by each timer */

 timer 6 */

 timer 7 */

 timer 10 */

 timer 11 */

 timer 6 */

 timer 7 */

 timer 9 */

 timer 10 */

 timer 11 */

 timer 13 */

 timer 14 */

 timer 16 */

 timer 17 */

 concurrent sysfs configuration */

 Period and prescaler values depends of clock rate */

	/*

	 * Increase prescaler value until we get a result that fit

	 * with auto reload register maximum value.

 Check if nobody else use the timer */

 Force master mode to update mode */

 Make sure that registers are updated */

 Enable controller */

 Stop timer */

 Force disable master mode */

 Make sure that registers are updated */

 Master mode selection 2 only */

 Clock should be enabled first */

 replace trailing space by newline */

		/*

		 * sampling frequency and master mode attributes

		 * should only be available on trgo/trgo2 triggers

 in quadrature case scale = 0.25 */

 fixed scale */

	/*

	 * Triggered mode sets CEN bit automatically by hardware. So, first

	 * enable counter clock, so it can use it. Keeps it in sync with CEN.

 TIMx_ARR register shouldn't be buffered (ARPE=0) */

/**

 * is_stm32_timer_trigger

 * @trig: trigger to be checked

 *

 * return true if the trigger is a valid stm32 iio timer trigger

 * either return false

	/*

	 * Master mode selection 2 bits can only be written and read back when

	 * timer supports it.

 Create an IIO device only if we have triggers to be validated */

 Unregister triggers before everything can be safely turned off */

 Check if nobody else use the timer, then disable it */

 Only take care of enabled timer: don't disturb other MFD child */

 Backup registers that may get lost in low power mode */

 Disable the timer */

 restore master/slave modes */

 restore sampling_frequency (trgo / trgo2 triggers) */

 Also re-enables the timer */

 end node */ },

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2016 Jonathan Cameron <jic23@kernel.org>

 *

 * Based on a mashup of the hrtimer trigger and continuous sampling proposal of

 * Gregor Boirie <gregor.boirie@parrot.com>

 *

 * Note this is still rather experimental and may eat babies.

 *

 * Todo

 * * Protect against connection of devices that 'need' the top half

 *   handler.

 * * Work out how to run top half handlers in this context if it is

 *   safe to do so (timestamp grabbing for example)

 *

 * Tested against a max1363. Used about 33% cpu for the thread and 20%

 * for generic_buffer piping to /dev/null. Watermark set at 64 on a 128

 * element kfifo buffer.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Industrial I/O - generic interrupt based trigger support

 *

 * Copyright (c) 2008-2013 Jonathan Cameron

 First clean up the partly allocated trigger */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2011 Analog Devices Inc.

 Nothing to actually do upon release */

 SPDX-License-Identifier: GPL-2.0

/*

 * STM32 Low-Power Timer Trigger driver

 *

 * Copyright (C) STMicroelectronics 2017

 *

 * Author: Fabrice Gasnier <fabrice.gasnier@st.com>.

 *

 * Inspired by Benjamin Gaignard's stm32-timer-trigger driver

 List Low-Power Timer triggers */

/**

 * is_stm32_lptim_trigger

 * @trig: trigger to be checked

 *

 * return true if the trigger is a valid STM32 IIO Low-Power Timer Trigger

 * either return false

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ad2s1200.c simple support for the ADI Resolver to Digital Converters:

 * AD2S1200/1205

 *

 * Copyright (c) 2018-2018 David Veenstra <davidjulianveenstra@gmail.com>

 * Copyright (c) 2010-2010 Analog Devices Inc.

 input clock on serial interface */

 clock period in nano second */

/**

 * struct ad2s1200_state - driver instance specific data.

 * @lock:	protects both the GPIO pins and the rx buffer.

 * @sdev:	spi device.

 * @sample:	GPIO pin SAMPLE.

 * @rdvel:	GPIO pin RDVEL.

 * @rx:		buffer for spi transfers.

 2 * Pi / (2^12 - 1) ~= 0.001534355 */

 2 * Pi ~= 6.283185 */

 delay (6 * AD2S1200_TSCLK + 20) nano seconds */

 delay (2 * AD2S1200_TSCLK + 20) ns for sample pulse */

 SPDX-License-Identifier: GPL-2.0

/*

 * ad2s90.c simple support for the ADI Resolver to Digital Converters: AD2S90

 *

 * Copyright (c) 2010-2010 Analog Devices Inc.

/*

 * Although chip's max frequency is 2Mhz, it needs 600ns between CS and the

 * first falling edge of SCLK, so frequency should be at most 1 / (2 * 6e-7)

 lock to protect rx buffer */

 2 * Pi / 2^12 */

 mV */

 SPDX-License-Identifier: GPL-2.0+

/*

 * ADS8344 16-bit 8-Channel ADC driver

 *

 * Author: Gregory CLEMENT <gregory.clement@bootlin.com>

 *

 * Datasheet: https://www.ti.com/lit/ds/symlink/ads8344.pdf

 PD1 = 1 and PD0 = 0 */

	/*

	 * Lock protecting access to adc->tx_buff and rx_buff,

	 * especially from concurrent read on sysfs file.

 convert regulator output voltage to mV */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Freescale i.MX7D ADC driver

 *

 * Copyright (C) 2015 Freescale Semiconductor, Inc.

 ADC register */

 impact the sample rate */

	/*

	 * Before sample set, disable channel A,B,C,D. Here we

	 * clear the bit 31 of register REG_ADC_CH_A\B\C\D_CFG1.

 power up and enable adc analogue core */

 enable channel A,B,C,D interrupt */

 the channel choose single conversion, and enable average mode */

	/*

	 * physical channel 0 chose logical channel A

	 * physical channel 1 chose logical channel B

	 * physical channel 2 chose logical channel C

	 * physical channel 3 chose logical channel D

	/*

	 * read register REG_ADC_CH_A\B\C\D_CFG2, according to the

	 * channel chosen

	/*

	 * write the register REG_ADC_CH_A\B\C\D_CFG2, according to

	 * the channel chosen

	/*

	 * channel A and B conversion result share one register,

	 * bit[27~16] is the channel B conversion result,

	 * bit[11~0] is the channel A conversion result.

	 * channel C and D is the same.

 channel B or D */

 channel A or C */

		/*

		 * The register IMX7D_REG_ADC_INT_STATUS can't clear

		 * itself after read operation, need software to write

		 * 0 to the related bit. Here we clear the channel A/B/C/D

		 * conversion finished flag.

	/*

	 * If the channel A/B/C/D conversion timeout, report it and clear these

	 * timeout flags.

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0

/* TI ADS124S0X chip family driver

 * Copyright (C) 2018 Texas Instruments Incorporated - https://www.ti.com/

 Commands */

 Registers */

 ADS124S0x common channels */

 ADS124S08 only channels */

	/*

	 * Used to correctly align data.

	 * Ensure timestamp is naturally aligned.

	 * Note that the full buffer length may not be needed if not

	 * all channels are enabled, as long as the alignment of the

	 * timestamp is maintained.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2017 Tony Lindgren <tony@atomide.com>

 *

 * Rewritten for Linux IIO framework with some code based on

 * earlier driver found in the Motorola Linux kernel:

 *

 * Copyright (C) 2009-2010 Motorola, Inc.

 Register CPCAP_REG_ADCC1 bits */

 Currently unused */

 Set with BIT_RAND0 */

 Currently unused */

 Currently unused */

 Set for bank1 */

 Set for channel 16 & 17 */

 Set with CAL_MODE */

 Currently unused */

 Register CPCAP_REG_ADCC2 bits */

 Currently unused */

 Currently unused */

 Set for !TIMING_IMM */

 Set for TIMING_IMM */

 Currently unused */

 Currently unused */

 Bias for AD0_BATTDETB */

 Disable interrupt */

 Currently unused */

 Currently unused */

 Currently unused */

 Currently unused */

 Currently unused */

 Calibration */

/*

 * struct cpcap_adc_ato - timing settings for cpcap adc

 *

 * Unfortunately no cpcap documentation available, please document when

 * using these.

/**

 * struct cpcap_adc - cpcap adc device driver data

 * @reg: cpcap regmap

 * @dev: struct device

 * @vendor: cpcap vendor

 * @irq: interrupt

 * @lock: mutex

 * @ato: request timings

 * @wq_data_avail: work queue

 * @done: work done

 ADC register access lock */

/*

 * enum cpcap_adc_channel - cpcap adc channels

 Bank0 channels */

 Battery temperature */

 Battery voltage */

 USB VBUS voltage */

 Die temperature when charging */

 Another battery or system voltage */

 Calibrated charge current */

 Calibrated system current */

 USB OTG ID, unused on droid 4? */

 Bank1 channels */

 Seems unused */

 Seems unused */

 Maybe system voltage? Always 3V */

 Another battery detection? */

 Seems unused, for touchscreen? */

 Seems unused, for touchscreen? */

 Seems unused, for touchscreen? */

 Seems unused, for touchscreen? */

 Remuxed channels using bank0 entries */

 Alternative mux mode for BATTP */

 Alternative mux mode for BATTI */

/*

 * enum cpcap_adc_timing - cpcap adc timing options

 *

 * CPCAP_ADC_TIMING_IMM seems to be immediate with no timings.

 * Please document when using.

/**

 * struct cpcap_adc_phasing_tbl - cpcap phasing table

 * @offset: offset in the phasing table

 * @multiplier: multiplier in the phasing table

 * @divider: divider in the phasing table

 * @min: minimum value

 * @max: maximum value

/**

 * struct cpcap_adc_conversion_tbl - cpcap conversion table

 * @conv_type: conversion type

 * @align_offset: align offset

 * @conv_offset: conversion offset

 * @cal_offset: calibration offset

 * @multiplier: conversion multiplier

 * @divider: conversion divider

/**

 * struct cpcap_adc_request - cpcap adc request

 * @channel: request channel

 * @phase_tbl: channel phasing table

 * @conv_tbl: channel conversion table

 * @bank_index: channel index within the bank

 * @timing: timing settings

 * @result: result

 Phasing table for channels. Note that channels 16 & 17 use BATTP and BATTI */

 Bank0 */

 Bank1 */

/*

 * Conversion table for channels. Updated during init based on calibration.

 * Here too channels 16 & 17 use BATTP and BATTI.

 Bank0 */

 Bank1 */

/*

 * Temperature lookup table of register values to milliCelcius.

 * REVISIT: Check the duplicate 0x3ff entry in a freezer

/*

 * The datasheet names are from Motorola mapphone Linux kernel except

 * for the last two which might be uncalibrated charge voltage and

 * current.

 Bank0 */

 Bank1 */

 There are two registers with multiplexed functionality */

 ADC calibration functions */

 ADC setup, read and scale functions */

 Remuxed channels 16 and 17 use BATTP and BATTI entries */

 Looks up temperatures in a table and calculates averages if needed */

 Remuxed channels 16 and 17 use BATTP and BATTI entries */

 No conversion for raw channels */

 Temperatures use a lookup table instead of conversion table */

 All processed channels use a conversion table */

/*

 * REVISIT: Check if timed sampling can use multiple channels at the

 * same time. If not, replace channel_mask with just channel.

/*

 * Configuration for Motorola mapphone series such as droid 4.

 * Copied from the Motorola mapphone kernel tree.

 sentinel */ },

 SPDX-License-Identifier: GPL-2.0

/* ad7949.c - Analog Devices ADC driver 14/16 bits 4/8 channels

 *

 * Copyright (C) 2018 CMC NV

 *

 * https://www.analog.com/media/en/technical-documentation/data-sheets/AD7949.pdf

 CFG: Configuration Update */

 INCC: Input Channel Configuration */

 INX: Input channel Selection in a binary fashion */

 BW: select bandwidth for low-pass filter. Full or Quarter */

 REF: reference/buffer selection */

 SEQ: channel sequencer. Allows for scanning channels */

 RB: Read back the CFG register */

/**

 * struct ad7949_adc_chip - AD ADC chip

 * @lock: protects write sequences

 * @vref: regulator generating Vref

 * @indio_dev: reference to iio structure

 * @spi: reference to spi structure

 * @refsel: reference selection

 * @resolution: resolution of the chip

 * @cfg: copy of the configuration register

 * @current_channel: current channel in use

 * @buffer: buffer to send / receive data to / from device

 * @buf8b: be16 buffer to exchange data with the device in 8-bit transfers

 Here, type is big endian as it must be sent in two transfers */

	/*

	 * This delay is to avoid a new request before the required time to

	 * send a new command to the device

	/*

	 * 1: write CFG for sample N and read old data (sample N-2)

	 * 2: if CFG was not changed since sample N-1 then we'll get good data

	 *    at the next xfer, so we bail out now, otherwise we write something

	 *    and we read garbage (sample N-1 configuration).

 3: write something and read actual data */

	/*

	 * This delay is to avoid a new request before the required time to

	 * send a new command to the device

 Shift-out padding bits */

 Here, type is big endian as data was sent in two transfers */

 Shift-out padding bits */

 convert value back to mV */

	/*

	 * Do two dummy conversions to apply the first configuration setting.

	 * Required only after the start up of the device.

 Set SPI bits per word */

 Setup internal voltage reference */

 Setup external voltage reference, buffered? */

 unbuffered? */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * TI LP8788 MFD - ADC driver

 *

 * Copyright 2012 Texas Instruments

 *

 * Author: Milo(Woogyom) Kim <milo.kim@ti.com>

 register address */

 retry until adc conversion is done */

 conversion done */

 default maps used by iio consumer (lp8788-charger driver) */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2013 Oskar Andero <oskar.andero@gmail.com>

 * Copyright (C) 2014 Rose Technology

 * 	   Allan Bendorff Jensen <abj@rosetechnology.dk>

 *	   Soren Andersen <san@rosetechnology.dk>

 *

 * Driver for following ADC chips from Microchip Technology's:

 * 10 Bit converter

 * MCP3001

 * MCP3002

 * MCP3004

 * MCP3008

 * ------------

 * 12 bit converter

 * MCP3201

 * MCP3202

 * MCP3204

 * MCP3208

 * ------------

 * 13 bit converter

 * MCP3301

 * ------------

 * 22 bit converter

 * MCP3550

 * MCP3551

 * MCP3553

 *

 * Datasheet can be found here:

 * https://ww1.microchip.com/downloads/en/DeviceDoc/21293C.pdf  mcp3001

 * https://ww1.microchip.com/downloads/en/DeviceDoc/21294E.pdf  mcp3002

 * https://ww1.microchip.com/downloads/en/DeviceDoc/21295d.pdf  mcp3004/08

 * http://ww1.microchip.com/downloads/en/DeviceDoc/21290D.pdf  mcp3201

 * http://ww1.microchip.com/downloads/en/DeviceDoc/21034D.pdf  mcp3202

 * http://ww1.microchip.com/downloads/en/DeviceDoc/21298c.pdf  mcp3204/08

 * https://ww1.microchip.com/downloads/en/DeviceDoc/21700E.pdf  mcp3301

 * http://ww1.microchip.com/downloads/en/DeviceDoc/21950D.pdf  mcp3550/1/3

 usec */

/**

 * struct mcp320x - Microchip SPI ADC instance

 * @spi: SPI slave (parent of the IIO device)

 * @msg: SPI message to select a channel and receive a value from the ADC

 * @transfer: SPI transfers used by @msg

 * @start_conv_msg: SPI message to start a conversion by briefly asserting CS

 * @start_conv_transfer: SPI transfer used by @start_conv_msg

 * @reg: regulator generating Vref

 * @lock: protects read sequences

 * @chip_info: ADC properties

 * @tx_buf: buffer for @transfer[0] (not used on single-channel converters)

 * @rx_buf: buffer for @transfer[1]

 strip Data Ready bit in SPI mode 0,0 */

		/*

		 * If the input is within -vref and vref, bit 21 is the sign.

		 * Up to 12% overrange or underrange are allowed, in which case

		 * bit 23 is the sign and bit 0 to 21 is the value.

 cannot have overrange AND underrange */

 overrange */

 underrange or negative */

 convert regulator output voltage to mV */

 2% max deviation + 144 clock periods to exit shutdown */

 single-channel converters are rx only (no MOSI pin) */

 rx len increases from 24 to 25 bit in SPI mode 0,0 */

 conversions are started by asserting CS pin for 8 usec */

		/*

		 * If CS was previously kept low (continuous conversion mode)

		 * and then changed to high, the chip is in shutdown.

		 * Sometimes it fails to wake from shutdown and clocks out

		 * only 0xffffff.  The magic sequence of performing two

		 * conversions without delay between them resets the chip

		 * and ensures all subsequent conversions succeed.

 NOTE: The use of compatibles with no vendor prefix is deprecated. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for the ADC present in the Atmel AT91 evaluation boards.

 *

 * Copyright 2011 Free Electrons

 Registers */

 Control Register */

 Software Reset */

 Start Conversion */

 Mode Register */

 ADC mode */

 ADC Mode */

 Touch Screen Only Mode */

 Trigger Enable */

 Trigger Selection */

 Low Resolution */

 Sleep Mode */

 Pen contact detection enable */

 Prescalar Rate Selection */

 Startup Up Time */

 Sample & Hold Time */

 Pen Debounce time */

 Sample & Hold Time */

 Channel Enable Register */

 Channel Disable Register */

 Channel Status Register */

 Channel Number */

 Status Register */

 End of Conversion on Channel N */

 Overrun Error on Channel N */

 Data Ready */

 General Overrun Error */

 End of RX Buffer */

 RX Buffer Full */

 Status Register for 9x5 */

 Data Ready */

 Last Converted Data Register */

 Interrupt Enable Register */

 Interrupt Disable Register */

 Interrupt Mask Register */

 Channel Data Register N */

 Channel Data Register 0 for 9X5 */

 Analog Control Register */

 pull-up resistor */

 Touch Screen Mode */

 Averages samples */

 Switch closure time */

 Pen Debounce time */

 No Touchscreen DMA */

 Pen contact detection disable */

 Pen contact detection enable */

 Trigger Register bit field */

 2ms */

 10ms, the SoC can't keep up with 2ms */

 10us for the Touchscreen Switches Closure Time */

/**

 * struct at91_adc_trigger - description of triggers

 * @name:		name of the trigger advertised to the user

 * @value:		value to set in the ADC's trigger setup register

 *			to enable the trigger

 * @is_external:	Does the trigger rely on an external pin?

/**

 * struct at91_adc_reg_desc - Various informations relative to registers

 * @channel_base:	Base offset for the channel data registers

 * @drdy_mask:		Mask of the DRDY field in the relevant registers

 *			(Interruptions registers mostly)

 * @status_register:	Offset of the Interrupt Status Register

 * @trigger_register:	Offset of the Trigger setup register

 * @mr_prescal_mask:	Mask of the PRESCAL field in the adc MR register

 * @mr_startup_mask:	Mask of the STARTUP field in the adc MR register

 Support touch screen */

 only at91sam9x5, sama5d3 have TSMR reg */

	/*

	 * Numbers of sampling data will be averaged. Can be 0~3.

	 * Hardware can average (2 ^ ts_filter_average) sample data.

 Pen Detection input pull-up resistor, can be 0~3 */

 startup time calculate function */

 resolution used for convertions */

	/*

	 * Following ADC channels are shared by touchscreen:

	 *

	 * CH0 -- Touch screen XP/UL

	 * CH1 -- Touch screen XM/UR

	 * CH2 -- Touch screen YP/LL

	 * CH3 -- Touch screen YM/Sense

	 * CH4 -- Touch screen LR(5-wire only)

	 *

	 * The bitfields below represents the reserved channel in the

	 * touchscreen mode.

 Needed to ACK the DRDY interruption */

 Handler for classic adc channel eoc trigger */

 Needed to ACK the DRDY interruption */

 calculate position */

 x position = (x / xscale) * max, max = 2^MAX_POS_BITS - 1 */

 y position = (y / yscale) * max, max = 2^MAX_POS_BITS - 1 */

 calculate the pressure */

 no pen contacted */

 Disabling pen debounce is required to get a NOPEN irq */

 Set up period trigger for sampling */

 Conversion finished and we've a touchscreen */

			/*

			 * Last measurement is always discarded, since it can

			 * be erroneous.

			 * Always report previous measurement

 Now make new measurement */

 Set up period trigger for sampling */

 Now all touchscreen data is ready */

 validate data by pen contact */

			/* triggered by event that is no pen contact, just read

			 * them to clean the interrupt and discard all.

 If touchscreen is enable, then reserve the adc channels */

 set up the channel mask to reserve touchscreen channels */

		/* Disable interrupts, regardless if adc conversion was

		 * successful or not

 a valid conversion took place */

 conversion timeout */

	/*

	 * Number of ticks needed to cover the startup time of the ADC

	 * as defined in the electrical characteristics of the board,

	 * divided by 8. The formula thus is :

	 *   Startup Time = (ticks + 1) * 8 / ADC Clock

	/*

	 * For sama5d3x and at91sam9x5, the formula changes to:

	 * Startup Time = <lookup_table_value> / ADC Clock

 Reach the end of lookup table */

 Touchscreen related functions */

	/* a Pen Detect Debounce Time is necessary for the ADC Touch to avoid

	 * pen detect noise.

	 * The formula is : Pen Detect Debounce Time = (2 ^ pendbc) / ADCClock

 Empty! Find the shift offset */

	/* Touchscreen Switches Closure time needed for allowing the value to

	 * stabilize.

	 * Switch Closure Time = (TSSCTIM * 4) ADCClock periods

 TSFREQ, needs to be bigger than TSAV */

	/* Change adc internal resistor value for better pen detection,

	 * default value is 100 kOhm.

	 * 0 = 200 kOhm, 1 = 150 kOhm, 2 = 100 kOhm, 3 = 50 kOhm

	 * option only available on ES2 and higher

 Sample Period Time = (TRGPER + 1) / ADCClock */

 Check if touchscreen is supported. */

	/*

	 * Disable all IRQs before setting up the handler

	/*

	 * Prescaler rate computation using the formula from the Atmel's

	 * datasheet : ADC Clock = MCK / ((Prescaler + 1) * 2), ADC Clock being

	 * specified by the electrical characteristics of the board.

	/*

	 * a minimal Sample and Hold Time is necessary for the ADC to guarantee

	 * the best converted final value between two channels selection

	 * The formula thus is : Sample and Hold Time = (shtim + 1) / ADCClock

 Setup the ADC channels available on the board */

	/*

	 * Since touch screen will set trigger register as period trigger. So

	 * when touch screen is enabled, then we have to disable hardware

	 * trigger for classic adc.

 same as 9260 */

 same as 9260 */

 prescal mask is same as 9G45 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * IIO ADC driver for NXP LPC18xx ADC

 *

 * Copyright (C) 2016 Joachim Eastwood <manabian@gmail.com>

 *

 * UNSUPPORTED hardware features:

 *  - Hardware triggers

 *  - Burst mode

 *  - Interrupts

 *  - DMA

 LPC18XX ADC registers and bits */

 Data register bits */

 Clock should be 4.5 MHz or less */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ltc2485.c - Driver for Linear Technology LTC2485 ADC

 *

 * Copyright (C) 2016 Alison Schofield <amsfield22@gmail.com>

 *

 * Datasheet: http://cds.linear.com/docs/en/datasheet/2485fd.pdf

 Power-on configuration: rejects both 50/60Hz, operates at 1x speed */

 last conversion */

 conversion time ms */

 delay if conversion time not passed since last read or write */

 on board vref millivolts */

 25 (24 + sign) data bits */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Support code for Analog Devices Sigma-Delta ADCs

 *

 * Copyright 2012 Analog Devices Inc.

 *  Author: Lars-Peter Clausen <lars@metafoo.de>

/**

 * ad_sd_set_comm() - Set communications register

 *

 * @sigma_delta: The sigma delta device

 * @comm: New value for the communications register

	/* Some variants use the lower two bits of the communications register

/**

 * ad_sd_write_reg() - Write a register

 *

 * @sigma_delta: The sigma delta device

 * @reg: Address of the register

 * @size: Size of the register (0-3)

 * @val: Value to write to the register

 *

 * Returns 0 on success, an error code otherwise.

/**

 * ad_sd_read_reg() - Read a register

 *

 * @sigma_delta: The sigma delta device

 * @reg: Address of the register

 * @size: Size of the register (1-4)

 * @val: Read value

 *

 * Returns 0 on success, an error code otherwise.

/**

 * ad_sd_reset() - Reset the serial interface

 *

 * @sigma_delta: The sigma delta device

 * @reset_length: Number of SCLKs with DIN = 1

 *

 * Returns 0 on success, an error code otherwise.

/**

 * ad_sd_calibrate_all() - Performs channel calibration

 * @sigma_delta: The sigma delta device

 * @cb: Array of channels and calibration type to perform

 * @n: Number of items in cb

 *

 * Returns 0 on success, an error code otherwise.

/**

 * ad_sigma_delta_single_conversion() - Performs a single data conversion

 * @indio_dev: The IIO device

 * @chan: The conversion is done for this channel

 * @val: Pointer to the location where to store the read value

 *

 * Returns: 0 on success, an error value otherwise.

		/* We store 24 bit samples in a 32 bit word. Keep the upper

/**

 * ad_sd_validate_trigger() - validate_trigger callback for ad_sigma_delta devices

 * @indio_dev: The IIO device

 * @trig: The new trigger

 *

 * Returns: 0 if the 'trig' matches the trigger registered by the ad_sigma_delta

 * device, -EINVAL otherwise.

 select default trigger */

/**

 * devm_ad_sd_setup_buffer_and_trigger() - Device-managed buffer & trigger setup

 * @dev: Device object to which to bind the life-time of the resources attached

 * @indio_dev: The IIO device

/**

 * ad_sd_init() - Initializes a ad_sigma_delta struct

 * @sigma_delta: The ad_sigma_delta device

 * @indio_dev: The IIO device which the Sigma Delta device is used for

 * @spi: The SPI device for the ad_sigma_delta device

 * @info: Device specific callbacks and options

 *

 * This function needs to be called before any other operations are performed on

 * the ad_sigma_delta struct.

 SPDX-License-Identifier: GPL-2.0

/*

 * This file is part of STM32 ADC driver

 *

 * Copyright (C) 2016, STMicroelectronics - All Rights Reserved

 * Author: Fabrice Gasnier <fabrice.gasnier@st.com>.

 Number of linear calibration shadow registers / LINCALRDYW control bits */

 BOOST bit must be set on STM32H7 when ADC clock is above 20MHz */

 max number of channels */

 max channel name size */

 SQ1..SQ16 */

 SMPx range is [0..7] */

 External trigger enable */

 extsel - trigger mux selection value */

/**

 * struct stm32_adc_ic - ADC internal channels

 * @name:	name of the internal channel

 * @idx:	internal channel enum index

/**

 * struct stm32_adc_trig_info - ADC trigger info

 * @name:		name of the trigger, corresponding to its source

 * @extsel:		trigger selection

/**

 * struct stm32_adc_calib - optional adc calibration data

 * @calfact_s: Calibration offset for single ended channels

 * @calfact_d: Calibration offset in differential

 * @lincalfact: Linearity calibration factor

 * @calibrated: Indicates calibration status

/**

 * struct stm32_adc_regs - stm32 ADC misc registers & bitfield desc

 * @reg:		register offset

 * @mask:		bitfield mask

 * @shift:		left shift

/**

 * struct stm32_adc_vrefint - stm32 ADC internal reference voltage data

 * @vrefint_cal:	vrefint calibration value from nvmem

 * @vrefint_data:	vrefint actual value

/**

 * struct stm32_adc_regspec - stm32 registers definition

 * @dr:			data register offset

 * @ier_eoc:		interrupt enable register & eocie bitfield

 * @ier_ovr:		interrupt enable register & overrun bitfield

 * @isr_eoc:		interrupt status register & eoc bitfield

 * @isr_ovr:		interrupt status register & overrun bitfield

 * @sqr:		reference to sequence registers array

 * @exten:		trigger control register & bitfield

 * @extsel:		trigger selection register & bitfield

 * @res:		resolution selection register & bitfield

 * @smpr:		smpr1 & smpr2 registers offset array

 * @smp_bits:		smpr1 & smpr2 index and bitfields

 * @or_vdd:		option register & vddcore bitfield

 * @ccr_vbat:		common register & vbat bitfield

 * @ccr_vref:		common register & vrefint bitfield

/**

 * struct stm32_adc_cfg - stm32 compatible configuration data

 * @regs:		registers descriptions

 * @adc_info:		per instance input channels definitions

 * @trigs:		external trigger sources

 * @clk_required:	clock is required

 * @has_vregready:	vregready status flag presence

 * @prepare:		optional prepare routine (power-up, enable)

 * @start_conv:		routine to start conversions

 * @stop_conv:		routine to stop conversions

 * @unprepare:		optional unprepare routine (disable, power-down)

 * @irq_clear:		routine to clear irqs

 * @smp_cycles:		programmable sampling time (ADC clock cycles)

 * @ts_vrefint_ns:	vrefint minimum sampling time in ns

/**

 * struct stm32_adc - private data of each ADC IIO instance

 * @common:		reference to ADC block common data

 * @offset:		ADC instance register offset in ADC block

 * @cfg:		compatible configuration data

 * @completion:		end of single conversion completion

 * @buffer:		data buffer + 8 bytes for timestamp if enabled

 * @clk:		clock for this adc instance

 * @irq:		interrupt for this adc instance

 * @lock:		spinlock

 * @bufi:		data buffer index

 * @num_conv:		expected number of scan conversions

 * @res:		data resolution (e.g. RES bitfield value)

 * @trigger_polarity:	external trigger polarity (e.g. exten)

 * @dma_chan:		dma channel

 * @rx_buf:		dma rx buffer cpu address

 * @rx_dma_buf:		dma rx buffer bus address

 * @rx_buf_sz:		dma rx buffer size

 * @difsel:		bitmask to set single-ended/differential channel

 * @pcsel:		bitmask to preselect channels on some devices

 * @smpr_val:		sampling time settings (e.g. smpr1 / smpr2)

 * @cal:		optional calibration data on some devices

 * @vrefint:		internal reference voltage data

 * @chan_name:		channel name array

 * @num_diff:		number of differential channels

 * @int_ch:		internal channel indexes array

 interrupt lock */

/**

 * struct stm32_adc_info - stm32 ADC, per instance config data

 * @max_channels:	Number of channels

 * @resolutions:	available resolutions

 * @num_res:		number of available resolutions

 sorted values so the index matches RES[1:0] in STM32F4_ADC_CR1 */

 stm32f4 can have up to 16 channels */

 sorted values so the index matches RES[2:0] in STM32H7_ADC_CFGR */

 stm32h7 can have up to 20 channels */

/*

 * stm32f4_sq - describe regular sequence registers

 * - L: sequence len (register & bit field)

 * - SQ1..SQ16: sequence entries (register & bit field)

 L: len bit field description to be kept as first element */

 SQ1..SQ16 registers & bit fields (reg, mask, shift) */

 STM32F4 external trigger sources for all instances */

 sentinel */

/*

 * stm32f4_smp_bits[] - describe sampling time register index & bit fields

 * Sorted so it can be indexed by channel number.

 STM32F4_ADC_SMPR2: smpr[] index, mask, shift for SMP0 to SMP9 */

 STM32F4_ADC_SMPR1, smpr[] index, mask, shift for SMP10 to SMP18 */

 STM32F4 programmable sampling time (ADC clock cycles) */

 L: len bit field description to be kept as first element */

 SQ1..SQ16 registers & bit fields (reg, mask, shift) */

 STM32H7 external trigger sources for all instances */

/*

 * stm32h7_smp_bits - describe sampling time register index & bit fields

 * Sorted so it can be indexed by channel number.

 STM32H7_ADC_SMPR1, smpr[] index, mask, shift for SMP0 to SMP9 */

 STM32H7_ADC_SMPR2, smpr[] index, mask, shift for SMP10 to SMP19 */

 STM32H7 programmable sampling time (ADC clock cycles, rounded down) */

/*

 * STM32 ADC registers access routines

 * @adc: stm32 adc instance

 * @reg: reg offset in adc instance

 *

 * Note: All instances share same base, with 0x0, 0x100 or 0x200 offset resp.

 * for adc1, adc2 and adc3.

/**

 * stm32_adc_conv_irq_enable() - Enable end of conversion interrupt

 * @adc: stm32 adc instance

/**

 * stm32_adc_conv_irq_disable() - Disable end of conversion interrupt

 * @adc: stm32 adc instance

/**

 * stm32f4_adc_start_conv() - Start conversions for regular channels.

 * @indio_dev: IIO device instance

 * @dma: use dma to transfer conversion result

 *

 * Start conversions for regular channels.

 * Also take care of normal or DMA mode. Circular DMA may be used for regular

 * conversions, in IIO buffer modes. Otherwise, use ADC interrupt with direct

 * DR read instead (e.g. read_raw, or triggered buffer mode without DMA).

 Wait for Power-up time (tSTAB from datasheet) */

 Software start ? (e.g. trigger detection disabled ?) */

 On STM32H7 IRQs are cleared by writing 1 into ISR register */

 Exit deep power down, then enable ADC voltage regulator */

 Wait for startup time */

 Setting DEEPPWD disables ADC vreg and clears ADVREGEN */

 Poll for ADRDY to be set (after adc startup time) */

 Clear ADRDY by writing one */

 Disable ADC and wait until it's effectively disabled */

/**

 * stm32h7_adc_read_selfcalib() - read calibration shadow regs, save result

 * @indio_dev: IIO device instance

 * Note: Must be called once ADC is enabled, so LINCALRDYW[1..6] are writable

 Read linearity calibration */

 Clear STM32H7_LINCALRDYW[6..1]: transfer calib to CALFACT2 */

 Poll: wait calib data to be ready in CALFACT2 register */

 Read offset calibration */

/**

 * stm32h7_adc_restore_selfcalib() - Restore saved self-calibration result

 * @indio_dev: IIO device instance

 * Note: ADC must be enabled, with no on-going conversions.

		/*

		 * Write saved calibration data to shadow registers:

		 * Write CALFACT2, and set LINCALRDYW[6..1] bit to trigger

		 * data write. Then poll to wait for complete transfer.

		/*

		 * Read back calibration data, has two effects:

		 * - It ensures bits LINCALRDYW[6..1] are kept cleared

		 *   for next time calibration needs to be restored.

		 * - BTW, bit clear triggers a read, then check data has been

		 *   correctly written.

/*

 * Fixed timeout value for ADC calibration.

 * worst cases:

 * - low clock frequency

 * - maximum prescalers

 * Calibration requires:

 * - 131,072 ADC clock cycle for the linear calibration

 * - 20 ADC clock cycle for the offset calibration

 *

 * Set to 100ms for now

/**

 * stm32h7_adc_selfcalib() - Procedure to calibrate ADC

 * @indio_dev: IIO device instance

 * Note: Must be called once ADC is out of power down.

	/*

	 * Select calibration mode:

	 * - Offset calibration for single ended inputs

	 * - No linearity calibration (do it later, before reading it)

 Start calibration, then wait for completion */

	/*

	 * Select calibration mode, then start calibration:

	 * - Offset calibration for differential input

	 * - Linearity calibration (needs to be done only once for single/diff)

	 *   will run simultaneously with offset calibration.

/**

 * stm32h7_adc_prepare() - Leave power down mode to enable ADC.

 * @indio_dev: IIO device instance

 * Leave power down mode.

 * Configure channels as single ended or differential before enabling ADC.

 * Enable ADC.

 * Restore calibration data.

 * Pre-select channels that may be used in PCSEL (required by input MUX / IO):

 * - Only one input is selected for single ended (e.g. 'vinp')

 * - Two inputs are selected for differential channels (e.g. 'vinp' & 'vinn')

 Either restore or read calibration result for future reference */

/**

 * stm32_adc_conf_scan_seq() - Build regular channels scan sequence

 * @indio_dev: IIO device

 * @scan_mask: channels to be converted

 *

 * Conversion sequence :

 * Apply sampling time settings for all channels.

 * Configure ADC scan sequence based on selected channels in scan_mask.

 * Add channels to SQR registers, from scan_mask LSB to MSB, then

 * program sequence len.

 Apply sampling time settings */

		/*

		 * Assign one channel per SQ entry in regular

		 * sequence, starting with SQ1.

 Sequence len */

/**

 * stm32_adc_get_trig_extsel() - Get external trigger selection

 * @indio_dev: IIO device structure

 * @trig: trigger

 *

 * Returns trigger extsel value, if trig matches, -EINVAL otherwise.

 lookup triggers registered by stm32 timer trigger driver */

		/**

		 * Checking both stm32 timer trigger type and trig name

		 * should be safe against arbitrary trigger names.

/**

 * stm32_adc_set_trig() - Set a regular trigger

 * @indio_dev: IIO device

 * @trig: IIO trigger

 *

 * Set trigger source/polarity (e.g. SW, or HW with polarity) :

 * - if HW trigger disabled (e.g. trig == NULL, conversion launched by sw)

 * - if HW trigger enabled, set source & polarity

 set trigger source and polarity (default to rising edge) */

/**

 * stm32_adc_single_conv() - Performs a single conversion

 * @indio_dev: IIO device

 * @chan: IIO channel

 * @res: conversion result

 *

 * The function performs a single conversion on a given channel:

 * - Apply sampling time settings

 * - Program sequencer with one channel (e.g. in SQ1 with len = 1)

 * - Use SW trigger

 * - Start conversion, then wait for interrupt completion.

 Apply sampling time settings */

 Program chan number in regular sequence (SQ1) */

 Set regular sequence len (0 for 1 conversion) */

 Trigger detection disabled (conversion can be launched in SW) */

 ADC_full_scale / 2 */

 Check ovr status right now, as ovr mask should be already disabled */

		/*

		 * Clear ovr bit to avoid subsequent calls to IRQ handler.

		 * This requires to stop ADC first. OVR bit state in ISR,

		 * is propaged to CSR register by hardware.

		/*

		 * Overrun occurred on regular conversions: data for wrong

		 * channel may be read. Unconditionally disable interrupts

		 * to stop processing data and print error message.

		 * Restarting the capture can be done by disabling, then

		 * re-enabling it (e.g. write 0, then 1 to buffer/enable).

 Reading DR also clears EOC status flag */

/**

 * stm32_adc_validate_trigger() - validate trigger for stm32 adc

 * @indio_dev: IIO device

 * @trig: new trigger

 *

 * Returns: 0 if trig matches one of the triggers registered by stm32 adc

 * driver, -EINVAL otherwise.

	/*

	 * dma cyclic transfers are used, buffer is split into two periods.

	 * There should be :

	 * - always one buffer (period) dma is working on

	 * - one buffer (period) driver can push data.

/**

 * stm32_adc_debugfs_reg_access - read or write register value

 * @indio_dev: IIO device structure

 * @reg: register offset

 * @writeval: value to write

 * @readval: value to read

 *

 * To read a value from an ADC register:

 *   echo [ADC reg offset] > direct_reg_access

 *   cat direct_reg_access

 *

 * To write a value in a ADC register:

 *   echo [ADC_reg_offset] [value] > direct_reg_access

 Residue is size in bytes from end of buffer */

 Return available bytes */

	/*

	 * In DMA mode the trigger services of IIO are not used

	 * (e.g. no call to iio_trigger_poll).

	 * Calling irq handler associated to the hardware trigger is not

	 * relevant as the conversions have already been done. Data

	 * transfers are performed directly in DMA callback instead.

	 * This implementation avoids to call trigger irq handler that

	 * may sleep, in an atomic context (DMA irq handler context).

 Prepare a DMA cyclic transaction */

 Issue pending DMA requests */

 Reset adc buffer index */

 reset buffer index */

 re-enable eoc irq */

	/*

	 * For vrefint channel, ensure that the sampling time cannot

	 * be lower than the one specified in the datasheet

 Determine sampling time (ADC clock cycles) */

 pre-build sampling time registers (e.g. smpr1, smpr2) */

 pre-build selected channels mask */

 pre-build diff channels mask */

 Also add negative input to pre-selected channels */

 Optional sample time is provided either for each, or all channels */

 Channel can't be configured both as single-ended & diff */

		/*

		 * Using of_property_read_u32_index(), smp value will only be

		 * modified if valid u32 value can be decoded. This allows to

		 * get either no value, 1 shared value for all indexes, or one

		 * value per channel.

 Prepare sampling time settings */

 Get calibration data for vrefint channel */

 label is optional */

 diff-channels is optional */

 st,min-sample-time-ns is optional */

 If no channels have been found, fallback to channels legacy properties. */

 DMA is optional: fall back to IRQ mode */

 Configure DMA channel to read data register */

		/* For PIO mode only, iio_pollfunc_store_time stores a timestamp

		 * in the primary trigger IRQ handler and stm32_adc_trigger_handler

		 * runs in the IRQ thread to push out buffer along with timestamp.

 Get stm32-adc-core PM online */

/*

 * Marvell Berlin2 ADC driver

 *

 * Copyright (C) 2015 Marvell Technology Group Ltd.

 *

 * Antoine Tenart <antoine.tenart@free-electrons.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 0-15 */

 1.25 MHz */

 2.5 MHz */

 0-125 C */

 10-50 C */

 0-15 */

 0-15 */

 4 us */

 12 us */

 external input */

 external input */

 external input */

 external input */

 reserved */

 reserved */

 temperature sensor */

 reserved */

 timestamp */

 Enable the interrupts */

 Configure the ADC */

 Disable the interrupts */

 Enable interrupts */

 Configure the ADC */

 Configure the temperature sensor */

 Disable interrupts */

 Convert to milli Celsius */

 Power up the ADC */

 SPDX-License-Identifier: GPL-2.0

/*

 * RZ/G2L A/D Converter driver

 *

 *  Copyright (c) 2021 Renesas Electronics Europe GmbH

 *

 * Author: Lad Prabhakar <prabhakar.mahadev-lad.rj@bp.renesas.com>

	/*

	 * Setup ADM1 for SW trigger

	 * EGA[13:12] - Set 00 to indicate hardware trigger is invalid

	 * BS[4] - Enable 1-buffer mode

	 * MS[1] - Enable Select mode

	 * TRG[0] - Enable software trigger mode

 Select analog input channel subjected to conversion. */

	/*

	 * Setup ADINT

	 * INTS[31] - Select pulse signal

	 * CSEEN[16] - Enable channel select error interrupt

	 * INTEN[7:0] - Select channel interrupt

 A/D conversion channel select error interrupt */

 clear the channel interrupt */

 SW reset */

 Only division by 4 can be set */

	/*

	 * Setup AMD3

	 * ADIL[31:24] - Should be always set to 0

	 * ADCMP[23:16] - Should be always set to 0xe

	 * ADSMP[15:0] - Set default (0x578) sampling period

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Analog Devices AD9467 SPI ADC driver

 *

 * Copyright 2012-2020 Analog Devices Inc.

/*

 * ADI High-Speed ADC common spi interface registers

 * See Application-Note AN-877:

 *   https://www.analog.com/media/en/technical-documentation/application-notes/AN-877.pdf

 AN877_ADC_REG_TEST_IO */

 AN877_ADC_REG_TRANSFER */

 AN877_ADC_REG_OUTPUT_MODE */

 AN877_ADC_REG_OUTPUT_PHASE */

 AN877_ADC_REG_OUTPUT_DELAY */

/*

 * Analog Devices AD9265 16-Bit, 125/105/80 MSPS ADC

/*

 * Analog Devices AD9434 12-Bit, 370/500 MSPS ADC

/*

 * Analog Devices AD9467 16-Bit, 200/250 MSPS ADC

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Driver for Linear Technology LTC2471 and LTC2473 voltage monitors

 * The LTC2473 is identical to the 2471, but reports a differential signal.

 *

 * Copyright (C) 2017 Topic Embedded Products

 * Author: Mike Looijmans <mike.looijmans@topic.nl>

 Reference voltage is 1.25V */

 Read two bytes from the I2C bus to obtain the ADC result */

 MSB first */

 Output ranges from -VREF to +VREF */

 Output ranges from 0 to VREF */

 16 data bits */

 Only differential chip has this property */

 Trigger once to start conversion and check if chip is there */

 SPDX-License-Identifier: GPL-2.0+

/*

 * NXP i.MX8QXP ADC driver

 *

 * Based on the work of Haibo Chen <haibo.chen@nxp.com>

 * The initial developer of the original code is Haibo Chen.

 * Portions created by Haibo Chen are Copyright (C) 2018 NXP.

 * All Rights Reserved.

 *

 * Copyright (C) 2018 NXP

 * Copyright (C) 2021 Cai Huoqing

 Register map definition */

 ADC bit shift */

 ADC PARAMETER*/

 Serialise ADC channel reads */

software reset, need to clear the set bit*/

 reset the fifo */

 ADC configuration */

 config the trigger control */

 config the cmd */

 set the watermark level to 1 */

 FIFO Watermark Interrupt Enable */

 adc enable */

 adc start */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0

/*

 * AD7091RX Analog to Digital converter driver

 *

 * Copyright 2014-2019 Analog Devices Inc.

 AD7091R_REG_RESULT */

 AD7091R_REG_CONF */

lock to prevent concurent reads */

 AD7091R_REG_CHANNEL specified which channels to be converted */

	/*

	 * There is a latency of one conversion before the channel conversion

	 * sequence is updated

 Use command mode by default to convert only desired channels*/

 SPDX-License-Identifier: GPL-2.0-only

/*

 * MAX1241 low-power, 12-bit serial ADC

 *

 * Datasheet: https://datasheets.maximintegrated.com/en/ds/MAX1240-MAX1241.pdf

		/*

		 * Begin conversion by bringing /CS low for at least

		 * tconv us.

		/*

		 * Then read two bytes of data in our RX buffer.

 SPDX-License-Identifier: GPL-2.0

/*

 *  STMicroelectronics STMPE811 IIO ADC Driver

 *

 *  4 channel, 10/12-bit ADC

 *

 *  Copyright (C) 2013-2018 Toradex AG <stefan.agner@toradex.com>

 We are allocating plus one for the temperature channel */

	/*

	 * absolute temp = +V3.3 * value /7.51 [K]

	 * scale to [milli °C]

 Is the interrupt relevant */

 Read value */

 Read value */

 use temp irq for each conversion completion */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * HX711: analog to digital converter for weight sensor module

 *

 * Copyright (c) 2016 Andreas Klinger <ak@it-klinger.de>

 gain to pulse and scale conversion */

/*

 * .scale depends on AVDD which in turn is known as soon as the regulator

 * is available

 * therefore we set .scale in hx711_probe()

 *

 * channel A in documentation is channel 0 in source code

 * channel B in documentation is channel 1 in source code

 gain set on device */

 gain for channel A */

	/*

	 * triggered buffer

	 * 2x32-bit channel + 64-bit naturally aligned timestamp

	/*

	 * delay after a rising edge on SCK until the data is ready DOUT

	 * this is dependent on the hx711 where the datasheet tells a

	 * maximum value of 100 ns

	 * but also on potential parasitic capacities on the wiring

	/*

	 * if preempted for more then 60us while PD_SCK is high:

	 * hx711 is going in reset

	 * ==> measuring is false

	/*

	 * wait until DOUT is ready

	 * it turned out that parasitic capacities are extending the time

	 * until DOUT has reached it's value

	/*

	 * here we are not waiting for 0.2 us as suggested by the datasheet,

	 * because the oscilloscope showed in a test scenario

	 * at least 1.15 us for PD_SCK high (T3 in datasheet)

	 * and 0.56 us for PD_SCK low on TI Sitara with 800 MHz

	/*

	 * make it a square wave for addressing cases with capacitance on

	 * PC_SCK

 sample as late as possible */

 we double check if it's really down */

	/*

	 * in some rare cases the reset takes quite a long time

	 * especially when the channel is changed.

	 * Allow up to one second for it

 sleep at least 10 ms */

		/*

		 * an examination with the oszilloscope indicated

		 * that the first value read after the reset is not stable

		 * if we reset too short;

		 * the shorter the reset cycle

		 * the less reliable the first value after reset is;

		 * there were no problems encountered with a value

		 * of 10 ms or higher

 after a reset the gain is 128 */

	/*

	 * hx711_reset() must be called from here

	 * because it could be calling hx711_read() by itself

		/*

		 * a scale greater than 1 mV per LSB is not possible

		 * with the HX711, therefore val must be 0

	/*

	 * PD_SCK stands for power down and serial clock input of HX711

	 * in the driver it is an output

	/*

	 * DOUT stands for serial data output of HX711

	 * for the driver it is an input

	/*

	 * with

	 * full scale differential input range: AVDD / GAIN

	 * full scale output data: 2^24

	 * we can say:

	 *     AVDD / GAIN = 2^24

	 * therefore:

	 *     1 LSB = AVDD / GAIN / 2^24

	 * AVDD is in uV, but we need 10^-9 mV

	 * approximately to fit into a 32 bit number:

	 * 1 LSB = (AVDD * 100) / GAIN / 1678 [10^-9 mV]

 we need 10^-9 mV */

	/*

	 * datasheet says the high level of PD_SCK has a maximum duration

	 * of 50 microseconds

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * MP2629 Driver for ADC

 *

 * Copyright 2020 Monolithic Power Systems, Inc

 *

 * Author: Saravanan Sekar <sravanhome@gmail.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ST SPEAr ADC driver

 *

 * Copyright 2012 Stefan Roese <sr@denx.de>

 SPEAR registers definitions */

 Bit definitions for SPEAR_ADC_STATUS */

 Not avail for 1340 & 1310 */

	/*

	 * Lock to protect the device state during a potential concurrent

	 * read access from userspace. Reading a raw value requires a sequence

	 * of register writes, then a wait for a completion callback,

	 * and finally a register read, during which userspace could issue

	 * another read request. This lock protects a read access from

	 * ocurring before another one has finished.

/*

 * Functions to access some SPEAr ADC register. Abstracted into

 * static inline functions, because of different register offsets

 * on different SoC variants (SPEAr300 vs SPEAr600 etc).

 set by ISR */

 Read value to clear IRQ */

 Reset ADC core */

	/*

	 * SPEAr600 has a different register layout than other SPEAr SoC's

	 * (e.g. SPEAr3xx). Let's provide two register base addresses

	 * to support multi-arch kernels.

	/*

	 * Optional avg_samples defaults to 0, resulting in single data

	 * conversion

	/*

	 * Optional vref_external defaults to 0, resulting in internal vref

	 * selection

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0

/*

 * Texas Instruments ADS7950 SPI ADC driver

 *

 * Copyright 2016 David Lechner <david@lechnology.com>

 *

 * Based on iio/ad7923.c:

 * Copyright 2011 Analog Devices Inc

 * Copyright 2012 CS Systemes d'Information

 *

 * And also on hwmon/ads79xx.c

 * Copyright (C) 2013 Texas Instruments Incorporated - https://www.ti.com/

 *	Nishanth Menon

/*

 * In case of ACPI, we use the 5000 mV as default for the reference pin.

 * Device tree users encode that via the vref-supply regulator.

 val = value, dec = left shift, bits = number of bits of the mask */

 Manual mode configuration */

 GPIO mode configuration */

 Lock to protect the spi xfer buffers */

	/*

	 * Bitmask of lower 7 bits used for configuration

	 * These bits only can be written when TI_ADS7950_CR_WRITE

	 * is set, otherwise it retains its original state.

	 * [0-3] GPIO signal

	 * [4]   Set following frame to return GPIO signal values

	 * [5]   Powers down device

	 * [6]   Sets Vref range1(2.5v) or range2(5v)

	 *

	 * Bits present on Manual/Auto1/Auto2 commands

	/*

	 * Bitmask of GPIO command

	 * [0-3] GPIO direction

	 * [4-6] Different GPIO alarm mode configurations

	 * [7]   GPIO 2 as device range input

	 * [8]   GPIO 3 as device power down input

	 * [9]   Reset all registers

	 * [10-11] N/A

	/*

	 * DMA (thus cache coherency maintenance) requires the

	 * transfer buffers to live in their own cache lines.

/*

 * ti_ads7950_update_scan_mode() setup the spi transfer buffer for the new

 * scan mask

 Data for the 1st channel is not returned until the 3rd transfer */

 If set as output, return the output */

 GPIO data bit sets SDO bits 12-15 to GPIO input */

 Revert back to original settings */

 Bitmask is inverted from GPIO framework 0=input/1=output */

 Only change direction if needed */

 Settings for Manual/Auto1/Auto2 commands */

 Default to 5v ref */

 Settings for GPIO command */

 build spi ring message */

 len will be set later */

	/*

	 * Setup default message. The sample is read at the end of the first

	 * transfer, then it takes one full cycle to convert the sample and one

	 * more cycle to send the value. The conversion process is driven by

	 * the SPI clock, which is why we have 3 transfers. The middle one is

	 * just dummy data sent while the chip is converting the sample that

	 * was read at the end of the first transfer.

 Use hard coded value for reference voltage in ACPI case */

 Add GPIO chip */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Driver for ADC module on the Cirrus Logic EP93xx series of SoCs

 *

 * Copyright (C) 2015 Alexander Sverdlin

 *

 * The driver uses polling to get the conversion status. According to EP93xx

 * datasheets, reading ADCResult register starts the conversion, but user is also

 * responsible for ensuring that delay between adjacent conversion triggers is

 * long enough so that maximum allowed conversion rate is not exceeded. This

 * basically renders IRQ mode unusable.

/*

 * This code could benefit from real HR Timers, but jiffy granularity would

 * lower ADC conversion rate down to CONFIG_HZ, so we fallback to busy wait

 * in such case.

 *

 * HR Timers-based version loads CPU only up to 10% during back to back ADC

 * conversion, while busy wait-based version consumes whole CPU power.

/*

 * Numbering scheme for channels 0..4 is defined in EP9301 and EP9302 datasheets.

 * EP9307, EP9312 and EP9312 have 3 channels more (total 8), but the numbering is

 * not defined. So the last three are numbered randomly, let's say.

			/*

			 * Switch register is software-locked, unlocking must be

			 * immediately followed by write

			/*

			 * Settling delay depends on module clock and could be

			 * 2ms or 500us

 Start the conversion, eventually discarding old result */

 Ensure maximum conversion rate is not exceeded */

 At this point conversion must be completed, but anyway... */

 According to datasheet, range is -25000..25000 */

 Typical supply voltage is 3.3v */

		/*

		 * This is actually a place for improvement:

		 * EP93xx ADC supports two clock divisors -- 4 and 16,

		 * resulting in conversion rates 3750 and 925 samples per second

		 * with 500us or 2ms settling time respectively.

		 * One might find this interesting enough to be configurable.

		/*

		 * We can tolerate rate setting failure because the module should

		 * work in any case.

 SPDX-License-Identifier: GPL-2.0

/*

 * AD7606 Parallel Interface ADC driver

 *

 * Copyright 2011 Analog Devices Inc.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * AD7887 SPI ADC driver

 *

 * Copyright 2010-2011 Analog Devices Inc.

 on-chip reference disable */

 dual-channel mode */

 convert on channel 1, DUAL=1 */

 convert on channel 0, DUAL=0,1 */

 CS based shutdown */

 full on */

 auto shutdown after conversion */

 standby mode */

/**

 * struct ad7887_chip_info - chip specifc information

 * @int_vref_mv:	the internal reference voltage

 * @channels:		channels specification

 * @num_channels:	number of channels

 * @dual_channels:	channels specification in dual mode

 * @num_dual_channels:	number of channels in dual mode

	/*

	 * DMA (thus cache coherency maintenance) requires the

	 * transfer buffers to live in their own cache lines.

	 * Buffer needs to be large enough to hold two 16 bit samples and a

	 * 64 bit aligned 64 bit timestamp.

 We know this is a single long so can 'cheat' */

 Dummy read: push CH1 setting down to hardware */

 dummy read: restore default CH0 settin */

	/*

	 * More devices added in future

 Setup default message */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  exynos_adc.c - Support for ADC in EXYNOS SoCs

 *

 *  8 ~ 10 channel, 10/12-bit ADC

 *

 *  Copyright (C) 2013 Naveen Krishna Chatradhi <ch.naveen@samsung.com>

 S3C/EXYNOS4412/5250 ADC_V1 registers definitions */

 S3C2410 ADC registers definitions */

 Future ADC_V2 registers definitions */

 Bit definitions for ADC_V1 */

 Bit definitions for S3C2410 ADC */

 touch screen always uses channel 0 */

 ADCTSC Register Bits */

 Bit definitions for ADC_V2 */

 Bit definitions common for ADC_V1 and ADC_V2 */

	/*

	 * Lock to protect from potential concurrent access to the

	 * completion callback during a manual conversion. For this driver

	 * a wait-callback is used to wait for the conversion result,

	 * so in the meantime no other read request (or conversion start)

	 * must be performed, otherwise it would interfere with the

	 * current conversion result.

 set default prescaler values and Enable prescaler */

 Enable 12-bit ADC resolution */

 set touchscreen delay */

 Exynos4212 and 4412 is like ADCv1 but with four channels only */

 12 bit ADC resolution */

 12 bit ADC resolution */

 12 bit ADC resolution */

 Enable 12 bit ADC resolution */

 Select channel for S3C2416 */

 12 bit ADC resolution */

 Select channel for S3C2433 */

 10 bit ADC resolution */

 10 bit ADC resolution */

 12 bit ADC resolution */

 Enable interrupts */

 12 bit ADC resolution */

 12 bit ADC resolution */

 Enable interrupts */

 12 bit ADC resolution */

 Regulator voltage is in uV, but need mV */

 Select the channel to be used and Trigger conversion */

 Select the ts channel to be used and Trigger conversion */

 Read value */

 clear irq */

/*

 * Here we (ab)use a threaded interrupt handler to stay running

 * for as long as the touchscreen remains pressed, we report

 * a new event with the latest data and then sleep until the

 * next timer tick. This mirrors the behavior of the old

 * driver, with much less code.

 leave out any TS related code if unreachable */

 SPDX-License-Identifier: GPL-2.0-only

/* ADC driver for AXP20X and AXP22X PMICs

 *

 * Copyright (c) 2016 Free Electrons NextThing Co.

 *	Quentin Schulz <quentin.schulz@free-electrons.com>

 sentinel */ }

 sentinel */ }

/*

 * Channels are mapped by physical system. Their channels share the same index.

 * i.e. acin_i is in_current0_raw and acin_v is in_voltage0_raw.

 * The only exception is for the battery. batt_v will be in_voltage6_raw and

 * charge current in_current6_raw and discharge current will be in_current7_raw.

	/*

	 * N.B.:  Unlike the Chinese datasheets tell, the charging current is

	 * stored on 12 bits, not 13 bits. Only discharging current is on 13

	 * bits.

	/*

	 * N.B.: Unlike the Chinese datasheets tell, the charging current is

	 * stored on 12 bits, not 13 bits. Only discharging current is on 13

	 * bits.

	/*

	 * The AXP20X PMIC allows the user to choose between 0V and 0.7V offsets

	 * for (independently) GPIO0 and GPIO1 when in ADC mode.

 sentinel */ }

 sentinel */ },

 Enable the ADCs on IP */

 Enable GPIO0/1 and internal temperature ADCs */

 Configure ADCs rate */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ltc2497-core.c - Common code for Analog Devices/Linear Technology

 * LTC2496 and LTC2497 ADCs

 *

 * Copyright (C) 2017 Analog Devices Inc.

		/* delay if conversion time not passed

		 * since last read or write

		/* We're in automatic mode -

		 * so the last reading is still not outdated

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2017 Axis Communications AB

 *

 * Driver for Texas Instruments' ADC084S021 ADC chip.

 * Datasheets can be found here:

 * https://www.ti.com/lit/ds/symlink/adc084s021.pdf

 Buffer used to align data */

	/*

	 * DMA (thus cache coherency maintenance) requires the

	 * transfer buffers to live in their own cache line.

 First 16-bits are trash */

/**

 * adc084s021_adc_conversion() - Read an ADC channel and return its value.

 *

 * @adc: The ADC SPI data.

 * @data: Buffer for converted data.

 Discard first word */

 Do the transfer */

/**

 * adc084s021_buffer_trigger_handler() - Read ADC channels and push to buffer.

 *

 * @irq: The interrupt number (not used).

 * @pollfunc: Pointer to the poll func.

 Trash + channels */

 Trash + single channel */

 Initiate the Industrial I/O device */

 Create SPI transfer for channel reads */

 Trash + single channel */

 Setup triggered buffer with pollfunction */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *

 * TWL4030 MADC module driver-This driver monitors the real time

 * conversion of analog signals like battery temperature,

 * battery type, battery level etc.

 *

 * Copyright (C) 2011 Texas Instruments Incorporated - https://www.ti.com/

 * J Keerthy <j-keerthy@ti.com>

 *

 * Based on twl4030-madc.c

 * Copyright (C) 2008 Nokia Corporation

 * Mikko Ylinen <mikko.k.ylinen@nokia.com>

 *

 * Amit Kucheria <amit.kucheria@canonical.com>

 MADC power on */

 MADC busy */

 MADC conversion completion */

 MADC SWx start conversion */

 Fixed channels */

 Step size and prescaler ratio */

 Register and bits for GPBR1 register */

/**

 * struct twl4030_madc_request - madc request packet for channel conversion

 * @channels:	16 bit bitmap for individual channels

 * @do_avg:	sample the input channel for 4 consecutive cycles

 * @method:	RT, SW1, SW2

 * @type:	Polling or interrupt based method

 * @active:	Flag if request is active

 * @result_pending: Flag from irq handler, that result is ready

 * @raw:	Return raw value, do not convert it

 * @rbuf:	Result buffer

/**

 * struct twl4030_madc_data - a container for madc info

 * @dev:		Pointer to device structure for madc

 * @lock:		Mutex protecting this data structure

 * @usb3v1:		Pointer to bias regulator for madc

 * @requests:		Array of request struct corresponding to SW1, SW2 and RT

 * @use_second_irq:	IRQ selection (main or co-processor)

 * @imr:		Interrupt mask register of MADC

 * @isr:		Interrupt status register of MADC

 CHANNEL 0 No Prescaler */

 CHANNEL 1 No Prescaler */

 CHANNEL 2 */

 CHANNEL 3 */

 CHANNEL 4 */

 CHANNEL 5 */

 CHANNEL 6 */

 CHANNEL 7 */

 CHANNEL 8 */

 CHANNEL 9 */

 CHANNEL 10 No Prescaler */

 CHANNEL 11 */

 CHANNEL 12 */

 CHANNEL 13 Reserved channels */

 CHANNEL 14 Reseved channels */

 CHANNEL 15 */

 Conversion table from -3 to 55 degrees Celcius */

/*

 * Structure containing the registers

 * of different conversion methods supported by MADC.

 * Hardware or RT real time conversion request initiated by external host

 * processor for RT Signal conversions.

 * External host processors can also request for non RT conversions

 * SW1 and SW2 software conversions also called asynchronous or GPC request.

/**

 * twl4030_madc_channel_raw_read() - Function to read a particular channel value

 * @madc:	pointer to struct twl4030_madc_data

 * @reg:	lsb of ADC Channel

 *

 * Return: 0 on success, an error code otherwise.

	/*

	 * For each ADC channel, we have MSB and LSB register pair. MSB address

	 * is always LSB address+1. reg parameter is the address of LSB register

/*

 * Return battery temperature in degrees Celsius

 * Or < 0 on failure.

 Getting and calculating the supply current in micro amperes */

 Getting and calculating the thermistor resistance in ohms */

 calculating temperature */

 slope of 0.44 mV/mA */

 slope of 0.88 mV/mA */

/*

 * Function to read channel values

 * @madc - pointer to twl4030_madc_data struct

 * @reg_base - Base address of the first channel

 * @Channels - 16 bit bitmap. If the bit is set, channel's value is read

 * @buf - The channel values are stored here. if read fails error

 * @raw - Return raw values without conversion

 * value is stored

 * Returns the number of successfully read channels.

			/* Analog Input (V) = conv_result * step_size / R

			 * conv_result = decimal value of 10-bit conversion

			 *		 result

			 * step size = 1.5 / (2 ^ 10 -1)

			 * R = Prescaler ratio for input channels.

			 * Result given in mV hence multiplied by 1000.

/*

 * Disables irq.

 * @madc - pointer to twl4030_madc_data struct

 * @id - irq number to be disabled

 * can take one of TWL4030_MADC_RT, TWL4030_MADC_SW1, TWL4030_MADC_SW2

 * corresponding to RT, SW1, SW2 conversion requests.

 * Returns error if i2c read/write fails.

 No pending results for this method, move to next one */

 Read results */

 Free request */

	/*

	 * In case of error check whichever request is active

	 * and service the same.

 Read results */

 Free request */

/*

 * Function which enables the madc conversion

 * by writing to the control register.

 * @madc - pointer to twl4030_madc_data struct

 * @conv_method - can be TWL4030_MADC_RT, TWL4030_MADC_SW2, TWL4030_MADC_SW1

 * corresponding to RT SW1 or SW2 conversion methods.

 * Returns 0 if succeeds else a negative error value

/*

 * Function that waits for conversion to be ready

 * @madc - pointer to twl4030_madc_data struct

 * @timeout_ms - timeout value in milliseconds

 * @status_reg - ctrl register

 * returns 0 if succeeds else a negative error value

/*

 * An exported function which can be called from other kernel drivers.

 * @req twl4030_madc_request structure

 * req->rbuf will be filled with read values of channels based on the

 * channel index. If a particular channel reading fails there will

 * be a negative error value in the corresponding array element.

 * returns 0 if succeeds else error value

 Do we have a conversion request ongoing */

 Select channels to be converted */

 Select averaging for all channels if do_avg is set */

 With RT method we should not be here anymore */

 Wait until conversion is ready (ctrl register returns EOC) */

/**

 * twl4030_madc_set_current_generator() - setup bias current

 *

 * @madc:	pointer to twl4030_madc_data struct

 * @chan:	can be one of the two values:

 *		0 - Enables bias current for main battery type reading

 *		1 - Enables bias current for main battery temperature sensing

 * @on:		enable or disable chan.

 *

 * Function to enable or disable bias current for

 * main battery type reading or temperature sensing

/*

 * Function that sets MADC software power on bit to enable MADC

 * @madc - pointer to twl4030_madc_data struct

 * @on - Enable or disable MADC software power on bit.

 * returns error if i2c read/write fails else 0

/*

 * Initialize MADC and request for threaded irq

	/*

	 * Phoenix provides 2 interrupt lines. The first one is connected to

	 * the OMAP. The other one can be connected to the other processor such

	 * as modem. Hence two separate ISR and IMR registers.

 Check that MADC clock is on */

 If MADC clk is not on, turn it on */

 Configure MADC[3:6] */

 Enable 3v1 bias regulator for MADC[3:6] */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * palmas-adc.c -- TI PALMAS GPADC.

 *

 * Copyright (c) 2013, NVIDIA Corporation. All rights reserved.

 *

 * Author: Pradeep Goudagunta <pgoudagunta@nvidia.com>

 calibration codes and regs */

 lower ideal code */

 higher ideal code */

 expected lower volt reading */

 expected higher volt reading */

 register number for lower trim */

 register number for upper trim */

 calculated from above (after reading trim regs) */

 calculated from above (after reading trim regs) */

 calculated from above (after reading trim regs) */

 if channel has calibration data */

/*

 * struct palmas_gpadc - the palmas_gpadc structure

 * @ch0_current:	channel 0 current source setting

 *			0: 0 uA

 *			1: 5 uA

 *			2: 15 uA

 *			3: 20 uA

 * @ch3_current:	channel 0 current source setting

 *			0: 0 uA

 *			1: 10 uA

 *			2: 400 uA

 *			3: 800 uA

 * @extended_delay:	enable the gpadc extended delay mode

 * @auto_conversion_period:	define the auto_conversion_period

 * @lock:	Lock to protect the device state during a potential concurrent

 *		read access from userspace. Reading a raw value requires a sequence

 *		of register writes, then a wait for a completion callback,

 *		and finally a register read, during which userspace could issue

 *		another read request. This lock protects a read access from

 *		ocurring before another one has finished.

 *

 * This is the palmas_gpadc structure to store run-time information

 * and pointers for this driver instance.

/*

 * GPADC lock issue in AUTO mode.

 * Impact: In AUTO mode, GPADC conversion can be locked after disabling AUTO

 *	   mode feature.

 * Details:

 *	When the AUTO mode is the only conversion mode enabled, if the AUTO

 *	mode feature is disabled with bit GPADC_AUTO_CTRL.  AUTO_CONV1_EN = 0

 *	or bit GPADC_AUTO_CTRL.  AUTO_CONV0_EN = 0 during a conversion, the

 *	conversion mechanism can be seen as locked meaning that all following

 *	conversion will give 0 as a result.  Bit GPADC_STATUS.GPADC_AVAILABLE

 *	will stay at 0 meaning that GPADC is busy.  An RT conversion can unlock

 *	the GPADC.

 *

 * Workaround(s):

 *	To avoid the lock mechanism, the workaround to follow before any stop

 *	conversion request is:

 *	Force the GPADC state machine to be ON by using the GPADC_CTRL1.

 *		GPADC_FORCE bit = 1

 *	Shutdown the GPADC AUTO conversion using

 *		GPADC_AUTO_CTRL.SHUTDOWN_CONV[01] = 0.

 *	After 100us, force the GPADC state machine to be OFF by using the

 *		GPADC_CTRL1.  GPADC_FORCE bit = 0

 gain error calculation */

 gain calculation */

 offset Calculation */

 set the current source 0 (value 0/5/15/20 uA => 0..3) */

 set the current source 3 (value 0/10/400/800 uA => 0..3) */

 end */ }

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * AD7766/AD7767 SPI ADC driver

 *

 * Copyright 2016 Analog Devices Inc.

	/*

	 * DMA (thus cache coherency maintenance) requires the

	 * transfer buffers to live in their own cache lines.

	 * Make the buffer large enough for one 24 bit sample and one 64 bit

	 * aligned 64 bit timestamp.

/*

 * AD7766 and AD7767 variations are interface compatible, the main difference is

 * analog performance. Both parts will use the same ID.

	/*

	 * The PD pin is synchronous to the clock, so give it some time to

	 * notice the change before we disable the clock.

		/*

		 * The device generates interrupts as long as it is powered up.

		 * Some platforms might not allow the option to power it down so

		 * don't enable the interrupt to avoid extra load on the system

 First byte always 0 */

 SPDX-License-Identifier: GPL-2.0

/*

 * iio/adc/max11100.c

 * Maxim max11100 ADC Driver with IIO interface

 *

 * Copyright (C) 2016-17 Renesas Electronics Corporation

 * Copyright (C) 2016-17 Jacopo Mondi

/*

 * LSB is the ADC single digital step

 * 1 LSB = (vref_mv / 2 ^ 16)

 *

 * LSB is used to calculate analog voltage value

 * from the number of ADC steps count

 *

 * Ain = (count * LSB)

	/*

	 * DMA (thus cache coherency maintenance) requires the

	 * transfer buffers to live in their own cache lines.

 [0] */

 the first 8 bits sent out from ADC must be 0s */

 dummy regulator "get_voltage" returns -EINVAL */

 SPDX-License-Identifier: GPL-2.0

/*

 * AD7091R5 Analog to Digital converter driver

 *

 * Copyright 2014-2019 Analog Devices Inc.

 SPDX-License-Identifier: GPL-2.0

/*

 * Analog Devices AD7466/7/8 AD7476/5/7/8 (A) SPI ADC driver

 * TI ADC081S/ADC101S/ADC121S 8/10/12-bit SPI ADC driver

 *

 * Copyright 2010 Analog Devices Inc.

 channels used when convst gpio is defined */

	/*

	 * DMA (thus cache coherency maintenance) requires the

	 * transfer buffers to live in their own cache lines.

	 * Make the buffer large enough for one 16 bit sample and one 64 bit

	 * aligned 64 bit timestamp.

 CONVST pulse width: 10 ns min */

 Conversion time: 650 ns max */

 Any transfers with 8 scl cycles will reset the device */

 Either vcc or vref (below) as appropriate */

 If a device has an internal reference vref is optional */

			/*

			 * Can only get here if device supports both internal

			 * and external reference, but the regulator connected

			 * to the external reference is not connected.

			 * Set the reference regulator pointer to NULL to

			 * indicate this.

 Setup default message */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ltc2496.c - Driver for Analog Devices/Linear Technology LTC2496 ADC

 *

 * Based on ltc2497.c which has

 * Copyright (C) 2017 Analog Devices Inc.

 *

 * Licensed under the GPL-2.

 *

 * Datasheet: https://www.analog.com/media/en/technical-documentation/data-sheets/2496fc.pdf

 this must be the first member */

	/*

	 * DMA (thus cache coherency maintenance) requires the

	 * transfer buffers to live in their own cache lines.

 SPDX-License-Identifier: GPL-2.0

/*

 * AD7606 SPI ADC driver

 *

 * Copyright 2011 Analog Devices Inc.

 VDRIVE above 4.75 V */

/*

 * Range of channels from a group are stored in 2 registers.

 * 0, 1, 2, 3 in a register followed by 4, 5, 6, 7 in second register.

 * For channels from second group(8-15) the order is the same, only with

 * an offset of 2 for register address.

 The range of the channel is stored in 2 bits */

/*

 * Range for AD7606B channels are stored in registers starting with address 0x3.

 * Each register stores range for 2 channels(4 bits per channel).

	/*

	 * The address of register consist of one w/r bit

	 * 6 bits of address followed by one reserved bit.

	/*

	 * The address of register consists of one bit which

	 * specifies a read command placed in bit 6, followed by

	 * 6 bits of address.

	/*

	 * Ad7616 has 16 channels divided in group A and group B.

	 * The range of channels from A are stored in registers with address 4

	 * while channels from B are stored in register with address 6.

	 * The last bit from channels determines if it is from group A or B

	 * because the order of channels in iio is 0A, 0B, 1A, 1B...

 channel A */

 channel B */

 0b01 for 2.5v, 0b10 for 5v and 0b11 for 10v */

	/*

	 * Scale can be configured individually for each channel

	 * in software mode.

 Activate Burst mode and SEQEN MODE */

	/*

	 * Software mode is enabled when all three oversampling

	 * pins are set to high. If oversampling gpios are defined

	 * in the device tree, then they need to be set to high,

	 * otherwise, they must be hardwired to VDD

 OS of 128 and 256 are available only in software mode */

 Configure device spi to output on a single channel */

	/*

	 * Scale can be configured individually for each channel

	 * in software mode.

 SPDX-License-Identifier: GPL-2.0+

/*

 *  lpc32xx_adc.c - Support for ADC in LPC32XX

 *

 *  3-channel, 10-bit ADC

 *

 *  Copyright (C) 2011, 2012 Roland Stigge <stigge@antcom.de>

/*

 * LPC32XX registers definitions

 Bit definitions for LPC32XXAD_SELECT: */

 constant, always write this value! */

 constant, always write this value! */

 multiple of this is the channel number: 0, 1, 2 */

 constant, always write this value! */

 Bit definitions for LPC32XXAD_CTRL: */

 Bit definitions for LPC32XXAD_VALUE: */

 Measurement setup */

 Trigger conversion */

 set by ISR */

 Read value and clear irq */

 SPDX-License-Identifier: GPL-2.0

/*

 * Generic sigma delta modulator driver

 *

 * Copyright (C) 2017, STMicroelectronics - All Rights Reserved

 * Author: Arnaud Pouliquen <arnaud.pouliquen@st.com>.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Nuvoton Technology corporation.

	/*

	 * Lock to protect the device state during a potential concurrent

	 * read access from userspace. Reading a raw value requires a sequence

	 * of register writes, then a wait for a event and finally a register

	 * read, during which userspace could issue another read request.

	 * This lock protects a read access from ocurring before another one

	 * has finished.

 ADC registers */

 ADCCON Register Bits */

 ADC General Definition */

 Select ADC channel */

 if conversion failed - reset ADC module */

 Enable ADC and start conversion module */

 sentinel */ }

 calculate ADC clock sample rate */

		/*

		 * Any error which is not ENODEV indicates the regulator

		 * has been specified and so is a failure case.

 Use internal reference */

 Enable the ADC Module */

 Start ADC conversion */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2014-2015 Pengutronix, Markus Pargmann <mpa@pengutronix.de>

 *

 * This is the driver for the imx25 GCQ (Generic Conversion Queue)

 * connected to the imx25 ADC.

	/*

	 * Lock to protect the device state during a potential concurrent

	 * read access from userspace. Reading a raw value requires a sequence

	 * of register writes, then a wait for a completion callback,

	 * and finally a register read, during which userspace could issue

	 * another read request. This lock protects a read access from

	 * ocurring before another one has finished.

 Disable conversion queue run */

 Acknowledge all possible irqs */

 Setup the configuration we want to use */

 Trigger queue for one run */

	/*

	 * Setup all configurations registers with a default conversion

	 * configuration for each input

 Conversion from uV to mV */

		/*

		 * Shift the read values to the correct positions within the

		 * register.

 Sentinel */ }

 SPDX-License-Identifier: GPL-2.0-only

/*

 * AD7298 SPI ADC driver

 *

 * Copyright 2011 Analog Devices Inc.

 write to the control register */

 repeated conversion enable */

 channel select */

 temperature conversion enable */

 external reference enable */

 temperature sensor averaging enable */

 partial power down enable */

	/*

	 * DMA (thus cache coherency maintenance) requires the

	 * transfer buffers to live in their own cache lines.

/*

 * ad7298_update_scan_mode() setup the spi transfer buffer for the new scan mask

 Now compute overall size */

 build spi ring message */

 make sure last transfer cs_change is not set */

 sleep > 100us */

 Setup default message */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014-2015 Imagination Technologies Ltd.

 Registers */

/*

 * As per device specification, wait six clock cycles after power-up to

 * activate START. Since adding two more clock cycles delay does not

 * impact the performance too much, we are adding two additional cycles delay

 * intentionally here.

 Channel selection and mode of operation */

 Read the 10 bit output register */

 Calculate delay step for eoc and sampled data */

 Calculate delay step for eoc and sampled data */

	/*

	 * There is only one register to power-up/power-down the AUX ADC.

	 * If the ADC is shared among multiple CPUs, always power it up here.

	 * If the ADC is used only by the MIPS, power-up/power-down at runtime.

 Setup the ADC channels available on the device */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * TI ADC108S102 SPI ADC driver

 *

 * Copyright (c) 2013-2015 Intel Corporation.

 * Copyright (c) 2017 Siemens AG

 *

 * This IIO device driver is designed to work with the following

 * analog to digital converters from Texas Instruments:

 *  ADC108S102

 *  ADC128S102

 * The communication with ADC chip is via the SPI bus (mode 3).

/*

 * In case of ACPI, we use the hard-wired 5000 mV of the Galileo and IOT2000

 * boards as default for the reference pin VA. Device tree users encode that

 * via the vref-supply regulator.

/*

 * Defining the ADC resolution being 12 bits, we can use the same driver for

 * both ADC108S102 (10 bits resolution) and ADC128S102 (12 bits resolution)

 * chips. The ADC108S102 effectively returns a 12-bit result with the 2

 * least-significant bits unset.

/*

 * 16-bit SPI command format:

 *   [15:14] Ignored

 *   [13:11] 3-bit channel address

 *   [10:0]  Ignored

/*

 * 16-bit SPI response format:

 *   [15:12] Zeros

 *   [11:0]  12-bit ADC sample (for ADC108S102, [1:0] will always be 0).

 SPI transfer used by triggered buffer handler*/

 SPI transfer used by direct scan */

 SPI message used by ring_xfer SPI transfer */

 SPI message used by scan_single_xfer SPI transfer */

	/*

	 * SPI message buffers:

	 *  tx_buf: |C0|C1|C2|C3|C4|C5|C6|C7|XX|

	 *  rx_buf: |XX|R0|R1|R2|R3|R4|R5|R6|R7|tt|tt|tt|tt|

	 *

	 *  tx_buf: 8 channel read commands, plus 1 dummy command

	 *  rx_buf: 1 dummy response, 8 channel responses

	/*

	 * Fill in the first x shorts of tx_buf with the number of channels

	 * enabled for sampling by the triggered buffer.

 One dummy command added, to clock in the last response */

 build SPI ring message */

 Skip the dummy response in the first slot */

 Skip the dummy response in the first slot */

 Setup default message */

 SPDX-License-Identifier: GPL-2.0+

/*

 * ti-adc161s626.c - Texas Instruments ADC161S626 1-channel differential ADC

 *

 * ADC Devices Supported:

 *  adc141s626 - 14-bit ADC

 *  adc161s626 - 16-bit ADC

 *

 * Copyright (C) 2016-2018

 * Author: Matt Ranostay <matt.ranostay@konsulko.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * MAX1117/MAX1118/MAX1119 8-bit, dual-channel ADCs driver

 *

 * Copyright (c) 2017 Akinobu Mita <akinobu.mita@gmail.com>

 *

 * Datasheet: https://datasheets.maximintegrated.com/en/ds/MAX1117-MAX1119.pdf

 *

 * SPI interface connections

 *

 * SPI                MAXIM

 * Master  Direction  MAX1117/8/9

 * ------  ---------  -----------

 * nCS        -->     CNVST

 * SCK        -->     SCLK

 * MISO       <--     DOUT

 * ------  ---------  -----------

 Ensure natural alignment of buffer elements */

		/*

		 * To select CH1 for conversion, CNVST pin must be brought high

		 * and low for a second time.

 > CNVST Low Time 100 ns */

		/*

		 * The acquisition interval begins with the falling edge of

		 * CNVST.  The total acquisition and conversion process takes

		 * <7.5us.

	/*

	 * To reinitiate a conversion on CH0, it is necessary to allow for a

	 * conversion to be complete and all of the data to be read out.  Once

	 * a conversion has been completed, the MAX1117/MAX1118/MAX1119 will go

	 * into AutoShutdown mode until the next conversion is initiated.

 SPDX-License-Identifier: GPL-2.0-only

 /*

  * iio/adc/max1027.c

  * Copyright (C) 2014 Philippe Reynes

  *

  * based on linux/drivers/iio/ad7923.c

  * Copyright 2011 Analog Devices Inc (from AD7923 Driver)

  * Copyright 2012 CS Systemes d'Information

  *

  * max1027.c

  *

  * Partial support for max1027 and similar chips.

 conversion register */

 setup register */

 averaging register */

 Device can achieve 300ksps so we assume a 3.33us conversion delay */

/*

 * These devices are able to scan from 0 to N, N being the highest voltage

 * channel requested by the user. The temperature can be included or not,

 * but cannot be retrieved alone. Based on the below

 * ->available_scan_masks, the core will select the most appropriate

 * ->active_scan_mask and the "minimum" number of channels will be

 * scanned and pushed to the buffers.

 *

 * For example, if the user wants channels 1, 4 and 5, all channels from

 * 0 to 5 will be scanned and pushed to the IIO buffers. The core will then

 * filter out the unneeded samples based on the ->active_scan_mask that has

 * been selected and only channels 1, 4 and 5 will be available to the user

 * in the shared buffer.

 Scan from chan 0 to the highest requested channel. Include temperature on demand. */

	/*

	 * Start acquisition on:

	 * MODE0: external hardware trigger wired to the cnvst input pin

	 * MODE2: conversion register write

 Configure conversion register with the requested chan */

	/*

	 * For an unknown reason, when we use the mode "10" (write

	 * conversion register), the interrupt doesn't occur every time.

	 * So we just wait the maximum conversion time and deliver the value.

 Read result */

	/*

	 * In order to disable the convst trigger, start acquisition on

	 * conversion register write, which basically disables triggering

	 * conversions upon cnvst changes and thus has the effect of disabling

	 * the external hardware trigger.

 fill buffer with all channel */

	/*

	 * If buffers are disabled (raw read) or when using external triggers,

	 * we just need to unlock the waiters which will then handle the data.

	 *

	 * When using the internal trigger, we must hand-off the choice of the

	 * handler to the core which will then lookup through the interrupt tree

	 * for the right handler registered with iio_triggered_buffer_setup()

	 * to execute, as this trigger might very well be used in conjunction

	 * with another device. The core will then call the relevant handler to

	 * perform the data processing step.

 This is a threaded handler, it is fine to wait for an IRQ */

 Enable triggered buffers */

 If there is an EOC interrupt, register the cnvst hardware trigger */

 Internal reset */

 Disable averaging */

 Assume conversion on register write for now */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2016 Broadcom

 Below Register's are common to IPROC ADC and Touchscreen IP */

 IPROC ADC Channel register offsets */

 Bit definitions for IPROC_REGCTL2 */

 Bit definitions for IPROC_INTERRUPT_MASK and IPROC_INTERRUPT_STATUS */

 Bit definitions for IPROC_ANALOG_CONTROL */

 Bit definitions for IPROC_ADC_CHANNEL_REGCTL1 */

 Bit definitions for IPROC_ADC_CHANNEL_REGCTL2 */

 Bit definitions for IPROC_ADC_CHANNEL_STATUS */

 Bit definitions for IPROC_ADC_CHANNEL_INTERRUPT_MASK */

 Number of time to retry a set of the interrupt mask reg */

	/*

	 * This interrupt is shared with the touchscreen driver.

	 * Make sure this interrupt is intended for us.

	 * Handle only ADC channel specific interrupts.

	/*

	 * After a read is complete the ADC interrupts will be disabled so

	 * we can assume this section of code is safe from interrupts.

 Clear any pending interrupt */

 Configure channel for snapshot mode and enable  */

 Set the Watermark for a channel */

 Enable water mark interrupt */

 Enable ADC interrupt for a channel */

	/*

	 * There seems to be a very rare issue where writing to this register

	 * does not take effect.  To work around the issue we will try multiple

	 * writes.  In total we will spend about 10*10 = 100 us attempting this.

	 * Testing has shown that this may loop a few time, but we have never

	 * hit the full count.

 Only the lower 16 bits are relevant */

		/*

		 * We never got the interrupt, something went wrong.

		 * Perhaps the interrupt may still be coming, we do not want

		 * that now.  Lets disable the ADC interrupt, and clear the

		 * status to put it back in to normal state.

 Set i_amux = 3b'000, select channel 0 */

	/*

	 * PWR up LDO, ADC, and Band Gap (0 to enable)

	 * Also enable ADC controller (set high)

 SPDX-License-Identifier: GPL-2.0

/*

 * ADC driver for Basin Cove PMIC

 *

 * Copyright (C) 2012 Intel Corporation

 * Author: Bin Yang <bin.yang@intel.com>

 *

 * Rewritten for upstream by:

 *	 Vincent Pelletier <plr.vincent@gmail.com>

 *	 Andy Shevchenko <andriy.shevchenko@linux.intel.com>

 Lock to protect the IPC transfers */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * axp288_adc.c - X-Powers AXP288 PMIC ADC Driver

 *

 * Copyright (C) 2014 Intel Corporation

 *

 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*

 * This mask enables all ADCs except for the battery temp-sensor (TS), that is

 * left as-is to avoid breaking charging on devices without a temp-sensor.

 for consumer drivers */

/*

 * The current-source used for the battery temp-sensor (TS) is shared

 * with the GPADC. For proper fuel-gauge and charger operation the TS

 * current-source needs to be permanently on. But to read the GPADC we

 * need to temporary switch the TS current-source to ondemand, so that

 * the GPADC can use it, otherwise we will always read an all 0 value.

 No need to switch the current-source if the TS pin is disabled */

 Channels other than GPADC do not need the current source */

 When switching to the GPADC pin give things some time to settle */

/*

 * We rely on the machine's firmware to correctly setup the TS pin bias current

 * at boot. This lists systems with broken fw where we need to set it ourselves.

 Lenovo Ideapad 100S (11 inch) */

	/*

	 * Determine if the TS pin is enabled and set the TS current-source

	 * accordingly.

 Turn on the ADC for all channels except TS, leave TS as is */

	/*

	 * Set ADC to enabled state at all time, including system suspend.

	 * otherwise internal fuel gauge functionality may be affected.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * MEN 16z188 Analog to Digial Converter

 *

 * Copyright (C) 2014 MEN Mikroelektronik GmbH (www.men.de)

 * Author: Johannes Thumshirn <johannes.thumshirn@men.de>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Nano River Technologies viperboard IIO ADC driver

 *

 *  (C) 2012 by Lemonage GmbH

 *  Author: Lars Poeschel <poeschel@lemonage.de>

 *  All rights reserved.

 registering iio */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * TWL6030 GPADC module driver

 *

 * Copyright (C) 2009-2013 Texas Instruments Inc.

 * Nishant Kamat <nskamat@ti.com>

 * Balaji T K <balajitk@ti.com>

 * Graeme Gregory <gg@slimlogic.co.uk>

 * Girish S Ghongdemath <girishsg@ti.com>

 * Ambresh K <ambresh@ti.com>

 * Oleksandr Kozaruk <oleksandr.kozaruk@ti.com

 *

 * Based on twl4030-madc.c

 * Copyright (C) 2008 Nokia Corporation

 * Mikko Ylinen <mikko.k.ylinen@nokia.com>

/*

 * twl6030 per TRM has 17 channels, and twl6032 has 19 channels

 * 2 test network channels are not used,

 * 2 die temperature channels are not used either, as it is not

 * defined how to convert ADC value to temperature

/**

 * struct twl6030_chnl_calib - channel calibration

 * @gain:		slope coefficient for ideal curve

 * @gain_error:		gain error

 * @offset_error:	offset of the real curve

/**

 * struct twl6030_ideal_code - GPADC calibration parameters

 * GPADC is calibrated in two points: close to the beginning and

 * to the and of the measurable input range

 *

 * @channel:	channel number

 * @code1:	ideal code for the input at the beginning

 * @code2:	ideal code for at the end of the range

 * @volt1:	voltage input at the beginning(low voltage)

 * @volt2:	voltage input at the end(high voltage)

/**

 * struct twl6030_gpadc_platform_data - platform specific data

 * @nchannels:		number of GPADC channels

 * @iio_channels:	iio channels

 * @ideal:		pointer to calibration parameters

 * @start_conversion:	pointer to ADC start conversion function

 * @channel_to_reg:	pointer to ADC function to convert channel to

 *			register address for reading conversion result

 * @calibrate:		pointer to calibration function

/**

 * struct twl6030_gpadc_data - GPADC data

 * @dev:		device pointer

 * @lock:		mutual exclusion lock for the structure

 * @irq_complete:	completion to signal end of conversion

 * @twl6030_cal_tbl:	pointer to calibration data for each

 *			channel with gain error and offset

 * @pdata:		pointer to device specific data

/*

 * channels 11, 12, 13, 15 and 16 have no calibration data

 * calibration offset is same for channels 1, 3, 4, 5

 *

 * The data is taken from GPADC_TRIM registers description.

 * GPADC_TRIM registers keep difference between the code measured

 * at volt1 and volt2 input voltages and corresponding code1 and code2

 ch 0, external, battery type, resistor value */

 ch 1, external, battery temperature, NTC resistor value */

 ch 2, external, audio accessory/general purpose */

 ch 3, external, general purpose */

 ch 4, external, temperature measurement/general purpose */

 ch 5, external, general purpose */

 ch 6, external, general purpose */

 ch 7, internal, main battery */

 ch 8, internal, backup battery */

 ch 9, internal, external charger input */

 ch 10, internal, VBUS */

 ch 11, internal, VBUS charging current */

 ch 12, internal, Die temperature */

 ch 13, internal, Die temperature */

 ch 14, internal, USB ID line */

 ch 0, external, battery type, resistor value */

 ch 1, external, battery temperature, NTC resistor value */

 ch 2, external, audio accessory/general purpose */

	[3] = { /* ch 3, external, temperature with external diode/general

 ch 4, external, temperature measurement/general purpose */

 ch 5, external, general purpose */

 ch 6, external, general purpose */

 ch7, internal, system supply */

 ch8, internal, backup battery */

 ch 9, internal, external charger input */

 ch10, internal, VBUS */

 ch 11, internal, VBUS DC-DC output current */

 ch 12, internal, Die temperature */

 ch 13, internal, Die temperature */

 ch 14, internal, USB ID line */

 ch 15, internal, test network */

 ch 16, internal, test network */

 ch 17, internal, battery charging current */

 ch 18, internal, battery voltage */

	/*

	 * for any prior chosen channel, when the conversion is ready

	 * the result is avalable in GPCH0_LSB, GPCH0_MSB.

 not calibrated channels have 0 in all structure members */

 Shift back into mV range */

 wait for conversion to complete */

/*

 * The GPADC channels are calibrated using a two point calibration method.

 * The channels measured with two known values: volt1 and volt2, and

 * ideal corresponding output codes are known: code1, code2.

 * The difference(d1, d2) between ideal and measured codes stored in trim

 * registers.

 * The goal is to find offset and gain of the real curve for each calibrated

 * channel.

 * gain: k = 1 + ((d2 - d1) / (x2 - x1))

 * offset: b = d1 + (k - 1) * x1

 Gain */

 k - real curve gain */

 b - offset of the real curve gain */

	/*

	 * XXX NOTE!

	 * bit 0 - sign, bit 7 - reserved, 6..1 - trim value

	 * though, the documentation states that trim value

	 * is absolute value, the correct conversion results are

	 * obtained if the value is interpreted as 2's complement.

	/*

	 * for calibration two measurements have been performed at

	 * factory, for some channels, during the production test and

	 * have been stored in registers. This two stored values are

	 * used to correct the measurements. The values represent

	 * offsets for the given input from the output on ideal curve.

	/*

	 * Loop to calculate the value needed for returning voltages from

	 * GPADC not values.

	 *

	 * gain is calculated to 3 decimal places fixed point.

 No data for other channels */

 end */ }

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Holt Integrated Circuits HI-8435 threshold detector driver

 *

 * Copyright (C) 2015 Zodiac Inflight Innovations

 * Copyright (C) 2015 Cogent Embedded, Inc.

 Register offsets for HI-8435 */

 CTRL register bits */

 soft mask/unmask channels events */

 GND-Open and Supply-Open thresholds */

 GND-Open and Supply-Open thresholds */

 Supply-Open or GND-Open sensing mode */

 Supply-Open or GND-Open sensing mode */

 falling threshold range 2..21V, hysteresis minimum 2V */

 hysteresis must not be odd */

 rising threshold range 3..22V, hysteresis minimum 2V */

 hysteresis must not be odd */

 program thresholds */

 hysteresis */

 threshold center */

 chip s/w reset if h/w reset failed */

 unmask all events */

	/*

	 * There is a restriction in the chip - the hysteresis can not be odd.

	 * If the hysteresis is set to odd value then chip gets into lock state

	 * and not functional anymore.

	 * After chip reset the thresholds are in undefined state, so we need to

	 * initialize thresholds to some initial values and then prevent

	 * userspace setting odd hysteresis.

	 *

	 * Set threshold low voltage to 2V, threshold high voltage to 4V

	 * for both GND-Open and Supply-Open sensing modes.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * TI tlc4541 ADC Driver

 *

 * Copyright (C) 2017 Phil Reid

 *

 * Datasheets can be found here:

 * https://www.ti.com/lit/gpn/tlc3541

 * https://www.ti.com/lit/gpn/tlc4541

 *

 * The tlc4541 requires 24 clock cycles to start a transfer.

 * Conversion then takes 2.94us to complete before data is ready

 * Data is returned MSB first.

	/*

	 * DMA (thus cache coherency maintenance) requires the

	 * transfer buffers to live in their own cache lines.

	 * 2 bytes data + 6 bytes padding + 8 bytes timestamp when

	 * call iio_push_to_buffers_with_timestamp.

 perform reset */

 Setup default message */

 SPDX-License-Identifier: GPL-2.0

/*

 * Driver for an envelope detector using a DAC and a comparator

 *

 * Copyright (C) 2016 Axentia Technologies AB

 *

 * Author: Peter Rosin <peda@axentia.se>

/*

 * The DAC is used to find the peak level of an alternating voltage input

 * signal by a binary search using the output of a comparator wired to

 * an interrupt pin. Like so:

 *                           _

 *                          | \

 *     input +------>-------|+ \

 *                          |   \

 *            .-------.     |    }---.

 *            |       |     |   /    |

 *            |    dac|-->--|- /     |

 *            |       |     |_/      |

 *            |       |              |

 *            |       |              |

 *            |    irq|------<-------'

 *            |       |

 *            '-------'

 protects comp */

 protects everything else */

/*

 * The envelope_detector_comp_latch function works together with the compare

 * interrupt service routine below (envelope_detector_comp_isr) as a latch

 * (one-bit memory) for if the interrupt has triggered since last calling

 * this function.

 * The ..._comp_isr function disables the interrupt so that the cpu does not

 * need to service a possible interrupt flood from the comparator when no-one

 * cares anyway, and this ..._comp_latch function reenables them again if

 * needed.

	/*

	 * The irq was disabled, and is reenabled just now.

	 * But there might have been a pending irq that

	 * happened while the irq was disabled that fires

	 * just as the irq is reenabled. That is not what

	 * is desired.

 So, synchronize this possibly pending irq... */

 ...and redo the whole dance. */

	/*

	 * Do a binary search for the peak input level, and stop

	 * when that level is "trapped" between two adjacent DAC

	 * values.

	 * When invert is active, use the midpoint floor so that

	 * env->level ends up as env->low when the termination

	 * criteria below is fulfilled, and use the midpoint

	 * ceiling when invert is not active so that env->level

	 * ends up as env->high in that case.

 Set a "safe" DAC level (if there is such a thing)... */

 ...clear the comparison result... */

 ...set the real DAC level... */

 ...and wait for a bit to see if the latch catches anything. */

 Adjust low/high depending on the latch content... */

 ...and continue the search. */

		/*

		 * When invert is active, start with high=max+1 and low=0

		 * since we will end up with the low value when the

		 * termination criteria is fulfilled (rounding down). And

		 * start with high=max and low=-1 when invert is not active

		 * since we will end up with the high value in that case.

		 * This ensures that the returned value in both cases are

		 * in the same range as the DAC and is a value that has not

		 * triggered the comparator.

 sentinel */ }

 some sensible default? */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-only

/*

 * TI ADC MFD driver

 *

 * Copyright (C) 2012 Texas Instruments Incorporated - https://www.ti.com/

 to protect fifo access */

 +1 for the charger */

	/*

	 * There are 16 configurable steps and 8 analog input

	 * lines available which are shared between Touchscreen and ADC.

	 *

	 * Steps forwards i.e. from 0 towards 16 are used by ADC

	 * depending on number of input lines needed.

	 * Channel would represent which analog input

	 * needs to be given to ADC to digitalize data.

	/*

	 * ADC and touchscreen share the IRQ line.

	 * FIFO0 interrupts are used by TSC. Handle FIFO1 IRQs here only

 FIFO Overrun. Clear flag. Disable/Enable ADC to recover */

		/*

		 * Wait for the idle state.

		 * ADC needs to finish the current conversion

		 * before disabling the module

 Disable irq and wake worker thread */

 swap the buffer ID */

 We start to fill period 0 */

	/*

	 * Make the fifo thresh as the multiple of total number of

	 * channels enabled, so make sure that cyclic DMA period

	 * length is also a multiple of total number of channels

	 * enabled. This ensures that no invalid data is reported

	 * to the stack via iio_push_to_buffers().

 Make sure that period length is multiple of fifo thresh level */

 Flush FIFO. Needed in corner cases in simultaneous tsc/adc use */

 Flush FIFO of leftover data in the time it takes to disable adc */

 Wait for Fifo threshold interrupt */

	/*

	 * We check the complete FIFO. We programmed just one entry but in case

	 * something went wrong we left empty handed (-EAGAIN previously) and

	 * then the value apeared somehow in the FIFO we would have two entries.

	 * Therefore we read every item and keep only the latest version of the

	 * requested channel.

 Default slave configuration parameters */

 Get a channel for RX */

 RX buffer */

 Set Default values for optional DT parameters */

 Make sure ADC is powered up */

 SPDX-License-Identifier: GPL-2.0+

/*

 * AD7124 SPI ADC driver

 *

 * Copyright 2018 Analog Devices Inc.

 AD7124 registers */

 AD7124_STATUS */

 AD7124_ADC_CONTROL */

 AD7124 ID */

 AD7124_CHANNEL_X */

 AD7124_CONFIG_X */

 AD7124_FILTER_X */

 lock for configs access */

 bitmap with slot status (1 means it is used) */

	/*

	 * FS[10:0] = fCLK / (fADC x 32) where:

	 * fADC is the output data rate

	 * fCLK is the master clock frequency

	 * FS[10:0] are the bits in the filter register

	 * FS[10:0] can have a value from 1 to 2047

 fADC = fCLK / (FS[10:0] x 32) */

 Conversion from uV to mV */

	/*

	 * Pop least recently used config from the fifo

	 * in order to make room for the new one

 mark slot as free */

 invalidate all other configs that pointed to this one */

 push the new config in configs queue */

 pop one config to make room for the new one */

 push the new config in configs queue */

 mark slot as used */

	/*

	 * Before doing any reads assign the channel a configuration.

	 * Check if channel's config is on the device

 check if config matches another one */

 point channel to the config slot and enable */

 After the conversion is performed, disable the channel */

 The AD7124 requires typically 2ms to power up and settle */

 The power mode changes the master clock frequency */

 Set the power mode */

		/*

		 * 9.38 SPS is the minimum output data rate supported

		 * regardless of the selected power mode. Round it up to 10 and

		 * set all channels to this default value.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * AD7785/AD7792/AD7793/AD7794/AD7795 SPI ADC driver

 *

 * Copyright 2011-2012 Analog Devices Inc.

 Registers */

 Communications Register (WO, 8-bit) */

 Status Register	     (RO, 8-bit) */

 Mode Register	     (RW, 16-bit */

 Configuration Register  (RW, 16-bit) */

 Data Register	     (RO, 16-/24-bit) */

 ID Register	     (RO, 8-bit) */

 IO Register	     (RO, 8-bit) */

#define AD7793_REG_OFFSET	6 /* Offset Register	     (RW, 16-bit

#define AD7793_REG_FULLSALE	7 /* Full-Scale Register

 Communications Register Bit Designations (AD7793_REG_COMM) */

 Write Enable */

 Write Operation */

 Read Operation */

 Register Address */

 Continuous Read of Data Register */

 Status Register Bit Designations (AD7793_REG_STAT) */

 Ready */

 Error (Overrange, Underrange) */

 Channel 3 */

 Channel 2 */

 Channel 1 */

 Mode Register Bit Designations (AD7793_REG_MODE) */

 Operation Mode Select */

 Operation Mode Select mask */

 ADC Clock Source Select */

 Filter Update Rate Select */

 Continuous Conversion Mode */

 Single Conversion Mode */

 Idle Mode */

 Power-Down Mode */

 Internal Zero-Scale Calibration */

 Internal Full-Scale Calibration */

 System Zero-Scale Calibration */

 System Full-Scale Calibration */

#define AD7793_CLK_INT		0 /* Internal 64 kHz Clock not

#define AD7793_CLK_INT_CO	1 /* Internal 64 kHz Clock available

 External 64 kHz Clock */

 External Clock divided by 2 */

 Configuration Register Bit Designations (AD7793_REG_CONF) */

#define AD7793_CONF_VBIAS(x)	(((x) & 0x3) << 14) /* Bias Voltage

 Burnout Current Enable */

 Unipolar/Bipolar Enable */

 Boost Enable */

 Gain Select */

 INT/EXT Reference Select */

 Buffered Mode Enable */

 Channel select */

 Channel select mask */

 AIN1(+) - AIN1(-) */

 AIN2(+) - AIN2(-) */

 AIN3(+) - AIN3(-) */

 AIN1(-) - AIN1(-) */

 Temp Sensor */

 AVDD Monitor */

 AIN4(+) - AIN4(-) */

 AIN5(+) - AIN5(-) */

 AIN6(+) - AIN6(-) */

 AIN1(-) - AIN1(-) */

 ID Register Bit Designations (AD7793_REG_ID) */

 IO (Excitation Current Sources) Register Bit Designations (AD7793_REG_IO) */

#define AD7793_IO_IEXC1_IOUT1_IEXC2_IOUT2	0 /* IEXC1 connect to IOUT1,

#define AD7793_IO_IEXC1_IOUT2_IEXC2_IOUT1	1 /* IEXC1 connect to IOUT2,

#define AD7793_IO_IEXC1_IEXC2_IOUT1		2 /* Both current sources

#define AD7793_IO_IEXC1_IEXC2_IOUT2		3 /* Both current sources

 Excitation Current 10uA */

 Excitation Current 210uA */

 Excitation Current 1mA */

/* NOTE:

 * The AD7792/AD7793 features a dual use data out ready DOUT/RDY output.

 * In order to avoid contentions on the SPI bus, it's therefore necessary

 * to use spi bus locking.

 *

 * The DOUT/RDY output must also be wired to an interrupt capable GPIO.

 reset the serial interface */

 Wait for at least 500us */

 write/read test for device presence */

 Populate available ADC input ranges */

 Values are stored in a 2D matrix  */

 1170mV / 2^23 * 6 */

 1170mV / 0.81 mV/C / 2^23 */

 Kelvin to Celsius */

 Build-in ref */

 SPDX-License-Identifier: GPL-2.0

/*

 * Driver for Microchip MCP3911, Two-channel Analog Front End

 *

 * Copyright (C) 2018 Marcus Folkesson <marcus.folkesson@gmail.com>

 * Copyright (C) 2018 Kent Gustavsson <kent@minoris.se>

 Internal voltage reference in uV */

 Write offset */

 Enable offset*/

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.

 IADC register and bit definition */

 16 bits */

 nano Ohms per bit */

 micro Ohms */

 micro Ohms */

 micro Ohms */

 micro Ohms */

 1:1 */

 512 */

 0 us */

 1 sample */

 IADC channel list */

/**

 * struct iadc_chip - IADC Current ADC device structure.

 * @regmap: regmap for register read/write.

 * @dev: This device pointer.

 * @base: base offset for the ADC peripheral.

 * @rsense: Values of the internal and external sense resister in micro Ohms.

 * @poll_eoc: Poll for end of conversion instead of waiting for IRQ.

 * @offset: Raw offset values for the internal and external channels.

 * @gain: Raw gain of the channels.

 * @lock: ADC lock for access to the peripheral.

 * @complete: ADC notification after end of conversion interrupt is received.

 Mode selection */

 Channel selection */

 Digital parameter setup */

 HW settle time delay */

 Request conversion */

 double check conversion status */

	/*

	 * Deviation value stored is an offset from 10 mili Ohms, bit 7 is

	 * the sign, the remaining bits have an LSB of 15625 nano Ohms.

 Scale it to nono Ohms */

 micro Ohms */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * mcp3422.c - driver for the Microchip mcp3421/2/3/4/5/6/7/8 chip family

 *

 * Copyright (C) 2013, Angelo Compagnucci

 * Author: Angelo Compagnucci <angelo.compagnucci@gmail.com>

 *

 * Datasheet: http://ww1.microchip.com/downloads/en/devicedoc/22088b.pdf

 *            https://ww1.microchip.com/downloads/en/DeviceDoc/22226a.pdf

 *            https://ww1.microchip.com/downloads/en/DeviceDoc/22072b.pdf

 *

 * This driver exports the value of analog input voltage to sysfs, the

 * voltage unit is nV.

 Masks */

 Constant msleep times for data acquisitions */

 sample rates to integer conversion table */

 sample rates to sign extension table */

 Client data (each client gets its own) */

 meaningful default configuration */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Rockchip Successive Approximation Register (SAR) A/D Converter

 * Copyright (C) 2014 ROCKCHIP, Inc.

 Clear irq & power down adc */

 8 clock periods as delay between power up and start cmd */

 Select the channel to be used and trigger conversion */

 Read value */

/*

 * Reset SARADC Controller.

	/*

	 * @values: each channel takes an u16 value

	 * @timestamp: will be 8-byte aligned automatically

 Sanity check for possible later IP variants with more channels */

	/*

	 * The reset should be an optional property, as it should work

	 * with old devicetrees as well

	/*

	 * Use a default value for the converter clock.

	 * This may become user-configurable in the future.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * TI ADC081C/ADC101C/ADC121C 8/10/12-bit ADC driver

 *

 * Copyright (C) 2012 Avionic Design GmbH

 * Copyright (C) 2016 Intel

 *

 * Datasheets:

 *	https://www.ti.com/lit/ds/symlink/adc081c021.pdf

 *	https://www.ti.com/lit/ds/symlink/adc101c021.pdf

 *	https://www.ti.com/lit/ds/symlink/adc121c021.pdf

 *

 * The devices have a very similar interface and differ mostly in the number of

 * bits handled. For the 8-bit and 10-bit models the least-significant 4 or 2

 * bits of value registers are reserved.

 8, 10 or 12 */

 Ensure natural alignment of buffer elements */

 Model ids are indexes in _models array */

 SPDX-License-Identifier: GPL-2.0

 PMUCHGCTRL3 0x313 */

 PMUADCCFG 0x356 */

 PMUADCRPT1 0x35A */

 Time in ms */

 Due to only one set of ADC control, this lock is used to prevent the race condition */

 Select the preferred ADC channel */

		/*

		 * There are two functions, ZCV and TypeC OTP, running ADC VBAT and TS in

		 * background, and ADC samples are taken on a fixed frequency no matter read the

		 * previous one or not.

		 * To avoid conflict, We set minimum time threshold after enable ADC and

		 * check report channel is the same.

		 * The worst case is run the same ADC twice and background function is also running,

		 * ADC conversion sequence is desire channel before start ADC, background ADC,

		 * desire channel after start ADC.

		 * So the minimum correct data is three times of typical conversion time.

 Only keep ADC enable */

 Config prefer channel to NO_PREFER */

 IBUS will be affected by input current limit for the different Ron */

 Check whether the config is <400mA or not */

 Clear ADC idle wait time to 0 */

 Only keep ADC enable, but keep all channels off */

 Reset all channel off time to the current one */

 SPDX-License-Identifier: GPL-2.0

/* ADC driver for sunxi platforms' (A10, A13 and A31) GPADC

 *

 * Copyright (c) 2016 Quentin Schulz <quentin.schulz@free-electrons.com>

 *

 * The Allwinner SoCs all have an ADC that can also act as a touchscreen

 * controller and a thermal sensor.

 * The thermal sensor works only when the ADC acts as a touchscreen controller

 * and is configured to throw an interrupt every fixed periods of time (let say

 * every X seconds).

 * One would be tempted to disable the IP on the hardware side rather than

 * disabling interrupts to save some power but that resets the internal clock of

 * the IP, resulting in having to wait X seconds every time we want to read the

 * value of the thermal sensor.

 * This is also the reason of using autosuspend in pm_runtime. If there was no

 * autosuspend, the thermal sensor would need X seconds after every

 * pm_runtime_get_sync to get a value from the ADC. The autosuspend allows the

 * thermal sensor to be requested again in a certain time span before it gets

 * shutdown for not being used.

 prevents concurrent reads of temperature and ADC */

 sentinel */ },

		/*

		 * When the IP changes channel, it needs a bit of time to get

		 * correct values.

		/*

		 * The temperature sensor returns valid data only when the ADC

		 * operates in touchscreen mode.

	/*

	 * When the IP changes mode between ADC or touchscreen, it

	 * needs a bit of time to get correct values.

	/*

	 * The temperature sensor throws an interruption periodically (currently

	 * set at periods of ~0.6s in sun4i_gpadc_runtime_resume). A 1s delay

	 * makes sure an interruption occurs in normal conditions. If it doesn't

	 * occur, then there is a timeout.

 3000mV / 4096 * raw */

 Disable the ADC on IP */

 Disable temperature sensor on IP */

 clkin = 6MHz */

 period = SUN4I_GPADC_TPR_TEMP_PERIOD * 256 * 16 / clkin; ~0.6s */

	/*

	 * Once the interrupt is activated, the IP continuously performs

	 * conversions thus throws interrupts. The interrupt is activated right

	 * after being requested but we want to control when these interrupts

	 * occur thus we disable it right after being requested. However, an

	 * interrupt might occur between these two instructions and we have to

	 * make sure that does not happen, by using atomic flags. We set the

	 * flag before requesting the interrupt and unset it right after

	 * disabling the interrupt. When an interrupt occurs between these two

	 * instructions, reading the atomic flag will tell us to ignore the

	 * interrupt.

 sentinel */ }

	/*

	 * Since the controller needs to be in touchscreen mode for its thermal

	 * sensor to operate properly, and that switching between the two modes

	 * needs a delay, always registering in the thermal framework will

	 * significantly slow down the conversion rate of the ADCs.

	 *

	 * Therefore, instead of depending on THERMAL_OF in Kconfig, we only

	 * register the sensor if that option is enabled, eventually leaving

	 * that choice to the user.

		/*

		 * This driver is a child of an MFD which has a node in the DT

		 * but not its children, because of DT backward compatibility

		 * for A10, A13 and A31 SoCs. Therefore, the resulting devices

		 * of this driver do not have an of_node variable.

		 * However, its parent (the MFD driver) has an of_node variable

		 * and since devm_thermal_zone_of_sensor_register uses its first

		 * argument to match the phandle defined in the node of the

		 * thermal driver with the of_node of the device passed as first

		 * argument and the third argument to call ops from

		 * thermal_zone_of_device_ops, the solution is to use the parent

		 * device as first argument to match the phandle with its

		 * of_node, and the device from this driver as third argument to

		 * return the temperature.

		/*

		 * Do not fail driver probing when failing to register in

		 * thermal because no thermal DT node is found.

 sentinel */ },

 SPDX-License-Identifier: GPL-2.0

/*

 * AD7170/AD7171 and AD7780/AD7781 SPI ADC driver

 *

 * Copyright 2011 Analog Devices Inc.

 * Copyright 2019 Renato Lui Geh

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * DA9150 GPADC Driver

 *

 * Copyright (c) 2014 Dialog Semiconductor

 *

 * Author: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>

 Channels */

 Private data */

 Set channel & enable measurement */

 Consume left-over completion from a previous timeout */

 Check for actual completion */

 Read result and status from device */

 Check to make sure device really has completed reading */

 LSBs - 2 bits */

 MSBs - 8 bits */

 Convert to mV */

 Convert to mA */

 Convert to mV */

 Convert to mV */

 No processing for other channels so return raw value */

 Supported channels */

 Default maps used by da9150-charger */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * AD7266/65 SPI ADC driver

 *

 * Copyright 2012 Analog Devices Inc.

	/*

	 * DMA (thus cache coherency maintenance) requires the

	 * transfer buffers to live in their own cache lines.

	 * The buffer needs to be large enough to hold two samples (4 bytes) and

	 * the naturally aligned timestamp (8 bytes).

 Any read with >= 2 bytes will wake the device */

 Any read with < 2 bytes will powerdown the device */

 Any other error indicates that the regulator does exist */

 Use internal reference */

 wakeup */

 conversion */

 powerdown */

/*

 * INA2XX Current and Power Monitors

 *

 * Copyright 2015 Baylibre SAS.

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License version 2 as

 * published by the Free Software Foundation.

 *

 * Based on linux/drivers/iio/adc/ad7291.c

 * Copyright 2010-2011 Analog Devices Inc.

 *

 * Based on linux/drivers/hwmon/ina2xx.c

 * Copyright 2012 Lothar Felten <l-felten@ti.com>

 *

 * Licensed under the GPL-2 or later.

 *

 * IIO driver for INA219-220-226-230-231

 *

 * Configurable 7-bit I2C slave address from 0x40 to 0x4F

 INA2XX registers definition */

 readonly */

 readonly */

 readonly */

 readonly */

 settings - depend on use case */

 PGA=1/8, BRNG=32V */

 32V */

 1000/8 */

/*

 * bit masks for reading the settings in the configuration register

 * FIXME: use regmap_fields.

 Gain for VShunt: 1/8 (default), 1/4, 1/2, 1 */

 VBus range: 32V (default), 16V */

 Averaging for VBus/VShunt/Power */

 Integration time for VBus */

 Integration time for VShunt */

 INA219 Bus voltage register, low bits are flags */

 Cosmetic macro giving the sampling period for a full P=UxI cycle */

 nV */

 position of lsb */

 uV */

 fixed relation between current and power lsb, uW/uA */

 Bus voltage integration time uS */

 Shunt voltage integration time uS */

 Bus voltage maximum in V */

 Shunt voltage PGA gain */

 data buffer needs space for channel data and timestamp */

		/*

		 * Sample freq is read only, it is a consequence of

		 * 1/AVG*(CT_bus+CT_shunt).

 processed (mV) = raw * lsb(nV) / 1000000 */

 processed (mV) = raw * lsb (uV) / 1000 */

			/*

			 * processed (mA) = raw * current_lsb (mA)

			 * current_lsb (mA) = shunt_voltage_lsb (nV) /

			 *                    shunt_resistor (uOhm)

			/*

			 * processed (mW) = raw * power_lsb (mW)

			 * power_lsb (mW) = power_lsb_factor (mW/mA) *

			 *                  current_lsb (mA)

/*

 * Available averaging rates for ina226. The indices correspond with

 * the bit values expected by the chip (according to the ina226 datasheet,

 * table 3 AVG bit settings, found at

 * https://www.ti.com/lit/ds/symlink/ina226.pdf.

 Conversion times in uS */

 Conversion times in uS. */

/*

 * Calibration register is set to the best value, which eliminates

 * truncation errors on calculating current register in hardware.

 * According to datasheet (INA 226: eq. 3, INA219: eq. 4) the best values

 * are 2048 for ina226 and 4096 for ina219. They are hardcoded as

 * calibration_value.

/*

 * Sampling Freq is a consequence of the integration times of

 * the Voltage channels.

	/*

	 * Because the timer thread and the chip conversion clock

	 * are asynchronous, the period difference will eventually

	 * result in reading V[k-1] again, or skip V[k] at time Tk.

	 * In order to resync the timer with the conversion process

	 * we check the ConVersionReadyFlag.

	 * On hardware that supports using the ALERT pin to toggle a

	 * GPIO a triggered buffer could be used instead.

	 * For now, we do an extra read of the MASK_ENABLE register (INA226)

	 * resp. the BUS_VOLTAGE register (INA219).

	/*

	 * Single register reads: bulk_read will not work with ina226/219

	 * as there is no auto-increment of the register pointer.

	/*

	 * Poll a bit faster than the chip internal Fs, in case

	 * we wish to sync with the conversion ready flag.

			/*

			 * If the conversion was not yet finished,

			 * reset the reference timestamp.

		/*

		 * Advance the timestamp for the next poll by one sampling

		 * interval, and sleep for the remainder (next - now)

		 * In case "next" has already passed, the interval is added

		 * multiple times, i.e. samples are dropped.

 Possible integration times for vshunt and vbus */

 Initialize the configuration and calibration registers. */

 This is only used for device removal purposes. */

 Patch the current config register with default. */

 Powerdown */

 SPDX-License-Identifier: GPL-2.0

/*

 * Analog Devices AD7768-1 SPI ADC driver

 *

 * Copyright 2017 Analog Devices Inc.

 AD7768 registers definition */

 AD7768_REG_POWER_CLOCK */

 AD7768_REG_DIGITAL_FILTER */

 AD7768_REG_CONVERSION */

	/*

	 * DMA (thus cache coherency maintenance) requires the

	 * transfer buffers to live in their own cache lines.

	/*

	 * Any SPI configuration of the AD7768-1 can only be

	 * performed in continuous conversion mode.

 A sync-in pulse is required every time the filter dec rate changes */

 Find the closest match for the desired sampling frequency */

	/*

	 * Set both the mclk_div and pwrmode with a single write to the

	 * POWER_CLOCK register

	/*

	 * Two writes to the SPI_RESET[1:0] bits are required to initiate

	 * a software reset. The bits must first be set to 11, and then

	 * to 10. When the sequence is detected, the reset occurs.

	 * See the datasheet, page 70.

 Set the default sampling frequency to 32000 kSPS */

	/*

	 * Write a 1 to the LSB of the INTERFACE_FORMAT register to enter

	 * continuous read mode. Subsequent data reads do not require an

	 * initial 8-bit write to query the ADC_DATA register.

	/*

	 * To exit continuous read mode, perform a single read of the ADC_DATA

	 * reg (0x2C), which allows further configuration of the device.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2015 Prevas A/S

/*

 * enum ads8688_range - ADS8688 reference voltage range

 * @ADS8688_PLUSMINUS25VREF: Device is configured for input range ±2.5 * VREF

 * @ADS8688_PLUSMINUS125VREF: Device is configured for input range ±1.25 * VREF

 * @ADS8688_PLUSMINUS0625VREF: Device is configured for input range ±0.625 * VREF

 * @ADS8688_PLUS25VREF: Device is configured for input range 0 - 2.5 * VREF

 * @ADS8688_PLUS125VREF: Device is configured for input range 0 - 1.25 * VREF

 If the offset is 0 the ±2.5 * VREF mode is not available */

 Lookup new mode */

		/*

		 * There are only two available offsets:

		 * 0 and -(1 << (ADS8688_REALBITS - 1))

		/*

		 * If the device are in ±2.5 * VREF mode, it's not allowed to

		 * switch to a mode where the offset is 0

 Lookup new mode */

 Ensure naturally aligned timestamp */

 Use internal reference */

 SPDX-License-Identifier: GPL-2.0

/*

 * This file is part the core part STM32 DFSDM driver

 *

 * Copyright (C) 2017, STMicroelectronics - All Rights Reserved

 * Author(s): Arnaud Pouliquen <arnaud.pouliquen@st.com> for STMicroelectronics.

	/*

	 * Mask is done on register to avoid to list registers of all

	 * filter instances.

 platform device */

 common data exported for all instances */

 SPI clkout divider value */

 number of current active channels */

 DFSDM clock */

 audio clock */

/**

 * stm32_dfsdm_start_dfsdm - start global dfsdm interface.

 *

 * Enable interface if n_active_ch is not null.

 * @dfsdm: Handle used to retrieve dfsdm context.

 select clock source, e.g. 0 for "dfsdm" or 1 for "audio" */

 Output the SPI CLKOUT (if clk_div == 0 clock if OFF) */

 Global enable of DFSDM interface */

/**

 * stm32_dfsdm_stop_dfsdm - stop global DFSDM interface.

 *

 * Disable interface if n_active_ch is null

 * @dfsdm: Handle used to retrieve dfsdm context.

 Global disable of DFSDM interface */

 Stop SPI CLKOUT */

	/*

	 * "dfsdm" clock is mandatory for DFSDM peripheral clocking.

	 * "dfsdm" or "audio" clocks can be used as source clock for

	 * the SPI clock out signal and internal processing, depending

	 * on use case.

 SPI clock out frequency */

 No SPI master mode */

 Round up divider when ckout isn't precise, not to exceed spi_freq */

 programmable divider is in range of [2:256] */

 SPI clock output divider is: divider = CKOUTDIV + 1 */

 Balance devm_regmap_init_mmio_clk() clk_prepare() */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * iio/adc/ad799x.c

 * Copyright (C) 2010-2011 Michael Hennerich, Analog Devices Inc.

 *

 * based on iio/adc/max1363

 * Copyright (C) 2008-2010 Jonathan Cameron

 *

 * based on linux/drivers/i2c/chips/max123x

 * Copyright (C) 2002-2004 Stefan Eletzhofer

 *

 * based on linux/drivers/acron/char/pcf8583.c

 * Copyright (C) 2000 Russell King

 *

 * ad799x.c

 *

 * Support for ad7991, ad7995, ad7999, ad7992, ad7993, ad7994, ad7997,

 * ad7998 and similar chips.

/*

 * AD7991, AD7995 and AD7999 defines

/*

 * AD7992, AD7993, AD7994, AD7997 and AD7998 defines

/*

 * AD7997 and AD7997 defines

/**

 * struct ad799x_chip_config - chip specific information

 * @channel:		channel specification

 * @default_config:	device default configuration

 * @info:		pointer to iio_info struct

/**

 * struct ad799x_chip_info - chip specific information

 * @num_channels:	number of channels

 * @noirq_config:	device configuration w/o IRQ

 * @irq_config:		device configuration w/IRQ

 Will be written when doing a conversion */

 No readback support */

 Wipe the bits clean */

 this is only used for device removal purposes */

 TODO: Add pdata options for filtering and bit delay */

 check if an external reference is supplied */

		/*

		 * Use external reference voltage if supported by hardware.

		 * This is optional if voltage / regulator present, use VCC otherwise.

 resync config */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * AD7291 8-Channel, I2C, 12-Bit SAR ADC with Temperature Sensor

 *

 * Copyright 2010-2011 Analog Devices Inc.

/*

 * Simplified handling

 *

 * If no events enabled - single polled channel read

 * If event enabled direct reads disable unless channel

 * is in the read mask.

 *

 * The noise-delayed bit as per datasheet suggestion is always enabled.

/*

 * AD7291 registers definition

/*

 * AD7291 command

/*

 * AD7291 value masks

/*

 * AD7291 alert register bits

 Active voltage channels for events */

 For now treat t_sense and t_sense_average the same */

	/*

	 * To be enabled the channel must simply be on. If any are enabled

	 * we are in continuous sampling mode

 always on */

	/*

	 * To be enabled the channel must simply be on. If any are enabled

	 * use continuous sampling mode.

	 * Possible to disable temp as well but that makes single read tricky.

 Enable autocycle? */

 If in autocycle mode drop through */

 Enable this channel alone */

 Read voltage */

 Assumes tsense bit of command register always set */

			/*

			 * One LSB of the ADC corresponds to 0.25 deg C.

			 * The temperature reading is in 12-bit twos

			 * complement format

 Tsense always enabled */

 set irq polarity low level */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Freescale Vybrid vf610 ADC driver

 *

 * Copyright 2013 Freescale Semiconductor, Inc.

 This will be the driver name the kernel reports */

 Vybrid/IMX ADC registers */

 Configuration register field define */

 General control register field define */

 Other field define */

 V at 25°C of 696 mV */

 V at 25°C of 699 mV */

 Typical sensor slope coefficient at all temperatures */

 Ensure the timestamp is naturally aligned */

 calculate clk divider which is within specification */

 fall-back value using a safe divisor */

	/*

	 * Determine the long sample time adder value to be used based

	 * on the default minimum sample time provided.

	/*

	 * Calculate ADC sample frequencies

	 * Sample time unit is ADCK cycles. ADCK clk source is ipg clock,

	 * which is the same as bus clock.

	 *

	 * ADC conversion time = SFCAdder + AverageNum x (BCT + LSTAdder)

	 * SFCAdder: fixed to 6 ADCK cycles

	 * AverageNum: 1, 4, 8, 16, 32 samples for hardware average.

	 * BCT (Base Conversion Time): fixed to 25 ADCK cycles for 12 bit mode

	 * LSTAdder(Long Sample Time): 3, 5, 7, 9, 13, 17, 21, 25 ADCK cycles

 set default Configuration for ADC controller */

 low power set for calibration */

 enable high speed for calibration */

 voltage reference */

 data overwrite enable */

 enable calibration interrupt */

 resolution mode */

 clock select and clock divider */

	/*

	 * Set ADLSMP and ADSTS based on the Long Sample Time Adder value

	 * determined.

 update hardware average selection */

 CFG: Feature set */

 adc calibration */

 CFG: power and speed set */

 sentinel */

 replace trailing space by newline */

			/*

			 * Calculate in degree Celsius times 1000

			 * Using the typical sensor slope of 1.84 mV/°C

			 * and VREFH_ADC at 3.3V, V at 25°C of 699 mV

 sentinel */ }

 ADC controller enters to stop mode */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ADS1015 - Texas Instruments Analog-to-Digital Converter

 *

 * Copyright (c) 2016, Intel Corporation.

 *

 * IIO driver for ADS1015 ADC 7-bit I2C slave address:

 *	* 0x48 - ADDR connected to Ground

 *	* 0x49 - ADDR connected to Vdd

 *	* 0x4A - ADDR connected to SDA

 *	* 0x4B - ADDR connected to SCL

 Comparator queue and disable field */

 Comparator polarity field */

 Comparator mode field */

 device operating modes */

/*

 * Translation from PGA bits to full-scale positive and negative input voltage

 * range in mV

/*

 * Translation from COMP_QUE field value to the number of successive readings

 * exceed the threshold values before an interrupt is generated

	/*

	 * Protects ADC ops, e.g: concurrent sysfs/buffered

	 * data reads, configuration updates

	/*

	 * Set to true when the ADC is switched to the continuous-conversion

	 * mode and exits from a power-down state.  This flag is used to avoid

	 * getting the stale result from the conversion register.

 !CONFIG_PM */

 !CONFIG_PM */

 10% internal clock inaccuracy */

 Ensure natural alignment of timestamp */

 Prevent from enabling both buffer and event at a time */

 Clear the latched ALERT/RDY pin */

 Prevent from enabling both buffer and event at a time */

 fallback on default configuration */

	/*

	 * Set default lower and upper threshold to min and max value

	 * respectively.

 we need to keep this ABI the same as used by hwmon ADS1015 driver */

 power down single shot mode */

 SPDX-License-Identifier: GPL-2.0

/*

 * iio/adc/max9611.c

 *

 * Maxim max9611/max9612 high side current sense amplifier with

 * 12-bit ADC interface.

 *

 * Copyright (C) 2017 Jacopo Mondi

/*

 * This driver supports input common-mode voltage, current-sense

 * amplifier with programmable gains and die temperature reading from

 * Maxim max9611/max9612.

 *

 * Op-amp, analog comparator, and watchdog functionalities are not

 * supported by this driver.

 max9611 register addresses */

 max9611 REG1 mux configuration options */

 max9611 voltage (both csa and input) helper macros */

/*

 * max9611 current sense amplifier voltage output:

 * LSB and offset values depends on selected gain (1x, 4x, 8x)

 *

 * GAIN		LSB (nV)	OFFSET (LSB steps)

 * 1x		107500		1

 * 4x		26880		1

 * 8x		13440		3

 *

 * The complete formula to calculate current sense voltage is:

 *     (((adc_read >> 4) - offset) / ((1 / LSB) * 10^-3)

/*

 * max9611 common input mode (CIM): LSB is 14mV, with 14mV offset at 25 C

 *

 * The complete formula to calculate input common voltage is:

 *     (((adc_read >> 4) * 1000) - offset) / (1 / 14 * 1000)

/*

 * max9611 temperature reading: LSB is 480 milli degrees Celsius

 *

 * The complete formula to calculate temperature is:

 *     ((adc_read >> 7) * 1000) / (1 / 480 * 1000)

/*

 * Conversion time is 2 ms (typically) at Ta=25 degreeC

 * No maximum value is known, so play it safe.

/*

 * max9611_mux_conf - associate ADC mux configuration with register address

 *		      where data shall be read from

/*

 * max9611_csa_gain_conf - associate gain multiplier with LSB and

 *			   offset values.

 *

 * Group together parameters associated with configurable gain

 * on current sense amplifier path to ADC interface.

 * Current sense read routine adjusts gain until it gets a meaningful

 * value; use this structure to retrieve the correct LSB and offset values.

/**

 * max9611_read_single() - read a single value from ADC interface

 *

 * Data registers are 16 bit long, spread between two 8 bit registers

 * with consecutive addresses.

 * Configure ADC mux first, then read register at address "reg_addr".

 * The smbus_read_word routine asks for 16 bits and the ADC is kind enough

 * to return values from "reg_addr" and "reg_addr + 1" consecutively.

 * Data are transmitted with big-endian ordering: MSB arrives first.

 *

 * @max9611: max9611 device

 * @selector: index for mux and register configuration

 * @raw_val: the value returned from ADC

	/*

	 * Keep mutex lock held during read-write to avoid mux register

	 * (CTRL1) re-configuration.

 need a delay here to make register configuration stabilize. */

/**

 * max9611_read_csa_voltage() - read current sense amplifier output voltage

 *

 * Current sense amplifier output voltage is read through a configurable

 * 1x, 4x or 8x gain.

 * Start with plain 1x gain, and adjust gain control properly until a

 * meaningful value is read from ADC output.

 *

 * @max9611: max9611 device

 * @adc_raw: raw value read from ADC output

 * @csa_gain: gain configuration option selector

 MAX9611_CHAN_VOLTAGE_INPUT */

			/*

			 * processed (mV): (raw - offset) * LSB (nV) / 10^6

			 *

			 * Even if max9611 can output raw csa voltage readings,

			 * use a produced value as scale depends on gain.

 processed (mA): Vcsa (nV) / Rshunt (uOhm)  */

			/*

			 * processed (mW): Vin (mV) * Vcsa (uV) /

			 *		   Rshunt (uOhm)

 divide by 10^3 here to avoid 32bit overflow */

 Make sure die temperature is in range to test communications. */

 Mux shall be zeroed back before applying other configurations */

 SPDX-License-Identifier: GPL-2.0

/*

 * AD7606 SPI ADC driver

 *

 * Copyright 2011 Analog Devices Inc.

/*

 * Scales are computed as 5000/32768 and 10000/32768 respectively,

 * so that when applied to the raw values they provide mV values

 t_reset >= 100ns */

	/*

	 * The frstdata signal is set to high while and after reading the sample

	 * of the first channel and low for all other channels. This can be used

	 * to check that the incoming data is correctly aligned. During normal

	 * operation the data should never become unaligned, but some glitch or

	 * electrostatic discharge might cause an extra read or clock cycle.

	 * Monitoring the frstdata signal allows to recover from such failure

	 * situations.

 The rising edge of the CONVST signal starts a new conversion. */

 AD7616 requires a reset to update value */

/*

 * The current assumption that this driver makes for AD7616, is that it's

 * working in Hardware Mode with Serial, Burst and Sequencer modes activated.

 * To activate them, following pins must be pulled high:

 *	-SER/PAR

 *	-SEQEN

 * And following pins must be pulled low:

 *	-WR/BURST

 *	-DB4/SER1W

 More devices added in future */

/*

 * The BUSY signal indicates when conversions are in progress, so when a rising

 * edge of CONVST is applied, BUSY goes logic high and transitions low at the

 * end of the entire conversion process. The falling edge of the BUSY signal

 * triggers this interrupt.

 tied to logic low, analog input range is +/- 5V */

 AD7616 requires al least 15ms to reconfigure after a reset */

 Scale of 0.076293 is only available in sw mode */

 After reset, in software mode, ±10 V is set by default */

 SPDX-License-Identifier: GPL-2.0

/*

 * This file is part of STM32 ADC driver

 *

 * Copyright (C) 2016, STMicroelectronics - All Rights Reserved

 * Author: Fabrice Gasnier <fabrice.gasnier@st.com>.

 *

 * Inspired from: fsl-imx25-tsadc

 *

 SYSCFG registers */

 SYSCFG bit fields */

 SYSCFG capability flags */

/**

 * struct stm32_adc_common_regs - stm32 common registers

 * @csr:	common status register offset

 * @ccr:	common control register offset

 * @eoc_msk:    array of eoc (end of conversion flag) masks in csr for adc1..n

 * @ovr_msk:    array of ovr (overrun flag) masks in csr for adc1..n

 * @ier:	interrupt enable register offset for each adc

 * @eocie_msk:	end of conversion interrupt enable mask in @ier

/**

 * struct stm32_adc_priv_cfg - stm32 core compatible configuration data

 * @regs:	common registers for all instances

 * @clk_sel:	clock selection routine

 * @max_clk_rate_hz: maximum analog clock rate (Hz, from datasheet)

 * @has_syscfg: SYSCFG capability flags

 * @num_irqs:	number of interrupt lines

/**

 * struct stm32_adc_priv - stm32 ADC core private data

 * @irq:		irq(s) for ADC block

 * @domain:		irq domain reference

 * @aclk:		clock reference for the analog circuitry

 * @bclk:		bus clock common for all ADCs, depends on part used

 * @max_clk_rate:	desired maximum clock rate

 * @booster:		booster supply reference

 * @vdd:		vdd supply reference

 * @vdda:		vdda analog supply reference

 * @vref:		regulator reference

 * @vdd_uv:		vdd supply voltage (microvolts)

 * @vdda_uv:		vdda supply voltage (microvolts)

 * @cfg:		compatible configuration data

 * @common:		common data for all ADC instances

 * @ccr_bak:		backup CCR in low power mode

 * @syscfg:		reference to syscon, system control registers

 STM32F4 ADC internal common clock prescaler division ratios */

/**

 * stm32f4_adc_clk_sel() - Select stm32f4 ADC common clock prescaler

 * @pdev: platform device

 * @priv: stm32 ADC core private data

 * Select clock prescaler used for analog conversions, before using ADC.

 stm32f4 has one clk input for analog (mandatory), enforce it here */

/**

 * struct stm32h7_adc_ck_spec - specification for stm32h7 adc clock

 * @ckmode: ADC clock mode, Async or sync with prescaler.

 * @presc: prescaler bitfield for async clock mode

 * @div: prescaler division ratio

 00: CK_ADC[1..3]: Asynchronous clock modes */

 HCLK used: Synchronous clock modes (1, 2 or 4 prescaler) */

 stm32h7 bus clock is common for all ADC instances (mandatory) */

	/*

	 * stm32h7 can use either 'bus' or 'adc' clock for analog circuitry.

	 * So, choice is to have bus clock mandatory and adc clock optional.

	 * If optional 'adc' clock has been found, then try to use it first.

		/*

		 * Asynchronous clock modes (e.g. ckmode == 0)

		 * From spec: PLL output musn't exceed max rate

 If duty is an error, kindly use at least /2 divider */

			/*

			 * For proper operation, clock duty cycle range is 49%

			 * to 51%. Apply at least /2 prescaler otherwise.

 Synchronous clock modes (e.g. ckmode is 1, 2 or 3) */

 rate used later by each ADC instance to control BOOST mode */

 Set common clock mode and prescaler */

 STM32F4 common registers definitions */

 STM32H7 common registers definitions */

 ADC common interrupt for all instances */

	/*

	 * End of conversion may be handled by using IRQ or DMA. There may be a

	 * race here when two conversions complete at the same time on several

	 * ADCs. EOC may be read 'set' for several ADCs, with:

	 * - an ADC configured to use DMA (EOC triggers the DMA request, and

	 *   is then automatically cleared by DR read in hardware)

	 * - an ADC configured to use IRQs (EOCIE bit is set. The handler must

	 *   be called in this case)

	 * So both EOC status bit in CSR and EOCIE control bit must be checked

	 * before invoking the interrupt handler (e.g. call ISR only for

	 * IRQ-enabled ADCs).

	/*

	 * Interrupt(s) must be provided, depending on the compatible:

	 * - stm32f4/h7 shares a common interrupt line.

	 * - stm32mp1, has one line per ADC

	/*

	 * On STM32H7 and STM32MP1, the ADC inputs are multiplexed with analog

	 * switches (via PCSEL) which have reduced performances when their

	 * supply is below 2.7V (vdda by default):

	 * - Voltage booster can be used, to get full ADC performances

	 *   (increases power consumption).

	 * - Vdd can be used to supply them, if above 2.7V (STM32MP1 only).

	 *

	 * Recommended settings for ANASWVDD and EN_BOOSTER:

	 * - vdda < 2.7V but vdd > 2.7V: ANASWVDD = 1, EN_BOOSTER = 0 (stm32mp1)

	 * - vdda < 2.7V and vdd < 2.7V: ANASWVDD = 0, EN_BOOSTER = 1

	 * - vdda >= 2.7V:               ANASWVDD = 0, EN_BOOSTER = 0 (default)

			/*

			 * This is optional, as this is a trade-off between

			 * analog performance and power consumption.

 Fallback using vdda (default), nothing to do */

 Backup CCR that may be lost (depends on power state to achieve) */

 Analog switches supply can be controlled by syscfg (optional) */

 Booster can be used to supply analog switches (optional) */

 Vdd can be used to supply analog switches (optional) */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Renesas R-Car GyroADC driver

 *

 * Copyright 2016 Marek Vasut <marek.vasut@gmail.com>

 GyroADC registers. */

 Hz */

	/*

	 * According to the R-Car Gen2 datasheet Rev. 1.01, Sept 08 2014,

	 * page 77-7, clock length must be even number. If it's odd number,

	 * add one.

 Stop the GyroADC. */

 Disable IRQ on V2H. */

 Set mode and timing. */

 Start sampling. */

	/*

	 * Wait for the first conversion to complete. This is longer than

	 * the 1.25 mS in the datasheet because 1.25 mS is not enough for

	 * the hardware to deliver the first sample and the hardware does

	 * then return zeroes instead of valid data.

 Stop the GyroADC. */

	/*

	 * MB88101 is special in that it has only single regulator for

	 * all four channels.

 Channel not connected. */

 Channel not connected. */

 Handle the V2H case with extra interrupt block. */

 R-Car compatible GyroADC */

 R-Car V2H specialty with interrupt registers. */

 sentinel */

 Mode 1 ADCs */

 Mode 2 ADCs */

 Mode 3 ADCs */

 sentinel */ }

		/*

		 * MB88101 is special in that it's only a single chip taking

		 * up all the CHS lines. Thus, the DT binding is also special

		 * and has no reg property. If we run into such ADC, handle

		 * it here.

 Channel number is too high. */

 Child node selected different mode than the rest. */

 Channel is valid, grab the regulator. */

 First child node which passed sanity tests. */

		/*

		 * MB88101 is special and we only have one such device

		 * attached to the GyroADC at a time, so if we found it,

		 * we can stop parsing here.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * IIO driver for the Apex Embedded Systems STX104

 * Copyright (C) 2016 William Breathitt Gray

/**

 * struct stx104_iio - IIO device private data structure

 * @chan_out_states:	channels' output states

 * @base:		base port address of the IIO device

/**

 * struct stx104_gpio - GPIO device private data structure

 * @chip:	instance of the gpio_chip

 * @lock:	synchronization lock to prevent I/O race conditions

 * @base:	base port address of the GPIO device

 * @out_state:	output bits state

 get gain configuration */

 select ADC channel */

 trigger ADC sample capture and wait for completion */

 get ADC bipolar/unipolar configuration */

 get ADC bipolar/unipolar and gain configuration */

 Only four gain states (x1, x2, x4, x8) */

 DAC can only accept up to a 16-bit value */

 single-ended input channels configuration */

 differential input channels configuration */

 GPIO 0-3 are input only, while the rest are output only */

 verify masked GPIO are output */

 determine if differential inputs */

 configure device for software trigger operation */

 initialize gain setting to x1 */

 initialize DAC output to 0V */

 SPDX-License-Identifier: GPL-2.0

/*

 * ADC driver for the Ingenic JZ47xx SoCs

 * Copyright (c) 2019 Artur Rojek <contact@artur-rojek.eu>

 *

 * based on drivers/mfd/jz4740-adc.c

 Init ADCMD */

 Second channel (INGENIC_ADC_TOUCH_YP): sample YP vs. GND */

 First channel (INGENIC_ADC_TOUCH_XP): sample XP vs. GND */

 Fourth channel (INGENIC_ADC_TOUCH_YN): sample YN vs. GND */

 Third channel (INGENIC_ADC_TOUCH_XN): sample XN vs. GND */

 Sixth channel (INGENIC_ADC_TOUCH_YD): sample YP vs. YN */

 Fifth channel (INGENIC_ADC_TOUCH_XD): sample XP vs. XN */

 We're done */

	/*

	 * Disable CMD_SEL temporarily, because it causes wrong VBAT readings,

	 * probably due to the switch of VREF. We must keep the lock here to

	 * avoid races with the buffer enable/disable functions.

	/*

	 * The JZ4725B ADC works at 500 kHz to 8 MHz.

	 * We pick the highest rate possible.

	 * In practice we typically get 6 MHz, half of the 12 MHz EXT clock.

 We also need a divider that produces a 10us clock. */

	/*

	 * The JZ4770 ADC works at 20 kHz to 200 kHz.

	 * We pick the highest rate possible.

 We also need a divider that produces a 10us clock. */

 And another, which produces a 1ms clock. */

 no ADCLK register on JZ4740 */

 We cannot sample the aux channels in parallel. */

 It takes significant time for the touchscreen hw to stabilize. */

 Set clock dividers. */

 Put hardware in a known passive state. */

 JZ4760B specific */

 Must wait at least 2ms. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Analog Devices AD7292 SPI ADC driver

 *

 * Copyright 2019 Analog Devices Inc.

 AD7292 registers definition */

 AD7292 configuration bank subregisters definition */

 AD7292_REG_ADC_CONVERSION */

 AD7292_CHANNEL_SAMPLING_MODE */

 AD7292_CHANNEL_VIN_RANGE */

	/*

	 * Every AD7292 ADC channel may have its input range adjusted according

	 * to the settings at the ADC sampling mode and VIN range subregisters.

	 * For a given channel, the minimum input range is equal to Vref, and it

	 * may be increased by a multiplier factor of 2 or 4 according to the

	 * following rule:

	 * If channel is being sampled with respect to AGND:

	 *	factor = 4 if VIN range0 and VIN range1 equal 0

	 *	factor = 2 if only one of VIN ranges equal 1

	 *	factor = 1 if both VIN range0 and VIN range1 equal 1

	 * If channel is being sampled with respect to AVDD:

	 *	factor = 4 if VIN range0 and VIN range1 equal 0

	 *	Behavior is undefined if any of VIN range doesn't equal 0

 Sampling with respect to AGND */

 Sampling with respect to AVDD */

		/*

		 * To convert a raw value to standard units, the IIO defines

		 * this formula: Scaled value = (raw + offset) * scale.

		 * For the scale to be a correct multiplier for (raw + offset),

		 * it must be calculated as the input range divided by the

		 * number of possible distinct input values. Given the ADC data

		 * is 10 bit long, it may assume 2^10 distinct values.

		 * Hence, scale = range / 2^10. The IIO_VAL_FRACTIONAL_LOG2

		 * return type indicates to the IIO API to divide *val by 2 to

		 * the power of *val2 when returning from read_raw.

 Use the internal voltage reference. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * AD7904/AD7914/AD7923/AD7924/AD7908/AD7918/AD7928 SPI ADC driver

 *

 * Copyright 2011 Analog Devices Inc (from AD7923 Driver)

 * Copyright 2012 CS Systemes d'Information

 write control register */

 range to REFin */

 coding is straight binary */

 auto shutdown */

 full shutdown */

 normal operation */

 no sequence fonction */

 no interrupt write cycle */

 continuous sequence */

 write mode */

 write channel */

 write sequence fonction */

 left shift for CR : bit 11 transmit in first */

 val = value, dec = left shift, bits = number of bits of the mask */

	/*

	 * DMA (thus cache coherency maintenance) requires the

	 * transfer buffers to live in their own cache lines.

	 * Ensure rx_buf can be directly used in iio_push_to_buffers_with_timetamp

	 * Length = 8 channels + 4 extra for 8 byte timestamp

/*

 * ad7923_update_scan_mode() setup the spi transfer buffer for the new scan mask

	/*

	 * For this driver the last channel is always the software timestamp so

	 * skip that one.

 build spi ring message */

 make sure last transfer cs_change is not set */

 Setup default message */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Xilinx XADC driver

 *

 * Copyright 2013-2014 Analog Devices Inc.

 *  Author: Lars-Peter Clausen <lars@metafoo.de>

 *

 * Documentation for the parts can be found at:

 *  - XADC hardmacro: Xilinx UG480

 *  - ZYNQ XADC interface: Xilinx UG585

 *  - AXI XADC interface: Xilinx PG019

 ZYNQ register definitions */

 AXI register definitions */

 7 Series */

 UltraScale */

/*

 * The XADC hardware supports a samplerate of up to 1MSPS. Unfortunately it does

 * not have a hardware FIFO. Which means an interrupt is generated for each

 * conversion sequence. At 1MSPS sample rate the CPU in ZYNQ7000 is completely

 * overloaded by the interrupts that it soft-lockups. For this reason the driver

 * limits the maximum samplerate 150kSPS. At this rate the CPU is fairly busy,

 * but still responsive.

/*

 * The ZYNQ interface uses two asynchronous FIFOs for communication with the

 * XADC. Reads and writes to the XADC register are performed by submitting a

 * request to the command FIFO (CFIFO), once the request has been completed the

 * result can be read from the data FIFO (DFIFO). The method currently used in

 * this driver is to submit the request for a read/write operation, then go to

 * sleep and wait for an interrupt that signals that a response is available in

 * the data FIFO.

/*

 * The ZYNQ threshold interrupts are level sensitive. Since we can't make the

 * threshold condition go way from within the interrupt handler, this means as

 * soon as a threshold condition is present we would enter the interrupt handler

 * again and again. To work around this we mask all active thresholds interrupts

 * in the interrupt handler and start a timer. In this timer we poll the

 * interrupt status and only if the interrupt is inactive we unmask it again.

 Clear those bits which are not active anymore */

 Also clear those which are masked out anyway */

 Clear the interrupts before we unmask them */

 if still pending some alarm re-trigger the timer */

		/*

		 * mask the current event interrupt,

		 * unmask it when the interrupt is no more active.

 unmask the required interrupts in timer. */

 TODO: Figure out how to make igap and tck_rate configurable */

 Move OT to bit 7 */

 Clear previous interrupts if any. */

		/*

		 * The order of the bits in the AXI-XADC status register does

		 * not match the order of the bits in the XADC alarm enable

		 * register. xadc_handle_events() expects the events to be in

		 * the same order as the XADC alarm enable register.

	/*

	 * The order of the bits in the AXI-XADC status register does not match

	 * the order of the bits in the XADC alarm enable register. We get

	 * passed the alarm mask in the same order as in the XADC alarm enable

	 * register.

 Only one of the two triggers can be active at a time. */

	/*

	 * As per datasheet the power-down bits are don't care in the

	 * UltraScale, but as per reality setting the power-down bit for the

	 * non-existing ADC-B powers down the main ADC, so just return and don't

	 * do anything.

 Powerdown the ADC-B when it is not needed. */

 UltraScale has only one ADC and supports only continuous mode */

 Run calibration as part of the sequence */

 Enable all channels and calibration */

	/*

	 * In simultaneous mode the upper and lower aux channels are samples at

	 * the same time. In this mode the upper 8 bits in the sequencer

	 * register are don't care and the lower 8 bits control two channels

	 * each. As such we must set the bit if either the channel in the lower

	 * group or the upper group is enabled.

 V = (val * 3.0) / 2**bits */

 Temp in C = (val * 503.975) / 2**bits - 273.15 */

 Only the temperature channel has an offset */

 Max. 150 kSPS */

 Min 1MHz */

	/*

	 * We want to round down, but only if we do not exceed the 150 kSPS

	 * limit.

 Separate values for upper and lower thresholds, but only a shared enabled */

 7 Series */

 UltraScale */

 If we can't resize the channels array, just use the original */

	/*

	 * Make sure not to exceed the maximum samplerate since otherwise the

	 * resulting interrupt storm will soft-lock the system.

 Disable all alarms */

 Set thresholds to min/max */

		/*

		 * Set max voltage threshold and both temperature thresholds to

		 * 0xffff, min voltage threshold to 0.

 Go to non-buffered mode */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Qualcomm PM8xxx PMIC XOADC driver

 *

 * These ADCs are known as HK/XO (house keeping / chrystal oscillator)

 * "XO" in "XOADC" means Chrystal Oscillator. It's a bunch of

 * specific-purpose and general purpose ADC converters and channels.

 *

 * Copyright (C) 2017 Linaro Ltd.

 * Author: Linus Walleij <linus.walleij@linaro.org>

/*

 * Definitions for the "user processor" registers lifted from the v3.4

 * Qualcomm tree. Their kernel has two out-of-tree drivers for the ADC:

 * drivers/misc/pmic8058-xoadc.c

 * drivers/hwmon/pm8xxx-adc.c

 * None of them contain any complete register specification, so this is

 * a best effort of combining the information.

 These appear to be "battery monitor" registers */

 Proper ADC registers */

/*

 * The channel mask includes the bits selecting channel mux and prescaler

 * on PM8058, or channel mux and premux on PM8921.

 On PM8058 this is prescaling, on PM8921 this is premux */

 We know very little about the bits in this register */

/*

 * On a later ADC the decimation factors are defined as

 * 00 = 512, 01 = 1024, 10 = 2048, 11 = 4096 so assume this

 * holds also for this older XOADC.

/*

 * Physical channels which MUST exist on all PM variants in order to provide

 * proper reference points for calibration.

 *

 * @PM8XXX_CHANNEL_INTERNAL: 625mV reference channel

 * @PM8XXX_CHANNEL_125V: 1250mV reference channel

 * @PM8XXX_CHANNEL_INTERNAL_2: 325mV reference channel

 * @PM8XXX_CHANNEL_MUXOFF: channel to reduce input load on mux, apparently also

 * measures XO temperature

/*

 * PM8058 AMUX premux scaling, two bits. This is done of the channel before

 * reaching the AMUX.

 No scaling on the signal */

 Unity scaling selected by the user */

 1/3 prescaler on the input */

 Defines reference voltage for the XOADC */

 XO_IN/XOADC_GND, special selection to read XO temp */

 PMIC_IN/XOADC_GND */

 PMIC_IN/BMS_CSP */

 not used */

 XOADC_GND/XOADC_GND */

 XOADC_VREF/XOADC_GND */

 3 bits 0..7, 3 and 6,7 are invalid */

/**

 * struct xoadc_channel - encodes channel properties and defaults

 * @datasheet_name: the hardwarename of this channel

 * @pre_scale_mux: prescale (PM8058) or premux (PM8921) for selecting

 * this channel. Both this and the amux channel is needed to uniquely

 * identify a channel. Values 0..3.

 * @amux_channel: value of the ADC_ARB_USRP_AMUX_CNTRL register for this

 * channel, bits 4..7, selects the amux, values 0..f

 * @prescale: the channels have hard-coded prescale ratios defined

 * by the hardware, this tells us what it is

 * @type: corresponding IIO channel type, usually IIO_VOLTAGE or

 * IIO_TEMP

 * @scale_fn_type: the liner interpolation etc to convert the

 * ADC code to the value that IIO expects, in uV or millicelsius

 * etc. This scale function can be pretty elaborate if different

 * thermistors are connected or other hardware characteristics are

 * deployed.

 * @amux_ip_rsv: ratiometric scale value used by the analog muxer: this

 * selects the reference voltage for ratiometric scaling

/**

 * struct xoadc_variant - encodes the XOADC variant characteristics

 * @name: name of this PMIC variant

 * @channels: the hardware channels and respective settings and defaults

 * @broken_ratiometric: if the PMIC has broken ratiometric scaling (this

 * is a known problem on PM8058)

 * @prescaling: this variant uses AMUX bits 2 & 3 for prescaling (PM8058)

 * @second_level_mux: this variant uses AMUX bits 2 & 3 for a second level

 * mux

/*

 * XOADC_CHAN macro parameters:

 * _dname: the name of the channel

 * _presmux: prescaler (PM8058) or premux (PM8921) setting for this channel

 * _amux: the value in bits 2..7 of the ADC_ARB_USRP_AMUX_CNTRL register

 * for this channel. On some PMICs some of the bits select a prescaler, and

 * on some PMICs some of the bits select various complex multiplex settings.

 * _type: IIO channel type

 * _prenum: prescaler numerator (dividend)

 * _preden: prescaler denominator (divisor)

 * _scale: scaling function type, this selects how the raw valued is mangled

 * to output the actual processed measurement

 * _amip: analog mux input parent when using ratiometric measurements

/*

 * Taken from arch/arm/mach-msm/board-9615.c in the vendor tree:

 * TODO: incomplete, needs testing.

 Used for battery ID or battery temperature */

 Sentinel */

/*

 * Taken from arch/arm/mach-msm/board-8930-pmic.c in the vendor tree:

 * TODO: needs testing.

 AMUX8 used for battery temperature in most cases */

 Sentinel */

/*

 * This was created by cross-referencing the vendor tree

 * arch/arm/mach-msm/board-msm8x60.c msm_adc_channels_data[]

 * with the "channel types" (first field) to find the right

 * configuration for these channels on an MSM8x60 i.e. PM8058

 * setup.

	/*

	 * AMUX channels 5 thru 9 are referred to as MPP5 thru MPP9 in

	 * some code and documentation. But they are really just 5

	 * channels just like any other. They are connected to a switching

	 * matrix where they can be routed to any of the MPPs, not just

	 * 1-to-1 onto MPP5 thru 9, so naming them MPP5 thru MPP9 is

	 * very confusing.

 There are also "unity" and divided by 3 channels (prescaler) but noone is using them */

 Sentinel */

/*

 * The PM8921 has some pre-muxing on its channels, this comes from the vendor tree

 * include/linux/mfd/pm8xxx/pm8xxx-adc.h

 * board-flo-pmic.c (Nexus 7) and board-8064-pmic.c

 channel "ICHG" is reserved and not used on PM8921 */

 CHAN 6 & 7 (MPP1 & MPP2) are reserved for MPP channels on PM8921 */

 FIXME: look into the scaling of this temperature */

 The following channels have premux bit 0 set to 1 (all end in 4) */

 Set scaling to 1/2 based on the name for these two */

 Internal test signals, I think */

 The following channels have premux bit 1 set to 1 (all end in 8) */

 I guess even ATEST8 will be divided by 3 here */

 I guess div 2 div 3 becomes div 6 */

 Sentinel */

/**

 * struct pm8xxx_chan_info - ADC channel information

 * @name: name of this channel

 * @hwchan: pointer to hardware channel information (muxing & scaling settings)

 * @calibration: whether to use absolute or ratiometric calibration

 * @scale_fn_type: scaling function type

 * @decimation: 0,1,2,3

 * @amux_ip_rsv: ratiometric scale value if using ratiometric

 * calibration: 0, 1, 2, 4, 5.

/**

 * struct pm8xxx_xoadc - state container for the XOADC

 * @dev: pointer to device

 * @map: regmap to access registers

 * @variant: XOADC variant characteristics

 * @vref: reference voltage regulator

 * characteristics of the channels, and sensible default settings

 * @nchans: number of channels, configured by the device tree

 * @chans: the channel information per-channel, configured by the device tree

 * @iio_chans: IIO channel specifiers

 * @graph: linear calibration parameters for absolute and

 * ratiometric measurements

 * @complete: completion to indicate end of conversion

 * @lock: lock to restrict access to the hardware to one client at the time

 Mux in this channel */

 Set up ratiometric scale value, mask off all bits except these */

		/*

		 * Apparently the PM8058 has some kind of bug which is

		 * reflected in the vendor tree drivers/misc/pmix8058-xoadc.c

		 * which just hardcodes the RSV selector to SEL1 (0x20) for

		 * most cases and SEL0 (0x10) for the MUXOFF channel only.

		 * If we force ratiometric (currently only done when attempting

		 * to do ratiometric calibration) this doesn't seem to work

		 * very well and I suspect ratiometric conversion is simply

		 * broken or not supported on the PM8058.

		 *

		 * Maybe IO_SEL2 doesn't exist on PM8058 and bits 4 & 5 select

		 * the mode alone.

		 *

		 * Some PM8058 register documentation would be nice to get

		 * this right.

 Decimation factor */

 Enable the arbiter, the Qualcomm code does it twice like this */

 Fire a request! */

 Next the interrupt occurs */

 Turn off the ADC by setting the arbiter to 0 twice */

	/*

	 * Normally we just use the ratiometric scale value (RSV) predefined

	 * for the channel, but during calibration we need to modify this

	 * so this wrapper is a helper hiding the more complex version.

 Common reference channel calibration */

 Ratiometric calibration */

	/*

	 * First cell is prescaler or premux, second cell is analog

	 * mux.

 We need to match exactly on the prescale/premux and channel */

 Find the right channel setting */

 The sentinel does not have a name assigned */

 Everyone seems to use absolute calibration except in special cases */

 Everyone seems to use default ("type 2") decimation */

 Optional decimation, if omitted we use the default */

 All channels are raw or processed */

 Check for required channels */

 Bring up regulator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for the Nuvoton NAU7802 ADC

 *

 * Copyright 2013 Free Electrons

/*

 * Conversions are synchronised on the rising edge of NAU7802_PUCTRL_CS_BIT

	/*

	 * Because there is actually only one ADC for both channels, we have to

	 * wait for enough conversions to happen before getting a significant

	 * value when changing channels and the values are far apart.

 read registers to ensure we flush everything */

 Wait for a conversion to finish */

 read registers to ensure we flush everything */

	/*

	 * Because there is actually only one ADC for both channels, we have to

	 * wait for enough conversions to happen before getting a significant

	 * value when changing channels and the values are far appart.

		/*

		 * Select the channel to use

		 *   - Channel 1 is value 0 in the CHS register

		 *   - Channel 2 is value 1 in the CHS register

		/*

		 * We have 24 bits of signed data, that means 23 bits of data

		 * plus the sign bit

 Reset the device */

 Enter normal operation mode */

	/*

	 * After about 200 usecs, the device should be ready and then

	 * the Power Up bit will be set to 1. If not, wait for it.

 Populate available ADC input ranges */

	/*

	 * The ADC fires continuously and we can't do anything about

	 * it. So we need to have the IRQ disabled by default, and we

	 * will enable them back when we will need them..

			/*

			 * What may happen here is that our IRQ controller is

			 * not able to get level interrupt but this is required

			 * by this ADC as when going over 40 sample per second,

			 * the interrupt line may stay high between conversions.

			 * So, we continue no matter what but we switch to

			 * polling mode.

		/*

		 * We are polling, use the fastest sample rate by

		 * default

 Setup the ADC channels available on the board */

 SPDX-License-Identifier: GPL-2.0

/*

 * Amlogic Meson Successive Approximation Register (SAR) A/D Converter

 *

 * Copyright (C) 2017 Martin Blumenstingl <martin.blumenstingl@googlemail.com>

/*

 * NOTE: registers from here are undocumented (the vendor Linux kernel driver

 * and u-boot source served as reference). These only seem to be relevant on

 * GXBB and newer.

 ms */

 temperature sensor calibration information in eFuse */

 for use with IIO_VAL_INT_PLUS_MICRO */

 use val_calib = scale * val_raw + offset calibration function */

	/*

	 * NOTE: we need a small delay before reading the status, otherwise

	 * the sample engine may not have started internally (which would

	 * seem to us that sampling is already finished).

	/*

	 * the SAR ADC engine allows sampling multiple channels at the same

	 * time. to keep it simple we're only working with one *internal*

	 * channel, which starts counting at index 0 (which means: count = 1).

 map channel index 0 to the channel which we want to read */

 wait until all modules are stopped */

 prevent BL30 from using the SAR ADC while we are using it */

		/*

		 * wait until BL30 releases it's lock (so we can use the SAR

		 * ADC)

 allow BL30 to use the SAR ADC again */

 clear the FIFO to make sure we're not reading old values */

 SoC specific multiplier and divider */

 celsius to millicelsius */

		/*

		 * leave the temperature sensor disabled if no calibration data

		 * was passed via nvmem-cells.

	/*

	 * make sure we start at CH7 input since the other muxes are only used

	 * for internal calibration.

		/*

		 * leave sampling delay and the input clocks as configured by

		 * BL30 to make sure BL30 gets the values it expects when

		 * reading the temperature sensor.

	/*

	 * disable this bit as seems to be only relevant for Meson6 (based

	 * on the vendor driver), which we don't support at the moment.

 disable all channels by default */

 delay between two samples = (10+1) * 1uS */

 delay between two samples = (10+1) * 1uS */

	/*

	 * set up the input channel muxes in MESON_SAR_ADC_CHAN_10_SW

	 * (0 = SAR_ADC_CH0, 1 = SAR_ADC_CH1)

	/*

	 * set up the input channel muxes in MESON_SAR_ADC_AUX_SW

	 * (2 = SAR_ADC_CH2, 3 = SAR_ADC_CH3, ...) and enable

	 * MESON_SAR_ADC_AUX_SW_YP_DRIVE_SW and

	 * MESON_SAR_ADC_AUX_SW_XP_DRIVE_SW like the vendor driver.

		/*

		 * set bits [3:0] of the TSC (temperature sensor coefficient)

		 * to get the correct values when reading the temperature.

			/*

			 * bit [4] (the 5th bit when starting to count at 1)

			 * of the TSC is located in the HHI register area.

 use points 25% and 75% for calibration */

 sentinel */ }

 on pre-GXBB SoCs the SAR ADC itself provides the ADC clock: */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.

/*

 * Conversion time varies based on the decimation, clock rate, fast average

 * samples and measurements queued across different VADC peripherals.

 * Set the timeout to a max of 100ms.

 Digital version >= 5.3 supports hw_settle_2 */

 For PMIC7 */

/**

 * struct adc5_channel_prop - ADC channel property.

 * @channel: channel number, refer to the channel list.

 * @cal_method: calibration method.

 * @cal_val: calibration value

 * @decimation: sampling rate supported for the channel.

 * @sid: slave id of PMIC owning the channel, for PMIC7.

 * @prescale: channel scaling performed on the input signal.

 * @hw_settle_time: the time between AMUX being configured and the

 *	start of conversion.

 * @avg_samples: ability to provide single result from the ADC

 *	that is an average of multiple measurements.

 * @scale_fn_type: Represents the scaling function to convert voltage

 *	physical units desired by the client for the channel.

 * @datasheet_name: Channel name used in device tree.

/**

 * struct adc5_chip - ADC private structure.

 * @regmap: SPMI ADC5 peripheral register map field.

 * @dev: SPMI ADC5 device.

 * @base: base address for the ADC peripheral.

 * @nchannels: number of ADC channels.

 * @chan_props: array of ADC channel properties.

 * @iio_chans: array of IIO channels specification.

 * @poll_eoc: use polling instead of interrupt.

 * @complete: ADC result notification after interrupt is received.

 * @lock: ADC lock for access to the peripheral.

 * @data: software configuration data.

 Update calibration value */

 Update calibration select */

 Update decimation ratio select */

 Read registers 0x42 through 0x46 */

 Digital param selection */

 Update fast average sample value */

 Select ADC channel */

 Select HW settle delay for channel */

 Select ADC enable */

 Select CONV request */

 Digital param selection */

 Update fast average sample value */

 Select ADC channel */

 Select HW settle delay for channel */

 Select CONV request */

 No support for polling mode at present */

 In these definitions, _pre refers to an index into adc5_prescale_ratios. */

 Charger prescales SBUx and MID_CHG to fit within 1.8V upper unit */

 Value read from "reg" is virtual channel number */

 virtual channel number = sid << 8 | channel number */

 the channel has DT description */

 Digital controller >= 5.3 have hw_settle_2 option */

	/*

	 * Default to using timer calibration. Using a fresh calibration value

	 * for every conversion will increase the overall time for a request.

 SPDX-License-Identifier: GPL-2.0

/**

 * struct vadc_map_pt - Map the graph representation for ADC channel

 * @x: Represent the ADC digitized code.

 * @y: Represent the physical data which can be temperature, voltage,

 *     resistance.

 Voltage to temperature */

/*

 * Voltage to temperature table for 100k pull up for NTCG104EF104 with

 * 1.875V reference.

/*

 * Resistance to temperature table for 100k pull up for NTCG104EF104.

 interpolate linearly */

	/*

	 * Table must be sorted, find the interval of 'y' which contains value

	 * 'input' and map it to proper 'x' value

 interpolate linearly */

 Temporary variable for do_div */

 convert voltage to ADC code, using 1.875V reference */

 reference voltage */

	/*

	 * The normal data range is between 0V to 1.875V. On cases where

	 * we read low voltage values, the ADC code can go beyond the

	 * range and the scale result is incorrect so we clamp the values

	 * for the cases where the code represents a value below 0V

 (ADC code * vref_vadc (1.875V)) / full_scale_code */

 (ADC code * R_PULLUP (100Kohm)) / (full_scale_code - ADC code)*/

 Map voltage to temperature from look-up table */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Freescale MXS LRADC ADC driver

 *

 * Copyright (c) 2012 DENX Software Engineering, GmbH.

 * Copyright (c) 2017 Ksenija Stanojevic <ksenija.stanojevic@gmail.com>

 *

 * Authors:

 *  Marek Vasut <marex@denx.de>

 *  Ksenija Stanojevic <ksenija.stanojevic@gmail.com>

/*

 * Make this runtime configurable if necessary. Currently, if the buffered mode

 * is enabled, the LRADC takes LRADC_DELAY_TIMER_LOOP samples of data before

 * triggering IRQ. The sampling happens every (LRADC_DELAY_TIMER_PER / 2000)

 * seconds. The result is that the samples arrive every 500mS.

 CH0 */

 CH1 */

 CH2 */

 CH3 */

 CH4 */

 CH5 */

 CH6 VDDIO */

 CH7 VBATT */

 CH8 Temp sense 0 */

 CH9 Temp sense 1 */

 CH10 */

 CH11 */

 CH12 USB_DP */

 CH13 USB_DN */

 CH14 VBG */

 CH15 VDD5V */

 CH0 */

 CH1 */

 CH2 */

 CH3 */

 CH4 */

 CH5 */

 CH6 */

 CH7 VBATT */

 CH8 Temp sense 0 */

 CH9 Temp sense 1 */

 CH10 VDDIO */

 CH11 VTH */

 CH12 VDDA */

 CH13 VDDD */

 CH14 VBG */

 CH15 VDD5V */

 Maximum of 8 channels + 8 byte ts */

 Raw I/O operations */

	/*

	 * See if there is no buffered operation in progress. If there is simply

	 * bail out. This can be improved to support both buffered and raw IO at

	 * the same time, yet the code becomes horribly complicated. Therefore I

	 * applied KISS principle here.

	/*

	 * No buffered operation in progress, map the channel and trigger it.

	 * Virtual channel 0 is always used here as the others are always not

	 * used if doing raw sampling.

 Enable / disable the divider per requirement */

 Clean the slot's previous content, then set new one. */

 Enable the IRQ and start sampling the channel. */

 Wait for completion on the channel, 1 second max. */

 Read the data. */

			/*

			 * From the datasheet, we have to multiply by 1.012 and

			 * divide by 4

			/*

			 * The calculated value from the ADC is in Kelvin, we

			 * want Celsius for hwmon so the offset is -273.15

			 * The offset is applied before scaling so it is

			 * actually -213.15 * 4 / 1.012 = -1079.644268

 divider by two disabled */

 divider by two enabled */

 IRQ Handling */

 Trigger handling */

 Test for attempts to map channels with special mode of operation. */

 Test for attempts to map more channels then available slots. */

 Driver initialization */

 Combined Temperature sensors */

 Hidden channel to keep indexes */

 Combined Temperature sensors */

 Hidden channel to keep indexes */

 The ADC always uses DELAY CHANNEL 0. */

 Configure DELAY CHANNEL 0 for generic ADC sampling. */

	/*

	 * Start internal temperature sensing by clearing bit

	 * HW_LRADC_CTRL2_TEMPSENSE_PWD. This bit can be left cleared

	 * after power up.

 Allocate the IIO device. */

 Populate available ADC input ranges */

			/*

			 * [s=0] = optional divider by two disabled (default)

			 * [s=1] = optional divider by two enabled

			 *

			 * The scale is calculated by doing:

			 *   Vref >> (realbits - s)

			 * which multiplies by two on the second component

			 * of the array.

 Configure the hardware. */

 Register IIO device. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ADC0831/ADC0832/ADC0834/ADC0838 8-bit ADC driver

 *

 * Copyright (c) 2016 Akinobu Mita <akinobu.mita@gmail.com>

 *

 * Datasheet: https://www.ti.com/lit/ds/symlink/adc0832-n.pdf

	/*

	 * Max size needed: 16x 1 byte ADC data + 8 bytes timestamp

	 * May be shorter if not all channels are enabled subject

	 * to the timestamp remaining 8 byte aligned.

	/*

	 * Skip TRI-STATE and a leading zero

 start bit */

 single-ended or differential */

 odd / sign */

 select */

 align Data output BIT7 (MSB) to 8-bit boundary */

 convert regulator output voltage to mV */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Driver for the Diolan DLN-2 USB-ADC adapter

 *

 * Copyright (c) 2017 Jack Andersen

/*

 * Plays similar role to iio_demux_table in subsystem core; except allocated

 * in a fixed 8-element array.

 Cached sample period in milliseconds */

 Demux table */

 Precomputed timestamp padding offset and length */

 Clear out any old demux */

 Optimize all 8-channels case */

 Build demux table from fixed 8-channels to active_scan_mask */

 Handle timestamp separately */

	/*

	 * Call GET_VAL twice due to initial zero-return immediately after

	 * enabling channel.

		/*

		 * Voltage reference is fixed at 3.3v

		 *  3.3 / (1 << 10) * 1000000000

		/*

		 * The first requested channel is arbitrated as a shared

		 * trigger source, so only one event is registered with the

		 * DLN. The event handler will then read all enabled channel

		 * values using DLN2_ADC_CHANNEL_GET_ALL_VAL to maintain

		 * synchronization between ADC readings.

 Assignment version of IIO_CHAN_SOFT_TIMESTAMP */

 Demux operation */

 Zero padding space between values and timestamp */

 Enable ADC */

 Assign trigger channel based on first enabled channel */

 Disable trigger channel */

 Disable ADC */

 Called via URB completion handler */

 SPDX-License-Identifier: GPL-2.0

/*

 * AD7190 AD7192 AD7193 AD7195 SPI ADC driver

 *

 * Copyright 2011-2015 Analog Devices Inc.

 Registers */

 Communications Register (WO, 8-bit) */

 Status Register	     (RO, 8-bit) */

 Mode Register	     (RW, 24-bit */

 Configuration Register  (RW, 24-bit) */

 Data Register	     (RO, 24/32-bit) */

 ID Register	     (RO, 8-bit) */

 GPOCON Register	     (RO, 8-bit) */

 Offset Register	     (RW, 16-bit */

 (AD7792)/24-bit (AD7192)) */

 Full-Scale Register */

 (RW, 16-bit (AD7792)/24-bit (AD7192)) */

 Communications Register Bit Designations (AD7192_REG_COMM) */

 Write Enable */

 Write Operation */

 Read Operation */

 Register Address */

 Continuous Read of Data Register */

 Status Register Bit Designations (AD7192_REG_STAT) */

 Ready */

 Error (Overrange, Underrange) */

 Error no external reference */

 Parity */

 Channel 3 */

 Channel 2 */

 Channel 1 */

 Mode Register Bit Designations (AD7192_REG_MODE) */

 Operation Mode Select */

 Operation Mode Select Mask */

 Status Register transmission */

 Clock Source Select */

 SINC3 Filter Select */

 AC excitation enable(AD7195 only)*/

 Parity Enable */

 Clock divide by 2 (AD7190/2 only)*/

 Single cycle conversion */

 50/60Hz notch filter */

 Filter Update Rate Select */

 Mode Register: AD7192_MODE_SEL options */

 Continuous Conversion Mode */

 Single Conversion Mode */

 Idle Mode */

 Power-Down Mode */

 Internal Zero-Scale Calibration */

 Internal Full-Scale Calibration */

 System Zero-Scale Calibration */

 System Full-Scale Calibration */

 Mode Register: AD7192_MODE_CLKSRC options */

 External 4.92 MHz Clock connected*/

 from MCLK1 to MCLK2 */

 External Clock applied to MCLK2 */

 Internal 4.92 MHz Clock not */

 available at the MCLK2 pin */

 Internal 4.92 MHz Clock available*/

 at the MCLK2 pin */

 Configuration Register Bit Designations (AD7192_REG_CONF) */

 CHOP enable */

 REFIN1/REFIN2 Reference Select */

 Channel select */

 Channel select mask */

 Burnout current enable */

 Reference detect enable */

 Buffered Mode Enable */

 Unipolar/Bipolar Enable */

 Gain Select */

 AIN1(+) - AIN2(-) */

 AIN3(+) - AIN4(-) */

 Temp Sensor */

 AIN2(+) - AIN2(-) */

 AIN1 - AINCOM */

 AIN2 - AINCOM */

 AIN3 - AINCOM */

 AIN4 - AINCOM */

 AIN1(+) - AIN2(-) */

 AIN3(+) - AIN4(-) */

 AIN5(+) - AIN6(-) */

 AIN7(+) - AIN8(-) */

 Temp senseor */

 AIN2(+) - AIN2(-) */

 AIN1 - AINCOM */

 AIN2 - AINCOM */

 AIN3 - AINCOM */

 AIN4 - AINCOM */

 AIN5 - AINCOM */

 AIN6 - AINCOM */

 AIN7 - AINCOM */

 AIN7 - AINCOM */

 AINCOM - AINCOM */

 ID Register Bit Designations (AD7192_REG_ID) */

 GPOCON Register Bit Designations (AD7192_REG_GPOCON) */

 Bridge power-down switch enable */

 Digital Output P3 and P2 enable */

 Digital Output P1 and P0 enable */

 P3 state */

 P2 state */

 P1 state */

 P0 state */

/* NOTE:

 * The AD7190/2/5 features a dual use data out ready DOUT/RDY output.

 * In order to avoid contentions on the SPI bus, it's therefore necessary

 * to use spi bus locking.

 *

 * The DOUT/RDY output must also be wired to an interrupt capable GPIO.

 protect sensor state */

 use internal clock */

 reset the serial interface */

 Wait for at least 500us */

 write/read test for device presence */

 Populate available ADC input ranges */

 Formulas for filter at page 25 of the datasheet */

 Kelvin to Celsius */

 Values are stored in a 2D matrix  */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) ST-Ericsson SA 2010

 *

 * Author: Arun R Murthy <arun.murthy@stericsson.com>

 * Author: Daniel Willerud <daniel.willerud@stericsson.com>

 * Author: Johan Palsson <johan.palsson@stericsson.com>

 * Author: M'boumba Cedric Madianga

 * Author: Linus Walleij <linus.walleij@linaro.org>

 *

 * AB8500 General Purpose ADC driver. The AB8500 uses reference voltages:

 * VinVADC, and VADC relative to GND to do its job. It monitors main and backup

 * battery voltages, AC (mains) voltage, USB cable voltage, as well as voltages

 * representing the temperature of the chip die and battery, accessory

 * detection by resistance measurements using relative voltages and GSM burst

 * information.

 *

 * Some of the voltages are measured on external pins on the IC, such as

 * battery temperature or "ADC aux" 1 and 2. Other voltages are internal rails

 * from other parts of the ASIC such as main charger voltage, main and battery

 * backup voltage or USB VBUS voltage. For this reason drivers for other

 * parts of the system are required to obtain handles to the ADC to do work

 * for them and the IIO driver provides arbitration among these consumers.

 GPADC register offsets and bit definitions */

 GPADC control register 1 bits */

 0 = use rising edge, 1 = use falling edge */

 0 = use VTVOUT, 1 = use VRTC as pull-up supply for battery temp NTC */

/*

 * GPADC control register 2 and 3 bits

 * the bit layout is the same for SW and HW conversion set-up

 This is not used on AB8505 */

 Only on AB8505 */

 FIXME: Applicable to all ASIC variants? */

 FIXME: Doesn't seem to work with pure AB8500 */

	/*

	 * Virtual channel used only for ibat conversion to ampere.

	 * Battery current conversion (ibat) cannot be requested as a

	 * single conversion but it is always requested in combination

	 * with other input requests.

/*

 * OTP register offsets

 * Bank : 0x15

 New calibration for 8540 */

 GPADC constants from AB8500 spec, UM0836 */

 GPADC constants from AB8540 spec */

 mA range measured by ADC for ibat */

 mV range measured by ADC for ibat */

 mV */

 This is used to not lose precision when dividing to get gain and offset */

/*

 * Number of bits shift used to not lose precision

 * when dividing to get ibat gain.

 Time in ms before disabling regulator */

 ms */

/**

 * struct ab8500_adc_cal_data - Table for storing gain and offset for the

 * calibrated ADC channels

 * @gain: Gain of the ADC channel

 * @offset: Offset of the ADC channel

 * @otp_calib_hi: Calibration from OTP

 * @otp_calib_lo: Calibration from OTP

/**

 * struct ab8500_gpadc_chan_info - per-channel GPADC info

 * @name: name of the channel

 * @id: the internal AB8500 ID number for the channel

 * @hardware_control: indicate that we want to use hardware ADC control

 * on this channel, the default is software ADC control. Hardware control

 * is normally only used to test the battery voltage during GSM bursts

 * and needs a hardware trigger on the GPADCTrig pin of the ASIC.

 * @falling_edge: indicate that we want to trigger on falling edge

 * rather than rising edge, rising edge is the default

 * @avg_sample: how many samples to average: must be 1, 4, 8 or 16.

 * @trig_timer: how long to wait for the trigger, in 32kHz periods:

 * 0 .. 255 periods

/**

 * struct ab8500_gpadc - AB8500 GPADC device information

 * @dev: pointer to the containing device

 * @ab8500: pointer to the parent AB8500 device

 * @chans: internal per-channel information container

 * @nchans: number of channels

 * @complete: pointer to the completion that indicates

 * the completion of an gpadc conversion cycle

 * @vddadc: pointer to the regulator supplying VDDADC

 * @irq_sw: interrupt number that is used by gpadc for software ADC conversion

 * @irq_hw: interrupt number that is used by gpadc for hardware ADC conversion

 * @cal_data: array of ADC calibration data structs

/**

 * ab8500_gpadc_ad_to_voltage() - Convert a raw ADC value to a voltage

 * @gpadc: GPADC instance

 * @ch: the sampled channel this raw value is coming from

 * @ad_value: the raw value

 No calibration data available: just interpolate */

 Here we can use calibration */

 No calibration data available: just interpolate */

 Here we can use calibration */

 No calibration data available: just interpolate */

 Here we can use calibration */

 No calibration data available: just interpolate */

 Here we can use calibration */

 check if conversion is supported */

 Enable vddadc by grabbing PM runtime */

 Check if ADC is not busy, lock and proceed */

 Enable GPADC */

 Select the channel source and set average samples */

	/*

	 * Enable ADC, buffering, select rising edge and enable ADC path

	 * charging current sense if it needed, ABB 3.0 needs some special

	 * treatment too.

			/*

			 * Delay might be needed for ABB8500 cut 3.0, if not,

			 * remove when hardware will be available

 Delay in micro seconds */

 large range optimises sleepmode */

 Write configuration to control register 1 */

 Set trigger delay timer */

 Start SW conversion */

 Wait for completion of conversion */

 Read the converted RAW data */

 Check if double conversion is required */

 not supported */

 Read the converted RAW data 2 */

 Disable GPADC */

 This eventually drops the regulator */

	/*

	 * It has shown to be needed to turn off the GPADC if an error occurs,

	 * otherwise we might have problem when waiting for the busy bit in the

	 * GPADC status register to go low. In V1.1 there wait_for_completion

	 * seems to timeout when waiting for an interrupt.. Not seen in V2.0

/**

 * ab8500_bm_gpadcconvend_handler() - isr for gpadc conversion completion

 * @irq: irq number

 * @data: pointer to the data passed during request irq

 *

 * This is a interrupt service routine for gpadc conversion completion.

 * Notifies the gpadc completion is completed and the converted raw value

 * can be read from the registers.

 * Returns IRQ status(IRQ_HANDLED)

 First we read all OTP registers and store the error code */

 Continue anyway: maybe the other registers are OK */

 Put this in the entropy pool as device-unique */

	/*

	 * The ADC calibration data is stored in OTP registers.

	 * The layout of the calibration data is outlined below and a more

	 * detailed description can be found in UM0836

	 *

	 * vm_h/l = vmain_high/low

	 * bt_h/l = btemp_high/low

	 * vb_h/l = vbat_high/low

	 *

	 * Data bits 8500/9540:

	 * | 7	   | 6	   | 5	   | 4	   | 3	   | 2	   | 1	   | 0

	 * |.......|.......|.......|.......|.......|.......|.......|.......

	 * |						   | vm_h9 | vm_h8

	 * |.......|.......|.......|.......|.......|.......|.......|.......

	 * |		   | vm_h7 | vm_h6 | vm_h5 | vm_h4 | vm_h3 | vm_h2

	 * |.......|.......|.......|.......|.......|.......|.......|.......

	 * | vm_h1 | vm_h0 | vm_l4 | vm_l3 | vm_l2 | vm_l1 | vm_l0 | bt_h9

	 * |.......|.......|.......|.......|.......|.......|.......|.......

	 * | bt_h8 | bt_h7 | bt_h6 | bt_h5 | bt_h4 | bt_h3 | bt_h2 | bt_h1

	 * |.......|.......|.......|.......|.......|.......|.......|.......

	 * | bt_h0 | bt_l4 | bt_l3 | bt_l2 | bt_l1 | bt_l0 | vb_h9 | vb_h8

	 * |.......|.......|.......|.......|.......|.......|.......|.......

	 * | vb_h7 | vb_h6 | vb_h5 | vb_h4 | vb_h3 | vb_h2 | vb_h1 | vb_h0

	 * |.......|.......|.......|.......|.......|.......|.......|.......

	 * | vb_l5 | vb_l4 | vb_l3 | vb_l2 | vb_l1 | vb_l0 |

	 * |.......|.......|.......|.......|.......|.......|.......|.......

	 *

	 * Data bits 8540:

	 * OTP2

	 * | 7	   | 6	   | 5	   | 4	   | 3	   | 2	   | 1	   | 0

	 * |.......|.......|.......|.......|.......|.......|.......|.......

	 * |

	 * |.......|.......|.......|.......|.......|.......|.......|.......

	 * | vm_h9 | vm_h8 | vm_h7 | vm_h6 | vm_h5 | vm_h4 | vm_h3 | vm_h2

	 * |.......|.......|.......|.......|.......|.......|.......|.......

	 * | vm_h1 | vm_h0 | vm_l4 | vm_l3 | vm_l2 | vm_l1 | vm_l0 | bt_h9

	 * |.......|.......|.......|.......|.......|.......|.......|.......

	 * | bt_h8 | bt_h7 | bt_h6 | bt_h5 | bt_h4 | bt_h3 | bt_h2 | bt_h1

	 * |.......|.......|.......|.......|.......|.......|.......|.......

	 * | bt_h0 | bt_l4 | bt_l3 | bt_l2 | bt_l1 | bt_l0 | vb_h9 | vb_h8

	 * |.......|.......|.......|.......|.......|.......|.......|.......

	 * | vb_h7 | vb_h6 | vb_h5 | vb_h4 | vb_h3 | vb_h2 | vb_h1 | vb_h0

	 * |.......|.......|.......|.......|.......|.......|.......|.......

	 * | vb_l5 | vb_l4 | vb_l3 | vb_l2 | vb_l1 | vb_l0 |

	 * |.......|.......|.......|.......|.......|.......|.......|.......

	 *

	 * Data bits 8540:

	 * OTP4

	 * | 7	   | 6	   | 5	   | 4	   | 3	   | 2	   | 1	   | 0

	 * |.......|.......|.......|.......|.......|.......|.......|.......

	 * |					   | ib_h9 | ib_h8 | ib_h7

	 * |.......|.......|.......|.......|.......|.......|.......|.......

	 * | ib_h6 | ib_h5 | ib_h4 | ib_h3 | ib_h2 | ib_h1 | ib_h0 | ib_l5

	 * |.......|.......|.......|.......|.......|.......|.......|.......

	 * | ib_l4 | ib_l3 | ib_l2 | ib_l1 | ib_l0 |

	 *

	 *

	 * Ideal output ADC codes corresponding to injected input voltages

	 * during manufacturing is:

	 *

	 * vmain_high: Vin = 19500mV / ADC ideal code = 997

	 * vmain_low:  Vin = 315mV   / ADC ideal code = 16

	 * btemp_high: Vin = 1300mV  / ADC ideal code = 985

	 * btemp_low:  Vin = 21mV    / ADC ideal code = 16

	 * vbat_high:  Vin = 4700mV  / ADC ideal code = 982

	 * vbat_low:   Vin = 2380mV  / ADC ideal code = 33

 Calculate gain and offset for VMAIN if all reads succeeded*/

 Read IBAT calibration Data */

 Calculate gain and offset for IBAT if all reads succeeded */

			/*

			 * Result obtained is in mV (at a scale factor),

			 * we need to calculate gain and offset to get mA

 Calculate gain and offset for VMAIN if all reads succeeded */

 Calculate gain and offset for BTEMP if all reads succeeded */

 Calculate gain and offset for VBAT if all reads succeeded */

 Return millivolt or milliamps or millicentigrades */

/**

 * ab8500_gpadc_parse_channel() - process devicetree channel configuration

 * @dev: pointer to containing device

 * @np: device tree node for the channel to configure

 * @ch: channel info to fill in

 * @iio_chan: IIO channel specification to fill in

 *

 * The devicetree will set up the channel for use with the specific device,

 * and define usage for things like AUX GPADC inputs more precisely.

 Most are voltages (also temperatures), some are currents */

 Sensible defaults */

/**

 * ab8500_gpadc_parse_channels() - Parse the GPADC channels from DT

 * @gpadc: the GPADC to configure the channels for

 * @np: device tree node containing the channel configurations

 * @chans: the IIO channels we parsed

 * @nchans: the number of IIO channels we parsed

 Initialize completion used to notify completion of conversion */

 Request interrupts */

 The VTVout LDO used to power the AB8500 GPADC */

 Enable runtime PM */

 SPDX-License-Identifier: GPL-2.0+

/*

 * ADC driver for the RICOH RN5T618 power management chip family

 *

 * Copyright (C) 2019 Andreas Kemnade

 mask for selecting channels for single conversion */

 average 4-time conversion mode */

 set for starting a single conversion, gets cleared by hw when done */

/* automatic conversion, period is in ADCCNT2, selected channels are

 * in ADCCNT1

 measured across 20mOhm, amplified by 32 */

 clear low & high threshold irqs */

 select channel */

 single conversion */

 sentinel */ }

 stop any auto-conversion */

 SPDX-License-Identifier: GPL-2.0

/*

 * Texas Instruments TSC2046 SPI ADC driver

 *

 * Copyright (c) 2021 Oleksij Rempel <kernel@pengutronix.de>, Pengutronix

/*

 * The PENIRQ of TSC2046 controller is implemented as level shifter attached to

 * the X+ line. If voltage of the X+ line reaches a specific level the IRQ will

 * be activated or deactivated.

 * To make this kind of IRQ reusable as trigger following additions were

 * implemented:

 * - rate limiting:

 *   For typical touchscreen use case, we need to trigger about each 10ms.

 * - hrtimer:

 *   Continue triggering at least once after the IRQ was deactivated. Then

 *   deactivate this trigger to stop sampling in order to reduce power

 *   consumption.

 This driver doesn't aim at the peak continuous sample rate */

/*

 * The mode bit sets the resolution of the ADC. With this bit low, the next

 * conversion has 12-bit resolution, whereas with this bit high, the next

 * conversion has 8-bit resolution. This driver is optimized for 12-bit mode.

 * So, for this driver, this bit should stay zero.

/*

 * SER/DFR - The SER/DFR bit controls the reference mode, either single-ended

 * (high) or differential (low).

/*

 * If VREF_ON and ADC_ON are both zero, then the chip operates in

 * auto-wake/suspend mode. In most case this bits should stay zero.

/*

 * All supported devices can do 8 or 12bit resolution. This driver

 * supports only 12bit mode, here we have a 16bit data transfer, where

 * the MSB and the 3 LSB are 0.

 Represents a HW sample */

	/*

	 * Command transmitted to the controller. This field is empty on the RX

	 * buffer.

	/*

	 * Data received from the controller. This field is empty for the TX

	 * buffer

 Layout of atomic buffers within big buffer */

 Group offset within the SPI RX buffer */

	/*

	 * Amount of tsc2046_adc_atom structs within the same command gathered

	 * within same group.

	/*

	 * Settling samples (tsc2046_adc_atom structs) which should be skipped

	 * before good samples will start.

 Scan data for each channel */

 Timestamp */

	/*

	 * Lock to protect the layout and the SPI transfer buffer.

	 * tsc2046_adc_group_layout can be changed within update_scan_mode(),

	 * in this case the l[] and tx/rx buffer will be out of sync to each

	 * other.

/*

 * Convert time to a number of samples which can be transferred within this

 * time.

	/*

	 * if PD bits are 0, controller will automatically disable ADC, VREF and

	 * enable IRQ.

	/*

	 * We aren't using spi_write_then_read() because we need to be able

	 * to get hold of the effective_speed_hz from the xfer

	/*

	 * Do not enable automatic power down on working samples. Otherwise the

	 * plates will never be completely charged.

 automatically power down on last sample */

 If the consumer is kfifo, we may get a EBUSY here - ignore it. */

	/*

	 * We can sample it as fast as we can, but usually we do not need so

	 * many samples. Reduce the sample rate for default (touchscreen) use

	 * case.

	 * Currently we do not need a highly precise sample rate. It is enough

	 * to have calculated numbers.

	/*

	 * We need to trigger at least one extra sample to detect state

	 * difference on ADC side.

	/*

	 * Make dummy read to set initial power state and get real SPI clock

	 * freq. It seems to be not important which channel is used for this

	 * case.

	/*

	 * In case SPI controller do not report effective_speed_hz, use

	 * configure value and hope it will match.

	/*

	 * Calculate and allocate maximal size buffer if all channels are

	 * enabled.

 set default trigger */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2014 Angelo Compagnucci <angelo.compagnucci@gmail.com>

 *

 * Driver for Texas Instruments' ADC128S052, ADC122S021 and ADC124S021 ADC chip.

 * Datasheets can be found here:

 * https://www.ti.com/lit/ds/symlink/adc128s052.pdf

 * https://www.ti.com/lit/ds/symlink/adc122s021.pdf

 * https://www.ti.com/lit/ds/symlink/adc124s021.pdf

 sentinel */ },

 index into adc128_config */

 ADC124S021 compatible ACPI ID */

 SPDX-License-Identifier: GPL-2.0

/*

 * This file is the ADC part of the STM32 DFSDM driver

 *

 * Copyright (C) 2017, STMicroelectronics - All Rights Reserved

 * Author: Arnaud Pouliquen <arnaud.pouliquen@st.com>.

 Conversion timeout */

 Oversampling attribute default */

 Oversampling max values */

 Limit filter output resolution to 31 bits. (i.e. sample range is +/-2^30) */

/*

 * Data are output as two's complement data in a 24 bit field.

 * Data from filters are in the range +/-2^(n-1)

 * 2^(n-1) maximum positive value cannot be coded in 2's complement n bits

 * An extra bit is required to avoid wrap-around of the binary code for 2^(n-1)

 * So, the resolution of samples from filter is actually limited to 23 bits

 Filter configuration */

 ADC specific */

 Audio specific */

 SPI bus clock frequency */

 Sample frequency after filter decimation */

 DMA */

 Buffer current position */

 Buffer size */

 DFSDM channel serial interface type */

 SPI with data on rising edge */

 SPI with data on falling edge */

 Manchester codec, rising edge = logic 0 */

 Manchester codec, falling edge = logic 1 */

 DFSDM channel clock source */

 External SPI clock (CLKIN x) */

 Internal SPI clock (CLKOUT) */

 Internal SPI clock divided by 2 (falling edge) */

 Internal SPI clock divided by 2 (falling edge) */

/**

 * struct stm32_dfsdm_trig_info - DFSDM trigger info

 * @name:		name of the trigger, corresponding to its source

 * @jextsel:		trigger signal selection

 hardware injected trigger enable, edge selection */

 lookup triggers registered by stm32 timer trigger driver */

		/**

		 * Checking both stm32 timer trigger type and trig name

		 * should be safe against arbitrary trigger names.

 multiplication factor */

 filter order (ford) */

	/*

	 * This function tries to compute filter oversampling and integrator

	 * oversampling, base on oversampling ratio requested by user.

	 *

	 * Decimation d depends on the filter order and the oversampling ratios.

	 * ford: filter order

	 * fosr: filter over sampling ratio

	 * iosr: integrator over sampling ratio

	/*

	 * Look for filter and integrator oversampling ratios which allows

	 * to maximize data output resolution.

			/*

			 * Check resolution (limited to signed 32 bits)

			 *   res <= 2^31

			 * Sincx filters:

			 *   res = m * fosr^p x iosr (with m=1, p=ford)

			 * FastSinc filter

			 *   res = m * fosr^p x iosr (with m=2, p=2)

 8 LBSs in data register contain chan info */

 if resolution is not a power of two */

				/*

				 * Compute right/left shift

				 * Right shift is performed by hardware

				 * when transferring samples to data register.

				 * Left shift is done by software on buffer

 Resolution is lower than 24 bits */

					/*

					 * If resolution is 24 bits or more,

					 * max positive value may be ambiguous

					 * (equal to max negative value as sign

					 * bit is dropped).

					 * Reduce resolution to 23 bits (rshift)

					 * to keep the sign on bit 23 and treat

					 * saturation before rescaling on 24

					 * bits (lshift).

 Enable filter */

 Nothing more to do for injected (scan mode/triggered) conversions */

 Software start (single or continuous) regular conversion */

 Disable conversion */

 set trigger source and polarity (default to rising edge) */

	/*

	 * In continuous mode, use fast mode configuration,

	 * if it provides a better resolution.

 Average integrator oversampling */

 Filter order and Oversampling */

	/*

	 * DFSDM modes configuration W.R.T audio/iio type modes

	 * ----------------------------------------------------------------

	 * Modes         | regular |  regular     | injected | injected   |

	 *               |         |  continuous  |          | + scan     |

	 * --------------|---------|--------------|----------|------------|

	 * single conv   |    x    |              |          |            |

	 * (1 chan)      |         |              |          |            |

	 * --------------|---------|--------------|----------|------------|

	 * 1 Audio chan	 |         | sample freq  |          |            |

	 *               |         | or sync_mode |          |            |

	 * --------------|---------|--------------|----------|------------|

	 * 1 IIO chan	 |         | sample freq  | trigger  |            |

	 *               |         | or sync_mode |          |            |

	 * --------------|---------|--------------|----------|------------|

	 * 2+ IIO chans  |         |              |          | trigger or |

	 *               |         |              |          | sync_mode  |

	 * ----------------------------------------------------------------

 Use regular conversion for single channel without trigger */

 Continuous conversions triggered by SPI clk in buffer mode */

 Use injected conversion for multiple channels */

 Use scan mode for multiple channels */

		/*

		 * Continuous conversions not supported in injected mode,

		 * either use:

		 * - conversions in sync with filter 0

		 * - triggered conversions

 If DFSDM is master on SPI, SPI freq can not be updated */

	/*

	 * DMA cyclic transfers are used, buffer is split into two periods.

	 * There should be :

	 * - always one buffer (period) DMA is working on

	 * - one buffer (period) driver pushed to ASoC side.

 Residue is size in bytes from end of buffer */

 Return available bytes */

 Mask 8 LSB that contains the channel ID */

 Convert 2^(n-1) sample to 2^(n-1)-1 to avoid wrap-around */

		/*

		 * Samples from filter are retrieved with 23 bits resolution

		 * or less. Shift left to align MSB on 24 bits.

	/*

	 * FIXME: In Kernel interface does not support cyclic DMA buffer,and

	 * offers only an interface to push data samples per samples.

	 * For this reason IIO buffer interface is not used and interface is

	 * bypassed using a private callback registered by ASoC.

	 * This should be a temporary solution waiting a cyclic DMA engine

	 * support in IIO.

		/*

		 * In DMA mode the trigger services of IIO are not used

		 * (e.g. no call to iio_trigger_poll).

		 * Calling irq handler associated to the hardware trigger is not

		 * relevant as the conversions have already been done. Data

		 * transfers are performed directly in DMA callback instead.

		 * This implementation avoids to call trigger irq handler that

		 * may sleep, in an atomic context (DMA irq handler context).

	/*

	 * The DFSDM supports half-word transfers. However, for 16 bits record,

	 * 4 bytes buswidth is kept, to avoid losing samples LSBs when left

	 * shift is required.

 Prepare a DMA cyclic transaction */

 Issue pending DMA requests */

 Enable regular DMA transfer*/

 Enable injected DMA transfer*/

 Reset adc buffer index */

/**

 * stm32_dfsdm_get_buff_cb() - register a callback that will be called when

 *                             DMA transfer period is achieved.

 *

 * @iio_dev: Handle to IIO device.

 * @cb: Pointer to callback function:

 *      - data: pointer to data buffer

 *      - size: size in byte of the data buffer

 *      - private: pointer to consumer private structure.

 * @private: Pointer to consumer private structure.

/**

 * stm32_dfsdm_release_buff_cb - unregister buffer callback

 *

 * @iio_dev: Handle to IIO device.

 Mask IRQ for regular conversion achievement*/

 Read the data register clean the IRQ status */

/*

 * Define external info for SPI Frequency and audio sampling rate that can be

 * configured by ASoC driver through consumer.h API

 spi_clk_freq : clock freq on SPI/manchester bus used by channel */

	/*

	 * IIO_CHAN_INFO_RAW: used to compute regular conversion

	 * IIO_CHAN_INFO_OVERSAMPLING_RATIO: used to set oversampling

 Bind to SD modulator IIO device */

 Optionally request DMA */

 lptimer/timer hardware triggers */

	/*

	 * In a first step IRQs generated for channels are not treated.

	 * So IRQ associated to filter instance 0 is dedicated to the Filter 0.

 restore channels configuration */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2016 MediaTek Inc.

 * Author: Zhiyong Tao <zhiyong.tao@mediatek.com>

 Register definitions */

 For Voltage calculation */

 VA voltage */

 12 bits */

 read channel and make sure old ready bit == 0 */

 set bit to trigger sample */

 we must delay here for hardware sample channel data */

 check MTK_AUXADC_CON2 if auxadc is idle */

 read channel and make sure ready bit == 1 */

 read data */

 Convert adc raw data to voltage: 0 - 1500 mV */

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2018 Spreadtrum Communications Inc.

 PMIC global registers definition */

 ADC controller registers definition */

 Bits and mask definition for SC27XX_ADC_CTL register */

 Bits and mask definition for SC27XX_ADC_CH_CFG register */

 Bits definitions for SC27XX_ADC_INT_EN registers */

 Bits definitions for SC27XX_ADC_INT_CLR registers */

 Bits definitions for SC27XX_ADC_INT_RAW registers */

 Mask definition for SC27XX_ADC_DATA register */

 Timeout (ms) for the trylock of hardware spinlocks */

 Timeout (us) for ADC data conversion according to ADC datasheet */

 Maximum ADC channel number */

 ADC voltage ratio definition */

	/*

	 * One hardware spinlock to synchronize between the multiple

	 * subsystems which will access the unique ADC controller.

/*

 * According to the datasheet, we can convert one ADC value to one voltage value

 * through 2 points in the linear graph. If the voltage is less than 1.2v, we

 * should use the small-scale graph, and if more than 1.2v, we should use the

 * big-scale graph.

 Only need to calibrate the adc values in the linear graph. */

 Configure the channel id and scale */

 Select 12bit conversion mode, and only sample 1 time */

	/*

	 * Convert ADC values to voltage values according to the linear graph,

	 * and channel 5 and channel 1 has been calibrated, so we can just

	 * return the voltage values calculated by the linear graph. But other

	 * channels need be calculated to the real voltage values with the

	 * voltage ratio.

 Enable ADC work clock and controller clock */

 ADC channel scales' calibration from nvmem device */

 Disable ADC work clock and controller clock */

 SPDX-License-Identifier: GPL-2.0-only

 /*

  * iio/adc/max1363.c

  * Copyright (C) 2008-2010 Jonathan Cameron

  *

  * based on linux/drivers/i2c/chips/max123x

  * Copyright (C) 2002-2004 Stefan Eletzhofer

  *

  * based on linux/drivers/acron/char/pcf8583.c

  * Copyright (C) 2000 Russell King

  *

  * Driver for max1363 and similar chips.

/* There is a fair bit more defined here than currently

 * used, but the intention is to support everything these

 see data sheets */

 max1363 and max1236, max1237, max1238, max1239 */

 think about including max11600 etc - more settings */

/* max1363 only - though don't care on others.

 * For now monitor modes are not implemented as the relevant

 * line is not connected on my test board.

 * The definitions are here as I intend to add this soon.

 Specific to the max1363 */

 defined for readability reasons */

 All chips */

 max123{6-9} only */

 max1363 only - merely part of channel selects or don't care for others */

 max1363 strictly 0x06 - but doesn't matter */

/**

 * struct max1363_mode - scan mode information

 * @conf:	The corresponding value of the configuration register

 * @modemask:	Bit mask corresponding to channels enabled in this mode

 This must be maintained along side the max1363_mode_table in max1363_core */

 Single read of a single channel */

 Differential single read */

 Scan to channel and mid to channel where overlapping */

 Differential scan to channel and mid to channel where overlapping */

/**

 * struct max1363_chip_info - chip specifc information

 * @info:		iio core function callbacks structure

 * @channels:		channel specification

 * @num_channels:       number of channels

 * @mode_list:		array of available scan modes

 * @default_mode:	the scan mode in which the chip starts up

 * @int_vref_mv:	the internal reference voltage

 * @num_modes:		number of modes

 * @bits:		accuracy of the adc in bits

/**

 * struct max1363_state - driver instance specific data

 * @client:		i2c_client

 * @setupbyte:		cache of current device setup byte

 * @configbyte:		cache of current device config byte

 * @chip_info:		chip model specific constants, available modes, etc.

 * @current_mode:	the scan mode of this chip

 * @requestedmask:	a valid requested set of channels

 * @reg:		supply regulator

 * @lock:		lock to ensure state is consistent

 * @monitor_on:		whether monitor mode is enabled

 * @monitor_speed:	parameter corresponding to device monitor speed setting

 * @mask_high:		bitmask for enabled high thresholds

 * @mask_low:		bitmask for enabled low thresholds

 * @thresh_high:	high threshold values

 * @thresh_low:		low threshold values

 * @vref:		Reference voltage regulator

 * @vref_uv:		Actual (external or internal) reference voltage

 * @send:		function used to send data to the chip

 * @recv:		function used to receive data from the chip

	/* Using monitor modes and buffer at the same time is

 4x unipolar first then the fours bipolar ones */

 note not available for max1363 hence naming */

 Can't think how to automate naming so specify for now */

 note only available for max1363 hence naming */

 All of the single channel options first */

 The multichannel scans next */

	/*

	 * If monitor mode is enabled, the method for reading a single

	 * channel will have to be rather different and has not yet

	 * been implemented.

	 *

	 * Also, cannot read directly if buffered capture enabled.

 Check to see if current scan mode is correct */

 Update scan mode if needed */

 Get reading */

 Get reading */

 Applies to max1363 */

 bipolar channel */

 Applies to max1236, max1237 */

 Applies to max1238, max1239 */

 make it handle signed correctly as well */

 transition to buffered capture is not currently supported */

 Ensure we are in the relevant mode */

	/*

	 * So we need to do yet another bit of nefarious scan mode

	 * setup to match what we need.

 Establish the mode is in the scan */

	/*

	 * Now that we hopefully have sensible thresholds in place it is

	 * time to turn the interrupts on.

	 * It is unclear from the data sheet if this should be necessary

	 * (i.e. whether monitor mode setup is atomic) but it appears to

	 * be in practice.

/*

 * To keep this manageable we always use one of 3 scan modes.

 * Scan 0...3, 0-1,2-3 and 1-0,3-2

 Is it unipolar */

/*

 * As with scan_elements, only certain sets of these can

 * be combined.

	/*

	 * Need to figure out the current mode based upon the requested

	 * scan mask in iio_dev

 max1363 and max1368 tested - rest from data sheet */

 Set scan mode writes the config anyway so wait until then */

 Ensure the timestamp is 8 byte aligned */

	/* Monitor mode prevents reading. Whilst not currently implemented

	 * might as well have this test in here in the meantime as it does

	 * no harm.

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Aspeed AST2400/2500/2600 ADC

 *

 * Copyright (C) 2017 Google, Inc.

 * Copyright (C) 2021 Aspeed Technology Inc.

 *

 * ADC clock formula:

 * Ast2400/Ast2500:

 * clock period = period of PCLK * 2 * (ADC0C[31:17] + 1) * (ADC0C[9:0] + 1)

 * Ast2600:

 * clock period = period of PCLK * 2 * (ADC0C[15:0] + 1)

/*

 * The register offset between 0xC8~0xCC can be read and won't affect the

 * hardware logic in each version of ADC.

/*

 * Bit 6 determines not only the reference voltage range but also the dividing

 * circuit for battery sensing.

/*

 * When the sampling rate is too high, the ADC may not have enough charging

 * time, resulting in a low voltage value. Thus, the default uses a slow

 * sampling rate for most use cases.

 Hz

 Hz

	/*

	 * Enable compensating sensing:

	 * After that, the input voltage of ADC will force to half of the reference

	 * voltage. So the expected reading raw data will become half of the max

	 * value. We can get compensating value = 0x200 - ADC read raw value.

	 * It is recommended to average at least 10 samples to get a final CV.

	/*

	 * After enable compensating sensing mode need to wait some time for ADC stable

	 * Experiment result is 1ms.

		/*

		 * Waiting for the sampling period ensures that the value acquired

		 * is fresh each time.

 Each sampling needs 12 clocks to convert.*/

			/*

			 * After enable battery sensing mode need to wait some time for adc stable

			 * Experiment result is 1ms.

 Restore control register value */

		/*

		 * Technically, these could be written but the only reasons

		 * for doing so seem better handled in userspace.  EPERM is

		 * returned to signal this is a policy choice rather than a

		 * hardware limitation.

 Conversion from uV to mV */

 Conversion from uV to mV */

 Register ADC clock prescaler with source specified by device tree. */

	/*

	 * Register ADC clock scaler downstream from the prescaler. Allow rate

	 * setting to adjust the prescaler as well.

 Enable engine in normal mode. */

 Wait for initial sequence complete. */

 Start all channels in normal mode. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Texas Instruments ADS131E0x 4-, 6- and 8-Channel ADCs

 *

 * Copyright (c) 2020 AVL DiTEST GmbH

 *   Tomislav Denis <tomislav.denis@avl.com>

 *

 * Datasheet: https://www.ti.com/lit/ds/symlink/ads131e08.pdf

 Commands */

 Registers */

 Configuration register 1 */

 Configuration register 3 */

 Channel settings register */

 ADC  misc */

	/*

	 * Add extra one padding byte to be able to access the last channel

	 * value using u32 pointer

 data rate in kSPS */

 reg value */

 PGA gain value */

 field value */

 Disable read data in continuous mode (enabled by default) */

 Power down unused channels */

 Request channel offset calibration */

	/*

	 * Channel offset calibration is triggered with the first START

	 * command. Since calibration takes more time than settling operation,

	 * this causes timeout error when command START is sent first

	 * time (e.g. first call of the ads131e08_read_direct method).

	 * To avoid this problem offset calibration is triggered here.

	/*

	 * The number of data bits per channel depends on the data rate.

	 * For 32 and 64 ksps data rates, number of data bits per channel

	 * is 16. This case is not compliant with used (fixed) scan element

	 * type (be:s24/32>>8). So we use a little tweak to pack properly

	 * 16 bits of data into the buffer.

		/*

		 * Tweek offset is 0:

		 * +---+---+---+---+

		 * |D0 |D1 |D2 | X | (3 data bytes)

		 * +---+---+---+---+

		 *  a+0 a+1 a+2 a+3

		 *

		 * Tweek offset is 1:

		 * +---+---+---+---+

		 * |P0 |D0 |D1 | X | (one padding byte and 2 data bytes)

		 * +---+---+---+---+

		 *  a+0 a+1 a+2 a+3

		/*

		 * Data conversion from 16 bits of data to 24 bits of data

		 * is done by sign extension (properly filling padding byte).

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Analog Devices Generic AXI ADC IP core

 * Link: https://wiki.analog.com/resources/fpga/docs/axi_adc_ip

 *

 * Copyright 2012-2020 Analog Devices Inc.

/*

 * Register definitions:

 *   https://wiki.analog.com/resources/fpga/docs/axi_adc_ip#register_map

 ADC controls */

 ADC Channel controls */

 Match table for of_platform binding */

 end of list */ }

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.

 VADC register and bit definitions */

 16 bits */

/**

 * struct vadc_channel_prop - VADC channel property.

 * @channel: channel number, refer to the channel list.

 * @calibration: calibration type.

 * @decimation: sampling rate supported for the channel.

 * @prescale: channel scaling performed on the input signal.

 * @hw_settle_time: the time between AMUX being configured and the

 *	start of conversion.

 * @avg_samples: ability to provide single result from the ADC

 *	that is an average of multiple measurements.

 * @scale_fn_type: Represents the scaling function to convert voltage

 *	physical units desired by the client for the channel.

/**

 * struct vadc_priv - VADC private structure.

 * @regmap: pointer to struct regmap.

 * @dev: pointer to struct device.

 * @base: base address for the ADC peripheral.

 * @nchannels: number of VADC channels.

 * @chan_props: array of VADC channel properties.

 * @iio_chans: array of IIO channels specification.

 * @are_ref_measured: are reference points measured.

 * @poll_eoc: use polling instead of interrupt.

 * @complete: VADC result notification after interrupt is received.

 * @graph: store parameters for calibration.

 * @lock: ADC lock for access to the peripheral.

 Mode selection */

 Channel selection */

 Digital parameter setup */

 HW settle time delay */

 Double check conversion status */

 Try with buffered 625mV channel first */

 Ratiometric calibration */

/*

 * The array represents all possible ADC channels found in the supported PMICs.

 * Every index in the array is equal to the channel number per datasheet. The

 * gaps in the array should be treated as reserved channels.

 the channel has DT description */

 These channels are mandatory, they are used as reference points */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ltc2497.c - Driver for Analog Devices/Linear Technology LTC2497 ADC

 *

 * Copyright (C) 2017 Analog Devices Inc.

 *

 * Datasheet: http://cds.linear.com/docs/en/datasheet/2497fd.pdf

 this must be the first member */

	/*

	 * DMA (thus cache coherency maintenance) requires the

	 * transfer buffers to live in their own cache lines.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Atmel ADC driver for SAMA5D2 devices and compatible.

 *

 * Copyright (C) 2015 Atmel,

 *               2015 Ludovic Desroches <ludovic.desroches@atmel.com>

 *		 2021 Microchip Technology, Inc. and its subsidiaries

 *		 2021 Eugen Hristev <eugen.hristev@microchip.com>

 Control Register */

 Software Reset */

 Start Conversion */

 Touchscreen Calibration */

 Comparison Restart */

 Mode Register */

 Trigger Selection */

 ADTRG */

 TIOA0 */

 TIOA1 */

 TIOA2 */

 PWM event line 0 */

 PWM event line 1 */

 TIOA3 */

 RTCOUT0 */

 Sleep Mode */

 Fast Wake Up */

 Prescaler Rate Selection */

 Startup Time */

 Analog Change */

 Tracking Time */

 Transfer Time */

 Use Sequence Enable */

 Channel Sequence Register 1 */

 Channel Sequence Register 2 */

 Channel Enable Register */

 Channel Disable Register */

 Channel Status Register */

 Last Converted Data Register */

 Interrupt Enable Register */

 Interrupt Enable Register - TS X measurement ready */

 Interrupt Enable Register - TS Y measurement ready */

 Interrupt Enable Register - TS pressure measurement ready */

 Interrupt Enable Register - Data ready */

 Interrupt Enable Register - general overrun error */

 Interrupt Enable Register - Pen detect */

 Interrupt Enable Register - No pen detect */

 Interrupt Disable Register */

 Interrupt Mask Register */

 Interrupt Status Register */

 End of Conversion Interrupt Enable Register */

 End of Conversion Interrupt Disable Register */

 End of Conversion Interrupt Mask Register */

 End of Conversion Interrupt Status Register */

 Interrupt Status Register - Pen touching sense status */

 Last Channel Trigger Mode Register */

 Last Channel Compare Window Register */

 Overrun Status Register */

 Extended Mode Register */

 Extended Mode Register - Oversampling rate */

 Extended Mode Register - Averaging on single trigger event */

 Compare Window Register */

 Channel Gain Register */

 Channel Offset Register */

 Channel Offset Register differential offset - constant, not a register */

 Analog Control Register */

 Analog Control Register - Pen detect sensitivity mask */

 Touchscreen Mode Register */

 Touchscreen Mode Register - No touch mode */

 Touchscreen Mode Register - 4 wire screen, no pressure measurement */

 Touchscreen Mode Register - 4 wire screen, pressure measurement */

 Touchscreen Mode Register - 5 wire screen */

 Touchscreen Mode Register - Average samples mask */

 Touchscreen Mode Register - Average samples */

 Touchscreen Mode Register - Touch/trigger frequency ratio mask */

 Touchscreen Mode Register - Touch/trigger frequency ratio */

 Touchscreen Mode Register - Pen Debounce Time mask */

 Touchscreen Mode Register - Pen Debounce Time */

 Touchscreen Mode Register - No DMA for touch measurements */

 Touchscreen Mode Register - Disable pen detection */

 Touchscreen Mode Register - Enable pen detection */

 Touchscreen X Position Register */

 Touchscreen Y Position Register */

 Touchscreen Pressure Register */

 Trigger Register */

 Mask for TRGMOD field of TRGR register */

 No trigger, only software trigger can start conversions */

 Trigger Mode external trigger rising edge */

 Trigger Mode external trigger falling edge */

 Trigger Mode external trigger any edge */

 Trigger Mode internal periodic */

 Trigger Mode - trigger period mask */

 Trigger Mode - trigger period */

 Correction Select Register */

 Correction Value Register */

 Channel Error Correction Register */

 Write Protection Mode Register */

 Write Protection Status Register */

 Version Register */

 2ms */

 Possible values for oversampling ratio */

/**

 * struct at91_adc_platform - at91-sama5d2 platform information struct

 * @layout:		pointer to the reg layout struct

 * @adc_channels:	pointer to an array of channels for registering in

 *			the iio subsystem

 * @nr_channels:	number of physical channels available

 * @touch_chan_x:	index of the touchscreen X channel

 * @touch_chan_y:	index of the touchscreen Y channel

 * @touch_chan_p:	index of the touchscreen P channel

 * @max_channels:	number of total channels

 * @max_index:		highest channel index (highest index may be higher

 *			than the total channel number)

 * @hw_trig_cnt:	number of possible hardware triggers

/**

 * struct at91_adc_soc_info - at91-sama5d2 soc information struct

 * @startup_time:	device startup time

 * @min_sample_rate:	minimum sample rate in Hz

 * @max_sample_rate:	maximum sample rate in Hz

 * @platform:		pointer to the platform structure

/**

 * struct at91_adc_dma - at91-sama5d2 dma information struct

 * @dma_chan:		the dma channel acquired

 * @rx_buf:		dma coherent allocated area

 * @rx_dma_buf:		dma handler for the buffer

 * @phys_addr:		physical address of the ADC base register

 * @buf_idx:		index inside the dma buffer where reading was last done

 * @rx_buf_sz:		size of buffer used by DMA operation

 * @watermark:		number of conversions to copy before DMA triggers irq

 * @dma_ts:		hold the start timestamp of dma operation

/**

 * struct at91_adc_touch - at91-sama5d2 touchscreen information struct

 * @sample_period_val:		the value for periodic trigger interval

 * @touching:			is the pen touching the screen or not

 * @x_pos:			temporary placeholder for pressure computation

 * @channels_bitmask:		bitmask with the touchscreen channels enabled

 * @workq:			workqueue for buffer data pushing

/*

 * Buffer size requirements:

 * No channels * bytes_per_channel(2) + timestamp bytes (8)

 * Divided by 2 because we need half words.

 * We assume 32 channels for now, has to be increased if needed.

 * Nobody minds a buffer being too big.

 Ensure naturally aligned timestamp */

	/*

	 * lock to prevent concurrent 'single conversion' requests through

	 * sysfs.

 original ABI has the differential channels with a gap in between */

	/*

	 * On some products having the EOC bits in a separate register,

	 * errata recommends not writing this register (EOC_IDR).

	 * On products having the EOC bits in the IDR register, it's fine to write it.

 configure the extended mode register */

 select oversampling per single trigger event */

 delete leftover content if it's the case */

 select oversampling ratio from configuration */

		/*

		 * in this case we only have 12 bits of real data, but channel

		 * is registered as 14 bits, so shift left two bits

		/*

		 * in this case we have 13 bits of real data, but channel

		 * is registered as 14 bits, so left shift one bit

	/*

	 * We are converting each two bytes (each sample).

	 * First convert the byte based array to u16, and convert each sample

	 * separately.

	 * Each value is two bytes in an array of chars, so to not shift

	 * more than we need, save the value separately.

	 * len is in bytes, so divide by two to get number of samples.

 disabling touch IRQs and setting mode to no touch enabled */

	/*

	 * debounce time is in microseconds, we need it in milliseconds to

	 * multiply with kilohertz, so, divide by 1000, but after the multiply.

	 * round up to make sure pendbc is at least 1

 get the required exponent */

 Sample Period Time = (TRGPER + 1) / ADCClock */

 enable pen detect IRQ */

	/*

	 * to obtain the actual position we must divide by scale

	 * and multiply with max, where

	 * max = 2^AT91_SAMA5D2_MAX_POS_BITS - 1

 first half of register is the x or y, second half is the scale */

 calculate the pressure */

 no pen contact */

	/*

	 * The pressure from device grows down, minimum is 0xFFFF, maximum 0x0.

	 * We compute it this way, but let's return it in the expected way,

	 * growing from 0 to 0xFFFF.

 clear TRGMOD */

 set/unset hw trigger */

 if we are using DMA, we must not reenable irq after each trigger */

 Needed to ACK the DRDY interruption */

 Transferred length is size in bytes from end of buffer */

 Return available bytes */

 we start a new DMA, so set buffer index to start */

	/*

	 * compute buffer size w.r.t. watermark and enabled channels.

	 * scan_bytes is aligned so we need an exact size for DMA

 Prepare a DMA cyclic transaction */

 enable general overrun error signaling */

 Issue pending DMA requests */

 consider current time as DMA start time for timestamps */

 if using DMA, we do not use our own IRQ (we use DMA-controller) */

 if the trigger is not ours, then it has its own IRQ */

 check if we are enabling triggered buffer or the touchscreen */

 if we are not in triggered mode, we cannot enable the buffer. */

 we continue with the triggered buffer */

 these channel types cannot be handled by this trigger */

 check if we are disabling triggered buffer or the touchscreen */

 if we are not in triggered mode, nothing to do here */

	/*

	 * For each enable channel we must disable it in hardware.

	 * In the case of DMA, we must read the last converted value

	 * to clear EOC status and not get a possible interrupt later.

	 * This value is being read by DMA from LCDR anyway, so it's not lost.

 these channel types are virtual, no need to do anything */

 read overflow register to clear possible overflow status */

 if we are using DMA we must clear registers and end DMA */

	/*

	 * Check if the conversion is ready. If not, wait a little bit, and

	 * in case of timeout exit with an error.

 Cannot read data, not ready. Continue without reporting data */

		/*

		 * Our external trigger only supports the voltage channels.

		 * In case someone requested a different type of channel

		 * just put zeroes to buffer.

		 * This should not happen because we check the scan mode

		 * and scan mask when we enable the buffer, and we don't allow

		 * the buffer to start with a mixed mask (voltage and something

		 * else).

		 * Thus, emit a warning.

 if we reached this point, we cannot sample faster */

	/*

	 * interval between samples is total time since last transfer handling

	 * divided by the number of samples (total size divided by sample size)

		/*

		 * for all the values in the current sample,

		 * adjust the values inside the buffer for oversampling

 adjust remaining length */

 adjust buffer index */

 in case of reaching end of buffer, reset index */

 adjust saved time for next transfer handling */

	/*

	 * If it's not our trigger, start a conversion now, as we are

	 * actually polling the trigger now.

	/*

	 * Since the adc frequency is checked before, there is no reason

	 * to not meet the startup time constraint.

	/*

	 * Schedule work to push to buffers.

	 * This is intended to push to the callback buffer that another driver

	 * registered. We are still in a handler from our IRQ. If we push

	 * directly, it means the other driver has it's callback called

	 * from our IRQ context. Which is something we better avoid.

	 * Let's schedule it after our IRQ is completed.

 pen detected IRQ */

 nopen detected IRQ */

 periodic trigger IRQ - during pen sense */

		/*

		 * touching, but the measurements are not ready yet.

		 * read and ignore.

 triggered buffer without DMA */

 triggered buffer with DMA - should not happen */

 software requested conversion */

	/*

	 * Keep in mind that we cannot use software trigger or touchscreen

	 * if external trigger is enabled

 in this case we have a voltage channel */

 Needed to ACK the DRDY interruption */

 if no change, optimize out */

 update ratio */

 we have 2 bytes for each channel */

	/*

	 * We make the buffer double the size of the fifo,

	 * such that DMA uses one half of the buffer (full fifo size)

	 * and the software uses the other half to read/write.

 Configure DMA channel to read data register */

 we have 2 bytes for each channel */

 if we are not using DMA, just return */

 wait for all transactions to be terminated first*/

	/*

	 * The logic here is: if we have watermark 1, it means we do

	 * each conversion with it's own IRQ, thus we don't need DMA.

	 * If the watermark is higher, we do DMA to do all the transfers in bulk

	/*

	 * We can start the DMA only after setting the watermark and

	 * having the DMA initialization completed

	/*

	 * if the new bitmap is a combination of touchscreen and regular

	 * channels, then we are not fine

	/*

	 * Transfer field must be set to 2 according to the datasheet and

	 * allows different analog settings for each channel.

 configure extended mode register */

	/*

	 * Initially the iio buffer has a length of 2 and

	 * a watermark of 1

 find the right trigger, or no trigger at all */

 if we plan to use DMA, we need the physical address of the regs */

	/*

	 * Do a sofware reset of the ADC before we go to suspend.

	 * this will ensure that all pins are free from being muxed by the ADC

	 * and can be used by for other devices.

	 * Otherwise, ADC will hog them and we can't go to suspend mode.

 reconfiguring trigger hardware state */

 check if we are enabling triggered buffer or the touchscreen */

 not needed but more explicit */

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ADC12130/ADC12132/ADC12138 12-bit plus sign ADC driver

 *

 * Copyright (c) 2016 Akinobu Mita <akinobu.mita@gmail.com>

 *

 * Datasheet: http://www.ti.com/lit/ds/symlink/adc12138.pdf

 conversion clock */

 positive analog voltage reference */

 negative analog voltage reference */

 The number of cclk periods for the S/H's acquisition time */

	/*

	 * Maximum size needed: 16x 2 bytes ADC data + 8 bytes timestamp.

	 * Less may be need if not all channels are enabled, as long as

	 * the 8 byte alignment of the timestamp is maintained.

 Skip unused bits for ADC12130 and ADC12132 */

 Issue a read status instruction and read previous conversion data */

 convert regulator output voltage to mV */

 convert regulator output voltage to mV */

 data output at this time has no significance */

		/*

		 * Assume vref_n is 0V if an optional regulator is not

		 * specified, otherwise return the error code.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * AD7787/AD7788/AD7789/AD7790/AD7791 SPI ADC driver

 *

 * Copyright 2012 Analog Devices Inc.

 *  Author: Lars-Peter Clausen <lars@metafoo.de>

 For writes */

 For reads */

		/**

		 * Unipolar: 0 to VREF

		 * Bipolar -VREF to VREF

 The monitor channel uses an internal reference. */

			/*

			 * The signal is attenuated by a factor of 5 and

			 * compared against a 1.17V internal reference.

 Set to poweron-reset default values */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Xilinx XADC driver

 *

 * Copyright 2013 Analog Devices Inc.

 *  Author: Lars-Peter Clausen <lars@metafoo.de>

 Temperature threshold error, we don't handle this yet */

		/*

		 * The temperature channel only supports over-temperature

		 * events.

		/*

		 * For other channels we don't know whether it is a upper or

		 * lower threshold event. Userspace will have to check the

		 * channel value if it wants to know.

 We will never get here */

 bram, pint, paux, ddr */

 ot */

 temp, vccint, vccaux */

 MSB aligned */

 MSB aligned */

		/*

		 * According to the datasheet we need to set the lower 4 bits to

		 * 0x3, otherwise 125 degree celsius will be used as the

		 * threshold.

		/*

		 * Since we store the hysteresis as relative (to the threshold)

		 * value, but the hardware expects an absolute value we need to

		 * recalcualte this value whenever the hysteresis or the

		 * threshold changes.

 SPDX-License-Identifier: GPL-2.0

/*

 * Analog Devices ADF4371 SPI Wideband Synthesizer driver

 *

 * Copyright 2019 Analog Devices Inc.

 Registers address macro */

 ADF4371_REG0 */

 ADF4371_REG17 */

 ADF4371_REG18 */

 ADF4371_REG1A */

 ADF4371_REG24 */

 ADF4371_REG25 */

 ADF4371_REG32 */

 ADF4371_REG34 */

 Specifications */

 4000 MHz */

 8000 MHz */

 Hz */

 Hz */

 Hz */

 Hz */

 Hz */

 Hz */

 Hz */

 Hz */

 MOD1 is a 24-bit primary modulus with fixed value of 2^25 */

 MOD2 is the programmable, 14-bit auxiliary fractional modulus */

	/*

	 * Lock for accessing device registers. Some operations require

	 * multiple consecutive R/W operations, during which the device

	 * shouldn't be interrupted. The buffers are also shared across

	 * all operations so need to be protected on stand alone reads and

	 * writes.

 ADF4371 RF16 8000...16000 MHz */

 ADF4371 RF32 16000...32000 MHz */

 REG12 default */

	/*

	 * The R counter allows the input reference frequency to be

	 * divided down to produce the reference clock to the PFD

	/*

	 * Set to 1 when in INT mode (when FRAC1 = FRAC2 = 0),

	 * and set to 0 when in FRAC mode.

	/*

	 * Ideally we use IIO_CHAN_INFO_FREQUENCY, but there are

	 * values > 2^32 in order to support the entire frequency range

	 * in Hz. Using scale is a bit ugly.

 Perform a software reset */

 Mute to Lock Detect */

 Set address in ascending order, so the bulk_write() will work */

	/*

	 * Calculate and maximize PFD frequency

	 * fPFD = REFIN × ((1 + D)/(R × (1 + T)))

	 * Where D is the REFIN doubler bit, T is the reference divide by 2,

	 * R is the reference division factor

	 * TODO: it is assumed D and T equal 0.

 Calculate Timeouts */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * AD9523 SPI Low Jitter Clock Generator

 *

 * Copyright 2012 Analog Devices Inc.

 AD9523_SERIAL_PORT_CONFIG */

 AD9523_READBACK_CTRL */

 AD9523_PLL1_CHARGE_PUMP_CTRL */

 AD9523_PLL1_INPUT_RECEIVERS_CTRL */

 AD9523_PLL1_REF_CTRL */

 AD9523_PLL1_MISC_CTRL */

 AD9523_PLL1_LOOP_FILTER_CTRL */

 AD9523_PLL2_CHARGE_PUMP */

 AD9523_PLL2_FEEDBACK_DIVIDER_AB */

 AD9523_PLL2_CTRL */

 AD9523_PLL2_VCO_CTRL */

 AD9523_PLL2_VCO_DIVIDER */

 AD9523_PLL2_LOOP_FILTER_CTRL */

 AD9523_PLL2_R2_DIVIDER */

 AD9523_CHANNEL_CLOCK_DIST */

 AD9523_PLL1_OUTPUT_CTRL */

 AD9523_PLL1_OUTPUT_CHANNEL_CTRL */

 AD9523_READBACK_0 */

 AD9523_READBACK_1 */

 AD9523_STATUS_SIGNALS */

 AD9523_POWER_DOWN_CTRL */

 AD9523_IO_UPDATE */

 AD9523_EEPROM_DATA_XFER_STATUS */

 AD9523_EEPROM_ERROR_READBACK */

 AD9523_EEPROM_CTRL1 */

 AD9523_EEPROM_CTRL2 */

 Helpers to avoid excess line breaks */

	/*

	 * Lock for accessing device registers. Some operations require

	 * multiple consecutive R/W operations, during which the device

	 * shouldn't be interrupted.  The buffers are also shared across

	 * all operations so need to be protected on stand alone reads and

	 * writes.

	/*

	 * DMA (thus cache coherency maintenance) requires the

	 * transfer buffers to live in their own cache lines.

	/* We encode the register size 1..3 bytes into the register address.

	 * On transfer we get the size from the register datum, and make sure

	 * the result is properly aligned.

 Ch 10..14: No action required, return success */

	/*

	 * PLL1 Setup

	/*

	 * PLL2 Setup

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ADF4350/ADF4351 SPI Wideband Synthesizer driver

 *

 * Copyright 2012-2013 Analog Devices Inc.

 Channel Spacing */

 Phase Frequency Detector */

	/*

	 * Lock to protect the state of the device from potential concurrent

	 * writes. The device is configured via a sequence of SPI writes,

	 * and this lock is meant to prevent the start of another sequence

	 * before another one has finished.

	/*

	 * DMA (thus cache coherency maintenance) requires the

	 * transfer buffers to live in their own cache lines.

	/*

	 * Allow a predefined reference division factor

	 * if not set, compute our own

 try higher spacing values */

 Div round closest (n + d/2)/d */

 PLL unlocked? return error */

	/* Ideally we use IIO_CHAN_INFO_FREQUENCY, but there are

	 * values > 2^32 in order to support the entire frequency range

	 * in Hz. Using scale is a bit ugly.

 r2_user_settings */

 r3_user_settings */

 r4_user_settings */

 sentinel */ },

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ADRF6780 driver

 *

 * Copyright 2021 Analog Devices Inc.

 ADRF6780 Register Map */

 ADRF6780_REG_CONTROL Map */

 ADRF6780_REG_ALARM_READBACK Map */

 ADRF6780_REG_ENABLE Map */

 ADRF6780_REG_LINEARIZE Map */

 ADRF6780_REG_LO_PATH Map */

 ADRF6780_REG_ADC_CONTROL Map */

 ADRF6780_REG_ADC_OUTPUT Map */

 Protect against concurrent accesses to the device */

 Recommended delay for the ADC to be ready*/

 Perform a software reset */

 Disable all components in the Enable Register */

 SPDX-License-Identifier: GPL-2.0

/*

 * Analog Devices LTC2983 Multi-Sensor Digital Temperature Measurement System

 * driver

 *

 * Copyright 2019 Analog Devices Inc.

 register map */

 cold junction for thermocouples and rsense for rtd's and thermistor's */

	/*

	 * DMA (thus cache coherency maintenance) requires the

	 * transfer buffers to live in their own cache lines.

	 * Holds the converted temperature

 specifies the sensor channel */

 sensor type */

 raw table sensor data */

 address offset */

/*

 * Convert to Q format numbers. These number's are integers where

 * the number of integer and fractional bits are specified. The resolution

 * is given by 1/@resolution and tell us the number of fractional bits. For

 * instance a resolution of 2^-10 means we have 10 fractional bits.

 all values are multiplied by 1000000 to remove the fraction */

 just print a warning */

	/*

	 * custom->size holds the raw size of the table. However, when

	 * configuring the sensor channel, we must write the number of

	 * entries of the table minus 1. For steinhart sensors 0 is written

	 * since the size is constant!

	/*

	 * Check if the offset was assigned already. It should be for steinhart

	 * sensors. When coming from sleep, it should be assigned for all.

		/*

		 * This needs to be done again here because, from the moment

		 * when this test was done (successfully) for this custom

		 * sensor, a steinhart sensor might have been added changing

		 * custom_table_size...

 write custom sensor table */

	/*

	 * For custom steinhart, the full u32 is taken. For all the others

	 * the MSB is discarded.

 n_entries must be an even number */

 check Steinhart size */

 Check space on the table. */

 allocate the table */

		/*

		 * Steinhart sensors are configured with raw values in the

		 * devicetree. For the other sensors we must convert the

		 * value to raw. The odd index's correspond to temperarures

		 * and always have 1/1024 of resolution. Temperatures also

		 * come in kelvin, so signed values is not possible

	/*

	 * This is done to first add all the steinhart sensors to the table,

	 * in order to maximize the table usage. If we mix adding steinhart

	 * with the other sensors, we might have to do some roundup to make

	 * sure that sensor_addr - 0x250(start address) is a multiple of 4

	 * (for steinhart), and a multiple of 6 for all the other sensors.

	 * Since we have const 24 bytes for steinhart sensors and 24 is

	 * also a multiple of 6, we guarantee that the first non-steinhart

	 * sensor will sit in a correct address without the need of filling

	 * addresses.

 mark as unset. This is checked later on the assign phase */

 validate channel index */

			/*

			 * This would be catched later but we can just return

			 * the error right away.

 check custom sensor */

 set common parameters */

 4 wires, Kelvin Rsense */

 Current rotation is only available with rsense sharing */

	/*

	 * rtd channel indexes are a bit more complicated to validate.

	 * For 4wire RTD with rotation, the channel selection cannot be

	 * >=19 since the chann + 1 is used in this configuration.

	 * For 4wire RTDs with kelvin rsense, the rsense channel cannot be

	 * <=1 since chanel - 1 and channel - 2 are used.

 4-wire */

 kelvin rsense*/

 same as differential case */

 check custom sensor */

 set common parameters */

 default to 5uA */

 rotation is only possible if sharing rsense */

 validate channel index */

 check custom sensor */

 set common parameters */

 Auto range is not allowed for custom sensors */

 default to 1uA */

 default to auto-range */

 auto range */

 validate channel index */

 set common parameters */

 2^20 resolution */

 validate channel index */

	/*

	 * Times 1000 because we have milli-ohms and __convert_to_raw

	 * expects scales of 1000000 which are used for all other

	 * properties.

	 * 2^10 resolution

 set common parameters */

 set common parameters */

 start conversion */

	/*

	 * wait for conversion to complete.

	 * 300 ms should be more than enough to complete the conversion.

	 * Depending on the sensor configuration, there are 2/3 conversions

	 * cycles of 82ms.

 read the converted data */

 sanity check */

 value in milli degrees */

 2^10 */

 value in millivolt */

 2^21 */

 check if we have a valid channel */

 don't add rsense to iio */

 set generic sensor parameters */

 make sure the device is up: start bit (7) is 0 and done bit (6) is 1 */

		/*

		 * The assign_iio flag is necessary for when the device is

		 * coming out of sleep. In that case, we just need to

		 * re-configure the device channels.

		 * We also don't assign iio channels for rsense.

 assign iio channel */

		/*

		 * add chan as the iio .address so that, we can directly

		 * reference the sensor given the iio_chan_spec

/*

 *  The reg_bits are actually 12 but the device needs the first *complete*

 *  byte for the command (R/W).

 bring the device out of reset */

 dummy read to bring the device out of sleep */

 we need to re-assign the channels */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HID Sensors Driver

 * Copyright (c) 2017, Intel Corporation.

 Channel definitions */

 Adjust channel real bits based on report descriptor */

 Real storage bits will change based on the report desc. */

 Maximum size of a sample to capture is s32 */

 Callback handler to send event after all samples are received and captured */

 Capture samples in local storage */

 Parse report which is specific to an usage id*/

 Function to initialize the processing for usage id */

 Function to deinitialize the processing for usage id */

 Format: HID-SENSOR-usage_id_in_hex_lowercase */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0

/*

 * mlx90632.c - Melexis MLX90632 contactless IR temperature sensor

 *

 * Copyright (c) 2017 Melexis <cmo@melexis.com>

 *

 * Driver for the Melexis MLX90632 I2C 16-bit IR thermopile sensor

 Memory sections addresses */

 Start address of ram */

 Start address of user eeprom */

 EEPROM addresses - used at startup */

 Control register initial value */

 I2C address register initial value */

 EEPROM version reg address */

 P_R calibration register 32bit */

 P_G calibration register 32bit */

 P_T calibration register 32bit */

 P_O calibration register 32bit */

 Aa calibration register 32bit */

 Ab calibration register 32bit */

 Ba calibration register 32bit */

 Bb calibration register 32bit */

 Ca calibration register 32bit */

 Cb calibration register 32bit */

 Da calibration register 32bit */

 Db calibration register 32bit */

 Ea calibration register 32bit */

 Eb calibration register 32bit */

 Fa calibration register 32bit */

 Fb calibration register 32bit */

 Ga calibration register 32bit */

 Gb calibration register 16bit */

 Ka calibration register 16bit */

 Ha customer calib value reg 16bit */

 Hb customer calib value reg 16bit */

 Register addresses - volatile */

 Chip I2C address register */

 Control register address - volatile */

 Control Register address */

 PowerMode Mask */

 Meas select Mask */

 PowerModes statuses */

 hold */

 sleep step*/

 step */

 continuous*/

 Measurement types */

 Measurement type select*/

 I2C command register - volatile */

 I2C command Register address */

 Device status register - volatile */

 Device status register */

 Device busy indicator */

 EEPROM busy indicator */

 Brown out reset indicator */

 Data position */

 Data ready indicator */

 RAM_MEAS address-es for each channel */

 Name important RAM_MEAS channels */

 Magic constants */

 EEPROM DSPv5 Medical device id */

 EEPROM DSPv5 Consumer device id */

 EEPROM DSPv5 Extended range device id */

 DSP version and device ID in EE_VERSION */

 DSP version */

 DSP version in EE_VERSION */

 Reset sensor (address or global) */

 ResCtrlRef value of Ch 1 or Ch 2 */

 ResCtrlRef value of Channel 3 */

 Maximum measurements in list */

 Autosleep delay */

 Extended mode raw value limit */

/**

 * struct mlx90632_data - private data for the MLX90632 device

 * @client: I2C client of the device

 * @lock: Internal mutex for multiple reads for single measurement

 * @regmap: Regmap of the device

 * @emissivity: Object emissivity from 0 to 1000 where 1000 = 1.

 * @mtyp: Measurement type physical sensor configuration for extended range

 *        calculations

 * @object_ambient_temperature: Ambient temperature at object (might differ of

 *                              the ambient temperature of sensor.

/**

 * mlx90632_perform_measurement() - Trigger and retrieve current measurement cycle

 * @data: pointer to mlx90632_data object containing regmap information

 *

 * Perform a measurement and return latest measurement cycle position reported

 * by sensor. This is a blocking function for 500ms, as that is default sensor

 * refresh rate.

	/*

	 * Give the mlx90632 some time to reset properly before sending a new I2C command

	 * if this is not done, the following I2C command(s) will not be accepted.

 Iterations of calculation as described in datasheet */

 Iterations of calculation as described in datasheet */

 Use extended mode calculations */

 Confirm we are within 0 and 1.0 */

 25 degrees milliCelsius */

 SPDX-License-Identifier: GPL-2.0

/* max31856.c

 *

 * Maxim MAX31856 thermocouple sensor driver

 *

 * Copyright (C) 2018-2019 Rockwell Collins

/*

 * The MSB of the register value determines whether the following byte will

 * be written or read. If it is 0, one or more byte reads will follow.

 The MAX31856 registers */

 Thermocouple Temperature */

 Cold Junction Temperature */

	/* Start by changing to Off mode before making changes as

	 * some settings are recommended to be set only when the device

	 * is off

 Set thermocouple type based on dts property */

	/*

	 * Enable Open circuit fault detection

	 * Read datasheet for more information: Table 4.

	 * Value 01 means : Enabled (Once every 16 conversions)

 Set Auto Conversion Mode */

		/*

		 * Multibyte Read

		 * MAX31856_LTCBH_REG, MAX31856_LTCBM_REG, MAX31856_LTCBL_REG

 Skip last 5 dead bits of LTCBL */

 Check 7th bit of LTCBH reg. value for sign*/

		/*

		 * Multibyte Read

		 * MAX31856_CJTO_REG, MAX31856_CJTH_REG, MAX31856_CJTL_REG

 Get Cold Junction Temp. offset register value */

 Get CJTH and CJTL value and skip last 2 dead bits of CJTL */

 As per datasheet add offset into CJTH and CJTL */

 Check 7th bit of CJTH reg. value for sign */

 Check for over/under voltage or open circuit fault */

 Cold junction Temp. Data resolution is 0.015625 */

 1000 * 0.015625 */

 Thermocouple Temp. Data resolution is 0.0078125 */

 1000 * 0.0078125) */

 Round up to next 2pow if needed */

	/*

	 * no need to translate values as the supported types

	 * have the same value as the #defines

 SPDX-License-Identifier: GPL-2.0-only

/*

 * tsys02d.c - Support for Measurement-Specialties tsys02d temperature sensor

 *

 * Copyright (c) 2015 Measurement-Specialties

 *

 * (7-bit I2C slave address 0x40)

 *

 * Datasheet:

 *  http://www.meas-spec.com/downloads/Digital_Sensor_TSYS02D.pdf

 String copy of the above const for readability purpose */

 in milli °C */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Digital temperature sensor with integrated Non-volatile memory

 * Copyright (c) 2021 Puranjay Mohan <puranjay12@gmail.com>

 *

 * Driver for the Texas Instruments TMP117 Temperature Sensor

 * (7-bit I2C slave address (0x48 - 0x4B), changeable via ADD pins)

 *

 * Note: This driver assumes that the sensor has been calibrated beforehand.

		/*

		 * Conversion from 10s of uC to mC

		 * as IIO reports temperature in mC

 SPDX-License-Identifier: GPL-2.0+

/*

 * Azoteq IQS620AT Temperature Sensor

 *

 * Copyright (C) 2019 Jeff LaBundy <jeff@labundy.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * tsys01.c - Support for Measurement-Specialties tsys01 temperature sensor

 *

 * Copyright (c) 2015 Measurement-Specialties

 *

 * Datasheet:

 *  http://www.meas-spec.com/downloads/TSYS01_Digital_Temperature_Sensor.pdf

 TSYS01 Commands */

 lock during conversion */

 Multiplication coefficients for temperature computation */

 Temperature algorithm */

 in milli °C */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * tmp007.c - Support for TI TMP007 IR thermopile sensor with integrated math engine

 *

 * Copyright (c) 2017 Manivannan Sadhasivam <manivannanece23@gmail.com>

 *

 * Driver for the Texas Instruments I2C 16-bit IR thermopile sensor

 *

 * (7-bit I2C slave address (0x40 - 0x47), changeable via ADR pins)

 *

 * Note:

 * 1. This driver assumes that the sensor has been calibrated beforehand

 * 2. Limit threshold events are enabled at the start

 * 3. Operating mode: INT

 Status register flags */

 LSB: 0.03125 degree Celsius */

 LSB: 0.5 degree Celsius */

 Shift length 7 bits = 6(15:6) + 1(0.5 LSB) */

 Full scale threshold value is +/- 256 degree Celsius */

 Shift length 7 bits = 6(15:6) + 1(0.5 LSB) */

	/*

	 * Set Configuration register:

	 * 1. Conversion ON

	 * 2. ALERT enable

	 * 3. Transient correction enable

	/*

	 * Only the following flags can activate ALERT pin. Data conversion/validity flags

	 * flags can still be polled for getting temperature data

	 *

	 * Set Status Mask register:

	 * 1. Object temperature high limit enable

	 * 2. Object temperature low limit enable

	 * 3. TDIE temperature high limit enable

	 * 4. TDIE temperature low limit enable

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) Linumiz 2021

 *

 * max31865.c - Maxim MAX31865 RTD-to-Digital Converter sensor driver

 *

 * Author: Navin Sankar Velliangiri <navin@linumiz.com>

/*

 * The MSB of the register value determines whether the following byte will

 * be written or read. If it is 0, read will follow and if it is 1, write

 * will follow.

 The MAX31865 registers */

 RTD Temperature */

 Enable BIAS to start the conversion */

 wait 10.5ms before initiating the conversion */

 50Hz filter mode requires 62.5ms to complete */

 60Hz filter mode requires 52ms to complete */

 Temp. Data resolution is 0.03125 degree centigrade */

 1000 * 0.03125 */

 3-wire RTD connection */

 50Hz noise rejection filter */

 select 3 wire */

 select 2 or 4 wire */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * mlx90614.c - Support for Melexis MLX90614 contactless IR temperature sensor

 *

 * Copyright (c) 2014 Peter Meerwald <pmeerw@pmeerw.net>

 * Copyright (c) 2015 Essensium NV

 * Copyright (c) 2015 Melexis

 *

 * Driver for the Melexis MLX90614 I2C 16-bit IR thermopile sensor

 *

 * (7-bit I2C slave address 0x5a, 100KHz bus speed only!)

 *

 * To wake up from sleep mode, the SDA line must be held low while SCL is high

 * for at least 33ms.  This is achieved with an extra GPIO that can be connected

 * directly to the SDA line.  In normal operation, the GPIO is set as input and

 * will not interfere in I2C communication.  While the GPIO is driven low, the

 * i2c adapter is locked since it cannot be used by other clients.  The SCL line

 * always has a pull-up so we do not need an extra GPIO to drive it high.  If

 * the "wakeup" GPIO is not given, power management will be disabled.

 RAM offsets with 16-bit data, MSB first */

 raw data IR channel 1 */

 raw data IR channel 2 */

 ambient temperature */

 object 1 temperature */

 object 2 temperature */

 EEPROM offsets with 16-bit data, MSB first */

 emissivity correction coefficient */

 configuration register */

 Control bits in configuration register */

 IIR coefficient */

 single (0) or dual (1) IR sensor */

 FIR coefficient */

 gain */

 Timings (in ms) */

 time for EEPROM write/erase to complete */

 time to hold SDA low for wake-up */

 time before first data after wake-up */

 default autosleep delay */

 Magic constants */

 decimal part of the Kelvin offset */

 remainder of offset (273.15*50) */

 Scale in milliKelvin (0.02 * 1000) */

 max value for emissivity */

 1/65535 ~ 0.000015259 */

 Fixed value for FIR part of low pass filter */

 for EEPROM access only */

 NULL to disable sleep/wake-up */

 in jiffies */

 Bandwidth values for IIR filtering */

/*

 * Erase an address and write word.

 * The mutex must be locked before calling.

	/*

	 * Note: The mlx90614 requires a PEC on writing but does not send us a

	 * valid PEC on reading.  Hence, we cannot set I2C_CLIENT_PEC in

	 * i2c_client.flags.  As a workaround, we use i2c_smbus_xfer here.

 erase command */

 actual write */

/*

 * Find the IIR value inside mlx90614_iir_values array and return its position

 * which is equivalent to the bit value in sensor register

	/*

	 * CONFIG register values must not be changed so

	 * we must read them before we actually write

	 * changes

 Write changed values */

/*

 * If @startup is true, make sure MLX90614_TIMING_STARTUP ms have elapsed since

 * the last wake-up.  This is normally only needed to get a valid temperature

 * reading.  EEPROM access does not need such delay.

 * Return 0 on success, <0 on error.

 0.02K / LSB */

 MSB is an error flag */

 1/65535 / LSB */

	case IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY: /* IIR setting with

 1/65535 / LSB */

 IIR Filter setting */

	/*

	 * Quirk: the i2c controller may get confused right after the

	 * wake-up signal has been sent.  As a workaround, do a dummy read.

	 * If the read fails, the controller will probably be reset so that

	 * further reads will work.

 Return wake-up GPIO or NULL if sleep functionality should be disabled. */

 Return 0 for single sensor, 1 for dual sensor, <0 on error. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * tmp006.c - Support for TI TMP006 IR thermopile sensor

 *

 * Copyright (c) 2013 Peter Meerwald <pmeerw@pmeerw.net>

 *

 * Driver for the Texas Instruments I2C 16-bit IR thermopile sensor

 *

 * (7-bit I2C slave address 0x40, changeable via ADR pins)

 *

 * TODO: data ready irq

 LSB is 156.25 nV */

 LSB is 0.03125 degrees Celsius */

 SPDX-License-Identifier: GPL-2.0+

/*

 * maxim_thermocouple.c  - Support for Maxim thermocouple chips

 *

 * Copyright (C) 2016-2018 Matt Ranostay

 * Author: <matt.ranostay@konsulko.com>

 thermocouple temperature */

 thermocouple temperature */

 cold junction temperature */

 bit-check for valid input */

 check to be sure this is a valid reading */

 1000 * 0.0625 */

 1000 * 0.25 */

 SPDX-License-Identifier: GPL-2.0

/*

 * IIO rescale driver

 *

 * Copyright (C) 2018 Axentia Technologies AB

 *

 * Author: Peter Rosin <peda@axentia.se>

			/*

			 * When only processed channels are supported, we

			 * read the processed data and scale it by 1/1

			 * augmented with whatever the rescaler has calculated.

			/*

			 * Processed channels are scaled 1-to-1

	/*

	 * Using .read_avail() is fringe to begin with and makes no sense

	 * whatsoever for processed channels, so we make sure that this cannot

	 * be called on a processed channel.

	/*

	 * Calculate the scaling factor, 1 / (gain * sense), or

	 * gain_div / (gain_mult * sense), while trying to keep the

	 * numerator/denominator from overflowing.

 sentinel */ }

 one extra entry for the sentinel */

/*

 * Workbit NinjaSCSI-32Bi/UDE PCI/CardBus SCSI Host Bus Adapter driver

 * Debug routine

 *

 * This software may be used and distributed according to the terms of

 * the GNU General Public License.

/*

 * Show the command data of a command

 00-03 */ "Test Unit Ready", "Rezero Unit", unknown, "Request Sense",

 04-07 */ "Format Unit", "Read Block Limits", unknown, "Reassign Blocks",

 08-0d */ "Read (6)", unknown, "Write (6)", "Seek (6)", unknown, unknown,

 0e-12 */ unknown, "Read Reverse", "Write Filemarks", "Space", "Inquiry",  

 13-16 */ unknown, "Recover Buffered Data", "Mode Select", "Reserve",

 17-1b */ "Release", "Copy", "Erase", "Mode Sense", "Start/Stop Unit",

 1c-1d */ "Receive Diagnostic", "Send Diagnostic", 

 1e-1f */ "Prevent/Allow Medium Removal", unknown,

 20-22 */  unknown, unknown, unknown,

 23-28 */ unknown, unknown, "Read Capacity", unknown, unknown, "Read (10)",

 29-2d */ unknown, "Write (10)", "Seek (10)", unknown, unknown,

 2e-31 */ "Write Verify","Verify", "Search High", "Search Equal",

 32-34 */ "Search Low", "Set Limits", "Prefetch or Read Position", 

 35-37 */ "Synchronize Cache","Lock/Unlock Cache", "Read Defect Data",

 38-3c */ "Medium Scan", "Compare","Copy Verify", "Write Buffer", "Read Buffer",

 3d-3f */ "Update Block", "Read Long",  "Write Long",

 40-41 */ "Change Definition", "Write Same", 

 42-48 */ "Read Sub-Ch(cd)", "Read TOC", "Read Header(cd)", "Play Audio(cd)", unknown, "Play Audio MSF(cd)", "Play Audio Track/Index(cd)", 

 49-4f */ "Play Track Relative(10)(cd)", unknown, "Pause/Resume(cd)", "Log Select", "Log Sense", unknown, unknown,

 50-55 */ unknown, unknown, unknown, unknown, unknown, "Mode Select (10)",

 56-5b */ unknown, unknown, unknown, unknown, "Mode Sense (10)", unknown,

 5c-5f */ unknown, unknown, unknown,

	printk(KERN_DEBUG);

printk(KERN_DEBUG "%s ", __func__);*/

 vender specific */

 end */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * SCSI device handler infrastructure.

 *

 * Copyright IBM Corporation, 2007

 *      Authors:

 *               Chandra Seetharaman <sekharan@us.ibm.com>

 *               Mike Anderson <andmike@linux.vnet.ibm.com>

/*

 * scsi_dh_handler_attach - Attach a device handler to a device

 * @sdev - SCSI device the device handler should attach to

 * @scsi_dh - The device handler to attach

/*

 * scsi_dh_handler_detach - Detach a device handler from a device

 * @sdev - SCSI device the device handler should be detached from

	/*

	 * device_handler is optional, so ignore errors

	 * from scsi_dh_handler_attach()

/*

 * scsi_register_device_handler - register a device handler personality

 *      module.

 * @scsi_dh - device handler to be registered.

 *

 * Returns 0 on success, -EBUSY if handler already registered.

/*

 * scsi_unregister_device_handler - register a device handler personality

 *      module.

 * @scsi_dh - device handler to be unregistered.

 *

 * Returns 0 on success, -ENODEV if handler not registered.

/*

 * scsi_dh_activate - activate the path associated with the scsi_device

 *      corresponding to the given request queue.

 *     Returns immediately without waiting for activation to be completed.

 * @q    - Request queue that is associated with the scsi_device to be

 *         activated.

 * @fn   - Function to be called upon completion of the activation.

 *         Function fn is called with data (below) and the error code.

 *         Function fn may be called from the same calling context. So,

 *         do not hold the lock in the caller which may be needed in fn.

 * @data - data passed to the function fn upon completion.

 *

/*

 * scsi_dh_set_params - set the parameters for the device as per the

 *      string specified in params.

 * @q - Request queue that is associated with the scsi_device for

 *      which the parameters to be set.

 * @params - parameters in the following format

 *      "no_of_params\0param1\0param2\0param3\0...\0"

 *      for example, string for 2 parameters with value 10 and 21

 *      is specified as "2\010\021\0".

/*

 * scsi_dh_attach - Attach device handler

 * @q - Request queue that is associated with the scsi_device

 *      the handler should be attached to

 * @name - name of the handler to attach

/*

 * scsi_dh_attached_handler_name - Get attached device handler's name

 * @q - Request queue that is associated with the scsi_device

 *      that may have a device handler attached

 * @gfp - the GFP mask used in the kmalloc() call when allocating memory

 *

 * Returns name of attached handler, NULL if no handler is attached.

 * Caller must take care to free the returned string.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * SCSI Enclosure Services

 *

 * Copyright (C) 2008 James Bottomley <James.Bottomley@HansenPartnership.com>

 only clear byte 1 for ENCLOSURE_COMPONENT_DEVICE */

 Set PCV bit */

	/* successful diagnostic but wrong page code.  This happens to some

 Set PF bit */

 Clear everything */

 set select */

 clear reserved, just in case */

/* For device slot and array device slot elements, byte 3 bit 6

 * is "fault sensed" while byte 3 bit 5 is "fault reqstd". As this

 * code stands these bits are shifted 4 positions right so in

 SES doesn't do the SGPIO blink settings */

 SES doesn't do the SGPIO blink settings */

 SES doesn't do the SGPIO blink settings */

 power = 1 is device_off = 0 and vice versa */

  0  */

 only take the phy0 addr */

 FIXME: Need to add more protocols than just SAS */

 re-read page 10 */

 Page 7 for the descriptors is optional */

 add 1 for trailing '\0' we'll use */

 skip past overall descriptor */

					/* Add trailing zero - pushes into

 only find additional descriptions for specific devices */

 these elements are optional */

 not an enclosure, but might be in one */

 TYPE_ENCLOSURE prints a message in probe */

	/* we always have one main enclosure and the rest are referred

 begin at the enclosure descriptor */

 skip all the enclosure descriptors */

 make sure getting page 2 actually works */

	/* The additional information page --- allows us

	/* see if there are any devices matching before

  exact match to this enclosure */

/*

 * Linux driver for VMware's para-virtualized SCSI HBA.

 *

 * Copyright (C) 2008-2014, VMware, Inc. All Rights Reserved.

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License as published by the

 * Free Software Foundation; version 2 of the License and no later version.

 *

 * This program is distributed in the hope that it will be useful, but

 * WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or

 * NON INFRINGEMENT.  See the GNU General Public License for more

 * details.

 *

 * You should have received a copy of the GNU General Public License

 * along with this program; if not, write to the Free Software

 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.

 *

	/*

	 * The index of the context in cmd_map serves as the context ID for a

	 * 1-to-1 mapping completions back to requests.

 Command line parameters */

/*

 * Map a pvscsi_ctx struct to a context ID field value; we map to a simple

 * non-zero integer. ctx always points to an entry in cmd_map array, hence

 * the return value is always >=1.

/*

 * Map all data buffers for a command into PCI space and

 * setup the scatter/gather list if needed.

		/*

		 * In case there is no S/G list, scsi_sglist points

		 * directly to the buffer.

/*

 * The device incorrectly doesn't clear the first byte of the sense

 * buffer in some cases. We have to do it ourselves.

 * Otherwise we run into trouble when SWIOTLB is forced.

/*

 * Pull a completion descriptor off and pass the completion back

 * to the SCSI mid layer.

		/*

		 * The command was requested to be aborted. Just signal that

		 * the request completed and swallow the actual cmd completion

		 * here. The abort handler will post a completion for this

		 * command indicating that it got successfully aborted.

			/*

			 * Commands like INQUIRY may transfer less data than

			 * requested by the initiator via bufflen. Set residual

			 * count to make upper layer aware of the actual amount

			 * of data returned.

 Report residual data in underruns */

 Our emulation returns this for non-connected devs */

/*

 * barrier usage : Since the PVSCSI device is emulated, there could be cases

 * where we may want to serialize some accesses between the driver and the

 * emulation layer. We use compiler barriers instead of the more expensive

 * memory barriers because PVSCSI is only supported on X86 which has strong

 * memory access ordering.

		/*

		 * This barrier() ensures that *e is not dereferenced while

		 * the device emulation still writes data into the slot.

		 * Since the device emulation advances s->cmpProdIdx only after

		 * updating the slot we want to check it first.

		/*

		 * This barrier() ensures that compiler doesn't reorder write

		 * to s->cmpConsIdx before the read of (*e) inside

		 * pvscsi_complete_request. Otherwise, device emulation may

		 * overwrite *e before we had a chance to read it.

/*

 * Translate a Linux SCSI request into a request ring entry.

	/*

	 * If this condition holds, we might have room on the request ring, but

	 * we might not have room on the completion ring for the response.

	 * However, we have already ruled out this possibility - we would not

	 * have successfully allocated a context if it were true, since we only

	 * have one context per request entry.  Check for it anyway, since it

	 * would be a serious bug.

	/*

	 * Poll the completion ring first - we might be trying to abort

	 * a command that is waiting to be dispatched in the completion ring.

	/*

	 * If there is no context for the command, it either already succeeded

	 * or else was never properly issued.  Not our problem.

	/*

	 * Mark that the command has been requested to be aborted and issue

	 * the abort.

 Wait for 2 secs for the completion. */

		/*

		 * Failed to abort the command, unmark the fact that it

		 * was requested to be aborted.

	/*

	 * Successfully aborted the command.

/*

 * Abort all outstanding requests.  This is only safe to use if the completion

 * ring will never be walked again or the device has been reset, because it

 * destroys the 1-1 mapping between context field passed to emulation and our

 * request structure.

		/*

		 * Now that we know that the ISR won't add more work on the

		 * workqueue we can safely flush any outstanding work.

	/*

	 * We're going to tear down the entire ring structure and set it back

	 * up, so stalling new requests until all completions are flushed and

	 * the rings are back in place.

	/*

	 * Now process any completions.  Note we do this AFTER adapter reset,

	 * which is strange, but stops races where completions get posted

	 * between processing the ring and issuing the reset.  The backend will

	 * not touch the ring memory after reset, so the immediately pre-reset

	 * completion ring state is still valid.

	/*

	 * We don't want to queue new requests for this bus after

	 * flushing all pending requests to emulation, since new

	 * requests could then sneak in during this bus reset phase,

	 * so take the lock now.

	/*

	 * We don't want to queue new requests for this device after flushing

	 * all pending requests to emulation, since new requests could then

	 * sneak in during this device reset phase, so take the lock now.

/*

 * Allocate scatter gather lists.

 *

 * These are statically allocated.  Trying to be clever was not worth it.

 *

 * Dynamic allocation can fail, and we can't go deep into the memory

 * allocator, since we're a SCSI driver, and trying too hard to allocate

 * memory might generate disk I/O.  We also don't want to fail disk I/O

 * in that case because we can't get an allocation - the I/O could be

 * trying to swap out data to free memory.  Since that is pathological,

 * just use a statically allocated scatter list.

 *

/*

 * Query the device, fetch the config info and return the

 * maximum number of targets on the adapter. In case of

 * failure due to any reason return default i.e. 16.

 Fetch config info from the device. */

	/*

	 * Mark the completion page header with error values. If the device

	 * completes the command successfully, it sets the status values to

	 * indicate success.

	/*

	 * Let's use a temp pvscsi_adapter struct until we find the number of

	 * targets on the adapter, after that we will switch to the real

	 * allocated struct.

	/*

	 * Ask the device for max number of targets before deciding the

	 * default pvscsi_ring_pages value.

		/*

		 * Set the right default value. Up to 16 it is 8, above it is

		 * max.

	/*

	 * Let's use the real pvscsi_adapter struct here onwards.

	/*

	 * Copy back what we already have to the allocated adapter struct.

	/*

	 * From this point on we should reset the adapter if anything goes

	 * wrong.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Virtio SCSI HBA driver

 *

 * Copyright IBM Corp. 2010

 * Copyright Red Hat, Inc. 2011

 *

 * Authors:

 *  Stefan Hajnoczi   <stefanha@linux.vnet.ibm.com>

 *  Paolo Bonzini   <pbonzini@redhat.com>

 Command queue element */

 Protects vq */

 Driver instance state */

 Get some buffers ready for event vq */

 Protected by event_vq lock */

/*

 * virtscsi_complete_cmd - finish a scsi_cmd and invoke scsi_done

 *

 * Called with vq_lock held.

 Stop scheduling work before calling cancel_work_sync.  */

	/* Handle "Parameters changed", "Mode parameters changed", and

 PQ indicates the LUN is not attached */

			/*

			 * If all LUNs of a virtio-scsi device are unplugged

			 * it will respond with BAD TARGET on any INQUIRY

			 * command.

			 * Remove the device in this case as well.

 Request header.  */

 Data-out buffer.  */

 Place WRITE protection SGLs before Data OUT payload */

 Response header.  */

 Data-in buffer */

 Place READ protection SGLs before Data IN payload */

/**

 * virtscsi_add_cmd - add a virtio_scsi_cmd to a virtqueue, optionally kick it

 * @vq		: the struct virtqueue we're talking about

 * @cmd		: command structure

 * @req_size	: size of the request buffer

 * @resp_size	: size of the response buffer

 * @kick	: whether to kick the virtqueue immediately

 TODO: check feature bit and fail if unsupported?  */

	/*

	 * The spec guarantees that all requests related to the TMF have

	 * been completed, but the callback might not have run yet if

	 * we're using independent interrupts (e.g. MSI).  Poll the

	 * virtqueues once.

	 *

	 * In the abort case, scsi_done() will do nothing, because the

	 * command timed out and hence SCMD_STATE_COMPLETE has been set.

	/*

	 * Passed through SCSI targets (e.g. with qemu's 'scsi-block')

	 * may have transfer limits which come from the host SCSI

	 * controller or something on the host side other than the

	 * target itself.

	 *

	 * To make this work properly, the hypervisor can adjust the

	 * target's VPD information to advertise these limits.  But

	 * for that to work, the guest has to look at the VPD pages,

	 * which we won't do by default if it is an SPC-2 device, even

	 * if it does actually support it.

	 *

	 * So, set the blist to always try to read the VPD pages.

/**

 * virtscsi_change_queue_depth() - Change a virtscsi target's queue depth

 * @sdev:	Virtscsi target whose queue depth to change

 * @qdepth:	New queue depth

/*

 * The host guarantees to respond to each command, although I/O

 * latencies might be higher than on bare metal.  Reset the timer

 * unconditionally to give the host a chance to perform EH.

 Stop all the virtqueues. */

 Discover virtqueues and write information to configuration.  */

 We need to know how many queues before we allocate. */

	/* LUNs > 256 are reported with format 1, so they go in the range

	 * 16640-32767.

 SPDX-License-Identifier: GPL-2.0-or-later

/* 

 *  Parallel SCSI (SPI) transport specific attributes exported to sysfs.

 *

 *  Copyright (c) 2003 Silicon Graphics, Inc.  All rights reserved.

 *  Copyright (c) 2004, 2005 James Bottomley <James.Bottomley@SteelEye.com>

 increase this if you add attributes */

#define SPI_OTHER_ATTRS 1	/* Increase this if you add "always

#define DV_RETRIES	3	/* should only need at most 

 Our blacklist flags */

 blacklist table, modelled on scsi_devinfo.c */

 Private data accessors (keep these out of the header file) */

	/* The PPR values 0-6 are reserved, fill them in when

 0x00 */

 0x01 */

 0x02 */

 0x03 */

 0x04 */

 0x05 */

 0x06 */

 0x07 */

 0x08 */

 0x09 */

 0x0a */

 0x0b */

 0x0c */

/* The PPR values at which you calculate the period in ns by multiplying

		/*

		 * The purpose of the RQF_PM flag below is to bypass the

		 * SDEV_QUIESCE state.

 retries */ 1,

	/* Populate the target capability fields with the values

 illegal value */

 async */

 narrow */

 no IU */

 ST */

 The Parallel SCSI Tranport Attributes: */

/* we only care about the first child device that's a real SCSI device

/* Translate the period into ns according to the current spec

/* This is for read/write Domain Validation:  If the device supports

	/* set up the pattern buffer.  Doesn't matter if we spill

 fill the buffer with counting (test a) */

		/* fill the buffer with alternating words of 0x0 and

		/* fill with crosstalk (alternating 0x5555 0xaaa)

 fill with shifting bits (test d) */

 don't bother with random data (test e) */

 INVALID FIELD IN CDB */

				/* This would mean that the drive lied

				 * to us about supporting an echo

				 * buffer (unfortunately some Western

				 * Digital drives do precisely this)

/* This is for the simplest form of Domain Validation: a read test

		/* If we don't have the inquiry data already, the

 failure */

 OK, retrain, fallback */

		/* Here's the fallback sequence; first try turning off

		 * IU, then QAS (if we can control them), then finally

 Total failure; set to async and return */

	/* first off do a test unit ready.  This can error out 

	 * because of reservations or some other reason.  If it

	 * fails, the device won't let us write to the echo buffer

	/* We send a set of three TURs to clear any outstanding 

	 * unit attention conditions if they exist (Otherwise the

	 * buffer tests won't be happy).  If the TUR still fails

	 * (reservation conflict, device not ready, etc) just

 TUR succeeded */

 Device has no echo buffer */

 first set us up for narrow async */

 FIXME: should probably offline the device here? */

 test width */

			/* Make sure we don't force wide back on by asking

 device can't handle synchronous */

	/* len == -1 is the signal that we need to ascertain the

	 * presence of an echo buffer before trying to use it.  len ==

 now set up to the maximum */

	/* try QAS requests; this should be harmless to set if the

 This u320 (or u640). Set IU transfers */

 Then set the optional parameters */

	/* now that we've done all this, actually check the bus

	 * signal type (if known).  Some devices are stupid on

	/* set width last because it will pull all the other

 Do the read only INQUIRY tests */

 See if we actually managed to negotiate and sustain DT */

	/* see if the device has an echo buffer.  If it does we can do

	 * the SPI pattern write tests.  Because of some broken

	 * devices, we *only* try this on a device that has actually

		/* OK, the stupid drive can't do a write echo buffer

/**	spi_dv_device - Do Domain Validation on the device

 *	@sdev:		scsi device to validate

 *

 *	Performs the domain validation on the given device in the

 *	current execution thread.  Since DV operations may sleep,

 *	the current thread must have user context.  Also no SCSI

 *	related locks that would deadlock I/O issued by the DV may

 *	be held.

	/*

	 * Because this function and the power management code both call

	 * scsi_device_quiesce(), it is not safe to perform domain validation

	 * while suspend or resume is in progress. Hence the

	 * lock/unlock_system_sleep() calls.

	/* We need to verify that the actual device will quiesce; the

/**

 *	spi_schedule_dv_device - schedule domain validation to occur on the device

 *	@sdev:	The device to validate

 *

 *	Identical to spi_dv_device() above, except that the DV will be

 *	scheduled to occur in a workqueue later.  All memory allocations

 *	are atomic, so may be called from any context including those holding

 *	SCSI locks.

 Set pending early (dv_device doesn't check it, only sets it) */

/**

 * spi_display_xfer_agreement - Print the current target transfer agreement

 * @starget: The target for which to display the agreement

 *

 * Each SPI port is required to maintain a transfer agreement for each

 * other port on the bus.  This function prints a one-line summary of

 * the current agreement; more detailed information is available in sysfs.

/**

 * spi_populate_tag_msg - place a tag message in a buffer

 * @msg:	pointer to the area to place the tag

 * @cmd:	pointer to the scsi command for the tag

 *

 * Notes:

 *	designed to create the correct type of tag message for the 

 *	particular request.  Returns the size of the tag message.

 *	May return 0 if TCQ is disabled for this device.

 0x00 */ "Task Complete", NULL 
 0x03 */ "Restore Pointers", "Disconnect", "Initiator Error", 

 0x06 */ "Abort Task Set", "Message Reject", "Nop", "Message Parity Error",

 0x0a */ "Linked Command Complete", "Linked Command Complete w/flag",

 0x0c */ "Target Reset", "Abort Task", "Clear Task Set", 

 0x0f */ "Initiate Recovery", "Release Recovery",

 0x11 */ "Terminate Process", "Continue Task", "Target Transfer Disable",

 0x14 */ NULL, NULL, "Clear ACA", "LUN Reset"

 0x20 */ "Simple Queue Tag", "Head of Queue Tag", "Ordered Queue Tag",

 0x23 */ "Ignore Wide Residue", "ACA"

 0x00 */ "Modify Data Pointer", "Synchronous Data Transfer Request",

 0x02 */ "SCSI-I Extended Identify", "Wide Data Transfer Request",

 0x04 */ "Parallel Protocol Request", "Modify Bidirectional Data Pointer"

 Identify */

 Normal One byte */

 Two byte */

 ifndef CONFIG_SCSI_CONSTANTS */

 Identify */

 Normal One byte */

 Two byte */

 ! CONFIG_SCSI_CONSTANTS */

	/* Note: this class has no device attributes, so it has

	 * no per-HBA allocation and thus we don't need to distinguish

/* returns true if we should be showing the variable.  Also

 * overloads the return by setting 1<<1 if the attribute should

 force an update based on parameters read from the device */

 compatible */

 SPDX-License-Identifier: GPL-2.0

/*

 * SCSI library functions depending on DMA

/**

 * scsi_dma_map - perform DMA mapping against command's sg lists

 * @cmd:	scsi command

 *

 * Returns the number of sg lists actually used, zero if the sg lists

 * is NULL, or -ENOMEM if the mapping failed.

/**

 * scsi_dma_unmap - unmap command's sg lists mapped by scsi_dma_map

 * @cmd:	scsi command

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * iSCSI transport class definitions

 *

 * Copyright (C) IBM Corporation, 2004

 * Copyright (C) Mike Christie, 2004 - 2005

 * Copyright (C) Dmitry Yusupov, 2004 - 2005

 * Copyright (C) Alex Aizman, 2004 - 2005

/*

 * Export tracepoint symbols to be used by other modules.

 sysfs session id for next new session */

/*

 * list of registered transports and lock that must

 * be held while accessing list. The iscsi_transport_lock must

 * be acquired after the rx_queue_mutex.

/*

 * iscsi_transport_class represents the iscsi_transports that are

 * registered.

/*

 * iSCSI endpoint attrs

/**

 * iscsi_lookup_endpoint - get ep from handle

 * @handle: endpoint handle

 *

 * Caller must do a iscsi_put_endpoint.

/*

 * Interface to display network param to sysfs

 iface attrs show */

 generic read only ipv4 attribute */

 generic read only ipv6 attribute */

 common read only iface attribute */

 common iscsi specific settings attributes */

 convert iscsi_ipaddress_state values to ascii string name */

 convert iscsi_router_state values to ascii string name */

 parent reference released in iscsi_iface_release */

/*

 * Interface to display flash node params to sysfs

 flash node session attrs show */

 Flash node session attributes */

 flash node connection attrs show */

 Flash node connection attributes */

/**

 * iscsi_create_flashnode_sess - Add flashnode session entry in sysfs

 * @shost: pointer to host data

 * @index: index of flashnode to add in sysfs

 * @transport: pointer to transport data

 * @dd_size: total size to allocate

 *

 * Adds a sysfs entry for the flashnode session attributes

 *

 * Returns:

 *  pointer to allocated flashnode sess on success

 *  %NULL on failure

/**

 * iscsi_create_flashnode_conn - Add flashnode conn entry in sysfs

 * @shost: pointer to host data

 * @fnode_sess: pointer to the parent flashnode session entry

 * @transport: pointer to transport data

 * @dd_size: total size to allocate

 *

 * Adds a sysfs entry for the flashnode connection attributes

 *

 * Returns:

 *  pointer to allocated flashnode conn on success

 *  %NULL on failure

/**

 * iscsi_is_flashnode_conn_dev - verify passed device is to be flashnode conn

 * @dev: device to verify

 * @data: pointer to data containing value to use for verification

 *

 * Verifies if the passed device is flashnode conn device

 *

 * Returns:

 *  1 on success

 *  0 on failure

/**

 * iscsi_get_flashnode_by_index -finds flashnode session entry by index

 * @shost: pointer to host data

 * @idx: index to match

 *

 * Finds the flashnode session object for the passed index

 *

 * Returns:

 *  pointer to found flashnode session object on success

 *  %NULL on failure

/**

 * iscsi_find_flashnode_sess - finds flashnode session entry

 * @shost: pointer to host data

 * @data: pointer to data containing value to use for comparison

 * @fn: function pointer that does actual comparison

 *

 * Finds the flashnode session object comparing the data passed using logic

 * defined in passed function pointer

 *

 * Returns:

 *  pointer to found flashnode session device object on success

 *  %NULL on failure

/**

 * iscsi_find_flashnode_conn - finds flashnode connection entry

 * @fnode_sess: pointer to parent flashnode session entry

 *

 * Finds the flashnode connection object comparing the data passed using logic

 * defined in passed function pointer

 *

 * Returns:

 *  pointer to found flashnode connection device object on success

 *  %NULL on failure

/**

 * iscsi_destroy_flashnode_sess - destroy flashnode session entry

 * @fnode_sess: pointer to flashnode session entry to be destroyed

 *

 * Deletes the flashnode session entry and all children flashnode connection

 * entries from sysfs

/**

 * iscsi_destroy_all_flashnode - destroy all flashnode session entries

 * @shost: pointer to host data

 *

 * Destroys all the flashnode session entries and all corresponding children

 * flashnode connection entries from sysfs

/*

 * BSG support

/**

 * iscsi_bsg_host_dispatch - Dispatch command to LLD.

 * @job: bsg job to be processed

 start with length of msgcode */

 check if we have the msgcode value at least */

 Validate the host command */

 check if we really have all the request data needed */

 return the errno failure code as the only status */

/**

 * iscsi_bsg_host_add - Create and add the bsg hooks to receive requests

 * @shost: shost for iscsi_host

 * @ihost: iscsi_cls_host adding the structures to

 ignore any bsg add error - we just can't do sgio */

/*

 * Returns the matching session to a given sid

/*

 * Returns the matching connection to a given sid / cid tuple

/*

 * The following functions can be used by LLDs that allocate

 * their own scsi_hosts or by software iscsi LLDs

/**

 * iscsi_scan_finished - helper to report when running scans are done

 * @shost: scsi host

 * @time: scan run time

 *

 * This function can be used by drives like qla4xxx to report to the scsi

 * layer when the scans it kicked off at module load time are done.

	/*

	 * qla4xxx will have kicked off some session unblocks before calling

	 * scsi_scan_host, so just wait for them to complete.

/**

 * iscsi_block_scsi_eh - block scsi eh until session state has transistioned

 * @cmd: scsi cmd passed to scsi eh handler

 *

 * If the session is down this function will wait for the recovery

 * timer to fire or for the session to be logged back in. If the

 * recovery timer fires then FAST_IO_FAIL is returned. The caller

 * should pass this error value to the scsi eh.

 we raced with the unblock's flush */

	/*

	 * The recovery and unblock work get run from the same workqueue,

	 * so try to cancel it if it was going to run after this unblock.

 start IO */

	/*

	 * Only do kernel scanning if the driver is properly hooked into

	 * the async scanning code (drivers like iscsi_tcp do login and

	 * scanning from userspace).

/**

 * iscsi_unblock_session - set a session as logged in and start IO.

 * @session: iscsi session

 *

 * Mark a session as ready to accept IO.

	/*

	 * Blocking the session can be done from any context so we only

	 * queue the block work. Make sure the unblock work has completed

	 * because it flushes/cancels the other works and updates the state.

 Prevent new scans and make sure scanning is not in progress */

 this is released in the dev's release function */

/**

 * iscsi_create_session - create iscsi class session

 * @shost: scsi host

 * @transport: iscsi transport

 * @dd_size: private driver data size

 * @target_id: which target

 *

 * This can be called from a LLD or iscsi_transport.

	/*

	 * If we are blocked let commands flow again. The lld or iscsi

	 * layer should set up the queuecommand to fail commands.

	 * We assume that LLD will not be calling block/unblock while

	 * removing the session.

 flush running scans then delete devices */

 flush running unbind operations */

 hw iscsi may not have removed all connections from session */

	/*

	 * If this is a termination we have to call stop_conn with that flag

	 * so the correct states get set. If we haven't run the work yet try to

	 * avoid the extra run.

		/*

		 * Figure out if it was the kernel or userspace initiating this.

		/*

		 * Only clear for recovery to avoid extra cleanup runs during

		 * termination.

	/*

	 * If we are not at least bound there is nothing for us to do. Userspace

	 * will do a ep_disconnect call if offload is used, but will not be

	 * doing a stop since there is nothing to clean up, so we have to clear

	 * the cleanup bit here.

		/*

		 * If the user has set up for the session to never timeout

		 * then hang like they wanted. For all other cases fail right

		 * away since userspace is not going to relogin.

/**

 * iscsi_create_conn - create iscsi class connection

 * @session: iscsi cls session

 * @dd_size: private driver data size

 * @cid: connection id

 *

 * This can be called from a LLD or iscsi_transport. The connection

 * is child of the session so cid must be unique for all connections

 * on the session.

 *

 * Since we do not support MCS, cid will normally be zero. In some cases

 * for software iscsi we could be trying to preallocate a connection struct

 * in which case there could be two connection structs and cid would be

 * non-zero.

 this is released in the dev's release function */

/**

 * iscsi_destroy_conn - destroy iscsi class connection

 * @conn: iscsi cls session

 *

 * This can be called from a LLD or iscsi_transport.

/*

 * iscsi interface functions

/**

 * iscsi_session_event - send session destr. completion event

 * @session: iscsi class session

 * @event: type of event

	/*

	 * this will occur if the daemon is not up, so we just warn

	 * the user and when the daemon is restarted it will handle it

		/*

		 * conn was not even bound yet, so we can't get iscsi conn

		 * failures yet.

 Check if this was a conn error and the kernel took ownership */

	/*

	 * The following cmds need to be run under the ep_mutex so in kernel

	 * conn cleanup (ep_disconnect + unbind and conn) is not done while

	 * these are running. They also must not run if we have just run a conn

	 * cleanup because they would set the state in a way that might allow

	 * IO or send IO themselves.

			/*

			 * For offload boot support where iscsid is restarted

			 * during the pivot root stage, the ep will be intact

			 * here when the new iscsid instance starts up and

			 * reconnects.

 Prevent this session from being found again */

/*

 * Get message from skb.  Each message is processed by iscsi_if_recv_msg.

 * Malformed skbs with wrong lengths or invalid creds are not processed.

			/*

			 * special case for GET_STATS:

			 * on success - sending reply and stats from

			 * inside of if_recv_msg(),

			 * on error - fall through.

/*

 * iSCSI connection attrs

	/*								\

	 * Need to make sure ep_disconnect does not free the LLD's	\

	 * interconnect resources while we are trying to read them.	\

/*

 * iSCSI session attrs

/*

 * iSCSI host attrs

 convert iscsi_port_speed values to ascii string name */

 convert iscsi_port_state values to ascii string name */

 host parameters */

 connection parameters */

 session parameters */

 SPDX-License-Identifier: GPL-2.0

/*

 * Linux Driver for Mylex DAC960/AcceleRAID/eXtremeRAID PCI RAID Controllers

 *

 * Copyright 2017 Hannes Reinecke, SUSE Linux GmbH <hare@suse.com>

 *

 * Based on the original DAC960 driver,

 * Copyright 1998-2001 by Leonard N. Zubkoff <lnz@dandelion.com>

 * Portions Copyright 2002 by Mylex (An IBM Business Unit)

 *

/*

 * myrb_create_mempools - allocates auxiliary data structures

 *

 * Return: true on success, false otherwise.

	/*

	 * Initialize the Monitoring Timer.

/*

 * myrb_destroy_mempools - tears down the memory pools for the controller

/*

 * myrb_reset_cmd - reset command block

/*

 * myrb_qcmd - queues command block for execution

/*

 * myrb_exec_cmd - executes command block and waits for completion.

 *

 * Return: command status

/*

 * myrb_exec_type3 - executes a type 3 command and waits for completion.

 *

 * Return: command status

/*

 * myrb_exec_type3D - executes a type 3D command and waits for completion.

 *

 * Return: command status

/**

 * myrb_get_event - get event log from HBA

 * @cb: pointer to the hba structure

 * @event: number of the event

 *

 * Execute a type 3E command and logs the event message

/*

 * myrb_get_errtable - retrieves the error table from the controller

 *

 * Executes a type 3 command and logs the error table from the controller.

/*

 * myrb_get_ldev_info - retrieves the logical device table from the controller

 *

 * Executes a type 3 command and updates the logical device table.

 *

 * Return: command status

/*

 * myrb_get_rbld_progress - get rebuild progress information

 *

 * Executes a type 3 command and returns the rebuild progress

 * information.

 *

 * Return: command status

/*

 * myrb_update_rbld_progress - updates the rebuild status

 *

 * Updates the rebuild status for the attached logical devices.

/*

 * myrb_get_cc_progress - retrieve the rebuild status

 *

 * Execute a type 3 Command and fetch the rebuild / consistency check

 * status.

/*

 * myrb_bgi_control - updates background initialisation status

 *

 * Executes a type 3B command and updates the background initialisation status

/*

 * myrb_hba_enquiry - updates the controller status

 *

 * Executes a DAC_V1_Enquiry command and updates the controller status.

 *

 * Return: command status

/*

 * myrb_set_pdev_state - sets the device state for a physical device

 *

 * Return: command status

/*

 * myrb_enable_mmio - enables the Memory Mailbox Interface

 *

 * PD and P controller types have no memory mailbox, but still need the

 * other dma mapped memory.

 *

 * Return: true on success, false otherwise.

	/*

	 * Skip mailbox initialisation for PD and P Controllers

 These are the base addresses for the command memory mailbox array */

 These are the base addresses for the status memory mailbox array */

 Enable the Memory Mailbox Interface. */

/*

 * myrb_get_hba_config - reads the configuration information

 *

 * Reads the configuration information from the controller and

 * initializes the controller structure.

 *

 * Return: 0 on success, errno otherwise

	/*

	 * Initialize the Controller Model Name and Full Model Name fields.

	/*

	 * Initialize the Controller Firmware Version field and verify that it

	 * is a supported firmware version.

	 * The supported firmware versions are:

	 *

	 * DAC1164P		    5.06 and above

	 * DAC960PTL/PRL/PJ/PG	    4.06 and above

	 * DAC960PU/PD/PL	    3.51 and above

	 * DAC960PU/PD/PL/P	    2.73 and above

	/*

	 * DEC Alpha machines were often equipped with DAC960 cards that were

	 * OEMed from Mylex, and had their own custom firmware. Version 2.70,

	 * the last custom FW revision to be released by DEC for these older

	 * controllers, appears to work quite well with this driver.

	 *

	 * Cards tested successfully were several versions each of the PD and

	 * PU, called by DEC the KZPSC and KZPAC, respectively, and having

	 * the Manufacturer Numbers (from Mylex), usually on a sticker on the

	 * back of the board, of:

	 *

	 * KZPSC:  D040347 (1-channel) or D040348 (2-channel)

	 *         or D040349 (3-channel)

	 * KZPAC:  D040395 (1-channel) or D040396 (2-channel)

	 *         or D040397 (3-channel)

	/*

	 * Initialize the Channels, Targets, Memory Size, and SAF-TE

	 * Enclosure Management Enabled fields.

	/*

	 * Initialize the Controller Queue Depth, Driver Queue Depth,

	 * Logical Drive Count, Maximum Blocks per Command, Controller

	 * Scatter/Gather Limit, and Driver Scatter/Gather Limit.

	 * The Driver Queue Depth must be at most one less than the

	 * Controller Queue Depth to allow for an automatic drive

	 * rebuild operation.

 Play safe and disable TCQ */

	/*

	 * Initialize the Stripe Size, Segment Size, and Geometry Translation.

 Assume 255/63 translation */

	/*

	 * Initialize the Background Initialization Status.

/*

 * myrb_unmap - unmaps controller structures

/*

 * myrb_cleanup - cleanup controller structures

 Free the memory mailbox, status, and related structures */

 Illegal request, invalid field in CDB */

 Illegal request, invalid field in CDB */

 Illegal request, invalid field in CDB */

 Illegal request, invalid field in CDB */

 Illegal request, invalid field in CDB */

 Assume good status */

 Data protect, attempt to read invalid data */

 Data protect, attempt to read invalid data */

 0x2F */

 0x2E */

 Data protect, attempt to read invalid data */

 0xAF */

 0xAE */

 Illegal request, invalid opcode */

/**

 * myrb_is_raid - return boolean indicating device is raid volume

 * @dev: the device struct object

/**

 * myrb_get_resync - get raid volume resync percent complete

 * @dev: the device struct object

/**

 * myrb_get_state - get raid volume status

 * @dev: the device struct object

 Unrecovered read error */

 Write error */

 Unrecovered read error, auto-reallocation failed */

 Write error, auto-reallocation failed */

 Logical block address out of range */

/*

 * myrb_err_status - reports controller BIOS messages

 *

 * Controller BIOS messages are passed through the Error Status Register

 * when the driver performs the BIOS handshaking.

 *

 * Return: true for fatal errors and false otherwise.

/*

 * Hardware-specific functions

/*

 * DAC960 LA Series Controllers

 Memory barrier to prevent reordering */

 Memory barrier to force PCI access */

/*

 * DAC960 PG Series Controllers

 Memory barrier to prevent reordering */

 Memory barrier to force PCI access */

/*

 * DAC960 PD Series Controllers

/*

 * DAC960 P Series Controllers

 *

 * Similar to the DAC960 PD Series Controllers, but some commands have

 * to be translated.

 SPDX-License-Identifier: GPL-2.0

/*

 * SCSI functions used by both the initiator and the target code.

 Command group 3 is reserved and should never be used.  */

/* NB: These are exposed through /proc/scsi/scsi and form part of the ABI.

 * You may not alter any existing entry (although adding new ones is

 * encouraged once assigned by ANSI/INCITS T10).

/**

 * scsi_device_type - Return 17-char string indicating device type.

 * @type: type number to look up

/**

 * scsilun_to_int - convert a scsi_lun to an int

 * @scsilun:	struct scsi_lun to be converted.

 *

 * Description:

 *     Convert @scsilun from a struct scsi_lun to a four-byte host byte-ordered

 *     integer, and return the result. The caller must check for

 *     truncation before using this function.

 *

 * Notes:

 *     For a description of the LUN format, post SCSI-3 see the SCSI

 *     Architecture Model, for SCSI-3 see the SCSI Controller Commands.

 *

 *     Given a struct scsi_lun of: d2 04 0b 03 00 00 00 00, this function

 *     returns the integer: 0x0b03d204

 *

 *     This encoding will return a standard integer LUN for LUNs smaller

 *     than 256, which typically use a single level LUN structure with

 *     addressing method 0.

/**

 * int_to_scsilun - reverts an int into a scsi_lun

 * @lun:        integer to be reverted

 * @scsilun:	struct scsi_lun to be set.

 *

 * Description:

 *     Reverts the functionality of the scsilun_to_int, which packed

 *     an 8-byte lun value into an int. This routine unpacks the int

 *     back into the lun value.

 *

 * Notes:

 *     Given an integer : 0x0b03d204, this function returns a

 *     struct scsi_lun of: d2 04 0b 03 00 00 00 00

 *

/**

 * scsi_normalize_sense - normalize main elements from either fixed or

 *			descriptor sense data format into a common format.

 *

 * @sense_buffer:	byte array containing sense data returned by device

 * @sb_len:		number of valid bytes in sense_buffer

 * @sshdr:		pointer to instance of structure that common

 *			elements are written to.

 *

 * Notes:

 *	The "main elements" from sense data are: response_code, sense_key,

 *	asc, ascq and additional_length (only for descriptor format).

 *

 *	Typically this function can be called after a device has

 *	responded to a SCSI command with the CHECK_CONDITION status.

 *

 * Return value:

 *	true if valid sense data information found, else false;

		/*

		 * descriptor format

		/*

		 * fixed format

/**

 * scsi_sense_desc_find - search for a given descriptor type in	descriptor sense data format.

 * @sense_buffer:	byte array of descriptor format sense data

 * @sb_len:		number of valid bytes in sense_buffer

 * @desc_type:		value of descriptor type to find

 *			(e.g. 0 -> information)

 *

 * Notes:

 *	only valid when sense data is in descriptor format

 *

 * Return value:

 *	pointer to start of (first) descriptor if found else NULL

 short descriptor ??

/**

 * scsi_build_sense_buffer - build sense data in a buffer

 * @desc:	Sense format (non-zero == descriptor format,

 *              0 == fixed format)

 * @buf:	Where to build sense data

 * @key:	Sense key

 * @asc:	Additional sense code

 * @ascq:	Additional sense code qualifier

 *

 descriptor, current */

 fixed, current */

/**

 * scsi_set_sense_information - set the information field in a

 *		formatted sense data buffer

 * @buf:	Where to build sense data

 * @buf_len:    buffer length

 * @info:	64-bit information value to be set

 *

 * Return value:

 *	0 on success or -EINVAL for invalid sense buffer length

 Not enough room for info */

 Valid bit */

		/*

		 * Only set the 'VALID' bit if we can represent the value

		 * correctly; otherwise just fill out the lower bytes and

		 * clear the 'VALID' flag.

/**

 * scsi_set_sense_field_pointer - set the field pointer sense key

 *		specific information in a formatted sense data buffer

 * @buf:	Where to build sense data

 * @buf_len:    buffer length

 * @fp:		field pointer to be set

 * @bp:		bit pointer to be set

 * @cd:		command/data bit

 *

 * Return value:

 *	0 on success or -EINVAL for invalid sense buffer length

 Not enough room for info */

 Valid bit */

 SPDX-License-Identifier: GPL-2.0-only

/* sun3x_esp.c: ESP front-end for Sun3x systems.

 *

 * Copyright (C) 2007,2008 Thomas Bogendoerfer (tsbogend@alpha.franken.de)

 DMA controller reg offsets */

 rw  DMA control/status register    0x00   */

 rw  DMA transfer address register  0x04   */

 rw  DMA transfer count register    0x08   */

 rw  DMA test/debug register        0x0c   */

/*

 * m68k always assumes readl/writel operate on little endian

 * mmio space; this is wrong at least for Sun3x, so we

 * need to workaround this until a proper way is found

 Enable interrupts.  */

 Disable interrupts.  */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * SCSI RDMA (SRP) transport class

 *

 * Copyright (C) 2007 FUJITA Tomonori <tomof@acm.org>

/**

 * srp_tmo_valid() - check timeout combination validity

 * @reconnect_delay: Reconnect delay in seconds.

 * @fast_io_fail_tmo: Fast I/O fail timeout in seconds.

 * @dev_loss_tmo: Device loss timeout in seconds.

 *

 * The combination of the timeout parameters must be such that SCSI commands

 * are finished in a reasonable time. Hence do not allow the fast I/O fail

 * timeout to exceed SCSI_DEVICE_BLOCK_MAX_TIMEOUT nor allow dev_loss_tmo to

 * exceed that limit if failing I/O fast has been disabled. Furthermore, these

 * parameters must be such that multipath can detect failed paths timely.

 * Hence do not allow all three parameters to be disabled simultaneously.

/**

 * srp_reconnect_work() - reconnect and schedule a new attempt if necessary

 * @work: Work structure used for scheduling this operation.

/*

 * scsi_target_block() must have been called before this function is

 * called to guarantee that no .queuecommand() calls are in progress.

 Involve the LLD if possible to terminate all I/O on the rport. */

/**

 * rport_fast_io_fail_timedout() - fast I/O failure timeout handler

 * @work: Work structure used for scheduling this operation.

/**

 * rport_dev_loss_timedout() - device loss timeout handler

 * @work: Work structure used for scheduling this operation.

/**

 * srp_start_tl_fail_timers() - start the transport layer failure timers

 * @rport: SRP target port.

 *

 * Start the transport layer fast I/O failure and device loss timers. Do not

 * modify a timer that was already started.

/**

 * srp_reconnect_rport() - reconnect to an SRP target port

 * @rport: SRP target port.

 *

 * Blocks SCSI command queueing before invoking reconnect() such that

 * queuecommand() won't be invoked concurrently with reconnect() from outside

 * the SCSI EH. This is important since a reconnect() implementation may

 * reallocate resources needed by queuecommand().

 *

 * Notes:

 * - This function neither waits until outstanding requests have finished nor

 *   tries to abort these. It is the responsibility of the reconnect()

 *   function to finish outstanding commands before reconnecting to the target

 *   port.

 * - It is the responsibility of the caller to ensure that the resources

 *   reallocated by the reconnect() function won't be used while this function

 *   is in progress. One possible strategy is to invoke this function from

 *   the context of the SCSI EH thread only. Another possible strategy is to

 *   lock the rport mutex inside each SCSI LLD callback that can be invoked by

 *   the SCSI EH (the scsi_host_template.eh_*() functions and also the

 *   scsi_host_template.queuecommand() function).

		/*

		 * sdev state must be SDEV_TRANSPORT_OFFLINE, transition

		 * to SDEV_BLOCK is illegal. Calling scsi_target_unblock()

		 * later is ok though, scsi_internal_device_unblock_nowait()

		 * treats SDEV_TRANSPORT_OFFLINE like SDEV_BLOCK.

		/*

		 * If the SCSI error handler has offlined one or more devices,

		 * invoking scsi_target_unblock() won't change the state of

		 * these devices into running so do that explicitly.

		/*

		 * srp_reconnect_rport() has been invoked with fast_io_fail

		 * and dev_loss off. Mark the port as failed and start the TL

		 * failure timers if these had not yet been started.

/**

 * srp_timed_out() - SRP transport intercept of the SCSI timeout EH

 * @scmd: SCSI command.

 *

 * If a timeout occurs while an rport is in the blocked state, ask the SCSI

 * EH to continue waiting (BLK_EH_RESET_TIMER). Otherwise let the SCSI core

 * handle the timeout (BLK_EH_DONE).

 *

 * Note: This function is called from soft-IRQ context and with the request

 * queue lock held.

/**

 * srp_rport_get() - increment rport reference count

 * @rport: SRP target port.

/**

 * srp_rport_put() - decrement rport reference count

 * @rport: SRP target port.

/**

 * srp_rport_add - add a SRP remote port to the device hierarchy

 * @shost:	scsi host the remote port is connected to.

 * @ids:	The port id for the remote port.

 *

 * Publishes a port to the rest of the system.

/**

 * srp_rport_del  -  remove a SRP remote port

 * @rport:	SRP remote port to remove

 *

 * Removes the specified SRP remote port.

/**

 * srp_remove_host  -  tear down a Scsi_Host's SRP data structures

 * @shost:	Scsi Host that is torn down

 *

 * Removes all SRP remote ports for a given Scsi_Host.

 * Must be called just before scsi_remove_host for SRP HBAs.

/**

 * srp_stop_rport_timers - stop the transport layer recovery timers

 * @rport: SRP remote port for which to stop the timers.

 *

 * Must be called after srp_remove_host() and scsi_remove_host(). The caller

 * must hold a reference on the rport (rport->dev) and on the SCSI host

 * (rport->dev.parent).

/**

 * srp_attach_transport  -  instantiate SRP transport template

 * @ft:		SRP transport class function template

/**

 * srp_release_transport  -  release SRP transport template instance

 * @t:		transport template instance

 SPDX-License-Identifier: GPL-2.0

/* The sr_is_xa() seems to trigger firmware bugs with some drives :-(

 LSB of length */

 LSB of length */

/* ATAPI drives don't have a SCMD_PLAYAUDIO_TI command.  When these drives

   are emulating a SCSI device via the idescsi module, they need to have

/* We do our own retries because we want to know what the specific

   error code is.  Normally the UNIT_ATTENTION code will automatically

 Minimal error checking.  Ignore cases we know about, and report the rest. */

 This happens if there is no disc in drive */

 sense: Logical unit is in process of becoming ready */

 sleep 2 sec and try again */

 20 secs are enough? */

 sense: Invalid command operation code */

 Wake up a process waiting for device */

 ---------------------------------------------------------------------- */

 interface to cdrom.c                                                   */

 close */ : 0x02 
 we have no changer support */

 SK/ASC/ASCQ of 2/4/1 means "unit is becoming ready" */

	/*

	 * SK/ASC/ASCQ of 2/4/2 means "initialization required"

	 * Using CD_TRAY_OPEN results in an START_STOP_UNIT to close

	 * the tray, which resolves the initialization requirement.

	/*

	 * 0x04 is format in progress .. but there must be a disc present!

	/*

	 * If not using Mt Fuji extended media tray reports,

	 * just return TRAY_OPEN since ATAPI doesn't provide

	 * any other way to detect this...

 0x3a is medium not present */

 look for data tracks */

 I do want the subchannel info */

 Give me medium catalog number info */

 set to max */

 Nx to kbyte/s */

 SET CD SPEED */

 MSB for speed (in kbytes/sec) */

 LSB */

 ----------------------------------------------------------------------- */

 this is called by the generic cdrom driver. arg is a _kernel_ pointer,  */

 because the generic cdrom driver does the user access stuff for us.     */

 only cdromreadtochdr and cdromreadtocentry are left - for use with the  */

 sr_disk_status interface for the generic cdrom driver.                  */

/* -----------------------------------------------------------------------

 * a function to read all sorts of funny cdrom sectors using the READ_CD

 * scsi-3 mmc command

 *

 * lba:     linear block address

 * format:  0 = data (anything)

 *          1 = audio

 *          2 = data (mode 1)

 *          3 = data (mode 2)

 *          4 = data (mode 2 form1)

 *          5 = data (mode 2 form2)

 * blksize: 2048 | 2336 | 2340 | 2352

 READ_CD */

/*

 * read sectors with blocksizes other than 2048

 we try the READ CD command first... */

 fall & retry the other way */

 ... if this fails, we switch the blocksize using MODE SELECT */

/*

 * read a sector in raw mode to check the sector format

 * ret: 1 == mode2 (XA), 0 == mode1, <0 == error 

 read a raw sector failed for some reason. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Driver for Western Digital WD7193, WD7197 and WD7296 SCSI cards

 * Copyright 2013 Ondrej Zary

 *

 * Original driver by

 * Aaron Dewell <dewell@woods.net>

 * Gaerti <Juergen.Gaertner@mbox.si.uni-hannover.de>

 *

 * HW documentation available in book:

 *

 * SPIDER Command Protocol

 * by Chandru M. Sippy

 * SCSI Storage Products (MCP)

 * Western Digital Corporation

 * 09-15-95

 *

 * http://web.archive.org/web/20070717175254/http://sun1.rrzn.uni-hannover.de/gaertner.juergen/wd719x/Linux/Docu/Spider/

/*

 * Driver workflow:

 * 1. SCSI command is transformed to SCB (Spider Control Block) by the

 *    queuecommand function.

 * 2. The address of the SCB is stored in a list to be able to access it, if

 *    something goes wrong.

 * 3. The address of the SCB is written to the Controller, which loads the SCB

 *    via BM-DMA and processes it.

 * 4. After it has finished, it generates an interrupt, and sets registers.

 *

 * flaws:

 *  - abort/reset functions

 *

 * ToDo:

 *  - tagged queueing

 low-level register access */

 wait until the command register is ready */

 poll interrupt status register until command finishes */

 we get this after wd719x_dev_reset, it's not an error */

 we get this after wd719x_bus_reset, it's not an error */

 clear interrupt status register (allow command register to clear) */

 Wait for the Command register to become free */

 disable interrupts except for RESET/ABORT (it breaks them) */

 clear interrupt status register again */

 Now, write the command */

 wait for the command to complete */

 clear interrupt status register (clean up) */

 stop the RISC */

 disable RISC */

 free internal buffers */

 finish a SCSI command, unmap buffers */

 Build a SCB and send it to the card */

 Tagged queueing not supported yet */

 copy the command */

 map SCB */

 map sense buffer */

 request autosense */

 check direction */

 Scather/gather */

 zero length */

 check if the Command register is free */

 write pointer to the AMR */

 send SCB opcode */

 WCS (sequencer) firmware */

 RISC firmware */

 make a fresh copy of WCS and RISC code */

 Reset the Spider Chip and adapter itself */

 Clear PIO mode bits set by BIOS */

 ensure RISC is not running */

 ensure command port is ready */

 Transfer the first 2K words of RISC code to kick start the uP */

 WCS FW */

 RISC FW */

 hash table */

 clear DMA status */

 address to read firmware from */

 base address to write firmware to (on card) */

 size: first 2K words */

 start DMA */

 wait for DMA to complete */

 firmware is loaded, now initialize and wake up the RISC */

 write RISC initialization long words to Spider */

 disable interrupts during initialization of RISC */

 issue INITIALIZE RISC comand */

 enable advanced mode (wake up RISC) */

 clear interrupt status register */

 RISC is up and running */

 Read FW version from RISC */

 RESET SCSI bus */

 use HostParameter structure to set Spider's Host Parameter Block */

 initiate SCAM (does nothing if disabled in BIOS) */

 bug?: we should pass a mask of static IDs which we don't have */

 clear AMR_BIOS_SHARE_INT register */

 flush all SCBs (or all for a device if dev_reset) */

 stop the RISC */

 disable RISC */

 flush all SCBs */

 Try to reinit the RISC */

 heads */

 sectors */

 heads */

 sectors */

 cylinders */

 process a SCB-completion interrupt */

 now have to find result from card */

 or DID_RESET? */

 or DID_ERROR ???*/

 read SCB pointer back from card */

 read all status info at once */

 was the cmd completed a direct or SCB command? */

 interrupt will not be cleared until all data is read */

 clear interrupt so another can happen */

 read config from EEPROM so it can be downloaded by the RISC on (re-)init */

 set all outputs to low */

 configure GPIO pins */

 GPIO outputs */

 GPIO input */

 read EEPROM header */

 default EEPROM values */

 16 DWs = 64 B */

 48ma, spue, parity check */

 ID 7, SCAM disabled */

 250 ms */

 all 6 B */

 narrow card - disable */

 initiate & respond to WIDE messages */

 all disabled */

 all disabled */

 disable TAGGED messages */

 Read card type from GPIO bits 1 and 3 */

 memory area for host (EEPROM) parameters */

 memory area for the RISC for hash table of outstanding requests */

 read parameters from EEPROM */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Generic Macintosh NCR5380 driver

 *

 * Copyright 1998, Michael Schmitz <mschmitz@lbl.gov>

 *

 * Copyright 2019 Finn Thain

 *

 * derived in part from:

/*

 * Generic Generic NCR5380 driver

 *

 * Copyright 1995, Russell King

 Definitions for the core NCR5380 driver. */

 ints[5] (use_tagged_queuing) is ignored */

 !MODULE */

/*

 * According to "Inside Macintosh: Devices", Mac OS requires disk drivers to

 * specify the number of bytes between the delays expected from a SCSI target.

 * This allows the operating system to "prevent bus errors when a target fails

 * to deliver the next byte within the processor bus error timeout period."

 * Linux SCSI drivers lack knowledge of the timing behaviour of SCSI targets

 * so bus errors are unavoidable.

 *

 * If a MOVE.B instruction faults, we assume that zero bytes were transferred

 * and simply retry. That assumption probably depends on target behaviour but

 * seems to hold up okay. The NOP provides synchronization: without it the

 * fault can sometimes occur after the program counter has moved past the

 * offending instruction. Post-increment addressing can't be used.

/*

 * If a MOVE.W (or MOVE.L) instruction faults, it cannot be retried because

 * the residual byte count would be uncertain. In that situation the MOVE_WORD

 * macro clears n in the fixup section to abort the transfer.

 Negated to indicate uncertain length */

 Negated to indicate uncertain length */

 The "SCSI DMA" chip on the IIfx implements this register. */

 SPDX-License-Identifier: GPL-2.0-or-later

/* NCR (or Symbios) 53c700 and 53c700-66 Driver

 *

 * Copyright (C) 2001 by James.Bottomley@HansenPartnership.com

**-----------------------------------------------------------------------------

**  

**

**-----------------------------------------------------------------------------

/* Notes:

 *

 * This driver is designed exclusively for these chips (virtually the

 * earliest of the scripts engine chips).  They need their own drivers

 * because they are missing so many of the scripts and snazzy register

 * features of their elder brothers (the 710, 720 and 770).

 *

 * The 700 is the lowliest of the line, it can only do async SCSI.

 * The 700-66 can at least do synchronous SCSI up to 10MHz.

 * 

 * The 700 chip has no host bus interface logic of its own.  However,

 * it is usually mapped to a location with well defined register

 * offsets.  Therefore, if you can determine the base address and the

 * irq your board incorporating this chip uses, you can probably use

 * this driver to run it (although you'll probably have to write a

 * minimal wrapper for the purpose---see the NCR_D700 driver for

 * details about how to do this).

 *

 *

 * TODO List:

 *

 * 1. Better statistics in the proc fs

 *

 * 2. Implement message queue (queues SCSI messages like commands) and make

 *    the abort and device reset functions use them.

/* CHANGELOG

 *

 * Version 2.8

 *

 * Fixed bad bug affecting tag starvation processing (previously the

 * driver would hang the system if too many tags starved.  Also fixed

 * bad bug having to do with 10 byte command processing and REQUEST

 * SENSE (the command would loop forever getting a transfer length

 * mismatch in the CMD phase).

 *

 * Version 2.7

 *

 * Fixed scripts problem which caused certain devices (notably CDRWs)

 * to hang on initial INQUIRY.  Updated NCR_700_readl/writel to use

 * __raw_readl/writel for parisc compatibility (Thomas

 * Bogendoerfer). Added missing SCp->request_bufflen initialisation

 * for sense requests (Ryan Bradetich).

 *

 * Version 2.6

 *

 * Following test of the 64 bit parisc kernel by Richard Hirst,

 * several problems have now been corrected.  Also adds support for

 * consistent memory allocation.

 *

 * Version 2.5

 * 

 * More Compatibility changes for 710 (now actually works).  Enhanced

 * support for odd clock speeds which constrain SDTR negotiations.

 * correct cacheline separation for scsi messages and status for

 * incoherent architectures.  Use of the pci mapping functions on

 * buffers to begin support for 64 bit drivers.

 *

 * Version 2.4

 *

 * Added support for the 53c710 chip (in 53c700 emulation mode only---no 

 * special 53c710 instructions or registers are used).

 *

 * Version 2.3

 *

 * More endianness/cache coherency changes.

 *

 * Better bad device handling (handles devices lying about tag

 * queueing support and devices which fail to provide sense data on

 * contingent allegiance conditions)

 *

 * Many thanks to Richard Hirst <rhirst@linuxcare.com> for patiently

 * debugging this driver on the parisc architecture and suggesting

 * many improvements and bug fixes.

 *

 * Thanks also go to Linuxcare Inc. for providing several PARISC

 * machines for me to debug the driver on.

 *

 * Version 2.2

 *

 * Made the driver mem or io mapped; added endian invariance; added

 * dma cache flushing operations for architectures which need it;

 * added support for more varied clocking speeds.

 *

 * Version 2.1

 *

 * Initial modularisation from the D700.  See NCR_D700.c for the rest of

 * the changelog.

/* NOTE: For 64 bit drivers there are points in the code where we use

 * a non dereferenceable pointer to point to a structure in dma-able

 * memory (which is 32 bits) so that we can use all of the structure

 * operations but take the address at the end.  This macro allows us

 * to truncate the 64 bit pointer down to 32 bits without the compiler

 This is the script */

/* This translates the SDTR message offset and period to a value

 * which can be loaded into the SXFER_REG.

 *

 * NOTE: According to SCSI-2, the true transfer period (in ns) is

 Fill in the missing routines from the host template */

 adjust all labels to be bus physical */

 now patch up fixed addresses. */

 kick the chip */

 reset the chip */

/*

 * Function : static int data_residual (Scsi_Host *host)

 *

 * Purpose : return residual data count of what's in the chip.  If you

 * really want to know what this function is doing, it's almost a

 * direct transcription of the algorithm described in the 53c710

 * guide, except that the DBC and DFIFO registers are only 6 bits

 * wide on a 53c700.

 *

 get the data direction */

 Receive */

 Send */

/* print out the SCSI wires and corresponding phase from the SBCL register

 Pull a slot off the free list */

 sanity check */

 should panic! */

	/* NOTE: set the state to busy here, not queued, since this

	 * indicates the slot is in use and cannot be run by the IRQ

	 * finish routine.  If we cannot queue the command when it

/* This routine really does very little.  The command is indexed on

 Its just possible that this gets executed twice */

			/* restore the old result if the request sense was

 restore the original length */

 NCR_700_DEBUG */

 Bus reset */

 this is for 700-66, does nothing on 700 */

		/* do the best we can, but the async clock will be out

 sync divider 1.5, async divider 3 */

 sync divider 1, async divider 2 */

 sync divider 1, async divider 1.5 */

 sync divider 1, async divider 1 */

	/* Calculate the actual minimum period that can be supported

	 * by our synchronous clock speed.  See the 710 manual for

	 * exact details of this calculation which is based on a

/* The heart of the message processing engine is that the instruction

 * immediately after the INT is the normal case (and so must be CLEAR

 * ACK).  If we want to do something else, we call that routine in

 * scripts and set temp to be the normal case + 8 (skipping the CLEAR

 * ACK) so that the routine returns correctly to resume its activity

 SDTR message out of the blue, reject it */

			/* SendMsgOut returns, so set up the return

 just reject it */

		/* SendMsgOut returns, so set up the return

 work out where to return to */

 Rejected our sync negotiation attempt */

 rejected our first simple tag message */

 we're done negotiating */

 however, just ignore it */

 just ignore it */

 just reject it */

		/* SendMsgOut returns, so set up the return

 set us up to receive another message */

 OK, if TCQ still under negotiation, we now know it works */

 check for contingent allegiance conditions */

				/* OOPS: bad device, returning another

				/* we can destroy the command here

				 * because the contingent allegiance

				 * condition will cause a retry which

				 * will re-copy the command from the

				 * saved data_cmnd.  We also unmap any

				 * data associated with the command

				/* Here's a quiet hack: the

				 * REQUEST_SENSE command is six bytes,

				 * so store a flag indicating that

				 * this was an internal sense request

				 * and the original status at the end

				SCp->cmd_len = 6; /* command length for

 queue the command for reissue */

 Currently rely on the mid layer evaluation

 of the tag queuing capability



if(status_byte(hostdata->status[0]) == GOOD &&

   SCp->cmnd[0] == INQUIRY && SCp->use_sg == 0) {

			//	/* Piggy back the tag queueing support

	 * on this command */

	dma_sync_single_for_cpu(hostdata->dev,

			    slot->dma_handle,

			    SCp->request_bufflen,

			    DMA_FROM_DEVICE);

	if(((char *)SCp->request_buffer)[7] & 0x02) {

		scmd_printk(KERN_INFO, SCp,

		     "Enabling Tag Command Queuing\n");

		hostdata->tag_negotiated |= (1<<scmd_id(SCp));

		NCR_700_set_flag(SCp->device, NCR_700_DEV_BEGIN_TAG_QUEUEING);

	} else {

		NCR_700_clear_flag(SCp->device, NCR_700_DEV_BEGIN_TAG_QUEUEING);

		hostdata->tag_negotiated &= ~(1<<scmd_id(SCp));

	}

}

 clear the reselection indicator */

 re-patch for this command */

			/* Note: setting SXFER only works if we're

			 * still in the MESSAGE phase, so it is vital

			 * that ACK is still asserted when we process

			 * the reselection message.  The resume offset

			/* I'm just being paranoid here, the command should

		/* This section is full of debugging code because I've

		 * never managed to reach it.  I think what happens is

		 * that, because the 700 runs with selection

		 * interrupts enabled the whole time that we take a

		 * selection interrupt before we manage to get to the

 Take out our own ID */

		/* I've never seen this happen, so keep this as a printk rather

 FIXME: DEBUGGING CODE */

 change slot from busy to queued to redo command */

 convert to real ID */

 just in case we have a stale simple tag message, clear it */

		/* we've just disconnected from the bus, do nothing since

		 * a return here will re-run the queued command slot

/* We run the 53c700 with selection interrupts always enabled.  This

 * means that the chip may be selected as soon as the bus frees.  On a

 * busy bus, this can be before the scripts engine finishes its

 * processing.  Therefore, part of the selection processing has to be

 * to find out what the scripts engine is doing and complete the

 * function if necessary (i.e. process the pending disconnect or save

 Squash compiler warning */

 Take out our own ID */

 mark as having been selected rather than reselected */

 convert to real ID */

 clear any stale simple tag message */

 Selected as target, Ignore */

/* The queue lock with interrupts disabled must be held on entry to

 for IDENTIFY message */

		/* keep this inside the lock to close the race window where

		 * the running command finishes on another CPU while we don't

	/* keep interrupts disabled until we have the command correctly

	/* for INQUIRY or REQUEST_SENSE commands, we cannot be sure

	 * if the negotiated transfer parameters still hold, so

	/* REQUEST_SENSE is asking for contingent I_T_L(_Q) status.

	 * If a contingent allegiance condition exists, the device

	 * will refuse all tags, so send the request sense as untagged

	/* finally plumb the beginning of the SG list into the script

 now perform all the writebacks and invalidates */

 set the synchronous period/offset */

	/* Use the host lock to serialise access to the 53c700

	 * hardware.  Note: In future, we may need to take the queue

	 * lock to enter the done routines.  When that happens, we

	 * need to ensure that for this driver, the host lock and the

 clear all the negotiated parameters */

 clear all the slots and their pending commands */

				/* NOTE: deadlock potential here: we

				 * rely on mid-layer guarantees that

				 * scsi_done won't try to issue the

				 * command again otherwise we'll

				 * deadlock on the

 signal back if this was an eh induced reset */

				/* It wants to reply to some part of

 set the executed moves to nops */

				/* and pretend we disconnected after

 make sure all the data is flushed */

		/* NOTE: selection interrupt processing MUST occur

		 * after script interrupt processing to correctly cope

		 * with the case where we process a disconnect and

		 * then get reselected before we process the

			/* FIXME: It currently takes at least FOUR

			 * interrupts to complete a command that

			 * disconnects: one for the disconnect, one

			 * for the reselection, one to get the

			 * reselection data and one to complete the

			 * command.  If we guess the reselected

			 * command here and prepare it, we only need

			 * to get a reselection data interrupt if we

			 * guessed wrongly.  Since the interrupt

			 * overhead is much greater than the command

			 * setup, this would be an efficient

			 * optimisation particularly as we probably

			 * only have one outstanding command on a

	/* There is probably a technical no-no about this: If we're a

	 * shared interrupt and we got this interrupt because the

	 * other device needs servicing not us, we're still going to

	 * check our queued commands here---of course, there shouldn't

			/* fairness: always run the queue from the last

		/* We're over our allocation, this should never happen

	/* check for untagged commands.  We cannot have any outstanding

	 * commands if we accept them.  Commands could be untagged because:

	 *

	 * - The tag negotiated bitmap is clear

	 * - The blk layer sent and untagged command

 begin the command here */

	/* no need to check for NULL, test for command_slot_count above

	/* here we may have to process an untagged command.  The gate

	 * above ensures that this will be the only one outstanding,

	 * so clear the tag negotiated bit.

	 *

	 * FIXME: This will royally screw up on multiple LUN devices

 save current command for reselection */

	/* sanity check: some of the commands generated by the mid-layer

 clear the internal sense magic */

 OK, get it from the command */

 now build the scatter gather list */

 no outstanding command to abort */

		/* FIXME: This is because of a problem in the new

		 * error handler.  When it is in error recovery, it

		 * will send a TUR to a device it thinks may still be

		 * showing a problem.  If the TUR isn't responded to,

		 * it will abort it and mark the device off line.

		 * Unfortunately, it does no other error recovery, so

		 * this would leave us with an outstanding command

		 * occupying a slot.  Rather than allow this to

		 * happen, we issue a bus reset to force all

 still drop through and return failed */

	/* In theory, eh_complete should always be null because the

	 * eh is single threaded, but just in case we're handling a

 Revalidate the transport parameters of the failing device */

 if we're currently async, make sure the period is reasonable */

 to do here: allocate memory; build a queue_full list */

 Find the correct offset and period via domain validation */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *	scsi_pm.c	Copyright (C) 2010 Alan Stern

 *

 *	SCSI dynamic Power Management

 *		Initial version: Alan Stern <stern@rowland.harvard.edu>

 Wait until async scanning is finished */

 CONFIG_PM_SLEEP */

 CONFIG_PM_SLEEP */

 Insert hooks here for targets, hosts, and transport classes */

 Insert hooks here for targets, hosts, and transport classes */

 Insert hooks here for targets, hosts, and transport classes */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Detection routine for the NCR53c710 based BVME6000 SCSI Controllers for Linux.

 *

 * Based on work by Alan Hourihane and Kars de Jong

 *

 * Rewritten to use 53c700.c by Richard Hirst <richard@sleepie.demon.co.uk>

 Fill in the required pieces of hostdata */

 XXX - depends on the CPU clock! */

 and register the chip */

/*

   3w-sas.c -- LSI 3ware SAS/SATA-RAID Controller device driver for Linux.



   Written By: Adam Radford <aradford@gmail.com>



   Copyright (C) 2009 LSI Corporation.



   This program is free software; you can redistribute it and/or modify

   it under the terms of the GNU General Public License as published by

   the Free Software Foundation; version 2 of the License.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   NO WARRANTY

   THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

   CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

   LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

   solely responsible for determining the appropriateness of using and

   distributing the Program and assumes all risks associated with its

   exercise of rights under this Agreement, including but not limited to

   the risks and costs of program errors, damage to or loss of data,

   programs or equipment, and unavailability or interruption of operations.



   DISCLAIMER OF LIABILITY

   NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

   DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

   USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

   HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES



   You should have received a copy of the GNU General Public License

   along with this program; if not, write to the Free Software

   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA



   Controllers supported by this driver:



   LSI 3ware 9750 6Gb/s SAS/SATA-RAID



   Bugs/Comments/Suggestions should be mailed to:

   aradford@gmail.com



   History

   -------

   3.26.02.000 - Initial driver release.

 Globals */

 Module parameters */

 Function prototypes */

 Functions */

 This function returns AENs through sysfs */

 End twl_sysfs_aen_read() */

 aen_read sysfs attribute initializer */

 This function returns driver compatibility info through sysfs */

 End twl_sysfs_compat_info() */

 compat_info sysfs attribute initializer */

 Show some statistics about the card */

 End twl_show_stats() */

 stats sysfs attribute initializer */

 Host attributes initializer */

 This function will look up an AEN severity string */

 End twl_aen_severity_lookup() */

 This function will queue an event */

 Fill out event info */

 event->time_stamp_sec overflows in y2106 */

 Check for embedded error string */

 End twl_aen_queue_event() */

 This function will attempt to post a command packet to the board */

 First write upper 4 bytes */

 Then the lower 4 bytes */

 End twl_post_command_packet() */

 This function hands scsi cdb's to the firmware */

 Initialize command packet */

 We forced 16 byte cdb use earlier */

 Map sglist from scsi layer to cmd packet */

 Internal cdb post */

 Update some stats */

 Now post the command to the board */

 End twl_scsiop_execute_scsi() */

 This function will read the aen queue from the isr */

 Initialize cdb */

 opcode */

 allocation length */

 Initialize sglist */

 Mark internal command */

 Now post the command packet */

 End twl_aen_read_queue() */

 This function will sync firmware time with the host time */

 Fill out the command packet */

 Setup the param */

 Controller time keep table */

 SchedulerTime */

	/* Convert system time in UTC to local time seconds since last

 Mark internal command */

 Now post the command */

 End twl_aen_sync_time() */

 This function will assign an available request id */

 End twl_get_request_id() */

 This function will free a request id */

 End twl_free_request_id() */

 This function will complete an aen request from the isr */

 First check for internal completion of set param for time sync */

 Keep reading the queue in case there are more aen's */

 Quit reading the queue if this is the last one */

 If there are more aen's, keep reading the queue */

 End twl_aen_complete() */

 This function will poll for a response */

 End twl_poll_response() */

 This function will drain the aen queue */

 Initialize cdb */

 opcode */

 allocation length */

 Initialize sglist */

 Mark internal command */

 Send command to the board */

 Now poll for completion */

 Now queue an event info */

 End twl_aen_drain_queue() */

 This function will allocate memory and check if it is correctly aligned */

 End twl_allocate_memory() */

 This function will load the request id and various sgls for ioctls */

 Load the sg list */

 End twl_load_sgl() */

/* This function handles ioctl for the character device

 Only let one of these through at a time */

 First copy down the driver command */

 Check data buffer size */

 Hardware can only do multiple of 512 byte transfers */

 Now allocate ioctl buf memory */

 Now copy down the entire ioctl */

 See which ioctl we are doing */

 Flag internal command */

 Flag chrdev ioctl */

 Load request id and sglist for both command types */

 Now post the command packet to the controller */

 Now wait for command to complete */

 We timed out, and didn't get an interrupt */

 Now we need to reset the board */

 Now copy in the command packet response */

 Now complete the io */

 Now copy the entire response to userspace */

 Now free ioctl buf memory */

 End twl_chrdev_ioctl() */

 This function handles open for the character device */

 End twl_chrdev_open() */

 File operations struct for character device */

 This function passes sense data from firmware to scsi layer */

 Get embedded firmware error string */

 Don't print error for Logical unit not supported during rollcall */

 End twl_fill_sense() */

 This function will free up device extension resources */

 End twl_free_device_extension() */

 This function will get parameter table entries from the firmware */

 Setup the command packet */

 Now setup the param */

 Post the command packet to the board */

 Poll for completion */

 End twl_get_param() */

 This function will send an initconnection command to controller */

 Initialize InitConnection command packet */

 Turn on 64-bit sgl support if we need to */

 Send command packet to the board */

 Poll for completion */

 End twl_initconnection() */

 This function will initialize the fields of a device extension */

 Initialize command packet buffers */

 Initialize generic buffer */

 Allocate sense buffers */

 Allocate event info space */

 End twl_initialize_device_extension() */

 This function will handle attention interrupts */

 Read doorbell status */

 Check for controller errors */

 Check if we need to perform an AEN drain */

 Clear doorbell interrupt */

 Make sure the clear was flushed by reading it back */

 End twl_handle_attention_interrupt() */

 Interrupt service routine */

 Read host interrupt status */

 Check if this is our interrupt, otherwise bail */

 If we are resetting, bail */

 Attention interrupt */

 Response interrupt */

 Check for command packet error */

 Skip ioctl error prints */

 Now re-post the sense buffer */

 Check for correct state */

 Check for internal command completion */

 Report residual bytes for single sgl */

 Now complete the io */

 Check for another response interrupt */

 End twl_interrupt() */

 This function will poll for a register change */

 End twl_poll_register() */

 This function will reset a controller */

 Do a soft reset if one is needed */

 Make sure controller is in a good state */

 Initconnect */

 Load sense buffers */

 Check status for over-run after each write */

 Now check status */

 Drain the AEN queue */

 Load rest of compatibility struct */

 If we got here, controller is in a good state */

 End twl_reset_sequence() */

 This function will reset a device extension */

 Block SCSI requests while we are resetting */

 Abort all requests that are in progress */

 Reset queues and counts */

 End twl_reset_device_extension() */

 This funciton returns unit geometry in cylinders/heads/sectors */

 cylinders */

 End twl_scsi_biosparam() */

 This is the new scsi eh reset function */

 Make sure we are not issuing an ioctl or resetting from ioctl */

 Now reset the card and some of the device extension data */

 End twl_scsi_eh_reset() */

 This is the main scsi queue function to handle scsi opcodes */

 If we are resetting due to timed out ioctl, report as busy */

 Get a free request id */

 Save the scsi command for use by the ISR */

 End twl_scsi_queue() */

 This function tells the controller to shut down */

 Disable interrupts */

 Free up the IRQ */

 Tell the card we are shutting down */

 Clear doorbell interrupt just before exit */

 End __twl_shutdown() */

 Wrapper for __twl_shutdown */

 End twl_shutdown() */

 This function configures unit settings when a unit is coming on-line */

 Force 60 second timeout */

 End twl_slave_configure() */

 scsi_host_template initializer */

 This function will probe and initialize a card */

 Save values to device extension */

 Request IO regions */

 Save base address, use region 1 */

 Disable interrupts on the card */

 Initialize the card */

 Set host specific parameters */

 Register the card with the kernel SCSI layer */

 Try to enable MSI */

 Now setup the interrupt handler */

 Re-enable interrupts on the card */

 Finally, scan the host */

 Add sysfs binary files */

 End twl_probe() */

 This function is called to remove a device */

 Remove sysfs binary files */

 Unregister character device */

 Shutdown the card */

 Disable MSI if enabled */

 Free IO remapping */

 Free up the mem region */

 Free up device extension resources */

 End twl_remove() */

 This function is called on PCI suspend */

 Disable interrupts */

 Tell the card we are shutting down */

 Clear doorbell interrupt */

 End twl_suspend() */

 This function is called on PCI resume */

 Initialize the card */

 Now setup the interrupt handler */

 Now enable MSI if enabled */

 Re-enable interrupts on the card */

 End twl_resume() */

 PCI Devices supported by this driver */

 pci_driver initializer */

 This function is called on driver initialization */

 End twl_init() */

 This function is called on driver exit */

 End twl_exit() */

 SPDX-License-Identifier: GPL-2.0-only

/* esp_scsi.c: ESP SCSI driver.

 *

 * Copyright (C) 2007 David S. Miller (davem@davemloft.net)

 SCSI bus reset settle time in seconds.  */

 Reset the ESP chip, _not_ the SCSI bus. */

 Now reset the ESP chip */

	/* This is the only point at which it is reliable to read

	 * the ID-code for a fast ESP chip variants.

 Version is usually '5'. */

 Enable Active Negation */

		/*

		 * The AM53c974 chip returns the same ID as FAS236;

		 * try to configure glitch eater.

 nothing to do */

 Slow 236 */

 Fast 100a */

 Reload the configuration registers */

 Eat any bitrot in the chip */

		/*

		 * For pseudo DMA and PIO we need the virtual address instead of

		 * a dma address, so perform an identity mapping.

 Arbitrary segment boundaries, 24-bit counts.  */

		/* ESP chip limits other variants by 16-bits of transfer

		 * count.  Actually on FAS100A and FAS236 we could get

		 * 24-bits of transfer count by enabling ESP_CONFIG2_FENAB

		 * in the ESP_CFG2 register but that causes other unwanted

		 * changes so we don't use it currently.

		/* All of the DMA variants hooked up to these chips

		 * cannot handle crossing a 24-bit address boundary.

 When offset is zero, period is "don't care".  */

 Non-tagged, slot already taken?  */

			/* We are being held by active tagged

			 * commands.

			/* Tagged commands completed, we can unplug

			 * the queue and run this untagged command.

			/* Plug the queue until num_tagged decreases

			 * to zero in esp_free_lun_tag.

 Tagged command. Check that it isn't blocked by a non-tagged one. */

/* When a contingent allegiance condition is created, we force feed a

 * REQUEST_SENSE command to the device to fetch the sense data.  I

 * tried many other schemes, relying on the scsi error handling layer

 * to send out the REQUEST_SENSE automatically, but this was difficult

 * to get right especially in the presence of applications like smartd

 * which use SG_IO to send out their own REQUEST_SENSE commands.

		/* Need to negotiate.  If the target is broken

		 * go for synchronous transfers and non-wide.

 If the settings are not changing, skip this.  */

 If there are multiple message bytes, use Select and Stop */

		/* ESP100 lacks select w/atn3 command, use select

		 * and stop instead.

		/* Restore the message/status bytes to what we actually

		 * saw originally.  Also, report that we are providing

		 * the sense data.

		/* Gross Error, could be one of:

		 * - top of fifo overwritten

		 * - top of command register overwritten

		 * - DMA programmed with wrong direction

		 * - improper phase change

 XXX Reset the chip. XXX */

		/* The interrupt pending bit of the status register cannot

		 * be trusted on these revisions.

			/* If the DMA is indicating interrupt pending and the

			 * ESP is not, the only possibility is a DMA error.

 XXX Reset the chip. XXX */

/* In order to avoid having to add a special half-reconnected state

 * into the driver we just sit here and poll through the rest of

 * the reselection process to get the tag message bytes.

 DMA in the tag bytes... */

 ACK the message.  */

		/* FASHME puts the target and lun numbers directly

		 * into the fifo.

		/* Older chips put the lun directly into the fifo, but

		 * the target is given as a sample of the arbitration

		 * lines on the bus at reselection time.  So we should

		 * see the ID of the ESP and the one reconnecting target

		 * set in the bitmap.

			/* This chip has a bug during reselection that can

			 * cause a spurious illegal-command interrupt, which

			 * we simply ACK here.  Another possibility is a bus

			 * reset so we must check for that.

 No longer selecting.  */

		/* If we see a DMA error during or as a result of selection,

		 * all bets are off.

		/* Carefully back out of the selection attempt.  Release

		 * resources (such as DMA mapping & TAG) and reset state (such

		 * as message out and command delivery variables).

		/* Now that the state is unwound properly, put back onto

		 * the issue queue.  This command is no longer active.

		/* Return value ignored by caller, it directly invokes

		 * esp_reconnect().

		/* Disconnect.  Make sure we re-negotiate sync and

		 * wide parameters if this target starts responding

		 * again in the future.

		/* Selection successful.  On pre-FAST chips we have

		 * to do a NOP and possibly clean out the FIFO.

		/* If we are doing a Select And Stop command, negotiation, etc.

		 * we'll do the right thing as we transition to the next phase.

	/*

	 * The am53c974 has a DMA 'peculiarity'. The doc states:

	 * In some odd byte conditions, one residual byte will

	 * be left in the SCSI FIFO, and the FIFO Flags will

	 * never count to '0 '. When this happens, the residual

	 * byte should be retrieved via PIO following completion

	 * of the BLAST operation.

 Synchronous data transfer, always flush fifo. */

			/* ESP100 has a chip bug where in the synchronous data

			 * phase it can mistake a final long REQ pulse from the

			 * target as an extra data byte.  Fun.

			 *

			 * To detect this case we resample the status register

			 * and fifo flags.  If we're still in a data phase and

			 * we see spurious chunks in the fifo, we return error

			 * to the caller which should reset and set things up

			 * such that we only try future transfers to this

			 * target in synchronous mode.

/* Analyze msgin bytes received from target so far.  Return non-zero

 * if there are more bytes needed to complete the message.

 Identify */

 XXX parity errors, etc. XXX */

			/* We should always see exactly a bus-service

			 * interrupt at the end of a successful transfer.

 XXX force sync mode for this target XXX */

 Always use the fifo.  */

 Use DMA. */

			/* XXX if the chip went into disconnected mode,

			 * we can't run the phase state machine anyway.

 Check whether a bus reset is to be done next */

 Force renegotiation of sync/wide transfers.  */

 Runs under host->lock */

       /*

	* Once INTRPT is read STATUS and SSTEP are cleared.

 Some combination of FDONE, BSERV, DC. */

			/*

			 * If what we write to cfg2 does not come back,

			 * cfg2 is not implemented.

			 * Therefore this must be a plain esp100.

		/* The cfg2 register is implemented, however

		 * cfg3 is not, must be esp100a.

		/* All of cfg{1,2,3} implemented, must be one of

		 * the fas variants, figure out which one.

	/* Start with a clear state, domain validation (via ->slave_configure,

	 * spi_dv_device()) will attempt to enable SYNC, WIDE, and tagged

	 * commands.

 This places the ESP into a known state at boot time. */

 Reset the DMA */

 Reset the ESP */

 Reset the SCSI bus, but tell ESP not to generate an irq */

 Eat any bitrot in the chip and we are done... */

	/* This is getting messy but it has to be done correctly or else

	 * you get weird behavior all over the place.  We are trying to

	 * basically figure out three pieces of information.

	 *

	 * a) Clock Conversion Factor

	 *

	 *    This is a representation of the input crystal clock frequency

	 *    going into the ESP on this machine.  Any operation whose timing

	 *    is longer than 400ns depends on this value being correct.  For

	 *    example, you'll get blips for arbitration/selection during high

	 *    load or with multiple targets if this is not set correctly.

	 *

	 * b) Selection Time-Out

	 *

	 *    The ESP isn't very bright and will arbitrate for the bus and try

	 *    to select a target forever if you let it.  This value tells the

	 *    ESP when it has taken too long to negotiate and that it should

	 *    interrupt the CPU so we can see what happened.  The value is

	 *    computed as follows (from NCR/Symbios chip docs).

	 *

	 *          (Time Out Period) *  (Input Clock)

	 *    STO = ----------------------------------

	 *          (8192) * (Clock Conversion Factor)

	 *

	 *    We use a time out period of 250ms (ESP_BUS_TIMEOUT).

	 *

	 * c) Imperical constants for synchronous offset and transfer period

         *    register values

	 *

	 *    This entails the smallest and largest sync period we could ever

	 *    handle on this ESP.

	/* If we can't find anything reasonable, just assume 20MHZ.

	 * This is the clock frequency of the older sun4c's where I've

	 * been unable to find the clock-frequency PROM property.  All

	 * other machines provide useful values it seems.

 Let the SCSI bus reset settle. */

	/* XXX This helps a lot with debugging but might be a bit

	 * XXX much for the final driver.

		/* Easiest case, we didn't even issue the command

		 * yet so it is trivial to abort.

		/* Command is the currently active command on

		 * the bus.  If we already have an output message

		 * pending, no dice.

		/* Send out an abort, encouraging the target to

		 * go to MSGOUT phase by asserting ATN.

		/* The command is disconnected.  This is not easy to

		 * abort.  For now we fail and let the scsi error

		 * handling layer go try a scsi bus reset or host

		 * reset.

		 *

		 * What we could do is put together a scsi command

		 * solely for the purpose of sending an abort message

		 * to the target.  Coming up with all the code to

		 * cook up scsi commands, special case them everywhere,

		 * etc. is for questionable gain and it would be better

		 * if the generic scsi error handling layer could do at

		 * least some of that for us.

		 *

		 * Anyways this is an area for potential future improvement

		 * in this driver.

	/* XXX This might be a good location to set ESP_TGT_BROKEN

	 * XXX since we know which target/lun in particular is

	 * XXX causing trouble.

	/* XXX This is too simple... We should add lots of

	 * XXX checks here so that if we find that the chip is

	 * XXX very wedged we return failure immediately so

	 * XXX that we can perform a full chip reset.

 All bets are off, reset the entire device.  */

 SPDX-License-Identifier: GPL-2.0

/* This driver works *ONLY* for Future Domain cards using the TMC-1800,

 * TMC-18C50, or TMC-18C30 chip.  This includes models TMC-1650, 1660, 1670,

 * and 1680. These are all 16-bit cards.

 * BIOS versions prior to 3.2 assigned SCSI ID 6 to SCSI adapter.

 *

 * The following BIOS signature signatures are for boards which do *NOT*

 * work with this driver (these TMC-8xx and TMC-9xx boards may work with the

 * Seagate driver):

 *

 * FUTURE DOMAIN CORP. (C) 1986-1988 V4.0I 03/16/88

 * FUTURE DOMAIN CORP. (C) 1986-1989 V5.0C2/14/89

 * FUTURE DOMAIN CORP. (C) 1986-1989 V6.0A7/28/89

 * FUTURE DOMAIN CORP. (C) 1986-1990 V6.0105/31/90

 * FUTURE DOMAIN CORP. (C) 1986-1990 V6.0209/18/90

 * FUTURE DOMAIN CORP. (C) 1986-1990 V7.009/18/90

 * FUTURE DOMAIN CORP. (C) 1992 V8.00.004/02/92

 *

 * (The cards which do *NOT* work are all 8-bit cards -- although some of

 * them have a 16-bit form-factor, the upper 8-bits are used only for IRQs

 * and are *NOT* used for data. You can tell the difference by following

 * the tracings on the circuit board -- if only the IRQ lines are involved,

 * you have a "8-bit" card, and should *NOT* use this driver.)

          1         2         3         4         5         6 */

 123456789012345678901234567890123456789012345678901234567890 */

 scan supported ISA BIOS addresses */

 no signature found */

 read I/O base from BIOS area */

 no I/O base in BIOS area */

 save BIOS signature for later use in port probing */

 scan supported I/O ports */

 use saved BIOS signature if present */

 use module parameters if present */

/*

 * dc395x.c

 *

 * Device Driver for Tekram DC395(U/UW/F), DC315(U)

 * PCI SCSI Bus Master Host Adapter

 * (SCSI chip set used Tekram ASIC TRM-S1040)

 *

 * Authors:

 *  C.L. Huang <ching@tekram.com.tw>

 *  Erich Chen <erich@tekram.com.tw>

 *  (C) Copyright 1995-1999 Tekram Technology Co., Ltd.

 *

 *  Kurt Garloff <garloff@suse.de>

 *  (C) 1999-2000 Kurt Garloff

 *

 *  Oliver Neukum <oliver@neukum.name>

 *  Ali Akcaagac <aliakc@web.de>

 *  Jamie Lenehan <lenehan@twibble.org>

 *  (C) 2003

 *

 * License: GNU GPL

 *

 *************************************************************************

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions

 * are met:

 * 1. Redistributions of source code must retain the above copyright

 *    notice, this list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright

 *    notice, this list of conditions and the following disclaimer in the

 *    documentation and/or other materials provided with the distribution.

 * 3. The name of the author may not be used to endorse or promote products

 *    derived from this software without specific prior written permission.

 *

 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR

 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES

 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.

 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,

 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT

 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,

 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY

 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF

 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 ************************************************************************

/*---------------------------------------------------------------------------

                                  Features

/*

 * Set to disable parts of the driver

#define DC395x_NO_DISCONNECT*/

#define DC395x_NO_TAGQ*/

#define DC395x_NO_SYNC*/

#define DC395x_NO_WIDE*/

/*---------------------------------------------------------------------------

                                  Debugging

/*

 * Types of debugging that can be enabled and disabled

/*

 * Set set of things to output debugging for.

 * Undefine to remove all debugging

#define DEBUG_MASK (DBG_0|DBG_1|DBG_SG|DBG_FIFO|DBG_PIO)*/

#define  DEBUG_MASK	DBG_0*/

/*

 * Output a kernel mesage at the specified level and append the

 * driver name and a ": " to the start of the message

/*

 * print a debug message - this is formated with KERN_DEBUG, then the

 * driver name followed by a ": " and then the message is output. 

 * This also checks that the specified debug level is enabled before

 * outputing the message

/*

 * Check if the specified type of debugging is enabled

/*

 * No debugging. Do nothing

 Vendor ID    */

 Device ID    */

/*

 * srb->segement_x is the hw sg list. It is always allocated as a

 * DC395x_MAX_SG_LISTENTRY entries in a linear block which does not

 * cross a page boundy.

 bus! address */

 The SEEPROM structure for TRM_S1040 */

 Target configuration byte 0  */

 Target period                */

 Target configuration byte 2  */

 Target configuration byte 3  */

 0,1  Sub Vendor ID   */

 2,3  Sub System ID   */

 4    Sub Class       */

 5,6  Vendor ID       */

 7,8  Device ID       */

 9    Reserved        */

						/** 10,11,12,13

						 ** 14,15,16,17

						 ** ....

						 ** ....

						 ** 70,71,72,73

 74 Host Adapter SCSI ID      */

 75 Channel configuration     */

 76 Power on delay time       */

 77 Maximum tags              */

 78  */

 79  */

 80  */

 81  */

 82,..125 */

 126,127 */

 next/prev ptrs for srb lists */

 Linear array of hw sg entries (up to 64 entries) */

 Bus address of sg list (ie, of segment_x) */

 No of HW sg entries for this request */

 Index of HW sg entry for this request */

 Total number of bytes remaining to be transferred */

 Total number of bytes in this request */

	/*

	 * The sense buffer handling function, request_sense, uses

	 * the first hw sg entry (segment_x[0]) and the transfer

	 * length (total_xfer_length). While doing this it stores the

	 * original values into the last sg hw list

	 * (srb->segment_x[DC395x_MAX_SG_LISTENTRY - 1] and the

	 * total_xfer_length in xferred. These values are restored in

	 * pci_unmap_srb_sense. This is the only place xferred is used.

 Saved copy of total_xfer_length */

 next/prev ptrs for the dcb list */

 head of going srb list */

 head of waiting srb list */

 SCSI Target ID  (SCSI Only) */

 SCSI Log.  Unit (SCSI Only) */

 To store Inquiry flags */

 0:async mode */

 for nego. */

 for reg.  */

 for reg. and nego.(low nibble) */

 head of going dcb list */

 head of free srb list */

 eeprom settings for this adapter */

/*---------------------------------------------------------------------------

                            Forward declarations

/*---------------------------------------------------------------------------

                                 Static Data

 phase:0 */

 phase:1 */

 phase:2 */

 phase:3 */

 phase:4 PH_BUS_FREE .. initial phase */

 phase:5 PH_BUS_FREE .. initial phase */

 phase:6 */

 phase:7 */

 phase:0 */

 phase:1 */

 phase:2 */

 phase:3 */

 phase:4 PH_BUS_FREE .. initial phase */

 phase:5 PH_BUS_FREE .. initial phase */

 phase:6 */

 phase:7 */

/*

 *Fast20:	000	 50ns, 20.0 MHz

 *		001	 75ns, 13.3 MHz

 *		010	100ns, 10.0 MHz

 *		011	125ns,  8.0 MHz

 *		100	150ns,  6.6 MHz

 *		101	175ns,  5.7 MHz

 *		110	200ns,  5.0 MHz

 *		111	250ns,  4.0 MHz

 *

 *Fast40(LVDS):	000	 25ns, 40.0 MHz

 *		001	 50ns, 20.0 MHz

 *		010	 75ns, 13.3 MHz

 *		011	100ns, 10.0 MHz

 *		100	125ns,  8.0 MHz

 *		101	150ns,  6.6 MHz

 *		110	175ns,  5.7 MHz

 *		111	200ns,  5.0 MHz

static u8	clock_period[] = {12,19,25,31,37,44,50,62};*/

 real period:48ns,76ns,100ns,124ns,148ns,176ns,200ns,248ns */

/*---------------------------------------------------------------------------

                                Configuration

/*

 * Module/boot parameters currently effect *all* instances of the

 * card in the system.

/*

 * Command line parameters are stored in a structure below.

 * These are the index's into the structure for the various

 * command line options.

 number of configuration items */

/*

 * Value used to indicate that a command line override

 * hasn't been used to modify the value.

/*

 * Hold command line parameters.

 value of this setting */

 minimum value */

 maximum value */

 default value */

 safe value */

 adapter id */

 max speed */

 13.3Mhz */

  6.7Hmz */

 dev mode */

 adapter mode */

| NAC_ACTIVE_NEG*/,

 tags */

 16 tags (??) */

 reset delay */

 1 second */

 10 seconds */

/*

 * Safe settings. If set to zero the BIOS/default values with

 * command line overrides will be used. If set to 1 then safe and

 * slow settings will be used.

/**

 * set_safe_settings - if the use_safe_settings option is set then

 * set all values to the safe and slow values.

/**

 * fix_settings - reset any boot parameters which are out of range

 * back to the default values.

/*

 * Mapping from the eeprom delay index value (index into this array)

 * to the number of actual seconds that the delay should be for.

/**

 * eeprom_index_to_delay - Take the eeprom delay setting and convert it

 * into a number of seconds.

 *

 * @eeprom: The eeprom structure in which we find the delay index to map.

/**

 * delay_to_eeprom_index - Take a delay in seconds and return the

 * closest eeprom index which will delay for at least that amount of

 * seconds.

 *

 * @delay: The delay, in seconds, to find the eeprom index for.

/**

 * eeprom_override - Override the eeprom settings, in the provided

 * eeprom structure, with values that have been set on the command

 * line.

 *

 * @eeprom: The eeprom data to override with command line options.

 Adapter Settings */

 Device Settings */

/*---------------------------------------------------------------------------

 find supplied dcb and then select the next one */

 if no next one take the head one (ie, wraparound) */

 free tag mask */

 Find cmd in SRB list */

 Sets the timer to wake us up */

 Send the next command from the waiting list to the bus */

	/*

	 * Find the starting dcb. Need to find it again in the list

	 * since the list may have changed since we set the ptr to it

 This can happen! */

	/*

	 * Loop over the dcb, but we start somewhere (potentially) in

	 * the middle of the loop so we need to manully do this.

 Make sure, the next another device gets scheduled ... */

 move to next dcb */

 Try to send to the bus */

 Wake up waiting queue */

 Get the DCB for a given ID/LUN combination */

 Send SCSI Request Block (srb) to adapter (acb) */

 Prepare SRB for being sent to Device DCB w/ command *cmd */

 initial phase */

		/*

		 * adjust last page if too big as it is allocated

		 * on even page boundaries

 Fixup for WIDE padding - make sure length is even */

/**

 * dc395x_queue_command_lck - queue scsi command passed from the mid

 * layer, invoke 'done' on completion

 *

 * @cmd: pointer to scsi command object

 * @done: function pointer to be invoked on completion

 *

 * Returns 1 if the adapter (host) is busy, else returns 0. One

 * reason for an adapter to be busy is that the number

 * of outstanding queued commands is already equal to

 * struct Scsi_Host::can_queue .

 *

 * Required: if struct Scsi_Host::can_queue is ever non-zero

 *           then this function is required.

 *

 * Locks: struct Scsi_Host::host_lock held on entry (with "irqsave")

 *        and is expected to be held on return.

 *

 Assume BAD_TARGET; will be cleared later */

 ignore invalid targets */

 does the specified lun on the specified device exist */

 do we have a DCB for the device */

 should never happen */

		/*

		 * Return 1 since we are unable to queue this command at this

		 * point in time.

 append to waiting queue */

 process immediately */

	/*

	 * Complete the command immediatey, and then return 0 to

	 * indicate that we have handled the command. This is usually

	 * done when the commad is for things like non existent

	 * devices.

/*

 * perform a hard reset on the SCSI bus

 * @cmd - some command for this host (for fetching hooks)

 * Returns: SUCCESS (0x2002) on success, else FAILED (0x2003).

	/*

	 * disable interrupt    

 We may be in serious trouble. Wait some seconds */

	/*

	 * re-enable interrupt      

 Clear SCSI FIFO          */

 Delete pending IRQ */

 RESET_DETECT, RESET_DONE ,RESET_DEV */

/*

 * abort an errant SCSI command

 * @cmd - command to be aborted

 * Returns: SUCCESS (0x2002) on success, else FAILED (0x2003).

	/*

	 * Look into our command queues: If it has not been sent already,

	 * we remove it and return success. Otherwise fail.

 XXX: Should abort the command here */

 SDTR */

 WDTR */

/* Timer to work around chip flaw: When selecting and the bus is 

 Sets the timer to wake us up */

 acb->tag_max_num: had error read in eeprom */

 s_stat2 & 0x02000 */ ) {

		/*

		 * Try anyway?

		 *

		 * We could, BUT: Sometimes the TRM_S1040 misses to produce a Selection

		 * Timeout, a Disconnect or a Reselection IRQ, so we would be screwed!

		 * (This is likely to be a bug in the hardware. Obviously, most people

		 *  only have one initiator per SCSI bus.)

		 * Instead let this fail and have the timer make sure the command is 

		 * tried again after a short time

selto_timer (acb); */

	/* Allow starting of SCSI commands half a second before we allow the mid-level

 Flush FIFO */

 initial phase */

DC395x_TRM_write8(TRM_S1040_SCSI_IDMSG, identify_message); */

 Don't allow disconnection for AUTO_REQSENSE: Cont.All.Cond.! */

 Send identify message */

 Send Tag message */

 Send Tag id */

polling:*/

 Send CDB ..command block ......... */

		/* 

		 * If start_scsi return 1:

		 * we caught an interrupt (must be reset or reselection ... )

		 * : Let's process it first!

 This IRQ should NOT get lost, as we did not acknowledge it */

		/* 

		 * If start_scsi returns 0:

		 * we know that the SCSI processor is free

 initial phase */

 it's important for atn stop */

 SCSI command */

 abort command */

/**

 * dc395x_handle_interrupt - Handle an interrupt that has been confirmed to

 *                           have been triggered for this card.

 *

 * @acb:	 a pointer to the adpter control block

 * @scsi_status: the status return when we checked the card

 This acknowledges the IRQ */

dprintkl(KERN_DEBUG, "handle_interrupt: intstatus = 0x%02x ", scsi_intstatus); */

 bus free interrupt  */

 software sequential machine */

		/* 

		 * 62037 or 62137

		 * call  dc395x_scsi_phase0[]... "phase entry"

		 * handle every phase before start transfer

 data_out_phase0,	phase:0 */

 data_in_phase0,	phase:1 */

 command_phase0,	phase:2 */

 status_phase0,	phase:3 */

 nop0,		phase:4 PH_BUS_FREE .. initial phase */

 nop0,		phase:5 PH_BUS_FREE .. initial phase */

 msgout_phase0,	phase:6 */

 msgin_phase0,	phase:7 */

		/* 

		 * if there were any exception occurred scsi_status

		 * will be modify to bus free phase new scsi_status

		 * transfer out from ... previous dc395x_statev

		/* 

		 * call  dc395x_scsi_phase1[]... "phase entry" handle

		 * every phase to do transfer

 data_out_phase1,	phase:0 */

 data_in_phase1,	phase:1 */

 command_phase1,	phase:2 */

 status_phase1,	phase:3 */

 nop1,		phase:4 PH_BUS_FREE .. initial phase */

 nop1,		phase:5 PH_BUS_FREE .. initial phase */

 msgout_phase1,	phase:6 */

 msgin_phase1,	phase:7 */

	/*

	 * Check for pending interrupt

 interrupt pending - let's process it! */

 Error from the DMA engine */

.. initial phase */

 it's important for atn stop */

 So what ? */

 it's important for atn stop */

 target id */

 it's important for atn stop */

 SCSI command */

/*

 * Verify that the remaining space in the hw sg lists is the same as

 * the count of remaining bytes in srb->total_xfer_length

/*

 * Compute the next Scatter Gather list index and adjust its length

 * and address if necessary

 bytes transferred */

 nothing to update since we did not transfer any data */

 update remaining count */

 Complete SG entries done */

 Partial SG entry done */

/*

 * We have transferred a single byte (PIO mode?) and need to update

 * the count of bytes remaining (total_xfer_length) and update the sg

 * entry to either point to next byte in the current sg entry, or of

 * already at the end to point to the start of the next sg entry

/* 

 * cleanup_after_transfer

 * 

 * Makes sure, DMA and SCSI engine are empty, after the transfer has finished

 * KG: Currently called from  StatusPhase1 ()

 * Should probably also be called from other places

 * Best might be to call it in DataXXPhase0, if new phase will differ 

DC395x_write8 (TRM_S1040_DMA_STATUS, FORCEDMACOMP); */

 read */

 write */

/*

 * Those no of bytes will be transferred w/ PIO through the SCSI FIFO

 * Seems to be needed for unknown reasons; could be a hardware bug :-(

	/*

	 * KG: We need to drain the buffers before we draw any conclusions!

	 * This means telling the DMA to push the rest into SCSI, telling

	 * SCSI to push the rest to the bus.

	 * However, the device might have been the one to stop us (phase

	 * change), and the data in transit just needs to be accounted so

	 * it can be retransmitted.)

	/* 

	 * KG: Stop DMA engine pushing more data into the SCSI FIFO

	 * If we need more data, the DMA SG list will be freshly set up, anyway

		/*

		 * KG: Right, we can't just rely on the SCSI_COUNTER, because this

		 * is the no of bytes it got from the DMA engine not the no it 

		 * transferred successfully to the device. (And the difference could

		 * be as much as the FIFO size, I guess ...)

			/*

			 * when data transfer from DMA FIFO to SCSI FIFO

			 * if there was some data left in SCSI FIFO

		/*

		 * calculate all the residue data that not yet tranfered

		 * SCSI transfer counter + left in SCSI FIFO data

		 *

		 * .....TRM_S1040_SCSI_COUNTER (24bits)

		 * The counter always decrement by one for every SCSI byte transfer.

		 * .....TRM_S1040_SCSI_FIFOCNT ( 5bits)

		 * The counter is SCSI FIFO offset counter (in units of bytes or! words)

 Is this a good idea? */

clear_fifo(acb, "DOP1"); */

 KG: What is this supposed to be useful for? WIDE padding stuff? */

		/*

		 * KG: Oops again. Same thinko as above: The SCSI might have been

		 * faster than the DMA engine, so that it ran out of data.

		 * In that case, we have to do just nothing! 

		 * But: Why the interrupt: No phase change. No XFERCNT_2_ZERO. Or?

		/*

		 * KG: This is nonsense: We have been WRITING data to the bus

		 * If the SCSI engine has no bytes left, how should the DMA engine?

			/*

			 * if transfer not yet complete

			 * there were some data residue in SCSI FIFO or

			 * SCSI transfer counter not empty

 KG: Most ugly hack! Apparently, this works around a chip bug */

srb->total_xfer_length -= diff; */

srb->virt_addr += diff; */

if (srb->cmd->use_sg) */

      srb->sg_index++; */

 do prepare before transfer when data out phase */

	/*

	 * KG: DataIn is much more tricky than DataOut. When the device is finished

	 * and switches to another phase, the SCSI engine should be finished too.

	 * But: There might still be bytes left in its FIFO to be fetched by the DMA

	 * engine and transferred to memory.

	 * We should wait for the FIFOs to be emptied by that (is there any way to 

	 * enforce this?) and then stop the DMA engine, because it might think, that

	 * there are more bytes to follow. Yes, the device might disconnect prior to

	 * having all bytes transferred! 

	 * Also we should make sure that all data from the DMA engine buffer's really

	 * made its way to the system memory! Some documentation on this would not

	 * seem to be a bad idea, actually.

		/*

		 * KG: We should wait for the DMA FIFO to be empty ...

		 * but: it would be better to wait first for the SCSI FIFO and then the

		 * the DMA FIFO to become empty? How do we know, that the device not already

		 * sent data to the FIFO in a MsgIn phase, eg.?

DC395x_write8  (TRM_S1040_DMA_CONTROL, STOPDMAXFER); */

DC395x_write32 (TRM_S1040_SCSI_COUNTER, 7); */

DC395x_write8  (TRM_S1040_SCSI_COMMAND, SCMD_DMA_IN); */

DC395x_write32 (TRM_S1040_SCSI_COUNTER, 0); */

 Now: Check remainig data: The SCSI counters should tell us ... */

 KG: Less than or equal to 4 bytes can not be transferred via DMA, it seems. */

u32 addr = (srb->segment_x[srb->sg_index].address); */

sg_update_list (srb, d_left_counter); */

				/* Assumption: it's inside one page as it's at most 4 bytes and

 Read the last byte ... */

printk(" %08x", *(u32*)(bus_to_virt (addr))); */

srb->total_xfer_length = 0; */

 DC395x_LASTPIO */

		/*

		 * KG: This was in DATAOUT. Does it also belong here?

		 * Nobody seems to know what counter and fifo_cnt count exactly ...

			/*

			 * when data transfer from DMA FIFO to SCSI FIFO

			 * if there was some data left in SCSI FIFO

			/*

			 * if WIDE scsi SCSI FIFOCNT unit is word !!!

			 * so need to *= 2

			 * KG: Seems to be correct ...

 KG: This should not be needed any more! */

 phase changed */

			/*

			 * parsing the case:

			 * when a transfer not yet complete 

			 * but be disconnected by target

			 * if transfer not yet complete

			 * there were some data residue in SCSI FIFO or

			 * SCSI transfer counter not empty

 KG: The target may decide to disconnect: Empty FIFO before! */

 can't happen? out of bounds error */

		/*

		 * KG: What should we do: Use SCSI Cmd 0x90/0x92?

		 * Maybe, even ABORTXFER would be appropriate

 clear_fifo(acb, "IO"); */

		/* 

		 * load what physical address of Scatter/Gather list table

		 * want to be transfer

 with S/G */

 load how many bytes in the sg list table */

 without S/G */

 load total transfer length (24bits) max value 16Mbyte */

 it's important for atn stop */

 read */

 The last four bytes: Do PIO */

		/* 

		 * load what physical address of Scatter/Gather list table

		 * want to be transfer

 load total transfer length (24bits) max value 16Mbyte */

 it's important for atn stop */

 read */

 write */

 Again, max 4 bytes */

DC395x_write32(acb, TRM_S1040_SCSI_COUNTER, ln); */

 DC395x_LASTPIO */

 xfer pad */

		/*

		 * KG: despite the fact that we are using 16 bits I/O ops

		 * the SCSI FIFO is only 8 bits according to the docs

		 * (we can set bit 1 in 0x8f to serialize FIFO access ...)

				/* Danger, Robinson: If you find KGs

				 * scattered over the wide disk, the driver

			/* Danger, Robinson: If you find a collection of Ks on your disk

 it's important for atn stop */

 SCSI command */

 get message */

.. initial phase */

 it's important for atn stop */

 it's important for atn stop */

 Check if the message is complete */

 two byte messages */

 reject_msg */

srb->state = SRB_ABORT_SENT; */

 How can we make the DORS happy? */

 set async transfer mode */

dcb->sync_period &= 0; */

 200ns <=> 5 MHz */

 set sync transfer mode */

 Reply with corrected SDTR Message */

 Completed */

dcb->sync_mode &= ~(WIDE_NEGO_ENABLE+WIDE_NEGO_DONE); */

/*

 * extended message codes:

 *

 *	code	description

 *

 *	02h	Reserved

 *	00h	MODIFY DATA  POINTER

 *	01h	SYNCHRONOUS DATA TRANSFER REQUEST

 *	03h	WIDE DATA TRANSFER REQUEST

 *   04h - 7Fh	Reserved

 *   80h - FFh	Vendor specific

 Now eval the msg */

 A sync nego message was rejected ! */

 A wide nego message was rejected ! */

srb->state |= SRB_ABORT_SENT */

 SDTR */

 WDTR */

 sanity check ... */

 Discard  wide residual */

 nothing has to be done */

			/*

			 * SAVE POINTER may be ignored as we have the struct

			 * ScsiReqBlk* associated with the scsi command.

 reject unknown messages */

break; */

 Clear counter and MsgIn state */

 it's important ... you know! */

 it's important for atn stop */

 SCSI command */

 set all lun device's  period, offset */

 Suspend queue for a while */

 initial phase */

			/*

			 * Selection time out 

			 * SRB_START_ || SRB_MSGOUT || (!SRB_DISCONNECT && !SRB_COMPLETED)

 Unexp. Disc / Sel Timeout */

 Normal selection timeout */

			/*

			 * SRB_DISCONNECT (This is what we expect!)

 It could come from another initiator, therefore don't do much ! */

			/*

			 ** SRB_COMPLETED

DC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_HWRESELECT | DO_DATALATCH); */

 Read Reselected Target ID and LUN */

 Arbitration lost but Reselection win */

 it's important for atn stop */

 Why the if ? */

srb->state |= SRB_DISCONNECT; */

 return; */

 Read Reselected Target Id and LUN */

 it's important for atn stop */

 There can be only one! */

			/*

			 * abort command

srb->state = SRB_ABORT_SENT; */

 initial phase */

 Program HA ID, target ID, period and offset */

 host   ID */

 target ID */

 offset    */

 sync period, wide */

 it's important for atn stop */

 SCSI command */

 Check for SCSI format (ANSI and Response data format) */

(dcb->dev_mode & NTC_DO_DISCONNECT) */

		    /* ((dcb->dev_type == TYPE_DISK) 

dcb->tag_mask = 0; */

 if (bval1 == TYPE_DISK || bval1 == TYPE_MOD) */

 unmap mapped pci regions from SRB */

 unmap DC395x SG list */

 unmap the sg segments */

 unmap mapped pci sense buffer from SRB */

 Unmap sense buffer */

 Restore SG stuff */

/*

 * Complete execution of a SCSI command

 * Signal completion to the generic SCSI driver  

		/*

		 ** target status..........................

************************************************************/

		/*

		 * target status..........................

		/*

		 ** process initiator status..........................

 No error */

 Check Error Conditions */

if( srb->cmd->cmnd[0] == INQUIRY && */

  (host_byte(cmd->result) == DID_OK || status_byte(cmd->result) & CHECK_CONDITION) ) */

 Here is the info for Doug Gilbert's sg3 ... */

 This may be interpreted by sb. or not ... */

 Add to free list */

 abort all cmds in our queues */

				/* For new EH, we normally don't need to give commands back,

 Waiting queue */

				/* For new EH, we normally don't need to give commands back,

 RESET_DETECT, RESET_DONE, RESET_DEV */

 nothing */;

 program configuration 1: Act_Neg (+ Act_Neg_Enh? + Fast_Filter? + DataDis?) */

 was 0x13: default */

 program Host ID                  */

 set ansynchronous transfer       */

 Turn LED control off */

 DMA config          */

| DMA_MEM_MULTI_READ */ ;

 Clear pending interrupt status */

 Enable SCSI interrupt    */

| EN_DMAXFERABORT | EN_DMAXFERCOMP | EN_FORCEDMACOMP */

 delay half a second */

DC395x_write8(acb, TRM_S1040_DMA_CONTROL,STOPDMAXFER); */

 Maybe we locked up the bus? Then lets wait even longer ... */

1.25 */

DC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_HWRESELECT); */

 RESET_DETECT, RESET_DONE, RESET_DEV */

DC395x_RecoverSRB( acb ); */

 KG: Can this prevent crap sense data ? */

 Save some data */

 srb->segment_x : a one entry of S/G list table */

 Map sense buffer */

 Should only happen, if sb. else grabs the bus */

/**

 * device_alloc - Allocate a new device instance. This create the

 * devices instance and sets up all the data items. The adapter

 * instance is required to obtain confiuration information for this

 * device. This does *not* add this device to the adapters device

 * list.

 *

 * @acb: The adapter to obtain configuration information from.

 * @target: The target for the new device.

 * @lun: The lun for the new device.

 *

 * Return the new device if successful or NULL on failure.

 Copy settings */

/**

 * adapter_add_device - Adds the device instance to the adaptor instance.

 *

 * @acb: The adapter device to be updated

 * @dcb: A newly created and initialised device instance to add.

 backpointer to adapter */

 set run_robin to this device if it is currently empty */

 add device to list */

 update device maps */

/**

 * adapter_remove_device - Removes the device instance from the adaptor

 * instance. The device instance is not check in any way or freed by this. 

 * The caller is expected to take care of that. This will simply remove the

 * device from the adapters data strcutures.

 *

 * @acb: The adapter device to be updated

 * @dcb: A device that has previously been added to the adapter.

 fix up any pointers to this device that we have in the adapter */

 unlink from list */

 clear map and children */	

/**

 * adapter_remove_and_free_device - Removes a single device from the adapter

 * and then frees the device information.

 *

 * @acb: The adapter device to be updated

 * @dcb: A device that has previously been added to the adapter.

/**

 * adapter_remove_and_free_all_devices - Removes and frees all of the

 * devices associated with the specified adapter.

 *

 * @acb: The adapter from which all devices should be removed.

/**

 * dc395x_slave_alloc - Called by the scsi mid layer to tell us about a new

 * scsi device that we need to deal with. We allocate a new device and then

 * insert that device into the adapters device list.

 *

 * @scsi_device: The new scsi device that we need to handle.

/**

 * dc395x_slave_destroy - Called by the scsi mid layer to tell us about a

 * device that is going away.

 *

 * @scsi_device: The new scsi device that we need to handle.

/**

 * trms1040_wait_30us: wait for 30 us

 *

 * Waits for 30us (using the chip by the looks of it..)

 *

 * @io_port: base I/O address

 ScsiPortStallExecution(30); wait 30 us */

 nothing */ ;

/**

 * trms1040_write_cmd - write the secified command and address to

 * chip

 *

 * @io_port:	base I/O address

 * @cmd:	SB + op code (command) to send

 * @addr:	address to send

 program SB + OP code */

 Start from bit 2 */

 send address */

 Start from bit 6 */

/**

 * trms1040_set_data - store a single byte in the eeprom

 *

 * Called from write all to write a single byte into the SSEEPROM

 * Which is done one bit at a time.

 *

 * @io_port:	base I/O address

 * @addr:	offset into EEPROM

 * @byte:	bytes to write

 Send write command & address */

 Write data */

 Start from bit 7 */

 Disable chip select */

 Wait for write ready */

  Disable chip select */

/**

 * trms1040_write_all - write 128 bytes to the eeprom

 *

 * Write the supplied 128 bytes to the chips SEEPROM

 *

 * @eeprom:	the data to write

 * @io_port:	the base io port

 Enable SEEPROM */

 write enable */

 write */

 write disable */

 Disable SEEPROM */

/**

 * trms1040_get_data - get a single byte from the eeprom

 *

 * Called from read all to read a single byte into the SSEEPROM

 * Which is done one bit at a time.

 *

 * @io_port:	base I/O address

 * @addr:	offset into SEEPROM

 *

 * Returns the byte read.

 Send read command & address */

 read data */

 Get data bit while falling edge */

 Disable chip select */

/**

 * trms1040_read_all - read all bytes from the eeprom

 *

 * Read the 128 bytes from the SEEPROM.

 *

 * @eeprom:	where to store the data

 * @io_port:	the base io port

 Enable SEEPROM */

 read details */

 Disable SEEPROM */

/**

 * check_eeprom - get and check contents of the eeprom

 *

 * Read seeprom 128 bytes into the memory provider in eeprom.

 * Checks the checksum and if it's not correct it uses a set of default

 * values.

 *

 * @eeprom:	caller allocated strcuture to read the eeprom data into

 * @io_port:	io port to read from

 read eeprom */

		/*

		 * Checksum is wrong.

		 * Load a set of defaults into the eeprom buffer

 cfg3,cfg2,period,cfg0 */

 max_tag,delay_time,channel_cfg,scsi_id */

 reserved1,boot_lun,boot_target,reserved0 */

 Now load defaults (maybe set by boot/module params) */

/**

 * print_eeprom_settings - output the eeprom settings

 * to the kernel log so people can see what they were.

 *

 * @eeprom: The eeprom data strucutre to show details for.

 Free SG tables */

/*

 * Allocate SG tables; as we have to pci_map them, an SG list (struct SGentry*)

/**

 * adapter_print_config - print adapter connection and termination

 * config

 *

 * The io port in the adapter needs to have been set before calling

 * this function.

 *

 * @acb: The adapter to print the information for.

(CON5068 | CON50 | CON68) */ )

/**

 * adapter_init_params - Initialize the various parameters in the

 * adapter structure. Note that the pointer to the scsi_host is set

 * early (when this instance is created) and the io_port and irq

 * values are set later after they have been reserved. This just gets

 * everything set to a good starting position.

 *

 * The eeprom structure in the adapter needs to have been set before

 * calling this function.

 *

 * @acb: The adapter to initialize.

 NOTE: acb->scsi_host is set at scsi_host/acb creation time */

 NOTE: acb->io_port_base is set at port registration time */

 NOTE: acb->io_port_len is set at port registration time */

  temp SRB for Q tag used or abort command used  */

 timeout=250ms */

 NOTE: acb->irq_level is set at IRQ registration time */

 RESET_DETECT, RESET_DONE, RESET_DEV */

 NOTE: actually set in adapter_init_chip */

 link static array of srbs into the srb free list */

/**

 * adapter_init_scsi_host - Initialize the scsi host instance based on

 * values that we have already stored in the adapter instance. There's

 * some mention that a lot of these are deprecated, so we won't use

 * them (we'll use the ones in the adapter instance) but we'll fill

 * them in in case something else needs them.

 *

 * The eeprom structure, irq and io ports in the adapter need to have

 * been set before calling this function.

 *

 * @host: The scsi host instance to fill in the values for.

/**

 * adapter_init_chip - Get the chip into a know state and figure out

 * some of the settings that apply to this adapter.

 *

 * The io port in the adapter needs to have been set before calling

 * this function. The config will be configured correctly on return.

 *

 * @acb: The adapter which we are to init.

 Mask all the interrupt */

 Reset SCSI module */

 Reset PCI/DMA module */

 program configuration 0 */

while (!( DC395x_read8(acb, TRM_S1040_SCSI_INTSTATUS) & INT_SCSIRESET )); */

spin_unlock_irq (&io_request_lock); */

spin_lock_irq (&io_request_lock); */

/**

 * adapter_init - Grab the resource for the card, setup the adapter

 * information, set the card into a known state, create the various

 * tables etc etc. This basically gets all adapter information all up

 * to date, initialised and gets the chip in sync with it.

 *

 * @acb:	The adapter which we are to init.

 * @io_port:	The base I/O port

 * @io_port_len: The I/O port size

 * @irq:	IRQ

 *

 * Returns 0 if the initialization succeeds, any other value on

 * failure.

 store port base to indicate we have registered it */

 release the region we just claimed */

 store irq to indicate we have registered it */

 get eeprom configuration information and command line settings etc */

 setup adapter control block */	

 display card connectors/termination settings */

/**

 * adapter_uninit_chip - cleanly shut down the scsi controller chip,

 * stopping all operations and disabling interrupt generation on the

 * card.

 *

 * @acb: The adapter which we are to shutdown.

 disable interrupts */

 reset the scsi bus */

 clear any pending interrupt state */

/**

 * adapter_uninit - Shut down the chip and release any resources that

 * we had allocated. Once this returns the adapter should not be used

 * anymore.

 *

 * @acb: The adapter which we are to un-initialize.

 remove timers */

seq_printf(m, ", DMA_Status %i\n", DC395x_read8(acb, TRM_S1040_DMA_STATUS)); */

seq_printf(m, "\n"); */

 Add more info ... */

/**

 * banner_display - Display banner on first instance of driver

 * initialized.

/**

 * dc395x_init_one - Initialise a single instance of the adapter.

 *

 * The PCI layer will call this once for each instance of the adapter

 * that it finds in the system. The pci_dev strcuture indicates which

 * instance we are being called from.

 * 

 * @dev: The PCI device to initialize.

 * @id: Looks like a pointer to the entry in our pci device table

 * that was actually matched by the PCI subsystem.

 *

 * Returns 0 on success, or an error code (-ve) on failure.

 allocate scsi host information (includes out adapter) */

 initialise the adapter and everything we need */

 get the scsi mid level to scan for new devices on the bus */

/**

 * dc395x_remove_one - Called to remove a single instance of the

 * adapter.

 *

 * @dev: The PCI device to initialize.

 Terminating entry */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * sd_dif.c - SCSI Data Integrity Field

 *

 * Copyright (C) 2007, 2008 Oracle Corporation

 * Written by: Martin K. Petersen <martin.petersen@oracle.com>

/*

 * Configure exchange of protection information between OS and HBA.

 Enable DMA of protection information */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

    dmx3191d.c - driver for the Domex DMX3191D SCSI card.

    Copyright (C) 2000 by Massimo Piccioni <dafastidio@libero.it>

    Portions Copyright (C) 2004 by Christoph Hellwig <hch@lst.de>



    Based on the generic NCR5380 driver by Drew Eckhardt et al.



/*

 * Definitions for the generic 5380 driver.

 none */

	/* This card does not seem to raise an interrupt on pdev->irq.

	 * Steam-powered SCSI controllers run without an IRQ anyway.

 SPDX-License-Identifier: GPL-2.0-or-later

/* PARISC LASI driver for the 53c700 chip

 *

 * Copyright (C) 2001 by James.Bottomley@HansenPartnership.com

**-----------------------------------------------------------------------------

**  

**

**-----------------------------------------------------------------------------

/*

 * Many thanks to Richard Hirst <rhirst@linuxcare.com> for patiently

 * debugging this driver on the parisc architecture and suggesting

 * many improvements and bug fixes.

 *

 * Thanks also go to Linuxcare Inc. for providing several PARISC

 * machines for me to debug the driver on.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HighPoint RR3xxx/4xxx controller driver for Linux

 * Copyright (C) 2006-2015 HighPoint Technologies, Inc. All Rights Reserved.

 *

 * Please report bugs/comments/suggestions to linux@highpoint-tech.com

 *

 * For more information, visit http://www.highpoint-tech.com

 enable interrupts */

 start background tasks */

 wait 100ms for MCU ready */

 build S/G table */

 IOP is in unknown state, abort reset */

 Enable 64bit DMA if possible */

 Allocate request mem */

 Enable Interrupt and start background task */

 stop the iop */

 disable all outbound interrupts */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Marvell UMI driver

 *

 * Copyright 2011 Marvell. <jyli@marvell.com>

/**

 * mvumi_make_sgl -	Prepares  SGL

 * @mhba:		Adapter soft state

 * @scmd:		SCSI command from the mid-layer

 * @sgl_p:		SGL to be filled in

 * @sg_count:		return the number of SG elements

 *

 * If successful, this function returns 0. otherwise, it returns -1.

/**

 * mvumi_get_cmd -	Get a command from the free pool

 * @mhba:		Adapter soft state

 *

 * Returns a free command from the pool

/**

 * mvumi_return_cmd -	Return a cmd to free command pool

 * @mhba:		Adapter soft state

 * @cmd:		Command packet to be returned to free command pool

/**

 * mvumi_free_cmds -	Free all the cmds in the free cmd pool

 * @mhba:		Adapter soft state

/**

 * mvumi_alloc_cmds -	Allocates the command packets

 * @mhba:		Adapter soft state

 *

		/* Copy pointer may point to entry in outbound list

		*  before entry has valid data

 command timeout */

 3 mean linux*/

 host dynamic source mode */

/**

 * mvumi_init_data -	Initialize requested date for FW

 * @mhba:			Adapter soft state

 ib_list */

 ib shadow */

 ob shadow */

 ob list */

 ob data pool */

/**

 * mvumi_handshake -	Move the FW to READY state

 * @mhba:				Adapter soft state

 *

 * During the initialization, FW passes can potentially be in any one of

 * several possible states. If the FW in operational, waiting-for-handshake

 * states, driver must take steps to bring it to ready state. Otherwise, it

 * has to wait for the ready state.

 Set communication list ISR */

 Set InBound List Available count shadow */

 Set OutBound List Available count shadow */

 clear Door bell */

/**

 * mvumi_complete_cmd -	Completes a command

 * @mhba:			Adapter soft state

 * @cmd:			Command to be completed

 * @ob_frame:			Command response

 detach Hard Disk */

 detach virtual device */

 device no response, remove it */

 device response, add it */

/**

 * mvumi_enable_intr -	Enables interrupts

 * @mhba:		Adapter soft state

/**

 * mvumi_disable_intr -Disables interrupt

 * @mhba:		Adapter soft state

 inbound or outbound parity error, command will timeout */

/**

 * mvumi_read_fw_status_reg - returns the current FW status value

 * @mhba:		Adapter soft state

/**

 * mvumi_build_frame -	Prepares a direct cdb (DCDB) command

 * @mhba:		Adapter soft state

 * @scmd:		SCSI command

 * @cmd:		Command to be prepared in

 *

 * This function prepares CDB commands. These are typcially pass-through

 * commands to the devices.

/**

 * mvumi_queue_command -	Queue entry point

 * @shost:			Scsi host to queue command on

 * @scmd:			SCSI command to be queued

 For Arm */

 For Doorbell */

 For Message Unit */

 Bit setting for HW */

 For Arm */

 For Doorbell */

 For reset*/

 For Message Unit */

 Bit setting for HW */

/**

 * mvumi_init_fw -	Initializes the FW

 * @mhba:		Adapter soft state

 *

 * This is the main function for initializing firmware.

/**

 * mvumi_io_attach -	Attaches this driver to SCSI mid-layer

 * @mhba:		Adapter soft state

/**

 * mvumi_probe_one -	PCI hotplug entry point

 * @pdev:		PCI device structure

 * @id:			PCI ids of supported hotplugged adapter

/**

 * mvumi_shutdown -	Shutdown entry point

 * @pdev:		PCI device structure

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * pmcraid.c -- driver for PMC Sierra MaxRAID controller adapters

 *

 * Written By: Anil Ravindranath<anil_ravindranath@pmc-sierra.com>

 *             PMC-Sierra Inc

 *

 * Copyright (C) 2008, 2009 PMC Sierra Inc

/*

 *   Module configuration parameters

/*

 * Data structures to support multiple adapters by the LLD.

 * pmcraid_adapter_count - count of configured adapters

/*

 * Supporting user-level control interface through IOCTL commands.

 * pmcraid_major - major number to use

 * pmcraid_minor - minor number(s) to use

/*

 * Module parameters

/* chip specific constants for PMC MaxRAID controllers (same for

 * 0x5220 and 0x8010

/*

 * PCI device ids supported by pmcraid driver

/**

 * pmcraid_slave_alloc - Prepare for commands to a device

 * @scsi_dev: scsi device struct

 *

 * This function is called by mid-layer prior to sending any command to the new

 * device. Stores resource entry details of the device in scsi_device struct.

 * Queuecommand uses the resource handle and other details to fill up IOARCB

 * while sending commands to the device.

 *

 * Return value:

 *	  0 on success / -ENXIO if device does not exist

	/* Driver exposes VSET and GSCSI resources only; all other device types

	 * are not exposed. Resource list is synchronized using resource lock

	 * so any traversal or modifications to the list should be done inside

	 * this lock

 do not expose VSETs with order-ids > MAX_VSET_TARGETS */

/**

 * pmcraid_slave_configure - Configures a SCSI device

 * @scsi_dev: scsi device struct

 *

 * This function is executed by SCSI mid layer just after a device is first

 * scanned (i.e. it has responded to an INQUIRY). For VSET resources, the

 * timeout value (default 30s) will be over-written to a higher value (60s)

 * and max_sectors value will be over-written to 512. It also sets queue depth

 * to host->cmd_per_lun value

 *

 * Return value:

 *	  0 on success

 LLD exposes VSETs and Enclosure devices only */

	/*

	 * We never want to report TCQ support for these types of devices.

/**

 * pmcraid_slave_destroy - Unconfigure a SCSI device before removing it

 *

 * @scsi_dev: scsi device struct

 *

 * This is called by mid-layer before removing a device. Pointer assignments

 * done in pmcraid_slave_alloc will be reset to NULL here.

 *

 * Return value

 *   none

/**

 * pmcraid_change_queue_depth - Change the device's queue depth

 * @scsi_dev: scsi device struct

 * @depth: depth to set

 *

 * Return value

 *	actual depth set

/**

 * pmcraid_init_cmdblk - initializes a command block

 *

 * @cmd: pointer to struct pmcraid_cmd to be initialized

 * @index: if >=0 first time initialization; otherwise reinitialization

 *

 * Return Value

 *	 None

 first time initialization (called from  probe) */

		/* re-initialization of various lengths, called once command is

		 * processed by IOA

/**

 * pmcraid_reinit_cmdblk - reinitialize a command block

 *

 * @cmd: pointer to struct pmcraid_cmd to be reinitialized

 *

 * Return Value

 *	 None

/**

 * pmcraid_get_free_cmd - get a free cmd block from command block pool

 * @pinstance: adapter instance structure

 *

 * Return Value:

 *	returns pointer to cmd block or NULL if no blocks are available

 free cmd block list is protected by free_pool_lock */

 Initialize the command block before giving it the caller */

/**

 * pmcraid_return_cmd - return a completed command block back into free pool

 * @cmd: pointer to the command block

 *

 * Return Value:

 *	nothing

/**

 * pmcraid_read_interrupts -  reads IOA interrupts

 *

 * @pinstance: pointer to adapter instance structure

 *

 * Return value

 *	 interrupts read from IOA

/**

 * pmcraid_disable_interrupts - Masks and clears all specified interrupts

 *

 * @pinstance: pointer to per adapter instance structure

 * @intrs: interrupts to disable

 *

 * Return Value

 *	 None

/**

 * pmcraid_enable_interrupts - Enables specified interrupts

 *

 * @pinstance: pointer to per adapter instance structure

 * @intrs: interrupts to enable

 *

 * Return Value

 *	 None

/**

 * pmcraid_clr_trans_op - clear trans to op interrupt

 *

 * @pinstance: pointer to per adapter instance structure

 *

 * Return Value

 *	 None

/**

 * pmcraid_reset_type - Determine the required reset type

 * @pinstance: pointer to adapter instance structure

 *

 * IOA requires hard reset if any of the following conditions is true.

 * 1. If HRRQ valid interrupt is not masked

 * 2. IOA reset alert doorbell is set

 * 3. If there are any error interrupts

 If unit check is active, trigger the dump */

/**

 * pmcraid_bist_done - completion function for PCI BIST

 * @t: pointer to reset command

 * Return Value

 *	none

 If PCI config space can't be accessed wait for another two secs */

/**

 * pmcraid_start_bist - starts BIST

 * @cmd: pointer to reset cmd

 * Return Value

 *   none

 proceed with bist and wait for 2 seconds */

/**

 * pmcraid_reset_alert_done - completion routine for reset_alert

 * @t: pointer to command block used in reset sequence

 * Return value

 *  None

	/* if the critical operation in progress bit is set or the wait times

	 * out, invoke reset engine to proceed with hard reset. If there is

	 * some more time to wait, restart the timer

 restart timer if some more time is available to wait */

/**

 * pmcraid_reset_alert - alerts IOA for a possible reset

 * @cmd: command block to be used for reset sequence.

 *

 * Return Value

 *	returns 0 if pci config-space is accessible and RESET_DOORBELL is

 *	successfully written to IOA. Returns non-zero in case pci_config_space

 *	is not accessible

	/* If we are able to access IOA PCI config space, alert IOA that we are

	 * going to reset it soon. This enables IOA to preserv persistent error

	 * data if any. In case memory space is not accessible, proceed with

	 * BIST or slot_reset

		/* wait for IOA permission i.e until CRITICAL_OPERATION bit is

		 * reset IOA doesn't generate any interrupts when CRITICAL

		 * OPERATION bit is reset. A timer is started to wait for this

		 * bit to be reset.

/**

 * pmcraid_timeout_handler -  Timeout handler for internally generated ops

 *

 * @t: pointer to command structure, that got timedout

 *

 * This function blocks host requests and initiates an adapter reset.

 *

 * Return value:

 *   None

	/* Command timeouts result in hard reset sequence. The command that got

	 * timed out may be the one used as part of reset sequence. In this

	 * case restart reset sequence using the same command block even if

	 * reset is in progress. Otherwise fail this command and get a free

	 * command block to restart the reset sequence.

		/* If we are out of command blocks, just return here itself.

		 * Some other command's timeout handler can do the reset job

			/* This command should have been given to IOA, this

			 * command will be completed by fail_outstanding_cmds

			 * anyway

		/* If this command was being used as part of the reset

		 * sequence, set cmd_done pointer to pmcraid_ioa_reset. This

		 * causes fail_outstanding_commands not to return the command

		 * block back to free pool

 Notify apps of important IOA bringup/bringdown sequences */

/**

 * pmcraid_internal_done - completion routine for internally generated cmds

 *

 * @cmd: command that got response from IOA

 *

 * Return Value:

 *	 none

	/* Some of the internal commands are sent with callers blocking for the

	 * response. Same will be indicated as part of cmd->completion_req

	 * field. Response path needs to wake up any waiters waiting for cmd

	 * completion if this flag is set.

	/* most of the internal commands are completed by caller itself, so

	 * no need to return the command block back to free pool until we are

	 * required to do so (e.g once done with initialization).

/**

 * pmcraid_reinit_cfgtable_done - done function for cfg table reinitialization

 *

 * @cmd: command that got response from IOA

 *

 * This routine is called after driver re-reads configuration table due to a

 * lost CCN. It returns the command block back to free pool and schedules

 * worker thread to add/delete devices into the system.

 *

 * Return Value:

 *	 none

/**

 * pmcraid_erp_done - Process completion of SCSI error response from device

 * @cmd: pmcraid_command

 *

 * This function copies the sense buffer into the scsi_cmd struct and completes

 * scsi_cmd by calling scsi_done function.

 *

 * Return value:

 *  none

/**

 * _pmcraid_fire_command - sends an IOA command to adapter

 *

 * This function adds the given block into pending command list

 * and returns without waiting

 *

 * @cmd : command to be sent to the device

 *

 * Return Value

 *	None

	/* Add this command block to pending cmd pool. We do this prior to

	 * writting IOARCB to ioarrin because IOA might complete the command

	 * by the time we are about to add it to the list. Response handler

	 * (isr/tasklet) looks for cmd block in the pending pending list.

 driver writes lower 32-bit value of IOARCB address only */

/**

 * pmcraid_send_cmd - fires a command to IOA

 *

 * This function also sets up timeout function, and command completion

 * function

 *

 * @cmd: pointer to the command block to be fired to IOA

 * @cmd_done: command completion function, called once IOA responds

 * @timeout: timeout to wait for this command completion

 * @timeout_func: timeout handler

 *

 * Return value

 *   none

 initialize done function */

 setup timeout handler */

 fire the command to IOA */

/**

 * pmcraid_ioa_shutdown_done - completion function for IOA shutdown command

 * @cmd: pointer to the command block used for sending IOA shutdown command

 *

 * Return value

 *  None

/**

 * pmcraid_ioa_shutdown - sends SHUTDOWN command to ioa

 *

 * @cmd: pointer to the command block used as part of reset sequence

 *

 * Return Value

 *  None

	/* Note that commands sent during reset require next command to be sent

	 * to IOA. Hence reinit the done function as well as timeout function

 fire shutdown command to hardware. */

/**

 * pmcraid_get_fwversion_done - completion function for get_fwversion

 *

 * @cmd: pointer to command block used to send INQUIRY command

 *

 * Return Value

 *	none

	/* configuration table entry size depends on firmware version. If fw

	 * version is not known, it is not possible to interpret IOA config

	 * table

/**

 * pmcraid_get_fwversion - reads firmware version information

 *

 * @cmd: pointer to command block used to send INQUIRY command

 *

 * Return Value

 *	none

	/* Since entire inquiry data it can be part of IOARCB itself

/**

 * pmcraid_identify_hrrq - registers host rrq buffers with IOA

 * @cmd: pointer to command block to be used for identify hrrq

 *

 * Return Value

 *	 none

 Initialize ioarcb */

 initialize the hrrq number where IOA will respond to this command */

	/* IOA expects 64-bit pci address to be written in B.E format

	 * (i.e cdb[2]=MSByte..cdb[9]=LSB.

	/* Subsequent commands require HRRQ identification to be successful.

	 * Note that this gets called even during reset from SCSI mid-layer

	 * or tasklet

/**

 * pmcraid_send_hcam_cmd - send an initialized command block(HCAM) to IOA

 *

 * @cmd: initialized command block pointer

 *

 * Return Value

 *   none

/**

 * pmcraid_init_hcam - send an initialized command block(HCAM) to IOA

 *

 * @pinstance: pointer to adapter instance structure

 * @type: HCAM type

 *

 * Return Value

 *   pointer to initialized pmcraid_cmd structure or NULL

 initialize command pointer used for HCAM registration */

 Initialize ioarcb */

/**

 * pmcraid_send_hcam - Send an HCAM to IOA

 * @pinstance: ioa config struct

 * @type: HCAM type

 *

 * This function will send a Host Controlled Async command to IOA.

 *

 * Return value:

 *	none

/**

 * pmcraid_prepare_cancel_cmd - prepares a command block to abort another

 *

 * @cmd: pointer to cmd that is used as cancelling command

 * @cmd_to_cancel: pointer to the command that needs to be cancelled

	/* IOARCB address of the command to be cancelled is given in

	 * cdb[2]..cdb[9] is Big-Endian format. Note that length bits in

	 * IOARCB address are not masked.

	/* Get the resource handle to where the command to be aborted has been

	 * sent.

/**

 * pmcraid_cancel_hcam - sends ABORT task to abort a given HCAM

 *

 * @cmd: command to be used as cancelling command

 * @type: HCAM type

 * @cmd_done: op done function for the cancelling command

	/* prepare for cancelling previous hcam command. If the HCAM is

	 * currently not pending with IOA, we would have hcam->cmd as non-null

	/* writing to IOARRIN must be protected by host_lock, as mid-layer

	 * schedule queuecommand while we are doing this

/**

 * pmcraid_cancel_ccn - cancel CCN HCAM already registered with IOA

 *

 * @cmd: command block to be used for cancelling the HCAM

/**

 * pmcraid_cancel_ldn - cancel LDN HCAM already registered with IOA

 *

 * @cmd: command block to be used for cancelling the HCAM

/**

 * pmcraid_expose_resource - check if the resource can be exposed to OS

 *

 * @fw_version: firmware version code

 * @cfgte: pointer to configuration table entry of the resource

 *

 * Return value:

 *	true if resource can be added to midlayer, false(0) otherwise

 attributes supported by pmcraid_event_family */

 commands supported by pmcraid_event_family */

 not really used - see ID discussion below */ },

/**

 * pmcraid_netlink_init - registers pmcraid_event_family

 *

 * Return value:

 *	0 if the pmcraid_event_family is successfully registered

 *	with netlink generic, non-zero otherwise

/**

 * pmcraid_netlink_release - unregisters pmcraid_event_family

 *

 * Return value:

 *	none

/*

 * pmcraid_notify_aen - sends event msg to user space application

 * @pinstance: pointer to adapter instance structure

 *

 * Return value:

 *	0 if success, error value in case of any failure.

 Add GENL_HDR to total_size */

 add the genetlink message header */

 send genetlink multicast message to notify appplications */

	/* If there are no listeners, genlmsg_multicast may return non-zero

	 * value.

/**

 * pmcraid_notify_ccn - notifies about CCN event msg to user space

 * @pinstance: pointer adapter instance structure

 *

 * Return value:

 *	0 if success, error value in case of any failure

/**

 * pmcraid_notify_ldn - notifies about CCN event msg to user space

 * @pinstance: pointer adapter instance structure

 *

 * Return value:

 *	0 if success, error value in case of any failure

/**

 * pmcraid_notify_ioastate - sends IOA state event msg to user space

 * @pinstance: pointer adapter instance structure

 * @evt: controller state event to be sent

 *

 * Return value:

 *	0 if success, error value in case of any failure

/**

 * pmcraid_handle_config_change - Handle a config change from the adapter

 * @pinstance: pointer to per adapter instance structure

 *

 * Return value:

 *  none

 If this HCAM indicates a lost notification, read the config table */

	/* If this resource is not going to be added to mid-layer, just notify

	 * applications and return. If this notification is about hiding a VSET

	 * resource, check if it was exposed already.

		/* If there are more number of resources than what driver can

		 * manage, do not notify the applications about the CCN. Just

		 * ignore this notifications and re-register the same HCAM

 This may be one of the non-exposed resources */

 Notify configuration changes to registered applications.*/

/**

 * pmcraid_get_error_info - return error string for an ioasc

 * @ioasc: ioasc code

 * Return Value

 *	 none

/**

 * pmcraid_ioasc_logger - log IOASC information based user-settings

 * @ioasc: ioasc code

 * @cmd: pointer to command that resulted in 'ioasc'

 log the error string */

/**

 * pmcraid_handle_error_log - Handle a config change (error log) from the IOA

 *

 * @pinstance: pointer to per adapter instance structure

 *

 * Return value:

 *  none

 log only the errors, no need to log informational log entries */

/**

 * pmcraid_process_ccn - Op done function for a CCN.

 * @cmd: pointer to command struct

 *

 * This function is the op done function for a configuration

 * change notification

 *

 * Return value:

 * none

	/* If driver initiated IOA reset happened while this hcam was pending

	 * with IOA, or IOA bringdown sequence is in progress, no need to

	 * re-register the hcam

/**

 * pmcraid_process_ldn - op done function for an LDN

 * @cmd: pointer to command block

 *

 * Return value

 *   none

 return the command block back to freepool */

	/* If driver initiated IOA reset happened while this hcam was pending

	 * with IOA, no need to re-register the hcam as reset engine will do it

	 * once reset sequence is complete

 send netlink message for HCAM notification if enabled */

/**

 * pmcraid_register_hcams - register HCAMs for CCN and LDN

 *

 * @pinstance: pointer per adapter instance structure

 *

 * Return Value

 *   none

/**

 * pmcraid_unregister_hcams - cancel HCAMs registered already

 * @cmd: pointer to command used as part of reset sequence

	/* During IOA bringdown, HCAM gets fired and tasklet proceeds with

	 * handling hcam response though it is not necessary. In order to

	 * prevent this, set 'ignore', so that bring-down sequence doesn't

	 * re-send any more hcams

	/* If adapter reset was forced as part of runtime reset sequence,

	 * start the reset sequence. Reset will be triggered even in case

	 * IOA unit_check.

	/* Driver tries to cancel HCAMs by sending ABORT TASK for each HCAM

	 * one after the other. So CCN cancellation will be triggered by

	 * pmcraid_cancel_ldn itself.

/**

 * pmcraid_reset_enable_ioa - re-enable IOA after a hard reset

 * @pinstance: pointer to adapter instance structure

 * Return Value

 *  1 if TRANSITION_TO_OPERATIONAL is active, otherwise 0

/**

 * pmcraid_soft_reset - performs a soft reset and makes IOA become ready

 * @cmd : pointer to reset command block

 *

 * Return Value

 *	none

	/* There will be an interrupt when Transition to Operational bit is

	 * set so tasklet would execute next reset task. The timeout handler

	 * would re-initiate a reset

	/* Enable destructive diagnostics on IOA if it is not yet in

	 * operational state

	/* Since we do RESET_ALERT and Start BIST we have to again write

	 * MSIX Doorbell to indicate the interrupt mode

/**

 * pmcraid_get_dump - retrieves IOA dump in case of Unit Check interrupt

 *

 * @pinstance: pointer to adapter instance structure

 *

 * Return Value

 *	none

/**

 * pmcraid_fail_outstanding_cmds - Fails all outstanding ops.

 * @pinstance: pointer to adapter instance structure

 *

 * This function fails all outstanding ops. If they are submitted to IOA

 * already, it sends cancel all messages if IOA is still accepting IOARCBs,

 * otherwise just completes the commands and returns the cmd blocks to free

 * pool.

 *

 * Return value:

 *	 none

	/* pending command list is protected by pending_pool_lock. Its

	 * traversal must be done as within this lock

 In case the command timer is still running */

		/* If this is an IO command, complete it by invoking scsi_done

		 * function. If this is one of the internal commands other

		 * than pmcraid_ioa_reset and HCAM commands invoke cmd_done to

		 * complete it

/**

 * pmcraid_ioa_reset - Implementation of IOA reset logic

 *

 * @cmd: pointer to the cmd block to be used for entire reset process

 *

 * This function executes most of the steps required for IOA reset. This gets

 * called by user threads (modprobe/insmod/rmmod) timer, tasklet and midlayer's

 * 'eh_' thread. Access to variables used for controlling the reset sequence is

 * synchronized using host lock. Various functions called during reset process

 * would make use of a single command block, pointer to which is also stored in

 * adapter instance structure.

 *

 * Return Value

 *	 None

		/* If IOA is offline, whatever may be the reset reason, just

		 * return. callers might be waiting on the reset wait_q, wake

		 * up them

		/* we enter here, once ioa shutdown command is processed by IOA

		 * Alert IOA for a possible reset. If reset alert fails, IOA

		 * goes through hard-reset

		/* We may be called during probe or resume. Some pre-processing

		 * is required for prior to reset

		/* If asked to reset while IOA was processing responses or

		 * there are any error responses then IOA may require

		 * hard-reset.

			/* Alert IOA of a possible reset and wait for critical

			 * operation in progress bit to reset

		/* If critical operation in progress bit is reset or wait gets

		 * timed out, reset proceeds with starting BIST on the IOA.

		 * pmcraid_ioa_hard_reset keeps a count of reset attempts. If

		 * they are 3 or more, reset engine marks IOA dead and returns

 retry reset if we haven't reached maximum allowed limit */

		/* Once either bist or pci reset is done, restore PCI config

		 * space. If this fails, proceed with hard reset again

 fail all pending commands */

 check if unit check is active, if so extract dump */

		/* if the reset reason is to bring-down the ioa, we might be

		 * done with the reset restore pci_config_space and complete

		 * the reset

			/* bring-up IOA, so proceed with soft reset

			 * Reinitialize hrrq_buffers and their indices also

			 * enable interrupts after a pci_restore_state

		/* TRANSITION TO OPERATIONAL is on so start initialization

		 * sequence

		/* Initialization commands start with HRRQ identification. From

		 * now on tasklet completes most of the commands as IOA is up

		 * and intrs are enabled

		/* we are done with bringing up of IOA, change the ioa_state to

		 * operational and wake up any waiters

		/* When IOA is operational and a reset is requested, check for

		 * the reset reason. If reset is to bring down IOA, unregister

		 * HCAMs and initiate shutdown; if adapter reset is forced then

		 * restart reset sequence again

	/* reset will be completed if ioa_state is either DEAD or UNKNOWN or

	 * OPERATIONAL. Reset all control variables used during reset, wake up

	 * any waiting threads and let the SCSI mid-layer send commands. Note

	 * that host_lock must be held before invoking scsi_report_bus_reset.

		/* If target state is to bring up the adapter, proceed with

		 * hcam registration and resource exposure to mid-layer.

/**

 * pmcraid_initiate_reset - initiates reset sequence. This is called from

 * ISR/tasklet during error interrupts including IOA unit check. If reset

 * is already in progress, it just returns, otherwise initiates IOA reset

 * to bring IOA up to operational state.

 *

 * @pinstance: pointer to adapter instance structure

 *

 * Return value

 *	 none

	/* If the reset is already in progress, just return, otherwise start

	 * reset sequence and return

/**

 * pmcraid_reset_reload - utility routine for doing IOA reset either to bringup

 *			  or bringdown IOA

 * @pinstance: pointer adapter instance structure

 * @shutdown_type: shutdown type to be used NONE, NORMAL or ABRREV

 * @target_state: expected target state after reset

 *

 * Note: This command initiates reset and waits for its completion. Hence this

 * should not be called from isr/timer/tasklet functions (timeout handlers,

 * error response handlers and interrupt handlers).

 *

 * Return Value

 *	 1 in case ioa_state is not target_state, 0 otherwise.

/**

 * pmcraid_reset_bringdown - wrapper over pmcraid_reset_reload to bringdown IOA

 *

 * @pinstance: pointer to adapter instance structure

 *

 * Return Value

 *	 whatever is returned from pmcraid_reset_reload

/**

 * pmcraid_reset_bringup - wrapper over pmcraid_reset_reload to bring up IOA

 *

 * @pinstance: pointer to adapter instance structure

 *

 * Return Value

 *	 whatever is returned from pmcraid_reset_reload

/**

 * pmcraid_request_sense - Send request sense to a device

 * @cmd: pmcraid command struct

 *

 * This function sends a request sense to a device as a result of a check

 * condition. This method re-uses the same command block that failed earlier.

 re-use the command block */

	/* request sense might be called as part of error response processing

	 * which runs in tasklets context. It is possible that mid-layer might

	 * schedule queuecommand during this time, hence, writting to IOARRIN

	 * must be protect by host_lock

/**

 * pmcraid_cancel_all - cancel all outstanding IOARCBs as part of error recovery

 * @cmd: command that failed

 * @need_sense: true if request_sense is required after cancel all

 *

 * This function sends a cancel all to a device to clear the queue.

	/* writing to IOARRIN must be protected by host_lock, as mid-layer

	 * schedule queuecommand while we are doing this

/**

 * pmcraid_frame_auto_sense: frame fixed format sense information

 *

 * @cmd: pointer to failing command block

 *

 * Return value

 *  none

 additional length */

/**

 * pmcraid_error_handler - Error response handlers for a SCSI op

 * @cmd: pointer to pmcraid_cmd that has failed

 *

 * This function determines whether or not to initiate ERP on the affected

 * device. This is called from a tasklet, which doesn't hold any locks.

 *

 * Return value:

 *	 0 it caller can complete the request, otherwise 1 where in error

 *	 handler itself completes the request and returns the command block

 *	 back to free-pool

 If this was a SCSI read/write command keep count of errors */

 Log IOASC/IOASA information based on user settings */

		/* if check_condition is not active return with error otherwise

		 * get/frame the sense buffer

		/* If we have auto sense data as part of IOASA pass it to

		 * mid-layer

/**

 * pmcraid_reset_device - device reset handler functions

 *

 * @scsi_cmd: scsi command struct

 * @timeout: command timeout

 * @modifier: reset modifier indicating the reset sequence to be performed

 *

 * This function issues a device reset to the affected device.

 * A LUN reset will be sent to the device first. If that does

 * not work, a target reset will be sent.

 *

 * Return value:

 *	SUCCESS / FAILED

	/* If adapter is currently going through reset/reload, return failed.

	 * This will force the mid-layer to call _eh_bus/host reset, which

	 * will then go to sleep and wait for the reset to complete

 get a free cmd block */

 Initialize reset modifier bits */

	/* RESET_DEVICE command completes after all pending IOARCBs are

	 * completed. Once this command is completed, pmcraind_internal_done

	 * will wake up the 'completion' queue.

	/* complete the command here itself and return the command block

	 * to free list

 set the return value based on the returned ioasc */

/**

 * _pmcraid_io_done - helper for pmcraid_io_done function

 *

 * @cmd: pointer to pmcraid command struct

 * @reslen: residual data length to be set in the ioasa

 * @ioasc: ioasc either returned by IOA or set by driver itself.

 *

 * This function is invoked by pmcraid_io_done to complete mid-layer

 * scsi ops.

 *

 * Return value:

 *	  0 if caller is required to return it to free_pool. Returns 1 if

 *	  caller need not worry about freeing command block as error handler

 *	  will take care of that.

/**

 * pmcraid_io_done - SCSI completion function

 *

 * @cmd: pointer to pmcraid command struct

 *

 * This function is invoked by tasklet/mid-layer error handler to completing

 * the SCSI ops sent from mid-layer.

 *

 * Return value

 *	  none

/**

 * pmcraid_abort_cmd - Aborts a single IOARCB already submitted to IOA

 *

 * @cmd: command block of the command to be aborted

 *

 * Return Value:

 *	 returns pointer to command structure used as cancelling cmd

/**

 * pmcraid_abort_complete - Waits for ABORT TASK completion

 *

 * @cancel_cmd: command block use as cancelling command

 *

 * Return Value:

 *	 returns SUCCESS if ABORT TASK has good completion

 *	 otherwise FAILED

	/* If the abort task is not timed out we will get a Good completion

	 * as sense_key, otherwise we may get one the following responses

	 * due to subsequent bus reset or device reset. In case IOASC is

	 * NR_SYNC_REQUIRED, set sync_reqd flag for the corresponding resource

 complete the command here itself */

/**

 * pmcraid_eh_abort_handler - entry point for aborting a single task on errors

 *

 * @scsi_cmd:   scsi command struct given by mid-layer. When this is called

 *		mid-layer ensures that no other commands are queued. This

 *		never gets called under interrupt, but a separate eh thread.

 *

 * Return value:

 *	 SUCCESS / FAILED

	/* If we are currently going through reset/reload, return failed.

	 * This will force the mid-layer to eventually call

	 * pmcraid_eh_host_reset which will then go to sleep and wait for the

	 * reset to complete

	/* loop over pending cmd list to find cmd corresponding to this

	 * scsi_cmd. Note that this command might not have been completed

	 * already. locking: all pending commands are protected with

	 * pending_pool_lock.

	/* If the command to be aborted was given to IOA and still pending with

	 * it, send ABORT_TASK to abort this and wait for its completion

/**

 * pmcraid_eh_device_reset_handler - bus/target/device reset handler callbacks

 *

 * @scmd: pointer to scsi_cmd that was sent to the resource to be reset.

 *

 * All these routines invokve pmcraid_reset_device with appropriate parameters.

 * Since these are called from mid-layer EH thread, no other IO will be queued

 * to the resource being reset. However, control path (IOCTL) may be active so

 * it is necessary to synchronize IOARRIN writes which pmcraid_reset_device

 * takes care by locking/unlocking host_lock.

 *

 * Return value

 *	SUCCESS or FAILED

/**

 * pmcraid_eh_host_reset_handler - adapter reset handler callback

 *

 * @scmd: pointer to scsi_cmd that was sent to a resource of adapter

 *

 * Initiates adapter reset to bring it up to operational state

 *

 * Return value

 *	SUCCESS or FAILED

 10 seconds interval */

	/* wait for an additional 150 seconds just in case firmware could come

	 * up and if it could complete all the pending commands excluding the

	 * two HCAM (CCN and LDN).

/**

 * pmcraid_init_ioadls - initializes IOADL related fields in IOARCB

 * @cmd: pmcraid command struct

 * @sgcount: count of scatter-gather elements

 *

 * Return value

 *   returns pointer pmcraid_ioadl_desc, initialized to point to internal

 *   or external IOADLs

		/* external ioadls start at offset 0x80 from control_block

		 * structure, re-using 24 out of 27 ioadls part of IOARCB.

		 * It is necessary to indicate to firmware that driver is

		 * using ioadls to be treated as external to IOARCB.

/**

 * pmcraid_build_ioadl - Build a scatter/gather list and map the buffer

 * @pinstance: pointer to adapter instance structure

 * @cmd: pmcraid command struct

 *

 * This function is invoked by queuecommand entry point while sending a command

 * to firmware. This builds ioadl descriptors and sets up ioarcb fields.

 *

 * Return value:

 *	0 on success or -1 on failure

 Initialize IOARCB data transfer length fields */

 Initialize IOADL descriptor addresses */

 setup last descriptor */

/**

 * pmcraid_free_sglist - Frees an allocated SG buffer list

 * @sglist: scatter/gather list pointer

 *

 * Free a DMA'able memory previously allocated with pmcraid_alloc_sglist

 *

 * Return value:

 *	none

/**

 * pmcraid_alloc_sglist - Allocates memory for a SG list

 * @buflen: buffer length

 *

 * Allocates a DMA'able buffer in chunks and assembles a scatter/gather

 * list.

 *

 * Return value

 *	pointer to sglist / NULL on failure

 Allocate a scatter/gather list for the DMA */

/**

 * pmcraid_copy_sglist - Copy user buffer to kernel buffer's SG list

 * @sglist: scatter/gather list pointer

 * @buffer: buffer pointer

 * @len: buffer length

 * @direction: data transfer direction

 *

 * Copy a user buffer into a buffer allocated by pmcraid_alloc_sglist

 *

 * Return value:

 * 0 on success / other on failure

 Determine the actual number of bytes per element */

/**

 * pmcraid_queuecommand_lck - Queue a mid-layer request

 * @scsi_cmd: scsi command struct

 * @done: done function

 *

 * This function queues a request generated by the mid-layer. Midlayer calls

 * this routine within host->lock. Some of the functions called by queuecommand

 * would use cmd block queue locks (free_pool_lock and pending_pool_lock)

 *

 * Return value:

 *	  0 on success

 *	  SCSI_MLQUEUE_DEVICE_BUSY if device is busy

 *	  SCSI_MLQUEUE_HOST_BUSY if host is busy

	/* if adapter is marked as dead, set result to DID_NO_CONNECT complete

	 * the command

 If IOA reset is in progress, can't queue the commands */

	/* Firmware doesn't support SYNCHRONIZE_CACHE command (0x35), complete

	 * the command here itself with success return

 initialize the command and IOARCB to be sent to IOA */

	/* set hrrq number where the IOA should respond to. Note that all cmds

	 * generated internally uses hrrq_id 0, exception to this is the cmd

	 * block of scsi_cmd which is re-used (e.g. cancel/abort), which uses

	 * hrrq_id assigned here in queuecommand

/*

 * pmcraid_open -char node "open" entry, allowed only users with admin access

 Populate adapter instance * pointer for use by ioctl */

/*

 * pmcraid_fasync - Async notifier registration from applications

 *

 * This function adds the calling process to a driver global queue. When an

 * event occurs, SIGIO will be sent to all processes in this queue.

/**

 * pmcraid_build_passthrough_ioadls - builds SG elements for passthrough

 * commands sent over IOCTL interface

 *

 * @cmd       : pointer to struct pmcraid_cmd

 * @buflen    : length of the request buffer

 * @direction : data transfer direction

 *

 * Return value

 *  0 on success, non-zero error code on failure

 Initialize IOADL descriptor addresses */

 setup the last descriptor */

/**

 * pmcraid_release_passthrough_ioadls - release passthrough ioadls

 *

 * @cmd: pointer to struct pmcraid_cmd for which ioadls were allocated

 * @buflen: size of the request buffer

 * @direction: data transfer direction

 *

 * Return value

 *  0 on success, non-zero error code on failure

/**

 * pmcraid_ioctl_passthrough - handling passthrough IOCTL commands

 *

 * @pinstance: pointer to adapter instance structure

 * @ioctl_cmd: ioctl code

 * @buflen: unused

 * @arg: pointer to pmcraid_passthrough_buffer user buffer

 *

 * Return value

 *  0 on success, non-zero error code on failure

 If IOA reset is in progress, wait 10 secs for reset to complete */

 If adapter is not in operational state, return error */

 check if we have any additional command parameters */

 Copy the user-provided IOARCB stuff field by field */

	/* set hrrq number where the IOA should respond to. Note that all cmds

	 * generated internally uses hrrq_id 0, exception to this is the cmd

	 * block of scsi_cmd which is re-used (e.g. cancel/abort), which uses

	 * hrrq_id assigned here in queuecommand

	/* If data is being written into the device, copy the data from user

	 * buffers

	/* passthrough ioctl is a blocking command so, put the user to sleep

	 * until timeout. Note that a timeout value of 0 means, do timeout.

	/* NOTE ! Remove the below line once abort_task is implemented

	 * in firmware. This line disables ioctl command timeout handling logic

	 * similar to IO command timeout handling, making ioctl commands to wait

	 * until the command completion regardless of timeout value specified in

	 * ioarcb

	/* If command timeout is specified put caller to wait till that time,

	 * otherwise it would be blocking wait. If command gets timed out, it

	 * will be aborted.

			/* if abort task couldn't find the command i.e it got

			 * completed prior to aborting, return good completion.

			 * if command got aborted successfully or there was IOA

			 * reset due to abort task itself getting timedout then

			 * return -ETIMEDOUT

		/* no command block for abort task or abort task failed to abort

		 * the IOARCB, then wait for 150 more seconds and initiate reset

		 * sequence after timeout

	/* copy entire IOASA buffer and return IOCTL success.

	 * If copying IOASA to user-buffer fails, return

	 * EFAULT

	/* If the data transfer was from device, copy the data onto user

	 * buffers

/**

 * pmcraid_ioctl_driver - ioctl handler for commands handled by driver itself

 *

 * @pinstance: pointer to adapter instance structure

 * @cmd: ioctl command passed in

 * @buflen: length of user_buffer

 * @user_buffer: user buffer pointer

 *

 * Return Value

 *   0 in case of success, otherwise appropriate error code

/**

 * pmcraid_check_ioctl_buffer - check for proper access to user buffer

 *

 * @cmd: ioctl command

 * @arg: user buffer

 * @hdr: pointer to kernel memory for pmcraid_ioctl_header

 *

 * Return Value

 *	negetive error code if there are access issues, otherwise zero.

 *	Upon success, returns ioctl header copied out of user buffer.

 check for valid driver signature */

/*

 *  pmcraid_ioctl - char node ioctl entry point

		/* If ioctl code is to download microcode, we need to block

		 * mid-layer requests.

/*

 * File operations structure for management interface

/**

 * pmcraid_show_log_level - Display adapter's error logging level

 * @dev: class device struct

 * @attr: unused

 * @buf: buffer

 *

 * Return value:

 *  number of bytes printed to buffer

/**

 * pmcraid_store_log_level - Change the adapter's error logging level

 * @dev: class device struct

 * @attr: unused

 * @buf: buffer

 * @count: not used

 *

 * Return value:

 *  number of bytes printed to buffer

 log-level should be from 0 to 2 */

/**

 * pmcraid_show_drv_version - Display driver version

 * @dev: class device struct

 * @attr: unused

 * @buf: buffer

 *

 * Return value:

 *  number of bytes printed to buffer

/**

 * pmcraid_show_adapter_id - Display driver assigned adapter id

 * @dev: class device struct

 * @attr: unused

 * @buf: buffer

 *

 * Return value:

 *  number of bytes printed to buffer

 host template structure for pmcraid driver */

/*

 * pmcraid_isr_msix - implements MSI-X interrupt handling routine

 * @irq: interrupt vector number

 * @dev_id: pointer hrrq_vector

 *

 * Return Value

 *	 IRQ_HANDLED if interrupt is handled or IRQ_NONE if ignored

 Read the interrupt */

			/* Any error interrupts including unit_check,

			 * initiate IOA reset.In case of unit check indicate

			 * to reset_sequence that IOA unit checked and prepare

			 * for a dump during reset sequence

			/* If interrupt was as part of the ioa initialization,

			 * clear it. Delete the timer and wakeup the

			 * reset engine to proceed with reset sequence

			/* Clear the interrupt register by writing

			 * to host to ioa doorbell. Once done

			 * FW will clear the interrupt.

/**

 * pmcraid_isr  - implements legacy interrupt handling routine

 *

 * @irq: interrupt vector number

 * @dev_id: pointer hrrq_vector

 *

 * Return Value

 *	 IRQ_HANDLED if interrupt is handled or IRQ_NONE if ignored

	/* In case of legacy interrupt mode where interrupts are shared across

	 * isrs, it may be possible that the current interrupt is not from IOA

	/* Any error interrupts including unit_check, initiate IOA reset.

	 * In case of unit check indicate to reset_sequence that IOA unit

	 * checked and prepare for a dump during reset sequence

		/* If interrupt was as part of the ioa initialization,

		 * clear. Delete the timer and wakeup the

		 * reset engine to proceed with reset sequence

/**

 * pmcraid_worker_function -  worker thread function

 *

 * @workp: pointer to struct work queue

 *

 * Return Value

 *	 None

 add resources only after host is added into system */

			/* host_lock must be held before calling

			 * scsi_device_get

/**

 * pmcraid_tasklet_function - Tasklet function

 *

 * @instance: pointer to msix param structure

 *

 * Return Value

 *	None

 hrrq buffer lock */

	/* loop through each of the commands responded by IOA. Each HRRQ buf is

	 * protected by its own lock. Traversals must be done within this lock

	 * as there may be multiple tasklets running on multiple CPUs. Note

	 * that the lock is held just for picking up the response handle and

	 * manipulating hrrq_curr/toggle_bit values.

 In case of invalid response handle, log message */

 loop over until we are done with all responses */

/**

 * pmcraid_unregister_interrupt_handler - de-register interrupts handlers

 * @pinstance: pointer to adapter instance structure

 *

 * This routine un-registers registered interrupt handler and

 * also frees irqs/vectors.

 *

 * Retun Value

 *	None

/**

 * pmcraid_register_interrupt_handler - registers interrupt handler

 * @pinstance: pointer to per-adapter instance structure

 *

 * Return Value

 *	0 on success, non-zero error code otherwise.

/**

 * pmcraid_release_cmd_blocks - release buufers allocated for command blocks

 * @pinstance: per adapter instance structure pointer

 * @max_index: number of buffer blocks to release

 *

 * Return Value

 *  None

/**

 * pmcraid_release_control_blocks - releases buffers alloced for control blocks

 * @pinstance: pointer to per adapter instance structure

 * @max_index: number of buffers (from 0 onwards) to release

 *

 * This function assumes that the command blocks for which control blocks are

 * linked are not released.

 *

 * Return Value

 *	 None

/**

 * pmcraid_allocate_cmd_blocks - allocate memory for cmd block structures

 * @pinstance: pointer to per adapter instance structure

 *

 * Allocates memory for command blocks using kernel slab allocator.

 *

 * Return Value

 *	0 in case of success; -ENOMEM in case of failure

/**

 * pmcraid_allocate_control_blocks - allocates memory control blocks

 * @pinstance : pointer to per adapter instance structure

 *

 * This function allocates PCI memory for DMAable buffers like IOARCB, IOADLs

 * and IOASAs. This is called after command blocks are already allocated.

 *

 * Return Value

 *  0 in case it can allocate all control blocks, otherwise -ENOMEM

/**

 * pmcraid_release_host_rrqs - release memory allocated for hrrq buffer(s)

 * @pinstance: pointer to per adapter instance structure

 * @maxindex: size of hrrq buffer pointer array

 *

 * Return Value

 *	None

 reset pointers and toggle bit to zeros */

/**

 * pmcraid_allocate_host_rrqs - Allocate and initialize host RRQ buffers

 * @pinstance: pointer to per adapter instance structure

 *

 * Return value

 *	0 hrrq buffers are allocated, -ENOMEM otherwise.

/**

 * pmcraid_release_hcams - release HCAM buffers

 *

 * @pinstance: pointer to per adapter instance structure

 *

 * Return value

 *  none

/**

 * pmcraid_allocate_hcams - allocates HCAM buffers

 * @pinstance : pointer to per adapter instance structure

 *

 * Return Value:

 *   0 in case of successful allocation, non-zero otherwise

/**

 * pmcraid_release_config_buffers - release config.table buffers

 * @pinstance: pointer to per adapter instance structure

 *

 * Return Value

 *	 none

/**

 * pmcraid_allocate_config_buffers - allocates DMAable memory for config table

 * @pinstance : pointer to per adapter instance structure

 *

 * Return Value

 *	0 for successful allocation, -ENOMEM for any failure

/**

 * pmcraid_init_tasklets - registers tasklets for response handling

 *

 * @pinstance: pointer adapter instance structure

 *

 * Return value

 *	none

/**

 * pmcraid_kill_tasklets - destroys tasklets registered for response handling

 *

 * @pinstance: pointer to adapter instance structure

 *

 * Return value

 *	none

/**

 * pmcraid_release_buffers - release per-adapter buffers allocated

 *

 * @pinstance: pointer to adapter soft state

 *

 * Return Value

 *	none

/**

 * pmcraid_init_buffers - allocates memory and initializes various structures

 * @pinstance: pointer to per adapter instance structure

 *

 * This routine pre-allocates memory based on the type of block as below:

 * cmdblocks(PMCRAID_MAX_CMD): kernel memory using kernel's slab_allocator,

 * IOARCBs(PMCRAID_MAX_CMD)  : DMAable memory, using pci pool allocator

 * config-table entries      : DMAable memory using dma_alloc_coherent

 * HostRRQs                  : DMAable memory, using dma_alloc_coherent

 *

 * Return Value

 *	 0 in case all of the blocks are allocated, -ENOMEM otherwise.

 allocate DMAable memory for page D0 INQUIRY buffer */

 allocate DMAable memory for set timestamp data buffer */

	/* Initialize all the command blocks and add them to free pool. No

	 * need to lock (free_pool_lock) as this is done in initialization

	 * itself

/**

 * pmcraid_reinit_buffers - resets various buffer pointers

 * @pinstance: pointer to adapter instance

 * Return value

 *	none

/**

 * pmcraid_init_instance - initialize per instance data structure

 * @pdev: pointer to pci device structure

 * @host: pointer to Scsi_Host structure

 * @mapped_pci_addr: memory mapped IOA configuration registers

 *

 * Return Value

 *	 0 on success, non-zero in case of any failure

 Initialize register addresses */

 Initialize chip-specific details */

		/* Current version of firmware exposes interrupt mask set

		 * and mask clr registers through memory mapped bar0.

 Work-queue (Shared) for deferred processing error handling */

 Initialize the default log_level */

 Setup variables required for reset engine */

/**

 * pmcraid_shutdown - shutdown adapter controller.

 * @pdev: pci device struct

 *

 * Issues an adapter shutdown to the card waits for its completion

 *

 * Return value

 *	  none

/*

 * pmcraid_get_minor - returns unused minor number from minor number bitmap

/*

 * pmcraid_release_minor - releases given minor back to minor number bitmap

/**

 * pmcraid_setup_chrdev - allocates a minor number and registers a char device

 *

 * @pinstance: pointer to adapter instance for which to register device

 *

 * Return value

 *	0 in case of success, otherwise non-zero

/**

 * pmcraid_release_chrdev - unregisters per-adapter management interface

 *

 * @pinstance: pointer to adapter instance structure

 *

 * Return value

 *  none

/**

 * pmcraid_remove - IOA hot plug remove entry point

 * @pdev: pci device struct

 *

 * Return value

 *	  none

 remove the management interface (/dev file) for this device */

 remove host template from scsi midlayer */

 block requests from mid-layer */

 initiate shutdown adapter */

/**

 * pmcraid_suspend - driver suspend entry point for power management

 * @dev:   Device structure

 *

 * Return Value - 0 always

/**

 * pmcraid_resume - driver resume entry point PCI power management

 * @dev: Device structure

 *

 * Return Value - 0 in case of success. Error code in case of any failure

	/* Start with hard reset sequence which brings up IOA to operational

	 * state as well as completes the reset sequence.

	/* Start IOA firmware initialization and bring card to Operational

	 * state.

/**

 * pmcraid_complete_ioa_reset - Called by either timer or tasklet during

 *				completion of the ioa reset

 * @cmd: pointer to reset command block

/**

 * pmcraid_set_supported_devs - sends SET SUPPORTED DEVICES to IOAFP

 *

 * @cmd: pointer to pmcraid_cmd structure

 *

 * Return Value

 *  0 for success or non-zero for failure cases

	/* If this was called as part of resource table reinitialization due to

	 * lost CCN, it is enough to return the command block back to free pool

	 * as part of set_supported_devs completion function.

	/* we will be done with the reset sequence after set supported devices,

	 * setup the done function to return the command block back to free

	 * pool

/**

 * pmcraid_set_timestamp - set the timestamp to IOAFP

 *

 * @cmd: pointer to pmcraid_cmd structure

 *

 * Return Value

 *  0 for success or non-zero for failure cases

/**

 * pmcraid_init_res_table - Initialize the resource table

 * @cmd:  pointer to pmcraid command struct

 *

 * This function looks through the existing resource table, comparing

 * it with the config table. This function will take care of old/new

 * devices and schedule adding/removing them from the mid-layer

 * as appropriate.

 *

 * Return value

 *	 None

	/* resource list is protected by pinstance->resource_lock.

	 * init_res_table can be called from probe (user-thread) or runtime

	 * reset (timer/tasklet)

 If this entry was already detected and initialized */

 If this is new entry, initialize it and add it the queue */

		/* copy new configuration table entry details into driver

		 * maintained resource entry

 Detect any deleted entries, mark them for deletion from mid-layer */

 release the resource list lock */

/**

 * pmcraid_querycfg - Send a Query IOA Config to the adapter.

 * @cmd: pointer pmcraid_cmd struct

 *

 * This function sends a Query IOA Configuration command to the adapter to

 * retrieve the IOA configuration table.

 *

 * Return value:

 *	none

 firmware requires 4-byte length field, specified in B.E format */

	/* Since entire config table can be described by single IOADL, it can

	 * be part of IOARCB itself

/**

 * pmcraid_probe - PCI probe entry pointer for PMC MaxRAID controller driver

 * @pdev: pointer to pci device structure

 * @dev_id: pointer to device ids structure

 *

 * Return Value

 *	returns 0 if the device is claimed and successfully configured.

 *	returns non-zero error code in case of any failure

	/* Firmware requires the system bus address of IOARCB to be within

	 * 32-bit addressable range though it has 64-bit IOARRIN register.

	 * However, firmware supports 64-bit streaming DMA buffers, whereas

	 * coherent buffers are to be 32-bit. Since dma_alloc_coherent always

	 * returns memory within 4GB (if not, change this logic), coherent

	 * buffers are within firmware acceptable address ranges.

	/* firmware expects 32-bit DMA addresses for IOARRIN register; set 32

	 * bit mask for dma_alloc_coherent to return addresses within 4GB

 zero out entire instance structure */

 Save PCI config-space for use following the reset */

 allocate verious buffers used by LLD.*/

 check the reset type required */

	/* Start IOA firmware initialization and bring card to Operational

	 * state.

 Add adapter instance into mid-layer list */

	/* Schedule worker thread to handle CCN and take care of adding and

	 * removing devices to OS

/*

 * PCI driver structure of pmcraid driver

/**

 * pmcraid_init - module load entry point

/**

 * pmcraid_exit - module unload entry point

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2010 FUJITSU LIMITED

 * Copyright (C) 2010 Tomohiro Kusumi <kusumi.tomohiro@jp.fujitsu.com>

	/*

	 * From SBC-2: a TRANSFER LENGTH field set to zero specifies that 256

	 * logical blocks shall be read (READ(6)) or written (WRITE(6)).

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * SuperTrak EX Series Storage Controller driver for Linux

 *

 *	Copyright (C) 2005-2015 Promise Technology Inc.

 *

 *	Written By:

 *		Ed Lin <promise_linux@promise.com>

 MU register offset */

 MU_INBOUND_MESSAGE_REG0 */

 MU_INBOUND_MESSAGE_REG1 */

 MU_OUTBOUND_MESSAGE_REG0 */

 MU_OUTBOUND_MESSAGE_REG1 */

 MU_INBOUND_DOORBELL */

 MU_INBOUND_INTERRUPT_STATUS */

 MU_INBOUND_INTERRUPT_MASK */

 MU_OUTBOUND_DOORBELL */

 MU_OUTBOUND_INTERRUPT_STATUS */

 MU_OUTBOUND_INTERRUPT_MASK */

 MU register value */

 MU status code */

 firmware returned values */

 task attribute */

 sg flags */

 end of table */

 64 bit item */

 sg in host memory */

 vendor specific commands of Promise */

 SG_CF_xxx */

 request payload queue physical address */

 size of each request payload */

 count of reqs the buffer can hold */

 size of each status payload */

 count of status the buffer can hold */

 seconds from Jan 1, 1970 (GMT) */

 who sends this frame */

 NEW */

 NEW */

 payload size in 4-byte, not used */

 payload size in 4-byte */

 iomapped PCI memory space */

 temp buffer for driver-handled commands */

 "Promise " */

 "RAID Con" */

 "sole    " */

 "1.00    " */

 "SX/RSAF-" */

 "TE1.00  " */

 "Invalid field in cdb" */

 flush */

 flush */

 flush */

		/*

		 * The shasta firmware does not report actual luns in the

		 * target, so fail the command to force sequential lun scan.

		 * Also, the console device does not support this command.

 cdb */

 status payloads */

	/*

	 * it's not a valid status payload if:

	 * 1. there are no pending requests(e.g. during init stage)

	 * 2. there are some pending requests, but the controller is in

	 *     reset status, and its type is not st_yosemite

	 * firmware of st_yosemite in reset status will return pending requests

	 * to driver, so we allow it to pass

 payload size */

 copy size */

 flush */

 clear the interrupt */

 flush */

 normal case */

 clear the interrupt */

 clear the interrupt */

 old fw compatible */

 flush */

 flush */

 flush */

 P3 MSI Register cannot access twice */

 flush */

 nullify the req's future return */

	/* Reset secondary bus. Our controller(MU/ATU) is the only device on

	/*

	 * 1 ms may be enough for 8-port controllers. But 16-port controllers

	 * require more time to finish bus reset. Use 100 ms here for safety

 flush */

 st_shasta */

 SuperTrak EX8350/8300/16350/16300 */

 SuperTrak EX12350 */

 SuperTrak EX4350 */

 SuperTrak EX24350 */

 st_vsc */

 st_yosemite */

 st_seq */

 st_yel */

 st_P3, pluto */

 st_P3, p3 */

 st_P3, SymplyStor4E */

 st_P3, SymplyStor8E */

 st_P3, SymplyStor4 */

 st_P3, SymplyStor8 */

 terminate list */

 st_shasta */

 st_vsc */

 st_yosemite */

 st_seq */

 st_yel */

 st_P3 */

 Retry minimum coherent mapping for st_seq and st_vsc */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *      sd.c Copyright (C) 1992 Drew Eckhardt

 *           Copyright (C) 1993, 1994, 1995, 1999 Eric Youngdale

 *

 *      Linux scsi disk driver

 *              Initial versions: Drew Eckhardt

 *              Subsequent revisions: Eric Youngdale

 *	Modification history:

 *       - Drew Eckhardt <drew@colorado.edu> original

 *       - Eric Youngdale <eric@andante.org> add scatter-gather, multiple 

 *         outstanding request, and other enhancements.

 *         Support loadable low-level scsi drivers.

 *       - Jirka Hanika <geo@ff.cuni.cz> support more scsi disks using 

 *         eight major numbers.

 *       - Richard Gooch <rgooch@atnf.csiro.au> support devfs.

 *	 - Torben Mathiasen <tmm@image.dk> Resource allocation fixes in 

 *	   sd_init and cleanups.

 *	 - Alex Davis <letmein@erols.com> Fix problem where partition info

 *	   not being read in sd_open. Fix problem where removable media 

 *	   could be ejected after sd_open.

 *	 - Douglas Gilbert <dgilbert@interlog.com> cleanup for lk 2.5.x

 *	 - Badari Pulavarty <pbadari@us.ibm.com>, Matthew Wilcox 

 *	   <willy@debian.org>, Kurt Garloff <garloff@suse.de>: 

 *	   Support 32k/1M disks.

 *

 *	Logging policy (needs CONFIG_SCSI_LOGGING defined):

 *	 - setting up transfer: SCSI_LOG_HLQUEUE levels 1 and 2

 *	 - end of transfer (bh + scsi_lib): SCSI_LOG_HLCOMPLETE level 1

 *	 - entering sd_ioctl: SCSI_LOG_IOCTL level 1

 *	 - entering other commands: SCSI_LOG_HLQUEUE level 3

 *	Note: when the logging level is set by the user, it must be greater

 *	than the level indicated above to trigger output.	

/* This semaphore is used to mediate the 0->1 reference get in the

 * face of object destruction (i.e. we can't allow a get on an

		/* no cache control on RBC devices; theoretically they

		 * can do it, but there's probably so many exceptions

	/*

	 * Ensure WP, DPOFUA, and RESERVED fields are cleared in

	 * received mode parameter buffer before doing MODE SELECT.

 sysfs_match_string() requires dense arrays */

 sysfs_match_string() requires dense arrays */

/*

 * Don't request a new module, as that could deadlock in multipath

 * environment.

/*

 * Device no to disk mapping:

 * 

 *       major         disc2     disc  p1

 *   |............|.............|....|....| <- dev_t

 *    31        20 19          8 7  4 3  0

 * 

 * Inside a major, we have 16k disks, however mapped non-

 * contiguously. The first 16 disks are for major0, the next

 * ones with major1, ... Disk 256 is for major0 again, disk 272 

 * for major1, ... 

 * As we stay compatible with our numbering scheme, we can reuse 

 * the well-know SCSI majors 8, 65--71, 136--143.

 shut up gcc */

 CONFIG_BLK_SED_OPAL */

/*

 * Look up the DIX operation based on whether the command is read or

 * write and whether dix and dif are enabled.

 Lookup table: bit 2 (write), bit 1 (dix), bit 0 (dif) */

 wrt dix dif */

  0	0   0  */

  0	0   1  */

  0	1   0  */

  0	1   1  */

  1	0   0  */

  1	0   1  */

  1	1   0  */

  1	1   1  */

/*

 * Returns a mask of the protection flags that are valid for a given DIX

 * operation.

 DIX Type 0, 1, 2, 3 */

 DIX/DIF Type 0, 1, 2 */

 DIX/DIF Type 1, 2, 3 */

 Disable target PI checking */

 Enable target PI checking */

 UNMAP */

 UNMAP */

	/* Some devices can not handle block counts above 0xffff despite

	 * supporting WRITE SAME(16). Consequently we default to 64k

	 * blocks per I/O unless the device explicitly advertises a

	 * bigger limit.

		/*

		 * Reporting a maximum number of blocks that is not aligned

		 * on the device physical size would cause a large write same

		 * request to be split into physically unaligned chunks by

		 * __blkdev_issue_write_zeroes() and __blkdev_issue_write_same()

		 * even if the caller of these functions took care to align the

		 * large request. So make sure the maximum reported is aligned

		 * to the device physical block size. This is only an optional

		 * optimization for regular disks, but this is mandatory to

		 * avoid failure of large write same requests directed at

		 * sequential write required zones of host-managed ZBC disks.

/**

 * sd_setup_write_same_cmnd - write the same data to multiple blocks

 * @cmd: command to prepare

 *

 * Will set up either WRITE SAME(10) or WRITE SAME(16) depending on

 * the preference indicated by the target device.

	/*

	 * For WRITE SAME the data transferred via the DATA OUT buffer is

	 * different from the amount of data actually written to the target.

	 *

	 * We set up __data_len to the amount of data transferred via the

	 * DATA OUT buffer so that blk_rq_map_sg sets up the proper S/G list

	 * to transfer a single sector of data first, but then reset it to

	 * the amount of data to be written right after so that the I/O path

	 * knows how much to actually write.

 flush requests don't perform I/O, zero the S/G table */

 Additional CDB len */

 Expected Indirect LBA */

 Avoid that 0 blocks gets translated into 256 blocks. */

		/*

		 * This happens only if this drive failed 10byte rw

		 * command with ILLEGAL_REQUEST during operation and

		 * thus turned off use_10_for_rw.

	/*

	 * Some SD card readers can't handle accesses which touch the

	 * last one or two logical blocks. Split accesses as needed.

 Access up to the threshold but not beyond */

 Access only a single logical block */

	/*

	 * We shouldn't disconnect in the middle of a sector, so with a dumb

	 * host adapter, it's safe to assume that we can at least transfer

	 * this many bytes between each connect / disconnect.

	/*

	 * This indicates that the command is ready from our end to be queued.

	/*

	 * Force a full rescan after ioctl(BLKRRPART).  While the disk state has

	 * nothing to do with partitions, BLKRRPART is used to force a full

	 * revalidate after things like a format for historical reasons.

/**

 *	sd_open - open a scsi disk device

 *	@bdev: Block device of the scsi disk to open

 *	@mode: FMODE_* mask

 *

 *	Returns 0 if successful. Returns a negated errno value in case 

 *	of error.

 *

 *	Note: This can be called from a user context (e.g. fsck(1) )

 *	or from within the kernel (e.g. as a result of a mount(1) ).

 *	In the latter case @inode and @filp carry an abridged amount

 *	of information as noted above.

 *

 *	Locking: called with bdev->bd_disk->open_mutex held.

	/*

	 * If the device is in error recovery, wait until it is done.

	 * If the device is offline, then disallow any access to it.

	/*

	 * If the drive is empty, just let the open fail.

	/*

	 * If the device has the write protect tab set, have the open fail

	 * if the user expects to be able to write to the thing.

	/*

	 * It is possible that the disk changing stuff resulted in

	 * the device being taken offline.  If this is the case,

	 * report this to the user, and don't pretend that the

	 * open actually succeeded.

/**

 *	sd_release - invoked when the (last) close(2) is called on this

 *	scsi disk.

 *	@disk: disk to release

 *	@mode: FMODE_* mask

 *

 *	Returns 0. 

 *

 *	Note: may block (uninterruptible) if error recovery is underway

 *	on this disk.

 *

 *	Locking: called with bdev->bd_disk->open_mutex held.

 default to most commonly used values */

 1 << 6 */

 1 << 5 */

 override with calculated, extended default, or driver values */

/**

 *	sd_ioctl - process an ioctl

 *	@bdev: target block device

 *	@mode: FMODE_* mask

 *	@cmd: ioctl command number

 *	@arg: this is third argument given to ioctl(2) system call.

 *	Often contains a pointer.

 *

 *	Returns 0 if successful (some ioctls return positive numbers on

 *	success as well). Returns a negated errno value in case of error.

 *

 *	Note: most ioctls are forward onto the block subsystem or further

 *	down in the scsi subsystem.

	/*

	 * If we are in the middle of error recovery, don't let anyone

	 * else try and use this device.  Also, if error recovery fails, it

	 * may try and take the device offline, in which case all further

	 * access to the device is prohibited.

 not invoked for commands that could return deferred errors */

 medium not present */

/**

 *	sd_check_events - check media events

 *	@disk: kernel device descriptor

 *	@clearing: disk events currently being cleared

 *

 *	Returns mask of DISK_EVENT_*.

 *

 *	Note: this function is invoked from the block subsystem.

	/*

	 * If the device is offline, don't send any commands - just pretend as

	 * if the command failed.  If the device ever comes back online, we

	 * can deal with it then.  It is only because of unrecoverable errors

	 * that we would ever take a device offline in the first place.

	/*

	 * Using TEST_UNIT_READY enables differentiation between drive with

	 * no cartridge loaded - NOT READY, drive with changed cartridge -

	 * UNIT ATTENTION, or with same cartridge - GOOD STATUS.

	 *

	 * Drives that auto spin down. eg iomega jaz 1G, will be started

	 * by sd_spinup_disk() from sd_revalidate_disk(), which happens whenever

	 * sd_revalidate() is called.

 failed to execute TUR, assume media not present */

	/*

	 * For removable scsi disk we have to recognise the presence

	 * of a disk in the drive.

	/*

	 * sdp->changed is set under the following conditions:

	 *

	 *	Medium present state has changed in either direction.

	 *	Device has indicated UNIT_ATTENTION.

 caller might not be interested in sense, but we need it */

		/*

		 * Leave the rest of the command zero to indicate

		 * flush everything.

 we need to evaluate the error return  */

 medium not present */

 invalid command */

 drive is password locked */

 this is no error here */

 ignore errors due to racing a disconnection */

 signal the upper layer it might try again */

 we only care about designators with LU association */

		/*

		 * Only exit early if a 16-byte descriptor was found.  Otherwise

		 * keep looking as one with more entropy might still show up.

 APTPL */);

/**

 *	sd_eh_reset - reset error handling callback

 *	@scmd:		sd-issued command that has failed

 *

 *	This function is called by the SCSI midlayer before starting

 *	SCSI EH. When counting medium access failures we have to be

 *	careful to register it only only once per device and SCSI EH run;

 *	there might be several timed out commands which will cause the

 *	'max_medium_access_timeouts' counter to trigger after the first

 *	SCSI EH run already and set the device to offline.

 *	So this function resets the internal counter before starting SCSI EH.

 New SCSI EH run, reset gate variable */

/**

 *	sd_eh_action - error handling callback

 *	@scmd:		sd-issued command that has failed

 *	@eh_disp:	The recovery disposition suggested by the midlayer

 *

 *	This function is called by the SCSI midlayer upon completion of an

 *	error test command (currently TEST UNIT READY). The result of sending

 *	the eh command is passed in eh_disp.  We're looking for devices that

 *	fail medium access commands but are OK with non access commands like

 *	test unit ready (so wrongly see the device as having a successful

 *	recovery)

	/*

	 * The device has timed out executing a medium access command.

	 * However, the TEST UNIT READY command sent during error

	 * handling completed successfully. Either the device is in the

	 * process of recovering or has it suffered an internal failure

	 * that prevents access to the storage medium.

	/*

	 * If the device keeps failing read/write commands but TEST UNIT

	 * READY always completes successfully we assume that medium

	 * access is no longer possible and take the device offline.

	/*

	 * Some commands have a payload smaller than the device logical

	 * block size (e.g. INQUIRY on a 4K disk).

 Check if we have a 'bad_lba' information */

	/*

	 * If the bad lba was reported incorrectly, we have no idea where

	 * the error is.

	/*

	 * resid is optional but mostly filled in.  When it's unused,

	 * its value is zero, so we assume the whole buffer transferred

	/* This computation should always be done in terms of the

	 * resolution of the device's medium.

/**

 *	sd_done - bottom half handler: called when the lower level

 *	driver has completed (successfully or otherwise) a scsi command.

 *	@SCpnt: mid-level's per command structure.

 *

 *	Note: potentially run from within an ISR. Must not block.

		/*

		 * In case of bogus fw or device, we could end up having

		 * an unaligned partial completion. Check this here and force

		 * alignment.

		/* This indicates a false check condition, so ignore it.  An

		 * unknown amount of data was transferred so treat it as an

		 * error.

 DIF: Target detected corruption */

 DIX: Host detected corruption */

 INVALID COMMAND OPCODE */

 INVALID FIELD IN CDB */

 UNMAP */

/*

 * spinup disk - called only in sd_revalidate_disk()

 Spin up drives, as required.  Only do this at boot time */

 Spinup needs to be done for module loads too. */

			/*

			 * If the drive has indicated to us that it

			 * doesn't have any media in it, don't bother

			 * with any more polling.

			/* no sense, TUR either succeeded or failed

		/*

		 * The device does not want the automatic start to be issued.

 manual intervention required */

 standby */

 unavailable */

 sanitize in progress */

			/*

			 * Issue command to spin up drive when not ready

 Return immediately */

 Start spin cycle */

 Wait 1 second for next try */

		/*

		 * Wait for USB flash devices with slow firmware.

		 * Yes, this sense key/ASC combination shouldn't

		 * occur here.  It's characteristic of these devices.

 Wait 1 second for next try */

			/* we don't understand the sense code, so it's

/*

 * Determine whether disk supports Data Integrity Field.

 P_TYPE 0 = Type 1 */

	/*

	 * Set dirty bit for removable devices if not ready -

	 * sometimes drives will not report this properly.

	/*

	 * We used to set media_present to 0 here to indicate no media

	 * in the drive, but some drives fail read capacity even with

	 * media present, so we can't do that.

 unknown mapped to zero - as usual */

				/* Invalid Command Operation Code or

				 * Invalid Field in CDB, just retry

				/* Device reset might occur several times,

 Logical blocks per physical block exponent */

 RC basis */

 Lowest aligned logical block */

 LBPME */

 LBPRZ */

				/* Device reset might occur several times,

		/* Some buggy (usb cardreader) devices return an lba of

		   0xffffffff when the want to report a size of 0 (with

/*

 * read disk capacity

 Remember that READ CAPACITY(16) succeeded */

	/* Some devices are known to return the total number of blocks,

	 * not the highest block number.  Some devices have versions

	 * which do this and others which do not.  Some devices we might

	 * suspect of doing this but we don't know for certain.

	 *

	 * If we know the reported capacity is wrong, decrement it.  If

	 * we can only guess, then assume the number of blocks is even

	 * (usually true but not always) and err on the side of lowering

	 * the capacity.

		/*

		 * The user might want to re-format the drive with

		 * a supported sectorsize.  Once this happens, it

		 * would be relatively trivial to set the thing up.

		 * For this reason, we leave the thing in the table.

		/*

		 * set a bogus sector size so the normal read/write

		 * logic in the block layer will eventually refuse any

		 * request on this device without tripping over power

		 * of two sector size assumptions

/*

 * Print disk capacity

 called with buffer of length 512 */

	/*

	 * If we must use MODE SENSE(10), make sure that the buffer length

	 * is at least 8 bytes so that the mode sense header fits.

/*

 * read write protect setting, if possible - called only in sd_revalidate_disk()

 * called with buffer of length SD_BUF_SIZE

		/*

		 * First attempt: ask for all pages (0x3F), but only 4 bytes.

		 * We have to start carefully: some devices hang if we ask

		 * for more than is available.

		/*

		 * Second attempt: ask for page 0 When only page 0 is

		 * implemented, a request for page 3F may return Sense Key

		 * 5: Illegal Request, Sense Code 24: Invalid field in

		 * CDB.

		/*

		 * Third attempt: ask 255 bytes, as we did earlier.

/*

 * sd_read_cache_type - called only from sd_revalidate_disk()

 * called with buffer of length SD_BUF_SIZE

 cautiously ask */

 that went OK, now ask for the proper length */

	/*

	 * We're only interested in the first three bytes, actually.

	 * But the data cache page is defined for the first 20.

 Get the data */

				/* We're interested only in the first 3 bytes.

 Go to the next page */

 No cache flush allowed for write protected devices */

 Invalid field in CDB */

/*

 * The ATO bit indicates whether the DIF application tag is available

 * for use by the operating system.

/**

 * sd_read_block_limits - Query disk device for preferred I/O sizes.

 * @sdkp: disk to query

 Block Limits VPD */

 LBP VPD page not provided */

 LBP VPD page tells us what to use */

/**

 * sd_read_block_characteristics - Query block dev. characteristics

 * @sdkp: disk to query

 Block Device Characteristics VPD */

 Host-managed */

 Host-aware */

 Regular disk or drive managed disk */

/**

 * sd_read_block_provisioning - Query provisioning VPD page

 * @sdkp: disk to query

 UNMAP */

 WRITE SAME(16) with UNMAP */

 WRITE SAME(10) with UNMAP */

 too large values might cause issues with arcmsr */

		/* Disable WRITE SAME if REPORT SUPPORTED OPERATION

		 * CODES is unsupported and the device has an ATA

		 * Information VPD page (SAT).

/**

 * sd_read_cpr - Query concurrent positioning ranges

 * @sdkp:	disk to query

	/*

	 * We need to have the capacity set first for the block layer to be

	 * able to check the ranges.

	/*

	 * Concurrent Positioning Ranges VPD: there can be at most 256 ranges,

	 * leading to a maximum page size of 64 + 256*32 bytes.

 We must have at least a 64B header and one 32B range descriptor */

/*

 * Determine the device's preferred I/O size for reads and writes

 * unless the reported value is unreasonably small, large, not a

 * multiple of the physical block size, or simply garbage.

/**

 *	sd_revalidate_disk - called the first time a new disk is seen,

 *	performs disk spin up, read_capacity, etc.

 *	@disk: struct gendisk we care about

	/*

	 * If the device is offline, don't try and read capacity or any

	 * of the other niceties.

	/*

	 * Without media there is no reason to ask; moreover, some devices

	 * react badly if we do.

		/*

		 * set the default to rotational.  All non-rotational devices

		 * support the block characteristics VPD page, which will

		 * cause this to be updated correctly and any device which

		 * doesn't support it should be treated as rotational.

	/*

	 * We now have all cache related info, determine how we deal

	 * with flush requests.

 Initial block count limit based on CDB TRANSFER LENGTH field size. */

 Some devices report a maximum block count for READ/WRITE requests. */

 Do not exceed controller limit */

	/*

	 * Only update max_sectors if previously unset or if the current value

	 * exceeds the capabilities of the hardware.

	/*

	 * For a zoned drive, revalidating the zones can be done only once

	 * the gendisk capacity is set. So if this fails, set back the gendisk

	 * capacity to 0.

/**

 *	sd_unlock_native_capacity - unlock native capacity

 *	@disk: struct gendisk to set capacity for

 *

 *	Block layer calls this function if it detects that partitions

 *	on @disk reach beyond the end of the device.  If the SCSI host

 *	implements ->unlock_native_capacity() method, it's invoked to

 *	give it a chance to adjust the device capacity.

 *

 *	CONTEXT:

 *	Defined by block layer.  Might sleep.

/**

 *	sd_format_disk_name - format disk name

 *	@prefix: name prefix - ie. "sd" for SCSI disks

 *	@index: index of the disk to format name for

 *	@buf: output buffer

 *	@buflen: length of the output buffer

 *

 *	SCSI disk names starts at sda.  The 26th device is sdz and the

 *	27th is sdaa.  The last one for two lettered suffix is sdzz

 *	which is followed by sdaaa.

 *

 *	This is basically 26 base counting with one extra 'nil' entry

 *	at the beginning from the second digit on and can be

 *	determined using similar method as 26 base conversion with the

 *	index shifted -1 after each digit is computed.

 *

 *	CONTEXT:

 *	Don't care.

 *

 *	RETURNS:

 *	0 on success, -errno on failure.

/**

 *	sd_probe - called during driver initialization and whenever a

 *	new scsi device is attached to the system. It is called once

 *	for each scsi device (not just disks) present.

 *	@dev: pointer to device object

 *

 *	Returns 0 if successful (or not interested in this scsi device 

 *	(e.g. scanner)); 1 when there is an error.

 *

 *	Note: this function is invoked from the scsi mid-level.

 *	This function sets up the mapping between a given 

 *	<host,channel,id,lun> (found in sdp) and new device name 

 *	(e.g. /dev/sda). More precisely it is the block device major 

 *	and minor number that is chosen here.

 *

 *	Assume sd_probe is not re-entrant (for time being)

 *	Also think about sd_probe() and sd_remove() running coincidentally.

 defaults, until the device tells us otherwise */

/**

 *	sd_remove - called whenever a scsi disk (previously recognized by

 *	sd_probe) is detached from the system. It is called (potentially

 *	multiple times) during sd module unload.

 *	@dev: pointer to device object

 *

 *	Note: this function is invoked from the scsi mid-level.

 *	This function potentially frees up a device name (e.g. /dev/sdc)

 *	that could be re-used by a subsequent sd_probe().

 *	This function is not called when the built-in sd driver is "exit-ed".

/**

 *	scsi_disk_release - Called to free the scsi_disk structure

 *	@dev: pointer to embedded class device

 *

 *	sd_ref_mutex must be held entering this routine.  Because it is

 *	called on last put, you should always use the scsi_disk_get()

 *	scsi_disk_put() helpers which manipulate the semaphore directly

 *	and never do a direct put_device.

	/*

	 * Wait until all requests that are in progress have completed.

	 * This is necessary to avoid that e.g. scsi_end_request() crashes

	 * due to clearing the disk->private_data pointer. Wait from inside

	 * scsi_disk_release() instead of from sd_release() to avoid that

	 * freezing and unfreezing the request queue affects user space I/O

	 * in case multiple processes open a /dev/sd... node concurrently.

 START_VALID */

 START */

 Active or Standby */

 0x3a is medium not present */

 SCSI error codes must not go to the generic layer */

/*

 * Send a SYNCHRONIZE CACHE instruction down to the device through

 * the normal SCSI command structure.  Wait for the command to

 * complete.

 this can happen */

 E.g.: runtime suspend following sd_remove() */

 ignore OFFLINE device */

			/*

			 * sshdr.sense_key == ILLEGAL_REQUEST means this drive

			 * doesn't support sync. There's not much to do and

			 * suspend shouldn't fail.

 an error is not worth aborting a system sleep */

 E.g.: runtime resume at the start of sd_probe() */

 E.g.: runtime resume at the start of sd_probe() */

 clear the device's sense data */

/**

 *	init_sd - entry point for this driver (both when built in or when

 *	a module).

 *

 *	Note: this function registers this driver with the scsi mid-level.

/**

 *	exit_sd - exit point for this driver (when it is a module).

 *

 *	Note: this function unregisters this driver from the scsi mid-level.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * NinjaSCSI-32Bi Cardbus, NinjaSCSI-32UDE PCI/CardBus SCSI driver

 * Copyright (C) 2001, 2002, 2003

 *      YOKOTA Hiroshi <yokota@netlab.is.tsukuba.ac.jp>

 *      GOTO Masanori <gotom@debian.or.jp>, <gotom@debian.org>

 *

 * Revision History:

 *   1.0: Initial Release.

 *   1.1: Add /proc SDTR status.

 *        Remove obsolete error handler nsp32_reset.

 *        Some clean up.

 *   1.2: PowerPC (big endian) support.

/***********************************************************************

 * Module parameters

 default: BIOS */

 default: ON */

 default: OFF */

/****************************************************************************

 * Supported hardware

 probe <-> detect glue */

/*

 * Period/AckWidth speed conversion table

 *

 * Note: This period/ackwidth speed table must be in descending order.

 {PNo, AW,   SP,   EP, SREQ smpl}  Speed(MB/s) Period AckWidth */

  20.0 :  50ns,  25ns */

  13.3 :  75ns,  25ns */

  10.0 : 100ns,  50ns */

   8.0 : 125ns,  50ns */

   6.7 : 150ns,  75ns */

   5.7 : 175ns,  75ns */

   5.0 : 200ns, 100ns */

   4.4 : 225ns, 100ns */

   4.0 : 250ns, 100ns */

 10.0 : 100ns,  50ns */

  6.7 : 150ns,  50ns */

  5.0 : 200ns, 100ns */

  4.0 : 250ns, 100ns */

  3.3 : 300ns, 150ns */

  2.8 : 350ns, 150ns */

  2.5 : 400ns, 200ns */

  2.2 : 450ns, 200ns */

  2.0 : 500ns, 200ns */

 16.6 :  60ns,  30ns */

 11.1 :  90ns,  30ns */

  8.3 : 120ns,  60ns */

  6.7 : 150ns,  60ns */

  5.6 : 180ns,  90ns */

  4.8 : 210ns,  90ns */

  4.2 : 240ns, 120ns */

  3.7 : 270ns, 120ns */

  3.3 : 300ns, 120ns */

/*

 * function declaration

 module entry point */

 struct struct scsi_host_template */

 SCSI error handler */

 generate SCSI message */

 SCSI message handler */

 SCSI SDTR */

 SCSI bus status handler */

 hardware interrupt handler */

 initialize hardware */

 EEPROM handler */

 debug/warning/info message */

/*

 * max_sectors is currently limited up to 128.

	.highmem_io			= 1, */

/***********************************************************************

 * debug, error print

 */

 */

 */

 */

/*

 * IDENTIFY Message

 XXX: Auto DiscPriv detection is progressing... */

 mode = TRUE; */

/*

 * SDTR Message Routine

/*

 * No Operation Message

/*

 * Reject Message

/*

 * timer

/*

 * set SCSI command and other parameter to asic, and start selection phase

	/*

	 * check bus free

	/*

	 * message out

	 *

	 * Note: If the range of msgout_len is 1 - 3, fill scsi_msgout.

	 *       over 3 messages needs another routine.

			/*

			 * the sending order of the message is:

			 *  MCNT 3: MSG#0 -> MSG#1 -> MSG#2

			 *  MCNT 2:          MSG#1 -> MSG#2

			 *  MCNT 1:                   MSG#2

 MV valid */

 len */

 data->msgout_len > 3 */

 nsp_dbg(NSP32_DEBUG_AUTOSCSI, "sel time out=0x%x\n",

 nsp32_read2(base, SEL_TIME_OUT));

 nsp32_write2(base, SEL_TIME_OUT,   SEL_TIMEOUT_TIME);

	/*

	 * setup asic parameter

 cdb */

 outgoing messages */

 syncreg, ackwidth, target id, SREQ sampling rate */

 nsp32_dbg(NSP32_DEBUG_AUTOSCSI, "sample rate=0x%x\n", data->cur_target->sample_reg);

 command control */

 transfer control */

	/*

	 * OR-ed BLIEND_MODE, FIFO intr is decreased, instead of PCI bus waits.

	 * For bus master transfer, it's taken off.

 sg table addr */

	/*

	 * transfer parameter to ASIC

	/*

	 * Check arbitration

/*

 * Selection with AUTO SCSI (without AUTO PARAMETER)

	/*

	 * IRQ disable

	/*

	 * check bus line

	/*

	 * clear execph

	/*

	 * clear FIFO counter to set CDBs

	/*

	 * set CDB0 - CDB15

	/*

	 * set SCSIOUT LATCH(initiator)/TARGET(target) (OR-ed) ID

	/*

	 * set SCSI MSGOUT REG

	 *

	 * Note: If the range of msgout_len is 1 - 3, fill scsi_msgout.

	 *       over 3 messages needs another routine.

			/*

			 * the sending order of the message is:

			 *  MCNT 3: MSG#0 -> MSG#1 -> MSG#2

			 *  MCNT 2:          MSG#1 -> MSG#2

			 *  MCNT 1:                   MSG#2

 MV valid */

 len */

 data->msgout_len > 3 */

	/*

	 * set selection timeout(= 250ms)

	/*

	 * set SREQ hazard killer sampling rate

	 *

	 * TODO: sample_rate (BASE+0F) is 0 when internal clock = 40MHz.

	 *      check other internal clock!

	/*

	 * clear Arbit

	/*

	 * set SYNCREG

	 * Don't set BM_START_ADR before setting this register.

	/*

	 * set ACKWIDTH

	/*

	 * set SGT ADDR (physical address)

	/*

	 * set TRANSFER CONTROL REG

	/*

	 * start AUTO SCSI, kick off arbitration

	/*

	 * Check arbitration

	/*

	 * IRQ enable

/*

 * Arbitration Status Check

 *

 * Note: Arbitration counter is waited during ARBIT_GO is not lifting.

 *	 Using udelay(1) consumes CPU time and system time, but

 *	 arbitration delay time is defined minimal 2.4us in SCSI

 *	 specification, thus udelay works as coarse grained wait timer.

 Arbitration succeeded */

 PCI LED on */

 Arbitration failed */

		/*

		 * unknown error or ARBIT_GO timeout,

		 * something lock up! guess no connection.

	/*

	 * clear Arbit

/*

 * reselection

 *

 * Note: This reselection routine is called from msgin_occur,

 *	 reselection target id&lun must be already set.

 *	 SCSI-2 says IDENTIFY implies RESTORE_POINTER operation.

	/*

	 * calculate reselected SCSI ID

	/*

	 * If reselected New ID:LUN is not existed

	 * or current nexus is not existed, unexpected

	 * reselection is occurred. Send reject message.

 reset SACK/SavedACK counter (or ALL clear?) */

/*

 * nsp32_setup_sg_table - build scatter gather list for transfer data

 *			    with bus master.

 *

 * Note: NinjaSCSI-32Bi/UDE bus master can not transfer over 64KB at a time.

			/*

			 * Build nsp32_sglist, substitute sg dma addresses.

 set end mark */

 check target ID is not same as this initiator ID */

 check target LUN is allowable value */

 initialize data */

 Build IDENTIFY */

	/*

	 * If target is the first time to transfer after the reset

	 * (target don't have SDTR_DONE and SDTR_INITIATOR), sync

	 * message SDTR is needed to do synchronous transfer.

		/*

		 * It was negotiating SDTR with target, sending from the

		 * initiator, but there are no chance to remove this flag.

		 * Set async because we don't get proper negotiation.

		/*

		 * It was negotiating SDTR with target, sending from target,

		 * but there are no chance to remove this flag.  Set async

		 * because we don't get proper negotiation.

 Selection */

 initialize asic */

	/*

	 * Fill FIFO_FULL_SHLD, FIFO_EMPTY_SHLD. Below parameter is

	 *  designated by specification.

 parity check is disable */

	/*

	 * initialize MISC_WRRD register

	 *

	 * Note: Designated parameters is obeyed as following:

	 *	MISC_SCSI_DIRECTION_DETECTOR_SELECT: It must be set.

	 *	MISC_MASTER_TERMINATION_SELECT:      It must be set.

	 *	MISC_BMREQ_NEGATE_TIMING_SEL:	     It should be set.

	 *	MISC_AUTOSEL_TIMING_SEL:	     It should be set.

	 *	MISC_BMSTOP_CHANGE2_NONDATA_PHASE:   It should be set.

	 *	MISC_DELAYED_BMSTART:		     It's selected for safety.

	 *

	 * Note: If MISC_BMSTOP_CHANGE2_NONDATA_PHASE is set, then

	 *	we have to set TRANSFERCONTROL_BM_START as 0 and set

	 *	appropriate value before restarting bus master transfer.

 Required 2 times */

	/*

	 * enable to select designated IRQ (except for

	 * IRQSELECT_SERR, IRQSELECT_PERR, IRQSELECT_BMCNTERR)

   IRQSELECT_BMCNTERR_IRQ      |

 PCI LED off */

 interrupt routine */

	/*

	 * IRQ check, then enable IRQ mask

 is this interrupt comes from Ninja asic? */

 Timer IRQ */

 SCSI reset */

	/*

	 * AutoSCSI Interrupt.

	 * Note: This interrupt is occurred when AutoSCSI is finished.  Then

	 * check SCSIEXECUTEPHASE, and do appropriate action.  Each phases are

	 * recorded when AutoSCSI sequencer has been processed.

 getting SCSI executed phase */

 Selection Timeout, go busfree phase. */

			/*

			 * MsgOut phase was processed.

			 * If MSG_IN_OCCUER is not set, then MsgOut phase is

			 * completed. Thus, msgout_len must reset.  Otherwise,

			 * nothing to do here. If MSG_OUT_OCCUER is occurred,

			 * then we will encounter the condition and check.

				/*

				 * !MSG_IN_OCCUER && msgout_len <=3

				 *   ---> AutoSCSI with MSGOUTreg is processed.

nsp32_pio_read(SCpnt);

 DATA_IN_PHASE/DATA_OUT_PHASE was processed. */

 read BMCNT, SGT pointer addr */

 all data transferred! */

		/*

		 * MsgIn Occur

		/*

		 * MsgOut Occur

		/*

		 * Bus Free Occur

			/*

			 * Read CSB and substitute CSB for SCpnt->result

			 * to save status phase stutas byte.

			 * scsi error handler checks host_byte (DID_*:

			 * low level driver to indicate status), then checks

			 * status_byte (SCSI status byte).

 Illegal phase is detected. SACK is not back. */

 TODO: currently we don't have any action... bus reset? */

			/*

			 * To send back SACK, assert, wait, and negate.

 nothing to do */

 AutoSCSI is running */

 FIFO_SHLD_IRQ */

nsp32_pio_write(SCpnt);

nsp32_pio_read(SCpnt);

 Phase Change IRQ */

 PCI_IRQ */

 Do nothing */

 BMCNTERR_IRQ */

		/*

		 * TODO: To be implemented improving bus master

		 * transfer reliability when BMCNTERR is occurred in

		 * AutoSCSI phase described in specification.

 disable IRQ mask */

/*

 * Reset parameters and call scsi_done for data->cur_lunt.

 * Be careful setting SCpnt->result = DID_* before calling this function.

	/*

	 * clear TRANSFERCONTROL_BM_START

	/*

	 * call scsi_done

	/*

	 * reset parameters

/*

 * Bus Free Occur

 *

 * Current Phase is BUSFREE. AutoSCSI is automatically execute BUSFREE phase

 * with ACK reply when below condition is matched:

 *	MsgIn 00: Command Complete.

 *	MsgIn 02: Save Data Pointer.

 *	MsgIn 04: Disconnect.

 * In other case, unexpected BUSFREE is detected.

	/*

	 * MsgIn 02: Save Data Pointer

	 *

	 * VALID:

	 *   Save Data Pointer is received. Adjust pointer.

	 *

	 * NO-VALID:

	 *   SCSI-3 says if Save Data Pointer is not received, then we restart

	 *   processing and we can't adjust any SCSI data pointer in next data

	 *   phase.

		/*

		 * Check sack_cnt/saved_sack_cnt, then adjust sg table if

		 * needed.

			/*

			 * Read SACK count and SAVEDSACK count, then compare.

			/*

			 * If SAVEDSACKCNT == 0, it means SavedDataPointer is

			 * come after data transferring.

				/*

				 * Comparing between sack and savedsack to

				 * check the condition of AutoMsgIn03.

				 *

				 * If they are same, set msgin03 == TRUE,

				 * COMMANDCONTROL_AUTO_MSGIN_03 is enabled at

				 * reselection.  On the other hand, if they

				 * aren't same, set msgin03 == FALSE, and

				 * COMMANDCONTROL_AUTO_MSGIN_03 is disabled at

				 * reselection.

 This value has not substitude with valid value yet... */

data->cur_lunt->save_datp = data->cur_datp;

		/*

		 * no processing.

 MsgIn03 was valid to be processed. No need processing. */

	/*

	 * target SDTR check

		/*

		 * SDTR negotiation pulled by the initiator has not

		 * finished yet. Fall back to ASYNC mode.

		/*

		 * SDTR negotiation pulled by the target has been

		 * negotiating.

			/*

			 * If valid message is received, then

			 * negotiation is succeeded.

			/*

			 * On the contrary, if unexpected bus free is

			 * occurred, then negotiation is failed. Fall

			 * back to ASYNC mode.

	/*

	 * It is always ensured by SCSI standard that initiator

	 * switches into Bus Free Phase after

	 * receiving message 00 (Command Complete), 04 (Disconnect).

	 * It's the reason that processing here is valid.

 MsgIn 00: Command Complete */

 All operation is done */

 MsgIn 04: Disconnect */

 Unexpected bus free */

 DID_ERROR? */

SCpnt->result   = (DID_OK << 16) | (SCpnt->SCp.Status << 0);

/*

 * nsp32_adjust_busfree - adjusting SG table

 *

 * Note: This driver adjust the SG table using SCSI ACK

 *       counter instead of BMCNT counter!

 adjust saved SACK count with 4 byte start address boundary */

	/*

	 * calculate new_entry from sack count and each sgt[].len

	 * calculate the byte which is intent to send

 all sgt is processed */

 XXX: confirm it's ok or not */

		/* In this case, it's ok because we are at

		 * the head element of the sg. restlen is correctly

		 * calculated.

 calculate the rest length for transferring */

 update adjusting current SG table entry */

 set cur_entry with new_entry */

 update hostdata and lun */

/*

 * It's called MsgOut phase occur.

 * NinjaSCSI-32Bi/UDE automatically processes up to 3 messages in

 * message out phase. It, however, has more than 3 messages,

 * HBA creates the interrupt and we have to process by hand.

	/*

	 * If MsgOut phase is occurred without having any

	 * message, then No_Operation is sent (SCSI-2).

	/*

	 * send messages

		/*

		 * Check REQ is asserted.

			/*

			 * If the last message, set the AutoSCSI restart

			 * before send back the ack message. AutoSCSI

			 * restart automatically negate ATN signal.

command = (AUTO_MSGIN_00_OR_04 | AUTO_MSGIN_02);

nsp32_restart_autoscsi(SCpnt, command);

		/*

		 * Write data with SACK, then wait sack is

		 * automatically negated.

/*

 * Restart AutoSCSI

 *

 * Note: Restarting AutoSCSI needs set:

 *		SYNC_REG, ACK_WIDTH, SGT_ADR, TRANSFER_CONTROL

	/*

	 * set SYNC_REG

	 * Don't set BM_START_ADR before setting this register.

	/*

	 * set ACKWIDTH

	/*

	 * set SREQ hazard killer sampling rate

	/*

	 * set SGT ADDR (physical address)

	/*

	 * set TRANSFER CONTROL REG

	/*

	 * restart AutoSCSI

	 *

	 * TODO: COMMANDCONTROL_AUTO_COMMAND_PHASE is needed ?

/*

 * cannot run automatically message in occur

	/*

	 * read first message

	 *    Use SCSIDATA_W_ACK instead of SCSIDATAIN, because the procedure

	 *    of Message-In have to be processed before sending back SCSI ACK.

	/*

	 * TODO: We need checking whether bus phase is message in?

	/*

	 * assert SCSI ACK

	/*

	 * processing IDENTIFY

 Invalid (non reselect) phase */

 TODO: SPI-3 compliant? */

	/*

	 * processing messages except for IDENTIFY

	 *

	 * TODO: Messages are all SCSI-2 terminology. SCSI-3 compliance is TODO.

	/*

	 * 1-byte message

		/*

		 * These messages should not be occurred.

		 * They should be processed on AutoSCSI sequencer.

		/*

		 * AutoMsgIn03 is disabled, and HBA gets this message.

 No need to rewrite SGT */

 Update with the new value */

 reset SACK/SavedACK counter (or ALL clear?) */

		/*

		 * set new sg pointer

		/*

		 * These messages should not be occurred.

		 * They should be processed on AutoSCSI sequencer.

		/* If previous message_out is sending SDTR, and get

			/*

			 * Current target is negotiating SDTR, but it's

			 * failed.  Fall back to async transfer mode, and set

			 * SDTR_DONE.

 queue tag is not supported currently */

 staring ECA (Extended Contingent Allegiance) state. */

 This message is declined in SPI2 or later. */

	/*

	 * 2-byte message

		/*

		 * 0x23: Ignore_Wide_Residue is not declared in scsi.h.

		 * No support is needed.

 current position is 1-byte of 2 byte */

	/*

	 * extended message

			/*

			 * Current position does not reach 2-byte

			 * (2-byte is extended message length).

			/*

			 * Current extended message has msginbuf[1] + 2

			 * (msgin_len starts counting from 0, so buf[1] + 1).

			 * If current message position is not finished,

			 * continue receiving message.

		/*

		 * Reach here means regular length of each type of

		 * extended messages.

 TODO */

 not implemented yet */

			/*

			 * Exchange this message between initiator and target.

				/*

				 * received inappropriate message.

 SCSI-I only, not supported. */

 not implemented yet */

 not implemented yet */

		/*

		 * If restarting AutoSCSI, but there are some message to out

		 * (msgout_len > 0), set AutoATN, and set SCSIMSGOUT as 0

		 * (MV_VALID = 0). When commandcontrol is written with

		 * AutoSCSI restart, at the same time MsgOutOccur should be

		 * happened (however, such situation is really possible...?).

		/*

		 * restart AutoSCSI

		 * If it's failed, COMMANDCONTROL_AUTO_COMMAND_PHASE is needed.

		/*

		 * If current msgin03 is TRUE, then flag on.

	/*

	 * restart AutoSCSI

	/*

	 * wait SCSI REQ negate for REQ-ACK handshake

	/*

	 * negate SCSI ACK

/*

 *

	/*

	 * If this inititor sent the SDTR message, then target responds SDTR,

	 * initiator SYNCREG, ACKWIDTH from SDTR parameter.

	 * Messages are not appropriate, then send back reject message.

	 * If initiator did not send the SDTR, but target sends SDTR,

	 * initiator calculator the appropriate parameter and send back SDTR.

		/*

		 * Initiator sent SDTR, the target responds and

		 * send back negotiation SDTR.

		/*

		 * offset:

			/*

			 * Negotiation is failed, the target send back

			 * unexpected offset value.

			/*

			 * Negotiation is succeeded, the target want

			 * to fall back into asynchronous transfer mode.

		/*

		 * period:

		 *    Check whether sync period is too short. If too short,

		 *    fall back to async mode. If it's ok, then investigate

		 *    the received sync period. If sync period is acceptable

		 *    between sync table start_period and end_period, then

		 *    set this I_T nexus as sent offset and period.

		 *    If it's not acceptable, send back reject and fall back

		 *    to async mode.

			/*

			 * Negotiation is failed, the target send back

			 * unexpected period value.

			/*

			 * Target want to use long period which is not

			 * acceptable NinjaSCSI-32Bi/UDE.

		/*

		 * Set new sync table and offset in this I_T nexus.

 Target send SDTR to initiator. */

 offset: */

 send back as SYNC_OFFSET */

 period: */

	/*

	 * If the current message is unacceptable, send back to the target

	 * with reject message.

 set as ASYNC transfer mode */

/*

 * Search config entry number matched in sync_table from given

 * target and speed period value. If failed to search, return negative value.

	/*

	 * Check given period value is over the sync_table value.

	 * If so, return max value.

/*

 * target <-> initiator use ASYNC transfer

/*

 * target <-> initiator use maximum SYNC transfer

 disable SREQ sampling */

/*

 * target <-> initiator use entry number speed

/*

 * It waits until SCSI REQ becomes assertion or negation state.

 *

 * Note: If nsp32_msgin_occur is called, we asserts SCSI ACK. Then

 *     connected target responds SCSI REQ negation.  We have to wait

 *     SCSI REQ becomes negation in order to negate SCSI ACK signal for

 *     REQ-ACK handshake.

 REQ is BIT(5) */

/*

 * It waits until SCSI SACK becomes assertion or negation state.

 ACK is BIT(4) */

/*

 * assert SCSI ACK

 *

 * Note: SCSI ACK assertion needs with ACKENB=1, AUTODIRECTION=1.

/*

 * negate SCSI ACK

/*

 * Note: n_io_port is defined as 0x7f because I/O register port is

 *	 assigned as:

 *	0x800-0x8ff: memory mapped I/O port

 *	0x900-0xbff: (map same 0x800-0x8ff I/O port image repeatedly)

 *	0xc00-0xfff: CardBus status registers

 registered host structure */

	/*

	 * register this HBA as SCSI device

	/*

	 * set nsp32_hw_data

	/*

	 * Bus master transfer mode is supported currently.

	/*

	 * Set clock div, CLOCK_4 (HBA has own external clock, and

	 * dividing * 100ns/4).

	 * Currently CLOCK_4 has only tested, not for CLOCK_2/PCICLK yet.

	/*

	 * Select appropriate nsp32_sync_table and set I_CLOCKDIV.

 If data->clock is CLOCK_4, then select 40M sync table. */

 If data->clock is CLOCK_2, then select 20M sync table. */

 If data->clock is PCICLK, then select pci sync table. */

 Use default value CLOCK_4 */

	/*

	 * setup nsp32_lunt

	/*

	 * setup DMA

	/*

	 * allocate autoparam DMA resource.

	/*

	 * allocate scatter-gather DMA resource.

	/*

	 * setup target

	/*

	 * EEPROM check

 default 3 */

	/*

	 * setup HBA

	/*

	 * SCSI bus reset

	 *

	 * Note: It's important to reset SCSI bus in initialization phase.

	 *     NinjaSCSI-32Bi/UDE HBA EEPROM seems to exchange SDTR when

	 *     system is coming up, so SCSI devices connected to HBA is set as

	 *     un-asynchronous mode.  It brings the merit that this HBA is

	 *     ready to start synchronous transfer without any preparation,

	 *     but we are difficult to control transfer speed.  In addition,

	 *     it prevents device transfer speed from effecting EEPROM start-up

	 *     SDTR.  NinjaSCSI-32Bi/UDE has the feature if EEPROM is set as

	 *     Auto Mode, then FAST-10M is selected when SCSI devices are

	 *     connected same or more than 4 devices.  It should be avoided

	 *     depending on this specification. Thus, resetting the SCSI bus

	 *     restores all connected SCSI devices to asynchronous mode, then

	 *     this driver set SDTR safely later, and we can control all SCSI

	 *     device transfer mode.

	/*

         * PCI IO register

/****************************************************************************

 * error handler

 reset SDTR negotiation */

	/*

	 * stop all transfer

	 * clear TRANSFERCONTROL_BM_START

	 * clear counter

	/*

	 * fall back to asynchronous transfer mode

	 * initialize SDTR negotiation flag

	/*

	 * reset SCSI bus

 dummy read */

 Host reset is succeeded at any time. */

/**************************************************************************

 * EEPROM handler

/*

 * getting EEPROM parameter

	/*

	 * EEPROM checking.

	/*

	 * check EEPROM type

 for debug : SPROM data full checking */

/*

 * AT24C01A (Logitec: LHA-600S), AT24C02 (Melco Buffalo: IFC-USLP) data map:

 *

 *   ROMADDR

 *   0x00 - 0x06 :  Device Synchronous Transfer Period (SCSI ID 0 - 6)

 *			Value 0x0: ASYNC, 0x0c: Ultra-20M, 0x19: Fast-10M

 *   0x07        :  HBA Synchronous Transfer Period

 *			Value 0: AutoSync, 1: Manual Setting

 *   0x08 - 0x0f :  Not Used? (0x0)

 *   0x10        :  Bus Termination

 *			Value 0: Auto[ON], 1: ON, 2: OFF

 *   0x11        :  Not Used? (0)

 *   0x12        :  Bus Reset Delay Time (0x03)

 *   0x13        :  Bootable CD Support

 *			Value 0: Disable, 1: Enable

 *   0x14        :  Device Scan

 *			Bit   7  6  5  4  3  2  1  0

 *			      |  <----------------->

 *			      |    SCSI ID: Value 0: Skip, 1: YES

 *			      |->  Value 0: ALL scan,  Value 1: Manual

 *   0x15 - 0x1b :  Not Used? (0)

 *   0x1c        :  Constant? (0x01) (clock div?)

 *   0x1d - 0x7c :  Not Used (0xff)

 *   0x7d	 :  Not Used? (0xff)

 *   0x7e        :  Constant (0x55), Validity signature

 *   0x7f        :  Constant (0xaa), Validity signature

	/*

	 * Reset time which is designated by EEPROM.

	 *

	 * TODO: Not used yet.

	/*

	 * HBA Synchronous Transfer Period

	 *

	 * Note: auto_sync = 0: auto, 1: manual.  Ninja SCSI HBA spec says

	 *	that if auto_sync is 0 (auto), and connected SCSI devices are

	 *	same or lower than 3, then transfer speed is set as ULTRA-20M.

	 *	On the contrary if connected SCSI devices are same or higher

	 *	than 4, then transfer speed is set as FAST-10M.

	 *

	 *	I break this rule. The number of connected SCSI devices are

	 *	only ignored. If auto_sync is 0 (auto), then transfer speed is

	 *	forced as ULTRA-20M.

	/*

	 * each device Synchronous Transfer Period

 set as ULTRA20M */

 search failed... set maximum speed */

/*

 * C16 110 (I-O Data: SC-NBD) data map:

 *

 *   ROMADDR

 *   0x00 - 0x06 :  Device Synchronous Transfer Period (SCSI ID 0 - 6)

 *			Value 0x0: 20MB/S, 0x1: 10MB/S, 0x2: 5MB/S, 0x3: ASYNC

 *   0x07        :  0 (HBA Synchronous Transfer Period: Auto Sync)

 *   0x08 - 0x0f :  Not Used? (0x0)

 *   0x10        :  Transfer Mode

 *			Value 0: PIO, 1: Busmater

 *   0x11        :  Bus Reset Delay Time (0x00-0x20)

 *   0x12        :  Bus Termination

 *			Value 0: Disable, 1: Enable

 *   0x13 - 0x19 :  Disconnection

 *			Value 0: Disable, 1: Enable

 *   0x1a - 0x7c :  Not Used? (0)

 *   0x7d	 :  Not Used? (0xf8)

 *   0x7e        :  Constant (0x55), Validity signature

 *   0x7f        :  Constant (0xaa), Validity signature

	/*

	 * Reset time which is designated by EEPROM.

	 *

	 * TODO: Not used yet.

	/*

	 * each device Synchronous Transfer Period

 20MB/s */

 10MB/s */

 5MB/s */

 ASYNC */

 default 20MB/s */

 search failed... set maximum speed */

/*

 * Atmel AT24C01A (drived in 5V) serial EEPROM routines

 start condition */

 device address */

 1 */

 0 */

 1 */

 0 */

 A2: 0 (GND) */

 A1: 0 (GND) */

 A0: 0 (GND) */

 R/W: W for dummy write */

 ack */

 word address */

 ack */

 start condition */

 device address */

 1 */

 0 */

 1 */

 0 */

 A2: 0 (GND) */

 A1: 0 (GND) */

 A0: 0 (GND) */

 R/W: R */

 ack */

 data... */

 no ack */

 stop condition */

 start condition */

 output mode */

	nsp32_prom_set(data, SDA, 0);	/* keeping SCL=1 and transiting

 stop condition */

 output mode */

 write */

 read */

 input mode */

 output mode */

/**************************************************************************

 * Power Management

 Device suspended */

 Device woken up */

/************************************************************************

 * PCI/Cardbus probe/remove routine

/*********************************************************************

 * Moule entry point

 end */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Zalon 53c7xx device driver.

 * By Richard Hirst (rhirst@linuxcare.com)

/* FIXME:

 * Is this function dead code? or is someone planning on using it in the

 * future.  The clock = (int) pdc_result[16] does not look correct to

 * me ... I think it should be iodc_data[16].  Since this cause a compile

 * error with the new encapsulated PDC, I'm not compiling in this function.

 * - RB

 poke SCSI clock out of iodc data */

 XXX: Save the Zalon version for bug workarounds? */

	/* Setup the interrupts first.

	** Later on request_irq() will register the handler.

 The following three are needed before any other access. */

 DCNTL_REG,  EA  */

 CTEST0_REG, EHP */

 CTEST4_REG, MUX */

 Initialise ncr_device structure with items required by ncr_attach. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * vvvvvvvvvvvvvvvvvvvvvvv Original vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

 *  Copyright (C) 1992  Eric Youngdale

 *  Simulate a host adapter with 2 disks attached.  Do a lot of checking

 *  to make sure that we are not getting blocks mixed up, and PANIC if

 *  anything out of the ordinary is seen.

 * ^^^^^^^^^^^^^^^^^^^^^^^ Original ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

 *

 * Copyright (C) 2001 - 2020 Douglas Gilbert

 *

 *  For documentation see http://sg.danny.cz/sg/scsi_debug.html

 make sure inq_product_rev string corresponds to this version */

 format to fit INQUIRY revision field */

 Additional Sense Code (ASC) */

 scsi bus reset occurred */

 mode parameters changed */

 with TARGET_CHANGED_ASC */

 Additional Sense Code Qualifier (ASCQ) */

 Default values for driver parameters */

/* With these defaults, this driver will make 1 host with 1 target

 * (id 0) containing 1 logical unit (lun 0). That is 1 device.

 if > 0 unit is a jiffy */

 if > 0 unit is a nanosecond */

 INQUIRY, byte2 [6->SPC-4; 7->SPC-5] */

 Default parameters for ZBC drives */

 bit mask values for sdebug_opts */

/* As indicated in SAM-5 and SPC-4 Unit Attentions (UAs) are returned in

 * priority order. In the subset implemented here lower numbers have higher

 * priority. The UA numbers should be a sequence starting from 0 with

 Power on, reset, or bus device reset */

 simulate firmware change */

/* when 1==SDEBUG_OPT_MEDIUM_ERR, a medium error is simulated at this

 that's sector 4660 in decimal */

 number of consecutive medium errs */

/* SDEBUG_CANQUEUE is the maximum number of commands that can be queued

 * (for response) per submit queue at one time. Can be reduced by max_queue

 * option. Command responses are not queued when jdelay=0 and ndelay=0. The

 * per-device DEF_CMD_PER_LUN can be changed via sysfs:

 * /sys/class/scsi_device/<h:c:t:l>/device/queue_depth

 * but cannot exceed SDEBUG_CANQUEUE .

 a WORD is bits in a long */

 UA - Unit Attention; SA - Service Action; SSU - Start Stop Unit */

 Data-in command (e.g. READ) */

 Data-out command (e.g. WRITE) */

 WRITE SAME, NDOB bit */

 allowed with REPORT LUNS W-LUN */

 bypass UAs (e.g. INQUIRY command) */

 for commands like INQUIRY */

 SA is in cdb byte 1, bits 4 to 0 */

 SA is in cdb bytes 8 and 9 */

 invalid opcode (not supported) */

 bypass resp_*() when fake_rw set */

 media access, reacts to SSU state */

 SSU command delay (long-ish) */

 SYNCHRONIZE CACHE delay */

 Useful combinations of the above flags */

 Zone types (zbcr05 table 25) */

 enumeration names taken from table 26, zbcr05 */

 ZBC: per zone state */

 1: by SSU, 2: device start */

 For ZBC devices */

 time since bootup that this device was created */

 sdeb_store_info (per host) xarray index */

 There is an xarray of pointers to this struct's objects, one per host */

 for atomic media access on this store */

 user data storage (ram) */

 protection info */

 provisioning map */

 time since boot to complete this cmd */

 index of sdebug_queue array */

 index of sdebug_queued_cmd array within sqa_idx */

 hostwide tag index */

 true when blk_abort_request() already called */

	/* corresponding bit set in in_use_bm[] in owning struct sdebug_queue

	 * instance indicates this slot is in use.

 to temporarily stop more being queued */

 number of incoming commands */

 count of deferred completions */

 submission + completion cpus differ */

 'almost task set full' counter */

 bumped when mq_poll returns > 0 */

 0 if this is it (i.e. a leaf); use 0xff */

 for terminating element */

 if num_attached > 0, preferred */

 service action */

 OR-ed set of SDEB_F_* */

 num_attached elements or NULL */

 len_mask[0]-->cdb_len, then mask for cdb */

 1 to min(cdb_len, 15); ignore cdb[15...] */

 SCSI opcodes (first byte of cdb) of interest mapped onto these indexes */

 6, 10 */

 6, 10 */

 10; 16 is in SA_IN(16) */

 6, 10, 12, 16 */

 6, 10, 12, 16 */

 add ...SERV_ACT_IN_12 if needed */

 add ...SERV_ACT_OUT_12 if needed */

 VERIFY(10), VERIFY(16) */

 READ(32), WRITE(32), WR_SCAT(32) */

 6, 10 */

 6, 10 */

 PREVENT ALLOW MEDIUM REMOVAL */

 REWIND in SSC */

 12, 16 */

 10, 16 */

 10, 16 */

 10, 16 */

 0x94+SA; includes no data xfer */

 0x95+SA; all have data-in */

 keep this last (previous + 1) */

 0x0; 0x0->0x1f: 6 byte cdbs */

 0x20; 0x20->0x3f: 10 byte cdbs */

 0x40; 0x40->0x5f: 10 byte cdbs */

 0x60; 0x60->0x7d are reserved, 0x7e is "extended cdb" */

 0x80; 0x80->0x9f: 16 byte cdbs */

 0xa0; 0xa0->0xbf: 12 byte cdbs */

 SDEB_I_SERV_ACT_OUT_12 */, SDEB_I_WRITE,

 SDEB_I_SERV_ACT_IN_12 */, 0, 0, 0, 0,

 0xc0; 0xc0->0xff: vendor specific */

/*

 * The following "response" functions return the SCSI mid-level's 4 byte

 * tuple-in-an-int. To handle commands with an IMMED bit, for a faster

 * command completion, they can mask their return value with

 * SDEG_RES_IMMED_MASK .

/*

 * The following are overflow arrays for cdbs that "hit" the same index in

 * the opcode_info_arr array. The most time sensitive (or commonly used) cdb

 * should be placed in opcode_info_arr[], the others should be placed here.

 READ(10) */

 READ(6) */

 READ(12) */

 WRITE(10) */

 WRITE(6) */

 WRITE(12) */

 VERIFY(10) */

 GET LBA STATUS(16) */

 VARIABLE LENGTH */

 WRITE(32) */

 WRITE SCATTERED(32) */

 MAINT IN */

 REPORT SUPPORTED OPERATION CODES */

 REPORTED SUPPORTED TASK MANAGEMENT FUNCTIONS */

 WRITE SAME(16) */

 RESERVE(6) */

 RELEASE(6) */

 SYNC_CACHE (16) */

 PRE-FETCH (16) */

 ZONE OUT(16) */

 CLOSE ZONE */

 FINISH ZONE */

 RESET WRITE POINTER */

 ZONE IN(16) */

 REPORT ZONES */

/* This array is accessed via SDEB_I_* values. Make sure all are mapped,

 * plus the terminating elements for logic that scans this table such as

 0 */

 unknown opcodes */

 INQUIRY */

 REPORT LUNS */

 TEST UNIT READY */

 5 */

 MODE SENSE(10) */

 MODE SELECT(10) */

 LOG SENSE */

 READ CAPACITY(10) */

 READ(16) */

 10 */

 WRITE(16) */

 START STOP UNIT */

 SA_IN(16), READ CAPACITY(16) */

 SA_OUT(16), WRITE SCAT(16) */

 MAINT IN, REPORT TARGET PORT GROUPS */

 15 */

 MAINT OUT */

 VERIFY(16) */

 VARIABLE LENGTH, READ(32) */

 RESERVE(10) <no response function> */

 RELEASE(10) <no response function> */

 20 */

 ALLOW REMOVAL */

 REWIND ?? */

 ATA_PT */

 SEND DIAGNOSTIC */

 UNMAP */

 25 */

 WRITE_BUFFER */

 WRITE SAME(10) */

 SYNC_CACHE (10) */

 COMPARE AND WRITE */

 PRE-FETCH (10) */

 30 */

 ZONE_OUT(16), OPEN ZONE) */

 SA */, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

 ZONE_IN(16), REPORT ZONES) */

 SA */, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

 sentinel */

 terminating element */

 in sysfs this is relative */

 if > 0 then unit is jiffies */

 per host */

 per submit queue */

 if > 0 then was prior max_queue */

 if > 0 then unit is nanoseconds */

 targets per host */

 SCSI peripheral device type */

 Following enum: 0: no zbc, def; 1: host aware; 2: host managed */

 in sectors */

/* old BIOS stuff, kernel may get rid of them but some mode sense pages

 heads per disk */

 cylinders per surface */

 sectors per cylinder */

 invalid index ==> none created */

 need a RW lock when fake_rw=1 */

 ZBC global data */

 true for host-aware and host-managed disks */

 > 1 for multi-queue (mq) */

 iouring iopoll interface.*/

 ptr to array of submit queues */

/* Only do the extra work involved in logical block provisioning if one or

 * more of the lbpu, lbpws or lbpws10 parameters are given and we are doing

 * real reads and writes (i.e. not skipping them for speed).

 should never be NULL */

 sdebug_max_luns; */

 Set in_bit to -1 to indicate no bit position of invalid field */

 correct return but upsets fdisk */

 suggest 6 byte READ, WRITE and MODE SENSE/SELECT */

 suggest 10 byte RWs and 6 byte MODE SENSE/SELECT */

 suggest 10 byte RWs and 10 byte MODE SENSE/SELECT */

 No knobs to suggest this so same as 16 for now */

			/*

			 * SPC-3 behavior is to report a UNIT ATTENTION with

			 * ASC/ASCQ REPORTED LUNS DATA HAS CHANGED on every LUN

			 * on the target, until a REPORT LUNS command is

			 * received.  SPC-4 behavior is to report it only once.

			 * NOTE:  sdebug_scsi_level does not use the same

			 * values as struct scsi_device->scsi_level.

 SPC-4 and above */

 Build SCSI "data-in" buffer. Returns 0 if ok else (DID_ERROR << 16). */

/* Partial build of SCSI "data-in" buffer. Returns 0 if ok else

 * (DID_ERROR << 16). Can write to offset in data-in buffer. If multiple

 * calls, not required to write in ascending offset order. Assumes resid

 * set to scsi_bufflen() prior to any calls.

/* Fetches from SCSI "data-out" buffer. Returns number of bytes fetched into

 * 'arr' or -1 if error.

 Use some locally assigned NAAs for SAS addresses. */

 Device identification VPD page. Returns number of bytes placed in arr */

 T10 vendor identifier field format (faked) */

 ASCII */

 Locally assigned UUID */

 binary (not necessarily sas) */

 PIV=0, lu, naa */

 uuid type=1, locally assigned */

 NAA-3, Logical unit identifier (binary) */

 binary (not necessarily sas) */

 PIV=0, lu, naa */

 Target relative port number */

 proto=sas, binary */

 PIV=1, target port, rel port */

 reserved */

 length */

 reserved */

 reserved */

 relative port A */

 NAA-3, Target port identifier */

 proto=sas, binary */

 piv=1, target port, naa */

 NAA-3, Target port group identifier */

 proto=sas, binary */

 piv=1, target port group id */

 NAA-3, Target device identifier */

 proto=sas, binary */

 piv=1, target device, naa */

 SCSI name string: Target device identifier */

 proto=sas, UTF-8 */

 piv=1, target device, SCSI name string */

 from 4th byte */ 0x22,0x22,0x22,0x0,0xbb,0x0,

  Software interface identification VPD page */

 Management network addresses VPD page */

www.kernel.org/config";

www.kernel.org/log";

 lu, storage config */

 reserved */

 length, null termianted, padded */

 lu, logging */

 reserved */

 length, null terminated, padded */

 SCSI ports VPD page */

 reserved */

 reserved */

 relative port 1 (primary) */

 length tp descriptor */

 naa-5 target port identifier (A) */

 proto=sas, binary */

 PIV=1, target port, NAA */

 reserved */

 length */

 reserved */

 reserved */

 relative port 2 (secondary) */

 length tp descriptor */

 naa-5 target port identifier (B) */

 proto=sas, binary */

 PIV=1, target port, NAA */

 reserved */

 length */

 from 4th byte */ 0,0,0,0,

 ATA Information VPD page */

 from 4th byte */ 0,0,0,4, 0,0,0x4,0, 0,0,0,64,

 Block limits VPD page (SBC-3) */

 Optimal transfer length granularity */

 Maximum Transfer Length */

 Optimal Transfer Length */

 Maximum Unmap LBA Count */

 Maximum Unmap Block Descriptor Count */

 Unmap Granularity Alignment */

 UGAVALID */

 Optimal Unmap Granularity */

 Maximum WRITE SAME Length */

 Mandatory page length for Logical Block Provisioning */

 Block device characteristics VPD page (SBC-3) */

 non rotating medium (e.g. solid state) */

 less than 1.8" */

 zoned field = 01b */

 Logical block provisioning VPD page (SBC-4) */

 threshold exponent */

 sbc4r07 and later */

 anc_sup=0; dp=0 (no provisioning group descriptor) */

 minimum_percentage=0; provisioning_type=0 (unknown) */

 threshold_percentage=0 */

 Zoned block device characteristics VPD page (ZBC mandatory) */

 set URSWRZ (unrestricted read in seq. wr req zone) */

	/*

	 * Set Optimal number of open sequential write preferred zones and

	 * Optimal number of non-sequentially written sequential write

	 * preferred zones fields to 'not reported' (0xffffffff). Leave other

	 * fields set to zero, apart from Max. number of open swrz_s field.

 present, wlun */

 not present, PQ=3, PDT=0x1f */

 CMDDT bit set */

 EVPD bit set */

 supported vital product data pages */

sanity */

 this page */

 unit serial number */

 device identification */

 software interface ident. */

 management network addresses */

 extended inquiry */

 mode page policy */

 SCSI ports */

 SBC or ZBC */

 ATA information */

 Block limits */

 Block characteristics */

 LB Provisioning */

 ZB dev. char. */

 number of supported VPD pages */

 unit serial number */

sanity */

 device identification */

sanity */

 Software interface ident. */

sanity */

 Management network addresses */

sanity */

 extended inquiry */

sanity */

 number of following entries */

 SPT: GRD_CHK:1 */

 SPT: GRD_CHK:1, REF_CHK:1 */

 no protection stuff */

 head of q, ordered + simple q's */

 mode page policy */

sanity */

 number of following entries */

 disconnect-reconnect mp */

 mlus, shared */

 protocol specific lu */

 mlus, per initiator port */

 SCSI Ports */

sanity */

 ATA info */

sanity */

 Block limits */

sanity */

 Block char. */

sanity */

 LB Prov. */

sanity */

 ZB dev. charact. */

sanity */

 drops through here for a standard inquiry */

 Removable disk */

 response_data_format==2 */

 PROTECT bit */

 claim: implicit TPGS */

 claim: MultiP */

 arr[6] |= 0x40; ... claim: EncServ (enclosure services) */

 claim: LINKED + CMDQUE */

 Use Vendor Specific area to place driver date in ASCII hex */

 version descriptors (2 bytes each) follow */

 SAM-6 no version claimed */

 SPC-5 no version claimed */

 SBC-4 no version claimed */

 SSC-4 rev 3 */

 ZBC BSR INCITS 536 revision 05 */

 SPL-4 no version claimed */

 See resp_iec_m_pg() for how this data is manipulated */

 assume >= 18 bytes */

 some "pollable" data [spc6r02: 5.12.2] */

 NO_SENSE in sense_key */

 18 byte sense buffer */

 Information exceptions control mode page: TEST=1, MRIE=6 */

 NO_SENSE in sense_key */

 Failure prediction(false) */

 NO_SENSE in sense_key */

 18 byte sense buffer */

 Failure prediction(false) */

 nothing to report */

 tur_ms_to_ready timer extinguished */

 dummy up success */

 Disallow tur_ms_to_ready delay to be overridden */

 START bit */);

 state unchanged or IMMED bit set in cdb */

 following just in case virtual_gb changed */

 following just in case virtual_gb changed */

 LBPME */

		/* from sbc4r07, this LBPRZ field is 1 bit, but the LBPRZ in

		 * the LB Provisioning VPD page is 3 bits. Note that lbprz=2

		 * in the wider field maps to 0 in this field.

 precisely what the draft requires */

 P_TYPE */

 PROT_EN */

	/*

	 * EVPD page 0x88 states we have two ports, one

	 * real and a fake port with no device connected.

	 * So we create two port groups with one port each

	 * and set the group with port B to unavailable.

 relative port A */

 relative port B */

	/*

	 * The asymmetric access state is cycled according to the host_id.

 Asymm access state */

 claim: all states are supported */

 Active/Optimized path */

 only support active/optimized paths */

 Reserved */

 Status code */

 Vendor unique */

 One port per group */

 Reserved */

 Reserved */

 Port unavailable */

 claim: only unavailalbe paths are supported */

 Reserved */

 Status code */

 Vendor unique */

 One port per group */

 Reserved */

 Reserved */

	/*

	 * Return the smallest value of either

	 * - The allocated length

	 * - The constructed command length

	 * - The maximum array size

 all commands */

 count number of commands */

 one command: opcode only */

 one command: opcode plus service action */

 one command: if sa==0 then opcode only else opcode+sa */

 point at requested sa */

 ATS | ATSS | LURS */

 ITNRS */

 <<Following mode page info copied from ST318451LW>> */

 Read-Write Error Recovery page for mode_sense */

 Disconnect-Reconnect page for mode_sense */

 Format device page for mode_sense */

 should agree with INQUIRY */

 Caching page for mode_sense */

 0x8, 18, */ 0x4, 0, 0, 0, 0, 0,

 set WCE=0 (default WCE=1) */

 Control mode page for mode_sense */

 0xa, 10, */ 0x6, 0, 0, 0, 0, 0,

 ATO=1 */

 Informational Exceptions control mode page for mode_sense */

 0x1c, 0xa, */ 0x4, 0xf, 0, 0, 0, 0,

 SAS SSP mode page - short format for mode_sense */

 SAS phy control and discover mode page for mode_sense */

 insert SAS addr */

 insert SAS addr */

 insert SAS addr */

 insert SAS addr */

 SAS SSP shared protocol specific port mode subpage */

 disable block descriptors */

 Saving values not supported */

 for disks+zbc set DPOFUA bit and clear write protect (WP) bit */

 =0x90 if WP=1 implies read-only */

 set LONGLBA bit */

 assume 255 or less */

 TODO: Control Extension page */

 Read-Write error recovery page, direct access */

 Disconnect-Reconnect page, all devices */

 Format device page, direct access */

 Caching page, direct access */

 Control Mode page, all devices */

 if spc==1 then sas phy, control+discover */

 Informational Exceptions Mode page, all devices */

 Read all Mode pages */

 Caching Mode page */

 Control Mode page */

 Informational Exceptions Mode page */

 TEST bit set */

 Supported log pages log page */

 this page */

 Temperature */

 Informational exceptions */

 Temperature log page */

 Informational exceptions log page */

 Supported log pages and subpages log page */

 0,0 page */

 this page */

 Temperature */

 Informational exceptions */

 Temperature subpages */

 Temperature */

 Informational exceptions subpages */

 Informational exceptions */

 Close an implicit open zone if necessary */

 For host-managed, reads cannot cross zone types boundaries */

 No restrictions for writes within conventional zones */

 Writes cannot cross sequential zone boundaries */

 Cannot write full zones */

 Writes must be aligned to the zone WP */

 Handle implicit open of closed and empty zones */

 transfer length excessive (tie in to block limits VPD page) */

 needs work to find which cdb byte 'num' comes from */

/*

 * Note: if BUG_ON() fires it usually indicates a problem with the parser

 * tables. Perhaps a missing F_FAKE_RW or FF_MEDIA_IO flag. Response functions

 * that access any of the "stores" in struct sdeb_store_info should call this

 * function with bug_if_fake_rw set to true.

 See note above */

 Returns number of bytes copied or -1 if error. */

 Returns number of bytes copied or -1 if error. */

/* If sip->storep+lba compares equal to arr(num), then copy top half of

 * arr into sip->storep+lba and return true. If comparison fails then

 Bytes of protection data to copy into sgl */

		/*

		 * Because scsi_debug acts as both initiator and

		 * target we proceed to verify the PI even if

		 * RDPROTECT=3. This is done so the "initiator" knows

		 * which type of error to return. Otherwise we would

		 * have to iterate over the PI twice.

 RDPROTECT */

 assume READ(32) */

 claim unrecoverable read error */

 set info field and valid bit for fixed descriptor */

 Valid bit */

 DIX + T10 DIF */

 Guard tag error */

 RDPROTECT != 3 */

 Reference tag error */

 RDPROTECT != 3 */

 Logical block guard check failed */

 For each protection page */

			/* If we're at the end of the current

			 * data page advance to the next one

 WRPROTECT */

 for LBPRZ=2 return 0xff_s */

 XDWRITEREAD(10) */

 assume WRITE(32) */

 DIX + T10 DIF */

 Guard tag error */

 WRPROTECT != 3 */

 Reference tag error */

 WRPROTECT != 3 */

 If ZBC zone then bump its write pointer */

 Logical block guard check failed */

/*

 * T10 has only specified WRITE SCATTERED(16) and WRITE SCATTERED(32).

 * No READ GATHERED yet (requires bidi or long cdb holding gather list).

 + parameter list header size */

 that leaves WRITE SCATTERED(16) */

 T10 says these do-nothings are not errors */

 Spec says Buffer xfer Length field in number of LBs in dout */

 DIX + T10 DIF */

 If ZBC zone then bump its write pointer */

 Logical block guard check failed */

 if ndob then zero 1 logical block, else fetch 1 logical block */

 Copy first sector to remaining blocks */

 If ZBC zone then bump its write pointer */

 UNMAP */

 NDOB (no data-out buffer, assumes zeroes) */

/* Note the mode field is in the same position as the (lower) service action

 * field. For the Report supported operation codes command, SPC-4 suggests

 download microcode (MC) and activate (ACT) */

 set UAs on this device only */

 download MC, save and ACT */

 download MC with offsets and ACT */

 set UAs on most devices (LUs) in this target */

 download MC with offsets, save, and ACT */

 set UA on all devices (LUs) in this target */

 do nothing for this command for other mode values */

 1 to a maximum of 255 logical blocks */

 degenerate case, not an error */

 fib and say its done */

 following just in case virtual_gb changed */

 Parameter Data Length */

 LBA */

 Number of blocks */

 prov_stat=0: mapped; 1: dealloc */

 10 byte cdb */

 SYNCHRONIZE_CACHE(16) */

 delay if write_since_sync and IMMED clear */

/*

 * Assuming the LBA+num_blocks is not out-of-range, this function will return

 * CONDITION MET if the specified blocks will/have fitted in the cache, and

 * a GOOD status otherwise. Model a disk with a big cache and yield

 * CONDITION MET. Actually tries to bring range in main memory into the

 * cache associated with the CPU(s).

 10 byte cdb */

 PRE-FETCH(16) */

 PRE-FETCH spec says nothing about LBP or PI so skip them */

 Try to bring the PRE-FETCH range into CPU's cache */

/* Even though each pseudo target has a REPORT LUNS "well known logical unit"

 * (W-LUN), the normal Linux scanning logic does not associate it with a

 * device (e.g. /dev/sg7). The following magic will make that association:

 *   "cd /sys/class/scsi_host/host<n> ; echo '- - 49409' > scan"

 * where <n> is a host number. If there are multiple targets in a host then

 * the above will associate a W-LUN to each target. To only get a W-LUN

 * for target 2, then use "echo '- 2 49409' > scan" .

 normal LUN count (max: 256) */

 report luns W-LUN count */

 total LUN count */

 response length (in bytes) */

 all LUNs apart from W-LUNs */

 only W-LUNs */

 all LUNs */

 only administrative LUs */

 see SPC-5 */

 only subsiduary LUs owned by referenced LU */

 excluding 8 byte header */

 loops rely on sizeof response header same as sizeof lun (both 8) */

 always claim internal verify okay */

 1 block sent, compared repeatedly */

 is VERIFY(10) */

 not an error */

 Treat following check like one for read (i.e. no write) access */

 Not changing store, so only need read access */

 Report zones depending on start LBA nad reporting options */

 not an error */

 All zones */

 Empty zones */

 Implicit open zones */

 Explicit open zones */

 Closed zones */

 Full zones */

			/*

			 * Read-only, offline, reset WP recommended are

			 * not emulated: no zones to report;

 non-seq-resource set */

 Not write pointer (conventional) zones */

 Fill zone descriptor */

 Report header */

 Logic transplanted from tcmu-runner, file_zbc.c */

 Check if all closed zones can be open */

 Open all closed zones */

 Open the specified zone */

 Close specified zone */

 Finish the specified zone */

 Queued (deferred) command completions converge here. */

 user has reduced max_queue */

 callback to mid level */

 When high resolution timer goes off this function is called. */

 When work queue schedules work, it calls this function. */

	/*

	 * Set the zone size: if sdeb_zbc_zone_size_mb is not set, figure out

	 * a zone size allowing for at least 4 zones on the device. Otherwise,

	 * use the specified zone size checking that at least 2 zones can be

	 * created for the device.

 zbc_max_open_zones can be 0, meaning "not reported" */

 try and make a new one */

 no resources, will be marked offline */

 make this slot available for re-use */

/* If @cmnd found deletes its timer or work queue and returns true; else

 found */

 Deletes (stops) timers or work queues of all queued commands */

 Free queued command memory on heap */

 assume partition table already zeroed */

 magic partition markings */

 plain Linux partition */

/* Adjust (by rounding down) the sdebug_cmnd_count so abs(every_nth)-1

 * commands will be processed normally before triggers occur.

 1 millisecond */

/* Complete the processing of the thread that queued a SCSI command to this

 * driver. It either completes the command by calling cmnd_done() or

 * schedules a hr timer or work queue then returns 0. Returns

 * SCSI_MLQUEUE_HOST_BUSY if temporarily out of resources.

 Set the hostwide tag */

 one of the resp_*() response functions is called here */

 scale to 4 usec precision */

 over 4 hours max */

 ndelay has a 4.2 second max */

 elapsed duration >= kt */

 call scsi_done() from this thread */

 otherwise reduce kt by elapsed time */

 schedule the invocation of scsi_done() for a later time */

 jdelay < 0, use work queue */

 call back to mid-layer using invocation thread */

/* Note: The following macros create attribute files in the

   /sys/module/scsi_debug/parameters directory. Unfortunately this

   driver is unaware of a change and cannot trigger auxiliary actions

   as it can when the corresponding attribute in the

   /sys/bus/pseudo/drivers/scsi_debug directory is changed.

 'echo <val> > /proc/scsi/scsi_debug/<host_id>' writes to opts */

/* Output seen with 'cat /proc/scsi/scsi_debug/<host_id>'. It will be the

 * same for each scsi_debug host (if more than one). Some of the counters

/* Returns -EBUSY if jdelay is being changed and commands are queued. The unit

 * of delay is jiffies.

 queued commands */

 Returns -EBUSY if ndelay is being changed and commands are queued */

 If > 0 and accepted then sdebug_jdelay is set to JDELAY_OVERRIDDEN */

 queued commands */

 Cannot change from or to TYPE_ZBC with sysfs */

 not transitioning so do nothing */

 1 --> 0 transition, set up store */

 make all hosts use same store */

 0 --> 1 transition is trigger for shrink */

 apart from first */);

 >= SPC-3 */

 >= SPC-3 */

/* N.B. max_queue can be changed while there are queued commands. In flight

/*

 * Since this is used for .can_queue, and we get the hc_idx tag from the bitmap

 * in range [0, sdebug_host_max_queue), we can't change it.

 Ignore capacity change for ZBC drives for now */

 absolute number of hosts currently active is what is shown */

 re-use case */

 N.B. sdebug_host_lock does nothing, kept for backward compatibility */

/* Note: The following array creates attribute files in the

   /sys/bus/pseudo/drivers/scsi_debug directory. The advantage of these

   files (over those found in the /sys/module/scsi_debug/parameters

   directory) is that auxiliary actions can be triggered when an attribute

   is changed. For example see: add_host_store() above.

	/*

	 * check for host managed zoned block device specified with

	 * ptype=0x14 or zbc=XXX.

 force minimum 1 MB ramdisk */

 play around with geometry, don't waste too much on track 0 */

 other LLDs do this; implies >= 1GB ram disk ... */

 idx must be valid, if sip is NULL then it will be obtained using idx */

 Assume apart_from_first==false only in shutdown case. */

/*

 * Returns store xarray new element index (idx) if >=0 else negated errno.

 * Limit the number of stores to 65536.

 DIF/DIX: what T10 calls Protection Information (PI) */

 Logical Block Provisioning */

 Map first 1KB for partition table */

 ignore command causing timeout */

 time out reads and writes */

 Response to TUR or media access command when device stopped */

 tur_ms_to_ready timer extinguished */

 As per 20-061r2 approved for spc6 by T10 on 20200716 */

 diff_ns becomes milliseconds */

 ignoring non REQ_POLLED requests */

 user has reduced max_queue */

 callback to mid level */

 fully mapped */

 safe if table consistent */

 multiple commands with this opcode */

 since no service action only check opcode */

 else (when na==0) we assume the oip is a match */

 check cdb against mask */

 ignore command: make trouble */

 calls a resp_* function */

 if leaf function ptr NULL, try the root's */

 cmds like INQUIRY respond asap */

		/*

		 * Skip long delays if ndelay <= 10 microseconds. Otherwise

		 * for Start Stop Unit (SSU) want at least 1 second delay and

		 * if sdebug_jdelay>1 want a long delay of that many seconds.

		 * For Synchronize Cache want 1/20 of SSU's delay.

	/*

	 * Decide whether to tell scsi subsystem that we want mq. The

	 * following should give the same answer for each host.

 poll queues are possible for nr_hw_queues > 1 */

	/*

	 * Poll queues don't need interrupts, but we need at least one I/O queue

	 * left over for non-polled I/O.

	 * If condition not met, trim poll_queues to 1 (just for simplicity).

 = sdebug_max_luns; */

 need stats counters for every_nth */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * SCSI low-level driver for the 53c94 SCSI bus adaptor found

 * on Power Macintosh computers, controlling the external SCSI chain.

 * We assume the 53c94 is connected to a DBDMA (descriptor-based DMA)

 * controller.

 *

 * Paul Mackerras, August 1996.

 * Copyright (C) 1996 Paul Mackerras.

 req we're currently working on */

 what we're currently trying to do */

 space for dbdma commands, aligned */

 assert RST */

 leave it on for a while (>= 25us) */

 250ms */

/*

 * Start the next command for a 53C94.

 * Should be called with interrupts disabled.

 Off we go */

 load the command into the FIFO */

 do select without ATN XXX */

	/*

	 * Apparently, reading the interrupt register unlatches

	 * the status and sequence step registers.

 SCSI bus was reset */

 stop dma */

 XXX these seem to be harmless? */

 selection timed out */

 set DMA controller going if any data to transfer */

 up to status phase already */

 Set up the count regs to transfer more */

 stop dma */

 should check dma status */

/*

 * Set up DMA commands for transferring data.

       	/* Space for dma command list: +1 for stop command,

       	 * +1 to allow for aligning.

	 * XXX FIXME: Use DMA consistent routines

 SPDX-License-Identifier: GPL-2.0-or-later

/* SNI RM driver

 *

 * Copyright (C) 2001 by James.Bottomley@HansenPartnership.com

**-----------------------------------------------------------------------------

**

**

**-----------------------------------------------------------------------------

/*

 * Based on lasi700.c

 SPDX-License-Identifier: GPL-2.0-only

 use bounce buffer if the physical address is bad */

 check if the address of the bounce buffer is OK */

 fall back to Chip RAM if address out of range */

 copy to bounce buffer for a write */

 setup dma direction */

 setup DMA *physical* address */

 invalidate any cache */

 push any dirty cache */

 start DMA */

 return success */

 stop DMA */

 remove write bit from CONTROL bits */

 copy from a bounce buffer, if necessary */

	/*

	 * These darn GVP boards are a problem - it can be tough to tell

	 * whether or not they include a SCSI controller. This is the

	 * ultimate Yet-Another-GVP-Detection-Hack in that it actually

	 * probes for a WD33c93 chip: If we find one, it's extremely

	 * likely that this card supports SCSI, regardless of Product_

	 * Code, Board_Size, etc.

 Get pointers to the presumed register locations and save contents */

 First test the AuxStatus Reg */

 read it */

 bit 3 should always be clear */

 setup indirect address */

 shouldn't retain the write */

 Oops - restore this byte */

 should still read the same */

 Oops - restore this byte */

 and so should the image at 0x1f */

	/*

	 * Ok, we probably have a wd33c93, but let's check a few other places

	 * for good measure. Make sure that this works for both 'A and 'B

	 * chip versions.

 should be read only */

 this register is unimplemented */

 should be read only, all 1's */

 should be read/write */

 CHECK_WD33C93 */

	/*

	 * Rumors state that some GVP ram boards use the same product

	 * code as the SCSI controllers. Therefore if the board-size

	 * is not 64KB we assume it is a ram board and bail out.

	/*

	 * Check for 14MHz SCSI clock

	/*

	 * This should (hopefully) be the correct way to identify

	 * all the different GVP SCSI controllers (except for the

	 * SERIES I though).

 SPDX-License-Identifier: GPL-2.0

/*

 * ASCII values for a number of symbolic constants, printing functions,

 * etc.

 * Additions for SCSI 2 and Linux 2.2.x by D. Gilbert (990422)

 * Additions for SCSI 3+ (SPC-3 T10/1416-D Rev 07 3 May 2002)

 *   by D. Gilbert and aeb (20020609)

 * Updated to SPC-4 T10/1713-D Rev 36g, D. Gilbert 20130701

 Commands with service actions that change the command name */

 00-03 */ "Test Unit Ready", "Rezero Unit/Rewind", NULL, "Request Sense",

 04-07 */ "Format Unit/Medium", "Read Block Limits", NULL,

 08-0d */ "Read(6)", NULL, "Write(6)", "Seek(6)", NULL, NULL,

 0e-12 */ NULL, "Read Reverse", "Write Filemarks", "Space", "Inquiry",

 13-16 */ "Verify(6)", "Recover Buffered Data", "Mode Select(6)",

 17-1a */ "Release(6)", "Copy", "Erase", "Mode Sense(6)",

 1b-1d */ "Start/Stop Unit", "Receive Diagnostic", "Send Diagnostic",

 1e-1f */ "Prevent/Allow Medium Removal", NULL,

 20-22 */  NULL, NULL, NULL,

 23-28 */ "Read Format Capacities", "Set Window",

 29-2d */ "Read Generation", "Write(10)", "Seek(10)", "Erase(10)",

 2e-31 */ "Write Verify(10)", "Verify(10)", "Search High", "Search Equal",

 32-34 */ "Search Low", "Set Limits", "Prefetch/Read Position",

 35-37 */ "Synchronize Cache(10)", "Lock/Unlock Cache(10)",

 38-3c */ "Medium Scan", "Compare", "Copy Verify", "Write Buffer",

 3d-3f */ "Update Block", "Read Long(10)",  "Write Long(10)",

 40-41 */ "Change Definition", "Write Same(10)",

 42-48 */ "Unmap/Read sub-channel", "Read TOC/PMA/ATIP",

 49-4f */ "Play track relative(10)", "Get event status notification",

 50-55 */ "Xdwrite", "Xpwrite, Read disk info", "Xdread, Read track info",

 56-5b */ "Reserve(10)", "Release(10)", "Repair track", "Read master cue",

 5c-5f */ "Read buffer capacity", "Send cue sheet", "Persistent reserve in",

 60-67 */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

 68-6f */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

 70-77 */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

 78-7f */ NULL, NULL, NULL, NULL, NULL, NULL, "Extended CDB",

 80-84 */ "Xdwrite(16)", "Rebuild(16)", "Regenerate(16)",

 85-89 */ "ATA command pass through(16)", "Access control in",

 8a-8f */ "Write(16)", "ORWrite", "Read attributes", "Write attributes",

 90-94 */ "Pre-fetch(16)", "Synchronize cache(16)",

 95-99 */ NULL, NULL, NULL, NULL, NULL,

 9a-9f */ NULL, NULL, NULL, "Service action bidirectional",

 a0-a5 */ "Report luns", "ATA command pass through(12)/Blank",

 a6-a9 */ "Exchange medium", "Move medium attached", "Read(12)",

 aa-ae */ "Write(12)", NULL, "Erase(12), Get Performance",

 af-b1 */ "Verify(12)", "Search data high(12)", "Search data equal(12)",

 b2-b4 */ "Search data low(12)", "Set limits(12)",

 b5-b6 */ "Security protocol out", "Send volume tag, set streaming",

 b7-b9 */ "Read defect data(12)", "Read element status", "Read CD msf",

 ba-bc */ "Redundancy group (in), Scan",

 bd-bf */ "Spare (out), Mechanism status", "Volume set (in), Read cd",

/* SPC-4 rev 34 renamed the Extended Copy opcode to Third Party Copy Out.

   LID1 (List Identifier length: 1 byte) is the Extended Copy found in SPC-2

 0x0302 looks better than 0x03,0x02 */

/*

 * There are 700+ entries in this table. To save space, we don't store

 * (code, pointer) pairs, which would make sizeof(struct

 * error_info)==16 on 64 bits. Rather, the second element just stores

 * the size (including \0) of the corresponding string, and we use the

 * sum of these to get the appropriate offset into additional_text

 * defined below. This approach saves 12 bytes per entry.

 description of the sense key values */

 0: There is no sense information */

	"Recovered Error",  /* 1: The last command completed successfully

 2: The addressed target is not ready */

 3: Data error detected on the medium */

 4: Controller or device failure */

 5: Error in request */

	"Unit Attention",   /* 6: Removable medium was changed, or

 7: Access to the data is blocked */

	"Blank Check",	    /* 8: Reached unexpected written or unwritten

 A: COPY or COMPARE was aborted */

 B: The target aborted the command */

	"Equal",	    /* C: A SEARCH DATA command found data equal,

 D: Medium full with still data to be written */

	"Miscompare",	    /* E: Source data and data on the medium

	"Completed",	    /* F: command completed sense data reported,

 Get sense key string or NULL if not available */

/*

 * Get additional sense code string or NULL if not available.

 * This string may contain a "%x" and should be printed with ascq as arg.

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  scsi_error.c Copyright (C) 1997 Eric Youngdale

 *

 *  SCSI error/timeout handling

 *      Initial versions: Eric Youngdale.  Based upon conversations with

 *                        Leonard Zubkoff and David Miller at Linux Expo,

 *                        ideas originating from all over the place.

 *

 *	Restructured scsi_unjam_host and associated functions.

 *	September 04, 2002 Mike Anderson (andmike@us.ibm.com)

 *

 *	Forward port of Russell King's (rmk@arm.linux.org.uk) changes and

 *	minor cleanups.

 *	September 30, 2002 Mike Anderson (andmike@us.ibm.com)

/*

 * These should *probably* be handled by the host itself.

 * Since it is allowed to sleep, it probably should.

/**

 * scsi_schedule_eh - schedule EH for SCSI host

 * @shost:	SCSI host to invoke error handling on.

 *

 * Schedule SCSI EH without scmd.

	/*

	 * 32bit accesses are guaranteed to be atomic

	 * (on all supported architectures), so instead

	 * of using a spinlock we can as well double check

	 * if eh_deadline has been set to 'off' during the

	 * time_before call.

	/*

	 * If the abort succeeds, and there is no further

	 * EH action, clear the ->last_reset time.

/**

 * scmd_eh_abort_handler - Handle command aborts

 * @work:	command to be aborted.

 *

 * Note: this function must be called only for a command that has timed out.

 * Because the block layer marks a request as complete before it calls

 * scsi_times_out(), a .scsi_done() call from the LLD for a command that has

 * timed out do not have any effect. Hence it is safe to call

 * scsi_finish_command() from this function.

/**

 * scsi_abort_command - schedule a command abort

 * @scmd:	scmd to abort.

 *

 * We only need to abort commands after a command timeout

		/*

		 * Retry after abort failed, escalate to next level.

/**

 * scsi_eh_reset - call into ->eh_action to reset internal counters

 * @scmd:	scmd to run eh on.

 *

 * The scsi driver might be carrying internal state about the

 * devices, so we need to call into the driver to reset the

 * internal state once the error handler is started.

/**

 * scsi_eh_scmd_add - add scsi cmd to error handling.

 * @scmd:	scmd to run eh on.

	/*

	 * Ensure that all tasks observe the host state change before the

	 * host_failed change.

/**

 * scsi_times_out - Timeout function for normal scsi commands.

 * @req:	request that is timing out.

 *

 * Notes:

 *     We do not need to lock this.  There is the potential for a race

 *     only in that the normal completion handling might run, but if the

 *     normal completion function determines that the timer has already

 *     fired, then it mustn't do anything.

		/*

		 * Set the command to complete first in order to prevent a real

		 * completion from releasing the command while error handling

		 * is using it. If the command was already completed, then the

		 * lower level driver beat the timeout handler, and it is safe

		 * to return without escalating error recovery.

		 *

		 * If timeout handling lost the race to a real completion, the

		 * block layer may ignore that due to a fake timeout injection,

		 * so return RESET_TIMER to allow error handling another shot

		 * at this command.

/**

 * scsi_block_when_processing_errors - Prevent cmds from being queued.

 * @sdev:	Device on which we are performing recovery.

 *

 * Description:

 *     We block until the host is out of error recovery, and then check to

 *     see whether the host or the device is offline.

 *

 * Return value:

 *     0 when dev was taken offline by error recovery. 1 OK to proceed.

/**

 * scsi_eh_prt_fail_stats - Log info on failures.

 * @shost:	scsi host being recovered.

 * @work_q:	Queue of scsi cmds to process.

 /**

 * scsi_report_lun_change - Set flag on all *other* devices on the same target

 *                          to indicate that a UNIT ATTENTION is expected.

 * @sdev:	Device reporting the UNIT ATTENTION

/**

 * scsi_report_sense - Examine scsi sense information and log messages for

 *		       certain conditions, also issue uevents for some of them.

 * @sdev:	Device reporting the sense code

 * @sshdr:	sshdr to be examined

 i.e. none */

/**

 * scsi_check_sense - Examine scsi cmd sense

 * @scmd:	Cmd to have sense checked.

 *

 * Return value:

 *	SUCCESS or FAILED or NEEDS_RETRY or ADD_TO_MLQUEUE

 *

 * Notes:

 *	When a deferred error is detected the current command has

 *	not been executed and needs retrying.

 no valid sense data */

 handler does not care. Drop down to default handling */

		/*

		 * nasty: for mid-layer issued TURs, we need to return the

		 * actual sense data without any recovery attempt.  For eh

		 * issued ones, we need to try to recover and interpret

	/*

	 * Previous logic looked for FILEMARK, EOM or ILI which are

	 * mainly associated with tapes and returned SUCCESS.

 fixed format */

		/*

		 * descriptor format: look for "stream commands sense data

		 * descriptor" (see SSC-3). Assume single sense data

		 * descriptor. Ignore ILI from SBC-2 READ LONG and WRITE LONG.

 soft_error */ SUCCESS;

 DIF */

		/*

		 * if we are expecting a cc/ua because of a bus reset that we

		 * performed, treat this just as a retry.  otherwise this is

		 * information that we should pass up to the upper-level driver

		 * so that we can deal with it there.

			/*

			 * Because some device does not queue unit

			 * attentions correctly, we carefully check

			 * additional sense code and qualifier so as

			 * not to squash media change unit attention.

		/*

		 * we might also expect a cc/ua if another LUN on the target

		 * reported a UA with an ASC/ASCQ of 3F 0E -

		 * REPORTED LUNS DATA HAS CHANGED.

		/*

		 * if the device is in the process of becoming ready, we

		 * should retry.

		/*

		 * if the device is not started, we need to wake

		 * the error handler to start the motor

		/*

		 * Pass the UA upwards for a determination in the completion

		 * functions.

 these are not supported */

 Thin provisioning hard threshold reached */

 UNRECOVERED READ ERR */

 AMNF DATA FIELD */

 RECORD NOT FOUND */

 Invalid command operation code */

 Logical block address out of range */

 Invalid function */

 Invalid field in cdb */

 Parameter value invalid */

 Write protected */

	/*

	 * Walk all devices of a target and do

	 * ramp up on them.

		/*

		 * We do not know the number of commands that were at

		 * the device when we got the queue full so we start

		 * from the highest possible value and work our way down.

/**

 * scsi_eh_completed_normally - Disposition a eh cmd on return from LLD.

 * @scmd:	SCSI cmd to examine.

 *

 * Notes:

 *    This is *only* called when we are examining the status of commands

 *    queued during error recovery.  the main difference here is that we

 *    don't allow for the possibility of retries here, and we are a lot

 *    more restrictive about what we consider acceptable.

	/*

	 * first check the host byte, to see if there is anything in there

	 * that would indicate what we need to do.

		/*

		 * rats.  we are already in the error handler, so we now

		 * get to try and figure out what to do next.  if the sense

		 * is valid, we have a pretty good idea of what to do.

		 * if not, we mark it as FAILED.

	/*

	 * now, check the status byte to see if this indicates

	 * anything special.

		/*

		 * who knows?  FIXME(eric)

			/* it is a success, we probed the device and

 otherwise, we failed to send the command */

/**

 * scsi_eh_done - Completion function for error handling.

 * @scmd:	Cmd that is done.

/**

 * scsi_try_host_reset - ask host adapter to reset itself

 * @scmd:	SCSI cmd to send host reset.

/**

 * scsi_try_bus_reset - ask host to perform a bus reset

 * @scmd:	SCSI cmd to send bus reset.

/**

 * scsi_try_target_reset - Ask host to perform a target reset

 * @scmd:	SCSI cmd used to send a target reset

 *

 * Notes:

 *    There is no timeout for this operation.  if this operation is

 *    unreliable for a given host, then the host itself needs to put a

 *    timer on it, and set the host back to a consistent state prior to

 *    returning.

/**

 * scsi_try_bus_device_reset - Ask host to perform a BDR on a dev

 * @scmd:	SCSI cmd used to send BDR

 *

 * Notes:

 *    There is no timeout for this operation.  if this operation is

 *    unreliable for a given host, then the host itself needs to put a

 *    timer on it, and set the host back to a consistent state prior to

 *    returning.

/**

 * scsi_try_to_abort_cmd - Ask host to abort a SCSI command

 * @hostt:	SCSI driver host template

 * @scmd:	SCSI cmd used to send a target reset

 *

 * Return value:

 *	SUCCESS, FAILED, or FAST_IO_FAIL

 *

 * Notes:

 *    SUCCESS does not necessarily indicate that the command

 *    has been aborted; it only indicates that the LLDDs

 *    has cleared all references to that command.

 *    LLDDs should return FAILED only if an abort was required

 *    but could not be executed. LLDDs should return FAST_IO_FAIL

 *    if the device is temporarily unavailable (eg due to a

 *    link down on FibreChannel)

/**

 * scsi_eh_prep_cmnd  - Save a scsi command info as part of error recovery

 * @scmd:       SCSI command structure to hijack

 * @ses:        structure to save restore information

 * @cmnd:       CDB to send. Can be NULL if no new cmnd is needed

 * @cmnd_size:  size in bytes of @cmnd (must be <= BLK_MAX_CDB)

 * @sense_bytes: size of sense data to copy. or 0 (if != 0 @cmnd is ignored)

 *

 * This function is used to save a scsi command information before re-execution

 * as part of the error recovery process.  If @sense_bytes is 0 the command

 * sent must be one that does not transfer any data.  If @sense_bytes != 0

 * @cmnd is ignored and this functions sets up a REQUEST_SENSE command

 * and cmnd buffers to read @sense_bytes into @scmd->sense_buffer.

	/*

	 * We need saved copies of a number of fields - this is because

	 * error handling may need to overwrite these with different values

	 * to run different commands, and once error handling is complete,

	 * we will need to restore these values prior to running the actual

	 * command.

	/*

	 * Zero the sense buffer.  The scsi spec mandates that any

	 * untransferred sense data should be interpreted as being zero.

/**

 * scsi_eh_restore_cmnd  - Restore a scsi command info as part of error recovery

 * @scmd:       SCSI command structure to restore

 * @ses:        saved information from a coresponding call to scsi_eh_prep_cmnd

 *

 * Undo any damage done by above scsi_eh_prep_cmnd().

	/*

	 * Restore original data

/**

 * scsi_send_eh_cmnd  - submit a scsi command as part of error recovery

 * @scmd:       SCSI command structure to hijack

 * @cmnd:       CDB to send

 * @cmnd_size:  size in bytes of @cmnd

 * @timeout:    timeout for this request

 * @sense_bytes: size of sense data to copy or 0

 *

 * This function is used to send a scsi command down to a target device

 * as part of the error recovery process. See also scsi_eh_prep_cmnd() above.

 *

 * Return value:

 *    SUCCESS or FAILED or NEEDS_RETRY

	/*

	 * Lock sdev->state_mutex to avoid that scsi_device_quiesce() can

	 * change the SCSI device state after we have examined it and before

	 * .queuecommand() is called.

 signal not to enter either branch of the if () below */

	/*

	 * If there is time left scsi_eh_done got called, and we will examine

	 * the actual status codes to see whether the command actually did

	 * complete normally, else if we have a zero return and no time left,

	 * the command must still be pending, so abort it and return FAILED.

	 * If we never actually managed to issue the command, because

	 * ->queuecommand() kept returning non zero, use the rtn = FAILED

	 * value above (so don't execute either branch of the if)

/**

 * scsi_request_sense - Request sense data from a particular target.

 * @scmd:	SCSI cmd for request sense.

 *

 * Notes:

 *    Some hosts automatically obtain this information, others require

 *    that we obtain it on our own. This function will *not* return until

 *    the command either times out, or it completes.

/**

 * scsi_eh_finish_cmd - Handle a cmd that eh is finished with.

 * @scmd:	Original SCSI cmd that eh has finished.

 * @done_q:	Queue for processed commands.

 *

 * Notes:

 *    We don't want to use the normal command completion while we are are

 *    still handling errors - it may cause other commands to be queued,

 *    and that would disturb what we are doing.  Thus we really want to

 *    keep a list of pending commands for final completion, and once we

 *    are ready to leave error handling we handle completion for real.

/**

 * scsi_eh_get_sense - Get device sense data.

 * @work_q:	Queue of commands to process.

 * @done_q:	Queue of processed commands.

 *

 * Description:

 *    See if we need to request sense information.  if so, then get it

 *    now, so we have a better idea of what to do.

 *

 * Notes:

 *    This has the unfortunate side effect that if a shost adapter does

 *    not automatically request sense information, we end up shutting

 *    it down before we request it.

 *

 *    All drivers should request sense information internally these days,

 *    so for now all I have to say is tough noogies if you end up in here.

 *

 *    XXX: Long term this code should go away, but that needs an audit of

 *         all LLDDs first.

	/*

	 * If SCSI_EH_ABORT_SCHEDULED has been set, it is timeout IO,

	 * should not get sense.

			/*

			 * don't request sense if there's no check condition

			 * status because the error we're processing isn't one

			 * that has a sense code (and some devices get

			 * confused by sense requests out of the blue)

		/*

		 * if the result was normal, then just pass it along to the

		 * upper level.

			/*

			 * We don't want this command reissued, just finished

			 * with the sense data, so set retries to the max

			 * allowed to ensure it won't get reissued. If the user

			 * has requested infinite retries, we also want to

			 * finish this command, so force completion by setting

			 * retries and allowed to the same value.

/**

 * scsi_eh_tur - Send TUR to device.

 * @scmd:	&scsi_cmnd to send TUR

 *

 * Return value:

 *    0 - Device is ready. 1 - Device NOT ready.

/**

 * scsi_eh_test_devices - check if devices are responding from error recovery.

 * @cmd_list:	scsi commands in error recovery.

 * @work_q:	queue for commands which still need more error recovery

 * @done_q:	queue for commands which are finished

 * @try_stu:	boolean on if a STU command should be tried in addition to TUR.

 *

 * Decription:

 *    Tests if devices are in a working state.  Commands to devices now in

 *    a working state are sent to the done_q while commands to devices which

 *    are still failing to respond are returned to the work_q for more

 *    processing.

 Push items back onto work_q */

/**

 * scsi_eh_try_stu - Send START_UNIT to device.

 * @scmd:	&scsi_cmnd to send START_UNIT

 *

 * Return value:

 *    0 - Device is ready. 1 - Device NOT ready.

 /**

 * scsi_eh_stu - send START_UNIT if needed

 * @shost:	&scsi host being recovered.

 * @work_q:	&list_head for pending commands.

 * @done_q:	&list_head for processed commands.

 *

 * Notes:

 *    If commands are failing due to not ready, initializing command required,

 *	try revalidating the device, which will end up sending a start unit.

/**

 * scsi_eh_bus_device_reset - send bdr if needed

 * @shost:	scsi host being recovered.

 * @work_q:	&list_head for pending commands.

 * @done_q:	&list_head for processed commands.

 *

 * Notes:

 *    Try a bus device reset.  Still, look to see whether we have multiple

 *    devices that are jammed or not - if we have multiple devices, it

 *    makes no sense to try bus_device_reset - we really would need to try

 *    a bus_reset instead.

/**

 * scsi_eh_target_reset - send target reset if needed

 * @shost:	scsi host being recovered.

 * @work_q:	&list_head for pending commands.

 * @done_q:	&list_head for processed commands.

 *

 * Notes:

 *    Try a target reset.

 push back on work queue for further processing */

 push back on work queue for further processing */

/**

 * scsi_eh_bus_reset - send a bus reset

 * @shost:	&scsi host being recovered.

 * @work_q:	&list_head for pending commands.

 * @done_q:	&list_head for processed commands.

	/*

	 * we really want to loop over the various channels, and do this on

	 * a channel by channel basis.  we should also check to see if any

	 * of the failed commands are on soft_reset devices, and if so, skip

	 * the reset.

				/*

				 * FIXME add back in some support for

				 * soft_reset devices.

/**

 * scsi_eh_host_reset - send a host reset

 * @shost:	host to be reset.

 * @work_q:	&list_head for pending commands.

 * @done_q:	&list_head for processed commands.

/**

 * scsi_eh_offline_sdevs - offline scsi devices that fail to recover

 * @work_q:	&list_head for pending commands.

 * @done_q:	&list_head for processed commands.

/**

 * scsi_noretry_cmd - determine if command should be failed fast

 * @scmd:	SCSI cmd to examine.

	/*

	 * assume caller has checked sense and determined

	 * the check condition was retryable.

/**

 * scsi_decide_disposition - Disposition a cmd on return from LLD.

 * @scmd:	SCSI cmd to examine.

 *

 * Notes:

 *    This is *only* called when we are examining the status after sending

 *    out the actual data command.  any commands that are queued for error

 *    recovery (e.g. test_unit_ready) do *not* come through here.

 *

 *    When this routine returns failed, it means the error handler thread

 *    is woken.  In cases where the error code indicates an error that

 *    doesn't require the error handler read (i.e. we don't need to

 *    abort/reset), this function should return SUCCESS.

	/*

	 * if the device is offline, then we clearly just pass the result back

	 * up to the top level.

	/*

	 * first check the host byte, to see if there is anything in there

	 * that would indicate what we need to do.

		/*

		 * no matter what, pass this through to the upper layer.

		 * nuke this special code so that it looks like we are saying

		 * did_ok.

		/*

		 * looks good.  drop through, and check the next byte.

		/*

		 * note - this means that we just report the status back

		 * to the top level driver, not that we actually think

		 * that it indicates SUCCESS.

		/*

		 * when the low level driver returns did_soft_error,

		 * it is responsible for keeping an internal retry counter

		 * in order to avoid endless loops (db)

		/*

		 * LLD/transport was disrupted during processing of the IO.

		 * The transport class is now blocked/blocking,

		 * and the transport will decide what to do with the IO

		 * based on its timers and recovery capablilities if

		 * there are enough retries.

		/*

		 * The transport decided to failfast the IO (most likely

		 * the fast io fail tmo fired), so send IO directly upwards.

		/*

		 * caller has decided not to do retries on

		 * abort success, so send IO directly upwards

			/*

			 * execute reservation conflict processing code

			 * lower down

		/*

		 * when we scan the bus, we get timeout messages for

		 * these commands if there is no device available.

		 * other hosts report did_no_connect for the same thing.

	/*

	 * check the status byte to see if this indicates anything special.

		/*

		 * the case of trying to send too many commands to a

		 * tagged queueing device.

		/*

		 * device can't talk to us at the moment.  Should only

		 * occur (SAM-3) when the task queue is empty, so will cause

		 * the empty queue handling to trigger a stall in the

		 * device.

		/* if rtn == FAILED, we have no sense information;

		 * returning FAILED will wake the error handler thread

		 * to collect the sense and redo the decide

		/*

		 * who knows?  FIXME(eric)

 causes immediate i/o error */

	/* we requeue for retry because the error was retryable, and

	 * the request was not marked fast fail.  Note that above,

	 * even if the request is marked fast fail, we still requeue

		/*

		 * no more retries - report this one back to upper level.

/**

 * scsi_eh_lock_door - Prevent medium removal for the specified device

 * @sdev:	SCSI device to prevent medium removal

 *

 * Locking:

 * 	We must be called from process context.

 *

 * Notes:

 * 	We queue up an asynchronous "ALLOW MEDIUM REMOVAL" request on the

 * 	head of the devices request queue, and continue.

/**

 * scsi_restart_operations - restart io operations to the specified host.

 * @shost:	Host we are restarting.

 *

 * Notes:

 *    When we entered the error handler, we blocked all further i/o to

 *    this device.  we need to 'reverse' this process.

	/*

	 * If the door was locked, we need to insert a door lock request

	 * onto the head of the SCSI request queue for the device.  There

	 * is no point trying to lock the door of an off-line device.

	/*

	 * next free up anything directly waiting upon the host.  this

	 * will be requests for character device operations, and also for

	 * ioctls to queued block devices.

	/*

	 * finally we need to re-initiate requests that may be pending.  we will

	 * have had everything blocked while error handling is taking place, and

	 * now that error recovery is done, we will need to ensure that these

	 * requests are started.

	/*

	 * if eh is active and host_eh_scheduled is pending we need to re-run

	 * recovery.  we do this check after scsi_run_host_queues() to allow

	 * everything pent up since the last eh run a chance to make forward

	 * progress before we sync again.  Either we'll immediately re-run

	 * recovery or scsi_device_unbusy() will wake us again when these

	 * pending commands complete.

/**

 * scsi_eh_ready_devs - check device ready state and recover if not.

 * @shost:	host to be recovered.

 * @work_q:	&list_head for pending commands.

 * @done_q:	&list_head for processed commands.

/**

 * scsi_eh_flush_done_q - finish processed commands or retry them.

 * @done_q:	list_head of processed commands.

			/*

			 * If just we got sense for the device (called

			 * scsi_eh_get_sense), scmd->result is already

			 * set, do not set DID_TIME_OUT.

/**

 * scsi_unjam_host - Attempt to fix a host which has a cmd that failed.

 * @shost:	Host to unjam.

 *

 * Notes:

 *    When we come in here, we *know* that all commands on the bus have

 *    either completed, failed or timed out.  we also know that no further

 *    commands are being sent to the host, so things are relatively quiet

 *    and we have freedom to fiddle with things as we wish.

 *

 *    This is only the *default* implementation.  it is possible for

 *    individual drivers to supply their own version of this function, and

 *    if the maintainer wishes to do this, it is strongly suggested that

 *    this function be taken as a template and modified.  this function

 *    was designed to correctly handle problems for about 95% of the

 *    different cases out there, and it should always provide at least a

 *    reasonable amount of error recovery.

 *

 *    Any command marked 'failed' or 'timeout' must eventually have

 *    scsi_finish_cmd() called for it.  we do all of the retry stuff

 *    here, so when we restart the host after we return it should have an

 *    empty queue.

/**

 * scsi_error_handler - SCSI error handler thread

 * @data:	Host for which we are running.

 *

 * Notes:

 *    This is the main error handling loop.  This is run as a kernel thread

 *    for every SCSI host and handles all error handling activity.

	/*

	 * We use TASK_INTERRUPTIBLE so that the thread is not

	 * counted against the load average as a running process.

	 * We never actually get interrupted because kthread_run

	 * disables signal delivery for the created thread.

		/*

		 * The sequence in kthread_stop() sets the stop flag first

		 * then wakes the process.  To avoid missed wakeups, the task

		 * should always be in a non running state before the stop

		 * flag is checked

		/*

		 * We have a host that is failing for some reason.  Figure out

		 * what we need to do to get it up and online again (if we can).

		 * If we fail, we end up taking the thing offline.

 All scmds have been handled */

		/*

		 * Note - if the above fails completely, the action is to take

		 * individual devices offline and flush the queue of any

		 * outstanding requests that may have been pending.  When we

		 * restart, we restart any I/O to any other devices on the bus

		 * which are still online.

/*

 * Function:    scsi_report_bus_reset()

 *

 * Purpose:     Utility function used by low-level drivers to report that

 *		they have observed a bus reset on the bus being handled.

 *

 * Arguments:   shost       - Host in question

 *		channel     - channel on which reset was observed.

 *

 * Returns:     Nothing

 *

 * Lock status: Host lock must be held.

 *

 * Notes:       This only needs to be called if the reset is one which

 *		originates from an unknown location.  Resets originated

 *		by the mid-level itself don't need to call this, but there

 *		should be no harm.

 *

 *		The main purpose of this is to make sure that a CHECK_CONDITION

 *		is properly treated.

/*

 * Function:    scsi_report_device_reset()

 *

 * Purpose:     Utility function used by low-level drivers to report that

 *		they have observed a device reset on the device being handled.

 *

 * Arguments:   shost       - Host in question

 *		channel     - channel on which reset was observed

 *		target	    - target on which reset was observed

 *

 * Returns:     Nothing

 *

 * Lock status: Host lock must be held

 *

 * Notes:       This only needs to be called if the reset is one which

 *		originates from an unknown location.  Resets originated

 *		by the mid-level itself don't need to call this, but there

 *		should be no harm.

 *

 *		The main purpose of this is to make sure that a CHECK_CONDITION

 *		is properly treated.

/**

 * scsi_ioctl_reset: explicitly reset a host/bus/target/device

 * @dev:	scsi_device to operate on

 * @arg:	reset type (see sg.h)

	/*

	 * be sure to wake up anyone who was sleeping or had their queue

	 * suspended while we performed the TMF.

/**

 * scsi_get_sense_info_fld - get information field from sense data (either fixed or descriptor format)

 * @sense_buffer:	byte array of sense data

 * @sb_len:		number of valid bytes in sense_buffer

 * @info_out:		pointer to 64 integer where 8 or 4 byte information

 *			field will be placed if found.

 *

 * Return value:

 *	true if information field found, false if not found.

 info desc */);

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  FiberChannel transport specific attributes exported to sysfs.

 *

 *  Copyright (c) 2003 Silicon Graphics, Inc.  All rights reserved.

 *  Copyright (C) 2004-2007   James Smart, Emulex Corporation

 *    Rewrite for host, target, device, and remote port attributes,

 *    statistics, and service functions...

 *    Add vports, etc

/*

 * Module Parameters

/*

 * dev_loss_tmo: the default number of seconds that the FC transport

 *   should insulate the loss of a remote port.

 *   The maximum will be capped by the value of SCSI_DEVICE_BLOCK_MAX_TIMEOUT.

 seconds */

/*

 * Redefine so that we can have same named attributes in the

 * sdev/starget/host objects.

 success */				\

 failure */						\

 Convert fc_port_type values to ascii string name */

 Reuse fc_port_type enum function for vport_type */

 Convert fc_host_event_code values to ascii string name */

 Convert fc_port_state values to ascii string name */

 Convert fc_vport_state values to ascii string name */

 Reuse fc_vport_state enum function for vport_last_state */

 Convert fc_tgtid_binding_type values to ascii string name */

 Convert FC_COS bit values to ascii string name */

 Convert FC_PORTSPEED bit values to ascii string name */

 Convert FC_PORT_ROLE bit values to ascii string name */

/*

 * Define roles that are specific to port_id. Values are relative to ROLE_MASK.

/*

 * Attribute counts pre object type...

 * Increase these values if you add attributes

	/*

	 * For attributes : each object has :

	 *   An array of the actual attributes structures

	 *   An array of null-terminated pointers to the attribute

	 *     structures - used for mid-layer interaction.

	 *

	 * The attribute containers for the starget and host are are

	 * part of the midlayer. As the remote port is specific to the

	 * fc transport, we must provide the attribute container.

	/*

	 * if parent is remote port, use values from remote port.

	 * Otherwise, this host uses the fc_transport, but not the

	 * remote port interface. As such, initialize to known non-values.

	/*

	 * Set default values easily detected by the midlayer as

	 * failure cases.  The scsi lldd is responsible for initializing

	 * all transport attributes to valid values per host.

 ignore any bsg add error - we just can't do sgio */

/*

 * Setup and Remove actions for remote ports are handled

 * in the service functions below.

/*

 * Setup and Remove actions for virtual ports are handled

 * in the service functions below.

/*

 * Netlink Infrastructure

/**

 * fc_get_event_number - Obtain the next sequential FC event number

 *

 * Notes:

 *   We could have inlined this, but it would have required fc_event_seq to

 *   be exposed. For now, live with the subroutine call.

 *   Atomic used to avoid lock/unlock...

/**

 * fc_host_post_fc_event - routine to do the work of posting an event

 *                      on an fc_host.

 * @shost:		host the event occurred on

 * @event_number:	fc event number obtained from get_fc_event_number()

 * @event_code:		fc_host event being posted

 * @data_len:		amount, in bytes, of event data

 * @data_buf:		pointer to event data

 * @vendor_id:          value for Vendor id

 *

 * Notes:

 *	This routine assumes no locks are held on entry.

 bytes */

/**

 * fc_host_post_event - called to post an even on an fc_host.

 * @shost:		host the event occurred on

 * @event_number:	fc event number obtained from get_fc_event_number()

 * @event_code:		fc_host event being posted

 * @event_data:		32bits of data for the event being posted

 *

 * Notes:

 *	This routine assumes no locks are held on entry.

/**

 * fc_host_post_vendor_event - called to post a vendor unique event

 *                      on an fc_host

 * @shost:		host the event occurred on

 * @event_number:	fc event number obtained from get_fc_event_number()

 * @data_len:		amount, in bytes, of vendor unique data

 * @data_buf:		pointer to vendor unique data

 * @vendor_id:          Vendor id

 *

 * Notes:

 *	This routine assumes no locks are held on entry.

/**

 * fc_find_rport_by_wwpn - find the fc_rport pointer for a given wwpn

 * @shost:		host the fc_rport is associated with

 * @wwpn:		wwpn of the fc_rport device

 *

 * Notes:

 *	This routine assumes no locks are held on entry.

/*

 * fc_fpin_li_stats_update - routine to update Link Integrity

 * event statistics.

 * @shost:		host the FPIN was received on

 * @tlv:		pointer to link integrity descriptor

 *

/*

 * fc_fpin_delivery_stats_update - routine to update Delivery Notification

 * event statistics.

 * @shost:		host the FPIN was received on

 * @tlv:		pointer to delivery descriptor

 *

/*

 * fc_fpin_peer_congn_stats_update - routine to update Peer Congestion

 * event statistics.

 * @shost:		host the FPIN was received on

 * @tlv:		pointer to peer congestion descriptor

 *

/*

 * fc_fpin_congn_stats_update - routine to update Congestion

 * event statistics.

 * @shost:		host the FPIN was received on

 * @tlv:		pointer to congestion descriptor

 *

/**

 * fc_host_fpin_rcv - routine to process a received FPIN.

 * @shost:		host the FPIN was received on

 * @fpin_len:		length of FPIN payload, in bytes

 * @fpin_buf:		pointer to FPIN payload

 *

 * Notes:

 *	This routine assumes no locks are held on entry.

 Update Statistics */

/*

 * FC Remote Port Attribute Management

 The FC Transport Remote Port Attributes: */

 Fixed Remote Port Attributes */

 Dynamic Remote Port Attributes */

/*

 * dev_loss_tmo attribute

	/*

	 * Check for overflow; dev_loss_tmo is u32

	/*

	 * Check for overflow; dev_loss_tmo is u32

	/*

	 * If fast_io_fail is off we have to cap

	 * dev_loss_tmo at SCSI_DEVICE_BLOCK_MAX_TIMEOUT

 Private Remote Port Attributes */

 identify any roles that are port_id specific */

		/*

		 * Change the state to Marginal only if the

		 * current rport state is Online

		 * Allow only Online->Marginal

		/*

		 * Change the state to Online only if the

		 * current rport state is Marginal

		 * Allow only Marginal->Online

/*

 * fast_io_fail_tmo attribute

		/*

		 * Cap fast_io_fail by dev_loss_tmo or

		 * SCSI_DEVICE_BLOCK_MAX_TIMEOUT.

/*

 * FC SCSI Target Attribute Management

/*

 * Note: in the target show function we recognize when the remote

 *  port is in the hierarchy and do not allow the driver to get

 *  involved in sysfs functions. The driver only gets involved if

 *  it's the "old" style that doesn't use rports.

 The FC Transport SCSI Target Attributes: */

/*

 * FC Virtual Port Attribute Management

 count may include a LF at end of string */			\

 NOTE: Above MACRO differs: checks function not show bit */

 NOTE: Above MACRO differs: checks function */

 NOTE: Above MACRO differs: does not check show bit */

 The FC Transport Virtual Port Attributes: */

 Fixed Virtual Port Attributes */

 Dynamic Virtual Port Attributes */

 Private Virtual Port Attributes */

/*

 * Enable/Disable vport

 *  Write "1" to disable, write "0" to enable

/*

 * Host Attribute Management

 count may include a LF at end of string */			\

 Fixed Host Attributes */

 Dynamic Host Attributes */

 Private Host Attributes */

 if changing bind type, purge all unused consistent bindings */

 ignore any data value written to the attribute */

/*

 * Host Statistics Management

 Show a given attribute in the statistics group */

 generate a read-only statistics attribute */

 ignore any data value written to the attribute */

 Host Vport Attributes */

 Validate and store the new name */

/*

 * "Short-cut" sysfs variable to create a new vport on a FC Host.

 * Input is a string of the form "<WWPN>:<WWNN>". Other attributes

 * will default to a NPIV-based FCP_Initiator; The WWNs are specified

 * as hex characters, and may *not* contain any prefixes (e.g. 0x, x, etc)

 count may include a LF at end of string */

 validate we have enough characters for WWPN */

 vid.symbolic_name is already zero/NULL's */

 always enabled */

 we only allow support on Channel 0 !!! */

/*

 * "Short-cut" sysfs variable to delete a vport on a FC Host.

 * Vport is identified by a string containing "<WWPN>:<WWNN>".

 * The WWNs are specified as hex characters, and may *not* contain

 * any prefixes (e.g. 0x, x, etc)

 count may include a LF at end of string */

 validate we have enough characters for WWPN */

 we only allow support on Channel 0 !!! */

 release kobj parent */

/**

 * fc_eh_timed_out - FC Transport I/O timeout intercept handler

 * @scmd:	The SCSI command which timed out

 *

 * This routine protects against error handlers getting invoked while a

 * rport is in a blocked state, typically due to a temporarily loss of

 * connectivity. If the error handlers are allowed to proceed, requests

 * to abort i/o, reset the target, etc will likely fail as there is no way

 * to communicate with the device to perform the requested function. These

 * failures may result in the midlayer taking the device offline, requiring

 * manual intervention to restore operation.

 *

 * This routine, called whenever an i/o times out, validates the state of

 * the underlying rport. If the rport is blocked, it returns

 * EH_RESET_TIMER, which will continue to reschedule the timeout.

 * Eventually, either the device will return, or devloss_tmo will fire,

 * and when the timeout then fires, it will be handled normally.

 * If the rport is not blocked, normal error handling continues.

 *

 * Notes:

 *	This routine assumes no locks are held on entry.

/*

 * Called by fc_user_scan to locate an rport on the shost that

 * matches the channel and target id, and invoke scsi_scan_target()

 * on the rport.

/*

 * Called via sysfs scan routines. Necessary, as the FC transport

 * wants to place all target objects below the rport object. So this

 * routine must invoke the scsi_scan_target() routine with the rport

 * object as the parent.

 Transport uses the shost workq for scsi scanning */

	/*

	 * Setup SCSI Target Attributes.

	/*

	 * Setup SCSI Host Attributes.

 Transport-managed attributes */

	/*

	 * Setup Remote Port Attributes.

	/*

	 * Setup Virtual Port Attributes.

/**

 * fc_queue_work - Queue work to the fc_host workqueue.

 * @shost:	Pointer to Scsi_Host bound to fc_host.

 * @work:	Work to queue for execution.

 *

 * Return value:

 * 	1 - work queued for execution

 *	0 - work is already queued

 *	-EINVAL - work queue doesn't exist

/**

 * fc_flush_work - Flush a fc_host's workqueue.

 * @shost:	Pointer to Scsi_Host bound to fc_host.

/**

 * fc_queue_devloss_work - Schedule work for the fc_host devloss workqueue.

 * @shost:	Pointer to Scsi_Host bound to fc_host.

 * @work:	Work to queue for execution.

 * @delay:	jiffies to delay the work queuing

 *

 * Return value:

 * 	1 on success / 0 already queued / < 0 for error

/**

 * fc_flush_devloss - Flush a fc_host's devloss workqueue.

 * @shost:	Pointer to Scsi_Host bound to fc_host.

/**

 * fc_remove_host - called to terminate any fc_transport-related elements for a scsi host.

 * @shost:	Which &Scsi_Host

 *

 * This routine is expected to be called immediately preceding the

 * a driver's call to scsi_remove_host().

 *

 * WARNING: A driver utilizing the fc_transport, which fails to call

 *   this routine prior to scsi_remove_host(), will leave dangling

 *   objects in /sys/class/fc_remote_ports. Access to any of these

 *   objects can result in a system crash !!!

 *

 * Notes:

 *	This routine assumes no locks are held on entry.

 Remove any vports */

 Remove any remote ports */

 flush all scan work items */

 flush all stgt delete, and rport delete work items, then kill it  */

 flush all devloss work items, then kill it  */

 Involve the LLDD if possible to terminate all io on the rport. */

	/*

	 * Must unblock to flush queued IO. scsi-ml will fail incoming reqs.

/**

 * fc_starget_delete - called to delete the scsi descendants of an rport

 * @work:	remote port to be operated on.

 *

 * Deletes target and all sdevs.

/**

 * fc_rport_final_delete - finish rport termination and delete it.

 * @work:	remote port to be deleted.

	/*

	 * if a scan is pending, flush the SCSI Host work_q so that

	 * that we can reclaim the rport scan work element.

	/*

	 * Cancel any outstanding timers. These should really exist

	 * only when rmmod'ing the LLDD and we're asking for

	 * immediate termination of the rports

 Delete SCSI target and sdevs */

	/*

	 * Notify the driver that the rport is now dead. The LLDD will

	 * also guarantee that any communication to the rport is terminated

	 *

	 * Avoid this call if we already called it when we preserved the

	 * rport for the binding.

 for fc_host->rport list */

 for self-reference */

/**

 * fc_remote_port_create - allocates and creates a remote FC port.

 * @shost:	scsi host the remote port is connected to.

 * @channel:	Channel on shost port connected to.

 * @ids:	The world wide names, fc address, and FC4 port

 *		roles for the remote port.

 *

 * Allocates and creates the remoter port structure, including the

 * class and sysfs creation.

 *

 * Notes:

 *	This routine assumes no locks are held on entry.

 for fc_host->rport list */

 takes self reference */

 parent reference */

 ignore any bsg add error - we just can't do sgio */

 initiate a scan of the target */

 for fc_host->rport list */

/**

 * fc_remote_port_add - notify fc transport of the existence of a remote FC port.

 * @shost:	scsi host the remote port is connected to.

 * @channel:	Channel on shost port connected to.

 * @ids:	The world wide names, fc address, and FC4 port

 *		roles for the remote port.

 *

 * The LLDD calls this routine to notify the transport of the existence

 * of a remote port. The LLDD provides the unique identifiers (wwpn,wwn)

 * of the port, it's FC address (port_id), and the FC4 roles that are

 * active for the port.

 *

 * For ports that are FCP targets (aka scsi targets), the FC transport

 * maintains consistent target id bindings on behalf of the LLDD.

 * A consistent target id binding is an assignment of a target id to

 * a remote port identifier, which persists while the scsi host is

 * attached. The remote port can disappear, then later reappear, and

 * it's target id assignment remains the same. This allows for shifts

 * in FC addressing (if binding by wwpn or wwnn) with no apparent

 * changes to the scsi subsystem which is based on scsi host number and

 * target id values.  Bindings are only valid during the attachment of

 * the scsi host. If the host detaches, then later re-attaches, target

 * id bindings may change.

 *

 * This routine is responsible for returning a remote port structure.

 * The routine will search the list of remote ports it maintains

 * internally on behalf of consistent target id mappings. If found, the

 * remote port structure will be reused. Otherwise, a new remote port

 * structure will be allocated.

 *

 * Whenever a remote port is allocated, a new fc_remote_port class

 * device is created.

 *

 * Should not be called from interrupt context.

 *

 * Notes:

 *	This routine assumes no locks are held on entry.

 ensure any stgt delete functions are done */

	/*

	 * Search the list of "active" rports, for an rport that has been

	 * deleted, but we've held off the real delete while the target

	 * is in a "blocked" state.

				/*

				 * If we were not a target, cancel the

				 * io terminate and rport timers, and

				 * we're done.

				 *

				 * If we were a target, but our new role

				 * doesn't indicate a target, leave the

				 * timers running expecting the role to

				 * change as the target fully logs in. If

				 * it doesn't, the target will be torn down.

				 *

				 * If we were a target, and our role shows

				 * we're still a target, cancel the timers

				 * and kick off a scan.

 was a target, not in roles */

				/*

				 * Stop the fail io and dev_loss timers.

				 * If they flush, the port_state will

				 * be checked and will NOOP the function.

 if target, initiate a scan */

	/*

	 * Search the bindings array

	 * Note: if never a FCP target, you won't be on this list

 search for a matching consistent binding */

 to keep compiler happy */

 No consistent binding found - create new remote port entry */

/**

 * fc_remote_port_delete - notifies the fc transport that a remote port is no longer in existence.

 * @rport:	The remote port that no longer exists

 *

 * The LLDD calls this routine to notify the transport that a remote

 * port is no longer part of the topology. Note: Although a port

 * may no longer be part of the topology, it may persist in the remote

 * ports displayed by the fc_host. We do this under 2 conditions:

 *

 * 1) If the port was a scsi target, we delay its deletion by "blocking" it.

 *    This allows the port to temporarily disappear, then reappear without

 *    disrupting the SCSI device tree attached to it. During the "blocked"

 *    period the port will still exist.

 *

 * 2) If the port was a scsi target and disappears for longer than we

 *    expect, we'll delete the port and the tear down the SCSI device tree

 *    attached to it. However, we want to semi-persist the target id assigned

 *    to that port if it eventually does exist. The port structure will

 *    remain (although with minimal information) so that the target id

 *    bindings also remain.

 *

 * If the remote port is not an FCP Target, it will be fully torn down

 * and deallocated, including the fc_remote_port class device.

 *

 * If the remote port is an FCP Target, the port will be placed in a

 * temporary blocked state. From the LLDD's perspective, the rport no

 * longer exists. From the SCSI midlayer's perspective, the SCSI target

 * exists, but all sdevs on it are blocked from further I/O. The following

 * is then expected.

 *

 *   If the remote port does not return (signaled by a LLDD call to

 *   fc_remote_port_add()) within the dev_loss_tmo timeout, then the

 *   scsi target is removed - killing all outstanding i/o and removing the

 *   scsi devices attached to it. The port structure will be marked Not

 *   Present and be partially cleared, leaving only enough information to

 *   recognize the remote port relative to the scsi target id binding if

 *   it later appears.  The port will remain as long as there is a valid

 *   binding (e.g. until the user changes the binding type or unloads the

 *   scsi host with the binding).

 *

 *   If the remote port returns within the dev_loss_tmo value (and matches

 *   according to the target id binding type), the port structure will be

 *   reused. If it is no longer a SCSI target, the target will be torn

 *   down. If it continues to be a SCSI target, then the target will be

 *   unblocked (allowing i/o to be resumed), and a scan will be activated

 *   to ensure that all luns are detected.

 *

 * Called from normal process context only - cannot be called from interrupt.

 *

 * Notes:

 *	This routine assumes no locks are held on entry.

	/*

	 * No need to flush the fc_host work_q's, as all adds are synchronous.

	 *

	 * We do need to reclaim the rport scan work element, so eventually

	 * (in fc_rport_final_delete()) we'll flush the scsi host work_q if

	 * there's still a scan pending.

	/*

	 * In the past, we if this was not an FCP-Target, we would

	 * unconditionally just jump to deleting the rport.

	 * However, rports can be used as node containers by the LLDD,

	 * and its not appropriate to just terminate the rport at the

	 * first sign of a loss in connectivity. The LLDD may want to

	 * send ELS traffic to re-validate the login. If the rport is

	 * immediately deleted, it makes it inappropriate for a node

	 * container.

	 * So... we now unconditionally wait dev_loss_tmo before

	 * destroying an rport.

 see if we need to kill io faster than waiting for device loss */

 cap the length the devices can be blocked until they are deleted */

/**

 * fc_remote_port_rolechg - notifies the fc transport that the roles on a remote may have changed.

 * @rport:	The remote port that changed.

 * @roles:      New roles for this port.

 *

 * Description: The LLDD calls this routine to notify the transport that the

 * roles on a remote port may have changed. The largest effect of this is

 * if a port now becomes a FCP Target, it must be allocated a

 * scsi target id.  If the port is no longer a FCP target, any

 * scsi target id value assigned to it will persist in case the

 * role changes back to include FCP Target. No changes in the scsi

 * midlayer will be invoked if the role changes (in the expectation

 * that the role will be resumed. If it doesn't normal error processing

 * will take place).

 *

 * Should not be called from interrupt context.

 *

 * Notes:

 *	This routine assumes no locks are held on entry.

		/*

		 * There may have been a delete timer running on the

		 * port. Ensure that it is cancelled as we now know

		 * the port is an FCP Target.

		 * Note: we know the rport exists and is in an online

		 *  state as the LLDD would not have had an rport

		 *  reference to pass us.

		 *

		 * Take no action on the del_timer failure as the state

		 * machine state change will validate the

		 * transaction.

 ensure any stgt delete functions are done */

 initiate a scan of the target */

/**

 * fc_timeout_deleted_rport - Timeout handler for a deleted remote port.

 * @work:	rport target that failed to reappear in the allotted time.

 *

 * Description: An attempt to delete a remote port blocks, and if it fails

 *              to return in the allotted time this gets called.

	/*

	 * If the port is ONLINE, then it came back. If it was a SCSI

	 * target, validate it still is. If not, tear down the

	 * scsi_target on it.

 NOOP state - we're flushing workq's */

	/*

	 * Note: We do not remove or clear the hostdata area. This allows

	 *   host-specific target data to persist along with the

	 *   scsi_target_id. It's up to the host to manage it's hostdata area.

	/*

	 * Reinitialize port attributes that may change if the port comes back.

	/*

	 * Pre-emptively kill I/O rather than waiting for the work queue

	 * item to teardown the starget. (FCOE libFC folks prefer this

	 * and to have the rport_port_id still set when it's done).

 still missing */

 remove the identifiers that aren't used in the consisting binding */

 to keep compiler happy */

		/*

		 * As this only occurs if the remote port (scsi target)

		 * went away and didn't come back - we'll remove

		 * all attached scsi devices.

	/*

	 * Notify the driver that the rport is now dead. The LLDD will

	 * also guarantee that any communication to the rport is terminated

	 *

	 * Note: we set the CALLBK_DONE flag above to correspond

/**

 * fc_timeout_fail_rport_io - Timeout handler for a fast io failing on a disconnected SCSI target.

 * @work:	rport to terminate io on.

 *

 * Notes: Only requests the failure of the io, not that all are flushed

 *    prior to returning.

/**

 * fc_scsi_scan_rport - called to perform a scsi scan on a remote port.

 * @work:	remote port to be scanned.

/**

 * fc_block_rport() - Block SCSI eh thread for blocked fc_rport.

 * @rport: Remote port that scsi_eh is trying to recover.

 *

 * This routine can be called from a FC LLD scsi_eh callback. It

 * blocks the scsi_eh thread until the fc_rport leaves the

 * FC_PORTSTATE_BLOCKED, or the fast_io_fail_tmo fires. This is

 * necessary to avoid the scsi_eh failing recovery actions for blocked

 * rports which would lead to offlined SCSI devices.

 *

 * Returns: 0 if the fc_rport left the state FC_PORTSTATE_BLOCKED.

 *	    FAST_IO_FAIL if the fast_io_fail_tmo fired, this should be

 *	    passed back to scsi_eh.

/**

 * fc_block_scsi_eh - Block SCSI eh thread for blocked fc_rport

 * @cmnd: SCSI command that scsi_eh is trying to recover

 *

 * This routine can be called from a FC LLD scsi_eh callback. It

 * blocks the scsi_eh thread until the fc_rport leaves the

 * FC_PORTSTATE_BLOCKED, or the fast_io_fail_tmo fires. This is

 * necessary to avoid the scsi_eh failing recovery actions for blocked

 * rports which would lead to offlined SCSI devices.

 *

 * Returns: 0 if the fc_rport left the state FC_PORTSTATE_BLOCKED.

 *	    FAST_IO_FAIL if the fast_io_fail_tmo fired, this should be

 *	    passed back to scsi_eh.

/*

 * fc_eh_should_retry_cmd - Checks if the cmd should be retried or not

 * @scmd:        The SCSI command to be checked

 *

 * This checks the rport state to decide if a cmd is

 * retryable.

 *

 * Returns: true if the rport state is not in marginal state.

/**

 * fc_vport_setup - allocates and creates a FC virtual port.

 * @shost:	scsi host the virtual port is connected to.

 * @channel:	Channel on shost port connected to.

 * @pdev:	parent device for vport

 * @ids:	The world wide names, FC4 port roles, etc for

 *              the virtual port.

 * @ret_vport:	The pointer to the created vport.

 *

 * Allocates and creates the vport structure, calls the parent host

 * to instantiate the vport, this completes w/ class and sysfs creation.

 *

 * Notes:

 *	This routine assumes no locks are held on entry.

 for fc_host->vport list */

 takes self reference */

 takes parent reference */

	/*

	 * if the parent isn't the physical adapter's Scsi_Host, ensure

	 * the Scsi_Host at least contains a symlink to the vport.

 for fc_host->vport list */

/**

 * fc_vport_create - Admin App or LLDD requests creation of a vport

 * @shost:	scsi host the virtual port is connected to.

 * @channel:	channel on shost port connected to.

 * @ids:	The world wide names, FC4 port roles, etc for

 *              the virtual port.

 *

 * Notes:

 *	This routine assumes no locks are held on entry.

/**

 * fc_vport_terminate - Admin App or LLDD requests termination of a vport

 * @vport:	fc_vport to be terminated

 *

 * Calls the LLDD vport_delete() function, then deallocates and removes

 * the vport from the shost and object tree.

 *

 * Notes:

 *	This routine assumes no locks are held on entry.

 for fc_host->vport list */

	/*

	 * Removing our self-reference should mean our

	 * release function gets called, which will drop the remaining

	 * parent reference and free the data structure.

 for self-reference */

 SUCCESS */

/**

 * fc_vport_sched_delete - workq-based delete request for a vport

 * @work:	vport to be deleted.

/*

 * BSG support

/**

 * fc_bsg_job_timeout - handler for when a bsg request timesout

 * @req:	request that timed out

 call LLDD to abort the i/o as it has timed out */

 the blk_end_sync_io() doesn't check the error */

/**

 * fc_bsg_host_dispatch - process fc host bsg requests and dispatch to LLDD

 * @shost:	scsi host rport attached to

 * @job:	bsg job to be processed

 start with length of msgcode */

 check if we really have all the request data needed */

 Validate the host command */

 there better be a xmt and rcv payloads */

 there better be xmt and rcv payloads */

 return the errno failure code as the only status */

/*

 * fc_bsg_goose_queue - restart rport queue in case it was stopped

 * @rport:	rport to be restarted

/**

 * fc_bsg_rport_dispatch - process rport bsg requests and dispatch to LLDD

 * @shost:	scsi host rport attached to

 * @job:	bsg job to be processed

 start with length of msgcode */

 check if we really have all the request data needed */

 Validate the rport command */

 there better be xmt and rcv payloads */

 return the errno failure code as the only status */

/**

 * fc_bsg_hostadd - Create and add the bsg hooks so we can receive requests

 * @shost:	shost for fc_host

 * @fc_host:	fc_host adding the structures to

/**

 * fc_bsg_rportadd - Create and add the bsg hooks so we can receive requests

 * @shost:	shost that rport is attached to

 * @rport:	rport that the bsg hooks are being attached to

/**

 * fc_bsg_remove - Deletes the bsg hooks on fchosts/rports

 * @q:	the request_queue that is to be torn down.

 *

 * Notes:

 *   Before unregistering the queue empty any requests that are blocked

 *

 *

 Original Author:  Martin Hicks */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  scsi.c Copyright (C) 1992 Drew Eckhardt

 *         Copyright (C) 1993, 1994, 1995, 1999 Eric Youngdale

 *         Copyright (C) 2002, 2003 Christoph Hellwig

 *

 *  generic mid-level SCSI driver

 *      Initial versions: Drew Eckhardt

 *      Subsequent revisions: Eric Youngdale

 *

 *  <drew@colorado.edu>

 *

 *  Bug correction thanks go to :

 *      Rik Faith <faith@cs.unc.edu>

 *      Tommy Thorn <tthorn>

 *      Thomas Wuensche <tw@fgb1.fgb.mw.tu-muenchen.de>

 *

 *  Modified by Eric Youngdale eric@andante.org or ericy@gnu.ai.mit.edu to

 *  add scatter-gather, multiple outstanding request, and other

 *  enhancements.

 *

 *  Native multichannel, wide scsi, /proc/scsi and hot plugging

 *  support added by Michael Neuffer <mike@i-connect.net>

 *

 *  Added request_module("scsi_hostadapter") for kerneld:

 *  (Put an "alias scsi_hostadapter your_hostadapter" in /etc/modprobe.conf)

 *  Bjorn Ekwall  <bj0rn@blox.se>

 *  (changed to kmod)

 *

 *  Major improvements to the timeout, abort, and reset processing,

 *  as well as performance modifications for large queue depths by

 *  Leonard N. Zubkoff <lnz@dandelion.com>

 *

 *  Converted cli() code to spinlocks, Ingo Molnar

 *

 *  Jiffies wrap fixes (host->resetting), 3 Dec 1998 Andrea Arcangeli

 *

 *  out_of_space hacks, D. Gilbert (dpg) 990608

/*

 * Definitions and constants.

/*

 * Note - the initial logging level can be set here to log events at boot time.

 * After the system is up, you may enable logging via the /proc interface.

	/*

	 * If ML QUEUE log level is greater than or equal to:

	 *

	 * 1: nothing (match completion)

	 *

	 * 2: log opcode + command of all commands + cmd address

	 *

	 * 3: same as 2

	 *

	 * 4: same as 3

	/*

	 * If ML COMPLETE log level is greater than or equal to:

	 *

	 * 1: log disposition, result, opcode + command, and conditionally

	 * sense data for failures or non SUCCESS dispositions.

	 *

	 * 2: same as 1 but for all command completions.

	 *

	 * 3: same as 2

	 *

	 * 4: same as 3 plus dump extra junk

/**

 * scsi_finish_command - cleanup and pass command back to upper layer

 * @cmd: the command

 *

 * Description: Pass command off to upper layer for finishing of I/O

 *              request, waking processes that are waiting on results,

 *              etc.

	/*

	 * Clear the flags that say that the device/target/host is no longer

	 * capable of accepting new commands.

		/*

		 * USB may not give sense identifying bad sector and

		 * simply return a residue instead, so subtract off the

		 * residue if drv->done() error processing indicates no

		 * change to the completion length.

/*

 * 1024 is big enough for saturating the fast scsi LUN now

/**

 * scsi_change_queue_depth - change a device's queue depth

 * @sdev: SCSI Device in question

 * @depth: number of commands allowed to be queued to the driver

 *

 * Sets the device queue depth and returns the new value.

/**

 * scsi_track_queue_full - track QUEUE_FULL events to adjust queue depth

 * @sdev: SCSI Device in question

 * @depth: Current number of outstanding SCSI commands on this device,

 *         not counting the one returned as QUEUE_FULL.

 *

 * Description:	This function will track successive QUEUE_FULL events on a

 * 		specific SCSI device to determine if and when there is a

 * 		need to adjust the queue depth on the device.

 *

 * Returns:	0 - No change needed, >0 - Adjust queue depth to this new depth,

 * 		-1 - Drop back to untagged operation using host->cmd_per_lun

 * 			as the untagged command depth

 *

 * Lock Status:	None held on entry

 *

 * Notes:	Low level drivers may call this at any time and we will do

 * 		"The Right Thing."  We are interrupt context safe.

	/*

	 * Don't let QUEUE_FULLs on the same

	 * jiffies count, they could all be from

	 * same event.

/**

 * scsi_vpd_inquiry - Request a device provide us with a VPD page

 * @sdev: The device to ask

 * @buffer: Where to put the result

 * @page: Which Vital Product Data to return

 * @len: The length of the buffer

 *

 * This is an internal helper function.  You probably want to use

 * scsi_get_vpd_page instead.

 *

 * Returns size of the vpd page on success or a negative error number.

 EVPD */

 Control byte */

	/*

	 * I'm not convinced we need to try quite this hard to get VPD, but

	 * all the existing users tried this hard.

 Sanity check that we got the page back that we asked for */

/**

 * scsi_get_vpd_page - Get Vital Product Data from a SCSI device

 * @sdev: The device to ask

 * @page: Which Vital Product Data to return

 * @buf: where to store the VPD

 * @buf_len: number of bytes in the VPD buffer area

 *

 * SCSI devices may optionally supply Vital Product Data.  Each 'page'

 * of VPD is defined in the appropriate SCSI document (eg SPC, SBC).

 * If the device supports this VPD page, this routine returns a pointer

 * to a buffer containing the data from that page.  The caller is

 * responsible for calling kfree() on this pointer when it is no longer

 * needed.  If we cannot retrieve the VPD page this routine returns %NULL.

 Ask for all the pages supported by this device */

 If the user actually wanted this page, we can skip the rest */

 ran off the end of the buffer, give us benefit of doubt */

 The device claims it doesn't support the requested page */

/**

 * scsi_get_vpd_buf - Get Vital Product Data from a SCSI device

 * @sdev: The device to ask

 * @page: Which Vital Product Data to return

 *

 * Returns %NULL upon failure.

/**

 * scsi_attach_vpd - Attach Vital Product Data to a SCSI device structure

 * @sdev: The device to ask

 *

 * Attach the 'Device Identification' VPD page (0x83) and the

 * 'Unit Serial Number' VPD page (0x80) to a SCSI device

 * structure. This information can be used to identify the device

 * uniquely.

 Ask for all the pages supported by this device */

/**

 * scsi_report_opcode - Find out if a given command opcode is supported

 * @sdev:	scsi device to query

 * @buffer:	scratch buffer (must be at least 20 bytes long)

 * @len:	length of buffer

 * @opcode:	opcode for command to look up

 *

 * Uses the REPORT SUPPORTED OPERATION CODES to look up the given

 * opcode. Returns -EINVAL if RSOC fails, 0 if the command opcode is

 * unsupported and 1 if the device claims to support the command.

 One command format */

 Command supported */

/**

 * scsi_device_get  -  get an additional reference to a scsi_device

 * @sdev:	device to get a reference to

 *

 * Description: Gets a reference to the scsi_device and increments the use count

 * of the underlying LLDD module.  You must hold host_lock of the

 * parent Scsi_Host or already have a reference when calling this.

 *

 * This will fail if a device is deleted or cancelled, or when the LLD module

 * is in the process of being unloaded.

/**

 * scsi_device_put  -  release a reference to a scsi_device

 * @sdev:	device to release a reference on.

 *

 * Description: Release a reference to the scsi_device and decrements the use

 * count of the underlying LLDD module.  The device is freed once the last

 * user vanishes.

 helper for shost_for_each_device, see that for documentation */

 skip devices that we can't get a reference to */

/**

 * starget_for_each_device  -  helper to walk all devices of a target

 * @starget:	target whose devices we want to iterate over.

 * @data:	Opaque passed to each function call.

 * @fn:		Function to call on each device

 *

 * This traverses over each device of @starget.  The devices have

 * a reference that must be released by scsi_host_put when breaking

 * out of the loop.

/**

 * __starget_for_each_device - helper to walk all devices of a target (UNLOCKED)

 * @starget:	target whose devices we want to iterate over.

 * @data:	parameter for callback @fn()

 * @fn:		callback function that is invoked for each device

 *

 * This traverses over each device of @starget.  It does _not_

 * take a reference on the scsi_device, so the whole loop must be

 * protected by shost->host_lock.

 *

 * Note:  The only reason why drivers would want to use this is because

 * they need to access the device list in irq context.  Otherwise you

 * really want to use starget_for_each_device instead.

/**

 * __scsi_device_lookup_by_target - find a device given the target (UNLOCKED)

 * @starget:	SCSI target pointer

 * @lun:	SCSI Logical Unit Number

 *

 * Description: Looks up the scsi_device with the specified @lun for a given

 * @starget.  The returned scsi_device does not have an additional

 * reference.  You must hold the host's host_lock over this call and

 * any access to the returned scsi_device. A scsi_device in state

 * SDEV_DEL is skipped.

 *

 * Note:  The only reason why drivers should use this is because

 * they need to access the device list in irq context.  Otherwise you

 * really want to use scsi_device_lookup_by_target instead.

/**

 * scsi_device_lookup_by_target - find a device given the target

 * @starget:	SCSI target pointer

 * @lun:	SCSI Logical Unit Number

 *

 * Description: Looks up the scsi_device with the specified @lun for a given

 * @starget.  The returned scsi_device has an additional reference that

 * needs to be released with scsi_device_put once you're done with it.

/**

 * __scsi_device_lookup - find a device given the host (UNLOCKED)

 * @shost:	SCSI host pointer

 * @channel:	SCSI channel (zero if only one channel)

 * @id:		SCSI target number (physical unit number)

 * @lun:	SCSI Logical Unit Number

 *

 * Description: Looks up the scsi_device with the specified @channel, @id, @lun

 * for a given host. The returned scsi_device does not have an additional

 * reference.  You must hold the host's host_lock over this call and any access

 * to the returned scsi_device.

 *

 * Note:  The only reason why drivers would want to use this is because

 * they need to access the device list in irq context.  Otherwise you

 * really want to use scsi_device_lookup instead.

/**

 * scsi_device_lookup - find a device given the host

 * @shost:	SCSI host pointer

 * @channel:	SCSI channel (zero if only one channel)

 * @id:		SCSI target number (physical unit number)

 * @lun:	SCSI Logical Unit Number

 *

 * Description: Looks up the scsi_device with the specified @channel, @id, @lun

 * for a given host.  The returned scsi_device has an additional reference that

 * needs to be released with scsi_device_put once you're done with it.

 SPDX-License-Identifier: GPL-2.0

/*

 * ESP front-end for Amiga ZORRO SCSI systems.

 *

 * Copyright (C) 1996 Jesper Skov (jskov@cygnus.co.uk)

 *

 * Copyright (C) 2011,2018 Michael Schmitz (schmitz@debian.org) for

 *               migration to ESP SCSI core

 *

 * Copyright (C) 2013 Tuomas Vainikka (tuomas.vainikka@aalto.fi) for

 *               Blizzard 1230 DMA and probe function fixes

/*

 * ZORRO bus code from:

/*

 * Detection routine for the NCR53c710 based Amiga SCSI Controllers for Linux.

 *		Amiga MacroSystemUS WarpEngine SCSI controller.

 *		Amiga Technologies/DKB A4091 SCSI controller.

 *

 * Written 1997 by Alan Hourihane <alanh@fairlite.demon.co.uk>

 * plus modifications of the 53c7xx.c driver to support the Amiga.

 *

 * Rewritten to use 53c700.c by Kars de Jong <jongk@linux-m68k.org>

 per-board register layout definitions */

 Blizzard 1230 DMA interface */

 DMA address      [0x0000] */

 DMA latch        [0x8000] */

 Blizzard 1230II DMA interface */

 DMA address      [0x0000] */

 DMA latch        [0x0010] */

 Blizzard 2060 DMA interface */

 DMA led control   [0x000] */

 DMA address (MSB) [0x010] */

 DMA address       [0x014] */

 DMA address       [0x018] */

 DMA address (LSB) [0x01c] */

 DMA control bits */

 Cyberstorm DMA interface */

 DMA address (MSB) [0x000] */

 DMA address       [0x002] */

 DMA address       [0x004] */

 DMA address (LSB) [0x006] */

 DMA cond    (ro)  [0x402] */

 DMA control (wo)  [0x402] */

 DMA control bits */

 DMA direction. 1 = write */

 16 (Z2) or 32 (CHIP/Z3) bit DMA transfer */

 DMA status bits */

 DMA IRQ pending? */

 The CyberStorm II DMA interface */

 DMA cond    (ro)  [0x000] */

 DMA control (wo)  [0x000] */

 DMA address (MSB) [0x040] */

 DMA address       [0x044] */

 DMA address       [0x048] */

 DMA address (LSB) [0x04c] */

 Fastlane DMA interface */

 DMA status  (ro) [0x0000] */

 DMA control (wo) [0x0000] */

 DMA clear   (wo) [0x0040] */

/*

 * The controller registers can be found in the Z2 config area at these

 * offsets:

 DMA status bits */

 DMA control bits */

 1 = write */

 Enable DMA */

 Enable DMA IRQ ? */

 Enable SCSI IRQ */

/*

 * private data used for driver

 our ESP instance - for Scsi_host* */

 virtual address (Zorro III board) */

 board is Zorro III */

 shadow copy of ctrl_reg */

/*

 * On all implementations except for the Oktagon, padding between ESP

 * registers is three bytes.

 * On Oktagon, it is one byte - use a different accessor there.

 *

 * Oktagon needs PDMA - currently unsupported!

 check ESP status register; DMA has no status reg. */

 It's important to check the DMA IRQ bit in the correct way! */

 not our IRQ */

 Return non-zero if ESP requested IRQ */

 The old driver used 0xfffc as limit, so do that here too */

 nothing to do here */

 nothing to do here */

 nothing to do here */

 Blizzard 1230/60 SCSI-IV DMA */

	/*

	 * Use PIO if transferring message bytes to esp->command_block_dma.

	 * PIO requires a virtual address, so substitute esp->command_block

	 * for addr.

 Clear the results of a possible prior esp->ops->send_dma_cmd() */

 DMA receive */

 DMA send */

 Blizzard 1230-II DMA */

 Use PIO if transferring message bytes to esp->command_block_dma */

 DMA receive */

 DMA send */

 Blizzard 2060 DMA */

 Use PIO if transferring message bytes to esp->command_block_dma */

 DMA receive */

 DMA send */

 Cyberstorm I DMA */

 Use PIO if transferring message bytes to esp->command_block_dma */

 DMA receive */

 DMA send */

 Z2, do 16 bit DMA */

 Cyberstorm II DMA */

 Use PIO if transferring message bytes to esp->command_block_dma */

 DMA receive */

 DMA send */

 Fastlane DMA */

 Use PIO if transferring message bytes to esp->command_block_dma */

 DMA receive */

 DMA send */

 per-board ESP driver ops */

 Zorro driver config data */

 offset is absolute address */

 board types */

 per-board config data */

 Blizzard 1230 IV */

 Blizzard 1230 II (Zorro II) or Fastlane (Zorro III) */

 Blizzard 2060 */

 Cyberstorm */

 Cyberstorm II */

 let's figure out whether we have a Zorro II or Zorro III board */

		/*

		 * Even though most of these boards identify as Zorro II,

		 * they are in fact CPU expansion slot boards and have full

		 * access to all of memory. Fix up DMA bitmask here.

	/*

	 * If Zorro III and ID matches Fastlane, our device table entry

	 * contains data for the Blizzard 1230 II board which does share the

	 * same ID. Fix up device table entry here.

	 * TODO: Some Cyberstom060 boards also share this ID but would need

	 * to use the Cyberstorm I driver data ... we catch this by checking

	 * for presence of ESP chip later, but don't try to fix up yet.

 additional setup required for Fastlane */

 map full address space up to ESP base for DMA */

 initialize DMA control shadow register */

 ZorroII address space remapped nocache by early startup */

 Check whether a Blizzard 12x0 or CyberstormII really has SCSI */

		/*

		 * Only Fastlane Z3 for now - add switch for correct struct

		 * dma_registers size if adding any more

 ZorroII address space remapped nocache by early startup */

 register the chip */

/*  $Id$

 *  1993/03/31

 *  linux/kernel/aha1740.c

 *

 *  Based loosely on aha1542.c which is

 *  Copyright (C) 1992  Tommy Thorn and

 *  Modified by Eric Youngdale

 *

 *  This file is aha1740.c, written and

 *  Copyright (C) 1992,1993  Brad McLean

 *  brad@saturn.gaylord.com or brad@bradpc.gaylord.com.

 *  

 *  Modifications to makecode and queuecommand

 *  for proper handling of multiple devices courteously

 *  provided by Michael Weller, March, 1993

 *

 *  Multiple adapter support, extended translation detection,

 *  update to current scsi subsystem changes, proc fs support,

 *  working (!) module support based on patches from Andreas Arens,

 *  by Andreas Degert <ad@papyrus.hamburg.com>, 2/1997

 *

 * aha1740_makecode may still need even more work

 * if it doesn't work for your devices, take a look.

 *

 * Reworked for new_eh and new locking by Alan Cox <alan@lxorguk.ukuu.org.uk>

 *

 * Converted to EISA and generic DMA APIs by Marc Zyngier

 * <maz@wild-wind.fr.eu.org>, 4/2003.

 *

 * Shared interrupt support added by Rask Ingemann Lambertsen

 * <rask@sygehus.dk>, 10/2003

 *

 * For the avoidance of doubt the "preferred form" of this code is one which

 * is in an open non patent encumbered format. Where cryptographic key signing

 * forms part of the process of creating an executable the information

 * including keys needed to generate an equivalently functional executable

 * are deemed to be part of the source code.

/* IF YOU ARE HAVING PROBLEMS WITH THIS DRIVER, AND WANT TO WATCH

   IT WORK, THEN:

#define DEBUG

 Command Done - No Error */

 Data underrun */

 Queue full */

 Specification Check */

 Data overrun */

 Chaining Halted */

 Interrupt issued */

 Additional Status Available */

 Sense information Stored */

 Initialization Required */

 Major error or exception */

 Extended Contingent alliance */

 Anything abnormal was detected */

Additional info available*/

 Use the supplied info for further diagnostics */

 It's an Overrun */

				/* If not overrun, assume underrun and

			case 0x00: /* No info, assume no error, should

				/* Either by this driver or the

				retval=DID_ERROR; /* No further

						   * diagnostics

 Michael suggests, and Brad concurs: */

 forces a redo */

				/* I think this specific one should

 Didn't find a better error */

			/* In any other case return DID_OK so for example

			   CONDITION_CHECKS make it through to the appropriate

 Under all circumstances supply the target status -Michael */

 Okay, we're all set */

 A "high" level interrupt handler */

 interrupt reset */

 Host Ready -> Mailbox in complete */

 Free the sg block */

			/* Fetch the sense data, and tuck it away, in

			   the required slot.  The Adaptec

			   automatically fetches it, and there is no

			   guarantee that we will still have it in the

 Goodbye */

 Say What? */

 Host Ready -> Mailbox in complete */

 set immediate command success flag here: */

 Set immediate command failure flag here: */

 locate an available ecb */

 An optimization */

	host->ecb[ecbno].cmdw = AHA1740CMD_INIT; /* SCSI Initiator Command

	host->ecb[ecbno].cdblen = SCpnt->cmd_len; /* SCSI Command

						   * Descriptor Block

		host->ecb[ecbno].sg = 1;  /* SCSI Initiator Command

 Suppress underrun errors */

 Yes, get the sense on an error */

	/* The Adaptec Spec says the card is so fast that the loops

           will only be executed once in the code below. Even if this

           was true with the fastest processors when the spec was

           written, it doesn't seem to be true with today's fast

           processors. We print a warning if the code is executed more

           often than LOOPCNT_WARN. If this happens, it should be

           investigated. If the count reaches LOOPCNT_MAX, we assume

           something is broken; since there is no way to return an

           error (the return value is ignored by the mid-level scsi

           layer) we have to panic (and maybe that's the best thing we

 excessive mbxout wait -> syslog-msg */

 mbxout deadlock -> panic() after ~ 2 sec. */

 Start it up */

/* Query the board for its irq_level and irq_type.  Nothing else matters

/*

 * From Alan Cox :

 * The AHA1740 has firmware handled abort/reset handling. The "head in

 * sand" kernel code is correct for once 8)

 *

 * So we define a dummy handler just to keep the kernel SCSI code as

 * quiet as possible...

 See if in use */

 If the card isn't ready, hard reset it */

 1740  */

 1740A */

 1742A */

 1744  */

 SPDX-License-Identifier: GPL-2.0-only

/* 

 *  Copyright (C) 1997	Wu Ching Chen

 *  2.1.x update (C) 1998  Krzysztof G. Baranowski

 *  2.5.x update (C) 2002  Red Hat

 *  2.6.x update (C) 2004  Red Hat

 *

 * Marcelo Tosatti <marcelo@conectiva.com.br> : SMP fixes

 *

 * Wu Ching Chen : NULL pointer fixes  2000/06/02

 *		   support atp876 chip

 *		   enable 32 bit fifo transfer

 *		   support cdrom & remove device run ultra speed

 *		   fix disconnect bug  2000/12/21

 *		   support atp880 chip lvd u160 2001/05/15

 *		   fix prd table bug 2001/09/12 (7.1)

 *

 * atp885 support add by ACARD Hao Ping Lian 2005/01/05

		/*

		 *	Remap wide devices onto id numbers

			/*

			 *      Flip wide

			/*

			 *	Issue more commands

			/*

			 *	Done

			/*

			 *	Remap wide identifiers

 Remap wide */

 Add direction */

 enable 32 bit fifo transfer */

j=workreq->cmnd[0];

			/*

			 *	Is this a wide device

			/*

			 *	Check transfer direction

		/*

		 *	Current scsi request on this target

			/*

			 *	Complete the command

			/*

			 *	Clear it off the queue

			/*

			 *      Take it back wide

			/*

			 *	If there is stuff to send and nothing going then send it

/**

 *	atp870u_queuecommand_lck -	Queue SCSI command

 *	@req_p: request block

 *	@done: completion function

 *

 *	Queue a command to the ATP queue. Called with the host lock held.

	/*

	 *      Fake a timeout for missing targets

	/*

	 *	Count new command

	/*

	 *	Check queue state

/*

 *	send_s870	-	send a command to the controller

 *

 *	On entry there is work queued to be done. We move some of that work to the

 *	controller itself.

 *

 *	Caller holds the host lock.

,k;

	/*

	 *	Wide ?

	/*

	 *	Write the command

	/*

	 *	Write the target

	/*

	 *	Write transfer size

	/*

	 *	Flip the wide bits

	/*

	 *	Check transfer direction

	/*

	 *	Now write the request list. Either as scatter/gather or as

	 *	a linear chain.

 stable >= bus settle delay(400 ns)  */

 DB7 all release?    */

 assert DB6           */

 assert DB5           */

 stable >= bus settle delay(400 ns) */

 DB5 all release?       */

 no DB4-0, assert DB7    */

 release DB6             */

 stable >= bus settle delay(400 ns)  */

 DB6 all release?  */

/*  I can't believe we need this before we've even done anything.  Remove it

 *  and see if anyone bitches.

	for (i = 0; i < 0x10; i++) {

		udelay(0xffff);

	}

 2*2=4ms,3EH 2/32*3E=3.9ms */

 bsy  */

 sel  */

 msg  */

 2 deskew delay(45ns*2=90ns) */

 no bsy  */

 after 1ms no msg */

 bsy ? */

 io,cd,db7  */

 no sel     */

	/*

	 * The funny division into multiple delays is to accomodate

	 * arches like ARM where udelay() multiplies its argument by

	 * a large number to initialize a loop counter.  To avoid

	 * overflow, the maximum supported udelay is 2000 microseconds.

	 *

	 * XXX it would be more polite to find a way to use msleep()

 bsy ? */

 synchronization  */

 isolation        */

 get ID_STRING */

 isolation complete..  */

/*    mbuf[32]=0;

 bit5=1:ID up to 7      */

 IDvalid?             */

 srch from max acceptable ID#  */

 max acceptable ID#            */

 k=binID#,       */

 1st dft ID<8    */

 1st  ID>=8      */

 AssignID 1stQuintet,AH=001xxxxx  */

 AssignID 2ndQuintet,AH=001xxxxx */

 check if atp876 chip */

 enable terminator */

 this delay used to be called tscam_885() */

 return non-zero on detection */

/* The abort command does not leave the device in a clean state where

   it is available to be used again.  Until this gets worked out, we will

 name */,

 info */,

 queuecommand */,

 abort */,

 biosparm */,

 can_queue */,

 SCSI ID */,

SG_ALL*/,

 result of is870() merge - is this a bug? */

 result of is870() merge - is this a bug? */

 force u2

 SPDX-License-Identifier: GPL-2.0-only

/*

 * SCSI Media Changer device driver for Linux 2.6

 *

 *     (c) 1996-2003 Gerd Knorr <kraxel@bytesex.org>

 *

 here are all the ioctls */

 tell the driver about vendor-specific slots */

 module_param_string_array(vendor_labels, NULL, 0444);

 ------------------------------------------------------------------- */

 ptrs to data transfer elements */

/* Just filled in what looks right. Hav'nt checked any standard paper for

 Invalid element address */

 Import or export element accessed */

 Medium destination element full */

 Medium source element empty */

 Invalid command operation code */

 end of list */

 ------------------------------------------------------------------- */

 Check to see if additional sense information is available */

 ------------------------------------------------------------------------ */

 vendor specific element types */

 look up the devices of the data transfer elements */

 should not happen */

 ------------------------------------------------------------------------ */

 restrict to ascii */

 don't allow search wildcards */

 ------------------------------------------------------------------------ */

 Synchronize with ch_probe() */

 ------------------------------------------------------------------------ */

 SPDX-License-Identifier: GPL-2.0-only

/* jazz_esp.c: ESP front-end for MIPS JAZZ systems.

 *

 * Copyright (C) 2007 Thomas Bogendörfer (tsbogend@alpha.frankende)

 nothing to do */

 work with hotplug and coldplug */

 SPDX-License-Identifier: GPL-2.0-or-later

/******************************************************************************

**  Device driver for the PCI-SCSI NCR538XX controller family.

**

**  Copyright (C) 1994  Wolfgang Stanglmeier

**

**

**-----------------------------------------------------------------------------

**

**  This driver has been ported to Linux from the FreeBSD NCR53C8XX driver

**  and is currently maintained by

**

**          Gerard Roudier              <groudier@free.fr>

**

**  Being given that this driver originates from the FreeBSD version, and

**  in order to keep synergy on both, any suggested enhancements and corrections

**  received on Linux are automatically a potential candidate for the FreeBSD 

**  version.

**

**  The original driver has been written for 386bsd and FreeBSD by

**          Wolfgang Stanglmeier        <wolf@cologne.de>

**          Stefan Esser                <se@mi.Uni-Koeln.de>

**

**  And has been ported to NetBSD by

**          Charles M. Hannum           <mycroft@gnu.ai.mit.edu>

**

**-----------------------------------------------------------------------------

**

**                     Brief history

**

**  December 10 1995 by Gerard Roudier:

**     Initial port to Linux.

**

**  June 23 1996 by Gerard Roudier:

**     Support for 64 bits architectures (Alpha).

**

**  November 30 1996 by Gerard Roudier:

**     Support for Fast-20 scsi.

**     Support for large DMA fifo and 128 dwords bursting.

**

**  February 27 1997 by Gerard Roudier:

**     Support for Fast-40 scsi.

**     Support for on-Board RAM.

**

**  May 3 1997 by Gerard Roudier:

**     Full support for scsi scripts instructions pre-fetching.

**

**  May 19 1997 by Richard Waltham <dormouse@farsrobt.demon.co.uk>:

**     Support for NvRAM detection and reading.

**

**  August 18 1997 by Cort <cort@cs.nmt.edu>:

**     Support for Power/PC (Big Endian).

**

**  June 20 1998 by Gerard Roudier

**     Support for up to 64 tags per lun.

**     O(1) everywhere (C and SCRIPTS) for normal cases.

**     Low PCI traffic for command handling when on-chip RAM is present.

**     Aggressive SCSI SCRIPTS optimizations.

**

**  2005 by Matthew Wilcox and James Bottomley

**     PCI-ectomy.  This driver now supports only the 720 chip (see the

**     NCR_Q720 and zalon drivers for the bus probe logic).

**

*******************************************************************************

/*

**	Supported SCSI-II features:

**	    Synchronous negotiation

**	    Wide negotiation        (depends on the NCR Chip)

**	    Enable disconnection

**	    Tagged command queuing

**	    Parity checking

**	    Etc...

**

**	Supported NCR/SYMBIOS chips:

**		53C720		(Wide,   Fast SCSI-2, intfly problems)

 Name and version of the driver */

/*==========================================================

**

**	Debugging tags

**

**==========================================================

/*

**    Enable/Disable debug messages.

**    Can be changed at runtime too.

/*

 * Locally used status flag

/*==========================================================

**

**	Simple power of two buddy-like allocator.

**

**	This simple code is not intended to be fast, but to 

**	provide power of 2 aligned memory allocations.

**	Since the SCRIPTS processor only supplies 8 bit 

**	arithmetic, this allocator allows simple and fast 

**	address calculations  from the SCRIPTS code.

**	In addition, cache line alignment is guaranteed for 

**	power of 2 cache line size.

**	Enhanced in linux-2.3.44 to provide a memory pool 

**	per pcidev to support dynamic dma mapping. (I would 

**	have preferred a real bus abstraction, btw).

**

**==========================================================

 16 bytes minimum memory chunk */

 1 PAGE  maximum */

 2 PAGES maximum */

 Free unused pages immediately */

 Enough bits to bit-hack addresses */

 Something that addresses DMAable */

 Link between free memory chunks */

 Virtual to Bus address translation */

 Memory pool of a given kind */

/*

 * With pci bus iommu support, we use a default pool of unmapped memory 

 * for memory we donnot need to DMA from/to and one pool per pcidev for 

 * memory accessed by the PCI chip. `mp0' is the default not DMAable pool.

/*

 * DMAable pools.

/*

 * With pci bus iommu support, we maintain one pool per pcidev and a 

 * hashed reverse table for virtual to bus physical address translations.

/*

 *  Deal with DMA mapping/unmapping.

 To keep track of the dma mapping (sg/single) that has been set */

/*==========================================================

**

**	Driver setup.

**

**	This structure is initialized from linux config 

**	options. It can be overridden at boot-up by the boot 

**	command line.

**

**==========================================================

 !MODULE */

/*===================================================================

**

**	Driver setup from the boot command line

**

**===================================================================

 DONNOT REMOVE THIS ';' */

 SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT */

 !MODULE */

/*===================================================================

**

**	Get device queue depth from boot command line.

**

**===================================================================

/*==========================================================

**

**	The CCB done queue uses an array of CCB virtual 

**	addresses. Empty entries are flagged using the bogus 

**	virtual address 0xffffffff.

**

**	Since PCI ensures that only aligned DWORDs are accessed 

**	atomically, 64 bit little-endian architecture requires 

**	to test the high order DWORD of the entry to determine 

**	if it is empty or valid.

**

**	BTW, I will make things differently as soon as I will 

**	have a better idea, but this is simple and should work.

**

**==========================================================

 All 32 bit architectures */

 All > 32 bit (64 bit) architectures regardless endian-ness */

 SCSI_NCR_CCB_DONE_SUPPORT */

/*==========================================================

**

**	Configuration and Debugging

**

**==========================================================

/*

**    SCSI address of this device.

**    The boot routines should have set it.

**    If not, use this.

/*

**    The maximum number of tags per logic unit.

**    Used only for disk devices that support tags.

/*

**    TAGS are actually limited to 64 tags/lun.

**    We need to deal with power of 2, for alignment constraints.

/*

**	Choose appropriate type for tag bitmap.

/*

**    Number of targets supported by the driver.

**    n permits target numbers 0..n-1.

**    Default is 16, meaning targets #0..#15.

**    #7 .. is myself.

/*

**    Number of logic units supported by the driver.

**    n enables logic unit numbers 0..n-1.

**    The common SCSI devices require only

**    one lun, so take 1 as the default.

/*

**    Asynchronous pre-scaler (ns). Shall be 40

/*

**    The maximum number of jobs scheduled for starting.

**    There should be one slot per target, and one slot

**    for each tag of each target in use.

**    The calculation below is actually quite silly ...

/*

**   We limit the max number of pending IO to 250.

**   since we donnot want to allocate more than 1 

**   PAGE for 'scripth'.

/*

**    The maximum number of segments a transfer is split into.

**    We support up to 127 segments for both read and write.

**    The data scripts are broken into 2 sub-scripts.

**    80 (MAX_SCATTERL) segments are moved from a sub-script

**    in on-chip RAM. This makes data transfers shorter than 

**    80k (assuming 1k fs) as fast as possible.

/*

**	other

/*

**	Other definitions

/*==========================================================

**

**	Command control block states.

**

**==========================================================

 sync/wide data transfer*/

 Disconnected by target */

 Selection timeout      */

 SCSI reset	          */

 Transfer aborted       */

 Software timeout       */

 SCSI or PCI bus errors */

 Unexpected disconnect  */

/*

**	Invalid host status values used by the SCRIPTS processor 

**	when the nexus is not fully identified.

**	Shall never appear in a CCB.

/*

**	Flags set by the SCRIPT processor for commands 

**	that have been skipped.

/*==========================================================

**

**	Software Interrupt Codes

**

**==========================================================

/*==========================================================

**

**	Extended error codes.

**	xerr_status field of struct ccb.

**

**==========================================================

 unexpected data phase */

 illegal phase (4/5)   */

/*==========================================================

**

**	Negotiation status.

**	nego_status field	of struct ccb.

**

**==========================================================

/*==========================================================

**

**	Misc.

**

**==========================================================

/*==========================================================

**

**	Declaration of structs.

**

**==========================================================

/*========================================================================

**

**	Declaration of structs:		target control block

**

**========================================================================

	/*----------------------------------------------------------------

	**	During reselection the ncr jumps to this point with SFBR 

	**	set to the encoded target number with bit 7 set.

	**	if it's not this target, jump to the next.

	**

	**	JUMP  IF (SFBR != #target#), @(next tcb)

	**----------------------------------------------------------------

	/*----------------------------------------------------------------

	**	Load the actual values for the sxfer and the scntl3

	**	register (sync/wide mode).

	**

	**	SCR_COPY (1), @(sval field of this tcb), @(sxfer  register)

	**	SCR_COPY (1), @(wval field of this tcb), @(scntl3 register)

	**----------------------------------------------------------------

	/*----------------------------------------------------------------

	**	Get the IDENTIFY message and load the LUN to SFBR.

	**

	**	CALL, <RESEL_LUN>

	**----------------------------------------------------------------

	/*----------------------------------------------------------------

	**	Now look for the right lun.

	**

	**	For i = 0 to 3

	**		SCR_JUMP ^ IFTRUE(MASK(i, 3)), @(first lcb mod. i)

	**

	**	Recent chips will prefetch the 4 JUMPS using only 1 burst.

	**	It is kind of hashcoding.

	**----------------------------------------------------------------

 JUMPs for reselection	*/

 The lcb's of this tcb	*/

	/*----------------------------------------------------------------

	**	Pointer to the ccb used for negotiation.

	**	Prevent from starting a negotiation for all queued commands 

	**	when tagged command queuing is enabled.

	**----------------------------------------------------------------

	/*----------------------------------------------------------------

	**	statistical data

	**----------------------------------------------------------------

	/*----------------------------------------------------------------

	**	negotiation of wide and synch transfer and device quirks.

	**----------------------------------------------------------------

0*/	u16	period;

2*/	u_char	sval;

3*/	u_char	minsync;

0*/	u_char	wval;

1*/	u_char	widedone;

2*/	u_char	quirks;

3*/	u_char	maxoffs;

0*/	u_char	minsync;

1*/	u_char	sval;

2*/	u16	period;

0*/	u_char	maxoffs;

1*/	u_char	quirks;

2*/	u_char	widedone;

3*/	u_char	wval;

 User settable limits and options.  */

/*========================================================================

**

**	Declaration of structs:		lun control block

**

**========================================================================

	/*----------------------------------------------------------------

	**	During reselection the ncr jumps to this point

	**	with SFBR set to the "Identify" message.

	**	if it's not this lun, jump to the next.

	**

	**	JUMP  IF (SFBR != #lun#), @(next lcb of this target)

	**

	**	It is this lun. Load TEMP with the nexus jumps table 

	**	address and jump to RESEL_TAG (or RESEL_NOTAG).

	**

	**		SCR_COPY (4), p_jump_ccb, TEMP,

	**		SCR_JUMP, <RESEL_TAG>

	**----------------------------------------------------------------

 Jump table bus address	*/

	/*----------------------------------------------------------------

	**	Jump table used by the script processor to directly jump 

	**	to the CCB corresponding to the reselected nexus.

	**	Address is allocated on 256 bytes boundary in order to 

	**	allow 8 bit calculation of the tag jump entry for up to 

	**	64 possible tags.

	**----------------------------------------------------------------

 Default table if no tags	*/

 Virtual address		*/

	/*----------------------------------------------------------------

	**	CCB queue management.

	**----------------------------------------------------------------

 Queue of available CCBs	*/

 Queue of busy CCBs		*/

 Queue of waiting for IO CCBs	*/

 Queue of skipped CCBs	*/

 Number of allocated CCBs	*/

 CCBs busy for this lun	*/

 CCBs queued to the controller*/

 Queue depth for this lun	*/

 SCSI device queue depth	*/

 Max possible nexuses		*/

	/*----------------------------------------------------------------

	**	Control of tagged command queuing.

	**	Tags allocation is performed using a circular buffer.

	**	This avoids using a loop for tag allocation.

	**----------------------------------------------------------------

 Allocation index		*/

 Freeing index		*/

 Circular tags buffer	*/

 Command queuing is active	*/

 Max nr of tags asked by user	*/

 Current number of tags	*/

	/*----------------------------------------------------------------

	**	QUEUE FULL control and ORDERED tag control.

	**----------------------------------------------------------------

	/*----------------------------------------------------------------

	**	QUEUE FULL and ORDERED tag control.

	**----------------------------------------------------------------

 Nr of GOOD since QUEUE FULL	*/

 Used tags bitmap		*/

 Tags in use at 'tag_stime'	*/

 Last time we set smap=umap	*/

 CCB held for QUEUE FULL	*/

/*========================================================================

**

**      Declaration of structs:     the launch script.

**

**========================================================================

**

**	It is part of the CCB and is called by the scripts processor to 

**	start or restart the data structure (nexus).

**	This 6 DWORDs mini script makes use of prefetching.

**

**------------------------------------------------------------------------

	/*----------------------------------------------------------------

	**	SCR_COPY(4),	@(p_phys), @(dsa register)

	**	SCR_JUMP,	@(scheduler_point)

	**----------------------------------------------------------------

 Copy 'phys' address to dsa	*/

 Jump to scheduler point	*/

 'phys' header bus address	*/

/*========================================================================

**

**      Declaration of structs:     global HEADER.

**

**========================================================================

**

**	This substructure is copied from the ccb to a global address after 

**	selection (or reselection) and copied back before disconnect.

**

**	These fields are accessible to the script processor.

**

**------------------------------------------------------------------------

	/*----------------------------------------------------------------

	**	Saved data pointer.

	**	Points to the position in the script responsible for the

	**	actual transfer transfer of data.

	**	It's written after reception of a SAVE_DATA_POINTER message.

	**	The goalpointer points after the last transfer command.

	**----------------------------------------------------------------

	/*----------------------------------------------------------------

	**	Alternate data pointer.

	**	They are copied back to savep/lastp/goalp by the SCRIPTS 

	**	when the direction is unknown and the device claims data out.

	**----------------------------------------------------------------

	/*----------------------------------------------------------------

	**	The virtual address of the ccb containing this header.

	**----------------------------------------------------------------

	/*----------------------------------------------------------------

	**	Status fields.

	**----------------------------------------------------------------

 script status		*/

 host status. must be the 	*/

  last DWORD of the header.	*/

/*

**	The status bytes are used by the host and the script processor.

**

**	The byte corresponding to the host_status must be stored in the 

**	last DWORD of the CCB header since it is used for command 

**	completion (ncr_wakeup()). Doing so, we are sure that the header 

**	has been entirely copied back to the CCB when the host_status is 

**	seen complete by the CPU.

**

**	The last four bytes (status[4]) are copied to the scratchb register

**	(declared as scr0..scr3 in ncr_reg.h) just after the select/reselect,

**	and copied back just after disconnecting.

**	Inside the script the XX_REG are used.

**

**	The first four bytes (scr_st[4]) are used inside the script by 

**	"COPY" commands.

**	Because source and destination must have the same alignment

**	in a DWORD, the fields HAVE to be at the chosen offsets.

**		xerr_st		0	(0x34)	scratcha

**		sync_st		1	(0x05)	sxfer

**		wide_st		3	(0x03)	scntl3

/*

**	Last four bytes (script)

/*

**	Last four bytes (host)

/*

**	First four bytes (script)

/*

**	First four bytes (host)

/*==========================================================

**

**      Declaration of structs:     Data structure block

**

**==========================================================

**

**	During execution of a ccb by the script processor,

**	the DSA (data structure address) register points

**	to this substructure of the ccb.

**	This substructure contains the header with

**	the script-processor-changeable data and

**	data blocks for the indirect move commands.

**

**----------------------------------------------------------

	/*

	**	Header.

	/*

	**	Table data for Script

/*========================================================================

**

**      Declaration of structs:     Command control block.

**

**========================================================================

	/*----------------------------------------------------------------

	**	This is the data structure which is pointed by the DSA 

	**	register when it is executed by the script processor.

	**	It must be the first entry because it contains the header 

	**	as first entry that must be cache line aligned.

	**----------------------------------------------------------------

	/*----------------------------------------------------------------

	**	Mini-script used at CCB execution start-up.

	**	Load the DSA with the data structure address (phys) and 

	**	jump to SELECT. Jump to CANCEL if CCB is to be canceled.

	**----------------------------------------------------------------

	/*----------------------------------------------------------------

	**	Mini-script used at CCB relection to restart the nexus.

	**	Load the DSA with the data structure address (phys) and 

	**	jump to RESEL_DSA. Jump to ABORT if CCB is to be aborted.

	**----------------------------------------------------------------

	/*----------------------------------------------------------------

	**	If a data transfer phase is terminated too early

	**	(after reception of a message (i.e. DISCONNECT)),

	**	we have to prepare a mini script to transfer

	**	the rest of the data.

	**----------------------------------------------------------------

	/*----------------------------------------------------------------

	**	The general SCSI driver provides a

	**	pointer to a control block.

	**----------------------------------------------------------------

 SCSI command 		*/

 Copy of CDB			*/

 Total data length		*/

	/*----------------------------------------------------------------

	**	Message areas.

	**	We prepare a message to be sent after selection.

	**	We may use a second one if the command is rescheduled 

	**	due to GETCC or QFULL.

	**      Contents are IDENTIFY and SIMPLE_TAG.

	**	While negotiating sync or wide transfer,

	**	a SDTR or WDTR message is appended.

	**----------------------------------------------------------------

	/*----------------------------------------------------------------

	**	Other fields.

	**----------------------------------------------------------------

 BUS address of this CCB	*/

 Sense command		*/

 Tag for this transfer	*/

  255 means no tag		*/

 Host adapter CCB chain	*/

 Link to unit CCB queue	*/

 Initial data pointer		*/

 Free / busy  CCB flag	*/

/*========================================================================

**

**      Declaration of structs:     NCR device descriptor

**

**========================================================================

	/*----------------------------------------------------------------

	**	The global header.

	**	It is accessible to both the host and the script processor.

	**	Must be cache line size aligned (32 for x86) in order to 

	**	allow cache line bursting when it is copied to/from CCB.

	**----------------------------------------------------------------

	/*----------------------------------------------------------------

	**	CCBs management queues.

	**----------------------------------------------------------------

 Commands waiting for a CCB	*/

  when lcb is not allocated.	*/

 Commands waiting for done()  */

 callback to be invoked.      */ 

 Lock for SMP threading       */

	/*----------------------------------------------------------------

	**	Chip and controller identification.

	**----------------------------------------------------------------

 Unit number			*/

 ncb instance name		*/

	/*----------------------------------------------------------------

	**	Initial value of some IO register bits.

	**	These values are assumed to have been set by BIOS, and may 

	**	be used for probing adapter implementation differences.

	**----------------------------------------------------------------

	/*----------------------------------------------------------------

	**	Actual initial value of IO register bits used by the 

	**	driver. They are loaded at initialisation according to  

	**	features that are to be enabled.

	**----------------------------------------------------------------

	/*----------------------------------------------------------------

	**	Targets management.

	**	During reselection the ncr jumps to jump_tcb.

	**	The SFBR register is loaded with the encoded target id.

	**	For i = 0 to 3

	**		SCR_JUMP ^ IFTRUE(MASK(i, 3)), @(next tcb mod. i)

	**

	**	Recent chips will prefetch the 4 JUMPS using only 1 burst.

	**	It is kind of hashcoding.

	**----------------------------------------------------------------

 JUMPs for reselection	*/

 Target data			*/

	/*----------------------------------------------------------------

	**	Virtual and physical bus addresses of the chip.

	**----------------------------------------------------------------

 Virtual and bus address of	*/

  chip's IO registers.	*/

 On-chip RAM bus address.	*/

 Pointer to volatile for 	*/

  memory mapped IO.		*/

	/*----------------------------------------------------------------

	**	SCRIPTS virtual and physical bus addresses.

	**	'script'  is loaded in the on-chip RAM if present.

	**	'scripth' stays in main memory.

	**----------------------------------------------------------------

 Copies of script and scripth	*/

  relocated for this ncb.	*/

 Actual scripth virt. address	*/

 Actual script and scripth	*/

  bus addresses.		*/

	/*----------------------------------------------------------------

	**	General controller parameters and configuration.

	**----------------------------------------------------------------

 PCI device revision id	*/

 IRQ level			*/

 Chip features map		*/

 SCSI id of the adapter	*/

 log base 2 of dwords burst	*/

 Maximum transfer width	*/

 Minimum sync period factor	*/

 Maximum sync period factor	*/

 Max scsi offset		*/

 Clock multiplier (1,2,4)	*/

 Number of clock divisors	*/

 SCSI clock frequency in KHz	*/

	/*----------------------------------------------------------------

	**	Start queue management.

	**	It is filled up by the host processor and accessed by the 

	**	SCRIPTS processor in order to start SCSI commands.

	**----------------------------------------------------------------

 Next free slot of the queue	*/

 Number of allocated CCBs	*/

 Number of CCBs in start queue*/

 Start queue depth		*/

	/*----------------------------------------------------------------

	**	Timeout handler.

	**----------------------------------------------------------------

 Timer handler link header	*/

 Resetting the SCSI BUS	*/

	/*----------------------------------------------------------------

	**	Debugging and profiling.

	**----------------------------------------------------------------

 Register dump		*/

 Time it has been done	*/

	/*----------------------------------------------------------------

	**	Miscellaneous buffers accessed by the scripts-processor.

	**	They shall be DWORD aligned, because they may be read or 

	**	written with a SCR_COPY script command.

	**----------------------------------------------------------------

 Buffer for MESSAGE OUT 	*/

 Buffer for MESSAGE IN	*/

 Last SCSI message sent	*/

 Scratch for SCSI receive	*/

	/*----------------------------------------------------------------

	**	Miscellaneous configuration and status parameters.

	**----------------------------------------------------------------

 Disconnection allowed	*/

 Current SCSI BUS mode	*/

 Tag order to use		*/

 Verbosity for this controller*/

 Used for cache test at init.	*/

 BUS address of this NCB	*/

	/*----------------------------------------------------------------

	**	Command completion handling.

	**----------------------------------------------------------------

	/*----------------------------------------------------------------

	**	Fields that should be removed or changed.

	**----------------------------------------------------------------

 Global CCB			*/

 Command from user		*/

 Synchronisation stage on release  */

/*==========================================================

**

**

**      Script for NCR-Processor.

**

**	Use ncr_script_fill() to create the variable parts.

**	Use ncr_script_copy_and_bind() to make a copy and

**	bind to physical addresses.

**

**

**==========================================================

**

**	We have to know the offsets of all labels before

**	we reach them (for forward jumps).

**	Therefore we declare a struct here.

**	If you make changes inside the script,

**	DONT FORGET TO CHANGE THE LENGTHS HERE!

**

**----------------------------------------------------------

/*

**	For HP Zalon/53c720 systems, the Zalon interface

**	between CPU and 53c720 does prefetches, which causes

**	problems with self modifying scripts.  The problem

**	is overcome by calling a dummy subroutine after each

**	modification, to force a refetch of the script on

**	return from the subroutine.

/*

**	Script fragments which are loaded into the on-chip RAM 

**	of 825A, 875 and 895 chips.

/*

**	Script fragments which stay in main memory for all chips.

/*==========================================================

**

**

**      Function headers.

**

**

**==========================================================

/*==========================================================

**

**

**      Scripts for NCR-Processor.

**

**      Use ncr_script_bind for binding to physical addresses.

**

**

**==========================================================

**

**	NADDR generates a reference to a field of the controller data.

**	PADDR generates a reference to another part of the script.

**	RADDR generates a reference to a script processor register.

**	FADDR generates a reference to a script processor register

**		with offset.

**

**----------------------------------------------------------

--------------------------< START >-----------------------*/ {

	/*

	**	This NOP will be patched with LED ON

	**	SCR_REG_REG (gpreg, SCR_AND, 0xfe)

	/*

	**      Clear SIGP.

	/*

	**	Then jump to a certain point in tryloop.

	**	Due to the lack of indirect addressing the code

	**	is self modifying here.

-------------------------< STARTPOS >--------------------*/,{

-------------------------< SELECT >----------------------*/,{

	/*

	**	DSA	contains the address of a scheduled

	**		data structure.

	**

	**	SCRATCHA contains the address of the script,

	**		which starts the next entry.

	**

	**	Set Initiator mode.

	**

	**	(Target mode is left as an exercise for the reader)

	/*

	**      And try to select this target.

-------------------------< SELECT2 >----------------------*/,{

	/*

	**	Now there are 4 possibilities:

	**

	**	(1) The ncr loses arbitration.

	**	This is ok, because it will try again,

	**	when the bus becomes idle.

	**	(But beware of the timeout function!)

	**

	**	(2) The ncr is reselected.

	**	Then the script processor takes the jump

	**	to the RESELECT label.

	**

	**	(3) The ncr wins arbitration.

	**	Then it will execute SCRIPTS instruction until 

	**	the next instruction that checks SCSI phase.

	**	Then will stop and wait for selection to be 

	**	complete or selection time-out to occur.

	**	As a result the SCRIPTS instructions until 

	**	LOADPOS + 2 should be executed in parallel with 

	**	the SCSI core performing selection.

	/*

	**	The MESSAGE_REJECT problem seems to be due to a selection 

	**	timing problem.

	**	Wait immediately for the selection to complete. 

	**	(2.5x behaves so)

	/*

	**	Next time use the next slot.

	/*

	**      The ncr doesn't have an indirect load

	**	or store command. So we have to

	**	copy part of the control block to a

	**	fixed place, where we can access it.

	**

	**	We patch the address part of a

	**	COPY command with the DSA-register.

	/*

	**	Flush script prefetch if required

	/*

	**	then we do the actual copy.

	/*

	**	continued after the next label ...

-------------------------< LOADPOS >---------------------*/,{

	/*

	**	Wait for the next phase or the selection

	**	to complete or time-out.

-------------------------< SEND_IDENT >----------------------*/,{

	/*

	**	Selection complete.

	**	Send the IDENTIFY and SIMPLE_TAG messages

	**	(and the EXTENDED_SDTR message)

-------------------------< PREPARE >----------------------*/,{

	/*

	**      load the savep (saved pointer) into

	**      the TEMP register (actual pointer)

	/*

	**      Initialize the status registers

-------------------------< PREPARE2 >---------------------*/,{

	/*

	**	Initialize the msgout buffer with a NOOP message.

	/*

	**	Anticipate the COMMAND phase.

	**	This is the normal case for initial selection.

-------------------------< COMMAND >--------------------*/,{

	/*

	**	... and send the command

	/*

	**	If status is still HS_NEGOTIATE, negotiation failed.

	**	We check this here, since we want to do that 

	**	only once.

-----------------------< DISPATCH >----------------------*/,{

	/*

	**	MSG_IN is the only phase that shall be 

	**	entered at least once for each (re)selection.

	**	So we test it first.

	/*

	**	DEL 397 - 53C875 Rev 3 - Part Number 609-0392410 - ITEM 4.

	**	Possible data corruption during Memory Write and Invalidate.

	**	This work-around resets the addressing logic prior to the 

	**	start of the first MOVE of a DATA IN phase.

	**	(See Documentation/scsi/ncr53c8xx.rst for more information)

	/*

	**      Discard one illegal phase byte, if required.

-------------------------< CLRACK >----------------------*/,{

	/*

	**	Terminate possible pending message phase.

-------------------------< NO_DATA >--------------------*/,{

	/*

	**	The target wants to tranfer too much data

	**	or in the wrong direction.

	**      Remember that in extended error.

	/*

	**      Discard one data byte, if required.

	/*

	**      .. and repeat as required.

-------------------------< STATUS >--------------------*/,{

	/*

	**	get the status

	/*

	**	save status to scsi_status.

	**	mark as complete.

-------------------------< MSG_IN >--------------------*/,{

	/*

	**	Get the first byte of the message

	**	and save it to SCRATCHA.

	**

	**	The script processor doesn't negate the

	**	ACK signal after this transfer.

-------------------------< MSG_IN2 >--------------------*/,{

	/*

	**	Handle this message.

	/*

	**	Rest of the messages left as

	**	an exercise ...

	**

	**	Unimplemented messages:

	**	fall through to MSG_BAD.

-------------------------< MSG_BAD >------------------*/,{

	/*

	**	unimplemented message - reject it.

-------------------------< SETMSG >----------------------*/,{

-------------------------< CLEANUP >-------------------*/,{

	/*

	**      dsa:    Pointer to ccb

	**	      or xxxxxxFF (no ccb)

	**

	**      HS_REG:   Host-Status (<>0!)

	/*

	**      dsa is valid.

	**	complete the cleanup.

-------------------------< COMPLETE >-----------------*/,{

	/*

	**	Complete message.

	**

	**	Copy TEMP register to LASTP in header.

	/*

	**	When we terminate the cycle by clearing ACK,

	**	the target may disconnect immediately.

	**

	**	We don't want to be told of an

	**	"unexpected disconnect",

	**	so we disable this feature.

	/*

	**	Terminate cycle ...

	/*

	**	... and wait for the disconnect.

-------------------------< CLEANUP_OK >----------------*/,{

	/*

	**	Save host status to header.

	/*

	**	and copy back the header to the ccb.

	/*

	**	Flush script prefetch if required

-------------------------< CLEANUP0 >--------------------*/,{

-------------------------< SIGNAL >----------------------*/,{

	/*

	**	if job not completed ...

	/*

	**	... start the next command.

	/*

	**	If command resulted in not GOOD status,

	**	call the C code if needed.

	/*

	**	... signal completion to the host

	/*

	**	Auf zu neuen Schandtaten!

 defined SCSI_NCR_CCB_DONE_SUPPORT */

	/*

	**	... signal completion to the host

------------------------< DONE_POS >---------------------*/,{

------------------------< DONE_PLUG >--------------------*/,{

------------------------< DONE_END >---------------------*/,{

 SCSI_NCR_CCB_DONE_SUPPORT */

-------------------------< SAVE_DP >------------------*/,{

	/*

	**	SAVE_DP message:

	**	Copy TEMP register to SAVEP in header.

-------------------------< RESTORE_DP >---------------*/,{

	/*

	**	RESTORE_DP message:

	**	Copy SAVEP in header to TEMP register.

-------------------------< DISCONNECT >---------------*/,{

	/*

	**	DISCONNECTing  ...

	**

	**	disable the "unexpected disconnect" feature,

	**	and remove the ACK signal.

	/*

	**	Wait for the disconnect.

	/*

	**	Status is: DISCONNECTED.

-------------------------< MSG_OUT >-------------------*/,{

	/*

	**	The target requests a message.

	/*

	**	If it was no ABORT message ...

	/*

	**	... wait for the next phase

	**	if it's a message out, send it again, ...

-------------------------< MSG_OUT_DONE >--------------*/,{

	/*

	**	... else clear the message ...

	/*

	**	... and process the next phase

-------------------------< IDLE >------------------------*/,{

	/*

	**	Nothing to do?

	**	Wait for reselect.

	**	This NOP will be patched with LED OFF

	**	SCR_REG_REG (gpreg, SCR_OR, 0x01)

-------------------------< RESELECT >--------------------*/,{

	/*

	**	make the DSA invalid.

	/*

	**	Sleep waiting for a reselection.

	**	If SIGP is set, special treatment.

	**

	**	Zu allem bereit ..

-------------------------< RESELECTED >------------------*/,{

	/*

	**	This NOP will be patched with LED ON

	**	SCR_REG_REG (gpreg, SCR_AND, 0xfe)

	/*

	**	... zu nichts zu gebrauchen ?

	**

	**      load the target id into the SFBR

	**	and jump to the control block.

	**

	**	Look at the declarations of

	**	- struct ncb

	**	- struct tcb

	**	- struct lcb

	**	- struct ccb

	**	to understand what's going on.

-------------------------< RESEL_DSA >-------------------*/,{

	/*

	**	Ack the IDENTIFY or TAG previously received.

	/*

	**      The ncr doesn't have an indirect load

	**	or store command. So we have to

	**	copy part of the control block to a

	**	fixed place, where we can access it.

	**

	**	We patch the address part of a

	**	COPY command with the DSA-register.

	/*

	**	Flush script prefetch if required

	/*

	**	then we do the actual copy.

	/*

	**	continued after the next label ...

-------------------------< LOADPOS1 >-------------------*/,{

	/*

	**	The DSA contains the data structure address.

-------------------------< RESEL_LUN >-------------------*/,{

	/*

	**	come back to this point

	**	to get an IDENTIFY message

	**	Wait for a msg_in phase.

	/*

	**	message phase.

	**	Read the data directly from the BUS DATA lines.

	**	This helps to support very old SCSI devices that 

	**	may reselect without sending an IDENTIFY.

	/*

	**	It should be an Identify message.

-------------------------< RESEL_TAG >-------------------*/,{

	/*

	**	Read IDENTIFY + SIMPLE + TAG using a single MOVE.

	**	Aggressive optimization, is'nt it?

	**	No need to test the SIMPLE TAG message, since the 

	**	driver only supports conformant devices for tags. ;-)

	/*

	**	Read the TAG from the SIDL.

	**	Still an aggressive optimization. ;-)

	**	Compute the CCB indirect jump address which 

	**	is (#TAG*2 & 0xfc) due to tag numbering using 

	**	1,3,5..MAXTAGS*2+1 actual values.

-------------------------< JUMP_TO_NEXUS >-------------------*/,{

	/*

	**	Flush script prefetch if required

-------------------------< NEXUS_INDIRECT >-------------------*/,{

-------------------------< RESEL_NOTAG >-------------------*/,{

	/*

	**	No tag expected.

	**	Read an throw away the IDENTIFY.

-------------------------< DATA_IN >--------------------*/,{

/*

**	Because the size depends on the

**	#define MAX_SCATTERL parameter,

**	it is filled in at runtime.

**

**  ##===========< i=0; i<MAX_SCATTERL >=========

**  ||	SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN)),

**  ||		PADDR (dispatch),

**  ||	SCR_MOVE_TBL ^ SCR_DATA_IN,

**  ||		offsetof (struct dsb, data[ i]),

**  ##==========================================

**

**---------------------------------------------------------

-------------------------< DATA_IN2 >-------------------*/,{

-------------------------< DATA_OUT >--------------------*/,{

/*

**	Because the size depends on the

**	#define MAX_SCATTERL parameter,

**	it is filled in at runtime.

**

**  ##===========< i=0; i<MAX_SCATTERL >=========

**  ||	SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT)),

**  ||		PADDR (dispatch),

**  ||	SCR_MOVE_TBL ^ SCR_DATA_OUT,

**  ||		offsetof (struct dsb, data[ i]),

**  ##==========================================

**

**---------------------------------------------------------

-------------------------< DATA_OUT2 >-------------------*/,{

--------------------------------------------------------*/

-------------------------< TRYLOOP >---------------------*/{

/*

**	Start the next entry.

**	Called addresses point to the launch script in the CCB.

**	They are patched by the main processor.

**

**	Because the size depends on the

**	#define MAX_START parameter, it is filled

**	in at runtime.

**

**-----------------------------------------------------------

**

**  ##===========< I=0; i<MAX_START >===========

**  ||	SCR_CALL,

**  ||		PADDR (idle),

**  ##==========================================

**

**-----------------------------------------------------------

------------------------< TRYLOOP2 >---------------------*/,{

------------------------< DONE_QUEUE >-------------------*/,{

/*

**	Copy the CCB address to the next done entry.

**	Because the size depends on the

**	#define MAX_DONE parameter, it is filled

**	in at runtime.

**

**-----------------------------------------------------------

**

**  ##===========< I=0; i<MAX_DONE >===========

**  ||	SCR_COPY (sizeof(struct ccb *),

**  ||		NADDR (header.cp),

**  ||		NADDR (ccb_done[i]),

**  ||	SCR_CALL,

**  ||		PADDR (done_end),

**  ##==========================================

**

**-----------------------------------------------------------

------------------------< DONE_QUEUE2 >------------------*/,{

 SCSI_NCR_CCB_DONE_SUPPORT */

------------------------< SELECT_NO_ATN >-----------------*/,{

	/*

	**	Set Initiator mode.

	**      And try to select this target without ATN.

-------------------------< CANCEL >------------------------*/,{

-------------------------< SKIP >------------------------*/,{

	/*

	**	This entry has been canceled.

	**	Next time use the next slot.

	/*

	**      The ncr doesn't have an indirect load

	**	or store command. So we have to

	**	copy part of the control block to a

	**	fixed place, where we can access it.

	**

	**	We patch the address part of a

	**	COPY command with the DSA-register.

	/*

	**	Flush script prefetch if required

	/*

	**	then we do the actual copy.

	/*

	**	continued after the next label ...

-------------------------< SKIP2 >---------------------*/,{

	/*

	**      Initialize the status registers

	/*

	**	Force host status.

-------------------------< PAR_ERR_DATA_IN >---------------*/{

	/*

	**	Ignore all data in byte, until next phase

-------------------------< PAR_ERR_OTHER >------------------*/{

	/*

	**	count it.

	/*

	**	jump to dispatcher.

-------------------------< MSG_REJECT >---------------*/,{

	/*

	**	If a negotiation was in progress,

	**	negotiation failed.

	**	Otherwise, let the C code print 

	**	some message.

-------------------------< MSG_IGN_RESIDUE >----------*/,{

	/*

	**	Terminate cycle

	/*

	**	get residue size.

	/*

	**	Size is 0 .. ignore message.

	/*

	**	Size is not 1 .. have to interrupt.

	/*

	**	Check for residue byte in swide register

	/*

	**	There IS data in the swide register.

	**	Discard it.

	/*

	**	Load again the size to the sfbr register.

-------------------------< MSG_EXTENDED >-------------*/,{

	/*

	**	Terminate cycle

	/*

	**	get length.

	/*

-------------------------< MSG_EXT_2 >----------------*/,{

	/*

	**	get extended message code.

	/*

	**	unknown extended message

-------------------------< MSG_WDTR >-----------------*/,{

	/*

	**	get data bus width

	/*

	**	let the host do the real work.

	/*

	**	let the target fetch our answer.

-------------------------< SEND_WDTR >----------------*/,{

	/*

	**	Send the EXTENDED_WDTR

-------------------------< MSG_EXT_3 >----------------*/,{

	/*

	**	get extended message code.

	/*

	**	unknown extended message

-------------------------< MSG_SDTR >-----------------*/,{

	/*

	**	get period and offset

	/*

	**	let the host do the real work.

	/*

	**	let the target fetch our answer.

-------------------------< SEND_SDTR >-------------*/,{

	/*

	**	Send the EXTENDED_SDTR

-------------------------< NEGO_BAD_PHASE >------------*/,{

-------------------------< MSG_OUT_ABORT >-------------*/,{

	/*

	**	After ABORT message,

	**

	**	expect an immediate disconnect, ...

	/*

	**	... and set the status to "ABORTED"

-------------------------< HDATA_IN >-------------------*/,{

/*

**	Because the size depends on the

**	#define MAX_SCATTERH parameter,

**	it is filled in at runtime.

**

**  ##==< i=MAX_SCATTERL; i<MAX_SCATTERL+MAX_SCATTERH >==

**  ||	SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN)),

**  ||		PADDR (dispatch),

**  ||	SCR_MOVE_TBL ^ SCR_DATA_IN,

**  ||		offsetof (struct dsb, data[ i]),

**  ##===================================================

**

**---------------------------------------------------------

-------------------------< HDATA_IN2 >------------------*/,{

-------------------------< HDATA_OUT >-------------------*/,{

/*

**	Because the size depends on the

**	#define MAX_SCATTERH parameter,

**	it is filled in at runtime.

**

**  ##==< i=MAX_SCATTERL; i<MAX_SCATTERL+MAX_SCATTERH >==

**  ||	SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT)),

**  ||		PADDR (dispatch),

**  ||	SCR_MOVE_TBL ^ SCR_DATA_OUT,

**  ||		offsetof (struct dsb, data[ i]),

**  ##===================================================

**

**---------------------------------------------------------

-------------------------< HDATA_OUT2 >------------------*/,{

-------------------------< RESET >----------------------*/,{

	/*

	**      Send a TARGET_RESET message if bad IDENTIFY 

	**	received on reselection.

-------------------------< ABORTTAG >-------------------*/,{

	/*

	**      Abort a wrong tag received on reselection.

-------------------------< ABORT >----------------------*/,{

	/*

	**      Abort a reselection when no active CCB.

-------------------------< ABORT_RESEL >----------------*/,{

	/*

	**	and send it.

	**	we expect an immediate disconnect

-------------------------< RESEND_IDENT >-------------------*/,{

	/*

	**	The target stays in MSG OUT phase after having acked 

	**	Identify [+ Tag [+ Extended message ]]. Targets shall

	**	behave this way on parity error.

	**	We must send it again all the messages.

 Shall be asserted 2 deskew delays before the  */

 1rst ACK = 90 ns. Hope the NCR is'nt too fast */

-------------------------< CLRATN_GO_ON >-------------------*/,{

-------------------------< NXTDSP_GO_ON >-------------------*/,{

-------------------------< SDATA_IN >-------------------*/,{

-------------------------< DATA_IO >--------------------*/,{

	/*

	**	We jump here if the data direction was unknown at the 

	**	time we had to queue the command to the scripts processor.

	**	Pointers had been set as follow in this situation:

	**	  savep   -->   DATA_IO

	**	  lastp   -->   start pointer when DATA_IN

	**	  goalp   -->   goal  pointer when DATA_IN

	**	  wlastp  -->   start pointer when DATA_OUT

	**	  wgoalp  -->   goal  pointer when DATA_OUT

	**	This script sets savep/lastp/goalp according to the 

	**	direction chosen by the target.

	/*

	**	Direction is DATA IN.

	**	Warning: we jump here, even when phase is DATA OUT.

	/*

	**	Jump to the SCRIPTS according to actual direction.

	/*

	**	Direction is DATA OUT.

-------------------------< BAD_IDENTIFY >---------------*/,{

	/*

	**	If message phase but not an IDENTIFY,

	**	get some help from the C code.

	**	Old SCSI device may behave so.

	/*

	**	Message is an IDENTIFY, but lun is unknown.

	**	Read the message, since we got it directly 

	**	from the SCSI BUS data lines.

	**	Signal problem to C code for logging the event.

	**	Send an ABORT_TASK_SET to clear all pending tasks.

-------------------------< BAD_I_T_L >------------------*/,{

	/*

	**	We donnot have a task for that I_T_L.

	**	Signal problem to C code for logging the event.

	**	Send an ABORT_TASK_SET message.

-------------------------< BAD_I_T_L_Q >----------------*/,{

	/*

	**	We donnot have a task that matches the tag.

	**	Signal problem to C code for logging the event.

	**	Send an ABORT_TASK message.

-------------------------< BAD_TARGET >-----------------*/,{

	/*

	**	We donnot know the target that reselected us.

	**	Grab the first message if any (IDENTIFY).

	**	Signal problem to C code for logging the event.

	**	TARGET_RESET message.

-------------------------< BAD_STATUS >-----------------*/,{

	/*

	**	If command resulted in either TASK_SET FULL,

	**	CHECK CONDITION or COMMAND TERMINATED,

	**	call the C code.

-------------------------< START_RAM >-------------------*/,{

	/*

	**	Load the script into on-chip RAM, 

	**	and jump to start point.

	/*

	**	Flush script prefetch if required

-------------------------< START_RAM0 >--------------------*/,{

-------------------------< STO_RESTART >-------------------*/,{

	/*

	**

	**	Repair start queue (e.g. next time use the next slot) 

	**	and jump to start point.

-------------------------< WAIT_DMA >-------------------*/,{

	/*

	**	For HP Zalon/53c720 systems, the Zalon interface

	**	between CPU and 53c720 does prefetches, which causes

	**	problems with self modifying scripts.  The problem

	**	is overcome by calling a dummy subroutine after each

	**	modification, to force a refetch of the script on

	**	return from the subroutine.

-------------------------< SNOOPTEST >-------------------*/,{

	/*

	**	Read the variable.

	/*

	**	Write the variable.

	/*

	**	Read back the variable.

-------------------------< SNOOPEND >-------------------*/,{

	/*

	**	And stop.

--------------------------------------------------------*/

/*==========================================================

**

**

**	Fill in #define dependent parts of the script

**

**

**==========================================================

 SCSI_NCR_CCB_DONE_SUPPORT */

/*==========================================================

**

**

**	Copy and rebind a script.

**

**

**==========================================================

		/*

		**	If we forget to change the length

		**	in struct script, a field will be

		**	padded with 0. This is an illegal

		**	command.

		/*

		**	We don't have to decode ALL commands

			/*

			**	COPY has TWO arguments.

			/*

			**	If PREFETCH feature not enabled, remove 

			**	the NO FLUSH bit if present.

			/*

			**	MOVE (absolute address)

			/*

			**	JUMP / CALL

			**	don't relocate if relative :-)

 Don't relocate a 0 address. */

/*

**	Linux host data structure

/*==========================================================

**

**	NCR chip clock divisor table.

**	Divisors are multiplied by 10,000,000 in order to make 

**	calculations more simple.

**

**==========================================================

/*===============================================================

**

**	Prepare io register values used by ncr_init() according 

**	to selected and supported features.

**

**	NCR chips allow burst lengths of 2, 4, 8, 16, 32, 64, 128 

**	transfers. 32,64,128 are only supported by 875 and 895 chips.

**	We use log base 2 (burst length) as internal code, with 

**	value 0 meaning "burst disabled".

**

**===============================================================

/*

 *	Burst length from burst code.

/*

 *	Burst code from io register bits.  Burst enable is ctest0 for c720

/*

 *	Set initial io register bits from burst code.

	/*

	**	Save assumed BIOS setting

	/*

	**	Wide ?

 	/*

	 *  Guess the frequency of the chip's clock.

	/*

	 *  Get the clock multiplier factor.

	/*

	 *  Measure SCSI clock frequency for chips 

	 *  it may vary from assumed one.

	/*

	 * Divisor to be used for async (timer pre-scaler).

	/*

	 * Minimum synchronous period factor supported by the chip.

	 * Btw, 'period' is in tenths of nanoseconds.

	/*

	 * Check against chip SCSI standard support (SCSI-2,ULTRA,ULTRA2).

	/*

	 * Maximum synchronous period factor supported by the chip.

	/*

	**	Prepare initial value of other IO registers

	/*

	**	Select burst length (dwords)

	/*

	**	Select all supported special features

 Enable Read Line */

 Burst Opcode Fetch */

 Enable Read Multiple */

 Prefetch Enable */

 Cache Line Size Enable */

 Write and Invalidate */

 Dma Fifo Size */

 Host bus multiplex mode */

 Enable ACK */

 Even host parity */

	/*

	**	Select some other

 Master parity checking */

  full arb., ena parity, par->ATN  */

	/*

	**  Get SCSI addr of host adapter (set by bios?).

 SCSI_NCR_TRUST_BIOS_SETTING */

	/*

	 *	Prepare initial io register bits for burst length

	/*

	**	Set SCSI BUS mode.

	**

	**	- ULTRA2 chips (895/895A/896) report the current 

	**	  BUS mode through the STEST4 IO register.

	**	- For previous generation chips (825/825A/875), 

	**	  user has to tell us how to check against HVD, 

	**	  since a 100% safe algorithm is not possible.

 Trust previous settings if present, then GPIO3 */

 SYMBIOS controllers report HVD through GPIO3 */

 Set HVD unconditionally */

 Trust previous settings for HVD */

 Don't care about HVD */	

	/*

	**	Set LED support from SCRIPTS.

	**	Ignore this feature for boards known to use a 

	**	specific GPIO wiring and for the 895A or 896 

	**	that drive the LED directly.

	**	Also probe initial setting of GPIO0 as output.

	/*

	**	Set irq mode.

	/*

	**	Configure targets according to driver setup.

	**	Allow to override sync, wide and NOSCAN from 

	**	boot command line.

	/*

	**	Announce all that stuff to user.

/*==========================================================

**

**

**	Done SCSI commands list management.

**

**	We donnot enter the scsi_done() callback immediately 

**	after a command has been seen as completed but we 

**	insert it into a list which is flushed outside any kind 

**	of driver critical section.

**	This allows to do minimal stuff under interrupt and 

**	inside critical sections and to also avoid locking up 

**	on recursive calls to driver entry points under SMP.

**	In fact, the only kernel point which is entered by the 

**	driver with a driver lock set is kmalloc(GFP_ATOMIC) 

**	that shall not reenter the driver under any circumstances,

**	AFAIK.

**

**==========================================================

/*==========================================================

**

**

**	Prepare the next negotiation message if needed.

**

**	Fill in the part of message buffer that contains the 

**	negotiation and the nego_status field of the CCB.

**	Returns the size of the message in bytes.

**

**

**==========================================================

 negotiate wide transfers ?  */

 negotiate synchronous transfers?  */

/*==========================================================

**

**

**	Start execution of a SCSI command.

**	This is called from the generic SCSI driver.

**

**

**==========================================================

	/*---------------------------------------------

	**

	**      Some shortcuts ...

	**

	**---------------------------------------------

	/*---------------------------------------------

	**

	**	Complete the 1st TEST UNIT READY command

	**	with error condition if the device is 

	**	flagged NOSCAN, in order to speed up 

	**	the boot.

	**

	**---------------------------------------------

	/*---------------------------------------------------

	**

	**	Assign a ccb / bind cmd.

	**	If resetting, shorten settle_time if necessary

	**	in order to avoid spurious timeouts.

	**	If resetting or no free ccb,

	**	insert cmd into the waiting list.

	**

	**----------------------------------------------------

	/*----------------------------------------------------

	**

	**	Build the identify / tag / sdtr message

	**

	**----------------------------------------------------

		/*

		**	Force ordered tag if necessary to avoid timeouts 

		**	and to preserve interactivity.

			/*

			**	Ordered write ops, unordered read ops.

 READ_SMALL (6) */

 READ_BIG  (10) */

 READ_HUGE (12) */

		/*

		**	Actual tags are numbered 1,3,5,..2*MAXTAGS+1,

		**	since we may have to deal with devices that have 

		**	problems with #TAG 0 or too great #TAG numbers.

	/*----------------------------------------------------

	**

	**	Build the data descriptors

	**

	**----------------------------------------------------

	/*---------------------------------------------------

	**

	**	negotiation required?

	**

	**	(nego_status is filled by ncr_prepare_nego())

	**

	**---------------------------------------------------

	/*----------------------------------------------------

	**

	**	Determine xfer direction.

	**

	**----------------------------------------------------

	/*

	**	If data direction is BIDIRECTIONAL, speculate FROM_DEVICE

	**	but prepare alternate pointers for TO_DEVICE in case 

	**	of our speculation will be just wrong.

	**	SCRIPTS will swap values if needed.

	/*

	**	Set all pointers values needed by SCRIPTS.

	**	If direction is unknown, start at data_io.

	/*

	**	Save the initial data pointer in order to be able 

	**	to redo the command.

	/*----------------------------------------------------

	**

	**	fill in ccb

	**

	**----------------------------------------------------

	**

	**

	**	physical -> virtual backlink

	**	Generic SCSI command

	/*

	**	Startqueue

	/*

	**	select

	/*

	**	message

	/*

	**	command

	/*

	**	status

	/*----------------------------------------------------

	**

	**	Critical region: start this job.

	**

	**----------------------------------------------------

 activate this job.  */

	/*

	**	insert next CCBs into start queue.

	**	2 max at a time is enough to flush the CCB wait queue.

 Command is successfully queued.  */

/*==========================================================

**

**

**	Insert a CCB into the start queue and wake up the 

**	SCRIPTS processor.

**

**

**==========================================================

	/*

	**	insert into start queue.

	/*

	**	Script processor may be waiting for reselect.

	**	Wake it up.

 The 895 needs time for the bus mode to settle */

	/*

	**	Enable Tolerant, reset IRQD if present and 

	**	properly set IRQ mode, prior to resetting the bus.

	/*

	**	Check for no terminators or SCSI bus shorts to ground.

	**	Read SCSI data bus, data parity bits and control signals.

	**	We are expecting RESET to be TRUE and other signals to be 

	**	FALSE.

 rst sdp0 */

 sdp1     */

 d7-0     */

 d15-8    */

 req ack bsy sel atn msg cd io    */

/*

 * Start reset process.

 * If reset in progress do nothing.

 * The interrupt handler will reinitialize the chip.

 * The timeout handler will wait for settle_time before 

 * clearing it and so resuming command processing.

/*==========================================================

**

**

**	Reset the SCSI BUS.

**	This is called from the generic SCSI driver.

**

**

**==========================================================

/*

 * Return immediately if reset is in progress.

/*

 * Start the reset process.

 * The script processor is then assumed to be stopped.

 * Commands will now be queued in the waiting list until a settle 

 * delay of 2 seconds will be completed.

/*

 * Wake-up all awaiting commands with DID_RESET.

/*

 * Wake-up all pending commands with HS_RESET -> DID_RESET.

 Local copy so we don't access np after freeing it! */

/*

**	Stop the ncr_timeout process

**	Set release_stage to 1 and wait that ncr_timeout() set it to 2.

/*

**	Disable chip interrupts

	/*

	**	Reset NCR chip

	**	Restore bios setting for automatic clock detection.

	/*

	**	Free allocated ccb(s)

 Free allocated tp(s) */

/*==========================================================

**

**

**	Complete execution of a SCSI command.

**	Signal completion to the generic SCSI driver.

**

**

**==========================================================

	/*

	**	Sanity check

	/*

	**	Print minimal debug information.

	/*

	**	Get command, target and lun pointers.

	/*

	**	We donnot queue more than 1 ccb per target 

	**	with negotiation at any time. If this ccb was 

	**	used for negotiation, clear this info in the tcb.

	/*

	**	If auto-sense performed, change scsi status.

	/*

	**	If we were recovering from queue full or performing 

	**	auto-sense, requeue skipped CCBs to the wait queue.

	/*

	**	Check for parity errors.

	/*

	**	Check for extended errors.

	/*

	**	Print out any error for debugging purpose.

	/*

	**	Check the status.

		/*

		 *	All went well (GOOD status).

		 *	CONDITION MET status is returned on

		 *	`Pre-Fetch' or `Search data' success.

		/*

		**	@RESID@

		**	Could dig out the correct value for resid,

		**	but it would be quite complicated.

 if (cp->phys.header.lastp != cp->phys.header.goalp) */

		/*

		**	Allocate the lcb if not yet.

		/*

		**	If tags was reduced due to queue full,

		**	increase tags if 1000 good status received.

		/*

		**   Check condition code

		/*

		**	Copy back sense data to caller's buffer.

		/*

		**   Reservation Conflict condition code

		/*

		**   Target is busy.

		/*

		**   No response

		/*

		**   SCSI bus reset

		/*

		**   Transfer aborted

		/*

		**  Other protocol messes

	/*

	**	trace output

	/*

	**	Free this ccb

	/*

	**	requeue awaiting scsi commands for this lun.

	/*

	**	requeue awaiting scsi commands for this controller.

	/*

	**	signal completion to generic driver.

/*==========================================================

**

**

**	Signal all (or one) control block done.

**

**

**==========================================================

/*

**	This CCB has been skipped by the NCR.

**	Queue it in the corresponding unit queue.

/*

**	The NCR has completed CCBs.

**	Look at the DONE QUEUE if enabled, otherwise scan all CCBs

/*

**	Complete all active CCBs.

/*

** Reset ncr chip.

/* Some initialisation must be done immediately following reset, for 53c720,

 * at least.  EA (dcntl bit 5) isn't set here as it is set once only in

 * the _detect function.

/*==========================================================

**

**

**	Start NCR chip.

**

**

**==========================================================

 	/*

	**	Reset chip if asked, otherwise just clear fifos.

	/*

	**	Message.

	/*

	**	Clear Start Queue

 1 entry needed as end marker */

	/*

	**	Start at first entry.

	/*

	**	Clear Done Queue

	/*

	**	Start at first entry.

	/*

	**	Wakeup all pending jobs.

	/*

	**	Init chip.

	/*

	** Remove reset; big delay because the 895 needs time for the

	** bus mode to settle

  full arb., ena parity, par->ATN  */

  odd parity, and remove CRST!! */

 Select SCSI clock */

 Adapter SCSI address */

 Id to respond to */

  Signal Process */

 Burst length, dma mode */

 Large fifo + large burst */

 Protect SFBR */

 720: CDIS and EHP */

 Write and invalidate */

 Master parity checking */

 Extended Sreq/Sack filtering */

 TolerANT enable */

 HTH disabled  STO 0.25 sec */

	/*

	**	Disable disconnects.

	/*

	**    Enable GPIO0 pin for writing if LED support.

	/*

	**      enable ints

	/*

	**	Fill in target structure.

	**	Reinitialize usrsync.

	**	Reinitialize usrwide.

	**	Prepare sync negotiation according to actual SCSI bus mode.

	/*

	**    Start script processor.

/*==========================================================

**

**	Prepare the negotiation values for wide and

**	synchronous transfers.

**

**==========================================================

	/*

	**	minsync unit is 4ns !

	/*

	**	SCSI bus mode limit

	/*

	**	our limit ..

	/*

	**	divider limit

	/*

	**	period=0: has to negotiate sync transfer

	/*

	**	widedone=0: has to negotiate wide transfer

/*==========================================================

**

**	Get clock factor and sync divisor for a given 

**	synchronous factor period.

**	Returns the clock factor (in sxfer) and scntl3 

**	synchronous divisor field.

**

**==========================================================

 SCSI clock frequency in kHz	*/

 Number of divisors supported	*/

 Sync factor in sxfer		*/

 Period in tenths of ns	*/

 (per * clk)			*/

	/*

	**	Compute the synchronous period in tenths of nano-seconds

	/*

	**	Look for the greatest clock divisor that allows an 

	**	input speed faster than the period.

	/*

	**	Calculate the lowest clock factor that allows an output 

	**	speed not faster than the period.

 Should never happen, too bad ... */

	/*

	**	Compute and return sync parameters for the ncr

/*==========================================================

**

**	Set actual values, sync status and patch all ccbs of 

**	a target according to new sync/wide agreement.

**

**==========================================================

	/*

	**	set actual value and sync_status

	/*

	**	patch ALL ccbs of this target.

/*==========================================================

**

**	Switch sync mode for current job and it's target

**

**==========================================================

	/*

	**	Deduce the value of controller sync period from scntl3.

	**	period is in tenths of nano-seconds.

 Stop there if sync parameters are unchanged */

 Disable extended Sreq/Sack filtering */

	/*

	**	set actual value and sync_status

	**	patch ALL ccbs of this target.

/*==========================================================

**

**	Switch wide mode for current job and it's target

**	SCSI specs say: a SCSI device that accepts a WDTR 

**	message shall reset the synchronous agreement to 

**	asynchronous mode.

**

**==========================================================

	/*

	**	 Stop there if sync/wide parameters are unchanged

	/*

	**	Bells and whistles   ;-)

	/*

	**	set actual value and sync_status

	**	patch ALL ccbs of this target.

/*==========================================================

**

**	Switch tagged mode for a target.

**

**==========================================================

	/*

	**	Just in case ...

	/*

	**	If SCSI device queue depth is not yet set, leave here.

	/*

	**	Donnot allow more tags than the SCSI driver can queue 

	**	for this device.

	**	Donnot allow more tags than we can handle.

	/*

	**	only devices conformant to ANSI Version >= 2

	**	only devices capable of tagged commands

	**	only if enabled by user ..

	/*

	**	Update max number of tags

	/*

	**	If we want to switch tag mode, we must wait 

	**	for no CCB to be active.

 Stay in tagged mode    */

 Already announced	   */

 Stay in untagged mode  */

 Want to switch tag mode */

 If not yet safe, return */

	/*

	**	Patch the lun mini-script, according to tag mode.

	/*

	**	Announce change to user.

/*==========================================================

**

**

**	ncr timeout handler.

**

**

**==========================================================

**

**	Misused to keep the driver running when

**	interrupts are not configured correctly.

**

**----------------------------------------------------------

	/*

	**	If release process in progress, let's go

	**	Set the release stage from 1 to 2 to synchronize

	**	with the release process.

	/*

	**	If we are resetting the ncr, wait for settle_time before 

	**	clearing it. Then command processing will be resumed.

	/*

	**	Since the generic scsi driver only allows us 0.5 second 

	**	to perform abort of a command, we must look at ccbs about 

	**	every 0.25 second.

		/*

		**	block ncr interrupts

		/*

		**	Process pending interrupts.

 SCSI_NCR_BROKEN_INTR */

/*==========================================================

**

**	log message for real hard errors

**

**	"ncr0 targ 0?: ERROR (ds:si) (so-si-sd) (sxfer/scntl3) @ name (dsp:dbc)."

**	"	      reg: r0 r1 r2 r3 r4 r5 r6 ..... rf."

**

**	exception register:

**		ds:	dstat

**		si:	sist

**

**	SCSI bus lines:

**		so:	control lines as driver by NCR.

**		si:	control lines as seen by NCR.

**		sd:	scsi data lines as seen by NCR.

**

**	wide/fastmode:

**		sxfer:	(see the manual)

**		scntl3:	(see the manual)

**

**	current script command:

**		dsp:	script address (relative to start of script).

**		dbc:	first word of script command.

**

**	First 16 register of the chip:

**		r0..rf

**

**==========================================================

/*============================================================

**

**	ncr chip exception handler.

**

**============================================================

**

**	In normal cases, interrupt conditions occur one at a 

**	time. The ncr is able to stack in some extra registers 

**	other interrupts that will occur after the first one.

**	But, several interrupts may occur at the same time.

**

**	We probably should only try to deal with the normal 

**	case, but it seems that multiple interrupts occur in 

**	some cases that are not abnormal at all.

**

**	The most frequent interrupt condition is Phase Mismatch.

**	We should want to service this interrupt quickly.

**	A SCSI parity error may be delivered at the same time.

**	The SIR interrupt is not very frequent in this driver, 

**	since the INTFLY is likely used for command completion 

**	signaling.

**	The Selection Timeout interrupt may be triggered with 

**	IID and/or UDC.

**	The SBMC interrupt (SCSI Bus Mode Change) may probably 

**	occur at any time.

**

**	This handler try to deal as cleverly as possible with all

**	the above.

**

**============================================================

	/*

	**	interrupt on the fly ?

	**	Since the global header may be copied back to a CCB 

	**	using a posted PCI memory write, the last operation on 

	**	the istat register is a READ in order to flush posted 

	**	PCI write commands.

	/*

	**	Steinbach's Guideline for Systems Programming:

	**	Never test for an error condition you don't know how to handle.

	/*========================================================

	**	First, interrupts we want to service cleanly.

	**

	**	Phase mismatch is the most frequent interrupt, and 

	**	so we have to service it as quickly and as cleanly 

	**	as possible.

	**	Programmed interrupts are rarely used in this driver,

	**	but we must handle them cleanly anyway.

	**	We try to deal with PAR and SBMC combined with 

	**	some other interrupt(s).

	**=========================================================

		/*

		**  DEL 397 - 53C875 Rev 3 - Part Number 609-0392410 - ITEM 2.

	/*========================================================

	**	Now, interrupts that need some fixing up.

	**	Order and multiple interrupts is so less important.

	**

	**	If SRST has been asserted, we just reset the chip.

	**

	**	Selection is intirely handled by the chip. If the 

	**	chip says STO, we trust it. Seems some other 

	**	interrupts may occur at the same time (UDC, IID), so 

	**	we ignore them. In any case we do enough fix-up 

	**	in the service routine.

	**	We just exclude some fatal dma errors.

	**=========================================================

	/*

	**	DEL 397 - 53C875 Rev 3 - Part Number 609-0392410 - ITEM 1.

	/*=========================================================

	**	Now, interrupts we are not able to recover cleanly.

	**	(At least for the moment).

	**

	**	Do the register dump.

	**	Log message for real hard errors.

	**	Clear all fifos.

	**	For MDPE, BF, ABORT, IID, SGE and HTH we reset the 

	**	BUS and the chip.

	**	We are more soft for UDC.

	**=========================================================

	/*=========================================================

	**	We just miss the cause of the interrupt. :(

	**	Print a message. The timeout will do the real work.

	**=========================================================

/*==========================================================

**

**	ncr chip exception handler for selection timeout

**

**==========================================================

**

**	There seems to be a bug in the 53c810.

**	Although a STO-Interrupt is pending,

**	it continues executing script commands.

**	But it will fail and interrupt (IID) on

**	the next instruction where it's looking

**	for a valid phase.

**

**----------------------------------------------------------

	/*

	**	look for ccb and set the status.

	/*

	**	repair start queue and jump to start point.

/*==========================================================

**

**	ncr chip exception handler for SCSI bus mode change

**

**==========================================================

**

**	spi2-r12 11.2.3 says a transceiver mode change must 

**	generate a reset event and a device that detects a reset 

**	event shall initiate a hard reset. It says also that a

**	device that detects a mode change shall set data transfer 

**	mode to eight bit asynchronous, etc...

**	So, just resetting should be enough.

**	 

**

**----------------------------------------------------------

		/*

		**	Suspend command processing for 1 second and 

		**	reinitialize all except the chip.

/*==========================================================

**

**	ncr chip exception handler for SCSI parity error.

**

**==========================================================

**

**

**----------------------------------------------------------

	/*

	 *	Ignore the interrupt if the NCR is not connected 

	 *	to the SCSI bus, since the right work should have  

	 *	been done on unexpected disconnection handling.

	/*

	 *	If the nexus is not clearly identified, reset the bus.

	 *	We will try to do better later.

	/*

	 *	If the SCSI parity error occurs in MSG IN phase, prepare a 

	 *	MSG PARITY message. Otherwise, prepare a INITIATOR DETECTED 

	 *	ERROR message and let the device decide to retry the command 

	 *	or to terminate with check condition. If we were in MSG IN 

	 *	phase waiting for the response of a negotiation, we will 

	 *	get SIR_NEGO_FAILED at dispatch.

	/*

	 *	If the NCR stopped on a MOVE ^ DATA_IN, we jump to a 

	 *	script that will ignore all data in bytes until phase 

	 *	change, since we are not sure the chip will wait the phase 

	 *	change prior to delivering the interrupt.

 clear dma fifo  */

 clear scsi fifo */

/*==========================================================

**

**

**	ncr chip exception handler for phase errors.

**

**

**==========================================================

**

**	We have to construct a new transfer descriptor,

**	to transfer the rest of the current block.

**

**----------------------------------------------------------

	/*

	**	Take into account dma fifo and various buffers and latches,

	**	only if the interrupted phase is an OUTPUT phase.

		/*

		**	The data in the dma fifo has not been transferred to

		**	the target -> add the amount to the rest

		**	and clear the data.

		**	Check the sstat2 register in case of wide transfer.

	/*

	**	Clear fifos.

 clear dma fifo  */

 clear scsi fifo */

	/*

	**	locate matching cp.

	**	if the interrupted phase is DATA IN or DATA OUT,

	**	trust the global header.

	/*

	**	try to find the interrupted script command,

	**	and the address at which to continue.

	/*

	**	log the information

	/*

	**	cp=0 means that the DSA does not point to a valid control 

	**	block. This should not happen since we donnot use multi-byte 

	**	move while we are being reselected ot after command complete.

	**	We are not able to recover from such a phase error.

	/*

	**	get old startaddress and old length.

 Table indirect */

	/*

	**	check cmd against assumed interrupted script command.

	/*

	**	cp != np->header.cp means that the header of the CCB 

	**	currently being processed has not yet been copied to 

	**	the global header area. That may happen if the device did 

	**	not accept all our messages after having been selected.

	/*

	**	if old phase not dataphase, leave here.

	/*

	**	choose the correct patch area.

	**	if savep points to one, choose the other.

	/*

	**	fillin the commands

	/*

	**	fake the return address (to the patch).

	**	and restart script processor at dispatcher.

	/*

	**	Unexpected phase changes that occurs when the current phase 

	**	is not a DATA IN or DATA OUT phase are due to error conditions.

	**	Such event may only happen when the SCRIPTS is using a 

	**	multibyte SCSI MOVE.

	**

	**	Phase change		Some possible cause

	**

	**	COMMAND  --> MSG IN	SCSI parity error detected by target.

	**	COMMAND  --> STATUS	Bad command or refused by target.

	**	MSG OUT  --> MSG IN     Message rejected by target.

	**	MSG OUT  --> COMMAND    Bogus target that discards extended

	**				negotiation messages.

	**

	**	The code below does not care of the new phase and so 

	**	trusts the target. Why to annoy it ?

	**	If the interrupted phase is COMMAND phase, we restart at

	**	dispatcher.

	**	If a target does not get all the messages after selection, 

	**	the code assumes blindly that the target discards extended 

	**	messages and clears the negotiation status.

	**	If the target does not want all our response to negotiation,

	**	we force a SIR_NEGO_PROTO interrupt (it is a hack that avoids 

	**	bloat for such a should_not_happen situation).

	**	In all other situation, we reset the BUS.

	**	Are these assumptions reasonable ? (Wait and see ...)

 COMMAND phase */

 STATUS  phase */

 MSG OUT phase */

 MSG IN  phase */

	/*

	**	Let the SCRIPTS processor skip all not yet started CCBs,

	**	and count disconnected CCBs. Since the busy queue is in 

	**	the same order as the chip start queue, disconnected CCBs 

	**	are before cp and busy ones after.

 Requeue when this one completes */

 Just for safety, should never happen */

		/*

		**	Decrease number of tags to the number of 

		**	disconnected commands.

		/*

		**	Requeue the command to the start queue.

		**	If any disconnected commands,

		**		Clear SIGP.

		**		Jump to reselect.

 Clear SIGP */

		/*

		**	If we were requesting sense, give up.

		/*

		**	Device returned CHECK CONDITION status.

		**	Prepare all needed data strutures for getting 

		**	sense data.

		**

		**	identify message

		/*

		**	sense command

		/*

		**	patch requested size into sense command

		/*

		**	sense data

		/*

		**	requeue the command.

		/*

		**	Select without ATN for quirky devices.

/*==========================================================

**

**

**      ncr chip exception handler for programmed interrupts.

**

**

**==========================================================

		/*

		**	This is used for HP Zalon/53c720 where INTFLY

		**	operation is currently broken.

		/*

		**	If devices reselecting without sending an IDENTIFY 

		**	message still exist, this should help.

		**	We just assume lun=0, 1 CCB, no tag.

 Will send a TARGET RESET message */

 Will send a TARGET RESET message */

 Will send an ABORT TAG message   */

 Will send an ABORT message	    */

		/*

		**	lookup the ccb

/*-----------------------------------------------------------------------------

**

**	Was Sie schon immer ueber transfermode negotiation wissen wollten ...

**	("Everything you've always wanted to know about transfer mode

**	  negotiation")

**

**	We try to negotiate sync and wide transfer only after

**	a successful inquire command. We look at byte 7 of the

**	inquire data to determine the capabilities of the target.

**

**	When we try to negotiate, we append the negotiation message

**	to the identify and (maybe) simple tag message.

**	The host status field is set to HS_NEGOTIATE to mark this

**	situation.

**

**	If the target doesn't answer this message immediately

**	(as required by the standard), the SIR_NEGO_FAIL interrupt

**	will be raised eventually.

**	The handler removes the HS_NEGOTIATE status, and sets the

**	negotiated value to the default (async / nowide).

**

**	If we receive a matching answer immediately, we check it

**	for validity, and set the values.

**

**	If we receive a Reject message immediately, we assume the

**	negotiation has failed, and fall back to standard values.

**

**	If we receive a negotiation message while not in HS_NEGOTIATE

**	state, it's a target initiated negotiation. We prepare a

**	(hopefully) valid answer, set our parameters, and send back 

**	this answer to the target.

**

**	If the target doesn't fetch the answer (no message out phase),

**	we assume the negotiation has failed, and fall back to default

**	settings.

**

**	When we set the values, we adjust them in all ccbs belonging 

**	to this target, in the controller's register, and in the "phys"

**	field of the controller's struct ncb.

**

**	Possible cases:		   hs  sir   msg_in value  send   goto

**	We try to negotiate:

**	-> target doesn't msgin    NEG FAIL  noop   defa.  -      dispatch

**	-> target rejected our msg NEG FAIL  reject defa.  -      dispatch

**	-> target answered  (ok)   NEG SYNC  sdtr   set    -      clrack

**	-> target answered (!ok)   NEG SYNC  sdtr   defa.  REJ--->msg_bad

**	-> target answered  (ok)   NEG WIDE  wdtr   set    -      clrack

**	-> target answered (!ok)   NEG WIDE  wdtr   defa.  REJ--->msg_bad

**	-> any other msgin	   NEG FAIL  noop   defa.  -      dispatch

**

**	Target tries to negotiate:

**	-> incoming message	   --- SYNC  sdtr   set    SDTR   -

**	-> incoming message	   --- WIDE  wdtr   set    WDTR   -

**      We sent our answer:

**	-> target doesn't msgout   --- PROTO ?      defa.  -      dispatch

**

**-----------------------------------------------------------------------------

		/*-------------------------------------------------------

		**

		**	Negotiation failed.

		**	Target doesn't send an answer message,

		**	or target rejected our message.

		**

		**      Remove negotiation request.

		**

		**-------------------------------------------------------

		/*-------------------------------------------------------

		**

		**	Negotiation failed.

		**	Target doesn't fetch the answer message.

		**

		**-------------------------------------------------------

		/*

		**	any error in negotiation:

		**	fall back to default mode.

		/*

		**      if target sends SDTR message,

		**	      it CAN transfer synch.

		/*

		**	check values against driver limits.

		/*

		**	Check against controller limits.

 This was an answer message */

 Answer wasn't acceptable.  */

 Answer is ok.  */

		/*

		**	It was a request. Set value and

		**      prepare an answer message

		/*

		**	Wide request message received.

		/*

		**	get requested values.

		/*

		**      if target sends WDTR message,

		**	      it CAN transfer wide.

		/*

		**	check values against driver limits.

				/*

				**      This was an answer message

 Answer wasn't acceptable.  */

 Answer is ok.  */

		/*

		**	It was a request, set value and

		**      prepare an answer message

/*--------------------------------------------------------------------

**

**	Processing of special messages

**

**--------------------------------------------------------------------

		/*-----------------------------------------------

		**

		**	We received a MESSAGE_REJECT.

		**

		**-----------------------------------------------

		/*-----------------------------------------------

		**

		**	We received an unknown message

		**

		**-----------------------------------------------

/*--------------------------------------------------------------------

**

**	Processing of special messages

**

**--------------------------------------------------------------------

		/*-----------------------------------------------

		**

		**	We received an IGNORE RESIDUE message,

		**	which couldn't be handled by the script.

		**

		**-----------------------------------------------

		/*-----------------------------------------------

		**

		**	We received an DISCONNECT message,

		**	but the datapointer wasn't saved before.

		**

		**-----------------------------------------------

/*==========================================================

**

**

**	Acquire a control block

**

**

**==========================================================

	/*

	**	Lun structure available ?

		/*

		**	Keep from using more tags than we can handle.

		/*

		**	Allocate a new CCB if needed.

		/*

		**	Look for free CCB

		/*

		**	If a CCB is available,

		**	Get a tag for this nexus if required.

	/*

	**	if nothing available, take the default.

	/*

	**	Wait until available.

	/*

	**	Move to next available tag if tag used.

	/*

	**	Remember all informations needed to free this CCB.

/*==========================================================

**

**

**	Release one control block

**

**

**==========================================================

	/*

	**	If lun control block available,

	**	decrement active commands and increment credit, 

	**	free the tag if any and remove the JUMP for reselect.

	/*

	**	Make this CCB available.

/*------------------------------------------------------------------------

**	Initialize the fixed part of a CCB structure.

**------------------------------------------------------------------------

**------------------------------------------------------------------------

	/*

	**	Remember virtual and bus address of this ccb.

	/*

	**	This allows list_del to work for the default ccb.

	/*

	**	Initialyze the start and restart launch script.

	**

	**	COPY(4) @(...p_phys), @(dsa)

	**	JUMP @(sched_point)

/*------------------------------------------------------------------------

**	Allocate a CCB and initialize its fixed part.

**------------------------------------------------------------------------

**------------------------------------------------------------------------

	/*

	**	Allocate memory for this CCB.

	/*

	**	Count it and initialyze it.

	/*

	**	Chain into wakeup list and free ccb queue and take it 

	**	into account for tagged commands.

/*==========================================================

**

**

**      Allocation of resources for Targets/Luns/Tags.

**

**

**==========================================================

/*------------------------------------------------------------------------

**	Target control block initialisation.

**------------------------------------------------------------------------

**	This data structure is fully initialized after a SCSI command 

**	has been successfully completed for this target.

**	It contains a SCRIPT that is called on target reselection.

**------------------------------------------------------------------------

	/*

	**	Jump to next tcb if SFBR does not match this target.

	**	JUMP  IF (SFBR != #target#), @(next tcb)

	/*

	**	Load the synchronous transfer register.

	**	COPY @(tp->sval), @(sxfer)

	/*

	**	Load the timing register.

	**	COPY @(tp->wval), @(scntl3)

	/*

	**	Get the IDENTIFY message and the lun.

	**	CALL @script(resel_lun)

	/*

	**	Look for the lun control block of this nexus.

	**	For i = 0 to 3

	**		JUMP ^ IFTRUE (MASK (i, 3)), @(next_lcb)

	/*

	**	Link this target control block to the JUMP chain.

	/*

	**	These assert's should be moved at driver initialisations.

/*------------------------------------------------------------------------

**	Lun control block allocation and initialization.

**------------------------------------------------------------------------

**	This data structure is allocated and initialized after a SCSI 

**	command has been successfully completed for this target/lun.

**------------------------------------------------------------------------

	/*

	**	Already done, return.

	/*

	**	Allocate the lcb.

	/*

	**	Initialize the target control block if not yet.

	/*

	**	Initialize the CCB queue headers.

	/*

	**	Set max CCBs to 1 and use the default 1 entry 

	**	jump table by default.

	/*

	**	Initilialyze the reselect script:

	**

	**	Jump to next lcb if SFBR does not match this lun.

	**	Load TEMP with the CCB direct jump table bus address.

	**	Get the SIMPLE TAG message and the tag.

	**

	**	JUMP  IF (SFBR != #lun#), @(next lcb)

	**	COPY @(lp->p_jump_ccb),	  @(temp)

	**	JUMP @script(resel_notag)

	/*

	**	Link this lun control block to the JUMP chain.

	/*

	**	Initialize command queuing control.

/*------------------------------------------------------------------------

**	Lun control block setup on INQUIRY data received.

**------------------------------------------------------------------------

**	We only support WIDE, SYNC for targets and CMDQ for logical units.

**	This setup is done on each INQUIRY since we are expecting user 

**	will play with CHANGE DEFINITION commands. :-)

**------------------------------------------------------------------------

 If no lcb, try to allocate it.  */

	/*

	**	If unit supports tagged commands, allocate the 

	**	CCB JUMP table if not yet.

/*==========================================================

**

**

**	Build Scatter Gather Block

**

**

**==========================================================

**

**	The transfer area may be scattered among

**	several non adjacent physical pages.

**

**	We may use MAX_SCATTER blocks.

**

**----------------------------------------------------------

/*

**	We try to reduce the number of interrupts caused

**	by unexpected phase changes due to disconnects.

**	A typical harddisk may disconnect before ANY block.

**	If we wanted to avoid unexpected phase changes at all

**	we had to use a break point every 512 bytes.

**	Of course the number of scatter/gather blocks is

**	limited.

**	Under Linux, the scatter/gatter blocks are provided by 

**	the generic driver. We just have to copy addresses and 

**	sizes to the data segment array.

/*==========================================================

**

**

**	Test the bus snoop logic :-(

**

**	Has to be called with interrupts disabled.

**

**

**==========================================================

	/*

	**	ncr registers may NOT be cached.

	**	write 0xffffffff to a read only register area,

	**	and try to read it back.

 init */

	/*

	**	Set memory and register.

	/*

	**	Start script (exchange values)

	/*

	**	Wait 'til done (with timeout)

	/*

	**	Save termination position.

	/*

	**	Read memory and register.

	/*

	**	Reset ncr chip

	/*

	**	check for timeout

	/*

	**	Check termination position.

	/*

	**	Show results.

/*==========================================================

**

**	Determine the ncr's clock frequency.

**	This is essential for the negotiation

**	of the synchronous transfer rate.

**

**==========================================================

**

**	Note: we have to return the correct value.

**	THERE IS NO SAFE DEFAULT VALUE.

**

**	Most NCR/SYMBIOS boards are delivered with a 40 Mhz clock.

**	53C860 and 53C875 rev. 1 support fast20 transfers but 

**	do not have a clock doubler and so are provided with a 

**	80 MHz clock. All other fast20 boards incorporate a doubler 

**	and so should be delivered with a 40 MHz clock.

**	The future fast40 chips (895/895) use a 40 Mhz base clock 

**	and provide a clock quadrupler (160 Mhz). The code below 

**	tries to deal as cleverly as possible with all this stuff.

**

**----------------------------------------------------------

/*

 *	Select NCR SCSI clock frequency

 Enable clock multiplier		  */

 Poll bit 5 of stest4 for quadrupler */

 Wait 20 micro-seconds for doubler	*/

 Halt the scsi clock		*/

 Select clock multiplier	*/

 Restart scsi clock 		*/

/*

 *	calculate NCR SCSI clock frequency (in KHz)

	/*

	 * Measure GEN timer delay in order 

	 * to calculate SCSI clock frequency

	 *

	 * This code will never execute too

	 * many loop iterations (if DELAY is 

	 * reasonably correct). It could get

	 * too low a delay (too high a freq.)

	 * if the CPU is slow executing the 

	 * loop for some reason (an NMI, for

	 * example). For this reason we will

	 * if multiple measurements are to be 

	 * performed trust the higher delay 

	 * (lower frequency returned).

 make sure clock doubler is OFF */

 mask all scsi interrupts */

 clear pending scsi interrupt */

 mask all dma interrupts */

 another one, just to be sure :) */

 set pre-scaler to divide by 3 */

 disable general purpose timer */

 set to nominal delay of 1<<gen * 125us */

 count ms */

 disable general purpose timer */

 	/*

 	 * set prescaler to divide by whatever 0 means

 	 * 0 ought to choose divide by 2, but appears

 	 * to set divide by 3.5 mode in my 53c810 ...

  	/*

 	 * adjust for prescaler, and convert into KHz 

/*

 *	Get/probe NCR SCSI clock frequency

	/*

	**	True with 875 or 895 with clock multiplier selected

	/*

	**	If multiplier not found or scntl3 not 7,5,3,

	**	reset chip and get frequency from general purpose timer.

	**	Otherwise trust scntl3 BIOS setting.

 throw away first result */

 trust lower result	*/

	/*

	**	Compute controller synchronous parameters.

===================== LINUX ENTRY POINTS SECTION ==========================*/

	/*

	**	Select queue depth from driver setup.

	**	Donnot use more than configured by user.

	**	Use at least 2.

	**	Donnot use more than our maximum.

	/*

	**	Since the queue depth is not tunable under Linux,

	**	we need to know this value in order not to 

	**	announce stupid things to user.

	**

	**	XXX(hch): As of Linux 2.6 it certainly _is_ tunable..

	**		  In fact we just tuned it, or did I miss

	**		  something important? :)

	/*

	 * If the mid-level driver told us reset is synchronous, it seems 

	 * that we must call the done() callback for the involved command, 

	 * even if this command was not queued to the low-level driver, 

	 * before returning SUCCESS.

/*

**	Scsi command waiting list management.

**

**	It may happen that we cannot insert a scsi command into the start queue,

**	in the following circumstances.

** 		Too few preallocated ccb(s), 

**		maxtags < cmd_per_lun of the Linux host control block,

**		etc...

**	Such scsi commands are inserted into a waiting list.

**	When a scsi command complete, we try to requeue the commands of the

**	waiting list.

/*==========================================================

**

**	Boot command line.

**

**==========================================================

 command line passed by insmod */

/*

 *	Host attach and initialisations.

 *

 *	Allocate host data and ncb structure.

 *	Request IO region and remap MMIO region.

 *	Do chip initialization.

 *	If all is OK, install interrupt handling and

 *	start the timer daemon.

 Store input information in the host data structure.  */

 Allocate SCRIPTS areas.  */

 Try to map the controller chip to virtual and physical memory. */

	/* Make the controller's registers available.  Now the INB INW INL

	 * OUTB OUTW OUTL macros can be used safely.

 Do chip dependent initialization.  */

	/* This can happen if you forget to call ncr53c8xx_init from

 Patch script to physical addresses */

 Patch the script for LED support.  */

	/*

	 * Look for the target control block of this nexus.

	 * For i = 0 to 3

	 *   JUMP ^ IFTRUE (MASK (i, 3)), @(next_lcb)

 Now check the cache handling of the chipset.  */

 Install the interrupt handler.  */

 Initialize the fixed part of the default ccb.  */

	/*

	 * After SCSI devices have been opened, we cannot reset the bus

	 * safely, so we do it here.  Interrupt handler does the real work.

	 * Process the reset exception if interrupts are not enabled yet.

	 * Then enable disconnects.

	/*

	 * The middle-level SCSI driver does not wait for devices to settle.

	 * Wait synchronously if more than 2 seconds.

 start the timeout daemon */

 use SIMPLE TAG messages by default */

 SPDX-License-Identifier: GPL-2.0-or-later

/* aha152x.c -- Adaptec AHA-152x driver

 * Author: Jürgen E. Fischer, fischer@norbit.de

 * Copyright 1993-2004 Jürgen E. Fischer

 *

 * $Id: aha152x.c,v 2.7 2004/01/24 11:42:59 fischer Exp $

 *

 * $Log: aha152x.c,v $

 * Revision 2.7  2004/01/24 11:42:59  fischer

 * - gather code that is not used by PCMCIA at the end

 * - move request_region for !PCMCIA case to detection

 * - migration to new scsi host api (remove legacy code)

 * - free host scribble before scsi_done

 * - fix error handling

 * - one isapnp device added to id_table

 *

 * Revision 2.6  2003/10/30 20:52:47  fischer

 * - interfaces changes for kernel 2.6

 * - aha152x_probe_one introduced for pcmcia stub

 * - fixed pnpdev handling

 * - instead of allocation a new one, reuse command for request sense after check condition and reset

 * - fixes race in is_complete

 *

 * Revision 2.5  2002/04/14 11:24:53  fischer

 * - isapnp support

 * - abort fixed

 * - 2.5 support

 *

 * Revision 2.4  2000/12/16 12:53:56  fischer

 * - allow REQUEST SENSE to be queued

 * - handle shared PCI interrupts

 *

 * Revision 2.3  2000/11/04 16:40:26  fischer

 * - handle data overruns

 * - extend timeout for data phases

 *

 * Revision 2.2  2000/08/08 19:54:53  fischer

 * - minor changes

 *

 * Revision 2.1  2000/05/17 16:23:17  fischer

 * - signature update

 * - fix for data out w/o scatter gather

 *

 * Revision 2.0  1999/12/25 15:07:32  fischer

 * - interrupt routine completly reworked

 * - basic support for new eh code

 *

 * Revision 1.21  1999/11/10 23:46:36  fischer

 * - default to synchronous operation

 * - synchronous negotiation fixed

 * - added timeout to loops

 * - debugging output can be controlled through procfs

 *

 * Revision 1.20  1999/11/07 18:37:31  fischer

 * - synchronous operation works

 * - resid support for sg driver

 *

 * Revision 1.19  1999/11/02 22:39:59  fischer

 * - moved leading comments to README.aha152x

 * - new additional module parameters

 * - updates for 2.3

 * - support for the Tripace TC1550 controller

 * - interrupt handling changed

 *

 * Revision 1.18  1996/09/07 20:10:40  fischer

 * - fixed can_queue handling (multiple outstanding commands working again)

 *

 * Revision 1.17  1996/08/17 16:05:14  fischer

 * - biosparam improved

 * - interrupt verification

 * - updated documentation

 * - cleanups

 *

 * Revision 1.16  1996/06/09 00:04:56  root

 * - added configuration symbols for insmod (aha152x/aha152x1)

 *

 * Revision 1.15  1996/04/30 14:52:06  fischer

 * - proc info fixed

 * - support for extended translation for >1GB disks

 *

 * Revision 1.14  1996/01/17  15:11:20  fischer

 * - fixed lockup in MESSAGE IN phase after reconnection

 *

 * Revision 1.13  1996/01/09  02:15:53  fischer

 * - some cleanups

 * - moved request_irq behind controller initialization

 *   (to avoid spurious interrupts)

 *

 * Revision 1.12  1995/12/16  12:26:07  fischer

 * - barrier()s added

 * - configurable RESET delay added

 *

 * Revision 1.11  1995/12/06  21:18:35  fischer

 * - some minor updates

 *

 * Revision 1.10  1995/07/22  19:18:45  fischer

 * - support for 2 controllers

 * - started synchronous data transfers (not working yet)

 *

 * Revision 1.9  1995/03/18  09:20:24  root

 * - patches for PCMCIA and modules

 *

 * Revision 1.8  1995/01/21  22:07:19  root

 * - snarf_region => request_region

 * - aha152x_intr interface change

 *

 * Revision 1.7  1995/01/02  23:19:36  root

 * - updated COMMAND_SIZE to cmd_len

 * - changed sti() to restore_flags()

 * - fixed some #ifdef which generated warnings

 *

 * Revision 1.6  1994/11/24  20:35:27  root

 * - problem with odd number of bytes in fifo fixed

 *

 * Revision 1.5  1994/10/30  14:39:56  root

 * - abort code fixed

 * - debugging improved

 *

 * Revision 1.4  1994/09/12  11:33:01  root

 * - irqaction to request_irq

 * - abortion updated

 *

 * Revision 1.3  1994/08/04  13:53:05  root

 * - updates for mid-level-driver changes

 * - accept unexpected BUSFREE phase as error condition

 * - parity check now configurable

 *

 * Revision 1.2  1994/07/03  12:56:36  root

 * - cleaned up debugging code

 * - more tweaking on reset delays

 * - updated abort/reset code (pretty untested...)

 *

 * Revision 1.1  1994/05/28  21:18:49  root

 * - update for mid-level interface change (abort-reset)

 * - delays after resets adjusted for some slow devices

 *

 * Revision 1.0  1994/03/25  12:52:00  root

 * - Fixed "more data than expected" problem

 * - added new BIOS signatures

 *

 * Revision 0.102  1994/01/31  20:44:12  root

 * - minor changes in insw/outsw handling

 *

 * Revision 0.101  1993/12/13  01:16:27  root

 * - fixed STATUS phase (non-GOOD stati were dropped sometimes;

 *   fixes problems with CD-ROM sector size detection & media change)

 *

 * Revision 0.100  1993/12/10  16:58:47  root

 * - fix for unsuccessful selections in case of non-continuous id assignments

 *   on the scsi bus.

 *

 * Revision 0.99  1993/10/24  16:19:59  root

 * - fixed DATA IN (rare read errors gone)

 *

 * Revision 0.98  1993/10/17  12:54:44  root

 * - fixed some recent fixes (shame on me)

 * - moved initialization of scratch area to aha152x_queue

 *

 * Revision 0.97  1993/10/09  18:53:53  root

 * - DATA IN fixed. Rarely left data in the fifo.

 *

 * Revision 0.96  1993/10/03  00:53:59  root

 * - minor changes on DATA IN

 *

 * Revision 0.95  1993/09/24  10:36:01  root

 * - change handling of MSGI after reselection

 * - fixed sti/cli

 * - minor changes

 *

 * Revision 0.94  1993/09/18  14:08:22  root

 * - fixed bug in multiple outstanding command code

 * - changed detection

 * - support for kernel command line configuration

 * - reset corrected

 * - changed message handling

 *

 * Revision 0.93  1993/09/15  20:41:19  root

 * - fixed bugs with multiple outstanding commands

 *

 * Revision 0.92  1993/09/13  02:46:33  root

 * - multiple outstanding commands work (no problems with IBM drive)

 *

 * Revision 0.91  1993/09/12  20:51:46  root

 * added multiple outstanding commands

 * (some problem with this $%&? IBM device remain)

 *

 * Revision 0.9  1993/09/12  11:11:22  root

 * - corrected auto-configuration

 * - changed the auto-configuration (added some '#define's)

 * - added support for dis-/reconnection

 *

 * Revision 0.8  1993/09/06  23:09:39  root

 * - added support for the drive activity light

 * - minor changes

 *

 * Revision 0.7  1993/09/05  14:30:15  root

 * - improved phase detection

 * - now using the new snarf_region code of 0.99pl13

 *

 * Revision 0.6  1993/09/02  11:01:38  root

 * first public release; added some signatures and biosparam()

 *

 * Revision 0.5  1993/08/30  10:23:30  root

 * fixed timing problems with my IBM drive

 *

 * Revision 0.4  1993/08/29  14:06:52  root

 * fixed some problems with timeouts due incomplete commands

 *

 * Revision 0.3  1993/08/28  15:55:03  root

 * writing data works too.  mounted and worked on a dos partition

 *

 * Revision 0.2  1993/08/27  22:42:07  root

 * reading data works.  Mounted a msdos partition.

 *

 * Revision 0.1  1993/08/25  13:38:30  root

 * first "damn thing doesn't work" version

 *

 * Revision 0.0  1993/08/14  19:54:25  root

 * empty function bodies; detect() works.

 *

 **************************************************************************



 see Documentation/scsi/aha152x.rst for configuration details



 DEFINES */

 For PCMCIA cards, always use AUTOCONF */

 command not yet issued */

 target is being selected */

 IDENTIFY was sent */

 target disconnected */

 target sent COMMAND COMPLETE */

 ABORT was sent */

 BUS DEVICE RESET was sent */

 waiting for SPIORDY to raise */

 synchronous negotiation in progress */

 ABORT is pending */

 BUS DEVICE RESET is pending */

 requesting sense after CHECK CONDITION */

 MODULE */

 ISAPNP */

 !AHA152X_PCMCIA */

/*

 * internal states of the host

 *

/*

 * current state information of the host

 *

 pending commands to issue */

 current command on the bus */

 commands that disconnected */

 command that was completed */

 host lock */

 current number of commands */

 disconnection allowed */

 parity checking enabled */

 synchronous transferes enabled */

 reset out delay */

 extended translation enabled */

 software-interrupt was fired during detect() */

 bh needs to be run */

 bh is running */

	/* current state,

	   previous state,

 reconnecting target */

 current synchronous transfer agreements */

		/* 0: no negotiation;

		 * 1: negotiation in progress;

		 * 2: negotiation completed

 number of sent bytes of current command */

 number of received message bytes */

 received message bytes */

 number of sent bytes and length of current messages */

 pending messages */

 number of sent/received bytes in dataphase */

/*

 * host specific command extension

 *

 next sc in queue */

 semaphore to block on */

 access macros for hostdata */

 state handling */

/*

 * driver states

 *

 setup & interrupt */

 diagnostics */

/*

 *  queue services:

 *

 need to have host registered before triggering any interrupt */

 RESET OUT */

 not expecting any interrupts */

 clear interrupts */

/*

 * setup controller to generate interrupts depending

 * on current state (lock has to be acquired)

 *

/*

 *  Queue a command and setup interrupts for a free bus.

 Ilegal status by SCSI standard */

	/* setup scratch area

	   SCp.ptr              : buffer pointer

	   SCp.this_residual    : buffer length

	   SCp.buffer           : next buffer

 Turn led on, when this is the first command. */

/*

 *  queue a command

 *

/*

 *

/*

 *  Abort a command

 *

	/*

	 * FIXME:

	 * for current command: queue ABORT for message out and raise ATN

	 * for disconnected command: pseudo SC with ABORT message or ABORT on reselection?

	 *

/*

 * Reset a device

 *

 remove command from issue queue */

 requeue */

/*

 * Reset the bus

 *

 * AIC-6260 has a hard reset (MRST signal), but apparently

 * one cannot trigger it via software. So live with

 * a soft reset; no-one seemed to have cared.

/*

 * Reset the bus

 *

/*

 *  Restore default values to the AIC-6260 registers and reset the fifos

 *

 disable interrupts */

 clear all interrupt conditions */

 clear SCSI fifos and transfer count */

/*

 * Reset the host (bus and controller)

 *

/*

 * Return the "logical geometry"

 *

 try default translation */

 for disks >1GB do some guessing */

 try to figure out the geometry from the partition table */

/*

 *  Internal done function

 *

/*

 * Run service completions on the card with interrupts enabled.

 *

/*

 * Interrupt handler

 *

	/*

	 * Read a couple of registers that are known to not be all 1's. If

	 * we read all 1's (-1), that means that either:

	 *

	 * a. The host adapter chip has gone bad, and we cannot control it,

	 *	OR

	 * b. The host adapter is a PCMCIA card that has been ejected

	 *

	 * In either case, we cannot do anything with the host adapter at

	 * this point in time. So just ignore the interrupt and return.

	 * In the latter case, the interrupt might actually be meant for

	 * someone else sharing this IRQ, and that driver will handle it.

	/* no more interrupts from the controller, while we're busy.

 Poke the BH handler */

/*

 * busfree phase

 * - handle completition/disconnection/error of current command

 * - start selection for next command (if any)

 target sent COMMAND COMPLETE */

 target sent DISCONNECT */

 turn led off */

 It was allocated in aha152x_internal_queue? */

 turn led off, when no commands are in the driver */

 turn led off */

 clear selection timeout */

/*

 * Selection done (OUT)

 * - queue IDENTIFY message and SDTR to selected target for message out

 *   (ATN asserted automagically via ENAUTOATNO in busfree())

 negotiation in progress */

/*

 * Selection timeout

 * - return command to mid-level with failure cause

 *

 ARBITRATION won, but SELECTION failed */

/*

 * Selection in done

 * - put current command back to issue queue

 *   (reconnection of a disconnected nexus instead

 *    of successful selection out)

 *

/*

 * message in phase

 * - handle initial message after reconnection to identify

 *   reconnecting nexus

 * - queue command on DISCONNECTED_SC on DISCONNECT message

 * - set completed flag on COMMAND COMPLETE

 *   (other completition code moved to busfree_run)

 * - handle response to SDTR

 * - clear synchronous transfer agreements on BUS RESET

 *

 * FIXME: what about SAVE POINTERS, RESTORE POINTERS?

 *

			/*

			 * Handle reselection

 next message if any */

 negotiation completed */

 not yet completed */

 negotiation in progress */

 requested SDTR is too slow, do it asynchronously */

 negotiation completed */

/*

 * message out phase

 *

/*

 * message out phase

 *

 Leave MESSAGE OUT after transfer */

/*

 * command phase

 *

/*

 * command phase

 *

/*

 * status phase

 *

/*

 * data in phase

 *

	/*

	 * loop while the phase persists or the fifos are not empty

	 *

		/* FIXME: maybe this should be done by setting up

		 * STCNT to trigger ENSWRAP interrupt, instead of

		 * polling for DFIFOFULL

 advance to next buffer */

		/*

		 * something went wrong, if there's something left in the fifos

		 * or the phase didn't change

/*

 * data out phase

 *

 until phase changes or all data sent */

 advance to next buffer */

 Locate the first SG entry not yet sent */

/*

 * figure out what state we're in

 *

/*

 * handle parity error

 *

 * FIXME: in which phase?

 *

/*

 * handle reset in

 *

/*

 * bottom-half handler

 *

 aha152x_error never returns.. */

	/*

	 * loop while there are interrupt conditions pending

	 *

		/*

		 * end previous state

		 *

		/*

		 * disable SPIO mode if previous phase used it

		 * and this one doesn't

		 *

		/*

		 * accept current dataphase phase

		 *

		/*

		 * enable SPIO mode if previous didn't use it

		 * and this one does

		 *

		/*

		 * initialize for new state

		 *

		/*

		 * handle current state

		 *

		/*

		 * setup controller to interrupt on

		 * the next expected condition and

		 * loop if it's already there

		 *

	/*

	 * enable interrupts and leave bottom-half

	 *

/*

 * Dump the current driver status and panic

/*

 * display enabled interrupts

/*

 * Show the command data of a command

/*

 * Dump the queued data

 possible i/o addresses for the AIC-6260; default first */

 possible locations for the Adaptec BIOS; defaults first */

 default first */

 VTech Platinum SMP */

/* signatures for various AIC-6[23]60 based controllers.

   The point in detecting signatures is to avoid useless and maybe

   harmful probes on ports. I'm not sure that all listed boards pass

   auto-configuration. For those which fail the BIOS signature is

   obsolete, because user intervention to supply the configuration is

   needed anyway.  May be an information whether or not the BIOS supports

 Adaptec 152x */

 Adaptec 152x rev B */

 Iomega Jaz Jet ISA (AIC6370Q) */

 on-board controller */

 on-board controller */

 on-board controller */

 on-board controller */

 ScsiPro-Controller  */

 Gigabyte Local-Bus-SCSI */

 Adaptec 282x */

 IBM Thinkpad Dock II */

 IBM Thinkpad Dock II SCSI */

 DTC 3520A ISA SCSI */

 !SKIP_BIOSTEST */

/*

 * Test, if port_base is valid.

 *

 reset stack pointer */

 reset stack pointer */

 reset stack pointer */

 reset stack pointer */

 !SKIP_BIOSTEST */

}*/

 !AHA152X_PCMCIA */

/*

 * Initio A100 device driver for Linux.

 *

 * Copyright (c) 1994-1998 Initio Corporation

 * Copyright (c) 2003-2004 Christoph Hellwig

 * All rights reserved.

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation; either version 2, or (at your option)

 * any later version.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * You should have received a copy of the GNU General Public License

 * along with this program; see the file COPYING.  If not, write to

 * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

 *

 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND

 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE

 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE

 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR

 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS

 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)

 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT

 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY

 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF

 * SUCH DAMAGE.

/*

 * Revision History:

 * 07/02/98 hl	- v.91n Initial drivers.

 * 09/14/98 hl - v1.01 Support new Kernel.

 * 09/22/98 hl - v1.01a Support reset.

 * 09/24/98 hl - v1.01b Fixed reset.

 * 10/05/98 hl - v1.02 split the source code and release.

 * 12/19/98 bv - v1.02a Use spinlocks for 2.1.95 and up

 * 01/31/99 bv - v1.02b Use mdelay instead of waitForPause

 * 08/08/99 bv - v1.02c Use waitForPause again.

 * 06/25/02 Doug Ledford <dledford@redhat.com> - v1.02d

 *          - Remove limit on number of controllers

 *          - Port to DMA mapping API

 *          - Clean up interrupt handler registration

 *          - Fix memory leaks

 *          - Fix allocation of scsi host structs and private data

 * 11/18/03 Christoph Hellwig <hch@lst.de>

 *	    - Port to new probing API

 *	    - Fix some more leaks in init failure cases

 * 9/28/04 Christoph Hellwig <hch@lst.de>

 *	    - merge the two source files

 *	    - remove internal queueing code

 * 14/06/07 Alan Cox <alan@lxorguk.ukuu.org.uk>

 *	 - Grand cleanup and Linuxisation

----------header -------------*/

 0x00: Sub System Vendor ID 0 */

 0x01: Sub System Vendor ID 1 */

 0x02: Sub System ID 0        */

 0x03: Sub System ID 1        */

 0x04: SubClass               */

 0x05: Vendor ID 0            */

 0x06: Vendor ID 1            */

 0x07: Device ID 0            */

 0x08: Device ID 1            */

 0x09: Reserved               */

 0x0A: Reserved               */

 0x0B: Revision of Data Structure     */

 -- Host Adapter Structure --- */

 0x0C: Number Of SCSI Channel */

 0x0D: BIOS Configuration 1   */

 0x0E: BIOS Configuration 2   */

 0x0F: BIOS Configuration 3   */

 --- SCSI Channel 0 Configuration --- */

 0x10: H/A ID                 */

 0x11: Channel Configuration  */

 0x12: MAX TAG per target     */

 0x13: SCSI Reset Recovering time     */

 0x14: Channel Configuration4 */

 0x15: Channel Configuration5 */

 SCSI Channel 0 Target Configuration  */

 0x16-0x25                    */

 --- SCSI Channel 1 Configuration --- */

 0x26: H/A ID                 */

 0x27: Channel Configuration  */

 0x28: MAX TAG per target     */

 0x29: SCSI Reset Recovering time     */

 0x2A: Channel Configuration4 */

 0x2B: Channel Configuration5 */

 SCSI Channel 1 Target Configuration  */

 0x2C-0x3B                    */

 0x3C: Reserved               */

 0x3D: Reserved               */

 0x3E: Reserved               */

 0x3F: Checksum               */

 Wait 1 second for report timeout     */

 Wait HOSTSTOP set */

 Wait 1 second for report timeout     */

 Wait READY set */

 wait 100ms before try again  */

**************************************************************************/

 Wait 1 second for report timeout     */

 Wait SCSIRST done */

 wait 100ms before try again  */

**************************************************************************/

 Wait 1 second for report timeout     */

 Wait HDO off */

 wait 100ms before try again  */

**************************************************************************/

 Wait 1 second for report timeout     */

 Wait HDI set */

 wait 100ms before try again  */

**************************************************************************/

 Wait HDO off   */

 Wait HDI set   */

 Clear HDI            */

 Wait HDI set   */

 Clear HDI            */

**************************************************************************/

 Write command */

 Wait HDO off   */

 Write address */

 Wait HDO off   */

 Write value  */

 Wait HDO off   */

**************************************************************************/

 Write command */

 Wait HDO off   */

 Write address */

 Wait HDO off   */

 Wait HDI set   */

 Clear HDI    */

/**

 *	orc_exec_scb		-	Queue an SCB with the HA

 *	@host: host adapter the SCB belongs to

 *	@scb: SCB to queue for execution

/**

 *	se2_rd_all	-	read SCSI parameters from EEPROM

 *	@host: Host whose EEPROM is being loaded

 *

 *	Read SCSI H/A configuration parameters from serial EEPROM

 <01> */

------ Is ckecksum ok ? ------*/

/**

 *	se2_update_all		-	update the EEPROM

 *	@host: Host whose EEPROM is being updated

 *

 *	Update changed bytes in the EEPROM image.

 setup default pattern  */

 Calculate checksum first   */

/**

 *	read_eeprom		-	load EEPROM

 *	@host: Host EEPROM to read

 *

 *	Read the EEPROM for a given host. If it is invalid or fails

 *	the restore the defaults and use them.

 setup default pattern        */

 load again                   */

/**

 *	orc_load_firmware	-	initialise firmware

 *	@host: Host to set up

 *

 *	Load the firmware from the EEPROM into controller SRAM. This

 *	is basically a 4K block copy and then a 4K block read to check

 *	correctness. The rest is convulted by the indirect interfaces

 *	in the hardware

 Set up the EEPROM for access */

 Enable EEPROM programming */

 Disable EEPROM programming */

 Disable EEPROM programming */

 Enable SRAM programming */

 Initial FW address to 0 */

 Read from BIOS */

 Read from BIOS */

 Read from BIOS */

 Write FW address */

 Copy the code from the BIOS to the SRAM */

 Required on Sun Ultra 5 ... 350 -> failures */

 FW code locate at BIOS address + ? */

 Download the code    */

 Firmware code size = 4K      */

 Read from BIOS */

 Write every 4 bytes */

 Go back and check they match */

 Reset program count 0 */

 Reset the BIOS address */

 Check the code       */

 Firmware code size = 4K      */

 Read from BIOS */

 Reset program to 0 */

Disable EEPROM programming */

 Success */

 Reset program to 0   */

 Disable EEPROM programming */

**************************************************************************/

 Setup SCB base and SCB Size registers */

 Total number of SCBs */

 SCB base address 0      */

 SCB base address 1      */

 setup scatter list address with one buffer */

/**

 *	init_alloc_map		-	initialise allocation map

 *	@host: host map to configure

 *

 *	Initialise the allocation maps for this device. If the device

 *	is not quiescent the caller must hold the allocation lock

/**

 *	init_orchid		-	initialise the host adapter

 *	@host:host adapter to initialise

 *

 *	Initialise the controller and if necessary load the firmware.

 *

 *	Returns -1 if the initialisation fails.

 Disable all interrupts */

 Orchid is ready */

 Reset Host Adapter   */

 Download FW                  */

 Setup SCB base and SCB Size registers */

 clear HOSTSTOP       */

 Wait for firmware ready     */

 Setup SCB base and SCB Size registers */

 Orchid is not Ready          */

 Reset Host Adapter   */

 Download FW                  */

 Setup SCB base and SCB Size registers */

 Do Hardware Reset &  */

     clear HOSTSTOP  */

 Wait for firmware ready      */

 Load an EEProm copy into RAM */

 Assumes single threaded at this point */

 enable RP FIFO interrupt     */

/**

 *	orc_reset_scsi_bus		-	perform bus reset

 *	@host: host being reset

 *

 *	Perform a full bus reset on the adapter.

 I need Host Control Block Information */

 reset scsi bus */

	/* FIXME: We can spend up to a second with the lock held and

/**

 *	orc_device_reset	-	device reset handler

 *	@host: host to reset

 *	@cmd: command causing the reset

 *	@target: target device

 *

 *	Reset registers, reset a hanging bus and kill active and disconnected

 *	commands for target w/o soft reset

 I need Host Control Block Information */

 setup scatter list address with one buffer */

	/* FIXME: is this safe if we then fail to issue the reset or race

 Find the scb corresponding to the command */

 Allocate a new SCB for the reset command to the firmware */

 Can't happen.. */

	/* Reset device is handled by the firmware, we fill in an SCB and

 Start execute SCB            */

/**

 *	__orc_alloc_scb		-		allocate an SCB

 *	@host: host to allocate from

 *

 *	Allocate an SCB and return a pointer to the SCB object. NULL

 *	is returned if no SCB is free. The caller must already hold

 *	the allocator lock at this point.

				/*

				 * Translate the index to a structure instance

/**

 *	orc_alloc_scb		-		allocate an SCB

 *	@host: host to allocate from

 *

 *	Allocate an SCB and return a pointer to the SCB object. NULL

 *	is returned if no SCB is free.

/**

 *	orc_release_scb			-	release an SCB

 *	@host: host owning the SCB

 *	@scb: SCB that is now free

 *

 *	Called to return a completed SCB to the allocation pool. Before

 *	calling the SCB must be out of use on both the host and the HA.

 Channel */

/*

 *	orchid_abort_scb	-	abort a command

 *

 *	Abort a queued command that has been passed to the firmware layer

 *	if possible. This is all handled by the firmware. We aks the firmware

 *	and it either aborts the command or fails

 Write command */

 Wait HDO off   */

 Write address */

 Wait HDO off   */

 Wait HDI set   */

 Clear HDI    */

 0 - Successfully               */

 1 - Fail                     */

	/* Walk the queue until we find the SCB that belongs to the command

	   block. This isn't a performance critical path so a walk in the park

 Issue an ABORT to the firmware */

/**

 *	orc_interrupt		-	IRQ processing

 *	@host: Host causing the interrupt

 *

 *	This function is called from the IRQ handler and protected

 *	by the host lock. While the controller reports that there are

 *	scb's for processing we pull them off the controller, turn the

 *	index into a host address pointer to the scb and call the scb

 *	handler.

 *

 *	Returns IRQ_HANDLED if any SCBs were processed, IRQ_NONE otherwise

 Check if we have an SCB queued for servicing */

 Get the SCB index of the SCB to service */

 Translate it back to a host pointer */

 Process the SCB */

 End of I1060Interrupt() */

/**

 *	inia100_build_scb	-	build SCB

 *	@host: host owing the control block

 *	@scb: control block to use

 *	@cmd: Mid layer command

 *

 *	Build a host adapter control block from the SCSI mid layer command

 Create corresponding SCB     */

 Pointer to SG list           */

 Links between the escb, scb and Linux scsi midlayer cmd */

 Set up the SCB to do a SCSI command block */

 Clear done bit               */

 Build the scatter gather lists */

 sense_addr is already little endian */

 Tag Support                  */

 Do simple tag only   */

 No tag support               */

/**

 *	inia100_queue_lck		-	queue command with host

 *	@cmd: Command block

 *	@done: Completion function

 *

 *	Called by the mid layer to queue a command. Process the command

 *	block, build the host specific scb structures and if there is room

 *	queue the command down to the controller

 Point to Host adapter control block */

 Get free SCSI control block  */

 Start execute SCB            */

/*****************************************************************************

 Function name  : inia100_abort

 Description    : Abort a queued command.

	                 (commands that are on the bus can't be aborted easily)

 Input          : host  -       Pointer to host adapter structure

 Output         : None.

 Return         : pSRB  -       Pointer to SCSI request block.

/*****************************************************************************

 Function name  : inia100_reset

 Description    : Reset registers, reset a hanging bus and

                  kill active and disconnected commands for target w/o soft reset

 Input          : host  -       Pointer to host adapter structure

 Output         : None.

 Return         : pSRB  -       Pointer to SCSI request block.

 I need Host Control Block Information */

/*****************************************************************************

 Function name  : inia100_device_reset

 Description    : Reset the device

 Input          : host  -       Pointer to host adapter structure

 Output         : None.

 Return         : pSRB  -       Pointer to SCSI request block.

 I need Host Control Block Information */

/**

 *	inia100_scb_handler	-	interrupt callback

 *	@host: Host causing the interrupt

 *	@scb: SCB the controller returned as needing processing

 *

 *	Perform completion processing on a control block. Do the conversions

 *	from host to SCSI midlayer error coding, save any sense data and

 *	the complete with the midlayer and recycle the scb.

 Pointer to SCSI request block */

 Release SCB for current channel */

 Linked command complete without error and linked normally */

 Linked command complete without error interrupt generated */

	case 0x11:		/* Selection time out-The initiator selection or target

	case 0x14:		/* Target bus phase sequence failure-An invalid bus phase or bus

				   phase sequence was requested by the target. The host adapter

				   will generate a SCSI Reset Condition, notifying the host with

 SCB Aborted. 07/21/98 */

	case 0x12:		/* Data overrun/underrun-The target attempted to transfer more data

				   than was allocated by the Data Length field or the sum of the

 Unexpected bus free-The target dropped the SCSI BSY at an unexpected time. */

 Invalid CCB Operation Code-The first byte of the CCB was invalid. */

 Couldn't find any better */

 Check condition              */

 Notify system DONE           */

 Release SCB for current channel */

/**

 *	inia100_intr		-	interrupt handler

 *	@irqno: Interrupt value

 *	@devid: Host adapter

 *

 *	Entry point for IRQ handling. All the real work is performed

 *	by orc_interrupt.

 <02> read from base address + 0x50 offset to get the bios value. */

 Get total memory needed for SCB */

 Get total memory needed for ESCB */

 Initialize orchid chip */

 Assign HCS index */

 Initial orc chip           */

/*



  FlashPoint.c -- FlashPoint SCCB Manager for Linux



  This file contains the FlashPoint SCCB Manager from BusLogic's FlashPoint

  Driver Developer's Kit, with minor modifications by Leonard N. Zubkoff for

  Linux compatibility.  It was provided by BusLogic in the form of 16 separate

  source files, which would have unnecessarily cluttered the scsi directory, so

  the individual files have been combined into this single file.



  Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved



  This file is available under both the GNU General Public License

  and a BSD-style copyright; see LICENSE.FlashPoint for details.



/* SCCB struct used for both SCCB and UCB manager compiles! 

 * The UCB Manager treats the SCCB as it's 'native hardware structure' 

#pragma pack(1)*/

 VOID (*SccbCallback)(); */

 Identifies board base port */

 actual transfer count */

 virtual addr for OS/2 */

 identify msg for selection */

 image of last msg in */

Inidcates TAGGED command. */

Type of tag msg to send. */

 Write */

 Read */

 No Request Sense Buffer */

 Select w\ Bus Device Reset */

 Select w\ Sync Nego */

 Select w\ Wide Data Nego */

 Select w\ Tagged Q'ing */

 SCCB completed without error */

 Set SCSI selection timed out */

 Target bus phase sequence failure */

 Major problem! */

 BusMaster error. */

 SCSI parity error */

1 for Normal disconnect 32 for Q'ing. */

 Max. no of cards suppoerted on Mother Board */

Number of prefetched elements. */

Eight byte per element. */

Contingent Allgiance */

 for alignment */

 Model No. of card */

 Card no. */

 Port Address of card */

	unsigned char niSysConf;	/* Adapter Configuration byte -

	unsigned char niScsiConf;	/* SCSI Configuration byte -

	unsigned char niScamConf;	/* SCAM Configuration byte -

	unsigned char niAdapId;		/* Host Adapter ID -

	unsigned char niSyncTbl[MAX_SCSI_TAR / 2];	/* Sync/Wide byte

	unsigned char niScamTbl[MAX_SCSI_TAR][4];	/* Compressed Scam name

Level2 Mstr (bits 7-6),  */

Priority Bit set (bits 7-6),  */

 Maxbyteoffset for Sync Xfers */

 LSB */

 MSB */

 LSB */

 MSB */

	/* Sub Vendor ID and Sub Device ID only available in

 LSB */

Turn off BusMaster Clock */

Firmware Reset to 80C15 chip */

Halt State Machine      */

Hard Abort              */

     1 1 0 64 byte per block */

 PCI mode can only xfer 16 bytes */

 DMA command complete   */

 Extended Status Set    */

     0 0 0 Transfer Host -> DMA */

     0 0 1 Transfer DMA  -> Host */

     0 0 Auto Transfer Size   */

     0 1 8 BIT  Transfer Size */

Do not interrupt at end of cmd. */

 SCSI high byte terminator */

Enable/Disable external terminators */

Flush transfer counter */

Always xfer one byte in byte mode */

?? */

 Enable/Disable all Interrupts */

 NARROW/WIDE SCSI config pin */

received Master abort */

Bus Master is forced to get off */

PCI bus master transaction aborted */

PCI Device Time out */

Command aborted */

parity error on data received   */

Slave data overrun */

Bus master transfer command busy */

Extended status is valid */

Global indication of a SCSI int. */

 */

 3.9959ms */

 4.9152ms */

 11.xxxms */

 250.68ms */

 289.99ms */

 Cmp Reg. w/ Data */

 Cmp Reg. w. Reg. */

 Cmp SCSI phs & Branch EQ */

 Cmp SCSI phs & Branch NOT EQ */

 Branch */

 Test condition & branch */

 Match phase and move data */

 Move DReg. to Reg. */

Next Phase */

Non- Tagged Command start */

Command phase */

Data Out/In interrupt */

Data Out */

Disconnect Message */

Status Phase */

Unknown bus action */

Command Completion failure */

New target reselected us. */

Select & Check SCSI ID latch reg */

/* #define GET_XFER_CNT(port, xfercnt) (xfercnt = RD_HARPOON(port+hp_xfercnt_2), \

                                 xfercnt <<= 16,\

                                 xfercnt |= RDW_HARPOON((unsigned short)(port+hp_xfercnt_0)))

/*---------------------------------------------------------------------

 *

 * Function: FlashPoint_ProbeHostAdapter

 *

 * Description: Setup and/or Search for cards and return info to caller.

 *

/* For new Harpoon then check for sub_device ID LSB

   the bits(0-3) must be all ZERO for compatible with

   current version of SCCBMgr, else skip this Harpoon

Must Init the SCSI before attempting */

 Synchronous, 20 mega-transfers/second */

 Synchronous, 10 mega-transfers/second */

 Synchronous, 5 mega-transfers/second */

 Asynchronous */

	/* return with -1 if no sort, else return with

/*---------------------------------------------------------------------

 *

 * Function: FlashPoint_HardwareResetHostAdapter

 *

 * Description: Setup adapter for normal operation (hard reset).

 *

	/* Set global flag to indicate Re-Negotiation to be done on all

/*         if ((pCardInfo->si_per_targ_wide_nego & sync_bit_map) ||

            (id*2+i >= 8)){

 NARROW SCSI */

/*---------------------------------------------------------------------

 *

 * Function: FlashPoint_StartCCB

 *

 * Description: Start a command pointed to by p_Sccb. When the

 *              command is completed it will be returned via the

 *              callback function.

 *

/*---------------------------------------------------------------------

 *

 * Function: FlashPoint_AbortCCB

 *

 * Description: Abort the command pointed to by p_Sccb.  When the

 *              command is completed it will be returned via the

 *              callback function.

 *

/*---------------------------------------------------------------------

 *

 * Function: FlashPoint_InterruptPending

 *

 * Description: Do a quick check to determine if there is a pending

 *              interrupt for this card and disable the IRQ Pin if so.

 *

/*---------------------------------------------------------------------

 *

 * Function: FlashPoint_HandleInterrupt

 *

 * Description: This is our entry point when an interrupt is generated

 *              by the card and the upper level driver passes it on to

 *              us.

 *

				/* Wait for the BusFree before starting a new command.  We

				   must also check for being reselected since the BusFree

				   may not show up if another device reselects us in 1.5us or

				   less.  SRR Wednesday, 3/8/1995.

/*         WRW_HARPOON((ioport+hp_intstat),

            (BUS_FREE | ICMD_COMP | ITAR_DISC | XFER_CNT_0));

			/* Wait for the BusFree before starting a new command.  We

			   must also check for being reselected since the BusFree

			   may not show up if another device reselects us in 1.5us or

			   less.  SRR Wednesday, 3/8/1995.

			/*

			   The additional loop exit condition above detects a timing problem

			   with the revision D/E harpoon chips.  The caller should reset the

			   host adapter to recover when 0xFE is returned.

				/* Harpoon problem some SCSI target device respond to selection

				   with short BUSY pulse (<400ns) this will make the Harpoon is not able

				   to latch the correct Target ID into reg. x53.

				   The work around require to correct this reg. But when write to this

				   reg. (0x53) also increment the FIFO write addr reg (0x6f), thus we

end while */

/*---------------------------------------------------------------------

 *

 * Function: Sccb_bad_isr

 *

 * Description: Some type of interrupt has occurred which is slightly

 *              out of the ordinary.  We will now decode it fully, in

 *              this routine.  This is broken up in an attempt to save

 *              processing time.

 *

/*---------------------------------------------------------------------

 *

 * Function: SccbMgrTableInit

 *

 * Description: Initialize all Sccb manager data structures.

 *

/*---------------------------------------------------------------------

 *

 * Function: SccbMgrTableInit

 *

 * Description: Initialize all Sccb manager data structures.

 *

/*---------------------------------------------------------------------

 *

 * Function: SccbMgrTableInit

 *

 * Description: Initialize all Sccb manager data structures.

 *

/*---------------------------------------------------------------------

 *

 * Function: sfetm

 *

 * Description: Read in a message byte from the SCSI bus, and check

 *              for a parity error.

 *

 force message byte = 0 if Time Out on Req */

/*---------------------------------------------------------------------

 *

 * Function: FPT_ssel

 *

 * Description: Load up automation and select target device.

 *

End non-tagged */

!Use cmd Q Tagged */

else use cmd Q tagged */

if glob tagged started */

 Use by new automation logic */

				/* Fix up the start instruction with a jump to

				/* Setup our STATE so we know what happened when

 auto_loaded */

/*      auto_loaded =  (RD_HARPOON(port+hp_autostart_3) & (unsigned char)0x1F);

/*---------------------------------------------------------------------

 *

 * Function: FPT_sres

 *

 * Description: Hookup the correct CCB and handle the incoming messages.

 *

Release the ACK for ID msg. */

C.A. exists! */

End Q cnt != 0 */

End Tag cmds supported! */

End valid ID message.  */

 End good id message. */

			/* During Abort Tag command, the target could have got re-selected

			   and completed the command. Check the select Q and remove the CCB

/*---------------------------------------------------------------------

 *

 * Function: FPT_sdecm

 *

 * Description: Determine the proper response to the message from the

 *              target device.

 *

 ACK the RESIDUE MSG */

/*---------------------------------------------------------------------

 *

 * Function: FPT_shandem

 *

 * Description: Decide what to do with the extended message.

 *

/*---------------------------------------------------------------------

 *

 * Function: FPT_sisyncn

 *

 * Description: Read in a message byte from the SCSI bus, and check

 *              for a parity error.

 *

/*---------------------------------------------------------------------

 *

 * Function: FPT_stsyncn

 *

 * Description: The has sent us a Sync Nego message so handle it as

 *              necessary.

 *

 Setup our Message to 20mb/s */

 Setup our Message to 10mb/s */

 Setup our Message to 5mb/s */

 Message = Async */

if faster, then set to max. */

 Use 10MB/s */

 Use 6.6MB/s */

 Use 5MB/s */

 Use 4MB/s */

 Use 3.33MB/s */

 Use 2.85MB/s */

 Use 2.5MB/s */

 Use ASYNC */

/*---------------------------------------------------------------------

 *

 * Function: FPT_sisyncr

 *

 * Description: Answer the targets sync message.

 *

/*---------------------------------------------------------------------

 *

 * Function: FPT_siwidn

 *

 * Description: Read in a message byte from the SCSI bus, and check

 *              for a parity error.

 *

/*---------------------------------------------------------------------

 *

 * Function: FPT_stwidn

 *

 * Description: The has sent us a Wide Nego message so handle it as

 *              necessary.

 *

/*---------------------------------------------------------------------

 *

 * Function: FPT_siwidr

 *

 * Description: Answer the targets Wide nego message.

 *

/*---------------------------------------------------------------------

 *

 * Function: FPT_sssyncv

 *

 * Description: Write the desired value to the Sync Register for the

 *              ID specified.

 *

 hp_synctarg_0 */

 hp_synctarg_1 */

 hp_synctarg_2 */

 hp_synctarg_3 */

 hp_synctarg_4 */

 hp_synctarg_5 */

 hp_synctarg_6 */

 hp_synctarg_7 */

 hp_synctarg_8 */

 hp_synctarg_9 */

 hp_synctarg_10 */

 hp_synctarg_11 */

 hp_synctarg_12 */

 hp_synctarg_13 */

 hp_synctarg_14 */

 hp_synctarg_15 */

/*---------------------------------------------------------------------

 *

 * Function: FPT_sresb

 *

 * Description: Reset the desired card's SCSI bus.

 *

/*---------------------------------------------------------------------

 *

 * Function: FPT_ssenss

 *

 * Description: Setup for the Auto Sense command.

 *

Keep LUN. */

/*---------------------------------------------------------------------

 *

 * Function: FPT_sxfrp

 *

 * Description: Transfer data into the bit bucket until the device

 *              decides to switch phase.

 *

	/* If the Automation handled the end of the transfer then do not

 End of While loop for padding data I/O phase */

/*---------------------------------------------------------------------

 *

 * Function: FPT_schkdd

 *

 * Description: Make sure data has been flushed from both FIFOs and abort

 *              the operations if necessary.

 *

/*---------------------------------------------------------------------

 *

 * Function: FPT_sinits

 *

 * Description: Setup SCCB manager fields in this SCCB.

 *

/*      For !single SCSI device in system  & device allow Disconnect

	or command is tag_q type then send Cmd with Disconnect Enable

/*

   if (((!(FPT_BL_Card[p_card].globalFlags & F_SINGLE_DEVICE)) &&

      (currTar_Info->TarStatus & TAR_ALLOW_DISC)) ||

      (currTar_Info->TarStatus & TAG_Q_TRYING)) {

/*

   p_sccb->SccbVirtDataPtr    = 0x00;

   p_sccb->Sccb_forwardlink   = NULL;

   p_sccb->Sccb_backlink      = NULL;

/*---------------------------------------------------------------------

 *

 * Function: Phase Decode

 *

 * Description: Determine the phase and call the appropriate function.

 *

 Call the correct phase func */

/*---------------------------------------------------------------------

 *

 * Function: Data Out Phase

 *

 * Description: Start up both the BusMaster and Xbow.

 *

 Exit if No SCCB record */

/*---------------------------------------------------------------------

 *

 * Function: Data In Phase

 *

 * Description: Startup the BusMaster and the XBOW.

 *

 Exit if No SCCB record */

/*---------------------------------------------------------------------

 *

 * Function: Command Phase

 *

 * Description: Load the CDB into the automation and start it up.

 *

/*---------------------------------------------------------------------

 *

 * Function: Status phase

 *

 * Description: Bring in the status and command complete message bytes

 *

	/* Start-up the automation to finish off this command and let the

	   isr handle the interrupt for command complete when it comes in.

	   We could wait here for the interrupt to be generated?

/*---------------------------------------------------------------------

 *

 * Function: Phase Message Out

 *

 * Description: Send out our message (if we have one) and handle whatever

 *              else is involed.

 *

/*---------------------------------------------------------------------

 *

 * Function: Message In phase

 *

 * Description: Bring in the message and determine what to do with it.

 *

/*---------------------------------------------------------------------

 *

 * Function: Illegal phase

 *

 * Description: Target switched to some illegal phase, so all we can do

 *              is report an error back to the host (if that is possible)

 *              and send an ABORT message to the misbehaving target.

 *

/*---------------------------------------------------------------------

 *

 * Function: Phase Check FIFO

 *

 * Description: Make sure data has been flushed from both FIFOs and abort

 *              the operations if necessary.

 *

End Data In specific code. */

/*---------------------------------------------------------------------

 *

 * Function: Phase Bus Free

 *

 * Description: We just went bus free so figure out if it was

 *              because of command complete or from a disconnect.

 *

			/* Make sure this is not a phony BUS_FREE.  If we were

			   reselected or if BUSY is NOT on then this is a

end if !=null */

/*---------------------------------------------------------------------

 *

 * Function: Auto Load Default Map

 *

 * Description: Load the Automation RAM with the default map values.

 *

ID MESSAGE */

SIMPLE TAG QUEUEING MSG */

RESET ATTENTION */

TAG ID MSG */

CDB BYTE 0 */

CDB BYTE 1 */

CDB BYTE 2 */

CDB BYTE 3 */

CDB BYTE 4 */

CDB BYTE 5 */

CDB BYTE 6 */

CDB BYTE 7 */

CDB BYTE 8 */

CDB BYTE 9 */

CDB BYTE 10 */

CDB BYTE 11 */

JUMP IF DATA OUT */

JUMP IF NO DATA IN FIFO */

This means AYNC DATA IN */

STOP AND INTERRUPT */

JUMP IF NOT DATA IN PHZ */

IF NOT MSG IN CHECK 4 DATA IN */

SAVE DATA PTR MSG? */

GO CHECK FOR DISCONNECT MSG */

SAVE DATA PTRS MSG */

IF NOT MSG IN CHECK DATA IN */

DISCONNECT MSG? */

UKNKNOWN MSG */

XFER DISCONNECT MSG */

STOP AND INTERRUPT */

JUMP IF NOT STATUS PHZ. */

GET STATUS BYTE */

ERROR IF NOT MSG IN PHZ */

CHECK FOR CMD COMPLETE MSG. */

ERROR IF NOT CMD COMPLETE MSG. */

GET CMD COMPLETE MSG */

END OF COMMAND */

RECEIVED UNKNOWN MSG BYTE */

NO COMMAND COMPLETE AFTER STATUS */

BIOS Tickled the Mgr */

EXPECTED ID/TAG MESSAGES AND */

 DIDN'T GET ONE */

 comp SCSI SEL ID & AR3 */

SEL ID OK then Conti. */

NO COMMAND COMPLETE AFTER STATUS */

/*---------------------------------------------------------------------

 *

 * Function: Auto Command Complete

 *

 * Description: Post command back to host and find another command

 *              to execute.

 *

/*---------------------------------------------------------------------

 *

 * Function: Data Transfer Processor

 *

 * Description: This routine performs two tasks.

 *              (1) Start data transfer by calling HOST_DATA_XFER_START

 *              function.  Once data transfer is started, (2) Depends

 *              on the type of data transfer mode Scatter/Gather mode

 *              or NON Scatter/Gather mode.  In NON Scatter/Gather mode,

 *              this routine checks Sccb_MGRFlag (F_HOST_XFER_ACT bit) for

 *              data transfer done.  In Scatter/Gather mode, this routine

 *              checks bus master command complete and dual rank busy

 *              bit to keep chaining SC transfer command.  Similarly,

 *              in Scatter/Gather mode, it checks Sccb_MGRFlag

 *              (F_HOST_XFER_ACT bit) for data transfer done.

 *              

/*---------------------------------------------------------------------

 *

 * Function: BusMaster Scatter Gather Data Transfer Start

 *

 * Description:

 *

End While */

/*---------------------------------------------------------------------

 *

 * Function: BusMaster Data Transfer Start

 *

 * Description: 

 *

/*---------------------------------------------------------------------

 *

 * Function: BusMaster Timeout Handler

 *

 * Description: This function is called after a bus master command busy time

 *               out is detected.  This routines issue halt state machine

 *               with a software time out for command busy.  If command busy

 *               is still asserted at the end of the time out, it issues

 *               hard abort with another software time out.  It hard abort

 *               command busy is also time out, it'll just give up.

 *

Clear command complete */

/*---------------------------------------------------------------------

 *

 * Function: Host Data Transfer Abort

 *

 * Description: Abort any in progress transfer.

 *

/*---------------------------------------------------------------------

 *

 * Function: Host Data Transfer Restart

 *

 * Description: Reset the available count due to a restore data

 *              pointers message.

 *

Index by long words into sg list. */

Running count of SG xfer counts. */

/*---------------------------------------------------------------------

 *

 * Function: FPT_scini

 *

 * Description: Setup all data structures necessary for SCAM selection.

 *

 check if reset bus in AutoSCSI parameter set */

	/* Force to wait 1 sec after SCSI bus reset. Some SCAM device FW

	/* if (p_power_up)

	   FPT_Wait1Second(p_port);

	   else

/*

   for (i=0,k=0; i < MAX_SCSI_TAR; i++)

      {

      if ((FPT_scamInfo[i].state == ID_ASSIGNED) ||

         (FPT_scamInfo[i].state == LEGACY))

         k++;

      }



   if (k==2)

      currCard->globalFlags |= F_SINGLE_DEVICE;

   else

      currCard->globalFlags &= ~F_SINGLE_DEVICE;

/*---------------------------------------------------------------------

 *

 * Function: FPT_scarb

 *

 * Description: Gain control of the bus and wait SCAM select time (250ms)

 *

/*---------------------------------------------------------------------

 *

 * Function: FPT_scbusf

 *

 * Description: Release the SCSI bus and disable SCAM selection.

 *

/*---------------------------------------------------------------------

 *

 * Function: FPT_scasid

 *

 * Description: Assign an ID to all the SCAM devices.

 *

Not the last ID yet. */

Count number of zeros in DB0-3. */

Not the last ID yet. */

End while */

/*---------------------------------------------------------------------

 *

 * Function: FPT_scsel

 *

 * Description: Select all the SCAM devices.

 *

/*---------------------------------------------------------------------

 *

 * Function: FPT_scxferc

 *

 * Description: Handshake the p_data (DB4-0) across the bus.

 *

Start with DB7 & DB5 asserted. */

Wait for DB7 to be released. */

Wait for DB5 to be released. */

Release data bits */

Wait for DB6 to be released. */

/*---------------------------------------------------------------------

 *

 * Function: FPT_scsendi

 *

 * Description: Transfer our Identification string to determine if we

 *              will be the dominant master.

 *

End of isolation stage, we won! */

End of isolation stage, we lost. */

bit loop */

byte loop */

We lost */

We WON! Yeeessss! */

/*---------------------------------------------------------------------

 *

 * Function: FPT_sciso

 *

 * Description: Transfer the Identification string.

 *

/*

				if(bit_cnt != 0 || bit_cnt != 8)

				{

					byte_cnt = 0;

					bit_cnt = 0;

					FPT_scxferc(p_port, SYNC_PTRN);

					FPT_scxferc(p_port, ASSIGN_ID);

					continue;

				}

bit loop */

byte loop */

/*---------------------------------------------------------------------

 *

 * Function: FPT_scwirod

 *

 * Description: Sample the SCSI data bus making sure the signal has been

 *              deasserted for the correct number of consecutive samples.

 *

/*---------------------------------------------------------------------

 *

 * Function: FPT_scwiros

 *

 * Description: Sample the SCSI Signal lines making sure the signal has been

 *              deasserted for the correct number of consecutive samples.

 *

/*---------------------------------------------------------------------

 *

 * Function: FPT_scvalq

 *

 * Description: Make sure we received a valid data byte.

 *

/*---------------------------------------------------------------------

 *

 * Function: FPT_scsell

 *

 * Description: Select the specified device ID using a selection timeout

 *              less than 4ms.  If somebody responds then it is a legacy

 *              drive and this ID must be marked as such.

 *

No legacy device */

Found one of them oldies! */

/*---------------------------------------------------------------------

 *

 * Function: FPT_scwtsel

 *

 * Description: Wait to be selected by another SCAM initiator.

 *

/*---------------------------------------------------------------------

 *

 * Function: FPT_inisci

 *

 * Description: Setup the data Structure with the info from the EEPROM.

 *

Default to unused ID. */

Default to unassigned ID. */

Default to unused ID. */

Default to unassigned ID. */

/*---------------------------------------------------------------------

 *

 * Function: FPT_scmachid

 *

 * Description: Match the Device ID string with our values stored in

 *              the EEPROM.

 *

/*---------------------------------------------------------------------

 *

 * Function: FPT_scsavdi

 *

 * Description: Save off the device SCAM ID strings.

 *

 Enable write access to the EEPROM */

 Turn off write access */

/*---------------------------------------------------------------------

 *

 * Function: FPT_XbowInit

 *

 * Description: Setup the Xbow for normal operation.

 *

  Clear any signals we might */

	/* Turn on SCSI_MODE8 for narrow cards to fix the

/*---------------------------------------------------------------------

 *

 * Function: FPT_BusMasterInit

 *

 * Description: Initialize the BusMaster for normal operations.

 *

Clear interrupts. */

/*---------------------------------------------------------------------

 *

 * Function: FPT_DiagEEPROM

 *

 * Description: Verfiy checksum and 'Key' and initialize the EEPROM if

 *              necessary.

 *

EEPROM is Okay so return now! */

PRODUCT ID */

 FlashPoint LT   */

Vendor ID code */

 BUSLOGIC      */

Vendor unique code */

 BT- 930           */

Serial #          */

 01234567         */

/*---------------------------------------------------------------------

 *

 * Function: Queue Search Select

 *

 * Description: Try to find a new command to execute.

 *

/*---------------------------------------------------------------------

 *

 * Function: Queue Select Fail

 *

 * Description: Add the current SCCB to the head of the Queue.

 *

/*---------------------------------------------------------------------

 *

 * Function: Queue Command Complete

 *

 * Description: Call the callback function with the current SCCB.

 *

/*---------------------------------------------------------------------

 *

 * Function: Queue Disconnect

 *

 * Description: Add SCCB to our disconnect array.

 *

/*---------------------------------------------------------------------

 *

 * Function: Queue Flush SCCB

 *

 * Description: Flush all SCCB's back to the host driver for this target.

 *

/*---------------------------------------------------------------------

 *

 * Function: Queue Flush Target SCCB

 *

 * Description: Flush all SCCB's back to the host driver for this target.

 *

/*---------------------------------------------------------------------

 *

 * Function: Queue Find SCCB

 *

 * Description: Search the target select Queue for this SCCB, and

 *              remove it if found.

 *

/*---------------------------------------------------------------------

 *

 * Function: Utility Update Residual Count

 *

 * Description: Update the XferCnt to the remaining byte count.

 *              If we transferred all the data then just write zero.

 *              If Non-SG transfer then report Total Cnt - Actual Transfer

 *              Cnt.  For SG transfers add the count fields of all

 *              remaining SG elements, as well as any partial remaining

 *              element.

 *

/*---------------------------------------------------------------------

 *

 * Function: Wait 1 Second

 *

 * Description: Wait for 1 second.

 *

/*---------------------------------------------------------------------

 *

 * Function: FPT_Wait

 *

 * Description: Wait the desired delay.

 *

/*---------------------------------------------------------------------

 *

 * Function: Enable/Disable Write to EEPROM

 *

 * Description: The EEPROM must first be enabled for writes

 *              A total of 9 clocks are needed.

 *

Turn off CS */

Turn off Master Select */

/*---------------------------------------------------------------------

 *

 * Function: Write EEPROM

 *

 * Description: Write a word to the EEPROM at the specified

 *              address.

 *

 Clock  data! */

 Set CS to EEPROM */

 Turn off CS */

 Turn off Master Select */

/*---------------------------------------------------------------------

 *

 * Function: Read EEPROM

 *

 * Description: Read a word from the EEPROM at the desired

 *              address.

 *

/*---------------------------------------------------------------------

 *

 * Function: Read EEPROM Original 

 *

 * Description: Read a word from the EEPROM at the desired

 *              address.

 *

 Clock  data! */

Turn off CS */

Turn off Master Select */

/*---------------------------------------------------------------------

 *

 * Function: Send EE command and Address to the EEPROM

 *

 * Description: Transfers the correct command and sends the address

 *              to the eeprom.

 *

 Set CS to EEPROM */

 Clock  data! */

 Clock  data! */

/*

  The following inline definitions avoid type conflicts.

 !CONFIG_SCSI_FLASHPOINT */

/*

  Define prototypes for the FlashPoint SCCB Manager Functions.

 CONFIG_SCSI_FLASHPOINT */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2009, Microsoft Corporation.

 *

 * Authors:

 *   Haiyang Zhang <haiyangz@microsoft.com>

 *   Hank Janssen  <hjanssen@microsoft.com>

 *   K. Y. Srinivasan <kys@microsoft.com>

/*

 * All wire protocol details (storage protocol between the guest and the host)

 * are consolidated here.

 *

 * Begin protocol definitions.

/*

 * Version history:

 * V1 Beta: 0.1

 * V1 RC < 2008/1/31: 1.0

 * V1 RC > 2008/1/31:  2.0

 * Win7: 4.2

 * Win8: 5.1

 * Win8.1: 6.0

 * Win10: 6.2

  Packet structure describing virtual storage requests. */

/*

 * WWN packet for Fibre Channel HBA

/*

 * SRB Flag Bits

/*

 * This flag indicates the request is part of the workflow for processing a D3.

/*

 * Platform neutral description of a scsi request -

 * this remains the same across the write regardless of 32/64 bit

 * note: it's patterned off the SCSI_PASS_THROUGH structure

/*

 * Sense buffer size changed in win8; have a run-time

 * variable to track the size we should use.  This value will

 * likely change during protocol negotiation but it is valid

 * to start by assuming pre-Win8.

/*

 * The storage protocol version is determined during the

 * initial exchange with the host.  It will indicate which

 * storage functionality is available in the host.

	/*

	 * The following were added in Windows 8

	/*

	 * The following was added in win8.

/*

 * The list of storage protocols in order of preference.

/*

 * This structure is sent during the initialization phase to get the different

 * properties of the channel.

  This structure is sent during the storage protocol negotiations. */

 Major (MSW) and minor (LSW) version numbers. */

	/*

	 * Revision number is auto-incremented whenever this file is changed

	 * (See FILL_VMSTOR_REVISION macro above).  Mismatch does not

	 * definitely indicate incompatibility--but it does indicate mismatched

	 * builds.

	 * This is only used on the windows side. Just set it to 0.

 Channel Property Flags */

 Requested operation type */

  Flags - see below for values */

 Status of the request returned from the server side. */

 Data payload area */

		/*

		 * Structure used to forward SCSI commands from the

		 * client to the server.

 Structure used to query channel properties. */

 Used during version negotiations. */

 Fibre channel address packet */

 Number of sub-channels to create */

 This will be the maximum of the union members */

/*

 * Packet Flags:

 *

 * This flag indicates that the server should send back a completion for this

 * packet.

 Matches Windows-end */

/*

 * SRB status codes and masks; a subset of the codes used here.

/*

 * This is the end of Protocol specific defines.

/*

 * Timeout in seconds for all devices managed by this driver.

/*

 * Upper bound on the size of a storvsc packet. vmscsi_size_delta is not

 * included in the calculation because it is set after STORVSC_MAX_PKT_SIZE

 * is used in storvsc_connect_to_vsp

 Synchronize the request/response if needed */

 A storvsc device is a device object that contains a vmbus channel */

	/*

	 * Each unique Port/Path/Target represents 1 channel ie scsi

	 * controller. In reality, the pathid, targetid is always 0

	 * and the port is set by us

	/*

	 * The size of the vmscsi_request has changed in win8. The

	 * additional size is because of new elements added to the

	 * structure. These elements are valid only when we are talking

	 * to a win8 host.

	 * Track the correction to size we need to apply. This value

	 * will likely change during protocol negotiation but it is

	 * valid to start by assuming pre-Win8.

	/*

	 * Max I/O, the device can support.

	/*

	 * Number of sub-channels we will open.

	/*

	 * Mask of CPUs bound to subchannels.

	/*

	 * Serializes modifications of stor_chns[] from storvsc_do_io()

	 * and storvsc_change_target_cpu().

 Used for vsc/vsp channel reset process */

	/*

	 * Currently active port and node names for FC devices.

	/*

	 * Before scanning the host, first check to see if any of the

	 * currrently known devices have been hot removed. We issue a

	 * "unit ready" command against all currently known devices.

	 * This I/O will result in an error for devices that have been

	 * removed. As part of handling the I/O error, we remove the device.

	 *

	 * When a LUN is added or removed, the host sends us a signal to

	 * scan the host. Thus we are forced to discover the LUNs that

	 * may have been removed this way.

	/*

	 * Now scan the host to discover LUNs that may have been added.

/*

 * We can get incoming messages from the host that are not in response to

 * messages that we have sent out. An example of this would be messages

 * received by the guest to notify dynamic addition/removal of LUNs. To

 * deal with potential race conditions where the driver may be in the

 * midst of being unloaded when we might receive an unsolicited message

 * from the host, we have implemented a mechanism to gurantee sequential

 * consistency:

 *

 * 1) Once the device is marked as being destroyed, we will fail all

 *    outgoing messages.

 * 2) We permit incoming messages when the device is being destroyed,

 *    only to properly account for messages already sent out.

	/*

	 * If the device is being destroyed; allow incoming

	 * traffic only to cleanup outstanding requests.

 See storvsc_do_io() -> get_og_chn(). */

	/*

	 * Determines if the storvsc device has other channels assigned to

	 * the "old" CPU to update the alloced_cpus mask and the stor_chns

	 * array.

 "Flush" the stor_chns array. */

	/*

	 * Cannot return an ID of 0, which is reserved for an unsolicited

	 * message from Hyper-V.

 In case vmbus_open() fails, we don't use the sub-channel. */

 Add the sub-channel to the array of available channels. */

	/*

	 * If the number of CPUs is artificially restricted, such as

	 * with maxcpus=1 on the kernel boot line, Hyper-V could offer

	 * sub-channels >= the number of CPUs. These sub-channels

	 * should not be created. The primary channel is already created

	 * and assigned to one CPU, so check against # CPUs - 1.

	/*

	 * Establish a handler for dealing with subchannels.

	/*

	 * Request the host to create sub-channels.

	/*

	 * We need to do nothing here, because vmbus_process_offer()

	 * invokes channel->sc_creation_callback, which will open and use

	 * the sub-channel(s).

	/*

	 * Cache the currently active port and node ww names.

	/*

	 * Now, initiate the vsc/vsp initialization protocol on the open

	 * channel

	/*

	 * Query host supported protocol version.

 reuse the packet for version range supported */

		/*

		 * The revision number is only used in Windows; set it to 0.

	/*

	 * Check to see if multi-channel support is there.

	 * Hosts that implement protocol version of 5.1 and above

	 * support multi-channel.

	/*

	 * Allocate state to manage the sub-channels.

	 * We allocate an array based on the numbers of possible CPUs

	 * (Hyper-V does not support cpu online/offline).

	 * This Array will be sparseley populated with unique

	 * channels - primary + sub-channels.

	 * We will however populate all the slots to evenly distribute

	 * the load.

	/*

	 * For FC devices retrieve FC HBA data.

	/*

	 * Cache the currently active port and node ww names.

	/*

	 * In some situations, Hyper-V sets multiple bits in the

	 * srb_status, such as ABORTED and ERROR. So process them

	 * individually, with the most specific bits first.

 Capacity data has changed */

			/*

			 * Retry the I/O that triggered this.

		/*

		 * Let upper layer deal with error when

		 * sense message is present.

		/*

		 * If there is an error; offline the device since all

		 * error recovery strategies would have already been

		 * deployed on the host side. However, if the command

		 * were a pass-through command deal with it appropriately.

		/*

		 * On some Hyper-V hosts TEST_UNIT_READY command can

		 * return SRB_STATUS_ERROR. Let the upper level code

		 * deal with it based on the sense information.

	/*

	 * We need to schedule work to process this error; schedule it.

		/*

		 * The Windows driver set data_transfer_length on

		 * SRB_STATUS_DATA_OVERRUN. On other errors, this value

		 * is untouched.  In these cases we set it to 0.

 Validate data_transfer_length (from Hyper-V) */

	/*

	 * The current SCSI handling on the host side does

	 * not correctly handle:

	 * INQUIRY command with page code parameter set to 0x80

	 * MODE_SENSE command with cmd[2] == 0x1c

	 *

	 * Setup srb and scsi status so this won't be fatal.

	 * We do this so we can distinguish truly fatal failues

	 * (srb status == 0x4) and off-line the device in that case.

 Copy over the status...etc */

	/*

	 * Copy over the sense_info_length, but limit to the known max

	 * size if Hyper-V returns a bad value.

		/*

		 * Log TEST_UNIT_READY errors only as warnings. Hyper-V can

		 * return errors when detecting devices using TEST_UNIT_READY,

		 * and logging these as errors produces unhelpful noise.

 Hyper-V can send an unsolicited message with ID of 0 */

				/*

				 * storvsc_on_receive() looks at the vstor_packet in the message

				 * from the ring buffer.

				 *

				 * - If the operation in the vstor_packet is COMPLETE_IO, then

				 *   we call storvsc_on_io_completion(), and dereference the

				 *   guest memory address.  Make sure we don't call

				 *   storvsc_on_io_completion() with a guest memory address

				 *   that is zero if Hyper-V were to construct and send such

				 *   a bogus packet.

				 *

				 * - If the operation in the vstor_packet is FCHBA_DATA, then

				 *   we call cache_wwn(), and access the data payload area of

				 *   the packet (wwn_packet); however, there is no guarantee

				 *   that the packet is big enough to contain such area.

				 *   Future-proof the code by rejecting such a bogus packet.

 Transaction 'rqst_id' corresponds to tag 'rqst_id - 1' */

 Make sure flag is set before waiting */

	/*

	 * At this point, all outbound traffic should be disable. We

	 * only allow inbound traffic (responses) to proceed so that

	 * outstanding requests can be completed.

	/*

	 * Since we have already drained, we don't need to busy wait

	 * as was done in final_release_stor_device()

	 * Note that we cannot set the ext pointer to NULL until

	 * we have drained - to drain the outgoing packets, we need to

	 * allow incoming packets.

 Close the channel */

	/*

	 * Our channel array is sparsley populated and we

	 * initiated I/O on a processor/hw-q that does not

	 * currently have a designated channel. Fix this.

	 * The strategy is simple:

	 * I. Ensure NUMA locality

	 * II. Distribute evenly (best effort)

	/*

	 * Select an appropriate channel to send the request out.

 See storvsc_change_target_cpu(). */

			/*

			 * Ideally, we want to pick a different channel if

			 * available on the same NUMA node.

			/*

			 * All the other channels on the same NUMA node are

			 * busy. Try to use the channel on the current CPU

			/*

			 * If we reach here, all the channels on the current

			 * NUMA node are busy. Try to find a channel in

			 * other NUMA nodes

	/*

	 * Set blist flag to permit the reading of the VPD pages even when

	 * the target may claim SPC-2 compliance. MSFT targets currently

	 * claim SPC-2 compliance while they implement post SPC-2 features.

	 * With this flag we can correctly handle WRITE_SAME_16 issues.

	 *

	 * Hypervisor reports SCSI_UNKNOWN type for DVD ROM device but

	 * still supports REPORT LUN.

	/*

	 * If the host is WIN8 or WIN8 R2, claim conformance to SPC-3

	 * if the device is a MSFT virtual device.  If the host is

	 * WIN10 or newer, allow write_same.

	/*

	 * We are making up these values; let us keep it simple.

 Sectors per track */

	/*

	 * At this point, all outstanding requests in the adapter

	 * should have been flushed out and return to us

	 * There is a potential race here where the host may be in

	 * the process of responding when we return from here.

	 * Just wait for all in-transit packets to be accounted for

	 * before we return from here.

/*

 * The host guarantees to respond to each command, although I/O latencies might

 * be unbounded on Azure.  Reset the timer unconditionally to give the host a

 * chance to perform EH.

 the host does not handle WRITE_SAME, log accident usage */

	/*

	 * smartd sends this command and the host does not handle

	 * this. So, don't send it.

		/*

		 * On legacy hosts filter unimplemented commands.

		 * Future hosts are expected to correctly handle

		 * unsupported commands. Furthermore, it is

		 * possible that some of the currently

		 * unsupported commands maybe supported in

		 * future versions of the host.

 Setup the cmd request */

 Build the SRB */

		/*

		 * This is DMA_BIDIRECTIONAL or something else we are never

		 * supposed to see here.

			/*

			 * Init values for the current sgl entry. hvpgoff

			 * and hvpfns_to_add are in units of Hyper-V size

			 * pages. Handling the PAGE_SIZE != HV_HYP_PAGE_SIZE

			 * case also handles values of sgl->offset that are

			 * larger than PAGE_SIZE. Such offsets are handled

			 * even on other than the first sgl entry, provided

			 * they are a multiple of PAGE_SIZE.

			/*

			 * Fill the next portion of the PFN array with

			 * sequential Hyper-V PFNs for the continguous physical

			 * memory described by the sgl entry. The end of the

			 * last sgl should be reached at the same time that

			 * the PFN array is filled.

 Invokes the vsc to start an IO */

 no more space */

 Ensure there are no gaps in presented sgls */

 SCSI guid */

 IDE guid */

 Fibre Channel GUID */

	/*

	 * Based on the windows host we are running on,

	 * set state to properly communicate with the host.

		/*

		 * On Windows8 and above, we support sub-channels for storage

		 * on SCSI and FC controllers.

		 * The number of sub-channels offerred is based on the number of

		 * VCPUs in the guest.

 max cmd length */

	/*

	 * set the table size based on the info we got

	 * from the host.

	/*

	 * For non-IDE disks, the host supports multiple channels.

	 * Set the number of HW queues we are supporting.

	/*

	 * Set the error handler work queue.

 Register the HBA and start the scsi bus scan */

	/*

	 * Once we have connected with the host, we would need to

	 * to invoke storvsc_dev_remove() to rollback this state and

	 * this call also frees up the stor_device; hence the jump around

	 * err_out1 label.

 Change a scsi target's queue depth */

	/*

	 * Divide the ring buffer data size (which is 1 page less

	 * than the ring buffer size since that page is reserved for

	 * the ring buffer indices) by the max request size (which is

	 * vmbus_channel_packet_multipage_buffer + struct vstor_packet + u64)

	 *

	 * The computation underestimates max_outstanding_req_per_channel

	 * for Win7 and older hosts because it does not take into account

	 * the vmscsi_size_delta correction to the max request size.

 SPDX-License-Identifier: GPL-2.0

/*

 * NCR 5380 generic driver routines.  These should make it *trivial*

 * to implement 5380 SCSI drivers under Linux with a non-trantor

 * architecture.

 *

 * Note that these routines also work with NR53c400 family chips.

 *

 * Copyright 1993, Drew Eckhardt

 * Visionary Computing

 * (Unix and Linux consulting and custom programming)

 * drew@colorado.edu

 * +1 (303) 666-5836

 *

 * For more information, please consult

 *

 * NCR 5380 Family

 * SCSI Protocol Controller

 * Databook

 *

 * NCR Microelectronics

 * 1635 Aeroplaza Drive

 * Colorado Springs, CO 80916

 * 1+ (719) 578-3400

 * 1+ (800) 334-5454

/*

 * With contributions from Ray Van Tassle, Ingmar Baumgart,

 * Ronald van Cuijlenborg, Alan Cox and others.

 Ported to Atari by Roman Hodek and others. */

 Adapted for the Sun 3 by Sam Creasey. */

/*

 * Design

 *

 * This is a generic 5380 driver.  To use it on a different platform,

 * one simply writes appropriate system specific macros (ie, data

 * transfer - some PC's will use the I/O bus, 68K's must use

 * memory mapped) and drops this file in their 'C' wrapper.

 *

 * As far as command queueing, two queues are maintained for

 * each 5380 in the system - commands that haven't been issued yet,

 * and commands that are currently executing.  This means that an

 * unlimited number of commands may be queued, letting

 * more commands propagate from the higher driver levels giving higher

 * throughput.  Note that both I_T_L and I_T_L_Q nexuses are supported,

 * allowing multiple commands to propagate all the way to a SCSI-II device

 * while a command is already executing.

 *

 *

 * Issues specific to the NCR5380 :

 *

 * When used in a PIO or pseudo-dma mode, the NCR5380 is a braindead

 * piece of hardware that requires you to sit in a loop polling for

 * the REQ signal as long as you are connected.  Some devices are

 * brain dead (ie, many TEXEL CD ROM drives) and won't disconnect

 * while doing long seek operations. [...] These

 * broken devices are the exception rather than the rule and I'd rather

 * spend my time optimizing for the normal case.

 *

 * Architecture :

 *

 * At the heart of the design is a coroutine, NCR5380_main,

 * which is started from a workqueue for each NCR5380 host in the

 * system.  It attempts to establish I_T_L or I_T_L_Q nexuses by

 * removing the commands from the issue queue and calling

 * NCR5380_select() if a nexus is not established.

 *

 * Once a nexus is established, the NCR5380_information_transfer()

 * phase goes through the various phases as instructed by the target.

 * if the target goes into MSG IN and sends a DISCONNECT message,

 * the command structure is placed into the per instance disconnected

 * queue, and NCR5380_main tries to find more work.  If the target is

 * idle for too long, the system will try to sleep.

 *

 * If a command has disconnected, eventually an interrupt will trigger,

 * calling NCR5380_intr()  which will in turn call NCR5380_reselect

 * to reestablish a nexus.  This will run main if necessary.

 *

 * On command termination, the done function will be called as

 * appropriate.

 *

 * SCSI pointers are maintained in the SCp field of SCSI command

 * structures, being initialized after the command is connected

 * in NCR5380_select, and set as appropriate in NCR5380_information_transfer.

 * Note that in violation of the standard, an implicit SAVE POINTERS operation

 * is done, since some BROKEN disks fail to issue an explicit SAVE POINTERS.

/*

 * Using this file :

 * This file a skeleton Linux SCSI driver for the NCR 5380 series

 * of chips.  To use it, you write an architecture specific functions

 * and macros and include this file in your driver.

 *

 * These macros MUST be defined :

 *

 * NCR5380_read(register)  - read from the specified register

 *

 * NCR5380_write(register, value) - write to the specific register

 *

 * NCR5380_implementation_fields  - additional fields needed for this

 * specific implementation of the NCR5380

 *

 * Either real DMA *or* pseudo DMA may be implemented

 *

 * NCR5380_dma_xfer_len   - determine size of DMA/PDMA transfer

 * NCR5380_dma_send_setup - execute DMA/PDMA from memory to 5380

 * NCR5380_dma_recv_setup - execute DMA/PDMA from 5380 to memory

 * NCR5380_dma_residual   - residual byte count

 *

 * The generic driver is initialized by calling NCR5380_init(instance),

 * after setting the appropriate host specific fields and ID.

/**

 * initialize_SCp - init the scsi pointer field

 * @cmd: command block to set up

 *

 * Set up the internal fields in the SCSI command.

	/*

	 * Initialize the Scsi Pointer field so that all of the commands in the

	 * various queues are valid.

/**

 * NCR5380_poll_politely2 - wait for two chip register values

 * @hostdata: host private data

 * @reg1: 5380 register to poll

 * @bit1: Bitmask to check

 * @val1: Expected value

 * @reg2: Second 5380 register to poll

 * @bit2: Second bitmask to check

 * @val2: Second expected value

 * @wait: Time-out in jiffies, 0 if sleeping is not allowed

 *

 * Polls the chip in a reasonably efficient manner waiting for an

 * event to occur. After a short quick poll we begin to yield the CPU

 * (if possible). In irq contexts the time-out is arbitrarily limited.

 * Callers may hold locks as long as they are held in irq mode.

 *

 * Returns 0 if either or both event(s) occurred otherwise -ETIMEDOUT.

 Repeatedly sleep for 1 ms until deadline */

/**

 * NCR5380_print - print scsi bus signals

 * @instance: adapter state to dump

 *

 * Print the SCSI bus signals for debugging purposes

/**

 * NCR5380_print_phase - show SCSI phase

 * @instance: adapter to dump

 *

 * Print the current SCSI phase for debugging purposes

/**

 * NCR5380_info - report driver and host information

 * @instance: relevant scsi host instance

 *

 * For use as the host template info() handler.

/**

 * NCR5380_init - initialise an NCR5380

 * @instance: adapter to configure

 * @flags: control flags

 *

 * Initializes *instance and corresponding 5380 chip,

 * with flags OR'd into the initial flags value.

 *

 * Notes : I assume that the host, hostno, and id bits have been

 * set correctly. I don't care about the irq and other fields.

 *

 * Returns 0 for success

 Calibrate register polling loop */

/**

 * NCR5380_maybe_reset_bus - Detect and correct bus wedge problems.

 * @instance: adapter to check

 *

 * If the system crashed, it may have crashed with a connected target and

 * the SCSI bus busy. Check for BUS FREE phase. If not, try to abort the

 * currently established nexus, which we know nothing about. Failing that

 * do a bus reset.

 *

 * Note that a bus reset will cause the chip to assert IRQ.

 *

 * Returns 0 if successful, otherwise -ENXIO.

			/* Wait after a reset; the SCSI standard calls for

			 * 250ms, we wait 500ms to be on the safe side.

			 * But some Toshiba CD-ROMs need ten times that.

/**

 * NCR5380_exit - remove an NCR5380

 * @instance: adapter to remove

 *

 * Assumes that no more work can be queued (e.g. by NCR5380_intr).

/**

 * complete_cmd - finish processing a command and return it to the SCSI ML

 * @instance: the host instance

 * @cmd: command to complete

 Autosense processing ends here */

/**

 * NCR5380_queue_command - queue a command

 * @instance: the relevant SCSI adapter

 * @cmd: SCSI command

 *

 * cmd is added to the per-instance issue queue, with minor

 * twiddling done to the host specific fields of cmd.  If the

 * main coroutine is not running, it is restarted.

 (NDEBUG & NDEBUG_NO_WRITE) */

	/*

	 * Insert the cmd into the issue queue. Note that REQUEST SENSE

	 * commands are added to the head of the queue since any command will

	 * clear the contingent allegiance condition that exists and the

	 * sense data is only guaranteed to be valid while the condition exists.

 Kick off command processing */

 Caller does the locking needed to set & test these data atomically */

/**

 * dequeue_next_cmd - dequeue a command for processing

 * @instance: the scsi host instance

 *

 * Priority is given to commands on the autosense queue. These commands

 * need autosense because of a CHECK CONDITION result.

 *

 * Returns a command pointer if a command is found for a target that is

 * not already busy. Otherwise returns NULL.

 Autosense processing begins here */

/**

 * NCR5380_main - NCR state machines

 *

 * NCR5380_main is a coroutine that runs as long as more work can

 * be done on the NCR5380 host adapters in a system.  Both

 * NCR5380_queue_command() and NCR5380_intr() will try to start it

 * in case it is not running.

			/*

			 * Attempt to establish an I_T_L nexus here.

			 * On success, instance->hostdata->connected is set.

			 * On failure, we must add the command back to the

			 * issue queue so we can keep trying.

			/*

			 * REQUEST SENSE commands are issued without tagged

			 * queueing, even on SCSI-II devices because the

			 * contingent allegiance condition exists for the

			 * entire unit.

/*

 * NCR5380_dma_complete - finish DMA transfer

 * @instance: the scsi host instance

 *

 * Called by the interrupt handler when DMA finishes or a phase

 * mismatch occurs (which would end the DMA transfer).

/**

 * NCR5380_intr - generic NCR5380 irq handler

 * @irq: interrupt number

 * @dev_id: device info

 *

 * Handle interrupts, reestablishing I_T_L or I_T_L_Q nexuses

 * from the disconnected queue, and restarting NCR5380_main()

 * as required.

 *

 * The chip can assert IRQ in any of six different conditions. The IRQ flag

 * is then cleared by reading the Reset Parity/Interrupt Register (RPIR).

 * Three of these six conditions are latched in the Bus and Status Register:

 * - End of DMA (cleared by ending DMA Mode)

 * - Parity error (cleared by reading RPIR)

 * - Loss of BSY (cleared by reading RPIR)

 * Two conditions have flag bits that are not latched:

 * - Bus phase mismatch (non-maskable in DMA Mode, cleared by ending DMA Mode)

 * - Bus reset (non-maskable)

 * The remaining condition has no flag bit at all:

 * - Selection/reselection

 *

 * Hence, establishing the cause(s) of any interrupt is partly guesswork.

 * In "The DP8490 and DP5380 Comparison Guide", National Semiconductor

 * claimed that "the design of the [DP8490] interrupt logic ensures

 * interrupts will not be lost (they can be on the DP5380)."

 * The L5380/53C80 datasheet from LOGIC Devices has more details.

 *

 * Checking for bus reset by reading RST is futile because of interrupt

 * latency, but a bus reset will reset chip logic. Checking for parity error

 * is unnecessary because that interrupt is never enabled. A Loss of BSY

 * condition will clear DMA Mode. We can tell when this occurs because the

 * the Busy Monitor interrupt is enabled together with DMA Mode.

			/* Probably End of DMA, Phase Mismatch or Loss of BSY.

			 * We ack IRQ after clearing Mode Register. Workarounds

			 * for End of DMA errata need to happen in DMA Mode.

 Probably reselected */

 Probably Bus Reset */

 Certainly Bus Reset */

/**

 * NCR5380_select - attempt arbitration and selection for a given command

 * @instance: the Scsi_Host instance

 * @cmd: the scsi_cmnd to execute

 *

 * This routine establishes an I_T_L nexus for a SCSI command. This involves

 * ARBITRATION, SELECTION and MESSAGE OUT phases and an IDENTIFY message.

 *

 * Returns true if the operation should be retried.

 * Returns false if it should not be retried.

 *

 * Side effects :

 * If bus busy, arbitration failed, etc, NCR5380_select() will exit

 * with registers as they should have been on entry - ie

 * SELECT_ENABLE will be set appropriately, the NCR5380

 * will cease to drive any SCSI bus signals.

 *

 * If successful : the I_T_L nexus will be established, and

 * hostdata->connected will be set to cmd.

 * SELECT interrupt will be disabled.

 *

 * If failed (no target) : scsi_done() will be called, and the

 * cmd->result host byte set to DID_BAD_TARGET.

	/*

	 * Arbitration and selection phases are slow and involve dropping the

	 * lock, so we have to watch out for EH. An exception handler may

	 * change 'selecting' to NULL. This function will then return false

	 * so that the caller will forget about 'cmd'. (During information

	 * transfer phases, EH may change 'connected' to NULL.)

	/*

	 * Set the phase bits to 0, otherwise the NCR5380 won't drive the

	 * data bus during SELECTION.

	/*

	 * Start arbitration.

	/* The chip now waits for BUS FREE phase. Then after the 800 ns

	 * Bus Free Delay, arbitration will begin.

 Reselection interrupt */

 Command was aborted */

 The SCSI-2 arbitration delay is 2.4 us */

 Check for lost arbitration */

	/* After/during arbitration, BSY should be asserted.

	 * IBM DPES-31080 Version S31Q works now

	 * Tnx to Thomas_Roesch@m2.maus.de for finding this! (Roman)

	/*

	 * Again, bus clear + bus settle time is 1.2us, however, this is

	 * a minimum so we'll udelay ceil(1.2)

 NCR5380_reselect() clears MODE_REG after a reselection interrupt */

	/*

	 * Now that we have won arbitration, start Selection process, asserting

	 * the host and target ID's on the SCSI bus.

	/*

	 * Raise ATN while SEL is true before BSY goes false from arbitration,

	 * since this is the only way to guarantee that we'll get a MESSAGE OUT

	 * phase immediately after selection.

	/*

	 * Reselect interrupts must be turned off prior to the dropping of BSY,

	 * otherwise we will trigger an interrupt.

	/*

	 * The initiator shall then wait at least two deskew delays and release

	 * the BSY signal.

 wingel -- wait two bus deskew delay >2*45ns */

 Reset BSY */

	/*

	 * Something weird happens when we cease to drive BSY - looks

	 * like the board/chip is letting us do another read before the

	 * appropriate propagation delay has expired, and we're confusing

	 * a BSY signal from ourselves as the target's response to SELECTION.

	 *

	 * A small delay (the 'C++' frontend breaks the pipeline with an

	 * unnecessary jump, making it work on my 386-33/Trantor T128, the

	 * tighter 'C' code breaks and requires this) solves the problem -

	 * the 1 us delay is arbitrary, and only used because this delay will

	 * be the same on other platforms and since it works here, it should

	 * work there.

	 *

	 * wingel suggests that this could be due to failing to wait

	 * one deskew delay.

	/*

	 * The SCSI specification calls for a 250 ms timeout for the actual

	 * selection.

 Can't touch cmd if it has been reclaimed by the scsi ML */

	/*

	 * No less than two deskew delays after the initiator detects the

	 * BSY signal is true, it shall release the SEL signal and may

	 * change the DATA BUS.                                     -wingel

	/*

	 * Since we followed the SCSI spec, and raised ATN while SEL

	 * was true but before BSY was false during selection, the information

	 * transfer phase should be a MESSAGE OUT phase so that we can send the

	 * IDENTIFY message.

 Wait for start of REQ/ACK handshake */

/*

 * Function : int NCR5380_transfer_pio (struct Scsi_Host *instance,

 * unsigned char *phase, int *count, unsigned char **data)

 *

 * Purpose : transfers data in given phase using polled I/O

 *

 * Inputs : instance - instance of driver, *phase - pointer to

 * what phase is expected, *count - pointer to number of

 * bytes to transfer, **data - pointer to data pointer,

 * can_sleep - 1 or 0 when sleeping is permitted or not, respectively.

 *

 * Returns : -1 when different phase is entered without transferring

 * maximum number of bytes, 0 if all bytes are transferred or exit

 * is in same phase.

 *

 * Also, *phase, *count, *data are modified in place.

 *

 * XXX Note : handling for bus free may be useful.

/*

 * Note : this code is not as quick as it could be, however it

 * IS 100% reliable, and for the actual data transfer where speed

 * counts, we will always do a pseudo DMA or DMA transfer.

	/*

	 * The NCR5380 chip will only drive the SCSI bus when the

	 * phase specified in the appropriate bits of the TARGET COMMAND

	 * REGISTER match the STATUS REGISTER

		/*

		 * Wait for assertion of REQ, after which the phase bits will be

		 * valid

 Check for phase mismatch */

 Do actual transfer from SCSI bus to / from memory */

		/*

		 * The SCSI standard suggests that in MSGOUT phase, the initiator

		 * should drop ATN on the last byte of the message phase

		 * after REQ has been asserted for the handshake but before

		 * the initiator raises ACK.

/*

 * We have several special cases to consider during REQ/ACK handshaking :

 * 1.  We were in MSGOUT phase, and we are on the last byte of the

 * message.  ATN must be dropped as ACK is dropped.

 *

 * 2.  We are in a MSGIN phase, and we are on the last byte of the

 * message.  We must exit with ACK asserted, so that the calling

 * code may raise ATN before dropping ACK to reject the message.

 *

 * 3.  ACK and ATN are clear and the target may proceed as normal.

	/* The phase read from the bus is valid if either REQ is (already)

	 * asserted or if ACK hasn't been released yet. The latter applies if

	 * we're in MSG IN, DATA IN or STATUS and all bytes have been received.

/**

 * do_reset - issue a reset command

 * @instance: adapter to reset

 *

 * Issue a reset sequence to the NCR5380 and try and get the bus

 * back into sane shape.

 *

 * This clears the reset interrupt flag because there may be no handler for

 * it. When the driver is initialized, the NCR5380_intr() handler has not yet

 * been installed. And when in EH we may have released the ST DMA interrupt.

/**

 * do_abort - abort the currently established nexus by going to

 * MESSAGE OUT phase and sending an ABORT message.

 * @instance: relevant scsi host instance

 * @can_sleep: 1 or 0 when sleeping is permitted or not, respectively

 *

 * Returns 0 on success, negative error code on failure.

 Request message out phase */

	/*

	 * Wait for the target to indicate a valid phase by asserting

	 * REQ.  Once this happens, we'll have either a MSGOUT phase

	 * and can immediately send the ABORT message, or we'll have some

	 * other phase and will have to source/sink data.

	 *

	 * We really don't care what value was on the bus or what value

	 * the target sees, so we just handshake.

	/*

	 * If we got here, and the command completed successfully,

	 * we're about to go into bus free state.

/*

 * Function : int NCR5380_transfer_dma (struct Scsi_Host *instance,

 * unsigned char *phase, int *count, unsigned char **data)

 *

 * Purpose : transfers data in given phase using either real

 * or pseudo DMA.

 *

 * Inputs : instance - instance of driver, *phase - pointer to

 * what phase is expected, *count - pointer to number of

 * bytes to transfer, **data - pointer to data pointer.

 *

 * Returns : -1 when different phase is entered without transferring

 * maximum number of bytes, 0 if all bytes or transferred or exit

 * is in same phase.

 *

 * Also, *phase, *count, *data are modified in place.

 send start chain */

		/* On the Medusa, it is a must to initialize the DMA before

		 * starting the NCR. This is also the cleaner way for the TT.

	/*

	 * On the PAS16 at least I/O recovery delays are not needed here.

	 * Everyone else seems to want them.

		/* On the Falcon, the DMA setup must be done after the last

		 * NCR access, else the DMA setup gets trashed!

 On failure, NCR5380_dma_xxxx_setup() returns a negative int. */

 For real DMA, result is the byte count. DMA interrupt is expected. */

 The result is zero iff pseudo DMA send/receive was completed. */

/*

 * A note regarding the DMA errata workarounds for early NMOS silicon.

 *

 * For DMA sends, we want to wait until the last byte has been

 * transferred out over the bus before we turn off DMA mode.  Alas, there

 * seems to be no terribly good way of doing this on a 5380 under all

 * conditions.  For non-scatter-gather operations, we can wait until REQ

 * and ACK both go false, or until a phase mismatch occurs.  Gather-sends

 * are nastier, since the device will be expecting more data than we

 * are prepared to send it, and REQ will remain asserted.  On a 53C8[01] we

 * could test Last Byte Sent to assure transfer (I imagine this is precisely

 * why this signal was added to the newer chips) but on the older 538[01]

 * this signal does not exist.  The workaround for this lack is a watchdog;

 * we bail out of the wait-loop after a modest amount of wait-time if

 * the usual exit conditions are not met.  Not a terribly clean or

 * correct solution :-%

 *

 * DMA receive is equally tricky due to a nasty characteristic of the NCR5380.

 * If the chip is in DMA receive mode, it will respond to a target's

 * REQ by latching the SCSI data into the INPUT DATA register and asserting

 * ACK, even if it has _already_ been notified by the DMA controller that

 * the current DMA transfer has completed!  If the NCR5380 is then taken

 * out of DMA mode, this already-acknowledged byte is lost. This is

 * not a problem for "one DMA transfer per READ command", because

 * the situation will never arise... either all of the data is DMA'ed

 * properly, or the target switches to MESSAGE IN phase to signal a

 * disconnection (either operation bringing the DMA to a clean halt).

 * However, in order to handle scatter-receive, we must work around the

 * problem.  The chosen fix is to DMA fewer bytes, then check for the

 * condition before taking the NCR5380 out of DMA mode.  One or two extra

 * bytes are transferred via PIO as necessary to fill out the original

 * request.

			/*

			 * The workaround was to transfer fewer bytes than we

			 * intended to with the pseudo-DMA read function, wait for

			 * the chip to latch the last byte, read it, and then disable

			 * pseudo-DMA mode.

			 *

			 * After REQ is asserted, the NCR5380 asserts DRQ and ACK.

			 * REQ is deasserted when ACK is asserted, and not reasserted

			 * until ACK goes false.  Since the NCR5380 won't lower ACK

			 * until DACK is asserted, which won't happen unless we twiddle

			 * the DMA port or we take the NCR5380 out of DMA mode, we

			 * can guarantee that we won't handshake another extra

			 * byte.

			/*

			 * Wait for the last byte to be sent.  If REQ is being asserted for

			 * the byte we're interested, we'll ACK it and it will go false.

/*

 * Function : NCR5380_information_transfer (struct Scsi_Host *instance)

 *

 * Purpose : run through the various SCSI phases and do as the target

 * directs us to.  Operates on the currently connected command,

 * instance->connected.

 *

 * Inputs : instance, instance for which we are doing commands

 *

 * Side effects : SCSI things happen, the disconnected queue will be

 * modified if a command disconnects, *instance->connected will

 * change.

 *

 * XXX Note : we need to watch for bus free or a reset condition here

 * to recover from an unexpected bus free condition.

 We only have a valid SCSI phase when REQ is asserted */

 CONFIG_SUN3 */

				/*

				 * If there is no room left in the current buffer in the

				 * scatter-gather list, move onto the next one.

				/*

				 * The preferred transfer method is going to be

				 * PSEUDO-DMA for systems that are strictly PIO,

				 * since we can let the hardware do the handshaking.

				 *

				 * For this to work, we need to know the transfersize

				 * ahead of time, since the pseudo-DMA code will sit

				 * in an unconditional loop.

						/*

						 * If the watchdog timer fires, all future

						 * accesses to this device will use the

						 * polled-IO.

					/* Transfer a small chunk so that the

					 * irq mode lock is not held too long.

 Accept message by clearing ACK */

					/*

					 * Restore phase bits to 0 so an interrupted selection,

					 * arbitration can resume.

 Accept message by clearing ACK */

 Accept message by clearing ACK */

					/*

					 * Restore phase bits to 0 so an interrupted selection,

					 * arbitration can resume.

					/*

					 * The SCSI data pointer is *IMPLICITLY* saved on a disconnect

					 * operation, in violation of the SCSI spec so we can safely

					 * ignore SAVE/RESTORE pointers calls.

					 *

					 * Unfortunately, some disks violate the SCSI spec and

					 * don't issue the required SAVE_POINTERS message before

					 * disconnecting, and we have to break spec to remain

					 * compatible.

 Accept message by clearing ACK */

					/*

					 * Start the message buffer with the EXTENDED_MESSAGE

					 * byte, since spi_print_msg() wants the whole thing.

 Accept first byte by clearing ACK */

 Accept third byte by clearing ACK */

 Reject message */

					/*

					 * If we get something weird that we aren't expecting,

					 * log it.

 switch (tmp) */

				/*

				 * XXX for performance reasons, on machines with a

				 * PSEUDO-DMA architecture we should probably

				 * use the dma transfer function.

 switch(phase) */

/*

 * Function : void NCR5380_reselect (struct Scsi_Host *instance)

 *

 * Purpose : does reselection, initializing the instance->connected

 * field to point to the scsi_cmnd for which the I_T_L or I_T_L_Q

 * nexus has been reestablished,

 *

 * Inputs : instance - this instance of the NCR5380.

	/*

	 * Disable arbitration, etc. since the host adapter obviously

	 * lost, and tell an interrupted NCR5380_select() to restart.

	/*

	 * At this point, we have detected that our SCSI ID is on the bus,

	 * SEL is true and BSY was false for at least one bus settle delay

	 * (400 ns).

	 *

	 * We must assert BSY ourselves, until the target drops the SEL

	 * signal.

	/*

	 * Wait for target to go into MSGIN.

 BUS FREE phase */

 acknowledge toggle to MSGIN */

 peek at the byte without really hitting the bus */

 CONFIG_SUN3 */

	/*

	 * We need to add code for SCSI-II to track which devices have

	 * I_T_L_Q nexuses established, and which have simple I_T_L

	 * nexuses so we can chose to do additional data transfer.

	/*

	 * Find the command corresponding to the I_T_L or I_T_L_Q  nexus we

	 * just reestablished, and remove it from the disconnected queue.

		/*

		 * Since we have an established nexus that we can't do anything

		 * with, we must abort it.

 CONFIG_SUN3 */

 Accept message by clearing ACK */

/**

 * list_find_cmd - test for presence of a command in a linked list

 * @haystack: list of commands

 * @needle: command to search for

/**

 * list_remove_cmd - remove a command from linked list

 * @haystack: list of commands

 * @needle: command to remove

/**

 * NCR5380_abort - scsi host eh_abort_handler() method

 * @cmd: the command to be aborted

 *

 * Try to abort a given command by removing it from queues and/or sending

 * the target an abort message. This may not succeed in causing a target

 * to abort the command. Nonetheless, the low-level driver must forget about

 * the command because the mid-layer reclaims it and it may be re-issued.

 *

 * The normal path taken by a command is as follows. For EH we trace this

 * same path to locate and abort the command.

 *

 * unissued -> selecting -> [unissued -> selecting ->]... connected ->

 * [disconnected -> connected ->]...

 * [autosense -> connected ->] done

 *

 * If cmd was not found at all then presumably it has already been completed,

 * in which case return SUCCESS to try to avoid further EH measures.

 *

 * If the command has not completed yet, we must not fail to find it.

 * We have no option but to forget the aborted command (even if it still

 * lacks sense data). The mid-layer may re-issue a command that is in error

 * recovery (see scsi_send_eh_cmnd), but the logic and data structures in

 * this driver are such that a command can appear on one queue only.

 *

 * The lock protects driver data structures, but EH handlers also use it

 * to serialize their own execution and prevent their own re-entry.

 No tag or busy flag to worry about */

		/* Can't call NCR5380_select() and send ABORT because that

		 * means releasing the lock. Need a bus reset.

 reset NCR registers */

	/* After the reset, there are no more connected or disconnected commands

	 * and no busy units; so clear the low-level status here to avoid

	 * conflicts when the mid-level code tries to wake up the affected

	 * commands!

/**

 * NCR5380_host_reset - reset the SCSI host

 * @cmd: SCSI command undergoing EH

 *

 * Returns SUCCESS

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * advansys.c - Linux Host Driver for AdvanSys SCSI Adapters

 *

 * Copyright (c) 1995-2000 Advanced System Products, Inc.

 * Copyright (c) 2000-2001 ConnectCom Solutions, Inc.

 * Copyright (c) 2007 Matthew Wilcox <matthew@wil.cx>

 * Copyright (c) 2014 Hannes Reinecke <hare@suse.de>

 * All Rights Reserved.

/*

 * As of March 8, 2000 Advanced System Products, Inc. (AdvanSys)

 * changed its name to ConnectCom Solutions, Inc.

 * On June 18, 2001 Initio Corp. acquired ConnectCom's SCSI assets

 AdvanSys Driver Version */

/* FIXME:

 *

 *  1. Use scsi_transport_spi

 *  2. advansys_info is not safe against multiple simultaneous callers

 *  3. Add module_param to override ISA/VLB ioport array

 Enable driver /proc statistics. */

 Enable driver tracing. */

 port address size  */

/*

 * Narrow boards only support 12-byte commands, while wide boards

 * extend to 16-byte commands.

/*

 * Warning code values are set in ASC_DVC_VAR  'warn_code'.

/*

 * Error code values are set in {ASC/ADV}_DVC_VAR  'err_code'.

 No more carrier memory */

 micro code check sum error */

 start/stop chip failed */

 Illegal cable connection */

 SE device on DIFF bus */

 Narrow flat cable reversed */

 set SCSI ID failed */

 HVD device on LVD port */

 signature not found */

 BIST pre-test error */

 BIST RAM test error */

 Invalid chip_type setting */

/* The narrow chip only supports a limited selection of transfer rates.

 * These are encoded in the range 0..7 or 0..15 depending whether the chip

 * is Ultra-capable or not.  These tables let us convert from one to the other.

 Forward Declaration. */

/*

 * These macros keep the chip SCSI id  bitfields in board order. C bitfields

 * aren't portable between big and little-endian platforms so they are not used.

 low order 4 bits is chip scsi id */

 high order 4 bits is isa dma speed */

 Virtual memory address size */

/*

 * Define Adv Library required memory access macros.

/*

 * Define total number of simultaneous maximum element scatter-gather

 * request blocks per wide adapter. ASC_DEF_MAX_HOST_QNG (253) is the

 * maximum number of outstanding commands per wide host adapter. Each

 * command uses one or more ADV_SG_BLOCK each with 15 scatter-gather

 * elements. Allow each command to have at least one ADV_SG_BLOCK structure.

 * This allows about 15 commands to have the maximum 17 ADV_SG_BLOCK

 * structures or 255 scatter-gather elements.

/*

 * Define maximum number of scatter-gather elements per request.

 location of OEM name */

 EEPROM Bit 15 */

 EEPROM Bit 14 */

/*

 * For the ASC3550 Bit 13 is Termination Polarity control bit.

 * For later ICs Bit 13 controls whether the CIS (Card Information

 * Service Section) is loaded from EEPROM.

 EEPROM Bit 13 */

 EEPROM Bit 13 */

/*

 * ASC38C1600 Bit 11

 *

 * If EEPROM Bit 11 is 0 for Function 0, then Function 0 will specify

 * INT A in the PCI Configuration Space Int Pin field. If it is 1, then

 * Function 0 will specify INT B.

 *

 * If EEPROM Bit 11 is 0 for Function 1, then Function 1 will specify

 * INT B in the PCI Configuration Space Int Pin field. If it is 1, then

 * Function 1 will specify INT A.

 EEPROM Bit 11 */

 Word Offset, Description */

 00 power up initialization */

  bit 13 set - Term Polarity Control */

  bit 14 set - BIOS Enable */

  bit 15 set - Big Endian Mode */

 01 unused      */

 02 disconnect enable */

 03 Wide DTR able */

 04 Synchronous DTR able */

 05 send start up motor */

 06 tag queuing able */

 07 BIOS device control */

 08 no scam */

 09 Host Adapter ID */

    power up wait */

 10 reset delay */

    first boot device scsi id & lun */

    high nibble is lun */

    low nibble is scsi id */

 11 0 - automatic */

    1 - low off / high off */

    2 - low off / high on */

    3 - low on  / high on */

    There is no low on  / high off */

    reserved byte (not used) */

 12 BIOS control bits */

  bit 0  BIOS don't act as initiator. */

  bit 1  BIOS > 1 GB support */

  bit 2  BIOS > 2 Disk Support */

  bit 3  BIOS don't support removables */

  bit 4  BIOS support bootable CD */

  bit 5  BIOS scan enabled */

  bit 6  BIOS support multiple LUNs */

  bit 7  BIOS display of message */

  bit 8  SCAM disabled */

  bit 9  Reset SCSI bus during init. */

  bit 10 */

  bit 11 No verbose initialization. */

  bit 12 SCSI parity enabled */

  bit 13 */

  bit 14 */

  bit 15 */

 13 ULTRA speed able */

 14 reserved */

 15 maximum host queuing */

    maximum per device queuing */

 16 control bit for driver */

 17 control bit for bug fix */

 18 Board serial number word 1 */

 19 Board serial number word 2 */

 20 Board serial number word 3 */

 21 EEP check sum */

 22 OEM name */

 30 last device driver error code */

 31 last uc and Adv Lib error code */

 32 last uc error address */

 33 saved last dev. driver error code   */

 34 saved last uc and Adv Lib error code */

 35 saved last uc error address         */

 36 number of error */

 Word Offset, Description */

 00 power up initialization */

  bit 13 set - Load CIS */

  bit 14 set - BIOS Enable */

  bit 15 set - Big Endian Mode */

 01 unused      */

 02 disconnect enable */

 03 Wide DTR able */

 04 SDTR Speed TID 0-3 */

 05 send start up motor */

 06 tag queuing able */

 07 BIOS device control */

 08 no scam */

 09 Host Adapter ID */

    power up wait */

 10 reset delay */

    first boot device scsi id & lun */

    high nibble is lun */

    low nibble is scsi id */

 11 0 - automatic */

    1 - low off / high off */

    2 - low off / high on */

    3 - low on  / high on */

    There is no low on  / high off */

 11 0 - automatic */

    1 - low off / high off */

    2 - low off / high on */

    3 - low on  / high on */

    There is no low on  / high off */

 12 BIOS control bits */

  bit 0  BIOS don't act as initiator. */

  bit 1  BIOS > 1 GB support */

  bit 2  BIOS > 2 Disk Support */

  bit 3  BIOS don't support removables */

  bit 4  BIOS support bootable CD */

  bit 5  BIOS scan enabled */

  bit 6  BIOS support multiple LUNs */

  bit 7  BIOS display of message */

  bit 8  SCAM disabled */

  bit 9  Reset SCSI bus during init. */

  bit 10 */

  bit 11 No verbose initialization. */

  bit 12 SCSI parity enabled */

  bit 13 */

  bit 14 */

  bit 15 */

 13 SDTR speed TID 4-7 */

 14 SDTR speed TID 8-11 */

 15 maximum host queueing */

    maximum per device queuing */

 16 control bit for driver */

 17 SDTR speed 4 TID 12-15 */

 18 Board serial number word 1 */

 19 Board serial number word 2 */

 20 Board serial number word 3 */

 21 EEP check sum */

 22 OEM name */

 30 last device driver error code */

 31 last uc and Adv Lib error code */

 32 last uc error address */

 33 saved last dev. driver error code   */

 34 saved last uc and Adv Lib error code */

 35 saved last uc error address         */

 36 reserved */

 37 reserved */

 38 reserved */

 39 reserved */

 40 reserved */

 41 reserved */

 42 reserved */

 43 reserved */

 44 reserved */

 45 reserved */

 46 reserved */

 47 reserved */

 48 reserved */

 49 reserved */

 50 reserved */

 51 reserved */

 52 reserved */

 53 reserved */

 54 reserved */

 55 reserved */

 56 CIS PTR LSW */

 57 CIS PTR MSW */

 58 SubSystem Vendor ID */

 59 SubSystem ID */

 60 reserved */

 61 reserved */

 62 reserved */

 63 reserved */

 Word Offset, Description */

 00 power up initialization */

  bit 11 set - Func. 0 INTB, Func. 1 INTA */

       clear - Func. 0 INTA, Func. 1 INTB */

  bit 13 set - Load CIS */

  bit 14 set - BIOS Enable */

  bit 15 set - Big Endian Mode */

 01 unused */

 02 disconnect enable */

 03 Wide DTR able */

 04 SDTR Speed TID 0-3 */

 05 send start up motor */

 06 tag queuing able */

 07 BIOS device control */

 08 no scam */

 09 Host Adapter ID */

    power up wait */

 10 reset delay */

    first boot device scsi id & lun */

    high nibble is lun */

    low nibble is scsi id */

 11 0 - automatic */

    1 - low off / high off */

    2 - low off / high on */

    3 - low on  / high on */

    There is no low on  / high off */

 11 0 - automatic */

    1 - low off / high off */

    2 - low off / high on */

    3 - low on  / high on */

    There is no low on  / high off */

 12 BIOS control bits */

  bit 0  BIOS don't act as initiator. */

  bit 1  BIOS > 1 GB support */

  bit 2  BIOS > 2 Disk Support */

  bit 3  BIOS don't support removables */

  bit 4  BIOS support bootable CD */

  bit 5  BIOS scan enabled */

  bit 6  BIOS support multiple LUNs */

  bit 7  BIOS display of message */

  bit 8  SCAM disabled */

  bit 9  Reset SCSI bus during init. */

  bit 10 Basic Integrity Checking disabled */

  bit 11 No verbose initialization. */

  bit 12 SCSI parity enabled */

  bit 13 AIPP (Asyn. Info. Ph. Prot.) dis. */

  bit 14 */

  bit 15 */

 13 SDTR speed TID 4-7 */

 14 SDTR speed TID 8-11 */

 15 maximum host queueing */

    maximum per device queuing */

 16 control bit for driver */

 17 SDTR speed 4 TID 12-15 */

 18 Board serial number word 1 */

 19 Board serial number word 2 */

 20 Board serial number word 3 */

 21 EEP check sum */

 22 OEM name */

 30 last device driver error code */

 31 last uc and Adv Lib error code */

 32 last uc error address */

 33 saved last dev. driver error code   */

 34 saved last uc and Adv Lib error code */

 35 saved last uc error address         */

 36 reserved */

 37 reserved */

 38 reserved */

 39 reserved */

 40 reserved */

 41 reserved */

 42 reserved */

 43 reserved */

 44 reserved */

 45 reserved */

 46 reserved */

 47 reserved */

 48 reserved */

 49 reserved */

 50 reserved */

 51 reserved */

 52 reserved */

 53 reserved */

 54 reserved */

 55 reserved */

 56 CIS PTR LSW */

 57 CIS PTR MSW */

 58 SubSystem Vendor ID */

 59 SubSystem ID */

 60 reserved */

 61 reserved */

 62 reserved */

 63 reserved */

/*

 * EEPROM Commands

 bios_ctrl */

 8 KB Internal Memory */

 16 KB Internal Memory */

/*

 * XXX - Since ASC38C1600 Rev.3 has a local RAM failure issue, there is

 * a special 16K Adv Library and Microcode version. After the issue is

 * resolved, should restore 32K support.

 *

 * #define ADV_38C1600_MEMSIZE  0x8000L   * 32 KB Internal Memory *

 16 KB Internal Memory */

/*

 * Byte I/O register address from base of 'iop_base'.

/*

 * Word I/O register address from base of 'iop_base'.

 CID0  */

 CC    */

 LA    */

 LD    */

 CSR   */

 CFG0  */

 CFG1  */

 SM    */

 FA    */

 EC    */

 ED    */

 SFC   */

 QB    */

 QP    */

 IX    */

 SP    */

 PC    */

 SD    */

 SDH   */

 SC    */

 HCFG  */

 SXS   */

 SXL   */

 SXH   */

 RFD   */

/*

 * Doubleword I/O register address from base of 'iop_base'.

/*

 * SCSI_CFG0 Register bit definitions

 Watchdog, Second, and Select. Timer Ctrl. */

 Enable SCSI Parity Error detection */

 Select Even Parity */

 Watchdog Interval, 1: 57 min, 0: 13 sec */

 Queue Size, 1: 128 byte, 0: 64 byte */

 Primitive SCSI mode */

 Enable SCAM selection */

 Sel/Resel Timeout, 1: 400 ms, 0: 1.6 ms */

 SCAM id sel. confirm., 1: fast, 0: 6.4 ms */

 Enable OUR_ID bits */

 SCSI ID */

/*

 * SCSI_CFG1 Register bit definitions

 Enable Big Endian Mode MIO:15, EEP:15 */

 Terminator Polarity Ctrl. MIO:13, EEP:13 */

 SCSI output buffer slew rate */

 Filter Period Selection */

 Input Filtering Disabled */

 Input Filtering 11ns to 20ns */

 Input Filtering 21ns to 39ns */

 Disable Active Negation */

 SCSI differential Mode (Read-Only) */

 1: No SE cables, 0: SE cable (Read-Only) */

 Enable TERM_CTL_H and TERM_CTL_L */

 External SCSI Termination Bits */

 Enable External SCSI Upper Termination */

 Enable External SCSI Lower Termination */

 External SCSI Cable Connection Status */

/*

 * Addendum for ASC-38C0800 Chip

 *

 * The ASC-38C1600 Chip uses the same definitions except that the

 * bus mode override bits [12:10] have been moved to byte register

 * offset 0xE (IOPB_SOFT_OVER_WR) bits [12:10]. The [12:10] bits in

 * SCSI_CFG1 are read-only and always available. Bit 14 (DIS_TERM_DRV)

 * is not needed. The [12:10] bits in IOPB_SOFT_OVER_WR are write-only.

 * Also each ASC-38C1600 function or channel uses only cable bits [5:4]

 * and [1:0]. Bits [14], [7:6], [3:2] are unused.

 1: Read c_det[3:0], 0: cannot read */

 Device Detect Bits */

 HVD Device Detect */

 LVD Device Detect */

 SE Device Detect */

 LVD Termination Bits */

 Enable LVD Upper Termination */

 Enable LVD Lower Termination */

 SE Termination Bits */

 Enable SE Upper Termination */

 Enable SE Lower Termination */

 LVD Cable Detect Bits */

 Cable Detect for LVD External Wide */

 Cable Detect for LVD Internal Wide */

 SE Cable Detect Bits */

 Cable Detect for SE Internal Wide */

 Cable Detect for SE Internal Narrow */

 x 0 0 0  | on  on | Illegal (all 3 connectors are used) */

 0 x 0 0  | on  on | Illegal (all 3 connectors are used) */

/*

 * MEM_CFG Register bit definitions

 BIOS Enable MIO:14,EEP:14 */

 Diagnostic Bit */

 Specify size of RAM to RISC */

 2 KB */

 4 KB */

 8 KB */

 16 KB */

 32 KB */

 64 KB */

/*

 * DMA_CFG0 Register bit definitions

 *

 * This register is only accessible to the host.

 PCI DMA Start Conditions */

 PCI DMA FIFO Threshold */

 16 bytes */

 32 bytes */

 48 bytes */

 64 bytes */

 80 bytes (default) */

 96 bytes */

 112 bytes */

 DMA start conditions */

 Wait threshold level (default) */

 Wait SDMA/SBUS idle */

 Wait threshold and SDMA/SBUS idle */

 Wait SDMA FIFO empty/full */

 Memory Read Method */

 Memory Read */

 Memory Read Long */

 Memory Read Multiple (default) */

/*

 * ASC-38C0800 RAM BIST Register bit definitions

/*

 * ASC38C1600 Definitions

 *

 * IOPB_PCI_INT_CFG Bit Field Definitions

 Value loaded from EEPROM Bit 11. */

/*

 * Bit 1 can be set to change the interrupt for the Function to operate in

 * Totem Pole mode. By default Bit 1 is 0 and the interrupt operates in

 * Open Drain mode. Both functions of the ASC38C1600 must be set to the same

 * mode, otherwise the operating mode is undefined.

/*

 * Bit 0 can be used to change the Int Pin for the Function. The value is

 * 0 by default for both Functions with Function 0 using INT A and Function

 * B using INT B. For Function 0 if set, INT B is used. For Function 1 if set,

 * INT A is used.

 *

 * EEPROM Word 0 Bit 11 for each Function may change the initial Int Pin

 * value specified in the PCI Configuration Space.

/*

 * Adv Library Status Definitions

/*

 * ADV_DVC_VAR 'warn_code' values

 SCSI Bus Reset error */

 EEP check sum error */

 EEP termination bad field */

 ADV_ERROR return */

 max. target identifier */

 max. logical unit number */

/*

 * Fixed locations of microcode operating variables.

 microcode start address */

 microcode end address */

 microcode code checksum */

 microcode version */

 microcode number */

 BIOS RISC Memory Start */

 BIOS RISC Memory Length */

 BIOS Signature 0x55AA */

 BIOS Version (2 bytes) */

 SDTR Speed for TID 0-3 */

 SDTR Speed for TID 4-7 */

 SDTR Speed for TID 8-11 */

 SDTR Speed for TID 12-15 */

 Microcode control flag. */

 CAM mode TID bitmask. */

/*

 * BIOS LRAM variable absolute offsets.

/*

 * Microcode Control Flags

 *

 * Flags set by the Adv Library in RISC variable 'control_flag' (0x122)

 * and handled by the microcode.

 Ignore DMA Parity Errors */

 Enabled AIPP checking. */

/*

 * ASC_MC_DEVICE_HSHK_CFG_TABLE microcode table or HSHK_CFG register format

 Max. number of host commands (253) */

 Min. number of host commands (16) */

 Max. number commands per device (63) */

 Min. number commands per device (4) */

 Require ASC_QC_DATA_OUT set or clear. */

 Data out DMA transfer. */

 Send auto-start motor before request. */

 Don't report overrun. */

 Freeze TID queue after request. XXX TBD */

 Don't allow disconnect for request. */

 Don't allow tag queuing for request. */

 Don't use Synch. transfer on request. */

 Don't use Wide transfer on request. */

 Renegotiate WDTR/SDTR before request. */

/*

 * Note: If a Tag Message is to be sent and neither ASC_QSC_HEAD_TAG or

 * ASC_QSC_ORDERED_TAG is set, then a Simple Tag Message (0x20) is used.

 Use Head Tag Message (0x21). */

 Use Ordered Tag Message (0x22). */

/*

 * All fields here are accessed by the board microcode and need to be

 * little-endian.

 Carrier Virtual Address */

 Carrier Physical Address */

 ADV_SCSI_REQ_Q Virtual or Physical Address */

	/*

	 * next_vpa [31:4]            Carrier Virtual or Physical Next Pointer

	 *

	 * next_vpa [3:1]             Reserved Bits

	 * next_vpa [0]               Done Flag set in Response Queue.

/*

 * Mask used to eliminate low 4 bits of carrier 'next_vpa' field.

/*

 * Each carrier is 64 bytes, and we need three additional

 * carrier for icq, irq, and the termination carrier.

 Ultra-Wide IC */

 Ultra2-Wide/LVD IC */

 Ultra3-Wide/LVD2 IC */

/*

 * Adapter temporary configuration structure

 *

 * This structure can be discarded after initialization. Don't add

 * fields here needed after initialization.

 *

 * Field naming convention:

 *

 *  *_enable indicates the field enables or disables a feature. The

 *  value of the field is never reset.

 enable disconnection */

 chip version */

 Term. Ctrl. bits 6-5 of SCSI_CFG1 register */

 Microcode Control Flag */

 Microcode date */

 Microcode version */

 EEPROM serial number word 1 */

 EEPROM serial number word 2 */

 EEPROM serial number word 3 */

 Valid entries in block. */

 Pointer to next sg block. */

 SG element address. */

 SG element count. */

/*

 * ADV_SCSI_REQ_Q - microcode request structure

 *

 * All fields in this structure up to byte 60 are used by the microcode.

 * The microcode makes assumptions about the size and ordering of fields

 * in this structure. Do not change the structure definition here without

 * coordinating the change with the microcode.

 *

 * All fields accessed by microcode must be maintained in little_endian

 * order.

 Ucode flags and state (ASC_MC_QC_*). */

 Device target identifier. */

 Device target logical unit number. */

 Data buffer physical address. */

 Data count. Ucode sets to residual. */

 SCSI CDB length. Must <= 16 bytes. */

 Completion status. */

 SCSI status byte. */

 Ucode host status. */

 SCSI CDB bytes 0-11. */

 SG list physical address. */

 SCSI CDB bytes 12-15. */

	/*

	 * End of microcode structure - 60 bytes. The rest of the structure

	 * is used by the Adv Library and ignored by the microcode.

 SG list virtual address. */

/*

 * The following two structures are used to process Wide Board requests.

 *

 * The ADV_SCSI_REQ_Q structure in adv_req_t is passed to the Adv Library

 * and microcode with the ADV_SCSI_REQ_Q field 'srb_tag' set to the

 * SCSI request tag. The adv_req_t structure 'cmndp' field in turn points

 * to the Mid-Level SCSI request structure.

 *

 * Zero or more ADV_SG_BLOCK are used with each ADV_SCSI_REQ_Q. Each

 * ADV_SG_BLOCK structure holds 15 scatter-gather elements. Under Linux

 * up to 255 scatter-gather elements may be used per request or

 * ADV_SCSI_REQ_Q.

 *

 * Both structures must be 32 byte aligned.

 Sgblock structure. */

 Physical address */

 Next scatter-gather structure. */

 Adv Library request structure. */

 Request structure padding. */

 Mid-Level SCSI command pointer. */

 Adv Library scatter-gather pointer. */

/*

 * Adapter operation variable structure.

 *

 * One structure is required per host adapter.

 *

 * Field naming convention:

 *

 *  *_able indicates both whether a feature should be enabled or disabled

 *  and whether a device is capable of the feature. At initialization

 *  this field may be set, but later if a device is found to be incapable

 *  of the feature, the field is cleared.

 I/O port address */

 fatal error code */

 BIOS control word, EEPROM word 12 */

 try WDTR for a device */

 try SDTR for a device */

 try SDTR Ultra speed for a device */

 EEPROM SDTR Speed for TID 0-3   */

 EEPROM SDTR Speed for TID 4-7   */

 EEPROM SDTR Speed for TID 8-11  */

 EEPROM SDTR Speed for TID 12-15 */

 try tagged queuing with a device */

 PPR message capable per TID bitmask. */

 maximum number of tagged commands per device */

 start motor command allowed */

 delay in seconds after scsi bus reset */

 should be assigned by caller */

 maximum number of Q'ed command allowed */

 scam_tolerant of EEPROM */

 driver pointer to private structure */

 chip SCSI target ID */

 Carrier free list. */

 Initiator command queue stopper pointer. */

 Initiator response queue stopper pointer. */

 Count of pending carriers. */

	/*

	 * Note: The following fields will not be used after initialization. The

	 * driver may discard the buffer after initialization is done.

 temporary configuration structure  */

/*

 * Microcode idle loop commands

 Assert SCSI Bus Reset */

 Deassert SCSI Bus Reset */

/*

 * AdvSendIdleCmd() flag definitions.

/*

 * Wait loop time out values.

 100 milliseconds */

 microseconds per millisecond */

 retry count */

 Fatal RDMA failure. */

 Detected SCSI Bus Reset. */

 Carrier Ready failure. */

 RDMAed-in data invalid. */

 Host Initiated SCSI Bus Reset. */

 Read byte from a register. */

 Write byte to a register. */

 Read word (2 bytes) from a register. */

 Write word (2 bytes) to a register. */

 Write dword (4 bytes) to a register. */

 Read byte from LRAM. */

 Write byte to LRAM. */

 Read word (2 bytes) from LRAM. */

 Write word (2 bytes) to LRAM. */

 Write little-endian double word (4 bytes) to LRAM */

 Because of unspecified C language ordering don't use auto-increment. */

 Read word (2 bytes) from LRAM assuming that the address is already set. */

 Write word (2 bytes) to LRAM assuming that the address is already set. */

/*

 * Define macro to check for Condor signature.

 *

 * Evaluate to ADV_TRUE if a Condor chip is found the specified port

 * address 'iop_base'. Otherwise evalue to ADV_FALSE.

/*

 * Define macro to Return the version number of the chip at 'iop_base'.

 *

 * The second parameter 'bus_type' is currently unused.

/*

 * Abort an SRB in the chip's RISC Memory. The 'srb_tag' argument must

 * match the ADV_SCSI_REQ_Q 'srb_tag' field.

 *

 * If the request has not yet been sent to the device it will simply be

 * aborted from RISC memory. If the request is disconnected it will be

 * aborted on reselection by sending an Abort Message to the target ID.

 *

 * Return value:

 *      ADV_TRUE(1) - Queue was successfully aborted.

 *      ADV_FALSE(0) - Queue was not found on the active queue list.

/*

 * Send a Bus Device Reset Message to the specified target ID.

 *

 * All outstanding commands will be purged if sending the

 * Bus Device Reset Message is successful.

 *

 * Return Value:

 *      ADV_TRUE(1) - All requests on the target are purged.

 *      ADV_FALSE(0) - Couldn't issue Bus Device Reset Message; Requests

 *                     are not purged.

/*

 * SCSI Wide Type definition.

/*

 * AdvInitScsiTarget() 'cntl_flag' options.

/*

 * Convert target id to target id bit mask.

/*

 * ADV_SCSI_REQ_Q 'done_status' and 'host_status' return values.

 Request not completed yet. */

 SXFR_STATUS SCSI DMA Error */

 SXFR_STATUS SCSI Bus Parity Error */

 RISC PCI DMA parity error */

 SXFR_STATUS Offset Underflow */

 SXFR_STATUS Offset Overflow */

 SXFR_STATUS Watchdog Timeout */

 SXFR_STATUS Deselected */

 Note: QHSTA_M_SXFR_XFR_OFLW is identical to QHSTA_M_DATA_OVER_RUN. */

 SXFR_STATUS Transfer Overflow */

 SXFR_STATUS Transfer Phase Error */

 SXFR_STATUS Unknown Error */

 Request aborted from SBR */

 Request aborted from unsol. SBR */

 Request aborted from BDR */

 Data Phase mismatch */

 Data Phase mismatch and bus hang */

 Bad target ID */

 TID Queue frozen. */

 Scatter-Gather backup error */

 Return the address that is aligned at the next doubleword >= to 'addr'. */

/*

 * Total contiguous memory needed for driver SG blocks.

 *

 * ADV_MAX_SG_LIST must be defined by a driver. It is the maximum

 * number of scatter-gather elements the driver supports in a

 * single request.

 struct asc_board flags */

 AdvanSys Wide Board */

 No ISA DMA Channel Used */

 advansys_info() line size */

 Asc Library return codes */

 ADVANSYS_STATS */

 ADVANSYS_STATS */

 If the result wraps when calculating tenths, return 0. */

/*

 * Display a message to the console.

 ADVANSYS_DEBUG */

/*

 * Debugging Message Levels:

 * 0: Errors Only

 * 1: High-Level Tracing

 * 2-N: Verbose Tracing

 ADVANSYS_DEBUG */

 Per board statistics structure */

 Driver Entrypoint Statistics */

 # calls to advansys_queuecommand() */

 # calls to advansys_eh_bus_reset() */

 # calls to advansys_biosparam() */

 # advansys_interrupt() calls */

 # calls to asc/adv_isr_callback() */

 # calls to request's scsi_done function */

 # asc/adv_build_req() ASC_ERROR returns. */

 # adv_build_req() adv_req_t alloc. fail. */

 # adv_build_req() adv_sgblk_t alloc. fail. */

 AscExeScsiQueue()/AdvExeScsiQueue() Statistics */

 # ASC_NOERROR returns. */

 # ASC_BUSY returns. */

 # ASC_ERROR returns. */

 # unknown returns. */

 Data Transfer Statistics */

 # I/O requests received */

 # scatter-gather elements */

 # 512-byte blocks */

 ADVANSYS_STATS */

/*

 * Structure allocated for each board.

 *

 * This structure is allocated by scsi_host_alloc() at the end

 * of the 'Scsi_Host' structure starting at the 'hostdata'

 * field. It is guaranteed to be allocated from DMA-able memory.

 Board flags */

 Narrow board */

 Wide board */

 Narrow board */

 Wide board */

 Number I/O ports. */

 Target init./valid mask */

 Starvation request count */

 Queue full mask */

 Queue full count */

 Narrow EEPROM config. */

 3550 EEPROM config. */

 38C0800 EEPROM config. */

 38C1600 EEPROM config. */

 /proc/scsi/advansys/[0...] */

 Board statistics */

 ADVANSYS_STATS */

	/*

	 * The following fields are used only for Narrow Boards.

 SDTR information */

	/*

	 * The following fields are used only for Wide Boards.

 I/O Memory remap address. */

 I/O Port address. */

 Request structures. */

 Scatter-gather structures. */

 BIOS Signature. */

 BIOS Version. */

 BIOS Code Segment. */

 BIOS Code Segment Length. */

/*

 * asc_prt_asc_dvc_var()

/*

 * asc_prt_asc_dvc_cfg()

/*

 * asc_prt_adv_dvc_var()

 *

 * Display an ADV_DVC_VAR structure.

/*

 * asc_prt_adv_dvc_cfg()

 *

 * Display an ADV_DVC_CFG structure.

/*

 * asc_prt_scsi_host()

/*

 * asc_prt_hex()

 *

 * Print hexadecimal output in 4 byte groupings 32 bytes

 * or 8 double-words per line.

 Display a maximum of 8 double-words per line. */

/*

 * asc_prt_asc_scsi_q()

/*

 * asc_prt_asc_qdone_info()

/*

 * asc_prt_adv_sgblock()

 *

 * Display an ADV_SG_BLOCK structure.

/*

 * asc_prt_adv_scsi_req_q()

 *

 * Display an ADV_SCSI_REQ_Q structure.

 Display the request's ADV_SG_BLOCK structures. */

 ADVANSYS_DEBUG */

/*

 * advansys_info()

 *

 * Return suitable for printing on the console with the argument

 * adapter's configuration information.

 *

 * Note: The information line should not exceed ASC_INFO_SIZE bytes,

 * otherwise the static 'info' array will be overrun.

		/*

		 * Wide Adapter Information

		 *

		 * Memory-mapped I/O is used instead of I/O space to access

		 * the adapter, but display the I/O Port range. The Memory

		 * I/O address is displayed through the driver /proc file.

/*

 * asc_prt_board_devices()

 *

 * Print driver information for devices attached to the board.

/*

 * Display Wide Board BIOS Information.

	/*

	 * If the BIOS saved a valid signature, then fill in

	 * the BIOS code segment base address.

ftp.connectcom.net/pub\n");

		/*

		 * Current available ROM BIOS release is 3.1I for UW

		 * and 3.2I for U2W. This code doesn't differentiate

		 * UW and U2W boards.

ftp.connectcom.net/pub\n");

/*

 * Add serial number to information bar if signature AAh

 * is found in at bit 15-9 (7 bits) of word 1.

 *

 * Serial Number consists fo 12 alpha-numeric digits.

 *

 *       1 - Product type (A,B,C,D..)  Word0: 15-13 (3 bits)

 *       2 - MFG Location (A,B,C,D..)  Word0: 12-10 (3 bits)

 *     3-4 - Product ID (0-99)         Word0: 9-0 (10 bits)

 *       5 - Product revision (A-J)    Word0:  "         "

 *

 *           Signature                 Word1: 15-9 (7 bits)

 *       6 - Year (0-9)                Word1: 8-6 (3 bits) & Word2: 15 (1 bit)

 *     7-8 - Week of the year (1-52)   Word1: 5-0 (6 bits)

 *

 *    9-12 - Serial Number (A001-Z999) Word2: 14-0 (15 bits)

 *

 * Note 1: Only production cards will have a serial number.

 *

 * Note 2: Signature is most significant 7 bits (0xFE).

 *

 * Returns ASC_TRUE if serial number found, otherwise returns ASC_FALSE.

		/*

		 * First word - 6 digits.

 Product type - 1st digit. */

 Product type is P=Prototype */

 Manufacturing location - 2nd digit. */

 Product ID - 3rd, 4th digits. */

 Product revision - 5th digit. */

		/*

		 * Second word

		/*

		 * Year - 6th digit.

		 *

		 * If bit 15 of third word is set, then the

		 * last digit of the year is greater than 7.

 Week of year - 7th, 8th digits. */

		/*

		 * Third word

 Serial number - 9th digit. */

 10th, 11th, 12th digits. */

 Null Terminate the string. */

/*

 * asc_prt_asc_board_eeprom()

 *

 * Print board EEPROM configuration.

/*

 * asc_prt_adv_board_eeprom()

 *

 * Print board EEPROM configuration.

/*

 * asc_prt_driver_conf()

/*

 * asc_prt_asc_board_info()

 *

 * Print dynamic board configuration information.

 Current number of commands waiting for the host. */

 Current number of commands waiting for a device. */

 Current limit on number of commands that can be sent to a device. */

 Indicate whether the device has returned queue full status. */

/*

 * asc_prt_adv_board_info()

 *

 * Print dynamic board configuration information.

 Check for REQ/ACK Offset 0. */

 80 Mhz */

 40 Mhz */

 20 Mhz or below. */

 Should never happen. */

/*

 * asc_prt_board_stats()

	/*

	 * Display data transfer statistics.

 Scatter gather transfer statistics */

 ADVANSYS_STATS */

/*

 * advansys_show_info() - /proc/scsi/advansys/{0,1,2,3,...}

 *

 * m: seq_file to print into

 * shost: Scsi_Host

 *

 * Return the number of bytes read from or written to a

 * /proc/scsi/advansys/[0...] file.

	/*

	 * User read of /proc/scsi/advansys/[0...] file.

	/*

	 * Get board configuration information.

	 *

	 * advansys_info() returns the board string from its own static buffer.

 Copy board information. */

	/*

	 * Display Wide Board BIOS Information.

	/*

	 * Display driver information for each device attached to the board.

	/*

	 * Display EEPROM configuration for the board.

	/*

	 * Display driver configuration and information for the board.

	/*

	 * Display driver statistics for the board.

 ADVANSYS_STATS */

	/*

	 * Display Asc Library dynamic configuration information

	 * for the board.

 CONFIG_PROC_FS */

/*

 * Copy 2 bytes to LRAM.

 *

 * The source data is assumed to be in little-endian order in memory

 * and is maintained in little-endian order when written to LRAM.

		/*

		 * On a little-endian system the second argument below

		 * produces a little-endian ushort which is written to

		 * LRAM in little-endian order. On a big-endian system

		 * the second argument produces a big-endian ushort which

		 * is "transparently" byte-swapped by outpw() and written

		 * in little-endian order to LRAM.

/*

 * Copy 4 bytes to LRAM.

 *

 * The source data is assumed to be in little-endian order in memory

 * and is maintained in little-endian order when written to LRAM.

 LSW */

 MSW */

/*

 * Copy 2 bytes from LRAM.

 *

 * The source data is assumed to be in little-endian order in LRAM

 * and is maintained in little-endian order when written to memory.

 Write the microcode buffer starting at LRAM address 0. */

 Ensure overrun buffer is aligned on an 8 byte boundary. */

 XXX: msleep? */

/*

 * Load the Microcode

 *

 * Write the microcode image to RISC memory starting at address 0.

 *

 * The microcode is stored compressed in the following format:

 *

 *  254 word (508 byte) table indexed by byte code followed

 *  by the following byte codes:

 *

 *    1-Byte Code:

 *      00: Emit word 0 in table.

 *      01: Emit word 1 in table.

 *      .

 *      FD: Emit word 253 in table.

 *

 *    Multi-Byte Code:

 *      FE WW WW: (3 byte code) Word to emit is the next word WW WW.

 *      FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.

 *

 * Returns 0 or an error if the checksum doesn't match

 Verify the microcode checksum. */

 Get physical address of the carrier 'carrp'. */

	/*

	 * We cannot have a carrier with 'carr_va' of '0', as

	 * a reference to this carrier would be interpreted as

	 * list termination.

	 * So start at carrier 1 with the freelist.

	/*

	 * insert stopper carrier to terminate list

/*

 * 'offset' is the index in the request pointer array

/*

 * Send an idle command to the chip and wait for completion.

 *

 * Command completion is polled for once per microsecond.

 *

 * The function can be called from anywhere including an interrupt handler.

 * But the function is not re-entrant, so it uses the DvcEnter/LeaveCritical()

 * functions to prevent reentrancy.

 *

 * Return Values:

 *   ADV_TRUE - command completed successfully

 *   ADV_FALSE - command failed

 *   ADV_ERROR - command timed out

	/*

	 * Clear the idle command status which is set by the microcode

	 * to a non-zero value to indicate when the command is completed.

	 * The non-zero result is one of the IDLE_CMD_STATUS_* values

	/*

	 * Write the idle command value after the idle command parameter

	 * has been written to avoid a race condition. If the order is not

	 * followed, the microcode may process the idle command before the

	 * parameters have been written to LRAM.

	/*

	 * Tickle the RISC to tell it to process the idle command.

		/*

		 * Clear the tickle value. In the ASC-3550 the RISC flag

		 * command 'clr_tickle_b' does not work unless the host

		 * value is cleared.

 Wait for up to 100 millisecond for the idle command to timeout. */

 Poll once each microsecond for command completion. */

 The idle command should never timeout. */

/*

 * Reset SCSI Bus and purge all outstanding requests.

 *

 * Return Value:

 *      ADV_TRUE(1) -   All requests are purged and SCSI Bus is reset.

 *      ADV_FALSE(0) -  Microcode command failed.

 *      ADV_ERROR(-1) - Microcode command timed-out. Microcode or IC

 *                      may be hung which requires driver recovery.

	/*

	 * Send the SCSI Bus Reset idle start idle command which asserts

	 * the SCSI Bus Reset signal.

	/*

	 * Delay for the specified SCSI Bus Reset hold time.

	 *

	 * The hold time delay is done on the host because the RISC has no

	 * microsecond accurate timer.

	/*

	 * Send the SCSI Bus Reset end idle command which de-asserts

	 * the SCSI Bus Reset signal and purges any pending requests.

 XXX: msleep? */

/*

 * Initialize the ASC-3550.

 *

 * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.

 *

 * For a non-fatal error return a warning code. If there are no warnings

 * then 0 is returned.

 *

 * Needed after initialization for error recovery.

 BIOS RISC Memory 0x40-0x8F. */

 If there is already an error, don't continue. */

	/*

	 * The caller must set 'chip_type' to ADV_CHIP_ASC3550.

	/*

	 * Save the RISC memory BIOS region before writing the microcode.

	 * The BIOS may already be loaded and using its RISC LRAM region

	 * so its region must be saved and restored.

	 *

	 * Note: This code makes the assumption, which is currently true,

	 * that a chip reset does not clear RISC LRAM.

	/*

	 * Save current per TID negotiated values.

 BIOS 3.1 and earlier location of 'wdtr_able' variable. */

	/*

	 * Restore the RISC memory BIOS region.

	/*

	 * Calculate and write the microcode code checksum to the microcode

	 * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).

	/*

	 * Read and save microcode version and date.

	/*

	 * Set the chip type to indicate the ASC3550.

	/*

	 * If the PCI Configuration Command Register "Parity Error Response

	 * Control" Bit was clear (0), then set the microcode variable

	 * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode

	 * to ignore DMA parity errors.

	/*

	 * For ASC-3550, setting the START_CTL_EMFU [3:2] bits sets a FIFO

	 * threshold of 128 bytes. This register is only accessible to the host.

	/*

	 * Microcode operating variables for WDTR, SDTR, and command tag

	 * queuing will be set in slave_configure() based on what a

	 * device reports it is capable of in Inquiry byte 7.

	 *

	 * If SCSI Bus Resets have been disabled, then directly set

	 * SDTR and WDTR from the EEPROM configuration. This will allow

	 * the BIOS and warm boot to work without a SCSI bus hang on

	 * the Inquiry caused by host and target mismatched DTR values.

	 * Without the SCSI Bus Reset, before an Inquiry a device can't

	 * be assumed to be in Asynchronous, Narrow mode.

	/*

	 * Set microcode operating variables for SDTR_SPEED1, SDTR_SPEED2,

	 * SDTR_SPEED3, and SDTR_SPEED4 based on the ULTRA EEPROM per TID

	 * bitmask. These values determine the maximum SDTR speed negotiated

	 * with a device.

	 *

	 * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,

	 * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them

	 * without determining here whether the device supports SDTR.

	 *

	 * 4-bit speed  SDTR speed name

	 * ===========  ===============

	 * 0000b (0x0)  SDTR disabled

	 * 0001b (0x1)  5 Mhz

	 * 0010b (0x2)  10 Mhz

	 * 0011b (0x3)  20 Mhz (Ultra)

	 * 0100b (0x4)  40 Mhz (LVD/Ultra2)

	 * 0101b (0x5)  80 Mhz (LVD2/Ultra3)

	 * 0110b (0x6)  Undefined

	 * .

	 * 1111b (0xF)  Undefined

 Set Ultra speed for TID 'tid'. */

 Set Fast speed for TID 'tid'. */

 Check if done with sdtr_speed1. */

 Check if done with sdtr_speed2. */

 Check if done with sdtr_speed3. */

 Check if done with sdtr_speed4. */

 End of loop. */

	/*

	 * Set microcode operating variable for the disconnect per TID bitmask.

	/*

	 * Set SCSI_CFG0 Microcode Default Value.

	 *

	 * The microcode will set the SCSI_CFG0 register using this value

	 * after it is started below.

	/*

	 * Determine SCSI_CFG1 Microcode Default Value.

	 *

	 * The microcode will set the SCSI_CFG1 register using this value

	 * after it is started below.

 Read current SCSI_CFG1 Register value. */

	/*

	 * If all three connectors are in use, return an error.

	/*

	 * If the internal narrow cable is reversed all of the SCSI_CTRL

	 * register signals will be set. Check for and return an error if

	 * this condition is found.

	/*

	 * If this is a differential board and a single-ended device

	 * is attached to one of the connectors, return an error.

	/*

	 * If automatic termination control is enabled, then set the

	 * termination value based on a table listed in a_condor.h.

	 *

	 * If manual termination was specified with an EEPROM setting

	 * then 'termination' was set-up in AdvInitFrom3550EEPROM() and

	 * is ready to be 'ored' into SCSI_CFG1.

		/*

		 * The software always controls termination by setting TERM_CTL_SEL.

		 * If TERM_CTL_SEL were set to 0, the hardware would set termination.

 TERM_CTL_H: on, TERM_CTL_L: on */

 TERM_CTL_H: on, TERM_CTL_L: off */

 TERM_CTL_H: off, TERM_CTL_L: off */

	/*

	 * Clear any set TERM_CTL_H and TERM_CTL_L bits.

	/*

	 * Invert the TERM_CTL_H and TERM_CTL_L bits and then

	 * set 'scsi_cfg1'. The TERM_POL bit does not need to be

	 * referenced, because the hardware internally inverts

	 * the Termination High and Low bits if TERM_POL is set.

	/*

	 * Set SCSI_CFG1 Microcode Default Value

	 *

	 * Set filter value and possibly modified termination control

	 * bits in the Microcode SCSI_CFG1 Register Value.

	 *

	 * The microcode will set the SCSI_CFG1 register using this value

	 * after it is started below.

	/*

	 * Set MEM_CFG Microcode Default Value

	 *

	 * The microcode will set the MEM_CFG register using this value

	 * after it is started below.

	 *

	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7

	 * are defined.

	 *

	 * ASC-3550 has 8KB internal memory.

	/*

	 * Set SEL_MASK Microcode Default Value

	 *

	 * The microcode will set the SEL_MASK register using this value

	 * after it is started below.

	/*

	 * Set-up the Host->RISC Initiator Command Queue (ICQ).

	/*

	 * Set RISC ICQ physical address start value.

	/*

	 * Set-up the RISC->Host Initiator Response Queue (IRQ).

	/*

	 * Set RISC IRQ physical address start value.

 finally, finally, gentlemen, start your engine */

	/*

	 * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus

	 * Resets should be performed. The RISC has to be running

	 * to issue a SCSI Bus Reset.

		/*

		 * If the BIOS Signature is present in memory, restore the

		 * BIOS Handshake Configuration Table and do not perform

		 * a SCSI Bus Reset.

			/*

			 * Restore per TID negotiated values.

/*

 * Initialize the ASC-38C0800.

 *

 * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.

 *

 * For a non-fatal error return a warning code. If there are no warnings

 * then 0 is returned.

 *

 * Needed after initialization for error recovery.

 BIOS RISC Memory 0x40-0x8F. */

 If there is already an error, don't continue. */

	/*

	 * The caller must set 'chip_type' to ADV_CHIP_ASC38C0800.

	/*

	 * Save the RISC memory BIOS region before writing the microcode.

	 * The BIOS may already be loaded and using its RISC LRAM region

	 * so its region must be saved and restored.

	 *

	 * Note: This code makes the assumption, which is currently true,

	 * that a chip reset does not clear RISC LRAM.

	/*

	 * Save current per TID negotiated values.

	/*

	 * RAM BIST (RAM Built-In Self Test)

	 *

	 * Address : I/O base + offset 0x38h register (byte).

	 * Function: Bit 7-6(RW) : RAM mode

	 *                          Normal Mode   : 0x00

	 *                          Pre-test Mode : 0x40

	 *                          RAM Test Mode : 0x80

	 *           Bit 5       : unused

	 *           Bit 4(RO)   : Done bit

	 *           Bit 3-0(RO) : Status

	 *                          Host Error    : 0x08

	 *                          Int_RAM Error : 0x04

	 *                          RISC Error    : 0x02

	 *                          SCSI Error    : 0x01

	 *                          No Error      : 0x00

	 *

	 * Note: RAM BIST code should be put right here, before loading the

	 * microcode and after saving the RISC memory BIOS region.

	/*

	 * LRAM Pre-test

	 *

	 * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.

	 * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return

	 * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset

	 * to NORMAL_MODE, return an error too.

 Wait for 10ms before reading back. */

 Wait for 10ms before reading back. */

	/*

	 * LRAM Test - It takes about 1.5 ms to run through the test.

	 *

	 * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.

	 * If Done bit not set or Status not 0, save register byte, set the

	 * err_code, and return an error.

 Wait for 10ms before checking status. */

 Get here if Done bit not set or Status not 0. */

 for BIOS display message */

 We need to reset back to normal mode after LRAM test passes. */

	/*

	 * Restore the RISC memory BIOS region.

	/*

	 * Calculate and write the microcode code checksum to the microcode

	 * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).

	/*

	 * Read microcode version and date.

	/*

	 * Set the chip type to indicate the ASC38C0800.

	/*

	 * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.

	 * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current

	 * cable detection and then we are able to read C_DET[3:0].

	 *

	 * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1

	 * Microcode Default Value' section below.

	/*

	 * If the PCI Configuration Command Register "Parity Error Response

	 * Control" Bit was clear (0), then set the microcode variable

	 * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode

	 * to ignore DMA parity errors.

	/*

	 * For ASC-38C0800, set FIFO_THRESH_80B [6:4] bits and START_CTL_TH [3:2]

	 * bits for the default FIFO threshold.

	 *

	 * Note: ASC-38C0800 FIFO threshold has been changed to 256 bytes.

	 *

	 * For DMA Errata #4 set the BC_THRESH_ENB bit.

	/*

	 * Microcode operating variables for WDTR, SDTR, and command tag

	 * queuing will be set in slave_configure() based on what a

	 * device reports it is capable of in Inquiry byte 7.

	 *

	 * If SCSI Bus Resets have been disabled, then directly set

	 * SDTR and WDTR from the EEPROM configuration. This will allow

	 * the BIOS and warm boot to work without a SCSI bus hang on

	 * the Inquiry caused by host and target mismatched DTR values.

	 * Without the SCSI Bus Reset, before an Inquiry a device can't

	 * be assumed to be in Asynchronous, Narrow mode.

	/*

	 * Set microcode operating variables for DISC and SDTR_SPEED1,

	 * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM

	 * configuration values.

	 *

	 * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,

	 * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them

	 * without determining here whether the device supports SDTR.

	/*

	 * Set SCSI_CFG0 Microcode Default Value.

	 *

	 * The microcode will set the SCSI_CFG0 register using this value

	 * after it is started below.

	/*

	 * Determine SCSI_CFG1 Microcode Default Value.

	 *

	 * The microcode will set the SCSI_CFG1 register using this value

	 * after it is started below.

 Read current SCSI_CFG1 Register value. */

	/*

	 * If the internal narrow cable is reversed all of the SCSI_CTRL

	 * register signals will be set. Check for and return an error if

	 * this condition is found.

	/*

	 * All kind of combinations of devices attached to one of four

	 * connectors are acceptable except HVD device attached. For example,

	 * LVD device can be attached to SE connector while SE device attached

	 * to LVD connector.  If LVD device attached to SE connector, it only

	 * runs up to Ultra speed.

	 *

	 * If an HVD device is attached to one of LVD connectors, return an

	 * error.  However, there is no way to detect HVD device attached to

	 * SE connectors.

	/*

	 * If either SE or LVD automatic termination control is enabled, then

	 * set the termination value based on a table listed in a_condor.h.

	 *

	 * If manual termination was specified with an EEPROM setting then

	 * 'termination' was set-up in AdvInitFrom38C0800EEPROM() and is ready

	 * to be 'ored' into SCSI_CFG1.

 SE automatic termination control is enabled. */

 TERM_SE_HI: on, TERM_SE_LO: on */

 TERM_SE_HI: on, TERM_SE_LO: off */

 LVD automatic termination control is enabled. */

 TERM_LVD_HI: on, TERM_LVD_LO: on */

 TERM_LVD_HI: off, TERM_LVD_LO: off */

	/*

	 * Clear any set TERM_SE and TERM_LVD bits.

	/*

	 * Invert the TERM_SE and TERM_LVD bits and then set 'scsi_cfg1'.

	/*

	 * Clear BIG_ENDIAN, DIS_TERM_DRV, Terminator Polarity and HVD/LVD/SE

	 * bits and set possibly modified termination control bits in the

	 * Microcode SCSI_CFG1 Register Value.

	/*

	 * Set SCSI_CFG1 Microcode Default Value

	 *

	 * Set possibly modified termination control and reset DIS_TERM_DRV

	 * bits in the Microcode SCSI_CFG1 Register Value.

	 *

	 * The microcode will set the SCSI_CFG1 register using this value

	 * after it is started below.

	/*

	 * Set MEM_CFG Microcode Default Value

	 *

	 * The microcode will set the MEM_CFG register using this value

	 * after it is started below.

	 *

	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7

	 * are defined.

	 *

	 * ASC-38C0800 has 16KB internal memory.

	/*

	 * Set SEL_MASK Microcode Default Value

	 *

	 * The microcode will set the SEL_MASK register using this value

	 * after it is started below.

	/*

	 * Set-up the Host->RISC Initiator Command Queue (ICQ).

	/*

	 * Set RISC ICQ physical address start value.

	 * carr_pa is LE, must be native before write

	/*

	 * Set-up the RISC->Host Initiator Response Queue (IRQ).

	/*

	 * Set RISC IRQ physical address start value.

	 *

	 * carr_pa is LE, must be native before write *

 finally, finally, gentlemen, start your engine */

	/*

	 * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus

	 * Resets should be performed. The RISC has to be running

	 * to issue a SCSI Bus Reset.

		/*

		 * If the BIOS Signature is present in memory, restore the

		 * BIOS Handshake Configuration Table and do not perform

		 * a SCSI Bus Reset.

			/*

			 * Restore per TID negotiated values.

/*

 * Initialize the ASC-38C1600.

 *

 * On failure set the ASC_DVC_VAR field 'err_code' and return ADV_ERROR.

 *

 * For a non-fatal error return a warning code. If there are no warnings

 * then 0 is returned.

 *

 * Needed after initialization for error recovery.

 BIOS RISC Memory 0x40-0x8F. */

 If there is already an error, don't continue. */

	/*

	 * The caller must set 'chip_type' to ADV_CHIP_ASC38C1600.

	/*

	 * Save the RISC memory BIOS region before writing the microcode.

	 * The BIOS may already be loaded and using its RISC LRAM region

	 * so its region must be saved and restored.

	 *

	 * Note: This code makes the assumption, which is currently true,

	 * that a chip reset does not clear RISC LRAM.

	/*

	 * Save current per TID negotiated values.

	/*

	 * RAM BIST (Built-In Self Test)

	 *

	 * Address : I/O base + offset 0x38h register (byte).

	 * Function: Bit 7-6(RW) : RAM mode

	 *                          Normal Mode   : 0x00

	 *                          Pre-test Mode : 0x40

	 *                          RAM Test Mode : 0x80

	 *           Bit 5       : unused

	 *           Bit 4(RO)   : Done bit

	 *           Bit 3-0(RO) : Status

	 *                          Host Error    : 0x08

	 *                          Int_RAM Error : 0x04

	 *                          RISC Error    : 0x02

	 *                          SCSI Error    : 0x01

	 *                          No Error      : 0x00

	 *

	 * Note: RAM BIST code should be put right here, before loading the

	 * microcode and after saving the RISC memory BIOS region.

	/*

	 * LRAM Pre-test

	 *

	 * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.

	 * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return

	 * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset

	 * to NORMAL_MODE, return an error too.

 Wait for 10ms before reading back. */

 Wait for 10ms before reading back. */

	/*

	 * LRAM Test - It takes about 1.5 ms to run through the test.

	 *

	 * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.

	 * If Done bit not set or Status not 0, save register byte, set the

	 * err_code, and return an error.

 Wait for 10ms before checking status. */

 Get here if Done bit not set or Status not 0. */

 for BIOS display message */

 We need to reset back to normal mode after LRAM test passes. */

	/*

	 * Restore the RISC memory BIOS region.

	/*

	 * Calculate and write the microcode code checksum to the microcode

	 * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).

	/*

	 * Read microcode version and date.

	/*

	 * Set the chip type to indicate the ASC38C1600.

	/*

	 * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.

	 * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current

	 * cable detection and then we are able to read C_DET[3:0].

	 *

	 * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1

	 * Microcode Default Value' section below.

	/*

	 * If the PCI Configuration Command Register "Parity Error Response

	 * Control" Bit was clear (0), then set the microcode variable

	 * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode

	 * to ignore DMA parity errors.

	/*

	 * If the BIOS control flag AIPP (Asynchronous Information

	 * Phase Protection) disable bit is not set, then set the firmware

	 * 'control_flag' CONTROL_FLAG_ENABLE_AIPP bit to enable

	 * AIPP checking and encoding.

	/*

	 * For ASC-38C1600 use DMA_CFG0 default values: FIFO_THRESH_80B [6:4],

	 * and START_CTL_TH [3:2].

	/*

	 * Microcode operating variables for WDTR, SDTR, and command tag

	 * queuing will be set in slave_configure() based on what a

	 * device reports it is capable of in Inquiry byte 7.

	 *

	 * If SCSI Bus Resets have been disabled, then directly set

	 * SDTR and WDTR from the EEPROM configuration. This will allow

	 * the BIOS and warm boot to work without a SCSI bus hang on

	 * the Inquiry caused by host and target mismatched DTR values.

	 * Without the SCSI Bus Reset, before an Inquiry a device can't

	 * be assumed to be in Asynchronous, Narrow mode.

	/*

	 * Set microcode operating variables for DISC and SDTR_SPEED1,

	 * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM

	 * configuration values.

	 *

	 * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,

	 * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them

	 * without determining here whether the device supports SDTR.

	/*

	 * Set SCSI_CFG0 Microcode Default Value.

	 *

	 * The microcode will set the SCSI_CFG0 register using this value

	 * after it is started below.

	/*

	 * Calculate SCSI_CFG1 Microcode Default Value.

	 *

	 * The microcode will set the SCSI_CFG1 register using this value

	 * after it is started below.

	 *

	 * Each ASC-38C1600 function has only two cable detect bits.

	 * The bus mode override bits are in IOPB_SOFT_OVER_WR.

	/*

	 * If the cable is reversed all of the SCSI_CTRL register signals

	 * will be set. Check for and return an error if this condition is

	 * found.

	/*

	 * Each ASC-38C1600 function has two connectors. Only an HVD device

	 * can not be connected to either connector. An LVD device or SE device

	 * may be connected to either connecor. If an SE device is connected,

	 * then at most Ultra speed (20 Mhz) can be used on both connectors.

	 *

	 * If an HVD device is attached, return an error.

	/*

	 * Each function in the ASC-38C1600 uses only the SE cable detect and

	 * termination because there are two connectors for each function. Each

	 * function may use either LVD or SE mode. Corresponding the SE automatic

	 * termination control EEPROM bits are used for each function. Each

	 * function has its own EEPROM. If SE automatic control is enabled for

	 * the function, then set the termination value based on a table listed

	 * in a_condor.h.

	 *

	 * If manual termination is specified in the EEPROM for the function,

	 * then 'termination' was set-up in AscInitFrom38C1600EEPROM() and is

	 * ready to be 'ored' into SCSI_CFG1.

 SE automatic termination control is enabled. */

 TERM_SE_HI: on, TERM_SE_LO: on */

 Function 0 - TERM_SE_HI: off, TERM_SE_LO: off */

 Function 1 - TERM_SE_HI: on, TERM_SE_LO: off */

	/*

	 * Clear any set TERM_SE bits.

	/*

	 * Invert the TERM_SE bits and then set 'scsi_cfg1'.

	/*

	 * Clear Big Endian and Terminator Polarity bits and set possibly

	 * modified termination control bits in the Microcode SCSI_CFG1

	 * Register Value.

	 *

	 * Big Endian bit is not used even on big endian machines.

	/*

	 * Set SCSI_CFG1 Microcode Default Value

	 *

	 * Set possibly modified termination control bits in the Microcode

	 * SCSI_CFG1 Register Value.

	 *

	 * The microcode will set the SCSI_CFG1 register using this value

	 * after it is started below.

	/*

	 * Set MEM_CFG Microcode Default Value

	 *

	 * The microcode will set the MEM_CFG register using this value

	 * after it is started below.

	 *

	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7

	 * are defined.

	 *

	 * ASC-38C1600 has 32KB internal memory.

	 *

	 * XXX - Since ASC38C1600 Rev.3 has a Local RAM failure issue, we come

	 * out a special 16K Adv Library and Microcode version. After the issue

	 * resolved, we should turn back to the 32K support. Both a_condor.h and

	 * mcode.sas files also need to be updated.

	 *

	 * AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,

	 *  BIOS_EN | RAM_SZ_32KB);

	/*

	 * Set SEL_MASK Microcode Default Value

	 *

	 * The microcode will set the SEL_MASK register using this value

	 * after it is started below.

	/*

	 * Set-up the Host->RISC Initiator Command Queue (ICQ).

	/*

	 * Set RISC ICQ physical address start value. Initialize the

	 * COMMA register to the same value otherwise the RISC will

	 * prematurely detect a command is available.

	/*

	 * Set-up the RISC->Host Initiator Response Queue (IRQ).

	/*

	 * Set RISC IRQ physical address start value.

 finally, finally, gentlemen, start your engine */

	/*

	 * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus

	 * Resets should be performed. The RISC has to be running

	 * to issue a SCSI Bus Reset.

		/*

		 * If the BIOS Signature is present in memory, restore the

		 * per TID microcode operating variables.

			/*

			 * Restore per TID negotiated values.

/*

 * Reset chip and SCSI Bus.

 *

 * Return Value:

 *      ADV_TRUE(1) -   Chip re-initialization and SCSI Bus Reset successful.

 *      ADV_FALSE(0) -  Chip re-initialization and SCSI Bus Reset failure.

	/*

	 * Save current per TID negotiated values.

	/*

	 * Force the AdvInitAsc3550/38C0800Driver() function to

	 * perform a SCSI Bus Reset by clearing the BIOS signature word.

	 * The initialization functions assumes a SCSI Bus Reset is not

	 * needed if the BIOS signature word is present.

	/*

	 * Stop chip and reset it.

	/*

	 * Reset Adv Library error code, if any, and try

	 * re-initializing the chip.

 Translate initialization return value to status value. */

	/*

	 * Restore the BIOS signature word.

	/*

	 * Restore per TID negotiated values.

/*

 * adv_async_callback() - Adv Library asynchronous event callback function.

		/*

		 * The firmware detected a SCSI Bus reset.

		/*

		 * Handle RDMA failure by resetting the SCSI Bus and

		 * possibly the chip if it is unresponsive. Log the error

		 * with a unique code.

		/*

		 * Host generated SCSI bus reset occurred.

/*

 * adv_isr_callback() - Second Level Interrupt Handler called by AdvISR().

 *

 * Callback function for the Wide SCSI Adv Library.

	/*

	 * Get the adv_req_t structure for the command that has been

	 * completed. The adv_req_t structure actually contains the

	 * completed ADV_SCSI_REQ_Q structure.

	/*

	 * Remove backreferences to avoid duplicate

	 * command completions.

	/*

	 * 'done_status' contains the command's ending status.

		/*

		 * Check for an underrun condition.

		 *

		 * If there was no error and an underrun condition, then

		 * then return the number of underrun bytes.

 Some other QHSTA error occurred. */

	/*

	 * If the 'init_tidmask' bit isn't already set for the target and the

	 * current request finished normally, then set the bit for the target

	 * to indicate that a device is present.

	/*

	 * Free all 'adv_sgblk_t' structures allocated for the request.

 Remove 'sgblkp' from the request list. */

/*

 * Adv Library Interrupt Service Routine

 *

 *  This function is called by a driver's interrupt service routine.

 *  The function disables and re-enables interrupts.

 *

 *  When a microcode idle command is completed, the ADV_DVC_VAR

 *  'idle_cmd_done' field is set to ADV_TRUE.

 *

 *  Note: AdvISR() can be called when interrupts are disabled or even

 *  when there is no hardware interrupt condition present. It will

 *  always check for completed idle commands and microcode requests.

 *  This is an important feature that shouldn't be changed because it

 *  allows commands to be completed from polling mode loops.

 *

 * Return:

 *   ADV_TRUE(1) - interrupt was pending

 *   ADV_FALSE(0) - no interrupt was pending

 Reading the register clears the interrupt. */

	/*

	 * Notify the driver of an asynchronous microcode condition by

	 * calling the adv_async_callback function. The function

	 * is passed the microcode ASC_MC_INTRB_CODE byte value.

	/*

	 * Check if the IRQ stopper carrier contains a completed request.

		/*

		 * Get a pointer to the newly completed ADV_SCSI_REQ_Q structure.

		 * The RISC will have set 'areq_vpa' to a virtual address.

		 *

		 * The firmware will have copied the ADV_SCSI_REQ_Q.scsiq_ptr

		 * field to the carrier ADV_CARR_T.areq_vpa field. The conversion

		 * below complements the conversion of ADV_SCSI_REQ_Q.scsiq_ptr'

		 * in AdvExeScsiQueue().

		/*

		 * Request finished with good status and the queue was not

		 * DMAed to host memory by the firmware. Set all status fields

		 * to indicate good status.

		/*

		 * Advance the stopper pointer to the next carrier

		 * ignoring the lower four bits. Free the previous

		 * stopper carrier.

		/*

		 * Clear request microcode control flag.

		/*

		 * Notify the driver of the completed request by passing

		 * the ADV_SCSI_REQ_Q pointer to its callback function.

		/*

		 * Note: After the driver callback function is called, 'scsiq'

		 * can no longer be referenced.

		 *

		 * Fall through and continue processing other completed

		 * requests...

					/*

					 * Set the device queue depth to the

					 * number of active requests when the

					 * QUEUE FULL condition was encountered.

/*

 * void

 * DvcGetQinfo(PortAddr iop_base, ushort s_addr, uchar *inbuf, int words)

 *

 * Calling/Exit State:

 *    none

 *

 * Description:

 *     Input an ASC_QDONE_INFO structure from the chip

	/*

	 * Read high word of remain bytes from alternate location.

	/*

	 * Read low word of remain bytes from original location.

/*

 * asc_isr_callback() - Second Level Interrupt Handler called by AscISR().

 *

 * Interrupt callback function for the Narrow SCSI Asc Library.

	/*

	 * Decrease the srb_tag by 1 to find the SCSI command

	/*

	 * 'qdonep' contains the command's ending status.

		/*

		 * Check for an underrun condition.

		 *

		 * If there was no error and an underrun condition, then

		 * return the number of underrun bytes.

 QHSTA error occurred */

	/*

	 * If the 'init_tidmask' bit isn't already set for the target and the

	 * current request finished normally, then set the bit for the target

	 * to indicate that a device is present.

			/*

			 * This is also curious.

			 * false_overrun will _always_ be set to 'false'

/*

 * advansys_reset()

 *

 * Reset the host associated with the command 'scp'.

 *

 * This function runs its own thread. Interrupts must be blocked but

 * sleeping is allowed and no locking other than for host structures is

 * required. Returns SUCCESS or FAILED.

 Reset the chip and SCSI bus. */

 Refer to ASC_IERR_* definitions for meaning of 'err_code'. */

		/*

		 * If the suggest reset bus flags are set, then reset the bus.

		 * Otherwise only reset the device.

		/*

		 * Reset the chip and SCSI bus.

/*

 * advansys_biosparam()

 *

 * Translate disk drive geometry if the "BIOS greater than 1 GB"

 * support is enabled for a drive.

 *

 * ip (information pointer) is an int array with the following definition:

 * ip[0]: heads

 * ip[1]: sectors

 * ip[2]: cylinders

/*

 * First-level interrupt handler.

 *

 * 'dev_id' is a pointer to the interrupting adapter's Scsi_Host.

/*

 * Wide Transfers

 *

 * If the EEPROM enabled WDTR for the device and the device supports wide

 * bus (16 bit) transfers, then turn on the device's 'wdtr_able' bit and

 * write the new value to the microcode.

	/*

	 * Clear the microcode SDTR and WDTR negotiation done indicators for

	 * the target to cause it to negotiate with the new setting set above.

	 * WDTR when accepted causes the target to enter asynchronous mode, so

	 * SDTR must be negotiated.

/*

 * Synchronous Transfers

 *

 * If the EEPROM enabled SDTR for the device and the device

 * supports synchronous transfers, then turn on the device's

 * 'sdtr_able' bit. Write the new value to the microcode.

	/*

	 * Clear the microcode "SDTR negotiation" done indicator for the

	 * target to cause it to negotiate with the new setting set above.

/*

 * PPR (Parallel Protocol Request) Capable

 *

 * If the device supports DT mode, then it must be PPR capable.

 * The PPR message will be used in place of the SDTR and WDTR

 * messages to negotiate synchronous speed and offset, transfer

 * width, and protocol options.

		/*

		 * Handle WDTR, SDTR, and Tag Queuing. If the feature

		 * is enabled in the EEPROM and the device supports the

		 * feature, then enable it in the microcode.

		/*

		 * Tag Queuing is disabled for the BIOS which runs in polled

		 * mode and would see no benefit from Tag Queuing. Also by

		 * disabling Tag Queuing in the BIOS devices with Tag Queuing

		 * bugs will at least work with the BIOS.

/*

 * Set the number of commands to queue per device for the

 * specified host adapter.

	/*

	 * Set the srb_tag to the command tag + 1, as

	 * srb_tag '0' is used internally by the chip.

	/*

	 * Build the ASC_SCSI_Q request.

	/*

	 * If there are any outstanding requests for the current target,

	 * then every 255th request send an ORDERED request. This heuristic

	 * tries to retain the benefit of request sorting while preventing

	 * request starvation. 255 is the max number of tags or pending commands

	 * a device may have outstanding.

	 *

	 * The request count is incremented below for every successfully

	 * started request.

	 *

 Build ASC_SCSI_Q */

 This is a byte value, otherwise it would need to be swapped. */

		/*

		 * Convert scatter-gather list into ASC_SG_HEAD list.

/*

 * Build scatter-gather list for Adv Library (Wide Board).

 *

 * Additional ADV_SG_BLOCK structures will need to be allocated

 * if the total number of scatter-gather elements exceeds

 * NO_OF_SG_PER_BLOCK (15). The ADV_SG_BLOCK structures are

 * assumed to be physically contiguous.

 *

 * Return:

 *      ADV_SUCCESS(1) - SG List successfully created

 *      ADV_ERROR(-1) - SG List creation failed

		/*

		 * Allocate a 'adv_sgblk_t' structure from the board free

		 * list. One 'adv_sgblk_t' structure holds NO_OF_SG_PER_BLOCK

		 * (15) scatter-gather elements.

			/*

			 * Allocation failed. Free 'adv_sgblk_t' structures

			 * already allocated for the request.

 Remove 'sgblkp' from the request list. */

 Complete 'adv_sgblk_t' board allocation. */

		/*

		 * Check if this is the first 'adv_sgblk_t' for the

		 * request.

 Request's first scatter-gather block. */

			/*

			 * Set ADV_SCSI_REQ_T ADV_SG_BLOCK virtual and physical

			 * address pointers.

 Request's second or later scatter-gather block. */

			/*

			 * Point the previous ADV_SG_BLOCK structure to

			 * the newly allocated ADV_SG_BLOCK structure.

				/*

				 * Last ADV_SG_BLOCK and scatter-gather entry.

 Last ADV_SG_BLOCK in list. */

/*

 * Build a request structure for the Adv Library (Wide Board).

 *

 * If an adv_req_t can not be allocated to issue the request,

 * then return ASC_BUSY. If an error occurs, then return ASC_ERROR.

 *

 * Multi-byte fields in the ADV_SCSI_REQ_Q that are used by the

 * microcode for DMA addresses or math operations are byte swapped

 * to little-endian order.

	/*

	 * Allocate an adv_req_t structure from the board to execute

	 * the command.

	/*

	 * Initialize the structure.

	/*

	 * Set the srb_tag to the command tag.

	/*

	 * Set 'host_scribble' to point to the adv_req_t structure.

	/*

	 * Build the ADV_SCSI_REQ_Q request.

 Set CDB length and copy it to the request structure.  */

 Copy first 12 CDB bytes to cdb[]. */

 Copy last 4 CDB bytes, if present, to cdb16[]. */

 Build ADV_SCSI_REQ_Q */

 Zero-length transfer */

/*

 * void

 * DvcPutScsiQ(PortAddr iop_base, ushort s_addr, uchar *outbuf, int words)

 *

 * Calling/Exit State:

 *    none

 *

 * Description:

 *     Output an ASC_SCSI_Q structure to the chip

	/*

	 * Set sg_entry_cnt to be the number of SG elements that

	 * will fit in the allocated SG queues. It is minus 1, because

	 * the first SG element is handled above.

/*

 * AdvExeScsiQueue() - Send a request to the RISC microcode program.

 *

 *   Allocate a carrier structure, point the carrier to the ADV_SCSI_REQ_Q,

 *   add the carrier to the ICQ (Initiator Command Queue), and tickle the

 *   RISC to notify it a new command is ready to be executed.

 *

 * If 'done_status' is not set to QD_DO_RETRY, then 'error_retry' will be

 * set to SCSI_MAX_RETRY.

 *

 * Multi-byte fields in the ADV_SCSI_REQ_Q that are used by the microcode

 * for DMA addresses or math operations are byte swapped to little-endian

 * order.

 *

 * Return:

 *      ADV_SUCCESS(1) - The request was successfully queued.

 *      ADV_BUSY(0) -    Resource unavailable; Retry again after pending

 *                       request completes.

 *      ADV_ERROR(-1) -  Invalid ADV_SCSI_REQ_Q request structure

 *                       host IC error.

	/*

	 * The ADV_SCSI_REQ_Q 'target_id' field should never exceed ADV_MAX_TID.

	/*

	 * Allocate a carrier ensuring at least one carrier always

	 * remains on the freelist and initialize fields.

 Save virtual and physical address of ADV_SCSI_REQ_Q and carrier. */

	/*

	 * Use the current stopper to send the ADV_SCSI_REQ_Q command to

	 * the microcode. The newly allocated stopper will become the new

	 * stopper.

	/*

	 * Set the 'next_vpa' pointer for the old stopper to be the

	 * physical address of the new stopper. The RISC can only

	 * follow physical addresses.

	/*

	 * Set the host adapter stopper pointer to point to the new carrier.

		/*

		 * Tickle the RISC to tell it to read its Command Queue Head pointer.

			/*

			 * Clear the tickle value. In the ASC-3550 the RISC flag

			 * command 'clr_tickle_a' does not work unless the host

			 * value is cleared.

		/*

		 * Notify the RISC a carrier is ready by writing the physical

		 * address of the new carrier stopper to the COMMA register.

/*

 * Execute a single 'struct scsi_cmnd'.

			/*

			 * The asc_stats fields 'adv_build_noreq' and

			 * 'adv_build_nosg' count wide board busy conditions.

			 * They are updated in adv_build_req and

			 * adv_get_sglist, respectively.

		/*

		 * Increment monotonically increasing per device

		 * successful request counter. Wrapping doesn't matter.

/*

 * advansys_queuecommand() - interrupt-driven I/O entrypoint.

 *

 * This function always returns 0. Command return status is saved

 * in the 'scp' result field.

/*

 * Return the BIOS address of the adapter at the specified

 * I/O port and with the specified bus type.

	/*

	 * The PCI BIOS is re-located by the motherboard BIOS. Because

	 * of this the driver can not determine where a PCI BIOS is

	 * loaded and executes.

 asc_dvc->init_state initialized in AscInitGetConfig(). */

 Read two config words; Byte-swapping done by AscReadEEPWord(). */

			/*

			 * Swap all char fields - must unswap bytes already swapped

			 * by AscReadEEPWord().

 Don't swap word field at the end - cntl field. */

 Checksum treats all EEPROM data as words. */

	/*

	 * Read the checksum word which will be compared against 'sum'

	 * by the caller. Word field already swapped.

 Write two config words; AscWriteEEPWord() will swap bytes. */

			/*

			 * This is a char field. Swap char fields before they are

			 * swapped again by AscWriteEEPWord().

 Don't swap word field at the end - cntl field. */

 Checksum calculated from word values. */

 Write checksum word. It will be swapped by AscWriteEEPWord(). */

 Read EEPROM back again. */

	/*

	 * Read two config words; Byte-swapping done by AscReadEEPWord().

			/*

			 * Swap all char fields. Must unswap bytes already swapped

			 * by AscReadEEPWord().

 Don't swap word field at the end - cntl field. */

 Read checksum; Byte swapping not needed. */

 XXX: msleep? */

 Indicate EEPROM-less board. */

 No error */

 CONFIG_PCI */

 No error. */

/*

 * EEPROM Configuration.

 *

 * All drivers should use this structure to set the default EEPROM

 * configuration. The BIOS now uses this structure when it is built.

 * Additional structure information can be found in a_condor.h where

 * the structure is defined.

 *

 * The *_Field_IsChar structs are needed to correct for endianness.

 * These values are read from the board 16 bits at a time directly

 * into the structs. Because some fields are char, the values will be

 * in the wrong order. The *_Field_IsChar tells when to flip the

 * bytes. Data read and written to PCI memory is automatically swapped

 * on big-endian platforms so char fields read as words are actually being

 * unswapped on big-endian platforms.

 cfg_lsw */

 cfg_msw */

 disc_enable */

 wdtr_able */

 sdtr_able */

 start_motor */

 tagqng_able */

 bios_scan */

 scam_tolerant */

 adapter_scsi_id */

 bios_boot_delay */

 scsi_reset_delay */

 bios_id_lun */

 termination */

 reserved1 */

 bios_ctrl */

 ultra_able */

 reserved2 */

 max_host_qng */

 max_dvc_qng */

 dvc_cntl */

 bug_fix */

 serial_number_word1 */

 serial_number_word2 */

 serial_number_word3 */

 check_sum */

 oem_name[16] */

 dvc_err_code */

 adv_err_code */

 adv_err_addr */

 saved_dvc_err_code */

 saved_adv_err_code */

 saved_adv_err_addr */

 num_of_err */

 cfg_lsw */

 cfg_msw */

 -disc_enable */

 wdtr_able */

 sdtr_able */

 start_motor */

 tagqng_able */

 bios_scan */

 scam_tolerant */

 adapter_scsi_id */

 bios_boot_delay */

 scsi_reset_delay */

 bios_id_lun */

 termination */

 reserved1 */

 bios_ctrl */

 ultra_able */

 reserved2 */

 max_host_qng */

 max_dvc_qng */

 dvc_cntl */

 bug_fix */

 serial_number_word1 */

 serial_number_word2 */

 serial_number_word3 */

 check_sum */

 oem_name[16] */

 dvc_err_code */

 adv_err_code */

 adv_err_addr */

 saved_dvc_err_code */

 saved_adv_err_code */

 saved_adv_err_addr */

 num_of_err */

 00 cfg_lsw */

 01 cfg_msw */

 02 disc_enable */

 03 wdtr_able */

 04 sdtr_speed1 */

 05 start_motor */

 06 tagqng_able */

 07 bios_scan */

 08 scam_tolerant */

 09 adapter_scsi_id */

    bios_boot_delay */

 10 scsi_reset_delay */

    bios_id_lun */

 11 termination_se */

    termination_lvd */

 12 bios_ctrl */

 13 sdtr_speed2 */

 14 sdtr_speed3 */

 15 max_host_qng */

    max_dvc_qng */

 16 dvc_cntl */

 17 sdtr_speed4 */

 18 serial_number_word1 */

 19 serial_number_word2 */

 20 serial_number_word3 */

 21 check_sum */

 22-29 oem_name[16] */

 30 dvc_err_code */

 31 adv_err_code */

 32 adv_err_addr */

 33 saved_dvc_err_code */

 34 saved_adv_err_code */

 35 saved_adv_err_addr */

 36 reserved */

 37 reserved */

 38 reserved */

 39 reserved */

 40 reserved */

 41 reserved */

 42 reserved */

 43 reserved */

 44 reserved */

 45 reserved */

 46 reserved */

 47 reserved */

 48 reserved */

 49 reserved */

 50 reserved */

 51 reserved */

 52 reserved */

 53 reserved */

 54 reserved */

 55 reserved */

 56 cisptr_lsw */

 57 cisprt_msw */

 58 subsysvid */

 59 subsysid */

 60 reserved */

 61 reserved */

 62 reserved */

 63 reserved */

 00 cfg_lsw */

 01 cfg_msw */

 02 disc_enable */

 03 wdtr_able */

 04 sdtr_speed1 */

 05 start_motor */

 06 tagqng_able */

 07 bios_scan */

 08 scam_tolerant */

 09 adapter_scsi_id */

    bios_boot_delay */

 10 scsi_reset_delay */

    bios_id_lun */

 11 termination_se */

    termination_lvd */

 12 bios_ctrl */

 13 sdtr_speed2 */

 14 sdtr_speed3 */

 15 max_host_qng */

    max_dvc_qng */

 16 dvc_cntl */

 17 sdtr_speed4 */

 18 serial_number_word1 */

 19 serial_number_word2 */

 20 serial_number_word3 */

 21 check_sum */

 22-29 oem_name[16] */

 30 dvc_err_code */

 31 adv_err_code */

 32 adv_err_addr */

 33 saved_dvc_err_code */

 34 saved_adv_err_code */

 35 saved_adv_err_addr */

 36 reserved */

 37 reserved */

 38 reserved */

 39 reserved */

 40 reserved */

 41 reserved */

 42 reserved */

 43 reserved */

 44 reserved */

 45 reserved */

 46 reserved */

 47 reserved */

 48 reserved */

 49 reserved */

 50 reserved */

 51 reserved */

 52 reserved */

 53 reserved */

 54 reserved */

 55 reserved */

 56 cisptr_lsw */

 57 cisprt_msw */

 58 subsysvid */

 59 subsysid */

 60 reserved */

 61 reserved */

 62 reserved */

 63 reserved */

 00 cfg_lsw */

 01 cfg_msw */

 02 disc_enable */

 03 wdtr_able */

 04 sdtr_speed1 */

 05 start_motor */

 06 tagqng_able */

 07 bios_scan */

 08 scam_tolerant */

 09 adapter_scsi_id */

    bios_boot_delay */

 10 scsi_reset_delay */

    bios_id_lun */

 11 termination_se */

    termination_lvd */

 12 bios_ctrl */

 13 sdtr_speed2 */

 14 sdtr_speed3 */

 15 max_host_qng */

    max_dvc_qng */

 16 dvc_cntl */

 17 sdtr_speed4 */

 18 serial_number_word1 */

 19 serial_number_word2 */

 20 serial_number_word3 */

 21 check_sum */

 22-29 oem_name[16] */

 30 dvc_err_code */

 31 adv_err_code */

 32 adv_err_addr */

 33 saved_dvc_err_code */

 34 saved_adv_err_code */

 35 saved_adv_err_addr */

 36 reserved */

 37 reserved */

 38 reserved */

 39 reserved */

 40 reserved */

 41 reserved */

 42 reserved */

 43 reserved */

 44 reserved */

 45 reserved */

 46 reserved */

 47 reserved */

 48 reserved */

 49 reserved */

 50 reserved */

 51 reserved */

 52 reserved */

 53 reserved */

 54 reserved */

 55 reserved */

 56 cisptr_lsw */

 57 cisprt_msw */

 58 subsysvid */

 59 subsysid */

 60 reserved */

 61 reserved */

 62 reserved */

 63 reserved */

 00 cfg_lsw */

 01 cfg_msw */

 02 disc_enable */

 03 wdtr_able */

 04 sdtr_speed1 */

 05 start_motor */

 06 tagqng_able */

 07 bios_scan */

 08 scam_tolerant */

 09 adapter_scsi_id */

    bios_boot_delay */

 10 scsi_reset_delay */

    bios_id_lun */

 11 termination_se */

    termination_lvd */

 12 bios_ctrl */

 13 sdtr_speed2 */

 14 sdtr_speed3 */

 15 max_host_qng */

    max_dvc_qng */

 16 dvc_cntl */

 17 sdtr_speed4 */

 18 serial_number_word1 */

 19 serial_number_word2 */

 20 serial_number_word3 */

 21 check_sum */

 22-29 oem_name[16] */

 30 dvc_err_code */

 31 adv_err_code */

 32 adv_err_addr */

 33 saved_dvc_err_code */

 34 saved_adv_err_code */

 35 saved_adv_err_addr */

 36 reserved */

 37 reserved */

 38 reserved */

 39 reserved */

 40 reserved */

 41 reserved */

 42 reserved */

 43 reserved */

 44 reserved */

 45 reserved */

 46 reserved */

 47 reserved */

 48 reserved */

 49 reserved */

 50 reserved */

 51 reserved */

 52 reserved */

 53 reserved */

 54 reserved */

 55 reserved */

 56 cisptr_lsw */

 57 cisprt_msw */

 58 subsysvid */

 59 subsysid */

 60 reserved */

 61 reserved */

 62 reserved */

 63 reserved */

/*

 * Wait for EEPROM command to complete

/*

 * Read the EEPROM from specified location

/*

 * Write the EEPROM from 'cfg_buf'.

	/*

	 * Write EEPROM from word 0 to word 20.

 Checksum is calculated from word values. */

	/*

	 * Write EEPROM checksum at word 21.

	/*

	 * Write EEPROM OEM name at words 22 to 29.

/*

 * Write the EEPROM from 'cfg_buf'.

	/*

	 * Write EEPROM from word 0 to word 20.

 Checksum is calculated from word values. */

	/*

	 * Write EEPROM checksum at word 21.

	/*

	 * Write EEPROM OEM name at words 22 to 29.

/*

 * Write the EEPROM from 'cfg_buf'.

	/*

	 * Write EEPROM from word 0 to word 20.

 Checksum is calculated from word values. */

	/*

	 * Write EEPROM checksum at word 21.

	/*

	 * Write EEPROM OEM name at words 22 to 29.

/*

 * Read EEPROM configuration into the specified buffer.

 *

 * Return a checksum based on the EEPROM configuration read.

 Checksum is calculated from word values. */

 Read checksum word. */

 Read rest of EEPROM not covered by the checksum. */

/*

 * Read EEPROM configuration into the specified buffer.

 *

 * Return a checksum based on the EEPROM configuration read.

 Checksum is calculated from word values. */

 Read checksum word. */

 Read rest of EEPROM not covered by the checksum. */

/*

 * Read EEPROM configuration into the specified buffer.

 *

 * Return a checksum based on the EEPROM configuration read.

 Checksum is calculated from word values. */

 Read checksum word. */

 Read rest of EEPROM not covered by the checksum. */

/*

 * Read the board's EEPROM configuration. Set fields in ADV_DVC_VAR and

 * ADV_DVC_CFG based on the EEPROM settings. The chip is stopped while

 * all of this is done.

 *

 * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.

 *

 * For a non-fatal error return a warning code. If there are no warnings

 * then 0 is returned.

 *

 * Note: Chip is stopped on entry.

	/*

	 * Read the board's EEPROM configuration.

	 *

	 * Set default values if a bad checksum is found.

		/*

		 * Set EEPROM default values.

		/*

		 * Assume the 6 byte board serial number that was read from

		 * EEPROM is correct even if the EEPROM checksum failed.

	/*

	 * Set ASC_DVC_VAR and ASC_DVC_CFG variables from the

	 * EEPROM configuration that was read.

	 *

	 * This is the mapping of EEPROM fields to Adv Library fields.

	/*

	 * Set the host maximum queuing (max. 253, min. 16) and the per device

	 * maximum queuing (max. 63, min. 4).

 If the value is zero, assume it is uninitialized. */

 If the value is zero, assume it is uninitialized. */

	/*

	 * If 'max_dvc_qng' is greater than 'max_host_qng', then

	 * set 'max_dvc_qng' to 'max_host_qng'.

	/*

	 * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'

	 * values based on possibly adjusted EEPROM values.

	/*

	 * If the EEPROM 'termination' field is set to automatic (0), then set

	 * the ADV_DVC_CFG 'termination' field to automatic also.

	 *

	 * If the termination is specified with a non-zero 'termination'

	 * value check that a legal value is set and set the ADV_DVC_CFG

	 * 'termination' field appropriately.

 auto termination */

 Enable manual control with low off / high off. */

 Enable manual control with low off / high on. */

 Enable manual control with low on / high on. */

			/*

			 * The EEPROM 'termination' field contains a bad value. Use

			 * automatic termination instead.

/*

 * Read the board's EEPROM configuration. Set fields in ADV_DVC_VAR and

 * ADV_DVC_CFG based on the EEPROM settings. The chip is stopped while

 * all of this is done.

 *

 * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.

 *

 * For a non-fatal error return a warning code. If there are no warnings

 * then 0 is returned.

 *

 * Note: Chip is stopped on entry.

	/*

	 * Read the board's EEPROM configuration.

	 *

	 * Set default values if a bad checksum is found.

		/*

		 * Set EEPROM default values.

		/*

		 * Assume the 6 byte board serial number that was read from

		 * EEPROM is correct even if the EEPROM checksum failed.

	/*

	 * Set ADV_DVC_VAR and ADV_DVC_CFG variables from the

	 * EEPROM configuration that was read.

	 *

	 * This is the mapping of EEPROM fields to Adv Library fields.

	/*

	 * For every Target ID if any of its 'sdtr_speed[1234]' bits

	 * are set, then set an 'sdtr_able' bit for it.

	/*

	 * Set the host maximum queuing (max. 253, min. 16) and the per device

	 * maximum queuing (max. 63, min. 4).

 If the value is zero, assume it is uninitialized. */

 If the value is zero, assume it is uninitialized. */

	/*

	 * If 'max_dvc_qng' is greater than 'max_host_qng', then

	 * set 'max_dvc_qng' to 'max_host_qng'.

	/*

	 * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'

	 * values based on possibly adjusted EEPROM values.

	/*

	 * If the EEPROM 'termination' field is set to automatic (0), then set

	 * the ADV_DVC_CFG 'termination' field to automatic also.

	 *

	 * If the termination is specified with a non-zero 'termination'

	 * value check that a legal value is set and set the ADV_DVC_CFG

	 * 'termination' field appropriately.

 auto termination for SE */

 Enable manual control with low off / high off. */

 Enable manual control with low off / high on. */

 Enable manual control with low on / high on. */

			/*

			 * The EEPROM 'termination_se' field contains a bad value.

			 * Use automatic termination instead.

 auto termination for LVD */

 Enable manual control with low off / high off. */

 Enable manual control with low off / high on. */

 Enable manual control with low on / high on. */

			/*

			 * The EEPROM 'termination_lvd' field contains a bad value.

			 * Use automatic termination instead.

/*

 * Read the board's EEPROM configuration. Set fields in ASC_DVC_VAR and

 * ASC_DVC_CFG based on the EEPROM settings. The chip is stopped while

 * all of this is done.

 *

 * On failure set the ASC_DVC_VAR field 'err_code' and return ADV_ERROR.

 *

 * For a non-fatal error return a warning code. If there are no warnings

 * then 0 is returned.

 *

 * Note: Chip is stopped on entry.

	/*

	 * Read the board's EEPROM configuration.

	 *

	 * Set default values if a bad checksum is found.

		/*

		 * Set EEPROM default values.

			/*

			 * Disable Bit 14 (BIOS_ENABLE) to fix SPARC Ultra 60

			 * and old Mac system booting problem. The Expansion

			 * ROM must be disabled in Function 1 for these systems

			/*

			 * Clear the INTAB (bit 11) if the GPIO 0 input

			 * indicates the Function 1 interrupt line is wired

			 * to INTB.

			 *

			 * Set/Clear Bit 11 (INTAB) from the GPIO bit 0 input:

			 *   1 - Function 1 interrupt line wired to INT A.

			 *   0 - Function 1 interrupt line wired to INT B.

			 *

			 * Note: Function 0 is always wired to INTA.

			 * Put all 5 GPIO bits in input mode and then read

			 * their input values.

		/*

		 * Assume the 6 byte board serial number that was read from

		 * EEPROM is correct even if the EEPROM checksum failed.

	/*

	 * Set ASC_DVC_VAR and ASC_DVC_CFG variables from the

	 * EEPROM configuration that was read.

	 *

	 * This is the mapping of EEPROM fields to Adv Library fields.

	/*

	 * For every Target ID if any of its 'sdtr_speed[1234]' bits

	 * are set, then set an 'sdtr_able' bit for it.

	/*

	 * Set the host maximum queuing (max. 253, min. 16) and the per device

	 * maximum queuing (max. 63, min. 4).

 If the value is zero, assume it is uninitialized. */

 If the value is zero, assume it is uninitialized. */

	/*

	 * If 'max_dvc_qng' is greater than 'max_host_qng', then

	 * set 'max_dvc_qng' to 'max_host_qng'.

	/*

	 * Set ASC_DVC_VAR 'max_host_qng' and ASC_DVC_VAR 'max_dvc_qng'

	 * values based on possibly adjusted EEPROM values.

	/*

	 * If the EEPROM 'termination' field is set to automatic (0), then set

	 * the ASC_DVC_CFG 'termination' field to automatic also.

	 *

	 * If the termination is specified with a non-zero 'termination'

	 * value check that a legal value is set and set the ASC_DVC_CFG

	 * 'termination' field appropriately.

 auto termination for SE */

 Enable manual control with low off / high off. */

 Enable manual control with low off / high on. */

 Enable manual control with low on / high on. */

			/*

			 * The EEPROM 'termination_se' field contains a bad value.

			 * Use automatic termination instead.

 auto termination for LVD */

 Enable manual control with low off / high off. */

 Enable manual control with low off / high on. */

 Enable manual control with low on / high on. */

			/*

			 * The EEPROM 'termination_lvd' field contains a bad value.

			 * Use automatic termination instead.

/*

 * Initialize the ADV_DVC_VAR structure.

 *

 * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.

 *

 * For a non-fatal error return a warning code. If there are no warnings

 * then 0 is returned.

	/*

	 * Save the state of the PCI Configuration Command Register

	 * "Parity Error Response Control" Bit. If the bit is clear (0),

	 * in AdvInitAsc3550/38C0800Driver() tell the microcode to ignore

	 * DMA parity errors.

	/*

	 * Reset the chip to start and allow register writes.

		/*

		 * The caller must set 'chip_type' to a valid setting.

		/*

		 * Reset Chip.

	/*

	 * Allocate buffer carrier structures. The total size

	 * is about 8 KB, so allocate all at once.

	/*

	 * Allocate up to 'max_host_qng' request structures for the Wide

	 * board. The total size is about 16 KB, so allocate all at once.

	 * If the allocation fails decrement and try again.

	/*

	 * Allocate up to ADV_TOT_SG_BLOCK request structures for

	 * the Wide board. Each structure is about 136 bytes.

		/*

		 * Even though it isn't used to access wide boards, other

		 * than for the debug line below, save I/O Port address so

		 * that it can be reported.

 CONFIG_PCI */

		/*

		 * Set the board bus type and PCI IRQ before

		 * calling AscInitGetConfig().

 CONFIG_ISA */

 CONFIG_PCI */

		/*

		 * NOTE: AscInitGetConfig() may change the board's

		 * bus_type value. The bus_type value should no

		 * longer be used. If the bus_type field must be

		 * referenced only use the bit-wise AND operator "&".

		/*

		 * For Wide boards set PCI information before calling

		 * AdvInitGetConfig().

 CONFIG_PCI */

	/*

	 * Save the EEPROM configuration so that it can be displayed

	 * from /proc/scsi/advansys/[0...].

		/*

		 * Set the adapter's target id bit in the 'init_tidmask' field.

		/*

		 * Save EEPROM settings for the board.

 'max_tag_qng' is set to the same value for every device. */

		/*

		 * Modify board configuration.

		/*

		 * Save Wide EEP Configuration Information.

		/*

		 * Set the adapter's target id bit in the 'init_tidmask' field.

	/*

	 * Channels are numbered beginning with 0. For AdvanSys one host

	 * structure supports one channel. Multi-channel boards have a

	 * separate host structure for each channel.

 Set maximum number of queues the adapter can handle. */

		/*

		 * Save the I/O Port address and length even though

		 * I/O ports are not used to access Wide boards.

		 * Instead the Wide boards are accessed with

		 * PCI Memory Mapped I/O.

 Set maximum number of queues the adapter can handle. */

	/*

	 * Set the maximum number of scatter-gather elements the

	 * adapter can handle.

		/*

		 * Allow two commands with 'sg_tablesize' scatter-gather

		 * elements to be executed simultaneously. This value is

		 * the theoretical hardware limit. It may be decreased

		 * below.

	/*

	 * The value of 'sg_tablesize' can not exceed the SCSI

	 * mid-level driver definition of SG_ALL. SG_ALL also

	 * must not be exceeded, because it is used to define the

	 * size of the scatter-gather table in 'struct asc_sg_head'.

 BIOS start address. */

		/*

		 * Fill-in BIOS board variables. The Wide BIOS saves

		 * information in LRAM that is used by the driver.

		/*

		 * If the BIOS saved a valid signature, then fill in

		 * the BIOS code segment base address.

			/*

			 * Convert x86 realmode code segment to a linear

			 * address by shifting left 4.

	/*

	 * Register Board Resources - I/O Port, DMA, IRQ

 Register DMA Channel for Narrow boards. */

 Default to no ISA DMA. */

 Register IRQ Number. */

	/*

	 * Initialize board RISC chip and enable interrupts.

/*

 * advansys_release()

 *

 * Release resources allocated for a single AdvanSys adapter.

/*

 * The VLB IRQ number is found in bits 2 to 4 of the CfgLsw.  It decodes as:

 * 000: invalid

 * 001: 10

 * 010: 11

 * 011: 12

 * 100: invalid

 * 101: 14

 * 110: 15

 * 111: invalid

	/*

	 * I don't think this condition can actually happen, but the old

	 * driver did it, and the chances of finding a VLB setup in 2007

	 * to do testing with is slight to none.

/*

 * EISA is a little more tricky than PCI; each EISA device may have two

 * channels, and this driver is written to make each channel its own Scsi_Host

/*

 * The EISA IRQ number is found in bits 8 to 10 of the CfgLsw.  It decodes as:

 * 000: 10

 * 001: 11

 * 010: 12

 * 011: invalid

 * 100: 14

 * 101: 15

 * 110: invalid

 * 111: invalid

		/*

		 * I don't know why we need to do this for EISA chips, but

		 * not for any others.  It looks to be equivalent to

		 * AscGetChipCfgMsw, but I may have overlooked something,

		 * so I'm not converting it until I get an EISA board to

		 * test with.

 PCI Devices supported by this driver */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Detection routine for the NCR53c710 based Amiga SCSI Controllers for Linux.

 *		Amiga Technologies A4000T SCSI controller.

 *

 * Written 1997 by Alan Hourihane <alanh@fairlite.demon.co.uk>

 * plus modifications of the 53c7xx.c driver to support the Amiga.

 *

 * Rewritten to use 53c700.c by Kars de Jong <jongk@linux-m68k.org>

 Fill in the required pieces of hostdata */

 and register the chip */

 SPDX-License-Identifier: GPL-2.0-only

/* mac_esp.c: ESP front-end for Macintosh Quadra systems.

 *

 * Adapted from jazz_esp.c and the old mac_esp.c.

 *

 * The pseudo DMA algorithm is based on the one used in NetBSD.

 * See sys/arch/mac68k/obio/esp.c for some background information.

 *

 * Copyright (C) 2007-2008 Finn Thain

 Nothing to do. */

 Nothing to do. */

 Nothing to do. */

	/*

	 * This is an edge triggered IRQ, so we have to be careful to

	 * avoid missing a transition when it is shared by two ESP devices.

		/* These quadras have a real DMA controller (the PSC) but we

		 * don't know how to drive it so we must use PIO instead.

	/* The request_irq() call is intended to succeed for the first device

	 * and fail for the second device.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *

 *			Linux MegaRAID device driver

 *

 * Copyright (c) 2002  LSI Logic Corporation.

 *

 * Copyright (c) 2002  Red Hat, Inc. All rights reserved.

 *	  - fixes

 *	  - speed-ups (list handling fixes, issued_list, optimizations.)

 *	  - lots of cleanups.

 *

 * Copyright (c) 2003  Christoph Hellwig  <hch@lst.de>

 *	  - new-style, hotplug-aware pci probing and scsi registration

 *

 * Version : v2.00.4 Mon Nov 14 14:02:43 EST 2005 - Seokmann Ju

 * 						<Seokmann.Ju@lsil.com>

 *

 * Description: Linux device driver for LSI Logic MegaRAID controller

 *

 * Supported controllers: MegaRAID 418, 428, 438, 466, 762, 467, 471, 490, 493

 *					518, 520, 531, 532

 *

 * This driver is supported by LSI Logic, with assistance from Red Hat, Dell,

 * and others. Please send updates to the mailing list

 * linux-scsi@vger.kernel.org .

/*

 * Global variables

 For controller re-ordering */

/*

 * The File Operations structure for the serial/ioctl interface of the driver

/*

 * Array to structures for storing the information about the controllers. This

 * information is sent to the user level applications, when they do an ioctl

 * for this information.

 The current driver version */

 major number used by the device for character interface */

/*

 * Debug variable to print some diagnostic messages

/**

 * mega_setup_mailbox()

 * @adapter: pointer to our soft state

 *

 * Allocates a 8 byte aligned memory for the handshake mailbox.

	/*

	 * Register the mailbox if the controller is an io-mapped controller

/*

 * mega_query_adapter()

 * @adapter - pointer to our soft state

 *

 * Issue the adapter inquiry commands to the controller and find out

 * information and parameter about the devices attached

 Initialize adapter inquiry mailbox */

	/*

	 * Try to issue Inquiry3 command

	 * if not succeeded, then issue MEGA_MBOXCMD_ADAPTERINQ command and

	 * update enquiry3 structure

 i.e. mbox->cmd=0xA1 */

 i.e. 0x0F */

 i.e. 0x02 */

 Issue a blocking command to the card */

 the adapter does not support 40ld */

issue old 0x04 command to adapter */

		/*

		 * update Enquiry3 and ProductInfo structures with

		 * mraid_inquiry structure

adapter supports 40ld */

		/*

		 * get product_info, which is static information and will be

		 * unchanged

 i.e. mbox->cmd=0xA1 */

 i.e. 0x0E */

	/*

	 * kernel scans the channels from 0 to <= max_channel

 max targets per channel */

 Up to 7 luns for non disk devices */

	/*

	 * Get the maximum number of scatter-gather elements supported by this

	 * firmware

	/* use HP firmware and bios version encoding

	   Note: fw_version[0|1] and bios_version[0|1] were originally shifted

	   right 8 bits making them zero. This 0 value was hardcoded to fix

	/*

	 * Do we support extended (>10 bytes) cdbs

/**

 * mega_runpendq()

 * @adapter: pointer to our soft state

 *

 * Runs through the list of pending requests.

/*

 * megaraid_queue()

 * @scmd - Issue this scsi command

 * @done - the callback hook into the scsi mid-layer

 *

 * The command queuing entry point for the mid-layer.

	/*

	 * Allocate and build a SCB request

	 * busy flag will be set if mega_build_cmd() command could not

	 * allocate scb. We will return non-zero status in that case.

	 * NOTE: scb can be null even though certain commands completed

	 * successfully, e.g., MODE_SENSE and TEST_UNIT_READY, we would

	 * return 0 in that case.

	/*

	 * Check if the HBA is in quiescent state, e.g., during a

	 * delete logical drive opertion. If it is, don't run

	 * the pending_list.

/**

 * mega_allocate_scb()

 * @adapter: pointer to our soft state

 * @cmd: scsi command from the mid-layer

 *

 * Allocate a SCB structure. This is the central structure for controller

 * commands.

 Unlink command from Free List */

/**

 * mega_get_ldrv_num()

 * @adapter: pointer to our soft state

 * @cmd: scsi mid layer command

 * @channel: channel on the controller

 *

 * Calculate the logical drive number based on the information in scsi command

 * and the channel number.

 we do not get inquires for initiator id */

	/*

	 * If we have a logical drive with boot enabled, project it first

	/*

	 * If "delete logical drive" feature is enabled on this controller.

	 * Do only if at least one delete logical drive operation was done.

	 *

	 * Also, after logical drive deletion, instead of logical drive number,

	 * the value returned should be 0x80+logical drive id.

	 *

	 * These is valid only for IO commands.

/**

 * mega_build_cmd()

 * @adapter: pointer to our soft state

 * @cmd: Prepare using this scsi command

 * @busy: busy flag if no resources

 *

 * Prepares a command and scatter gather list for the controller. This routine

 * also finds out if the commands is intended for a logical drive or a

 * physical device and prepares the controller command accordingly.

 *

 * We also re-order the logical drives and physical devices based on their

 * boot settings.

 logical drive number */

	/*

	 * We know what channels our logical drives are on - mega_find_card()

	/*

	 * The theory: If physical drive is chosen for boot, all the physical

	 * devices are exported before the logical drives, otherwise physical

	 * devices are pushed after logical drives, in which case - Kernel sees

	 * the physical devices on virtual channel which is obviously converted

	 * to actual channel on the HBA.

 logical channel */

 this is physical channel */

			/*

			 * boot from a physical disk, that disk needs to be

			 * exposed first IF both the channels are SCSI, then

			 * booting from the second channel is not allowed.

 this is the logical channel */

 physical channel */

 have just LUN 0 for each target on virtual channels */

		/*

		 * max_ldrv_num increases by 0x80 if some logical drive was

		 * deleted.

			/*

			 * Do not support lun >7 for physically accessed

			 * devices

	/*

	 *

	 * Logical drive commands

	 *

			/*

			 * Do we support clustering and is the support enabled

			 * If no, return success always

 Allocate a SCB and initialize passthru */

 Allocate a SCB and initialize mailbox */

			/*

			 * A little hack: 2nd bit is zero for all scsi read

			 * commands and is set for all scsi write commands

			/*

			 * 6-byte READ(0x08) or WRITE(0x0A) cdb

				/*

				 * Take modulo 0x80, since the logical drive

				 * number increases by 0x80 when a logical

				 * drive was deleted

			/*

			 * 10-byte READ(0x28) or WRITE(0x2A) cdb

			/*

			 * 12-byte READ(0xA8) or WRITE(0xAA) cdb

			/*

			 * If it is a read command

 Calculate Scatter-Gather info */

			/*

			 * Do we support clustering and is the support enabled

 Allocate a SCB and initialize mailbox */

	/*

	 * Passthru drive commands

 Allocate a SCB and initialize passthru */

 Initialize mailbox */

/**

 * mega_prepare_passthru()

 * @adapter: pointer to our soft state

 * @scb: our scsi control block

 * @cmd: scsi command from the mid-layer

 * @channel: actual channel on the controller

 * @target: actual id on the controller.

 *

 * prepare a command for the scsi physical devices.

 0=6sec/1=60sec/2=10min/3=3hrs */

 Not sure about the direction */

 Special Code for Handling READ_CAPA/ INQ using bounce buffers */

/**

 * mega_prepare_extpassthru()

 * @adapter: pointer to our soft state

 * @scb: our scsi control block

 * @cmd: scsi command from the mid-layer

 * @channel: actual channel on the controller

 * @target: actual id on the controller.

 *

 * prepare a command for the scsi physical devices. This rountine prepares

 * commands for devices which can take extended CDBs (>10 bytes)

 0=6sec/1=60sec/2=10min/3=3hrs */

 Not sure about the direction */

 Issue any pending commands to the card */

/**

 * issue_scb()

 * @adapter: pointer to our soft state

 * @scb: scsi control block

 *

 * Post a command to the card if the mailbox is available, otherwise return

 * busy. We also take the scb from the pending list if the mailbox is

 * available.

 Copy mailbox data into host structure */

 Set cmdid */

 Set busy */

	/*

	 * Increment the pending queue counter

	/*

	 * post the command

/*

 * Wait until the controller's mailbox is available

/**

 * issue_scb_block()

 * @adapter: pointer to our soft state

 * @raw_mbox: the mailbox

 *

 * Issue a scb in synchronous and non-interrupt mode

 Wait until mailbox is free */

 Copy mailbox data into host structure */

/**

 * megaraid_isr_iomapped()

 * @irq: irq

 * @devp: pointer to our soft state

 *

 * Interrupt service routine for io-mapped controllers.

 * Find out if our device is interrupting. If yes, acknowledge the interrupt

 * and service the completed commands.

	/*

	 * loop till F/W has more commands for us to complete.

 Check if a valid interrupt is pending */

			/*

			 * No more pending commands

		/*

		 * decrement the pending queue counter

 Acknowledge interrupt */

 Loop through any pending requests */

/**

 * megaraid_isr_memmapped()

 * @irq: irq

 * @devp: pointer to our soft state

 *

 * Interrupt service routine for memory-mapped controllers.

 * Find out if our device is interrupting. If yes, acknowledge the interrupt

 * and service the completed commands.

	/*

	 * loop till F/W has more commands for us to complete.

 Check if a valid interrupt is pending */

			/*

			 * No more pending commands

		/*

		 * decrement the pending queue counter

 Acknowledge interrupt */

 Loop through any pending requests */

/**

 * mega_cmd_done()

 * @adapter: pointer to our soft state

 * @completed: array of ids of completed commands

 * @nstatus: number of completed commands

 * @status: status of the last command completed

 *

 * Complete the commands and call the scsi mid-layer callback hooks.

	/*

	 * for all the commands completed, call the mid-layer callback routine

	 * and free the scb.

		/*

		 * Only free SCBs for the commands coming down from the

		 * mid-layer, not for which were issued internally

		 *

		 * For internal command, restore the status returned by the

		 * firmware so that user can interpret it.

			/*

			 * Make sure f/w has completed a valid command

			/*

			 * Was a abort issued for this command

			/*

			 * Was a reset issued for this command

			/*

			 * Maintain an error counter for the logical drive.

			 * Some application like SNMP agent need such

			 * statistics

				/*

				 * Logical drive number increases by 0x80 when

				 * a logical drive is deleted

				/*

				 * Logical drive number increases by 0x80 when

				 * a logical drive is deleted

		/*

		 * Do not return the presence of hard disk on the channel so,

		 * inquiry sent, and returned data==hard disk or removable

		 * hard disk and not logical, request should return failure! -

		 * PJ

 clear result; otherwise, success returns corrupt value */

 Convert MegaRAID status to Linux error code */

 SUCCESS , i.e. SCSI_STATUS_GOOD */

		case 0x02:	/* ERROR_ABORTED, i.e.

 set sense_buffer and result fields */

		case 0x08:	/* ERR_DEST_DRIVE_FAILED, i.e.

			/*

			 * If TEST_UNIT_READY fails, we know

			 * MEGA_RESERVATION_STATUS failed

			/*

			 * Error code returned is 1 if Reserve or Release

			 * failed or the input parameter is invalid

 Add Scsi_Command to end of completed queue */

/*

 * mega_runpendq()

 *

 * Run through the list of completed requests and finish it

/*

 * Free a SCB structure

 * Note: We assume the scsi commands associated with this scb is not free yet.

	/*

	 * Remove from the pending list

 Link the scb back into free list */

 give up after 1 second */

/*

 * Copies data to SGLIST

 * Note: For 64 bit cards, we need a minimum of one SG element for read/write

	/*

	 * Copy Scatter-Gather list info into controller structure.

	 *

	 * The number of sg elements returned must not exceed our limit

 Reset pointer and length fields */

 Return count of SG requests */

/*

 * mega_8_to_40ld()

 *

 * takes all info in AdapterInquiry structure and puts it into ProductInfo and

 * Enquiry3 structures for later use

/*

 * Get information about the card/driver

/*

 * Abort a previous SCSI request. Only commands on the pending list can be

 * aborted. All the commands issued to the F/W must complete.

	/*

	 * This is required here to complete any completed requests

	 * to be communicated over to the mid layer.

	/*

	 * This is required here to complete any completed requests

	 * to be communicated over to the mid layer.

/**

 * megaraid_abort_and_reset()

 * @adapter: megaraid soft state

 * @cmd: scsi command to be aborted or reset

 * @aor: abort or reset flag

 *

 * Try to locate the scsi command in the pending queue. If found and is not

 * issued to the controller, abort/reset it. Otherwise return failure

 Found command */

			/*

			 * Check if this command has firmware ownership. If

			 * yes, we cannot reset this command. Whenever f/w

			 * completes this command, we will return appropriate

			 * status from ISR.

				/*

				 * Not yet issued! Remove from the pending

				 * list

/**

 * mega_allocate_inquiry()

 * @dma_handle: handle returned for dma address

 * @pdev: handle to pci device

 *

 * allocates memory for inquiry structure

 Following code handles /proc fs  */

/**

 * proc_show_config()

 * @m: Synthetic file construction data

 * @v: File iterator

 *

 * Display configuration information about the controller.

/**

 * proc_show_stat()

 * @m: Synthetic file construction data

 * @v: File iterator

 *

 * Display statistical information about the I/O activity.

/**

 * proc_show_mbox()

 * @m: Synthetic file construction data

 * @v: File iterator

 *

 * Display mailbox information for the last command issued. This information

 * is good for debugging.

/**

 * proc_show_rebuild_rate()

 * @m: Synthetic file construction data

 * @v: File iterator

 *

 * Display current rebuild rate

/**

 * proc_show_battery()

 * @m: Synthetic file construction data

 * @v: File iterator

 *

 * Display information about the battery module on the controller.

	/*

	 * Decode the battery status

/*

 * Display scsi inquiry

/**

 * proc_show_pdrv()

 * @m: Synthetic file construction data

 * @adapter: pointer to our soft state

 * @channel: channel

 *

 * Display information about the physical drives.

		/*

		 * This interface displays inquiries for disk drives

		 * only. Inquries for logical drives and non-disk

		 * devices are available through /proc/scsi/scsi

		/*

		 * Check for overflow. We print less than 240

		 * characters for inquiry

/**

 * proc_show_pdrv_ch0()

 * @m: Synthetic file construction data

 * @v: File iterator

 *

 * Display information about the physical drives on physical channel 0.

/**

 * proc_show_pdrv_ch1()

 * @m: Synthetic file construction data

 * @v: File iterator

 *

 * Display information about the physical drives on physical channel 1.

/**

 * proc_show_pdrv_ch2()

 * @m: Synthetic file construction data

 * @v: File iterator

 *

 * Display information about the physical drives on physical channel 2.

/**

 * proc_show_pdrv_ch3()

 * @m: Synthetic file construction data

 * @v: File iterator

 *

 * Display information about the physical drives on physical channel 3.

/**

 * proc_show_rdrv()

 * @m: Synthetic file construction data

 * @adapter: pointer to our soft state

 * @start: starting logical drive to display

 * @end: ending logical drive to display

 *

 * We do not print the inquiry information since its already available through

 * /proc/scsi/scsi interface

		/*

		 * Check for overflow. We print less than 240 characters for

		 * information about each logical drive.

		/*

		 * Check if check consistency or initialization is going on

		 * for this logical drive.

/**

 * proc_show_rdrv_10()

 * @m: Synthetic file construction data

 * @v: File iterator

 *

 * Display real time information about the logical drives 0 through 9.

/**

 * proc_show_rdrv_20()

 * @m: Synthetic file construction data

 * @v: File iterator

 *

 * Display real time information about the logical drives 0 through 9.

/**

 * proc_show_rdrv_30()

 * @m: Synthetic file construction data

 * @v: File iterator

 *

 * Display real time information about the logical drives 0 through 9.

/**

 * proc_show_rdrv_40()

 * @m: Synthetic file construction data

 * @v: File iterator

 *

 * Display real time information about the logical drives 0 through 9.

/**

 * mega_create_proc_entry()

 * @index: index in soft state array

 * @parent: parent node for this /proc entry

 *

 * Creates /proc entries for our controllers.

/*

 * megaraid_biosparam()

 *

 * Return the disk geometry for a particular disk

 Get pointer to host config structure */

 Default heads (64) & sectors (32) */

			/*

			 * Handle extended translation size for logical drives

			 * > 1Gb

 return result */

 Default heads (64) & sectors (32) */

 Handle extended translation size for logical drives > 1Gb */

 return result */

/**

 * mega_init_scb()

 * @adapter: pointer to our soft state

 *

 * Allocate memory for the various pointers in the scb structures:

 * scatter-gather list pointer, passthru and extended passthru structure

 * pointers.

		/*

		 * Link to free list

		 * lock not required since we are loading the driver, so no

		 * commands possible right now.

/**

 * megadev_open()

 * @inode: unused

 * @filep: unused

 *

 * Routines for the character/ioctl interface to the driver. Find out if this

 * is a valid open. 

	/*

	 * Only allow superuser to access private ioctl interface

/**

 * megadev_ioctl()

 * @filep: Our device file

 * @cmd: ioctl command

 * @arg: user buffer

 *

 * ioctl entry point for our private ioctl interface. We move the data in from

 * the user space, prepare the command (if necessary, convert the old MIMD

 * ioctl to new ioctl command), and issue a synchronous command to the

 * controller.

 user address for passthru */

 copy user passthru here */

 data to be transferred */

 dma handle for data xfer area */

	/*

	 * Make sure only USCSICMD are issued through this interface.

	 * MIMD application would still fire different command.

	/*

	 * Check and convert a possible MIMD command to NIT command.

	 * mega_m_to_n() copies the data from the user space, so we do not

	 * have to do it here.

	 * NOTE: We will need some user address to copyout the data, therefore

	 * the inteface layer will also provide us with the required user

	 * addresses.

		/*

		 * Shucks. MIMD interface returns a positive value for number

		 * of adapters. TODO: Change it to return 0 when there is no

		 * applicatio using mimd interface.

		/*

		 * Which adapter

		/*

		 * Which adapter

		/*

		 * Check for the validity of the logical drive number

		/*

		 * Which adapter

		/*

		 * Deletion of logical drive is a special case. The adapter

		 * should be quiescent before this command is issued.

			/*

			 * Do we support this feature

		/*

		 * This interface only support the regular passthru commands.

		 * Reject extended passthru and 64-bit passthru

		/*

		 * For all internal commands, the buffer must be allocated in

		 * <4GB address range

 Is it a passthru command or a DCMD */

 Passthru commands */

			/*

			 * The user passthru structure

			/*

			 * Copy in the user passthru here.

			/*

			 * Is there a data transfer

				/*

				 * Save the user address and point the kernel

				 * address at just allocated memory

			/*

			 * Is data coming down-stream

				/*

				 * Get the user data

			/*

			 * Issue the command

			/*

			 * Is data going up-stream

			/*

			 * Send the request sense data also, irrespective of

			 * whether the user has asked for it or not.

 DCMD commands */

			/*

			 * Is there a data transfer

			/*

			 * Is data coming down-stream

				/*

				 * Get the user data

			/*

			 * Issue the command

			/*

			 * Is data going up-stream

/**

 * mega_m_to_n()

 * @arg: user address

 * @uioc: new ioctl structure

 *

 * A thin layer to convert older mimd interface ioctl structure to NIT ioctl

 * structure

 *

 * Converts the older mimd ioctl structure to newer NIT structure

	/*

	 * check is the application conforms to NIT. We do not have to do much

	 * in that case.

	 * We exploit the fact that the signature is stored in the very

	 * beginning of the structure.

		/*

		 * NOTE NOTE: The nit ioctl is still under flux because of

		 * change of mailbox definition, in HPE. No applications yet

		 * use this interface and let's not have applications use this

		 * interface till the new specifitions are in place.

	/*

	 * Else assume we have mimd uioctl_t as arg. Convert to nitioctl_t

	 *

	 * Get the user ioctl structure

	/*

	 * Get the opcode and subopcode for the commands

 Query driver version */

 Get # of adapters */

 Get adapter information */

		/*

		 * Choose the xferlen bigger of input and output data

/*

 * mega_n_to_m()

 * @arg: user address

 * @mc: mailbox command

 *

 * Updates the status information to the application, depending on application

 * conforms to older mimd ioctl interface or newer NIT ioctl interface

	/*

	 * check is the application conforms to NIT.

/*

 * MEGARAID 'FW' commands.

/**

 * mega_is_bios_enabled()

 * @adapter: pointer to our soft state

 *

 * issue command to find out if the BIOS is enabled for this controller

/**

 * mega_enum_raid_scsi()

 * @adapter: pointer to our soft state

 *

 * Find out what channels are RAID/SCSI. This information is used to

 * differentiate the virtual channels and physical channels and to support

 * ROMB feature and non-disk devices.

	/*

	 * issue command to find out what channels are raid/scsi

	/*

	 * Non-ROMB firmware fail this command, so all channels

	 * must be shown RAID

/**

 * mega_get_boot_drv()

 * @adapter: pointer to our soft state

 *

 * Find out which device is the boot device. Note, any logical drive or any

 * phyical device (e.g., a CDROM) can be designated as a boot device.

			/*

			 * If MSB is set, a physical drive is set as boot

			 * device

/**

 * mega_support_random_del()

 * @adapter: pointer to our soft state

 *

 * Find out if this controller supports random deletion and addition of

 * logical drives

	/*

	 * issue command

/**

 * mega_support_ext_cdb()

 * @adapter: pointer to our soft state

 *

 * Find out if this firmware support cdblen > 10

	/*

	 * issue command to find out if controller supports extended CDBs.

/**

 * mega_del_logdrv()

 * @adapter: pointer to our soft state

 * @logdrv: logical drive to be deleted

 *

 * Delete the specified logical drive. It is the responsibility of the user

 * app to let the OS know about this operation.

	/*

	 * Stop sending commands to the controller, queue them internally.

	 * When deletion is complete, ISR will flush the queue.

	/*

	 * Wait till all the issued commands are complete and there are no

	 * commands in the pending queue

 sleep for 1s */

	/*

	 * If delete operation was successful, add 0x80 to the logical drive

	 * ids for commands in the pending queue.

 log this event */

	/*

	 * After deleting first logical drive, the logical drives must be

	 * addressed by adding 0x80 to the logical drive id.

/**

 * mega_get_max_sgl()

 * @adapter: pointer to our soft state

 *

 * Find out the maximum number of scatter-gather elements supported by this

 * version of the firmware

		/*

		 * f/w does not support this command. Choose the default value

		/*

		 * Make sure this is not more than the resources we are

		 * planning to allocate

/**

 * mega_support_cluster()

 * @adapter: pointer to our soft state

 *

 * Find out if this firmware support cluster calls.

	/*

	 * Try to get the initiator id. This command will succeed iff the

	 * clustering is available on this HBA.

		/*

		 * Cluster support available. Get the initiator target id.

		 * Tell our id to mid-layer too.

/**

 * mega_adapinq()

 * @adapter: pointer to our soft state

 * @dma_handle: DMA address of the buffer

 *

 * Issue internal commands while interrupts are available.

 * We only issue direct mailbox commands from within the driver. ioctl()

 * interface using these routines can issue passthru commands.

/**

 * mega_internal_dev_inquiry()

 * @adapter: pointer to our soft state

 * @ch: channel for this device

 * @tgt: ID of this device

 * @buf_dma_handle: DMA address of the buffer

 *

 * Issue the scsi inquiry for the specified device.

	/*

	 * For all internal commands, the buffer must be allocated in <4GB

	 * address range

/**

 * mega_internal_command()

 * @adapter: pointer to our soft state

 * @mc: the mailbox command

 * @pthru: Passthru structure for DCDB commands

 *

 * Issue the internal commands in interrupt mode.

 * The last argument is the address of the passthru structure if the command

 * to be fired is a passthru command

 *

 * Note: parameter 'pthru' is null for non-passthru commands.

	/*

	 * The internal commands share one command id and hence are

	 * serialized. This is so because we want to reserve maximum number of

	 * available command ids for the I/O commands.

	/*

	 * Is it a passthru command

	/*

	 * Check if the HBA is in quiescent state, e.g., during a

	 * delete logical drive opertion. If it is, don't run

	 * the pending_list.

	/*

	 * Print a debug message for all failed commands. Applications can use

	 * this information.

	/*

	 * The megaraid3 stuff reports the ID of the Intel part which is not

	 * remotely specific to the megaraid

		/*

		 * Don't fall over the Compaq management cards using the same

		 * PCI identifier

 Now check the magic signature byte */

 Ok it is probably a megaraid */

	/*

	 * For these vendor and device ids, signature offsets are not

	 * valid and 64 bit is implicit

 Read the base port and IRQ from PCI */

 Initialize SCSI Host structure */

	/*

	 * Allocate buffer to issue internal commands.

	/*

	 * Have checks for some buggy f/w

		/*

		 * Which firmware

support."

	/*

	 * If we have a HP 1M(0x60E7)/2M(0x60E8) controller with

	 * firmware H.01.07, H.01.08, and H.01.09 disable 64 bit

	 * support, since this firmware cannot handle 64 bit

	 * addressing

		/*

		 * which firmware

	/*

	 * Find out which channel is raid and which is scsi. This is

	 * for ROMB support.

	/*

	 * Find out if a logical drive is set as the boot drive. If

	 * there is one, will make that as the first logical drive.

	 * ROMB: Do we have to boot from a physical drive. Then all

	 * the physical drives would appear before the logical disks.

	 * Else, all the physical drives would be exported to the mid

	 * layer after logical drives.

	/*

	 * Do we support random deletion and addition of logical

	 * drives

	adapter->read_ldidmap = 0;	/* set it after first logdrv

 Initialize SCBs */

	/*

	 * Reset the pending commands counter

	/*

	 * Reset the adapter quiescent flag

	/*

	 * Fill in the structure which needs to be passed back to the

	 * application when it does an ioctl() for controller related

	 * information.

 Set the Mode of addressing to 64 bit if we can */

	/*

	 * Is cluster support enabled on this controller

	 * Note: In a cluster the HBAs ( the initiators ) will have

	 * different target IDs and we cannot assume it to be 7. Call

	 * to mega_support_cluster() will get the target ids also if

	 * the cluster support is available

 Flush adapter cache */

 Issue a blocking (interrupts disabled) command to the card */

 Flush disks cache */

 Issue a blocking (interrupts disabled) command to the card */

	/*

	 * Have a delibrate delay to make sure all the caches are

	 * actually flushed.

 Free our resources */

	/*

	 * Register the driver as a character device, for applications

	 * to access it for ioctls.

	 * First argument (major) to register_chrdev implies a dynamic

	 * major number allocation.

	/*

	 * Unregister the character device interface to the driver.

 vi: set ts=8 sw=8 tw=78: */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Driver for Adaptec AHA-1542 SCSI host adapters

 *

 *  Copyright (C) 1992  Tommy Thorn

 *  Copyright (C) 1993, 1994, 1995 Eric Youngdale

 *  Copyright (C) 2015 Ondrej Zary

 time AHA spends on the AT-bus during data transfer */

 power-on default: 11us */

 time AHA spends off the bus (not to monopolize it) during data transfer  */

 power-on default: 4us */

 default is jumper selected (J1 on 1542A), factory default = 5 MB/s */

 Default case these days */

 Big disk case */

 This will effectively start both of them at the first mailbox */

 Mapping bios uses - for compatibility */

 bounce buffer */

/*

 * Only used at boot time, so we do not need to worry about latency as much

 * here

 Linked command complete without error and linked normally */

 Linked command complete without error, interrupt generated */

	case 0x11:		/* Selection time out-The initiator selection or target

				 * reselection was not complete within the SCSI Time out period

	case 0x12:		/* Data overrun/underrun-The target attempted to transfer more data

				 * than was allocated by the Data Length field or the sum of the

				 * Scatter / Gather Data Length fields.

 Unexpected bus free-The target dropped the SCSI BSY at an unexpected time. */

	case 0x15:		/* MBO command was not 00, 01 or 02-The first byte of the CB was

				 * invalid. This usually indicates a software failure.

	case 0x16:		/* Invalid CCB Operation Code-The first byte of the CCB was invalid.

				 * This usually indicates a software failure.

	case 0x17:		/* Linked CCB does not have the same LUN-A subsequent CCB of a set

				 * of linked CCB's does not specify the same logical unit number as

				 * the first.

	case 0x18:		/* Invalid Target Direction received from Host-The direction of a

				 * Target Mode CCB was invalid.

	case 0x19:		/* Duplicate CCB Received in Target Mode-More than once CCB was

				 * received to service data transfer between the same target LUN

				 * and initiator SCSI ID in the same direction.

	case 0x1a:		/* Invalid CCB or Segment List Parameter-A segment list with a zero

				 * length segment or invalid segment list boundaries was received.

				 * A CCB parameter was invalid.

 Couldn't find any better */

	case 0x14:		/* Target bus phase sequence failure-An invalid bus phase or bus

				 * phase sequence was requested by the target. The host adapter

				 * will generate a SCSI Reset Condition, notifying the host with

				 * a SCRD interrupt

 Quick and dirty test for presence of the card. */

 Reset the adapter. I ought to make a hard reset, but it's not really necessary */

 In case some other card was probing here, reset interrupts */

 reset interrupts, so they don't block */

|SCRST */ , CONTROL(sh->io_port));

 Wait a little bit for things to settle down. */

 Expect INIT and IDLE, any of the others are bad */

 Shouldn't have generated any interrupts during reset */

	/*

	 * Perform a host adapter inquiry instead so we do not need to set

	 * up the mailboxes ahead of time

 Reading port should reset DF */

 When HACC, command is completed, and we're though testing */

 Clear interrupts */

		/*

		 * Check for unusual interrupts.  If any of these happen, we should

		 * probably do something special, but for now just printing a message

		 * is sufficient.  A SCSI reset detected is something that we really

		 * need to deal with in some way.

 Hmm, no mail.  Must have read it the last time around */

 Aborted command not found */

		/*

		 * Fetch the sense data, and tuck it away, in the required slot.  The

		 * Adaptec automatically fetches it, and there is no guarantee that

		 * we will still have it in the cdb when we come back

 is there mail :-) */

 more error checking left out here */

 This is surely wrong, but I don't know what's right */

		aha1542->int_cmds[mbo] = NULL;	/* This effectively frees up the mailbox slot, as

						 * far as queuecommand is concerned

 Don't do the command - we have the sense data already */

	/*

	 * Use the outgoing mailboxes in a round-robin fashion, because this

	 * is how the host adapter will scan for them

	aha1542->int_cmds[mbo] = cmd;	/* This will effectively prevent someone else from

					 * screwing with this cdb.

 This gets trashed for some reason */

 SCSI Initiator Command */

SCSI Target Id */

 Initialize mailboxes */

 reset interrupts, so they don't block */

		/*

		 * This means that the adapter, although Adaptec 1542 compatible, doesn't use a DMA channel.

		 * Currently only aware of the BusLogic BT-445S VL-Bus adapter which needs this.

/*

 * This function should only be called for 1542C boards - we can detect

 * the special firmware settings and unlock the board

 Query the board to find out if it is a 1542 or a 1740, or whatever. */

 Default case */

	/*

	 * For an AHA1740 series board, we ignore the board since there is a

	 * hardware bug which can lead to wrong blocks being returned if the board

	 * is operating in the 1542 emulation mode.  Since there is an extended mode

	 * driver, we simply ignore the board and let the 1740 driver pick it up.

	/*

	 * Always call this - boards that do not support extended bios translation

	 * will ignore the command, and we will set the proper default

 invalid */

 Set the Bus on/off-times as not to ruin floppy performance */

 return non-zero on detection */

/*

 * This is a device reset.  This is handled by sending a special command

 * to the device.

	aha1542->int_cmds[mbo] = cmd;	/* This will effectively

					 * prevent someone else from

					 * screwing with this cdb.

 This gets trashed for some reason */

 BUS DEVICE RESET */

SCSI Target Id */

	/*

	 * Now tell the 1542 to flush all pending commands for this

	 * target

	/*

	 * This does a scsi reset for all devices on the bus.

	 * In principle, we could also reset the 1542 - should

	 * we do this?  Try this first, and we can add that later

	 * if it turns out to be useful.

	/*

	 * We need to do this too before the 1542 can interact with

	 * us again after host reset.

	/*

	 * Now try to pick up the pieces.  For all pending commands,

	 * free any internal data structures, and basically clear things

	 * out.  We do not try and restart any commands or anything -

	 * the strategy handler takes care of that crap.

				/*

				 * If this device implements the soft reset option,

				 * then it is still holding onto the command, and

				 * may yet complete it.  In this case, we don't

				 * flush the data.

 Please verify that this is the same as what DOS returns */

 heads */

 sectors */

 heads */

 sectors */

 cylinders */

		/*

		 * The card can be queried for its DMA, we have

		 * the DMA set up that is enough

 CONFIG_PNP */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 1999 Eric Youngdale

 * Copyright (C) 2014 Christoph Hellwig

 *

 *  SCSI queueing library.

 *      Initial versions: Eric Youngdale (eric@andante.org).

 *                        Based upon conversations with large numbers

 *                        of people at Linux Expo.

 __scsi_init_queue() */

/*

 * Size of integrity metadata is usually small, 1 inline sg should

 * cover normal cases.

/*

 * When to reinvoke queueing after a resource shortage. It's 3 msecs to

 * not change behaviour from the previous unplug mechanism, experimentation

 * may prove this needs changing.

	/*

	 * Set the appropriate busy bit for the device/host.

	 *

	 * If the host/device isn't busy, assume that something actually

	 * completed, and that we should be able to queue a command now.

	 *

	 * Note that the prior mid-layer assumption that any host could

	 * always queue at least one command is now broken.  The mid-layer

	 * will implement a user specifiable stall (see

	 * scsi_host.max_host_blocked and scsi_device.max_device_blocked)

	 * if a command is requeued with no other commands outstanding

	 * either for the device or for the host.

/**

 * __scsi_queue_insert - private queue insertion

 * @cmd: The SCSI command being requeued

 * @reason:  The reason for the requeue

 * @unbusy: Whether the queue should be unbusied

 *

 * This is a private queue insertion.  The public interface

 * scsi_queue_insert() always assumes the queue should be unbusied

 * because it's always called before the completion.  This function is

 * for a requeue after completion, which should only occur in this

 * file.

	/*

	 * Decrement the counters, since these commands are no longer

	 * active on the host/device.

	/*

	 * Requeue this command.  It will go before all other commands

	 * that are already in the queue. Schedule requeue work under

	 * lock such that the kblockd_schedule_work() call happens

	 * before blk_cleanup_queue() finishes.

/**

 * scsi_queue_insert - Reinsert a command in the queue.

 * @cmd:    command that we are adding to queue.

 * @reason: why we are inserting command to queue.

 *

 * We do this for one of two cases. Either the host is busy and it cannot accept

 * any more commands for the time being, or the device returned QUEUE_FULL and

 * can accept no more commands.

 *

 * Context: This could be called either from an interrupt context or a normal

 * process context.

/**

 * __scsi_execute - insert request and wait for the result

 * @sdev:	scsi device

 * @cmd:	scsi command

 * @data_direction: data direction

 * @buffer:	data buffer

 * @bufflen:	len of buffer

 * @sense:	optional sense buffer

 * @sshdr:	optional decoded sense header

 * @timeout:	request timeout in HZ

 * @retries:	number of times to retry request

 * @flags:	flags for ->cmd_flags

 * @rq_flags:	flags for ->rq_flags

 * @resid:	optional residual length

 *

 * Returns the scsi_cmnd result field if a command was executed, or a negative

 * Linux error code if we didn't get that far.

	/*

	 * head injection *required* here otherwise quiesce won't work

	/*

	 * Some devices (USB mass-storage in particular) may transfer

	 * garbage data together with a residue indicating that the data

	 * is invalid.  Prevent the garbage from being misinterpreted

	 * and prevent security leaks by zeroing out the excess data.

/*

 * Wake up the error handler if necessary. Avoid as follows that the error

 * handler is not woken up if host in-flight requests number ==

 * shost->host_failed: use call_rcu() in scsi_eh_scmd_add() in combination

 * with an RCU read lock in this function to ensure that this function in

 * its entirety either finishes before scsi_eh_scmd_add() increases the

 * host_failed counter or that it notices the shost state change made by

 * scsi_eh_scmd_add().

/*

 * Called for single_lun devices on IO completion. Clear starget_sdev_user,

 * and call blk_run_queue for all the scsi_devices on the target -

 * including current_sdev first.

 *

 * Called with *no* scsi locks held.

	/*

	 * Call blk_run_queue for all LUNs on the target, starting with

	 * current_sdev. We race with others (to set starget_sdev_user),

	 * but in most cases, we will be first. Ideally, each LU on the

	 * target would get some limited time or requests on the target.

		/*

		 * As long as shost is accepting commands and we have

		 * starved queues, call blk_run_queue. scsi_request_fn

		 * drops the queue_lock and can add us back to the

		 * starved_list.

		 *

		 * host_lock protects the starved_list and starved_entry.

		 * scsi_request_fn must get the host_lock before checking

		 * or modifying starved_list or starved_entry.

		/*

		 * Once we drop the host lock, a racing scsi_remove_device()

		 * call may remove the sdev from the starved list and destroy

		 * it and the queue.  Mitigate by taking a reference to the

		 * queue and never touching the sdev again after we drop the

		 * host lock.  Note: if __scsi_remove_device() invokes

		 * blk_cleanup_queue() before the queue is run from this

		 * function then blk_run_queue() will return immediately since

		 * blk_cleanup_queue() marks the queue with QUEUE_FLAG_DYING.

 put any unprocessed entries back */

/**

 * scsi_run_queue - Select a proper request queue to serve next.

 * @q:  last request's queue

 *

 * The previous command was completely finished, start a new one if possible.

		/*

		 * smp_mb() present in sbitmap_queue_clear() or implied in

		 * .end_io is for ordering writing .device_busy in

		 * scsi_device_unbusy() and reading sdev->restarts.

		/*

		 * ->restarts has to be kept as non-zero if new budget

		 *  contention occurs.

		 *

		 *  No need to run queue when either another re-run

		 *  queue wins in updating ->restarts or a new budget

		 *  contention occurs.

 Returns false when no more bytes to process, true if there are more */

	/*

	 * Calling rcu_barrier() is not necessary here because the

	 * SCSI error handler guarantees that the function called by

	 * call_rcu() has been called before scsi_end_request() is

	 * called.

	/*

	 * In the MQ case the command gets freed by __blk_mq_end_request,

	 * so we have to do all cleanup that depends on it earlier.

	 *

	 * We also can't kick the queues from irq context, so we

	 * will have to defer it to a workqueue.

	/*

	 * queue is still alive, so grab the ref for preventing it

	 * from being cleaned up during running queue.

/**

 * scsi_result_to_blk_status - translate a SCSI result code into blk_status_t

 * @cmd:	SCSI command

 * @result:	scsi error code

 *

 * Translate a SCSI result code into a blk_status_t value. May reset the host

 * byte of @cmd->result.

 Helper for scsi_io_completion() when "reprep" action required. */

 A new command will be prepared and issued. */

 Helper for scsi_io_completion() when special action required. */

 false implies "deferred sense" */

		/* Third party bus reset or reset for error recovery

		 * reasons.  Just retry the command and see what

		 * happens.

				/* Detected disc change.  Set a bit

				 * and quietly refuse further access.

				/* Must have been a power glitch, or a

				 * bus reset.  Could not have been a

				 * media change, so we just retry the

				 * command and see what happens.

			/* If we had an ILLEGAL REQUEST returned, then

			 * we may have performed an unsupported

			 * command.  The only thing this should be

			 * would be a ten byte read where only a six

			 * byte read was supported.  Also, on a system

			 * where READ CAPACITY failed, we may have

			 * read past the end of the disk.

 This will issue a new 6-byte command. */

 DIX */ {

 INVALID COMMAND OPCODE or INVALID FIELD IN CDB */

 DIF */

			/* If the device is in the process of becoming

			 * ready, or has a temporary blockage, retry.

 becoming ready */

 format in progress */

 rebuild in progress */

 recalculation in progress */

 operation in progress */

 Long write in progress */

 self test in progress */

 notify (enable spinup) required */

 space allocation in progress */

 start stop unit in progress */

 sanitize in progress */

 configuration in progress */

 depopulation in progress */

 ALUA state transition */

 See SSC3rXX or current. */

 Insufficient zone resources */

 Give up and fail the remainder of the request */

			/*

			 * if logging is enabled the failure will be printed

			 * in scsi_log_completion(), so avoid duplicate messages

 Retry the same command immediately */

 Retry the same command after a delay */

/*

 * Helper for scsi_io_completion() when cmd->result is non-zero. Returns a

 * new result that may suppress further error checking. Also modifies

 * *blk_statp in some cases.

 false implies "deferred sense" */

			/*

			 * SG_IO wants current and deferred errors

		/*

		 * Flush commands do not transfers any data, and thus cannot use

		 * good_bytes != blk_rq_bytes(req) as the signal for an error.

		 * This sets *blk_statp explicitly for the problem case.

	/*

	 * Recovered errors need reporting, but they're always treated as

	 * success, so fiddle the result code here.  For passthrough requests

	 * we already took a copy of the original into sreq->result which

	 * is what gets returned to the user

		/*

		 * if ATA PASS-THROUGH INFORMATION AVAILABLE [0x0, 0x1d]

		 * skip print since caller wants ATA registers. Only occurs

		 * on SCSI ATA PASS_THROUGH commands when CK_COND=1

 for passthrough, *blk_statp may be set */

	/*

	 * Another corner case: the SCSI status byte is non-zero but 'good'.

	 * Example: PRE-FETCH command returns SAM_STAT_CONDITION_MET when

	 * it is able to fit nominated LBs in its cache (and SAM_STAT_GOOD

	 * if it can't fit). Treat SAM_STAT_CONDITION_MET and the related

	 * intermediate statuses (both obsolete in SAM-4) as good.

/**

 * scsi_io_completion - Completion processing for SCSI commands.

 * @cmd:	command that is finished.

 * @good_bytes:	number of processed bytes.

 *

 * We will finish off the specified number of sectors. If we are done, the

 * command block will be released and the queue function will be goosed. If we

 * are not done then we have to figure out what to do next:

 *

 *   a) We can call scsi_io_completion_reprep().  The request will be

 *	unprepared and put back on the queue.  Then a new command will

 *	be created for it.  This should be used if we made forward

 *	progress, or if we want to switch from READ(10) to READ(6) for

 *	example.

 *

 *   b) We can call scsi_io_completion_action().  The request will be

 *	put back on the queue and retried using the same command as

 *	before, possibly after a delay.

 *

 *   c) We can call scsi_end_request() with blk_stat other than

 *	BLK_STS_OK, to fail the remainder of the request.

 a nz result may or may not be an error */

		/*

		 * scsi_result_to_blk_status may have reset the host_byte

	/*

	 * Next deal with any sectors which we were able to correctly

	 * handle.

	/*

	 * Failed, zero length commands always need to drop down

	 * to retry code. Fast path should return in this block.

 no bytes remaining */

 Kill remainder if no retries. */

	/*

	 * If there had been no error, but we have leftover bytes in the

	 * request just queue the command up again.

/**

 * scsi_alloc_sgtables - Allocate and initialize data and integrity scatterlists

 * @cmd: SCSI command data structure to initialize.

 *

 * Initializes @cmd->sdb and also @cmd->prot_sdb if data integrity is enabled

 * for @cmd.

 *

 * Returns:

 * * BLK_STS_OK       - on success

 * * BLK_STS_RESOURCE - if the failure is retryable

 * * BLK_STS_IOERR    - if the failure is fatal

	/*

	 * Make sure there is space for the drain.  The driver must adjust

	 * max_hw_segments to be prepared for this.

	/*

	 * If sg table allocation fails, requeue request later.

	/*

	 * Next, walk the list, and fill in the addresses and sizes of

	 * each segment.

			/*

			 * This can happen if someone (e.g. multipath)

			 * queues a command to a device on an adapter

			 * that does not support DIX.

/**

 * scsi_initialize_rq - initialize struct scsi_cmnd partially

 * @rq: Request associated with the SCSI command to be initialized.

 *

 * This function initializes the members of struct scsi_cmnd that must be

 * initialized before request processing starts and that won't be

 * reinitialized if a SCSI command is requeued.

/*

 * Only called when the request isn't completed by SCSI, and not freed by

 * SCSI

 Called before a request is prepared. See also scsi_mq_prep_fn(). */

	/*

	 * Zero out the cmd, except for the embedded scsi_request. Only clear

	 * the driver-private command data if the LLD does not supply a

	 * function to initialize that data.

	/*

	 * Passthrough requests may transfer data, in which case they must

	 * a bio attached to them.  Or they might contain a SCSI command

	 * that does not transfer data, in which case they may optionally

	 * submit a request without an attached bio.

		/*

		 * If the device is offline we refuse to process any

		 * commands.  The device must be brought online

		 * before trying any recovery commands.

		/*

		 * If the device is fully deleted, we refuse to

		 * process any commands as well.

		/*

		 * If the device is blocked we only accept power management

		 * commands.

		/*

		 * For any other not fully online state we only allow

		 * power management commands.

/*

 * scsi_dev_queue_ready: if we can send requests to sdev, assign one token

 * and return the token else return -1.

		/*

		 * unblock after device_blocked iterates to zero

/*

 * scsi_target_queue_ready: checks if there we can send commands to target

 * @sdev: scsi device on starget to check.

		/*

		 * unblock after target_blocked iterates to zero

/*

 * scsi_host_queue_ready: if we can send requests to shost, return 1 else

 * return 0. We must end up running the queue again whenever 0 is

 * returned, else IO can hang.

		/*

		 * unblock after host_blocked iterates to zero

 We're OK to process the command, so we can't be starved */

/*

 * Busy state exporting function for request stacking drivers.

 *

 * For efficiency, no lock is taken to check the busy state of

 * shost/starget/sdev, since the returned value is not guaranteed and

 * may be changed after request stacking drivers call the function,

 * regardless of taking lock or not.

 *

 * When scsi can't dispatch I/Os anymore and needs to kill I/Os scsi

 * needs to return 'not busy'. Otherwise, request stacking drivers

 * may hold requests forever.

	/*

	 * Ignore host/starget busy state.

	 * Since block layer does not have a concept of fairness across

	 * multiple queues, congestion of host/starget needs to be handled

	 * in SCSI layer.

/*

 * Block layer request completion callback. May be called from interrupt

 * context.

/**

 * scsi_dispatch_cmd - Dispatch a command to the low-level driver.

 * @cmd: command block we are dispatching.

 *

 * Return: nonzero return request was rejected and device's queue needs to be

 * plugged.

 check if the device is still usable */

		/* in SDEV_DEL we error all commands. DID_NO_CONNECT

		 * returns an immediate error upwards, and signals

 Check to see if the scsi lld made this device blocked. */

		/*

		 * in blocked state, the command is just put back on

		 * the device queue.  The suspend state has already

		 * blocked the queue so future requests should not

		 * occur until the device transitions out of the

		 * suspend state.

 Store the LUN value in cmnd, if needed. */

	/*

	 * Before we queue this command, check if the command

	 * length exceeds what the host adapter can handle.

 Size in bytes of the sg-list stored in the scsi-mq command-private data. */

	/*

	 * Special handling for passthrough commands, which don't go to the ULP

	 * at all:

	/*

	 * Orders atomic_inc(&sdev->restarts) and atomic_read(&sdev->device_busy).

	 * .restarts must be incremented before .device_busy is read because the

	 * code in scsi_run_queue_async() depends on the order of these operations.

	/*

	 * If all in-flight requests originated from this LUN are completed

	 * before reading .device_busy, sdev->device_busy will be observed as

	 * zero, then blk_mq_delay_run_hw_queues() will dispatch this request

	 * soon. Otherwise, completion of one of these requests will observe

	 * the .restarts flag, and the request queue will be run for handling

	 * this request, see scsi_end_request().

	/*

	 * If the device is not in running state we will reject some or all

	 * commands.

		/*

		 * Make sure to release all allocated resources when

		 * we hit an error, as we will never see this command

		 * again.

	/*

	 * this limit is imposed by hardware restrictions

	/*

	 * Set a reasonable default alignment:  The larger of 32-byte (dword),

	 * which is a common minimum for HBAs, and the minimum DMA alignment,

	 * which is set by the platform.

	 *

	 * Devices that require a bigger alignment can increase it later.

/**

 * scsi_device_from_queue - return sdev associated with a request_queue

 * @q: The request queue to return the sdev from

 *

 * Return the sdev associated with a request queue or NULL if the

 * request_queue does not reference a SCSI device.

/*

 * pktcdvd should have been integrated into the SCSI layers, but for historical

 * reasons like the old IDE driver it isn't.  This export allows it to safely

 * probe if a given device is a SCSI one and only attach to that.

/**

 * scsi_block_requests - Utility function used by low-level drivers to prevent

 * further commands from being queued to the device.

 * @shost:  host in question

 *

 * There is no timer nor any other means by which the requests get unblocked

 * other than the low-level driver calling scsi_unblock_requests().

/**

 * scsi_unblock_requests - Utility function used by low-level drivers to allow

 * further commands to be queued to the device.

 * @shost:  host in question

 *

 * There is no timer nor any other means by which the requests get unblocked

 * other than the low-level driver calling scsi_unblock_requests(). This is done

 * as an API function so that changes to the internals of the scsi mid-layer

 * won't require wholesale changes to drivers that use this feature.

/**

 *	scsi_mode_select - issue a mode select

 *	@sdev:	SCSI device to be queried

 *	@pf:	Page format bit (1 == standard, 0 == vendor specific)

 *	@sp:	Save page bit (0 == don't save, 1 == save)

 *	@modepage: mode page being requested

 *	@buffer: request buffer (may not be smaller than eight bytes)

 *	@len:	length of request buffer.

 *	@timeout: command timeout

 *	@retries: number of retries before failing

 *	@data: returns a structure abstracting the mode header data

 *	@sshdr: place to put sense data (or NULL if no sense to be collected).

 *		must be SCSI_SENSE_BUFFERSIZE big.

 *

 *	Returns zero if successful; negative error number or scsi

 *	status on error

 *

	/*

	 * Use MODE SELECT(10) if the device asked for it or if the mode page

	 * and the mode select header cannot fit within the maximumm 255 bytes

	 * of the MODE SELECT(6) command.

/**

 *	scsi_mode_sense - issue a mode sense, falling back from 10 to six bytes if necessary.

 *	@sdev:	SCSI device to be queried

 *	@dbd:	set to prevent mode sense from returning block descriptors

 *	@modepage: mode page being requested

 *	@buffer: request buffer (may not be smaller than eight bytes)

 *	@len:	length of request buffer.

 *	@timeout: command timeout

 *	@retries: number of retries before failing

 *	@data: returns a structure abstracting the mode header data

 *	@sshdr: place to put sense data (or NULL if no sense to be collected).

 *		must be SCSI_SENSE_BUFFERSIZE big.

 *

 *	Returns zero if successful, or a negative error number on failure

 allows DBD and LLBA bits */

 caller might not be interested in sense, but we need it */

	/* This code looks awful: what it's doing is making sure an

	 * ILLEGAL REQUEST sense return identifies the actual command

	 * byte as the problem.  MODE_SENSE commands can return

				/*

				 * Invalid command operation code: retry using

				 * MODE SENSE(6) if this was a MODE SENSE(10)

				 * request, except if the request mode page is

				 * too large for MODE SENSE single byte

				 * allocation length field.

 Initio breakage? */

/**

 *	scsi_test_unit_ready - test if unit is ready

 *	@sdev:	scsi device to change the state of.

 *	@timeout: command timeout

 *	@retries: number of retries before failing

 *	@sshdr: outpout pointer for decoded sense information.

 *

 *	Returns zero if unsuccessful or an error if TUR failed.  For

 *	removable media, UNIT_ATTENTION sets ->changed flag.

 try to eat the UNIT_ATTENTION if there are enough retries */

/**

 *	scsi_device_set_state - Take the given device through the device state model.

 *	@sdev:	scsi device to change the state of.

 *	@state:	state to change to.

 *

 *	Returns zero if successful or an error if the requested

 *	transition is illegal.

/**

 *	scsi_evt_emit - emit a single SCSI device uevent

 *	@sdev: associated SCSI device

 *	@evt: event to emit

 *

 *	Send a single uevent (scsi_event) to the associated scsi_device.

 do nothing */

/**

 *	scsi_evt_thread - send a uevent for each scsi event

 *	@work: work struct for scsi_device

 *

 *	Dispatch queued events to their associated scsi_device kobjects

 *	as uevents.

/**

 * 	sdev_evt_send - send asserted event to uevent thread

 *	@sdev: scsi_device event occurred on

 *	@evt: event to send

 *

 *	Assert scsi device event asynchronously.

	/* FIXME: currently this check eliminates all media change events

	 * for polled devices.  Need to update to discriminate between AN

/**

 * 	sdev_evt_alloc - allocate a new scsi event

 *	@evt_type: type of event to allocate

 *	@gfpflags: GFP flags for allocation

 *

 *	Allocates and returns a new scsi_event.

 evt_type-specific initialization, if any */

 do nothing */

/**

 * 	sdev_evt_send_simple - send asserted event to uevent thread

 *	@sdev: scsi_device event occurred on

 *	@evt_type: type of event to send

 *	@gfpflags: GFP flags for allocation

 *

 *	Assert scsi device event asynchronously, given an event type.

/**

 *	scsi_device_quiesce - Block all commands except power management.

 *	@sdev:	scsi device to quiesce.

 *

 *	This works by trying to transition to the SDEV_QUIESCE state

 *	(which must be a legal transition).  When the device is in this

 *	state, only power management requests will be accepted, all others will

 *	be deferred.

 *

 *	Must be called with user context, may sleep.

 *

 *	Returns zero if unsuccessful or an error if not.

	/*

	 * It is allowed to call scsi_device_quiesce() multiple times from

	 * the same context but concurrent scsi_device_quiesce() calls are

	 * not allowed.

	/*

	 * Ensure that the effect of blk_set_pm_only() will be visible

	 * for percpu_ref_tryget() callers that occur after the queue

	 * unfreeze even if the queue was already frozen before this function

	 * was called. See also https://lwn.net/Articles/573497/.

/**

 *	scsi_device_resume - Restart user issued commands to a quiesced device.

 *	@sdev:	scsi device to resume.

 *

 *	Moves the device from quiesced back to running and restarts the

 *	queues.

 *

 *	Must be called with user context, may sleep.

	/* check if the device state was mutated prior to resume, and if

	 * so assume the state is being managed elsewhere (for example

	 * device deleted during suspend)

	/*

	 * The atomic variable of ->queue_stopped covers that

	 * blk_mq_quiesce_queue* is balanced with blk_mq_unquiesce_queue.

	 *

	 * However, we still need to wait until quiesce is done

	 * in case that queue has been stopped.

/**

 * scsi_internal_device_block_nowait - try to transition to the SDEV_BLOCK state

 * @sdev: device to block

 *

 * Pause SCSI command processing on the specified device. Does not sleep.

 *

 * Returns zero if successful or a negative error code upon failure.

 *

 * Notes:

 * This routine transitions the device to the SDEV_BLOCK state (which must be

 * a legal transition). When the device is in this state, command processing

 * is paused until the device leaves the SDEV_BLOCK state. See also

 * scsi_internal_device_unblock_nowait().

	/*

	 * The device has transitioned to SDEV_BLOCK.  Stop the

	 * block layer from calling the midlayer with this device's

	 * request queue.

/**

 * scsi_internal_device_block - try to transition to the SDEV_BLOCK state

 * @sdev: device to block

 *

 * Pause SCSI command processing on the specified device and wait until all

 * ongoing scsi_request_fn() / scsi_queue_rq() calls have finished. May sleep.

 *

 * Returns zero if successful or a negative error code upon failure.

 *

 * Note:

 * This routine transitions the device to the SDEV_BLOCK state (which must be

 * a legal transition). When the device is in this state, command processing

 * is paused until the device leaves the SDEV_BLOCK state. See also

 * scsi_internal_device_unblock().

/**

 * scsi_internal_device_unblock_nowait - resume a device after a block request

 * @sdev:	device to resume

 * @new_state:	state to set the device to after unblocking

 *

 * Restart the device queue for a previously suspended SCSI device. Does not

 * sleep.

 *

 * Returns zero if successful or a negative error code upon failure.

 *

 * Notes:

 * This routine transitions the device to the SDEV_RUNNING state or to one of

 * the offline states (which must be a legal transition) allowing the midlayer

 * to goose the queue for this device.

	/*

	 * Try to transition the scsi device to SDEV_RUNNING or one of the

	 * offlined states and goose the device queue if successful.

/**

 * scsi_internal_device_unblock - resume a device after a block request

 * @sdev:	device to resume

 * @new_state:	state to set the device to after unblocking

 *

 * Restart the device queue for a previously suspended SCSI device. May sleep.

 *

 * Returns zero if successful or a negative error code upon failure.

 *

 * Notes:

 * This routine transitions the device to the SDEV_RUNNING state or to one of

 * the offline states (which must be a legal transition) allowing the midlayer

 * to goose the queue for this device.

	/*

	 * Call scsi_internal_device_block_nowait so we can avoid

	 * calling synchronize_rcu() for each LUN.

	/*

	 * SCSI never enables blk-mq's BLK_MQ_F_BLOCKING flag so

	 * calling synchronize_rcu() once is enough.

/**

 * scsi_kmap_atomic_sg - find and atomically map an sg-elemnt

 * @sgl:	scatter-gather list

 * @sg_count:	number of segments in sg

 * @offset:	offset in bytes into sg, on return offset into the mapped area

 * @len:	bytes to map, on return number of bytes mapped

 *

 * Returns virtual address of the start of the mapped page

 Complete sg-entries */

 Offset starting from the beginning of first page in this sg-entry */

 Assumption: contiguous pages can be accessed as "page + i" */

 Bytes in this sg-entry from *offset to the end of the page */

/**

 * scsi_kunmap_atomic_sg - atomically unmap a virtual address, previously mapped with scsi_kmap_atomic_sg

 * @virt:	virtual address to be unmapped

 not associated with LUN */

 invalid length */

	/*

	 * Order of preference for lun descriptor:

	 * - SCSI name string

	 * - NAA IEEE Registered Extended

	 * - EUI-64 based 16-byte

	 * - EUI-64 based 12-byte

	 * - NAA IEEE Registered

	 * - NAA IEEE Extended

	 * - EUI-64 based 8-byte

	 * - SCSI name string (truncated)

	 * - T10 Vendor ID

	 * as longer descriptors reduce the likelyhood

	 * of identification clashes.

 SCSI name string, variable-length UTF-8 */

 NAA registered extended */

 NAA registered */

 NAA extended */

 NAA locally assigned */

 EUI64-based, 16 byte */

 EUI64-based, 12 byte */

 EUI64-based, 8 byte */

 T10 vendor ID */

/**

 * scsi_vpd_lun_id - return a unique device identification

 * @sdev: SCSI device

 * @id:   buffer for the identification

 * @id_len:  length of the buffer

 *

 * Copies a unique device identification into @id based

 * on the information in the VPD page 0x83 of the device.

 * The string will be formatted as a SCSI name string.

 *

 * Returns the length of the identification or error on failure.

 * If the identifier is longer than the supplied buffer the actual

 * identifier length is returned and the buffer is not zero-padded.

 The id string must be at least 20 bytes + terminating NULL byte */

 T10 Vendor ID */

 EUI-64 */

 NAA */

 SCSI name string */

 Prefer others for truncated descriptor */

/*

 * scsi_vpd_tpg_id - return a target port group identifier

 * @sdev: SCSI device

 *

 * Returns the Target Port Group identifier from the information

 * froom VPD page 0x83 of the device.

 *

 * Returns the identifier or error on failure.

 Relative target port */

 Target port group */

/**

 * scsi_build_sense - build sense data for a command

 * @scmd:	scsi command for which the sense should be formatted

 * @desc:	Sense format (non-zero == descriptor format,

 *              0 == fixed format)

 * @key:	Sense key

 * @asc:	Additional sense code

 * @ascq:	Additional sense code qualifier

 *

/*

 *    Disk Array driver for HP Smart Array SAS controllers

 *    Copyright (c) 2019-2020 Microchip Technology Inc. and its subsidiaries

 *    Copyright 2016 Microsemi Corporation

 *    Copyright 2014-2015 PMC-Sierra, Inc.

 *    Copyright 2000,2009-2015 Hewlett-Packard Development Company, L.P.

 *

 *    This program is free software; you can redistribute it and/or modify

 *    it under the terms of the GNU General Public License as published by

 *    the Free Software Foundation; version 2 of the License.

 *

 *    This program is distributed in the hope that it will be useful,

 *    but WITHOUT ANY WARRANTY; without even the implied warranty of

 *    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or

 *    NON INFRINGEMENT.  See the GNU General Public License for more details.

 *

 *    Questions/Comments/Bugfixes to esc.storagedev@microsemi.com

 *

/*

 * HPSA_DRIVER_VERSION must be 3 byte values (0-255) separated by '.'

 * with an optional trailing '-' followed by a byte value (0-255).

 How long to wait for CISS doorbell communication */

 ms for each msleep() call */

 ms for each msleep() call */

 times 20 ms = 600 s */

 times 10 ms = 20 s */

define how many times we will try a command because of bus resets */

 How long to wait before giving up on a command */

 Embedded module documentation macros - see modules.h */

 define the PCI info for the cards we can control */

/*  board_id = Subsystem Device ID & Vendor ID

 *  product = Marketing Name for the board

 *  access = Address of the struct of function pointers

 alias of 333f */

 performant mode helper functions */

 extract sense key, asc, and ascq from sense data.  -1 means invalid. */

	/*

	 * Note: this REPORT_LUNS_CHANGED condition only occurs on the external

	 * target (array) devices.

 List of controllers which cannot be hard reset on kexec with reset_devices */

 Smart Array P712m */

 Smart Array P711m */

 Smart Array P800 */

 Smart Array P400 */

 Smart Array P400i */

 Smart Array E200i */

 Smart Array E200 */

 Smart Array E200i */

 Smart Array E200i */

 Smart Array E200i */

 Smart Array E500 */

 Smart Array P700m */

 Smart Array 5i */

 Smart Array 6400 */

 Smart Array 6400 EM */

 Smart Array 5300 */

 Smart Array 532 */

 Smart Array 5312 */

 Smart Array 641 */

 Smart Array 642 */

 Smart Array 6i */

 List of controllers which cannot even be soft reset */

 Smart Array 5i */

 Smart Array 5300 */

 Smart Array 532 */

 Smart Array 5312 */

 Smart Array 641 */

 Smart Array 642 */

 Smart Array 6i */

	/* Exclude 640x boards.  These are two pci devices in one slot

	 * which share a battery backed cache module.  One controls the

	 * cache, the other accesses the cache through the one that controls

	 * it.  If we reset the one controlling the cache, the other will

	 * likely not be happy.  Just forbid resetting this conjoined mess.

	 * The 640x isn't really supported by hpsa anyway.

 Smart Array 6400 */

 Smart Array 6400 EM */

 also used for RAID 10 */

 also used for RAID 50 */

 also used for RAID 60 */

 also used for RAID 1+0 ADM */

 Is this even a logical drive? */

 Check for wraparound */

/*

 * There are some special bits in the bus address of the

 * command that we have to set for the controller to know

 * how to process the command:

 *

 * Normal performant mode:

 * bit 0: 1 means performant mode, 0 means simple mode.

 * bits 1-3 = block fetch table entry

 * bits 4-6 = command type (== 0)

 *

 * ioaccel1 mode:

 * bit 0 = "performant mode" bit.

 * bits 1-3 = block fetch table entry

 * bits 4-6 = command type (== 110)

 * (command type is needed because ioaccel1 mode

 * commands are submitted through the same register as normal

 * mode commands, so this is how the controller knows whether

 * the command is normal mode or ioaccel1 mode.)

 *

 * ioaccel2 mode:

 * bit 0 = "performant mode" bit.

 * bits 1-4 = block fetch table entry (note extra bit)

 * bits 4-6 = not needed, because ioaccel2 mode has

 * a separate special register for submitting commands.

/*

 * set_performant_mode: Modify the tag for cciss performant

 * set bit 0 for pull model, bits 3-1 for block fetch

 * register number

	/*

	 * Tell the controller to post the reply to the queue for this

	 * processor.  This seems to give the best I/O throughput.

	/*

	 * Set the bits in the address sent down to include:

	 *  - performant mode bit (bit 0)

	 *  - pull count (bits 1-3)

	 *  - command type (bits 4-6)

	/* Tell the controller to post the reply to the queue for this

	 * processor.  This seems to give the best I/O throughput.

	/* Set the bits in the address sent down to include:

	 *  - performant mode bit not used in ioaccel mode 2

	 *  - pull count (bits 0-3)

	 *  - command type isn't needed for ioaccel2

	/*

	 * Tell the controller to post the reply to the queue for this

	 * processor.  This seems to give the best I/O throughput.

	/*

	 * Set the bits in the address sent down to include:

	 *  - performant mode bit not used in ioaccel mode 2

	 *  - pull count (bits 0-3)

	 *  - command type isn't needed for ioaccel2

/*

 * During firmware flash, the heartbeat register may not update as frequently

 * as it should.  So we dial down lockup detection during firmware flash. and

 * dial it back up when firmware flash completes.

	/*

	 * Check to see if the command is being retried.

	/* finds an unused bus, target, lun for a new physical device

	 * assumes h->devlock is held

 *bus = 1; */

 Add an entry into h->dev[] array. */

 assumes h->devlock is held */

 physical devices do not have lun or target assigned until now. */

 Logical device, lun is already assigned. */

	/* If this device a non-zero lun of a multi-lun device

	 * byte 4 of the 8-byte LUN addr will contain the logical

	 * unit no, zero otherwise.

 This is not a non-zero lun of a multi-lun device */

	/* This is a non-zero lun of a multi-lun device.

	 * Search through our list and find the device which

	 * has the same 8 byte LUN address, excepting byte 4 and 5.

	 * Assign the same bus and target for this new LUN.

	 * Use the logical unit number from the firmware.

 differ only in byte 4 and 5? */

/*

 * Called during a scan operation.

 *

 * Update an entry in h->dev[] array.

 assumes h->devlock is held */

 Raid level changed. */

	/*

	 * ioacccel_handle may have changed for a dual domain disk

 Raid offload parameters changed.  Careful about the ordering. */

		/*

		 * if drive is newly offload_enabled, we want to copy the

		 * raid map data first.  If previously offload_enabled and

		 * offload_config were set, raid map data had better be

		 * the same as it was before. If raid map data has changed

		 * then it had better be the case that

		 * h->dev[entry]->offload_enabled is currently 0.

 set ioaccel_handle *before* hba_ioaccel_enabled */

	/*

	 * We can turn off ioaccel offload now, but need to delay turning

	 * ioaccel on until we can update h->dev[entry]->phys_disk[], but we

	 * can't do that until all the devices are updated.

	/*

	 * turn ioaccel off immediately if told to do so.

 Replace an entry from h->dev[] array. */

 assumes h->devlock is held */

	/*

	 * New physical devices won't have target/lun assigned yet

	 * so we need to preserve the values in the slot we are replacing.

 Remove an entry from h->dev[] array. */

 assumes h->devlock is held */

	/* called when scsi_add_device fails in order to re-adjust

	 * h->dev[] to match the mid layer's view.

	/* we compare everything except lun and target as these

	 * are not yet assigned.  Compare parts likely

	 * to differ first

	/* Device attributes that can change, but don't mean

	 * that the device is a different device, nor that the OS

	 * needs to be told anything about the change.

	/*

	 * This can happen for dual domain devices. An active

	 * path change causes the ioaccel handle to change

	 *

	 * for example note the handle differences between p0 and p1

	 * Device                    WWN               ,WWN hash,Handle

	 * D016 p0|0x3 [02]P2E:01:01,0x5000C5005FC4DACA,0x9B5616,0x01030003

	 *	p1                   0x5000C5005FC4DAC9,0x6798C0,0x00040004

/* Find needle in haystack.  If exact match found, return DEVICE_SAME,

 * and return needle location in *index.  If scsi3addr matches, but not

 * vendor, model, serial num, etc. return DEVICE_CHANGED, and return needle

 * location in *index.

 * In the case of a minor device attribute change, such as RAID level, just

 * return DEVICE_UPDATED, along with the updated device's location in index.

 * If needle not found, return DEVICE_NOT_FOUND.

 previously removed. */

 Keep offline devices offline */

 Check to see if device is already on the list */

 Device is not on the list, add it. */

 Print a message explaining various offline volume states */

/*

 * Figure the list of physical drive pointers for a logical drive with

 * raid offload configured.

		/*

		 * This can happen if a physical drive is removed and

		 * the logical drive is degraded.  In that case, the RAID

		 * map data will refer to a physical disk which isn't actually

		 * present.  And in that case offload_enabled should already

		 * be 0, but we'll turn it off here just in case

		/*

		 * This is correct for reads, too high for full stripe writes,

		 * way too high for partial stripe writes

		/*

		 * If offload is currently enabled, the RAID map and

		 * phys_disk[] assignment *better* not be changing

		 * because we would be changing ioaccel phsy_disk[] pointers

		 * on a ioaccel volume processing I/O requests.

		 *

		 * If an ioaccel volume status changed, initially because it was

		 * re-configured and thus underwent a transformation, or

		 * a drive failed, we would have received a state change

		 * request and ioaccel should have been turned off. When the

		 * transformation completes, we get another state change

		 * request to turn ioaccel back on. In this case, we need

		 * to update the ioaccel information.

		 *

		 * Thus: If it is not currently enabled, but will be after

		 * the scan completes, make sure the ioaccel pointers

		 * are up to date.

 RAID */

 HBA */

 Implied MB */

	/*

	 * Allow for commands to drain

 RAID */

			/*

			 * We don't expect to get here.  Future commands

			 * to this device will get a selection timeout as

			 * if the device were gone.

 HBA */

	/* sd contains scsi3 addresses and devtypes, and inquiry

	 * data.  This function takes what's in sd to be the current

	 * reality and updates h->dev[] to reflect that reality.

	/*

	 * A reset can cause a device status to change

	 * re-schedule the scan to see what happened.

	/* find any devices in h->dev[] that are not in

	 * sd[] and remove them from h->dev[], and for any

	 * devices which have changed, remove the old device

	 * info and add the new device info.

	 * If minor device attributes change, just update

	 * the existing device structure.

 remove ^^^, hence i not incremented */

			/* Set it to NULL to prevent it from being freed

			 * at the bottom of hpsa_update_scsi_devices()

	/* Now, make sure every device listed in sd[] is also

	 * listed in h->dev[], adding them if they aren't found

 if already added above. */

		/* Don't add devices which are NOT READY, FORMAT IN PROGRESS

		 * as the SCSI mid-layer does not handle such devices well.

		 * It relentlessly loops sending TUR at 3Hz, then READ(10)

		 * at 160Hz, and prevents the system from coming up.

 prevent from being freed later. */

 should never happen... */

 but if it does happen, we just ignore that device */

	/*

	 * Now that h->dev[]->phys_disk[] is coherent, we can enable

	 * any logical drives that need it enabled.

	 *

	 * The raid map should be current by now.

	 *

	 * We are updating the device list used for I/O requests.

	/* Monitor devices which are in one of several NOT READY states to be

	 * brought online later. This must be done without holding h->devlock,

	 * so don't touch h->dev[]

 if already added above. */

	/* Don't notify scsi mid layer of any changes the first time through

	 * (or if there are no changes) scsi_scan_host will do it later the

	 * first time through.

 Notify scsi mid layer of any removed devices */

 Notify scsi mid layer of any added devices */

		/* now we have to remove it from h->dev,

		 * since it didn't get added to scsi mid layer

/*

 * Lookup bus/target/lun and return corresponding struct hpsa_scsi_dev_t *

 * Assume's h->devlock is held.

 configure scsi device based on internal per-device structure */

 prevent subsequent unmapping */

 prevent subsequent unmapping */

/* Decode the various types of errors on ioaccel2 path.

 * Return 1 for any error that should generate a RAID path retry.

 * Return 0 for errors that don't require a RAID path retry.

 copy the sense data */

 host byte */

			/*

			 * Did an HBA disk disappear? We will eventually

			 * get a state change event from the controller but

			 * in the meantime, we need to tell the OS that the

			 * HBA disk is no longer there and stop I/O

			 * from going down. This allows the potential re-insert

			 * of the disk to get the same device node.

				/*

				 * Retry by sending down the RAID path.

				 * We will get an event from ctlr to

				 * trigger rescan regardless.

 retry on raid path? */

	/*

	 * Reset c->scsi_cmd here so that the reset handler will know

	 * this command has completed.  Then, check to see if the handler is

	 * waiting for this command, and, if so, wake it.

 Declare command idle before checking for pending events. */

 check for good status */

	/*

	 * Any RAID offload error results in retry which will use

	 * the normal I/O path so the controller can handle whatever is

	 * wrong.

 Returns 0 on success, < 0 otherwise. */

		/*

		 * CISS_TMF_COMPLETE never happens, instead,

		 * ei->CommandStatus == 0 for this case.

 additional sense code */

 additional sense code qualifier */

 undo the DMA mappings */

 host byte */

 SCSI command has already been cleaned up in SML */

	/*

	 * We check for lockup status here as it may be set for

	 * CMD_SCSI, CMD_IOACCEL1 and CMD_IOACCEL2 commands by

	 * fail_all_oustanding_cmds()

 DID_NO_CONNECT will prevent a retry */

	/* For I/O accelerator commands, copy over some fields to the normal

	 * CISS header used below for error handling.

		/* Any RAID offload error results in retry which will use

		 * the normal I/O path so the controller can handle whatever's

		 * wrong.

 an error has occurred */

 copy the sense data */

		/* Problem was not a check condition

		 * Pass it up to the upper layers...

 scsi status is zero??? How??? */

			/* Ordinarily, this case should never happen,

			 * but there is a bug in some released firmware

			 * revisions that allows it to happen if, for

			 * example, a 4100 backplane loses power and

			 * the tape drive is in it.  We assume that

			 * it's a fatal error of some kind because we

			 * can't show that it wasn't. We will make it

			 * look like selection timeout since that is

			 * the most common reason for this to occur,

			 * and it's severe enough.

 let mid layer handle it. */

		/* print_bytes(cp, sizeof(*cp), 1, 0);

		/* We get CMD_INVALID if you address a non-existent device

		 * instead of a selection timeout (no response).  You will

		 * see this if you yank out a drive, then try to access it.

		 * This is kind of a shame because it means that any other

		 * CMD_INVALID (e.g. driver bug) will get interpreted as a

 retry the command */

 TMF failed? */

		/* This only handles the direct pass-through case since RAID

		 * offload is handled above.  Just attempt a retry.

 Prevent subsequent unmap of something never mapped */

 we are not chaining */

 no. SGs contig in this cmd */

 total sgs in cmd list */

 milliseconds */

 TODO: get rid of this no-timeout thing */

 let mid layer handle it. */

		/* controller unfortunately reports SCSI passthru's

		 * to non-existent targets as invalid commands.

 fill_cmd can't fail here, no data buffer to map. */

 no unmap needed here because no data xfer. */

 HBA mode match */

 Possible RAID mode -- check each phys dev. */

			/* FIXME:  Do we need to take out a lock here?  If

			 * so, we could just call hpsa_get_pdisk_of_ioaccel2()

				/* FIXME: an alternate test might be

				 *

				 * match = dev->phys_disk[i]->ioaccel_handle

 The command is in the middle of being initialized. */

 We can really only handle one reset at a time */

 incremented by sending the reset request */

 Show details only if debugging has been activated. */

 @todo in the future, dynamically allocate RAID map memory */

/*

 * get enclosure information

 * struct ReportExtendedLUNdata *rlep - Used for BMIC drive number

 * struct hpsa_scsi_dev_t *encl_dev - device entry for enclosure

 * Uses id_physical_device to determine the box_index.

 Get a device id from inquiry page 0x83 */

 Get the size of the page list first */

 Get the whole VPD page list */

/*

 * Called during a scan operation.

 * Sets ioaccel status on the new device list, not the existing device list

 *

 * The device list used during I/O will be updated later in

 * adjust_hpsa_scsi_table.

		/*

		 * Check to see if offload can be enabled.

 could not load raid_map */

 Get the device id from inquiry page 0x83 */

 Does controller have VPD for device id? */

 not supported */

0 - got id,  otherwise, didn't */

 address the controller */

 REPORT PHYS EXTENDED is not supported */

 Copy ReportLUNdata header */

 Use VPD inquiry to get details of volume status */

 Does controller have VPD for logical volume status? */

 Get the size of the VPD return buffer */

 Now get the whole VPD buffer */

 status byte */

/* Determine offline status of a volume.

 * Return either:

 *  0 (not offline)

 *  0xff (offline for unknown reasons)

 *  # (integer code indicating one of several NOT READY states

 *     describing why a volume is to be kept offline)

 Determine the reason for not ready state */

 Keep volume offline in certain cases: */

		/* If VPD status page isn't available,

		 * use ASC/ASCQ to determine state

 Do an inquiry to the device to see what it is. */

			/*

			 * Legacy boards might not support volume status

		/* See if this is a One-Button-Disaster-Recovery device

		 * by looking for "$DR-10" at offset 43 in inquiry data.

/*

 * Helper function to assign bus, target, lun mapping of devices.

 * Logical drive target and lun are assigned at this time, but

 * physical device lun and target assignment are deferred (assigned

 * in hpsa_find_target_lun, called by hpsa_scsi_add_entry.)

 physical device, target and lun filled in later */

 defer target, lun assignment for physical devices */

 It's a logical device */

	/* In report logicals, local logicals are listed first,

	* then any externals.

 i is in logicals range, but still within local logicals */

 it's an external lun */

/*

 * Do CISS_REPORT_PHYS and CISS_REPORT_LOG.  Data is returned in physdev,

 * logdev.  The number of luns in physdev and logdev are returned in

 * *nphysicals and *nlogicals, respectively.

 * Returns 0 on success, -1 otherwise.

 Reject Logicals in excess of our max capability. */

	/* Helper function, figure out where the LUN ID info is coming from

	 * given index i, lists of physical and logical devices, where in

	 * the list the raid controller is supposed to appear (first or last)

 get physical drive ioaccel handle and queue depth */

 Reserve space for FW operations */

 conservative */

 get number of local logical disks. */

	/*

	 * Spares may be spun down, we do not want to

	 * do an Inquiry to a RAID set spare drive as

	 * that would have them spun up, that is a

	 * performance hit because I/O to the RAID device

	 * stops while the spin up occurs which can take

	 * over 50 seconds.

	/* the idea here is we could get notified

	 * that some devices have changed, so we do a report

	 * physical luns and report logical luns cmd, and adjust

	 * our list of devices accordingly.

	 *

	 * The scsi3addr's of devices won't change so long as the

	 * adapter is not reset.  That means we can rescan and

	 * tell which devices we already know about, vs. new

	 * devices, vs.  disappearing devices.

 cancel scheduled rescan - we're doing it. */

 Set number of local logicals (non PTRAID) */

	/* We might see up to the maximum number of logical and physical disks

	 * plus external target devices, and a device for the local RAID

	 * controller.

 Allocate the per device structures */

 adjust our table of devices */

 Figure out where the LUN ID info is coming from */

 Determine if this is a lun from an external target array */

		/*

		 * Skip over some devices such as a spare.

 Get device type, vendor, model, device id, raid_map */

		/*

		 * Expose all devices except for physical devices that

		 * are masked.

		/*

		 * Get the SAS address for physical devices that are exposed.

			/* We don't *really* support actual CD-ROM devices,

			 * just "One Button Disaster Recovery" tape drive

			 * which temporarily pretends to be a CD-ROM drive.

			 * So we check that the device is really an OBDR tape

			 * device by checking for "$DR-10" in bytes 43-48 of

			 * the inquiry data.

 The disk is in HBA mode. */

 Never use RAID mapper in HBA mode. */

			/* Only present the Smartarray HBA as a RAID controller.

			 * If it's a RAID controller other than the HBA itself

			 * (an external RAID controller, MSA500 or similar)

			 * don't present it.

/*

 * hpsa_scatter_gather takes a struct scsi_cmnd, (cmd), and does the pci

 * dma mapping  and fills in the scatter gather entries of the

 * hpsa command, cp.

	/*

	 * If the number of entries is greater than the max for a single list,

	 * then we have a chained list; we will set up all but one entry in the

	 * first list (the last entry is saved for link information);

	 * otherwise, we don't have a chained list and we'll set up at each of

	 * the entries in the one list.

		/*

		 * Continue with the chained list.  Set curr_sg to the chained

		 * list.  Modify the limit to the total count less the entries

		 * we've already set up.  Resume the scan at the list entry

		 * where the previous loop left off.

 Back the pointer up to the last entry and mark it as "last". */

 no. SGs contig in this cmd */

 total sgs in cmd list */

 zero-length transfers trigger hardware errors. */

 Block zero-length transfer sizes on certain commands. */

 0x2F */

 0x2E */

 0xAF */

 0xAE */

 0x8F */

 Perform some CDB fixups if needed using 10 byte reads/writes only */

 TODO: implement chaining support */

 Adjust the DMA address to point to the accelerated command buffer */

 Fill out the command structure to submit */

 Tag was already set at init time. */

/*

 * Queue a command directly to a device behind the controller using the

 * I/O accelerator path.

/*

 * Set encryption parameters for the ioaccel2 request

 Are we doing encryption on this device */

 Set the data encryption key index. */

 Set the encryption enable flag, encoded into direction field. */

	/* Set encryption tweak values based on logical block address

	 * If block size is 512, tweak value is LBA.

	 * For other block sizes, tweak is (LBA * block size)/ 512)

 Required? 6-byte cdbs eliminated by fixup_ioaccel_cdb */

 Required? 12-byte cdbs eliminated by fixup_ioaccel_cdb */

 Adjust the DMA address to point to the accelerated command buffer */

		/*

		 * Set the last s/g element bit

 Set encryption parameters, if necessary */

 fill in sg elements */

/*

 * Queue a command to the correct I/O accelerator path.

 Try to honor the device's queue depth */

 use physical disk in the first mirrored group. */

 determine mirror group that *map_index indicates */

 select map index from next group */

 select map index from first group */

/*

 * Attempt to perform offload RAID mapping for a logical volume I/O.

 check for valid opcode, get LBA and block count */

 process via normal I/O path */

 check for write to non-RAID-0 */

 check for invalid block or wraparound */

 calculate stripe information for the request */

 if this isn't a single row/column then give to the controller */

 proceeding with driver mapping */

 nothing special to do */

		/* Handles load balance across RAID 1 members.

		 * (2-drive R1 and R10 with even # of drives.)

		 * Appropriate for SSDs, not optimal for HDDs

		 * Ensure we have the correct raid_map.

		/* Handles N-way mirrors  (R1-ADM)

		 * and R10 with # of drives divisible by 3.)

		 * Ensure we have the correct raid_map.

 set mirror group to use next time */

		/* Avoid direct use of dev->offload_to_mirror within this

		 * function since multiple threads might simultaneously

		 * increment it beyond the range of dev->layout_map_count -1.

 Verify first and last block are in same RAID group */

 Verify request is in a single row of RAID 5/6 */

 Verify request is in a single column */

 Request is eligible */

 handle differing logical/physical block sizes */

 build the new CDB for the physical disk I/O */

/*

 * Submit commands down the "normal" RAID stack path

 * All callers to hpsa_ciss_submit must check lockup_detected

 * beforehand, before (opt.) and after calling cmd_alloc

 unused in simple mode */

 Fill in the request block... */

		/* This can happen if a buggy application does a scsi passthru

		 * and sets both inlen and outlen to non-zero. ( see

		 * ../scsi/scsi_ioctl.c:scsi_ioctl_send_command() )

		/* This is technically wrong, and hpsa controllers should

		 * reject it with CMD_INVALID, which is the most correct

		 * response, but non-fibre backends appear to let it

		 * slide by, and give the same results as if this field

		 * were set correctly.  Either way is acceptable for

		 * our purposes here.

 Fill SG list */

 the cmd'll come back via intr handler in complete_scsi_command()  */

 Zero out all of commandlist except the last field, refcount */

 Zeroes out all fields */

 Resubmit but do not increment device->commands_outstanding. */

 scsi_dma_map failed. */

 Zeroes out all fields */

 Resubmit but do not increment device->commands_outstanding. */

 scsi_dma_map failed. */

 Resubmit with the retry_pending flag set. */

				/*

				 * If we get here, it means dma mapping failed.

				 * Try again via scsi mid layer, which will

				 * then get SCSI_MLQUEUE_HOST_BUSY.

 else, fall thru and resubmit down CISS path */

	/*

	 * Here we have not come in though queue_command, so we

	 * can set the retry_pending flag to true for a driver initiated

	 * retry attempt (I.E. not a SML retry).

	 * I.E. We are submitting a driver initiated retry.

	 * Note: hpsa_ciss_submit does not zero out the command fields like

	 *       ioaccel submit does.

		/*

		 * If we get here, it means dma mapping failed. Try

		 * again via scsi mid layer, which will then get

		 * SCSI_MLQUEUE_HOST_BUSY.

		 *

		 * hpsa_ciss_submit will have already freed c

		 * if it encountered a dma mapping failure.

 Running in struct Scsi_Host->host_lock less mode */

 Get the ptr to our adapter structure out of cmd->host. */

	/*

	 * This is necessary because the SML doesn't zero out this field during

	 * error recovery.

	/*

	 * Call alternate submit routine for I/O accelerated commands.

	 * Retries always go down the normal I/O path.

	 * Note: If cmd->retries is non-zero, then this is a SML

	 *       initiated retry and not a driver initiated retry.

	 *       This command has been obtained from cmd_tagged_alloc

	 *       and is therefore a brand-new command.

 Submit with the retry_pending flag unset. */

	/*

	 * Don't let rescans be initiated on a controller known to be locked

	 * up.  If the controller locks up *during* a rescan, that thread is

	 * probably hosed, but at least we can prevent new rescan threads from

	 * piling up on a locked up controller.

	/*

	 * If a scan is already waiting to run, no need to add another

 wait until any scan already in progress is finished. */

		/* Note: We don't need to worry about a race between this

		 * thread and driver unload because the midlayer will

		 * have incremented the reference count, so unload won't

		 * happen if we're in here.

 mark scan as in progress */

	/*

	 * Do the scan after a reset completion

/*

 * The block layer has already gone to the trouble of picking out a unique,

 * small-integer tag for this request.  We use an offset from that value as

 * an index to select our command block.  (The offset allows us to reserve the

 * low-numbered entries for our own uses.)

 Offset to leave space for internal cmds. */

/*

 * Send a TEST_UNIT_READY command to the specified LUN using the specified

 * reply queue; returns zero if the unit is ready, and non-zero otherwise.

 Send the Test Unit Ready, fill_cmd can't fail, no mapping */

 no unmap needed here because no data xfer. */

 Check if the unit is already ready. */

	/*

	 * The first command sent after reset will receive "unit attention" to

	 * indicate that the LUN has been reset...this is actually what we're

	 * looking for (but, success is good too).

/*

 * Wait for a TEST_UNIT_READY command to complete, retrying as necessary;

 * returns zero when the unit is ready, and non-zero when giving up.

 seconds */

 Send test unit ready until device ready, or give up. */

		/*

		 * Wait for a bit.  do this first, because if we send

		 * the TUR right away, the reset will just abort it.

 Increase wait time with each try, up to a point. */

	/*

	 * If no specific reply queue was requested, then send the TUR

	 * repeatedly, requesting a reply on each reply queue; otherwise execute

	 * the loop exactly once using only the specified queue.

/* Need at least one of these error handlers to keep ../scsi/hosts.c from

 * complaining.  Doing a host- or bus-reset can't do anything good here.

 find the controller to which the command to be aborted was sent */

 paranoia */

 if controller locked up, we can guarantee command won't complete */

 this reset request might be the result of a lockup; check */

 Do not attempt on controller */

	/*

	 * wait to see if any commands will complete before sending reset

 block any new cmds from OS for this device */

 send a reset to the SCSI LUN which the command was sent to */

/*

 * For operations with an associated SCSI command, a command block is allocated

 * at init, and managed by cmd_tagged_alloc() and cmd_tagged_free() using the

 * block request tag as an index into a table of entries.  cmd_tagged_free() is

 * the complement, although cmd_free() may be called instead.

 * This function is only called for new requests from queue_command.

		/* The index value comes from the block layer, so if it's out of

		 * bounds, it's probably not our bug.

		/*

		 * We expect that the SCSI layer will hand us a unique tag

		 * value.  Thus, there should never be a collision here between

		 * two requests...because if the selected command isn't idle

		 * then someone is going to be very disappointed.

 Print once per tag */

	/*

	 * This is a new command obtained from queue_command so

	 * there have not been any driver initiated retry attempts.

	/*

	 * Release our reference to the block.  We don't need to do anything

	 * else to free it, because it is accessed by index.

/*

 * For operations that cannot sleep, a command block is allocated at init,

 * and managed by cmd_alloc() and cmd_free() using a simple bitmap to track

 * which ones are free or in use.  Lock must be held when calling this.

 * cmd_free() is the complement.

 * This function never gives up and returns NULL.  If it hangs,

 * another thread must call cmd_free() to free some tags.

	/*

	 * There is some *extremely* small but non-zero chance that that

	 * multiple threads could get in here, and one thread could

	 * be scanning through the list of bits looking for a free

	 * one, but the free ones are always behind him, and other

	 * threads sneak in behind him and eat them before he can

	 * get to them, so that while there is always a free one, a

	 * very unlucky thread might be starved anyway, never able to

	 * beat the other threads.  In reality, this happens so

	 * infrequently as to be indistinguishable from never.

	 *

	 * Note that we start allocating commands before the SCSI host structure

	 * is initialized.  Since the search starts at bit zero, this

	 * all works, since we have at least one command structure available;

	 * however, it means that the structures with the low indexes have to be

	 * reserved for driver-initiated requests, while requests from the block

	 * layer will use the higher indexes.

 already in use */

 it's ours now. */

	/*

	 * cmd_alloc is for "internal" commands and they are never

	 * retried.

/*

 * This is the complementary operation to cmd_alloc().  Note, however, in some

 * corner cases it may also be used to free blocks allocated by

 * cmd_tagged_alloc() in which case the ref-count decrement does the trick and

 * the clear-bit is harmless.

 Copy the data into the buffer we created */

 Fill in the command type */

 Fill in Command Header */

 unused in simple mode */

 buffer to fill */

 no buffers to fill */

 Fill in Request block */

 Fill in the scatter gather information */

 not chaining */

 Copy the error information out */

 Copy the data out of the buffer we created */

 Check kmalloc limits  using all SGs */

 Copy the error information out */

 Copy the data out of the buffer we created */

/*

 * ioctl

 fill_cmd can't fail here, no data buffer to map */

 fill_cmd defaults to target reset */

	/* Don't wait for completion, the reset won't complete.  Don't free

	 * the command either.  This is the last command we will send before

	 * re-initializing everything, so it doesn't matter and won't leak.

 are we trying to read a vital product page */

			/* Talking to controller so It's a physical command

			   mode = 00 target = 0.  Nothing to write.

 MSB */

 Spec says this should be BMIC_WRITE */

 MSB */

 Don't time out */

 Physical target reset needs no control bytes 4-7*/

 Don't time out */

 If bytes 4-7 are zero, it means reset the */

 LunID device */

/*

 * Map (physical) PCI mem into (virtual) kernel space

 process completion of an indexed ("direct lookup") command */

/* Some controllers, like p400, will give us one interrupt

 * after a soft reset, even if we turned interrupts off.

 * Only need to check for this in the hpsa_xxx_discard_completions

 * functions.

/*

 * Convert &h->q[x] (passed to interrupt handlers) back to h.

 * Relies on (h-q[x] == x) being true for x such that

 * 0 <= x < MAX_REPLY_QUEUES.

/* Send a message CDB to the firmware. Careful, this only works

 * in simple mode, not performant mode due to the tag lookup.

 * We only ever use this immediately after a controller reset.

	/* The Inbound Post Queue only accepts 32-bit physical addresses for the

	 * CCISS commands, so they must be allocated from the lower 4GiB of

	 * memory.

	/* This must fit, because of the 32-bit consistent DMA mask.  Also,

	 * although there's no guarantee, we assume that the address is at

	 * least 4-byte aligned (most likely, it's page-aligned).

 Don't time out */

 rest of the CDB is reserved */

	/* we leak the DMA buffer here ... no choice since the controller could

	 *  still complete the command.

		/* For everything after the P600, the PCI power state method

		 * of resetting the controller doesn't work, so we have this

		 * other way using the doorbell register.

		/* PMC hardware guys tell us we need a 10 second delay after

		 * doorbell reset and before any attempt to talk to the board

		 * at all to ensure that this actually works and doesn't fall

		 * over in some weird corner cases.

 Try to do it the PCI power state way */

		/* Quoting from the Open CISS Specification: "The Power

		 * Management Control/Status Register (CSR) controls the power

		 * state of the device.  The normal operating state is D0,

		 * CSR=00h.  The software off state is D3, CSR=03h.  To reset

		 * the controller, place the interface device in D3 then to D0,

		 * this causes a secondary PCI reset which will reset the

 enter the D3hot power management state */

 enter the D0 power management state */

		/*

		 * The P600 requires a small delay when changing states.

		 * Otherwise we may think the board did not reset and we bail.

		 * This for kdump only and is particular to the P600.

	/* After a reset, the 32 bytes of "driver version" in the cfgtable

	 * should have been changed, otherwise we know the reset failed.

/* This does a hard reset of the controller using PCI power management

 * states or the using the doorbell register.

	/* For controllers as old as the P600, this is very nearly

	 * the same thing as

	 *

	 * pci_save_state(pci_dev);

	 * pci_set_power_state(pci_dev, PCI_D3hot);

	 * pci_set_power_state(pci_dev, PCI_D0);

	 * pci_restore_state(pci_dev);

	 *

	 * For controllers newer than the P600, the pci power state

	 * method of resetting doesn't work so we have another way

	 * using the doorbell register.

 if controller is soft- but not hard resettable... */

 try soft reset later. */

 Save the PCI command register */

 find the first memory BAR, so we can find the cfg table */

 find cfgtable in order to check if reset via doorbell is supported */

	/* If reset via doorbell register is supported, use that.

	 * There are two such methods.  Favor the newest method.

 try soft reset */

	/* Some devices (notably the HP Smart Array 5i Controller)

/*

 *  We cannot read the structure directly, for portability we must use

 *   the io functions.

 *   This is for debug only.

 HPSA_DEBUG */

 looking for BAR zero? */

 32 bit */

 reserved in PCI 2.2 */

/* If MSI/MSI-X is supported by the kernel we will try to enable it on

 * controllers that are capable. If not, we use legacy INTx mode.

 Some boards advertise MSI but don't really support it */

 generic unknown smart array */

 addressing mode bits already removed */

/* Find and map CISS config table and transfer table

+ * several items must be unmapped (freed) later

 Find performant mode table. */

 Limit commands in memory limited kdump scenario. */

/* If the controller reports that the total max sg entries is greater than 512,

 * then we know that chained SG blocks work.  (Original smart arrays did not

 * support chained SG blocks and would return zero for max sg entries.)

/* Interrogate the hardware for some limits:

 * max commands, max SG elements without chaining, and with chaining,

 * SG chain block size, etc.

 Limit in-command s/g elements to 32 save dma'able memory. */

 save one for chain pointer */

		/*

		 * Original smart arrays supported at most 31 s/g entries

		 * embedded inline in the command (trying to use more

		 * would lock up the controller)

 default to traditional values */

 Find out what task management functions are supported and cache */

 Need to enable prefetch in the SCSI core for 6400 in x86 */

/* Disable DMA prefetch for the P600.  Otherwise an ASIC bug may result

 * in a prefetch beyond physical memory.

 wait until the clear_event_notify bit 6 is cleared by controller. */

 delay and try again */

	/* under certain very rare conditions, this can take awhile.

	 * (e.g.: hot replace a failed 144GB drive in a RAID 5 set right

	 * as we enter this code.)

 delay and try again */

 return -ENODEV or other reason on error, 0 on success */

 Update the field, and then ring the doorbell */

 free items allocated or mapped by hpsa_pci_init */

 pci_init 4 */

 pci_init 3 */

 pci_init 2 */

	/*

	 * call pci_disable_device before pci_release_regions per

	 * Documentation/driver-api/pci/pci.rst

 pci_init 1 */

 pci_init 2 */

 several items must be freed later */

 setup mapping between CPU and reply queue */

 intmode+region, pci */

 intmode+region, pci */

 vaddr, intmode+region, pci */

 vaddr, intmode+region, pci */

 cfgtables, vaddr, intmode+region, pci */

 cfgtables, vaddr, intmode+region, pci */

 cfgtables, vaddr, intmode+region, pci */

 vaddr, intmode+region, pci */

 intmode+region, pci */

	/*

	 * call pci_disable_device before pci_release_regions per

	 * Documentation/driver-api/pci/pci.rst

	/* kdump kernel is loading, we don't know in which state is

	 * the pci interface. The dev->enable_cnt is equal zero

	 * so we call enable+disable, wait a while and switch it on.

 a randomly chosen number */

 Reset the controller with a PCI power-cycle or via doorbell */

	/* -ENOTSUPP here means we cannot reset the controller

	 * but it's already (and still) up and running in

	 * "performant mode".  Or, it might be 640x, which can't reset

	 * due to concerns about shared bbwc between 6402/6404 pair.

 Now try to get the controller to respond to a no-op */

 clear affinity hints and free MSI-X, MSI, or legacy INTx vectors */

 Single reply queue, only one irq to free */

 returns 0 on success; cleans up and returns -Enn on error */

	/*

	 * initialize h->q[x] = x so that interrupt handlers know which

	 * queue to process.

 If performant mode and MSI-X, use multiple reply queues */

 Use single reply pool */

 init_one 7 */

 init_one 6 */

 init_one 5 */

 init_one 4 */

 init_one 3 */

 init_one 3 */

 init_one 2_5 */

 init_one 2 */

 init_one 2 */

 init_one 1 */

 init_one 1 */

 Called when controller lockup detected. */

 ensure all cmds are fully built */

 be sure the per-cpu variables are out to memory */

 no heartbeat, but controller gave us a zero. */

 If we've received an interrupt recently, we're ok. */

	/*

	 * If we've already checked the heartbeat recently, we're ok.

	 * This could happen if someone sends us a signal. We

	 * otherwise don't care about signals in this thread.

 If heartbeat has not changed since we last looked, we're not ok. */

 We're ok. */

/*

 * Set ioaccel status for all ioaccel volumes.

 *

 * Called from monitor controller worker (hpsa_event_monitor_worker)

 *

 * A Volume (or Volumes that comprise an Array set) may be undergoing a

 * transformation, so we will be turning off ioaccel for all volumes that

 * make up the Array.

	/*

	 * Run through current device list used during I/O requests.

		/*

		 * Check if offload is still configured on

		/*

		 * If offload is configured on, check to see if ioaccel

		 * needs to be enabled.

		/*

		 * If ioaccel is to be re-enabled, re-enable later during the

		 * scan operation so the driver can get a fresh raidmap

		 * before turning ioaccel back on.

		/*

		 * Immediately turn off ioaccel for any volume the

		 * controller tells us to. Some of the reasons could be:

		 *    transformation - change to the LVs of an Array.

		 *    degraded volume - component failure

 Ask the controller to clear the events we're handling. */

 Stop sending new RAID offload reqs via the IO accelerator */

 Set 'accelerator path config change' bit */

 Set the "clear event notify field update" bit 6 */

 Wait until ctlr clears 'clear event notify field', bit 6 */

 Acknowledge controller notification events. */

/* Check a register on the controller to see if there are configuration

 * changes (added/changed/removed logical drives, etc.) which mean that

 * we should rescan the controller for devices.

 * Also check flag for driver-initiated rescan.

/*

 * Check if any of the offline devices have become ready

 assume there are changes */

	/* if we can't find out if lun data has changed,

	 * assume that it has.

 no changes detected. */

	/*

	 * Do the scan after the reset

/*

 * watch for controller events

		/* If the reset fails in a particular way (it has no way to do

		 * a proper hard reset, so returns -ENOTSUPP) we can try to do

		 * a soft reset once we get the controller configured up to the

		 * point that it can accept a command.

	/* Command structures must be aligned on a 32-byte boundary because

	 * the 5 lower bits of the address are used by the hardware. and by

	 * the driver.  See comments in hpsa.h for more info.

 Allocate and clear per-cpu variable lockup_detected */

 aer/h */

 lu, aer/h */

	/* relies on h-> settings made by hpsa_pci_init, including

 pci, lu, aer/h */

 configure PCI DMA stuff */

 shost, pci, lu, aer/h */

 make sure the board interrupts are off */

 shost, pci, lu, aer/h */

 irq, shost, pci, lu, aer/h */

 cmd, irq, shost, pci, lu, aer/h */

 no scan currently in progress */

 sg, cmd, irq, shost, pci, lu, aer/h */

 create the resubmit workqueue */

 aer/h */

	/*

	 * At this point, the controller is ready to take commands.

	 * Now, if reset_devices and the hard reset didn't work, try

	 * the soft reset and see if that works.

		/* This is kind of gross.  We may or may not get a completion

		 * from the soft reset command, and if we do, then the value

		 * from the fifo may or may not be valid.  So, we wait 10 secs

		 * after the reset throwing away any completions we get during

		 * that time.  Unregister the interrupt handler and register

		 * fake ones to scoop up any residual completions.

			/*

			 * cannot goto clean7 or free_irqs will be called

			 * again. Instead, do its work

 clean7 */

 clean6 */

 clean5 */

			/*

			 * skip hpsa_free_irqs(h) clean4 since that

			 * was just called before request_irqs failed

 Neither hard nor soft reset worked, we're hosed. */

		/* since the controller's reset, we have to go back and re-init

		 * everything.  Easiest to just forget what we've done and do it

		 * all over again.

 don't goto clean, we already unallocated */

 Enable Accelerated IO path at driver layer */

 Disable discovery polling.*/

 Turn the interrupts on so we can service requests */

 hook into SCSI subsystem */

 lastlogicals, perf, sg, cmd, irq, shost, pci, lu, aer/h */

 Monitor the controller for firmware lockups */

 lastlogicals, perf, sg, cmd, irq, shost, pci, lu, aer/h */

 perf, sg, cmd, irq, shost, pci, lu, aer/h */

 sg, cmd, irq, pci, lockup, wq/aer/h */

 cmd, irq, shost, pci, lu, aer/h */

 irq, shost, pci, lu, aer/h */

 shost, pci, lu, aer/h */

 pci, lu, aer/h */

 lu, aer/h */

 wq/aer/h */

/* Make controller gather fresh report lun data each time we

 * send down a report luns request

 Don't bother trying to set diag options if locked up */

 first, get the current diag options settings */

 Now, set the bit for disabling the RLD caching */

 Now verify that it got set: */

	/* Turn board interrupts off  and send the flush cache command

	 * sendcmd will turn off interrupt, and send the flush...

	 * To write all data in the battery backed cache to disks

 init_one 4 */

 pci_init 2 */

 Get rid of any controller monitoring work items */

	/*

	 * Call before disabling interrupts.

	 * scsi_remove_host can trigger I/O operations especially

	 * when multipath is enabled. There can be SYNCHRONIZE CACHE

	 * operations which cannot complete and will hang the system.

 init_one 8 */

 includes hpsa_free_irqs - init_one 4 */

 includes hpsa_disable_interrupt_mode - pci_init 2 */

 scan */

 init_one 10 */

 init_one 10 */

 init_one 7 */

 init_one 6 */

 init_one 5 */

 hpsa_free_irqs already called via hpsa_shutdown init_one 4 */

 init_one 3 */

 init_one 3 */

 includes hpsa_disable_interrupt_mode - pci_init 2 */

 init_one 2.5 */

 init_one 2 */

 init_one 2 */

 (void) pci_disable_pcie_error_reporting(pdev); */	
 init_one 1 */

 id_table */

/* Fill in bucket_map[], given nsgs (the max number of

 * scatter gather elements supported) and bucket[],

 * which is an array of 8 integers.  The bucket[] array

 * contains 8 different DMA transfer sizes (in 16

 * byte increments) which the controller uses to fetch

 * commands.  This function fills in bucket_map[], which

 * maps a given number of scatter gather elements to one of

 * the 8 DMA transfer sizes.  The point of it is to allow the

 * controller to only do as much DMA as needed to fetch the

 * command, with the DMA transfer size encoded in the lower

 * bits of the command address.

 Note, bucket_map must have nsgs+1 entries. */

 Compute size of a command with i SG entries */

 Assume the biggest bucket */

 Find the bucket that is just big enough */

 for a command with i SG entries, use bucket b. */

/*

 * return -ENODEV on err, 0 on success (or no action)

 * allocates numerous items that must be freed later

	/* This is a bit complicated.  There are 8 registers on

	 * the controller which we write to to tell it 8 different

	 * sizes of commands which there may be.  It's a way of

	 * reducing the DMA done to fetch each command.  Encoded into

	 * each command's tag are 3 bits which communicate to the controller

	 * which of the eight sizes that command fits within.  The size of

	 * each command depends on how many scatter gather entries there are.

	 * Each SG entry requires 16 bytes.  The eight registers are programmed

	 * with the number of 16-byte blocks a command of that size requires.

	 * The smallest command possible requires 5 such 16 byte blocks.

	 * the largest command possible requires SG_ENTRIES_IN_CMD + 4 16-byte

	 * blocks.  Note, this only extends to the SG entries contained

	 * within the command block, and does not extend to chained blocks

	 * of SG elements.   bft[] contains the eight values we write to

	 * the registers.  They are not evenly distributed, but have more

	 * sizes for small commands, and fewer sizes for larger commands.

	/*  5 = 1 s/g entry or 4k

	 *  6 = 2 s/g entry or 8k

	 *  8 = 4 s/g entry or 16k

	 * 10 = 6 s/g entry or 24k

	/* If the controller supports either ioaccel method then

	 * we can also use the RAID stack submit path that does not

	 * perform the superfluous readl() after each command submission.

 Controller spec: zero out this buffer. */

 size of controller ring buffer */

	/*

	 * enable outbound interrupt coalescing in accelerator mode;

 Change the access methods to the performant access methods */

 Set up I/O accelerator mode */

 initialize all reply queue entries to unused */

		/* set all the constant fields in the accelerator command

		 * frames once at init time to save CPU cycles later.

 Free ioaccel1 mode command blocks and block fetch table */

 Allocate ioaccel1 mode command blocks and block fetch table */

	/* Command structures must be aligned on a 128-byte boundary

	 * because the 7 lower bits of the address are used by the

	 * hardware.

 Free ioaccel2 mode command blocks and block fetch table */

 Allocate ioaccel2 mode command blocks and block fetch table */

 Allocate ioaccel2 mode command blocks and block fetch table */

 Free items allocated by hpsa_put_ctlr_into_performant_mode */

/* return -ENODEV on error, 0 on success (or no action)

 * allocates numerous items that must be freed later

 Check for I/O accelerator mode support */

 Performant mode ring buffer and supporting data structures */

 rq, ioaccel */

 spec: init to 1 */

 Need a block fetch table for performant mode */

 rq, ioaccel */

 bft, rq, ioaccel */

 bft, rq, ioaccel */

 rq, ioaccel */

 wait for all outstanding ioaccel commands to drain out */

 Command is allocated */

/*

 *  This is it.  Register the PCI driver information for the cards we control

 *  the OS will call our registered routines when it finds one of our cards.

 VERIFY_OFFSET(reserved, 48 */

 VERIFY_OFFSET(reserved1, 3);  */

 VERIFY_OFFSET(reserved3 */

 VERIFY_OFFSET(reserved4  */

/*

 * Xen SCSI frontend driver

 *

 * Copyright (c) 2008, FUJITSU Limited

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License version 2

 * as published by the Free Software Foundation; or, when distributed

 * separately from the Linux kernel or incorporated into other

 * software packages, subject to the following license:

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this source file (the "Software"), to deal in the Software without

 * restriction, including without limitation the rights to use, copy, modify,

 * merge, publish, distribute, sublicense, and/or sell copies of the Software,

 * and to permit persons to whom the Software is furnished to do so, subject to

 * the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * all copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING

 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS

 * IN THE SOFTWARE.

 Tuning point. */

 command between backend and frontend */

 number of grants in gref[] */

 scatter/gather elements */

 Do reset or abort function. */

 reset work queue           */

 reset work queue condition */

 reset response status:     */

 SUCCESS or FAILED or:      */

 Requested struct scsi_cmnd is stored from kernel. */

 Following items are protected by the host lock. */

 use id in response */

 ordering required respective to dom0 */

 Yield point for this unbounded loop. */

			/*

			 * sg sends a scatterlist that is larger than

			 * the data_len it wants transferred for certain

			 * IO sizes.

/*

 * Any exception handling (reset or abort) must be forwarded to the backend.

 * We have to wait until an answer is returned. This answer contains the

 * result to be returned to the requestor.

**** Frontend to Backend ring start *****/

 free resource */

 Finish all still pending commands. */

 Reconnect to dom0. */

 No new commands for the backend. */

 Scsi_host not yet removed */

	/*

	 * When this function is executed, all devices of

	 * Frontend have been deleted.

	 * Therefore, it need not block I/O before remove_host.

 mark current task as the one allowed to modify device states */

 read status */

 virtual SCSI device */

		/*

		 * Front device state path, used in slave_configure called

		 * on successfull scsi_add_device, and in slave_destroy called

		 * on remove of a device.

 Missed the backend's Closing state */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Sun3 SCSI stuff by Erik Verbruggen (erik@bigmama.xtdnet.nl)

 *

 * Sun3 DMA routines added by Sam Creasey (sammy@sammy.net)

 *

 * VME support added by Sam Creasey

 *

 * TODO: modify this driver to support multiple Sun3 SCSI VME boards

 *

 * Adapted from mac_scsinew.c:

/*

 * Generic Macintosh NCR5380 driver

 *

 * Copyright 1998, Michael Schmitz <mschmitz@lbl.gov>

 *

 * derived in part from:

/*

 * Generic Generic NCR5380 driver

 *

 * Copyright 1995, Russell King

 minimum number of bytes to do dma on */

 Definitions for the core NCR5380 driver. */

 none */

 dma regs start at regbase + 8, directly after the NCR regs */

 vme only */

 vme only */

 vme only */

 vme only */

 udc dma data reg (obio only) */

 uda dma addr reg (obio only) */

	unsigned short fifo_data; /* fifo data reg,

	                           * holds extra byte on odd dma reads

 control/status reg */

 vme only */

 vme only */

 vme only */

 vme only */

 ucd chip specific regs - live in dvma space */

 select regs to load */

 high word of addr */

 low word */

 words to be xfer'd */

 high word of channel mode */

 low word of channel mode */

 addresses of the udc registers */

 command/status */

 chain high word */

 chain lo word */

 cur reg A high */

 cur reg A low */

 cur reg B high */

 cur reg B low */

 mode reg high */

 mode reg low */

 words to xfer */

 some udc commands */

 start chain */

 channel 1 int on */

 udc mode words */

 udc reg selections */

 bits in csr reg */

 fifo flushed? */

 sbc interrupt pending */

 dma interrupt pending */

 1 = send  0 = recv */

 reset fifo */

 interrupt enable */

 ms to wait after hitting dma regs */

 dvma buffer to allocate -- 32k should hopefully be more than sufficient */

 dma controller register access functions */

 safe bits for the CSR

 sun3scsi_dma_setup() -- initialize the dma controller for a read/write */

 reset fifo */

 set direction */

 byte count for fifo */

 reset fifo */

 setup udc */

 count in words */

 announce location of regs block */

 set dma master on */

 interrupt enable */

/*	if(!(csr & CSR_DMA_ENABLE))

 *		dregs->csr |= CSR_DMA_ENABLE;

 clean up after our dma is done */

 empty bytes from the fifo which didn't make it */

 check to empty the fifo on a read

 .2 sec */

 empty bytes from the fifo which didn't make it */

	dregs->csr |= CSR_DMA_ENABLE; */

 reset fifo */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 1996 John Shifflett, GeoLog Consulting

 *    john@geolog.com

 *    jshiffle@netcom.com

/*

 * Drew Eckhardt's excellent 'Generic NCR5380' sources from Linux-PC

 * provided much of the inspiration and some of the code for this

 * driver. Everything I know about Amiga DMA was gleaned from careful

 * reading of Hamish Mcdonald's original wd33c93 driver; in fact, I

 * borrowed shamelessly from all over that source. Thanks Hamish!

 *

 * _This_ driver is (I feel) an improvement over the old one in

 * several respects:

 *

 *    -  Target Disconnection/Reconnection  is now supported. Any

 *          system with more than one device active on the SCSI bus

 *          will benefit from this. The driver defaults to what I

 *          call 'adaptive disconnect' - meaning that each command

 *          is evaluated individually as to whether or not it should

 *          be run with the option to disconnect/reselect (if the

 *          device chooses), or as a "SCSI-bus-hog".

 *

 *    -  Synchronous data transfers are now supported. Because of

 *          a few devices that choke after telling the driver that

 *          they can do sync transfers, we don't automatically use

 *          this faster protocol - it can be enabled via the command-

 *          line on a device-by-device basis.

 *

 *    -  Runtime operating parameters can now be specified through

 *       the 'amiboot' or the 'insmod' command line. For amiboot do:

 *          "amiboot [usual stuff] wd33c93=blah,blah,blah"

 *       The defaults should be good for most people. See the comment

 *       for 'setup_strings' below for more details.

 *

 *    -  The old driver relied exclusively on what the Western Digital

 *          docs call "Combination Level 2 Commands", which are a great

 *          idea in that the CPU is relieved of a lot of interrupt

 *          overhead. However, by accepting a certain (user-settable)

 *          amount of additional interrupts, this driver achieves

 *          better control over the SCSI bus, and data transfers are

 *          almost as fast while being much easier to define, track,

 *          and debug.

 *

 *

 * TODO:

 *       more speed. linked commands.

 *

 *

 * People with bug reports, wish-lists, complaints, comments,

 * or improvements are asked to pah-leeez email me (John Shifflett)

 * at john@geolog.com or jshiffle@netcom.com! I'm anxious to get

 * this thing into as good a shape as possible, and I'm positive

 * there are lots of lurking bugs and "Stupid Places".

 *

 * Updates:

 *

 * Added support for pre -A chips, which don't have advanced features

 * and will generate CSR_RESEL rather than CSR_RESEL_AM.

 *	Richard Hirst <richard@sleepie.demon.co.uk>  August 2000

 *

 * Added support for Burst Mode DMA and Fast SCSI. Enabled the use of

 * default_sx_per for asynchronous data transfers. Added adjustment

 * of transfer periods in sx_table to the actual input-clock.

 *  peter fuerst <post@pfrst.de>  February 2007

/*

 * 'setup_strings' is a single string used to pass operating parameters and

 * settings from the kernel/module command-line to the driver. 'setup_args[]'

 * is an array of strings that define the compile-time default values for

 * these settings. If Linux boots with an amiboot or insmod command-line,

 * those settings are combined with 'setup_args[]'. Note that amiboot

 * command-lines are prefixed with "wd33c93=" while insmod uses a

 * "setup_strings=" prefix. The driver recognizes the following keywords

 * (lower case required) and arguments:

 *

 * -  nosync:bitmask -bitmask is a byte where the 1st 7 bits correspond with

 *                    the 7 possible SCSI devices. Set a bit to negotiate for

 *                    asynchronous transfers on that device. To maintain

 *                    backwards compatibility, a command-line such as

 *                    "wd33c93=255" will be automatically translated to

 *                    "wd33c93=nosync:0xff".

 * -  nodma:x        -x = 1 to disable DMA, x = 0 to enable it. Argument is

 *                    optional - if not present, same as "nodma:1".

 * -  period:ns      -ns is the minimum # of nanoseconds in a SCSI data transfer

 *                    period. Default is 500; acceptable values are 250 - 1000.

 * -  disconnect:x   -x = 0 to never allow disconnects, 2 to always allow them.

 *                    x = 1 does 'adaptive' disconnects, which is the default

 *                    and generally the best choice.

 * -  debug:x        -If 'DEBUGGING_ON' is defined, x is a bit mask that causes

 *                    various types of debug output to printed - see the DB_xxx

 *                    defines in wd33c93.h

 * -  clock:x        -x = clock input in MHz for WD33c93 chip. Normal values

 *                    would be from 8 through 20. Default is 8.

 * -  burst:x        -x = 1 to use Burst Mode (or Demand-Mode) DMA, x = 0 to use

 *                    Single Byte DMA, which is the default. Argument is

 *                    optional - if not present, same as "burst:1".

 * -  fast:x         -x = 1 to enable Fast SCSI, which is only effective with

 *                    input-clock divisor 4 (WD33C93_FS_16_20), x = 0 to disable

 *                    it, which is the default.  Argument is optional - if not

 *                    present, same as "fast:1".

 * -  next           -No argument. Used to separate blocks of keywords when

 *                    there's more than one host adapter in the system.

 *

 * Syntax Notes:

 * -  Numeric arguments can be decimal or the '0x' form of hex notation. There

 *    _must_ be a colon between a keyword and its numeric argument, with no

 *    spaces.

 * -  Keywords are separated by commas, no spaces, in the standard kernel

 *    command-line manner.

 * -  A keyword in the 'nth' comma-separated command-line member will overwrite

 *    the 'nth' element of setup_args[]. A blank command-line member (in

 *    other words, a comma with no preceding keyword) will _not_ overwrite

 *    the corresponding setup_args[] element.

 * -  If a keyword is used more than once, the first one applies to the first

 *    SCSI host found, the second to the second card, etc, unless the 'next'

 *    keyword is used to change the order.

 *

 * Some amiboot examples (for insmod, use 'setup_strings' instead of 'wd33c93'):

 * -  wd33c93=nosync:255

 * -  wd33c93=nodma

 * -  wd33c93=nodma:1

 * -  wd33c93=disconnect:2,nosync:0x08,period:250

 * -  wd33c93=debug:0x1c

 Normally, no defaults are specified */

 CONFIG_WD33C93_PIO */

 CONFIG_WD33C93_PIO */

/*

 * Calculate Synchronous Transfer Register value from SDTR code.

	/* When doing Fast SCSI synchronous data transfers, the corresponding

	 * value in 'sx_table' is two times the actually used transfer period.

 convert SDTR code to ns */

/*

 * Calculate SDTR code bytes [3],[4] from period and offset.

	/* 'period' is a "normal"-mode value, like the ones in 'sx_table'. The

	 * actually used transfer period for Fast SCSI synchronous data

	 * transfers is half that value.

/* Set up a few fields in the scsi_cmnd structure for our own use:

 *  - host_scribble is the pointer to the next cmd in the input queue

 *  - result is what you'd expect

/* We use the Scsi_Pointer structure that's included with each command

 * as a scratchpad (as it's intended to be used!). The handy thing about

 * the SCp.xxx fields is that they're always associated with a given

 * cmd, and are preserved across disconnect-reselect. This means we

 * can pretty much ignore SAVE_POINTERS and RESTORE_POINTERS messages

 * if we keep all the critical pointers and counters in SCp:

 *  - SCp.ptr is the pointer into the RAM buffer

 *  - SCp.this_residual is the size of that buffer

 *  - SCp.buffer points to the current scatter-gather buffer

 *  - SCp.buffers_residual tells us how many S.G. buffers there are

 *  - SCp.have_data_in is not used

 *  - SCp.sent_command is not used

 *  - SCp.phase records this command's SRCID_ER bit setting

/* WD docs state that at the conclusion of a "LEVEL2" command, the

 * status byte can be retrieved from the LUN register. Apparently,

 * this is the case only for *uninterrupted* LEVEL2 commands! If

 * there are any unexpected phases entered, even if they are 100%

 * legal (different devices may choose to do things differently),

 * the LEVEL2 command sequence is exited. This often occurs prior

 * to receiving the status byte, in which case the driver does a

 * status phase interrupt and gets the status byte on its own.

 * While such a command can then be "resumed" (ie restarted to

 * finish up as a LEVEL2 command), the LUN register will NOT be

 * a valid status byte at the command's conclusion, and we must

 * use the byte obtained during the earlier interrupt. Here, we

 * preset SCp.Status to an illegal value (0xff) so that when

 * this command finally completes, we can tell where the actual

 * status byte is stored.

	/*

	 * Add the cmd to the end of 'input_Q'. Note that REQUEST SENSE

	 * commands are added to the head of the queue so that the desired

	 * sense data is not lost before REQUEST_SENSE executes.

 find the end of the queue */

/* We know that there's at least one command in 'input_Q' now.

 * Go see if any of them are runnable!

/*

 * This routine attempts to start a scsi command. If the host_card is

 * already connected, we give up immediately. Otherwise, look through

 * the input_Q, using the first command we find that's intended

 * for a currently non-busy target/lun.

 *

 * wd33c93_execute() is always called with interrupts disabled or from

 * the wd33c93_intr itself, which means that a wd33c93 interrupt

 * cannot occur while we are in here.

	/*

	 * Search through the input_Q for a command destined

	 * for an idle target/lun.

 quit if queue empty or all possible targets are busy */

  remove command from queue */

	/*

	 * Start the selection process

/* Now we need to figure out whether or not this command is a good

 * candidate for disconnect/reselect. We guess to the best of our

 * ability, based on a set of hierarchical rules. When several

 * devices are operating simultaneously, disconnects are usually

 * an advantage. In a single device system, or if only 1 device

 * is being accessed, transfers usually go faster if disconnects

 * are not allowed:

 *

 * + Commands should NEVER disconnect if hostdata->disconnect =

 *   DIS_NEVER (this holds for tape drives also), and ALWAYS

 *   disconnect if hostdata->disconnect = DIS_ALWAYS.

 * + Tape drive commands should always be allowed to disconnect.

 * + Disconnect should be allowed if disconnected_Q isn't empty.

 * + Commands should NOT disconnect if input_Q is empty.

 * + Disconnect should be allowed if there are commands in input_Q

 *   for a different target/lun. In this case, the other commands

 *   should be made disconnect-able, if not already.

 *

 * I know, I know - this code would flunk me out of any

 * "C Programming 101" class ever offered. But it's easy

 * to change around and experiment with for now.

 assume no disconnect */

 tape drive? */

 other commands disconnected? */

 input_Q empty? */

		/*

		 * Do a 'Select-With-ATN' command. This will end with

		 * one of the following interrupts:

		 *    CSR_RESEL_AM:  failure - can try again later.

		 *    CSR_TIMEOUT:   failure - give up.

		 *    CSR_SELECT:    success - proceed.

/* Every target has its own synchronous transfer setting, kept in the

 * sync_xfer array, and a corresponding status byte in sync_stat[].

 * Each target's sync_stat[] entry is initialized to SX_UNSET, and its

 * sync_xfer[] entry is initialized to the default/safe value. SS_UNSET

 * means that the parameters are undetermined as yet, and that we

 * need to send an SDTR message to this device after selection is

 * complete: We set SS_FIRST to tell the interrupt routine to do so.

 * If we've been asked not to try synchronous transfers on this

 * target (and _all_ luns within it), we'll still send the SDTR message

 * later, but at that time we'll negotiate for async by specifying a

 * sync fifo depth of 0.

 guarantee a DATA_PHASE interrupt */

		/*

		 * Do a 'Select-With-ATN-Xfer' command. This will end with

		 * one of the following interrupts:

		 *    CSR_RESEL_AM:  failure - can try again later.

		 *    CSR_TIMEOUT:   failure - give up.

		 *    anything else: success - proceed.

		/* copy command_descriptor_block into WD chip

		 * (take advantage of auto-incrementing)

		/* The wd33c93 only knows about Group 0, 1, and 5 commands when

		 * it's doing a 'select-and-transfer'. To be safe, we write the

		 * size of the CDB into the OWN_ID register for every case. This

		 * way there won't be problems with vendor-unique, audio, etc.

		/* When doing a non-disconnect command with DMA, we can save

		 * ourselves a DATA phase interrupt later by setting everything

		 * up ahead of time.

 guarantee a DATA_PHASE interrupt */

 guarantee a DATA_PHASE interrupt */

	/*

	 * Since the SCSI bus can handle only 1 connection at a time,

	 * we get out of here now. If the selection fails, or when

	 * the command disconnects, we'll come back to this routine

	 * to search the input_Q again...

	/* Note: we are returning with the interrupt UN-cleared.

	 * Since (presumably) an entire I/O operation has

	 * completed, the bus phase is probably different, and

	 * the interrupt routine will discover this when it

	 * responds to the uncleared int.

/* Normally, you'd expect 'this_residual' to be non-zero here.

 * In a series of scatter-gather transfers, however, this

 * routine will usually be called with 'this_residual' equal

 * to 0 and 'buffers_residual' non-zero. This means that a

 * previous transfer completed, clearing 'this_residual', and

 * now we need to setup the next scatter-gather buffer as the

 * source or destination for THIS transfer.

 avoid bogus setups */

/* 'hostdata->no_dma' is TRUE if we don't even want to try DMA.

 * Update 'this_residual' and 'ptr' after 'transfer_pio()' returns.

/* We are able to do DMA (in fact, the Amiga hardware is

 * already going!), so start up the wd33c93 in DMA mode.

 * We set 'hostdata->dma' = D_DMA_RUNNING so that when the

 * transfer completes and causes an interrupt, we're

 * reminded to tell the Amiga to shut down its end. We'll

 * postpone the updating of 'this_residual' and 'ptr'

 * until then.

 assume we're connected */

 clear the interrupt */

/* After starting a DMA transfer, the next interrupt

 * is guaranteed to be in response to completion of

 * the transfer. Since the Amiga DMA hardware runs in

 * in an open-ended fashion, it needs to be told when

 * to stop; do that here if D_DMA_RUNNING is true.

 * Also, we have to update 'this_residual' and 'ptr'

 * based on the contents of the TRANSFER_COUNT register,

 * in case the device decided to do an intermediate

 * disconnect (a device may do this if it has to do a

 * seek, or just to be nice and let other devices have

 * some bus time during long transfers). After doing

 * whatever is needed, we go on and service the WD3393

 * interrupt normally.

 Respond to the specific WD3393 interrupt - there are quite a few! */

 get a valid cmd */

		/* From esp.c:

		 * There is a window of time within the scsi_done() path

		 * of execution where interrupts are turned back on full

		 * blast and left that way.  During that time we could

		 * reconnect to a disconnected command, then we'd bomb

		 * out below.  We could also end up executing two commands

		 * at _once_.  ...just so you know why the restore_flags()

		 * is here...

/* We are not connected to a target - check to see if there

 * are commands waiting to be executed.

 Note: this interrupt should not occur in a LEVEL2 command */

 construct an IDENTIFY message with correct disconnect bit */

/* Tack on a 2nd message to ask about synchronous transfers. If we've

 * been asked to do only asynchronous transfers on this device, we

 * request a fifo depth of 0, which is equivalent to async - should

 * solve the problems some people have had with GVP's Guru ROM.

 Note: this interrupt should not occur in a LEVEL2 command */

 clear interrupt */

 clear interrupt */

 we want default_sx_per, not DEFAULT_SX_PER */

 Is this the last byte of the extended message? */

 what's the EXTENDED code? */

 default to default async period */

/* A device has sent an unsolicited SDTR message; rather than go

 * through the effort of decoding it and then figuring out what

 * our reply should be, we're just gonna say that we have a

 * synchronous fifo depth of 0. This will result in asynchronous

 * transfers - not ideal but so much easier.

 * Actually, this is OK because it assures us that if we don't

 * specifically ask for sync transfers, we won't do any.

 want MESS_OUT */

 well, sync transfer */

 very unlikely... */

 want MESS_OUT */

 8 bit transfer width */

 want MESS_OUT */

 We need to read more MESS_IN bytes for the extended message */

 want MESS_OUT */

 Note: this interrupt will occur only after a LEVEL2 command */

/* Make sure that reselection is enabled at this point - it may

 * have been turned off for the command that just completed.

/* We are no longer  connected to a target - check to see if

 * there are commands waiting to be executed.

 Note: this interrupt will occur only after a LEVEL2 command */

/* To get here, we've probably requested MESSAGE_OUT and have

 * already put the correct bytes in outgoing_msg[] and filled

 * in outgoing_len. We simply send them out to the SCSI bus.

 * Sometimes we get MESSAGE_OUT phase when we're not expecting

 * it - like when our SDTR message is rejected by a target. Some

 * targets send the REJECT before receiving all of the extended

 * message, and then seem to go back to MESSAGE_OUT for a byte

 * or two. Not sure why, or if I'm doing something wrong to

 * cause this to happen. Regardless, it seems that sending

 * NOP messages in these situations results in no harm and

 * makes everyone happy.

/* I think I've seen this after a request-sense that was in response

 * to an error condition, but not sure. We certainly need to do

 * something when we get this interrupt - the question is 'what?'.

 * Let's think positively, and assume some command has finished

 * in a legal manner (like a command that provokes a request-sense),

 * so we treat it as a normal command-complete-disconnect.

/* Make sure that reselection is enabled at this point - it may

 * have been turned off for the command that just completed.

/* We are no longer connected to a target - check to see if

 * there are commands waiting to be executed.

 look above for comments on scsi_done() */

/* Make sure that reselection is enabled at this point - it may

 * have been turned off for the command that just completed.

/* We are no longer connected to a target - check to see if

 * there are commands waiting to be executed.

		    /* Old chips (pre -A ???) don't have advanced features and will

		     * generate CSR_RESEL.  In that case we have to extract the LUN the

		     * hard way (see below).

		     * First we have to make sure this reselection didn't

		     * happen during Arbitration/Selection of some other device.

		     * If yes, put losing command back on top of input_Q.

 OK - find out which device reselected us. */

		/* and extract the lun from the ID message. (Note that we don't

		 * bother to check for a valid message here - I guess this is

		 * not the right way to go, but...)

 Old chip; wait for msgin phase to pick up the LUN. */

 Verify this is a change to MSG_IN and read the message */

 Got MSG_IN, grab target LUN */

 Now we expect a 'paused with ACK asserted' int.. */

 Now we look for the command that's reconnecting. */

 Hmm. Couldn't find a valid command.... What to do? */

 Ok, found the command - now start it up again. */

		/* We don't need to worry about 'initialize_SCp()' or 'hostdata->busy[]'

		 * because these things are preserved over a disconnect.

		 * But we DO need to fix the DPD bit so it's correct for this command.

 we want a DATA_PHASE interrupt */

 wait 'til the chip gets some time for us */

	/*

 	 * there are scsi devices out there, which manage to lock up

	 * the wd33c93 in a busy condition. In this state it won't

	 * accept the reset command. The only way to solve this is to

 	 * give the chip a hardware reset (if possible). The code below

	 * does this for the SGI Indy, where this is possible

 still busy ? */

 yeah, give it the hard one */

 The old wd33c93 on MVME147 needs this, at least */

 any random number */

 Fast SCSI unavailable */

 using default sync values */

/*

 * Case 1 : If the command hasn't been issued yet, we simply remove it

 *     from the input_Q.

/*

 * Case 2 : If the command is connected, we're going to fail the abort

 *     and let the high level SCSI driver retry at a later time or

 *     issue a reset.

 *

 *     Timeouts, and therefore aborted commands, will be highly unlikely

 *     and handling them cleanly in this situation would make the common

 *     case of noresets less efficient, and would pollute our code.  So,

 *     we fail.

 Now we have to attempt to flush out the FIFO... */

		/*

		 * Abort command processed.

		 * Still connected.

		 * We must disconnect.

      sti();*/

/*

 * Case 3: If the command is currently disconnected from the bus,

 * we're not going to expend much effort here: Let's just return

 * an ABORT_SNOOZE and hope for the best...

/*

 * Case 4 : If we reached this point, the command was not found in any of

 *     the queues.

 *

 * We probably reached this point because of an unlikely race condition

 * between the command completing successfully and the abortion code,

 * so we won't panic, but we will notify the user in case something really

 * broke.

   sti();*/

	/* The kernel does some processing of the command-line before calling

	 * this function: If it begins with any decimal or hex number arguments,

	 * ints[0] = how many numbers found and ints[1] through [n] are the values

	 * themselves. str points to where the non-numeric arguments (if any)

	 * start: We do our own parsing of those. We construct synthetic 'nosync'

	 * keywords out of numeric args (to maintain compatibility with older

	 * versions) and then add the rest of the arguments.

/* check_setup_args() returns index if key found, 0 if not

/*

 * Calculate internal data-transfer-clock cycle from input-clock

 * frequency (/MHz) and fill 'sx_table'.

 *

 * The original driver used to rely on a fixed sx_table, containing periods

 * for (only) the lower limits of the respective input-clock-frequency ranges

 * (8-10/12-15/16-20 MHz). Although it seems, that no problems occurred with

 * this setting so far, it might be desirable to adjust the transfer periods

 * closer to the really attached, possibly 25% higher, input-clock, since

 * - the wd33c93 may really use a significant shorter period, than it has

 *   negotiated (eg. thrashing the target, which expects 4/8MHz, with 5/10MHz

 *   instead).

 * - the wd33c93 may ask the target for a lower transfer rate, than the target

 *   is capable of (eg. negotiating for an assumed minimum of 252ns instead of

 *   possible 200ns, which indeed shows up in tests as an approx. 10% lower

 *   transfer rate).

 divisor for  8-10 MHz input-clock */

 divisor for 12-15 MHz input-clock */

 divisor for 16-20 MHz input-clock */

 100 x DTCC / nanosec */

/*

 * check and, maybe, map an init- or "clock:"- argument.

 Hmm, wouldn't it be safer to assume highest freq here? */

/*

 * to be used with the resync: fast: ... options

 using default sync values */

 default is DMA enabled */

 divisor 4 */

/* We accept the following

 * keywords (same format as command-line, but arguments are not optional):

 *    debug

 *    disconnect

 *    period

 *    resync

 *    proc

 *    nodma

 *    level2

 *    burst

 *    fast

 *    nosync

 unknown keyword,syntax-error,... */

 PROC_INTERFACE */

----------------------------------------------------------------*/

/*

   Qlogic linux driver - work in progress. No Warranty express or implied.

   Use at your own risk.  Support Tort Reform so you won't have to read all

   these silly disclaimers.



   Copyright 1994, Tom Zerucha.

   tz@execpc.com



   Additional Code, and much appreciated help by

   Michael A. Griffith

   grif@cs.ucr.edu



   Thanks to Eric Youngdale and Dave Hinds for loadable module and PCMCIA

   help respectively, and for suffering through my foolishness during the

   debugging process.



   Reference Qlogic FAS408 Technical Manual, 53408-510-00A, May 10, 1994

   (you can reference it, but it is incomplete and inaccurate in places)



   Version 0.46 1/30/97 - kernel 1.2.0+



   Functions as standalone, loadable, and PCMCIA driver, the latter from

   Dave Hinds' PCMCIA package.



   Cleaned up 26/10/2002 by Alan Cox <alan@lxorguk.ukuu.org.uk> as part of the 2.5

   SCSI driver cleanup and audit. This driver still needs work on the

   following

	-	Non terminating hardware waits

	-	Some layering violations with its pcmcia stub



   Redistributable under terms of the GNU General Public License



   For the avoidance of doubt the "preferred form" of this code is one which

   is in an open non patent encumbered format. Where cryptographic key signing

   forms part of the process of creating an executable the information

   including keys needed to generate an equivalently functional executable

   are deemed to be part of the source code.



 to get disk capacity */

----------------------------------------------------------------*/

 15625/512 */

----------------------------------------------------------------*/

----------------------------------------------------------------*/

 local functions */

----------------------------------------------------------------*/

 error recovery - reset everything */

 reset SCSI */

 reset chip */

/*

 *	Do a pseudo-dma tranfer

 in */

 empty fifo in large chunks */

 full */

 2/3 */

 1/3 */

 until both empty and int (or until reclen is 0) */

 while bytes to receive and not empty */

 out */

 empty */

 1/3 */

 2/3 */

 until full and int (or until reclen is 0) */

 while bytes to send and not full */

 maybe return reqlen */

/*

 *	Wait for interrupt flag (polled - not real hardware interrupt)

/*

 *	Initiate scsi command - queueing handler

 *	caller must hold host lock

 clearing of interrupts and the fifo is needed */

 clear interrupts */

 if still interrupting */

 reset chip */

 clear fifo */

 clear ints */

 set for PIO pseudo DMA */

 disable ints */

 clear int bits */

 enable features */

 configurables */

 config: no reset interrupt, (initiator) bus id */

 select timer */

 prescaler */

	outb(0x99, qbase + 5);	*/

 select and send command */

/*

 *	Process scsi command - usually after interrupt

 scsi returned status */

 scsi returned message */

 recorded scsi phase */

 total length of transfer */

 the 0x10 bit can be set after the 0x08 */

 j = inb( qbase + 7 ) >> 5; */

 correct status is supposed to be step 4 */

 it sometimes returns step 3 but with 0 bytes left to send */

	/* We can try stuffing the FIFO with the max each time, but we will get a

 if some bytes in fifo */

 clear fifo */

 note that request_bufflen is the total xfer size when sg is used */

 note that it won't work if transfers > 16M are requested */

 data phase */

 low-mid xfer cnt */

 low-mid xfer cnt */

 high xfer cnt */

 command do xfer */

 PIO pseudo DMA to buffer or sglist */

		/*

		 *	Wait for irq (split into second state of irq handler

		 *	if this can take time)

 should be 0x10, bus service */

	/*

	 *	Enter Status (and Message In) Phase

 wait for status phase */

 FIXME: timeout ?? */

 clear pending ints */

 get status and message */

 get chip irq stat */

 and bytes rec'd */

	/*

	 *	Should get function complete int if Status and message, else

	 *	bus serv if only status

 done, disconnect */

	/*

	 *	Should get bus service interrupt and disconnect interrupt

 should be bus service */

/*

 *	Interrupt handler

 false alarm? */

 no command to process? */

 maybe also ql_zap() */

	/*

	 *	If result is CHECK CONDITION done calls qcommand to request

	 *	sense

/*

 *	Queued command

 wait for the last command's interrupt to finish */

/*

 *	Return bios parameters

 This should mimic the DOS Qlogic driver's behavior exactly */

/*

 *	Abort a command in progress

/*

 *	Reset SCSI bus

 *	FIXME: This function is invoked with cmd = NULL directly by

 *	the PCMCIA qlogic_stub code. This wants fixing

/*

 *	Return info string

/*

 *	Get type of chip

/*

 *	Perform initialization tasks

 set for PIO pseudo DMA */

 (ini) bus id, disable scsi rst */

 select timer */

 prescaler */

 FIXME: timeout */

/*

 *	Checks if this is a QLogic FAS 408

/*

 *	Disable interrupts

 disable ints */

/*

 *	Init and exit functions

 SPDX-License-Identifier: GPL-2.0-or-later

/***************************************************************************

                          dpti.c  -  description

                             -------------------

    begin                : Thu Sep 7 2000

    copyright            : (C) 2000 by Adaptec



			   July 30, 2001 First version being submitted

			   for inclusion in the kernel.  V2.4



    See Documentation/scsi/dpti.rst for history, notes, license info

    and credits

/***************************************************************************

 *                                                                         *

 *                                                                         *

/***************************************************************************

 * Sat Dec 20 2003 Go Taniguchi <go@turbolinux.co.jp>

 - Support 2.6 kernel and DMA-mapping

 - ioctl fix for raid tools

 - use schedule_timeout in long long loop

#define DEBUG 1 */

#define UARTDELAY 1 */



 For SCSI-Passthrough */

 for kmalloc() */

 for PCI support */

 for udelay */

 for printk */

 for boot_cpu_data */

 for virt_to_bus, etc. */

/*============================================================================

 * Create a binary signature - this is read by dptsig

 * Needed for our management apps

 *============================================================================

/*============================================================================

 * Globals

 *============================================================================

/* Structures and definitions for synchronous message posting.

 * See adpt_i2o_post_wait() for description

/*============================================================================

 * 				Functions

 *============================================================================

/*============================================================================

 * Scsi host template interface functions

 *============================================================================

 search for all Adatpec I2O RAID cards */

 In INIT state, Activate IOPs */

 Activate does get status , init outbound, and get hrt

 Active IOPs in HOLD state */

	/*

	 * If build_sys_table fails, we kill everything and bail

	 * as we can't init the IOPs w/o a system table

 If IOP don't get online, we need to rebuild the System table */

 Active IOPs now in OPERATIONAL state */

 Register our control device node

 nodes will need to be created in /dev to access this

 the nodes can not be created from within the driver

	adpt_i2o_quiesce_hba(pHba);

 DATA IN  (iop<--dev)

 SINGLE SGE, 64 bit

 SINGLE SGE, 32 bit

 Stick the headers on */

 Adaptec/DPT Private stuff 

 Interpret*/;

 Direction, disconnect ok | sense data | simple queue , CDBLen */

 I2O_SCB_FLAG_ENABLE_DISCONNECT | 

 I2O_SCB_FLAG_SIMPLE_QUEUE_TAG | 

 I2O_SCB_FLAG_SENSE_DATA_IN_MESSAGE;

 cmd len*/;

 Write SCSI command into the message - always 16 byte block 

 Don't care about the rest of scb

 Remember me - fill in when we know */

 Now fill in the SGList and command */

 Enable 64 bit */

 Send it on it's way

 precautionary */

 dpt per device information */

	/*

	 * SCSI REQUEST_SENSE commands will be executed automatically by the 

	 * Host Adapter for any errors, so they should not be executed 

	 * explicitly unless the Sense Data is zero indicating that no error 

	 * occurred.

 TODO if the cmd->device if offline then I may need to issue a bus rescan

 followed by a get_lct to see if the device is there anymore

		/*

		 * First command request for this device.  Set up a pointer

		 * to the device structure.  This should be a TEST_UNIT_READY

		 * command from scan_scsis_single.

 TODO: if any luns are at this bus, scsi id then fake a TEST_UNIT_READY and INQUIRY response 

 with type 7F (for all luns less than the max for this bus,id) so the lun scan will continue.

	/*

	 * If we are being called from when the device is being reset, 

	 * delay processing of the command until later.

 *** First lets set the default geometry ****

 If the capacity is less than ox2000

 floppy

 else if between 0x2000 and 0x20000

 else if between 0x20000 and 0x40000

 else if between 0x4000 and 0x80000

 else if greater than 0x80000

 Special case if CDROM

 CDROM

 Find HBA (host bus adapter) we are looking for

 found adapter */

/*

 *	Turn a pointer to ioctl reply data into an u32 'context'

/*

 *	Go from an u32 'context' to a pointer to ioctl reply data.

/*===========================================================================

 * Error Handling routines

 *===========================================================================

 host bus adapter structure */

 dpt per device information */

 Add 1 to avoid firmware treating it as invalid command */

 This is the same for BLK and SCSI devices

 NOTE this is wrong in the i2o.h definitions

 This is not currently supported by our adapter but we issue it anyway

 This version of bus reset is called by the eh_error handler

 This version of reset is called by the eh_error_handler

 This version of reset is called by the ioctls and indirectly from eh_error_handler via adpt_reset

 Activate does get status , init outbound, and get hrt

 return success */

/*===========================================================================

 * 

 *===========================================================================

 Delete all IOPs from the controller chain */

	/* They should have already been released by the

	 * scsi-core

 Remove any timedout entries from the wait queue.  */

	spin_lock_irqsave(&adpt_post_wait_lock, flags);

	/* Nothing should be outstanding at this point so just

	 * free them 

	spin_unlock_irqrestore(&adpt_post_wait_lock, flags);

	/*

	 *	See if we should enable dma64 mode.

 adapter only supports message blocks below 4GB */

 Check if standard PCI card or single BAR Raptor

 Raptor card with this device id needs 4M

 Not Raptor - it is a PCI card

 Raptor split BAR config

 Use BAR1 in this configuration

	/*

	 *	The original Adaptec 64 bit driver has this comment here:

	 *	"x86_64 machines need more optimal mappings"

	 *

	 *	I assume some HBAs report ridiculously large mappings

	 *	and we need to limit them on platforms with IOMMUs.

 Allocate and zero the data structure

 Set up the Virtual Base Address of the I2O Device

 Initializing the spinlocks

 If it is the only lun at that address then this should match*/

 else we need to look through all the luns */

 I used my own version of the WAIT_QUEUE_HEAD

 to handle some version differences

 When embedded in the kernel this could go back to the vanilla one

	/*

	 * The spin locking is needed to keep anyone from playing

	 * with the queue pointers and id while we do the same

 TODO we need a MORE unique way of getting ids

 to support async LCT get

 I/O issued, but cannot get result in

 specified time. Freeing resorces is

 dangerous.

 We will have to free the wait_data memory during shutdown

 Remove the entry from the queue.  */

post message

	/*

	 * We need to search through the adpt_post_wait

	 * queue to see if the given message is still

	 * outstanding.  If not, it means that the IOP

	 * took longer to respond to the message than we

	 * had allowed and timer has already expired.

	 * Not much we can do about that except log

	 * it for debug purposes, increase timeout, and recompile

	 *

	 * Lock needed to keep anyone from moving queue pointers

	 * around while we're looking through them.

 If this happens we lose commands that probably really completed

 First time reset should be quick

			/* We lose 4 bytes of "status" here, but we cannot

			   free these because controller may awake and corrupt

 dma_free_coherent(&pHba->pDev->dev, 4, buf, addr); */

I2O_EXEC_IOP_RESET_IN_PROGRESS*/) {

 Here we wait for message frame to become available

 indicated that reset has finished

				/* We lose 4 bytes of "status" here, but we

				   cannot free these because controller may

 dma_free_coherent(&pHba->pDev->dev, 4, buf, addr); */

 Flush the offset

 This delay is to allow someone attached to the card through the debug UART to 

 set up the dump levels that they want before the rest of the initialization sequence

 larger than 7, or 8 ...

			/*

			 * If we have hidden devices, we need to inform the upper layers about

			 * the possible maximum id reference to handle device access when

			 * an array is disassembled. This code has no other purpose but to

			 * allow us future access to devices that are currently hidden

			 * behind arrays, hotspares or have not been configured (JBOD mode).

 I2O_DPT_DEVICE_INFO_GROUP_NO;

 Something wrong skip it

 TODO get the bus_no from hrt-but for now they are in order

bus_no = 

 TODO remove - this is just until we get from hrt

 Something wrong skip it

 Setup adpt_device table

 I2O_DPT_DEVICE_INFO_GROUP_NO;

 Something wrong skip it

/*

 *	Each I2O controller has a chain of devices on it - these match

 *	the useful parts of the LCT of the board.

TODO check for root access



 found adapter */

	if(pHba->in_use){

	mutex_unlock(&adpt_configuration_lock);

		return -EBUSY;

	}

 found adapter */

 get user msg size in u32s 

 Convert to bytes

 Copy in the user's I2O command */

 IOCTL context

 TODO add 64 bit API

I2O_SGL_FLAGS_SIMPLE_ADDRESS_ELEMENT*/)) {

 Allocate memory for the transfer */

 sglist indexed with input frame, not our internal frame.

 Copy in the user's SG buffer if necessary */

I2O_SGL_FLAGS_DIR*/) {

 sg_simple_element API is 32 bit

 sg_simple_element API is 32 bit, but addr < 4GB */

		/*

		 * Stop any new commands from enterring the

		 * controller while processing the ioctl

 Copy back the Scatter Gather buffers back to user space */

 TODO add 64 bit API

 re-acquire the original message to handle correctly the sg copy operation

 get user msg size in u32s 

 Copy in the user's I2O command */

 TODO add 64 bit API

 Copy out the SG list to user's buffer if necessary */

I2O_SGL_FLAGS_DIR*/)) {

 sg_simple_element API is 32 bit

 Copy back the reply to user space */

 we wrote our own values for context - now restore the user supplied ones

 This is all the info we need for now

 We will add more info as our new

 managmenent utility requires it

 This is all the info we need for now

 We will add more info as our new

 managmenent utility requires it

 This is all the info we need for now

 We will add more info as our new

 managmenent utility requires it

 This is all the info we need for now

 We will add more info as our new

 managmenent utility requires it

 Just in case 

/*

 * This routine returns information about the system.  This does not effect

 * any logic and if the info is wrong - it doesn't matter.

 Get all the info we can not get from kernel services */

 found adapter */

 TODO: handle 3 cases

 Try twice then give up

 This really should not happen

 Ick, we should *never* be here */

 Transaction context is 0 in failed reply frame

 IOCTL

 All IOCTLs will also be post wait

 Post wait message

 Get detail status */

				/*

				 * The request tag is one less than the command tag

				 * as the firmware might treat a 0 tag as invalid

 SCSI message

			/*

			 * The request tag is one less than the command tag

			 * as the firmware might treat a 0 tag as invalid

 DATA NO XFER

		/*

		 * Set SCBFlags to indicate if data is being transferred

		 * in or out, or no data transfer

		 * Note:  Do not have to verify index is less than 0 since

		 * cmd->cmnd[0] is an unsigned char

 DATA IN  (iop<--dev)

 SGL OUT

 DATA OUT (iop-->dev)

 DATA IN  (iop<--dev)

 Assume In - and continue;

 msg[0] is set later

 I2O_CMD_SCSI_EXEC

 Add 1 to avoid firmware treating it as invalid command */

 Our cards use the transaction context as the tag for queueing

 Adaptec/DPT Private stuff 

 Direction, disconnect ok | sense data | simple queue , CDBLen */

 I2O_SCB_FLAG_ENABLE_DISCONNECT | 

 I2O_SCB_FLAG_SIMPLE_QUEUE_TAG | 

 I2O_SCB_FLAG_SENSE_DATA_IN_MESSAGE;

 Write SCSI command into the message - always 16 byte block 

 Remember me - fill in when we know */

 SINGLE SGE

 Enable 64 bit */

 SINGLE SGE

 Now fill in the SGList and command */

 Make this an end of list */

 Stick the headers on */

 Send it on it's way

	/* no IO ports, so don't have to set host->io_port and

	 * host->n_io_port

 see comments in scsi_host.h */

 Leave it shifted up 8 bits 

 I know this would look cleaner if I just read bytes

 but the model I have been using for all the rest of the

 io is in 4 byte words - so I keep that model

 calculate resid for sg 

 initialize sense valid flag to false

 handle underflow

 copy over the request sense data if it was a check

 condition status

 Copy over the sense data

 class 7 */ && 

 This is to handle an array failed */

		/* In this condtion we could not talk to the tid

		 * the card rejected it.  We should signal a retry

		 * for a limitted number of retries.

 at least 8 u32's

 Mark each drive as unscanned

 Something wrong skip it */

 da lun */

 Something new add it

 Too late, SCSI system has made up it's mind, but what the hey ...

 end of new i2o device

 We found an old device - check it

 something changed

 Found it - mark it scanned

 Drive offline drives that previously existed but could not be found

 in the LCT table

/*============================================================================

 *  Routines from i2o subsystem

 *============================================================================

/*

 *	Bring an I2O controller into HOLD state. See the spec.

 In HOLD state */

/*

 *	Bring a controller online into OPERATIONAL state. 

 In READY state */

 In OPERATIONAL state  */

 Transaction context */

 Host page frame size */

 Outbound msg frame size and Initcode */

 Simple SG LE, EOB */

 Wait for the reply status to come back

I2O_EXEC_OUTBOUND_INIT_IN_PROGRESS*/) {

			/* We lose 4 bytes of "status" here, but we

			   cannot free these because controller may

 dma_free_coherent(&pHba->pDev->dev, 4, status, addr); */

 If the command was successful, fill the fifo with our reply

 message packets

I2O_EXEC_OUTBOUND_INIT_COMPLETE*/) {

/*

 * I2O System Table.  Contains information about

 * all the IOPs in the system.  Used to inform IOPs

 * about each other's existence.

 *

 * sys_tbl_ver is the CurrentChangeIndicator that is

 * used by IOPs to track changes.

 88 bytes

post message

 Set up our number of outbound and inbound messages

 Calculate the Scatter Gather list size

/*

 * Get the IOP's Logical Configuration Table

 All devices */

 Report now */

 I2O_DPT_EXEC_IOP_BUFFERS_GROUP_NO;

 Header + IOPs

 Get updated Status Block so we have the latest information

 try next one	

 ??

/*

 *	 Dump the information block associated with a given unit (TID)

 ConfigDialog requested

 Multi-user capable

 Peer service enabled!

 Mgmt service enabled!

/*

 *	Do i2o class name lookup

 Simple transaction */

 Dump it here */

/*

 *	 Query one scalar group value or a whole scalar group.

 8 bytes for header */

 whole group */

 cut off header */

/*	Issue UTIL_PARAMS_GET or UTIL_PARAMS_SET

 *

 *	This function can be used for all UtilParamsGet/Set operations.

 *	The OperationBlock is given in opblk-buffer, 

 *	and results are returned in resblk-buffer.

 *	Note that the minimum sized resblk is 8 bytes and contains

 *	ResultCount, ErrorInfoSize, BlockStatus and BlockSize.

 OperationBlock */

 ResultBlock */

 -DetailedStatus */

 BlockStatus != SUCCESS */

 -BlockStatus */

 bytes used in resblk */

 SysQuiesce discarded if IOP not in READY or OPERATIONAL state */

/* 

 * Enable IOP. Allows the IOP to resume external operations.

 Enable only allowed on READY state */

 Host 0 IOP ID (unit + 2) */

 Segment 0 */

	/* 

	 * Provide three SGL-elements:

	 * System table (SysTab), Private memory space declaration and 

	 * Private i/o space declaration  

/*============================================================================

 *

 *============================================================================

 delay for one millisecond */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * iSCSI over TCP/IP Data-Path lib

 *

 * Copyright (C) 2004 Dmitry Yusupov

 * Copyright (C) 2004 Alex Aizman

 * Copyright (C) 2005 - 2006 Mike Christie

 * Copyright (C) 2006 Red Hat, Inc.  All rights reserved.

 * maintained by open-iscsi@googlegroups.com

 *

 * Credits:

 *	Christoph Hellwig

 *	FUJITA Tomonori

 *	Arne Redlich

 *	Zhenyu Wang

/*

 * Scatterlist handling: inside the iscsi_segment, we

 * remember an index into the scatterlist, and set data/size

 * to the current scatterlist entry. For highmem pages, we

 * kmap as needed.

 *

 * Note that the page is unmapped when we return from

 * TCP's data_ready handler, so we may end up mapping and

 * unmapping the same page repeatedly. The whole reason

 * for this is that we shouldn't keep the page mapped

 * outside the softirq.

/**

 * iscsi_tcp_segment_init_sg - init indicated scatterlist entry

 * @segment: the buffer object

 * @sg: scatterlist

 * @offset: byte offset into that sg entry

 *

 * This function sets up the segment so that subsequent

 * data is copied to the indicated sg entry, at the given

 * offset.

/**

 * iscsi_tcp_segment_map - map the current S/G page

 * @segment: iscsi_segment

 * @recv: 1 if called from recv path

 *

 * We only need to possibly kmap data if scatter lists are being used,

 * because the iscsi passthrough and internal IO paths will never use high

 * mem pages.

	/*

	 * We always map for the recv path.

	 *

	 * If the page count is greater than one it is ok to send

	 * to the network layer's zero copy send path. If not we

	 * have to go the slow sendmsg path.

	 *

	 * Same goes for slab pages: skb_can_coalesce() allows

	 * coalescing neighboring slab objects into a single frag which

	 * triggers one of hardened usercopy checks.

 the xmit path can sleep with the page mapped so use kmap */

/*

 * Splice the digest buffer into the buffer

/**

 * iscsi_tcp_segment_done - check whether the segment is complete

 * @tcp_conn: iscsi tcp connection

 * @segment: iscsi segment to check

 * @recv: set to one of this is called from the recv path

 * @copied: number of bytes copied

 *

 * Check if we're done receiving this segment. If the receive

 * buffer is full but we expect more data, move on to the

 * next entry in the scatterlist.

 *

 * If the amount of data we received isn't a multiple of 4,

 * we will transparently receive the pad bytes, too.

 *

 * This function must be re-entrant.

		/*

		 * If a segment is kmapd we must unmap it before sending

		 * to the crypto layer since that will try to kmap it again.

 Unmap the current scatterlist page, if there is one. */

 Do we have more scatterlist entries? */

 Proceed to the next entry in the scatterlist. */

 Do we need to handle padding? */

	/*

	 * Set us up for transferring the data digest. hdr digest

	 * is completely handled in hdr done function.

/**

 * iscsi_tcp_segment_recv - copy data to segment

 * @tcp_conn: the iSCSI TCP connection

 * @segment: the buffer to copy to

 * @ptr: data pointer

 * @len: amount of data available

 *

 * This function copies up to @len bytes to the

 * given buffer, and returns the number of bytes

 * consumed, which can actually be less than @len.

 *

 * If hash digest is enabled, the function will update the

 * hash while copying.

 * Combining these two operations doesn't buy us a lot (yet),

 * but in the future we could implement combined copy+crc,

 * just way we do for network layer checksums.

/*

 * Helper function to set up segment buffer

/**

 * iscsi_tcp_hdr_recv_prep - prep segment for hdr reception

 * @tcp_conn: iscsi connection to prep for

 *

 * This function always passes NULL for the hash argument, because when this

 * function is called we do not yet know the final size of the header and want

 * to delay the digest processing until we know that.

/*

 * Handle incoming reply to any other type of command

/**

 * iscsi_tcp_cleanup_task - free tcp_task resources

 * @task: iscsi task

 *

 * must be called with session back_lock

 nothing to do for mgmt */

 flush task's r2t queues */

/**

 * iscsi_tcp_data_in - SCSI Data-In Response processing

 * @conn: iscsi connection

 * @task: scsi command task

	/*

	 * lib iscsi will update this in the completion handling if there

	 * is status.

/**

 * iscsi_tcp_r2t_rsp - iSCSI R2T Response processing

 * @conn: iscsi connection

 * @hdr: PDU header

	/*

	 * A bad target might complete the cmd before we have handled R2Ts

	 * so get a ref to the task that will be dropped in the xmit path.

 Let the path that got the early rsp complete it */

 fill-in new R2T associated with the task */

 no flip */

/*

 * Handle incoming reply to DataIn command

 check for non-exceptional status */

/**

 * iscsi_tcp_hdr_dissect - process PDU header

 * @conn: iSCSI connection

 * @hdr: PDU header

 *

 * This function analyzes the header of the PDU received,

 * and performs several sanity checks. If the PDU is accompanied

 * by data, the receive buffer is set up to copy the incoming data

 * to the correct location.

 verify PDU length */

	/* Additional header segments. So far, we don't

	 * process additional headers.

 verify itt (itt encoding: age+cid+itt) */

			/*

			 * Setup copy of Data-In into the struct scsi_cmnd

			 * Scatterlist case:

			 * We set up the iscsi_segment to point to the next

			 * scatterlist entry to copy to. As we go along,

			 * we move on to the next scatterlist entry and

			 * update the digest per-entry.

		/*

		 * It is possible that we could get a PDU with a buffer larger

		 * than 8K, but there are no targets that currently do this.

		 * For now we fail until we find a vendor that needs it

		/* If there's data coming in with the response,

		 * receive it to the connection's buffer.

		/* Anything that comes with data should have

/**

 * iscsi_tcp_hdr_recv_done - process PDU header

 * @tcp_conn: iSCSI TCP connection

 * @segment: the buffer segment being processed

 *

 * This is the callback invoked when the PDU header has

 * been received. If the header is followed by additional

 * header segments, we go back for more data.

	/* Check if there are additional header segments

	 * *prior* to computing the digest, because we

	 * may need to go back to the caller for more.

		/* Bump the header length - the caller will

		 * just loop around and get the AHS for us, and

 Make sure we don't overflow */

	/* We're done processing the header. See if we're doing

	 * header digests; if so, set up the recv_digest buffer

			/*

			 * Even if we offload the digest processing we

			 * splice it in so we can increment the skb/segment

			 * counters in preparation for the data segment.

/**

 * iscsi_tcp_recv_segment_is_hdr - tests if we are reading in a header

 * @tcp_conn: iscsi tcp conn

 *

 * returns non zero if we are currently processing or setup to process

 * a header.

/**

 * iscsi_tcp_recv_skb - Process skb

 * @conn: iscsi connection

 * @skb: network buffer with header and/or data segment

 * @offset: offset in skb

 * @offloaded: bool indicating if transfer was offloaded

 * @status: iscsi TCP status result

 *

 * Will return status of transfer in @status. And will return

 * number of bytes copied.

	/*

	 * Update for each skb instead of pdu, because over slow networks a

	 * data_in's data could take a while to read in. We also want to

	 * account for r2ts.

 The done() functions sets up the next segment. */

/**

 * iscsi_tcp_task_init - Initialize iSCSI SCSI_READ or SCSI_WRITE commands

 * @task: scsi command task

		/*

		 * mgmt tasks do not have a scatterlist since they come

		 * in from the iscsi interface.

 Prepare PDU, optionally w/ immediate data */

 Continue with this R2T? */

/**

 * iscsi_tcp_task_xmit - xmit normal PDU task

 * @task: iscsi command task

 *

 * We're expected to return 0 when everything was transmitted successfully,

 * -EAGAIN if there's still data in the queue, or != 0 for any other kind

 * of error.

 Flush any pending data first. */

 mgmt command */

 Are we done already? */

 Waiting for more R2Ts to arrive. */

	/*

	 * due to strange issues with iser these are not set

	 * in iscsi_conn_setup

	/*

	 * initialize per-task: R2T pool and xmit queue

		/*

		 * pre-allocated x2 as much r2ts to handle race when

		 * target acks DataOut faster than we data_xmit() queues

		 * could replenish r2tqueue.

 R2T pool */

 R2T xmit queue */

 SPDX-License-Identifier: GPL-2.0-only

/*



  Linux Driver for BusLogic MultiMaster and FlashPoint SCSI Host Adapters



  Copyright 1995-1998 by Leonard N. Zubkoff <lnz@dandelion.com>





  The author respectfully requests that any modifications to this software be

  sent directly to him for evaluation and testing.



  Special thanks to Wayne Yen, Jin-Lon Hon, and Alex Win of BusLogic, whose

  advice has been invaluable, to David Gentzel, for writing the original Linux

  BusLogic driver, and to Paul Gortmaker, for being such a dedicated test site.



  Finally, special thanks to Mylex/BusLogic for making the FlashPoint SCCB

  Manager available as freely redistributable source code.



/*

  blogic_drvr_options_count is a count of the number of BusLogic Driver

  Options specifications provided via the Linux Kernel Command Line or via

  the Loadable Kernel Module Installation Facility.

/*

  blogic_drvr_options is an array of Driver Options structures representing

  BusLogic Driver Options specifications provided via the Linux Kernel Command

  Line or via the Loadable Kernel Module Installation Facility.

/*

  BusLogic can be assigned a string by insmod.

/*

  blogic_probe_options is a set of Probe Options to be applied across

  all BusLogic Host Adapters.

/*

  blogic_global_options is a set of Global Options to be applied across

  all BusLogic Host Adapters.

/*

  blogic_probeinfo_count is the number of entries in blogic_probeinfo_list.

/*

  blogic_probeinfo_list is the list of I/O Addresses and Bus Probe Information

  to be checked for potential BusLogic Host Adapters.  It is initialized by

  interrogating the PCI Configuration Space on PCI machines as well as from the

  list of standard BusLogic I/O Addresses.

/*

  blogic_cmd_failure_reason holds a string identifying the reason why a

  call to blogic_cmd failed.  It is only non-NULL when blogic_cmd

  returns a failure code.

/*

  blogic_announce_drvr announces the Driver Version and Date, Author's

  Name, Copyright Notice, and Electronic Mail Address.

/*

  blogic_drvr_info returns the Host Adapter Name to identify this SCSI

  Driver and Host Adapter.

/*

  blogic_init_ccbs initializes a group of Command Control Blocks (CCBs)

  for Host Adapter from the blk_size bytes located at blk_pointer.  The newly

  created CCBs are added to Host Adapter's free list.

/*

  blogic_create_initccbs allocates the initial CCBs for Host Adapter.

/*

  blogic_destroy_ccbs deallocates the CCBs for Host Adapter.

/*

  blogic_create_addlccbs allocates Additional CCBs for Host Adapter.  If

  allocation fails and there are no remaining CCBs available, the Driver Queue

  Depth is decreased to a known safe value to avoid potential deadlocks when

  multiple host adapters share the same IRQ Channel.

/*

  blogic_alloc_ccb allocates a CCB from Host Adapter's free list,

  allocating more memory from the Kernel if necessary.  The Host Adapter's

  Lock should already have been acquired by the caller.

/*

  blogic_dealloc_ccb deallocates a CCB, returning it to the Host Adapter's

  free list.  The Host Adapter's Lock should already have been acquired by the

  caller.

/*

  blogic_cmd sends the command opcode to adapter, optionally

  providing paramlen bytes of param and receiving at most

  replylen bytes of reply; any excess reply data is received but

  discarded.



  On success, this function returns the number of reply bytes read from

  the Host Adapter (including any discarded data); on failure, it returns

  -1 if the command was invalid, or -2 if a timeout occurred.



  blogic_cmd is called exclusively during host adapter detection and

  initialization, so performance and latency are not critical, and exclusive

  access to the Host Adapter hardware is assumed.  Once the host adapter and

  driver are initialized, the only Host Adapter command that is issued is the

  single byte Execute Mailbox Command operation code, which does not require

  waiting for the Host Adapter Ready bit to be set in the Status Register.

	/*

	   Clear out the Reply Data if provided.

	/*

	   If the IRQ Channel has not yet been acquired, then interrupts

	   must be disabled while issuing host adapter commands since a

	   Command Complete interrupt could occur if the IRQ Channel was

	   previously enabled by another BusLogic Host Adapter or another

	   driver sharing the same IRQ Channel.

	/*

	   Wait for the Host Adapter Ready bit to be set and the

	   Command/Parameter Register Busy bit to be reset in the Status

	   Register.

	/*

	   Write the opcode to the Command/Parameter Register.

	/*

	   Write any additional Parameter Bytes.

		/*

		   Wait 100 microseconds to give the Host Adapter enough

		   time to determine whether the last value written to the

		   Command/Parameter Register was valid or not. If the

		   Command Complete bit is set in the Interrupt Register,

		   then the Command Invalid bit in the Status Register will

		   be reset if the Operation Code or Parameter was valid

		   and the command has completed, or set if the Operation

		   Code or Parameter was invalid. If the Data In Register

		   Ready bit is set in the Status Register, then the

		   Operation Code was valid, and data is waiting to be read

		   back from the Host Adapter. Otherwise, wait for the

		   Command/Parameter Register Busy bit in the Status

		   Register to be reset.

	/*

	   The Modify I/O Address command does not cause a Command Complete

	   Interrupt.

	/*

	   Select an appropriate timeout value for awaiting command completion.

 Approximately 60 seconds. */

 Approximately 1 second. */

	/*

	   Receive any Reply Bytes, waiting for either the Command

	   Complete bit to be set in the Interrupt Register, or for the

	   Interrupt Handler to set the Host Adapter Command Completed

	   bit in the Host Adapter structure.

	/*

	   Clear any pending Command Complete Interrupt.

	/*

	   Provide tracing information if requested.

	/*

	   Process Command Invalid conditions.

		/*

		   Some early BusLogic Host Adapters may not recover

		   properly from a Command Invalid condition, so if this

		   appears to be the case, a Soft Reset is issued to the

		   Host Adapter.  Potentially invalid commands are never

		   attempted after Mailbox Initialization is performed,

		   so there should be no Host Adapter state lost by a

		   Soft Reset in response to a Command Invalid condition.

	/*

	   Handle Excess Parameters Supplied conditions.

	/*

	   Indicate the command completed successfully.

	/*

	   Restore the interrupt status if necessary and return.

/*

  blogic_sort_probeinfo sorts a section of blogic_probeinfo_list in order

  of increasing PCI Bus and Device Number.

/*

  blogic_init_mm_probeinfo initializes the list of I/O Address

  and Bus Probe Information to be checked for potential BusLogic MultiMaster

  SCSI Host Adapters by interrogating the PCI Configuration Space on PCI

  machines as well as from the list of standard BusLogic MultiMaster ISA

  I/O Addresses.  It returns the number of PCI MultiMaster Host Adapters found.

	/*

	   Iterate over the MultiMaster PCI Host Adapters.  For each

	   enumerated host adapter, determine whether its ISA Compatible

	   I/O Port is enabled and if so, whether it is assigned the

	   Primary I/O Address.  A host adapter that is assigned the

	   Primary I/O Address will always be the preferred boot device.

	   The MultiMaster BIOS will first recognize a host adapter at

	   the Primary I/O Address, then any other PCI host adapters,

	   and finally any host adapters located at the remaining

	   standard ISA I/O Addresses.  When a PCI host adapter is found

	   with its ISA Compatible I/O Port enabled, a command is issued

	   to disable the ISA Compatible I/O Port, and it is noted that the

	   particular standard ISA I/O Address need not be probed.

		/*

		   Issue the Inquire PCI Host Adapter Information command to determine

		   the ISA Compatible I/O Port.  If the ISA Compatible I/O Port is

		   known and enabled, note that the particular Standard ISA I/O

		   Address should not be probed.

		/*

		   Issue the Modify I/O Address command to disable the

		   ISA Compatible I/O Port. On PCI Host Adapters, the

		   Modify I/O Address command allows modification of the

		   ISA compatible I/O Address that the Host Adapter

		   responds to; it does not affect the PCI compliant

		   I/O Address assigned at system initialization.

		/*

		   For the first MultiMaster Host Adapter enumerated,

		   issue the Fetch Host Adapter Local RAM command to read

		   byte 45 of the AutoSCSI area, for the setting of the

		   "Use Bus And Device # For PCI Scanning Seq." option.

		   Issue the Inquire Board ID command since this option is

		   only valid for the BT-948/958/958D.

		/*

		   Determine whether this MultiMaster Host Adapter has its

		   ISA Compatible I/O Port enabled and is assigned the

		   Primary I/O Address. If it does, then it is the Primary

		   MultiMaster Host Adapter and must be recognized first.

		   If it does not, then it is added to the list for probing

		   after any Primary MultiMaster Host Adapter is probed.

	/*

	   If the AutoSCSI "Use Bus And Device # For PCI Scanning Seq."

	   option is ON for the first enumerated MultiMaster Host Adapter,

	   and if that host adapter is a BT-948/958/958D, then the

	   MultiMaster BIOS will recognize MultiMaster Host Adapters in

	   the order of increasing PCI Bus and Device Number. In that case,

	   sort the probe information into the same order the BIOS uses.

	   If this option is OFF, then the MultiMaster BIOS will recognize

	   MultiMaster Host Adapters in the order they are enumerated by

	   the PCI BIOS, and hence no sorting is necessary.

	/*

	   Iterate over the older non-compliant MultiMaster PCI Host Adapters,

	   noting the PCI bus location and assigned IRQ Channel.

/*

  blogic_init_fp_probeinfo initializes the list of I/O Address

  and Bus Probe Information to be checked for potential BusLogic FlashPoint

  Host Adapters by interrogating the PCI Configuration Space.  It returns the

  number of FlashPoint Host Adapters found.

	/*

	   Interrogate PCI Configuration Space for any FlashPoint Host Adapters.

	/*

	   The FlashPoint BIOS will scan for FlashPoint Host Adapters in the order of

	   increasing PCI Bus and Device Number, so sort the probe information into

	   the same order the BIOS uses.

/*

  blogic_init_probeinfo_list initializes the list of I/O Address and Bus

  Probe Information to be checked for potential BusLogic SCSI Host Adapters by

  interrogating the PCI Configuration Space on PCI machines as well as from the

  list of standard BusLogic MultiMaster ISA I/O Addresses.  By default, if both

  FlashPoint and PCI MultiMaster Host Adapters are present, this driver will

  probe for FlashPoint Host Adapters first unless the BIOS primary disk is

  controlled by the first PCI MultiMaster Host Adapter, in which case

  MultiMaster Host Adapters will be probed first.  The BusLogic Driver Options

  specifications "MultiMasterFirst" and "FlashPointFirst" can be used to force

  a particular probe order.

	/*

	   If a PCI BIOS is present, interrogate it for MultiMaster and

	   FlashPoint Host Adapters; otherwise, default to the standard

	   ISA MultiMaster probe.

				/*

				   If the Map Byte for BIOS Drive 0 indicates

				   that BIOS Drive 0 is controlled by this

				   PCI MultiMaster Host Adapter, then reverse

				   the probe order so that MultiMaster Host

				   Adapters are probed before FlashPoint Host

				   Adapters.

/*

  blogic_failure prints a standardized error message, and then returns false.

/*

  blogic_probe probes for a BusLogic Host Adapter.

	/*

	   FlashPoint Host Adapters are Probed by the FlashPoint SCCB Manager.

		/*

		   Indicate the Host Adapter Probe completed successfully.

	/*

	   Read the Status, Interrupt, and Geometry Registers to test if there are I/O

	   ports that respond, and to check the values to determine if they are from a

	   BusLogic Host Adapter.  A nonexistent I/O port will return 0xFF, in which

	   case there is definitely no BusLogic Host Adapter at this base I/O Address.

	   The test here is a subset of that used by the BusLogic Host Adapter BIOS.

	/*

	   Check the undocumented Geometry Register to test if there is

	   an I/O port that responded.  Adaptec Host Adapters do not

	   implement the Geometry Register, so this test helps serve to

	   avoid incorrectly recognizing an Adaptec 1542A or 1542B as a

	   BusLogic.  Unfortunately, the Adaptec 1542C series does respond

	   to the Geometry Register I/O port, but it will be rejected

	   later when the Inquire Extended Setup Information command is

	   issued in blogic_checkadapter.  The AMI FastDisk Host Adapter

	   is a BusLogic clone that implements the same interface as

	   earlier BusLogic Host Adapters, including the undocumented

	   commands, and is therefore supported by this driver. However,

	   the AMI FastDisk always returns 0x00 upon reading the Geometry

	   Register, so the extended translation option should always be

	   left disabled on the AMI FastDisk.

	/*

	   Indicate the Host Adapter Probe completed successfully.

/*

  blogic_hwreset issues a Hardware Reset to the Host Adapter

  and waits for Host Adapter Diagnostics to complete.  If hard_reset is true, a

  Hard Reset is performed which also initiates a SCSI Bus Reset.  Otherwise, a

  Soft Reset is performed which only resets the Host Adapter without forcing a

  SCSI Bus Reset.

	/*

	   FlashPoint Host Adapters are Hard Reset by the FlashPoint

	   SCCB Manager.

		/*

		   Indicate the Host Adapter Hard Reset completed successfully.

	/*

	   Issue a Hard Reset or Soft Reset Command to the Host Adapter.

	   The Host Adapter should respond by setting Diagnostic Active in

	   the Status Register.

	/*

	   Wait until Diagnostic Active is set in the Status Register.

	/*

	   Wait 100 microseconds to allow completion of any initial diagnostic

	   activity which might leave the contents of the Status Register

	   unpredictable.

	/*

	   Wait until Diagnostic Active is reset in the Status Register.

	/*

	   Wait until at least one of the Diagnostic Failure, Host Adapter

	   Ready, or Data In Register Ready bits is set in the Status Register.

	/*

	   If Diagnostic Failure is set or Host Adapter Ready is reset,

	   then an error occurred during the Host Adapter diagnostics.

	   If Data In Register Ready is set, then there is an Error Code

	   available.

	/*

	   Indicate the Host Adapter Hard Reset completed successfully.

/*

  blogic_checkadapter checks to be sure this really is a BusLogic

  Host Adapter.

	/*

	   FlashPoint Host Adapters do not require this protection.

	/*

	   Issue the Inquire Extended Setup Information command. Only genuine

	   BusLogic Host Adapters and true clones support this command.

	   Adaptec 1542C series Host Adapters that respond to the Geometry

	   Register I/O port will fail this command.

	/*

	   Provide tracing information if requested and return.

/*

  blogic_rdconfig reads the Configuration Information

  from Host Adapter and initializes the Host Adapter structure.

	/*

	   Configuration Information for FlashPoint Host Adapters is

	   provided in the fpoint_info structure by the FlashPoint

	   SCCB Manager's Probe Function. Initialize fields in the

	   Host Adapter structure from the fpoint_info structure.

	/*

	   Issue the Inquire Board ID command.

	/*

	   Issue the Inquire Configuration command.

	/*

	   Issue the Inquire Setup Information command.

	/*

	   Issue the Inquire Extended Setup Information command.

	/*

	   Issue the Inquire Firmware Version 3rd Digit command.

	/*

	   Issue the Inquire Host Adapter Model Number command.

 BusLogic BT-542B ISA 2.xx */

 BusLogic BT-742A EISA 2.1x or 2.20 */

 AMI FastDisk EISA Series 441 0.x */

	/*

	   BusLogic MultiMaster Host Adapters can be identified by their

	   model number and the major version number of their firmware

	   as follows:



	   5.xx       BusLogic "W" Series Host Adapters:

	   BT-948/958/958D

	   4.xx       BusLogic "C" Series Host Adapters:

	   BT-946C/956C/956CD/747C/757C/757CD/445C/545C/540CF

	   3.xx       BusLogic "S" Series Host Adapters:

	   BT-747S/747D/757S/757D/445S/545S/542D

	   BT-542B/742A (revision H)

	   2.xx       BusLogic "A" Series Host Adapters:

	   BT-542B/742A (revision G and below)

	   0.xx       AMI FastDisk VLB/EISA BusLogic Clone Host Adapter

	/*

	   Save the Model Name and Host Adapter Name in the Host Adapter

	   structure.

	/*

	   Save the Firmware Version in the Host Adapter structure.

	/*

	   Issue the Inquire Firmware Version Letter command.

	/*

	   Save the Host Adapter SCSI ID in the Host Adapter structure.

	/*

	   Determine the Bus Type and save it in the Host Adapter structure,

	   determine and save the IRQ Channel if necessary, and determine

	   and save the DMA Channel for ISA Host Adapters.

	/*

	   Determine whether Extended Translation is enabled and save it in

	   the Host Adapter structure.

	/*

	   Save the Scatter Gather Limits, Level Sensitive Interrupt flag, Wide

	   SCSI flag, Differential SCSI flag, SCAM Supported flag, and

	   Ultra SCSI flag in the Host Adapter structure.

	/*

	   Determine whether Extended LUN Format CCBs are supported and save the

	   information in the Host Adapter structure.

	/*

	   Issue the Inquire PCI Host Adapter Information command to read the

	   Termination Information from "W" series MultiMaster Host Adapters.

		/*

		   Save the Termination Information in the Host Adapter

		   structure.

	/*

	   Issue the Fetch Host Adapter Local RAM command to read the

	   AutoSCSI data from "W" and "C" series MultiMaster Host Adapters.

		/*

		   Save the Parity Checking Enabled, Bus Reset Enabled,

		   and Termination Information in the Host Adapter structure.

		/*

		   Save the Wide Permitted, Fast Permitted, Synchronous

		   Permitted, Disconnect Permitted, Ultra Permitted, and

		   SCAM Information in the Host Adapter structure.

	/*

	   Initialize fields in the Host Adapter structure for "S" and "A"

	   series MultiMaster Host Adapters.

	/*

	   Determine the maximum number of Target IDs and Logical Units

	   supported by this driver for Wide and Narrow Host Adapters.

	/*

	   Select appropriate values for the Mailbox Count, Driver Queue Depth,

	   Initial CCBs, and Incremental CCBs variables based on whether

	   or not Strict Round Robin Mode is supported.  If Strict Round

	   Robin Mode is supported, then there is no performance degradation

	   in using the maximum possible number of Outgoing and Incoming

	   Mailboxes and allowing the Tagged and Untagged Queue Depths to

	   determine the actual utilization.  If Strict Round Robin Mode is

	   not supported, then the Host Adapter must scan all the Outgoing

	   Mailboxes whenever an Outgoing Mailbox entry is made, which can

	   cause a substantial performance penalty.  The host adapters

	   actually have room to store the following number of CCBs

	   internally; that is, they can internally queue and manage this

	   many active commands on the SCSI bus simultaneously.  Performance

	   measurements demonstrate that the Driver Queue Depth should be

	   set to the Mailbox Count, rather than the Host Adapter Queue

	   Depth (internal CCB capacity), as it is more efficient to have the

	   queued commands waiting in Outgoing Mailboxes if necessary than

	   to block the process in the higher levels of the SCSI Subsystem.



	   192          BT-948/958/958D

	   100          BT-946C/956C/956CD/747C/757C/757CD/445C

	   50   BT-545C/540CF

	   30   BT-747S/747D/757S/757D/445S/545S/542D/542B/742A

	/*

	   Tagged Queuing support is available and operates properly on

	   all "W" series MultiMaster Host Adapters, on "C" series

	   MultiMaster Host Adapters with firmware version 4.22 and above,

	   and on "S" series MultiMaster Host Adapters with firmware version

	   3.35 and above.

	/*

	   Determine the Host Adapter BIOS Address if the BIOS is enabled and

	   save it in the Host Adapter structure.  The BIOS is disabled if the

	   bios_addr is 0.

	/*

	   BusLogic BT-445S Host Adapters prior to board revision E have a

	   hardware bug whereby when the BIOS is enabled, transfers to/from

	   the same address range the BIOS occupies modulo 16MB are handled

	   incorrectly.  Only properly functioning BT-445S Host Adapters

	   have firmware version 3.37.

	/*

	   Initialize parameters common to MultiMaster and FlashPoint

	   Host Adapters.

	/*

	   Initialize the Host Adapter Full Model Name from the Model Name.

	/*

	   Select an appropriate value for the Tagged Queue Depth either from a

	   BusLogic Driver Options specification, or based on whether this Host

	   Adapter requires that ISA Bounce Buffers be used.  The Tagged Queue

	   Depth is left at 0 for automatic determination in

	   BusLogic_SelectQueueDepths. Initialize the Untagged Queue Depth.

	/*

	   Tagged Queuing is only allowed if Disconnect/Reconnect is permitted.

	   Therefore, mask the Tagged Queuing Permitted Default bits with the

	   Disconnect/Reconnect Permitted bits.

	/*

	   Combine the default Tagged Queuing Permitted bits with any

	   BusLogic Driver Options Tagged Queuing specification.

	/*

	   Select an appropriate value for Bus Settle Time either from a

	   BusLogic Driver Options specification, or from

	   BLOGIC_BUS_SETTLE_TIME.

	/*

	   Indicate reading the Host Adapter Configuration completed

	   successfully.

/*

  blogic_reportconfig reports the configuration of Host Adapter.

	/*

	   Indicate reporting the Host Adapter configuration completed

	   successfully.

/*

  blogic_getres acquires the system resources necessary to use

  Host Adapter.

	/*

	   Acquire shared access to the IRQ Channel.

	/*

	   Indicate the System Resource Acquisition completed successfully,

/*

  blogic_relres releases any system resources previously acquired

  by blogic_getres.

	/*

	   Release shared access to the IRQ Channel.

	/*

	   Release any allocated memory structs not released elsewhere

/*

  blogic_initadapter initializes Host Adapter.  This is the only

  function called during SCSI Host Adapter detection which modifies the state

  of the Host Adapter from its initial power on or hard reset state.

	/*

	   Initialize the pointers to the first and last CCBs that are

	   queued for completion processing.

	/*

	   Initialize the Bus Device Reset Pending CCB, Tagged Queuing Active,

	   Command Successful Flag, Active Commands, and Commands Since Reset

	   for each Target Device.

	/*

	   FlashPoint Host Adapters do not use Outgoing and Incoming Mailboxes.

	/*

	   Initialize the Outgoing and Incoming Mailbox pointers.

	/*

	   Initialize the Outgoing and Incoming Mailbox structures.

	/*

	   Initialize the Host Adapter's Pointer to the Outgoing/Incoming

	   Mailboxes.

	/*

	   Enable Strict Round Robin Mode if supported by the Host Adapter. In

	   Strict Round Robin Mode, the Host Adapter only looks at the next

	   Outgoing Mailbox for each new command, rather than scanning

	   through all the Outgoing Mailboxes to find any that have new

	   commands in them.  Strict Round Robin Mode is significantly more

	   efficient.

	/*

	   For Host Adapters that support Extended LUN Format CCBs, issue the

	   Set CCB Format command to allow 32 Logical Units per Target Device.

	/*

	   Announce Successful Initialization.

	/*

	   Indicate the Host Adapter Initialization completed successfully.

/*

  blogic_inquiry inquires about the Target Devices accessible

  through Host Adapter.

	/*

	   Wait a few seconds between the Host Adapter Hard Reset which

	   initiates a SCSI Bus Reset and issuing any SCSI Commands. Some

	   SCSI devices get confused if they receive SCSI Commands too soon

	   after a SCSI Bus Reset.

	/*

	   FlashPoint Host Adapters do not provide for Target Device Inquiry.

	/*

	   Inhibit the Target Device Inquiry if requested.

	/*

	   Issue the Inquire Target Devices command for host adapters with

	   firmware version 4.25 or later, or the Inquire Installed Devices

	   ID 0 to 7 command for older host adapters.  This is necessary to

	   force Synchronous Transfer Negotiation so that the Inquire Setup

	   Information and Inquire Synchronous Period commands will return

	   valid data.  The Inquire Target Devices command is preferable to

	   Inquire Installed Devices ID 0 to 7 since it only probes Logical

	   Unit 0 of each Target Device.

		/*

		   Issue a Inquire Target Devices command. Inquire Target

		   Devices only tests Logical Unit 0 of each Target Device

		   unlike the Inquire Installed Devices commands which test

		   Logical Units 0 - 7.  Two bytes are returned, where byte

		   0 bit 0 set indicates that Target Device 0 exists, and so on.

		/*

		   Issue an Inquire Installed Devices command. For each

		   Target Device, a byte is returned where bit 0 set

		   indicates that Logical Unit 0 * exists, bit 1 set

		   indicates that Logical Unit 1 exists, and so on.

	/*

	   Issue the Inquire Setup Information command.

	/*

	   Issue the Inquire Synchronous Period command.

		/* Issue a Inquire Synchronous Period command. For each

		   Target Device, a byte is returned which represents the

		   Synchronous Transfer Period in units of 10 nanoseconds.

	/*

	   Indicate the Target Device Inquiry completed successfully.

/*

  blogic_inithoststruct initializes the fields in the SCSI Host

  structure.  The base, io_port, n_io_ports, irq, and dma_channel fields in the

  SCSI Host structure are intentionally left uninitialized, as this driver

  handles acquisition and release of these resources explicitly, as well as

  ensuring exclusive access to the Host Adapter hardware and data structures

  through explicit acquisition and release of the Host Adapter's Lock.

/*

  blogic_slaveconfig will actually set the queue depth on individual

  scsi devices as they are permanently added to the device chain.  We

  shamelessly rip off the SelectQueueDepths code to make this work mostly

  like it used to.  Since we don't get called once at the end of the scan

  but instead get called for each device, we have to do things a bit

  differently.

/*

  blogic_init probes for BusLogic Host Adapters at the standard

  I/O Addresses where they may be located, initializing, registering, and

  reporting the configuration of each BusLogic Host Adapter it finds.  It

  returns the number of BusLogic Host Adapters successfully initialized and

  registered.

		/*

		   Make sure region is free prior to probing.

		/*

		   Probe the Host Adapter. If unsuccessful, abort further

		   initialization.

		/*

		   Hard Reset the Host Adapter.  If unsuccessful, abort further

		   initialization.

		/*

		   Check the Host Adapter.  If unsuccessful, abort further

		   initialization.

		/*

		   Initialize the Driver Options field if provided.

		/*

		   Announce the Driver Version and Date, Author's Name,

		   Copyright Notice, and Electronic Mail Address.

		/*

		   Register the SCSI Host structure.

		/*

		   Add Host Adapter to the end of the list of registered

		   BusLogic Host Adapters.

		/*

		   Read the Host Adapter Configuration, Configure the Host

		   Adapter, Acquire the System Resources necessary to use

		   the Host Adapter, then Create the Initial CCBs, Initialize

		   the Host Adapter, and finally perform Target Device

		   Inquiry. From this point onward, any failure will be

		   assumed to be due to a problem with the Host Adapter,

		   rather than due to having mistakenly identified this port

		   as belonging to a BusLogic Host Adapter. The I/O Address

		   range will not be released, thereby preventing it from

		   being incorrectly identified as any other type of Host

		   Adapter.

			/*

			   Initialization has been completed successfully.

			   Release and re-register usage of the I/O Address

			   range so that the Model Name of the Host Adapter

			   will appear, and initialize the SCSI Host structure.

			/*

			   An error occurred during Host Adapter Configuration

			   Querying, Host Adapter Configuration, Resource

			   Acquisition, CCB Creation, Host Adapter

			   Initialization, or Target Device Inquiry, so

			   remove Host Adapter from the list of registered

			   BusLogic Host Adapters, destroy the CCBs, Release

			   the System Resources, and Unregister the SCSI

			   Host.

/*

  blogic_deladapter releases all resources previously acquired to

  support a specific Host Adapter, including the I/O Address range, and

  unregisters the BusLogic Host Adapter.

	/*

	   FlashPoint Host Adapters must first be released by the FlashPoint

	   SCCB Manager.

	/*

	   Destroy the CCBs and release any system resources acquired to

	   support Host Adapter.

	/*

	   Release usage of the I/O Address range.

	/*

	   Remove Host Adapter from the list of registered BusLogic

	   Host Adapters.

/*

  blogic_qcompleted_ccb queues CCB for completion processing.

/*

  blogic_resultcode computes a SCSI Subsystem Result Code from

  the Host Adapter Status and Target Device Status.

/*

  blogic_scan_inbox scans the Incoming Mailboxes saving any

  Incoming Mailbox entries for completion processing.

	/*

	   Scan through the Incoming Mailboxes in Strict Round Robin

	   fashion, saving any completed CCBs for further processing. It

	   is essential that for each CCB and SCSI Command issued, command

	   completion processing is performed exactly once.  Therefore,

	   only Incoming Mailboxes with completion code Command Completed

	   Without Error, Command Completed With Error, or Command Aborted

	   At Host Request are saved for completion processing. When an

	   Incoming Mailbox has a completion code of Aborted Command Not

	   Found, the CCB had already completed or been aborted before the

	   current Abort request was processed, and so completion processing

	   has already occurred and no further action should be taken.

		/*

		   We are only allowed to do this because we limit our

		   architectures we run on to machines where bus_to_virt(

		   actually works.  There *needs* to be a dma_addr_to_virt()

		   in the new PCI DMA mapping interface to replace

		   bus_to_virt() or else this code is going to become very

		   innefficient.

				/*

				   Save the Completion Code for this CCB and

				   queue the CCB for completion processing.

				/*

				   If a CCB ever appears in an Incoming Mailbox

				   and is not marked as status Active or Reset,

				   then there is most likely a bug in

				   the Host Adapter firmware.

/*

  blogic_process_ccbs iterates over the completed CCBs for Host

  Adapter setting the SCSI Command Result Codes, deallocating the CCBs, and

  calling the SCSI Subsystem Completion Routines.  The Host Adapter's Lock

  should already have been acquired by the caller.

		/*

		   Process the Completed CCB.

			/*

			   Place CCB back on the Host Adapter's free list.

 this needs to be redone different for new EH */

			/*

			   Bus Device Reset CCBs have the command field

			   non-NULL only when a Bus Device Reset was requested

			   for a command that did not have a currently active

			   CCB in the Host Adapter (i.e., a Synchronous Bus

			   Device Reset), and hence would not have its

			   Completion Routine called otherwise.

			/*

			   Iterate over the CCBs for this Host Adapter

			   performing completion processing for any CCBs

			   marked as Reset for this Target.

			/*

			   Translate the Completion Code, Host Adapter Status,

			   and Target Device Status into a SCSI Subsystem

			   Result Code.

			/*

			   When an INQUIRY command completes normally, save the

			   CmdQue (Tagged Queuing Supported) and WBus16 (16 Bit

			   Wide Data Transfers Supported) bits.

			/*

			   Place CCB back on the Host Adapter's free list.

			/*

			   Call the SCSI Command Completion Routine.

/*

  blogic_inthandler handles hardware interrupts from BusLogic Host

  Adapters.

	/*

	   Acquire exclusive access to Host Adapter.

	/*

	   Handle Interrupts appropriately for each Host Adapter type.

		/*

		   Read the Host Adapter Interrupt Register.

			/*

			   Acknowledge the interrupt and reset the Host Adapter

			   Interrupt Register.

			/*

			   Process valid External SCSI Bus Reset and Incoming

			   Mailbox Loaded Interrupts. Command Complete

			   Interrupts are noted, and Outgoing Mailbox Available

			   Interrupts are ignored, as they are never enabled.

		/*

		   Check if there is a pending interrupt for this Host Adapter.

	/*

	   Process any completed CCBs.

	/*

	   Reset the Host Adapter if requested.

	/*

	   Release exclusive access to Host Adapter.

/*

  blogic_write_outbox places CCB and Action Code into an Outgoing

  Mailbox for execution by Host Adapter.  The Host Adapter's Lock should

  already have been acquired by the caller.

		/*

		   The CCB field must be written before the Action Code field

		   since the Host Adapter is operating asynchronously and the

		   locking code does not protect against simultaneous access

		   by the Host Adapter.

 Error Handling (EH) support */

/*

  blogic_qcmd creates a CCB for Command and places it into an

  Outgoing Mailbox for execution by the associated Host Adapter.

	/*

	   SCSI REQUEST_SENSE commands will be executed automatically by the

	   Host Adapter for any errors, so they should not be executed

	   explicitly unless the Sense Data is zero indicating that no error

	   occurred.

	/*

	   Allocate a CCB from the Host Adapter's free list. In the unlikely

	   event that there are none available and memory allocation fails,

	   wait 1 second and try again. If that fails, the Host Adapter is

	   probably hung so signal an error as a Host Adapter Hard Reset

	   should be initiated soon.

	/*

	   Initialize the fields in the BusLogic Command Control Block (CCB).

	/*

	   BusLogic recommends that after a Reset the first couple of

	   commands that are sent to a Target Device be sent in a non

	   Tagged Queue fashion so that the Host Adapter and Target Device

	   can establish Synchronous and Wide Transfer before Queue Tag

	   messages can interfere with the Synchronous and Wide Negotiation

	   messages.  By waiting to enable Tagged Queuing until after the

	   first BLOGIC_MAX_TAG_DEPTH commands have been queued, it is

	   assured that after a Reset any pending commands are requeued

	   before Tagged Queuing is enabled and that the Tagged Queuing

	   message will not occur while the partition table is being printed.

	   In addition, some devices do not properly handle the transition

	   from non-tagged to tagged commands, so it is necessary to wait

	   until there are no pending commands for a target device

	   before queuing tagged commands.

		/*

		   When using Tagged Queuing with Simple Queue Tags, it

		   appears that disk drive controllers do not guarantee that

		   a queued command will not remain in a disconnected state

		   indefinitely if commands that read or write nearer the

		   head position continue to arrive without interruption.

		   Therefore, for each Target Device this driver keeps track

		   of the last time either the queue was empty or an Ordered

		   Queue Tag was issued. If more than 4 seconds (one fifth

		   of the 20 second disk timeout) have elapsed since this

		   last sequence point, this command will be issued with an

		   Ordered Queue Tag rather than a Simple Queue Tag, which

		   forces the Target Device to complete all previously

		   queued commands before this command may be executed.

		/*

		   Place the CCB in an Outgoing Mailbox. The higher levels

		   of the SCSI Subsystem should not attempt to queue more

		   commands than can be placed in Outgoing Mailboxes, so

		   there should always be one free.  In the unlikely event

		   that there are none available, wait 1 second and try

		   again. If that fails, the Host Adapter is probably hung

		   so signal an error as a Host Adapter Hard Reset should

		   be initiated soon.

		/*

		   Call the FlashPoint SCCB Manager to start execution of

		   the CCB.

		/*

		   The Command may have already completed and

		   blogic_qcompleted_ccb been called, or it may still be

		   pending.

/*

  blogic_abort aborts Command if possible.

	/*

	   Attempt to find an Active CCB for this Command. If no Active

	   CCB for this Command is found, then no Abort is necessary.

		/*

		   Attempt to Abort this CCB.  MultiMaster Firmware versions

		   prior to 5.xx do not generate Abort Tag messages, but only

		   generate the non-tagged Abort message.  Since non-tagged

		   commands are not sent by the Host Adapter until the queue

		   of outstanding tagged commands has completed, and the

		   Abort message is treated as a non-tagged command, it is

		   effectively impossible to abort commands when Tagged

		   Queuing is active. Firmware version 5.xx does generate

		   Abort Tag messages, so it is possible to abort commands

		   when Tagged Queuing is active.

		/*

		   Call the FlashPoint SCCB Manager to abort execution of

		   the CCB.

		/*

		   The Abort may have already been completed and

		   blogic_qcompleted_ccb been called, or it

		   may still be pending.

/*

  blogic_resetadapter resets Host Adapter if possible, marking all

  currently executing SCSI Commands as having been Reset.

	/*

	 * Attempt to Reset and Reinitialize the Host Adapter.

	/*

	 * Deallocate all currently executing CCBs.

	/*

	 * Wait a few seconds between the Host Adapter Hard Reset which

	 * initiates a SCSI Bus Reset and issuing any SCSI Commands.  Some

	 * SCSI devices get confused if they receive SCSI Commands too soon

	 * after a SCSI Bus Reset.

/*

  blogic_diskparam returns the Heads/Sectors/Cylinders BIOS Disk

  Parameters for Disk.  The default disk geometry is 64 heads, 32 sectors, and

  the appropriate number of cylinders so as not to exceed drive capacity.  In

  order for disks equal to or larger than 1 GB to be addressable by the BIOS

  without exceeding the BIOS limitation of 1024 cylinders, Extended Translation

  may be enabled in AutoSCSI on FlashPoint Host Adapters and on "W" and "C"

  series MultiMaster Host Adapters, or by a dip switch setting on "S" and "A"

  series MultiMaster Host Adapters.  With Extended Translation enabled, drives

  between 1 GB inclusive and 2 GB exclusive are given a disk geometry of 128

  heads and 32 sectors, and drives above 2 GB inclusive are given a disk

  geometry of 255 heads and 63 sectors.  However, if the BIOS detects that the

  Extended Translation setting does not match the geometry in the partition

  table, then the translation inferred from the partition table will be used by

  the BIOS, and a warning may be displayed.

 1 GB in 512 byte sectors */) {

 2 GB in 512 byte sectors */) {

	/*

	   If the boot sector partition table flag is valid, search for

	   a partition table entry whose end_head matches one of the

	   standard BusLogic geometry translations (64/32, 128/32, or 255/63).

/*

  BugLogic_ProcDirectoryInfo implements /proc/scsi/BusLogic/<N>.

  \\\\\\\\ Attempted \n\

/*

  blogic_msg prints Driver Messages.

/*

  blogic_parse parses an individual option keyword.  It returns true

  and updates the pointer if the keyword is recognized and false otherwise.

/*

  blogic_parseopts handles processing of BusLogic Driver Options

  specifications.



  BusLogic Driver Options may be specified either via the Linux Kernel Command

  Line or via the Loadable Kernel Module Installation Facility.  Driver Options

  for multiple host adapters may be specified either by separating the option

  strings by a semicolon, or by specifying multiple "BusLogic=" strings on the

  command line.  Individual option specifications for a single host adapter are

  separated by commas.  The Probing and Debugging Options apply to all host

  adapters whereas the remaining options apply individually only to the

  selected host adapter.



  The BusLogic Driver Probing Options are described in

  <file:Documentation/scsi/BusLogic.rst>.

 Tagged Queuing Options. */

 Miscellaneous Options. */

 Debugging Options. */

		/*

		   Tagged Queuing is disabled when the Queue Depth is 1 since queuing

		   multiple commands is not possible.

/*

  Get it all started

/*

  blogic_setup handles processing of Kernel Command Line Arguments.

/*

 * Exit function.  Deletes all hosts associated with this driver.

/*static struct pci_device_id blogic_pci_tbl[] = {

	{ PCI_VENDOR_ID_BUSLOGIC, PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER,

	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},

	{ PCI_VENDOR_ID_BUSLOGIC, PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER_NC,

	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},

	{ PCI_VENDOR_ID_BUSLOGIC, PCI_DEVICE_ID_BUSLOGIC_FLASHPOINT,

	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},

	{ }

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Detection routine for the NCR53c710 based Amiga SCSI Controllers for Linux.

 *		Amiga MacroSystemUS WarpEngine SCSI controller.

 *		Amiga Technologies/DKB A4091 SCSI controller.

 *

 * Written 1997 by Alan Hourihane <alanh@fairlite.demon.co.uk>

 * plus modifications of the 53c7xx.c driver to support the Amiga.

 *

 * Rewritten to use 53c700.c by Kars de Jong <jongk@linux-m68k.org>

 offset is absolute address */

 Fill in the required pieces of hostdata */

 Settings for at least WarpEngine 40xx */

 and register the chip */

 SPDX-License-Identifier: GPL-2.0

/*

 * scsi_scan.c

 *

 * Copyright (C) 2000 Eric Youngdale,

 * Copyright (C) 2002 Patrick Mansfield

 *

 * The general scanning/probing algorithm is as follows, exceptions are

 * made to it depending on device specific flags, compilation options, and

 * global variable (boot or module load time) settings.

 *

 * A specific LUN is scanned via an INQUIRY command; if the LUN has a

 * device attached, a scsi_device is allocated and setup for it.

 *

 * For every id of every channel on the given host:

 *

 * 	Scan LUN 0; if the target responds to LUN 0 (even if there is no

 * 	device or storage attached to LUN 0):

 *

 * 		If LUN 0 has a device attached, allocate and setup a

 * 		scsi_device for it.

 *

 * 		If target is SCSI-3 or up, issue a REPORT LUN, and scan

 * 		all of the LUNs returned by the REPORT LUN; else,

 * 		sequentially scan LUNs up until some maximum is reached,

 * 		or a LUN is seen that cannot have a device attached to it.

/*

 * Default timeout

/*

 * Prefix values for the SCSI id's (stored in sysfs name field)

/*

 * Return values of some of the scanning functions.

 *

 * SCSI_SCAN_NO_RESPONSE: no valid response received from the target, this

 * includes allocation or general failures preventing IO from being sent.

 *

 * SCSI_SCAN_TARGET_PRESENT: target responded, but no device is available

 * on the given LUN.

 *

 * SCSI_SCAN_LUN_PRESENT: target responded, and a device is available on a

 * given LUN.

 This lock protects only this list */

/**

 * scsi_enable_async_suspend - Enable async suspend and resume

	/*

	 * If a user has disabled async probing a likely reason is due to a

	 * storage enclosure that does not inject staggered spin-ups. For

	 * safety, make resume synchronous as well in that case.

 Enable asynchronous suspend and resume. */

/**

 * scsi_complete_async_scans - Wait for asynchronous scans to complete

 *

 * When this function returns, any host which started scanning before

 * this function was called will have finished its scan.  Hosts which

 * started scanning after this function was called may or may not have

 * finished.

		/* If we can't get memory immediately, that's OK.  Just

		 * sleep a little.  Even if we never get memory, the async

		 * scans will finish eventually.

 Check that there's still somebody else on the list */

/**

 * scsi_unlock_floptical - unlock device via a special MODE SENSE command

 * @sdev:	scsi device to send command to

 * @result:	area to store the result of the MODE SENSE

 *

 * Description:

 *     Send a vendor specific MODE SENSE (not a MODE SELECT) command.

 *     Called for BLIST_KEY devices.

 size */

/**

 * scsi_alloc_sdev - allocate and setup a scsi_Device

 * @starget: which target to allocate a &scsi_device for

 * @lun: which lun

 * @hostdata: usually NULL and set by ->slave_alloc instead

 *

 * Description:

 *     Allocate, initialize for io, and return a pointer to a scsi_Device.

 *     Stores the @shost, @channel, @id, and @lun in the scsi_Device, and

 *     adds scsi_Device to the appropriate list.

 *

 * Return value:

 *     scsi_Device pointer, or NULL on failure.

 usually NULL and set by ->slave_alloc instead */

	/* if the device needs this changing, it may do so in the

	/*

	 * Some low level driver could use device->type

	/*

	 * Assume that the device will have handshaking problems,

	 * and then fix this field later if it turns out it

	 * doesn't

		/* release fn is set up in scsi_sysfs_device_initialise, so

	/*

	 * Use .can_queue as budget map's depth because we have to

	 * support adjusting queue depth from sysfs. Meantime use

	 * default device queue depth to figure out sbitmap shift

	 * since we use this queue depth most of times.

			/*

			 * if LLDD reports slave not present, don't clutter

			 * console with alloc failure messages

	/*

	 * Search for an existing target for this sdev.

/**

 * scsi_target_reap_ref_release - remove target from visibility

 * @kref: the reap_ref in the target being released

 *

 * Called on last put of reap_ref, which is the indication that no device

 * under this target is visible anymore, so render the target invisible in

 * sysfs.  Note: we have to be in user context here because the target reaps

 * should be done in places where the scsi device visibility is being removed.

	/*

	 * if we get here and the target is still in a CREATED state that

	 * means it was allocated but never made visible (because a scan

	 * turned up no LUNs), so don't call device_del() on it.

/**

 * scsi_alloc_target - allocate a new or find an existing target

 * @parent:	parent of the target (need not be a scsi host)

 * @channel:	target channel number (zero if no channels)

 * @id:		target id number

 *

 * Return an existing target if one exists, provided it hasn't already

 * gone into STARGET_DEL state, otherwise allocate a new target.

 *

 * The target is returned with an incremented reference, so the caller

 * is responsible for both reaping and doing a last put

 allocate and add */

			/* don't want scsi_target_reap to do the final

	/*

	 * release routine already fired if kref is zero, so if we can still

	 * take the reference, the target must be alive.  If we can't, it must

	 * be dying and we need to wait for a new target

	/*

	 * Unfortunately, we found a dying target; need to wait until it's

	 * dead before we can get a new one.  There is an anomaly here.  We

	 * *should* call scsi_target_reap() to balance the kref_get() of the

	 * reap_ref above.  However, since the target being released, it's

	 * already invisible and the reap_ref is irrelevant.  If we call

	 * scsi_target_reap() we might spuriously do another device_del() on

	 * an already invisible target.

	/*

	 * length of time is irrelevant here, we just want to yield the CPU

	 * for a tick to avoid busy waiting for the target to die.

/**

 * scsi_target_reap - check to see if target is in use and destroy if not

 * @starget: target to be checked

 *

 * This is used after removing a LUN or doing a last put of the target

 * it checks atomically that nothing is using the target and removes

 * it if so.

	/*

	 * serious problem if this triggers: STARGET_DEL is only set in the if

	 * the reap_ref drops to zero, so we're trying to do another final put

	 * on an already released kref

/**

 * scsi_sanitize_inquiry_string - remove non-graphical chars from an

 *                                INQUIRY result string

 * @s: INQUIRY result string to sanitize

 * @len: length of the string

 *

 * Description:

 *	The SCSI spec says that INQUIRY vendor, product, and revision

 *	strings must consist entirely of graphic ASCII characters,

 *	padded on the right with spaces.  Since not all devices obey

 *	this rule, we will replace non-graphic or non-ASCII characters

 *	with spaces.  Exception: a NUL character is interpreted as a

 *	string terminator, so all the following characters are set to

 *	spaces.

/**

 * scsi_probe_lun - probe a single LUN using a SCSI INQUIRY

 * @sdev:	scsi_device to probe

 * @inq_result:	area to store the INQUIRY result

 * @result_len: len of inq_result

 * @bflags:	store any bflags found here

 *

 * Description:

 *     Probe the lun associated with @req using a standard SCSI INQUIRY;

 *

 *     If the INQUIRY is successful, zero is returned and the

 *     INQUIRY data is in @inq_result; the scsi_level and INQUIRY length

 *     are copied to the scsi_device any flags value is stored in *@bflags.

	/* Perform up to 3 passes.  The first pass uses a conservative

	 * transfer length of 36 unless sdev->inquiry_len specifies a

 Each pass gets up to three chances to ignore Unit Attention */

			/*

			 * not-ready to ready transition [asc/ascq=0x28/0x0]

			 * or power-on, reset [asc/ascq=0x29/0x0], continue.

			 * INQUIRY should not yield UNIT_ATTENTION

			 * but many buggy devices do so anyway. 

			/*

			 * if nothing was transferred, we try

			 * again. It's a workaround for some USB

			 * devices.

 sanity */

		/*

		 * Get any flags for this device.

		 *

		 * XXX add a bflags to scsi_device, and replace the

		 * corresponding bit fields in scsi_device, so bflags

		 * need not be passed as an argument.

		/* When the first pass succeeds we gain information about

 If more data is available perform the second pass */

		/* If this pass failed, the third pass goes back and transfers

	/* If the last transfer attempt got an error, assume the

 Don't report any more data than the device says is valid */

	/*

	 * XXX Abort if the response length is less than 36? If less than

	 * 32, the lookup of the device flags (above) could be invalid,

	 * and it would be possible to take an incorrect action - we do

	 * not want to hang because of a short INQUIRY. On the flip side,

	 * if the device is spun down or becoming ready (and so it gives a

	 * short INQUIRY), an abort here prevents any further use of the

	 * device, including spin up.

	 *

	 * On the whole, the best approach seems to be to assume the first

	 * 36 bytes are valid no matter what the device says.  That's

	 * better than copying < 36 bytes to the inquiry-result buffer

	 * and displaying garbage for the Vendor, Product, or Revision

	 * strings.

	/*

	 * Related to the above issue:

	 *

	 * XXX Devices (disk or all?) should be sent a TEST UNIT READY,

	 * and if not ready, sent a START_STOP to start (maybe spin up) and

	 * then send the INQUIRY again, since the INQUIRY can change after

	 * a device is initialized.

	 *

	 * Ideally, start a device if explicitly asked to do so.  This

	 * assumes that a device is spun up on power on, spun down on

	 * request, and then spun up on request.

	/*

	 * The scanning code needs to know the scsi_level, even if no

	 * device is attached at LUN 0 (SCSI_SCAN_TARGET_PRESENT) so

	 * non-zero LUNs can be scanned.

	/*

	 * If SCSI-2 or lower, and if the transport requires it,

	 * store the LUN value in CDB[1].

/**

 * scsi_add_lun - allocate and fully initialze a scsi_device

 * @sdev:	holds information to be stored in the new scsi_device

 * @inq_result:	holds the result of a previous INQUIRY to the LUN

 * @bflags:	black/white list flag

 * @async:	1 if this device is being scanned asynchronously

 *

 * Description:

 *     Initialize the scsi_device @sdev.  Optionally set fields based

 *     on values in *@bflags.

 *

 * Return:

 *     SCSI_SCAN_NO_RESPONSE: could not allocate or setup a scsi_device

 *     SCSI_SCAN_LUN_PRESENT: a new scsi_device was allocated and initialized

	/*

	 * XXX do not save the inquiry, since it can change underneath us,

	 * save just vendor/model/rev.

	 *

	 * Rather than save it and have an ioctl that retrieves the saved

	 * value, have an ioctl that executes the same INQUIRY code used

	 * in scsi_probe_lun, let user level programs doing INQUIRY

	 * scanning run at their own risk, or supply a user level program

	 * that can correctly scan.

	/*

	 * Copy at least 36 bytes of INQUIRY data, so that we don't

	 * dereference unallocated memory when accessing the Vendor,

	 * Product, and Revision strings.  Badly behaved devices may set

	 * the INQUIRY Additional Length byte to a small value, indicating

	 * these strings are invalid, but often they contain plausible data

	 * nonetheless.  It doesn't matter if the device sent < 36 bytes

	 * total, since scsi_probe_lun() initializes inq_result with 0s.

		/*

		 * sata emulation layer device.  This is a hack to work around

		 * the SATL power management specifications which state that

		 * when the SATL detects the device has gone into standby

		 * mode, it shall respond with NOT READY.

		/*

		 * some devices may respond with wrong type for

		 * well-known logical units. Force well-known type

		 * to enumerate them correctly.

		/* RBC and MMC devices can return SCSI-3 compliance and yet

		 * still not support REPORT LUNS, so make them act as

		 * BLIST_NOREPORTLUN unless BLIST_REPORTLUN2 is

	/*

	 * For a peripheral qualifier (PQ) value of 1 (001b), the SCSI

	 * spec says: The device server is capable of supporting the

	 * specified peripheral device type on this logical unit. However,

	 * the physical device is not currently connected to this logical

	 * unit.

	 *

	 * The above is vague, as it implies that we could treat 001 and

	 * 011 the same. Stay compatible with previous code, and create a

	 * scsi_device for a PQ of 1

	 *

	 * Don't set the device offline here; rather let the upper

	 * level drivers eval the PQ to decide whether they should

	 * attach. So remove ((inq_result[0] >> 5) & 7) == 1 check.

	/*

	 * Some devices (Texel CD ROM drives) have handshaking problems

	 * when used with the Seagate controllers. borken is initialized

	 * to 1, and then set it to 0 here.

	/*

	 * Apparently some really broken devices (contrary to the SCSI

	 * standards) need to be selected without asserting ATN

	/*

	 * Maximum 512 sector transfer length

	 * broken RA4x00 Compaq Disk Array

	/*

	 * Max 1024 sector transfer length for targets that report incorrect

	 * max/optimal lengths and relied on the old block layer safe default

	/*

	 * Some devices may not want to have a start command automatically

	 * issued when a device is added.

	/* some devices don't like REPORT SUPPORTED OPERATION CODES

	 * and will simply timeout causing sd_mod init to take a very

	/* set the device running here so that slave configure

			/*

			 * if LLDD reports slave not present, don't clutter

			 * console with alloc failure messages

	/*

	 * Ok, the device is now all set up, we can

	 * register it and tell the rest of the kernel

	 * about it.

/** 

 * scsi_inq_str - print INQUIRY data from min to max index, strip trailing whitespace

 * @buf:   Output buffer with at least end-first+1 bytes of space

 * @inq:   Inquiry buffer (input)

 * @first: Offset of string into inq

 * @end:   Index after last character in inq

/**

 * scsi_probe_and_add_lun - probe a LUN, if a LUN is found add it

 * @starget:	pointer to target device structure

 * @lun:	LUN of target device

 * @bflagsp:	store bflags here if not NULL

 * @sdevp:	probe the LUN corresponding to this scsi_device

 * @rescan:     if not equal to SCSI_SCAN_INITIAL skip some code only

 *              needed on first scan

 * @hostdata:	passed to scsi_alloc_sdev()

 *

 * Description:

 *     Call scsi_probe_lun, if a LUN with an attached device is found,

 *     allocate and set it up by calling scsi_add_lun.

 *

 * Return:

 *

 *   - SCSI_SCAN_NO_RESPONSE: could not allocate or setup a scsi_device

 *   - SCSI_SCAN_TARGET_PRESENT: target responded, but no device is

 *         attached at the LUN

 *   - SCSI_SCAN_LUN_PRESENT: a new scsi_device was allocated and initialized

	/*

	 * The rescan flag is used as an optimization, the first scan of a

	 * host adapter calls into here with rescan == 0.

	/*

	 * result contains valid SCSI INQUIRY data.

		/*

		 * For a Peripheral qualifier 3 (011b), the SCSI

		 * spec says: The device server is not capable of

		 * supporting a physical device on this logical

		 * unit.

		 *

		 * For disks, this implies that there is no

		 * logical disk configured at sdev->lun, but there

		 * is a target id responding.

	/*

	 * Some targets may set slight variations of PQ and PDT to signal

	 * that no LUN is present, so don't add sdev in these cases.

	 * Two specific examples are:

	 * 1) NetApp targets: return PQ=1, PDT=0x1f

	 * 2) IBM/2145 targets: return PQ=1, PDT=0

	 * 3) USB UFI: returns PDT=0x1f, with the PQ bits being "reserved"

	 *    in the UFI 1.0 spec (we cannot rely on reserved bits).

	 *

	 * References:

	 * 1) SCSI SPC-3, pp. 145-146

	 * PQ=1: "A peripheral device having the specified peripheral

	 * device type is not connected to this logical unit. However, the

	 * device server is capable of supporting the specified peripheral

	 * device type on this logical unit."

	 * PDT=0x1f: "Unknown or no device type"

	 * 2) USB UFI 1.0, p. 20

	 * PDT=00h Direct-access device (floppy)

	 * PDT=1Fh none (no FDD connected to the requested logical unit)

/**

 * scsi_sequential_lun_scan - sequentially scan a SCSI target

 * @starget:	pointer to target structure to scan

 * @bflags:	black/white list flag for LUN 0

 * @scsi_level: Which version of the standard does this device adhere to

 * @rescan:     passed to scsi_probe_add_lun()

 *

 * Description:

 *     Generally, scan from LUN 1 (LUN 0 is assumed to already have been

 *     scanned) to some maximum lun until a LUN is found with no device

 *     attached. Use the bflags to figure out any oddities.

 *

 *     Modifies sdevscan->lun.

	/*

	 * If this device is known to support sparse multiple units,

	 * override the other settings, and scan all of them. Normally,

	 * SCSI-3 devices should be scanned via the REPORT LUNS.

	/*

	 * If less than SCSI_1_CCS, and no special lun scanning, stop

	 * scanning; this matches 2.4 behaviour, but could just be a bug

	 * (to continue scanning a SCSI_1_CCS device).

	 *

	 * This test is broken.  We might not have any device on lun0 for

	 * a sparselun device, and if that's the case then how would we

	 * know the real scsi_level, eh?  It might make sense to just not

	 * scan any SCSI_1 device for non-0 luns, but that check would best

	 * go into scsi_alloc_sdev() and just have it return null when asked

	 * to alloc an sdev for lun > 0 on an already found SCSI_1 device.

	 *

	if ((sdevscan->scsi_level < SCSI_1_CCS) &&

	    ((bflags & (BLIST_FORCELUN | BLIST_SPARSELUN | BLIST_MAX5LUN))

	     == 0))

		return;

	/*

	 * If this device is known to support multiple units, override

	 * the other settings, and scan all of them.

	/*

	 * REGAL CDC-4X: avoid hang after LUN 4

	/*

	 * Do not scan SCSI-2 or lower device past LUN 7, unless

	 * BLIST_LARGELUN.

	/*

	 * We have already scanned LUN 0, so start at LUN 1. Keep scanning

	 * until we reach the max, or no LUN is found and we are not

	 * sparse_lun.

/**

 * scsi_report_lun_scan - Scan using SCSI REPORT LUN results

 * @starget: which target

 * @bflags: Zero or a mix of BLIST_NOLUN, BLIST_REPORTLUN2, or BLIST_NOREPORTLUN

 * @rescan: nonzero if we can skip code only needed on first scan

 *

 * Description:

 *   Fast scanning for modern (SCSI-3) devices by sending a REPORT LUN command.

 *   Scan the resulting list of LUNs by calling scsi_probe_and_add_lun.

 *

 *   If BLINK_REPORTLUN2 is set, scan a target that supports more than 8

 *   LUNs even if it's older than SCSI-3.

 *   If BLIST_NOREPORTLUN is set, return 1 always.

 *   If BLIST_NOLUN is set, return 0 always.

 *   If starget->no_report_luns is set, return 1 always.

 *

 * Return:

 *     0: scan completed (or no memory, so further scanning is futile)

 *     1: could not scan with REPORT LUN

	/*

	 * Only support SCSI-3 and up devices if BLIST_NOREPORTLUN is not set.

	 * Also allow SCSI-2 if BLIST_REPORTLUN2 is set and host adapter does

	 * support more than 8 LUNs.

	 * Don't attempt if the target doesn't support REPORT LUNS.

	/*

	 * Allocate enough to hold the header (the same size as one scsi_lun)

	 * plus the number of luns we are requesting.  511 was the default

	 * value of the now removed max_report_luns parameter.

	/*

	 * bytes 1 - 5: reserved, set to zero.

	/*

	 * bytes 6 - 9: length of the command.

 reserved */

 control */

	/*

	 * We can get a UNIT ATTENTION, for example a power on/reset, so

	 * retry a few times (like sd.c does for TEST UNIT READY).

	 * Experience shows some combinations of adapter/devices get at

	 * least two power on/resets.

	 *

	 * Illegal requests (for devices that do not support REPORT LUNS)

	 * should come through as a check condition, and will not generate

	 * a retry.

		/*

		 * The device probably does not support a REPORT LUN command

	/*

	 * Get the length from the first four bytes of lun_data.

	/*

	 * Scan the luns in lun_data. The entry at offset 0 is really

	 * the header, so start at 1 and go up to and including num_luns.

				/*

				 * Got some results, but now none, abort.

		/*

		 * the sdev we used didn't appear in the report luns scan

	/*

	 * paired with scsi_alloc_target().  Target will be destroyed unless

	 * scsi_probe_and_add_lun made an underlying device visible

		/*

		 * Don't scan the host adapter

		/*

		 * Scan for a specific host/chan/id/lun.

	/*

	 * Scan LUN 0, if there is some response, scan further. Ideally, we

	 * would not configure LUN 0 until all LUNs are scanned.

			/*

			 * The REPORT LUN did not scan the target,

			 * do a sequential scan.

	/*

	 * paired with scsi_alloc_target(): determine if the target has

	 * any children at all and if not, nuke it

/**

 * scsi_scan_target - scan a target id, possibly including all LUNs on the target.

 * @parent:	host to scan

 * @channel:	channel to scan

 * @id:		target id to scan

 * @lun:	Specific LUN to scan or SCAN_WILD_CARD

 * @rescan:	passed to LUN scanning routines; SCSI_SCAN_INITIAL for

 *              no rescan, SCSI_SCAN_RESCAN to rescan existing LUNs,

 *              and SCSI_SCAN_MANUAL to force scanning even if

 *              'scan=manual' is set.

 *

 * Description:

 *     Scan the target id on @parent, @channel, and @id. Scan at least LUN 0,

 *     and possibly all LUNs on the target id.

 *

 *     First try a REPORT LUN scan, if that does not scan the target, do a

 *     sequential scan of LUNs on the target id.

			/*

			 * XXX adapter drivers when possible (FCP, iSCSI)

			 * could modify max_id to match the current max,

			 * not the absolute max.

			 *

			 * XXX add a shost id iterator, so for example,

			 * the FC ID can be the same as a target id

			 * without a huge overhead of sparse id's.

				/*

				 * Scan from high to low id.

 target removed before the device could be added */

 If device is already visible, skip adding it to sysfs */

/**

 * scsi_prep_async_scan - prepare for an async scan

 * @shost: the host which will be scanned

 * Returns: a cookie to be passed to scsi_finish_async_scan()

 *

 * Tells the midlayer this host is going to do an asynchronous scan.

 * It reserves the host's position in the scanning list and ensures

 * that other asynchronous scans started after this one won't affect the

 * ordering of the discovered devices.

/**

 * scsi_finish_async_scan - asynchronous scan has finished

 * @data: cookie returned from earlier call to scsi_prep_async_scan()

 *

 * All the devices currently attached to this host have been found.

 * This function announces all the devices it has found to the rest

 * of the system.

/**

 * scsi_scan_host - scan the given adapter

 * @shost:	adapter to scan

	/* register with the async subsystem so wait_for_device_probe()

	 * will flush this work

 scsi_autopm_put_host(shost) is called in scsi_finish_async_scan() */

/*

 * Qlogic FAS408 ISA card driver

 *

 * Copyright 1994, Tom Zerucha.   

 * tz@execpc.com

 * 

 * Redistributable under terms of the GNU General Public License

 *

 * For the avoidance of doubt the "preferred form" of this code is one which

 * is in an open non patent encumbered format. Where cryptographic key signing

 * forms part of the process of creating an executable the information

 * including keys needed to generate an equivalently functional executable

 * are deemed to be part of the source code.

 *

 * Check qlogicfas408.c for more credits and info.

 to get disk capacity */

/* Set the following to 2 to use normal interrupt (active high/totempole-

 * tristate), otherwise use 0 (REQUIRED FOR PCMCIA) for active low, open

 * drain

/*

 *	Look for qlogic card and init if found 

 type of chip */

 registered host structure */

	/*	Qlogic Cards only exist at 0x230 or 0x330 (the chip itself

	 *	decodes the address - I check 230 first since MIDI cards are

	 *	typically at 0x330

	 *

	 *	Theoretically, two Qlogic cards can coexist in the same system.

	 *	This should work by simply using this as a loadable module for

	 *	the second card, but I haven't tested this.

 if no ID, use 7 */

 no more devices */

/*

 *	The driver template is also needed for PCMCIA

 no cards found */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2005-2006 Dell Inc.

 *

 * Serial Attached SCSI (SAS) transport class.

 *

 * The SAS transport class contains common code to deal with SAS HBAs,

 * an aproximated representation of SAS topologies in the driver model,

 * and various sysfs attributes to expose these topologies and management

 * interfaces to userspace.

 *

 * In addition to the basic SCSI core objects this transport class

 * introduces two additional intermediate objects:  The SAS PHY

 * as represented by struct sas_phy defines an "outgoing" PHY on

 * a SAS HBA or Expander, and the SAS remote PHY represented by

 * struct sas_rphy defines an "incoming" PHY on a SAS Expander or

 * end device.  Note that this is purely a software concept, the

 * underlying hardware for a PHY and a remote PHY is the exactly

 * the same.

 *

 * There is no concept of a SAS port in this code, users can see

 * what PHYs form a wide port based on the port_identifier attribute,

 * which is the same for all PHYs in a port.

/*

 * Hack to allow attributes of the same name in different objects.

/*

 * Pretty printing helpers

/*

 * SAS host attributes

/**

 * sas_remove_children  -  tear down a devices SAS data structures

 * @dev:	device belonging to the sas object

 *

 * Removes all SAS PHYs and remote PHYs for a given object

/**

 * sas_remove_host  -  tear down a Scsi_Host's SAS data structures

 * @shost:	Scsi Host that is torn down

 *

 * Removes all SAS PHYs and remote PHYs for a given Scsi_Host and remove the

 * Scsi_Host as well.

 *

 * Note: Do not call scsi_remove_host() on the Scsi_Host any more, as it is

 * already removed.

/**

 * sas_get_address - return the SAS address of the device

 * @sdev: scsi device

 *

 * Returns the SAS address of the scsi device

/**

 * sas_tlr_supported - checking TLR bit in vpd 0x90

 * @sdev: scsi device struct

 *

 * Check Transport Layer Retries are supported or not.

 * If vpd page 0x90 is present, TRL is supported.

 *

	/*

	 * Magic numbers: the VPD Protocol page (0x90)

	 * has a 4 byte header and then one entry per device port

	 * the TLR bit is at offset 8 on each port entry

	 * if we take the first port, that's at total offset 12

/**

 * sas_disable_tlr - setting TLR flags

 * @sdev: scsi device struct

 *

 * Seting tlr_enabled flag to 0.

 *

/**

 * sas_enable_tlr - setting TLR flags

 * @sdev: scsi device struct

 *

 * Seting tlr_enabled flag 1.

 *

/*

 * SAS Phy attributes

 Fudge to tell if we're minimum or maximum */

/**

 * sas_phy_alloc  -  allocates and initialize a SAS PHY structure

 * @parent:	Parent device

 * @number:	Phy index

 *

 * Allocates an SAS PHY structure.  It will be added in the device tree

 * below the device specified by @parent, which has to be either a Scsi_Host

 * or sas_rphy.

 *

 * Returns:

 *	SAS PHY allocated or %NULL if the allocation failed.

/**

 * sas_phy_add  -  add a SAS PHY to the device hierarchy

 * @phy:	The PHY to be added

 *

 * Publishes a SAS PHY to the rest of the system.

/**

 * sas_phy_free  -  free a SAS PHY

 * @phy:	SAS PHY to free

 *

 * Frees the specified SAS PHY.

 *

 * Note:

 *   This function must only be called on a PHY that has not

 *   successfully been added using sas_phy_add().

/**

 * sas_phy_delete  -  remove SAS PHY

 * @phy:	SAS PHY to remove

 *

 * Removes the specified SAS PHY.  If the SAS PHY has an

 * associated remote PHY it is removed before.

 this happens if the phy is still part of a port when deleted */

/**

 * scsi_is_sas_phy  -  check if a struct device represents a SAS PHY

 * @dev:	device to check

 *

 * Returns:

 *	%1 if the device represents a SAS PHY, %0 else

/*

 * SAS Port attributes

/** sas_port_alloc - allocate and initialize a SAS port structure

 *

 * @parent:	parent device

 * @port_id:	port number

 *

 * Allocates a SAS port structure.  It will be added to the device tree

 * below the device specified by @parent which must be either a Scsi_Host

 * or a sas_expander_device.

 *

 * Returns %NULL on error

/** sas_port_alloc_num - allocate and initialize a SAS port structure

 *

 * @parent:	parent device

 *

 * Allocates a SAS port structure and a number to go with it.  This

 * interface is really for adapters where the port number has no

 * meansing, so the sas class should manage them.  It will be added to

 * the device tree below the device specified by @parent which must be

 * either a Scsi_Host or a sas_expander_device.

 *

 * Returns %NULL on error

 FIXME: use idr for this eventually */

/**

 * sas_port_add - add a SAS port to the device hierarchy

 * @port:	port to be added

 *

 * publishes a port to the rest of the system

 No phys should be added until this is made visible */

/**

 * sas_port_free  -  free a SAS PORT

 * @port:	SAS PORT to free

 *

 * Frees the specified SAS PORT.

 *

 * Note:

 *   This function must only be called on a PORT that has not

 *   successfully been added using sas_port_add().

/**

 * sas_port_delete  -  remove SAS PORT

 * @port:	SAS PORT to remove

 *

 * Removes the specified SAS PORT.  If the SAS PORT has an

 * associated phys, unlink them from the port as well.

/**

 * scsi_is_sas_port -  check if a struct device represents a SAS port

 * @dev:	device to check

 *

 * Returns:

 *	%1 if the device represents a SAS Port, %0 else

/**

 * sas_port_get_phy - try to take a reference on a port member

 * @port: port to check

/**

 * sas_port_add_phy - add another phy to a port to form a wide port

 * @port:	port to add the phy to

 * @phy:	phy to add

 *

 * When a port is initially created, it is empty (has no phys).  All

 * ports must have at least one phy to operated, and all wide ports

 * must have at least two.  The current code makes no difference

 * between ports and wide ports, but the only object that can be

 * connected to a remote device is a port, so ports must be formed on

 * all devices with phys if they're connected to anything.

 make sure we're already on this port */

		/* If this trips, you added a phy that was already

/**

 * sas_port_delete_phy - remove a phy from a port or wide port

 * @port:	port to remove the phy from

 * @phy:	phy to remove

 *

 * This operation is used for tearing down ports again.  It must be

 * done to every port or wide port before calling sas_port_delete.

/*

 * SAS remote PHY attributes.

 only need 8 bytes of data plus header (4 or 8) */

/**

 * sas_rphy_initialize - common rphy initialization

 * @rphy:	rphy to initialise

 *

 * Used by both sas_end_device_alloc() and sas_expander_alloc() to

 * initialise the common rphy component of each.

/**

 * sas_end_device_alloc - allocate an rphy for an end device

 * @parent: which port

 *

 * Allocates an SAS remote PHY structure, connected to @parent.

 *

 * Returns:

 *	SAS PHY allocated or %NULL if the allocation failed.

/**

 * sas_expander_alloc - allocate an rphy for an end device

 * @parent: which port

 * @type: SAS_EDGE_EXPANDER_DEVICE or SAS_FANOUT_EXPANDER_DEVICE

 *

 * Allocates an SAS remote PHY structure, connected to @parent.

 *

 * Returns:

 *	SAS PHY allocated or %NULL if the allocation failed.

/**

 * sas_rphy_add  -  add a SAS remote PHY to the device hierarchy

 * @rphy:	The remote PHY to be added

 *

 * Publishes a SAS remote PHY to the rest of the system.

/**

 * sas_rphy_free  -  free a SAS remote PHY

 * @rphy: SAS remote PHY to free

 *

 * Frees the specified SAS remote PHY.

 *

 * Note:

 *   This function must only be called on a remote

 *   PHY that has not successfully been added using

 *   sas_rphy_add() (or has been sas_rphy_remove()'d)

/**

 * sas_rphy_delete  -  remove and free SAS remote PHY

 * @rphy:	SAS remote PHY to remove and free

 *

 * Removes the specified SAS remote PHY and frees it.

/**

 * sas_rphy_unlink  -  unlink SAS remote PHY

 * @rphy:	SAS remote phy to unlink from its parent port

 *

 * Removes port reference to an rphy

/**

 * sas_rphy_remove  -  remove SAS remote PHY

 * @rphy:	SAS remote phy to remove

 *

 * Removes the specified SAS remote PHY.

/**

 * scsi_is_sas_rphy  -  check if a struct device represents a SAS remote PHY

 * @dev:	device to check

 *

 * Returns:

 *	%1 if the device represents a SAS remote PHY, %0 else

/*

 * SCSI scan helper

/*

 * Setup / Teardown code

/**

 * sas_attach_transport  -  instantiate SAS transport template

 * @ft:		SAS transport class function template

/**

 * sas_release_transport  -  release SAS transport template instance

 * @t:		transport template instance

/*

 * atari_scsi.c -- Device dependent functions for the Atari generic SCSI port

 *

 * Copyright 1994 Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de>

 *

 *   Loosely based on the work of Robert De Vries' team and added:

 *    - working real DMA

 *    - Falcon support (untested yet!)   ++bjoern fixed and now it works

 *    - lots of extensions and bug fixes.

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file COPYING in the main directory of this archive

 * for more details.

 *

/*

 * Notes for Falcon SCSI DMA

 *

 * The 5380 device is one of several that all share the DMA chip. Hence

 * "locking" and "unlocking" access to this chip is required.

 *

 * Two possible schemes for ST DMA acquisition by atari_scsi are:

 * 1) The lock is taken for each command separately (i.e. can_queue == 1).

 * 2) The lock is taken when the first command arrives and released

 * when the last command is finished (i.e. can_queue > 1).

 *

 * The first alternative limits SCSI bus utilization, since interleaving

 * commands is not possible. The second gives better performance but is

 * unfair to other drivers needing to use the ST DMA chip. In order to

 * allow the IDE and floppy drivers equal access to the ST DMA chip

 * the default is can_queue == 1.

 Definitions for the core NCR5380 driver. */

 none */

 pointer to the dribble buffer */

 precalculated physical address of the dribble buffer */

 != 0 tells the Falcon int handler to copy data from the dribble buffer */

/* size of the dribble buffer; 4k seems enough, since the Falcon cannot use

 * scatter-gather anyway, so most transfers are 1024 byte only. In the rare

 * cases where requests to physical contiguous buffers have been merged, this

 * request is <= 4k (one page). So I don't think we have to split transfers

 * just due to this buffer size...

 mask for address bits that can't be used with the ST-DMA */

		/* A bus error happens when DMA-ing from the last page of a

		 * physical memory chunk (DMA prefetch!), but that doesn't hurt.

		 * Check for this case:

	/* Look if it was the DMA that has interrupted: First possibility

	 * is that a bus error occurred...

	/* If the DMA is active but not finished, we have the case

	 * that some other 5380 interrupt occurred within the DMA transfer.

	 * This means we have residual bytes, if the desired end address

	 * is not yet reached. Maybe we have to fetch some bytes from the

	 * rest data register, too. The residual must be calculated from

	 * the address pointer, not the counter register, because only the

	 * addr reg counts bytes not yet written and pending in the rest

	 * data reg!

			/*

			 * After read operations, we maybe have to

			 * transport some rest bytes

			/*

			 * There seems to be a nasty bug in some SCSI-DMA/NCR

			 * combinations: If a target disconnects while a write

			 * operation is going on, the address register of the

			 * DMA may be a few bytes farer than it actually read.

			 * This is probably due to DMA prefetching and a delay

			 * between DMA and NCR.  Experiments showed that the

			 * dma_addr is 9 bytes to high, but this could vary.

			 * The problem is, that the residual is thus calculated

			 * wrong and the next transfer will start behind where

			 * it should.  So we round up the residual to the next

			 * multiple of a sector size, if it isn't already a

			 * multiple and the originally expected transfer size

			 * was.  The latter condition is there to ensure that

			 * the correction is taken only for "real" data

			 * transfers and not for, e.g., the parameters of some

			 * other command.  These shouldn't disconnect anyway.

 If the DMA is finished, fetch the rest bytes and turn it off */

	/* Turn off DMA and select sector counter register before

	 * accessing the status register (Atari recommendation!)

	/* Bit 0 indicates some error in the DMA process... don't know

	 * what happened exactly (no further docu).

 DMA error */

	/* If the DMA was active, but now bit 1 is not clear, it is some

	 * other 5380 interrupt that finishes the DMA transfer. We have to

	 * calculate the number of residual bytes and give a warning if

	 * bytes are stuck in the ST-DMA fifo (there's no way to reach them!)

		/* The ST-DMA address is incremented in 2-byte steps, but the

		 * data are written only in 16-byte chunks. If the number of

		 * transferred bytes is not divisible by 16, the remainder is

		 * lost somewhere in outer space.

		/* If the dribble buffer was used on a read operation, copy the DMA-ed

		 * data to the original destination address.

 fetch rest bytes in the DMA register */

		/* there are 'nr' bytes left for the last long address

 The content of the DMA pointer is a physical address!  */

/* This function releases the lock on the DMA chip if there is no

 * connected command and the disconnected queue is empty.

/* This function manages the locking of the ST-DMA.

 * If the DMA isn't locked already for SCSI, it tries to lock it by

 * calling stdma_lock(). But if the DMA is locked by the SCSI code and

 * there are other drivers waiting for the chip, we do not issue the

 * command immediately but tell the SCSI mid-layer to defer.

 stdma_lock() may sleep which means it can't be used here */

	/* Format of atascsi parameter is:

	 *   atascsi=<can_queue>,<cmd_per_lun>,<sg_tablesize>,<hostid>,<use_tags>

	 * Defaults depend on TT or Falcon, determined at run time.

	 * Negative values mean don't change.

 ints[5] (use_tagged_queuing) is ignored */

 ints[6] (use_pdma) is ignored */

 !MODULE */

		/* If we have a non-DMAable address on a Falcon, use the dribble

		 * buffer; 'orig_addr' != 0 in the read case tells the interrupt

		 * handler to copy data from the dribble buffer to the originally

		 * wanted address.

 Needed for calculating residual later. */

	/* Cache cleanup stuff: On writes, push any dirty cache out before sending

	 * it to the peripheral. (Must be done before DMA setup, since at least

	 * the ST-DMA begins to fill internal buffers right after setup. For

	 * reads, invalidate any cache, may be altered after DMA without CPU

	 * knowledge.

	 *

	 * ++roman: For the Medusa, there's no need at all for that cache stuff,

	 * because the hardware does bus snooping (fine!).

 ! IS_A_TT */

 set address */

 toggle direction bit to clear FIFO and set DMA direction */

		/* On writes, round up the transfer length to the next multiple of 512

 need not restore value of dir, only boolean value is tested */

 READ_12 */ || opcode == READ_REVERSE ||

		/* In case of a sequential-access target (tape), special care is

		 * needed here: The transfer is block-mode only if the 'fixed' bit is

/* This function calculates the number of bytes that can be transferred via

 * DMA. On the TT, this is arbitrary, but on the Falcon we have to use the

 * ST-DMA chip. There are only multiples of 512 bytes possible and max.

 * 255*512 bytes :-( This means also, that defining READ_OVERRUNS is not

 * possible on the Falcon, since that would require to program the DMA for

 * n*512 - atari_read_overrun bytes. But it seems that the Falcon doesn't have

 * the overrun problem, so this question is academic :-)

 TT SCSI DMA can transfer arbitrary #bytes */

	/* ST DMA chip is stupid -- only multiples of 512 bytes! (and max.

	 * 255*512 bytes, but this should be enough)

	 *

	 * ++roman: Aaargl! Another Falcon-SCSI problem... There are some commands

	 * that return a number of bytes which cannot be known beforehand. In this

	 * case, the given transfer length is an "allocation length". Now it

	 * can happen that this allocation length is a multiple of 512 bytes and

	 * the DMA is used. But if not n*512 bytes really arrive, some input data

	 * will be lost in the ST-DMA's FIFO :-( Thus, we have to distinguish

	 * between commands that do block transfers and those that do byte

	 * transfers. But this isn't easy... there are lots of vendor specific

	 * commands, and the user can issue any command via the

	 * SCSI_IOCTL_SEND_COMMAND.

	 *

	 * The solution: We classify SCSI commands in 1) surely block-mode cmd.s,

	 * 2) surely byte-mode cmd.s and 3) cmd.s with unknown mode. In case 1)

	 * and 3), the thing to do is obvious: allow any number of blocks via DMA

	 * or none. In case 2), we apply some heuristic: Byte mode is assumed if

	 * the transfer (allocation) length is < 1024, hoping that no cmd. not

	 * explicitly known as byte mode have such big allocation lengths...

	 * BTW, all the discussion above applies only to reads. DMA writes are

	 * unproblematic anyways, since the targets aborts the transfer after

	 * receiving a sufficient number of bytes.

	 *

	 * Another point: If the transfer is from/to an non-ST-RAM address, we

	 * use the dribble buffer and thus can do only STRAM_BUFFER_SIZE bytes.

		/* Write operation can always use the DMA, but the transfer size must

		 * be rounded up to the next multiple of 512 (atari_dma_setup() does

		 * this).

		/* Read operations: if the wanted transfer length is not a multiple of

		 * 512, we cannot use DMA, since the ST-DMA cannot split transfers

		 * (no interrupt on DMA finished!)

			/* Now classify the command (see above) and decide whether it is

 DMA prohibited */

				/* For unknown commands assume block transfers if the transfer

 Last step: apply the hard limit on DMA transfers */

/* NCR5380 register access functions

 *

 * There are separate functions for TT and Falcon, because the access

 * methods are quite different. The calling macros NCR5380_read and

 * NCR5380_write call these functions via function pointers.

 Abort a maybe active DMA transfer */

	/* The 5380 raises its IRQ line while _RST is active but the ST DMA

	 * "lock" has been released so this interrupt may end up handled by

	 * floppy or IDE driver (if one of them holds the lock). The NCR5380

	 * interrupt flag has been cleared already.

 Don't increase sg_tablesize on Falcon! */

 Test if a host id is set in the NVRam */

			/* Arbitration enabled? (for TOS)

			 * If yes, use configured host ID

	/* If running on a Falcon and if there's TT-Ram (i.e., more than one

	 * memory block, since there's always ST-Ram in a Falcon), then

	 * allocate a STRAM_BUFFER_SIZE byte dribble buffer for transfers

	 * from/to alternative Ram.

 SCSI int on L->H */

		/* While the read overruns (described by Drew Eckhardt in

		 * NCR5380.c) never happened on TTs, they do in fact on the

		 * Medusa (This was the cause why SCSI didn't work right for

		 * so long there.) Since handling the overruns slows down

		 * a bit, I turned the #ifdef's into a runtime condition.

		 *

		 * In principle it should be sufficient to do max. 1 byte with

		 * PIO, but there is another problem on the Medusa with the DMA

		 * rest data register. So read_overruns is currently set

		 * to 4 to avoid having transfers that aren't a multiple of 4.

		 * If the rest data bug is fixed, this can be lowered to 1.

		/* Nothing to do for the interrupt: the ST-DMA is initialized

		 * already.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * SCSI low-level driver for the MESH (Macintosh Enhanced SCSI Hardware)

 * bus adaptor found on Power Macintosh computers.

 * We assume the MESH is connected to a DBDMA (descriptor-based DMA)

 * controller.

 *

 * Paul Mackerras, August 1996.

 * Copyright (C) 1996 Paul Mackerras.

 *

 * Apr. 21 2002  - BenH		Rework bus reset code for new error handler

 *                              Add delay after initial bus reset

 *                              Add module parameters

 *

 * Sep. 27 2003  - BenH		Move to new driver model, fix some write posting

 *				issues

 * To do:

 * - handle aborts correctly

 * - retry arbitration if lost (unless higher levels do this for us)

 * - power down the chip when no device is detected

 print debug for these targets */

 bit mask for SEQ_ACTIVE_NEG if used */

 bombs on 601 */

 guess as to data direction */

 what we're currently trying to do */

 target we're connected to */

 req we're currently working on */

 space for dbdma commands, aligned */

/*

 * Driver is too messy, we need a few prototypes...

/*

 * Some debugging & logging routines

 Beware: if you enable this, it will crash on 601s. */

 MESH_DBG */

/*

 * Flush write buffers on the bus path to the mesh

/* Called with  meshinterrupt disabled, initialize the chipset

 * and eventually do the initial bus reset. The lock must not be

 * held since we can schedule.

 Reset controller */

 stop dma */

 clear all exception bits */

 clear all error bits */

 250ms */

 Reset bus */

 assert RST */

 leave it on for >= 25us */

 negate RST */

 Wait for bus to come back */

 Reconfigure controller */

 clear all interrupt bits */

 Off we go */

		/*

		 * Some other device has the bus or is arbitrating for it -

		 * probably a target which is about to reselect us.

 XXX should try again in a little while */

	/*

	 * Apparently the mesh has a bug where it will assert both its

	 * own bit and the target's bit on the bus during arbitration.

	/*

	 * There appears to be a race with reselection sometimes,

	 * where a target reselects us just as we issue the

	 * arbitrate command.  It seems that then the arbitrate

	 * command just hangs waiting for the bus to be free

	 * without giving us a reselection exception.

	 * The only way I have found to get it to respond correctly

	 * is this: disable reselection before issuing the arbitrate

	 * command, then after issuing it, if it looks like a target

	 * is trying to reselect us, reset the mesh and then enable

	 * reselection.

 looks like a reselection - try resetting the mesh */

			/*

			 * If this is a target reselecting us, and the

			 * mesh isn't responding, the higher levels of

			 * the scsi code will eventually time out and

			 * reset the bus.

/*

 * Start the next command for a MESH.

 * Should be called with interrupts disabled.

 needs to use sg? */

 asynchronous */

	/*

	 * We need to compute ceil(clk_freq * period / 500e6) - 2

	 * without incurring overflow.

 special case: sync_period == 5 * clk_period */

 units of tr are 100kB/s */

 sync_period == (v + 2) * 2 * clk_period */

 oops */

 can't happen */

		/*

		 * To make sure ATN drops before we assert ACK for

		 * the last byte of the message, we have to do the

		 * last byte specially.

		/*

		 * If ATN is not already asserted, we assert it, then

		 * issue a SEQ_MSGOUT to get the mesh to drop ACK.

 explicit ATN */

 release explicit ATN */

			/*

			 * We can't issue the SEQ_MSGOUT without ATN

			 * until the target has asserted REQ.  The logic

			 * in cmd_complete handles both situations:

			 * REQ already asserted or not.

 transfer data, if any */

 extended message */

 2-byte message */

 put the command back on the queue */

	/*

	 * We seem to get abortive reselections sometimes.

	/*

	 * Find out who reselected us.

 get the last byte in the fifo */

	/*

	 * Set up to continue with that target's transfer.

 SCSI bus was reset */

 request_q is empty, no point in mesh_start() */

 Unexpected disconnect */

 reissue the data transfer command */

			/* This can happen if we issue a command to

 try to do what the target wants */

 selection timed out */

		/* target wants to do something different:

 reply with an SDTR */

				/* limit period to at least his value,

/*

 * Set up DMA commands for transferring data.

		/* Either the target has overrun our buffer,

 wait a little while until the fifo drains */

 turn off RUN bit */

	/* nb is the number of bytes not yet transferred

 MESH_DBG */

 output the last byte of the message, without ATN */

 huh?  we expected a phase mismatch */

 should have some message bytes in fifo */

		/*

		 * To get the right timing on ATN wrt ACK, we have

		 * to get the MESH to drop ACK, wait until REQ gets

		 * asserted, then drop ATN.  To do this we first

		 * issue a SEQ_MSGOUT with ATN and wait for REQ,

		 * then change the command to a SEQ_MSGOUT w/o ATN.

		 * If we don't see REQ in a reasonable time, we

		 * change the command to SEQ_MSGIN with ATN,

		 * wait for the phase mismatch interrupt, then

		 * issue the SEQ_MSGOUT without ATN.

 wait up to 30us */

 whoops, target didn't do what we expected */

 add SDTR message */

			/*

			 * We need to wait for REQ before dropping ATN.

			 * We wait for at most 30us, then fall back to

			 * a scheme where we issue a SEQ_COMMAND with ATN,

			 * which will give us a phase mismatch interrupt

			 * when REQ does come, and then we send the message.

 wait up to 230us */

			/*

			 * We can get a phase mismatch here if the target

			 * changes to the status phase, even though we have

			 * had a command complete interrupt.  Then, if we

			 * issue the SEQ_STATUS command, we'll get a sequence

			 * error interrupt.  Which isn't so bad except that

			 * occasionally the mesh actually executes the

			 * SEQ_STATUS *as well as* giving us the sequence

			 * error and phase mismatch exception.

/*

 * Called by midlayer with host locked to queue a new

 * request

/*

 * Called to handle interrupts, either call by the interrupt

 * handler (do_mesh_interrupt) or by other functions in

 * exceptional circumstances

/* Todo: here we can at least try to remove the command from the

 * queue if it isn't connected yet, and for pending command, assert

 * ATN until the bus gets freed.

/*

 * Called by the midlayer with the lock held to reset the

 * SCSI host and bus.

 * The midlayer will wait for devices to come back, we don't need

 * to do that ourselves

 Reset the controller & dbdma channel */

 stop dma */

 clear all exception bits */

 clear all error bits */

 250ms */

 Reset the bus */

 assert RST */

 leave it on for >= 25us */

 negate RST */

 Complete pending commands */

 CONFIG_PM */

/*

 * If we leave drives set for synchronous transfers (especially

 * CDROMs), and reboot to MacOS, it gets confused, poor thing.

 * So, on reboot we reset the SCSI bus.

 Old junk for root discovery, that will die ultimately */

       	/* Space for dma command list: +1 for stop command,

       	 * +1 to allow for aligning.

	/* We use the PCI APIs for now until the generic one gets fixed

	 * enough or until we get some macio-specific versions

       	/* The maximum sync rate is clock / 5; increase

       	 * mesh_sync_period if necessary.

 ns */

 Power up the chip */

 Set it up */

 Request interrupt */

 Add scsi host & scan */

	/* shutdown & reset bus in case of error or macos can be confused

	 * at reboot if the bus was set to synchronous mode already

 Reset scsi bus */

 Shut down chip & termination */

 Unmap registers & dma controller */

 Free DMA commands memory */

 Release memory resources */

 Calculate sync rate from module parameters */

 ns */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  History:

 *  Started: Aug 9 by Lawrence Foard (entropy@world.std.com),

 *           to allow user process control of SCSI devices.

 *  Development Sponsored by Killy Corp. NY NY

 *

 * Original driver (sg.c):

 *        Copyright (C) 1992 Lawrence Foard

 * Version 2 and 3 extensions to driver:

 *        Copyright (C) 1998 - 2014 Douglas Gilbert

 2 digits for each component */

/*

 *  D. P. Gilbert (dgilbert@interlog.com), notes:

 *      - scsi logging is available via SCSI_LOG_TIMEOUT macros. First

 *        the kernel/module needs to be built with CONFIG_SCSI_LOGGING

 *        (otherwise the macros compile to empty statements).

 *

 for sg_check_file_access() */

/* SG_MAX_CDB_SIZE should be 260 (spc4r37 section 3.1.30) however the type

 * of sg_io_hdr::cmd_len can only represent 255. All SCSI commands greater

 * than 16 bytes are "variable length" whose length is a multiple of 4

/* N.B. This variable is readable and writeable via

   /proc/scsi/sg/def_reserved_size . Each time sg_open() is called a buffer

   of this size (or less if there is not enough memory) will be reserved

   for use by this file descriptor. [Deprecated usage: this variable is also

   readable via /proc/sys/kernel/sg-big-buff if the sg driver is built into

 picks up init parameter */

static DEFINE_RWLOCK(sg_index_lock);	/* Also used to lock

 holding area for scsi scatter gather info */

 Count of kernel scatter-gather pieces */

 size of malloc'd scatter-gather list ++ */

 Size of (aggregate) data buffer */

 0->indirect IO (or mmap), 1->dio */

 first byte of command */

 forward declarations */

 SG_MAX_QUEUE requests outstanding per file */

 list entry */

 NULL -> not in use */

 hold buffer, perhaps scatter list */

 scsi command+info, see <scsi/sg.h> */

 1 -> using reserve buffer, 0 -> not ... */

 1 -> drop on sight, 0 -> normal */

 1 -> packet belongs to SG_IO */

 done protected by rq_list_lock */

 0->before bh, 1->before read, 2->read */

 holds the state of a file descriptor */

 protected by device's sfd_lock */

 owning device */

 queue read until command done */

 protect access to list in req_arr */

 protect against changes in this fd */

 defaults to SG_DEFAULT_TIMEOUT      */

 defaults to SG_DEFAULT_TIMEOUT_USER */

 buffer held for this file descriptor */

 head of request list */

 used by asynchronous notification */

 used as singly-linked list */

 1 -> pack_id input to read(), 0 -> ignored */

 1 -> allow command queuing, 0 -> don't */

 0: automatic, >0: use on next write() */

 0 -> drop orphan (def), 1 -> keep for read() */

 0 -> mmap() never called on this fd */

 1 -> 'reserve' array in use */

 holds the state of each scsi generic device */

 queue open() when O_EXCL present */

 held when in open() or release() */

 adapter's max scatter-gather table size */

 device index number */

 protect access to sfd list */

 0->device usable, 1->device detaching */

 1->open(O_EXCL) succeeded and is active */

 count of opens (perhaps < num(sfds) ) */

 0->off, 1->sense, 9->dump dev, 10-> all devs */

 char_dev [sysfs: /sys/cdev/major/sg<n>] */

 tasklet or soft irq callback */

/*

 * The SCSI interfaces that use read() and write() as an asynchronous variant of

 * ioctl(..., SG_IO, ...) are fundamentally unsafe, since there are lots of ways

 * to trigger read() and write() calls from various contexts with elevated

 * privileges. This can lead to kernel memory corruption (e.g. if these

 * interfaces are called through splice()) and privilege escalation inside

 * userspace (e.g. if a process with access to such a device passes a file

 * descriptor to a SUID binary as stdin/stdout/stderr).

 *

 * This function provides protection for the legacy API by restricting the

 * calling context.

 -ERESTARTSYS */

 -ERESTARTSYS */

 Returns 0 on success, else a negated errno value */

 Can't lock it with read only access */

 This driver's module count bumped by fops_get in <linux/fs.h> */

 Prevent the device driver from vanishing while we sleep */

	/* scsi_block_when_processing_errors() may block so bypass

	 * check if O_NONBLOCK. Permits SCSI commands to be issued

 we are in error recovery for this device */

 -ERESTARTSYS or -ENODEV */

 N.B. at this point we are holding the open_rel_lock */

 no existing opens */

 undo if error */

/* Release resources associated with a successful sg_open()

	/* possibly many open()s waiting on exlude clearing, start many;

 negative reply_len means v3 format, otherwise v1/v2 */

 no valid header was passed, so ignore the pack_id */

	/*

	 * This could cause a response to be stranded. Close the associated

	 * file descriptor to free up any resources being held.

 now wait on packet to arrive */

 -ERESTARTSYS as signal hit process */

 old, strange behaviour */

	/* This setup of 'result' is for backward compatibility and is best

 Now copy the result back to the user buffer.  */

 Additional sense length field */

 The minimum scsi command length is 6 bytes. */

 reset so only this write() effected */

 based on SCSI command group */

 Determine buffer size.  */

 User did not pass enough bytes for this command. */

 indicator of old interface tunnelled */

 structure abuse ... */

 structure abuse ... */

	/*

	 * SG_DXFER_TO_FROM_DEV is functionally equivalent to SG_DXFER_FROM_DEV,

	 * but is is possible that the app intended SG_DXFER_TO_DEV, because there

	 * is a non-zero input_size, so emit a warning.

 when sg_io_hdr seen, set command queuing on */

 MMAP_IO size must fit in reserve buffer */

 either MMAP_IO or DIRECT_IO (not both) */

 reserve buffer already being used */

 hold opcode of command */

 probably out of space --> ENOMEM */

 v3 (or later) interface */

 sg_rq_end_io() does kref_put(). */

 used by SG_GET_REQUEST_TABLE ioctl() */

 -ERESTARTSYS because signal hit process */

 N.B. User receives timeout as return value */

 strange ..., for backward compatibility */

		/*

		 * N.B. This ioctl never worked properly, but failed to

		 * return an error value. So returning '0' to keep compability

		 * with legacy applications.

 faked - we don't have a real access count anymore */

 don't know so take safe approach */

 if any read waiting, flag it */

 increment page count */

 success */

 want no offset */

 cannot map more than reserved buffer */

/*

 * This function is a "bottom half" handler that is called by the mid

 * level when a command is completed (or has failed).

 Following if statement is a patch supplied by Eric Youngdale */

 Detected possible disc change. Set the bit - this */

 may be used if there are filesystems using this device */

 Rely on write phase to clean out srp status values, so no "else" */

	/*

	 * Free the request as soon as it is complete so that its resources

	 * can be reused without waiting for userspace to read() the

	 * result.  But keep the associated bio (if any) around until

	 * blk_rq_unmap_user() can be called from user context.

		/* Now wake up any sg_read() that is waiting for this

		 * packet.

	/* CAUTION!  Note that the device can still be found via idr_find()

	 * even though the refcount is 0.  Therefore, do idr_remove() BEFORE

	 * any other cleanup.

 want sdp->detaching non-zero as soon as possible */

 only want to do following once per device */

 CONFIG_SCSI_PROC_FS */

 CONFIG_SCSI_PROC_FS */

	/*

	 * NOTE

	 *

	 * With scsi-mq enabled, there are a fixed number of preallocated

	 * requests equal in number to shost->can_queue.  If all of the

	 * preallocated requests are already in use, then scsi_alloc_request()

	 * will sleep until an active command completes, freeing up a request.

	 * Although waiting in an asynchronous interface is less than ideal, we

	 * do not want to use BLK_MQ_REQ_NOWAIT here because userspace might

	 * not expect an EWOULDBLOCK from this condition.

 sfp->res_in_use == 1 */

 number of scat_gath elements allocated */

 don't know why */

 round request up to next highest SG_SECTOR_SZ byte boundary */

 N.B. ret_sz carried into this block ... */

 most likely -ENOMEM */

 end of for loop */

 must have failed */

 divide by 2 */

 Called without mutex lock to avoid deadlock */

 look for requests that are ready + not SG_IO owned */

 guard against other readers */

 always adds to end of list */

 Return of 1 for found; 0 for not found */

 Cleanup any responses which were never read(). */

 origin 1 */

 must be called with sg_index_lock held */

		/* If sdp->detaching, then the refcount may already be 0, in

		 * which case it would be a bug to do kref_get().

 limit "big buff" to 1 MB */

 must be called while holding sg_index_lock */

 irqs already disabled */

 CONFIG_SCSI_PROC_FS */

 SPDX-License-Identifier: GPL-2.0-only

 don't allow DMA if the physical address is bad */

 can't allocate memory; use PIO */

 get the physical address of the bounce buffer */

 the bounce buffer may not be in the first 16M of physmem */

 we could use chipmem... maybe later */

 copy to bounce buffer for a write */

 setup dma direction */

 remember direction */

 setup DMA *physical* address */

 invalidate any cache */

 push any dirty cache */

 start DMA */

 return success */

 disable SCSI interrupts */

 disable SCSI interrupts */

 flush if we were reading */

 clear a possible interrupt */

 stop DMA */

 restore the CONTROL bits (minus the direction flag) */

 copy from a bounce buffer, if necessary */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2003 Christoph Hellwig.

 SPDX-License-Identifier: GPL-2.0-only

/* qlogicpti.c: Performance Technologies QlogicISP sbus card driver.

 *

 * Copyright (C) 1996, 2006, 2008 David S. Miller (davem@davemloft.net)

 *

 * A lot of this driver was directly stolen from Erik H. Moe's PCI

 * Qlogic ISP driver.  Mucho kudos to him for this code.

 *

 * An even bigger kudos to John Grana at Performance Technologies

 * for providing me with the hardware to write this driver, you rule

 * John you really do.

 *

 * May, 2, 1997: Added support for QLGC,isp --jj

 32 for 1.31 F/W */

 MBOX_NO_OP */

 MBOX_LOAD_RAM */

 MBOX_EXEC_FIRMWARE */

 MBOX_DUMP_RAM */

 MBOX_WRITE_RAM_WORD */

 MBOX_READ_RAM_WORD */

 MBOX_MAILBOX_REG_TEST */

 MBOX_VERIFY_CHECKSUM	*/

 MBOX_ABOUT_FIRMWARE */

 0x0009 */

 0x000a */

 0x000b */

 0x000c */

 0x000d */

 MBOX_CHECK_FIRMWARE */

 0x000f */

 MBOX_INIT_REQ_QUEUE */

 MBOX_INIT_RES_QUEUE */

 MBOX_EXECUTE_IOCB */

 MBOX_WAKE_UP	*/

 MBOX_STOP_FIRMWARE */

 MBOX_ABORT */

 MBOX_ABORT_DEVICE */

 MBOX_ABORT_TARGET */

 MBOX_BUS_RESET */

 MBOX_STOP_QUEUE */

 MBOX_START_QUEUE */

 MBOX_SINGLE_STEP_QUEUE */

 MBOX_ABORT_QUEUE */

 MBOX_GET_DEV_QUEUE_STATUS */

 0x001e */

 MBOX_GET_FIRMWARE_STATUS */

 MBOX_GET_INIT_SCSI_ID */

 MBOX_GET_SELECT_TIMEOUT */

 MBOX_GET_RETRY_COUNT	*/

 MBOX_GET_TAG_AGE_LIMIT */

 MBOX_GET_CLOCK_RATE */

 MBOX_GET_ACT_NEG_STATE */

 MBOX_GET_ASYNC_DATA_SETUP_TIME */

 MBOX_GET_SBUS_PARAMS */

 MBOX_GET_TARGET_PARAMS */

 MBOX_GET_DEV_QUEUE_PARAMS */

 0x002a */

 0x002b */

 0x002c */

 0x002d */

 0x002e */

 0x002f */

 MBOX_SET_INIT_SCSI_ID */

 MBOX_SET_SELECT_TIMEOUT */

 MBOX_SET_RETRY_COUNT	*/

 MBOX_SET_TAG_AGE_LIMIT */

 MBOX_SET_CLOCK_RATE */

 MBOX_SET_ACTIVE_NEG_STATE */

 MBOX_SET_ASYNC_DATA_SETUP_TIME */

 MBOX_SET_SBUS_CONTROL_PARAMS */

 MBOX_SET_TARGET_PARAMS */

 MBOX_SET_DEV_QUEUE_PARAMS */

 0x003a */

 0x003b */

 0x003c */

 0x003d */

 0x003e */

 0x003f */

 0x0040 */

 0x0041 */

 0x0042 */

 queue length's _must_ be power of two: */

#if 0	/* It appears that at least PTI cards do not support

	 * 64-byte bursts and that setting the B64 bit actually

	 * is a nop and the chip ends up using the smallest burst

	 * size. -DaveM

 No sbus bursts for you... */

 Set SBUS semaphore. */

 Wait for host IRQ bit to clear. */

 Write mailbox command registers. */

 Clear RISC interrupt. */

 Clear SBUS semaphore. */

 Set HOST interrupt. */

 Wait for HOST interrupt clears. */

 Wait for SBUS semaphore to get set. */

 Workaround for some buggy chips. */

 Wait for MBOX busy condition to go away. */

 Read back output parameters. */

 Clear RISC interrupt. */

 Release SBUS semaphore. */

 We're done. */

		/*

		 * disconnect, parity, arq, reneg on reset, and, oddly enough

		 * tags...the midlayer's notion of tagged support has to match

		 * our device settings, and since we base whether we enable a

		 * tag on a  per-cmnd basis upon what the midlayer sez, we

		 * actually enable the capability here.

 all load addresses are at 0x1000 */

 Only reset the scsi bus if it is not free. */

 reset adapter and per-device default values. */

 do it after finding out whether we're ultra mode capable */

 Release the RISC processor. */

 Get RISC to start executing the firmware code. */

 Set initiator scsi ID. */

 Initialize state of the queues, both hw and sw. */

		/*

		 * Since we're now loading 1.31 f/w, force narrow/async.

 no offset, we do not have sync mode yet */

	/*

	 * Always (sigh) do an initial bus reset (kicks f/w).

 all f/w modules load at 0x1000 */

	/* Verify the checksum twice, one before loading it, and once

	 * afterwards via the mailbox commands.

 Pin lines are only stable while RISC is paused. */

	/* This shouldn't be necessary- we've reset things so we should be

 Load it up.. */

 Reset the ISP again. */

 Ask ISP to verify the checksum of the new code. */

 Start using newly downloaded firmware. */

 Snag the major and minor revisions from the result. */

 Set the clock rate */

 Load scsi initiator ID and interrupt level into sbus static ram. */

	/* We used to try various overly-clever things to

	 * reduce the interrupt processing overhead on

	 * sun4c/sun4m when multiple PTI's shared the

	 * same IRQ.  It was too complex and messy to

	 * sanely maintain.

	/* Check for what the clock input to this card is.

	 * Default to 40Mhz.

 bullshit */

/* The request and response queues must each be aligned

 * on a page boundary.

 I am a certified frobtronicist. */

 Do it to it baby. */

 Fill in first four sg entries: */

 Shouldn't this be 0? */

 Committed, record Scsi_Cmd so we can find it later. */

	/* Temporary workaround until bug is found and fixed (one bug has been found

 tags handled in midlayer */

 enable sync mode? */

 are we wide capable? */

/*

 * The middle SCSI layer ensures that queuecommand never gets invoked

 * concurrently with itself or the interrupt handler (though the

 * interrupt handler may call this routine as part of

 * request-completion handling).

 *

 * "This code must fly." -davem

	/* Unfortunately, unless you use the new EH code, which

	 * we don't, the midlayer will ignore the return value,

	 * which is insane.  We pick up the pieces like this.

 This looks like a network driver! */

		/* We store an index in the handle, not the pointer in

		 * some form.  This avoids problems due to the fact

		 * that the handle provided is only 32-bits. -DaveM

	/* Find the 32-bit cookie we gave to the firmware for

	 * this command.

	/* Sometimes Antares cards come up not completely

	 * setup, and we get a report of a zero IRQ.

 Clear out scsi_cmnd array. */

 Load the firmware. */

 Check the PTI status reg. */

 Reset the ISP and init res/req queues. */

 Shut up the card. */

 Free IRQ handler and unmap Qlogic,ISP and PTI status regs. */

/*

   3w-9xxx.c -- 3ware 9000 Storage Controller device driver for Linux.



   Written By: Adam Radford <aradford@gmail.com>

   Modifications By: Tom Couch



   Copyright (C) 2004-2009 Applied Micro Circuits Corporation.

   Copyright (C) 2010 LSI Corporation.



   This program is free software; you can redistribute it and/or modify

   it under the terms of the GNU General Public License as published by

   the Free Software Foundation; version 2 of the License.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   NO WARRANTY

   THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

   CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

   LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

   solely responsible for determining the appropriateness of using and

   distributing the Program and assumes all risks associated with its

   exercise of rights under this Agreement, including but not limited to

   the risks and costs of program errors, damage to or loss of data,

   programs or equipment, and unavailability or interruption of operations.



   DISCLAIMER OF LIABILITY

   NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

   DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

   USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

   HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES



   You should have received a copy of the GNU General Public License

   along with this program; if not, write to the Free Software

   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA



   Bugs/Comments/Suggestions should be mailed to:

   aradford@gmail.com



   Note: This version of the driver does not contain a bundled firmware

         image.



   History

   -------

   2.26.02.000 - Driver cleanup for kernel submission.

   2.26.02.001 - Replace schedule_timeout() calls with msleep().

   2.26.02.002 - Add support for PAE mode.

                 Add lun support.

                 Fix twa_remove() to free irq handler/unregister_chrdev()

                 before shutting down card.

                 Change to new 'change_queue_depth' api.

                 Fix 'handled=1' ISR usage, remove bogus IRQ check.

                 Remove un-needed eh_abort handler.

                 Add support for embedded firmware error strings.

   2.26.02.003 - Correctly handle single sgl's with use_sg=1.

   2.26.02.004 - Add support for 9550SX controllers.

   2.26.02.005 - Fix use_sg == 0 mapping on systems with 4GB or higher.

   2.26.02.006 - Fix 9550SX pchip reset timeout.

                 Add big endian support.

   2.26.02.007 - Disable local interrupts during kmap/unmap_atomic().

   2.26.02.008 - Free irq handler in __twa_shutdown().

                 Serialize reset code.

                 Add support for 9650SE controllers.

   2.26.02.009 - Fix dma mask setting to fallback to 32-bit if 64-bit fails.

   2.26.02.010 - Add support for 9690SA controllers.

   2.26.02.011 - Increase max AENs drained to 256.

                 Add MSI support and "use_msi" module parameter.

                 Fix bug in twa_get_param() on 4GB+.

                 Use pci_resource_len() for ioremap().

   2.26.02.012 - Add power management support.

   2.26.02.013 - Fix bug in twa_load_sgl().

   2.26.02.014 - Force 60 second timeout default.

 Globals */

 Module parameters */

 Function prototypes */

 Functions */

 Show some statistics about the card */

 End twa_show_stats() */

 Create sysfs 'stats' entry */

 Host attributes initializer */

 File operations struct for character device */

/*

 * The controllers use an inline buffer instead of a mapped SGL for small,

 * single entry buffers.  Note that we treat a zero-length transfer like

 * a mapped SGL.

 This function will complete an aen request from the isr */

 First check for internal completion of set param for time sync */

 Keep reading the queue in case there are more aen's */

 Quit reading the queue if this is the last one */

 If there are more aen's, keep reading the queue */

 End twa_aen_complete() */

 This function will drain aen queue */

 Initialize cdb */

 opcode */

 allocation length */

 Initialize sglist */

 Mark internal command */

 Send command to the board */

 Now poll for completion */

 Now queue an event info */

 End twa_aen_drain_queue() */

 This function will queue an event */

 Fill out event info */

 Check for clobber */

 event->time_stamp_sec overflows in y2106 */

 Check for embedded error string */

 End twa_aen_queue_event() */

 This function will read the aen queue from the isr */

 Initialize cdb */

 opcode */

 allocation length */

 Initialize sglist */

 Mark internal command */

 Now post the command packet */

 End twa_aen_read_queue() */

 This function will look up an AEN severity string */

 End twa_aen_severity_lookup() */

 This function will sync firmware time with the host time */

 Fill out the command packet */

 Setup the param */

 Controller time keep table */

 SchedulerTime */

	/* Convert system time in UTC to local time seconds since last

 Mark internal command */

 Now post the command */

 End twa_aen_sync_time() */

 This function will allocate memory and check if it is correctly aligned */

 End twa_allocate_memory() */

 This function will check the status register for unexpected bits */

 End twa_check_bits() */

 This function will check the srl and decide if we are compatible  */

 Try base mode compatibility */

 Load rest of compatibility struct */

 End twa_check_srl() */

 This function handles ioctl for the character device */

 Only let one of these through at a time */

 First copy down the driver command */

 Check data buffer size */

 Hardware can only do multiple of 512 byte transfers */

 Now allocate ioctl buf memory */

 Now copy down the entire ioctl */

 See which ioctl we are doing */

 Flag internal command */

 Flag chrdev ioctl */

 Load request id and sglist for both command types */

 Now post the command packet to the controller */

 Now wait for command to complete */

 We timed out, and didn't get an interrupt */

 Now we need to reset the board */

 Now copy in the command packet response */

 Now complete the io */

 Copy compatibility struct into ioctl data buffer */

 Now copy the entire response to userspace */

 Now free ioctl buf memory */

 End twa_chrdev_ioctl() */

 This function handles open for the character device */

 NOTE that this function will race with remove. */

 End twa_chrdev_open() */

 This function will print readable messages from status register errors */

 Check for various error conditions and handle them appropriately */

 End twa_decode_bits() */

 This function will empty the response queue */

 End twa_empty_response_queue() */

 This function will clear the pchip/response queue on 9550SX */

 P-chip settle time */

 End twa_empty_response_queue_large() */

 This function passes sense keys from firmware to scsi layer */

 Check for embedded error string */

 Don't print error for Logical unit not supported during rollcall */

 End twa_fill_sense() */

 This function will free up device extension resources */

 End twa_free_device_extension() */

 This function will free a request id */

 End twa_free_request_id() */

 This function will get parameter table entries from the firmware */

 Setup the command packet */

 Now setup the param */

 Post the command packet to the board */

 Poll for completion */

 End twa_get_param() */

 This function will assign an available request id */

 End twa_get_request_id() */

 This function will send an initconnection command to controller */

 Initialize InitConnection command packet */

 Turn on 64-bit sgl support if we need to */

 Send command packet to the board */

 Poll for completion */

 End twa_initconnection() */

 This function will initialize the fields of a device extension */

 Initialize command packet buffers */

 Initialize generic buffer */

 Allocate event info space */

 End twa_initialize_device_extension() */

 This function is the interrupt service routine */

 Get the per adapter lock */

 Read the registers */

 Check if this is our interrupt, otherwise bail */

 If we are resetting, bail */

 Check controller for errors */

 Handle host interrupt */

 Handle attention interrupt */

 Handle command interrupt */

 Drain as many pending commands as we can */

 If we get here, we will continue re-posting on the next command interrupt */

 Handle response interrupt */

 Drain the response queue from the board */

 Complete the response */

 Check for command packet errors */

 Skip ioctl error prints */

 Check for correct state */

 Check for internal command completion */

 If no error command was a success */

 If error, command failed */

 Ask for a host reset */

 Report residual bytes for single sgl */

 Now complete the io */

 Check for valid status after each drain */

 End twa_interrupt() */

 This function will load the request id and various sgls for ioctls */

 Load the sg list */

 End twa_load_sgl() */

 This function will poll for a response interrupt of a request */

 bad response */

 bad response */

 End twa_poll_response() */

 This function will poll the status register for a flag */

 End twa_poll_status() */

 This function will poll the status register for disappearance of a flag */

 End twa_poll_status_gone() */

 This function will attempt to post a command packet to the board */

 For 9650SE write low 4 bytes first */

 Only pend internal driver commands */

 Couldn't post the command packet, so we do it later */

 Now write upper 4 bytes */

 End twa_post_command_packet() */

 This function will reset a device extension */

 Abort all requests that are in progress */

 Reset queues and counts */

 End twa_reset_device_extension() */

 This function will reset a controller */

 Clear pchip/response queue on 9550SX */

 Make sure controller is in a good state */

 Empty response queue */

 Check for compatibility/flash */

 Drain the AEN queue */

 If we got here, controller is in a good state */

 End twa_reset_sequence() */

 This funciton returns unit geometry in cylinders/heads/sectors */

 End twa_scsi_biosparam() */

 This is the new scsi eh reset function */

 Make sure we are not issuing an ioctl or resetting from ioctl */

 Now reset the card and some of the device extension data */

 End twa_scsi_eh_reset() */

 This is the main scsi queue function to handle scsi opcodes */

 If we are resetting due to timed out ioctl, report as busy */

 Check if this FW supports luns */

 Get a free request id */

 Save the scsi command for use by the ISR */

 End twa_scsi_queue() */

 This function hands scsi cdb's to the firmware */

 Initialize command packet */

 We forced 16 byte cdb use earlier */

 Map sglist from scsi layer to cmd packet */

 Internal cdb post */

 Update sector statistic */

 Update SG statistics */

 Now post the command to the board */

 End twa_scsiop_execute_scsi() */

 This function completes an execute scsi operation */

 End twa_scsiop_execute_scsi_complete() */

 This function tells the controller to shut down */

 Disable interrupts */

 Free up the IRQ */

 Tell the card we are shutting down */

 Clear all interrupts just before exit */

 End __twa_shutdown() */

 Wrapper for __twa_shutdown */

 End twa_shutdown() */

 This function will look up a string */

 End twa_string_lookup() */

 This function gets called when a disk is coming on-line */

 Force 60 second timeout */

 End twa_slave_configure() */

 scsi_host_template initializer */

 This function will probe and initialize a card */

 Save values to device extension */

 Request IO regions */

 Save base address */

 Disable interrupts on the card */

 Initialize the card */

 Set host specific parameters */

 Channels aren't supported by adapter */

 Register the card with the kernel SCSI layer */

 Try to enable MSI */

 Now setup the interrupt handler */

 Re-enable interrupts on the card */

 Finally, scan the host */

 End twa_probe() */

 This function is called to remove a device */

 Unregister character device */

 Shutdown the card */

 Disable MSI if enabled */

 Free IO remapping */

 Free up the mem region */

 Free up device extension resources */

 End twa_remove() */

 This function is called on PCI suspend */

 Tell the card we are shutting down */

 End twa_suspend() */

 This function is called on PCI resume */

 Initialize the card */

 Now setup the interrupt handler */

 Now enable MSI if enabled */

 Re-enable interrupts on the card */

 End twa_resume() */

 PCI Devices supported by this driver */

 pci_driver initializer */

 This function is called on driver initialization */

 End twa_init() */

 This function is called on driver exit */

 End twa_exit() */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * AMD am53c974 driver.

 * Copyright (c) 2014 Hannes Reinecke, SUSE Linux GmbH

 EEPROM is accessed with 16-bit values */

/*

 * DC390 EEPROM

 *

 * 8 * 4 bytes of per-device options

 * followed by HBA specific options

 Per-device options */

 HBA-specific options */

 Nothing to do ? */

 Data-In or Data-Out, nothing to be done */

	/*

	 * When there is a residual BCMPLT will never be set

	 * (obviously). But we still have to issue the BLAST

	 * command, otherwise the data will not being transferred.

	 * But we'll never know when the BLAST operation is

	 * finished. So check for some time and give up eventually.

 BLAST residual handling is currently untested */

 Set DMA engine to IDLE */

 DMA write direction logic is inverted */

 Send DMA Start command */

	/*

	 * If CONFIG2_FENAB is set we can

	 * handle up to 24 bit addresses

	/*

	 * Prevent crossing a 24-bit address boundary.

/*

 * Read DC-390 eeprom

 no Tekram EEprom found */

	/*

	 * The am53c974 HBA has a design flaw of generating

	 * spurious DMA completion interrupts when using

	 * DMA for command submission.

	/*

	 * Enable CONFIG2_FENAB to allow for large DMA transfers

 Assume 40MHz clock */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * SCSI Zoned Block commands

 *

 * Copyright (C) 2014-2015 SUSE Linux GmbH

 * Written by: Hannes Reinecke <hare@suse.de>

 * Modified by: Damien Le Moal <damien.lemoal@hgst.com>

 * Modified by: Shaun Tancheff <shaun.tancheff@seagate.com>

		/*

		 * Offline and read-only zones do not have a valid

		 * write pointer. Use 0 as for an empty zone.

/**

 * sd_zbc_do_report_zones - Issue a REPORT ZONES scsi command.

 * @sdkp: The target disk

 * @buf: vmalloc-ed buffer to use for the reply

 * @buflen: the buffer size

 * @lba: Start LBA of the report

 * @partial: Do partial report

 *

 * For internal use during device validation.

 * Using partial=true can significantly speed up execution of a report zones

 * command because the disk does not have to count all possible report matching

 * zones and will only report the count of zones fitting in the command reply

 * buffer.

/**

 * sd_zbc_alloc_report_buffer() - Allocate a buffer for report zones reply.

 * @sdkp: The target disk

 * @nr_zones: Maximum number of zones to report

 * @buflen: Size of the buffer allocated

 *

 * Try to allocate a reply buffer for the number of requested zones.

 * The size of the buffer allocated may be smaller than requested to

 * satify the device constraint (max_hw_sectors, max_segments, etc).

 *

 * Return the address of the allocated buffer and update @buflen with

 * the size of the allocated buffer.

	/*

	 * Report zone buffer size should be at most 64B times the number of

	 * zones requested plus the 64B reply header, but should be aligned

	 * to SECTOR_SIZE for ATA devices.

	 * Make sure that this size does not exceed the hardware capabilities.

	 * Furthermore, since the report zone command cannot be split, make

	 * sure that the allocated buffer can always be mapped by limiting the

	 * number of pages allocated to the HBA max segments limit.

/**

 * sd_zbc_zone_sectors - Get the device zone size in number of 512B sectors.

 * @sdkp: The target disk

 Not a zoned device */

 Device gone or invalid */

 Not a zoned device */

 Unaligned request */

/**

 * sd_zbc_prepare_zone_append() - Prepare an emulated ZONE_APPEND command.

 * @cmd: the command to setup

 * @lba: the LBA to patch

 * @nr_blocks: the number of LBAs to be written

 *

 * Called from sd_setup_read_write_cmnd() for REQ_OP_ZONE_APPEND.

 * @sd_zbc_prepare_zone_append() handles the necessary zone wrote locking and

 * patching of the lba for an emulated ZONE_APPEND command.

 *

 * In case the cached write pointer offset is %SD_ZBC_INVALID_WP_OFST it will

 * schedule a REPORT ZONES command and return BLK_STS_IOERR.

 Unlock of the write lock will happen in sd_zbc_complete() */

		/*

		 * We are about to schedule work to update a zone write pointer

		 * offset, which will cause the zone append command to be

		 * requeued. So make sure that the scsi device does not go away

		 * while the work is being processed.

/**

 * sd_zbc_setup_zone_mgmt_cmnd - Prepare a zone ZBC_OUT command. The operations

 *			can be RESET WRITE POINTER, OPEN, CLOSE or FINISH.

 * @cmd: the command to setup

 * @op: Operation to be performed

 * @all: All zones control

 *

 * Called from sd_init_command() for REQ_OP_ZONE_RESET, REQ_OP_ZONE_RESET_ALL,

 * REQ_OP_ZONE_OPEN, REQ_OP_ZONE_CLOSE or REQ_OP_ZONE_FINISH requests.

/**

 * sd_zbc_zone_wp_update - Update cached zone write pointer upon cmd completion

 * @cmd: Completed command

 * @good_bytes: Command reply bytes

 *

 * Called from sd_zbc_complete() to handle the update of the cached zone write

 * pointer value in case an update is needed.

	/*

	 * If we got an error for a command that needs updating the write

	 * pointer offset cache, we must mark the zone wp offset entry as

	 * invalid to force an update from disk the next time a zone append

	 * command is issued.

 Force complete completion (no retry) */

		/*

		 * Force an update of the zone write pointer offset on

		 * the next zone append access.

/**

 * sd_zbc_complete - ZBC command post processing.

 * @cmd: Completed command

 * @good_bytes: Command reply bytes

 * @sshdr: command sense header

 *

 * Called from sd_done() to handle zone commands errors and updates to the

 * device queue zone write pointer offset cahce.

		/*

		 * INVALID FIELD IN CDB error: a zone management command was

		 * attempted on a conventional zone. Nothing to worry about,

		 * so be quiet about the error.

/**

 * sd_zbc_check_zoned_characteristics - Check zoned block device characteristics

 * @sdkp: Target disk

 * @buf: Buffer where to store the VPD page data

 *

 * Read VPD page B6, get information and check that reads are unconstrained.

 Host-aware */

 Host-managed */

	/*

	 * Check for unconstrained reads: host-managed devices with

	 * constrained reads (drives failing read after write pointer)

	 * are not supported.

/**

 * sd_zbc_check_capacity - Check the device capacity

 * @sdkp: Target disk

 * @buf: command buffer

 * @zblocks: zone size in number of blocks

 *

 * Get the device zone size and check that the device capacity as reported

 * by READ CAPACITY matches the max_lba value (plus one) of the report zones

 * command reply for devices with RC_BASIS == 0.

 *

 * Returns 0 upon success or an error code upon failure.

 Do a report zone to get max_lba and the size of the first zone */

 The max_lba field is the capacity of this device */

 Get the size of the first reported zone */

 Serialize against revalidate zones */

	/*

	 * For all zoned disks, initialize zone append emulation data if not

	 * already done. This is necessary also for host-aware disks used as

	 * regular disks due to the presence of partitions as these partitions

	 * may be deleted and the disk zoned model changed back from

	 * BLK_ZONED_NONE to BLK_ZONED_HA.

	/*

	 * There is nothing to do for regular disks, including host-aware disks

	 * that have partitions.

	/*

	 * Make sure revalidate zones are serialized to ensure exclusive

	 * updates of the scsi disk data.

		/*

		 * Device managed or normal SCSI disk,

		 * no special handling required

 READ16/WRITE16 is mandatory for ZBC disks */

		/*

		 * This can happen for a host aware disk with partitions.

		 * The block device zone information was already cleared

		 * by blk_queue_set_zoned(). Only clear the scsi disk zone

		 * information and exit early.

 Check zoned block device characteristics (unconstrained reads) */

 Check the device capacity reported by report zones */

 The drive satisfies the kernel restrictions: set it up */

	/*

	 * Per ZBC and ZAC specifications, writes in sequential write required

	 * zones of host-managed devices must be aligned to the device physical

	 * block size.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * scsi_sysfs.c

 *

 * SCSI sysfs interface routines.

 *

 * Created to pull SCSI mid layer sysfs routines into one file.

		/*

		 * Doesn't check for int overflow

/*

 * shost_show_function: macro to create an attr function that can be used to

 * show a non-bit field.

/*

 * shost_rd_attr: macro to create a function and attribute variable for a

 * read only field.

/*

 * Create the actual show/store functions and data structures.

 DEVICE_ATTR(state) clashes with dev_attr_state for sdev */

 by default this should be initiator */

 NULL queue means the device can't be used */

 Set module pointer as NULL in case of module unloading */

 all probing is done in the individual ->probe routines */

/*

 * sdev_show_function: macro to create an attr function that can be used to

 * show a non-bit field.

/*

 * sdev_rd_attr: macro to create a function and attribute variable for a

 * read only field.

/*

 * sdev_rw_attr: create a function and attribute variable for a

 * read/write field.

/* Currently we don't export bit fields, but we might in future,

/*

 * sdev_rd_attr: create a function and attribute variable for a

 * read/write bit field.

/*

 * scsi_sdev_check_buf_bit: return 0 if buf is "0", return 1 if buf is "1",

 * else return -EINVAL.

/*

 * Create the actual show/store functions and data structures.

/*

 * TODO: can we make these symlinks to the block layer ones?

	/*

	 * We need to try to get module, avoiding the module been removed

	 * during delete.

	/*

	 * Concurrent writes into the "delete" sysfs attribute may trigger

	 * concurrent calls to device_remove_file() and scsi_remove_device().

	 * device_remove_file() handles concurrent removal calls by

	 * serializing these and by ignoring the second and later removal

	 * attempts.  Concurrent calls of scsi_remove_device() are

	 * serialized. The second and later calls of scsi_remove_device() are

	 * ignored because the first call of that function changes the device

	 * state into SDEV_DEL.

		/*

		 * If the device state changes to SDEV_RUNNING, we need to

		 * run the queue to avoid I/O hang, and rescan the device

		 * to revalidate it. Running the queue first is necessary

		 * because another thread may be waiting inside

		 * blk_mq_freeze_queue_wait() and because that call may be

		 * waiting for pending I/O to finish.

		/*

		 * Attach to a device handler

		/*

		 * Activate a device handler

		/*

		 * Detach from a device handler

 Default template for device attributes.  May NOT be modified */

/**

 * scsi_sysfs_add_sdev - add scsi device to sysfs

 * @sdev:	scsi_device to add

 *

 * Return value:

 * 	0 on Success / non-zero on Failure

			/*

			 * We're treating error on bsg register as non-fatal, so

			 * pretend nothing went wrong.

	/*

	 * This cleanup path is not reentrant and while it is impossible

	 * to get a new reference with scsi_device_get() someone can still

	 * hold a previously acquired one.

		/*

		 * If scsi_internal_target_block() is running concurrently,

		 * wait until it has finished before changing the device state.

		/*

		 * If blocked, we go straight to DEL and restart the queue so

		 * any commands issued during driver shutdown (like sync

		 * cache) are errored immediately.

	/*

	 * Stop accepting new requests and wait until all queuecommand() and

	 * scsi_run_queue() invocations have finished before tearing down the

	 * device.

	/*

	 * Paired with the kref_get() in scsi_sysfs_initialize().  We have

	 * removed sysfs visibility from the device, so make the target

	 * invisible if this was the last device underneath it.

/**

 * scsi_remove_device - unregister a device from the scsi bus

 * @sdev:	scsi_device to unregister

		/*

		 * We cannot call scsi_device_get() here, as

		 * we might've been called from rmmod() causing

		 * scsi_device_get() to fail the module_is_live()

		 * check.

/**

 * scsi_remove_target - try to remove a target and all its devices

 * @dev: generic starget or parent of generic stargets to be removed

 *

 * Note: This is slightly racy.  It is possible that if the user

 * requests the addition of another device then the target won't be

 * removed.

/**

 * scsi_sysfs_add_host - add scsi host to subsystem

 * @shost:     scsi host struct to add to subsystem

	/*

	 * Get a default scsi_level from the target (derived from sibling

	 * devices).  This is the best we can do for guessing how to set

	 * sdev->lun_in_cdb for the initial INQUIRY command.  For LUN 0 the

	 * setting doesn't matter, because all the bits are zero anyway.

	 * But it does matter for higher LUNs.

	/*

	 * device can now only be removed via __scsi_remove_device() so hold

	 * the target.  Target will be held in CREATED state until something

	 * beneath it becomes visible (in which case it moves to RUNNING)

/* A blank transport template that is used in drivers that don't

 SPDX-License-Identifier: GPL-2.0-only

/*

 * raid_class.c - implementation of a simple raid visualisation class

 *

 * Copyright (c) 2005 - James Bottomley <James.Bottomley@steeleye.com>

 *

 * This class is designed to allow raid attributes to be visualised and

 * manipulated in a form independent of the underlying raid.  Ultimately this

 * should work for both hardware and software raids.

 The actual attributes */

	/* The array of null terminated pointers to attributes 

	/* We have to look for every subsystem that could house

 FIXME: look at other subsystems too */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * sim710.c - Copyright (C) 1999 Richard Hirst <richard@sleepie.demon.co.uk>

 *

 *----------------------------------------------------------------------------

 *----------------------------------------------------------------------------

 *

 * MCA card detection code by Trent McNair. (now deleted)

 * Fixes to not explicitly nul bss data from Xavier Bestel.

 * Some multiboard fixes from Rolf Eike Beer.

 * Auto probing of EISA config space from Trevor Hemsley.

 *

 * Rewritten to use 53c700.c by James.Bottomley@SteelEye.com

 Must be enough for EISA */

 command line passed by insmod */

 Fill in the three required pieces of hostdata */

 and register the chip */

 CONFIG_EISA */

	/*

	 * FIXME: We'd really like to return -ENODEV if no devices have actually

	 * been found.  However eisa_driver_register() only reports problems

	 * with kobject_register() so simply return success for now.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  scsi_netlink.c  - SCSI Transport Netlink Interface

 *

 *  Copyright (C) 2006   James Smart, Emulex Corporation

/**

 * scsi_nl_rcv_msg - Receive message handler.

 * @skb:		socket receive buffer

 *

 * Description: Extracts message from a receive buffer.

 *    Validates message header and calls appropriate transport message handler

 *

 *

		/*

		 * Deliver message to the appropriate transport

 Locate the driver that corresponds to the message */

/**

 * scsi_netlink_init - Called by SCSI subsystem to initialize

 * 	the SCSI transport netlink interface

 *

/**

 * scsi_netlink_exit - Called by SCSI subsystem to disable the SCSI transport netlink interface

 *

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/drivers/scsi/scsi_proc.c

 *

 * The functions in this file provide an interface between

 * the PROC file system and the SCSI device drivers

 * It is mainly used for debugging, statistics and to pass 

 * information directly to the lowlevel driver.

 *

 * (c) 1995 Michael Neuffer neuffer@goofy.zdv.uni-mainz.de 

 * Version: 0.99.8   last change: 95/09/13

 * 

 * generic command parser provided by: 

 * Andreas Heilwagen <crashcar@informatik.uni-koblenz.de>

 *

 * generic_proc_info() support of xxxx_info() by:

 * Michael A. Griffith <grif@acm.org>

 4K page size, but our output routines, use some slack for overruns */

 Protect sht->present and sht->proc_dir */

/**

 * scsi_proc_hostdir_add - Create directory in /proc for a scsi host

 * @sht: owner of this directory

 *

 * Sets sht->proc_dir to the new directory.

/**

 * scsi_proc_hostdir_rm - remove directory in /proc for a scsi host

 * @sht: owner of directory

/**

 * scsi_proc_host_add - Add entry for this host to appropriate /proc dir

 * @shost: host to add

/**

 * scsi_proc_host_rm - remove this host's entry from /proc

 * @shost: which host

/**

 * proc_print_scsidevice - return data about this host

 * @dev: A scsi device

 * @data: &struct seq_file to output to.

 *

 * Description: prints Host, Channel, Id, Lun, Vendor, Model, Rev, Type,

 * and revision.

/**

 * scsi_add_single_device - Respond to user request to probe for/add device

 * @host: user-supplied decimal integer

 * @channel: user-supplied decimal integer

 * @id: user-supplied decimal integer

 * @lun: user-supplied decimal integer

 *

 * Description: called by writing "scsi add-single-device" to /proc/scsi/scsi.

 *

 * does scsi_host_lookup() and either user_scan() if that transport

 * type supports it, or else scsi_scan_host_selected()

 *

 * Note: this seems to be aimed exclusively at SCSI parallel busses.

/**

 * scsi_remove_single_device - Respond to user request to remove a device

 * @host: user-supplied decimal integer

 * @channel: user-supplied decimal integer

 * @id: user-supplied decimal integer

 * @lun: user-supplied decimal integer

 *

 * Description: called by writing "scsi remove-single-device" to

 * /proc/scsi/scsi.  Does a scsi_device_lookup() and scsi_remove_device()

/**

 * proc_scsi_write - handle writes to /proc/scsi/scsi

 * @file: not used

 * @buf: buffer to write

 * @length: length of buf, at most PAGE_SIZE

 * @ppos: not used

 *

 * Description: this provides a legacy mechanism to add or remove devices by

 * Host, Channel, ID, and Lun.  To use,

 * "echo 'scsi add-single-device 0 1 2 3' > /proc/scsi/scsi" or

 * "echo 'scsi remove-single-device 0 1 2 3' > /proc/scsi/scsi" with

 * "0 1 2 3" replaced by the Host, Channel, Id, and Lun.

 *

 * Note: this seems to be aimed at parallel SCSI. Most modern busses (USB,

 * SATA, Firewire, Fibre Channel, etc) dynamically assign these values to

 * provide a unique identifier and nothing more.

	/*

	 * Usage: echo "scsi add-single-device 0 1 2 3" >/proc/scsi/scsi

	 * with  "0 1 2 3" replaced by your "Host Channel Id Lun".

	/*

	 * Usage: echo "scsi remove-single-device 0 1 2 3" >/proc/scsi/scsi

	 * with  "0 1 2 3" replaced by your "Host Channel Id Lun".

	/*

	 * convert success returns so that we return the 

	 * number of bytes consumed.

/**

 * proc_scsi_open - glue function

 * @inode: not used

 * @file: passed to single_open()

 *

 * Associates proc_scsi_show with this file

	/*

	 * We don't really need this for the write case but it doesn't

	 * harm either.

/**

 * scsi_init_procfs - create scsi and scsi/scsi in procfs

/**

 * scsi_exit_procfs - Remove scsi/scsi and scsi from procfs

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  sr.c Copyright (C) 1992 David Giller

 *           Copyright (C) 1993, 1994, 1995, 1999 Eric Youngdale

 *

 *  adapted from:

 *      sd.c Copyright (C) 1992 Drew Eckhardt

 *      Linux scsi disk driver by

 *              Drew Eckhardt <drew@colorado.edu>

 *

 *	Modified by Eric Youngdale ericy@andante.org to

 *	add scatter-gather, multiple outstanding request, and other

 *	enhancements.

 *

 *      Modified by Eric Youngdale eric@andante.org to support loadable

 *      low-level scsi drivers.

 *

 *      Modified by Thomas Quinot thomas@melchior.cuivre.fdn.fr to

 *      provide auto-eject.

 *

 *      Modified by Gerd Knorr <kraxel@cs.tu-berlin.de> to support the

 *      generic cdrom interface

 *

 *      Modified by Jens Axboe <axboe@suse.de> - Uniform sr_packet()

 *      interface, capabilities probe additions, ioctl cleanups, etc.

 *

 *	Modified by Richard Gooch <rgooch@atnf.csiro.au> to support devfs

 *

 *	Modified by Jens Axboe <axboe@suse.de> - support DVD-RAM

 *	transparently and lose the GHOST hack

 *

 *	Modified by Arnaldo Carvalho de Melo <acme@conectiva.com.br>

 *	check resource allocation in sr_init and some cleanups

 For the door lock/unlock commands */

/* This semaphore is used to mediate the 0->1 reference get in the

 * face of object destruction (i.e. we can't allow a get on an

 E.g.: runtime suspend following sr_remove() */

/*

 * The get and put routines for the struct scsi_cd.  Note this entity

 * has a scsi_device pointer and owns a reference to this.

 polled */

 reserved */

 notification class: media */

 reserved */

 allocation length */

 control */

/*

 * This function checks to see if the media has been changed or eject

 * button has been pressed.  It is possible that we have already

 * sensed a change, or the drive may have sensed one and not yet

 * reported it.  The past events are accumulated in sdev->changed and

 * returned together with the current state.

 no changer support */

	/*

	 * If earlier GET_EVENT_STATUS_NOTIFICATION and TUR did not agree

	 * for several times in a row.  We rely on TUR only for this likely

	 * broken device, to prevent generating incorrect media changed

	 * events for every open().

	/*

	 * GET_EVENT_STATUS_NOTIFICATION is enough unless MEDIA_CHANGE

	 * is being cleared.  Note that there are devices which hang

	 * if asked to execute TUR repeatedly.

 let's see whether the media is there with TUR */

	/*

	 * Media is considered to be present if TUR succeeds or fails with

	 * sense data indicating something other than media-not-present

	 * (ASC 0x3a).

 check whether GET_EVENT is reporting spurious MEDIA_CHANGE */

/*

 * sr_done is the interrupt routine for the device driver.

 *

 * It will be notified on the end of a SCSI read / write, and will take one

 * of several actions based on success or failure.

	/*

	 * Handle MEDIUM ERRORs or VOLUME OVERFLOWs that indicate partial

	 * success.  Since this is a relatively rare error condition, no

	 * care is taken to avoid unnecessary additional work such as

	 * memcpy's that could be avoided.

 Sense current */

			/*

			 * The SCSI specification allows for the value

			 * returned by READ CAPACITY to be up to 75 2K

			 * sectors past the last readable block.

			 * Therefore, if we hit a medium error within the

			 * last 75 2K sectors, we decrease the saved size

			 * value.

		/*

		 * quietly refuse to do anything to a changed disc until the

		 * changed bit has been reset

	/*

	 * request doesn't start on hw block boundary, add scatter pads

	/*

	 * We shouldn't disconnect in the middle of a sector, so with a dumb

	 * host adapter, it's safe to assume that we can at least transfer

	 * this many bytes between each connect / disconnect.

	/*

	 * This indicates that the command is ready from our end to be queued.

 if the unit is not ready, nothing more to do */

	/*

	 * If the device is in error recovery, wait until it is done.

	 * If the device is offline, then disallow any access to it.

 force recheck CD type */

 A guess, just in case */

 FIXME: need to handle a get_capabilities failure properly ?? */

	/*

	 * Initialize block layer runtime PM stuffs before the

	 * periodic event checking request gets started in add_disk.

 Do the command and wait.. */

 A guess, just in case */

		/*

		 * READ_CAPACITY doesn't return the correct size on

		 * certain UDF media.  If last_written is larger, use

		 * it instead.

		 *

		 * http://bugzilla.kernel.org/show_bug.cgi?id=9668

			/*

			 * HP 4020i CD-Recorder reports 2340 byte sectors

			 * Philips CD-Writers report 2352 byte sectors

			 *

			 * Use 2k sectors for them..

		/*

		 * Add this so that we have the ability to correctly gauge

		 * what the device is capable of.

 allocate transfer buffer */

 eat unit attentions */

 ask for mode page 0x2a */

 failed, drive doesn't have capabilities mode page */

 print some capability bits */

 CD Writer */

 can read rewriteable */

 can read xa/from2 */

 can read audio data */

 caddy drives can't close tray... */

 not a DVD drive */

 can't write DVD-RAM media */

 can't write DVD-R media */

 can't write CD-RW media */

 can't write CD-R media */

 can't eject */

 not a changer */

	/*else    I don't think it can close its tray

	/*

	 * if DVD-RAM, MRW-W or CD-RW, we are randomly writable

/*

 * sr_packet() is the entry point for the generic commands generated

 * by the Uniform CD-ROM layer.

/**

 *	sr_kref_release - Called to free the scsi_cd structure

 *	@kref: pointer to embedded kref

 *

 *	sr_ref_mutex must be held entering this routine.  Because it is

 *	called on last put, you should always use the scsi_cd_get()

 *	scsi_cd_put() helpers which manipulate the semaphore directly

 *	and never do a direct kref_put().

 SPDX-License-Identifier: GPL-2.0-only

/* sun_esp.c: ESP front-end for Sparc SBUS systems.

 *

 * Copyright (C) 2007, 2008 David S. Miller (davem@davemloft.net)

 DVMA chip revisions */

	/* On HME, two reg sets exist, first is DVMA,

	 * second is ESP registers.

 Put the DVMA into a known state. */

 Enable interrupts.  */

		/* This is necessary to avoid having the SCSI channel

		 * engine lock up on us.

	/* Before we try to touch the ESP chip, ESC1 dma can

	 * come up with the reset bit set, so make sure that

	 * is clear first.

 Disable interrupts.  */

****************************************************************************/

 ips.c -- driver for the Adaptec / IBM ServeRAID controller                */

                                                                           */

 Written By: Keith Mitchell, IBM Corporation                               */

             Jack Hammer, Adaptec, Inc.                                    */

             David Jeffery, Adaptec, Inc.                                  */

                                                                           */

 Copyright (C) 2000 IBM Corporation                                        */

 Copyright (C) 2002,2003 Adaptec, Inc.                                     */

                                                                           */

 This program is free software; you can redistribute it and/or modify      */

 it under the terms of the GNU General Public License as published by      */

 the Free Software Foundation; either version 2 of the License, or         */

 (at your option) any later version.                                       */

                                                                           */

 This program is distributed in the hope that it will be useful,           */

 but WITHOUT ANY WARRANTY; without even the implied warranty of            */

 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */

 GNU General Public License for more details.                              */

                                                                           */

 NO WARRANTY                                                               */

 THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR        */

 CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT      */

 LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,      */

 MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is    */

 solely responsible for determining the appropriateness of using and       */

 distributing the Program and assumes all risks associated with its        */

 exercise of rights under this Agreement, including but not limited to     */

 the risks and costs of program errors, damage to or loss of data,         */

 programs or equipment, and unavailability or interruption of operations.  */

                                                                           */

 DISCLAIMER OF LIABILITY                                                   */

 NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY   */

 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL        */

 DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND   */

 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR     */

 TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE    */

 USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED  */

 HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES             */

                                                                           */

 You should have received a copy of the GNU General Public License         */

 along with this program; if not, write to the Free Software               */

 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */

                                                                           */

 Bugs/Comments/Suggestions about this driver should be mailed to:          */

      ipslinux@adaptec.com        	                                     */

                                                                           */

 For system support issues, contact your local IBM Customer support.       */

 Directions to find IBM Customer Support for each country can be found at: */

www.ibm.com/planetwide/                                       */

                                                                           */

****************************************************************************/

****************************************************************************/

 Change Log                                                                */

                                                                           */

 0.99.02  - Breakup commands that are bigger than 8 * the stripe size      */

 0.99.03  - Make interrupt routine handle all completed request on the     */

            adapter not just the first one                                 */

          - Make sure passthru commands get woken up if we run out of      */

            SCBs                                                           */

          - Send all of the commands on the queue at once rather than      */

            one at a time since the card will support it.                  */

 0.99.04  - Fix race condition in the passthru mechanism -- this required  */

            the interface to the utilities to change                       */

          - Fix error recovery code                                        */

 0.99.05  - Fix an oops when we get certain passthru commands              */

 1.00.00  - Initial Public Release                                         */

            Functionally equivalent to 0.99.05                             */

 3.60.00  - Bump max commands to 128 for use with firmware 3.60            */

          - Change version to 3.60 to coincide with release numbering.     */

 3.60.01  - Remove bogus error check in passthru routine                   */

 3.60.02  - Make DCDB direction based on lookup table                      */

          - Only allow one DCDB command to a SCSI ID at a time             */

 4.00.00  - Add support for ServeRAID 4                                    */

 4.00.01  - Add support for First Failure Data Capture                     */

 4.00.02  - Fix problem with PT DCDB with no buffer                        */

 4.00.03  - Add alternative passthru interface                             */

          - Add ability to flash BIOS                                      */

 4.00.04  - Rename structures/constants to be prefixed with IPS_           */

 4.00.05  - Remove wish_block from init routine                            */

          - Use linux/spinlock.h instead of asm/spinlock.h for kernels     */

            2.3.18 and later                                               */

          - Sync with other changes from the 2.3 kernels                   */

 4.00.06  - Fix timeout with initial FFDC command                          */

 4.00.06a - Port to 2.4 (trivial) -- Christoph Hellwig <hch@infradead.org> */

 4.10.00  - Add support for ServeRAID 4M/4L                                */

 4.10.13  - Fix for dynamic unload and proc file system                    */

 4.20.03  - Rename version to coincide with new release schedules          */

            Performance fixes                                              */

            Fix truncation of /proc files with cat                         */

            Merge in changes through kernel 2.4.0test1ac21                 */

 4.20.13  - Fix some failure cases / reset code                            */

          - Hook into the reboot_notifier to flush the controller cache    */

 4.50.01  - Fix problem when there is a hole in logical drive numbering    */

 4.70.09  - Use a Common ( Large Buffer ) for Flashing from the JCRM CD    */

          - Add IPSSEND Flash Support                                      */

          - Set Sense Data for Unknown SCSI Command                        */

          - Use Slot Number from NVRAM Page 5                              */

          - Restore caller's DCDB Structure                                */

 4.70.12  - Corrective actions for bad controller ( during initialization )*/

 4.70.13  - Don't Send CDB's if we already know the device is not present  */

          - Don't release HA Lock in ips_next() until SC taken off queue   */

          - Unregister SCSI device in ips_release()                        */

 4.70.15  - Fix Breakup for very large ( non-SG ) requests in ips_done()   */

 4.71.00  - Change all memory allocations to not use GFP_DMA flag          */

            Code Clean-Up for 2.4.x kernel                                 */

 4.72.00  - Allow for a Scatter-Gather Element to exceed MAX_XFER Size     */

 4.72.01  - I/O Mapped Memory release ( so "insmod ips" does not Fail )    */

          - Don't Issue Internal FFDC Command if there are Active Commands */

          - Close Window for getting too many IOCTL's active               */

 4.80.00  - Make ia64 Safe                                                 */

 4.80.04  - Eliminate calls to strtok() if 2.4.x or greater                */

          - Adjustments to Device Queue Depth                              */

 4.80.14  - Take all semaphores off stack                                  */

          - Clean Up New_IOCTL path                                        */

 4.80.20  - Set max_sectors in Scsi_Host structure ( if >= 2.4.7 kernel )  */

          - 5 second delay needed after resetting an i960 adapter          */

 4.80.26  - Clean up potential code problems ( Arjan's recommendations )   */

 4.90.01  - Version Matching for FirmWare, BIOS, and Driver                */

 4.90.05  - Use New PCI Architecture to facilitate Hot Plug Development    */

 4.90.08  - Increase Delays in Flashing ( Trombone Only - 4H )             */

 4.90.08  - Data Corruption if First Scatter Gather Element is > 64K       */

 4.90.11  - Don't actually RESET unless it's physically required           */

          - Remove unused compile options                                  */

 5.00.01  - Sarasota ( 5i ) adapters must always be scanned first          */

          - Get rid on IOCTL_NEW_COMMAND code                              */

          - Add Extended DCDB Commands for Tape Support in 5I              */

 5.10.12  - use pci_dma interfaces, update for 2.5 kernel changes          */

 5.10.15  - remove unused code (sem, macros, etc.)                         */

 5.30.00  - use __devexit_p()                                              */

 6.00.00  - Add 6x Adapters and Battery Flash                              */

 6.10.00  - Remove 1G Addressing Limitations                               */

 6.11.xx  - Get VersionInfo buffer off the stack !              DDTS 60401 */

 6.11.xx  - Make Logical Drive Info structure safe for DMA      DDTS 60639 */

 7.10.18  - Add highmem_io flag in SCSI Templete for 2.4 kernels           */

          - Fix path/name for scsi_hosts.h include for 2.6 kernels         */

          - Fix sort order of 7k                                           */

          - Remove 3 unused "inline" functions                             */

 7.12.xx  - Use STATIC functions wherever possible                        */

          - Clean up deprecated MODULE_PARM calls                          */

 7.12.05  - Remove Version Matching per IBM request                        */

****************************************************************************/

/*

 * Conditional Compilation directives for this driver:

 *

 * IPS_DEBUG            - Turn on debugging info

 *

 * Parameters:

 *

 * debug:<number>       - Set debug level to <number>

 *                        NOTE: only works when IPS_DEBUG compile directive is used.

 *       1              - Normal debug messages

 *       2              - Verbose debug messages

 *       11             - Method trace (non interrupt)

 *       12             - Method trace (includes interrupt)

 *

 * noi2o                - Don't use I2O Queues (ServeRAID 4 only)

 * nommap               - Don't use memory mapped I/O

 * ioctlsize            - Initial size of the IOCTL buffer

/*

 * DRIVER_VER

/*

 * Function prototypes

/*

 * global variables

 Array of host controller structures */

 Array of HA structures */

 Always use Memory Mapped I/O    */

 Always use I2O command delivery */

 Size of the ioctl buffer        */

 Booting from Manager CD         */

 CD Boot - Flash Data Buffer      */

 CD Boot - Flash Data In Use Flag */

 Max Active Cmds for a Lite Adapter */

 This table describes all ServeRAID Adapters */

/*

 * Necessary forward function protoypes

/*

 * Direction table

***************************************************************************/

                                                                          */

 Routine Name: ips_setup                                                  */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   setup parameters to the driver                                         */

                                                                          */

***************************************************************************/

 Don't use strtok() anymore ( if 2.4 Kernel or beyond ) */

 Search for value */

		/*

		 * We now have key/value pairs.

		 * Update the variables

***************************************************************************/

                                                                          */

 Routine Name: ips_detect                                                 */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Detect and initialize the driver                                       */

                                                                          */

 NOTE: this routine is called under the io_request_lock spinlock          */

                                                                          */

***************************************************************************/

***************************************************************************/

   configure the function pointers to use the functions that will work    */

   with the found version of the adapter                                  */

***************************************************************************/

	/*

	 * Setup Functions

 morpheus / marco / sebring */

 copperhead w/MEMIO */

 copperhead */

***************************************************************************/

                                                                          */

 Routine Name: ips_release                                                */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Remove a driver                                                        */

                                                                          */

***************************************************************************/

 flush the cache on the controller */

 send command */

 free extra memory */

 free IRQ */

***************************************************************************/

                                                                          */

 Routine Name: ips_halt                                                   */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Perform cleanup when the system reboots                                */

                                                                          */

***************************************************************************/

 flush the cache on the controller */

 send command */

***************************************************************************/

                                                                          */

 Routine Name: ips_eh_abort                                               */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Abort a command (using the new error code stuff)                       */

 Note: this routine is called under the io_request_lock                   */

***************************************************************************/

 See if the command is on the copp queue */

 Found it */

 See if the command is on the wait queue */

 command not sent yet */

 command must have already been sent */

***************************************************************************/

                                                                          */

 Routine Name: ips_eh_reset                                               */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Reset the controller (with new eh error code)                          */

                                                                          */

 NOTE: this routine is called under the io_request_lock spinlock          */

                                                                          */

***************************************************************************/

 See if the command is on the copp queue */

 Found it */

 See if the command is on the wait queue */

 command not sent yet */

 An explanation for the casual observer:                              */

 Part of the function of a RAID controller is automatic error         */

 detection and recovery.  As such, the only problem that physically   */

 resetting an adapter will ever fix is when, for some reason,         */

 the driver is not successfully communicating with the adapter.       */

 Therefore, we will attempt to flush this adapter.  If that succeeds, */

 then there's no real purpose in a physical reset. This will complete */

 much faster and avoids any problems that might be caused by a        */

 physical reset ( such as having to fail all the outstanding I/O's ). */

 IF Not an IOCTL Requested Reset */

 Attempt the flush command */

 Either we can't communicate with the adapter or it's an IOCTL request */

 from a utility.  A physical reset is needed at this point.            */

 Reset the IOCTL Requested Reset Flag */

	/*

	 * command must have already been sent

	 * reset the controller

 Now fail all of the active commands */

 Now fail all of the pending commands */

 Now fail all of the active commands */

 Now fail all of the pending commands */

 FFDC */

 Now fail all of the active commands */

 Reset DCDB active command bits */

 Reset the number of active IOCTLs */

 NO_IPS_RESET */

***************************************************************************/

                                                                          */

 Routine Name: ips_queue                                                  */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Send a command to the controller                                       */

                                                                          */

 NOTE:                                                                    */

    Linux obtains io_request_lock before calling this function            */

                                                                          */

***************************************************************************/

 Check for command to initiator IDs */

 A Reset IOCTL is only sent by the boot CD in extreme cases.           */

 There can never be any system activity ( network or disk ), but check */

 anyway just as a good practice.                                       */

 This reset request is from an IOCTL */

 allocate space for the scribble */

***************************************************************************/

                                                                          */

 Routine Name: ips_biosparam                                              */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Set bios geometry for the controller                                   */

                                                                          */

***************************************************************************/

 ?!?! host adater info invalid */

 ?!?! Enquiry command failed */

***************************************************************************/

                                                                          */

 Routine Name: ips_slave_configure                                        */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Set queue depths on devices once scan is complete                      */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: do_ipsintr                                                 */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Wrapper for the interrupt handler                                      */

                                                                          */

***************************************************************************/

 interrupt during initialization */

 start the next command */

***************************************************************************/

                                                                          */

 Routine Name: ips_intr_copperhead                                        */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Polling interrupt handler                                              */

                                                                          */

   ASSUMES interrupts are disabled                                        */

                                                                          */

***************************************************************************/

		/*

		 * Unexpected/Shared interrupt

 Spurious Interrupt ? */

		/*

		 * use the callback function to finish things up

		 * NOTE: interrupts are OFF for this

 end while */

***************************************************************************/

                                                                          */

 Routine Name: ips_intr_morpheus                                          */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Polling interrupt handler                                              */

                                                                          */

   ASSUMES interrupts are disabled                                        */

                                                                          */

***************************************************************************/

		/*

		 * Unexpected/Shared interrupt

 No more to process */

		/*

		 * use the callback function to finish things up

		 * NOTE: interrupts are OFF for this

 end while */

***************************************************************************/

                                                                          */

 Routine Name: ips_info                                                   */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Return info about the driver                                           */

                                                                          */

***************************************************************************/

 Find our host structure */

 Find our host structure */

--------------------------------------------------------------------------*/

 Helper Functions                                                         */

--------------------------------------------------------------------------*/

***************************************************************************/

                                                                          */

 Routine Name: ips_is_passthru                                            */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Determine if the specified SCSI command is really a passthru command   */

                                                                          */

***************************************************************************/

 kmap_atomic() ensures addressability of the user buffer.*/

 local_irq_save() protects the KM_IRQ0 address slot.     */

***************************************************************************/

                                                                          */

 Routine Name: ips_alloc_passthru_buffer                                  */

                                                                          */

 Routine Description:                                                     */

   allocate a buffer large enough for the ioctl data if the ioctl buffer  */

   is too small or doesn't exist                                          */

***************************************************************************/

 there is no buffer or it's not big enough, allocate a new one */

 free the old memory */

 use the new memory */

***************************************************************************/

                                                                          */

 Routine Name: ips_make_passthru                                          */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Make a passthru command out of the info in the Scsi block              */

                                                                          */

***************************************************************************/

 wrong size */

		/* allocation failure!  If ha->ioctl_data exists, use it to return

	/*

	 * Some notes about the passthru interface used

	 *

	 * IF the scsi op_code == 0x0d then we assume

	 * that the data came along with/goes with the

	 * packet we received from the sg driver. In this

	 * case the CmdBSize field of the pt structure is

	 * used for the size of the buffer.

 wrong size */

 end switch */

***************************************************************************/

 Routine Name: ips_flash_copperhead                                       */

 Routine Description:                                                     */

   Flash the BIOS/FW on a Copperhead style controller                     */

***************************************************************************/

	/* Trombone is the only copperhead that can do packet flash, but only

 IF it's OK to Use the "CD BOOT" Flash Buffer, then you can     */

 avoid allocating a huge buffer per adapter ( which can fail ). */

***************************************************************************/

 Routine Name: ips_flash_bios                                             */

 Routine Description:                                                     */

   flashes the bios of a copperhead adapter                               */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_fill_scb_sg_single                                     */

                                                                          */

 Routine Description:                                                     */

   Fill in a single scb sg_list element from an address                   */

   return a -1 if a breakup occurred                                      */

***************************************************************************/

***************************************************************************/

 Routine Name: ips_flash_firmware                                         */

 Routine Description:                                                     */

   flashes the firmware of a copperhead adapter                           */

***************************************************************************/

 Save the S/G list pointer so it doesn't get clobbered */

 copy in the CP */

 FIX stuff that might be wrong */

***************************************************************************/

 Routine Name: ips_free_flash_copperhead                                  */

 Routine Description:                                                     */

   release the memory resources used to hold the flash image              */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_usrcmd                                                 */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Process a user command and make it ready to send                       */

                                                                          */

***************************************************************************/

 Save the S/G list pointer so it doesn't get clobbered */

 copy in the CP */

 FIX stuff that might be wrong */

 we don't support DCDB/READ/WRITE Scatter Gather */

 set timeouts */

 assume success */

 success */

***************************************************************************/

                                                                          */

 Routine Name: ips_cleanup_passthru                                       */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Cleanup after a passthru command                                       */

                                                                          */

***************************************************************************/

 Copy data back to the user */

 Copy DCDB Back to Caller's Area */

***************************************************************************/

                                                                          */

 Routine Name: ips_host_info                                              */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   The passthru interface for the driver                                  */

                                                                          */

***************************************************************************/

 For the Next 3 lines Check for Binary 0 at the end and don't include it if it's there. */

 That keeps everything happy for "text" operations on the proc file.                    */

***************************************************************************/

                                                                          */

 Routine Name: ips_identify_controller                                    */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Identify this controller                                               */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_get_bios_version                                       */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Get the BIOS revision number                                           */

                                                                          */

***************************************************************************/

 Memory Mapped I/O */

 test 1st byte */

 25 us */

 25 us */

 Get Major version */

 25 us */

 Get Minor version */

 25 us */

 Get SubMinor version */

 25 us */

 Programmed I/O */

 test 1st byte */

 25 us */

 25 us */

 Get Major version */

 25 us */

 Get Minor version */

 25 us */

 Get SubMinor version */

 25 us */

 Morpheus Family - Send Command to the card */

 issue the command */

 Error occurred */

 Offset 0x1ff after the header (0xc0) */

 Offset 0x1fe after the header (0xc0) */

 Offset 0x1fd after the header (0xc0) */

***************************************************************************/

                                                                          */

 Routine Name: ips_hainit                                                 */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Initialize the controller                                              */

                                                                          */

 NOTE: Assumes to be called from with a lock                              */

                                                                          */

***************************************************************************/

 Send FFDC */

 end if */

 Identify this controller */

 write nvram user page 5 */

 If there are Logical Drives and a Reset Occurred, then an EraseStripeLock is Needed */

 set limits on SID, LUN, BUS */

 setup max concurrent commands */

 Use the new method */

 use the old method */

 Limit the Active Commands on a Lite Adapter */

 set controller IDs */

***************************************************************************/

                                                                          */

 Routine Name: ips_next                                                   */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Take the next command off the queue and send it to the controller      */

                                                                          */

***************************************************************************/

	/*

	 * Block access to the queue function so

	 * this command won't time out

	/*

	 * Send passthru commands

	 * These have priority over normal I/O

	 * but shouldn't affect performance too much

	 * since we limit the number that can be active

	 * on the card at any one time

 end case */

 end case */

	/*

	 * Send "Normal" I/O commands

 Unlock HA after command is taken off queue */

 copy in the CDB */

 Allow a WRITE BUFFER Command to Have no Data */

 This is Used by Tape Flash Utilites          */

 end case */

 end while */

***************************************************************************/

                                                                          */

 Routine Name: ips_putq_scb_head                                          */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Add an item to the head of the queue                                   */

                                                                          */

 ASSUMED to be called from within the HA lock                             */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_removeq_scb_head                                       */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Remove the head of the queue                                           */

                                                                          */

 ASSUMED to be called from within the HA lock                             */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_removeq_scb                                            */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Remove an item from a queue                                            */

                                                                          */

 ASSUMED to be called from within the HA lock                             */

                                                                          */

***************************************************************************/

 found a match */

***************************************************************************/

                                                                          */

 Routine Name: ips_putq_wait_tail                                         */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Add an item to the tail of the queue                                   */

                                                                          */

 ASSUMED to be called from within the HA lock                             */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_removeq_wait_head                                      */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Remove the head of the queue                                           */

                                                                          */

 ASSUMED to be called from within the HA lock                             */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_removeq_wait                                           */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Remove an item from a queue                                            */

                                                                          */

 ASSUMED to be called from within the HA lock                             */

                                                                          */

***************************************************************************/

 found a match */

***************************************************************************/

                                                                          */

 Routine Name: ips_putq_copp_tail                                         */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Add an item to the tail of the queue                                   */

                                                                          */

 ASSUMED to be called from within the HA lock                             */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_removeq_copp_head                                      */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Remove the head of the queue                                           */

                                                                          */

 ASSUMED to be called from within the HA lock                             */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_removeq_copp                                           */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Remove an item from a queue                                            */

                                                                          */

 ASSUMED to be called from within the HA lock                             */

                                                                          */

***************************************************************************/

 found a match */

***************************************************************************/

                                                                          */

 Routine Name: ipsintr_blocking                                           */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Finalize an interrupt for internal commands                            */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ipsintr_done                                               */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Finalize an interrupt for non-internal commands                        */

                                                                          */

***************************************************************************/

 unexpected interrupt */

***************************************************************************/

                                                                          */

 Routine Name: ips_done                                                   */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Do housekeeping on completed commands                                  */

  ASSUMED to be called form within the request lock                       */

***************************************************************************/

		/*

		 * Check to see if this command had too much

		 * data and had to be broke up.  If so, queue

		 * the rest of the data and continue.

 we had a data breakup */

 Spin forward to last dma chunk */

 Take care of possible partial on last chunk */

 end case */

 end if passthru */

***************************************************************************/

                                                                          */

 Routine Name: ips_map_status                                             */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Map Controller Error codes to Linux Error Codes                        */

                                                                          */

***************************************************************************/

 default driver error */

 Underrun - set default to no error */

 Restrict access to physical DASD */

 don't fail recovered errors */

 check condition */

 end switch */

 end switch */

***************************************************************************/

                                                                          */

 Routine Name: ips_send_wait                                              */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Send a command to the controller and wait for it to return             */

                                                                          */

   The FFDC Time Stamp use this function for the callback, but doesn't    */

   actually need to wait.                                                 */

***************************************************************************/

 Won't be Waiting if this is a Time Stamp */

 Don't Wait around if this is a Time Stamp */

***************************************************************************/

                                                                          */

 Routine Name: ips_scmd_buf_write                                         */

                                                                          */

 Routine Description:                                                     */

  Write data to struct scsi_cmnd request_buffer at proper offsets	    */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_scmd_buf_read                                          */

                                                                          */

 Routine Description:                                                     */

  Copy data from a struct scsi_cmnd to a new, linear buffer		    */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_send_cmd                                               */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Map SCSI commands to ServeRAID commands for logical drives             */

                                                                          */

***************************************************************************/

 internal command */

 Controller commands can't be issued */

 to real devices -- fail them        */

 command to logical bus -- interpret */

				/*

				 * Either we have a TUR

				 * or we have a SCSI inquiry

				/*

				 * This is a null condition

				 * we don't have to do anything

				 * so just return

 Set the Return Info to appear like the Command was */

 attempted, a Check Condition occurred, and Sense   */

 Data indicating an Invalid CDB OpCode is returned. */

 Error Code               */

 Sense Key 5 Illegal Req. */

 Additional Sense Length  */

 ASC = Invalid OpCode     */

 ASCQ                     */

 Indicate Check Condition */

 end switch */

 end if */

 setup DCDB */

 If we already know the Device is Not there, no need to attempt a Command   */

 This also protects an NT FailOver Controller from getting CDB's sent to it */

 If NEW Tape DCDB is Supported */

 Use Same Data Area as Old DCDB Struct */

 Always Turn OFF 64K Size Flag */

 TimeOut is 10 Seconds */

 TimeOut is 60 Seconds */

 TimeOut is 20 Minutes */

 TimeOut is 10 Seconds */

 TimeOut is 60 Seconds */

 TimeOut is 20 Minutes */

***************************************************************************/

                                                                          */

 Routine Name: ips_chk_status                                             */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Check the status of commands to logical drives                         */

   Assumed to be called with the HA lock                                  */

***************************************************************************/

 Remove the item from the active queue */

 internal commands are handled in do_ipsintr */

 passthru - just returns the raw result */

 end switch */

 bus == 0 */

 restrict access to physical drives */

 else */

 recovered error / success */

 else */

***************************************************************************/

                                                                          */

 Routine Name: ips_online                                                 */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Determine if a logical drive is online                                 */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_inquiry                                                */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Simulate an inquiry command to a logical drive                         */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_rdcap                                                  */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Simulate a read capacity command to a logical drive                    */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_msense                                                 */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Simulate a mode sense command to a logical drive                       */

                                                                          */

***************************************************************************/

 page 3 */

 everything else is left set to 0 */

 end switch */

***************************************************************************/

                                                                          */

 Routine Name: ips_reqsen                                                 */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Simulate a request sense command to a logical drive                    */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_free                                                   */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Free any allocated space for this controller                           */

                                                                          */

***************************************************************************/

 free memory mapped (if applicable) */

***************************************************************************/

                                                                          */

 Routine Name: ips_deallocatescbs                                         */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Free the command blocks                                                */

                                                                          */

***************************************************************************/

 end if */

***************************************************************************/

                                                                          */

 Routine Name: ips_allocatescbs                                           */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Allocate the command blocks                                            */

                                                                          */

***************************************************************************/

 Allocate memory for the SCBs */

 set up S/G list */

 add to the free list */

 success */

***************************************************************************/

                                                                          */

 Routine Name: ips_init_scb                                               */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Initialize a CCB to default values                                     */

                                                                          */

***************************************************************************/

 zero fill */

 Initialize dummy command bucket */

 set bus address of scb */

 Neptune Fix */

***************************************************************************/

                                                                          */

 Routine Name: ips_get_scb                                                */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Initialize a CCB to default values                                     */

                                                                          */

 ASSUMED to be called from within a lock                                 */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_free_scb                                               */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Return an unused CCB back to the free list                             */

                                                                          */

 ASSUMED to be called from within a lock                                  */

                                                                          */

***************************************************************************/

 check to make sure this is not our "special" scb */

***************************************************************************/

                                                                          */

 Routine Name: ips_isinit_copperhead                                      */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Is controller initialized ?                                            */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_isinit_copperhead_memio                                */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Is controller initialized ?                                            */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_isinit_morpheus                                        */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Is controller initialized ?                                            */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_flush_and_reset                                        */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Perform cleanup ( FLUSH and RESET ) when the adapter is in an unknown  */

   state ( was trying to INIT and an interrupt was already pending ) ...  */

                                                                          */

***************************************************************************/

 Create a usuable SCB */

 Use an ID that would otherwise not exist */

 Send the Flush Command */

 Max Wait time is 60 seconds */

 This may look evil, but it's only done during extremely rare start-up conditions ! */

 Now RESET and INIT the adapter */

***************************************************************************/

                                                                          */

 Routine Name: ips_poll_for_flush_complete                                */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Poll for the Flush Command issued by ips_flush_and_reset() to complete */

   All other responses are just taken off the queue and ignored           */

                                                                          */

***************************************************************************/

 If No Interrupt to process */

 Success is when we see the Flush Command ID */

***************************************************************************/

                                                                          */

 Routine Name: ips_enable_int_copperhead                                  */

                                                                          */

 Routine Description:                                                     */

   Turn on interrupts                                                     */

                                                                          */

***************************************************************************/

Ensure PCI Posting Completes*/

***************************************************************************/

                                                                          */

 Routine Name: ips_enable_int_copperhead_memio                            */

                                                                          */

 Routine Description:                                                     */

   Turn on interrupts                                                     */

                                                                          */

***************************************************************************/

Ensure PCI Posting Completes*/

***************************************************************************/

                                                                          */

 Routine Name: ips_enable_int_morpheus                                    */

                                                                          */

 Routine Description:                                                     */

   Turn on interrupts                                                     */

                                                                          */

***************************************************************************/

Ensure PCI Posting Completes*/

***************************************************************************/

                                                                          */

 Routine Name: ips_init_copperhead                                        */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Initialize a copperhead controller                                     */

                                                                          */

***************************************************************************/

 Delay for 1 Second */

 error occurred */

 Delay for 1 Second */

 error occurred */

 Delay for 1 Second */

 reset failed */

 setup CCCR */

 Enable busmastering */

 fix for anaconda64 */

 Enable interrupts */

***************************************************************************/

                                                                          */

 Routine Name: ips_init_copperhead_memio                                  */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Initialize a copperhead controller with memory mapped I/O              */

                                                                          */

***************************************************************************/

 Delay for 1 Second */

 error occurred */

 Delay for 1 Second */

 error occurred */

 Delay for 1 Second */

 error occurred */

 setup CCCR */

 Enable busmastering */

 fix for anaconda64 */

 Enable interrupts */

 if we get here then everything went OK */

***************************************************************************/

                                                                          */

 Routine Name: ips_init_morpheus                                          */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Initialize a morpheus controller                                       */

                                                                          */

***************************************************************************/

 Wait up to 45 secs for Post */

 Delay for 1 Second */

 error occurred */

 If Flashing the Battery PIC         */

 Clear the interrupt bit */

    Wait Up to 2 Min. for Completion */

 Delay for 1 Second */

 Clear the interrupt bit */

 Wait up to 240 secs for config bytes */

 Delay for 1 Second */

 error occurred */

 Clear interrupt bit */

 Turn on the interrupts */

 if we get here then everything went OK */

 Since we did a RESET, an EraseStripeLock may be needed */

***************************************************************************/

                                                                          */

 Routine Name: ips_reset_copperhead                                       */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Reset the controller                                                   */

                                                                          */

***************************************************************************/

 Delay for 1 Second */

 Delay for 1 Second */

***************************************************************************/

                                                                          */

 Routine Name: ips_reset_copperhead_memio                                 */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Reset the controller                                                   */

                                                                          */

***************************************************************************/

 Delay for 1 Second */

 Delay for 1 Second */

***************************************************************************/

                                                                          */

 Routine Name: ips_reset_morpheus                                         */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Reset the controller                                                   */

                                                                          */

***************************************************************************/

 Delay for 5 Seconds */

 Do a PCI config read to wait for adapter */

***************************************************************************/

                                                                          */

 Routine Name: ips_statinit                                               */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Initialize the status queues on the controller                         */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_statinit_memio                                         */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Initialize the status queues on the controller                         */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_statupd_copperhead                                     */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Remove an element from the status queue                                */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_statupd_copperhead_memio                               */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Remove an element from the status queue                                */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_statupd_morpheus                                       */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Remove an element from the status queue                                */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_issue_copperhead                                       */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Send a command down to the controller                                  */

                                                                          */

***************************************************************************/

 end if */

 end while */

***************************************************************************/

                                                                          */

 Routine Name: ips_issue_copperhead_memio                                 */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Send a command down to the controller                                  */

                                                                          */

***************************************************************************/

 end if */

 end while */

***************************************************************************/

                                                                          */

 Routine Name: ips_issue_i2o                                              */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Send a command down to the controller                                  */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_issue_i2o_memio                                        */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Send a command down to the controller                                  */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_isintr_copperhead                                      */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Test to see if an interrupt is for us                                  */

                                                                          */

***************************************************************************/

 ?!?! Nothing really there */

 status queue overflow or GHI */

 just clear the interrupt */

***************************************************************************/

                                                                          */

 Routine Name: ips_isintr_copperhead_memio                                */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Test to see if an interrupt is for us                                  */

                                                                          */

***************************************************************************/

 ?!?! Nothing really there */

 status queue overflow or GHI */

 just clear the interrupt */

***************************************************************************/

                                                                          */

 Routine Name: ips_isintr_morpheus                                        */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Test to see if an interrupt is for us                                  */

                                                                          */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_wait                                                   */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Wait for a command to complete                                         */

                                                                          */

***************************************************************************/

 convert seconds */

				/*

				 * controller generated an interrupt to

				 * acknowledge completion of the command

				 * and ips_intr() has serviced the interrupt.

			/*

			 * NOTE: we already have the io_request_lock so

			 * even if we get an interrupt it won't get serviced

			 * until after we finish.

 This looks like a very evil loop, but it only does this during start-up */

***************************************************************************/

                                                                          */

 Routine Name: ips_write_driver_status                                    */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Write OS/Driver version to Page 5 of the nvram on the controller       */

                                                                          */

***************************************************************************/

 check to make sure the page has a valid */

 signature */

 change values (as needed) */

 Indicate the Driver Does Not Support Versioning */

 now update the page */

 IF NVRAM Page 5 is OK, Use it for Slot Number Info Because Linux Doesn't Do Slots */

***************************************************************************/

                                                                          */

 Routine Name: ips_read_adapter_status                                    */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Do an Inquiry command to the adapter                                   */

                                                                          */

***************************************************************************/

 send command */

***************************************************************************/

                                                                          */

 Routine Name: ips_read_subsystem_parameters                              */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Read subsystem parameters from the adapter                             */

                                                                          */

***************************************************************************/

 send command */

***************************************************************************/

                                                                          */

 Routine Name: ips_read_config                                            */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Read the configuration on the adapter                                  */

                                                                          */

***************************************************************************/

 set defaults for initiator IDs */

 send command */

 reset initiator IDs */

 Allow Completed with Errors, so JCRM can access the Adapter to fix the problems */

***************************************************************************/

                                                                          */

 Routine Name: ips_readwrite_page5                                        */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Read nvram page 5 from the adapter                                     */

                                                                          */

***************************************************************************/

 issue the command */

***************************************************************************/

                                                                          */

 Routine Name: ips_clear_adapter                                          */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   Clear the stripe lock tables                                           */

                                                                          */

***************************************************************************/

 issue command */

 send unlock stripe command */

 issue command */

***************************************************************************/

                                                                          */

 Routine Name: ips_ffdc_reset                                             */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   FFDC: write reset info                                                 */

                                                                          */

***************************************************************************/

 convert time to what the card wants */

 issue command */

***************************************************************************/

                                                                          */

 Routine Name: ips_ffdc_time                                              */

                                                                          */

 Routine Description:                                                     */

                                                                          */

   FFDC: write time info                                                  */

                                                                          */

***************************************************************************/

 convert time to what the card wants */

 issue command */

***************************************************************************/

                                                                          */

 Routine Name: ips_fix_ffdc_time                                          */

                                                                          */

 Routine Description:                                                     */

   Adjust time_t to what the card wants                                   */

                                                                          */

***************************************************************************/

/****************************************************************************

 * BIOS Flash Routines                                                      *

***************************************************************************/

                                                                          */

 Routine Name: ips_erase_bios                                             */

                                                                          */

 Routine Description:                                                     */

   Erase the BIOS on the adapter                                          */

                                                                          */

***************************************************************************/

 Clear the status register */

 25 us */

 25 us */

 Erase Setup */

 25 us */

 Erase Confirm */

 25 us */

 Erase Status */

 25 us */

 80 seconds */

 25 us */

 check for timeout */

 timeout */

 try to suspend the erase */

 25 us */

 wait for 10 seconds */

 25 us */

 check for valid VPP */

 VPP failure */

 check for successful flash */

 sequence error */

 Otherwise, we were successful */

 clear status */

 25 us */

 enable reads */

 25 us */

***************************************************************************/

                                                                          */

 Routine Name: ips_erase_bios_memio                                       */

                                                                          */

 Routine Description:                                                     */

   Erase the BIOS on the adapter                                          */

                                                                          */

***************************************************************************/

 Clear the status register */

 25 us */

 25 us */

 Erase Setup */

 25 us */

 Erase Confirm */

 25 us */

 Erase Status */

 25 us */

 80 seconds */

 25 us */

 check for timeout */

 timeout */

 try to suspend the erase */

 25 us */

 wait for 10 seconds */

 25 us */

 check for valid VPP */

 VPP failure */

 check for successful flash */

 sequence error */

 Otherwise, we were successful */

 clear status */

 25 us */

 enable reads */

 25 us */

***************************************************************************/

                                                                          */

 Routine Name: ips_program_bios                                           */

                                                                          */

 Routine Description:                                                     */

   Program the BIOS on the adapter                                        */

                                                                          */

***************************************************************************/

 write a byte */

 25 us */

 25 us */

 25 us */

 wait up to one second */

 25 us */

 timeout error */

 25 us */

 25 us */

 check the status */

 programming error */

 25 us */

 25 us */

 end for */

 Enable reading */

 25 us */

 25 us */

***************************************************************************/

                                                                          */

 Routine Name: ips_program_bios_memio                                     */

                                                                          */

 Routine Description:                                                     */

   Program the BIOS on the adapter                                        */

                                                                          */

***************************************************************************/

 write a byte */

 25 us */

 25 us */

 25 us */

 wait up to one second */

 25 us */

 timeout error */

 25 us */

 25 us */

 check the status */

 programming error */

 25 us */

 25 us */

 end for */

 Enable reading */

 25 us */

 25 us */

***************************************************************************/

                                                                          */

 Routine Name: ips_verify_bios                                            */

                                                                          */

 Routine Description:                                                     */

   Verify the BIOS on the adapter                                         */

                                                                          */

***************************************************************************/

 test 1st byte */

 25 us */

 25 us */

 25 us */

 failure */

 success */

***************************************************************************/

                                                                          */

 Routine Name: ips_verify_bios_memio                                      */

                                                                          */

 Routine Description:                                                     */

   Verify the BIOS on the adapter                                         */

                                                                          */

***************************************************************************/

 test 1st byte */

 25 us */

 25 us */

 25 us */

 failure */

 success */

***************************************************************************/

                                                                          */

 Routine Name: ips_abort_init                                             */

                                                                          */

 Routine Description:                                                     */

   cleanup routine for a failed adapter initialization                    */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_shift_controllers                                      */

                                                                          */

 Routine Description:                                                     */

   helper function for ordering adapters                                  */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_order_controllers                                      */

                                                                          */

 Routine Description:                                                     */

   place controllers is the "proper" boot order                           */

***************************************************************************/

 if adapter_order[0], then ordering is complete */

 old bios, use older ordering */

 if there were no 5I cards, then don't do any extra ordering */

***************************************************************************/

                                                                          */

 Routine Name: ips_register_scsi                                          */

                                                                          */

 Routine Description:                                                     */

   perform any registration and setup with the scsi layer                 */

***************************************************************************/

 Install the interrupt handler with the new ha */

 Store away needed values for later use */

---------------------------------------------------------------------------*/

   Routine Name: ips_remove_device                                         */

                                                                           */

   Routine Description:                                                    */

     Remove one Adapter ( Hot Plugging )                                   */

---------------------------------------------------------------------------*/

***************************************************************************/

                                                                          */

 Routine Name: ips_module_init                                            */

                                                                          */

 Routine Description:                                                     */

   function called on module load                                         */

***************************************************************************/

***************************************************************************/

                                                                          */

 Routine Name: ips_module_exit                                            */

                                                                          */

 Routine Description:                                                     */

   function called on module unload                                       */

***************************************************************************/

---------------------------------------------------------------------------*/

   Routine Name: ips_insert_device                                         */

                                                                           */

   Routine Description:                                                    */

     Add One Adapter ( Hot Plug )                                          */

                                                                           */

   Return Value:                                                           */

     0 if Successful, else non-zero                                        */

---------------------------------------------------------------------------*/

---------------------------------------------------------------------------*/

   Routine Name: ips_init_phase1                                           */

                                                                           */

   Routine Description:                                                    */

     Adapter Initialization                                                */

                                                                           */

   Return Value:                                                           */

     0 if Successful, else non-zero                                        */

---------------------------------------------------------------------------*/

 Init MEM/IO addresses to 0 */

 setup memory mapped area (if applicable) */

 found a controller */

 Store info in HA structure */

	/*

	 * Set the pci_dev's dma_mask.  Not all adapters support 64bit

	 * addressing so don't enable it if the adapter can't support

	 * it!  Also, don't use 64bit addressing if dma addresses

	 * are guaranteed to be < 4G.

	/* the ioctl buffer is now used during adapter initialization, so its

	/*

	 * Setup Functions

 If Morpheus appears dead, reset it */

	/*

	 * Initialize the card if it isn't already

			/*

			 * Initialization failed

---------------------------------------------------------------------------*/

   Routine Name: ips_init_phase2                                           */

                                                                           */

   Routine Description:                                                    */

     Adapter Initialization Phase 2                                        */

                                                                           */

   Return Value:                                                           */

     0 if Successful, else non-zero                                        */

---------------------------------------------------------------------------*/

 Install the interrupt handler */

	/*

	 * Allocate a temporary SCB for initialization

 Free the temporary SCB */

 allocate CCBs */

 SPDX-License-Identifier: GPL-2.0

/*

 * Linux Driver for Mylex DAC960/AcceleRAID/eXtremeRAID PCI RAID Controllers

 *

 * This driver supports the newer, SCSI-based firmware interface only.

 *

 * Copyright 2017 Hannes Reinecke, SUSE Linux GmbH <hare@suse.com>

 *

 * Based on the original DAC960 driver, which has

 * Copyright 1998-2001 by Leonard N. Zubkoff <lnz@dandelion.com>

 * Portions Copyright 2002 by Mylex (An IBM Business Unit)

/*

 * myrs_reset_cmd - clears critical fields in struct myrs_cmdblk

/*

 * myrs_qcmd - queues Command for DAC960 V2 Series Controllers.

/*

 * myrs_exec_cmd - executes V2 Command and waits for completion.

/*

 * myrs_report_progress - prints progress message

/*

 * myrs_get_ctlr_info - executes a Controller Information IOCTL Command

/*

 * myrs_get_ldev_info - executes a Logical Device Information IOCTL Command

/*

 * myrs_get_pdev_info - executes a "Read Physical Device Information" Command

/*

 * myrs_dev_op - executes a "Device Operation" Command

/*

 * myrs_translate_pdev - translates a Physical Device Channel and

 * TargetID into a Logical Device.

/*

 * myrs_get_event - executes a Get Event Command

/*

 * myrs_get_fwstatus - executes a Get Health Status Command

/*

 * myrs_enable_mmio_mbox - enables the Memory Mailbox Interface

 Temporary dma mapping, used only in the scope of this function */

 These are the base addresses for the command memory mailbox array */

 These are the base addresses for the status memory mailbox array */

 Enable the Memory Mailbox Interface. */

/*

 * myrs_get_config - reads the Configuration Information

 Get data into dma-able area, then copy into permanent location */

 Initialize the Controller Model Name and Full Model Name fields. */

 Initialize the Controller Firmware Version field. */

 Initialize the Controller Channels and Targets. */

	/*

	 * Initialize the Controller Queue Depth, Driver Queue Depth,

	 * Logical Drive Count, Maximum Blocks per Command, Controller

	 * Scatter/Gather Limit, and Driver Scatter/Gather Limit.

	 * The Driver Queue Depth must be at most three less than

	 * the Controller Queue Depth; tag '1' is reserved for

	 * direct commands, and tag '2' for monitoring commands.

/*

 * myrs_log_event - prints a Controller Event message

 Physical Device Events (0x0000 - 0x007F) */

 Logical Device Events (0x0080 - 0x00FF) */

 Fault Management Events (0x0100 - 0x017F) */

 Controller Events (0x0180 - 0x01FF) */

 Controller Internal Processor Events */

/*

 * SCSI sysfs interface functions

/*

 * SCSI midlayer interface

 Enable FUA */

 Illegal request, invalid field in CDB */

 Skip HBA device */

/*

 * RAID template functions

/**

 * myrs_is_raid - return boolean indicating device is raid volume

 * @dev: the device struct object

/**

 * myrs_get_resync - get raid volume resync percent complete

 * @dev: the device struct object

/**

 * myrs_get_state - get raid volume status

 * @dev: the device struct object

/*

 * PCI interface functions

 Initialize the Monitoring Timer. */

 Free the memory mailbox, status, and related structures */

 Map the Controller Register Window. */

 Acquire shared access to the IRQ Channel. */

/*

 * myrs_err_status reports Controller BIOS Messages passed through

 * the Error Status Register when the driver performs the BIOS handshaking.

 * It returns true for fatal errors and false otherwise.

/*

 * Hardware-specific functions

/*

 * DAC960 GEM Series Controllers.

 Barrier to avoid reordering */

 Barrier to force PCI access */

/*

 * DAC960 BA Series Controllers.

 Barrier to avoid reordering */

 Barrier to force PCI access */

/*

 * DAC960 LP Series Controllers.

 Barrier to avoid reordering */

 Barrier to force PCI access */

/*

 * Module functions

 SPDX-License-Identifier: GPL-2.0-only

/* imm.c   --  low level driver for the IOMEGA MatchMaker

 * parallel port SCSI host adapter.

 * 

 * (The IMM is the embedded controller in the ZIP Plus drive.)

 * 

 * My unofficial company acronym list is 21 pages long:

 *      FLA:    Four letter acronym with built in facility for

 *              future expansion to five letters.

 The following #define is to avoid a clash with hosts.c */

 Parport device entry         */

 Actual port address          */

 Hi Base address for ECP-ISA chipset */

 Transfer mode                */

 Current queued command       */

 Polling interrupt stuff       */

 Jiffies at start             */

 Failure flag                 */

 Data phase present           */

 Read data in data phase      */

 Parport sharing busy flag    */

 Device number		*/

/* This is to give the imm driver a way to modify the timings (and other

 * parameters) by writing to the /proc/scsi/imm/0 file.

 * Very simple method really... (Too simple, no error checking :( )

 * Reason: Kernel hackers HATE having to unload and reload modules for

 * testing...

 * Also gives a method to use a script to obtain optimum timings (TODO)

 If we fail a device then we trash status / message bytes */

/*

 * Wait for the high bit to be set.

 * 

 * In principle, this could be tied to an interrupt, but the adapter

 * doesn't appear to be designed to support interrupts.  We spin on

 * the 0x80 ready bit. 

	/*

	 * STR register (LPT base+1) to SCSI mapping:

	 *

	 * STR      imm     imm

	 * ===================================

	 * 0x80     S_REQ   S_REQ

	 * 0x40     !S_BSY  (????)

	 * 0x20     !S_CD   !S_CD

	 * 0x10     !S_IO   !S_IO

	 * 0x08     (????)  !S_BSY

	 *

	 * imm      imm     meaning

	 * ==================================

	 * 0xf0     0xb8    Bit mask

	 * 0xc0     0x88    ZIP wants more data

	 * 0xd0     0x98    ZIP wants to send more data

	 * 0xe0     0xa8    ZIP is expecting SCSI command data

	 * 0xf0     0xb8    end of transfer, ZIP is sending status

 Counter expired - Time out occurred */

 command timed out */

	/*

	 * The following is supposedly the IEEE 1284-1994 negotiate

	 * sequence. I have yet to obtain a copy of the above standard

	 * so this is a bit of a guess...

	 *

	 * A fair chunk of this is based on the Linux parport implementation

	 * of IEEE 1284.

	 *

	 * Return 0 if data available

	 *        1 if no data available

/* 

 * Clear EPP timeout bit. 

/* 

 * Wait for empty ECP fifo (if we are in ECP fifo mode only)

 mode 011 == ECP fifo mode */

 apparently a sane mode */

 Drop STROBE low */

 STROBE high + INIT low */

 apparently a sane mode */

 All went well - we hope! */

	/*

	 * The following is based on documented timing signals

 All went well - we hope! */

	/*

	 * The following is based on documented timing signals

 All went well - we hope! */

	/*

	 * Make sure that:

	 * a) the SCSI bus is BUSY (device still listening)

	 * b) the device is listening

 8 bit output, with a loop */

	/*

	 * Make sure that:

	 * a) the SCSI bus is BUSY (device still listening)

	 * b) the device is sending data

 4 bit input, with a loop */

 8 bit input, with a loop */

	/*

	 * Comments on udelay values refer to the

	 * Command Packet Protocol (CPP) timing diagram.

 1 usec - infinite */

 7 usec - infinite */

 7 usec - infinite */

 7 usec - infinite */

 7 usec - infinite */

 7 usec - infinite */

 7 usec - infinite */

	/*

	 * Values for b are:

	 * 0000 00aa    Assign address aa to current device

	 * 0010 00aa    Select device aa in EPP Winbond mode

	 * 0010 10aa    Select device aa in EPP mode

	 * 0011 xxxx    Deselect all devices

	 * 0110 00aa    Test device aa

	 * 1101 00aa    Select device aa in ECP mode

	 * 1110 00aa    Select device aa in Compatible mode

 1 usec - infinite */

 7 usec - infinite */

 1 usec - infinite */

 7 usec - infinite */

 7 usec - infinite */

	/*

	 * The following table is electrical pin values.

	 * (BSY is inverted at the CTR register)

	 *

	 *       BSY  ACK  POut SEL  Fault

	 * S1    0    X    1    1    1

	 * S2    1    X    0    1    1

	 * S3    L    X    1    1    S

	 *

	 * L => Last device in chain

	 * S => Selected

	 *

	 * Observered values for S1,S2,S3 are:

	 * Disconnect => f8/58/78

	 * Connect    => f8/58/70

 Connected */

 Disconnected */

 No device present */

 Select device 0 in compatible mode */

 Disconnect all devices */

 Select device 0 in EPP mode */

 Select device 0 in compatible mode */

 Disconnect all devices */

	/*

	 * Firstly we want to make sure there is nothing

	 * holding onto the SCSI bus.

	/*

	 * Now assert the SCSI ID (HOST and TARGET) on the data bus

	/*

	 * Deassert SELIN first followed by STROBE

	/*

	 * ACK should drop low while SELIN is deasserted.

	 * FAULT should drop low when the SCSI device latches the bus.

	/*

	 * Place the interface back into a sane state (status mode)

 Delay to allow devices to settle */

 Another delay to allow devices to settle */

 NOTE: IMM uses byte pairs */

/*

 * The bulk flag enables some optimisations in the data transfer loops,

 * it should be true for any command that transfers data in integral

 * numbers of sectors.

 * 

 * The driver appears to remain stable if we speed up the parallel port

 * i/o in this function, but not elsewhere.

	/* Return codes:

	 * -1     Error

	 *  0     Told to schedule

	 *  1     Finished data transfer

	/*

	 * We only get here if the drive is ready to comunicate,

	 * hence no need for a full imm_wait.

	/*

	 * while (device is not ready to send status byte)

	 *     loop;

		/*

		 * If we have been running for more than a full timer tick

		 * then take a rest.

		/*

		 * FAIL if:

		 * a) Drive status is screwy (!ready && !present)

		 * b) Drive is requesting/sending more data than expected

 ERROR_RETURN */

 determine if we should use burst I/O */

 ERROR_RETURN */

 if scatter/gather, advance to the next segment */

				/*

				 * Make sure that we transfer even number of bytes

				 * otherwise it makes imm_byte_out() messy.

 Now check to see if the drive is ready to comunicate */

 If not, drop back down to the scheduler and wait a timer tick */

 FINISH_RETURN */

/*

 * Since the IMM itself doesn't generate interrupts, we use

 * the scheduler's task queue to generate a stream of call-backs and

 * complete the request when the drive is ready.

 Command must of completed hence it is safe to let go... */

	/* First check for any errors that may have occurred

	 * Here we check for internal errors

 Phase 0 - Waiting for parport */

			/*

			 * We waited more than a second

			 * for parport to call us

 wait until imm_wakeup claims parport */

 Phase 1 - Connected */

 Phase 2 - We are now talking to the scsi bus */

 Phase 3 - Ready to accept a command */

 Phase 4 - Setup scatter/gather buffers */

 Phase 5 - Pre-Data transfer stage */

 Spin lock for BUSY */

 Require negotiation for read requests */

 Phase 6 - Data transfer stage */

 Spin lock for BUSY */

 Phase 7 - Post data transfer stage */

 Phase 8 - Read status/message */

 Check for data overrun */

 read status byte */

 Check for optional message byte */

 Finished */

 default return code */

 bus free */

/*

 * Apparently the disk->capacity attribute is off by 1 sector 

 * for all disk drives.  We add the one here, but it should really

 * be done in sd.c.  Even if it gets fixed there, this will still

 * work.

	/*

	 * There is no method for aborting commands since Iomega

	 * have tied the SCSI_MESSAGE line high in the interface

 Do not have access to parport */

 Have not connected to interface */

 Forget the problem */

 SCSI command sent, can not abort */

 Forget the problem */

 device settle delay */

 device settle delay */

	/* This routine looks for a device and then attempts to use EPP

 Attempt to use EPP for Test Unit Ready */

 Select SCSI device */

 Send SCSI command */

 1 Second */

/*

 * imm cannot deal with highmem, so this causes all IO pages for this host

 * to reside in low memory (hence mapped)

/***************************************************************************

 *                   Parallel port probing routines                        *

/*

 * Finds the first available device number that can be alloted to the

 * new imm device and returns the address of the previous node so that

 * we can add to the tail and have a list in the ascending order.

	/* Claim the bus so it remembers what we do to the control

	 * registers. [ CTR and ECP ]

	/* Mode detection works up the chain of speed

	 * This avoids a nasty if-then-else-if-... tree

 Done configuration */

 now the glue ... */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * PS3 BD/DVD/CD-ROM Storage Driver

 *

 * Copyright (C) 2007 Sony Computer Entertainment Inc.

 * Copyright 2007 Sony Corp.

 packet command block           */

 should be 12 for ATAPI 8020    */

 transfer mode                  */

 transfer direction             */

 parameter except command block */

 length above                   */

 memory -> device */

 device -> memory */

	/*

	 * ATAPI SFF8020 devices use MODE_SENSE_10,

	 * so we can prohibit MODE_SENSE_6

 we don't support {READ,WRITE}_6 */

 transfer size is block_size * blocks */

	/*

	 * While we can submit READ/WRITE SCSI commands as ATAPI commands,

	 * it's recommended for various reasons (performance, error handling,

	 * ...) to use lv1_storage_{read,write}() instead

	/*

	 * status = -1 may mean that ATAPI transport completed OK, but

	 * ATAPI command itself resulted CHECK CONDITION

	 * so, upper layer should issue REQUEST_SENSE to check the sense data

 OK, completed */

 SCSI spec says request sense should never get error */

 only sg driver uses this */

 One device/LUN per SCSI bus */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Generic Generic NCR5380 driver

 *

 * Copyright 1993, Drew Eckhardt

 * Visionary Computing

 * (Unix and Linux consulting and custom programming)

 * drew@colorado.edu

 * +1 (303) 440-4894

 *

 * NCR53C400 extensions (c) 1994,1995,1996, Kevin Lentin

 * K.Lentin@cs.monash.edu.au

 *

 * NCR53C400A extensions (c) 1996, Ingmar Baumgart

 * ingmar@gonzo.schwaben.de

 *

 * DTC3181E extensions (c) 1997, Ronald van Cuijlenborg

 * ronald.van.cuijlenborg@tip.nl or nutty@dds.nl

 *

 * Added ISAPNP support for DTC436 adapters,

 * Thomas Sailer, sailer@ife.ee.ethz.ch

 *

 * See Documentation/scsi/g_NCR5380.rst for more info.

 Definitions for the core NCR5380 driver. */

 old-style parameters for compatibility */

	/*

	 * An interrupt is triggered whenever BSY = false, SEL = true

	 * and a bit set in the SELECT_ENABLE_REG is asserted on the

	 * SCSI bus.

	 *

	 * Note that the bus is only driven when the phase control signals

	 * (I/O, C/D, and MSG) match those in the TCR.

/**

 * g_NCR5380_probe_irq - find the IRQ of a NCR5380 or equivalent

 * @instance: SCSI host instance

 *

 * Autoprobe for the IRQ line used by the card by triggering an IRQ

 * and then looking to see what interrupt actually turned up.

/*

 * Configure I/O address of 53C400A or DTC436 by writing magic numbers

 * to ports 0x779 and 0x379.

 53C400A & DTC436 */

 HP C2502 */

 wakeup sequence for the NCR53C400A and DTC3181E */

 Disable the adapter and look for a free io port */

 index found */

 At this point we have our region reserved */

 no IRQ yet */

 NCR5380 - no configuration, just grab */

 MMIO */

 8-bit PDMA by default */

		/*

		 * On NCR53C400 boards, NCR5380 registers are mapped 8 past

		 * the base address.

 16-bit PDMA */

 Check for vacant slot */

 Compatibility with documented NCR5380 kernel parameters */

/* wait_for_53c80_access - wait for 53C80 registers to become accessible

 * @hostdata: scsi host private data

 *

 * The registers within the 53C80 logic block are inaccessible until

 * bit 7 in the 53C400 control status register gets asserted.

 DTC436 chip hangs without this */

/**

 * generic_NCR5380_precv - pseudo DMA receive

 * @hostdata: scsi host private data

 * @dst: buffer to write into

 * @len: transfer size

 *

 * Perform a pseudo DMA mode receive from a 53C400 or equivalent device.

 Ignore End of DMA interrupt for the final buffer */

 53c80 interrupt or transfer timeout. Reset 53c400 logic. */

/**

 * generic_NCR5380_psend - pseudo DMA send

 * @hostdata: scsi host private data

 * @src: buffer to read from

 * @len: transfer size

 *

 * Perform a pseudo DMA mode send to a 53C400 or equivalent device.

 Both 128 B buffers are in use */

 Host buffer is empty, other one is in use */

 53c80 interrupt or transfer timeout. Reset 53c400 logic. */

 53C400 datasheet: non-modulo-128-byte transfers should use PIO */

 Limit PDMA send to 512 B to avoid random corruption on DTC3181E */

 Include the core driver code. */

 defined(CONFIG_PNP) */

 compatibility with old-style parameters */

 SPDX-License-Identifier: GPL-2.0

	/*

	 * fill in all the output members

/*

   3w-xxxx.c -- 3ware Storage Controller device driver for Linux.



   Written By: Adam Radford <aradford@gmail.com>

   Modifications By: Joel Jacobson <linux@3ware.com>

                     Arnaldo Carvalho de Melo <acme@conectiva.com.br>

                     Brad Strand <linux@3ware.com>



   Copyright (C) 1999-2010 3ware Inc.



   Kernel compatibility By:	Andre Hedrick <andre@suse.com>

   Non-Copyright (C) 2000	Andre Hedrick <andre@suse.com>



   Further tiny build fixes and trivial hoovering    Alan Cox



   This program is free software; you can redistribute it and/or modify

   it under the terms of the GNU General Public License as published by

   the Free Software Foundation; version 2 of the License.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   NO WARRANTY

   THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

   CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

   LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

   solely responsible for determining the appropriateness of using and

   distributing the Program and assumes all risks associated with its

   exercise of rights under this Agreement, including but not limited to

   the risks and costs of program errors, damage to or loss of data,

   programs or equipment, and unavailability or interruption of operations.



   DISCLAIMER OF LIABILITY

   NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

   DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

   USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

   HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES



   You should have received a copy of the GNU General Public License

   along with this program; if not, write to the Free Software

   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA



   Bugs/Comments/Suggestions should be mailed to:



   aradford@gmail.com





   History

   -------

   0.1.000 -     Initial release.

   0.4.000 -     Added support for Asynchronous Event Notification through

                 ioctls for 3DM.

   1.0.000 -     Added DPO & FUA bit support for WRITE_10 & WRITE_6 cdb

                 to disable drive write-cache before writes.

   1.1.000 -     Fixed performance bug with DPO & FUA not existing for WRITE_6.

   1.2.000 -     Added support for clean shutdown notification/feature table.

   1.02.00.001 - Added support for full command packet posts through ioctls

                 for 3DM.

                 Bug fix so hot spare drives don't show up.

   1.02.00.002 - Fix bug with tw_setfeature() call that caused oops on some

                 systems.

   08/21/00    - release previously allocated resources on failure at

                 tw_allocate_memory (acme)

   1.02.00.003 - Fix tw_interrupt() to report error to scsi layer when

                 controller status is non-zero.

                 Added handling of request_sense opcode.

		 Fix possible null pointer dereference in

                 tw_reset_device_extension()

   1.02.00.004 - Add support for device id of 3ware 7000 series controllers.

                 Make tw_setfeature() call with interrupts disabled.

                 Register interrupt handler before enabling interrupts.

                 Clear attention interrupt before draining aen queue.

   1.02.00.005 - Allocate bounce buffers and custom queue depth for raid5 for

                 6000 and 5000 series controllers.

                 Reduce polling mdelays causing problems on some systems.

                 Fix use_sg = 1 calculation bug.

                 Check for scsi_register returning NULL.

                 Add aen count to /proc/scsi/3w-xxxx.

                 Remove aen code unit masking in tw_aen_complete().

   1.02.00.006 - Remove unit from printk in tw_scsi_eh_abort(), causing

                 possible oops.

                 Fix possible null pointer dereference in tw_scsi_queue()

                 if done function pointer was invalid.

   1.02.00.007 - Fix possible null pointer dereferences in tw_ioctl().

                 Remove check for invalid done function pointer from

                 tw_scsi_queue().

   1.02.00.008 - Set max sectors per io to TW_MAX_SECTORS in tw_findcards().

                 Add tw_decode_error() for printing readable error messages.

                 Print some useful information on certain aen codes.

                 Add tw_decode_bits() for interpreting status register output.

                 Make scsi_set_pci_device() for kernels >= 2.4.4

                 Fix bug where aen's could be lost before a reset.

                 Re-add spinlocks in tw_scsi_detect().

                 Fix possible null pointer dereference in tw_aen_drain_queue()

                 during initialization.

                 Clear pci parity errors during initialization and during io.

   1.02.00.009 - Remove redundant increment in tw_state_request_start().

                 Add ioctl support for direct ATA command passthru.

                 Add entire aen code string list.

   1.02.00.010 - Cleanup queueing code, fix jbod thoughput.

                 Fix get_param for specific units.

   1.02.00.011 - Fix bug in tw_aen_complete() where aen's could be lost.

                 Fix tw_aen_drain_queue() to display useful info at init.

                 Set tw_host->max_id for 12 port cards.

                 Add ioctl support for raw command packet post from userspace

                 with sglist fragments (parameter and io).

   1.02.00.012 - Fix read capacity to under report by 1 sector to fix get

                 last sector ioctl.

   1.02.00.013 - Fix bug where more AEN codes weren't coming out during

                 driver initialization.

                 Improved handling of PCI aborts.

   1.02.00.014 - Fix bug in tw_findcards() where AEN code could be lost.

                 Increase timeout in tw_aen_drain_queue() to 30 seconds.

   1.02.00.015 - Re-write raw command post with data ioctl method.

                 Remove raid5 bounce buffers for raid5 for 6XXX for kernel 2.5

                 Add tw_map/unmap_scsi_sg/single_data() for kernel 2.5

                 Replace io_request_lock with host_lock for kernel 2.5

                 Set max_cmd_len to 16 for 3dm for kernel 2.5

   1.02.00.016 - Set host->max_sectors back up to 256.

   1.02.00.017 - Modified pci parity error handling/clearing from config space

                 during initialization.

   1.02.00.018 - Better handling of request sense opcode and sense information

                 for failed commands.  Add tw_decode_sense().

                 Replace all mdelay()'s with scsi_sleep().

   1.02.00.019 - Revert mdelay's and scsi_sleep's, this caused problems on

                 some SMP systems.

   1.02.00.020 - Add pci_set_dma_mask(), rewrite kmalloc()/virt_to_bus() to

                 pci_alloc/free_consistent().

                 Better alignment checking in tw_allocate_memory().

                 Cleanup tw_initialize_device_extension().

   1.02.00.021 - Bump cmd_per_lun in SHT to 255 for better jbod performance.

                 Improve handling of errors in tw_interrupt().

                 Add handling/clearing of controller queue error.

                 Empty stale responses before draining aen queue.

                 Fix tw_scsi_eh_abort() to not reset on every io abort.

                 Set can_queue in SHT to 255 to prevent hang from AEN.

   1.02.00.022 - Fix possible null pointer dereference in tw_scsi_release().

   1.02.00.023 - Fix bug in tw_aen_drain_queue() where unit # was always zero.

   1.02.00.024 - Add severity levels to AEN strings.

   1.02.00.025 - Fix command interrupt spurious error messages.

                 Fix bug in raw command post with data ioctl method.

                 Fix bug where rollcall sometimes failed with cable errors.

                 Print unit # on all command timeouts.

   1.02.00.026 - Fix possible infinite retry bug with power glitch induced

                 drive timeouts.

                 Cleanup some AEN severity levels.

   1.02.00.027 - Add drive not supported AEN code for SATA controllers.

                 Remove spurious unknown ioctl error message.

   1.02.00.028 - Fix bug where multiple controllers with no units were the

                 same card number.

                 Fix bug where cards were being shut down more than once.

   1.02.00.029 - Add missing pci_free_consistent() in tw_allocate_memory().

                 Replace pci_map_single() with pci_map_page() for highmem.

                 Check for tw_setfeature() failure.

   1.02.00.030 - Make driver 64-bit clean.

   1.02.00.031 - Cleanup polling timeouts/routines in several places.

                 Add support for mode sense opcode.

                 Add support for cache mode page.

                 Add support for synchronize cache opcode.

   1.02.00.032 - Fix small multicard rollcall bug.

                 Make driver stay loaded with no units for hot add/swap.

                 Add support for "twe" character device for ioctls.

                 Clean up request_id queueing code.

                 Fix tw_scsi_queue() spinlocks.

   1.02.00.033 - Fix tw_aen_complete() to not queue 'queue empty' AEN's.

                 Initialize queues correctly when loading with no valid units.

   1.02.00.034 - Fix tw_decode_bits() to handle multiple errors.

                 Add support for user configurable cmd_per_lun.

                 Add support for sht->slave_configure().

   1.02.00.035 - Improve tw_allocate_memory() memory allocation.

                 Fix tw_chrdev_ioctl() to sleep correctly.

   1.02.00.036 - Increase character ioctl timeout to 60 seconds.

   1.02.00.037 - Fix tw_ioctl() to handle all non-data ATA passthru cmds

                 for 'smartmontools' support.

   1.26.00.038 - Roll driver minor version to 26 to denote kernel 2.6.

                 Add support for cmds_per_lun module parameter.

   1.26.00.039 - Fix bug in tw_chrdev_ioctl() polling code.

                 Fix data_buffer_length usage in tw_chrdev_ioctl().

                 Update contact information.

   1.26.02.000 - Convert driver to pci_driver format.

   1.26.02.001 - Increase max ioctl buffer size to 512 sectors.

                 Make tw_scsi_queue() return 0 for 'Unknown scsi opcode'.

                 Fix tw_remove() to free irq handler/unregister_chrdev()

                 before shutting down card.

                 Change to new 'change_queue_depth' api.

                 Fix 'handled=1' ISR usage, remove bogus IRQ check.

   1.26.02.002 - Free irq handler in __tw_shutdown().

                 Turn on RCD bit for caching mode page.

                 Serialize reset code.

   1.26.02.003 - Force 60 second timeout default.

 Globals */

 Module parameters */

 Function prototypes */

 Functions */

 This function will check the status register for unexpected bits */

 End tw_check_bits() */

 This function will print readable messages from status register errors */

 End tw_decode_bits() */

 This function will poll the status register for a flag */

 End tw_poll_status() */

 This function will poll the status register for disappearance of a flag */

 End tw_poll_status_gone() */

 This function will attempt to post a command packet to the board */

 We successfully posted the command packet */

 Couldn't post the command packet, so we do it in the isr */

 End tw_post_command_packet() */

 This function will return valid sense buffer information for failed cmds */

 Attempt to return intelligent sense information */

 Valid bit and 'current errors' */

 Sense key */

 Additional sense length */

 10 bytes */

 Additional sense code */

 Additional sense code qualifier */

 Special case for isr to not over-write result */

 If no table match, error so we get a reset */

 End tw_decode_sense() */

 This function will report controller error status */

 End tw_check_errors() */

 This function will empty the response que */

 End tw_empty_response_que() */

 This function will free a request_id */

 End tw_state_request_finish() */

 This function will assign an available request_id */

 End tw_state_request_start() */

 Show some statistics about the card */

 End tw_show_stats() */

 Create sysfs 'stats' entry */

 Host attributes initializer */

 This function will read the aen queue from the isr */

 Now setup the param */

 AEN table */

 Unit code */

 Now post the command packet */

 Flag internal command */

 End tw_aen_read_queue() */

 This function will complete an aen request from the isr */

 Print some useful info when certain aen codes come out */

 Now queue the code */

 End tw_aen_complete() */

 This function will drain the aen queue after a soft reset */

 Empty response queue */

 Initialize command packet */

 Now setup the param */

 AEN table */

 Unit code */

 Now drain the controller's aen queue */

 Post command packet */

 Now poll for completion */

 Unexpected request id */

 Bad response */

 We know this is a 3w-1x00, and doesn't support aen's */

 Now check the aen */

 Now put the aen on the aen_queue */

 End tw_aen_drain_queue() */

 This function will allocate memory */

 End tw_allocate_memory() */

 This function handles ioctl for the character device */

 Only let one of these through at a time */

 First copy down the buffer length */

 Check size */

 Hardware can only do multiple of 512 byte transfers */

 Now allocate ioctl buf memory */

 Now copy down the entire ioctl */

 See which ioctl we are doing */

 Flag internal command */

 Flag chrdev ioctl */

 Load the sg list */

 Now post the command packet to the controller */

 Now wait for the command to complete */

 We timed out, and didn't get an interrupt */

 Now we need to reset the board */

 Now copy in the command packet response */

 Now complete the io */

 Now copy the response to userspace */

 Now free ioctl buf memory */

 End tw_chrdev_ioctl() */

 This function handles open for the character device */

 NOTE that this function races with remove. */

 End tw_chrdev_open() */

 File operations struct for character device */

 This function will free up device extension resources */

 Free command packet and generic buffer memory */

 End tw_free_device_extension() */

 This function will send an initconnection command to controller */

 Initialize InitConnection command packet */

 Send command packet to the board */

 Poll for completion */

 unexpected request id */

 bad response */

 End tw_initconnection() */

 Set a value in the features table */

 Initialize SetParam command packet */

 Features table */

 Send command packet to the board */

 Poll for completion */

 unexpected request id */

 bad response */

 End tw_setfeature() */

 This function will reset a controller */

 Reset the board */

 Check for controller errors */

 Now the controller is in a good state */

 End tw_reset_sequence() */

 This function will initialize the fields of a device extension */

 Initialize command packet buffers */

 Initialize generic buffer */

 End tw_initialize_device_extension() */

 This function will reset a device extension */

 Abort all requests that are in progress */

 Reset queues and counts */

 End tw_reset_device_extension() */

 This funciton returns unit geometry in cylinders/heads/sectors */

 End tw_scsi_biosparam() */

 This is the new scsi eh reset function */

 Make sure we are not issuing an ioctl or resetting from ioctl */

 Now reset the card and some of the device extension data */

 End tw_scsi_eh_reset() */

 This function handles scsi inquiry commands */

 Initialize command packet */

 Now setup the param */

 unit summary table */

 unitsstatus parameter */

 Now try to post the command packet */

 End tw_scsiop_inquiry() */

 This function is called by the isr to complete an inquiry command */

 Peripheral device type */

 Device type modifier */

 No ansi/iso compliance */

 Additional length */

 Vendor ID */

 End tw_scsiop_inquiry_complete() */

 This function handles scsi mode_sense commands */

 Only page control = 0, page code = 0x8 (cache page) supported */

 Now read firmware cache setting for this unit */

 Setup the command packet */

 Setup the param */

 unit flags */

 Now try to post the command packet */

 End tw_scsiop_mode_sense() */

 This function is called by the isr to complete a mode sense command */

 mode data length */

 default medium type */

 dpo/fua support on */

 no block descriptors */

 caching page */

 page length */

 WCE on, RCD on */

 WCE off, RCD on */

 End tw_scsiop_mode_sense_complete() */

 This function handles scsi read_capacity commands */

 Initialize command packet */

 Now setup the param */

 unitcapacity parameter */

 Now try to post the command to the board */

 End tw_scsiop_read_capacity() */

 This function is called by the isr to complete a readcapacity command */

 Subtract one sector to fix get last sector ioctl */

 Number of LBA's */

 Block size in bytes (512) */

 End tw_scsiop_read_capacity_complete() */

 This function handles scsi read or write commands */

 Initialize command packet */

 Update sector statistic */

 Update SG statistics */

 Now try to post the command to the board */

 End tw_scsiop_read_write() */

 This function will handle the request sense scsi command */

 Immediate fixed format */

 minimum size per SPC: 18 bytes */

 leave all other fields zero, giving effectively NO_SENSE return */

 If we got a request_sense, we probably want a reset, return error */

 End tw_scsiop_request_sense() */

 This function will handle synchronize cache scsi command */

 Send firmware flush command for this unit */

 Setup the command packet */

 Now try to post the command packet */

 End tw_scsiop_synchronize_cache() */

 This function will handle test unit ready scsi command */

 Initialize command packet */

 Now setup the param */

 unit summary table */

 unitsstatus parameter */

 Now try to post the command packet */

 End tw_scsiop_test_unit_ready() */

 This function is called by the isr to complete a testunitready command */

 End tw_scsiop_test_unit_ready_complete() */

 This is the main scsi queue function to handle scsi opcodes */

 If we are resetting due to timed out ioctl, report as busy */

 Queue the command and get a request id */

 Save the scsi command for use by the ISR */

 End tw_scsi_queue() */

 This function is the interrupt service routine */

 Get the host lock for io completions */

 Read the registers */

 Check if this is our interrupt, otherwise bail */

 If we are resetting, bail */

 Check controller for errors */

 Handle host interrupt */

 Handle attention interrupt */

 Handle command interrupt */

 Drain as many pending commands as we can */

 If we get here, we will continue re-posting on the next command interrupt */

 If there are no more pending requests, we mask command interrupt */

 Handle response interrupt */

 Drain the response queue from the board */

 Read response queue register */

 Check for bad response */

 If internal command, don't error, don't fill sense */

 Check for correct state */

 Check for internal command completion */

 Check for chrdev ioctl completion */

 If no error command was a success */

 If error, command failed */

 Ask for a host reset */

 Now complete the io */

 Check for valid status after each drain */

 End tw_interrupt() */

 This function tells the controller to shut down */

 Disable interrupts */

 Free up the IRQ */

 Tell the card we are shutting down */

 Clear all interrupts just before exit */

 End __tw_shutdown() */

 Wrapper for __tw_shutdown */

 End tw_shutdown() */

 This function gets called when a disk is coming online */

 Force 60 second timeout */

 End tw_slave_configure() */

 This function will probe and initialize a card */

 Save values to device extension */

 Request IO regions */

 Save base address */

 Disable interrupts on the card */

 Initialize the card */

 Set host specific parameters */

 Luns and channels aren't supported by adapter */

 Register the card with the kernel SCSI layer */

 Now setup the interrupt handler */

 Re-enable interrupts on the card */

 Finally, scan the host */

 End tw_probe() */

 This function is called to remove a device */

 Unregister character device */

 Shutdown the card */

 Free up the mem region */

 Free up device extension resources */

 End tw_remove() */

 PCI Devices supported by this driver */

 pci_driver initializer */

 This function is called on driver initialization */

 End tw_init() */

 This function is called on driver exit */

 End tw_exit() */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Export the iSCSI boot info to userland via sysfs.

 *

 * Copyright (C) 2010 Red Hat, Inc.  All rights reserved.

 * Copyright (C) 2010 Mike Christie

/*

 * The kobject and attribute structures.

/*

 * The routine called for all sysfs attributes.

 Target attrs */

 Ethernet attrs */

 Initiator attrs */

 iBFT ACPI Table attributes */

		/*

		 * We do not want to free this because the caller

		 * will assume that since the creation call failed

		 * the boot kobj was not setup and the normal release

		 * path is not being run.

 Nothing broke so lets add it to the list. */

/**

 * iscsi_boot_create_target() - create boot target sysfs dir

 * @boot_kset: boot kset

 * @index: the target id

 * @data: driver specific data for target

 * @show: attr show function

 * @is_visible: attr visibility function

 * @release: release function

 *

 * Note: The boot sysfs lib will free the data passed in for the caller

 * when all refs to the target kobject have been released.

/**

 * iscsi_boot_create_initiator() - create boot initiator sysfs dir

 * @boot_kset: boot kset

 * @index: the initiator id

 * @data: driver specific data

 * @show: attr show function

 * @is_visible: attr visibility function

 * @release: release function

 *

 * Note: The boot sysfs lib will free the data passed in for the caller

 * when all refs to the initiator kobject have been released.

/**

 * iscsi_boot_create_ethernet() - create boot ethernet sysfs dir

 * @boot_kset: boot kset

 * @index: the ethernet device id

 * @data: driver specific data

 * @show: attr show function

 * @is_visible: attr visibility function

 * @release: release function

 *

 * Note: The boot sysfs lib will free the data passed in for the caller

 * when all refs to the ethernet kobject have been released.

/**

 * iscsi_boot_create_acpitbl() - create boot acpi table sysfs dir

 * @boot_kset: boot kset

 * @index: not used

 * @data: driver specific data

 * @show: attr show function

 * @is_visible: attr visibility function

 * @release: release function

 *

 * Note: The boot sysfs lib will free the data passed in for the caller

 * when all refs to the acpitbl kobject have been released.

/**

 * iscsi_boot_create_kset() - creates root sysfs tree

 * @set_name: name of root dir

/**

 * iscsi_boot_create_host_kset() - creates root sysfs tree for a scsi host

 * @hostno: host number of scsi host

/**

 * iscsi_boot_destroy_kset() - destroy kset and kobjects under it

 * @boot_kset: boot kset

 *

 * This will remove the kset and kobjects and attrs under it.

/*

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file "COPYING" in the main directory of this archive

 * for more details.

 *

 * Copyright (C) 1996 David S. Miller (davem@davemloft.net)

 * Copyright (C) 1999 Andrew R. Baker (andrewb@uab.edu)

 * Copyright (C) 2001 Florian Lohoff (flo@rfc822.org)

 * Copyright (C) 2003, 07 Ralf Baechle (ralf@linux-mips.org)

 * 

 * (In all truth, Jed Schimmel wrote all this code.)

 align to quadword boundary */

 space for hpc dma descriptors */

		/*

		 * even cntinfo could be up to 16383, without

		 * magic only 8192 works correctly

	/*

	 * To make sure, if we trip an HPC bug, that we transfer every single

	 * byte, we tag on an extra zero length dma descriptor at the end of

	 * the chain.

	/*

	 * wd33c93 shouldn't pass us bogus dma_setups, but it does:-(  The

	 * other wd33c93 drivers deal with it the same way (which isn't that

	 * obvious).  IMHO a better fix would be, not to do these dma setups

	 * in the first place.

 Start up the HPC. */

 First stop the HPC and flush it's FIFO. */

/*

 * Kludge alert - the SCSI code calls the abort and reset method with int

 * arguments not with pointers.  So this is going to blow up beautyfully

 * on 64-bit systems with memory outside the compat address spaces.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * ipr.c -- driver for IBM Power Linux RAID adapters

 *

 * Written By: Brian King <brking@us.ibm.com>, IBM Corporation

 *

 * Copyright (C) 2003, 2004 IBM Corporation

/*

 * Notes:

 *

 * This driver is used to control the following SCSI adapters:

 *

 * IBM iSeries: 5702, 5703, 2780, 5709, 570A, 570B

 *

 * IBM pSeries: PCI-X Dual Channel Ultra 320 SCSI RAID Adapter

 *              PCI-X Dual Channel Ultra 320 SCSI Adapter

 *              PCI-X Dual Channel Ultra 320 SCSI RAID Enablement Card

 *              Embedded SCSI adapter on p615 and p655 systems

 *

 * Supported Hardware Features:

 *	- Ultra 320 SCSI controller

 *	- PCI-X host interface

 *	- Embedded PowerPC RISC Processor and Hardware XOR DMA Engine

 *	- Non-Volatile Write Cache

 *	- Supports attachment of non-RAID disks, tape, and optical devices

 *	- RAID Levels 0, 5, 10

 *	- Hot spare

 *	- Background Parity Checking

 *	- Background Data Scrubbing

 *	- Ability to increase the capacity of an existing RAID 5 disk array

 *		by adding disks

 *

 * Driver Features:

 *	- Tagged command queuing

 *	- Adapter microcode download

 *	- PCI hot plug

 *	- SCSI device hot plug

 *

/*

 *   Global Data

 This table describes the differences between DMA controller chips */

 Gemstone, Citrine, Obsidian, and Obsidian-E */

 Snipe and Scamp */

 CRoC */

  A constant array of IOASCs/URCs/Error Messages */

 Hidive 7 slot */

 Hidive 5 slot */

 Bowtie */

 MartinFenning */

/*

 *  Function Prototypes

/**

 * ipr_trc_hook - Add a trace entry to the driver trace

 * @ipr_cmd:	ipr command struct

 * @type:		trace type

 * @add_data:	additional data

 *

 * Return value:

 * 	none

/**

 * ipr_lock_and_done - Acquire lock and complete command

 * @ipr_cmd:	ipr command struct

 *

 * Return value:

 *	none

/**

 * ipr_reinit_ipr_cmnd - Re-initialize an IPR Cmnd block for reuse

 * @ipr_cmd:	ipr command struct

 *

 * Return value:

 * 	none

/**

 * ipr_init_ipr_cmnd - Initialize an IPR Cmnd block

 * @ipr_cmd:	ipr command struct

 * @fast_done:	fast done function call-back

 *

 * Return value:

 * 	none

/**

 * __ipr_get_free_ipr_cmnd - Get a free IPR Cmnd block

 * @hrrq:	hrr queue

 *

 * Return value:

 * 	pointer to ipr command struct

/**

 * ipr_get_free_ipr_cmnd - Get a free IPR Cmnd block and initialize it

 * @ioa_cfg:	ioa config struct

 *

 * Return value:

 *	pointer to ipr command struct

/**

 * ipr_mask_and_clear_interrupts - Mask all and clear specified interrupts

 * @ioa_cfg:	ioa config struct

 * @clr_ints:     interrupts to clear

 *

 * This function masks all interrupts on the adapter, then clears the

 * interrupts specified in the mask

 *

 * Return value:

 * 	none

 Stop new interrupts */

 Set interrupt mask to stop all new interrupts */

 Clear any pending interrupts */

/**

 * ipr_save_pcix_cmd_reg - Save PCI-X command register

 * @ioa_cfg:	ioa config struct

 *

 * Return value:

 * 	0 on success / -EIO on failure

/**

 * ipr_set_pcix_cmd_reg - Setup PCI-X command register

 * @ioa_cfg:	ioa config struct

 *

 * Return value:

 * 	0 on success / -EIO on failure

/**

 * __ipr_sata_eh_done - done function for aborted SATA commands

 * @ipr_cmd:	ipr command struct

 *

 * This function is invoked for ops generated to SATA

 * devices which are being aborted.

 *

 * Return value:

 * 	none

/**

 * ipr_sata_eh_done - done function for aborted SATA commands

 * @ipr_cmd:	ipr command struct

 *

 * This function is invoked for ops generated to SATA

 * devices which are being aborted.

 *

 * Return value:

 * 	none

/**

 * __ipr_scsi_eh_done - mid-layer done function for aborted ops

 * @ipr_cmd:	ipr command struct

 *

 * This function is invoked by the interrupt handler for

 * ops generated by the SCSI mid-layer which are being aborted.

 *

 * Return value:

 * 	none

/**

 * ipr_scsi_eh_done - mid-layer done function for aborted ops

 * @ipr_cmd:	ipr command struct

 *

 * This function is invoked by the interrupt handler for

 * ops generated by the SCSI mid-layer which are being aborted.

 *

 * Return value:

 * 	none

/**

 * ipr_fail_all_ops - Fails all outstanding ops.

 * @ioa_cfg:	ioa config struct

 *

 * This function fails all outstanding ops.

 *

 * Return value:

 * 	none

/**

 * ipr_send_command -  Send driver initiated requests.

 * @ipr_cmd:		ipr command struct

 *

 * This function sends a command to the adapter using the correct write call.

 * In the case of sis64, calculate the ioarcb size required. Then or in the

 * appropriate bits.

 *

 * Return value:

 * 	none

 The default size is 256 bytes */

		/* If the number of ioadls * size of ioadl > 128 bytes,

/**

 * ipr_do_req -  Send driver initiated requests.

 * @ipr_cmd:		ipr command struct

 * @done:			done function

 * @timeout_func:	timeout function

 * @timeout:		timeout value

 *

 * This function sends the specified command to the adapter with the

 * timeout given. The done function is invoked on command completion.

 *

 * Return value:

 * 	none

/**

 * ipr_internal_cmd_done - Op done function for an internally generated op.

 * @ipr_cmd:	ipr command struct

 *

 * This function is the op done function for an internally generated,

 * blocking op. It simply wakes the sleeping thread.

 *

 * Return value:

 * 	none

/**

 * ipr_init_ioadl - initialize the ioadl for the correct SIS type

 * @ipr_cmd:	ipr command struct

 * @dma_addr:	dma address

 * @len:	transfer length

 * @flags:	ioadl flag value

 *

 * This function initializes an ioadl in the case where there is only a single

 * descriptor.

 *

 * Return value:

 * 	nothing

/**

 * ipr_send_blocking_cmd - Send command and sleep on its completion.

 * @ipr_cmd:	ipr command struct

 * @timeout_func:	function to invoke if command times out

 * @timeout:	timeout

 *

 * Return value:

 * 	none

/**

 * ipr_send_hcam - Send an HCAM to the adapter.

 * @ioa_cfg:	ioa config struct

 * @type:		HCAM type

 * @hostrcb:	hostrcb struct

 *

 * This function will send a Host Controlled Async command to the adapter.

 * If HCAMs are currently not allowed to be issued to the adapter, it will

 * place the hostrcb on the free queue.

 *

 * Return value:

 * 	none

/**

 * ipr_update_ata_class - Update the ata class in the resource entry

 * @res:	resource entry struct

 * @proto:	cfgte device bus protocol value

 *

 * Return value:

 * 	none

/**

 * ipr_init_res_entry - Initialize a resource entry struct.

 * @res:	resource entry struct

 * @cfgtew:	config table entry wrapper struct

 *

 * Return value:

 * 	none

/**

 * ipr_is_same_device - Determine if two devices are the same.

 * @res:	resource entry struct

 * @cfgtew:	config table entry wrapper struct

 *

 * Return value:

 * 	1 if the devices are the same / 0 otherwise

/**

 * __ipr_format_res_path - Format the resource path for printing.

 * @res_path:	resource path

 * @buffer:	buffer

 * @len:	length of buffer provided

 *

 * Return value:

 * 	pointer to buffer

/**

 * ipr_format_res_path - Format the resource path for printing.

 * @ioa_cfg:	ioa config struct

 * @res_path:	resource path

 * @buffer:	buffer

 * @len:	length of buffer provided

 *

 * Return value:

 *	pointer to buffer

/**

 * ipr_update_res_entry - Update the resource entry.

 * @res:	resource entry struct

 * @cfgtew:	config table entry wrapper struct

 *

 * Return value:

 *      none

/**

 * ipr_clear_res_target - Clear the bit in the bit map representing the target

 * 			  for the resource.

 * @res:	resource entry struct

 *

 * Return value:

 *      none

/**

 * ipr_handle_config_change - Handle a config change from the adapter

 * @ioa_cfg:	ioa config struct

 * @hostrcb:	hostrcb

 *

 * Return value:

 * 	none

/**

 * ipr_process_ccn - Op done function for a CCN.

 * @ipr_cmd:	ipr command struct

 *

 * This function is the op done function for a configuration

 * change notification host controlled async from the adapter.

 *

 * Return value:

 * 	none

/**

 * strip_and_pad_whitespace - Strip and pad trailing whitespace.

 * @i:		index into buffer

 * @buf:		string to modify

 *

 * This function will strip all trailing whitespace, pad the end

 * of the string with a single space, and NULL terminate the string.

 *

 * Return value:

 * 	new length of string

/**

 * ipr_log_vpd_compact - Log the passed extended VPD compactly.

 * @prefix:		string to print at start of printk

 * @hostrcb:	hostrcb pointer

 * @vpd:		vendor/product id/sn struct

 *

 * Return value:

 * 	none

/**

 * ipr_log_vpd - Log the passed VPD to the error log.

 * @vpd:		vendor/product id/sn struct

 *

 * Return value:

 * 	none

/**

 * ipr_log_ext_vpd_compact - Log the passed extended VPD compactly.

 * @prefix:		string to print at start of printk

 * @hostrcb:	hostrcb pointer

 * @vpd:		vendor/product id/sn/wwn struct

 *

 * Return value:

 * 	none

/**

 * ipr_log_ext_vpd - Log the passed extended VPD to the error log.

 * @vpd:		vendor/product id/sn/wwn struct

 *

 * Return value:

 * 	none

/**

 * ipr_log_enhanced_cache_error - Log a cache error.

 * @ioa_cfg:	ioa config struct

 * @hostrcb:	hostrcb struct

 *

 * Return value:

 * 	none

/**

 * ipr_log_cache_error - Log a cache error.

 * @ioa_cfg:	ioa config struct

 * @hostrcb:	hostrcb struct

 *

 * Return value:

 * 	none

/**

 * ipr_log_enhanced_config_error - Log a configuration error.

 * @ioa_cfg:	ioa config struct

 * @hostrcb:	hostrcb struct

 *

 * Return value:

 * 	none

/**

 * ipr_log_sis64_config_error - Log a device error.

 * @ioa_cfg:	ioa config struct

 * @hostrcb:	hostrcb struct

 *

 * Return value:

 * 	none

/**

 * ipr_log_config_error - Log a configuration error.

 * @ioa_cfg:	ioa config struct

 * @hostrcb:	hostrcb struct

 *

 * Return value:

 * 	none

/**

 * ipr_log_enhanced_array_error - Log an array configuration error.

 * @ioa_cfg:	ioa config struct

 * @hostrcb:	hostrcb struct

 *

 * Return value:

 * 	none

/**

 * ipr_log_array_error - Log an array configuration error.

 * @ioa_cfg:	ioa config struct

 * @hostrcb:	hostrcb struct

 *

 * Return value:

 * 	none

/**

 * ipr_log_hex_data - Log additional hex IOA error data.

 * @ioa_cfg:	ioa config struct

 * @data:		IOA error data

 * @len:		data length

 *

 * Return value:

 * 	none

/**

 * ipr_log_enhanced_dual_ioa_error - Log an enhanced dual adapter error.

 * @ioa_cfg:	ioa config struct

 * @hostrcb:	hostrcb struct

 *

 * Return value:

 * 	none

/**

 * ipr_log_dual_ioa_error - Log a dual adapter error.

 * @ioa_cfg:	ioa config struct

 * @hostrcb:	hostrcb struct

 *

 * Return value:

 * 	none

/**

 * ipr_log_fabric_path - Log a fabric path error

 * @hostrcb:	hostrcb struct

 * @fabric:		fabric descriptor

 *

 * Return value:

 * 	none

/**

 * ipr_log64_fabric_path - Log a fabric path error

 * @hostrcb:	hostrcb struct

 * @fabric:		fabric descriptor

 *

 * Return value:

 * 	none

/**

 * ipr_log_path_elem - Log a fabric path element.

 * @hostrcb:	hostrcb struct

 * @cfg:		fabric path element struct

 *

 * Return value:

 * 	none

/**

 * ipr_log64_path_elem - Log a fabric path element.

 * @hostrcb:	hostrcb struct

 * @cfg:		fabric path element struct

 *

 * Return value:

 * 	none

/**

 * ipr_log_fabric_error - Log a fabric error.

 * @ioa_cfg:	ioa config struct

 * @hostrcb:	hostrcb struct

 *

 * Return value:

 * 	none

/**

 * ipr_log_sis64_array_error - Log a sis64 array error.

 * @ioa_cfg:	ioa config struct

 * @hostrcb:	hostrcb struct

 *

 * Return value:

 * 	none

/**

 * ipr_log_sis64_fabric_error - Log a sis64 fabric error.

 * @ioa_cfg:	ioa config struct

 * @hostrcb:	hostrcb struct

 *

 * Return value:

 * 	none

/**

 * ipr_log_sis64_service_required_error - Log a sis64 service required error.

 * @ioa_cfg:    ioa config struct

 * @hostrcb:    hostrcb struct

 *

 * Return value:

 *      none

/**

 * ipr_log_generic_error - Log an adapter error.

 * @ioa_cfg:	ioa config struct

 * @hostrcb:	hostrcb struct

 *

 * Return value:

 * 	none

/**

 * ipr_log_sis64_device_error - Log a cache error.

 * @ioa_cfg:	ioa config struct

 * @hostrcb:	hostrcb struct

 *

 * Return value:

 * 	none

/**

 * ipr_get_error - Find the specfied IOASC in the ipr_error_table.

 * @ioasc:	IOASC

 *

 * This function will return the index of into the ipr_error_table

 * for the specified IOASC. If the IOASC is not in the table,

 * 0 will be returned, which points to the entry used for unknown errors.

 *

 * Return value:

 * 	index into the ipr_error_table

/**

 * ipr_handle_log_data - Log an adapter error.

 * @ioa_cfg:	ioa config struct

 * @hostrcb:	hostrcb struct

 *

 * This function logs an adapter error to the system.

 *

 * Return value:

 * 	none

 Tell the midlayer we had a bus reset so it will handle the UA properly */

 Set indication we have logged an error */

/**

 * ipr_process_error - Op done function for an adapter error log.

 * @ipr_cmd:	ipr command struct

 *

 * This function is the op done function for an error log host

 * controlled async from the adapter. It will log the error and

 * send the HCAM back to the adapter.

 *

 * Return value:

 * 	none

/**

 * ipr_timeout -  An internally generated op has timed out.

 * @t: Timer context used to fetch ipr command struct

 *

 * This function blocks host requests and initiates an

 * adapter reset.

 *

 * Return value:

 * 	none

/**

 * ipr_oper_timeout -  Adapter timed out transitioning to operational

 * @t: Timer context used to fetch ipr command struct

 *

 * This function blocks host requests and initiates an

 * adapter reset.

 *

 * Return value:

 * 	none

/**

 * ipr_find_ses_entry - Find matching SES in SES table

 * @res:	resource entry struct of SES

 *

 * Return value:

 * 	pointer to SES table entry / NULL on failure

/**

 * ipr_get_max_scsi_speed - Determine max SCSI speed for a given bus

 * @ioa_cfg:	ioa config struct

 * @bus:		SCSI bus

 * @bus_width:	bus width

 *

 * Return value:

 *	SCSI bus speed in units of 100KHz, 1600 is 160 MHz

 *	For a 2-byte wide SCSI bus, the maximum transfer speed is

 *	twice the maximum transfer rate (e.g. for a wide enabled bus,

 *	max 160MHz = max 320MB/sec).

 Loop through each config table entry in the config table buffer */

/**

 * ipr_wait_iodbg_ack - Wait for an IODEBUG ACK from the IOA

 * @ioa_cfg:		ioa config struct

 * @max_delay:		max delay in micro-seconds to wait

 *

 * Waits for an IODEBUG ACK from the IOA, doing busy looping.

 *

 * Return value:

 * 	0 on success / other on failure

 Read interrupt reg until IOA signals IO Debug Acknowledge */

 udelay cannot be used if delay is more than a few milliseconds */

/**

 * ipr_get_sis64_dump_data_section - Dump IOA memory

 * @ioa_cfg:			ioa config struct

 * @start_addr:			adapter address to dump

 * @dest:			destination kernel buffer

 * @length_in_words:		length to dump in 4 byte words

 *

 * Return value:

 * 	0 on success

/**

 * ipr_get_ldump_data_section - Dump IOA memory

 * @ioa_cfg:			ioa config struct

 * @start_addr:			adapter address to dump

 * @dest:				destination kernel buffer

 * @length_in_words:	length to dump in 4 byte words

 *

 * Return value:

 * 	0 on success / -EIO on failure

 Write IOA interrupt reg starting LDUMP state  */

 Wait for IO debug acknowledge */

 Signal LDUMP interlocked - clear IO debug ack */

 Write Mailbox with starting address */

 Signal address valid - clear IOA Reset alert */

 Wait for IO debug acknowledge */

 Read data from mailbox and increment destination pointer */

 For all but the last word of data, signal data received */

 Signal dump data received - Clear IO debug Ack */

 Signal end of block transfer. Set reset alert then clear IO debug ack */

 Signal dump data received - Clear IO debug Ack */

 Wait for IOA to signal LDUMP exit - IOA reset alert will be cleared */

/**

 * ipr_sdt_copy - Copy Smart Dump Table to kernel buffer

 * @ioa_cfg:		ioa config struct

 * @pci_address:	adapter address

 * @length:			length of data to copy

 *

 * Copy data from PCI adapter to kernel buffer.

 * Note: length MUST be a 4 byte multiple

 * Return value:

 * 	0 on success / other on failure

/**

 * ipr_init_dump_entry_hdr - Initialize a dump entry header.

 * @hdr:	dump entry header struct

 *

 * Return value:

 * 	nothing

/**

 * ipr_dump_ioa_type_data - Fill in the adapter type in the dump.

 * @ioa_cfg:	ioa config struct

 * @driver_dump:	driver dump struct

 *

 * Return value:

 * 	nothing

/**

 * ipr_dump_version_data - Fill in the driver version in the dump.

 * @ioa_cfg:	ioa config struct

 * @driver_dump:	driver dump struct

 *

 * Return value:

 * 	nothing

/**

 * ipr_dump_trace_data - Fill in the IOA trace in the dump.

 * @ioa_cfg:	ioa config struct

 * @driver_dump:	driver dump struct

 *

 * Return value:

 * 	nothing

/**

 * ipr_dump_location_data - Fill in the IOA location in the dump.

 * @ioa_cfg:	ioa config struct

 * @driver_dump:	driver dump struct

 *

 * Return value:

 * 	nothing

/**

 * ipr_get_ioa_dump - Perform a dump of the driver and adapter.

 * @ioa_cfg:	ioa config struct

 * @dump:		dump struct

 *

 * Return value:

 * 	nothing

 Initialize the overall dump header */

 Update dump_header */

 IOA Dump entry */

	/* First entries in sdt are actually a list of dump addresses and

	 lengths to gather the real dump data.  sdt represents the pointer

	 to the ioa generated dump table.  Dump data will be extracted based

 Smart Dump table is ready to use and the first entry is valid */

 Update dump length to the actual data to be copied */

 Copy data from adapter to driver buffers */

 Update dump_header */

/**

 * ipr_release_dump - Free adapter dump memory

 * @kref:	kref struct

 *

 * Return value:

 *	nothing

/**

 * ipr_worker_thread - Worker thread

 * @work:		ioa config struct

 *

 * Called at task level from a work thread. This function takes care

 * of adding and removing device from the mid-layer as configuration

 * changes are detected by the adapter.

 *

 * Return value:

 * 	nothing

/**

 * ipr_read_trace - Dump the adapter trace

 * @filp:		open sysfs file

 * @kobj:		kobject struct

 * @bin_attr:		bin_attribute struct

 * @buf:		buffer

 * @off:		offset

 * @count:		buffer size

 *

 * Return value:

 *	number of bytes printed to buffer

/**

 * ipr_show_fw_version - Show the firmware version

 * @dev:	class device struct

 * @attr:	device attribute (unused)

 * @buf:	buffer

 *

 * Return value:

 *	number of bytes printed to buffer

/**

 * ipr_show_log_level - Show the adapter's error logging level

 * @dev:	class device struct

 * @attr:	device attribute (unused)

 * @buf:	buffer

 *

 * Return value:

 * 	number of bytes printed to buffer

/**

 * ipr_store_log_level - Change the adapter's error logging level

 * @dev:	class device struct

 * @attr:	device attribute (unused)

 * @buf:	buffer

 * @count:	buffer size

 *

 * Return value:

 * 	number of bytes printed to buffer

/**

 * ipr_store_diagnostics - IOA Diagnostics interface

 * @dev:	device struct

 * @attr:	device attribute (unused)

 * @buf:	buffer

 * @count:	buffer size

 *

 * This function will reset the adapter and wait a reasonable

 * amount of time for any errors that the adapter might log.

 *

 * Return value:

 * 	count on success / other on failure

 Wait for a second for any errors to be logged */

/**

 * ipr_show_adapter_state - Show the adapter's state

 * @dev:	device struct

 * @attr:	device attribute (unused)

 * @buf:	buffer

 *

 * Return value:

 * 	number of bytes printed to buffer

/**

 * ipr_store_adapter_state - Change adapter state

 * @dev:	device struct

 * @attr:	device attribute (unused)

 * @buf:	buffer

 * @count:	buffer size

 *

 * This function will change the adapter's state.

 *

 * Return value:

 * 	count on success / other on failure

/**

 * ipr_store_reset_adapter - Reset the adapter

 * @dev:	device struct

 * @attr:	device attribute (unused)

 * @buf:	buffer

 * @count:	buffer size

 *

 * This function will reset the adapter.

 *

 * Return value:

 * 	count on success / other on failure

 /**

 * ipr_show_iopoll_weight - Show ipr polling mode

 * @dev:	class device struct

 * @attr:	device attribute (unused)

 * @buf:	buffer

 *

 * Return value:

 *	number of bytes printed to buffer

/**

 * ipr_store_iopoll_weight - Change the adapter's polling mode

 * @dev:	class device struct

 * @attr:	device attribute (unused)

 * @buf:	buffer

 * @count:	buffer size

 *

 * Return value:

 *	number of bytes printed to buffer

/**

 * ipr_alloc_ucode_buffer - Allocates a microcode download buffer

 * @buf_len:		buffer length

 *

 * Allocates a DMA'able buffer in chunks and assembles a scatter/gather

 * list to use for microcode download

 *

 * Return value:

 * 	pointer to sglist / NULL on failure

 Get the minimum size per scatter/gather element */

 Get the actual size per element */

 Allocate a scatter/gather list for the DMA */

/**

 * ipr_free_ucode_buffer - Frees a microcode download buffer

 * @sglist:		scatter/gather list pointer

 *

 * Free a DMA'able ucode download buffer previously allocated with

 * ipr_alloc_ucode_buffer

 *

 * Return value:

 * 	nothing

/**

 * ipr_copy_ucode_buffer - Copy user buffer to kernel buffer

 * @sglist:		scatter/gather list pointer

 * @buffer:		buffer pointer

 * @len:		buffer length

 *

 * Copy a microcode image from a user buffer into a buffer allocated by

 * ipr_alloc_ucode_buffer

 *

 * Return value:

 * 	0 on success / other on failure

 Determine the actual number of bytes per element */

/**

 * ipr_build_ucode_ioadl64 - Build a microcode download IOADL

 * @ipr_cmd:		ipr command struct

 * @sglist:		scatter/gather list

 *

 * Builds a microcode download IOA data list (IOADL).

 *

/**

 * ipr_build_ucode_ioadl - Build a microcode download IOADL

 * @ipr_cmd:	ipr command struct

 * @sglist:		scatter/gather list

 *

 * Builds a microcode download IOA data list (IOADL).

 *

/**

 * ipr_update_ioa_ucode - Update IOA's microcode

 * @ioa_cfg:	ioa config struct

 * @sglist:		scatter/gather list

 *

 * Initiate an adapter reset to update the IOA's microcode

 *

 * Return value:

 * 	0 on success / -EIO on failure

/**

 * ipr_store_update_fw - Update the firmware on the adapter

 * @dev:	device struct

 * @attr:	device attribute (unused)

 * @buf:	buffer

 * @count:	buffer size

 *

 * This function will update the firmware on the adapter.

 *

 * Return value:

 * 	count on success / other on failure

/**

 * ipr_show_fw_type - Show the adapter's firmware type.

 * @dev:	class device struct

 * @attr:	device attribute (unused)

 * @buf:	buffer

 *

 * Return value:

 *	number of bytes printed to buffer

 Reclaim hostrcb before exit */

/**

 * ipr_read_dump - Dump the adapter

 * @filp:		open sysfs file

 * @kobj:		kobject struct

 * @bin_attr:		bin_attribute struct

 * @buf:		buffer

 * @off:		offset

 * @count:		buffer size

 *

 * Return value:

 *	number of bytes printed to buffer

/**

 * ipr_alloc_dump - Prepare for adapter dump

 * @ioa_cfg:	ioa config struct

 *

 * Return value:

 *	0 on success / other on failure

/**

 * ipr_free_dump - Free adapter dump memory

 * @ioa_cfg:	ioa config struct

 *

 * Return value:

 *	0 on success / other on failure

/**

 * ipr_write_dump - Setup dump state of adapter

 * @filp:		open sysfs file

 * @kobj:		kobject struct

 * @bin_attr:		bin_attribute struct

 * @buf:		buffer

 * @off:		offset

 * @count:		buffer size

 *

 * Return value:

 *	number of bytes printed to buffer

/**

 * ipr_change_queue_depth - Change the device's queue depth

 * @sdev:	scsi device struct

 * @qdepth:	depth to set

 *

 * Return value:

 * 	actual depth set

/**

 * ipr_show_adapter_handle - Show the adapter's resource handle for this device

 * @dev:	device struct

 * @attr:	device attribute structure

 * @buf:	buffer

 *

 * Return value:

 * 	number of bytes printed to buffer

/**

 * ipr_show_resource_path - Show the resource path or the resource address for

 *			    this device.

 * @dev:	device struct

 * @attr:	device attribute structure

 * @buf:	buffer

 *

 * Return value:

 * 	number of bytes printed to buffer

/**

 * ipr_show_device_id - Show the device_id for this device.

 * @dev:	device struct

 * @attr:	device attribute structure

 * @buf:	buffer

 *

 * Return value:

 *	number of bytes printed to buffer

/**

 * ipr_show_resource_type - Show the resource type for this device.

 * @dev:	device struct

 * @attr:	device attribute structure

 * @buf:	buffer

 *

 * Return value:

 *	number of bytes printed to buffer

/**

 * ipr_show_raw_mode - Show the adapter's raw mode

 * @dev:	class device struct

 * @attr:	device attribute (unused)

 * @buf:	buffer

 *

 * Return value:

 * 	number of bytes printed to buffer

/**

 * ipr_store_raw_mode - Change the adapter's raw mode

 * @dev:	class device struct

 * @attr:	device attribute (unused)

 * @buf:	buffer

 * @count:		buffer size

 *

 * Return value:

 * 	number of bytes printed to buffer

/**

 * ipr_biosparam - Return the HSC mapping

 * @sdev:			scsi device struct

 * @block_device:	block device pointer

 * @capacity:		capacity of the device

 * @parm:			Array containing returned HSC values.

 *

 * This function generates the HSC parms that fdisk uses.

 * We want to make sure we return something that places partitions

 * on 4k boundaries for best performance with the IOA.

 *

 * Return value:

 * 	0 on success

 return result */

/**

 * ipr_find_starget - Find target based on bus/target.

 * @starget:	scsi target struct

 *

 * Return value:

 * 	resource entry pointer if found / NULL if not found

/**

 * ipr_target_alloc - Prepare for commands to a SCSI target

 * @starget:	scsi target struct

 *

 * If the device is a SATA device, this function allocates an

 * ATA port with libata, else it does nothing.

 *

 * Return value:

 * 	0 on success / non-0 on failure

/**

 * ipr_target_destroy - Destroy a SCSI target

 * @starget:	scsi target struct

 *

 * If the device was a SATA device, this function frees the libata

 * ATA port, else it does nothing.

 *

/**

 * ipr_find_sdev - Find device based on bus/target/lun.

 * @sdev:	scsi device struct

 *

 * Return value:

 * 	resource entry pointer if found / NULL if not found

/**

 * ipr_slave_destroy - Unconfigure a SCSI device

 * @sdev:	scsi device struct

 *

 * Return value:

 * 	nothing

/**

 * ipr_slave_configure - Configure a SCSI device

 * @sdev:	scsi device struct

 *

 * This function configures the specified scsi device.

 *

 * Return value:

 * 	0 on success

/**

 * ipr_ata_slave_alloc - Prepare for commands to a SATA device

 * @sdev:	scsi device struct

 *

 * This function initializes an ATA port so that future commands

 * sent through queuecommand will work.

 *

 * Return value:

 * 	0 on success

/**

 * ipr_slave_alloc - Prepare for commands to a device.

 * @sdev:	scsi device struct

 *

 * This function saves a pointer to the resource entry

 * in the scsi device struct if the device exists. We

 * can then use this pointer in ipr_queuecommand when

 * handling new commands.

 *

 * Return value:

 * 	0 on success / -ENXIO if device does not exist

/**

 * ipr_match_lun - Match function for specified LUN

 * @ipr_cmd:	ipr command struct

 * @device:		device to match (sdev)

 *

 * Returns:

 *	1 if command matches sdev / 0 if command does not match sdev

/**

 * ipr_cmnd_is_free - Check if a command is free or not

 * @ipr_cmd:	ipr command struct

 *

 * Returns:

 *	true / false

/**

 * ipr_match_res - Match function for specified resource entry

 * @ipr_cmd:	ipr command struct

 * @resource:	resource entry to match

 *

 * Returns:

 *	1 if command matches sdev / 0 if command does not match sdev

/**

 * ipr_wait_for_ops - Wait for matching commands to complete

 * @ioa_cfg:	ioa config struct

 * @device:		device to match (sdev)

 * @match:		match function to use

 *

 * Returns:

 *	SUCCESS / FAILED

	/* If we got hit with a host reset while we were already resetting

/**

 * ipr_device_reset - Reset the device

 * @ioa_cfg:	ioa config struct

 * @res:		resource entry struct

 *

 * This function issues a device reset to the affected device.

 * If the device is a SCSI device, a LUN reset will be sent

 * to the device first. If that does not work, a target reset

 * will be sent. If the device is a SATA device, a PHY reset will

 * be sent.

 *

 * Return value:

 *	0 on success / non-zero on failure

/**

 * ipr_sata_reset - Reset the SATA port

 * @link:	SATA link to reset

 * @classes:	class of the attached device

 * @deadline:	unused

 *

 * This function issues a SATA phy reset to the affected ATA link.

 *

 * Return value:

 *	0 on success / non-zero on failure

/**

 * __ipr_eh_dev_reset - Reset the device

 * @scsi_cmd:	scsi command struct

 *

 * This function issues a device reset to the affected device.

 * A LUN reset will be sent to the device first. If that does

 * not work, a target reset will be sent.

 *

 * Return value:

 *	SUCCESS / FAILED

	/*

	 * If we are currently going through reset/reload, return failed. This will force the

	 * mid-layer to call ipr_eh_host_reset, which will then go to sleep and wait for the

	 * reset to complete

/**

 * ipr_bus_reset_done - Op done function for bus reset.

 * @ipr_cmd:	ipr command struct

 *

 * This function is the op done function for a bus reset

 *

 * Return value:

 * 	none

	/*

	 * If abort has not completed, indicate the reset has, else call the

	 * abort's done function to wake the sleeping eh thread

/**

 * ipr_abort_timeout - An abort task has timed out

 * @t: Timer context used to fetch ipr command struct

 *

 * This function handles when an abort task times out. If this

 * happens we issue a bus reset since we have resources tied

 * up that must be freed before returning to the midlayer.

 *

 * Return value:

 *	none

/**

 * ipr_cancel_op - Cancel specified op

 * @scsi_cmd:	scsi command struct

 *

 * This function cancels specified op.

 *

 * Return value:

 *	SUCCESS / FAILED

	/* If we are currently going through reset/reload, return failed.

	 * This will force the mid-layer to call ipr_eh_host_reset,

	 * which will then go to sleep and wait for the reset to complete

	/*

	 * If we are aborting a timed out op, chances are that the timeout was caused

	 * by a still not detected EEH error. In such cases, reading a register will

	 * trigger the EEH recovery infrastructure.

	/*

	 * If the abort task timed out and we sent a bus reset, we will get

	 * one the following responses to the abort

/**

 * ipr_scan_finished - Report whether scan is done

 * @shost:           scsi host struct

 * @elapsed_time:    elapsed time

 *

 * Return value:

 *	0 if scan in progress / 1 if scan is complete

/**

 * ipr_eh_abort - Reset the host adapter

 * @scsi_cmd:	scsi command struct

 *

 * Return value:

 * 	SUCCESS / FAILED

/**

 * ipr_handle_other_interrupt - Handle "other" interrupts

 * @ioa_cfg:	ioa config struct

 * @int_reg:	interrupt register

 *

 * Return value:

 * 	IRQ_NONE / IRQ_HANDLED

	/* If an interrupt on the adapter did not occur, ignore it.

	 * Or in the case of SIS 64, check for a stage change interrupt.

 clear stage change */

 Mask the interrupt */

/**

 * ipr_isr_eh - Interrupt service routine error handler

 * @ioa_cfg:	ioa config struct

 * @msg:	message to log

 * @number:	various meanings depending on the caller/message

 *

 * Return value:

 * 	none

 If interrupts are disabled, ignore the interrupt */

/**

 * ipr_isr - Interrupt service routine

 * @irq:	irq number

 * @devp:	pointer to ioa config struct

 *

 * Return value:

 * 	IRQ_NONE / IRQ_HANDLED

 If interrupts are disabled, ignore the interrupt */

 Clear the PCI interrupt */

/**

 * ipr_isr_mhrrq - Interrupt service routine

 * @irq:	irq number

 * @devp:	pointer to ioa config struct

 *

 * Return value:

 *	IRQ_NONE / IRQ_HANDLED

 If interrupts are disabled, ignore the interrupt */

/**

 * ipr_build_ioadl64 - Build a scatter/gather list and map the buffer

 * @ioa_cfg:	ioa config struct

 * @ipr_cmd:	ipr command struct

 *

 * Return value:

 * 	0 on success / -1 on failure

/**

 * ipr_build_ioadl - Build a scatter/gather list and map the buffer

 * @ioa_cfg:	ioa config struct

 * @ipr_cmd:	ipr command struct

 *

 * Return value:

 * 	0 on success / -1 on failure

/**

 * __ipr_erp_done - Process completion of ERP for a device

 * @ipr_cmd:		ipr command struct

 *

 * This function copies the sense buffer into the scsi_cmd

 * struct and pushes the scsi_done function.

 *

 * Return value:

 * 	nothing

/**

 * ipr_erp_done - Process completion of ERP for a device

 * @ipr_cmd:		ipr command struct

 *

 * This function copies the sense buffer into the scsi_cmd

 * struct and pushes the scsi_done function.

 *

 * Return value:

 * 	nothing

/**

 * ipr_reinit_ipr_cmnd_for_erp - Re-initialize a cmnd block to be used for ERP

 * @ipr_cmd:	ipr command struct

 *

 * Return value:

 * 	none

/**

 * __ipr_erp_request_sense - Send request sense to a device

 * @ipr_cmd:	ipr command struct

 *

 * This function sends a request sense to a device as a result

 * of a check condition.

 *

 * Return value:

 * 	nothing

/**

 * ipr_erp_request_sense - Send request sense to a device

 * @ipr_cmd:	ipr command struct

 *

 * This function sends a request sense to a device as a result

 * of a check condition.

 *

 * Return value:

 * 	nothing

/**

 * ipr_erp_cancel_all - Send cancel all to a device

 * @ipr_cmd:	ipr command struct

 *

 * This function sends a cancel all to a device to clear the

 * queue. If we are running TCQ on the device, QERR is set to 1,

 * which means all outstanding ops have been dropped on the floor.

 * Cancel all will return them to us.

 *

 * Return value:

 * 	nothing

/**

 * ipr_dump_ioasa - Dump contents of IOASA

 * @ioa_cfg:	ioa config struct

 * @ipr_cmd:	ipr command struct

 * @res:		resource entry struct

 *

 * This function is invoked by the interrupt handler when ops

 * fail. It will log the IOASA if appropriate. Only called

 * for GPDD ops.

 *

 * Return value:

 * 	none

 Don't log an error if the IOA already logged one */

/**

 * ipr_gen_sense - Generate SCSI sense data from an IOASA

 * @ipr_cmd:	ipr command struct

 *

 * Return value:

 * 	none

 Illegal request */

 additional length */

 IOARCB was in error */

 Parameter data was invalid */

 Or in the Valid bit */

 additional length */

/**

 * ipr_get_autosense - Copy autosense data to sense buffer

 * @ipr_cmd:	ipr command struct

 *

 * This function copies the autosense buffer to the buffer

 * in the scsi_cmd, if there is autosense available.

 *

 * Return value:

 *	1 if autosense was available / 0 if not

/**

 * ipr_erp_start - Process an error response for a SCSI op

 * @ioa_cfg:	ioa config struct

 * @ipr_cmd:	ipr command struct

 *

 * This function determines whether or not to initiate ERP

 * on the affected device.

 *

 * Return value:

 * 	nothing

 prevent retries */

		/*

		 * exception: do not set DID_PASSTHROUGH on CHECK CONDITION

		 * so SCSI mid-layer and upper layers handle it accordingly.

		/*

		 * Report the bus reset and ask for a retry. The device

		 * will give CC/UA the next command.

/**

 * ipr_scsi_done - mid-layer done function

 * @ipr_cmd:	ipr command struct

 *

 * This function is invoked by the interrupt handler for

 * ops generated by the SCSI mid-layer

 *

 * Return value:

 * 	none

/**

 * ipr_queuecommand - Queue a mid-layer request

 * @shost:		scsi host struct

 * @scsi_cmd:	scsi command struct

 *

 * This function queues a request generated by the mid-layer.

 *

 * Return value:

 *	0 on success

 *	SCSI_MLQUEUE_DEVICE_BUSY if device is busy

 *	SCSI_MLQUEUE_HOST_BUSY if host is busy

	/*

	 * We are currently blocking all devices due to a host reset

	 * We have told the host to stop giving us new requests, but

	 * ERP ops don't count. FIXME

	/*

	 * FIXME - Create scsi_set_host_offline interface

	 *  and the ioa_is_dead check can be removed

/**

 * ipr_ioctl - IOCTL handler

 * @sdev:	scsi device struct

 * @cmd:	IOCTL cmd

 * @arg:	IOCTL arg

 *

 * Return value:

 * 	0 on success / other on failure

/**

 * ipr_ioa_info - Get information about the card/driver

 * @host:	scsi host struct

 *

 * Return value:

 * 	pointer to buffer with description string

/**

 * ipr_ata_phy_reset - libata phy_reset handler

 * @ap:		ata port to reset

 *

/**

 * ipr_ata_post_internal - Cleanup after an internal command

 * @qc:	ATA queued command

 *

 * Return value:

 * 	none

/**

 * ipr_copy_sata_tf - Copy a SATA taskfile to an IOA data structure

 * @regs:	destination

 * @tf:	source ATA taskfile

 *

 * Return value:

 * 	none

/**

 * ipr_sata_done - done function for SATA commands

 * @ipr_cmd:	ipr command struct

 *

 * This function is invoked by the interrupt handler for

 * ops generated by the SCSI mid-layer to SATA devices

 *

 * Return value:

 * 	none

/**

 * ipr_build_ata_ioadl64 - Build an ATA scatter/gather list

 * @ipr_cmd:	ipr command struct

 * @qc:		ATA queued command

 *

/**

 * ipr_build_ata_ioadl - Build an ATA scatter/gather list

 * @ipr_cmd:	ipr command struct

 * @qc:		ATA queued command

 *

/**

 * ipr_qc_defer - Get a free ipr_cmd

 * @qc:	queued command

 *

 * Return value:

 *	0 if success

/**

 * ipr_qc_issue - Issue a SATA qc to a device

 * @qc:	queued command

 *

 * Return value:

 * 	0 if success

/**

 * ipr_qc_fill_rtf - Read result TF

 * @qc: ATA queued command

 *

 * Return value:

 * 	true

/**

 * ipr_invalid_adapter - Determine if this adapter is supported on this hardware

 * @ioa_cfg:	ioa cfg struct

 *

 * Adapters that use Gemstone revision < 3.1 do not work reliably on

 * certain pSeries hardware. This function determines if the given

 * adapter is in one of these confgurations or not.

 *

 * Return value:

 * 	1 if adapter is not supported / 0 if adapter is supported

/**

 * ipr_ioa_bringdown_done - IOA bring down completion.

 * @ipr_cmd:	ipr command struct

 *

 * This function processes the completion of an adapter bring down.

 * It wakes any reset sleepers.

 *

 * Return value:

 * 	IPR_RC_JOB_RETURN

/**

 * ipr_ioa_reset_done - IOA reset completion.

 * @ipr_cmd:	ipr command struct

 *

 * This function processes the completion of an adapter reset.

 * It schedules any necessary mid-layer add/removes and

 * wakes any reset sleepers.

 *

 * Return value:

 * 	IPR_RC_JOB_RETURN

/**

 * ipr_set_sup_dev_dflt - Initialize a Set Supported Device buffer

 * @supported_dev:	supported device struct

 * @vpids:			vendor product id struct

 *

 * Return value:

 * 	none

/**

 * ipr_set_supported_devs - Send Set Supported Devices for a device

 * @ipr_cmd:	ipr command struct

 *

 * This function sends a Set Supported Devices to the adapter

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN

/**

 * ipr_get_mode_page - Locate specified mode page

 * @mode_pages:	mode page buffer

 * @page_code:	page code to find

 * @len:		minimum required length for mode page

 *

 * Return value:

 * 	pointer to mode page / NULL on failure

/**

 * ipr_check_term_power - Check for term power errors

 * @ioa_cfg:	ioa config struct

 * @mode_pages:	IOAFP mode pages buffer

 *

 * Check the IOAFP's mode page 28 for term power errors

 *

 * Return value:

 * 	nothing

/**

 * ipr_scsi_bus_speed_limit - Limit the SCSI speed based on SES table

 * @ioa_cfg:	ioa config struct

 *

 * Looks through the config table checking for SES devices. If

 * the SES device is in the SES table indicating a maximum SCSI

 * bus speed, the speed is limited for the bus.

 *

 * Return value:

 * 	none

/**

 * ipr_modify_ioafp_mode_page_28 - Modify IOAFP Mode Page 28

 * @ioa_cfg:	ioa config struct

 * @mode_pages:	mode page 28 buffer

 *

 * Updates mode page 28 based on driver configuration

 *

 * Return value:

 * 	none

 Loop for each device bus entry */

/**

 * ipr_build_mode_select - Build a mode select command

 * @ipr_cmd:	ipr command struct

 * @res_handle:	resource handle to send command to

 * @parm:		Byte 2 of Mode Sense command

 * @dma_addr:	DMA buffer address

 * @xfer_len:	data transfer length

 *

 * Return value:

 * 	none

/**

 * ipr_ioafp_mode_select_page28 - Issue Mode Select Page 28 to IOA

 * @ipr_cmd:	ipr command struct

 *

 * This function sets up the SCSI bus attributes and sends

 * a Mode Select for Page 28 to activate them.

 *

 * Return value:

 * 	IPR_RC_JOB_RETURN

/**

 * ipr_build_mode_sense - Builds a mode sense command

 * @ipr_cmd:	ipr command struct

 * @res_handle:		resource entry struct

 * @parm:		Byte 2 of mode sense command

 * @dma_addr:	DMA address of mode sense buffer

 * @xfer_len:	Size of DMA buffer

 *

 * Return value:

 * 	none

/**

 * ipr_reset_cmd_failed - Handle failure of IOA reset command

 * @ipr_cmd:	ipr command struct

 *

 * This function handles the failure of an IOA bringup command.

 *

 * Return value:

 * 	IPR_RC_JOB_RETURN

/**

 * ipr_reset_mode_sense_failed - Handle failure of IOAFP mode sense

 * @ipr_cmd:	ipr command struct

 *

 * This function handles the failure of a Mode Sense to the IOAFP.

 * Some adapters do not handle all mode pages.

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN

/**

 * ipr_ioafp_mode_sense_page28 - Issue Mode Sense Page 28 to IOA

 * @ipr_cmd:	ipr command struct

 *

 * This function send a Page 28 mode sense to the IOA to

 * retrieve SCSI bus attributes.

 *

 * Return value:

 * 	IPR_RC_JOB_RETURN

/**

 * ipr_ioafp_mode_select_page24 - Issue Mode Select to IOA

 * @ipr_cmd:	ipr command struct

 *

 * This function enables dual IOA RAID support if possible.

 *

 * Return value:

 * 	IPR_RC_JOB_RETURN

/**

 * ipr_reset_mode_sense_page24_failed - Handle failure of IOAFP mode sense

 * @ipr_cmd:	ipr command struct

 *

 * This function handles the failure of a Mode Sense to the IOAFP.

 * Some adapters do not handle all mode pages.

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN

/**

 * ipr_ioafp_mode_sense_page24 - Issue Page 24 Mode Sense to IOA

 * @ipr_cmd:	ipr command struct

 *

 * This function send a mode sense to the IOA to retrieve

 * the IOA Advanced Function Control mode page.

 *

 * Return value:

 * 	IPR_RC_JOB_RETURN

/**

 * ipr_init_res_table - Initialize the resource table

 * @ipr_cmd:	ipr command struct

 *

 * This function looks through the existing resource table, comparing

 * it with the config table. This function will take care of old/new

 * devices and schedule adding/removing them from the mid-layer

 * as appropriate.

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE

/**

 * ipr_ioafp_query_ioa_cfg - Send a Query IOA Config to the adapter.

 * @ipr_cmd:	ipr command struct

 *

 * This function sends a Query IOA Configuration command

 * to the adapter to retrieve the IOA configuration table.

 *

 * Return value:

 * 	IPR_RC_JOB_RETURN

/**

 * ipr_ioafp_set_caching_parameters - Issue Set Cache parameters service

 * action

 * @ipr_cmd:	ipr command struct

 *

 * Return value:

 *	none

/**

 * ipr_ioafp_inquiry - Send an Inquiry to the adapter.

 * @ipr_cmd:	ipr command struct

 * @flags:	flags to send

 * @page:	page to inquire

 * @dma_addr:	DMA address

 * @xfer_len:	transfer data length

 *

 * This utility function sends an inquiry to the adapter.

 *

 * Return value:

 * 	none

/**

 * ipr_inquiry_page_supported - Is the given inquiry page supported

 * @page0:		inquiry page 0 buffer

 * @page:		page code.

 *

 * This function determines if the specified inquiry page is supported.

 *

 * Return value:

 *	1 if page is supported / 0 if not

/**

 * ipr_ioafp_pageC4_inquiry - Send a Page 0xC4 Inquiry to the adapter.

 * @ipr_cmd:	ipr command struct

 *

 * This function sends a Page 0xC4 inquiry to the adapter

 * to retrieve software VPD information.

 *

 * Return value:

 *	IPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN

/**

 * ipr_ioafp_cap_inquiry - Send a Page 0xD0 Inquiry to the adapter.

 * @ipr_cmd:	ipr command struct

 *

 * This function sends a Page 0xD0 inquiry to the adapter

 * to retrieve adapter capabilities.

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN

/**

 * ipr_ioafp_page3_inquiry - Send a Page 3 Inquiry to the adapter.

 * @ipr_cmd:	ipr command struct

 *

 * This function sends a Page 3 inquiry to the adapter

 * to retrieve software VPD information.

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN

/**

 * ipr_ioafp_page0_inquiry - Send a Page 0 Inquiry to the adapter.

 * @ipr_cmd:	ipr command struct

 *

 * This function sends a Page 0 inquiry to the adapter

 * to retrieve supported inquiry pages.

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN

 Grab the type out of the VPD and store it away */

/**

 * ipr_ioafp_std_inquiry - Send a Standard Inquiry to the adapter.

 * @ipr_cmd:	ipr command struct

 *

 * This function sends a standard inquiry to the adapter.

 *

 * Return value:

 * 	IPR_RC_JOB_RETURN

/**

 * ipr_ioafp_identify_hrrq - Send Identify Host RRQ.

 * @ipr_cmd:	ipr command struct

 *

 * This function send an Identify Host Request Response Queue

 * command to establish the HRRQ with the adapter.

 *

 * Return value:

 * 	IPR_RC_JOB_RETURN

/**

 * ipr_reset_timer_done - Adapter reset timer function

 * @t: Timer context used to fetch ipr command struct

 *

 * Description: This function is used in adapter reset processing

 * for timing events. If the reset_cmd pointer in the IOA

 * config struct is not this adapter's we are doing nested

 * resets and fail_all_ops will take care of freeing the

 * command block.

 *

 * Return value:

 * 	none

/**

 * ipr_reset_start_timer - Start a timer for adapter reset job

 * @ipr_cmd:	ipr command struct

 * @timeout:	timeout value

 *

 * Description: This function is used in adapter reset processing

 * for timing events. If the reset_cmd pointer in the IOA

 * config struct is not this adapter's we are doing nested

 * resets and fail_all_ops will take care of freeing the

 * command block.

 *

 * Return value:

 * 	none

/**

 * ipr_init_ioa_mem - Initialize ioa_cfg control block

 * @ioa_cfg:	ioa cfg struct

 *

 * Return value:

 * 	nothing

 Initialize Host RRQ pointers */

 Zero out config table */

/**

 * ipr_reset_next_stage - Process IPL stage change based on feedback register.

 * @ipr_cmd:	ipr command struct

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN

 sanity check the stage_time value */

/**

 * ipr_reset_enable_ioa - Enable the IOA following a reset.

 * @ipr_cmd:	ipr command struct

 *

 * This function reinitializes some control blocks and

 * enables destructive diagnostics on the adapter.

 *

 * Return value:

 * 	IPR_RC_JOB_RETURN

 Set the adapter to the correct endian mode. */

 Enable destructive diagnostics on IOA */

/**

 * ipr_reset_wait_for_dump - Wait for a dump to timeout.

 * @ipr_cmd:	ipr command struct

 *

 * This function is invoked when an adapter dump has run out

 * of processing time.

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE

/**

 * ipr_unit_check_no_data - Log a unit check/no data error log

 * @ioa_cfg:		ioa config struct

 *

 * Logs an error indicating the adapter unit checked, but for some

 * reason, we were unable to fetch the unit check buffer.

 *

 * Return value:

 * 	nothing

/**

 * ipr_get_unit_check_buffer - Get the unit check buffer from the IOA

 * @ioa_cfg:		ioa config struct

 *

 * Fetches the unit check buffer from the adapter by clocking the data

 * through the mailbox register.

 *

 * Return value:

 * 	nothing

 Find length of the first sdt entry (UC buffer) */

/**

 * ipr_reset_get_unit_check_job - Call to get the unit check buffer.

 * @ipr_cmd:	ipr command struct

 *

 * Description: This function will call to get the unit check buffer.

 *

 * Return value:

 *	IPR_RC_JOB_RETURN

/**

 * ipr_reset_restore_cfg_space - Restore PCI config space.

 * @ipr_cmd:	ipr command struct

 *

 * Description: This function restores the saved PCI config space of

 * the adapter, fails all outstanding ops back to the callers, and

 * fetches the dump/unit check if applicable to this reset.

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN

 Set the adapter to the correct endian mode. */

/**

 * ipr_reset_bist_done - BIST has completed on the adapter.

 * @ipr_cmd:	ipr command struct

 *

 * Description: Unblock config space and resume the reset process.

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE

/**

 * ipr_reset_start_bist - Run BIST on the adapter.

 * @ipr_cmd:	ipr command struct

 *

 * Description: This function runs BIST on the adapter, then delays 2 seconds.

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN

/**

 * ipr_reset_slot_reset_done - Clear PCI reset to the adapter

 * @ipr_cmd:	ipr command struct

 *

 * Description: This clears PCI reset to the adapter and delays two seconds.

 *

 * Return value:

 * 	IPR_RC_JOB_RETURN

/**

 * ipr_reset_reset_work - Pulse a PCIe fundamental reset

 * @work:	work struct

 *

 * Description: This pulses warm reset to a slot.

 *

/**

 * ipr_reset_slot_reset - Reset the PCI slot of the adapter.

 * @ipr_cmd:	ipr command struct

 *

 * Description: This asserts PCI reset to the adapter.

 *

 * Return value:

 * 	IPR_RC_JOB_RETURN

/**

 * ipr_reset_block_config_access_wait - Wait for permission to block config access

 * @ipr_cmd:	ipr command struct

 *

 * Description: This attempts to block config access to the IOA.

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN

/**

 * ipr_reset_block_config_access - Block config access to the IOA

 * @ipr_cmd:	ipr command struct

 *

 * Description: This attempts to block config access to the IOA

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE

/**

 * ipr_reset_allowed - Query whether or not IOA can be reset

 * @ioa_cfg:	ioa config struct

 *

 * Return value:

 * 	0 if reset not allowed / non-zero if reset is allowed

/**

 * ipr_reset_wait_to_start_bist - Wait for permission to reset IOA.

 * @ipr_cmd:	ipr command struct

 *

 * Description: This function waits for adapter permission to run BIST,

 * then runs BIST. If the adapter does not give permission after a

 * reasonable time, we will reset the adapter anyway. The impact of

 * resetting the adapter without warning the adapter is the risk of

 * losing the persistent error log on the adapter. If the adapter is

 * reset while it is writing to the flash on the adapter, the flash

 * segment will have bad ECC and be zeroed.

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN

/**

 * ipr_reset_alert - Alert the adapter of a pending reset

 * @ipr_cmd:	ipr command struct

 *

 * Description: This function alerts the adapter that it will be reset.

 * If memory space is not currently enabled, proceed directly

 * to running BIST on the adapter. The timer must always be started

 * so we guarantee we do not run BIST from ipr_isr.

 *

 * Return value:

 * 	IPR_RC_JOB_RETURN

/**

 * ipr_reset_quiesce_done - Complete IOA disconnect

 * @ipr_cmd:	ipr command struct

 *

 * Description: Freeze the adapter to complete quiesce processing

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE

/**

 * ipr_reset_cancel_hcam_done - Check for outstanding commands

 * @ipr_cmd:	ipr command struct

 *

 * Description: Ensure nothing is outstanding to the IOA and

 *			proceed with IOA disconnect. Otherwise reset the IOA.

 *

 * Return value:

 * 	IPR_RC_JOB_RETURN / IPR_RC_JOB_CONTINUE

/**

 * ipr_reset_cancel_hcam - Cancel outstanding HCAMs

 * @ipr_cmd:	ipr command struct

 *

 * Description: Cancel any oustanding HCAMs to the IOA.

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN

/**

 * ipr_reset_ucode_download_done - Microcode download completion

 * @ipr_cmd:	ipr command struct

 *

 * Description: This function unmaps the microcode download buffer.

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE

/**

 * ipr_reset_ucode_download - Download microcode to the adapter

 * @ipr_cmd:	ipr command struct

 *

 * Description: This function checks to see if it there is microcode

 * to download to the adapter. If there is, a download is performed.

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN

/**

 * ipr_reset_shutdown_ioa - Shutdown the adapter

 * @ipr_cmd:	ipr command struct

 *

 * Description: This function issues an adapter shutdown of the

 * specified type to the specified adapter as part of the

 * adapter reset job.

 *

 * Return value:

 * 	IPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN

/**

 * ipr_reset_ioa_job - Adapter reset job

 * @ipr_cmd:	ipr command struct

 *

 * Description: This function is the job router for the adapter reset job.

 *

 * Return value:

 * 	none

			/*

			 * We are doing nested adapter resets and this is

			 * not the current reset job.

/**

 * _ipr_initiate_ioa_reset - Initiate an adapter reset

 * @ioa_cfg:		ioa config struct

 * @job_step:		first job step of reset job

 * @shutdown_type:	shutdown type

 *

 * Description: This function will initiate the reset of the given adapter

 * starting at the selected job step.

 * If the caller needs to wait on the completion of the reset,

 * the caller must sleep on the reset_wait_q.

 *

 * Return value:

 * 	none

/**

 * ipr_initiate_ioa_reset - Initiate an adapter reset

 * @ioa_cfg:		ioa config struct

 * @shutdown_type:	shutdown type

 *

 * Description: This function will initiate the reset of the given adapter.

 * If the caller needs to wait on the completion of the reset,

 * the caller must sleep on the reset_wait_q.

 *

 * Return value:

 * 	none

/**

 * ipr_reset_freeze - Hold off all I/O activity

 * @ipr_cmd:	ipr command struct

 *

 * Description: If the PCI slot is frozen, hold off all I/O

 * activity; then, as soon as the slot is available again,

 * initiate an adapter reset.

 Disallow new interrupts, avoid loop */

/**

 * ipr_pci_mmio_enabled - Called when MMIO has been re-enabled

 * @pdev:	PCI device struct

 *

 * Description: This routine is called to tell us that the MMIO

 * access to the IOA has been restored

/**

 * ipr_pci_frozen - Called when slot has experienced a PCI bus error.

 * @pdev:	PCI device struct

 *

 * Description: This routine is called to tell us that the PCI bus

 * is down. Can't do anything here, except put the device driver

 * into a holding pattern, waiting for the PCI bus to come back.

/**

 * ipr_pci_slot_reset - Called when PCI slot has been reset.

 * @pdev:	PCI device struct

 *

 * Description: This routine is called by the pci error recovery

 * code after the PCI slot has been reset, just before we

 * should resume normal operations.

/**

 * ipr_pci_perm_failure - Called when PCI slot is dead for good.

 * @pdev:	PCI device struct

 *

 * Description: This routine is called when the PCI bus has

 * permanently failed.

/**

 * ipr_pci_error_detected - Called when a PCI error is detected.

 * @pdev:	PCI device struct

 * @state:	PCI channel state

 *

 * Description: Called when a PCI error is detected.

 *

 * Return value:

 * 	PCI_ERS_RESULT_NEED_RESET or PCI_ERS_RESULT_DISCONNECT

/**

 * ipr_probe_ioa_part2 - Initializes IOAs found in ipr_probe_ioa(..)

 * @ioa_cfg:	ioa cfg struct

 *

 * Description: This is the second phase of adapter initialization

 * This function takes care of initilizing the adapter to the point

 * where it can accept new commands.

 * Return value:

 * 	0 on success / -EIO on failure

/**

 * ipr_free_cmd_blks - Frees command blocks allocated for an adapter

 * @ioa_cfg:	ioa config struct

 *

 * Return value:

 * 	none

/**

 * ipr_free_mem - Frees memory allocated for an adapter

 * @ioa_cfg:	ioa cfg struct

 *

 * Return value:

 * 	nothing

/**

 * ipr_free_irqs - Free all allocated IRQs for the adapter.

 * @ioa_cfg:	ipr cfg struct

 *

 * This function frees all allocated IRQs for the

 * specified adapter.

 *

 * Return value:

 * 	none

/**

 * ipr_free_all_resources - Free all allocated resources for an adapter.

 * @ioa_cfg:	ioa config struct

 *

 * This function frees all allocated resources for the

 * specified adapter.

 *

 * Return value:

 * 	none

/**

 * ipr_alloc_cmd_blks - Allocate command blocks for an adapter

 * @ioa_cfg:	ioa config struct

 *

 * Return value:

 * 	0 on success / -ENOMEM on allocation failure

/**

 * ipr_alloc_mem - Allocate memory for an adapter

 * @ioa_cfg:	ioa config struct

 *

 * Return value:

 * 	0 on success / non-zero for error

/**

 * ipr_initialize_bus_attr - Initialize SCSI bus attributes to default values

 * @ioa_cfg:	ioa config struct

 *

 * Return value:

 * 	none

/**

 * ipr_init_regs - Initialize IOA registers

 * @ioa_cfg:	ioa config struct

 *

 * Return value:

 *	none

/**

 * ipr_init_ioa_cfg - Initialize IOA config struct

 * @ioa_cfg:	ioa config struct

 * @host:		scsi host struct

 * @pdev:		PCI dev struct

 *

 * Return value:

 * 	none

/**

 * ipr_get_chip_info - Find adapter chip information

 * @dev_id:		PCI device id struct

 *

 * Return value:

 * 	ptr to chip information on success / NULL on failure

/**

 * ipr_wait_for_pci_err_recovery - Wait for any PCI error recovery to complete

 *						during probe time

 * @ioa_cfg:	ioa config struct

 *

 * Return value:

 * 	None

/**

 * ipr_test_intr - Handle the interrupt generated in ipr_test_msi().

 * @devp:		PCI device struct

 * @irq:		IRQ number

 *

 * Description: Simply set the msi_received flag to 1 indicating that

 * Message Signaled Interrupts are supported.

 *

 * Return value:

 * 	0 on success / non-zero on failure

/**

 * ipr_test_msi - Test for Message Signaled Interrupt (MSI) support.

 * @ioa_cfg:		ioa config struct

 * @pdev:		PCI device struct

 *

 * Description: This routine sets up and initiates a test interrupt to determine

 * if the interrupt is received via the ipr_test_intr() service routine.

 * If the tests fails, the driver will fall back to LSI.

 *

 * Return value:

 * 	0 on success / non-zero on failure

 MSI test failed */

 /* ipr_probe_ioa - Allocates memory and does first stage of initialization

 * @pdev:		PCI device struct

 * @dev_id:		PCI device id struct

 *

 * Return value:

 * 	0 on success / non-zero on failure

 set SIS 32 or SIS 64 */

 Issue MMIO read to ensure card is not in EEH */

 Save away PCI config space for use following IOA reset */

	/*

	 * If HRRQ updated interrupt is not masked, or reset alert is set,

	 * the card is in an unknown state and needs a hard reset

/**

 * ipr_initiate_ioa_bringdown - Bring down an adapter

 * @ioa_cfg:		ioa config struct

 * @shutdown_type:	shutdown type

 *

 * Description: This function will initiate bringing down the adapter.

 * This consists of issuing an IOA shutdown to the adapter

 * to flush the cache, and running BIST.

 * If the caller needs to wait on the completion of the reset,

 * the caller must sleep on the reset_wait_q.

 *

 * Return value:

 * 	none

/**

 * __ipr_remove - Remove a single adapter

 * @pdev:	pci device struct

 *

 * Adapter hot plug remove entry point.

 *

 * Return value:

 * 	none

/**

 * ipr_remove - IOA hot plug remove entry point

 * @pdev:	pci device struct

 *

 * Adapter hot plug remove entry point.

 *

 * Return value:

 * 	none

/**

 * ipr_probe - Adapter hot plug add entry point

 * @pdev:	pci device struct

 * @dev_id:	pci device ID

 *

 * Return value:

 * 	0 on success / non-zero on failure

/**

 * ipr_shutdown - Shutdown handler.

 * @pdev:	pci device struct

 *

 * This function is invoked upon system shutdown/reboot. It will issue

 * an adapter shutdown to the adapter to flush the write cache.

 *

 * Return value:

 * 	none

/**

 * ipr_halt_done - Shutdown prepare completion

 * @ipr_cmd:   ipr command struct

 *

 * Return value:

 * 	none

/**

 * ipr_halt - Issue shutdown prepare to all adapters

 * @nb: Notifier block

 * @event: Notifier event

 * @buf: Notifier data (unused)

 *

 * Return value:

 * 	NOTIFY_OK on success / NOTIFY_DONE on failure

/**

 * ipr_init - Module entry point

 *

 * Return value:

 * 	0 on success / negative value on failure

/**

 * ipr_exit - Module unload

 *

 * Module unload entry point.

 *

 * Return value:

 * 	none

 SPDX-License-Identifier: GPL-2.0

 Ack and enable ints */

 setup dma direction */

 remember direction */

 invalidate any cache */

 push any dirty cache */

 start DMA */

 return success */

 Disabled; causes problems booting */

 Assert SCSI bus reset */

 Negate SCSI bus reset */

 Clear bus reset interrupt */

 Enable interrupt */

 ensure DMA is stopped */

 Ack and enable ints */

 XXX Make sure DMA is stopped! */

 SPDX-License-Identifier: GPL-2.0

/* -*-linux-c-*-



 * vendor-specific code for SCSI CD-ROM's goes here.

 *

 * This is needed becauce most of the new features (multisession and

 * the like) are too new to be included into the SCSI-II standard (to

 * be exact: there is'nt anything in my draft copy).

 *

 * Aug 1997: Ha! Got a SCSI-3 cdrom spec across my fingers. SCSI-3 does

 *           multisession using the READ TOC command (like SONY).

 *

 *           Rearranged stuff here: SCSI-3 is included allways, support

 *           for NEC/TOSHIBA/HP commands is optional.

 *

 *   Gerd Knorr <kraxel@cs.tu-berlin.de> 

 *

 * --------------------------------------------------------------------------

 *

 * support for XA/multisession-CD's

 * 

 *   - NEC:     Detection and support of multisession CD's.

 *     

 *   - TOSHIBA: Detection and support of multisession CD's.

 *              Some XA-Sector tweaking, required for older drives.

 *

 *   - SONY:    Detection and support of multisession CD's.

 *              added by Thomas Quinot <thomas@cuivre.freenix.fr>

 *

 *   - PIONEER, HITACHI, PLEXTOR, MATSHITA, TEAC, PHILIPS: known to

 *              work with SONY (SCSI3 now)  code.

 *

 *   - HP:      Much like SONY, but a little different... (Thomas)

 *              HP-Writers only ??? Maybe other CD-Writers work with this too ?

 *              HP 6020 writers now supported.

 here are some constants to sort the vendors into groups */

 default: scsi-3 mmc */

 pre-scsi3 writers */

 CD-on-a-chip */

 default */

 this is true for scsi3/mmc drives - no more checks */

		/* my NEC 3x returns the read-raw data if a read-raw

 these can't handle multisession, may hang */

		/* The Beurer GL50 evo uses a Cygnal-manufactured CD-on-a-chip

		   that only accepts a subset of SCSI commands.  Most of the

		   not-implemented commands are fine to fail, but a few,

		   particularly around the MMC or Audio commands, will put the

		   device into an unrecoverable state, so they need to be

		   avoided at all costs.

/* small handy function for switching block length using MODE SELECT,

 the buffer for the ioctl */

/* This function gets called after a media change. Checks if the CD is

 the buffer for the ioctl */

 the multisession sector offset goes here  */

 flag: the drive can't handle multisession */

 ignore sector offsets from first track */

			/* we request some disc information (is it a XA-CD ?,

 Read TOC */

 number of last session */

 should not happen */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * scsi_logging.c

 *

 * Copyright (C) 2014 SUSE Linux Products GmbH

 * Copyright (C) 2014 Hannes Reinecke <hare@suse.de>

 print out all bytes in cdb */

 print out all bytes in cdb */

 Print opcode in one line and use separate lines for CDB */

/*

 * Print normalized SCSI sense header with a prefix.

 Normalize and print sense buffer with name prefix */

 Normalize and print sense buffer in SCSI command */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * iSCSI Initiator over TCP/IP Data-Path

 *

 * Copyright (C) 2004 Dmitry Yusupov

 * Copyright (C) 2004 Alex Aizman

 * Copyright (C) 2005 - 2006 Mike Christie

 * Copyright (C) 2006 Red Hat, Inc.  All rights reserved.

 * maintained by open-iscsi@googlegroups.com

 *

 * See the file COPYING included with this distribution for more details.

 *

 * Credits:

 *	Christoph Hellwig

 *	FUJITA Tomonori

 *	Arne Redlich

 *	Zhenyu Wang

/**

 * iscsi_sw_tcp_recv - TCP receive in sendfile fashion

 * @rd_desc: read descriptor

 * @skb: socket buffer

 * @offset: offset in skb

 * @len: skb->len - offset

/**

 * iscsi_sw_sk_state_check - check socket state

 * @sk: socket

 *

 * If the socket is in CLOSE or CLOSE_WAIT we should

 * not close the connection if there is still some

 * data pending.

 *

 * Must be called with sk_callback_lock.

	/*

	 * Use rd_desc to pass 'conn' to iscsi_tcp_recv.

	 * We set count to 1 because we want the network layer to

	 * hand us all the skbs that are available. iscsi_tcp_recv

	 * handled pdus that cross buffers or pdus that still need data.

	/* If we had to (atomically) map a highmem page,

/**

 * iscsi_sw_tcp_write_space - Called when more output buffer space is available

 * @sk: socket space is available for

 assign new callbacks */

 restore socket callbacks, see also: iscsi_conn_set_callbacks() */

/**

 * iscsi_sw_tcp_xmit_segment - transmit segment

 * @tcp_conn: the iSCSI TCP connection

 * @segment: the buffer to transmnit

 *

 * This function transmits as much of the buffer as

 * the network layer will accept, and returns the number of

 * bytes transmitted.

 *

 * If CRC hashing is enabled, the function will compute the

 * hash as it goes. When the entire segment has been transmitted,

 * it will retrieve the hash value and send it as well.

 Use sendpage if we can; else fall back to sendmsg */

/**

 * iscsi_sw_tcp_xmit - TCP transmit

 * @conn: iscsi connection

		/*

		 * We may not have been able to send data because the conn

		 * is getting stopped. libiscsi will know so propagate err

		 * for it to do the right thing.

	/* Transmit error. We could initiate error recovery

/**

 * iscsi_sw_tcp_xmit_qlen - return the number of bytes queued for xmit

 * @conn: iscsi connection

/*

 * This is called when we're done sending the header.

 * Simply copy the data_segment to the send segment, and return.

	/* Clear the data segment - needs to be filled in by the

	/* If header digest is enabled, compute the CRC and

	 * place the digest into the same buffer. We make

	 * sure that both iscsi_tcp_task and mtask have

	 * sufficient room.

	/* Remember header pointer for later, when we need

	 * to decide whether there's a payload to go along

/*

 * Prepare the send buffer for the payload data.

 * Padding and checksumming will all be taken care

 * of by the iscsi_segment routines.

	/* Make sure the datalen matches what the caller

	/* Make sure the datalen matches what the caller

 got invalid offset/len */

	/*

	 * Make sure we start socket shutdown now in case userspace is up

	 * but delayed in releasing the socket.

 userspace may have goofed up and not bound us */

 stop xmit side */

 stop recv side and release socket */

 lookup for existing socket */

 bind iSCSI connection and socket */

 setup Socket parameters */

 FIXME: make it configurable */

	/*

	 * set receive state machine into initial state

 session management */

 connection management */

 iscsi host params */

 IO */

 iscsi task/cmd helpers */

 low level pdu helpers */

 recovery */

 SPDX-License-Identifier: GPL-2.0

/*

 * Driver for Future Domain TMC-16x0 and TMC-3260 SCSI host adapters

 * Copyright 2019 Ondrej Zary

 *

 * Original driver by

 * Rickard E. Faith, faith@cs.unc.edu

 *

 * Future Domain BIOS versions supported for autodetect:

 *    2.0, 3.0, 3.2, 3.4 (1.0), 3.5 (2.0), 3.6, 3.61

 * Chips supported:

 *    TMC-1800, TMC-18C50, TMC-18C30, TMC-36C70

 * Boards supported:

 *    Future Domain TMC-1650, TMC-1660, TMC-1670, TMC-1680, TMC-1610M/MER/MEX

 *    Future Domain TMC-3260 (PCI)

 *    Quantum ISA-200S, ISA-250MG

 *    Adaptec AHA-2920A (PCI) [BUT *NOT* AHA-2920C -- use aic7xxx instead]

 *    IBM ?

 *

 * NOTE:

 *

 * The Adaptec AHA-2920C has an Adaptec AIC-7850 chip on it.

 * Use the aic7xxx driver for this board.

 *

 * The Adaptec AHA-2920A has a Future Domain chip on it, so this is the right

 * driver for that card.  Unfortunately, the boxes will probably just say

 * "2920", so you'll have to look on the card for a Future Domain logo, or a

 * letter after the 2920.

 *

 * If you have a TMC-8xx or TMC-9xx board, then this is not the driver for

 * your board.

 *

 * DESCRIPTION:

 *

 * This is the Linux low-level SCSI driver for Future Domain TMC-1660/1680

 * TMC-1650/1670, and TMC-3260 SCSI host adapters.  The 1650 and 1670 have a

 * 25-pin external connector, whereas the 1660 and 1680 have a SCSI-2 50-pin

 * high-density external connector.  The 1670 and 1680 have floppy disk

 * controllers built in.  The TMC-3260 is a PCI bus card.

 *

 * Future Domain's older boards are based on the TMC-1800 chip, and this

 * driver was originally written for a TMC-1680 board with the TMC-1800 chip.

 * More recently, boards are being produced with the TMC-18C50 and TMC-18C30

 * chips.

 *

 * Please note that the drive ordering that Future Domain implemented in BIOS

 * versions 3.4 and 3.5 is the opposite of the order (currently) used by the

 * rest of the SCSI industry.

 *

 *

 * REFERENCES USED:

 *

 * "TMC-1800 SCSI Chip Specification (FDC-1800T)", Future Domain Corporation,

 * 1990.

 *

 * "Technical Reference Manual: 18C50 SCSI Host Adapter Chip", Future Domain

 * Corporation, January 1992.

 *

 * "LXT SCSI Products: Specifications and OEM Technical Manual (Revision

 * B/September 1991)", Maxtor Corporation, 1991.

 *

 * "7213S product Manual (Revision P3)", Maxtor Corporation, 1992.

 *

 * "Draft Proposed American National Standard: Small Computer System

 * Interface - 2 (SCSI-2)", Global Engineering Documents. (X3T9.2/86-109,

 * revision 10h, October 17, 1991)

 *

 * Private communications, Drew Eckhardt (drew@cs.colorado.edu) and Eric

 * Youngdale (ericy@cais.com), 1992.

 *

 * Private communication, Tuong Le (Future Domain Engineering department),

 * 1994. (Disk geometry computations for Future Domain BIOS version 3.4, and

 * TMC-18C30 detection.)

 *

 * Hogan, Thom. The Programmer's PC Sourcebook. Microsoft Press, 1988. Page

 * 60 (2.39: Disk Partition Table Layout).

 *

 * "18C30 Technical Reference Manual", Future Domain Corporation, 1993, page

 * 6-1.

/*

 * FIFO_COUNT: The host adapter has an 8K cache (host adapters based on the

 * 18C30 chip have a 2k cache).  When this many 512 byte blocks are filled by

 * the SCSI device, an interrupt will be raised.  Therefore, this could be as

 * low as 0, or as high as 16.  Note, however, that values which are too high

 * or too low seem to prevent any interrupts from occurring, and thereby lock

 * up the machine.

 Number of 512 byte blocks before INTR */

 Parity enabled, 0 = disabled */

 Clear forced intr. */

 18c50 or 18c30 */

 Try to toggle 32-bit mode. This only works on an 18c30 chip. */

 If that failed, we are an 18c50. */

 Stop arbitration and enable parity */

 350 msec */

 Enable SCSI Bus */

 (on error, should make bus idle with 0) */

 8k FIFO for pre-tmc18c30 chips, 2k FIFO for tmc18c30 */

 Stop arbitration and enable parity */

 Try again, for slow devices */

 Stop arbitration and enable parity */

 cur_cmd->SCp.phase == in_other: this is the body of the routine */

 COMMAND OUT */

 DATA OUT -- tmc18c50/tmc18c30 only */

 DATA IN -- tmc18c50/tmc18c30 only */

 STATUS IN */

 MESSAGE OUT */

 MESSAGE IN */

 DATA OUT */

 DATA IN */

 Is it our IRQ? */

 We usually have one spurious interrupt after each command. */

 Spurious interrupt */

 Start arbitration */

 Disable data drivers */

 Set our id bit */

 Start arbitration */

 Aborts are not done well. . . */

 Partition table valid */

 Partition type */

 heads */

 sectors */

 heads */

 sectors */

 heads */

 sectors */

 heads */

 sectors */

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0

/*

 * scsicam.c - SCSI CAM support functions, use for HDIO_GETGEO, etc.

 *

 * Copyright 1993, 1994 Drew Eckhardt

 *      Visionary Computing 

 *      (Unix and Linux consulting and custom programming)

 *      drew@Colorado.EDU

 *      +1 (303) 786-7975

 *

 * For more information, please consult the SCSI-CAM draft.

/**

 * scsi_bios_ptable - Read PC partition table out of first sector of device.

 * @dev: from this device

 *

 * Description: Reads the first sector from the device and returns %0x42 bytes

 *              starting at offset %0x1be.

 * Returns: partition table in kmalloc(GFP_KERNEL) memory, or NULL on error.

/**

 * scsi_partsize - Parse cylinders/heads/sectors from PC partition table

 * @bdev: block device to parse

 * @capacity: size of the disk in sectors

 * @geom: output in form of [hds, cylinders, sectors]

 *

 * Determine the BIOS mapping/geometry used to create the partition

 * table, storing the results in @geom.

 *

 * Returns: %false on failure, %true on success.

 This is the actual _sector_ number at the end */

 This is for >1023 cylinders */

/*

 * Function : static int setsize(unsigned long capacity,unsigned int *cyls,

 *      unsigned int *hds, unsigned int *secs);

 *

 * Purpose : to determine a near-optimal int 0x13 mapping for a

 *      SCSI disk in terms of lost space of size capacity, storing

 *      the results in *cyls, *hds, and *secs.

 *

 * Returns : -1 on failure, 0 on success.

 *

 * Extracted from

 *

 * WORKING                                                    X3T9.2

 * DRAFT                                                        792D

 * see http://www.t10.org/ftp/t10/drafts/cam/cam-r12b.pdf

 *

 *                                                        Revision 6

 *                                                         10-MAR-94

 * Information technology -

 * SCSI-2 Common access method

 * transport and SCSI interface module

 * 

 * ANNEX A :

 *

 * setsize() converts a read capacity value to int 13h

 * head-cylinder-sector requirements. It minimizes the value for

 * number of heads and maximizes the number of cylinders. This

 * will support rather large disks before the number of heads

 * will not fit in 4 bits (or 6 bits). This algorithm also

 * minimizes the number of sectors that will be unused at the end

 * of the disk while allowing for very large disks to be

 * accommodated. This algorithm does not use physical geometry. 

 Set number of cylinders to max */

 Maximize sectors per track */

 Compute divisor for heads */

 Compute value for number of heads */

 If no remainder, done! */

 Else, increment number of heads */

 Compute divisor for sectors */

		sectors = capacity / temp;	/* Compute value for sectors per

 If no remainder, done! */

 Else, increment number of sectors */

 Compute divisor for cylinders */

 Compute number of cylinders */

 Give error if 0 cylinders */

 Stuff return values */

/**

 * scsicam_bios_param - Determine geometry of a disk in cylinders/heads/sectors.

 * @bdev: which device

 * @capacity: size of the disk in sectors

 * @ip: return value: ip[0]=heads, ip[1]=sectors, ip[2]=cylinders

 *

 * Description : determine the BIOS mapping/geometry used for a drive in a

 *      SCSI-CAM system, storing the results in ip as required

 *      by the HDIO_GETGEO ioctl().

 *

 * Returns : -1 on failure, 0 on success.

 Suppress gcc warning */

 try to infer mapping from partition table */

		/*

		 * Pick some standard mapping with at most 1024 cylinders, and

		 * at most 62 sectors per track - this works up to 7905 MB.

	/*

	 * If something went wrong, then apparently we have to return a geometry

	 * with more than 1024 cylinders.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Detection routine for the NCR53c710 based MVME16x SCSI Controllers for Linux.

 *

 * Based on work by Alan Hourihane

 *

 * Rewritten to use 53c700.c by Kars de Jong <jongk@linux-m68k.org>

 Fill in the required pieces of hostdata */

 XXX - depends on the CPU clock! */

 and register the chip */

 Enable scsi chip ints */

 Enable scsi interrupts at level 4 in PCCchip2 */

 Disable scsi chip ints */

 SPDX-License-Identifier: GPL-2.0-only

	/*

	 * if the physical address has the wrong alignment, or if

	 * physical address is bad, or if it is a write and at the

	 * end of a physical memory chunk, then allocate a bounce

	 * buffer

 can't allocate memory; use PIO */

 copy to bounce buffer for a write */

 setup dma direction */

 remember direction */

 setup DMA *physical* address */

 invalidate any cache */

 push any dirty cache */

 start DMA */

 make sure setup is completed */

 make sure DMA has started before next IO */

 return success */

 disable SCSI interrupts */

 make sure CNTR is updated before next IO */

 flush if we were reading */

 don't allow prefetch */

 no IO until FLUSH is done */

 clear a possible interrupt */

	/* I think that this CINT is only necessary if you are

	 * using the terminal count features.   HM 7 Mar 1994

 stop DMA */

 make sure DMA is stopped before next IO */

 restore the CONTROL bits (minus the direction flag) */

 make sure CNTR is updated before next IO */

 copy from a bounce buffer, if necessary */

 SPDX-License-Identifier: GPL-2.0-or-later

/**************************************************************************

 * Initio 9100 device driver for Linux.

 *

 * Copyright (c) 1994-1998 Initio Corporation

 * Copyright (c) 1998 Bas Vermeulen <bvermeul@blackstar.xs4all.nl>

 * Copyright (c) 2004 Christoph Hellwig <hch@lst.de>

 * Copyright (c) 2007 Red Hat

 *

 *************************************************************************

 *

 * DESCRIPTION:

 *

 * This is the Linux low-level SCSI driver for Initio INI-9X00U/UW SCSI host

 * adapters

 *

 * 08/06/97 hc	- v1.01h

 *		- Support inic-940 and inic-935

 * 09/26/97 hc	- v1.01i

 *		- Make correction from J.W. Schultz suggestion

 * 10/13/97 hc	- Support reset function

 * 10/21/97 hc	- v1.01j

 *		- Support 32 LUN (SCSI 3)

 * 01/14/98 hc	- v1.01k

 *		- Fix memory allocation problem

 * 03/04/98 hc	- v1.01l

 *		- Fix tape rewind which will hang the system problem

 *		- Set can_queue to initio_num_scb

 * 06/25/98 hc	- v1.01m

 *		- Get it work for kernel version >= 2.1.75

 *		- Dynamic assign SCSI bus reset holding time in initio_init()

 * 07/02/98 hc	- v1.01n

 *		- Support 0002134A

 * 08/07/98 hc  - v1.01o

 *		- Change the initio_abort_srb routine to use scsi_done. <01>

 * 09/07/98 hl  - v1.02

 *              - Change the INI9100U define and proc_dir_entry to

 *                reflect the newer Kernel 2.1.118, but the v1.o1o

 *                should work with Kernel 2.1.118.

 * 09/20/98 wh  - v1.02a

 *              - Support Abort command.

 *              - Handle reset routine.

 * 09/21/98 hl  - v1.03

 *              - remove comments.

 * 12/09/98 bv	- v1.03a

 *		- Removed unused code

 * 12/13/98 bv	- v1.03b

 *		- Remove cli() locking for kernels >= 2.1.95. This uses

 *		  spinlocks to serialize access to the pSRB_head and

 *		  pSRB_tail members of the HCS structure.

 * 09/01/99 bv	- v1.03d

 *		- Fixed a deadlock problem in SMP.

 * 21/01/99 bv	- v1.03e

 *		- Add support for the Domex 3192U PCI SCSI

 *		  This is a slightly modified patch by

 *		  Brian Macy <bmacy@sunshinecomputing.com>

 * 22/02/99 bv	- v1.03f

 *		- Didn't detect the INIC-950 in 2.0.x correctly.

 *		  Now fixed.

 * 05/07/99 bv	- v1.03g

 *		- Changed the assumption that HZ = 100

 * 10/17/03 mc	- v1.04

 *		- added new DMA API support

 * 06/01/04 jmd	- v1.04a

 *		- Re-add reset_bus support

--- forward references ---*/

 setup default pattern */

 ---- INTERNAL VARIABLES ---- */

----------- header -----------*/

 Signature    */

 Size         */

 Revision     */

 -- Host Adapter Structure -- */

 ModelByte0   */

 ModelByte1   */

 ModelInfo    */

 NumOfCh      */

 BIOSConfig1  */

 BIOSConfig2  */

 HAConfig1    */

 HAConfig2    */

 SCSI channel 0 and target Structure  */

 SCSIid       */

 SCSIconfig1  */

 SCSIconfig2  */

 NumSCSItarget */

 SCSI channel 1 and target Structure  */

 SCSIid       */

 SCSIconfig1  */

 SCSIconfig2  */

 NumSCSItarget */

      - CheckSum -            */

 fast 20      */

 nanosecond divide by 4 */

 50ns,  20M   */

 75ns,  13.3M */

 100ns, 10M   */

 125ns, 8M    */

 150ns, 6.6M  */

 175ns, 5.7M  */

 200ns, 5M    */

 250ns, 4M    */

 Pause for amount jiffies */

-- forward reference --*/

/******************************************************************

 Input: instruction for  Serial E2PROM



 EX: se2_rd(0 call se2_instr() to send address and read command



	 StartBit  OP_Code   Address                Data

	 --------- --------  ------------------     -------

	 1         1 , 0     A5,A4,A3,A2,A1,A0      D15-D0



		 +-----------------------------------------------------

		 |

 CS -----+

			+--+  +--+  +--+  +--+  +--+

			^  |  ^  |  ^  |  ^  |  ^  |

			|  |  |  |  |  |  |  |  |  |

 CLK -------+  +--+  +--+  +--+  +--+  +--

 (leading edge trigger)



		 +--1-----1--+

		 | SB    OP  |  OP    A5    A4

 DI  ----+           +--0------------------

 (address and cmd sent to nvram)



	 -------------------------------------------+

												|

 DO                                             +---

 (data sent from nvram)





/**

 *	initio_se2_instr	-	bitbang an instruction

 *	@base: Base of InitIO controller

 *	@instr: Instruction for serial E2PROM

 *

 *	Bitbang an instruction out to the serial E2Prom

 cs+start bit */

 +CLK */

 -CLK+dataBit */

 -CLK */

 +CLK */

 -CLK */

/**

 *	initio_se2_ew_en	-	Enable erase/write

 *	@base: Base address of InitIO controller

 *

 *	Enable erase/write state of serial EEPROM

 EWEN */

 -CS  */

/**

 *	initio_se2_ew_ds	-	Disable erase/write

 *	@base: Base address of InitIO controller

 *

 *	Disable erase/write state of serial EEPROM

 EWDS */

 -CS  */

/**

 *	initio_se2_rd		-	read E2PROM word

 *	@base: Base of InitIO controller

 *	@addr: Address of word in E2PROM

 *

 *	Read a word from the NV E2PROM device

 READ INSTR */

 +CLK */

 -CLK */

 sample data after the following edge of clock  */

 6/20/95 */

 no chip select */

/**

 *	initio_se2_wr		-	read E2PROM word

 *	@base: Base of InitIO controller

 *	@addr: Address of word in E2PROM

 *	@val: Value to write

 *

 *	Write a word to the NV E2PROM device. Used when recovering from

 *	a problem with the NV.

 WRITE INSTR */

 -CLK+dataBit 1 */

 -CLK+dataBit 0 */

 +CLK */

 -CLK */

 -CS  */

 +CS  */

 +CLK */

 -CLK */

 write complete */

 -CS */

/**

 *	initio_se2_rd_all	-	read hostadapter NV configuration

 *	@base: Base address of InitIO controller

 *

 *	Reads the E2PROM data into main memory. Ensures that the checksum

 *	and header marker are valid. Returns 1 on success -1 on error.

 Is signature "ini" ok ? */

 Is ckecksum ok ? */

/**

 *	initio_se2_update_all		-	Update E2PROM

 *	@base: Base of InitIO controller

 *

 *	Update the E2PROM by wrting any changes into the E2PROM

 *	chip, rewriting the checksum.

 setup default pattern */

 Calculate checksum first */

 Enable write  */

 Disable write   */

/**

 *	initio_read_eeprom		-	Retrieve configuration

 *	@base: Base of InitIO Host Adapter

 *

 *	Retrieve the host adapter configuration data from E2Prom. If the

 *	data is invalid then the defaults are used and are also restored

 *	into the E2PROM. This forms the access point for the SCSI driver

 *	into the E2PROM layer, the other functions for the E2PROM are all

 *	internal use.

 *

 *	Must be called single threaded, uses a shared global area.

 Enable EEProm programming */

 setup default pattern */

 load again  */

 Disable EEProm programming */

/**

 *	initio_stop_bm		-	stop bus master

 *	@host: InitIO we are stopping

 *

 *	Stop any pending DMA operation, aborting the DMA if necessary

 if DMA xfer is pending, abort DMA xfer */

 wait Abort DMA xfer done */

/**

 *	initio_reset_scsi		-	Reset SCSI host controller

 *	@host: InitIO host to reset

 *	@seconds: Recovery time

 *

 *	Perform a full reset of the SCSI subsystem.

 reset tulip chip */

 Stall for a while, wait for target's firmware ready,make it 2 sec ! */

 SONY 5200 tape drive won't work if only stall for 1 sec */

 FIXME: this is a very long busy wait right now */

/**

 *	initio_init		-	set up an InitIO host adapter

 *	@host: InitIO host adapter

 *	@bios_addr: BIOS address

 *

 *	Set up the host adapter and devices according to the configuration

 *	retrieved from the E2PROM.

 *

 *	Locking: Calls E2PROM layer code which is not re-enterable so must

 *	run single threaded for now.

 Get E2Prom configuration */

 Enable parity error response */

 Mask all the interrupt       */

 --- Initialize the tulip --- */

 program HBA's SCSI ID        */

	/* Enable Initiator Mode ,phase latch,alternate sync period mode,

 Enable HW reselect */

 selection time out = 250 ms */

 Enable SCSI terminator */

 for                          */

 Reset SCSI Bus */

/**

 *	initio_alloc_scb		-	Allocate an SCB

 *	@host: InitIO host we are allocating for

 *

 *	Walk the SCB list for the controller and allocate a free SCB if

 *	one exists.

/**

 *	initio_release_scb		-	Release an SCB

 *	@host: InitIO host that owns the SCB

 *	@cmnd: SCB command block being returned

 *

 *	Return an allocated SCB to the host free list

**************************************************************************/

**************************************************************************/

 Unlink this SCB              */

**************************************************************************/

**************************************************************************/

 Unlink this SCB              */

 Unlink this SCB              */

 disable Jasmin SCSI Int        */

 FIXME: synchronize_irq needed ? */

 Check Pend queue */

 07/27/98 */

 Check Busy queue */

**************************************************************************/

 7/29/98 */

***********************************************************************/

 Append this SCB to Pending queue */

 VVVVV 07/21/98 */

 Disable Jasmin SCSI Int */

**************************************************************************/

 Disable Tulip SCSI Int */

 Call tulip_scsi              */

 Walk the list of completed SCBs */

 find done entry */

 not in auto req. sense mode */

 clr sync. nego flag */

 for xfer_data_in */

						/* so, we won't report wrong direction in xfer_data_in,

 Disable Disconnect */

 in request sense mode */

				if (scb->tastat == 2) {		/* check contition status again after sending

 FIXME: only one post method and lose casts */

 while */

 find_active: */

 return to OS and wait for xfer_done_ISR/Selected_ISR */

 return to OS, enable interrupt */

 Check pending SCB            */

 return to OS, enable interrupt */

 End of for loop */

 statement won't reach here */

 make sure to service interrupt asap */

 SCSI bus reset detected      */

 if selected/reselected interrupt */

 BUS disconnection            */

 unexpected bus free or sel timeout */

 func complete or Bus service */

 program HBA's SCSI ID & target SCSI ID */

 do wdtr negotiation          */

 do sync negotiation          */

 bad command */

/**

 *	initio_next_state		-	Next SCSI state

 *	@host: InitIO host we are processing

 *

 *	Progress the active command block along the state machine

 *	until we hit a state which we must wait for activity to occur.

 *

 *	Returns zero or a negative code.

/**

 *	initio_state_1		-	SCSI state machine

 *	@host: InitIO host we are controlling

 *

 *	Perform SCSI state processing for Select/Attention/Stop

 Move the SCB from pending to busy */

 ATN on */

 Extended msg length */

 Sync request */

 Start from 16 bits */

 extended msg length */

 sync request */

 REQ/ACK offset */

 Into before CDB xfer */

/**

 *	initio_state_2		-	SCSI state machine

 *	@host: InitIO host we are controlling

 *

 * state after selection with attention

 * state after selection with attention3

 Into before CDB xfer */

/**

 *	initio_state_3		-	SCSI state machine

 *	@host: InitIO host we are controlling

 *

 * state before CDB xfer is done

 Command out phase            */

 Message in phase             */

 Status phase                 */

 Message out phase            */

 msg nop */

 ext. msg len */

 sync request */

 REQ/ACK offset */

/**

 *	initio_state_4		-	SCSI state machine

 *	@host: InitIO host we are controlling

 *

 *	SCSI state machine. State 4

 Go to state 6 (After data) */

 Status phase                 */

 if direction bit set then report data underrun */

 Message in phase             */

 Message out phase            */

 msg nop */

 Data in phase                */

 Data out phase               */

/**

 *	initio_state_5		-	SCSI state machine

 *	@host: InitIO host we are controlling

 *

 *	State after dma xfer done or phase change before xfer done

 cannot use unsigned !! code: if (xcnt < 0) */

------ get remaining count -------*/

 ----------------------- DATA_IN ----------------------------- */

 check scsi parity error */

 DMA xfer pending, Send STOP  */

 tell Hardware  scsi xfer has been terminated */

 wait until DMA xfer not pending */

-------- DATA OUT -----------*/

 if DMA xfer is pending, abort DMA xfer */

 wait Abort DMA xfer done */

 After Data */

 Update active data pointer */

 xcnt== bytes already xferred */

 cnt == bytes left to be xferred */

 this sgp xfer half done */

 xcnt == bytes xferred in this sgp */

 new ptr to be xfer */

 new len to be xfer */

 new SG table ptr */

 new SG table len */

 for next disc and come in this loop */

 Go to state 4                */

 else (xcnt >= 0 , i.e. this sgp already xferred */

 for */

 Go to state 6                */

 Go to state 4                */

/**

 *	initio_state_6		-	SCSI state machine

 *	@host: InitIO host we are controlling

 *

 *	State after Data phase

 Status phase                 */

 Message in phase             */

 Message out phase            */

 msg nop */

 Data in phase                */

 Data out phase               */

/**

 *	initio_state_7		-	SCSI state machine

 *	@host: InitIO host we are controlling

 *

 flush SCSI FIFO */

 Data in phase                */

 Data out phase               */

 Go to state 6                */

/**

 *	initio_xfer_data_in	-	Commence data input

 *	@host: InitIO host in use

 *

 *	Commence a block of data transfer. The transfer itself will

 *	be managed by the controller and we will get a completion (or

 *	failure) interrupt.

 wrong direction */

 7/25/95 */

 S/G xfer */

 return to OS, wait xfer done , let jas_isr come in */

/**

 *	initio_xfer_data_out	-	Commence data output

 *	@host: InitIO host in use

 *

 *	Commence a block of data transfer. The transfer itself will

 *	be managed by the controller and we will get a completion (or

 *	failure) interrupt.

 wrong direction */

 S/G xfer */

 return to OS, wait xfer done , let jas_isr come in */

 over run             */

 over run             */

 Disable wide CPU to allow read 16 bits */

 status & MSG_IN */

 get status */

 Parity error                 */

 Command complete             */

 No link support              */

 scsi bus free */

 selection timeout */

 Unexpected bus free          */

 Flush SCSI FIFO  */

 Enable HW reselect       */

/**

 *	int_initio_scsi_rst	-	SCSI reset occurred

 *	@host: Host seeing the reset

 *

 *	A SCSI bus reset has occurred. Clean up any pending transfer

 *	the hardware is doing by DMA and then abort all active and

 *	disconnected commands. The mid layer should sort the rest out

 *	for us

 if DMA xfer is pending, abort DMA xfer */

 wait Abort DMA xfer done */

 Abort all active & disconnected scb */

 clr sync nego. done flag */

/**

 *	int_initio_resel	-	Reselection occurred

 *	@host: InitIO host adapter

 *

 *	A SCSI reselection event has been signalled and the interrupt

 *	is now being processed. Work out which command block needs attention

 *	and continue processing that command.

 FIXME: Why check and not just clear ? */

 if waiting for selection complete */

 --------- get target id---------------------- */

 ------ get LUN from Identify message----------- */

 07/22/98 from 0x1F -> 0x0F */

 ------------- tag queueing ? ------------------- */

 Read Tag Message    */

 Is simple Tag      */

 Read Tag ID       */

 03/24/95             */

 No tag               */

/**

 *	int_initio_bad_seq		-	out of phase

 *	@host: InitIO host flagging event

 *

 *	We have ended up out of phase somehow. Reset the host controller

 *	and throw all our toys out of the pram. Let the midlayer clean up

 target wrong phase           */

/**

 *	initio_msgout_abort_targ		-	abort a tag

 *	@host: InitIO host

 *

 *	Abort when the target/lun does not match or when our SCB is not

 *	busy. Used by untagged commands.

/**

 *	initio_msgout_abort_tag		-	abort a tag

 *	@host: InitIO host

 *

 *	Abort when the target/lun does not match or when our SCB is not

 *	busy. Used for tagged commands.

/**

 *	initio_msgin		-	Message in

 *	@host: InitIO Host

 *

 *	Process incoming message

 Disconnect msg */

 Clear ATN first              */

 do sync nego */

 extended msg */

 statement won't reach here */

 Msg reject           */

 Initiator Detected Error */

 Get extended msg length      */

 if it's synchronous data transfer request */

 if length is not right */

 Set OFFSET=0 to do async, nego back */

 sync msg out */

 if it's WIDE DATA XFER REQ   */

 > 32 bits            */

 == 32                */

 WDTR msg out                 */

 Change to async              */

 offset requests asynchronous transfers ? */

 if 16 bit */

 pick the big one */

 clear sync done flag         */

 Initialize the sync. xfer register values to an asyn xfer */

 07/22/98 */

 07/22/98 */

 for */

/**

 *	initio_bus_device_reset	-	 SCSI Bus Device Reset

 *	@host: InitIO host to reset

 *

 *	Perform a device reset and abort all pending SCBs for the

 *	victim device

 Unexpected phase */

 target                       */

 clr sync. nego & WDTR flags  07/22/98 */

 abort all SCB with same target */

 Check Busy queue */

 unlink it */

 Previous haven't change      */

 if SCSI bus reset detected */

 if selected/reselected timeout interrupt */

 if SCSI bus reset detected   */

 BUS disconnection            */

 Flush SCSI FIFO */

 Enable HW reselect */

 Flush SCSI FIFO */

 Enable HW reselect */

 The old code really does the below. Can probably be removed */

 if SCSI bus reset detected */

 BUS disconnection */

 Flush SCSI FIFO */

 Enable HW reselect */

 if SCSI bus reset detected */

 BUS disconnection */

 Flush SCSI FIFO */

 Enable HW reselect */

/**

 *	i91u_intr		-	IRQ handler

 *	@irqno: IRQ number

 *	@dev_id: IRQ identifier

 *

 *	Take the relevant locks and then invoke the actual isr processing

 *	code under the lock.

/**

 *	initio_build_scb		-	Build the mappings and SCB

 *	@host: InitIO host taking the command

 *	@cblk: Firmware command block

 *	@cmnd: SCSI midlayer command block

 *

 *	Translate the abstract SCSI command into a firmware command block

 *	suitable for feeding to the InitIO host controller. This also requires

 *	we build the scatter gather lists and ensure they are mapped properly.

 Create corresponding SCB     */

 Pointer to SG list           */

 Fill in the command headers */

 i91u's callback routine      */

 After SCSI done, call post routine */

 Turn on auto request sense   */

 Map the sense buffer into bus memory */

 Clear the returned status */

 Command the command */

 Set up tags */

 Tag Support                  */

 Do simple tag only   */

 No tag support               */

 todo handle map_sg error */

 Turn on SG list flag       */

 No data transfer required */

/**

 *	i91u_queuecommand_lck	-	Queue a new command if possible

 *	@cmd: SCSI command block from the mid layer

 *	@done: Completion handler

 *

 *	Attempts to queue a new command with the host adapter. Will return

 *	zero if successful or indicate a host busy condition if not (which

 *	will cause the mid layer to call us again later with the command)

/**

 *	i91u_bus_reset		-	reset the SCSI bus

 *	@cmnd: Command block we want to trigger the reset for

 *

 *	Initiate a SCSI bus reset sequence

/**

 *	i91u_biosparam			-	return the "logical geometry

 *	@sdev: SCSI device

 *	@dev: Matching block device

 *	@capacity: Sector size of drive

 *	@info_array: Return space for BIOS geometry

 *

 *	Map the device geometry in a manner compatible with the host

 *	controller BIOS behaviour.

 *

 *	FIXME: limited to 2^32 sector devices.

 Point to Host adapter control block */

/**

 *	i91u_unmap_scb		-	Unmap a command

 *	@pci_dev: PCI device the command is for

 *	@cmnd: The command itself

 *

 *	Unmap any PCI mapping/IOMMU resources allocated when the command

 *	was mapped originally as part of initio_build_scb

 auto sense buffer */

 request buffer */

/*

 *	i91uSCBPost		-	SCSI callback

 *

 *	This is callback routine be called when tulip finish one

 *	SCSI command.

 Pointer to SCSI request block */

 Release SCB for current channel */

	/*

	 *	Remap the firmware error status into a mid layer one

 Linked command complete without error and linked normally */

 Linked command complete without error interrupt generated */

	case 0x11:		/* Selection time out-The initiator selection or target

	case 0x14:		/* Target bus phase sequence failure-An invalid bus phase or bus

				   phase sequence was requested by the target. The host adapter

				   will generate a SCSI Reset Condition, notifying the host with

 SCB Aborted. 07/21/98 */

	case 0x12:		/* Data overrun/underrun-The target attempted to transfer more data

				   than was allocated by the Data Length field or the sum of the

 Unexpected bus free-The target dropped the SCSI BSY at an unexpected time. */

 Invalid SCB Operation Code. */

 Couldn't find any better */

 Notify system DONE           */

 Release SCB for current channel */

 silence gcc */;

 1.01i */

 1-tape, 1-CD_ROM, 1- extra */

 03/05/98                      */

 10/21/97                     */

 Assign HCS index           */

/**

 *	initio_remove_one	-	control shutdown

 *	@pdev:	PCI device being released

 *

 *	Release the resources assigned to this adapter after it has

 *	finished being used.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * iSCSI lib functions

 *

 * Copyright (C) 2006 Red Hat, Inc.  All rights reserved.

 * Copyright (C) 2004 - 2006 Mike Christie

 * Copyright (C) 2004 - 2005 Dmitry Yusupov

 * Copyright (C) 2004 - 2005 Alex Aizman

 * maintained by open-iscsi@googlegroups.com

	/*

	 * standard specifies this check for when to update expected and

	 * max sequence numbers

/**

 * iscsi_prep_data_out_pdu - initialize Data-Out

 * @task: scsi command task

 * @r2t: R2T info

 * @hdr: iscsi data in pdu

 *

 * Notes:

 *	Initialize Data-Out within this R2T sequence and finds

 *	proper data_offset within this SCSI command.

 *

 *	This function is called with connection lock taken.

 caller must pad the AHS */

/*

 * make an extended cdb AHS

/**

 * iscsi_check_tmf_restrictions - check if a task is affected by TMF

 * @task: iscsi task

 * @opcode: opcode to check for

 *

 * During TMF a task has to be checked if it's affected.

 * All unrelated I/O can be passed through, but I/O to the

 * affected LUN should be restricted.

 * If 'fast_abort' is set we won't be sending any I/O to the

 * affected LUN.

 * Otherwise the target is waiting for all TTTs to be completed,

 * so we have to send all outstanding Data-Out PDUs to the target.

		/*

		 * Allow PDUs for unrelated LUNs

		/*

		 * Fail all SCSI cmd PDUs

		/*

		 * And also all data-out PDUs in response to R2T

		 * if fast_abort is set.

		/*

		 * the caller has already checked if the task

		 * they want to abort was in the pending queue so if

		 * we are here the cmd pdu has gone out already, and

		 * we will only hit this for data-outs

/**

 * iscsi_prep_scsi_cmd_pdu - prep iscsi scsi cmd pdu

 * @task: iscsi task

 *

 * Prep basic iSCSI PDU fields for a scsi cmd pdu. The LLD should set

 * fields like dlength or final based on how much data it sends

		/*

		 * Write counters:

		 *

		 *	imm_count	bytes to be sent right after

		 *			SCSI PDU Header

		 *

		 *	unsol_count	bytes(as Data-Out) to be sent

		 *			without	R2T ack right after

		 *			immediate data

		 *

		 *	r2t data_length bytes to be sent via R2T ack's

		 *

		 *      pad_count       bytes to be sent as zero-padding

 No unsolicit Data-Out's */

 calculate size of additional header segments (AHSs) */

/**

 * iscsi_free_task - free a task

 * @task: iscsi cmd task

 *

 * Must be called with session back_lock.

 * This function returns the scsi command to scsi-ml or cleans

 * up mgmt tasks then returns the task to the pool.

	/*

	 * login task is preallocated so do not free

 SCSI eh reuses commands to verify us */

		/*

		 * queue command may call this to free the task, so

		 * it will decide how to return sc to scsi-ml.

 regular RX path uses back_lock */

/**

 * iscsi_complete_task - finish a task

 * @task: iscsi cmd task

 * @state: state to complete task with

 *

 * Must be called with session back_lock.

 release get from queueing */

/**

 * iscsi_complete_scsi_task - finish scsi task normally

 * @task: iscsi task for scsi cmd

 * @exp_cmdsn: expected cmd sn in cpu format

 * @max_cmdsn: max cmd sn in cpu format

 *

 * This is used when drivers do not need or cannot perform

 * lower level pdu processing.

 *

 * Called with session back_lock

/*

 * Must be called with back and frwd lock

 Bad target might have completed task while it was still running */

		/*

		 * If it's on a list but still running, this could be from

		 * a bad target sending a rsp early, cleanup from a TMF, or

		 * session recovery.

/*

 * session frwd lock must be held and if not called for a task that is still

 * pending or from the xmit thread, then xmit thread must be suspended

		/*

		 * cmd never made it to the xmit thread, so we should not count

		 * the cmd in the sequencing

 it was never sent so just complete like normal */

	/*

	 * pre-format CmdSN for outgoing PDU.

		/*

		 * TODO: We always use immediate for normal session pdus.

		 * If we start to send tmfs or nops as non-immediate then

		 * we should start checking the cmdsn numbers for mgmt tasks.

		 *

		 * During discovery sessions iscsid sends TEXT as non immediate,

		 * but we always only send one PDU at a time.

		/*

		 * Login and Text are sent serially, in

		 * request-followed-by-response sequence.

		 * Same task can be used. Same ITT must be used.

		 * Note that login_task is preallocated at conn_create().

	/*

	 * released in complete pdu for task we expect a response for, and

	 * released by the lld when it has transmitted the task for

	 * pdus we do not expect a response for.

 regular RX path uses back_lock */

/**

 * iscsi_scsi_cmd_rsp - SCSI Command Response processing

 * @conn: iscsi connection

 * @hdr: iscsi header

 * @task: scsi command task

 * @data: cmd data buffer

 * @datalen: len of buffer

 *

 * iscsi_cmd_rsp sets up the scsi_cmnd fields based on the PDU and

 * then completes the command and task. called under back_lock

		/**

		 * Transports that didn't implement check_protection

		 * callback but still published T10-PI support to scsi-mid

		 * deserve this BUG_ON.

 write side for bidi or uni-io set_resid */

/**

 * iscsi_data_in_rsp - SCSI Data-In Response processing

 * @conn: iscsi connection

 * @hdr:  iscsi pdu

 * @task: scsi command task

 *

 * iscsi_data_in_rsp sets up the scsi_cmnd fields based on the data received

 * then completes the command and task. called under back_lock

 only track our nops */

/**

 * iscsi_nop_out_rsp - SCSI NOP Response processing

 * @task: scsi command task

 * @nop: the nop structure

 * @data: where to put the data

 * @datalen: length of data

 *

 * iscsi_nop_out_rsp handles nop response from use or

 * from user space. called under back_lock

		/*

		 * If this is not in response to one of our

		 * nops then it must be from userspace.

		/*

		 * We only send one TMF at a time so if the target could not

		 * handle it, then it should get fixed (RFC mandates that

		 * a target can handle one immediate TMF per conn).

		 *

		 * For nops-outs, we could have sent more than one if

		 * the target is sending us lots of nop-ins

			/*

			 * nop-out in response to target's nop-out rejected.

			 * Just resend.

 In RX path we are under back lock */

			/*

			 * Our nop as ping got dropped. We know the target

			 * and transport are ok so just clean up

/**

 * iscsi_itt_to_task - look up task by itt

 * @conn: iscsi connection

 * @itt: itt

 *

 * This should be used for mgmt tasks like login and nops, or if

 * the LDD's itt space does not include the session age.

 *

 * The session back_lock must be held.

/**

 * __iscsi_complete_pdu - complete pdu

 * @conn: iscsi conn

 * @hdr: iscsi header

 * @data: data buffer

 * @datalen: len of data buffer

 *

 * Completes pdu processing by freeing any resources allocated at

 * queuecommand or send generic. session back_lock must be held and verify

 * itt must have been called.

 In RX path we are under back lock */

		/*

		 * LLD handles R2Ts if they need to.

		/*

		 * login related PDU's exp_statsn is handled in

		 * userspace

/**

 * iscsi_itt_to_ctask - look up ctask by itt

 * @conn: iscsi connection

 * @itt: itt

 *

 * This should be used for cmd tasks.

 *

 * The session back_lock must be held.

	/*

	 * if the host is being removed bypass the connection

	 * recovery initialization because we are going to kill

	 * the session.

	/*

	 * Check for iSCSI window and take care of CmdSN wrap-around

 Take a ref so we can access it after xmit_task() */

 Already have a ref from when we failed to send it last call */

	/*

	 * If this was a requeue for a R2T we have an extra ref on the task in

	 * case a bad target sends a cmd rsp before we have handled the task.

	/*

	 * Do this after dropping the extra ref because if this was a requeue

	 * it's removed from that list and cleanup_queued_task would miss it.

		/*

		 * Save the task and ref in case we weren't cleaning up this

		 * task and get woken up again.

 done with this task */

 regular RX path uses back_lock */

		/*

		 * get an extra ref that is released next time we access it

		 * as conn->task above.

/**

 * iscsi_requeue_task - requeue task to run from session workqueue

 * @task: task to requeue

 *

 * Callers must have taken a ref to the task that is going to be requeued.

	/*

	 * this may be on the requeue list already if the xmit_task callout

	 * is handling the r2ts while we are adding new ones

		/*

		 * Don't need the extra ref since it's already requeued and

		 * has a ref.

/**

 * iscsi_data_xmit - xmit any command into the scheduled connection

 * @conn: iscsi connection

 *

 * Notes:

 *	The function can return -EAGAIN in which case the caller must

 *	re-schedule it again later or recover. '0' return code means

 *	successful xmit.

	/*

	 * process mgmt pdus like nops before commands since we should

	 * only have one nop-out as a ping from us and targets should not

	 * overflow us with nop-ins

 regular RX path uses back_lock */

 process pending command queue */

		/*

		 * we could continuously get new task requests so

		 * we need to check the mgmt queue for nops that need to

		 * be sent to aviod starvation

		/*

		 * we always do fastlogout - conn stop code will clean up.

	/*

	 * serialize Xmit worker on a per-connection basis.

		/*

		 * to handle the race between when we set the recovery state

		 * and block the session we requeue here (commands could

		 * be entering our queuecommand while a block is starting

		 * up because the block code is not locked)

			/*

			 * cmds should fail during shutdown, if the session

			 * state is bad, allowing completion to happen

 unblock eh_abort() */

	/*

	 * block eh thread until:

	 *

	 * 1) tmf response

	 * 2) tmf timeout

	 * 3) session is terminated or restarted or userspace has

	 * given up on recovery

 if the session drops it will clean up the task */

/*

 * Fail commands. session frwd lock held and xmit thread flushed.

/**

 * iscsi_suspend_queue - suspend iscsi_queuecommand

 * @conn: iscsi conn to stop queueing IO on

 *

 * This grabs the session frwd_lock to make sure no one is in

 * xmit_task/queuecommand, and then sets suspend to prevent

 * new commands from being queued. This only needs to be called

 * by offload drivers that need to sync a path like ep disconnect

 * with the iscsi_queuecommand/xmit_task. To start IO again libiscsi

 * will call iscsi_start_tx and iscsi_unblock_session when in FFP.

/**

 * iscsi_suspend_tx - suspend iscsi_data_xmit

 * @conn: iscsi conn tp stop processing IO on.

 *

 * This function sets the suspend bit to prevent iscsi_data_xmit

 * from sending new IO, and if work is queued on the xmit thread

 * it will wait for it to be completed.

/*

 * We want to make sure a ping is in flight. It has timed out.

 * And we are not busy processing a pdu that is making

 * progress but got started before the ping and is taking a while

 * to complete so the ping is just stuck behind it in a queue.

		/*

		 * Raced with completion. Blk layer has taken ownership

		 * so let timeout code complete it now.

		/*

		 * During shutdown, if session is prematurely disconnected,

		 * recovery won't happen and there will be hung cmds. Not

		 * handling cmds would trigger EH, also bad in this case.

		 * Instead, handle cmd, allow completion to happen and let

		 * upper layer to deal with the result.

		/*

		 * We are probably in the middle of iscsi recovery so let

		 * that complete and handle the error.

 In the middle of shuting down */

	/*

	 * If we have sent (at least queued to the network layer) a pdu or

	 * recvd one for the task since the last timeout ask for

	 * more time. If on the next timeout we have not made progress

	 * we can check if it is the task or connection when we send the

	 * nop as a ping.

	/*

	 * if the ping timedout then we are in the middle of cleaning up

	 * and can let the iscsi eh handle it

		/*

		 * Only check if cmds started before this one have made

		 * progress, or this could never fail

			/*

			 * This task has not made progress, but a task

			 * started before us has transferred data since

			 * we started/last-checked. We could be queueing

			 * too many tasks or the LU is bad.

			 *

			 * If the device is bad the cmds ahead of us on

			 * other devs will complete, and this loop will

			 * eventually fail starting the scsi eh.

 Assumes nop timeout is shorter than scsi cmd timeout */

	/*

	 * Checking the transport already or nop from a cmd timeout still

	 * running

 Make sure there is a transport check done */

 send a ping to try to provoke some traffic */

/**

 * iscsi_conn_unbind - prevent queueing to conn.

 * @cls_conn: iscsi conn ep is bound to.

 * @is_active: is the conn in use for boot or is this for EH/termination

 *

 * This must be called by drivers implementing the ep_disconnect callout.

 * It disables queueing to the connection from libiscsi in preparation for

 * an ep_disconnect call.

	/*

	 * Wait for iscsi_eh calls to exit. We don't wait for the tmf to

	 * complete or timeout. The caller just wants to know what's running

	 * is everything that needs to be cleaned up, and no cmds will be

	 * queued.

		/*

		 * if logout timed out before userspace could even send a PDU

		 * the state might still be in ISCSI_STATE_LOGGED_IN and

		 * allowing new cmds and TMFs.

	/*

	 * if session was ISCSI_STATE_IN_RECOVERY then we may not have

	 * got the command.

	/*

	 * If we are not logged in or we have started a new session

	 * then let the host reset code handle this

 task completed before time out */

 only have one tmf outstanding at a time */

		/*

		 * stop tx side incase the target had sent a abort rsp but

		 * the initiator was still writing out data.

		/*

		 * we do not stop the recv side because targets have been

		 * good and have never sent us a successful tmf response

		 * then sent more data for the cmd.

 task completed before tmf abort response */

	/*

	 * The driver might be accessing the task so hold the ref. The conn

	 * stop cleanup will drop the ref after ep_disconnect so we know the

	 * driver's no longer touching the task.

	/*

	 * Just check if we are not logged in. We cannot check for

	 * the phase because the reset could come from a ioctl.

 only have one tmf outstanding at a time */

/**

 * iscsi_eh_session_reset - drop session and attempt relogin

 * @sc: scsi command

 *

 * This function will wait for a relogin, session termination from

 * userspace, or a recovery/replacement timeout.

/**

 * iscsi_eh_target_reset - reset target

 * @sc: scsi command

 *

 * This will attempt to send a warm target reset.

	/*

	 * Just check if we are not logged in. We cannot check for

	 * the phase because the reset could come from a ioctl.

 only have one tmf outstanding at a time */

/**

 * iscsi_eh_recover_target - reset target and possibly the session

 * @sc: scsi command

 *

 * This will attempt to send a warm target reset. If that fails,

 * we will escalate to ERL0 session recovery.

/*

 * Pre-allocate a pool of @max items of @item_size. By default, the pool

 * should be accessed via kfifo_{get,put} on q->queue.

 * Optionally, the caller can obtain the array of object pointers

 * by passing in a non-NULL @items pointer

	/* If the user passed an items pointer, he wants a copy of

	/*

	 * The iscsi layer needs some tasks for nop handling and tmfs,

	 * so the cmds_max must at least be greater than ISCSI_MGMT_CMDS_MAX

	 * + 1 command for scsi IO.

/**

 * iscsi_host_add - add host to system

 * @shost: scsi host

 * @pdev: parent device

 *

 * This should be called by partial offload and software iscsi drivers

 * to add a host to the system.

/**

 * iscsi_host_alloc - allocate a host and driver data

 * @sht: scsi host template

 * @dd_data_size: driver host data size

 * @xmit_can_sleep: bool indicating if LLD will queue IO from a work queue

 *

 * This should be called by partial offload and software iscsi drivers.

 * To access the driver specific memory use the iscsi_host_priv() macro.

/**

 * iscsi_host_remove - remove host and sessions

 * @shost: scsi host

 *

 * If there are any sessions left, this will initiate the removal and wait

 * for the completion.

/**

 * iscsi_session_setup - create iscsi cls session and host and session

 * @iscsit: iscsi transport template

 * @shost: scsi host

 * @cmds_max: session can queue

 * @dd_size: private driver data size, added to session allocation size

 * @cmd_task_size: LLD task private data size

 * @initial_cmdsn: initial CmdSN

 * @id: target ID to add to this session

 *

 * This can be used by software iscsi_transports that allocate

 * a session per scsi host.

 *

 * Callers should set cmds_max to the largest total numer (mgmt + scsi) of

 * tasks they support. The iscsi layer reserves ISCSI_MGMT_CMDS_MAX tasks

 * for nop handling and login/logout requests.

 initialize SCSI PDU commands pool */

 pre-format cmds pool with ITT */

/**

 * iscsi_session_teardown - destroy session, host, and cls_session

 * @cls_session: iscsi session

/**

 * iscsi_conn_setup - create iscsi_cls_conn and iscsi_conn

 * @cls_session: iscsi_cls_session

 * @dd_size: private driver data size

 * @conn_idx: cid

 allocate login_task used for the login/text sequences */

/**

 * iscsi_conn_teardown - teardown iscsi connection

 * @cls_conn: iscsi class connection

 *

 * TODO: we may need to make this into a two step process

 * like scsi-mls remove + put host

		/*

		 * leading connection? then give up on recovery.

 flush queued up work because we free the connection below */

 regular RX path uses back_lock */

		/*

		 * unblock eh_abort() if it is blocked. re-try all

		 * commands after successful recovery

	/*

	 * When this is called for the in_login state, we only want to clean

	 * up the login task and connection. We do not need to block and set

	 * the recovery state again

	/*

	 * for connection level recovery we should not calculate

	 * header digest. conn->hdr_size used for optimization

	 * in hdr_extract() and will be re-negotiated at

	 * set_param() time.

	/*

	 * flush queues.

	/*

	 * The target could have reduced it's window size between logins, so

	 * we have to reset max/exp cmdsn so we can see the new values.

	/*

	 * Unblock xmitworker(), Login Phase will pass through.

 SPDX-License-Identifier: GPL-2.0

/*

 * scsi_dev_info_list: structure to hold black/white listed devices.

 for use with scsi_static_device_list entries */

 our node for being on the master list */

 head of dev info list */

 name of list for /proc (NULL for global) */

 unique numeric identifier */

/*

 * scsi_static_device_list: deprecated list of devices that require

 * settings that differ from the default, includes black-listed (broken)

 * devices. The entries here are added to the tail of scsi_dev_info_list

 * via scsi_dev_info_list_init.

 *

 * Do not add to this list, use the command line or proc interface to add

 * to the scsi_dev_info_list. This table will eventually go away.

 revision known to be bad, unused */

	/*

	 * The following devices are known not to tolerate a lun != 0 scan

	 * for one reason or another. Some will respond to all luns,

	 * others will lock up.

 locks up */

 locks up */

 locks up */

 locks up */

 responds to all lun */

 responds to all lun */

 locks up */

 locks up */

 locks up */

 locks up */

 locks up */

 locks up */

 locks up */

 locks up */

 responds to all lun */

 responds to all lun */

 locks up */

 responds to all lun */

 locks up */

 responds to all luns */

	/*

	 * The following causes a failed REQUEST SENSE on lun 1 for

	 * aha152x controller, which causes SCSI code to reset bus.

	/*

	 * The following causes a failed REQUEST SENSE on lun 1 for

	 * aha152x controller, which causes SCSI code to reset bus.

 responds to all lun */

 responds to all lun */

 locks up */

 locks up */

	/*

	 * The following causes a failed REQUEST SENSE on lun 1 for

	 * seagate controller, which causes SCSI code to reset bus.

 responds to all lun */

	/*

	 * The following causes a failed REQUEST SENSE on lun 1 for

	 * seagate controller, which causes SCSI code to reset bus.

 scanjet iic */

 scanjet iip */

 scanjet iicx */

 locks up */

 responds to all lun */

 locks up */

 locks up */

 locks up */

 locks up */

 responds to all lun */

 causes failed REQ SENSE, extra reset */

 locks up */

 locks up */

 locks up */

 locks up */

 responds to all lun */

	/*

	 * Other types of devices that have special flags.

	 * Note that all USB devices should have the BLIST_INQUIRY_36 flag.

 CMD RAID Controller */

 Chaparral G7324 RAID */

 Chaparral G8324 RAID */

 Compaq RA4x00 */

 Compaq RA4x00 */

 Dell PV 530F */

 EMC CLARiiON, storage on LUN 0 */

 EMC CLARiiON, no storage on LUN 0 */

 FW: 0180 and 0207 */

 HP VA7400 */

 HP XP Arrays */

 Chokes on tagged INQUIRY */

 DDS3 & DDS4 autoloaders */

 locks up */

/*

 * scsi_strcpy_devinfo: called from scsi_dev_info_list_add to copy into

 * devinfo vendor and model strings.

 This zero-pads the destination */

		/*

		 * space pad the string if it is short.

/**

 * scsi_dev_info_list_add - add one dev_info list entry.

 * @compatible: if true, null terminate short strings.  Otherwise space pad.

 * @vendor:	vendor string

 * @model:	model (product) string

 * @strflags:	integer string

 * @flags:	if strflags NULL, use this flag value

 *

 * Description:

 *	Create and add one dev_info entry for @vendor, @model, @strflags or

 *	@flag. If @compatible, add to the tail of the list, do not space

 *	pad, and set devinfo->compatible. The scsi_static_device_list entries

 *	are added with @compatible 1 and @clfags NULL.

 *

 * Returns: 0 OK, -error on failure.

/**

 * scsi_dev_info_list_add_keyed - add one dev_info list entry.

 * @compatible: if true, null terminate short strings.  Otherwise space pad.

 * @vendor:	vendor string

 * @model:	model (product) string

 * @strflags:	integer string

 * @flags:	if strflags NULL, use this flag value

 * @key:	specify list to use

 *

 * Description:

 *	Create and add one dev_info entry for @vendor, @model,

 *	@strflags or @flag in list specified by @key. If @compatible,

 *	add to the tail of the list, do not space pad, and set

 *	devinfo->compatible. The scsi_static_device_list entries are

 *	added with @compatible 1 and @clfags NULL.

 *

 * Returns: 0 OK, -error on failure.

/**

 * scsi_dev_info_list_find - find a matching dev_info list entry.

 * @vendor:	full vendor string

 * @model:	full model (product) string

 * @key:	specify list to use

 *

 * Description:

 *	Finds the first dev_info entry matching @vendor, @model

 *	in list specified by @key.

 *

 * Returns: pointer to matching entry, or ERR_PTR on failure.

 Prepare for "compatible" matches */

	/*

	 * XXX why skip leading spaces? If an odd INQUIRY

	 * value, that should have been part of the

	 * scsi_static_device_list[] entry, such as "  FOO"

	 * rather than "FOO". Since this code is already

	 * here, and we don't know what device it is

	 * trying to work with, leave it as-is.

 Also skip trailing spaces */

			/*

			 * vendor strings must be an exact match

			/*

			 * @model specifies the full string, and

			 * must be larger or equal to devinfo->model

/**

 * scsi_dev_info_list_del_keyed - remove one dev_info list entry.

 * @vendor:	vendor string

 * @model:	model (product) string

 * @key:	specify list to use

 *

 * Description:

 *	Remove and destroy one dev_info entry for @vendor, @model

 *	in list specified by @key.

 *

 * Returns: 0 OK, -error on failure.

/**

 * scsi_dev_info_list_add_str - parse dev_list and add to the scsi_dev_info_list.

 * @dev_list:	string of device flags to add

 *

 * Description:

 *	Parse dev_list, and add entries to the scsi_dev_info_list.

 *	dev_list is of the form "vendor:product:flag,vendor:product:flag".

 *	dev_list is modified via strsep. Can be called for command line

 *	addition, for proc or mabye a sysfs interface.

 *

 * Returns: 0 if OK, -error on failure.

		/*

		 * Ignore both the leading and trailing quote.

	/*

	 * For the leading and trailing '"' case, the for loop comes

	 * through the last time with vendor[0] == '\0'.

 compatible */, vendor,

/**

 * scsi_get_device_flags - get device specific flags from the dynamic

 *	device list.

 * @sdev:       &scsi_device to get flags for

 * @vendor:	vendor name

 * @model:	model name

 *

 * Description:

 *     Search the global scsi_dev_info_list (specified by list zero)

 *     for an entry matching @vendor and @model, if found, return the

 *     matching flags value, else return the host or global default

 *     settings.  Called during scan time.

/**

 * scsi_get_device_flags_keyed - get device specific flags from the dynamic device list

 * @sdev:       &scsi_device to get flags for

 * @vendor:	vendor name

 * @model:	model name

 * @key:	list to look up

 *

 * Description:

 *     Search the scsi_dev_info_list specified by @key for an entry

 *     matching @vendor and @model, if found, return the matching

 *     flags value, else return the host or global default settings.

 *     Called during scan time.

 key or device not found: return nothing */

 except for the global list, where we have an exception */

/*

 * proc_scsi_dev_info_write - allow additions to scsi_dev_info_list via /proc.

 *

 * Description: Adds a black/white list entry for vendor and model with an

 * integer value of flag to the scsi device info list.

 * To use, echo "vendor:model:flag" > /proc/scsi/device_info

 CONFIG_SCSI_PROC_FS */

/**

 * scsi_exit_devinfo - remove /proc/scsi/device_info & the scsi_dev_info_list

/**

 * scsi_dev_info_add_list - add a new devinfo list

 * @key:	key of the list to add

 * @name:	Name of the list to add (for /proc/scsi/device_info)

 *

 * Adds the requested list, returns zero on success, -EEXIST if the

 * key is already registered to a list, or other error on failure.

 list already exists */

/**

 * scsi_dev_info_remove_list - destroy an added devinfo list

 * @key: key of the list to destroy

 *

 * Iterates over the entire list first, freeing all the values, then

 * frees the list itself.  Returns 0 on success or -EINVAL if the key

 * can't be found.

 no such list */

 remove from the master list */

/**

 * scsi_init_devinfo - set up the dynamic device list.

 *

 * Description:

 *	Add command line entries from scsi_dev_flags, then add

 *	scsi_static_device_list entries to the scsi device info list.

 compatibile */,

 CONFIG_SCSI_PROC_FS */

 SPDX-License-Identifier: GPL-2.0-or-later

/******************************************************************************

*                  QLOGIC LINUX SOFTWARE

*

* QLogic  QLA1280 (Ultra2)  and  QLA12160 (Ultra3) SCSI driver

* Copyright (C) 2000 Qlogic Corporation (www.qlogic.com)

* Copyright (C) 2001-2004 Jes Sorensen, Wild Open Source Inc.

* Copyright (C) 2003-2004 Christoph Hellwig

*

/*****************************************************************************

    Revision History:

    Rev  3.27.1, February 8, 2010, Michael Reed

	- Retain firmware image for error recovery.

    Rev  3.27, February 10, 2009, Michael Reed

	- General code cleanup.

	- Improve error recovery.

    Rev  3.26, January 16, 2006 Jes Sorensen

	- Ditch all < 2.6 support

    Rev  3.25.1, February 10, 2005 Christoph Hellwig

	- use pci_map_single to map non-S/G requests

	- remove qla1280_proc_info

    Rev  3.25, September 28, 2004, Christoph Hellwig

	- add support for ISP1020/1040

	- don't include "scsi.h" anymore for 2.6.x

    Rev  3.24.4 June 7, 2004 Christoph Hellwig

	- restructure firmware loading, cleanup initialization code

	- prepare support for ISP1020/1040 chips

    Rev  3.24.3 January 19, 2004, Jes Sorensen

	- Handle PCI DMA mask settings correctly

	- Correct order of error handling in probe_one, free_irq should not

	  be called if request_irq failed

    Rev  3.24.2 January 19, 2004, James Bottomley & Andrew Vasquez

	- Big endian fixes (James)

	- Remove bogus IOCB content on zero data transfer commands (Andrew)

    Rev  3.24.1 January 5, 2004, Jes Sorensen

	- Initialize completion queue to avoid OOPS on probe

	- Handle interrupts during mailbox testing

    Rev  3.24 November 17, 2003, Christoph Hellwig

    	- use struct list_head for completion queue

	- avoid old Scsi_FOO typedefs

	- cleanup 2.4 compat glue a bit

	- use <scsi/scsi_*.h> headers on 2.6 instead of "scsi.h"

	- make initialization for memory mapped vs port I/O more similar

	- remove broken pci config space manipulation

	- kill more cruft

	- this is an almost perfect 2.6 scsi driver now! ;)

    Rev  3.23.39 December 17, 2003, Jes Sorensen

	- Delete completion queue from srb if mailbox command failed to

	  to avoid qla1280_done completeting qla1280_error_action's

	  obsolete context

	- Reduce arguments for qla1280_done

    Rev  3.23.38 October 18, 2003, Christoph Hellwig

	- Convert to new-style hotplugable driver for 2.6

	- Fix missing scsi_unregister/scsi_host_put on HBA removal

	- Kill some more cruft

    Rev  3.23.37 October 1, 2003, Jes Sorensen

	- Make MMIO depend on CONFIG_X86_VISWS instead of yet another

	  random CONFIG option

	- Clean up locking in probe path

    Rev  3.23.36 October 1, 2003, Christoph Hellwig

	- queuecommand only ever receives new commands - clear flags

	- Reintegrate lost fixes from Linux 2.5

    Rev  3.23.35 August 14, 2003, Jes Sorensen

	- Build against 2.6

    Rev  3.23.34 July 23, 2003, Jes Sorensen

	- Remove pointless TRUE/FALSE macros

	- Clean up vchan handling

    Rev  3.23.33 July 3, 2003, Jes Sorensen

	- Don't define register access macros before define determining MMIO.

	  This just happened to work out on ia64 but not elsewhere.

	- Don't try and read from the card while it is in reset as

	  it won't respond and causes an MCA

    Rev  3.23.32 June 23, 2003, Jes Sorensen

	- Basic support for boot time arguments

    Rev  3.23.31 June 8, 2003, Jes Sorensen

	- Reduce boot time messages

    Rev  3.23.30 June 6, 2003, Jes Sorensen

	- Do not enable sync/wide/ppr before it has been determined

	  that the target device actually supports it

	- Enable DMA arbitration for multi channel controllers

    Rev  3.23.29 June 3, 2003, Jes Sorensen

	- Port to 2.5.69

    Rev  3.23.28 June 3, 2003, Jes Sorensen

	- Eliminate duplicate marker commands on bus resets

	- Handle outstanding commands appropriately on bus/device resets

    Rev  3.23.27 May 28, 2003, Jes Sorensen

	- Remove bogus input queue code, let the Linux SCSI layer do the work

	- Clean up NVRAM handling, only read it once from the card

	- Add a number of missing default nvram parameters

    Rev  3.23.26 Beta May 28, 2003, Jes Sorensen

	- Use completion queue for mailbox commands instead of busy wait

    Rev  3.23.25 Beta May 27, 2003, James Bottomley

	- Migrate to use new error handling code

    Rev  3.23.24 Beta May 21, 2003, James Bottomley

	- Big endian support

	- Cleanup data direction code

    Rev  3.23.23 Beta May 12, 2003, Jes Sorensen

	- Switch to using MMIO instead of PIO

    Rev  3.23.22 Beta April 15, 2003, Jes Sorensen

	- Fix PCI parity problem with 12160 during reset.

    Rev  3.23.21 Beta April 14, 2003, Jes Sorensen

	- Use pci_map_page()/pci_unmap_page() instead of map_single version.

    Rev  3.23.20 Beta April 9, 2003, Jes Sorensen

	- Remove < 2.4.x support

	- Introduce HOST_LOCK to make the spin lock changes portable.

	- Remove a bunch of idiotic and unnecessary typedef's

	- Kill all leftovers of target-mode support which never worked anyway

    Rev  3.23.19 Beta April 11, 2002, Linus Torvalds

	- Do qla1280_pci_config() before calling request_irq() and

	  request_region()

	- Use pci_dma_hi32() to handle upper word of DMA addresses instead

	  of large shifts

	- Hand correct arguments to free_irq() in case of failure

    Rev  3.23.18 Beta April 11, 2002, Jes Sorensen

	- Run source through Lindent and clean up the output

    Rev  3.23.17 Beta April 11, 2002, Jes Sorensen

	- Update SCSI firmware to qla1280 v8.15.00 and qla12160 v10.04.32

    Rev  3.23.16 Beta March 19, 2002, Jes Sorensen

	- Rely on mailbox commands generating interrupts - do not

	  run qla1280_isr() from ql1280_mailbox_command()

	- Remove device_reg_t

	- Integrate ql12160_set_target_parameters() with 1280 version

	- Make qla1280_setup() non static

	- Do not call qla1280_check_for_dead_scsi_bus() on every I/O request

	  sent to the card - this command pauses the firmware!!!

    Rev  3.23.15 Beta March 19, 2002, Jes Sorensen

	- Clean up qla1280.h - remove obsolete QL_DEBUG_LEVEL_x definitions

	- Remove a pile of pointless and confusing (srb_t **) and

	  (scsi_lu_t *) typecasts

	- Explicit mark that we do not use the new error handling (for now)

	- Remove scsi_qla_host_t and use 'struct' instead

	- Remove in_abort, watchdog_enabled, dpc, dpc_sched, bios_enabled,

	  pci_64bit_slot flags which weren't used for anything anyway

	- Grab host->host_lock while calling qla1280_isr() from abort()

	- Use spin_lock()/spin_unlock() in qla1280_intr_handler() - we

	  do not need to save/restore flags in the interrupt handler

	- Enable interrupts early (before any mailbox access) in preparation

	  for cleaning up the mailbox handling

    Rev  3.23.14 Beta March 14, 2002, Jes Sorensen

	- Further cleanups. Remove all trace of QL_DEBUG_LEVEL_x and replace

	  it with proper use of dprintk().

	- Make qla1280_print_scsi_cmd() and qla1280_dump_buffer() both take

	  a debug level argument to determine if data is to be printed

	- Add KERN_* info to printk()

    Rev  3.23.13 Beta March 14, 2002, Jes Sorensen

	- Significant cosmetic cleanups

	- Change debug code to use dprintk() and remove #if mess

    Rev  3.23.12 Beta March 13, 2002, Jes Sorensen

	- More cosmetic cleanups, fix places treating return as function

	- use cpu_relax() in qla1280_debounce_register()

    Rev  3.23.11 Beta March 13, 2002, Jes Sorensen

	- Make it compile under 2.5.5

    Rev  3.23.10 Beta October 1, 2001, Jes Sorensen

	- Do no typecast short * to long * in QL1280BoardTbl, this

	  broke miserably on big endian boxes

    Rev  3.23.9 Beta September 30, 2001, Jes Sorensen

	- Remove pre 2.2 hack for checking for reentrance in interrupt handler

	- Make data types used to receive from SCSI_{BUS,TCN,LUN}_32

	  unsigned int to match the types from struct scsi_cmnd

    Rev  3.23.8 Beta September 29, 2001, Jes Sorensen

	- Remove bogus timer_t typedef from qla1280.h

	- Remove obsolete pre 2.2 PCI setup code, use proper #define's

	  for PCI_ values, call pci_set_master()

	- Fix memleak of qla1280_buffer on module unload

	- Only compile module parsing code #ifdef MODULE - should be

	  changed to use individual MODULE_PARM's later

	- Remove dummy_buffer that was never modified nor printed

	- ENTER()/LEAVE() are noops unless QL_DEBUG_LEVEL_3, hence remove

	  #ifdef QL_DEBUG_LEVEL_3/#endif around ENTER()/LEAVE() calls

	- Remove \r from print statements, this is Linux, not DOS

	- Remove obsolete QLA1280_{SCSILU,INTR,RING}_{LOCK,UNLOCK}

	  dummy macros

	- Remove C++ compile hack in header file as Linux driver are not

	  supposed to be compiled as C++

	- Kill MS_64BITS macro as it makes the code more readable

	- Remove unnecessary flags.in_interrupts bit

    Rev  3.23.7 Beta August 20, 2001, Jes Sorensen

	- Dont' check for set flags on q->q_flag one by one in qla1280_next()

        - Check whether the interrupt was generated by the QLA1280 before

          doing any processing

	- qla1280_status_entry(): Only zero out part of sense_buffer that

	  is not being copied into

	- Remove more superflouous typecasts

	- qla1280_32bit_start_scsi() replace home-brew memcpy() with memcpy()

    Rev  3.23.6 Beta August 20, 2001, Tony Luck, Intel

        - Don't walk the entire list in qla1280_putq_t() just to directly

	  grab the pointer to the last element afterwards

    Rev  3.23.5 Beta August 9, 2001, Jes Sorensen

	- Don't use IRQF_DISABLED, it's use is deprecated for this kinda driver

    Rev  3.23.4 Beta August 8, 2001, Jes Sorensen

	- Set dev->max_sectors to 1024

    Rev  3.23.3 Beta August 6, 2001, Jes Sorensen

	- Provide compat macros for pci_enable_device(), pci_find_subsys()

	  and scsi_set_pci_device()

	- Call scsi_set_pci_device() for all devices

	- Reduce size of kernel version dependent device probe code

	- Move duplicate probe/init code to separate function

	- Handle error if qla1280_mem_alloc() fails

	- Kill OFFSET() macro and use Linux's PCI definitions instead

        - Kill private structure defining PCI config space (struct config_reg)

	- Only allocate I/O port region if not in MMIO mode

	- Remove duplicate (unused) sanity check of sife of srb_t

    Rev  3.23.2 Beta August 6, 2001, Jes Sorensen

	- Change home-brew memset() implementations to use memset()

        - Remove all references to COMTRACE() - accessing a PC's COM2 serial

          port directly is not legal under Linux.

    Rev  3.23.1 Beta April 24, 2001, Jes Sorensen

        - Remove pre 2.2 kernel support

        - clean up 64 bit DMA setting to use 2.4 API (provide backwards compat)

        - Fix MMIO access to use readl/writel instead of directly

          dereferencing pointers

        - Nuke MSDOS debugging code

        - Change true/false data types to int from uint8_t

        - Use int for counters instead of uint8_t etc.

        - Clean up size & byte order conversion macro usage

    Rev  3.23 Beta January 11, 2001 BN Qlogic

        - Added check of device_id when handling non

          QLA12160s during detect().

    Rev  3.22 Beta January 5, 2001 BN Qlogic

        - Changed queue_task() to schedule_task()

          for kernels 2.4.0 and higher.

          Note: 2.4.0-testxx kernels released prior to

                the actual 2.4.0 kernel release on January 2001

                will get compile/link errors with schedule_task().

                Please update your kernel to released 2.4.0 level,

                or comment lines in this file flagged with  3.22

                to resolve compile/link error of schedule_task().

        - Added -DCONFIG_SMP in addition to -D__SMP__

          in Makefile for 2.4.0 builds of driver as module.

    Rev  3.21 Beta January 4, 2001 BN Qlogic

        - Changed criteria of 64/32 Bit mode of HBA

          operation according to BITS_PER_LONG rather

          than HBA's NVRAM setting of >4Gig memory bit;

          so that the HBA auto-configures without the need

          to setup each system individually.

    Rev  3.20 Beta December 5, 2000 BN Qlogic

        - Added priority handling to IA-64  onboard SCSI

          ISP12160 chip for kernels greater than 2.3.18.

        - Added irqrestore for qla1280_intr_handler.

        - Enabled /proc/scsi/qla1280 interface.

        - Clear /proc/scsi/qla1280 counters in detect().

    Rev  3.19 Beta October 13, 2000 BN Qlogic

        - Declare driver_template for new kernel

          (2.4.0 and greater) scsi initialization scheme.

        - Update /proc/scsi entry for 2.3.18 kernels and

          above as qla1280

    Rev  3.18 Beta October 10, 2000 BN Qlogic

        - Changed scan order of adapters to map

          the QLA12160 followed by the QLA1280.

    Rev  3.17 Beta September 18, 2000 BN Qlogic

        - Removed warnings for 32 bit 2.4.x compiles

        - Corrected declared size for request and response

          DMA addresses that are kept in each ha

    Rev. 3.16 Beta  August 25, 2000   BN  Qlogic

        - Corrected 64 bit addressing issue on IA-64

          where the upper 32 bits were not properly

          passed to the RISC engine.

    Rev. 3.15 Beta  August 22, 2000   BN  Qlogic

        - Modified qla1280_setup_chip to properly load

          ISP firmware for greater that 4 Gig memory on IA-64

    Rev. 3.14 Beta  August 16, 2000   BN  Qlogic

        - Added setting of dma_mask to full 64 bit

          if flags.enable_64bit_addressing is set in NVRAM

    Rev. 3.13 Beta  August 16, 2000   BN  Qlogic

        - Use new PCI DMA mapping APIs for 2.4.x kernel

    Rev. 3.12       July 18, 2000    Redhat & BN Qlogic

        - Added check of pci_enable_device to detect() for 2.3.x

        - Use pci_resource_start() instead of

          pdev->resource[0].start in detect() for 2.3.x

        - Updated driver version

    Rev. 3.11       July 14, 2000    BN  Qlogic

	- Updated SCSI Firmware to following versions:

	  qla1x80:   8.13.08

	  qla1x160:  10.04.08

	- Updated driver version to 3.11

    Rev. 3.10    June 23, 2000   BN Qlogic

        - Added filtering of AMI SubSys Vendor ID devices

    Rev. 3.9

        - DEBUG_QLA1280 undefined and  new version  BN Qlogic

    Rev. 3.08b      May 9, 2000    MD Dell

        - Added logic to check against AMI subsystem vendor ID

	Rev. 3.08       May 4, 2000    DG  Qlogic

        - Added logic to check for PCI subsystem ID.

	Rev. 3.07       Apr 24, 2000    DG & BN  Qlogic

	   - Updated SCSI Firmware to following versions:

	     qla12160:   10.01.19

		 qla1280:     8.09.00

	Rev. 3.06       Apr 12, 2000    DG & BN  Qlogic

	   - Internal revision; not released

    Rev. 3.05       Mar 28, 2000    DG & BN  Qlogic

       - Edit correction for virt_to_bus and PROC.

    Rev. 3.04       Mar 28, 2000    DG & BN  Qlogic

       - Merge changes from ia64 port.

    Rev. 3.03       Mar 28, 2000    BN  Qlogic

       - Increase version to reflect new code drop with compile fix

         of issue with inclusion of linux/spinlock for 2.3 kernels

    Rev. 3.02       Mar 15, 2000    BN  Qlogic

       - Merge qla1280_proc_info from 2.10 code base

    Rev. 3.01       Feb 10, 2000    BN  Qlogic

       - Corrected code to compile on a 2.2.x kernel.

    Rev. 3.00       Jan 17, 2000    DG  Qlogic

	   - Added 64-bit support.

    Rev. 2.07       Nov 9, 1999     DG  Qlogic

	   - Added new routine to set target parameters for ISP12160.

    Rev. 2.06       Sept 10, 1999     DG  Qlogic

       - Added support for ISP12160 Ultra 3 chip.

    Rev. 2.03       August 3, 1999    Fred Lewis, Intel DuPont

	- Modified code to remove errors generated when compiling with

	  Cygnus IA64 Compiler.

        - Changed conversion of pointers to unsigned longs instead of integers.

        - Changed type of I/O port variables from uint32_t to unsigned long.

        - Modified OFFSET macro to work with 64-bit as well as 32-bit.

        - Changed sprintf and printk format specifiers for pointers to %p.

        - Changed some int to long type casts where needed in sprintf & printk.

        - Added l modifiers to sprintf and printk format specifiers for longs.

        - Removed unused local variables.

    Rev. 1.20       June 8, 1999      DG,  Qlogic

         Changes to support RedHat release 6.0 (kernel 2.2.5).

       - Added SCSI exclusive access lock (io_request_lock) when accessing

         the adapter.

       - Added changes for the new LINUX interface template. Some new error

         handling routines have been added to the template, but for now we

         will use the old ones.

    -   Initial Beta Release.

/*

 * Compile time Options:

 *            0 - Disable and 1 - Enable

 2 microseconds */

/*

 *  QLogic Driver Support Function Prototypes.

/*

 *  QLogic ISP1280 Hardware Support Function Prototypes.

/*

 * convert scsi data direction to request_t control flags

	/*

	 * We could BUG() on default here if one of the four cases aren't

	 * met, but then again if we receive something like that from the

	 * SCSI layer we have more serious problems. This shuts up GCC.

/*

 * insmod needs to find the variable and make it point to something

 insmod qla1280 options=verbose" */

/*

 * We use the scsi_pointer structure that's included with each scsi_command

 * to overlay our struct srb over it. qla1280_init() checks that a srb is not

 * bigger than a scsi_pointer.

****************************************/

   ISP Boards supported by this driver */

****************************************/

 Board ID String */

 Number of SCSI ports */

 index into qla1280_fw_tbl for firmware */

 NOTE: the last argument in each entry is used to index ql1280_board_tbl */

 image 0 */

 image 1 */

 image 2 */

 NOTE: Order of boards in this table must match order in qla1280_pci_tbl */

	/* The firmware interface is, um, interesting, in that the

	 * actual firmware image on the chip is little endian, thus,

	 * the process of taking that image to the CPU would end up

	 * little endian.  However, the firmware interface requires it

	 * to be read a word (two bytes) at a time.

	 *

	 * The net result of this would be that the word (and

	 * doubleword) quantities in the firmware would be correct, but

	 * the bytes would be pairwise reversed.  Since most of the

	 * firmware quantities are, in fact, bytes, we do an extra

	 * le16_to_cpu() in the firmware read routine.

	 *

	 * The upshot of all this is that the bytes in the firmware

	 * are in the correct places, but the 16 and 32 bit quantities

	 * are still in little endian format.  We fix that up below by

/**************************************************************************

 *   qla1280_info

 *     Return a string describing the driver.

/**************************************************************************

 *   qla1280_queuecommand

 *     Queue a command to the controller.

 *

 * Note:

 * The mid-level driver tries to ensures that queuecommand never gets invoked

 * concurrently with itself or the interrupt handler (although the

 * interrupt handler may call this routine as part of request-completion

 * handling).   Unfortunately, it sometimes calls the scheduler in interrupt

 * context which is a big NO! NO!.

	/*

	 * Using 64 bit commands if the PCI bridge doesn't support it is a

	 * bit wasteful, however this should really only happen if one's

	 * PCI controller is completely broken, like the BCM1250. For

	 * sane hardware this is not an issue.

	/*

	 * Wait for all commands with the designated bus/target

	 * to be completed by the firmware

/**************************************************************************

 * qla1280_error_action

 *    The function will attempt to perform a specified error action and

 *    wait for the results (or time out).

 *

 * Input:

 *      cmd = Linux SCSI command packet of the command that cause the

 *            bus reset.

 *      action = error action to take (see action_t)

 *

 * Returns:

 *      SUCCESS or FAILED

 *

	/*

	 * Check to see if we have the command in the outstanding_cmds[]

	 * array.  If not then it must have completed before this error

	 * action was initiated.  If the error_action isn't ABORT_COMMAND

	 * then the driver must proceed with the requested action.

 we'll wait for it to complete */

 driver doesn't have command */

		/*

		 * The abort might fail due to race when the host_lock

		 * is released to issue the abort.  As such, we

		 * don't bother to check the return status.

 issued device reset, set wait conditions */

 issued bus reset, set wait conditions */

 it's dead */

	/*

	 * At this point, the host_lock has been released and retaken

	 * by the issuance of the mailbox command.

	 * Wait for the command passed in by the mid-layer if it

	 * was found by the driver.  It might have been returned

	 * between eh recovery steps, hence the check of the "found"

	 * variable.

	/*

	 * If the command passed in by the mid-layer has been

	 * returned by the board, then wait for any additional

	 * commands which are supposed to complete based upon

	 * the error action.

	 *

	 * All commands are unconditionally returned during a

	 * call to qla1280_abort_isp(), ADAPTER_RESET.  No need

	 * to wait for them.

/**************************************************************************

 *   qla1280_abort

 *     Abort the specified SCSI command(s).

/**************************************************************************

 *   qla1280_device_reset

 *     Reset the specified SCSI device

/**************************************************************************

 *   qla1280_bus_reset

 *     Reset the specified bus.

/**************************************************************************

 *   qla1280_adapter_reset

 *     Reset the specified adapter (both channels)

		/* if (cylinders > 1023)

 disable risc and host interrupts */

 PCI Posted Write flush */

 enable risc and host interrupts */

 PCI Posted Write flush */

/**************************************************************************

 * qla1280_intr_handler

 *   Handles the H/W interrupt

 Check for pending interrupts. */

 Set Target Parameters. */

 Set Device Queue Parameters. */

/**************************************************************************

 *   qla1280_slave_configure

 *

 * Description:

 *   Determines the queue depth for a given device.  There are two ways

 *   a queue depth can be obtained for a tagged queueing device.  One

 *   way is the default queue depth which is determined by whether

 *   If it is defined, then it is used

 *   as the default queue depth.  Otherwise, we use either 4 or 8 as the

 *   default queue depth (dependent on the number of hardware SCBs).

/*

 * qla1280_done

 *      Process completed commands.

 *

 * Input:

 *      ha           = adapter block pointer.

 Issue marker command. */

 Release memory used for this I/O */

 Call the mid-level driver interrupt handler */

/*

 * Translates a ISP error to a Linux SCSI error

 DEBUG_QLA1280_INTR */

	/*

	  dprintk(1, "qla1280_return_status: compl status = 0x%04x\n",

	  comp_status);

***************************************************************************/

                QLogic ISP1280 Hardware Support Functions.                */

***************************************************************************/

/*

 * qla1280_initialize_adapter

 *      Initialize board.

 *

 * Input:

 *      ha = adapter block pointer.

 *

 * Returns:

 *      0 = success

 Clear adapter flags. */

 TODO: implement support for the 1040 nvram format */

 Insure mailbox registers are free. */

	/*

	 * It's necessary to grab the spin here as qla1280_mailbox_command

	 * needs to be able to drop the lock unconditionally to wait

	 * for completion.

 Setup adapter based on NVRAM parameters. */

 Issue SCSI reset, if we can't reset twice then bus is dead */

/*

 * qla1280_request_firmware

 *      Acquire firmware for chip.  Retain in memory

 *      for error recovery.

 *

 * Input:

 *      ha = adapter block pointer.

 *

 * Returns:

 *      Pointer to firmware image or an error code

 *      cast to pointer via ERR_PTR().

/*

 * Chip diagnostics

 *      Test chip for proper operation.

 *

 * Input:

 *      ha = adapter block pointer.

 *

 * Returns:

 *      0 = success.

 Soft reset chip and wait for it to finish. */

	/*

	 * We can't do a traditional PCI write flush here by reading

	 * back the register. The card will not respond once the reset

	 * is in action and we end up with a machine check exception

	 * instead. Nothing to do but wait and hope for the best.

	 * A portable pci_write_flush(pdev) call would be very useful here.

	/*

	 * Yet another QLogic gem ;-(

 Reset register cleared by chip reset. */

	/* Reset RISC and disable BIOS which

 Flush PCI write */

	/*

	 * I *LOVE* this code!

 Check product ID of chip */

	/*

	 * Enable ints early!!!

 Wrap Incoming Mailboxes Test. */

 enter with host_lock acquired */

 Load RISC code. */

 for debug of RISC loading */

 enter with host_lock acquired */

 Load RISC code. */

break; */

 Verify checksum of loaded RISC code. */

 mb[1] = ql12_risc_code_addr01; */

 Start firmware execution. */

 enter with host_lock taken */

/*

 * Initialize rings

 *

 * Input:

 *      ha                = adapter block pointer.

 *      ha->request_ring  = request ring virtual address

 *      ha->response_ring = response ring virtual address

 *      ha->request_dma   = request ring physical address

 *      ha->response_dma  = response ring physical address

 *

 * Returns:

 *      0 = success.

 Clear outstanding commands array. */

 Initialize request queue. */

 mb[0] = MBC_INIT_REQUEST_QUEUE; */

 Initialize response queue. */

 mb[0] = MBC_INIT_RESPONSE_QUEUE; */

 Some SCSI Processors do not seem to like this */

 nv->cntr_flags_1.disable_loading_risc_code = 1; */

	/*

	 * Set default FIFO magic - What appropriate values would be here

	 * is unknown. This is what I have found testing with 12160s.

	 *

	 * Now, I would love the magic decoder ring for this one, the

	 * header file provided by QLogic seems to be bogus or incomplete

	 * at best.

 fast memory enable */

 Set Target Parameters. */

	/*

	 * Do not enable sync and ppr for the initial INQUIRY run. We

	 * enable this later if we determine the target actually

	 * supports it.

 Save Tag queuing enable flag. */

 Save Device enable flag. */

 Save LUN disable flag. */

 Set Device Queue Parameters. */

 SCSI Reset Disable. */

 Initiator ID. */

 Reset Delay. */

 Command queue depth per device. */

 Set target parameters. */

 Always force AUTO sense for LINUX SCSI */

 Disable RISC load of firmware. */

 Busted fifo, says mjacob. */

 Set ISP hardware DMA burst */

 Enable DMA arbitration on dual channel controllers */

 Set SCSI termination. */

 Flush PCI write */

 Flush PCI write */

 ISP parameter word. */

 clock rate - for qla1240 and older, only */

 Firmware feature word. */

 Retry count and delay. */

 ASYNC data setup time. */

 Active negation states. */

 Reset SCSI bus and return all outstanding IO */

 thingy */

 Data DMA Channel Burst Enable */

 Command DMA Channel Burst Enable */

 Selection timeout. */

/*

 * Get NVRAM data word

 *      Calculates word position in NVRAM and calls request routine to

 *      get the word from NVRAM.

 *

 * Input:

 *      ha      = adapter block pointer.

 *      address = NVRAM word address.

 *

 * Returns:

 *      data word.

/*

 * NVRAM request

 *      Sends read command to NVRAM and gets data from NVRAM.

 *

 * Input:

 *      ha     = adapter block pointer.

 *      nv_cmd = Bit 26     = start bit

 *               Bit 25, 24 = opcode

 *               Bit 23-16  = address

 *               Bit 15-0   = write data

 *

 * Returns:

 *      data word.

 Send command to NVRAM. */

 Read data from NVRAM. */

 Flush PCI write */

 Flush PCI write */

 Deselect chip. */

 Flush PCI write */

 Flush PCI write */

 Flush PCI write */

 Flush PCI write */

/*

 * Mailbox Command

 *      Issue mailbox command and waits for completion.

 *

 * Input:

 *      ha = adapter block pointer.

 *      mr = mailbox registers to load.

 *      mb = data pointer for mailbox registers.

 *

 * Output:

 *      mb[MAILBOX_REGISTER_COUNT] = returned mailbox data.

 *

 * Returns:

 *      0 = success

	/*

	 * We really should start out by verifying that the mailbox is

	 * available before starting sending the command data

 Load mailbox registers. */

 Issue set host interrupt command. */

 set up a timer just in case we're really jammed */

 Check for mailbox command timeout. */

 Load return mailbox registers. */

/*

 * qla1280_poll

 *      Polls ISP for interrupts.

 *

 * Input:

 *      ha = adapter block pointer.

 ENTER("qla1280_poll"); */

 Check for pending interrupts. */

 LEAVE("qla1280_poll"); */

/*

 * qla1280_bus_reset

 *      Issue SCSI bus reset.

 *

 * Input:

 *      ha  = adapter block pointer.

 *      bus = SCSI bus number.

 *

 * Returns:

 *      0 = success

 Issue marker command. */

	/*

	 * We should probably call qla1280_set_target_parameters()

	 * here as well for all devices on the bus.

/*

 * qla1280_device_reset

 *      Issue bus device reset message to the target.

 *

 * Input:

 *      ha      = adapter block pointer.

 *      bus     = SCSI BUS number.

 *      target  = SCSI ID.

 *

 * Returns:

 *      0 = success

 Issue marker command. */

/*

 * qla1280_abort_command

 *      Abort command aborts a specified IOCB.

 *

 * Input:

 *      ha = adapter block pointer.

 *      sp = SB structure pointer.

 *

 * Returns:

 *      0 = success

/*

 * qla1280_reset_adapter

 *      Reset adapter.

 *

 * Input:

 *      ha = adapter block pointer.

 Disable ISP chip */

 Flush PCI write */

/*

 *  Issue marker command.

 *      Function issues marker IOCB.

 *

 * Input:

 *      ha   = adapter block pointer.

 *      bus  = SCSI BUS number

 *      id   = SCSI ID

 *      lun  = SCSI LUN

 *      type = marker modifier

 Get request packet. */

 Issue command to ISP */

/*

 * qla1280_64bit_start_scsi

 *      The start SCSI is responsible for building request packets on

 *      request ring and modifying ISP input pointer.

 *

 * Input:

 *      ha = adapter block pointer.

 *      sp = SB structure pointer.

 *

 * Returns:

 *      0 = success, was able to issue command.

 Calculate number of entries and segments required. */

 Calculate number of free request entries. */

 If room for request in request ring. */

 Check for room in outstanding command list. */

	/*

	 * Build command packet.

 Zero out remaining portion of packet. */

 Set ISP command timeout. */

 Set device target ID and LUN */

 Enable simple tag queuing if device supports it. */

 Load SCSI command packet. */

 dprintk(1, "Build packet for command[0]=0x%x\n",pkt->scsi_cdb[0]); */

 Set transfer direction. */

 Set total data segment count. */

	/*

	 * Load data segments.

 If data transfer. */

 Setup packet address segment pointer. */

 Load command entry data segments. */

		/*

		 * Build continuation packets.

 Update sg start */

 Adjust ring index. */

 Zero out packet. */

 Load packet defaults. */

 Setup packet address segment pointer. */

 Load continuation entry data segments. */

 No data transfer */

 Adjust ring index. */

 Set chip new ring index. */

 !QLA_64BIT_PTR */

/*

 * qla1280_32bit_start_scsi

 *      The start SCSI is responsible for building request packets on

 *      request ring and modifying ISP input pointer.

 *

 *      The Qlogic firmware interface allows every queue slot to have a SCSI

 *      command and up to 4 scatter/gather (SG) entries.  If we need more

 *      than 4 SG entries, then continuation entries are used that can

 *      hold another 7 entries each.  The start routine determines if there

 *      is eought empty slots then build the combination of requests to

 *      fulfill the OS request.

 *

 * Input:

 *      ha = adapter block pointer.

 *      sp = SCSI Request Block structure pointer.

 *

 * Returns:

 *      0 = success, was able to issue command.

 Calculate number of entries and segments required. */

		/*

		 * if greater than four sg entries then we need to allocate

		 * continuation entries

 Calculate number of free request entries. */

 If room for request in request ring. */

 Check for empty slot in outstanding command list. */

	/*

	 * Build command packet.

 Zero out remaining portion of packet. */

 Set ISP command timeout. */

 Set device target ID and LUN */

 Enable simple tag queuing if device supports it. */

 Load SCSI command packet. */

dprintk(1, "Build packet for command[0]=0x%x\n",pkt->scsi_cdb[0]); */

 Set transfer direction. */

 Set total data segment count. */

	/*

	 * Load data segments.

 Setup packet address segment pointer. */

 Load command entry data segments. */

		/*

		 * Build continuation packets.

 Continue from end point */

 Adjust ring index. */

 Zero out packet. */

 Load packet defaults. */

 Setup packet address segment pointer. */

 Load continuation entry data segments. */

 No data transfer at all */

 Adjust ring index. */

 Set chip new ring index. */

/*

 * qla1280_req_pkt

 *      Function is responsible for locking ring and

 *      getting a zeroed out request packet.

 *

 * Input:

 *      ha  = adapter block pointer.

 *

 * Returns:

 *      0 = failed to get slot.

	/*

	 * This can be called from interrupt context, damn it!!!

 Wait for 30 seconds for slot. */

 Calculate number of free request entries. */

 Found empty request ring slot? */

 Zero out packet. */

			/*

			 * How can this be right when we have a ring

			 * size of 512???

 Set system defined field. */

 Set entry count. */

 10 */

 Check for pending interrupts. */

/*

 * qla1280_isp_cmd

 *      Function is responsible for modifying ISP input pointer.

 *      Releases ring lock.

 *

 * Input:

 *      ha  = adapter block pointer.

 Adjust ring index. */

	/*

	 * Update request index to mailbox4 (Request Queue In).

***************************************************************************/

                        Interrupt Service Routine.                        */

***************************************************************************/

/****************************************************************************

 *  qla1280_isr

 *      Calls I/O done on command completion.

 *

 * Input:

 *      ha           = adapter block pointer.

 *      done_q       = done queue.

 Save mailbox register 5 */

 Check for mailbox interrupt. */

 Get mailbox data. */

 dprintk(1, "qla1280_isr: In Get mailbox data \n"); */

 Release mailbox registers. */

 Handle asynchronous event */

 Response completion */

 Get outstanding command index. */

 Validate handle. */

 Free outstanding command slot. */

 Save ISP completion status */

 Place block on done queue */

					/*

					 * If we get here we have a real problem!

 SCSI Bus Reset */

 System Error */

 Request Transfer Error */

 Response Transfer Error */

 Request Queue Wake-up */

 Execution Timeout Reset */

 Bus Device Reset */

 dprintk(1, "qla1280_isr: default case of switch MB \n"); */

	/*

	 * We will receive interrupts during mailbox testing prior to

	 * the card being marked online, hence the double check.

 Adjust ring index. */

/*

 *  qla1280_rst_aen

 *      Processes asynchronous reset.

 *

 * Input:

 *      ha  = adapter block pointer.

 Issue marker command. */

/*

 *  qla1280_status_entry

 *      Processes received ISP status entry.

 *

 * Input:

 *      ha           = adapter block pointer.

 *      pkt          = entry pointer.

 *      done_q       = done queue.

 Validate handle. */

 Free outstanding command slot. */

 Target busy or queue full */

 Save ISP completion status */

					/*

					 * scsi_cmnd->sense_buffer is

					 * 64 bytes, why only copy 63?

					 * This looks wrong! /Jes

 Place command on done queue. */

/*

 *  qla1280_error_entry

 *      Processes error entry.

 *

 * Input:

 *      ha           = adapter block pointer.

 *      pkt          = entry pointer.

 *      done_q       = done queue.

 Validate handle. */

 Free outstanding command slot. */

 Bad payload or header */

 Bad payload or header, set error status. */

 CMD_RESULT(sp->cmd) = CS_BAD_PAYLOAD; */

 FULL flag */

 Set error status. */

 Place command on done queue. */

/*

 *  qla1280_abort_isp

 *      Resets ISP and aborts all outstanding commands.

 *

 * Input:

 *      ha           = adapter block pointer.

 *

 * Returns:

 *      0 = success

 Disable ISP interrupts. */

 Dequeue all commands in outstanding command list. */

 Setup adapter based on NVRAM parameters. */

 Issue SCSI reset. */

/*

 * qla1280_debounce_register

 *      Debounce register.

 *

 * Input:

 *      port = register address.

 *

 * Returns:

 *      register value.

/************************************************************************

 * qla1280_check_for_dead_scsi_bus                                      *

 *                                                                      *

 *    This routine checks for a dead SCSI bus                           *

 bus is dead */

 bus is not dead */

/**************************************************************************

 *   ql1280_print_scsi_cmd

 *

 struct scatterlist *sg; */

	/* if (cmd->use_sg)

	   {

	   sg = (struct scatterlist *) cmd->request_buffer;

	   printk("  SG buffer: \n");

	   qla1280_dump_buffer(1, (char *)sg, (cmd->use_sg*sizeof(struct scatterlist)));

/**************************************************************************

 *   ql1280_dump_device

 *

/**************************************************************************

 *   qla1280_setup

 *

 *   Handle boot parameters. This really needs to be changed so one

 *   can specify per adapter parameters.

 Bypass all AMI SUBSYS VENDOR IDs */

 specifies microcode load address */

 Disable ISP interrupts. */

 load the F/W, read paramaters, and init the H/W */

 set our host ID  (need to do something about our two IDs) */

	/*

	 * If we are called as a module, the qla1280 pointer may not be null

	 * and it would point to our bootup string, just like on the lilo

	 * command line.  IF not NULL, then process this config string with

	 * qla1280_setup

	 *

	 * Boot time Options

	 * To add options at boot time add a line to your lilo.conf file like:

	 * append="qla1280=verbose,max_tags:{{255,255,255,255},{255,255,255,255}}"

	 * which will result in the first four devices on the first two

	 * controllers being set to a tagged queue depth of 32.

 release any allocated firmware images */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  hosts.c Copyright (C) 1992 Drew Eckhardt

 *          Copyright (C) 1993, 1994, 1995 Eric Youngdale

 *          Copyright (C) 2002-2003 Christoph Hellwig

 *

 *  mid to lowlevel SCSI driver interface

 *      Initial versions: Drew Eckhardt

 *      Subsequent revisions: Eric Youngdale

 *

 *  <drew@colorado.edu>

 *

 *  Jiffies wrap fixes (host->resetting), 3 Dec 1998 Andrea Arcangeli

 *  Added QLOGIC QLA1280 SCSI controller kernel host support. 

 *     August 4, 1999 Fred Lewis, Intel DuPont

 *

 *  Updated to reflect the new initialization scheme for the higher 

 *  level of scsi drivers (sd/sr/st)

 *  September 17, 2000 Torben Mathiasen <tmm@image.dk>

 *

 *  Restructured scsi_host lists and associated functions.

 *  September 04, 2002 Mike Anderson (andmike@us.ibm.com)

/**

 *	scsi_host_set_state - Take the given host through the host state model.

 *	@shost:	scsi host to change the state of.

 *	@state:	state to change to.

 *

 *	Returns zero if unsuccessful or an error if the requested

 *	transition is illegal.

		/* There are no legal states that come back to

		 * created.  This is the manually initialised start

/**

 * scsi_remove_host - remove a scsi host

 * @shost:	a pointer to a scsi host to remove

/**

 * scsi_add_host_with_dma - add a scsi host with dma device

 * @shost:	scsi host pointer to add

 * @dev:	a struct device of type scsi class

 * @dma_dev:	dma device for the host

 *

 * Note: You rarely need to worry about this unless you're in a

 * virtualised host environments, so use the simpler scsi_add_host()

 * function instead.

 *

 * Return value: 

 * 	0 on success / != 0 for error

 Use min_t(int, ...) in case shost->can_queue exceeds SHRT_MAX */

	/*

	 * Increase usage count temporarily here so that calling

	 * scsi_autopm_put_host() will trigger runtime idle if there is

	 * nothing else preventing suspending the device.

	/*

	 * Any host allocation in this function will be freed in

	 * scsi_host_dev_release().

	/*

	 * Host state is SHOST_RUNNING so we have to explicitly release

	 * ->shost_dev.

 Wait for functions invoked through call_rcu(&scmd->rcu, ...) */

		/*

		 * Free the shost_dev device name here if scsi_host_alloc()

		 * and scsi_host_put() have been called but neither

		 * scsi_host_add() nor scsi_host_remove() has been called.

		 * This avoids that the memory allocated for the shost_dev

		 * name is leaked.

/**

 * scsi_host_alloc - register a scsi host adapter instance.

 * @sht:	pointer to scsi host template

 * @privsize:	extra bytes to allocate for driver

 *

 * Note:

 * 	Allocate a new Scsi_Host and perform basic initialization.

 * 	The host is not published to the scsi midlayer until scsi_add_host

 * 	is called.

 *

 * Return value:

 * 	Pointer to a new Scsi_Host

 These three are default values which can be overridden */

 Give each shost a default transportt */

	/*

	 * All drivers right now should be able to handle 12 byte

	 * commands.  Every so often there are requests for 16 byte

	 * commands, but individual low-level drivers need to certify that

	 * they actually do something sensible with such commands.

 means we didn't set it ... default to INITIATOR */

	/*

	 * If the driver imposes no hard sector transfer limit, start at

	 * machine infinity initially.

	/*

	 * assume a 4GB boundary, if not set

	/*

	 * Host state is still SHOST_CREATED and that is enough to release

	 * ->shost_gendev. scsi_host_dev_release() will free

	 * dev_name(&shost->shost_dev).

/**

 * scsi_host_lookup - get a reference to a Scsi_Host by host no

 * @hostnum:	host number to locate

 *

 * Return value:

 *	A pointer to located Scsi_Host or NULL.

 *

 *	The caller must do a scsi_host_put() to drop the reference

 *	that scsi_host_get() took. The put_device() below dropped

 *	the reference from class_find_device().

/**

 * scsi_host_get - inc a Scsi_Host ref count

 * @shost:	Pointer to Scsi_Host to inc.

/**

 * scsi_host_busy - Return the host busy counter

 * @shost:	Pointer to Scsi_Host to inc.

/**

 * scsi_host_put - dec a Scsi_Host ref count

 * @shost:	Pointer to Scsi_Host to dec.

/**

 * scsi_queue_work - Queue work to the Scsi_Host workqueue.

 * @shost:	Pointer to Scsi_Host.

 * @work:	Work to queue for execution.

 *

 * Return value:

 * 	1 - work queued for execution

 *	0 - work is already queued

 *	-EINVAL - work queue doesn't exist

/**

 * scsi_flush_work - Flush a Scsi_Host's workqueue.

 * @shost:	Pointer to Scsi_Host.

/**

 * scsi_host_complete_all_commands - Terminate all running commands

 * @shost:	Scsi Host on which commands should be terminated

 * @status:	Status to be set for the terminated commands

 *

 * There is no protection against modification of the number

 * of outstanding commands. It is the responsibility of the

 * caller to ensure that concurrent I/O submission and/or

 * completion is stopped when calling this function.

/**

 * scsi_host_busy_iter - Iterate over all busy commands

 * @shost:	Pointer to Scsi_Host.

 * @fn:		Function to call on each busy command

 * @priv:	Data pointer passed to @fn

 *

 * If locking against concurrent command completions is required

 * ithas to be provided by the caller

 SPDX-License-Identifier: GPL-2.0-only

/*

   SCSI Tape Driver for Linux version 1.1 and newer. See the accompanying

   file Documentation/scsi/st.rst for more information.



   History:

   Rewritten from Dwayne Forsyth's SCSI tape driver by Kai Makisara.

   Contribution and ideas from several people including (in alphabetical

   order) Klaus Ehrenfried, Eugene Exarevsky, Eric Lee Green, Wolfgang Denk,

   Steve Hirsch, Andreas Koppenh"ofer, Michael Leodolter, Eyal Lebedinsky,

   Michael Schaefer, J"org Weule, and Eric Youngdale.



   Copyright 1992 - 2016 Kai Makisara

   email Kai.Makisara@kolumbus.fi



   Some small formal changes - aeb, 950809



   Last modified: 18-JAN-1998 Richard Gooch <rgooch@atnf.csiro.au> Devfs support

/* The driver prints some debugging information on the console if DEBUG

/* The message level for the debug messages is currently set to KERN_NOTICE

   so that people can easily see the messages. Later when the debugging messages

/* Set 'perm' (4th argument) to 0 to disable module_param's definition

 * of sysfs parameters (which module_param doesn't yet support).

 * Sysfs parameters defined explicitly later.

 Extra parameters for testing */

 retained for compatibility */

 Retained for compatibility with 2.4 */

 Restrict the number of modes so that names for all are assigned */

/* Bit reversed order to get same names for same minors with all

 The default definitions have been moved to st_options.h */

/* The buffer size should fit into the 24 bits for length in the

 Remove mode bits and auto-rewind bit (7) */

 Construct the minor number from the device (d), mode (m), and non-rewind (n) data */

/* Internal ioctl to set both density (uppermost 8 bits) and blocksize (lower

 Name of the correct driver, NULL if unknown */

 {"XXX", "Yy-", "", NULL},  example */

/* If the device signature is on the list of incompatible drives, the

 Convert the result to success code */

 end DEB */

 Abnormal conditions for tape */

 scode != UNIT_ATTENTION && */

 Only fixed format sense */

 ASC and ASCQ => cleaning requested */

 end DEB */

/* Do the scsi command. Waits until command performed if do_wait is true.

   Otherwise write_behind_check() is used to check that the command

 if async, make sure there's no command outstanding */

	/* If async IO, set last_SRpnt. This ptr tells write_behind_check

 could not allocate the buffer or request was too large */

/* Handle the write-behind checking (waits for completion). Returns -ENOSPC if

   write has been correct but EOM early warning reached, -EIO if write ended in

   error or zero if write successful. Asynchronous writes are used only in

 end DEB */

 EOM at write-behind, has all data been written? */

 end DEB */

/* Step over EOF if it has been inadvertently crossed (ioctl not used because

 Space FileMarks */

 -1 filemarks */

 Flush the write buffer (never need to write if variable blocksize). */

 All written at EOM early warning */

/* Flush the tape buffer. The tape will be positioned correctly unless

	/*

	 * If there was a bus reset, block further access

	 * to this device.

 Writing */

 Back over the EOF hit */

 Set the mode parameters */

 Lock or unlock the drive door. Don't use when st_request allocated. */

 Set the internal state after reset */

/* Test if the drive is ready. Returns either one of the codes below or a negative system

 New media? */

 Check ASC */

/* See if the drive is ready and gather information about the tape. Return values:

   < 0   negative error code from errno.h

   0     drive ready

   1     drive not ready (possibly no tape)

			STp->nbr_partitions = 1; /* This guess will be updated later

 Clear the erroneous "residue" */

 Educated guess (?) */

 Prevent error propagation */

		/* This code is reached when the device is opened for the first time

		   after the driver has been initialized with tape in the drive and the

 This guess will be updated when necessary */

 Change the drive parameters for the new mode */

/* Open the device. Needs to take the BKL only because of incrementing the SCSI host

	/*

	 * We really want to do nonseekable_open(inode, filp); here, but some

	 * versions of tar incorrectly call lseek on tapes and bail out if that

	 * fails.  So we disallow pread() and pwrite(), but permit lseeks.

 See that we have at least a one page buffer available */

 Flush the tape buffer before close */

 Write successful at EOM */

 Write error */

/* Close the device and release it. BKL is not needed: this is the only thread

 The checks common to both reading and writing */

	/*

	 * If we are in the middle of error recovery, don't let anyone

	 * else try and use this device.  Also, if error recovery fails, it

	 * may try and take the device offline, in which case all further

	 * access to the device is prohibited.

	/*

	 * If there was a bus reset, block further access

	 * to this device.

 end DEB */

 can be used as transfer counter */

 fall back to buffering with any error */

			/* Make sure that data from previous user is not leaked even if

 Can be called more than once after each setup_buffer() */

 Write command */

 Write must be integral number of blocks */

 allow next write */

	/* Check the buffer readability in cases where copy_user might catch

 Don't write a buffer that is not full enough. */

 Prevent releasing this request! */

 Only data from this write is not written */

					/* Continue in fixed block mode if all written

					   in this request but still something left to write

					   (retval left to zero)

 EOM within current request */

					/* EOT within data buffered earlier (possible only

						/* Either error within data buffered by driver or

 Too cautious? */

 EOM for old data */

 Too cautious? */

/* Read data from the tape. Returns zero in the normal case, one if the

   eof status has changed, and the negative error code in case of a

   fatal error. Otherwise updates the buffer and the eof state.



   Does release user buffer mapping if it is set.

 Something to check */

 No need for EOM in this case */

 EOF, EOM, or ILI */

 Compute the residual count */

 Some drives set ILI with MEDIUM ERROR */

 ILI */

 We did not get anything, error */

 We have some data, deliver it */

 FM overrides EOM */

 end of EOF, EOM, ILI test */

 nonzero sense key */

 First BLANK_CHECK after FM */

 Some other extended sense code */

 Caused by bogus sense data */

 End of extended sense test */

 Non-extended sense */

 End of error handling */

 Read successful */

 In fixed block mode residual is always zero here */

 Read command */

 Read must be integral number of blocks */

 Direct i/o can't handle split blocks */

 end DEB */

 EOM or Blank Check */

		/* Check the buffer writability before any tape movement. Don't alter

 Loop until enough data in buffer or a special condition found */

 Get new data if the buffer is empty */

 No need to continue read */

 Move the data from driver buffer to user buffer */

 end DEB */

 Read only one variable length block */

	}			/* for (total = 0, special = 0;

 Change the eof state if no data from tape or buffer */

 Set the driver options */

 Retained for compatibility */

 Mode header and page byte offsets */

 Mode header and page bit masks */

 Don't return block descriptors */

/* Read a mode page into the tape buffer. The block descriptors are included

   if incl_block_descs is true. The page control is ored to the page number

/* Send the mode page in the tape buffer to the drive. Assumes that the mode data

 Clear reserved fields */

/* Control the compression with mode page 15. Algorithm not changed if zero.



   The block descriptors are read and written because Sony SDT-7000 does not

   work without this (suggestion from Michael Schaefer <Michael.Schaefer@dlr.de>).

 Offset to mode page start */

 Read the current page contents */

 Check if compression can be changed */

 Do the change */

 no compression */

 Process the load and unload commands (does unload if the load code is zero) */

	/*

	 * If arg >= 1 && arg <= 6 Enhanced load/unload in HP C1553A

 MediaID field of C1553A */

 Don't wait for completion */

 SCSI command successful */

 Internal ioctl function */

 Changed from the FSF after this */

 Space FileMarks */

 Changed from the FSF after this */

 Space FileMarks */

 We can't know the block number */

 Space Blocks */

 Space Blocks */

 Space Setmarks */

 Space Setmarks */

 Don't wait for completion */

 Should do something ? */

 Don't wait for completion */

 space to the end of tape */

			/* The next lines would hide the number of spaced FileMarks

			   That's why I inserted the previous lines. I had no luck

			   with detecting EOM with FSF, so we go now to EOM.

 Long erase with non-zero argument */

 Don't wait for completion */

 Set block length */

 Set tape density */

 Set drive buffering */

 Set density and block size */

 Not allowed if data in buffer */

 block descriptor length */

 At least we tried ;-) */

 At least we tried ;-) */

 SCSI command successful */

 prevent automatic WEOF at close */

	} else { /* SCSI command was not completely successful. Don't return

 EOF(s) written successfully at EOM */

 Writing EOF(s) failed */

 Some drives get this wrong */

 Hit filemark */

 Hit filemark */

 Some drives get this wrong */

				/* Try the other possible state of Page Format if not

/* Get the tape position. If bt == 2, arg points into a kernel space mt_loc

 BOP of partition 0 */

/* Set the tape block and partition. Negative partition means that only the

 Update the location at the partition we are leaving */

 Don't wait for completion */

/* Find the current partition number for the drive status. Called from open and

 Change the partition if necessary */

 Functions for reading and writing the medium partition mode page. */

/* Get the number of partitions on the tape. As a side effect reads the

 Don't wait for completion */

/* Partition the tape into two partitions if size > 0 or one partition if

   size == 0.



   The block descriptors are read and written because Sony SDT-7000 does not

   work without this (suggestion from Michael Schaefer <Michael.Schaefer@dlr.de>).



   My HP C1533A drive returns only one partition size field. This is used to

   set the size of partition 1. There is no size field for the default partition.

   Michael Schaefer's Sony SDT-7000 returns two descriptors and the second is

   used to set the size of partition 1 (this is what the SCSI-3 standard specifies).

   The following algorithm is used to accommodate both drives: if the number of

   partition size fields is greater than the maximum number of additional partitions

   in the mode page, the second field is used. Otherwise the first field is used.



   For Seagate DDS drives the page length must be 8 when no partitions is defined

   and 10 when 1 partition is defined (information from Eric Lee Green). This is

   is acceptable also to some other old drives and enforced if the first partition

   size field is used for the first additional partition size.



   For drives that advertize SCSI-3 or newer, use the SSC-3 methods.

 The mode page is in the buffer. Let's modify it and write it. */

			/* No need to write the mode page when clearing

			 *  partitioning

 Leave the old value for HP DATs claiming SCSI_3 */

			/* Use units scaling for large partitions if the device

			 * suggests it and no precision lost. Required for IBM

			 * TS1140/50 drives that don't support MB units.

 GB */

 Try it anyway if too large to specify in MB */

 GB */

 Does not fit into two bytes */

	/* The second condition is for HP DDS which use only one partition size

	 * descriptor

 Rest to partition 0 */

 The ioctl command */

 end DEB */

	/*

	 * If we are in the middle of error recovery, don't let anyone

	 * else try and use this device.  Also, if error recovery fails, it

	 * may try and take the device offline, in which case all further

	 * access to the device is prohibited.

				/* Old position must be restored if partition will be

			/*

			 * If there was a bus reset, block further access

			 * to this device.  If the user wants to rewind the tape,

			 * then reset the flag and allow access again.

 remove this when the midlevel properly clears was_reset */

 Prevent automatic WEOF and fsf */

 Ignore result! */

 Clear after read */

 End of MTIOCGET */

 unload */

 argument conversion is handled using put_user_mtpos/put_user_mtget */

/* Try to allocate a new tape buffer. Calling function must not hold

 Try to allocate enough space in the tape buffer */

 Avoid extra segment */

 empty */

 Make sure that no data from previous user is in the internal buffer */

 Release the extra buffer */

/* Move data from the user buffer to the tape buffer. Returns zero (success) or

 Should never happen */

 Should never happen */

/* Move data from the tape buffer to the user buffer. Returns zero (success) or

 Should never happen */

 Should never happen */

 Move data towards start of buffer */

 Validate the options from command line or module parameters */

/* Set the boot options. Syntax is defined in Documenation/scsi/st.txt.

 Try buffering if no mode sense */

 BSR mandatory in SCSI3 */

 No forced buffering */

 No forced size */

 No forced density */

/**

 *      scsi_tape_release - Called to free the Scsi_Tape structure

 *      @kref: pointer to embedded kref

 *

 *      st_ref_mutex must be held entering this routine.  Because it is

 *      called on last put, you should always use the scsi_tape_get()

 *      scsi_tape_put() helpers which manipulate the semaphore directly

 *      and never do a direct kref_put().

 The sysfs driver interface. Read-only at the moment */

/* We only care what the first byte of the data is the rest is unused.

 * if it's a '1' we turn on debug and if it's a '0' we disable it. All

 * other values have -EINVAL returned if they are passed in.

 The sysfs simple class interface */

 Support for tape stats */

/**

 * read_cnt_show - return read count - count of reads made from tape drive

 * @dev: struct device

 * @attr: attribute structure

 * @buf: buffer to return formatted data in

/**

 * read_byte_cnt_show - return read byte count - tape drives

 * may use blocks less than 512 bytes this gives the raw byte count of

 * of data read from the tape drive.

 * @dev: struct device

 * @attr: attribute structure

 * @buf: buffer to return formatted data in

/**

 * read_ns_show - return read ns - overall time spent waiting on reads in ns.

 * @dev: struct device

 * @attr: attribute structure

 * @buf: buffer to return formatted data in

/**

 * write_cnt_show - write count - number of user calls

 * to write(2) that have written data to tape.

 * @dev: struct device

 * @attr: attribute structure

 * @buf: buffer to return formatted data in

/**

 * write_byte_cnt_show - write byte count - raw count of

 * bytes written to tape.

 * @dev: struct device

 * @attr: attribute structure

 * @buf: buffer to return formatted data in

/**

 * write_ns_show - write ns - number of nanoseconds waiting on write

 * requests to complete.

 * @dev: struct device

 * @attr: attribute structure

 * @buf: buffer to return formatted data in

/**

 * in_flight_show - number of I/Os currently in flight -

 * in most cases this will be either 0 or 1. It may be higher if someone

 * has also issued other SCSI commands such as via an ioctl.

 * @dev: struct device

 * @attr: attribute structure

 * @buf: buffer to return formatted data in

/**

 * io_ns_show - io wait ns - this is the number of ns spent

 * waiting on all I/O to complete. This includes tape movement commands

 * such as rewinding, seeking to end of file or tape, it also includes

 * read and write. To determine the time spent on tape movement

 * subtract the read and write ns from this value.

 * @dev: struct device

 * @attr: attribute structure

 * @buf: buffer to return formatted data in

/**

 * other_cnt_show - other io count - this is the number of

 * I/O requests other than read and write requests.

 * Typically these are tape movement requests but will include driver

 * tape movement. This includes only requests issued by the st driver.

 * @dev: struct device

 * @attr: attribute structure

 * @buf: buffer to return formatted data in

/**

 * resid_cnt_show - A count of the number of times we get a residual

 * count - this should indicate someone issuing reads larger than the

 * block size on tape.

 * @dev: struct device

 * @attr: attribute structure

 * @buf: buffer to return formatted data in

 The following functions may be useful for a larger audience. */

 User attempted Overflow! */

 Too big */

 Hmm? */

 Try to fault in all of the necessary pages */

 rw==READ means read from drive, write into memory area */

 Errors and no page mapped should return here */

                /* FIXME: flush superflous for rw==READ,

                 * probably wrong function for rw==WRITE

 And unmap them... */

 FIXME: cache flush missing for rw==READ */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Changes:

 * Arnaldo Carvalho de Melo <acme@conectiva.com.br> 08/23/2000

 * - get rid of some verify_areas and use __copy*user and __get/put_user

 *   for the ones that remain

/**

 * ioctl_probe  --  return host identification

 * @host:	host to identify

 * @buffer:	userspace buffer for identification

 *

 * Return an identifying string at @buffer, if @buffer is non-NULL, filling

 * to the length stored at * (int *) @buffer.

 This happens if there is no disc in drive */

 This is no longer considered an error */

 for non-removable media */

/*

 * The scsi_ioctl_get_pci() function places into arg the value

 * pci_dev::slot_name (8 characters) for the PCI device (if any).

 * Returns: 0 on success

 *          -ENXIO if there isn't a PCI device pointer

 *                 (could be because the SCSI driver hasn't been

 *                  updated yet, or because it isn't a SCSI

 *                  device)

 *          any copy_to_user() error on failure there

	/* compatibility with old ioctl which only returned

/*

 * will always return that we are ATAPI even for a real SCSI drive, I'm not

 * so sure this is worth doing anything about (why would you care??)

/*

 * Check if the given command is allowed.

 *

 * Only a subset of commands are allowed for unprivileged users. Commands used

 * to format the media, update the firmware, etc. are not permitted.

 root can do any command. */

 Anybody who can open the device can do a read-safe command */

 Basic read-only commands */

 also GPCMD_READ_CDVD_CAPACITY */

 also GPCMD_SEND_KEY, which is a write command */

 Audio CD commands */

 CD/DVD data reading */

 ZBC */

 Basic writing commands */

 ZBC */

	/*

	 * fill in request structure

	/*

	 * fill in all the output members

 SG_IO howto says that the shorter of the two wins */

/**

 * sg_scsi_ioctl  --  handle deprecated SCSI_IOCTL_SEND_COMMAND ioctl

 * @q:		request queue to send scsi commands down

 * @disk:	gendisk to operate on (option)

 * @mode:	mode used to open the file through which the ioctl has been

 *		submitted

 * @sic:	userspace structure describing the command to perform

 *

 * Send down the scsi command described by @sic to the device below

 * the request queue @q.  If @file is non-NULL it's used to perform

 * fine-grained permission checks that allow users to send down

 * non-destructive SCSI commands.  If the caller has a struct gendisk

 * available it should be passed in as @disk to allow the low level

 * driver to use the information contained in it.  A non-NULL @disk

 * is only allowed if the caller knows that the low level driver doesn't

 * need it (e.g. in the scsi subsystem).

 *

 * Notes:

 *   -  This interface is deprecated - users should use the SG_IO

 *      interface instead, as this is a more flexible approach to

 *      performing SCSI commands on a device.

 *   -  The SCSI command length is determined by examining the 1st byte

 *      of the given command. There is no way to override this.

 *   -  Data transfers are limited to PAGE_SIZE

 *   -  The length (x + y) must be at least OMAX_SB_LEN bytes long to

 *      accommodate the sense buffer when an error occurs.

 *      The sense buffer is truncated to OMAX_SB_LEN (16) bytes so that

 *      old code will not be surprised.

 *   -  If a Unix error occurs (e.g. ENOMEM) then the user will receive

 *      a negative return and the Unix error code in 'errno'.

 *      If the SCSI command succeeds then 0 is returned.

 *      Positive numbers returned are the compacted SCSI error codes (4

 *      bytes in one int) where the lowest byte is the SCSI status.

 For backward compatibility */

	/*

	 * get in an out lengths, verify they don't exceed a page worth of data

	/*

	 * get command and data to send to device, if any

 default.  possible overridden later */

 only 8 bit SCSI status */

/**

 * scsi_ioctl - Dispatch ioctl to scsi device

 * @sdev: scsi device receiving ioctl

 * @disk: disk receiving the ioctl

 * @mode: mode the block/char device is opened with

 * @cmd: which ioctl is it

 * @arg: data associated with ioctl

 *

 * Description: The scsi_ioctl() function differs from most ioctls in that it

 * does not take a major/minor number as the dev field.  Rather, it takes

 * a pointer to a &struct scsi_device.

	/* Check for deprecated ioctls ... all the ioctls which don't

/*

 * We can process a reset even when a device isn't fully operable.

/* ppa.c   --  low level driver for the IOMEGA PPA3 

 * parallel port SCSI host adapter.

 * 

 * (The PPA3 is the embedded controller in the ZIP drive.)

 * 

 * (c) 1995,1996 Grant R. Guenther, grant@torque.net,

 * under the terms of the GNU General Public License.

 * 

 Parport device entry         */

 Actual port address          */

 Transfer mode                */

 Current queued command       */

 Polling interrupt stuff       */

 Jiffies at start             */

 How many usecs to wait for reconnection (6th bit) */

 Failure flag                 */

 Parport sharing busy flag    */

 Device number		*/

/*

 * Start of Chipset kludges

/* This is to give the ppa driver a way to modify the timings (and other

 * parameters) by writing to the /proc/scsi/ppa/0 file.

 * Very simple method really... (To simple, no error checking :( )

 * Reason: Kernel hackers HATE having to unload and reload modules for

 * testing...

 * Also gives a method to use a script to obtain optimum timings (TODO)

 If we fail a device then we trash status / message bytes */

/*

 * Wait for the high bit to be set.

 * 

 * In principle, this could be tied to an interrupt, but the adapter

 * doesn't appear to be designed to support interrupts.  We spin on

 * the 0x80 ready bit. 

 Wait for bit 6 and 7 - PJC */

	/*

	 * return some status information.

	 * Semantics: 0xc0 = ZIP wants more data

	 *            0xd0 = ZIP wants to send more data

	 *            0xe0 = ZIP is expecting SCSI command data

	 *            0xf0 = end of transfer, ZIP is sending status

 Counter expired - Time out occurred */

 command timed out */

/*

 * Clear EPP Timeout Bit 

/* 

 * Wait for empty ECP fifo (if we are in ECP fifo mode only)

 mode 011 == ECP fifo mode */

 All went well - we hope! */

 All went well - we hope! */

 All went well - we hope! */

 8 bit output, with a loop */

 4 bit input, with a loop */

 8 bit input, with a loop */

 end of ppa_io.h */

	/*

	 * Bit 6 (0x40) is the device selected bit.

	 * First we must wait till the current device goes off line...

 This is NOT the initator */

/* 

 * This is based on a trace of what the Iomega DOS 'guest' driver does.

 * I've tried several different kinds of parallel ports with guest and

 * coded this to react in the same ways that it does.

 * 

 * The return value from this function is just a hint about where the

 * handshaking failed.

 * 

 Failed */

 Allow devices to settle down */

 Another delay to allow devices to settle */

/*

 * The bulk flag enables some optimisations in the data transfer loops,

 * it should be true for any command that transfers data in integral

 * numbers of sectors.

 * 

 * The driver appears to remain stable if we speed up the parallel port

 * i/o in this function, but not elsewhere.

	/* Return codes:

	 * -1     Error

	 *  0     Told to schedule

	 *  1     Finished data transfer

	/*

	 * We only get here if the drive is ready to comunicate,

	 * hence no need for a full ppa_wait.

		/*

		 * If we have been running for more than a full timer tick

		 * then take a rest.

 ERROR_RETURN */

		/* On some hardware we have SCSI disconnected (6th bit low)

		 * for about 100usecs. It is too expensive to wait a 

		 * tick on every loop so we busy wait for no more than

		 * 500usecs to give the drive a chance first. We do not 

		 * change things for "normal" hardware since generally 

		 * the 6th bit is always high.

		 * This makes the CPU load higher on some hardware 

		 * but otherwise we can not get more than 50K/secs 

		 * on this problem hardware.

			/* Wait for reconnection should be no more than 

			 * jiffy/2 = 5ms = 5000 loops

 determine if we should use burst I/O */

 ERROR_RETURN */

 if scatter/gather, advance to the next segment */

 Now check to see if the drive is ready to comunicate */

 If not, drop back down to the scheduler and wait a timer tick */

 FINISH_RETURN */

/*

 * Since the PPA itself doesn't generate interrupts, we use

 * the scheduler's task queue to generate a stream of call-backs and

 * complete the request when the drive is ready.

 Command must of completed hence it is safe to let go... */

	/* First check for any errors that may of occurred

	 * Here we check for internal errors

 Phase 0 - Waiting for parport */

			/*

			 * We waited more than a second

			 * for parport to call us

 wait until ppa_wakeup claims parport */

 Phase 1 - Connected */

 Perform a sanity check for cable unplugged */

 Failed */

 Try again in a jiffy */

 Phase 2 - We are now talking to the scsi bus */

 Phase 3 - Ready to accept a command */

 Phase 4 - Setup scatter/gather buffers */

 Phase 5 - Data transfer stage */

 Phase 6 - Read status/message */

 Check for data overrun */

 read status byte */

 Check for optional message byte */

 Finished */

 default return code */

 bus free */

/*

 * Apparently the disk->capacity attribute is off by 1 sector 

 * for all disk drives.  We add the one here, but it should really

 * be done in sd.c.  Even if it gets fixed there, this will still

 * work.

	/*

	 * There is no method for aborting commands since Iomega

	 * have tied the SCSI_MESSAGE line high in the interface

 Do not have access to parport */

 Have not connected to interface */

 Forget the problem */

 SCSI command sent, can not abort */

 Forget the problem */

 device settle delay */

 device settle delay */

	/* This routine looks for a device and then attempts to use EPP

 Attempt to use EPP for Test Unit Ready */

 Select SCSI device */

 Send SCSI command */

 1 Second */

/***************************************************************************

 *                   Parallel port probing routines                        *

/*

 * Finds the first available device number that can be alloted to the

 * new ppa device and returns the address of the previous node so that

 * we can add to the tail and have a list in the ascending order.

	/* Claim the bus so it remembers what we do to the control

	 * registers. [ CTR and ECP ]

	/* Mode detection works up the chain of speed

	 * This avoids a nasty if-then-else-if-... tree

 Done configuration */

 now the glue ... */

/*

 * This file is part of the Emulex Linux Device Driver for Enterprise iSCSI

 * Host Bus Adapters. Refer to the README file included with this package

 * for driver version and adapter compatibility.

 *

 * Copyright (c) 2018 Broadcom. All Rights Reserved.

 * The term “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of version 2 of the GNU General Public License as published

 * by the Free Software Foundation.

 *

 * This program is distributed in the hope that it will be useful. ALL EXPRESS

 * OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING ANY

 * IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,

 * OR NON-INFRINGEMENT, ARE DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH

 * DISCLAIMERS ARE HELD TO BE LEGALLY INVALID.

 * See the GNU General Public License for more details, a copy of which

 * can be found in the file COPYING included with this package.

 *

 * Contact Information:

 * linux-drivers@broadcom.com

 *

/*

 * When new log level added update MAX allowed value for log_enable

 check if we raced, task just got cleaned up under us */

 get a task ref till FW processes the req for the ICD used */

 mark WRB invalid which have been not processed by FW yet */

 take back_lock to prevent task from getting cleaned up under us */

		/**

		 * Can't fit in more cmds? Normally this won't happen b'coz

		 * BEISCSI_CMD_PER_LUN is same as BE_INVLDT_CMD_TBL_SZ.

 get a task ref till FW processes the req for the ICD used */

 mark WRB invalid which have been not processed by FW yet */

------------------- PCI Driver operations and data ----------------- */

/**

 * beiscsi_get_params()- Set the config paramters

 * @phba: ptr  device priv structure

 Get ICD count that can be posted on each page */

 Check if icd_start is aligned ICD per page posting */

 ICD discarded in the process of alignment */

 Updated ICD count available */

 Setting lower order EQ_ID Bits */

 Setting Higher order EQ_ID Bits */

/**

 * be_isr_mcc - The isr routine of the driver.

 * @irq: Not used

 * @dev_id: Pointer to host adapter structure

/**

 * be_isr_msix - The isr routine of the driver.

 * @irq: Not used

 * @dev_id: Pointer to host adapter structure

 disable interrupt till iopoll completes */

/**

 * be_isr - The isr routine of the driver.

 * @irq: Not used

 * @dev_id: Pointer to host adapter structure

 no need to rearm if interrupt is only for IOs */

 rearm for MCCQ */

 Setting lower order CQ_ID Bits */

 Setting Higher order CQ_ID Bits */

		/*

		 * this can happen if clean_task is called on a task that

		 * failed in xmit_task or alloc_pdu.

/**

 * alloc_wrb_handle - To allocate a wrb handle

 * @phba: The hba pointer

 * @cid: The cid to use for allocation

 * @pcontext: ptr to ptr to wrb context

 *

 * This happens under session_lock until submission to chip

 return the context address */

/**

 * free_wrb_handle - To free the wrb handle back to pool

 * @phba: The hba pointer

 * @pwrb_context: The context to free from

 * @pwrb_handle: The wrb_handle to free

 *

 * This happens under session_lock until submission to chip

		/*

		 * this can happen if clean_task is called on a task that

		 * failed in xmit_task or alloc_pdu.

 bidi not initially supported */

 Copy the elements to a common structure */

/*

 * ASYNC PDUs include

 * a. Unsolicited NOP-In (target initiated NOP-In)

 * b. ASYNC Messages

 * c. Reject PDU

 * d. Login response

 * These headers arrive unprocessed by the EP firmware.

 * iSCSI layer processes them.

	/**

	 * This function is invoked to get the right async_handle structure

	 * from a given DEF PDU CQ entry.

	 *

	 * - index in CQ entry gives the vertical index

	 * - address in CQ entry is the offset where the DMA last ended

	 * - final - no more notifications for this PDU

	/**

	 * DB addr Hi/Lo is same for BE and SKH.

	 * Subtract the dataplacementlength to get to the base.

 called only for above codes */

 driver bug - if ci does not match async handle index */

 FW has stale address - attempt continuing by dropping */

	/**

	 * DEF PDU header and data buffers with errors should be simply

	 * dropped as there are no consumers for it.

	/**

	 * Each CID is associated with unique CRI.

	 * ASYNC_CRI_FROM_CID mapping and CRI_FROM_CID are totaly different.

 get the header, the first entry */

 use first buffer to collect all the data */

 last handle should have final PDU notification from FW */

 check if PDU hdr is rcv'd when old hdr not completed */

 check if data received has header and is needed */

 Something got overwritten? Better catch it here. */

 discard this handle */

 free all the other handles in cri_wait_queue */

 try continuing */

 setup the ring only once */

 note hi is lo */

 num_cons indicates number of 8 RQEs consumed */

 rearm EQ for further interrupts */

/**

 * beiscsi_process_cq()- Process the Completion Queue

 * @pbe_eq: Event Q on which the Completion has come

 * @budget: Max number of events to processed

 *

 * return

 *     Number of Completion Entries processed.

 Get the CID */

			/* connection has already been freed

			 * just move on to next one

 replenish cq */

 driver consumes the entry and drops the contents */

/**

 * hwi_write_buffer()- Populate the WRB with task info

 * @pwrb: ptr to the WRB entry

 * @task: iscsi task which is to be executed

 Check for the data_count */

 Map addr only if there is data_count */

/**

 * beiscsi_find_mem_req()- Find mem needed

 * @phba: ptr to HBA struct

 Allocate memory for wrb_context */

 Allocate memory for WRBQ */

 get async_ctx for each ULP */

 setup header buffers */

 setup header buffer sgls */

 setup header buffer handles */

 setup data buffer sgls */

 setup data buffer handles */

 setup data buffers */

 Get the ULP Count */

		/**

		 * If MCC is still active and waiting then wake up the process.

		 * We are here only because port is going offline. The process

		 * sees that (BEISCSI_HBA_ONLINE is cleared) and EIO error is

		 * returned for the operation and allocated memory cleaned up.

			/*

			 * Control tag info gets reinitialized in enable

			 * so wait for the process to clear running state.

		/**

		 * For MCC with tag_states MCC_TAG_STATE_ASYNC and

		 * MCC_TAG_STATE_IGNORE nothing needs to done.

 Alloc MCC compl queue */

 Ask BE to create MCC compl queue; */

 Alloc MCC queue */

 Ask BE to create MCC queue */

 if eqid_count == 1 fall back to INTX */

	/**

	 * Purge all EQ entries that may have been left out. This is to

	 * workaround a problem we've seen occasionally where driver gets an

	 * interrupt with EQ entry bit set after stopping the controller.

 this ensures complete FW cleanup */

 last communication, indicate driver is unloading */

 set port optic state to unknown */

			/**

			 * Now that the default PDU rings have been created,

			 * let EP know about it.

 Allocate memory for CID array */

 Save the cid_info_array ptr */

/**

 * beiscsi_free_mgmt_task_handles()- Free driver CXN resources

 * @beiscsi_conn: ptr to the conn to be cleaned up

 * @task: ptr to iscsi_task resource to be freed.

 *

 * Free driver mgmt resources binded to CXN.

/**

 * beiscsi_cleanup_task()- Free driver resources of the task

 * @task: ptr to the iscsi task

 *

	/*

	 * We can always use 0 here because it is reserved by libiscsi for

	 * login/startup related tasks.

 Check for the adapter family */

	/*

	 * There is no completion for CONTEXT_UPDATE. The completion of next

	 * WRB posted guarantees FW's processing and DMA'ing of it.

	 * Use beiscsi_put_wrb_handle to put it back in the pool which makes

	 * sure zero'ing or reuse of the WRB only after wrbs_per_cxn.

/**

 * beiscsi_alloc_pdu - allocates pdu and related resources

 * @task: libiscsi task

 * @opcode: opcode of pdu for task

 *

 * This is called with the session lock held. It will allocate

 * the wrb and sgl if needed for the command. And it will prep

 * the pdu's itt. beiscsi_parse_pdu will later translate

 * the pdu itt to the libiscsi task itt.

 Set the task type */

	/**

	 * HBA in error includes BEISCSI_HBA_FW_TIMEOUT. IO path might be

	 * operational if FW still gets heartbeat from EP FW. Is management

	 * path really needed to continue further?

	/**

	 * For scsi cmd task, check num_sg before unmapping in cleanup_task.

	 * For management task, cleanup_task checks mtask_addr before unmapping.

/**

 * beiscsi_bsg_request - handle bsg request from ISCSI transport

 * @job: job to handle

 Set the logging parameter */

 skip if boot work is already in progress */

/*

 * beiscsi_show_boot_tgt_info()

 * Boot flag info for iscsi-utilities

 * Bit 0 Block valid flag

 * Bit 1 Firmware booting selected

 get shost ref because the show function will refer phba */

		/**

		 * updated boot_kset is made visible to all before

		 * ending the boot work.

 completion of this is ignored */

 if not TPE, do nothing */

 wait default 4000ms before recovering */

 sessions are no longer valid, so first fail the sessions */

 detect UER supported */

 modify this timer to check TPE */

/*

 * beiscsi_enable_port()- Enables the disabled port.

 * Only port resources freed in disable function are reallocated.

 * This is called in HBA error handling path.

 *

 * @phba: Instance of driver private structure

 *

 Re-enable UER. If different TPE occurs then it is recoverable. */

 Work item for MCC handling */

 port operational: clear all error bits */

 start hw_check timer and eqd_update work */

	/**

	 * Timer function gets modified for TPE detection.

	 * Always reinit to do health check first.

/*

 * beiscsi_disable_port()- Disable port and cleanup driver resources.

 * This is called in HBA error handling and driver removal.

 * @phba: Instance Priv structure

 * @unload: indicate driver is unloading

 *

 * Free the OS and HW resources held by the driver

 WQ might be running cancel queued mcc_work if we are not exiting */

	/*

	 * This work gets scheduled only in case of HBA error.

	 * Old sessions are gone so need to be re-established.

	 * iscsi_session_failure needs process context hence this work.

 first stop UE detection when PCI error detected */

 sessions are no longer valid, so first fail the sessions */

	/* The error could cause the FW to trigger a flash debug dump.

	 * Resetting the card while flash dump is in progress

	 * can cause it not to recover; wait for it to finish.

	 * Wait only for first function as it is needed only once per

	 * adapter.

 Enable EEH reporting */

 Initialize Driver configuration Paramters */

 Work item for MCC handling */

 set online bit after port is operational */

		/**

		 * Set this bit after starting the work to let

		 * probe handle it first.

		 * ASYNC event can too schedule this work.

	/**

	 * Start UE detection here. UE before this will cause stall in probe

	 * and eventually fail the probe.

 first stop UE detection before unloading */

 after cancelling boot_work */

 free all resources */

 ctrl uninit */

/*

 * This file is part of the Emulex Linux Device Driver for Enterprise iSCSI

 * Host Bus Adapters. Refer to the README file included with this package

 * for driver version and adapter compatibility.

 *

 * Copyright (c) 2018 Broadcom. All Rights Reserved.

 * The term “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of version 2 of the GNU General Public License as published

 * by the Free Software Foundation.

 *

 * This program is distributed in the hope that it will be useful. ALL EXPRESS

 * OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING ANY

 * IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,

 * OR NON-INFRINGEMENT, ARE DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH

 * DISCLAIMERS ARE HELD TO BE LEGALLY INVALID.

 * See the GNU General Public License for more details, a copy of which

 * can be found in the file COPYING included with this package.

 *

 * Contact Information:

 * linux-drivers@broadcom.com

 *

/**

 * mgmt_open_connection()- Establish a TCP CXN

 * @phba: driver priv structure

 * @dst_addr: Destination Address

 * @beiscsi_ep: ptr to device endpoint struct

 * @nonemb_cmd: ptr to memory allocated for command

 *

 * return

 *	Success: Tag number of the MBX Command issued

 *	Failure: Error code

 else its PF_INET6 family */

/**

 * beiscsi_exec_nemb_cmd()- execute non-embedded MBX cmd

 * @phba: driver priv structure

 * @nonemb_cmd: DMA address of the MBX command to be issued

 * @cbfn: callback func on MCC completion

 * @resp_buf: buffer to copy the MBX cmd response

 * @resp_buf_len: response length to be copied

 *

 store DMA mem to be freed in callback */

 with cbfn set, its async cmd, don't wait */

 copy the response, if any */

	/*

	 * If FW is busy the DMA buffer is saved with the tag. When the cmd

	 * completes this buffer is freed.

 status is ignored */

		/*

		 * Only free on failure. Async cmds are handled like -EBUSY

		 * where it's handled for us.

/**

 * beiscsi_get_initiator_name - read initiator name from flash

 * @phba: device priv structure

 * @name: buffer pointer

 * @cfg: fetch user configured

 *

 we now support only one interface per function */

	/**

	 * In some cases, host needs to look into individual record status

	 * even though FW reported success for that IOCTL.

 first delete any IP set */

 if ip == NULL then this is called just to release DHCP IP */

 first delete any IP set */

 delete gateway settings if mode change is to DHCP */

 use ip_type provided in if_info */

 1 - blocking; 0 - non-blocking */

/**

 * beiscsi_if_set_vlan()- Issue and wait for CMD completion

 * @phba: device private structure instance

 * @vlan_tag: VLAN tag

 *

 * Issue the MBX Cmd and wait for the completion of the

 * command.

 *

 * returns

 *	Success: 0

 *	Failure: Non-Xero Value

 Allocate memory for if_info */

 Check if the error is because of Insufficent_Buffer */

 Get the new memory size */

 Free the virtual memory */

 continue to create boot_kset even if logout failed? */

 clear the tag so no other completion matches this tag */

 wait for next event to start boot_work */

/**

 * beiscsi_boot_logout_sess()- Logout from boot FW session

 * @phba: Device priv structure instance

 *

 * return

 *	the TAG used for MBOX Command

 *

 Use the session handle copied into boot_sess */

/**

 * beiscsi_boot_reopen_sess()- Reopen boot session

 * @phba: Device priv structure instance

 *

 * return

 *	the TAG used for MBOX Command

 *

/**

 * beiscsi_boot_get_sinfo()- Get boot session info

 * @phba: device priv structure instance

 *

 * Fetches the boot_struct.s_handle info from FW.

 * return

 *	the TAG used for MBOX Command

 *

/**

 * beiscsi_boot_get_shandle()- Get boot session handle

 * @phba: device priv structure instance

 * @s_handle: session handle returned for boot session.

 *

 * return

 *	Success: 1

 *	Failure: negative

 *

 get configured boot session count and handle */

 check if there are any boot targets configured */

 only if FW has logged in to the boot target, s_handle is valid */

/**

 * beiscsi_drvr_ver_disp()- Display the driver Name and Version

 * @dev: ptr to device not used.

 * @attr: device attribute, not used.

 * @buf: contains formatted text driver name and version

 *

 * return

 * size of the formatted string

/**

 * beiscsi_fw_ver_disp()- Display Firmware Version

 * @dev: ptr to device not used.

 * @attr: device attribute, not used.

 * @buf: contains formatted text Firmware version

 *

 * return

 * size of the formatted string

/**

 * beiscsi_active_session_disp()- Display Sessions Active

 * @dev: ptr to device not used.

 * @attr: device attribute, not used.

 * @buf: contains formatted text Session Count

 *

 * return

 * size of the formatted string

/**

 * beiscsi_free_session_disp()- Display Avaliable Session

 * @dev: ptr to device not used.

 * @attr: device attribute, not used.

 * @buf: contains formatted text Session Count

 *

 * return

 * size of the formatted string

/**

 * beiscsi_adap_family_disp()- Display adapter family.

 * @dev: ptr to device to get priv structure

 * @attr: device attribute, not used.

 * @buf: contains formatted text driver name and version

 *

 * return

 * size of the formatted string

/**

 * beiscsi_phys_port_disp()- Display Physical Port Identifier

 * @dev: ptr to device not used.

 * @attr: device attribute, not used.

 * @buf: contains formatted text port identifier

 *

 * return

 * size of the formatted string

	/**

	 * 0 - non-persistent targets

	 * 1 - save session info on flash

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2017 Broadcom. All Rights Reserved.

 * The term "Broadcom" refers to Broadcom Limited and/or its subsidiaries.

 *

 * Contact Information:

 * linux-drivers@broadcom.com

 UE Status Low CSR */

 UE Status High CSR */

 return this tag for further reference */

/*

 * beiscsi_mcc_compl_status - Return the status of MCC completion

 * @phba: Driver private structure

 * @tag: Tag for the MBX Command

 * @wrb: the WRB used for the MBX Command

 * @mbx_cmd_mem: ptr to memory allocated for MBX Cmd

 *

 * return

 * Success: 0

 * Failure: Non-Zero

/*

 * beiscsi_mccq_compl_wait()- Process completion in MCC CQ

 * @phba: Driver private structure

 * @tag: Tag for the MBX Command

 * @wrb: the WRB used for the MBX Command

 * @mbx_cmd_mem: ptr to memory allocated for MBX Cmd

 *

 * Waits for MBX completion with the passed TAG.

 *

 * return

 * Success: 0

 * Failure: Non-Zero

 wait for the mccq completion */

	/**

	 * Return EIO if port is being disabled. Associated DMA memory, if any,

	 * is freed by the caller. When port goes offline, MCCQ is cleaned up

	 * so does WRB.

	/**

	 * If MBOX cmd timeout expired, tag and resource allocated

	 * for cmd is not freed until FW returns completion.

		/**

		 * PCI/DMA memory allocated and posted in non-embedded mode

		 * will have mbx_cmd_mem != NULL.

		 * Save virtual and bus addresses for the command so that it

		 * can be freed later.

 first make tag_mem_state visible to all */

/*

 * beiscsi_process_mbox_compl()- Check the MBX completion status

 * @ctrl: Function specific MBX data structure

 * @compl: Completion status of MBX Command

 *

 * Check for the MBX completion status when BMBX method used

 *

 * return

 * Success: Zero

 * Failure: Non-Zero

	/**

	 * To check if valid bit is set, check the entire word as we don't know

	 * the endianness of the data (old entry is host endian while a new

	 * entry is little endian)

	/**

	 * Just swap the status to host endian;

	 * mcc tag is opaquely copied from mcc_wrb.

 Need to reset the entire word that houses the valid bit */

	/**

	 * Check logical link status in ASYNC event.

	 * This has been newly introduced in SKH-R Firmware 10.0.338.45.

 processing only MISCONFIGURED physical port event */

 fw is reporting a state we don't know, log and return */

 log link effect for unqualified-4, uncertified-5 optics */

 1 - info */

 2 - error */

 interpret flags as an async trailer */

 event not registered */

 end MCC with this tag */

		/**

		 * Check for the size before freeing resource.

		 * Only for non-embedded cmd, PCI resource is allocated.

	/* The ctrl.mcc_tag_status[tag] is filled with

	 * [31] = valid, [30:24] = Rsvd, [23:16] = wrb, [15:8] = extd_status,

	 * [7:0] = compl_status

 just check completion status and free wrb */

 make request available for DMA */

/*

 * be_mbox_db_ready_poll()- Check ready status

 * @ctrl: Function specific MBX data structure

 *

 * Check for the ready status of FW to send BMBX

 * commands to adapter.

 *

 * return

 * Success: 0

 * Failure: Non-Zero

 wait 30s for generic non-flash MBOX operation */

	/*

	 * This BMBX busy wait path is used during init only.

	 * For the commands executed during init, 5s should suffice.

 1ms sleep is enough in most cases */

/*

 * be_mbox_notify: Notify adapter of new BMBX command

 * @ctrl: Function specific MBX data structure

 *

 * Ring doorbell to inform adapter of a BMBX command

 * to process

 *

 * return

 * Success: 0

 * Failure: Non-Zero

 RDY is set; small delay before CQE read. */

 log2(len) + 1 */

/**

 * be_cmd_create_default_pdu_queue()- Create DEFQ for the adapter

 * @ctrl: ptr to ctrl_info

 * @cq: Completion Queue

 * @dq: Default Queue

 * @length: ring size

 * @entry_size: size of each entry in DEFQ

 * @is_header: Header or Data DEFQ

 * @ulp_num: Bind to which ULP

 *

 * Create HDR/Data DEFQ for the passed ULP. Unsol PDU are posted

 * on this queue by the FW

 *

 * return

 *	Success: 0

 *	Failure: Non-Zero Value

 *

/**

 * be_cmd_wrbq_create()- Create WRBQ

 * @ctrl: ptr to ctrl_info

 * @q_mem: memory details for the queue

 * @wrbq: queue info

 * @pwrb_context: ptr to wrb_context

 * @ulp_num: ULP on which the WRBQ is to be created

 *

 * Create WRBQ on the passed ULP_NUM.

 *

/**

 * be_cmd_set_vlan()- Configure VLAN paramters on the adapter

 * @phba: device priv structure instance

 * @vlan_tag: TAG to be set

 *

 * Set the VLAN_TAG for the adapter or Disable VLAN on adapter

 *

 * returns

 *	TAG for the MBX Cmd

/**

 * beiscsi_get_fw_config()- Get the FW config for the function

 * @ctrl: ptr to Ctrl Info

 * @phba: ptr to the dev priv structure

 *

 * Get the FW config and resources available for the function.

 * The resources are created based on the count received here.

 *

 * return

 *	Success: 0

 *	Failure: Non-Zero Value

 FW response formats depend on port id */

 populate and check FW config against min and max values */

	/**

	 * Check on which all ULP iSCSI Protocol is loaded.

	 * Set the Bit for those ULP. This set flag is used

	 * at all places in the code to check on which ULP

	 * iSCSi Protocol is loaded

 Get the CID, ICD and Chain count for each ULP */

	/**

	 * ICD is shared among ULPs. Use icd_count of any one loaded ULP

	/**

	 * Check FW is dual ULP aware i.e. can handle either

	 * of the protocols.

 all set, continue using this FW config */

/**

 * beiscsi_get_port_name()- Get port name for the function

 * @ctrl: ptr to Ctrl Info

 * @phba: ptr to the dev priv structure

 *

 * Get the alphanumeric character for port

 *

		/**

		 * Check "MCC_STATUS_INVALID_LENGTH" for SKH.

		 * Older FW versions return this error.

		/**

		 * Check "MCC_STATUS_INVALID_LENGTH" for SKH.

		 * Older FW versions return this error.

 to start communicating */

 to stop communicating */

 check POST stage before talking to FW */

 clear all error states after checking FW rdy */

 check again UER support */

	/*

	 * SLI COMMON_FUNCTION_RESET completion is indicated by BMBX RDY bit.

	 * It should clean up any stale info in FW for this fn.

 indicate driver is loading */

/**

 * beiscsi_cmd_iscsi_cleanup()- Inform FW to cleanup EP data structures.

 * @phba: pointer to dev priv structure

 * @ulp: ULP number.

 *

 * return

 *	Success: 0

 *	Failure: Non-Zero Value

 BE2/BE3 FW creates 8-bit ring id */

/*

 * beiscsi_detect_ue()- Detect Unrecoverable Error on adapter

 * @phba: Driver priv structure

 *

 * Read registers linked to UE and check for the UE status

/*

 * beiscsi_detect_tpe()- Detect Transient Parity Error on adapter

 * @phba: Driver priv structure

 *

 * Read SLIPORT SEMAPHORE register to check for UER

 *

 SPDX-License-Identifier: GPL-2.0-only

/*

 * This file is part of the Emulex Linux Device Driver for Enterprise iSCSI

 * Host Bus Adapters. Refer to the README file included with this package

 * for driver version and adapter compatibility.

 *

 * Copyright (c) 2018 Broadcom. All Rights Reserved.

 * The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.

 *

 * Contact Information:

 * linux-drivers@broadcom.com

/**

 * beiscsi_session_create - creates a new iscsi session

 * @ep: pointer to iscsi ep

 * @cmds_max: max commands supported

 * @qdepth: max queue depth supported

 * @initial_cmdsn: initial iscsi CMDSN

/**

 * beiscsi_session_destroy - destroys iscsi session

 * @cls_session:	pointer to iscsi cls session

 *

 * Destroys iSCSI session instance and releases

 * resources allocated for it.

/**

 * beiscsi_session_fail(): Closing session with appropriate error

 * @cls_session: ptr to session

/**

 * beiscsi_conn_create - create an instance of iscsi connection

 * @cls_session: ptr to iscsi_cls_session

 * @cid: iscsi cid

/**

 * beiscsi_conn_bind - Binds iscsi session/connection with TCP connection

 * @cls_session: pointer to iscsi cls session

 * @cls_conn: pointer to iscsi cls conn

 * @transport_fd: EP handle(64 bit)

 * @is_leading: indicate if this is the session leading connection (MCS)

 *

 * This function binds the TCP Conn with iSCSI Connection and Session.

	/**

	 * Each connection is associated with a WRBQ kept in wrb_context.

	 * Store doorbell offset for transmit path.

/**

 * beiscsi_iface_config_vlan()- Set the VLAN TAG

 * @shost: Scsi Host for the driver instance

 * @iface_param: Interface paramters

 *

 * Set the VLAN TAG for the adapter or disable

 * the VLAN config

 *

 * returns

 *	Success: 0

 *	Failure: Non-Zero Value

 Check the param */

 release DHCP IP address */

		/*

		 * OPCODE_COMMON_ISCSI_NTWK_MODIFY_IP_ADDR ioctl needs IP

		 * and subnet both. Find IP to be applied for this subnet.

 update interface_handle */

		/*

		 * BE2ISCSI only supports 1 interface

/**

 * beiscsi_ep_get_param - get the iscsi parameter

 * @ep: pointer to iscsi ep

 * @param: parameter type identifier

 * @buf: buffer pointer

 *

 * returns iscsi parameter

	/*

	 * If userspace tried to set the value to higher than we can

	 * support override here.

/**

 * beiscsi_get_port_state - Get the Port State

 * @shost : pointer to scsi_host structure

 *

/**

 * beiscsi_get_port_speed  - Get the Port Speed from Adapter

 * @shost : pointer to scsi_host structure

 *

/**

 * beiscsi_get_host_param - get the iscsi parameter

 * @shost: pointer to scsi_host structure

 * @param: parameter type identifier

 * @buf: buffer pointer

 *

 try fetching user configured name first */

/**

 * beiscsi_conn_get_stats - get the iscsi stats

 * @cls_conn: pointer to iscsi cls conn

 * @stats: pointer to iscsi_stats structure

 *

 * returns iscsi stats

/**

 * beiscsi_set_params_for_offld - get the parameters for offload

 * @beiscsi_conn: pointer to beiscsi_conn

 * @params: pointer to offload_params structure

/**

 * beiscsi_conn_start - offload of session to chip

 * @cls_conn: pointer to beiscsi_conn

/**

 * beiscsi_get_cid - Allocate a cid

 * @phba: The phba instance

 Find the ULP which has more CID available */

	/**

	 * If iSCSI protocol is loaded only on ULP 0, and when cid_avlbl_ulp

	 * is ZERO for both, ULP 1 is returned.

	 * Check if ULP is loaded before getting new CID.

 empty the slot */

/**

 * beiscsi_put_cid - Free the cid

 * @phba: The phba for which the cid is being freed

 * @cid: The cid to free

 fill only in empty slot */

/**

 * beiscsi_free_ep - free endpoint

 * @beiscsi_ep: pointer to device endpoint struct

 clear this to track freeing in beiscsi_ep_disconnect */

	/**

	 * Check if any connection resource allocated by driver

	 * is to be freed.This case occurs when target redirection

	 * or connection retry is done.

	/**

	 * Break ep->conn link here so that completions after

	 * this are ignored.

/**

 * beiscsi_open_conn - Ask FW to open a TCP connection

 * @ep: pointer to device endpoint struct

 * @src_addr: The source IP address

 * @dst_addr: The Destination  IP address

 * @non_blocking: blocking or non-blocking call

 *

 * Asks the FW to open a TCP connection

/**

 * beiscsi_ep_connect - Ask chip to create TCP Conn

 * @shost: Pointer to scsi_host structure

 * @dst_addr: The IP address of Target

 * @non_blocking: blocking or non-blocking call

 *

 * This routines first asks chip to create a connection and then allocates an EP

/**

 * beiscsi_ep_poll - Poll to see if connection is established

 * @ep:	endpoint to be used

 * @timeout_ms: timeout specified in millisecs

 *

 * Poll to see if TCP connection established

/**

 * beiscsi_flush_cq()- Flush the CQ created.

 * @phba: ptr device priv structure.

 *

 * Before the connection resource are freed flush

 * all the CQ enteries

/**

 * beiscsi_conn_close - Invalidate and upload connection

 * @beiscsi_ep: pointer to device endpoint struct

 *

 * Returns 0 on success,  -1 on failure.

	/**

	 * Without successfully invalidating and uploading connection

	 * driver can't reuse the CID so attempt more than once.

 wait for all completions to arrive, then process them */

 flush CQ entries */

/**

 * beiscsi_ep_disconnect - Tears down the TCP connection

 * @ep:	endpoint to be used

 *

 * Tears down the TCP connection

		/**

		 * Make CID available even if close fails.

		 * If not freed, FW might fail open using the CID.

/*

*******************************************************************************

**        O.S   : Linux

**   FILE NAME  : arcmsr_attr.c

**        BY    : Nick Cheng

**   Description: attributes exported to sysfs and device host

*******************************************************************************

** Copyright (C) 2002 - 2005, Areca Technology Corporation All rights reserved

**

**     Web site: www.areca.com.tw

**       E-mail: support@areca.com.tw

**

** This program is free software; you can redistribute it and/or modify

** it under the terms of the GNU General Public License version 2 as

** published by the Free Software Foundation.

** This program is distributed in the hope that it will be useful,

** but WITHOUT ANY WARRANTY; without even the implied warranty of

** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

** GNU General Public License for more details.

*******************************************************************************

** Redistribution and use in source and binary forms, with or without

** modification, are permitted provided that the following conditions

** are met:

** 1. Redistributions of source code must retain the above copyright

**    notice, this list of conditions and the following disclaimer.

** 2. Redistributions in binary form must reproduce the above copyright

**    notice, this list of conditions and the following disclaimer in the

**    documentation and/or other materials provided with the distribution.

** 3. The name of the author may not be used to endorse or promote products

**    derived from this software without specific prior written permission.

**

** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR

** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES

** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.

** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,

** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING,BUT

** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,

** DATA, OR PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY

** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

** (INCLUDING NEGLIGENCE OR OTHERWISE)ARISING IN ANY WAY OUT OF THE USE OF

** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*******************************************************************************

** For history of changes, see Documentation/scsi/ChangeLog.arcmsr

**     Firmware Specification, see Documentation/scsi/arcmsr_spec.rst

*******************************************************************************

 do message unit read. */

 do message unit write. */

need retry*/

/*

*******************************************************************************

**        O.S   : Linux

**   FILE NAME  : arcmsr_hba.c

**        BY    : Nick Cheng, C.L. Huang

**   Description: SCSI RAID Device Driver for Areca RAID Controller

*******************************************************************************

** Copyright (C) 2002 - 2014, Areca Technology Corporation All rights reserved

**

**     Web site: www.areca.com.tw

**       E-mail: support@areca.com.tw

**

** This program is free software; you can redistribute it and/or modify

** it under the terms of the GNU General Public License version 2 as

** published by the Free Software Foundation.

** This program is distributed in the hope that it will be useful,

** but WITHOUT ANY WARRANTY; without even the implied warranty of

** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

** GNU General Public License for more details.

*******************************************************************************

** Redistribution and use in source and binary forms, with or without

** modification, are permitted provided that the following conditions

** are met:

** 1. Redistributions of source code must retain the above copyright

**    notice, this list of conditions and the following disclaimer.

** 2. Redistributions in binary form must reproduce the above copyright

**    notice, this list of conditions and the following disclaimer in the

**    documentation and/or other materials provided with the distribution.

** 3. The name of the author may not be used to endorse or promote products

**    derived from this software without specific prior written permission.

**

** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR

** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES

** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.

** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,

** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING,BUT

** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,

** DATA, OR PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY

** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

** (INCLUDING NEGLIGENCE OR OTHERWISE)ARISING IN ANY WAY OUT OF THE USE OF

** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*******************************************************************************

** For history of changes, see Documentation/scsi/ChangeLog.arcmsr

**     Firmware Specification, see Documentation/scsi/arcmsr_spec.rst

*******************************************************************************

 Terminating entry */

/*

****************************************************************************

****************************************************************************

clear interrupt*/

clear interrupt*/

 synchronize doorbell to 0 */

 clear interrupt */

 max 20 seconds */

 max 20 seconds */

clear interrupt*/

 max 20 seconds */

 max 20 seconds */

clear interrupt*/

 max 20 seconds */

 enlarge wait flush adapter cache time: 10 minute */

 host buffer low address, bit0:1 all buffer active */

 host buffer high address */

 set host buffer physical address */

 max 4M byte */

16:8*/

this is issue of 64bit LBA ,over 2T byte*/

 max simultaneous cmds */

 disable all outbound interrupt */

 disable outbound message0 int */

 disable all outbound interrupt */

 Dummy readl to force pci flush */

clear and abort all outbound posted Q*/

clear interrupt*/

clear all outbound posted Q*/

 clear doorbell interrupt */

need to do*/

 FIXME: need spinlock */

 Get the physical address of the current data pointer */

if last index number set it to 0 */

		/*

		** push inbound doorbell tell iop, driver data write ok

		** and wait reply on next hwinterrupt for next Qbuffer post

		/*

		** push inbound doorbell tell iop, driver data write ok

		** and wait reply on next hwinterrupt for next Qbuffer post

		/*

		** push inbound doorbell tell iop, driver data write ok

		** and wait reply on next hwinterrupt for next Qbuffer post

 if last, index number set it to 0 */

 let IOP know data has been read */

	/*

	*******************************************************************

	**  Maybe here we need to check wrqbuffer_lock is lock or not

	**  DOORBELL: din! don!

	**  check if there are any mail need to pack from firmware

	*******************************************************************

 clear interrupt */

 areca cdb command done */

 Use correct offset and size for syncing */

 check if command done with no error */

/*

**********************************************************************************

** Handle a message interrupt

**

** The only message interrupt we expect is in response to a query for the current adapter config.  

** We want this in order to compare the drivemap so that we can detect newly-attached drives.

**********************************************************************************

clear interrupt and message state*/

clear interrupt and message state*/

/*

**********************************************************************************

** Handle a message interrupt

**

** The only message interrupt we expect is in response to a query for the

** current adapter config.

** We want this in order to compare the drivemap so that we can detect newly-attached drives.

**********************************************************************************

clear interrupt and message state*/

	/*

	*********************************************

	**   check outbound intstatus

	*********************************************

 MU post queue interrupts*/

 MU post queue interrupts*/

 MU ioctl transfer doorbell interrupts*/

 MU post queue interrupts*/

 MU post queue interrupts*/

 MU ioctl transfer doorbell interrupts*/

 stop adapter background rebuild */

 has error report sensedata */

 Periph Qualifier & Periph Dev Type */

 rem media bit & Dev Type Modifier */

 ISO, ECMA, & ANSI versions */

 length of additional data */

 Vendor Identification */

 Product Identification */

 Product Revision */

 virtual device for iop message transfer */

 disable all outbound interrupt */

 disable outbound message0 int */

 wait firmware ready */

 post "get config" instruction */

 wait message ready */

clear interrupt*/

 post "get config" instruction */

 wait message ready */

 disable all outbound interrupt */

 disable outbound message0 int */

 wait firmware ready */

 post "get config" instruction */

 wait message ready */

 disable all outbound interrupt */

 disable outbound message0 int */

 wait firmware ready */

 post "get config" instruction */

 wait message ready */

clear interrupt*/

 clear doorbell interrupt */

if last index number set it to 0 */

 check if command done with no error*/

 check ifcommand done with no error*/

 check if command done with no error*/

 base 2000 instead of 1900 */

	/*

	********************************************************************

	** here we need to tell iop 331 our freeccb.HighPart

	** if freeccb.HighPart is not zero

	********************************************************************

	/*

	***********************************************************************

	**    if adapter type B, set window of "post command Q"

	***********************************************************************

 driver "set config" signature */

 normal should be zero */

 postQ size (256 + 8)*4	 */

 doneQ size (256 + 8)*4	 */

 ccb maxQ size must be --> [(256 + 8)*4]*/

 empty doorbell Qbuffer if door bell ringed */

clear doorbell interrupt */

 let IOP know data has been read */

 empty doorbell Qbuffer if door bell ringed */

 empty doorbell Qbuffer if door bell ringed */

clear interrupt*/

clear interrupt*/

 backup pci config data */

 hardware reset signal */

 write back pci config data */

 disable all outbound interrupt */

start background rebuild*/

 empty doorbell Qbuffer if door bell ringed */

 enable outbound Post Queue,outbound doorbell Interrupt */

 disable all outbound interrupt */

 talk to iop 331 outstanding command aborted */

 clear all outbound posted Q */

 enable all outbound interrupt */

	/*

	************************************************

	** the all interrupt service routine is locked

	** we need to handle it as soon as possible and exit

	************************************************

/*******************************************************************

 * This file is part of the Emulex Linux Device Driver for         *

 * Fibre Channel Host Bus Adapters.                                *

 * Copyright (C) 2017-2021 Broadcom. All Rights Reserved. The term *

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.     *

 * Copyright (C) 2004-2016 Emulex.  All rights reserved.           *

 * EMULEX and SLI are trademarks of Emulex.                        *

 * www.broadcom.com                                                *

 * Portions Copyright (C) 2004-2005 Christoph Hellwig              *

 *                                                                 *

 * This program is free software; you can redistribute it and/or   *

 * modify it under the terms of version 2 of the GNU General       *

 * Public License as published by the Free Software Foundation.    *

 * This program is distributed in the hope that it will be useful. *

 * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *

 * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *

 * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *

 * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *

 * TO BE LEGALLY INVALID.  See the GNU General Public License for  *

 * more details, a copy of which can be found in the file COPYING  *

 * included with this package.                                     *

 AlpaArray for assignment of scsid for scan-down and bind_method */

/* The source of a terminate rport I/O is either a dev_loss_tmo

 * event or a call to fc_remove_host.  While the rport should be

 * valid during these downcalls, the transport can call twice

 * in a single event.  This routine provides somoe protection

 * as the NDLP isn't really free, just released to the pool.

/*

 * This function will be called when dev_loss_tmo fire.

	/* Don't schedule a worker thread event if the vport is going down.

	 * The teardown process cleans up the node via lpfc_drop_node.

		/* Remove the node reference from remote_port_add now.

		 * The driver will not call remote_port_delete.

	/* If there is a PLOGI in progress, and we are in a

	 * NLP_NPR_2B_DISC state, don't turn off the flag.

	/*

	 * The backend does not expect any more calls associated with this

	 * rport. Remove the association between rport and ndlp.

	/* We need to hold the node by incrementing the reference

	 * count until this queued work is done

/**

 * lpfc_check_inactive_vmid_one - VMID inactivity checker for a vport

 * @vport: Pointer to vport context object.

 *

 * This function checks for idle VMID entries related to a particular vport. If

 * found unused/idle, free them accordingly.

 iterate through the table */

 check if the particular VMID is in use */

 for all available per cpu variable */

 if last access time is less than timeout */

 if none of the cpus have been used by the vm, */

  remove the entry if already registered */

 mark the entry for deregistration */

 decrement number of active vms and mark */

 entry in slot as free */

/**

 * lpfc_check_inactive_vmid - VMID inactivity checker

 * @phba: Pointer to hba context object.

 *

 * This function is called from the worker thread to determine if an entry in

 * the VMID table can be released since there was no I/O activity seen from that

 * particular VM for the specified time. When this happens, the entry in the

 * table is released and also the resources on the switch cleared.

/**

 * lpfc_check_nlp_post_devloss - Check to restore ndlp refcnt after devloss

 * @vport: Pointer to vport object.

 * @ndlp: Pointer to remote node object.

 *

 * If NLP_IN_RECOV_POST_DEV_LOSS flag was set due to outstanding recovery of

 * node during dev_loss_tmo processing, then this function restores the nlp_put

 * kref decrement from lpfc_dev_loss_tmo_handler.

/**

 * lpfc_dev_loss_tmo_handler - Remote node devloss timeout handler

 * @ndlp: Pointer to remote node object.

 *

 * This function is called from the worker thread when devloss timeout timer

 * expires. For SLI4 host, this routine shall return 1 when at lease one

 * remote node, including this @ndlp, is still in use of FCF; otherwise, this

 * routine shall return 0 when there is no remote node is still in use of FCF

 * when devloss timeout happened to this @ndlp.

 If the driver is recovering the rport, ignore devloss. */

 Fabric nodes are done. */

		/* In massive vport configuration settings, it's possible

		 * dev_loss_tmo fired during node recovery.  So, check if

		 * fabric nodes are in discovery states outstanding.

		/* Mark an NLP_IN_RECOV_POST_DEV_LOSS flag to know if reversing

		 * the following lpfc_nlp_put is necessary after fabric node is

		 * recovered.

			/* Fabric node fully recovered before this dev_loss_tmo

			 * queue work is processed.  Thus, ignore the

			 * dev_loss_tmo event.

	/* If we are devloss, but we are in the process of rediscovering the

	 * ndlp, don't issue a NLP_EVT_DEVICE_RM event.

/**

 * lpfc_sli4_post_dev_loss_tmo_handler - SLI4 post devloss timeout handler

 * @phba: Pointer to hba context object.

 * @fcf_inuse: SLI4 FCF in-use state reported from devloss timeout handler.

 * @nlp_did: remote node identifer with devloss timeout.

 *

 * This function is called from the worker thread after invoking devloss

 * timeout handler and releasing the reference count for the ndlp with

 * which the devloss timeout was handled for SLI4 host. For the devloss

 * timeout of the last remote node which had been in use of FCF, when this

 * routine is invoked, it shall be guaranteed that none of the remote are

 * in-use of FCF. When devloss timeout to the last remote using the FCF,

 * if the FIP engine is neither in FCF table scan process nor roundrobin

 * failover process, the in-use FCF shall be unregistered. If the FIP

 * engine is in FCF discovery process, the devloss timeout state shall

 * be set for either the FCF table scan process or roundrobin failover

 * process to unregister the in-use FCF.

	/* If devloss timeout happened to a remote node when FCF had no

	 * longer been in-use, do nothing.

 Unregister in-use FCF and rescan */

/**

 * lpfc_alloc_fast_evt - Allocates data structure for posting event

 * @phba: Pointer to hba context object.

 *

 * This function is called from the functions which need to post

 * events from interrupt context. This function allocates data

 * structure required for posting event. It also keeps track of

 * number of events pending and prevent event storm when there are

 * too many events.

 If there are lot of fast event do not exhaust memory due to this */

/**

 * lpfc_free_fast_evt - Frees event data structure

 * @phba: Pointer to hba context object.

 * @evt:  Event object which need to be freed.

 *

 * This function frees the data structure required for posting

 * events.

/**

 * lpfc_send_fastpath_evt - Posts events generated from fast path

 * @phba: Pointer to hba context object.

 * @evtp: Event data structure.

 *

 * This function is called from worker thread, when the interrupt

 * context need to post an event. This function posts the event

 * to fc transport netlink interface.

 evt is part of ndlp */

			/* decrement the node reference count held

			 * for this queued work

			/* decrement the node reference count held for

			 * this queued work

			/* decrement the node reference count held for

			 * this queued work

 First, try to post the next mailbox command to SLI4 device */

 Handle the error attention event */

 Handle VMID Events */

 Process SLI4 events */

			/*

			 * We could have no vports in array if unloading, so if

			 * this happens then just use the pport

 Preserve legacy behavior. */

			/* Driver could have abort request completed in queue

			 * when link goes down.  Allow for this transition.

		/*

		 * Turn on Ring interrupts

 flush */

 wait and check worker queue activities */

 Signal wakeup shall terminate the worker thread */

 Attend pending lpfc data processing */

/*

 * This is only called to handle FC worker events. Since this a rare

 * occurrence, we allocate a struct lpfc_work_evt structure here instead of

 * embedding it in the IOCB.

	/*

	 * All Mailbox completions and LPFC_ELS_RING rcv ring IOCB events will

	 * be queued to worker thread for processing

			/* It's possible the FLOGI to the fabric node never

			 * successfully completed and never registered with the

			 * transport.  In this case there is no way to clean up

			 * the node.

 Leave Fabric nodes alone on link down */

 Notify transport of connectivity loss to trigger cleanup. */

 Cleanup any outstanding received buffers */

 Cleanup any outstanding RSCN activity */

 Cleanup any outstanding ELS commands */

 Turn off discovery timer if its running */

 Stop delayed Nport discovery */

 Block all SCSI stack I/Os */

 Issue a LINK DOWN event to all nodes */

 Clean up any SLI3 firmware default rpi's */

 Setup myDID for link up if we are in pt2pt mode */

			/* On Linkup its safe to clean up the ndlp

			 * from Fabric connections.

			/* Fail outstanding IO now since device is

			 * marked for PLOGI.

 If NPIV is not enabled, only bring the physical port up */

 Unblock fabric iocbs if they are blocked */

	/* Clear the pport flogi counter in case the link down was

	 * absorbed without an ACQE. No lock here - in worker thread

	 * and discovery is synchronized.

 reinitialize initial FLOGI flag */

/*

 * This routine handles processing a CLEAR_LA mailbox

 * command upon completion. It is setup in the LPFC_MBOXQ

 * as the completion routine when the command is

 * handed off to the SLI layer. SLI3 only.

 Since we don't do discovery right now, turn these off here */

 Check for error */

 CLEAR_LA mbox error <mbxStatus> state <hba_state> */

 flush */

 Device Discovery completes */

 turn on Link Attention interrupts */

 flush */

 don't perform discovery for SLI4 loopback diagnostic test */

			/* Need to wait for FAN - use discovery timer

			 * for timeout.  port_state is identically

			 * LPFC_LOCAL_CFG_LINK while waiting for FAN

	/* Start discovery by sending a FLOGI. port_state is identically

	 * LPFC_FLOGI while waiting for FLOGI cmpl.

		/* Issue MBX_READ_SPARAM to update CSPs before FLOGI if

		 * bb-credit recovery is in place.

/**

 * lpfc_sli4_clear_fcf_rr_bmask

 * @phba: pointer to the struct lpfc_hba for this port.

 * This fucnction resets the round robin bit mask and clears the

 * fcf priority list. The list deletions are done while holding the

 * hbalock. The ON_LIST flag and the FLOGI_FAILED flags are cleared

 * from the lpfc_fcf_pri record.

 Start FCoE discovery by sending a FLOGI. */

 Set the FCFI registered flag */

 If there is a pending FCoE event, restart FCF table scan. */

 Mark successful completion of FCF table scan */

/**

 * lpfc_fab_name_match - Check if the fcf fabric name match.

 * @fab_name: pointer to fabric name.

 * @new_fcf_record: pointer to fcf record.

 *

 * This routine compare the fcf record's fabric name with provided

 * fabric name. If the fabric name are identical this function

 * returns 1 else return 0.

/**

 * lpfc_sw_name_match - Check if the fcf switch name match.

 * @sw_name: pointer to switch name.

 * @new_fcf_record: pointer to fcf record.

 *

 * This routine compare the fcf record's switch name with provided

 * switch name. If the switch name are identical this function

 * returns 1 else return 0.

/**

 * lpfc_mac_addr_match - Check if the fcf mac address match.

 * @mac_addr: pointer to mac address.

 * @new_fcf_record: pointer to fcf record.

 *

 * This routine compare the fcf record's mac address with HBA's

 * FCF mac address. If the mac addresses are identical this function

 * returns 1 else return 0.

/**

 * __lpfc_update_fcf_record_pri - update the lpfc_fcf_pri record.

 * @phba: pointer to lpfc hba data structure.

 * @fcf_index: Index for the lpfc_fcf_record.

 * @new_fcf_record: pointer to hba fcf record.

 *

 * This routine updates the driver FCF priority record from the new HBA FCF

 * record. The hbalock is asserted held in the code path calling this

 * routine.

 FCF record priority */

/**

 * lpfc_copy_fcf_record - Copy fcf information to lpfc_hba.

 * @fcf_rec: pointer to driver fcf record.

 * @new_fcf_record: pointer to fcf record.

 *

 * This routine copies the FCF information from the FCF

 * record to lpfc_hba data structure.

 Fabric name */

 Mac address */

 FCF record index */

 FCF record priority */

 Switch name */

/**

 * __lpfc_update_fcf_record - Update driver fcf record

 * @phba: pointer to lpfc hba data structure.

 * @fcf_rec: pointer to driver fcf record.

 * @new_fcf_record: pointer to hba fcf record.

 * @addr_mode: address mode to be set to the driver fcf record.

 * @vlan_id: vlan tag to be set to the driver fcf record.

 * @flag: flag bits to be set to the driver fcf record.

 *

 * This routine updates the driver FCF record from the new HBA FCF record

 * together with the address mode, vlan_id, and other informations. This

 * routine is called with the hbalock held.

 Copy the fields from the HBA's FCF record */

 Update other fields of driver FCF record */

/**

 * lpfc_register_fcf - Register the FCF with hba.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine issues a register fcfi mailbox command to register

 * the fcf with HBA.

 If the FCF is not available do nothing. */

 The FCF is already registered, start discovery */

/**

 * lpfc_match_fcf_conn_list - Check if the FCF record can be used for discovery.

 * @phba: pointer to lpfc hba data structure.

 * @new_fcf_record: pointer to fcf record.

 * @boot_flag: Indicates if this record used by boot bios.

 * @addr_mode: The address mode to be used by this FCF

 * @vlan_id: The vlan id to be used as vlan tagging by this FCF.

 *

 * This routine compare the fcf record with connect list obtained from the

 * config region to decide if this FCF can be used for SAN discovery. It returns

 * 1 if this record can be used for SAN discovery else return zero. If this FCF

 * record can be used for SAN discovery, the boot_flag will indicate if this FCF

 * is used by boot bios and addr_mode will indicate the addressing mode to be

 * used for this FCF when the function returns.

 * If the FCF record need to be used with a particular vlan id, the vlan is

 * set in the vlan_id on return of the function. If not VLAN tagging need to

 * be used with the FCF vlan_id will be set to LPFC_FCOE_NULL_VID;

 Find the lowest VLAN id in the FCF record */

 FCF not valid/available or solicitation in progress */

	/*

	 * If there are no FCF connection table entry, driver connect to all

	 * FCFs.

		/*

		 * When there are no FCF connect entries, use driver's default

		 * addressing mode - FPMA.

 If FCF record report a vlan id use that vlan id */

			/*

			 * If the vlan bit map does not have the bit set for the

			 * vlan id to be used, then it is not a match.

		/*

		 * If connection record does not support any addressing mode,

		 * skip the FCF record.

		/*

		 * Check if the connection record specifies a required

		 * addressing mode.

			/*

			 * If SPMA required but FCF not support this continue.

			/*

			 * If FPMA required but FCF not support this continue.

		/*

		 * This fcf record matches filtering criteria.

		/*

		 * If user did not specify any addressing mode, or if the

		 * preferred addressing mode specified by user is not supported

		 * by FCF, allow fabric to pick the addressing mode.

		/*

		 * If the user specified a required address mode, assign that

		 * address mode

		/*

		 * If the user specified a preferred address mode, use the

		 * addr mode only if FCF support the addr_mode.

 If matching connect list has a vlan id, use it */

		/*

		 * If no vlan id is specified in connect list, use the vlan id

		 * in the FCF record

/**

 * lpfc_check_pending_fcoe_event - Check if there is pending fcoe event.

 * @phba: pointer to lpfc hba data structure.

 * @unreg_fcf: Unregister FCF if FCF table need to be re-scaned.

 *

 * This function check if there is any fcoe event pending while driver

 * scan FCF entries. If there is any pending event, it will restart the

 * FCF saning and return 1 else return 0.

	/*

	 * If the Link is up and no FCoE events while in the

	 * FCF discovery, no need to restart FCF discovery.

		/*

		 * Do not continue FCF discovery and clear FCF_TS_INPROG

		 * flag

 Unregister the currently registered FCF if required */

/**

 * lpfc_sli4_new_fcf_random_select - Randomly select an eligible new fcf record

 * @phba: pointer to lpfc hba data structure.

 * @fcf_cnt: number of eligible fcf record seen so far.

 *

 * This function makes an running random selection decision on FCF record to

 * use through a sequence of @fcf_cnt eligible FCF records with equal

 * probability. To perform integer manunipulation of random numbers with

 * size unit32_t, the lower 16 bits of the 32-bit random number returned

 * from prandom_u32() are taken as the random random number generated.

 *

 * Returns true when outcome is for the newly read FCF record should be

 * chosen; otherwise, return false when outcome is for keeping the previously

 * chosen FCF record.

 Get 16-bit uniform random number */

 Decision with probability 1/fcf_cnt */

/**

 * lpfc_sli4_fcf_rec_mbox_parse - Parse read_fcf mbox command.

 * @phba: pointer to lpfc hba data structure.

 * @mboxq: pointer to mailbox object.

 * @next_fcf_index: pointer to holder of next fcf index.

 *

 * This routine parses the non-embedded fcf mailbox command by performing the

 * necessarily error checking, non-embedded read FCF record mailbox command

 * SGE parsing, and endianness swapping.

 *

 * Returns the pointer to the new FCF record in the non-embedded mailbox

 * command DMA memory if successfully, other NULL.

	/* Get the first SGE entry from the non-embedded DMA memory. This

	 * routine only uses a single SGE.

 Interpreting the returned information of the FCF record */

/**

 * lpfc_sli4_log_fcf_record_info - Log the information of a fcf record

 * @phba: pointer to lpfc hba data structure.

 * @fcf_record: pointer to the fcf record.

 * @vlan_id: the lowest vlan identifier associated to this fcf record.

 * @next_fcf_index: the index to the next fcf record in hba's fcf table.

 *

 * This routine logs the detailed FCF record if the LOG_FIP loggin is

 * enabled.

/**

 * lpfc_sli4_fcf_record_match - testing new FCF record for matching existing FCF

 * @phba: pointer to lpfc hba data structure.

 * @fcf_rec: pointer to an existing FCF record.

 * @new_fcf_record: pointer to a new FCF record.

 * @new_vlan_id: vlan id from the new FCF record.

 *

 * This function performs matching test of a new FCF record against an existing

 * FCF record. If the new_vlan_id passed in is LPFC_FCOE_IGNORE_VID, vlan id

 * will not be used as part of the FCF record matching criteria.

 *

 * Returns true if all the fields matching, otherwise returns false.

/**

 * lpfc_sli4_fcf_rr_next_proc - processing next roundrobin fcf

 * @vport: Pointer to vport object.

 * @fcf_index: index to next fcf.

 *

 * This function processing the roundrobin fcf failover to next fcf index.

 * When this function is invoked, there will be a current fcf registered

 * for flogi.

 * Return: 0 for continue retrying flogi on currently registered fcf;

 *         1 for stop flogi on currently registered fcf;

 Mark the end to FLOGI roundrobin failover */

 Allow action to new fcf asynchronous event */

/**

 * lpfc_sli4_fcf_pri_list_del

 * @phba: pointer to lpfc hba data structure.

 * @fcf_index: the index of the fcf record to delete

 * This routine checks the on list flag of the fcf_index to be deleted.

 * If it is one the list then it is removed from the list, and the flag

 * is cleared. This routine grab the hbalock before removing the fcf

 * record from the list.

/**

 * lpfc_sli4_set_fcf_flogi_fail

 * @phba: pointer to lpfc hba data structure.

 * @fcf_index: the index of the fcf record to update

 * This routine acquires the hbalock and then set the LPFC_FCF_FLOGI_FAILED

 * flag so the the round robin slection for the particular priority level

 * will try a different fcf record that does not have this bit set.

 * If the fcf record is re-read for any reason this flag is cleared brfore

 * adding it to the priority list.

/**

 * lpfc_sli4_fcf_pri_list_add

 * @phba: pointer to lpfc hba data structure.

 * @fcf_index: the index of the fcf record to add

 * @new_fcf_record: pointer to a new FCF record.

 * This routine checks the priority of the fcf_index to be added.

 * If it is a lower priority than the current head of the fcf_pri list

 * then it is added to the list in the right order.

 * If it is the same priority as the current head of the list then it

 * is added to the head of the list and its bit in the rr_bmask is set.

 * If the fcf_index to be added is of a higher priority than the current

 * head of the list then the rr_bmask is cleared, its bit is set in the

 * rr_bmask and it is added to the head of the list.

 * returns:

 * 0=success 1=failure

 Empty rr list */

 fcfs_at_this_priority_level = 1; */

 fcfs_at_this_priority_level++; */

 we use = instead of |= to clear the FLOGI_FAILED flag. */

/**

 * lpfc_mbx_cmpl_fcf_scan_read_fcf_rec - fcf scan read_fcf mbox cmpl handler.

 * @phba: pointer to lpfc hba data structure.

 * @mboxq: pointer to mailbox object.

 *

 * This function iterates through all the fcf records available in

 * HBA and chooses the optimal FCF record for discovery. After finding

 * the FCF for discovery it registers the FCF record and kicks start

 * discovery.

 * If FCF_IN_USE flag is set in currently used FCF, the routine tries to

 * use an FCF record which matches fabric name and mac address of the

 * currently used FCF record.

 * If the driver supports only one FCF, it will try to use the FCF record

 * used by BOOT_BIOS.

 If there is pending FCoE event restart FCF table scan */

 Parse the FCF record from the non-embedded mailbox command */

 Let next new FCF event trigger fast failover */

 Check the FCF record against the connection list */

 Log the FCF record information if turned on */

	/*

	 * If the fcf record does not match with connect list entries

	 * read the next entry; otherwise, this is an eligible FCF

	 * record for roundrobin FCF failover.

			/*

			 * In case the current in-use FCF record becomes

			 * invalid/unavailable during FCF discovery that

			 * was not triggered by fast FCF failover process,

			 * treat it as fast FCF failover.

	/*

	 * If this is not the first FCF discovery of the HBA, use last

	 * FCF record for the discovery. The condition that a rescan

	 * matches the in-use FCF record: fabric name, switch name, mac

	 * address, and vlan_id.

 Stop FCF redisc wait timer */

 Fast failover, mark completed */

		/*

		 * Read next FCF record from HBA searching for the matching

		 * with in-use record only if not during the fast failover

		 * period. In case of fast failover period, it shall try to

		 * determine whether the FCF record just read should be the

		 * next candidate.

	/*

	 * Update on failover FCF record only if it's in FCF fast-failover

	 * period; otherwise, update on current FCF record.

		/*

		 * If the driver FCF record does not have boot flag

		 * set and new hba fcf record has boot flag set, use

		 * the new hba fcf record.

 Choose this FCF record */

		/*

		 * If the driver FCF record has boot flag set and the

		 * new hba FCF record does not have boot flag, read

		 * the next FCF record.

		/*

		 * If the new hba FCF record has lower priority value

		 * than the driver FCF record, use the new record.

 Choose the new FCF record with lower priority */

 Reset running random FCF selection count */

 Update running random FCF selection count */

 Choose the new FCF by random selection */

	/*

	 * This is the first suitable FCF record, choose this record for

	 * initial best-fit FCF.

 Setup initial running random FCF selection count */

			/*

			 * Case of FCF fast failover scan

			/*

			 * It has not found any suitable FCF record, cancel

			 * FCF scan inprogress, and do nothing

 Unregister in-use FCF and rescan */

				/*

				 * Let next new FCF event trigger fast failover

			/*

			 * It has found a suitable FCF record that is not

			 * the same as in-use FCF record, unregister the

			 * in-use FCF record, replace the in-use FCF record

			 * with the new FCF record, mark FCF fast failover

			 * completed, and then start register the new FCF

			 * record.

 Unregister the current in-use FCF record */

 Replace in-use record with the new record */

			/*

			 * Mark the fast FCF failover rediscovery completed

			 * and the start of the first round of the roundrobin

			 * FCF failover.

 Register to the new FCF record */

			/*

			 * In case of transaction period to fast FCF failover,

			 * do nothing when search to the end of the FCF table.

				/*

				 * In case the current in-use FCF record no

				 * longer existed during FCF discovery that

				 * was not triggered by fast FCF failover

				 * process, treat it as fast FCF failover.

 Register to the new FCF record */

/**

 * lpfc_mbx_cmpl_fcf_rr_read_fcf_rec - fcf roundrobin read_fcf mbox cmpl hdler

 * @phba: pointer to lpfc hba data structure.

 * @mboxq: pointer to mailbox object.

 *

 * This is the callback function for FLOGI failure roundrobin FCF failover

 * read FCF record mailbox command from the eligible FCF record bmask for

 * performing the failover. If the FCF read back is not valid/available, it

 * fails through to retrying FLOGI to the currently registered FCF again.

 * Otherwise, if the FCF read back is valid and available, it will set the

 * newly read FCF record to the failover FCF record, unregister currently

 * registered FCF record, copy the failover FCF record to the current

 * FCF record, and then register the current FCF record before proceeding

 * to trying FLOGI on the new failover FCF.

 If link state is not up, stop the roundrobin failover process */

 Parse the FCF record from the non-embedded mailbox command */

 Get the needed parameters from FCF record */

 Log the FCF record information if turned on */

 Clear roundrobin bmask bit for ineligible FCF */

 Perform next round of roundrobin FCF failover */

 Wait 500 ms before retrying FLOGI to current FCF */

 Upload new FCF record to the failover FCF record */

 Unregister the current in-use FCF record */

 Replace in-use record with the new record */

/**

 * lpfc_mbx_cmpl_read_fcf_rec - read fcf completion handler.

 * @phba: pointer to lpfc hba data structure.

 * @mboxq: pointer to mailbox object.

 *

 * This is the callback function of read FCF record mailbox command for

 * updating the eligible FCF bmask for FLOGI failure roundrobin FCF

 * failover when a new FCF event happened. If the FCF read back is

 * valid/available and it passes the connection list check, it updates

 * the bmask for the eligible FCF record for roundrobin failover.

 If link state is not up, no need to proceed */

 If FCF discovery period is over, no need to proceed */

 Parse the FCF record from the non-embedded mailbox command */

 Check the connection list for eligibility */

 Log the FCF record information if turned on */

 Update the eligible FCF record index bmask */

/**

 * lpfc_init_vfi_cmpl - Completion handler for init_vfi mbox command.

 * @phba: pointer to lpfc hba data structure.

 * @mboxq: pointer to mailbox data structure.

 *

 * This function handles completion of init vfi mailbox command.

	/*

	 * VFI not supported on interface type 0, just do the flogi

	 * Also continue if the VFI is in use - just use the same one.

/**

 * lpfc_issue_init_vfi - Issue init_vfi mailbox command.

 * @vport: pointer to lpfc_vport data structure.

 *

 * This function issue a init_vfi mailbox command to initialize the VFI and

 * VPI for the physical port.

/**

 * lpfc_init_vpi_cmpl - Completion handler for init_vpi mbox command.

 * @phba: pointer to lpfc hba data structure.

 * @mboxq: pointer to mailbox data structure.

 *

 * This function handles completion of init vpi mailbox command.

 If this port is physical port or FDISC is done, do reg_vpi */

/**

 * lpfc_issue_init_vpi - Issue init_vpi mailbox command.

 * @vport: pointer to lpfc_vport data structure.

 *

 * This function issue a init_vpi mailbox command to initialize

 * VPI for the vport.

/**

 * lpfc_start_fdiscs - send fdiscs for each vports on this port.

 * @phba: pointer to lpfc hba data structure.

 *

 * This function loops through the list of vports on the @phba and issues an

 * FDISC if possible.

 There are no vpi for this vport */

	/*

	 * VFI not supported for interface type 0, so ignore any mailbox

	 * error (except VFI in use) and continue with the discovery.

 FLOGI failed, use loop map to make discovery list */

 Start discovery */

	/* If the VFI is already registered, there is nothing else to do

	 * Unless this was a VFI update and we are in PT2PT mode, then

	 * we should drop through to set the port state to ready.

 The VPI is implicitly registered when the VFI is registered */

 In case SLI4 FC loopback test, we are ready */

		/*

		 * For private loop or for NPort pt2pt,

		 * just start discovery and we are done.

 Use loop map to make discovery list */

 Start discovery */

 Check for error */

 READ_SPARAM mbox error <mbxStatus> state <hba_state> */

 E_D_TOV ticks are in nanoseconds */

 RA_TOV should be atleast 10sec for initial flogi */

	/* Check if sending the FLOGI is being deferred to after we get

	 * up to date CSPs from MBX_READ_SPARAM.

		/* if npiv is enabled and this adapter supports npiv log

		 * a message that npiv is not supported in this topology

 Get Loop Map information */

 Link Up Event ALPA map */

		/*

		 * Add the driver's default FCF record at FCF index 0 now. This

		 * is phase 1 implementation that support FCF index 0 and driver

		 * defaults.

		/*

		 * The driver is expected to do FIP/FCF. Call the port

		 * and get the FCF Table.

 This is the initial FCF discovery scan */

 Reset FCF roundrobin bmask for new discovery */

 Prepare for LINK up registrations */

 flush */

 turn on Link Attention interrupts - no CLEAR_LA needed */

/*

 * This routine handles processing a READ_TOPOLOGY mailbox

 * command upon completion. It is setup in the LPFC_MBOXQ

 * as the completion routine when the command is

 * handed off to the SLI layer. SLI4 only.

 Unblock ELS traffic */

 Check for error */

		/*

		 * The cmnd that triggered this will be waiting for this

		 * signal.

 WAKEUP for MENLO_SET_MODE or MENLO_RESET command. */

/*

 * This routine handles processing a REG_LOGIN mailbox

 * command upon completion. It is setup in the LPFC_MBOXQ

 * as the completion routine when the command is

 * handed off to the SLI layer.

		/* We rcvd a rscn after issuing this

		 * mbox reg login, we may have cycled

		 * back through the state and be

		 * back at reg login state so this

		 * mbox needs to be ignored becase

		 * there is another reg login in

		 * process.

		/*

		 * We cannot leave the RPI registered because

		 * if we go thru discovery again for this ndlp

		 * a subsequent REG_RPI will fail.

 Call state machine */

	/* decrement the node reference count held for this callback

	 * function.

 If VPI is busy, reset the HBA */

	/*

	 * This shost reference might have been taken at the beginning of

	 * lpfc_vport_delete()

 go thru NPR list and issue ELS PLOGIs */

/**

 * lpfc_create_static_vport - Read HBA config region to create static vports.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine issue a DUMP mailbox command for config region 22 to get

 * the list of static vports to be created. The function create vports

 * based on the information returned from the HBA.

 free dma buffer from previous round */

/*

 * This routine handles processing a Fabric REG_LOGIN mailbox

 * command upon completion. It is setup in the LPFC_MBOXQ

 * as the completion routine when the command is

 * handed off to the SLI layer.

 FLOGI failed, use loop map to make discovery list */

 Start discovery */

			/* Decrement the reference count to ndlp after the

			 * reference to the ndlp are done.

		/* Decrement the reference count to ndlp after the reference

		 * to the ndlp are done.

		/* when physical port receive logo donot start

	/* Drop the reference count from the mbox at the end after

	 * all the current reference to the ndlp have been done.

 /*

  * This routine will issue a GID_FT for each FC4 Type supported

  * by the driver. ALL GID_FTs must complete before discovery is started.

 Good status, issue CT Request to NameServer */

			/* Cannot issue NameServer FCP Query, so finish up

			 * discovery

			/* Cannot issue NameServer NVME Query, so finish up

			 * discovery

/**

 * lpfc_issue_gidpt - issue a GID_PT for all N_Ports

 * @vport: The virtual port for which this call is being executed.

 *

 * This routine will issue a GID_PT to get a list of all N_Ports

 *

 * Return value :

 *   0 - Failure to issue a GID_PT

 *   1 - GID_PT issued

 Good status, issue CT Request to NameServer */

		/* Cannot issue NameServer FCP Query, so finish up

		 * discovery

/*

 * This routine handles processing a NameServer REG_LOGIN mailbox

 * command upon completion. It is setup in the LPFC_MBOXQ

 * as the completion routine when the command is

 * handed off to the SLI layer.

		/* decrement the node reference count held for this

		 * callback function.

		/* If the node is not registered with the scsi or nvme

		 * transport, remove the fabric node.  The failed reg_login

		 * is terminal.

			/*

			 * RegLogin failed, use loop map to make discovery

			 * list

 Start discovery */

 Link up discovery requires Fabric registration. */

 Issue SCR just before NameServer GID_FT Query */

		/* Link was bounced or a Fabric LOGO occurred.  Start EDC

		 * with initial FW values provided the congestion mode is

		 * not off.  Note that signals may or may not be supported

		 * by the adapter but FPIN is provided by default for 1

		 * or both missing signals support.

	/*

	 * At this point in time we may need to wait for multiple

	 * SLI_CTNS_GID_FT CT commands to complete before we start discovery.

	 *

	 * decrement the node reference count held for this

	 * callback function.

/*

 * This routine handles processing a Fabric Controller REG_LOGIN mailbox

 * command upon completion. It is setup in the LPFC_MBOXQ

 * as the completion routine when the command is handed off to the SLI layer.

	/* Drop the reference count from the mbox at the end after

	 * all the current reference to the ndlp have been done.

 Remote port has reappeared. Re-register w/ FC transport */

 Don't add the remote port if unloading. */

	/*

	 * Disassociate any older association between this ndlp and rport

 Successful port add.  Complete initializing node data */

 Register a node with backend if not already done */

 Already registered with backend, trigger rescan */

		/*

		 * Tell the fc transport about the port, if we haven't

		 * already. If we have, and it's a scsi entity, be

 We are done if we do not have any NVME remote node */

 Notify the NVME transport of this new rport. */

			/* Register this rport with the transport.

			 * Only NVME Target Rports are registered with

			 * the transport.

			/* Just take an NDLP ref count since the

			 * target does not register rports.

 Unregister a node with backend if not already done */

 Start devloss if target. */

 NVMET has no upcall. */

/*

 * Adisc state change handling

	/*

	 * Any state to ADISC_ISSUE

	 * Do nothing, adisc cmpl handling will trigger state changes

	/*

	 * ADISC_ISSUE to mapped states

	 * Trigger a registration with backend, it will be nop if

	 * already registered

	/*

	 * ADISC_ISSUE to non-mapped states

	 * We are moving from ADISC_ISSUE to a non-mapped state because

	 * ADISC failed, we would have skipped unregistering with

	 * backend, attempt it now

 Trap ADISC changes here */

 Reg/Unreg for FCP and NVME Transport interface */

		/* For nodes marked for ADISC, Handle unreg in ADISC cmpl

		 * if linkup. In linkdown do unreg_node

		/*

		 * A new target is discovered, if there is no buffer for

		 * statistical data collection allocate buffer.

	/*

	 * If the node just added to Mapped list was an FCP target,

	 * but the remote port registration failed or assigned a target

	 * id outside the presentable range - move the node to the

	 * Unmapped List.

/**

 * lpfc_initialize_node - Initialize all fields of node object

 * @vport: Pointer to Virtual Port object.

 * @ndlp: Pointer to FC node object.

 * @did: FC_ID of the node.

 *

 * This function is always called when node object need to be initialized.

 * It initializes all the fields of the node object. Although the reference

 * to phba from @ndlp can be obtained indirectly through it's reference to

 * @vport, a direct reference to phba is taken here by @ndlp. This is due

 * to the life-span of the @ndlp might go beyond the existence of @vport as

 * the final release of ndlp is determined by its reference count. And, the

 * operation on @ndlp needs the reference to phba.

	/*

	 * Use of lpfc_drop_node and UNUSED list: lpfc_drop_node should

	 * be used if we wish to issue the "last" lpfc_nlp_put() to remove

	 * the ndlp from the vport. The ndlp marked as UNUSED on the list

	 * until ALL other outstanding threads have completed. We check

	 * that the ndlp not already in the UNUSED state before we proceed.

/*

 * Start / ReStart rescue timer for Discovery / RSCN handling

 For FAN, timeout should be greater than edtov */

		/* Normal discovery timeout should be > than ELS/CT timeout

		 * FC spec states we need 3 * ratov for CT requests

 Start Discovery Timer state <hba_state> */

/*

 * Cancel rescue timer for Discovery / RSCN handling

 Turn off discovery timer if its running */

 Cancel Discovery Timer state <hba_state> */

/*

 * Check specified ring for outstanding IOCB on the SLI queue

 * Return true if iocb matches the specified nport

 Skip match check if waiting to relogin to FCP target */

 Check to see if iocb matches the nport */

 match, dequeue */

/*

 * Free resources / clean up outstanding I/Os

 * associated with nlp_rpi in the LPFC_NODELIST entry.

	/*

	 * Everything that matches on txcmplq will be returned

	 * by firmware with a no rpi error.

 Cancel all the IOCBs from the completions list */

/**

 * lpfc_nlp_logo_unreg - Unreg mailbox completion handler before LOGO

 * @phba: Pointer to HBA context object.

 * @pmb: Pointer to mailbox object.

 *

 * This function will issue an ELS LOGO command after completing

 * the UNREG_RPI.

 Check to see if there are any deferred events to process */

 NLP_RELEASE_RPI is only set for SLI4 ports. */

/*

 * Sets the mailbox completion handler to be used for the

 * unreg_rpi command. The handler varies based on the state of

 * the port and what will be happening to the rpi next.

	/* Driver always gets a reference on the mailbox job

	 * in support of async jobs.

/*

 * Free rpi associated with LPFC_NODELIST entry.

 * This routine is called from lpfc_freenode(), when we are removing

 * a LPFC_NODELIST entry. It is also called if the driver initiates a

 * LOGO that completes successfully, and we are waiting to PLOGI back

 * to the remote NPort. In addition, it is called after we receive

 * and unsolicated ELS cmd, send back a rsp, the rsp completes and

 * we are waiting to PLOGI back to the remote NPort.

		/* If there is already an UNREG in progress for this ndlp,

		 * no need to queue up another one.

 SLI4 ports require the physical rpi value. */

				/*

				 * accept PLOGIs after unreg_rpi_cmpl

			/* Because mempool_alloc failed, we

			 * will issue a LOGO here and keep the rpi alive if

			 * not unloading.

/**

 * lpfc_unreg_hba_rpis - Unregister rpis registered to the hba.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to unregister all the currently registered RPIs

 * to the HBA.

 The mempool_alloc might sleep */

 Unreg DID is an SLI3 operation. */

/*

 * Free resources associated with LPFC_NODELIST entry

 * so it can be freed.

 Cleanup node for NPort <nlp_DID> */

 Don't need to clean up REG_LOGIN64 cmds for Default RPI cleanup */

 cleanup any ndlp on mbox q waiting for reglogin cmpl */

 Cleanup REG_LOGIN completions which are not yet processed */

			/* We shall not invoke the lpfc_nlp_put to decrement

			 * the ndlp reference count as we are in the process

			 * of lpfc_nlp_release.

 First check for Direct match */

 Next check for area/domain identically equals 0 match */

			/* This code is supposed to match the ID

			 * for a private loop device that is

			 * connect to fl_port. But we need to

			 * check that the port did not just go

			 * from pt2pt to fabric or we could end

			 * up matching ndlp->nlp_DID 000001 to

			 * fabric DID 0x20101

 Search for a nodelist entry */

 FIND node did <did> NOT FOUND */

 FIND node did <did> NOT FOUND */

	/* The NVME Target does not want to actively manage an rport.

	 * The goal is to allow the target to reset its state and clear

	 * pending IO in preparation for the initiator to recover.

			/* Since this node is marked for discovery,

			 * delay timeout is not needed.

			/* NVME Target mode waits until rport is known to be

			 * impacted by the RSCN before it transitions.  No

			 * active management - just go to NPR provided the

			 * node had a valid login.

			/* If we've already received a PLOGI from this NPort

			 * we don't need to try to discover it again.

		/* If the initiator received a PLOGI from this NPort or if the

		 * initiator is already in the process of discovery on it,

		 * there's no need to try to discover it again.

		/* Moving to NPR state clears unsolicited flags and

		 * allows for rediscovery

 Build a list of nodes to discover based on the loopmap */

 Check for loop map present or not */

 No alpamap, so try all alpa's */

			/* If cfg_scan_down is set, start from highest

			 * ALPA (0xef) to lowest (0x1).

 SLI3 only */

	/*

	 * if it's not a physical port or if we already send

	 * clear_la then don't send it.

 Link up discovery */

 Reg_vpi to tell firmware to resume normal operations */

 Start Link up / RSCN discovery on NPR nodes */

 Start Discovery state <hba_state> */

 First do ADISCs - if any */

 Register the VPI for SLI3, NPIV only. */

	/*

	 * For SLI2, we need to set port_state to READY and continue

	 * discovery.

 If we get here, there is nothing to ADISC */

 go thru NPR nodes and issue ELS PLOGIs */

 Next do PLOGIs - if any */

			/* Check to see if more RSCNs came in while we

			 * were processing this one.

/*

 *  Ignore completion for all IOCBs on tx and txcmpl queue for ELS

 *  ring the match the sppecified nodelist.

	/* Error matching iocb on txq or txcmplq

	 * First check the txq.

 Next check the txcmplq */

 Make sure HBA is alive */

 Cancel all the IOCBs from the completions list */

****************************************************************************/

/*

 * NAME:     lpfc_disc_timeout

 *

 * FUNCTION: Fibre Channel driver discovery timeout routine.

 *

 * EXECUTION ENVIRONMENT: interrupt only

 *

 * CALLED FROM:

 *      Timer function

 *

 * RETURNS:

 *      none

****************************************************************************/

		/*

		 * port_state is identically  LPFC_LOCAL_CFG_LINK while

		 * waiting for FAN timeout

 Start discovery by sending FLOGI, clean up old rpis */

 Clean up the ndlp on Fabric connections */

				/* Fail outstanding IO now since device

				 * is marked for PLOGI.

 port_state is identically LPFC_FLOGI while waiting for FLOGI cmpl */

 Initial FLOGI timeout */

		/* Assume no Fabric and go on with discovery.

		 * Check for outstanding ELS FLOGI to abort.

 FLOGI failed, so just use loop map to make discovery list */

 Start discovery */

	/* hba_state is identically LPFC_FABRIC_CFG_LINK while waiting for

 Next look for NameServer ndlp */

 ReStart discovery */

 Check for wait for NameServer Rsp timeout */

 Try it one more time */

		/*

		 * Discovery is over.

		 * set port_state to PORT_READY if SLI2.

		 * cmpl_reg_vpi will set port_state to READY for SLI3.

 Setup and issue mailbox INITIALIZE LINK command */

 Node Authentication timeout */

		/*

		 * set port_state to PORT_READY if SLI2.

		 * cmpl_reg_vpi will set port_state to READY for SLI3.

 NPIV Not enabled */

 Cleanup any outstanding ELS commands */

 CLEAR LA timeout */

/*

 * This routine handles processing a NameServer REG_LOGIN mailbox

 * command upon completion. It is setup in the LPFC_MBOXQ

 * as the completion routine when the command is

 * handed off to the SLI layer.

	/*

	 * Start issuing Fabric-Device Management Interface (FDMI) command to

	 * 0xfffffa (FDMI well known port).

	 * DHBA -> DPRT -> RHBA -> RPA  (physical port)

	 * DPRT -> RPRT (vports)

 For extra Vendor RPA */

	/* decrement the node reference count held for this callback

	 * function.

/*

 * This routine looks up the ndlp lists for the given RPI. If rpi found it

 * returns the node list element pointer else return NULL.

/*

 * This routine looks up the ndlp lists for the given WWPN. If WWPN found it

 * returns the node element list pointer else return NULL.

/*

 * This routine looks up the ndlp lists for the given RPI. If the rpi

 * is found, the routine returns the node element list pointer else

 * return NULL.

/**

 * lpfc_find_vport_by_vpid - Find a vport on a HBA through vport identifier

 * @phba: pointer to lpfc hba data structure.

 * @vpi: the physical host virtual N_Port identifier.

 *

 * This routine finds a vport on a HBA (referred by @phba) through a

 * @vpi. The function walks the HBA's vport list and returns the address

 * of the vport with the matching @vpi.

 *

 * Return code

 *    NULL - No vport with the matching @vpi found

 *    Otherwise - Address to the vport with the matching @vpi.

 The physical ports are always vpi 0 - translate is unnecessary. */

		/*

		 * Translate the physical vpi to the logical vpi.  The

		 * vport stores the logical vpi.

/* This routine releases all resources associated with a specifc NPort's ndlp

 * and mempool_free's the nodelist.

 remove ndlp from action. */

	/* Not all ELS transactions have registered the RPI with the port.

	 * In these cases the rpi usage is temporary and the node is

	 * released when the WQE is completed.  Catch this case to free the

	 * RPI to the pool.  Because this node is in the release path, a lock

	 * is unnecessary.  All references are gone and the node has been

	 * dequeued.

	/* The node is not freed back to memory, it is released to a pool so

	 * the node fields need to be cleaned up.

 free ndlp memory for final ndlp release */

/* This routine bumps the reference count for a ndlp structure to ensure

 * that one discovery thread won't free a ndlp while another discovery thread

 * is using it.

		/* The check of ndlp usage to prevent incrementing the

		 * ndlp reference count that is in the process of being

		 * released.

/* This routine decrements the reference count for a ndlp structure. If the

 * count goes to 0, this indicates the associated nodelist should be freed.

/* This routine free's the specified nodelist if it is not in use

 * by any other discovery thread. This routine returns 1 if the

 * ndlp has been freed. A return value of 0 indicates the ndlp is

 * not yet been released.

/**

 * lpfc_fcf_inuse - Check if FCF can be unregistered.

 * @phba: Pointer to hba context object.

 *

 * This function iterate through all FC nodes associated

 * will all vports to check if there is any node with

 * fc_rports associated with it. If there is an fc_rport

 * associated with the node, then the node is either in

 * discovered state or its devloss_timer is pending.

 If driver cannot allocate memory, indicate fcf is in use */

		/*

		 * IF the CVL_RCVD bit is not set then we have sent the

		 * flogi.

		 * If dev_loss fires while we are waiting we do not want to

		 * unreg the fcf.

/**

 * lpfc_unregister_vfi_cmpl - Completion handler for unreg vfi.

 * @phba: Pointer to hba context object.

 * @mboxq: Pointer to mailbox object.

 *

 * This function frees memory associated with the mailbox command.

/**

 * lpfc_unregister_fcfi_cmpl - Completion handler for unreg fcfi.

 * @phba: Pointer to hba context object.

 * @mboxq: Pointer to mailbox object.

 *

 * This function frees memory associated with the mailbox command.

/**

 * lpfc_unregister_fcf_prep - Unregister fcf record preparation

 * @phba: Pointer to hba context object.

 *

 * This function prepare the HBA for unregistering the currently registered

 * FCF from the HBA. It performs unregistering, in order, RPIs, VPIs, and

 * VFIs.

 Unregister RPIs */

 At this point, all discovery is aborted */

 Unregister VPIs */

 Stop FLOGI/FDISC retries */

 Cleanup any outstanding ELS commands */

 Unregister the physical port VFI */

/**

 * lpfc_sli4_unregister_fcf - Unregister currently registered FCF record

 * @phba: Pointer to hba context object.

 *

 * This function issues synchronous unregister FCF mailbox command to HBA to

 * unregister the currently registered FCF record. The driver does not reset

 * the driver FCF usage state flags.

 *

 * Return 0 if successfully issued, none-zero otherwise.

/**

 * lpfc_unregister_fcf_rescan - Unregister currently registered fcf and rescan

 * @phba: Pointer to hba context object.

 *

 * This function unregisters the currently reigstered FCF. This function

 * also tries to find another FCF for discovery by rescan the HBA FCF table.

 Preparation for unregistering fcf */

 Now, unregister FCF record and reset HBA FCF state */

 Reset HBA FCF states after successful unregister FCF */

	/*

	 * If driver is not unloading, check if there is any other

	 * FCF record that can be used for discovery.

 This is considered as the initial FCF discovery scan */

 Reset FCF roundrobin bmask for new discovery */

/**

 * lpfc_unregister_fcf - Unregister the currently registered fcf record

 * @phba: Pointer to hba context object.

 *

 * This function just unregisters the currently reigstered FCF. It does not

 * try to find another FCF for discovery.

 Preparation for unregistering fcf */

 Now, unregister FCF record and reset HBA FCF state */

 Set proper HBA FCF states after successful unregister FCF */

/**

 * lpfc_unregister_unused_fcf - Unregister FCF if all devices are disconnected.

 * @phba: Pointer to hba context object.

 *

 * This function check if there are any connected remote port for the FCF and

 * if all the devices are disconnected, this function unregister FCFI.

 * This function also tries to use another FCF for discovery.

	/*

	 * If HBA is not running in FIP mode, if HBA does not support

	 * FCoE, if FCF discovery is ongoing, or if FCF has not been

	 * registered, do nothing.

/**

 * lpfc_read_fcf_conn_tbl - Create driver FCF connection table.

 * @phba: Pointer to hba context object.

 * @buff: Buffer containing the FCF connection table as in the config

 *         region.

 * This function create driver data structure for the FCF connection

 * record table read from config region 23.

 Free the current connect table */

/**

 * lpfc_read_fcoe_param - Read FCoe parameters from conf region..

 * @phba: Pointer to hba context object.

 * @buff: Buffer containing the FCoE parameter data structure.

 *

 *  This function update driver data structure with config

 *  parameters read from config region 23.

/**

 * lpfc_get_rec_conf23 - Get a record type in config region data.

 * @buff: Buffer containing config region 23 data.

 * @size: Size of the data buffer.

 * @rec_type: Record type to be searched.

 *

 * This function searches config region data to find the beginning

 * of the record specified by record_type. If record found, this

 * function return pointer to the record else return NULL.

	/*

	 * One TLV record has one word header and number of data words

	 * specified in the rec_length field of the record header.

/**

 * lpfc_parse_fcoe_conf - Parse FCoE config data read from config region 23.

 * @phba: Pointer to lpfc_hba data structure.

 * @buff: Buffer containing config region 23 data.

 * @size: Size of the data buffer.

 *

 * This function parses the FCoE config parameters in config region 23 and

 * populate driver data structure with the parameters.

	/*

	 * If data size is less than 2 words signature and version cannot be

	 * verified.

 Check the region signature first */

 Check the data structure version */

 Read FCoE param record */

 Read FCF connection table */

/*******************************************************************

 * This file is part of the Emulex Linux Device Driver for         *

 * Fibre Channel Host Bus Adapters.                                *

 * Copyright (C) 2017-2021 Broadcom. All Rights Reserved. The term *

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.  *

 * Copyright (C) 2004-2016 Emulex.  All rights reserved.           *

 * EMULEX and SLI are trademarks of Emulex.                        *

 * www.broadcom.com                                                *

 * Portions Copyright (C) 2004-2005 Christoph Hellwig              *

 *                                                                 *

 * This program is free software; you can redistribute it and/or   *

 * modify it under the terms of version 2 of the GNU General       *

 * Public License as published by the Free Software Foundation.    *

 * This program is distributed in the hope that it will be useful. *

 * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *

 * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *

 * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *

 * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *

 * TO BE LEGALLY INVALID.  See the GNU General Public License for  *

 * more details, a copy of which can be found in the file COPYING  *

 * included with this package.                                     *

 Used when mapping IRQ vectors in a driver centric manner */

/**

 * lpfc_config_port_prep - Perform lpfc initialization prior to config port

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine will do LPFC initialization prior to issuing the CONFIG_PORT

 * mailbox command. It retrieves the revision information from the HBA and

 * collects the Vital Product Data (VPD) about the HBA for preparing the

 * configuration of the HBA.

 *

 * Return codes:

 *   0 - success.

 *   -ERESTART - requests the SLI layer to reset the HBA and try again.

 *   Any other value - indicates an error.

	/*

	 * Clear all option bits except LPFC_SLI3_BG_ENABLED,

	 * which was already set in lpfc_get_cfgparam()

 Setup and issue mailbox READ REV command */

	/*

	 * The value of rr must be 1 since the driver set the cv field to 1.

	 * This setting requires the FW to set all revision fields.

 Save information as VPD data */

	/* If the sli feature level is less then 9, we must

	 * tear down all RPIs and VPIs on link down if NPIV

	 * is enabled.

 Get adapter VPD information */

		/* dump mem may return a zero when finished or we got a

		 * mailbox error, either way we are done.

/**

 * lpfc_config_async_cmpl - Completion handler for config async event mbox cmd

 * @phba: pointer to lpfc hba data structure.

 * @pmboxq: pointer to the driver internal queue element for mailbox command.

 *

 * This is the completion handler for driver's configuring asynchronous event

 * mailbox command to the device. If the mailbox command returns successfully,

 * it will set internal async event support flag to 1; otherwise, it will

 * set internal async event support flag to 0.

/**

 * lpfc_dump_wakeup_param_cmpl - dump memory mailbox command completion handler

 * @phba: pointer to lpfc hba data structure.

 * @pmboxq: pointer to the driver internal queue element for mailbox command.

 *

 * This is the completion handler for dump mailbox command for getting

 * wake up parameters. When this command complete, the response contain

 * Option rom version of the HBA. This function translate the version number

 * into a human readable string and store it in OptionROMVersion.

 character array used for decoding dist type. */

 word 7 contain option rom version */

 Decode the Option rom version word to a readable string */

/**

 * lpfc_update_vport_wwn - Updates the fc_nodename, fc_portname,

 *	cfg_soft_wwnn, cfg_soft_wwpn

 * @vport: pointer to lpfc vport data structure.

 *

 *

 * Return codes

 *   None.

 If the soft name exists then update it using the service params */

	/*

	 * If the name is empty or there exists a soft name

	 * then copy the service params name, otherwise use the fc name

	/*

	 * If the port name has changed, then set the Param changes flag

	 * to unreg the login

/**

 * lpfc_config_port_post - Perform lpfc initialization after config port

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine will do LPFC initialization after the CONFIG_PORT mailbox

 * command call. It performs all internal resource and state setups on the

 * port: post IOCB buffers, enable appropriate host interrupt attentions,

 * ELS ring timers, etc.

 *

 * Return codes

 *   0 - success.

 *   Any other value - error.

	/*

	 * If the Config port completed correctly the HBA is not

	 * over heated any more.

 Get login parameters for NID.  */

 Update the fc_host data structures with new wwn. */

 If no serial number in VPD data, use low 6 bytes of WWNN */

 This should be consolidated into parse_vpd ? - mr */

 Check if the port is disabled */

 Reset the DFT_HBA_Q_DEPTH to the max xri  */

 Get the default values for Model Name and Description */

 Only process IOCBs on ELS ring till hba_state is READY */

 Post receive buffers for desired rings */

	/*

	 * Configure HBA MSI-X attention conditions to messages if MSI-X mode

 Initialize ERATT handling flag */

 Enable appropriate host interrupts */

 flush */

 Set up ring-0 (ELS) timer */

 Set up heart beat (HB) timer */

 Set up error attention (ERATT) polling timer */

 MBOX buffer will be freed in mbox compl */

 Get Option rom version */

/**

 * lpfc_sli4_refresh_params - update driver copy of params.

 * @phba: Pointer to HBA context object.

 *

 * This is called to refresh driver copy of dynamic fields from the

 * common_get_sli4_parameters descriptor.

 Read the port's SLI4 Config Parameters */

/**

 * lpfc_hba_init_link - Initialize the FC link

 * @phba: pointer to lpfc hba data structure.

 * @flag: mailbox command issue mode - either MBX_POLL or MBX_NOWAIT

 *

 * This routine will issue the INIT_LINK mailbox command call.

 * It is available to other drivers through the lpfc_hba data

 * structure for use as a delayed link up mechanism with the

 * module parameter lpfc_suppress_link_up.

 *

 * Return code

 *		0 - success

 *		Any other value - error

/**

 * lpfc_hba_init_link_fc_topology - Initialize FC link with desired topology

 * @phba: pointer to lpfc hba data structure.

 * @fc_topology: desired fc topology.

 * @flag: mailbox command issue mode - either MBX_POLL or MBX_NOWAIT

 *

 * This routine will issue the INIT_LINK mailbox command call.

 * It is available to other drivers through the lpfc_hba data

 * structure for use as a delayed link up mechanism with the

 * module parameter lpfc_suppress_link_up.

 *

 * Return code

 *              0 - success

 *              Any other value - error

 Reset link speed to auto */

 Clear all interrupt enable conditions */

 flush */

 Clear all pending interrupts */

 flush */

/**

 * lpfc_hba_down_link - this routine downs the FC link

 * @phba: pointer to lpfc hba data structure.

 * @flag: mailbox command issue mode - either MBX_POLL or MBX_NOWAIT

 *

 * This routine will issue the DOWN_LINK mailbox command call.

 * It is available to other drivers through the lpfc_hba data

 * structure for use to stop the link.

 *

 * Return code

 *		0 - success

 *		Any other value - error

/**

 * lpfc_hba_down_prep - Perform lpfc uninitialization prior to HBA reset

 * @phba: pointer to lpfc HBA data structure.

 *

 * This routine will do LPFC uninitialization before the HBA is reset when

 * bringing down the SLI Layer.

 *

 * Return codes

 *   0 - success.

 *   Any other value - error.

 Disable interrupts */

 flush */

/**

 * lpfc_sli4_free_sp_events - Cleanup sp_queue_events to free

 * rspiocb which got deferred

 *

 * @phba: pointer to lpfc HBA data structure.

 *

 * This routine will cleanup completed slow path events after HBA is reset

 * when bringing down the SLI Layer.

 *

 *

 * Return codes

 *   void.

 Get the response iocb from the head of work queue */

/**

 * lpfc_hba_free_post_buf - Perform lpfc uninitialization after HBA reset

 * @phba: pointer to lpfc HBA data structure.

 *

 * This routine will cleanup posted ELS buffers after the HBA is reset

 * when bringing down the SLI Layer.

 *

 *

 * Return codes

 *   void.

 Cleanup preposted buffers on the ELS ring */

/**

 * lpfc_hba_clean_txcmplq - Perform lpfc uninitialization after HBA reset

 * @phba: pointer to lpfc HBA data structure.

 *

 * This routine will cleanup the txcmplq after the HBA is reset when bringing

 * down the SLI Layer.

 *

 * Return codes

 *   void

			/* At this point in time the HBA is either reset or DOA

			 * Nothing should be on txcmplq as it will

			 * NEVER complete.

 Cancel all the IOCBs from the completions list */

 Cancel all the IOCBs from the completions list */

/**

 * lpfc_hba_down_post_s3 - Perform lpfc uninitialization after HBA reset

 * @phba: pointer to lpfc HBA data structure.

 *

 * This routine will do uninitialization after the HBA is reset when bring

 * down the SLI Layer.

 *

 * Return codes

 *   0 - success.

 *   Any other value - error.

/**

 * lpfc_hba_down_post_s4 - Perform lpfc uninitialization after HBA reset

 * @phba: pointer to lpfc HBA data structure.

 *

 * This routine will do uninitialization after the HBA is reset when bring

 * down the SLI Layer.

 *

 * Return codes

 *   0 - success.

 *   Any other value - error.

	/* At this point in time the HBA is either reset or DOA. Either

	 * way, nothing should be on lpfc_abts_els_sgl_list, it needs to be

	 * on the lpfc_els_sgl_list so that it can either be freed if the

	 * driver is unloading or reposted if the driver is restarting

	 * the port.

	/* sgl_list_lock required because worker thread uses this

	 * list.

	/* abts_xxxx_buf_list_lock required because worker thread uses this

	 * list.

/**

 * lpfc_hba_down_post - Wrapper func for hba down post routine

 * @phba: pointer to lpfc HBA data structure.

 *

 * This routine wraps the actual SLI3 or SLI4 routine for performing

 * uninitialization after the HBA is reset when bring down the SLI Layer.

 *

 * Return codes

 *   0 - success.

 *   Any other value - error.

/**

 * lpfc_hb_timeout - The HBA-timer timeout handler

 * @t: timer context used to obtain the pointer to lpfc hba data structure.

 *

 * This is the HBA-timer timeout handler registered to the lpfc driver. When

 * this timer fires, a HBA timeout event shall be posted to the lpfc driver

 * work-port-events bitmap and the worker thread is notified. This timeout

 * event will be used by the worker thread to invoke the actual timeout

 * handler routine, lpfc_hb_timeout_handler. Any periodical operations will

 * be performed in the timeout handler and the HBA timeout event bit shall

 * be cleared by the worker thread after it has taken the event bitmap out.

 Check for heart beat timeout conditions */

 Tell the worker thread there is work to do */

/**

 * lpfc_rrq_timeout - The RRQ-timer timeout handler

 * @t: timer context used to obtain the pointer to lpfc hba data structure.

 *

 * This is the RRQ-timer timeout handler registered to the lpfc driver. When

 * this timer fires, a RRQ timeout event shall be posted to the lpfc driver

 * work-port-events bitmap and the worker thread is notified. This timeout

 * event will be used by the worker thread to invoke the actual timeout

 * handler routine, lpfc_rrq_handler. Any periodical operations will

 * be performed in the timeout handler and the RRQ timeout event bit shall

 * be cleared by the worker thread after it has taken the event bitmap out.

/**

 * lpfc_hb_mbox_cmpl - The lpfc heart-beat mailbox command callback function

 * @phba: pointer to lpfc hba data structure.

 * @pmboxq: pointer to the driver internal queue element for mailbox command.

 *

 * This is the callback function to the lpfc heart-beat mailbox command.

 * If configured, the lpfc driver issues the heart-beat mailbox command to

 * the HBA every LPFC_HB_MBOX_INTERVAL (current 5) seconds. At the time the

 * heart-beat mailbox command is issued, the driver shall set up heart-beat

 * timeout timer to LPFC_HB_MBOX_TIMEOUT (current 30) seconds and marks

 * heart-beat outstanding state. Once the mailbox command comes back and

 * no error conditions detected, the heart-beat mailbox command timer is

 * reset to LPFC_HB_MBOX_INTERVAL seconds and the heart-beat outstanding

 * state is cleared for the next heart-beat. If the timer expired with the

 * heart-beat outstanding state set, the driver will put the HBA offline.

 Check and reset heart-beat timer if necessary */

/*

 * lpfc_idle_stat_delay_work - idle_stat tracking

 *

 * This routine tracks per-cq idle_stat and determines polling decisions.

 *

 * Return codes:

 *   None

 Skip if we've already handled this cq's primary CPU */

		/* get_cpu_idle_time returns values as running counters. Thus,

		 * to know the amount for this period, the prior counter values

		 * need to be subtracted from the current counter values.

		 * From there, the idle time stat can be calculated as a

		 * percentage of 100 - the sum of the other consumption times.

 Get the EQ corresponding to the IRQ vector */

/**

 * lpfc_hb_mxp_handler - Multi-XRI pools handler to adjust XRI distribution

 * @phba: pointer to lpfc hba data structure.

 *

 * For each heartbeat, this routine does some heuristic methods to adjust

 * XRI distribution. The goal is to fully utilize free XRIs.

 Adjust XRIs in private pool */

 Adjust high watermark */

 Snapshot pbl, pvt and busy count */

/**

 * lpfc_issue_hb_mbox - Issues heart-beat mailbox command

 * @phba: pointer to lpfc hba data structure.

 *

 * If a HB mbox is not already in progrees, this routine will allocate

 * a LPFC_MBOXQ_t, populate it with a MBX_HEARTBEAT (0x31) command,

 * and issue it. The HBA_HBEAT_INP flag means the command is in progress.

 Is a Heartbeat mbox already in progress */

/**

 * lpfc_issue_hb_tmo - Signals heartbeat timer to issue mbox command

 * @phba: pointer to lpfc hba data structure.

 *

 * The heartbeat timer (every 5 sec) will fire. If the HBA_HBEAT_TMO

 * flag is set, it will force a MBX_HEARTBEAT mbox command, regardless

 * of the value of lpfc_enable_hba_heartbeat.

 * If lpfc_enable_hba_heartbeat is set, the timeout routine will always

 * try to issue a MBX_HEARTBEAT mbox command.

/**

 * lpfc_hb_timeout_handler - The HBA-timer timeout handler

 * @phba: pointer to lpfc hba data structure.

 *

 * This is the actual HBA-timer timeout handler to be invoked by the worker

 * thread whenever the HBA timer fired and HBA-timeout event posted. This

 * handler performs any periodic operations needed for the device. If such

 * periodic event has already been attended to either in the interrupt handler

 * or by processing slow-ring or fast-ring events within the HBA-timer

 * timeout window (LPFC_HB_MBOX_INTERVAL), this handler just simply resets

 * the timer for the next timeout period. If lpfc heart-beat mailbox command

 * is configured and there is no heart-beat mailbox command outstanding, a

 * heart-beat mailbox is issued and timer set properly. Otherwise, if there

 * has been a heart-beat mailbox command outstanding, the HBA shall be put

 * to offline.

 Multi-XRI pools handler */

 If there is no heart beat outstanding, issue a heartbeat command */

 If IOs are completing, no need to issue a MBX_HEARTBEAT */

 Check if a MBX_HEARTBEAT is already in progress */

			/*

			 * If heart beat timeout called with HBA_HBEAT_INP set

			 * we need to give the hb mailbox cmd a chance to

			 * complete or TMO.

 Check to see if we want to force a MBX_HEARTBEAT */

/**

 * lpfc_offline_eratt - Bring lpfc offline on hardware error attention

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is called to bring the HBA offline when HBA hardware error

 * other than Port Error 6 has been detected.

/**

 * lpfc_sli4_offline_eratt - Bring lpfc offline on SLI4 hardware error attention

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is called to bring a SLI4 HBA offline when HBA hardware error

 * other than Port Error 6 has been detected.

/**

 * lpfc_handle_deferred_eratt - The HBA hardware deferred error handler

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to handle the deferred HBA hardware error

 * conditions. This type of error is indicated by HBA by setting ER1

 * and another ER bit in the host status register. The driver will

 * wait until the ER1 bit clears before handling the error condition.

	/* If the pci channel is offline, ignore possible errors,

	 * since we cannot communicate with the pci card anyway.

	/*

	 * Firmware stops when it triggred erratt. That could cause the I/Os

	 * dropped by the firmware. Error iocb (I/O) on txcmplq and let the

	 * SCSI layer retry it after re-establishing link.

	/*

	 * There was a firmware error. Take the hba offline and then

	 * attempt to restart it.

 Wait for the ER1 bit to clear.*/

 If driver is unloading let the worker thread continue */

	/*

	 * This is to ptrotect against a race condition in which

	 * first write to the host attention register clear the

	 * host status register.

/**

 * lpfc_handle_eratt_s3 - The SLI3 HBA hardware error handler

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to handle the following HBA hardware error

 * conditions:

 * 1 - HBA error attention interrupt

 * 2 - DMA ring index out of range

 * 3 - Mailbox command came back as unknown

	/* If the pci channel is offline, ignore possible errors,

	 * since we cannot communicate with the pci card anyway.

 If resets are disabled then leave the HBA alone and return */

 Send an internal error event to mgmt application */

 Re-establishing Link */

 Device Zeroization */

		/*

		* Firmware stops when it triggled erratt with HS_FFER6.

		* That could cause the I/Os dropped by the firmware.

		* Error iocb (I/O) on txcmplq and let the SCSI layer

		* retry it after re-establishing link.

		/*

		 * There was a firmware error.  Take the hba offline and then

		 * attempt to restart it.

 Initialize the HBA */

		/* The if clause above forces this code path when the status

		 * failure is a value other than FFER6. Do not call the offline

		 * twice. This is the adapter hardware error path.

/**

 * lpfc_sli4_port_sta_fn_reset - The SLI4 function reset due to port status reg

 * @phba: pointer to lpfc hba data structure.

 * @mbx_action: flag for mailbox shutdown action.

 * @en_rn_msg: send reset/port recovery message.

 * This routine is invoked to perform an SLI4 port PCI function reset in

 * response to port status register polling attention. It waits for port

 * status register (ERR, RDY, RN) bits before proceeding with function reset.

 * During this process, interrupt vectors are freed and later requested

 * for handling possible port resource change.

		/*

		 * On error status condition, driver need to wait for port

		 * ready before performing reset.

 need reset: attempt for port recovery */

	/* If we are no wait, the HBA has been reset and is not

	 * functional, thus we should clear

	 * (LPFC_SLI_ACTIVE | LPFC_SLI_MBOX_ACTIVE) flags.

 release interrupt for possible resource change */

 request and enable interrupt */

/**

 * lpfc_handle_eratt_s4 - The SLI4 HBA hardware error handler

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to handle the SLI4 HBA hardware error attention

 * conditions.

	/* If the pci channel is offline, ignore possible errors, since

	 * we cannot communicate with the pci card anyway.

 consider PCI bus read error as pci_channel_offline */

Sleep for 1Sec, before checking SEMAPHORE */

 Recoverable UE, reset the HBA device */

 consider PCI bus read error as pci_channel_offline */

 If resets are disabled then leave the HBA alone and return */

 Check port status register for function reset */

 don't report event on forced debug dump */

 fall through for not able to recover */

 Send an internal error event to mgmt application */

/**

 * lpfc_handle_eratt - Wrapper func for handling hba error attention

 * @phba: pointer to lpfc HBA data structure.

 *

 * This routine wraps the actual SLI3 or SLI4 hba error attention handling

 * routine from the API jump table function pointer from the lpfc_hba struct.

 *

 * Return codes

 *   0 - success.

 *   Any other value - error.

/**

 * lpfc_handle_latt - The HBA link event handler

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked from the worker thread to handle a HBA host

 * attention link event. SLI3 only.

 Cleanup any outstanding ELS commands */

 Block ELS IOCBs until we have processed this mbox command */

 Clear Link Attention in HA REG */

 flush */

 Enable Link attention interrupts */

 flush */

 Clear Link Attention in HA REG */

 flush */

/**

 * lpfc_parse_vpd - Parse VPD (Vital Product Data)

 * @phba: pointer to lpfc hba data structure.

 * @vpd: pointer to the vital product data.

 * @len: length of the vital product data in bytes.

 *

 * This routine parses the Vital Product Data (VPD). The VPD is treated as

 * an array of characters. In this routine, the ModelName, ProgramType, and

 * ModelDesc, etc. fields of the phba data structure will be populated.

 *

 * Return codes

 *   0 - pointer to the VPD passed in is NULL

 *   1 - success

 Vital Product */

 Look for Serial Number */

/**

 * lpfc_get_hba_model_desc - Retrieve HBA device model name and description

 * @phba: pointer to lpfc hba data structure.

 * @mdp: pointer to the data structure to hold the derived model name.

 * @descp: pointer to the data structure to hold the derived description.

 *

 * This routine retrieves HBA's description based on its registered PCI device

 * ID. The @descp passed into this function points to an array of 256 chars. It

 * shall be returned with the model name, maximum speed, and the host bus type.

 * The @mdp passed into this function points to an array of 80 chars. When the

 * function returns, the @mdp will be filled with the model name.

 default is not a oneConnect */

	/*

	 * oneConnect hba requires special processing, they are all initiators

	 * and we put the port number on the end

/**

 * lpfc_post_buffer - Post IOCB(s) with DMA buffer descriptor(s) to a IOCB ring

 * @phba: pointer to lpfc hba data structure.

 * @pring: pointer to a IOCB ring.

 * @cnt: the number of IOCBs to be posted to the IOCB ring.

 *

 * This routine posts a given number of IOCBs with the associated DMA buffer

 * descriptors specified by the cnt argument to the given IOCB ring.

 *

 * Return codes

 *   The number of IOCBs NOT able to be posted to the IOCB ring.

 While there are buffers to post */

 Allocate buffer for  command iocb */

 2 buffers can be posted per command */

 Allocate buffer to post */

 Allocate buffer to post */

/**

 * lpfc_post_rcv_buf - Post the initial receive IOCB buffers to ELS ring

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine posts initial receive IOCB buffers to the ELS ring. The

 * current number of initial IOCB buffers specified by LPFC_BUF_RING0 is

 * set to 64 IOCBs. SLI3 only.

 *

 * Return codes

 *   0 - success (currently always success)

 Ring 0, ELS / CT buffers */

 Ring 2 - FCP no buffers needed */

/**

 * lpfc_sha_init - Set up initial array of hash table entries

 * @HashResultPointer: pointer to an array as hash table.

 *

 * This routine sets up the initial values to the array of hash table entries

 * for the LC HBAs.

/**

 * lpfc_sha_iterate - Iterate initial hash table with the working hash table

 * @HashResultPointer: pointer to an initial/result hash table.

 * @HashWorkingPointer: pointer to an working hash table.

 *

 * This routine iterates an initial hash table pointed by @HashResultPointer

 * with the values from the working hash table pointeed by @HashWorkingPointer.

 * The results are putting back to the initial hash table, returned through

 * the @HashResultPointer as the result hash table.

/**

 * lpfc_challenge_key - Create challenge key based on WWPN of the HBA

 * @RandomChallenge: pointer to the entry of host challenge random number array.

 * @HashWorking: pointer to the entry of the working hash array.

 *

 * This routine calculates the working hash array referred by @HashWorking

 * from the challenge random numbers associated with the host, referred by

 * @RandomChallenge. The result is put into the entry of the working hash

 * array and returned by reference through @HashWorking.

/**

 * lpfc_hba_init - Perform special handling for LC HBA initialization

 * @phba: pointer to lpfc hba data structure.

 * @hbainit: pointer to an array of unsigned 32-bit integers.

 *

 * This routine performs the special handling for LC HBA initialization.

/**

 * lpfc_cleanup - Performs vport cleanups before deleting a vport

 * @vport: pointer to a virtual N_Port data structure.

 *

 * This routine performs the necessary cleanups before deleting the @vport.

 * It invokes the discovery state machine to perform necessary state

 * transitions and to release the ndlps associated with the @vport. Note,

 * the physical port is treated as @vport 0.

 Clean up VMID resources */

 Just free up ndlp with Fabric_DID for vports */

		/* Fabric Ports not in UNMAPPED state are cleaned up in the

		 * DEVICE_RM event.

	/* At this point, ALL ndlp's should be gone

	 * because of the previous NLP_EVT_DEVICE_RM.

	 * Lets wait for this to happen, if needed.

 Wait for any activity on ndlps to settle */

/**

 * lpfc_stop_vport_timers - Stop all the timers associated with a vport

 * @vport: pointer to a virtual N_Port data structure.

 *

 * This routine stops all the timers associated with a @vport. This function

 * is invoked before disabling or deleting a @vport. Note that the physical

 * port is treated as @vport 0.

/**

 * __lpfc_sli4_stop_fcf_redisc_wait_timer - Stop FCF rediscovery wait timer

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine stops the SLI4 FCF rediscover wait timer if it's on. The

 * caller of this routine should already hold the host lock.

 Clear pending FCF rediscovery wait flag */

 Now, try to stop the timer */

/**

 * lpfc_sli4_stop_fcf_redisc_wait_timer - Stop FCF rediscovery wait timer

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine stops the SLI4 FCF rediscover wait timer if it's on. It

 * checks whether the FCF rediscovery wait timer is pending with the host

 * lock held before proceeding with disabling the timer and clearing the

 * wait timer pendig flag.

 FCF rediscovery timer already fired or stopped */

 Clear failover in progress flags */

/**

 * lpfc_cmf_stop - Stop CMF processing

 * @phba: pointer to lpfc hba data structure.

 *

 * This is called when the link goes down or if CMF mode is turned OFF.

 * It is also called when going offline or unloaded just before the

 * congestion info buffer is unregistered.

 We only do something if CMF is enabled */

 Cancel the CMF timer */

 Zero CMF counters */

 Resume any blocked IO - Queue unblock on workqueue */

 Use the new fc_linkspeed to recalculate */

 This is a signal to firmware to sync up CMF BW with link speed */

/**

 * lpfc_cmf_start - Start CMF processing

 * @phba: pointer to lpfc hba data structure.

 *

 * This is called when the link comes up or if CMF mode is turned OFF

 * to Monitor or Managed.

 We only do something if CMF is enabled */

 Reinitialize congestion buffer info */

 Setup for latency check in IO cmpl routines */

/**

 * lpfc_stop_hba_timers - Stop all the timers associated with an HBA

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine stops all the timers associated with a HBA. This function is

 * invoked before either putting a HBA offline or unloading the driver.

 Stop any LightPulse device specific driver timers */

 Stop any OneConnect device specific driver timers */

/**

 * lpfc_block_mgmt_io - Mark a HBA's management interface as blocked

 * @phba: pointer to lpfc hba data structure.

 * @mbx_action: flag for mailbox no wait action.

 *

 * This routine marks a HBA's management interface as blocked. Once the HBA's

 * management interface is marked as blocked, all the user space access to

 * the HBA, whether they are from sysfs interface or libdfc interface will

 * all be blocked. The HBA is set to block the management interface when the

 * driver prepares the HBA interface for online or offline.

		/* Determine how long we might wait for the active mailbox

		 * command to be gracefully completed by firmware.

 Wait for the outstnading mailbox command to complete */

 Check active mailbox complete status every 2ms */

/**

 * lpfc_sli4_node_prep - Assign RPIs for active nodes.

 * @phba: pointer to lpfc hba data structure.

 *

 * Allocate RPIs for all active remote nodes. This is needed whenever

 * an SLI4 adapter is reset and the driver is not unloading. Its purpose

 * is to fixup the temporary rpi assignments.

 TODO print log? */

/**

 * lpfc_create_expedite_pool - create expedite pool

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine moves a batch of XRIs from lpfc_io_buf_list_put of HWQ 0

 * to expedite pool. Mark them as expedite.

/**

 * lpfc_destroy_expedite_pool - destroy expedite pool

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine returns XRIs from expedite pool to lpfc_io_buf_list_put

 * of HWQ 0. Clear the mark.

/**

 * lpfc_create_multixri_pools - create multi-XRI pools

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine initialize public, private per HWQ. Then, move XRIs from

 * lpfc_io_buf_list_put to public pool. High and low watermark are also

 * Initialized.

 Deal with public free xri pool */

 Deal with private free xri pool */

/**

 * lpfc_destroy_multixri_pools - destroy multi-XRI pools

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine returns XRIs from public/private to lpfc_io_buf_list_put.

 Deal with public free xri pool */

 Deal with private free xri pool */

/**

 * lpfc_online - Initialize and bring a HBA online

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine initializes the HBA and brings a HBA online. During this

 * process, the management interface is blocked to prevent user space access

 * to the HBA interfering with the driver initialization.

 *

 * Return codes

 *   0 - successful

 *   1 - failed

 Initialize SLI4 HBA */

		/* Reestablish the local initiator port.

		 * The offline process destroyed the previous lport.

 Initialize SLI2/SLI3 HBA */

/**

 * lpfc_unblock_mgmt_io - Mark a HBA's management interface to be not blocked

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine marks a HBA's management interface as not blocked. Once the

 * HBA's management interface is marked as not blocked, all the user space

 * access to the HBA, whether they are from sysfs interface or libdfc

 * interface will be allowed. The HBA is set to block the management interface

 * when the driver prepares the HBA interface for online or offline and then

 * set to unblock the management interface afterwards.

/**

 * lpfc_offline_prep - Prepare a HBA to be brought offline

 * @phba: pointer to lpfc hba data structure.

 * @mbx_action: flag for mailbox shutdown action.

 *

 * This routine is invoked to prepare a HBA to be brought offline. It performs

 * unregistration login to all the nodes on all vports and flushes the mailbox

 * queue to make it ready to be brought offline.

 Issue an unreg_login to all nodes on all vports */

				/*

				 * Whenever an SLI4 port goes offline, free the

				 * RPI. Get a new RPI when the adapter port

				 * comes back online.

					/* Don't remove the node unless the node

					 * has been unregistered with the

					 * transport, and we're not in recovery

					 * before dev_loss_tmo triggered.

					 * Otherwise, let dev_loss take care of

					 * the node.

/**

 * lpfc_offline - Bring a HBA offline

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine actually brings a HBA offline. It stops all the timers

 * associated with the HBA, brings down the SLI layer, and eventually

 * marks the HBA as in offline state for the upper layer protocol.

 stop port and all timers associated with this hba */

	/* Tear down the local and target port registrations.  The

	 * nvme transports need to cleanup.

	/* Bring down the SLI Layer and cleanup.  The HBA is offline

	/* If OFFLINE flag is clear (i.e. unloading), cpuhp removal is handled

	 * in hba_unset

/**

 * lpfc_scsi_free - Free all the SCSI buffers and IOCBs from driver lists

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is to free all the SCSI buffers and IOCBs from the driver

 * list back to kernel. It is called from lpfc_pci_remove_one to free

 * the internal resources before the device is removed from the system.

 Release all the lpfc_scsi_bufs maintained by this host. */

/**

 * lpfc_io_free - Free all the IO buffers and IOCBs from driver lists

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is to free all the IO buffers and IOCBs from the driver

 * list back to kernel. It is called from lpfc_pci_remove_one to free

 * the internal resources before the device is removed from the system.

 Release all the lpfc_nvme_bufs maintained by this host. */

/**

 * lpfc_sli4_els_sgl_update - update ELS xri-sgl sizing and mapping

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine first calculates the sizes of the current els and allocated

 * scsi sgl lists, and then goes through all sgls to updates the physical

 * XRIs assigned due to port function reset. During port initialization, the

 * current els and allocated scsi sgl lists are 0s.

 *

 * Return codes

 *   0 - successful (for now, it always returns 0)

	/*

	 * update on pci function's els xri-sgl list

 els xri-sgl expanded */

 allocate the additional els sgls */

 els xri-sgl shrinked */

 release extra els sgls from list */

 update xris to els sgls on the list */

/**

 * lpfc_sli4_nvmet_sgl_update - update xri-sgl sizing and mapping

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine first calculates the sizes of the current els and allocated

 * scsi sgl lists, and then goes through all sgls to updates the physical

 * XRIs assigned due to port function reset. During port initialization, the

 * current els and allocated scsi sgl lists are 0s.

 *

 * Return codes

 *   0 - successful (for now, it always returns 0)

	/*

	 * update on pci function's nvmet xri-sgl list

 For NVMET, ALL remaining XRIs are dedicated for IO processing */

 els xri-sgl expanded */

 allocate the additional nvmet sgls */

 nvmet xri-sgl shrunk */

 release extra nvmet sgls from list */

 update xris to nvmet sgls on the list */

 Take everything off the get and put lists */

	/*

	 * Take IO buffers off blist and put on cbuf sorted by XRI.

	 * This is because POST_SGL takes a sequential range of XRIs

	 * to post to the firmware.

/**

 * lpfc_sli4_io_sgl_update - update xri-sgl sizing and mapping

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine first calculates the sizes of the current els and allocated

 * scsi sgl lists, and then goes through all sgls to updates the physical

 * XRIs assigned due to port function reset. During port initialization, the

 * current els and allocated scsi sgl lists are 0s.

 *

 * Return codes

 *   0 - successful (for now, it always returns 0)

	/*

	 * update on pci function's allocated nvme xri-sgl list

 maximum number of xris available for nvme buffers */

 max nvme xri shrunk below the allocated nvme buffers */

 release the extra allocated nvme buffers */

 update xris associated to remaining allocated nvme buffers */

/**

 * lpfc_new_io_buf - IO buffer allocator for HBA with SLI4 IF spec

 * @phba: Pointer to lpfc hba data structure.

 * @num_to_alloc: The requested number of buffers to allocate.

 *

 * This routine allocates nvme buffers for device with SLI-4 interface spec,

 * the nvme buffer contains all the necessary information needed to initiate

 * an I/O. After allocating up to @num_to_allocate IO buffers and put

 * them on a list, it post them to the port by using SGL block post.

 *

 * Return codes:

 *   int - number of IO buffers that were allocated and posted.

 *   0 = failure, less than num_to_alloc is a partial failure.

		/*

		 * Get memory from the pci pool to map the virt space to

		 * pci bus space for an I/O. The DMA buffer includes the

		 * number of SGE's necessary to support the sg_tablesize.

			/*

			 * 4K Page alignment is CRITICAL to BlockGuard, double

			 * check to be sure.

 Allocate iotag for lpfc_ncmd->cur_iocbq. */

 Initialize local short-hand pointers. */

 add the nvme buffer to a post list */

 post the list of nvme buffer sgls to port if available */

 First get WWN of HBA instance */

 wwn is WWPN of HBA instance */

/**

 * lpfc_vmid_res_alloc - Allocates resources for VMID

 * @phba: pointer to lpfc hba data structure.

 * @vport: pointer to vport data structure

 *

 * This routine allocated the resources needed for the VMID.

 *

 * Return codes

 *	0 on Success

 *	Non-0 on Failure

 VMID feature is supported only on SLI4 */

 Set the VMID parameters for the vport */

/**

 * lpfc_create_port - Create an FC port

 * @phba: pointer to lpfc hba data structure.

 * @instance: a unique integer ID to this FC port.

 * @dev: pointer to the device data structure.

 *

 * This routine creates a FC port for the upper layer protocol. The FC port

 * can be created on top of either a physical port or a virtual port provided

 * by the HBA. This routine also allocates a SCSI host data structure (shost)

 * and associates the FC port created before adding the shost into the SCSI

 * layer.

 *

 * Return codes

 *   @vport - pointer to the virtual N_Port data structure.

 *   NULL - port create failed.

 Reset the port first */

 Seed template for SCSI host registration */

 Seed physical port template */

 template is for a no reset SCSI Host */

 Template for all vports this physical port creates */

 Initialize the host templates with updated value */

 NVMET is for physical port only */

 Adjust value in vport */

		/* SLI-3 has a limited number of hardware queues (3),

		 * thus there is only one for FCP processing.

	/*

	 * Set initial can_queue value since 0 is no longer supported and

	 * scsi_add_host will fail. This will be adjusted later based on the

	 * max xri value determined in hba setup.

 Allocate the resources for VMID */

 Initialize all internally managed lists. */

/**

 * destroy_port -  destroy an FC port

 * @vport: pointer to an lpfc virtual N_Port data structure.

 *

 * This routine destroys a FC port from the upper layer protocol. All the

 * resources associated with the port are released.

/**

 * lpfc_get_instance - Get a unique integer ID

 *

 * This routine allocates a unique integer ID from lpfc_hba_index pool. It

 * uses the kernel idr facility to perform the task.

 *

 * Return codes:

 *   instance - a unique integer ID allocated as the new instance.

 *   -1 - lpfc get instance failed.

/**

 * lpfc_scan_finished - method for SCSI layer to detect whether scan is done

 * @shost: pointer to SCSI host data structure.

 * @time: elapsed time of the scan in jiffies.

 *

 * This routine is called by the SCSI layer with a SCSI host to determine

 * whether the scan host is finished.

 *

 * Note: there is no scan_start function as adapter initialization will have

 * asynchronously kicked off the link initialization.

 *

 * Return codes

 *   0 - SCSI host scan is not over yet.

 *   1 - SCSI host scan is over.

	/*

	 * Avoid reporting supported link speed for FCoE as it can't be

	 * controlled via FCoE.

/**

 * lpfc_host_attrib_init - Initialize SCSI host attributes on a FC port

 * @shost: pointer to SCSI host data structure.

 *

 * This routine initializes a given SCSI host attributes on a FC port. The

 * SCSI host can be either on top of a physical port or a virtual port.

	/*

	 * Set fixed host attributes.  Must done after lpfc_sli_hba_setup().

 This value is also unchanging */

/**

 * lpfc_stop_port_s3 - Stop SLI3 device port

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to stop an SLI3 device port, it stops the device

 * from generating interrupts and stops the device driver's timers for the

 * device.

 Clear all interrupt enable conditions */

 flush */

 Clear all pending interrupts */

 flush */

 Reset some HBA SLI setup states */

/**

 * lpfc_stop_port_s4 - Stop SLI4 device port

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to stop an SLI4 device port, it stops the device

 * from generating interrupts and stops the device driver's timers for the

 * device.

 Reset some HBA SLI4 setup states */

/**

 * lpfc_stop_port - Wrapper function for stopping hba port

 * @phba: Pointer to HBA context object.

 *

 * This routine wraps the actual SLI3 or SLI4 hba stop port routine from

 * the API jump table function pointer from the lpfc_hba struct.

/**

 * lpfc_fcf_redisc_wait_start_timer - Start fcf rediscover wait timer

 * @phba: Pointer to hba for which this call is being executed.

 *

 * This routine starts the timer waiting for the FCF rediscovery to complete.

 Start fcf rediscovery wait period timer */

 Allow action to new fcf asynchronous event */

 Mark the FCF rediscovery pending state */

/**

 * lpfc_sli4_fcf_redisc_wait_tmo - FCF table rediscover wait timeout

 * @t: Timer context used to obtain the pointer to lpfc hba data structure.

 *

 * This routine is invoked when waiting for FCF table rediscover has been

 * timed out. If new FCF record(s) has (have) been discovered during the

 * wait period, a new FCF event shall be added to the FCOE async event

 * list, and then worker thread shall be waked up for processing from the

 * worker thread context.

 Don't send FCF rediscovery event if timer cancelled */

 Clear FCF rediscovery timer pending flag */

 FCF rediscovery event to worker thread */

 wake up worker thread */

/**

 * lpfc_vmid_poll - VMID timeout detection

 * @t: Timer context used to obtain the pointer to lpfc hba data structure.

 *

 * This routine is invoked when there is no I/O on by a VM for the specified

 * amount of time. When this situation is detected, the VMID has to be

 * deregistered from the switch and all the local resources freed. The VMID

 * will be reassigned to the VM once the I/O begins.

 check if there is a need to issue QFPA */

 Is the vmid inactivity timer enabled */

 restart the timer for the next iteration */

/**

 * lpfc_sli4_parse_latt_fault - Parse sli4 link-attention link fault code

 * @phba: pointer to lpfc hba data structure.

 * @acqe_link: pointer to the async link completion queue entry.

 *

 * This routine is to parse the SLI4 link-attention link fault code.

/**

 * lpfc_sli4_parse_latt_type - Parse sli4 link attention type

 * @phba: pointer to lpfc hba data structure.

 * @acqe_link: pointer to the async link completion queue entry.

 *

 * This routine is to parse the SLI4 link attention type and translate it

 * into the base driver's link attention type coding.

 *

 * Return: Link attention type in terms of base driver's coding.

 Ignore physical link up events - wait for logical link up */

/**

 * lpfc_sli_port_speed_get - Get sli3 link speed code to link speed

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is to get an SLI3 FC port's link speed in Mbps.

 *

 * Return: link speed in terms of Mbps.

/**

 * lpfc_sli4_port_speed_parse - Parse async evt link speed code to link speed

 * @phba: pointer to lpfc hba data structure.

 * @evt_code: asynchronous event code.

 * @speed_code: asynchronous event link speed code.

 *

 * This routine is to parse the giving SLI4 async event link speed code into

 * value of Mbps for the link speed.

 *

 * Return: link speed in terms of Mbps.

/**

 * lpfc_sli4_async_link_evt - Process the asynchronous FCoE link event

 * @phba: pointer to lpfc hba data structure.

 * @acqe_link: pointer to the async link completion queue entry.

 *

 * This routine is to handle the SLI4 asynchronous FCoE link event.

 Cleanup any outstanding ELS commands */

 Block ELS IOCBs until we have done process link event */

 Update link event statistics */

 Create lpfc_handle_latt mailbox command from link ACQE */

 Keep the link status for extra SLI4 state machine reference */

	/*

	 * For FC Mode: issue the READ_TOPOLOGY mailbox command to fetch

	 * topology info. Note: Optional for non FC-AL ports.

	/*

	 * For FCoE Mode: fill in all the topology information we need and call

	 * the READ_TOPOLOGY completion routine to continue without actually

	 * sending the READ_TOPOLOGY mailbox command to the port.

 Initialize completion status */

 Parse port fault information field */

 Parse and translate link attention fields */

 Fake the the following irrelvant fields */

 Invoke the lpfc_handle_latt mailbox command callback function */

/**

 * lpfc_async_link_speed_to_read_top - Parse async evt link speed code to read

 * topology.

 * @phba: pointer to lpfc hba data structure.

 * @speed_code: asynchronous event link speed code.

 *

 * This routine is to parse the giving SLI4 async event link speed code into

 * value of Read topology link speed.

 *

 * Return: link speed in terms of Read topology.

 Display the last LPFC_MAX_RXMONITOR_DUMP entries from the rxtable */

/**

 * lpfc_cgn_update_stat - Save data into congestion stats buffer

 * @phba: pointer to lpfc hba data structure.

 * @dtag: FPIN descriptor received

 *

 * Increment the FPIN received counter/time when it happens.

 Make sure we have a congestion info buffer */

 Update congestion statistics */

/**

 * lpfc_cgn_save_evt_cnt - Save data into registered congestion buffer

 * @phba: pointer to lpfc hba data structure.

 *

 * Save the congestion event data every minute.

 * On the hour collapse all the minute data into hour data. Every day

 * collapse all the hour data into daily data. Separate driver

 * and fabrc congestion event counters that will be saved out

 * to the registered congestion buffer every minute.

 Make sure we have a congestion info buffer */

 We should get to this point in the routine on 1 minute intervals */

 Read and clear the latency counters for this minute */

	/* We need to store MB/sec bandwidth in the congestion information.

	 * block_cnt is count of 512 byte blocks for the entire minute,

	 * bps will get bytes per sec before finally converting to MB/sec.

 convert to MB/sec */

 Every minute */

 cgn parameters */

 Fill in default LUN qdepth */

	/* Record congestion buffer info - every minute

	 * cgn_driver_evt_cnt (Driver events)

	 * cgn_fabric_warn_cnt (Congestion Warnings)

	 * cgn_latency_evt_cnt / cgn_latency_evt (IO Latency)

	 * cgn_fabric_alarm_cnt (Congestion Alarms)

 Get the number of driver events in this sample and reset counter */

 Get the number of warning events - FPIN and Signal for this minute */

 Get the number of alarm events - FPIN and Signal for this minute */

	/* Collect the driver, warning, alarm and latency counts for this

	 * minute into the driver congestion buffer.

 Collect the bandwidth value into the driver's congesion buffer. */

 Every hour */

		/* Record congestion buffer info - every hour

		 * Collapse all minutes into an hour

 Avg of latency averages */

 Avg of Bandwidth averages */

 Every day */

		/* Record congestion buffer info - every hour

		 * Collapse all hours into a day. Rotate days

		 * after LPFC_MAX_CGN_DAYS.

		/* Anytime we overwrite daily index 0, after we wrap,

		 * we will be overwriting the oldest day, so we must

		 * update the congestion data start time for that day.

		 * That start time should have previously been saved after

		 * we wrote the last days worth of data.

 Avg of latency averages */

 Avg of Bandwidth averages */

		/* We just wrote LPFC_MAX_CGN_DAYS of data,

		 * so we are wrapped on any data after this.

		 * Save this as the start time for the next day.

 Use the frequency found in the last rcv'ed FPIN */

	/* Frequency (in ms) Signal Warning/Signal Congestion Notifications

	 * are received by the HBA

/**

 * lpfc_calc_cmf_latency - latency from start of rxate timer interval

 * @phba: The Hba for which this call is being executed.

 *

 * The routine calculates the latency from the beginning of the CMF timer

 * interval to the current point in time. It is called from IO completion

 * when we exceed our Bandwidth limitation for the time interval.

	/* This routine works on a ms granularity so sec and usec are

	 * converted accordingly.

/**

 * lpfc_cmf_timer -  This is the timer function for one congestion

 * rate interval.

 * @timer: Pointer to the high resolution timer that expired

 Only restart the timer if congestion mgmt is on */

	/* If pport is not ready yet, just exit and wait for

	 * the next timer cycle to hit.

	/* Do not block SCSI IO while in the timer routine since

	 * total_bytes will be cleared

	/* First we need to calculate the actual ms between

	 * the last timer interrupt and this one. We ask for

	 * LPFC_CMF_INTERVAL, however the actual time may

	 * vary depending on system overhead.

	/* Immediately after we calculate the time since the last

	 * timer interrupt, set the start time for the next

	 * interrupt

 Collect all the stats from the prior timer interval */

	/* Before we issue another CMF_SYNC_WQE, retrieve the BW

	 * returned from the last CMF_SYNC_WQE issued, from

	 * cmf_last_sync_bw. This will be the target BW for

	 * this next timer interval.

		/* Calculate any extra bytes needed to account for the

		 * timer accuracy. If we are less than LPFC_CMF_INTERVAL

		 * add an extra 3% slop factor, equal to LPFC_CMF_INTERVAL

		 * add an extra 2%. The goal is to equalize total with a

		 * time > LPFC_CMF_INTERVAL or <= LPFC_CMF_INTERVAL + 1

		/* For Monitor mode or link down we want mbpi

		 * to be the full link speed

 Update congestion info buffer latency in us */

 Calculate MBPI for the next timer interval */

		/* Change max_bytes_per_interval to what the prior

		 * CMF_SYNC_WQE cmpl indicated.

 Save rxmonitor information for debug */

 Increment rxtable index */

		/* If Monitor mode, check if we are oversubscribed

		 * against the full line rate.

 save 512 byte block cnt */

 Each minute save Fabric and Driver congestion information */

	/* Since we need to call lpfc_cgn_save_evt_cnt every minute, on the

	 * minute, adjust our next timer interval, if needed, to ensure a

	 * 1 minute granularity when we get the next timer interrupt.

		/* If we adjust timer_interval, max_bytes_per_interval

		 * needs to be adjusted as well.

	/* Since total_bytes has already been zero'ed, its okay to unblock

	 * after max_bytes_per_interval is setup.

 SCSI IO is now unblocked */

 Did port __idx reported an error */

 We got FC link speed, convert to fc_linkspeed (READ_TOPOLOGY) */

				/*

				 * SLI-4: We have only 0xA error codes

				 * defined as of now. print an appropriate

				 * message in case driver needs to be updated.

/**

 * lpfc_sli4_async_fc_evt - Process the asynchronous FC link event

 * @phba: pointer to lpfc hba data structure.

 * @acqe_fc: pointer to the async fc completion queue entry.

 *

 * This routine is to handle the SLI4 asynchronous FC event. It will simply log

 * that the event was received and then issue a read_topology mailbox command so

 * that the rest of the driver will treat it the same as SLI3.

 Keep the link status for extra SLI4 state machine reference */

 Cleanup any outstanding ELS commands */

 Block ELS IOCBs until we have done process link event */

 Update link event statistics */

 Create lpfc_handle_latt mailbox command from link ACQE */

 Initialize completion status */

 Parse port fault information field */

 Parse and translate link attention fields */

 Invoke the mailbox command callback function */

/**

 * lpfc_sli4_async_sli_evt - Process the asynchronous SLI link event

 * @phba: pointer to lpfc hba data structure.

 * @acqe_sli: pointer to the async SLI completion queue entry.

 *

 * This routine is to handle the SLI4 asynchronous SLI events.

 get port name is empty */

 fetch the status for this port */

 Skip if optic state unchanged */

 firmware is reporting a status we don't know about */

 Issue READ_CONFIG mbox command to refresh supported speeds */

 Call FW to obtain active parms */

		/* Misconfigured WWN. Reports that the SLI Port is configured

		 * to use FA-WWN, but the attached device doesn’t support it.

		 * No driver action is required.

		 * Event Data1 - N.A, Event Data2 - N.A

 EEPROM failure. No driver action is required */

 no threshold for CMF, even 1 signal will trigger an event */

 Alarm overrides warning, so check that first */

 Keep track of alarm cnt for cgn_info */

 Keep track of alarm cnt for CMF_SYNC_WQE */

 signal action needs to be taken */

 Keep track of warning cnt for cgn_info */

 Keep track of warning cnt for CMF_SYNC_WQE */

/**

 * lpfc_sli4_perform_vport_cvl - Perform clear virtual link on a vport

 * @vport: pointer to vport data structure.

 *

 * This routine is to perform Clear Virtual Link (CVL) on a vport in

 * response to a CVL event.

 *

 * Return the pointer to the ndlp with the vport if successful, otherwise

 * return NULL.

 Cannot find existing Fabric ndlp, so allocate a new one */

 Set the node type */

 Put ndlp onto node list */

 If virtual link is not yet instantiated ignore CVL */

/**

 * lpfc_sli4_perform_all_vport_cvl - Perform clear virtual link on all vports

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is to perform Clear Virtual Link (CVL) on all vports in

 * response to a FCF dead event.

/**

 * lpfc_sli4_async_fip_evt - Process the asynchronous FCoE FIP event

 * @phba: pointer to lpfc hba data structure.

 * @acqe_fip: pointer to the async fcoe completion queue entry.

 *

 * This routine is to handle the SLI4 asynchronous fcoe event.

			/*

			 * During period of FCF discovery, read the FCF

			 * table record indexed by the event to update

			 * FCF roundrobin failover eligible FCF bmask.

 If the FCF discovery is in progress, do nothing. */

 If fast FCF failover rescan event is pending, do nothing */

 If the FCF has been in discovered state, do nothing. */

 Otherwise, scan the entire FCF table and re-discover SAN */

		/*

		 * If we are in the middle of FCF failover process, clear

		 * the corresponding FCF bit in the roundrobin bitmap.

 Update FLOGI FCF failover eligible FCF bmask */

 If the event is not for currently used fcf do nothing */

		/*

		 * Otherwise, request the port to rediscover the entire FCF

		 * table for a fast recovery from case that the current FCF

		 * is no longer valid as we are not in the middle of FCF

		 * failover process already.

 Mark the fast failover process in progress */

			/*

			 * Last resort will fail over by treating this

			 * as a link down to FCF registration.

 Reset FCF roundrobin bmask for new discovery */

			/*

			 * Handling fast FCF failover to a DEAD FCF event is

			 * considered equalivant to receiving CVL to all vports.

		/*

		 * Don't re-instantiate if vport is marked for deletion.

		 * If we are here first then vport_delete is going to wait

		 * for discovery to complete.

			/*

			 * If there are other active VLinks present,

			 * re-instantiate the Vlink using FDISC.

			/*

			 * Otherwise, we request port to rediscover

			 * the entire FCF table for a fast recovery

			 * from possible case that the current FCF

			 * is no longer valid if we are not already

			 * in the FCF failover process.

 Mark the fast failover process in progress */

				/*

				 * Last resort will be re-try on the

				 * the current registered FCF entry.

				/*

				 * Reset FCF roundrobin bmask for new

				 * discovery.

/**

 * lpfc_sli4_async_dcbx_evt - Process the asynchronous dcbx event

 * @phba: pointer to lpfc hba data structure.

 * @acqe_dcbx: pointer to the async dcbx completion queue entry.

 *

 * This routine is to handle the SLI4 asynchronous dcbx event.

/**

 * lpfc_sli4_async_grp5_evt - Process the asynchronous group5 event

 * @phba: pointer to lpfc hba data structure.

 * @acqe_grp5: pointer to the async grp5 completion queue entry.

 *

 * This routine is to handle the SLI4 asynchronous grp5 event. A grp5 event

 * is an asynchronous notified of a logical link speed change.  The Port

 * reports the logical link speed in units of 10Mbps.

/**

 * lpfc_sli4_async_cmstat_evt - Process the asynchronous cmstat event

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is to handle the SLI4 asynchronous cmstat event. A cmstat event

 * is an asynchronous notification of a request to reset CM stats.

/**

 * lpfc_cgn_params_val - Validate FW congestion parameters.

 * @phba: pointer to lpfc hba data structure.

 * @p_cfg_param: pointer to FW provided congestion parameters.

 *

 * This routine validates the congestion parameters passed

 * by the FW to the driver via an ACQE event.

/**

 * lpfc_cgn_params_parse - Process a FW cong parm change event

 * @phba: pointer to lpfc hba data structure.

 * @p_cgn_param: pointer to a data buffer with the FW cong params.

 * @len: the size of pdata in bytes.

 *

 * This routine validates the congestion management buffer signature

 * from the FW, validates the contents and makes corrections for

 * valid, in-range values.  If the signature magic is correct and

 * after parameter validation, the contents are copied to the driver's

 * @phba structure. If the magic is incorrect, an error message is

 * logged.

	/* Make sure the FW has encoded the correct magic number to

	 * validate the congestion parameter in FW memory.

		/* Any parameters out of range are corrected to defaults

		 * by this routine.  No need to fail.

 Parameters are verified, move them into driver storage */

 Update parameters in congestion info buffer now */

 Turning CMF on */

 Turning CMF off */

 Resume blocked IO - unblock on workqueue */

 Turning CMF off */

/**

 * lpfc_sli4_cgn_params_read - Read and Validate FW congestion parameters.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine issues a read_object mailbox command to

 * get the congestion management parameters from the FW

 * parses it and updates the driver maintained values.

 *

 * Returns

 *  0     if the object was empty

 *  -Eval if an error was encountered

 *  Count if bytes were read from object

 Find out if the FW has a new set of congestion parameters. */

	/* 0 means no data.  A negative means error.  A positive means

	 * bytes were copied.

 Some error.  Just exit and return it to the caller.*/

	/* Parse data pointer over len and update the phba congestion

	 * parameters with values passed back.  The receive rate values

	 * may have been altered in FW, but take no action here.

/**

 * lpfc_sli4_cgn_parm_chg_evt - Process a FW congestion param change event

 * @phba: pointer to lpfc hba data structure.

 *

 * The FW generated Async ACQE SLI event calls this routine when

 * the event type is an SLI Internal Port Event and the Event Code

 * indicates a change to the FW maintained congestion parameters.

 *

 * This routine executes a Read_Object mailbox call to obtain the

 * current congestion parameters maintained in FW and corrects

 * the driver's active congestion parameters.

 *

 * The acqe event is not passed because there is no further data

 * required.

 *

 * Returns nonzero error if event processing encountered an error.

 * Zero otherwise for success.

	/* If the event is claiming an empty object, it's ok.  A write

	 * could have cleared it.  Only error is a negative return

	 * status.

/**

 * lpfc_sli4_async_event_proc - Process all the pending asynchronous event

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked by the worker thread to process all the pending

 * SLI4 asynchronous events.

 First, declare the async event has been handled */

 Now, handle all the async events */

 Process the asynchronous event */

 Free the completion event processed to the free pool */

/**

 * lpfc_sli4_fcf_redisc_event_proc - Process fcf table rediscovery event

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked by the worker thread to process FCF table

 * rediscovery pending completion event.

 Clear FCF rediscovery timeout event */

 Clear driver fast failover FCF record flag */

 Set state for FCF fast failover */

 Scan FCF table from the first entry to re-discover SAN */

/**

 * lpfc_api_table_setup - Set up per hba pci-device group func api jump table

 * @phba: pointer to lpfc hba data structure.

 * @dev_grp: The HBA PCI-Device group number.

 *

 * This routine is invoked to set up the per HBA PCI-Device group function

 * API jump table entries.

 *

 * Return: 0 if success, otherwise -ENODEV

 Set up lpfc PCI-device group */

 The LPFC_PCI_DEV_OC uses SLI4 */

 Set up device INIT API function jump table */

 Set up SCSI API function jump table */

 Set up SLI API function jump table */

 Set up MBOX API function jump table */

/**

 * lpfc_log_intr_mode - Log the active interrupt mode

 * @phba: pointer to lpfc hba data structure.

 * @intr_mode: active interrupt mode adopted.

 *

 * This routine it invoked to log the currently used active interrupt mode

 * to the device.

/**

 * lpfc_enable_pci_dev - Enable a generic PCI device.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to enable the PCI device that is common to all

 * PCI devices.

 *

 * Return codes

 * 	0 - successful

 * 	other values - error

 Obtain PCI device reference */

 Enable PCI device */

 Request PCI resource for the device */

 Set up device as PCI master and save state for EEH */

 PCIe EEH recovery on powerpc platforms needs fundamental reset */

/**

 * lpfc_disable_pci_dev - Disable a generic PCI device.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to disable the PCI device that is common to all

 * PCI devices.

 Obtain PCI device reference */

 Release PCI resource and disable PCI device */

/**

 * lpfc_reset_hba - Reset a hba

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to reset a hba device. It brings the HBA

 * offline, performs a board restart, and then brings the board back

 * online. The lpfc_offline calls lpfc_sli_hba_down which will clean up

 * on outstanding mailbox commands.

 If resets are disabled then set error state and return. */

 If not LPFC_SLI_ACTIVE, force all IO to be flushed */

/**

 * lpfc_sli_sriov_nr_virtfn_get - Get the number of sr-iov virtual functions

 * @phba: pointer to lpfc hba data structure.

 *

 * This function enables the PCI SR-IOV virtual functions to a physical

 * function. It invokes the PCI SR-IOV api with the @nr_vfn provided to

 * enable the number of virtual functions to the physical function. As

 * not all devices support SR-IOV, the return code from the pci_enable_sriov()

 * API call does not considered as an error condition for most of the device.

/**

 * lpfc_sli_probe_sriov_nr_virtfn - Enable a number of sr-iov virtual functions

 * @phba: pointer to lpfc hba data structure.

 * @nr_vfn: number of virtual functions to be enabled.

 *

 * This function enables the PCI SR-IOV virtual functions to a physical

 * function. It invokes the PCI SR-IOV api with the @nr_vfn provided to

 * enable the number of virtual functions to the physical function. As

 * not all devices support SR-IOV, the return code from the pci_enable_sriov()

 * API call does not considered as an error condition for most of the device.

/**

 * lpfc_setup_driver_resource_phase1 - Phase1 etup driver internal resources.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to set up the driver internal resources before the

 * device specific resource setup to support the HBA device it attached to.

 *

 * Return codes

 *	0 - successful

 *	other values - error

	/*

	 * Driver resources common to all SLI revisions

 Initialize port_list spinlock */

 Initialize the wait queue head for the kernel thread */

 Initialize the IO buffer list used by driver for SLI3 SCSI */

 Initialize the fabric iocb list */

 Initialize list to save ELS buffers */

 Initialize FCF connection rec list */

 Initialize OAS configuration list */

 MBOX heartbeat timer */

 Fabric block timer */

 EA polling mode timer */

 Heartbeat timer */

/**

 * lpfc_sli_driver_resource_setup - Setup driver internal resources for SLI3 dev

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to set up the driver internal resources specific to

 * support the SLI-3 HBA device it attached to.

 *

 * Return codes

 * 0 - successful

 * other values - error

	/*

	 * Initialize timers used by driver

 FCP polling mode timer */

 Host attention work mask setup */

 Get all the module params for configuring this host */

 Set up phase-1 common device driver resources */

 check for menlo minimum sg count */

	/*

	 * Since lpfc_sg_seg_cnt is module parameter, the sg_dma_buf_size

	 * used to create the sg_dma_buf_pool must be dynamically calculated.

 There are going to be 2 reserved BDEs: 1 FCP cmnd + 1 FCP rsp */

		/*

		 * The scsi_buf for a T10-DIF I/O will hold the FCP cmnd,

		 * the FCP rsp, and a BDE for each. Sice we have no control

		 * over how many protection data segments the SCSI Layer

		 * will hand us (ie: there could be one for every block

		 * in the IO), we just allocate enough BDEs to accomidate

		 * our max amount and we need to limit lpfc_sg_seg_cnt to

		 * minimize the risk of running out.

 Total BDEs in BPL for scsi_sg_list and scsi_sg_prot_list */

		/*

		 * The scsi_buf for a regular I/O will hold the FCP cmnd,

		 * the FCP rsp, a BDE for each, and a BDE for up to

		 * cfg_sg_seg_cnt data segments.

 Total BDEs in BPL for scsi_sg_list */

 This will be set to correct value after config_port mbox */

	/*

	 * Initialize the SLI Layer to run with lpfc HBAs.

 Allocate device driver memory */

	/*

	 * Enable sr-iov virtual functions if supported and configured

	 * through the module parameter.

/**

 * lpfc_sli_driver_resource_unset - Unset drvr internal resources for SLI3 dev

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to unset the driver internal resources set up

 * specific for supporting the SLI-3 HBA device it attached to.

 Free device driver memory allocated */

/**

 * lpfc_sli4_driver_resource_setup - Setup drvr internal resources for SLI4 dev

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to set up the driver internal resources specific to

 * support the SLI-4 HBA device it attached to.

 *

 * Return codes

 * 	0 - successful

 * 	other values - error

 Get all the module params for configuring this host */

 Set up phase-1 common device driver resources */

 Before proceed, wait for POST done and device ready */

 Allocate all driver workqueues here */

 The lpfc_wq workqueue for deferred irq use */

	/*

	 * Initialize timers used by driver

 FCF rediscover timer */

 CMF congestion timer */

	/*

	 * Control structure for handling external multi-buffer mailbox

	 * command pass-through.

 This will be set to correct value after the read_config mbox */

 Program the default value of vlan_id and fc_map */

	/*

	 * For SLI4, instead of using ring 0 (LPFC_FCP_RING) for FCP commands

	 * we will associate a new ring, for each EQ/CQ/WQ tuple.

	 * The WQ create will allocate the ring.

 Initialize buffer queue management fields */

 for VMID idle timeout if VMID is enabled */

	/*

	 * Initialize the SLI Layer to run with lpfc SLI4 HBAs.

 Initialize the Abort buffer list used by driver */

 Initialize the Abort nvme buffer list used by driver */

 This abort list used by worker thread */

	/*

	 * Initialize driver internal slow-path work queues

 Driver internel slow-path CQ Event pool */

 Response IOCB work queue list */

 Asynchronous event CQ Event work queue list */

 Slow-path XRI aborted CQ Event work queue list */

 Receive queue CQ Event work queue list */

 Initialize extent block lists. */

	/* Initialize mboxq lists. If the early init routines fail

	 * these lists need to be correctly initialized.

 initialize optic_state to 0xFF */

 Allocate device driver memory */

 IF Type 2 ports get initialized now. */

 Create the bootstrap mailbox command */

 Set up the host's endian order with the device. */

 Set up the hba's configuration parameters. */

 IF Type 0 ports get initialized now. */

 Check for NVMET being configured */

 First get WWN of HBA instance */

 wwn is WWPN of HBA instance */

 Check to see if it matches any module parameter */

 a match */

 Not supported for NVMET */

	/*

	 * Get sli4 parameters that override parameters from Port capabilities.

	 * If this call fails, it isn't critical unless the SLI4 parameters come

	 * back in conflict.

	/*

	 * 1 for cmd, 1 for rsp, NVME adds an extra one

	 * for boundary conditions in its max_sgl_segment template.

	/*

	 * It doesn't matter what family our adapter is in, we are

	 * limited to 2 Pages, 512 SGEs, for our SGL.

	 * There are going to be 2 reserved SGEs: 1 FCP cmnd + 1 FCP rsp

	/*

	 * Since lpfc_sg_seg_cnt is module param, the sg_dma_buf_size

	 * used to create the sg_dma_buf_pool must be calculated.

 Both cfg_enable_bg and cfg_external_dif code paths */

		/*

		 * The scsi_buf for a T10-DIF I/O holds the FCP cmnd,

		 * the FCP rsp, and a SGE. Sice we have no control

		 * over how many protection segments the SCSI Layer

		 * will hand us (ie: there could be one for every block

		 * in the IO), just allocate enough SGEs to accomidate

		 * our max amount and we need to limit lpfc_sg_seg_cnt

		 * to minimize the risk of running out.

 Total SGEs for scsi_sg_list and scsi_sg_prot_list */

		/*

		 * If supporting DIF, reduce the seg count for scsi to

		 * allow room for the DIF sges.

		/*

		 * The scsi_buf for a regular I/O holds the FCP cmnd,

		 * the FCP rsp, a SGE for each, and a SGE for up to

		 * cfg_sg_seg_cnt data segments.

 Total SGEs for scsi_sg_list */

		/*

		 * NOTE: if (phba->cfg_sg_seg_cnt + extra) <= 256 we only

		 * need to post 1 page for the SGL.

 Limit to LPFC_MAX_NVME_SEG_CNT for NVME. */

 Verify OAS is supported */

 Verify RAS support on adapter */

 Verify all the SLI4 queues */

 Create driver internal CQE event pool */

 Initialize sgl lists per host */

 Allocate and initialize active sgl array */

 Allocate eligible FCF bmask memory for FCF roundrobin failover */

	/*

	 * Enable sr-iov virtual functions if supported and configured

	 * through the module parameter.

/**

 * lpfc_sli4_driver_resource_unset - Unset drvr internal resources for SLI4 dev

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to unset the driver internal resources set up

 * specific for supporting the SLI-4 HBA device it attached to.

 Free memory allocated for msi-x interrupt vector to CPU mapping */

 Free memory allocated for fast-path work queue handles */

 Free the allocated rpi headers. */

 Free eligible FCF index bmask */

 Free the ELS sgl list */

 Free the completion queue EQ event pool */

 Release resource identifiers. */

 Free the bsmbx region. */

 Free the SLI Layer memory with SLI4 HBAs */

 Free the current connect table */

/**

 * lpfc_init_api_table_setup - Set up init api function jump table

 * @phba: The hba struct for which this call is being executed.

 * @dev_grp: The HBA PCI-Device group number.

 *

 * This routine sets up the device INIT interface API function jump table

 * in @phba struct.

 *

 * Returns: 0 - success, -ENODEV - failure.

/**

 * lpfc_setup_driver_resource_phase2 - Phase2 setup driver internal resources.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to set up the driver internal resources after the

 * device specific resource setup to support the HBA device it attached to.

 *

 * Return codes

 * 	0 - successful

 * 	other values - error

 Startup the kernel thread for this host adapter. */

/**

 * lpfc_unset_driver_resource_phase2 - Phase2 unset driver internal resources.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to unset the driver internal resources set up after

 * the device specific resource setup for supporting the HBA device it

 * attached to.

 Stop kernel worker thread */

/**

 * lpfc_free_iocb_list - Free iocb list.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to free the driver's IOCB list and memory.

/**

 * lpfc_init_iocb_list - Allocate and initialize iocb list.

 * @phba: pointer to lpfc hba data structure.

 * @iocb_count: number of requested iocbs

 *

 * This routine is invoked to allocate and initizlize the driver's IOCB

 * list and set up the IOCB tag array accordingly.

 *

 * Return codes

 *	0 - successful

 *	other values - error

 Initialize and populate the iocb list per host.  */

/**

 * lpfc_free_sgl_list - Free a given sgl list.

 * @phba: pointer to lpfc hba data structure.

 * @sglq_list: pointer to the head of sgl list.

 *

 * This routine is invoked to free a give sgl list and memory.

/**

 * lpfc_free_els_sgl_list - Free els sgl list.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to free the driver's els sgl list and memory.

 Retrieve all els sgls from driver list */

 Now free the sgl list */

/**

 * lpfc_free_nvmet_sgl_list - Free nvmet sgl list.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to free the driver's nvmet sgl list and memory.

 Retrieve all nvmet sgls from driver list */

 Now free the sgl list */

	/* Update the nvmet_xri_cnt to reflect no current sgls.

	 * The next initialization cycle sets the count and allocates

	 * the sgls over again.

/**

 * lpfc_init_active_sgl_array - Allocate the buf to track active ELS XRIs.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to allocate the driver's active sgl memory.

 * This array will hold the sglq_entry's for active IOs.

/**

 * lpfc_free_active_sgl - Free the buf that tracks active ELS XRIs.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to walk through the array of active sglq entries

 * and free all of the resources.

 * This is just a place holder for now.

/**

 * lpfc_init_sgl_list - Allocate and initialize sgl list.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to allocate and initizlize the driver's sgl

 * list and set up the sgl xritag tag array accordingly.

 *

 Initialize and populate the sglq list per host/VF. */

 els xri-sgl book keeping */

 nvme xri-buffer book keeping */

/**

 * lpfc_sli4_init_rpi_hdrs - Post the rpi header memory region to the port

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to post rpi header templates to the

 * port for those SLI4 ports that do not support extents.  This routine

 * posts a PAGE_SIZE memory region to the port to hold up to

 * PAGE_SIZE modulo 64 rpi context headers.  This is an initialization routine

 * and should be called only when interrupts are disabled.

 *

 * Return codes

 * 	0 - successful

 *	-ERROR - otherwise.

/**

 * lpfc_sli4_create_rpi_hdr - Allocate an rpi header memory region

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to allocate a single 4KB memory region to

 * support rpis and stores them in the phba.  This single region

 * provides support for up to 64 rpis.  The region is used globally

 * by the device.

 *

 * Returns:

 *   A valid rpi hdr on success.

 *   A NULL pointer on any failure.

	/*

	 * If the SLI4 port supports extents, posting the rpi header isn't

	 * required.  Set the expected maximum count and let the actual value

	 * get set when extents are fully allocated.

 The limit on the logical index is just the max_rpi count. */

	/*

	 * Establish the starting RPI in this header block.  The starting

	 * rpi is normalized to a zero base because the physical rpi is

	 * port based.

 Reached full RPI range */

	/*

	 * First allocate the protocol header region for the port.  The

	 * port expects a 4KB DMA-mapped memory region that is 4K aligned.

 Save the rpi header data for cleanup later. */

 The rpi_hdr stores the logical index only. */

/**

 * lpfc_sli4_remove_rpi_hdrs - Remove all rpi header memory regions

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to remove all memory resources allocated

 * to support rpis for SLI4 ports not supporting extents. This routine

 * presumes the caller has released all rpis consumed by fabric or port

 * logins and is prepared to have the header pages removed.

 There are no rpis available to the port now. */

/**

 * lpfc_hba_alloc - Allocate driver hba data structure for a device.

 * @pdev: pointer to pci device data structure.

 *

 * This routine is invoked to allocate the driver hba data structure for an

 * HBA device. If the allocation is successful, the phba reference to the

 * PCI device data structure is set.

 *

 * Return codes

 *      pointer to @phba - successful

 *      NULL - error

 Allocate memory for HBA structure */

 Set reference to PCI device in HBA structure */

 Assign an unused board number */

/**

 * lpfc_hba_free - Free driver hba data structure with a device.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to free the driver hba data structure with an

 * HBA device.

 Release the driver assigned board number */

 Free memory allocated with sli3 rings */

/**

 * lpfc_create_shost - Create hba physical port with associated scsi host.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to create HBA physical port and associate a SCSI

 * host with it.

 *

 * Return codes

 *      0 - successful

 *      other values - error

 Initialize HBA FC structure */

 Only 1 vport (pport) will support NVME target */

 Put reference to SCSI host to driver's device private data */

	/*

	 * At this point we are fully registered with PSA. In addition,

	 * any initial discovery should be completed.

 Setup appropriate attribute masks */

/**

 * lpfc_destroy_shost - Destroy hba physical port with associated scsi host.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to destroy HBA physical port and the associated

 * SCSI host.

 Destroy physical port that associated with the SCSI host */

/**

 * lpfc_setup_bg - Setup Block guard structures and debug areas.

 * @phba: pointer to lpfc hba data structure.

 * @shost: the shost to be used to detect Block guard settings.

 *

 * This routine sets up the local Block guard protocol settings for @shost.

 * This routine also allocates memory for debugging bg buffers.

 Only allow supported values */

 DIF Type 1 protection for profiles AST1/C1 is end to end */

/**

 * lpfc_post_init_setup - Perform necessary device post initialization setup.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to perform all the necessary post initialization

 * setup for the device.

 Get the default values for Model Name and Description */

	/*

	 * hba setup may have changed the hba_queue_depth so we need to

	 * adjust the value of can_queue.

 Send board arrival event to upper layer */

/**

 * lpfc_sli_pci_mem_setup - Setup SLI3 HBA PCI memory space.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to set up the PCI device memory space for device

 * with SLI-3 interface spec.

 *

 * Return codes

 * 	0 - successful

 * 	other values - error

 Set the device DMA mask size */

	/* Get the bus address of Bar0 and Bar2 and the number of bytes

	 * required by each mapping.

 Map HBA SLIM to a kernel virtual address. */

 Map HBA Control Registers to a kernel virtual address. */

 Allocate memory for SLI-2 structures */

/**

 * lpfc_sli_pci_mem_unset - Unset SLI3 HBA PCI memory space.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to unset the PCI device memory space for device

 * with SLI-3 interface spec.

 Obtain PCI device reference */

 Free coherent DMA memory allocated */

 I/O memory unmap */

/**

 * lpfc_sli4_post_status_check - Wait for SLI4 POST done and check status

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to wait for SLI4 device Power On Self Test (POST)

 * done and check status.

 *

 * Return 0 if successful, otherwise -ENODEV.

 Wait up to 30 seconds for the SLI Port POST done and ready */

 Port has a fatal POST error, break out */

	/*

	 * If there was a port error during POST, then don't proceed with

	 * other register reads as the data may not be valid.  Just exit.

		/*

		 * Check for other Port errors during the initialization

		 * process.  Fail the load if the port did not come up

		 * correctly.

 Final checks.  The port status should be clean. */

/**

 * lpfc_sli4_bar0_register_memmap - Set up SLI4 BAR0 register memory map.

 * @phba: pointer to lpfc hba data structure.

 * @if_type:  The SLI4 interface type getting configured.

 *

 * This routine is invoked to set up SLI4 BAR0 PCI config space register

 * memory map.

/**

 * lpfc_sli4_bar1_register_memmap - Set up SLI4 BAR1 register memory map.

 * @phba: pointer to lpfc hba data structure.

 * @if_type: sli if type to operate on.

 *

 * This routine is invoked to set up SLI4 BAR1 register memory map.

/**

 * lpfc_sli4_bar2_register_memmap - Set up SLI4 BAR2 register memory map.

 * @phba: pointer to lpfc hba data structure.

 * @vf: virtual function number

 *

 * This routine is invoked to set up SLI4 BAR2 doorbell register memory map

 * based on the given viftual function number, @vf.

 *

 * Return 0 if successful, otherwise -ENODEV.

/**

 * lpfc_create_bootstrap_mbox - Create the bootstrap mailbox

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to create the bootstrap mailbox

 * region consistent with the SLI-4 interface spec.  This

 * routine allocates all memory necessary to communicate

 * mailbox commands to the port and sets up all alignment

 * needs.  No locks are expected to be held when calling

 * this routine.

 *

 * Return codes

 * 	0 - successful

 * 	-ENOMEM - could not allocated memory.

	/*

	 * The bootstrap mailbox region is comprised of 2 parts

	 * plus an alignment restriction of 16 bytes.

	/*

	 * Initialize the bootstrap mailbox pointers now so that the register

	 * operations are simple later.  The mailbox dma address is required

	 * to be 16-byte aligned.  Also align the virtual memory as each

	 * maibox is copied into the bmbx mailbox region before issuing the

	 * command to the port.

	/*

	 * Set the high and low physical addresses now.  The SLI4 alignment

	 * requirement is 16 bytes and the mailbox is posted to the port

	 * as two 30-bit addresses.  The other data is a bit marking whether

	 * the 30-bit address is the high or low address.

	 * Upcast bmbx aphys to 64bits so shift instruction compiles

	 * clean on 32 bit machines.

/**

 * lpfc_destroy_bootstrap_mbox - Destroy all bootstrap mailbox resources

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to teardown the bootstrap mailbox

 * region and release all host resources. This routine requires

 * the caller to ensure all mailbox commands recovered, no

 * additional mailbox comands are sent, and interrupts are disabled

 * before calling this routine.

 *

/**

 * lpfc_map_topology - Map the topology read from READ_CONFIG

 * @phba: pointer to lpfc hba data structure.

 * @rd_config: pointer to read config data

 *

 * This routine is invoked to map the topology values as read

 * from the read config mailbox command. If the persistent

 * topology feature is supported, the firmware will provide the

 * saved topology information to be used in INIT_LINK

 FW supports persistent topology - override module parameter value */

 if ASIC_GEN_NUM >= 0xC) */

 G5 */

 If topology failover set - pt is '0' or '1' */

/**

 * lpfc_sli4_read_config - Get the config parameters.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to read the configuration parameters from the HBA.

 * The configuration parameters are used to set the base and maximum values

 * for RPI's XRI's VPI's VFI's and FCFIs. These values also affect the resource

 * allocation for the port.

 *

 * Return codes

 * 	0 - successful

 * 	-ENOMEM - No available memory

 *      -EIO - The mailbox failed to complete successfully.

 Reduce resource usage in kdump environment */

 Limit the max we support */

		/* Next decide on FPIN or Signal E2E CGN support

		 * For congestion alarms and warnings valid combination are:

		 * 1. FPIN alarms / FPIN warnings

		 * 2. Signal alarms / Signal warnings

		 * 3. FPIN alarms / Signal warnings

		 * 4. Signal alarms / FPIN warnings

		 *

		 * Initialize the adapter frequency to 100 mSecs

				/* MUST support both alarm and warning

				 * because EDC does not support alarm alone.

 Must support both or none */

 Set the congestion initial signal and fpin values. */

		/*

		 * Calculate queue resources based on how

		 * many WQ/CQ/EQs are available.

		/*

		 * Whats left after this can go toward NVME / FCP.

		 * The minus 4 accounts for ELS, NVME LS, MBOX

		 * plus one extra. When configured for

		 * NVMET, FCP io channel WQs are not created.

 Check to see if there is enough for NVME */

 Update link speed if forced link speed is supported */

 Reset the DFT_HBA_Q_DEPTH to the max xri  */

 get the pf# and vf# for SLI4 if_type 2 port */

 search for fc_fcoe resrouce descriptor */

/**

 * lpfc_setup_endian_order - Write endian order to an SLI4 if_type 0 port.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to setup the port-side endian order when

 * the port if_type is 0.  This routine has no function for other

 * if_types.

 *

 * Return codes

 * 	0 - successful

 * 	-ENOMEM - No available memory

 *      -EIO - The mailbox failed to complete successfully.

		/*

		 * The SLI4_CONFIG_SPECIAL mailbox command requires the first

		 * two words to contain special data values and no other data.

/**

 * lpfc_sli4_queue_verify - Verify and update EQ counts

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to check the user settable queue counts for EQs.

 * After this routine is called the counts will be set to valid values that

 * adhere to the constraints of the system's interrupt vectors and the port's

 * queue resources.

 *

 * Return codes

 *      0 - successful

 *      -ENOMEM - No available memory

	/*

	 * Sanity check for configured queue parameters against the run-time

	 * device parameters

 Get EQ depth from module parameter, fake the default for now */

 Get CQ depth from module parameter, fake the default for now */

 Create Fast Path IO CQs */

 Increase the CQ size when WQEs contain an embedded cdb */

 Create Fast Path IO WQs */

 Increase the WQ size when WQEs contain an embedded cdb */

/**

 * lpfc_sli4_queue_create - Create all the SLI4 queues

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to allocate all the SLI4 queues for the FCoE HBA

 * operation. For each SLI4 queue type, the parameters such as queue entry

 * count (queue depth) shall be taken from the module parameter. For now,

 * we just use some constant number as place holder.

 *

 * Return codes

 *      0 - successful

 *      -ENOMEM - No availble memory

 *      -EIO - The mailbox failed to complete successfully.

	/*

	 * Create HBA Record arrays.

	 * Both NVME and FCP will share that same vectors / EQs

 Prepare hardware queues to take IO buffers */

 Create HBA Event Queues (EQs) */

		/* We only want to create 1 EQ per vector, even though

		 * multiple CPUs might be using that vector. so only

		 * selects the CPUs that are LPFC_CPU_FIRST_IRQ.

 Get a ptr to the Hardware Queue associated with this CPU */

 Allocate an EQ */

 First CPU this EQ is affinitized to */

 Save the allocated EQ in the Hardware Queue */

	/* Now we need to populate the other Hardware Queues, that share

	 * an IRQ vector, with the associated EQ ptr.

 Check for EQ already allocated in previous loop */

 Check for multiple CPUs per hdwq */

 We need to share an EQ for this hdwq */

 Allocate IO Path SLI4 CQ/WQs */

	/*

	 * Create Slow Path Completion Queues (CQs)

 Create slow-path Mailbox Command Complete Queue */

 Create slow-path ELS Complete Queue */

	/*

	 * Create Slow Path Work Queues (WQs)

 Create Mailbox Command Queue */

	/*

	 * Create ELS Work Queues

 Create slow-path ELS Work Queue */

 Create NVME LS Complete Queue */

 Create NVME LS Work Queue */

	/*

	 * Create Receive Queue (RQ)

 Create Receive Queue for header */

 Create Receive Queue for data */

 Create NVMET Receive Queue for header */

 Only needed for header of RQ pair */

 Put list in known state in case driver load fails. */

 Create NVMET Receive Queue for data */

 Clear NVME stats */

 Clear SCSI stats */

 Loop thru all Hardware Queues */

 Free the CQ/WQ corresponding to the Hardware Queue */

 Loop thru all IRQ vectors */

 Free the EQ corresponding to the IRQ vector */

/**

 * lpfc_sli4_queue_destroy - Destroy all the SLI4 queues

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to release all the SLI4 queues with the FCoE HBA

 * operation.

 *

 * Return codes

 *      0 - successful

 *      -ENOMEM - No available memory

 *      -EIO - The mailbox failed to complete successfully.

	/*

	 * Set FREE_INIT before beginning to free the queues.

	 * Wait until the users of queues to acknowledge to

	 * release queues by clearing FREE_WAIT.

 Release HBA eqs */

 Release mailbox command work queue */

 Release ELS work queue */

 Release ELS work queue */

 Release unsolicited receive queue */

 Release ELS complete queue */

 Release NVME LS complete queue */

 Release mailbox command complete queue */

 Everything on this list has been freed */

 Done with freeing the queues */

 create the Cq first */

 Setup cq_map for fast lookup */

 create the wq */

 no need to tear down cq - caller will do so */

 Bind this CQ/WQ to the NVME ring */

 no need to tear down cq - caller will do so */

/**

 * lpfc_setup_cq_lookup - Setup the CQ lookup table

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine will populate the cq_lookup table by all

 * available CQ queue_id's.

 Loop thru all IRQ vectors */

 Get the EQ corresponding to the IRQ vector */

 Loop through all CQs associated with that EQ */

/**

 * lpfc_sli4_queue_setup - Set up all the SLI4 queues

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to set up all the SLI4 queues for the FCoE HBA

 * operation.

 *

 * Return codes

 *      0 - successful

 *      -ENOMEM - No available memory

 *      -EIO - The mailbox failed to complete successfully.

 Check for dual-ULP support */

	/*

	 * Set up HBA Event Queues (EQs)

 Set up HBA event queue */

 Loop thru all IRQ vectors */

 Create HBA Event Queues (EQs) in order */

			/* Look for the CPU thats using that vector with

			 * LPFC_CPU_FIRST_IRQ set.

 Create an EQ for that vector */

 Save the EQ for that vector in the hba_eq_hdl */

 Loop thru all Hardware Queues */

 Create the CQ/WQ corresponding to the Hardware Queue */

	/*

	 * Set up Slow Path Complete Queues (CQs)

 Set up slow-path MBOX CQ/MQ */

 Set up NVMET Receive Complete Queue */

 Set up slow-path ELS WQ/CQ */

 Set up NVME LS Complete Queue */

	/*

	 * Create NVMET Receive Queue (RQ)

/**

 * lpfc_sli4_queue_unset - Unset all the SLI4 queues

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to unset all the SLI4 queues with the FCoE HBA

 * operation.

 *

 * Return codes

 *      0 - successful

 *      -ENOMEM - No available memory

 *      -EIO - The mailbox failed to complete successfully.

 Unset mailbox command work queue */

 Unset NVME LS work queue */

 Unset ELS work queue */

 Unset unsolicited receive queue */

 Unset mailbox command complete queue */

 Unset ELS complete queue */

 Unset NVME LS complete queue */

 Unset NVMET MRQ queue */

 Unset NVMET CQ Set complete queue */

 Unset fast-path SLI4 queues */

 Loop thru all Hardware Queues */

 Destroy the CQ/WQ corresponding to Hardware Queue */

 Loop thru all IRQ vectors */

 Destroy the EQ corresponding to the IRQ vector */

/**

 * lpfc_sli4_cq_event_pool_create - Create completion-queue event free pool

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to allocate and set up a pool of completion queue

 * events. The body of the completion queue event is a completion queue entry

 * CQE. For now, this pool is used for the interrupt service routine to queue

 * the following HBA completion queue events for the worker thread to process:

 *   - Mailbox asynchronous events

 *   - Receive queue completion unsolicited events

 * Later, this can be used for all the slow-path events.

 *

 * Return codes

 *      0 - successful

 *      -ENOMEM - No available memory

/**

 * lpfc_sli4_cq_event_pool_destroy - Free completion-queue event free pool

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to free the pool of completion queue events at

 * driver unload time. Note that, it is the responsibility of the driver

 * cleanup routine to free all the outstanding completion-queue events

 * allocated from this pool back into the pool before invoking this routine

 * to destroy the pool.

/**

 * __lpfc_sli4_cq_event_alloc - Allocate a completion-queue event from free pool

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is the lock free version of the API invoked to allocate a

 * completion-queue event from the free pool.

 *

 * Return: Pointer to the newly allocated completion-queue event if successful

 *         NULL otherwise.

/**

 * lpfc_sli4_cq_event_alloc - Allocate a completion-queue event from free pool

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is the lock version of the API invoked to allocate a

 * completion-queue event from the free pool.

 *

 * Return: Pointer to the newly allocated completion-queue event if successful

 *         NULL otherwise.

/**

 * __lpfc_sli4_cq_event_release - Release a completion-queue event to free pool

 * @phba: pointer to lpfc hba data structure.

 * @cq_event: pointer to the completion queue event to be freed.

 *

 * This routine is the lock free version of the API invoked to release a

 * completion-queue event back into the free pool.

/**

 * lpfc_sli4_cq_event_release - Release a completion-queue event to free pool

 * @phba: pointer to lpfc hba data structure.

 * @cq_event: pointer to the completion queue event to be freed.

 *

 * This routine is the lock version of the API invoked to release a

 * completion-queue event back into the free pool.

/**

 * lpfc_sli4_cq_event_release_all - Release all cq events to the free pool

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is to free all the pending completion-queue events to the

 * back into the free pool for device reset.

 Retrieve all the pending WCQEs from pending WCQE lists */

 Pending ELS XRI abort events */

 Pending asynnc events */

/**

 * lpfc_pci_function_reset - Reset pci function.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to request a PCI function reset. It will destroys

 * all resources assigned to the PCI function which originates this request.

 *

 * Return codes

 *      0 - successful

 *      -ENOMEM - No available memory

 *      -EIO - The mailbox failed to complete successfully.

 Setup PCI function reset mailbox-ioctl command */

		/*

		 * Poll the Port Status Register and wait for RDY for

		 * up to 30 seconds. If the port doesn't respond, treat

		 * it as an error.

			/*

			 * Reset the port now

 flush */

 Catch the not-ready port failure after a port reset. */

/**

 * lpfc_sli4_pci_mem_setup - Setup SLI4 HBA PCI memory space.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to set up the PCI device memory space for device

 * with SLI-4 interface spec.

 *

 * Return codes

 * 	0 - successful

 * 	other values - error

 Set the device DMA mask size */

	/*

	 * The BARs and register set definitions and offset locations are

	 * dependent on the if_type.

 There is no SLI3 failback for SLI4 devices. */

	/*

	 * Get the bus address of SLI4 device Bar regions and the

	 * number of bytes required by each mapping. The mapping of the

	 * particular PCI BARs regions is dependent on the type of

	 * SLI4 device.

		/*

		 * Map SLI4 PCI Config Space Register base to a kernel virtual

		 * addr

 Set up BAR0 PCI config space register memory map */

			/*

			 * Map SLI4 if type 0 HBA Control Register base to a

			 * kernel virtual address and setup the registers.

		/*

		 * Map SLI4 if type 6 HBA Doorbell Register base to a kernel

		 * virtual address and setup the registers.

			/*

			 * Map SLI4 if type 0 HBA Doorbell Register base to

			 * a kernel virtual address and setup the registers.

		/*

		 * Map SLI4 if type 6 HBA DPP Register base to a kernel

		 * virtual address and setup the registers.

 Set up the EQ/CQ register handeling functions now */

/**

 * lpfc_sli4_pci_mem_unset - Unset SLI4 HBA PCI memory space.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to unset the PCI device memory space for device

 * with SLI-4 interface spec.

/**

 * lpfc_sli_enable_msix - Enable MSI-X interrupt mode on SLI-3 device

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to enable the MSI-X interrupt vectors to device

 * with SLI-3 interface specs.

 *

 * Return codes

 *   0 - successful

 *   other values - error

 Set up MSI-X multi-message vectors */

	/*

	 * Assign MSI-X vectors to interrupt handlers

 vector-0 is associated to slow-path handler */

 vector-1 is associated to fast-path handler */

	/*

	 * Configure HBA MSI-X attention conditions to messages

 Free memory allocated for mailbox command */

 Free memory allocated for mailbox command */

 free the irq already requested */

 free the irq already requested */

 Unconfigure MSI-X capability structure */

/**

 * lpfc_sli_enable_msi - Enable MSI interrupt mode on SLI-3 device.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to enable the MSI interrupt mode to device with

 * SLI-3 interface spec. The kernel function pci_enable_msi() is called to

 * enable the MSI vector. The device driver is responsible for calling the

 * request_irq() to register MSI vector with a interrupt the handler, which

 * is done in this function.

 *

 * Return codes

 * 	0 - successful

 * 	other values - error

/**

 * lpfc_sli_enable_intr - Enable device interrupt to SLI-3 device.

 * @phba: pointer to lpfc hba data structure.

 * @cfg_mode: Interrupt configuration mode (INTx, MSI or MSI-X).

 *

 * This routine is invoked to enable device interrupt and associate driver's

 * interrupt handler(s) to interrupt vector(s) to device with SLI-3 interface

 * spec. Depends on the interrupt mode configured to the driver, the driver

 * will try to fallback from the configured interrupt mode to an interrupt

 * mode which is supported by the platform, kernel, and device in the order

 * of:

 * MSI-X -> MSI -> IRQ.

 *

 * Return codes

 *   0 - successful

 *   other values - error

 Need to issue conf_port mbox cmd before conf_msi mbox cmd */

 Now, try to enable MSI-X interrupt mode */

 Indicate initialization to MSI-X mode */

 Fallback to MSI if MSI-X initialization failed */

 Indicate initialization to MSI mode */

 Fallback to INTx if both MSI-X/MSI initalization failed */

 Indicate initialization to INTx mode */

/**

 * lpfc_sli_disable_intr - Disable device interrupt to SLI-3 device.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to disable device interrupt and disassociate the

 * driver's interrupt handler(s) from interrupt vector(s) to device with

 * SLI-3 interface spec. Depending on the interrupt mode, the driver will

 * release the interrupt vector(s) for the message signaled interrupt.

 Reset interrupt management states */

/**

 * lpfc_find_cpu_handle - Find the CPU that corresponds to the specified Queue

 * @phba: pointer to lpfc hba data structure.

 * @id: EQ vector index or Hardware Queue index

 * @match: LPFC_FIND_BY_EQ = match by EQ

 *         LPFC_FIND_BY_HDWQ = match by Hardware Queue

 * Return the CPU that matches the selection criteria

 Loop through all CPUs */

		/* If we are matching by EQ, there may be multiple CPUs using

		 * using the same vector, so select the one with

		 * LPFC_CPU_FIRST_IRQ set.

 If matching by HDWQ, select the first CPU that matches */

/**

 * lpfc_find_hyper - Determine if the CPU map entry is hyper-threaded

 * @phba: pointer to lpfc hba data structure.

 * @cpu: CPU map index

 * @phys_id: CPU package physical id

 * @core_id: CPU core id

 Does the cpup match the one we are looking for */

/*

 * lpfc_assign_eq_map_info - Assigns eq for vector_map structure

 * @phba: pointer to lpfc hba data structure.

 * @eqidx: index for eq and irq vector

 * @flag: flags to set for vector_map structure

 * @cpu: cpu used to index vector_map structure

 *

 * The routine assigns eq info into vector_map structure

/**

 * lpfc_cpu_map_array_init - Initialize cpu_map structure

 * @phba: pointer to lpfc hba data structure.

 *

 * The routine initializes the cpu_map array structure

/**

 * lpfc_hba_eq_hdl_array_init - Initialize hba_eq_hdl structure

 * @phba: pointer to lpfc hba data structure.

 *

 * The routine initializes the hba_eq_hdl array structure

/**

 * lpfc_cpu_affinity_check - Check vector CPU affinity mappings

 * @phba: pointer to lpfc hba data structure.

 * @vectors: number of msix vectors allocated.

 *

 * The routine will figure out the CPU affinity assignment for every

 * MSI-X vector allocated for the HBA.

 * In addition, the CPU to IO channel mapping will be calculated

 * and the phba->sli4_hba.cpu_map array will reflect this.

 Update CPU map with physical id and core id of each CPU */

 No distinction between CPUs for other platforms */

	/* After looking at each irq vector assigned to this pcidev, its

	 * possible to see that not ALL CPUs have been accounted for.

	 * Next we will set any unassigned (unaffinitized) cpu map

	 * entries to a IRQ on the same phys_id.

 Is this CPU entry unassigned */

 Mark CPU as IRQ not assigned by the kernel */

			/* If so, find a new_cpup thats on the the SAME

			 * phys_id as cpup. start_cpu will start where we

			 * left off so all unassigned entries don't get assgined

			 * the IRQ of the first entry.

 At this point, we leave the CPU as unassigned */

 We found a matching phys_id, so copy the IRQ info */

			/* Bump start_cpu to the next slot to minmize the

			 * chance of having multiple unassigned CPU entries

			 * selecting the same IRQ.

 Set any unassigned cpu map entries to a IRQ on any phys_id */

 Is this entry unassigned */

 Mark it as IRQ not assigned by the kernel */

			/* If so, find a new_cpup thats on ANY phys_id

			 * as the cpup. start_cpu will start where we

			 * left off so all unassigned entries don't get

			 * assigned the IRQ of the first entry.

 We should never leave an entry unassigned */

 We found an available entry, copy the IRQ info */

			/* Bump start_cpu to the next slot to minmize the

			 * chance of having multiple unassigned CPU entries

			 * selecting the same IRQ.

	/* Assign hdwq indices that are unique across all cpus in the map

	 * that are also FIRST_CPUs.

 Only FIRST IRQs get a hdwq index assignment. */

 1 to 1, the first LPFC_CPU_FIRST_IRQ cpus to a unique hdwq */

	/* Associate a hdwq with each cpu_map entry

	 * This will be 1 to 1 - hdwq to cpu, unless there are less

	 * hardware queues then CPUs. For that case we will just round-robin

	 * the available hardware queues as they get assigned to CPUs.

	 * The next_idx is the idx from the FIRST_CPU loop above to account

	 * for irq_chann < hdwq.  The idx is used for round-robin assignments

	 * and needs to start at 0.

 FIRST cpus are already mapped. */

		/* If the cfg_irq_chann < cfg_hdw_queue, set the hdwq

		 * of the unassigned cpus to the next idx so that all

		 * hdw queues are fully utilized.

		/* Not a First CPU and all hdw_queues are used.  Reuse a

		 * Hardware Queue for another CPU, so be smart about it

		 * and pick one that has its IRQ/EQ mapped to the same phys_id

		 * (CPU package) and core_id.

		/* If we can't match both phys_id and core_id,

		 * settle for just a phys_id match.

 Otherwise just round robin on cfg_hdw_queue */

 We found an available entry, copy the IRQ info */

	/*

	 * Initialize the cpu_map slots for not-present cpus in case

	 * a cpu is hot-added. Perform a simple hdwq round robin assignment.

	/* The cpu_map array will be used later during initialization

	 * when EQ / CQ / WQs are allocated and configured.

/**

 * lpfc_cpuhp_get_eq

 *

 * @phba:   pointer to lpfc hba data structure.

 * @cpu:    cpu going offline

 * @eqlist: eq list to append to

		/*

		 * if irq is not affinitized to the cpu going

		 * then we don't need to poll the eq attached

		 * to it.

		/* get the cpus that are online and are affini-

		 * tized to this irq vector.  If the count is

		 * more than 1 then cpuhp is not going to shut-

		 * down this vector.  Since this cpu has not

		 * gone offline yet, we need >1.

		/* Now that we have an irq to shutdown, get the eq

		 * mapped to this irq.  Note: multiple hdwq's in

		 * the software can share an eq, but eventually

		 * only eq will be mapped to this vector

	/*

	 * unregistering the instance doesn't stop the polling

	 * timer. Wait for the poll timer to retire.

 proceed with the hotplug */

/**

 * lpfc_irq_set_aff - set IRQ affinity

 * @eqhdl: EQ handle

 * @cpu: cpu to set affinity

 *

/**

 * lpfc_irq_clear_aff - clear IRQ affinity

 * @eqhdl: EQ handle

 *

/**

 * lpfc_irq_rebalance - rebalances IRQ affinity according to cpuhp event

 * @phba: pointer to HBA context object.

 * @cpu: cpu going offline/online

 * @offline: true, cpu is going offline. false, cpu is coming online.

 *

 * If cpu is going offline, we'll try our best effort to find the next

 * online cpu on the phba's original_mask and migrate all offlining IRQ

 * affinities.

 *

 * If cpu is coming online, reaffinitize the IRQ back to the onlining cpu.

 *

 * Note: Call only if NUMA or NHT mode is enabled, otherwise rely on

 *	 PCI_IRQ_AFFINITY to auto-manage IRQ affinity.

 *

 Find next online CPU on original mask */

 Found a valid CPU */

			/* Go through each eqhdl and ensure offlining

			 * cpu aff_mask is migrated

 Migrate affinity */

 Rely on irqbalance if no online CPUs left on NUMA */

 Migrate affinity back to this CPU */

 start polling on these eq's */

/**

 * lpfc_sli4_enable_msix - Enable MSI-X interrupt mode to SLI-4 device

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to enable the MSI-X interrupt vectors to device

 * with SLI-4 interface spec.  It also allocates MSI-X vectors and maps them

 * to cpus on the system.

 *

 * When cfg_irq_numa is enabled, the adapter will only allocate vectors for

 * the number of cpus on the same numa node as this adapter.  The vectors are

 * allocated without requesting OS affinity mapping.  A vector will be

 * allocated and assigned to each online and offline cpu.  If the cpu is

 * online, then affinity will be set to that cpu.  If the cpu is offline, then

 * affinity will be set to the nearest peer cpu within the numa node that is

 * online.  If there are no online cpus within the numa node, affinity is not

 * assigned and the OS may do as it pleases. Note: cpu vector affinity mapping

 * is consistent with the way cpu online/offline is handled when cfg_irq_numa is

 * configured.

 *

 * If numa mode is not enabled and there is more than 1 vector allocated, then

 * the driver relies on the managed irq interface where the OS assigns vector to

 * cpu affinity.  The driver will then use that affinity mapping to setup its

 * cpu mapping table.

 *

 * Return codes

 * 0 - successful

 * other values - error

 Set up MSI-X multi-message vectors */

		/* cpu: iterates over aff_mask including offline or online

		 * cpu_select: iterates over online aff_mask to set affinity

 Assign MSI-X vectors to interrupt handlers */

 If found a neighboring online cpu, set affinity */

 Assign EQ to cpu_map */

 Iterate to next offline or online cpu in aff_mask */

 Find next online cpu in aff_mask to set affinity */

 Loop through all CPUs associated with vector index */

				/* If this is the first CPU thats assigned to

				 * this vector, set LPFC_CPU_FIRST_IRQ.

				 *

				 * With certain platforms its possible that irq

				 * vectors are affinitized to all the cpu's.

				 * This can result in each cpu_map.eq to be set

				 * to the last vector, resulting in overwrite

				 * of all the previous cpu_map.eq.  Ensure that

				 * each vector receives a place in cpu_map.

				 * Later call to lpfc_cpu_affinity_check will

				 * ensure we are nicely balanced out.

 free the irq already requested */

 Unconfigure MSI-X capability structure */

/**

 * lpfc_sli4_enable_msi - Enable MSI interrupt mode to SLI-4 device

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to enable the MSI interrupt mode to device with

 * SLI-4 interface spec. The kernel function pci_alloc_irq_vectors() is

 * called to enable the MSI vector. The device driver is responsible for

 * calling the request_irq() to register MSI vector with a interrupt the

 * handler, which is done in this function.

 *

 * Return codes

 * 	0 - successful

 * 	other values - error

/**

 * lpfc_sli4_enable_intr - Enable device interrupt to SLI-4 device

 * @phba: pointer to lpfc hba data structure.

 * @cfg_mode: Interrupt configuration mode (INTx, MSI or MSI-X).

 *

 * This routine is invoked to enable device interrupt and associate driver's

 * interrupt handler(s) to interrupt vector(s) to device with SLI-4

 * interface spec. Depends on the interrupt mode configured to the driver,

 * the driver will try to fallback from the configured interrupt mode to an

 * interrupt mode which is supported by the platform, kernel, and device in

 * the order of:

 * MSI-X -> MSI -> IRQ.

 *

 * Return codes

 * 	0 - successful

 * 	other values - error

 Preparation before conf_msi mbox cmd */

 Now, try to enable MSI-X interrupt mode */

 Indicate initialization to MSI-X mode */

 Fallback to MSI if MSI-X initialization failed */

 Indicate initialization to MSI mode */

 Fallback to INTx if both MSI-X/MSI initalization failed */

 Indicate initialization to INTx mode */

/**

 * lpfc_sli4_disable_intr - Disable device interrupt to SLI-4 device

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to disable device interrupt and disassociate

 * the driver's interrupt handler(s) from interrupt vector(s) to device

 * with SLI-4 interface spec. Depending on the interrupt mode, the driver

 * will release the interrupt vector(s) for the message signaled interrupt.

 Disable the currently initialized interrupt mode */

 Free up MSI-X multi-message vectors */

 Reset interrupt management states */

/**

 * lpfc_unset_hba - Unset SLI3 hba device initialization

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to unset the HBA device initialization steps to

 * a device with SLI-3 interface spec.

/**

 * lpfc_sli4_xri_exchange_busy_wait - Wait for device XRI exchange busy

 * @phba: Pointer to HBA context object.

 *

 * This function is called in the SLI4 code path to wait for completion

 * of device's XRIs exchange busy. It will check the XRI exchange busy

 * on outstanding FCP and ELS I/Os every 10ms for up to 10 seconds; after

 * that, it will check the XRI exchange busy on outstanding FCP and ELS

 * I/Os every 30 seconds, log error message, and wait forever. Only when

 * all XRI exchange busy complete, the driver unload shall proceed with

 * invoking the function reset ioctl mailbox command to the CNA and the

 * the rest of the driver unload resource release.

	/* Driver just aborted IOs during the hba_unset process.  Pause

	 * here to give the HBA time to complete the IO and get entries

	 * into the abts lists.

 Wait for NVME pending IO to flush back to transport. */

 if list is NOT empty */

 if list is NOT empty */

/**

 * lpfc_sli4_hba_unset - Unset the fcoe hba

 * @phba: Pointer to HBA context object.

 *

 * This function is called in the SLI4 code path to reset the HBA's FCoE

 * function. The caller is not required to hold any lock. This routine

 * issues PCI function reset mailbox command to reset the FCoE function.

 * At the end of the function, it calls lpfc_hba_down_post function to

 * free any pending commands.

	/*

	 * Gracefully wait out the potential current outstanding asynchronous

	 * mailbox command.

 First, block any pending async mailbox command from posted */

 Now, trying to wait it out if we can */

 Forcefully release the outstanding mailbox command if timed out */

 Abort all iocbs associated with the hba */

 Wait for completion of device XRI exchange busy */

 per-phba callback de-registration for hotplug event */

 Disable PCI subsystem interrupt */

 Disable SR-IOV if enabled */

 Stop kthread signal shall trigger work_done one more time */

 Disable FW logging to host memory */

	/* Unset the queues shared with the hardware then release all

	 * allocated resources.

 Reset SLI4 HBA FCoE function */

 Free RAS DMA memory */

 Stop the SLI4 device port */

/*

 * The routine corresponds with the algorithm the HBA firmware

 * uses to validate the data integrity.

 cgn parameters */

 relative to 2000 */

 Fill in default LUN qdepth */

 last used Index initialized to 0xff already */

 relative to 2000 */

/**

 * __lpfc_reg_congestion_buf - register congestion info buffer with HBA

 * @phba: Pointer to hba context object.

 * @reg: flag to determine register or unregister.

/**

 * lpfc_get_sli4_parameters - Get the SLI4 Config PARAMETERS.

 * @phba: Pointer to HBA context object.

 * @mboxq: Pointer to the mailboxq memory for the mailbox command response.

 *

 * This function is called in the SLI4 code path to read the port's

 * sli4 capabilities.

 *

 * This function may be be called from any context that can block-wait

 * for the completion.  The expectation is that this routine is called

 * typically from probe_one or from the online routine.

	/*

	 * By default, the driver assumes the SLI4 port requires RPI

	 * header postings.  The SLI4_PARAM response will correct this

	 * assumption.

 Read the port's SLI4 Config Parameters */

 Check for Extended Pre-Registered SGL support */

 Check for firmware nvme support */

 Save this to indicate the Firmware supports NVME */

 Firmware NVME support, check driver FC4 NVME support */

 No firmware NVME support, check driver FC4 NVME support */

 If no FC4 type support, move to just SCSI support */

	/* If the NVME FC4 type is enabled, scale the sg_seg_cnt to

	 * accommodate 512K and 1M IOs in a single nvme buf.

 Enable embedded Payload BDE if support is indicated */

	/*

	 * To support Suppress Response feature we must satisfy 3 conditions.

	 * lpfc_suppress_rsp module parameter must be set (default).

	 * In SLI4-Parameters Descriptor:

	 * Extended Inline Buffers (XIB) must be supported.

	 * Suppress Response IU Not Supported (SRIUNS) must NOT be supported

	 * (double negative).

 Make sure that sge_supp_len can be handled by the driver */

	/*

	 * Check whether the adapter supports an embedded copy of the

	 * FCP CMD IU within the WQE for FCP_Ixxx commands. In order

	 * to use this option, 128-byte WQEs must be used.

	/*

	 * Check if the SLI port supports MDS Diagnostics

	/*

	 * Check if the SLI port supports NSLER

/**

 * lpfc_pci_probe_one_s3 - PCI probe func to reg SLI-3 device to PCI subsystem.

 * @pdev: pointer to PCI device

 * @pid: pointer to PCI device identifier

 *

 * This routine is to be called to attach a device with SLI-3 interface spec

 * to the PCI subsystem. When an Emulex HBA with SLI-3 interface spec is

 * presented on PCI bus, the kernel PCI subsystem looks at PCI device-specific

 * information of the device and driver to see if the driver state that it can

 * support this kind of device. If the match is successful, the driver core

 * invokes this routine. If this routine determines it can claim the HBA, it

 * does all the initialization that it needs to do to handle the HBA properly.

 *

 * Return code

 * 	0 - driver can claim the device

 * 	negative value - driver can not claim the device

 Allocate memory for HBA structure */

 Perform generic PCI device enabling operation */

 Set up SLI API function jump table for PCI-device group-0 HBAs */

 Set up SLI-3 specific device PCI memory space */

 Set up SLI-3 specific device driver resources */

 Initialize and populate the iocb list per host */

 Set up common device driver resources */

 Get the default values for Model Name and Description */

 Create SCSI host to the physical port */

 Configure sysfs attributes */

 save shost for error cleanup */

 Now, trying to enable interrupt and bring up the device */

 Put device to a known state before enabling interrupt */

 Configure and enable interrupt */

 SLI-3 HBA setup */

 Wait 50ms for the interrupts of previous mailbox commands */

 Check active interrupts on message signaled interrupts */

 Log the current active interrupt mode */

 Disable the current interrupt mode */

 Try next level of interrupt mode */

 Perform post initialization setup */

 Check if there are static vports to be created. */

/**

 * lpfc_pci_remove_one_s3 - PCI func to unreg SLI-3 device from PCI subsystem.

 * @pdev: pointer to PCI device

 *

 * This routine is to be called to disattach a device with SLI-3 interface

 * spec from PCI subsystem. When an Emulex HBA with SLI-3 interface spec is

 * removed from PCI bus, it performs all the necessary cleanup for the HBA

 * device to be removed from the PCI subsystem properly.

 Release all the vports against this physical port */

 Remove FC host with the physical port */

 Clean up all nodes, mailboxes and IOs. */

	/*

	 * Bring down the SLI Layer. This step disable all interrupts,

	 * clears the rings, discards all mailbox commands, and resets

	 * the HBA.

 HBA interrupt will be disabled after this call */

 Stop kthread signal shall trigger work_done one more time */

 Final cleanup of txcmplq and reset the HBA */

 Disable SR-IOV if enabled */

 Disable interrupt */

	/*

	 * Call scsi_free before mem_free since scsi bufs are released to their

	 * corresponding pools here.

 Free resources associated with SLI2 interface */

 unmap adapter SLIM and Control Registers */

/**

 * lpfc_pci_suspend_one_s3 - PCI func to suspend SLI-3 device for power mgmnt

 * @dev_d: pointer to device

 *

 * This routine is to be called from the kernel's PCI subsystem to support

 * system Power Management (PM) to device with SLI-3 interface spec. When

 * PM invokes this method, it quiesces the device by stopping the driver's

 * worker thread for the device, turning off device's interrupt and DMA,

 * and bring the device offline. Note that as the driver implements the

 * minimum PM requirements to a power-aware driver's PM support for the

 * suspend/resume -- all the possible PM messages (SUSPEND, HIBERNATE, FREEZE)

 * to the suspend() method call will be treated as SUSPEND and the driver will

 * fully reinitialize its device during resume() method call, the driver will

 * set device to PCI_D3hot state in PCI config space instead of setting it

 * according to the @msg provided by the PM.

 *

 * Return code

 * 	0 - driver suspended the device

 * 	Error otherwise

 Bring down the device */

 Disable interrupt from device */

/**

 * lpfc_pci_resume_one_s3 - PCI func to resume SLI-3 device for power mgmnt

 * @dev_d: pointer to device

 *

 * This routine is to be called from the kernel's PCI subsystem to support

 * system Power Management (PM) to device with SLI-3 interface spec. When PM

 * invokes this method, it restores the device's PCI config space state and

 * fully reinitializes the device and brings it online. Note that as the

 * driver implements the minimum PM requirements to a power-aware driver's

 * PM for suspend/resume -- all the possible PM messages (SUSPEND, HIBERNATE,

 * FREEZE) to the suspend() method call will be treated as SUSPEND and the

 * driver will fully reinitialize its device during resume() method call,

 * the device will be set to PCI_D0 directly in PCI config space before

 * restoring the state.

 *

 * Return code

 * 	0 - driver suspended the device

 * 	Error otherwise

 Startup the kernel thread for this host adapter. */

 Init cpu_map array */

 Init hba_eq_hdl array */

 Configure and enable interrupt */

 Restart HBA and bring it online */

 Log the current active interrupt mode */

/**

 * lpfc_sli_prep_dev_for_recover - Prepare SLI3 device for pci slot recover

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is called to prepare the SLI3 device for PCI slot recover. It

 * aborts all the outstanding SCSI I/Os to the pci device.

	/*

	 * There may be errored I/Os through HBA, abort all I/Os on txcmplq

	 * and let the SCSI mid-layer to retry them to recover.

/**

 * lpfc_sli_prep_dev_for_reset - Prepare SLI3 device for pci slot reset

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is called to prepare the SLI3 device for PCI slot reset. It

 * disables the device interrupt and pci device, and aborts the internal FCP

 * pending I/Os.

 Block any management I/Os to the device */

 Block all SCSI devices' I/Os on the host */

 Flush all driver's outstanding SCSI I/Os as we are to reset */

 stop all timers */

 Disable interrupt and pci device */

/**

 * lpfc_sli_prep_dev_for_perm_failure - Prepare SLI3 dev for pci slot disable

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is called to prepare the SLI3 device for PCI slot permanently

 * disabling. It blocks the SCSI transport layer traffic and flushes the FCP

 * pending I/Os.

 Block all SCSI devices' I/Os on the host */

 stop all timers */

 Clean up all driver's outstanding SCSI I/Os */

/**

 * lpfc_io_error_detected_s3 - Method for handling SLI-3 device PCI I/O error

 * @pdev: pointer to PCI device.

 * @state: the current PCI connection state.

 *

 * This routine is called from the PCI subsystem for I/O error handling to

 * device with SLI-3 interface spec. This function is called by the PCI

 * subsystem after a PCI bus error affecting this device has been detected.

 * When this function is invoked, it will need to stop all the I/Os and

 * interrupt(s) to the device. Once that is done, it will return

 * PCI_ERS_RESULT_NEED_RESET for the PCI subsystem to perform proper recovery

 * as desired.

 *

 * Return codes

 * 	PCI_ERS_RESULT_CAN_RECOVER - can be recovered with reset_link

 * 	PCI_ERS_RESULT_NEED_RESET - need to reset before recovery

 * 	PCI_ERS_RESULT_DISCONNECT - device could not be recovered

 Non-fatal error, prepare for recovery */

 Fatal error, prepare for slot reset */

 Permanent failure, prepare for device down */

 Unknown state, prepare and request slot reset */

/**

 * lpfc_io_slot_reset_s3 - Method for restarting PCI SLI-3 device from scratch.

 * @pdev: pointer to PCI device.

 *

 * This routine is called from the PCI subsystem for error handling to

 * device with SLI-3 interface spec. This is called after PCI bus has been

 * reset to restart the PCI card from scratch, as if from a cold-boot.

 * During the PCI subsystem error recovery, after driver returns

 * PCI_ERS_RESULT_NEED_RESET, the PCI subsystem will perform proper error

 * recovery and then call this routine before calling the .resume method

 * to recover the device. This function will initialize the HBA device,

 * enable the interrupt, but it will just put the HBA to offline state

 * without passing any I/O traffic.

 *

 * Return codes

 * 	PCI_ERS_RESULT_RECOVERED - the device has been recovered

 * 	PCI_ERS_RESULT_DISCONNECT - device could not be recovered

	/*

	 * As the new kernel behavior of pci_restore_state() API call clears

	 * device saved_state flag, need to save the restored state again.

 Configure and enable interrupt */

 Take device offline, it will perform cleanup */

 Log the current active interrupt mode */

/**

 * lpfc_io_resume_s3 - Method for resuming PCI I/O operation on SLI-3 device.

 * @pdev: pointer to PCI device

 *

 * This routine is called from the PCI subsystem for error handling to device

 * with SLI-3 interface spec. It is called when kernel error recovery tells

 * the lpfc driver that it is ok to resume normal PCI operation after PCI bus

 * error recovery. After this call, traffic can start to flow from this device

 * again.

 Bring device online, it will be no-op for non-fatal error resume */

/**

 * lpfc_sli4_get_els_iocb_cnt - Calculate the # of ELS IOCBs to reserve

 * @phba: pointer to lpfc hba data structure.

 *

 * returns the number of ELS/CT IOCBs to reserve

/**

 * lpfc_sli4_get_iocb_cnt - Calculate the # of total IOCBs to reserve

 * @phba: pointer to lpfc hba data structure.

 *

 * returns the number of ELS/CT + NVMET IOCBs to reserve

	/* Three cases:  (1) FW was not supported on the detected adapter.

	 * (2) FW update has been locked out administratively.

	 * (3) Some other error during FW update.

	 * In each case, an unmaskable message is written to the console

	 * for admin diagnosis.

/**

 * lpfc_write_firmware - attempt to write a firmware image to the port

 * @fw: pointer to firmware image returned from request_firmware.

 * @context: pointer to firmware image returned from request_firmware.

 *

 It can be null in no-wait mode, sanity check */

/**

 * lpfc_sli4_request_firmware_update - Request linux generic firmware upgrade

 * @phba: pointer to lpfc hba data structure.

 * @fw_upgrade: which firmware to update.

 *

 * This routine is called to perform Linux generic firmware upgrade on device

 * that supports such feature.

 Only supported on SLI4 interface type 2 for now */

/**

 * lpfc_pci_probe_one_s4 - PCI probe func to reg SLI-4 device to PCI subsys

 * @pdev: pointer to PCI device

 * @pid: pointer to PCI device identifier

 *

 * This routine is called from the kernel's PCI subsystem to device with

 * SLI-4 interface spec. When an Emulex HBA with SLI-4 interface spec is

 * presented on PCI bus, the kernel PCI subsystem looks at PCI device-specific

 * information of the device and driver to see if the driver state that it

 * can support this kind of device. If the match is successful, the driver

 * core invokes this routine. If this routine determines it can claim the HBA,

 * it does all the initialization that it needs to do to handle the HBA

 * properly.

 *

 * Return code

 * 	0 - driver can claim the device

 * 	negative value - driver can not claim the device

 Allocate memory for HBA structure */

 Perform generic PCI device enabling operation */

 Set up SLI API function jump table for PCI-device group-1 HBAs */

 Set up SLI-4 specific device PCI memory space */

 Set up SLI-4 Specific device driver resources */

 Set up common device driver resources */

 Get the default values for Model Name and Description */

 Now, trying to enable interrupt and bring up the device */

 Put device to a known state before enabling interrupt */

 Init cpu_map array */

 Init hba_eq_hdl array */

 Configure and enable interrupt */

 Default to single EQ for non-MSI-X */

 Create SCSI host to the physical port */

 save shost for error cleanup */

 Configure sysfs attributes */

 Set up SLI-4 HBA */

 Log the current active interrupt mode */

 Perform post initialization setup */

	/* NVME support in FW earlier in the driver load corrects the

	 * FC4 type making a check for nvme_support unnecessary.

			/* Create NVME binding with nvme_fc_transport. This

			 * ensures the vport is initialized.  If the localport

			 * create fails, it should not unload the driver to

			 * support field issues.

 check for firmware upgrade or downgrade */

 Check if there are static vports to be created. */

 Enable RAS FW log support */

/**

 * lpfc_pci_remove_one_s4 - PCI func to unreg SLI-4 device from PCI subsystem

 * @pdev: pointer to PCI device

 *

 * This routine is called from the kernel's PCI subsystem to device with

 * SLI-4 interface spec. When an Emulex HBA with SLI-4 interface spec is

 * removed from PCI bus, it performs all the necessary cleanup for the HBA

 * device to be removed from the PCI subsystem properly.

 Mark the device unloading flag */

 Release all the vports against this physical port */

 Remove FC host with the physical port */

	/* Perform ndlp cleanup on the physical port.  The nvme and nvmet

	 * localports are destroyed after to cleanup all transport memory.

 De-allocate multi-XRI pools */

	/*

	 * Bring down the SLI Layer. This step disables all interrupts,

	 * clears the rings, discards all mailbox commands, and resets

	 * the HBA FCoE function.

	/* Perform scsi free before driver resource_unset since scsi

	 * buffers are released to their corresponding pools here.

 Unmap adapter Control and Doorbell registers */

 Release PCI resources and disable device's PCI function */

 Finally, free the driver's device data structure */

/**

 * lpfc_pci_suspend_one_s4 - PCI func to suspend SLI-4 device for power mgmnt

 * @dev_d: pointer to device

 *

 * This routine is called from the kernel's PCI subsystem to support system

 * Power Management (PM) to device with SLI-4 interface spec. When PM invokes

 * this method, it quiesces the device by stopping the driver's worker

 * thread for the device, turning off device's interrupt and DMA, and bring

 * the device offline. Note that as the driver implements the minimum PM

 * requirements to a power-aware driver's PM support for suspend/resume -- all

 * the possible PM messages (SUSPEND, HIBERNATE, FREEZE) to the suspend()

 * method call will be treated as SUSPEND and the driver will fully

 * reinitialize its device during resume() method call, the driver will set

 * device to PCI_D3hot state in PCI config space instead of setting it

 * according to the @msg provided by the PM.

 *

 * Return code

 * 	0 - driver suspended the device

 * 	Error otherwise

 Bring down the device */

 Disable interrupt from device */

/**

 * lpfc_pci_resume_one_s4 - PCI func to resume SLI-4 device for power mgmnt

 * @dev_d: pointer to device

 *

 * This routine is called from the kernel's PCI subsystem to support system

 * Power Management (PM) to device with SLI-4 interface spac. When PM invokes

 * this method, it restores the device's PCI config space state and fully

 * reinitializes the device and brings it online. Note that as the driver

 * implements the minimum PM requirements to a power-aware driver's PM for

 * suspend/resume -- all the possible PM messages (SUSPEND, HIBERNATE, FREEZE)

 * to the suspend() method call will be treated as SUSPEND and the driver

 * will fully reinitialize its device during resume() method call, the device

 * will be set to PCI_D0 directly in PCI config space before restoring the

 * state.

 *

 * Return code

 * 	0 - driver suspended the device

 * 	Error otherwise

 Startup the kernel thread for this host adapter. */

 Configure and enable interrupt */

 Restart HBA and bring it online */

 Log the current active interrupt mode */

/**

 * lpfc_sli4_prep_dev_for_recover - Prepare SLI4 device for pci slot recover

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is called to prepare the SLI4 device for PCI slot recover. It

 * aborts all the outstanding SCSI I/Os to the pci device.

	/*

	 * There may be errored I/Os through HBA, abort all I/Os on txcmplq

	 * and let the SCSI mid-layer to retry them to recover.

/**

 * lpfc_sli4_prep_dev_for_reset - Prepare SLI4 device for pci slot reset

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is called to prepare the SLI4 device for PCI slot reset. It

 * disables the device interrupt and pci device, and aborts the internal FCP

 * pending I/Os.

 Block any management I/Os to the device */

 Block all SCSI devices' I/Os on the host */

 Flush all driver's outstanding I/Os as we are to reset */

 stop all timers */

 Disable interrupt and pci device */

/**

 * lpfc_sli4_prep_dev_for_perm_failure - Prepare SLI4 dev for pci slot disable

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is called to prepare the SLI4 device for PCI slot permanently

 * disabling. It blocks the SCSI transport layer traffic and flushes the FCP

 * pending I/Os.

 Block all SCSI devices' I/Os on the host */

 stop all timers */

 Clean up all driver's outstanding I/Os */

/**

 * lpfc_io_error_detected_s4 - Method for handling PCI I/O error to SLI-4 device

 * @pdev: pointer to PCI device.

 * @state: the current PCI connection state.

 *

 * This routine is called from the PCI subsystem for error handling to device

 * with SLI-4 interface spec. This function is called by the PCI subsystem

 * after a PCI bus error affecting this device has been detected. When this

 * function is invoked, it will need to stop all the I/Os and interrupt(s)

 * to the device. Once that is done, it will return PCI_ERS_RESULT_NEED_RESET

 * for the PCI subsystem to perform proper recovery as desired.

 *

 * Return codes

 * 	PCI_ERS_RESULT_NEED_RESET - need to reset before recovery

 * 	PCI_ERS_RESULT_DISCONNECT - device could not be recovered

 Non-fatal error, prepare for recovery */

 Fatal error, prepare for slot reset */

 Permanent failure, prepare for device down */

 Unknown state, prepare and request slot reset */

/**

 * lpfc_io_slot_reset_s4 - Method for restart PCI SLI-4 device from scratch

 * @pdev: pointer to PCI device.

 *

 * This routine is called from the PCI subsystem for error handling to device

 * with SLI-4 interface spec. It is called after PCI bus has been reset to

 * restart the PCI card from scratch, as if from a cold-boot. During the

 * PCI subsystem error recovery, after the driver returns

 * PCI_ERS_RESULT_NEED_RESET, the PCI subsystem will perform proper error

 * recovery and then call this routine before calling the .resume method to

 * recover the device. This function will initialize the HBA device, enable

 * the interrupt, but it will just put the HBA to offline state without

 * passing any I/O traffic.

 *

 * Return codes

 * 	PCI_ERS_RESULT_RECOVERED - the device has been recovered

 * 	PCI_ERS_RESULT_DISCONNECT - device could not be recovered

	/*

	 * As the new kernel behavior of pci_restore_state() API call clears

	 * device saved_state flag, need to save the restored state again.

 Configure and enable interrupt */

 Log the current active interrupt mode */

/**

 * lpfc_io_resume_s4 - Method for resuming PCI I/O operation to SLI-4 device

 * @pdev: pointer to PCI device

 *

 * This routine is called from the PCI subsystem for error handling to device

 * with SLI-4 interface spec. It is called when kernel error recovery tells

 * the lpfc driver that it is ok to resume normal PCI operation after PCI bus

 * error recovery. After this call, traffic can start to flow from this device

 * again.

	/*

	 * In case of slot reset, as function reset is performed through

	 * mailbox command which needs DMA to be enabled, this operation

	 * has to be moved to the io resume phase. Taking device offline

	 * will perform the necessary cleanup.

 Perform device reset */

 Bring the device back online */

/**

 * lpfc_pci_probe_one - lpfc PCI probe func to reg dev to PCI subsystem

 * @pdev: pointer to PCI device

 * @pid: pointer to PCI device identifier

 *

 * This routine is to be registered to the kernel's PCI subsystem. When an

 * Emulex HBA device is presented on PCI bus, the kernel PCI subsystem looks

 * at PCI device-specific information of the device and driver to see if the

 * driver state that it can support this kind of device. If the match is

 * successful, the driver core invokes this routine. This routine dispatches

 * the action to the proper SLI-3 or SLI-4 device probing routine, which will

 * do all the initialization that it needs to do to handle the HBA device

 * properly.

 *

 * Return code

 * 	0 - driver can claim the device

 * 	negative value - driver can not claim the device

/**

 * lpfc_pci_remove_one - lpfc PCI func to unreg dev from PCI subsystem

 * @pdev: pointer to PCI device

 *

 * This routine is to be registered to the kernel's PCI subsystem. When an

 * Emulex HBA is removed from PCI bus, the driver core invokes this routine.

 * This routine dispatches the action to the proper SLI-3 or SLI-4 device

 * remove routine, which will perform all the necessary cleanup for the

 * device to be removed from the PCI subsystem properly.

/**

 * lpfc_pci_suspend_one - lpfc PCI func to suspend dev for power management

 * @dev: pointer to device

 *

 * This routine is to be registered to the kernel's PCI subsystem to support

 * system Power Management (PM). When PM invokes this method, it dispatches

 * the action to the proper SLI-3 or SLI-4 device suspend routine, which will

 * suspend the device.

 *

 * Return code

 * 	0 - driver suspended the device

 * 	Error otherwise

/**

 * lpfc_pci_resume_one - lpfc PCI func to resume dev for power management

 * @dev: pointer to device

 *

 * This routine is to be registered to the kernel's PCI subsystem to support

 * system Power Management (PM). When PM invokes this method, it dispatches

 * the action to the proper SLI-3 or SLI-4 device resume routine, which will

 * resume the device.

 *

 * Return code

 * 	0 - driver suspended the device

 * 	Error otherwise

/**

 * lpfc_io_error_detected - lpfc method for handling PCI I/O error

 * @pdev: pointer to PCI device.

 * @state: the current PCI connection state.

 *

 * This routine is registered to the PCI subsystem for error handling. This

 * function is called by the PCI subsystem after a PCI bus error affecting

 * this device has been detected. When this routine is invoked, it dispatches

 * the action to the proper SLI-3 or SLI-4 device error detected handling

 * routine, which will perform the proper error detected operation.

 *

 * Return codes

 * 	PCI_ERS_RESULT_NEED_RESET - need to reset before recovery

 * 	PCI_ERS_RESULT_DISCONNECT - device could not be recovered

/**

 * lpfc_io_slot_reset - lpfc method for restart PCI dev from scratch

 * @pdev: pointer to PCI device.

 *

 * This routine is registered to the PCI subsystem for error handling. This

 * function is called after PCI bus has been reset to restart the PCI card

 * from scratch, as if from a cold-boot. When this routine is invoked, it

 * dispatches the action to the proper SLI-3 or SLI-4 device reset handling

 * routine, which will perform the proper device reset.

 *

 * Return codes

 * 	PCI_ERS_RESULT_RECOVERED - the device has been recovered

 * 	PCI_ERS_RESULT_DISCONNECT - device could not be recovered

/**

 * lpfc_io_resume - lpfc method for resuming PCI I/O operation

 * @pdev: pointer to PCI device

 *

 * This routine is registered to the PCI subsystem for error handling. It

 * is called when kernel error recovery tells the lpfc driver that it is

 * OK to resume normal PCI operation after PCI bus error recovery. When

 * this routine is invoked, it dispatches the action to the proper SLI-3

 * or SLI-4 device io_resume routine, which will resume the device operation.

/**

 * lpfc_sli4_oas_verify - Verify OAS is supported by this adapter

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine checks to see if OAS is supported for this adapter. If

 * supported, the configure Flash Optimized Fabric flag is set.  Otherwise,

 * the enable oas flag is cleared and the pool created for OAS device data

 * is destroyed.

 *

/**

 * lpfc_sli4_ras_init - Verify RAS-FW log is supported by this adapter

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine checks to see if RAS is supported by the adapter. Check the

 * function through which RAS support enablement is to be done.

 if ASIC_GEN_NUM >= 0xC) */

/**

 * lpfc_init - lpfc module initialization routine

 *

 * This routine is to be invoked when the lpfc module is loaded into the

 * kernel. The special kernel macro module_init() is used to indicate the

 * role of this routine to the kernel as lpfc module entry point.

 *

 * Return codes

 *   0 - successful

 *   -ENOMEM - FC attach transport failed

 *   all others - failed

 Initialize in case vector mapping is needed */

	/* Don't dump messages if we explicitly set log_verbose for the

	 * physical port or any vport.

/**

 * lpfc_exit - lpfc module removal routine

 *

 * This routine is invoked when the lpfc module is removed from the kernel.

 * The special kernel macro module_exit() is used to indicate the role of

 * this routine to the kernel as lpfc module exit point.

