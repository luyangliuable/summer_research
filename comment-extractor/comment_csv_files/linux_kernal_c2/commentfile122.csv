 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2019 Intel Corporation. All rights reserved.
 Authors: Guennadi Liakhovetski <guennadi.liakhovetski@linux.intel.com>
 Generic SOF IPC code 
 Mailbox-based Generic IPC implementation 
 The stream might already be closed 
 check if offset is overflow or it is not aligned 
 binding pcm substream to hda stream 
 align to DMA minimum transfer size 
 avoid circular buffer wrap in middle of period 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
 Mixer Controls 
 set the ABI header values 
 refresh the component data from DSP 
 Set the flag to re-try next time to get the data 
 read back each channel 
 update each channel 
 notify DSP of mixer updates 
 read back each channel 
 update each channel 
 notify DSP of mixer updates 
 read back each channel 
 update each channel 
 notify DSP of enum updates 
 be->max has been verified to be >= sizeof(struct sof_abi_hdr) 
 copy back to kcontrol 
 be->max has been verified to be >= sizeof(struct sof_abi_hdr) 
 copy from kcontrol 
 notify DSP of byte control updates 
 make sure we have at least a header 
	
	  The beginning of bytes data contains a header from where
	  the length (as bytes) is needed to know the correct copy
	  length of data from tlvd->tlv.
 make sure TLV info is consistent 
 be->max is coming from topology 
 Check that header id matches the command 
 be->max has been verified to be >= sizeof(struct sof_abi_hdr) 
 notify DSP of byte control updates 
	
	  Decrement the limit by ext bytes header size to
	  ensure the user space buffer is not exceeded.
 set the ABI header values 
 get all the component data from DSP 
 check data size doesn't exceed max coming from topology 
 make sure we don't exceed size provided by user space for data 
	
	  Decrement the limit by ext bytes header size to
	  ensure the user space buffer is not exceeded.
 set the ABI header values 
 check data size doesn't exceed max coming from topology 
 make sure we don't exceed size provided by user space for data 
 copy the new binary data 
 copy the new values 
 Find the swidget first 
 Translate SOF cmd to TPLG type 
 skip non matching types or non matching indexes within type 
		
		  The message includes the updated valuedata, update the
		  control's local cache using the received notification
 Mark the scontrol that the valuedata is changed in SOF 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
 platform specific devices 
 allow runtime_pm 
 alternate fw and tplg filenames ? 
 set callback to be called on successful device probe to enable runtime_pm 
 call sof helper for DSP hardware probe 
 call sof helper for DSP hardware remove 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
 ignore empty content 
 update counter only when parsing whole entry passed 
	
	  Each entry contains at least 1, up to TRACE_FILTER_ELEMENTS_PER_ENTRY
	  IPC elements, depending on content. Calculate IPC elements capacity
	  for the input string where each element is set.
 split input string by ';', and parse each entry separately in trace_filter_parse_entry 
 assert null termination 
 add to dfsentry list 
	
	  If host offset is less than local pos, it means write pointer of
	  host DMA buffer has been wrapped. We should output the trace data
	  at the end of host DMA buffer at first.
 If there is available trace data now, it is unnecessary to wait. 
 data immediately available 
		
		  tracing has ended and all traces have been
		  read by client, return EOF
 wait for available trace data from FW 
 set timeout to max value, no error code 
 make sure we know about any failures on the DSP side 
 check pos and count 
 check for buffer wrap and count overflow 
 min() not used to avoid sparse warnings 
 get available count based on current host offset 
 make sure count is <= avail 
 copy available trace data to debugfs 
 move debugfs reading position 
 avoid duplicate traces at next open 
 set IPC parameters 
 PARAMS_EXT is only supported from ABI 3.7.0 onwards 
 in nanosecond 
 send IPC to the DSP 
 set false before start initialization 
 allocate trace page table buffer 
 allocate trace data buffer 
 create compressed page table for audio firmware 
 an error has occurred within the DSP that prevents further trace 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Author: Pan Xiuli <xiuli.pan@linux.intel.com>
  From 4.4.1.5 table 4-64 Exception Causes of Xtensa
  Instruction Set Architecture (ISA) Reference Manual
 only need xtensa atm 
 4  8chars + 3 ws + 1 terminating NUL 
	
	  example output:
	  0x0049fbb0: 8000f2d0 0049fc00 6f6c6c61 00632e63
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 Copyright(c) 2020 Intel Corporation. All rights reserved.
 Authors: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
  Hardware interface for audio DSP on Tigerlake.
 Tigerlake ops 
 proberemoveshutdown 
 Register IO 
 Block IO 
 Mailbox IO 
 doorbell 
 ipc 
 machine driver 
 debug 
 stream callbacks 
 probe callbacks 
 firmware loading 
 prepost fw run 
 parse platform specific extended manifest 
 dsp core power updown 
 firmware run 
 trace callback 
 DAI drivers 
 PM 
 ALSA HW info flags 
 Tigerlake , Alderlake 
 Tigerlake-H 
 Elkhartlake 
 Alderlake-S 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Authors: Liam Girdwood <liam.r.girdwood@linux.intel.com>
	    Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	    Rander Wang <rander.wang@intel.com>
          Keyon Jie <yang.jie@linux.intel.com>
  Hardware interface for generic Intel audio DSP HDA IP
 use 48KHz if not found 
 use 16bits format if not found 
 disable SPIB, to enable buffer wrap for stream 
 update no_stream_position flag for ipc params 
		 For older ABIs set host_period_bytes to zero to inform
		  FW we don't want position updates. Newer versions use
		  no_stream_position for this purpose.
 read position from IPC position 
	
	  DPIBposbuf position mode:
	  For Playback, Use DPIB register from HDA space which
	  reflects the actual data transferred.
	  For Capture, Use the position buffer for pointer, as DPIB
	  is not accurate enough, its update may be completed
	  earlier than the data written to DDR.
		
		  For capture stream, we need more workaround to fix the
		  position incorrect issue:
		 
		  1. Wait at least 20us before reading position buffer after
		  the interrupt generated(IOC), to make sure position update
		  happens on frame boundary i.e. 20.833uSec for 48KHz.
		  2. Perform a dummy Read to DPIB register to flush DMA
		  position value.
		  3. Read the DMA Position from posbuf. Now the readback
		  value should be >= period boundary.
	
	  All playback streams are DMI L1 capable, capture streams need
	  pause pushrelease to be disabled
 minimum as per HDA spec 
 avoid circular buffer wrap in middle of period 
 binding pcm substream to hda stream 
 unbinding pcm substream to hda stream 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Authors: Liam Girdwood <liam.r.girdwood@linux.intel.com>
	    Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	    Rander Wang <rander.wang@intel.com>
          Keyon Jie <yang.jie@linux.intel.com>
  Hardware interface for audio DSP on Cannonlake.
 reply message from DSP 
 mask Done interrupt 
 handle immediate reply from DSP core 
 new message from DSP 
 handle messages from DSP 
		
		  This interrupt is not shared so no need to return IRQ_NONE.
	
	  clear busy interrupt to tell dsp controller this
	  interrupt has been accepted, not trigger it again
	
	  set done bit to ack dsp the msg has been
	  processed and send reply msg to dsp
	
	  set DONE bit - tell DSP we have received the reply msg
	  from DSP, and processed it, don't send more reply to host
 unmask Done interrupt 
 send the compact message via the primary register 
 send payload via the extended data register 
	
	  Currently the only compact IPC supported is the PM_GATE
	  IPC which is used for transitioning the DSP between the
	  D0I0 and D0I3 states. And these are sent only during the
	  set_power_state() op. Therefore, there will never be a case
	  that a compact IPC results in the DSP exiting D0I3 without
	  the host and FW being in sync.
 send the message via IPC registers 
 send the message via mailbox 
	
	  Use mod_delayed_work() to schedule the delayed work
	  to avoid scheduling multiple workqueue items when
	  IPCs are sent at a high-rate. mod_delayed_work()
	  modifies the timer if the work is pending.
	  Also, a new delayed work should not be queued after the
	  CTX_SAVE IPC, which is sent before the DSP enters D3.
 read IPC status 
 dump the IPC regs 
 TODO: parse the raw msg 
 cannonlake ops 
 proberemoveshutdown 
 Register IO 
 Block IO 
 Mailbox IO 
 doorbell 
 ipc 
 machine driver 
 debug 
 stream callbacks 
 probe callbacks 
 firmware loading 
 prepost fw run 
 parse platform specific extended manifest 
 dsp core power updown 
 firmware run 
 trace callback 
 DAI drivers 
 PM 
 ALSA HW info flags 
 Cannonlake 
 Jasperlake 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
 platform specific devices 
 PCI IDs 
 CNL-LP 
 CNL-H 
 CML-LP 
 CML-H 
 CML-S 
 pci_driver definition 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Authors: Liam Girdwood <liam.r.girdwood@linux.intel.com>
	    Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	    Rander Wang <rander.wang@intel.com>
          Keyon Jie <yang.jie@linux.intel.com>
  Hardware interface for generic Intel audio DSP HDA IP
	
	  tell DSP cmd is done - clear busy
	  interrupt and send reply msg to dsp
 unmask BUSY interrupt 
	
	  set DONE bit - tell DSP we have received the reply msg
	  from DSP, and processed it, don't send more reply to host
 unmask Done interrupt 
 send IPC message to DSP 
	
	  Sometimes, there is unexpected reply ipc arriving. The reply
	  ipc belongs to none of the ipcs sent from driver.
	  In this case, the driver must ignore the ipc.
		
		  memory windows are powered off before sending IPC reply,
		  so we can't read the mailbox for CTX_SAVE and PM_GATE
		  replies.
 get IPC reply from DSP in the mailbox 
 reply correct size ? 
 getter payload is never known upfront 
 read the message 
 IPC handler thread 
 read IPC status 
 is this a reply message from the DSP 
 mask Done interrupt 
		
		  Make sure the interrupt thread cannot be preempted between
		  waking up the sender and re-enabling the interrupt. Also
		  protect against a theoretical race with sof_ipc_tx_message():
		  if the DSP is fast enough to receive an IPC message, reply to
		  it, and the host interrupt processing calls this function on
		  a different core from the one, where the sending is taking
		  place, the message might not yet be marked as expecting a
		  reply.
 handle immediate reply from DSP core 
 set the done bit 
 is this a new message from DSP 
 mask BUSY interrupt 
 handle messages from DSP 
 this is a PANIC message !! 
 normal message - process normally 
		
		  This interrupt is not shared so no need to return IRQ_NONE.
 Check if an IPC IRQ occurred 
 store status 
 invalid message ? 
 IPC message ? 
 The stream might already be closed 
 validate offset 
 check for unaligned offset or overflow 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018-2021 Intel Corporation. All rights reserved.
 Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
  Hardware interface for audio DSP on Atom devices
  Debug
 first read regsisters 
 note: variable AR register array is not read 
 then get panic info 
 then get the stack 
 now try generic SOF status messages 
 provide some context for firmware debug 
  IPC Doorbell IRQ handler and thread.
 reply message from DSP, Mask Done interrupt first 
 new message from DSP, Mask Busy interrupt first 
 reply message from DSP 
		
		  handle immediate reply from DSP core. If the msg is
		  found, set done bit in cmd_done which is called at the
		  end of message processing function, else set it here
		  because the done bit can't be set in cmd_done function
		  which is triggered by msg
 new message from DSP 
 Handle messages from DSP Core 
 unmask and prepare to receive Done interrupt 
 send the message 
	
	  Sometimes, there is unexpected reply ipc arriving. The reply
	  ipc belongs to none of the ipcs sent from driver.
	  In this case, the driver must ignore the ipc.
 get reply 
 reply correct size ? 
 read the message 
 clear BUSY bit and set DONE bit - accept new messages 
 unmask and prepare to receive next new message 
 clear DONE bit - tell DSP we have completed 
  DSP control.
 release stall and wait to unstall 
 return init core mask 
 put DSP into reset, set reset vector and stall 
 take DSP out of reset and keep stalled for FW loading 
 this assumes a .tplg extension 
 Atom DAIs 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Authors: Liam Girdwood <liam.r.girdwood@linux.intel.com>
	    Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	    Rander Wang <rander.wang@intel.com>
          Keyon Jie <yang.jie@linux.intel.com>
  Hardware interface for generic Intel audio DSP HDA IP
 Non audio DMA user, like dma-trace 
  set up one of BDL entries for a stream
 program BDL addr 
 program BDL size 
 one BDLE should not cross 4K boundary 
 only program IOC when the whole segment is processed 
  set up Buffer Descriptor List (BDL) for host memory transfer
  BDL describes the location of the individual buffers and is little endian.
 program the initial BDL entries 
	
	  set IOC if don't use position IPC
	  and period_wakeup needed.
 set the last small entry 
 enabledisable SPIB for the stream 
 set the SPIB value 
 get next unused stream 
 get an unused stream 
 check if the host DMA channel is reserved 
 stream found ? 
	
	  Prevent DMI Link L1 entry for streams that don't support it.
	  Workaround to address a known issue with host DMA that results
	  in xruns during pauserelease in capture scenarios.
 free a stream 
	
	  close stream matching the stream tag and check if there are any open streams
	  that are DMI L1 incompatible.
 Enable DMI L1 if permitted 
 cmd must be for audio stream 
 minimal recommended programming for ICCMAX stream 
 reset BDL address 
 program BDL address 
 program cyclic buffer length 
 program last valid index 
 decouple host and link DMA, enable DSP features 
 Follow HW recommendation to set the guardband value to 95us during FW boot 
 start DMA 
  prepare for common hdac registers settings, for both code loader
  and normal stream.
 decouple host and link DMA 
 clear stream status 
 stream reset 
 wait for hardware to report that stream is out of reset 
 reset BDL address 
 clear stream status 
 program stream tag to set up stream descriptor for DMA 
 program cyclic buffer length 
	
	  Recommended hardware programming sequence for HDAudio DMA format
	 
	  1. Put DMA into coupled mode by clearing PPCTL.PROCEN bit
	     for corresponding stream index before the time of writing
	     format to SDxFMT register.
	  2. Write SDxFMT
	  3. Set PPCTL.PROCEN bit for corresponding stream index to
	     enable decoupled mode
 couple host and link DMA, disable DSP features 
 program stream format 
 decouple host and link DMA, enable DSP features 
 program last valid index 
 program BDL address 
 enable position buffer 
 set interrupt enable bits 
 read FIFO size 
 couple host and link DMA if link DMA channel is idle 
 The function can be called at irq thread, so use spin_lock_irq 
 if Register inaccessible, ignore it.
 Inform ALSA only in case not do that with IPC 
	
	  Loop 10 times to handle missed interrupts caused by
	  unsolicited responses from the codec
 check streams 
 check and clear RIRB interrupt 
				
				  Clearing the interrupt status here ensures
				  that no interrupt gets masked after the RIRB
				  wp is read in snd_hdac_bus_update_rirb.
 get stream count from GCAP 
	
	  mem alloc for the position buffer
	  TODO: check position buffer update
 mem alloc for the CORBRIRB ringbuffers 
 create capture streams 
 do we support SPIB 
 memory alloc for stream BDL 
 create playback streams 
 we always have DSP support 
 do we support SPIB 
 mem alloc for stream BDL 
 store total stream count (playback + capture) from GCAP 
 free position buffer 
 free position buffer 
 TODO: decouple 
 free bdl buffer 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Authors: Liam Girdwood <liam.r.girdwood@linux.intel.com>
	    Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	    Rander Wang <rander.wang@intel.com>
          Keyon Jie <yang.jie@linux.intel.com>
  Hardware interface for generic Intel audio DSP HDA IP
  DSP Core control.
 set reset bits for cores 
 poll with timeout to check if operation successful 
 has core entered reset ? 
 clear reset bits for cores 
 poll with timeout to check if operation successful 
 has core left reset ? 
 stall core 
 set reset state 
 leave reset state 
 run core 
 is core now running ? 
  Power Management.
 update bits 
 poll with timeout to check if operation successful 
 did core power up ? 
 update bits 
 restrict core_mask to host managed cores mask 
 return if core_mask is not valid or cores are already enabled 
 power up 
 restrict core_mask to host managed cores mask 
 return if core_mask is not valid 
 place core in reset prior to power down 
 power down core 
 make sure we are in OFF state 
 enable IPC DONE and BUSY interrupts 
 enable IPC interrupt 
 disable IPC interrupt 
 disable IPC BUSY and DONE interrupt 
 configure pm_gate ipc message 
 send pm_gate ipc to dsp 
 Write to D0I3C after Command-In-Progress bit is cleared 
 Update D0I3C register 
 Wait for cmd in progress to be cleared before exiting the function 
	
	  Sanity check for illegal state transitions
	  The only allowed transitions are:
	  1. D3 -> D0I0
	  2. D0I0 -> D0I3
	  3. D0I3 -> D0I0
 Follow the sequence below for D0 substate transitions 
 Follow regular flow for D3 -> D0 transition 
 Set flags and register value for D0 target substate 
		
		  Trace DMA need to be disabled when the DSP enters
		  D0I3 for S0Ix suspend, but it can be kept enabled
		  when the DSP enters D0I3 while the system is in S0
		  for debug purpose.
 prevent power gating in D0I0 
 update D0I3C register 
	
	  Notify the DSP of the state change.
	  If this IPC fails, revert the D0I3C register update in order
	  to prevent partial state change.
 fallback to the previous register value 
	
	  This can fail but return the IPC error to signal that
	  the state change failed.
 helper to log DSP state 
  All DSP power state transitions are initiated by the driver.
  If the requested state change fails, the error is simply returned.
  Further state transitions are attempted only when the set_power_save() op
  is called again either because of a new IPC sent to the DSP or
  during system suspendresume.
	
	  When the DSP is already in D0I3 and the target state is D0I3,
	  it could be the case that the DSP is in D0I3 during S0
	  and the system is suspending to S0Ix. Therefore,
	  hda_dsp_set_D0_state() must be called to disable trace DMA
	  by sending the PM_GATE IPC to the FW.
	
	  For all other cases, return without doing anything if
	  the DSP is already in the target state.
 The only allowed transition is: D0I0 -> D3 
  Audio DSP states may transform as below:-
                                          Opportunistic D0I3 in S0
      Runtime    +---------------------+  Delayed D0i3 work timeout
      suspend    |                     +--------------------+
    +------------+       D0I0(active)  |                    |
    |            |                     <---------------+    |
    |   +-------->                     |    New IPC	|    |
    |   |Runtime +--^--+---------^--+--+ (via mailbox)	|    |
    |   |resume     |  |         |  |			|    |
    |   |           |  |         |  |			|    |
    |   |     System|  |         |  |			|    |
    |   |     resume|  | S3S0IX |  |                  |    |
    |   |	     |  | suspend |  | S0IX             |    |
    |   |           |  |         |  |suspend           |    |
    |   |           |  |         |  |                  |    |
    |   |           |  |         |  |                  |    |
  +-v---+-----------+--v-------+ |  |           +------+----v----+
  |                            | |  +----------->                |
  |       D3 (suspended)       | |              |      D0I3      |
  |                            | +--------------+                |
  |                            |  System resume |                |
  +----------------------------+		 +----------------+
  S0IX suspend: The DSP is in D0I3 if any D0I3-compatible streams
 		 ignored the suspend trigger. Otherwise the DSP
 		 is in D3.
 disable IPC interrupts 
 power down all hda link 
 power down DSP 
 disable ppcap interrupt 
 disable hda bus irq and streams 
 disable LP retention mode 
 reset controller 
 display codec can powered off after link reset 
 display codec must be powered before link reset 
	
	  clear TCSEL to clear playback on some HD Audio
	  codecs. PCI TCSEL is defined in the Intel manuals.
 reset and start hda controller 
 check jack status 
 turn off the links that were off before suspend 
 check dma status and clean up CORBRIRB buffers 
 enable ppcap interrupt 
 display codec can powered off after controller init 
 resume from D0I3 
 power up links that were active before suspend 
 set up CORBRIRB buffers if was on before suspend 
 Set DSP power state 
 restore L1SEN bit 
 restore and disable the system wakeup 
 init hda controller. DSP cores will be powered up during fw boot 
 init hda controller. DSP cores will be powered up during fw boot 
 cancel any attempt for DSP D0I3 
 stop hda controller and power dsp off 
 cancel any attempt for DSP D0I3 
 Set DSP power state 
 enable L1SEN to make sure the system can enter S0Ix 
 stop the CORBRIRB DMA if it is On 
 no link can be powered in s0ix state 
 enable the system waking up via IPC IRQ 
 stop hda controller and power dsp off 
 set internal flag for BE 
		
		  clear stream. This should already be taken care for running
		  streams when the SUSPEND trigger is called. But paused
		  streams do not get suspended, so this needs to be done
		  explicitly during suspend.
 DSP can enter D0I3 iff only D0I3-compatible streams are active 
 remain in D0I0 
 This can fail but error cannot be propagated 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Authors: Keyon Jie <yang.jie@linux.intel.com>
 CONFIG_SND_SOC_SOF_HDA_AUDIO_CODEC 
 load the legacy HDA codec driver 
 MODULE 
 enable controller wake up event for all codecs with jack connectors 
 check jack status after resuming from suspend mode 
		
		  Wake up all jack-detecting codecs regardless whether an event
		  has been recorded in STATESTS
 CONFIG_SND_SOC_SOF_HDA_AUDIO_CODEC 
 probe individual codec 
 only probe ASoC codec drivers for HDAC-HDMI 
		
		  handle ret==0 (no driver bound) as an error, but pass
		  other return codes without modification
 Codec initialization 
 probe codecs in avail slots 
 i915 exposes a HDA codec for HDMI audio 
 codec_mask not yet known, power up for probe 
 power down unconditionally 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018-2021 Intel Corporation. All rights reserved.
 Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
 platform specific devices 
 PCI IDs 
 BXT-P (ApolloLake) 
 BXT-T 
 GeminiLake 
 pci_driver definition 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Authors: Keyon Jie <yang.jie@linux.intel.com>
  This function checks if the host dma channel corresponding
  to the link DMA stream_tag argument is assigned to one
  of the FEs connected to the BE DAI.
 check if link is available 
				
				  check if the stream tag matches the stream
				  tag of one of the connected FEs
				
				  This must be a hostless stream.
				  So reserve the host DMA channel.
		
		  Decouple host and link DMA. The decoupled flag
		  is updated in snd_hdac_ext_stream_decouple().
 Update config for the DAI widget 
 update config with stream tag 
 send DAI_CONFIG IPC 
 set upfree DAI widget and send DAI_CONFIG IPC 
 get stored dma data if resuming from system suspend 
 set up the DAI widget and send the DAI_CONFIG with the new tag 
 set the stream tag in the codec dai dma params 
 set up hw_params 
		
		  clear link DMA channel. It will be assigned when
		  hw_params is set up again after resume.
 free the link DMA channel in the FW and the DAI widget 
 free the host DMA channel reserved by hostless streams 
 only one flag used so far to harden hw_paramshw_freetriggerprepare 
 DAI_CONFIG IPC during hw_params is not supported in older firmware 
 params are ignored for now 
	
	  the SSP will only be reconfigured during resume operations and
	  not in case of xruns
  common dai driver for skl+ platforms.
  some products who use this DAI array only physically have a subset of
  the DAIs, but no harm is done here by adding the whole set.
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Authors: Liam Girdwood <liam.r.girdwood@linux.intel.com>
	    Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	    Rander Wang <rander.wang@intel.com>
          Keyon Jie <yang.jie@linux.intel.com>
  Hardware interface for audio DSP on Apollolake and GeminiLake
 apollolake ops 
 proberemoveshutdown 
 Register IO 
 Block IO 
 Mailbox IO 
 doorbell 
 ipc 
 machine driver 
 debug 
 stream callbacks 
 probe callbacks 
 firmware loading 
 firmware run 
 prepost fw run 
 parse platform specific extended manifest 
 dsp core power updown 
 trace callback 
 DAI drivers 
 PM 
 ALSA HW info flags 
 Apollolake 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2019-2020 Intel Corporation. All rights reserved.
 Author: Cezary Rojewski <cezary.rojewski@intel.com>
 compr params do not store bit depth, default to S32_LE 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
  Hardware interface for audio DSP on Baytrail, Braswell and Cherrytrail.
 Disable Interrupt from both sides 
 Put DSP into reset, set reset vector 
 enable BUSY and disable DONE Interrupt by default 
 DSP DMA can only access low 31 bits of host memory 
 LPE base 
 TODO: add offsets 
 IMR base - optional 
 some BIOSes don't map IMR 
 register our IRQ 
 enable BUSY and disable DONE Interrupt by default 
 set default mailbox offset for FW ready message 
 baytrail ops 
 device init 
 DSP core boot  reset 
 Register IO 
 Block IO 
 Mailbox IO 
 doorbell 
 ipc 
 machine driver 
 debug 
 stream callbacks 
 module loading 
Firmware loading 
 PM 
 DAI drivers 
 we have only 3 SSPs on byt
 ALSA HW info flags 
 cherrytrail and braswell ops 
 device init 
 DSP core boot  reset 
 Register IO 
 Block IO 
 Mailbox IO 
 doorbell 
 ipc 
 machine driver 
 debug 
 stream callbacks 
 module loading 
Firmware loading 
 PM 
 DAI drivers 
 all 6 SSPs may be available for cherrytrail 
 ALSA HW info flags 
 BYTCR uses different IRQ index 
 acpi_driver definition 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018-2021 Intel Corporation. All rights reserved.
 Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
 platform specific devices 
 PCI IDs 
 TGL-LP 
 TGL-H 
 EHL 
 EHL 
 ADL-S 
 ADL-P 
 ADL-M 
 pci_driver definition 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Authors: Liam Girdwood <liam.r.girdwood@linux.intel.com>
	    Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	    Rander Wang <rander.wang@intel.com>
          Keyon Jie <yang.jie@linux.intel.com>
  Hardware interface for generic Intel audio DSP HDA IP
 initialize period_bytes 
	
	  initialize capture stream, set BDL address and return corresponding
	  stream tag which will be sent to the firmware by IPC message.
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Authors: Keyon Jie <yang.jie@linux.intel.com>
	
	  Both codec driver and controller can hold references to
	  display power. To avoid unnecessary power-updown cycles,
	  controller doesn't immediately release its reference.
	 
	  If the codec driver powers down the link, release
	  the controller reference as well.
  This can be used for both withwithout hda link support.
 CONFIG_SND_SOC_SOF_HDA 
	
	  There is only one HDA bus atm. keep the index as 0.
	  Need to fix when there are more than one HDA bus.
 CONFIG_SND_SOC_SOF_HDA 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018-2021 Intel Corporation. All rights reserved.
 Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
 platform specific devices 
 DSP DMA can only access low 31 bits of host memory 
 LPE base 
 IMR base - optional 
 some BIOSes don't map IMR 
 register our IRQ 
 enable BUSY and disable DONE Interrupt by default 
 set default mailbox offset for FW ready message 
 device init 
 DSP core boot  reset 
 Register IO 
 Block IO 
 Mailbox IO 
 doorbell 
 ipc 
 machine driver 
 debug 
 stream callbacks 
 module loading 
Firmware loading 
 DAI drivers 
 we have only 3 SSPs on byt
 ALSA HW info flags 
 IRAM, but subtract IRAM offset 
 PCI IDs 
 pci_driver definition 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Authors: Liam Girdwood <liam.r.girdwood@linux.intel.com>
	    Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	    Rander Wang <rander.wang@intel.com>
          Keyon Jie <yang.jie@linux.intel.com>
  Hardware interface for generic Intel audio DSP HDA IP
  HDA Operations.
 0 to enter reset and 1 to exit reset 
 enterexit HDA controller reset 
 wait to enterexit reset 
 enterexit reset failed 
	
	  On some devices, one reset cycle is necessary before reading
	  capabilities
  enabledisable audio dsp clock gating and power gating bits.
  This allows the HW to opportunistically power and clock gate
  the audio dsp when it is idle
 enabledisable audio dsp clock gating 
 enabledisable DMI Link L1 support 
 enabledisable audio dsp power gating 
 reset HDA controller 
 exit HDA controller reset 
 check to see if controller is ready 
 Accept unsolicited responses 
 detect codecs 
 clear stream status 
 clear WAKESTS 
 clear rirb status 
 clear interrupt status register 
 initialize the codec command IO 
 enable CIE and GIE interrupts 
 program the position buffer 
 Reset stream-to-link mapping 
 disable interrupts in stream descriptor 
 disable SIE for all streams 
 disable controller CIE and GIE 
 clear stream status 
 clear WAKESTS 
 clear rirb status 
 clear interrupt status register 
 disable CORBRIRB 
 disable position buffer 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Authors: Liam Girdwood <liam.r.girdwood@linux.intel.com>
	    Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	    Rander Wang <rander.wang@intel.com>
          Keyon Jie <yang.jie@linux.intel.com>
  Hardware interface for HDA DSP code loader
 allocate DMA buffer 
 initialize period_bytes 
  first boot sequence has some extra steps. core 0 waits for power
  status on core 1, so power up core 1 also momentarily, keep it in
  resetstall and then turn it off
 step 1: power up corex 
 DSP is powered up, set all SSPs to slave mode 
 step 2: purge FW request 
 step 3: unset core 0 reset state & unstallrun core 0 
 step 4: wait for IPC DONE bit from ROM 
 set DONE bit to clear the reply IPC message 
 step 5: power down cores that are no longer needed 
 step 6: enable IPC interrupts 
 step 7: wait for ROM init 
 after max boot attempts make sure that the dump is printed 
 code loader is special case that reuses stream ops 
 reset BDL address 
	
	  even in case of errors we still need to stop the DMAs,
	  but we return the initial error should the DMA stop also fail
 save the original LTRP guardband value 
 prepare capture stream for ICCMAX 
	
	  Perform iccmax stream cleanup. This should be done even if firmware loading fails.
	  If the cleanup also fails, we return the initial error
 set return value to indicate cleanup failure 
 restore the original guardband value after FW boot 
 init for booting wait 
 prepare DMA for code loader stream 
 try ROM init a few times before giving up 
 don't retry anymore if successful 
	
	  When a SoundWire link is in clock stop state, a Slave
	  device may trigger in-band wakes for events such as jack
	  insertion or acoustic event detection. This event will lead
	  to a WAKEEN interrupt, handled by the PCI device and routed
	  to PME if the PCI device is in D3. The resume function in
	  audio PCI driver will be invoked by ACPI for PME event and
	  initialize the device and process WAKEEN interrupt.
	 
	  The WAKEEN interrupt should be processed ASAP to prevent an
	  interrupt flood, otherwise other interrupts, such IPC,
	  cannot work normally.  The WAKEEN is handled after the ROM
	  is initialized successfully, which ensures power rails are
	  enabled before accessing the SoundWire SHIM registers
	
	  at this point DSP ROM has been initialized and
	  should be ready for code loading and firmware boot
	
	  Perform codeloader stream cleanup.
	  This should be done even if firmware loading fails.
	  If the cleanup also fails, we return the initial error
 set return value to indicate cleanup failure 
	
	  return primary core id if both fw copy
	  and stream clean up are successful
 disable DSP 
 pre fw run operations 
 disable clock gating and power gating 
 post fw run operations 
 re-enable clock gating and power gating 
  post fw run operations for ICL,
  Core 3 will be powered up and in stall when HPRO is enabled
	
	  The recommended HW programming sequence for ICL is to
	  power up core 3 and keep it in stall if HPRO is enabled.
	  Major difference between ICL and TGL, on ICL core 3 is managed by
	  the host whereas on TGL it is handled by the firmware.
 re-enable clock gating and power gating 
 calculate total number of config data elements 
 skip empty token 
 These elements are defined but not being used yet. No warn is required 
 make sure core_mask in host managed cores 
 stall core 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
  Hardware interface for audio DSP on Broadwell
 BARs 
  Debug
 DSP memories for BDW 
 DSP peripherals 
  DSP Control.
 set opportunistic mode on engine 0,1 for all channels 
 set DSP to RUN 
 return init core mask 
 put DSP into reset and stall 
 keep in reset for 10ms 
 take DSP out of reset and keep stalled for FW loading 
 Disable core clock gating (VDRTCTL2.DCLCGE = 0) 
 Disable D3PG (VDRTCTL0.D3PGD = 1) 
 Set D0 state 
 check that ADSP shim is enabled 
	
	  select SSP1 19.2MHz base clock, SSP clock 0,
	  turn off Low Power Clock
 stall DSP core, set clk to 19296Mhz 
 Set 24MHz MCLK, prevent local clock gating, enable SSP0 clock 
 Stall and reset core, set CSR 
 Enable core clock gating (VDRTCTL2.DCLCGE = 1), delay 50 us 
 switch on audio PLL 
	
	  set default power gating control, enable power gating control for
	  all blocks. that is, can't be accessed, please enable each block
	  before accessing.
 disable DMA finish function for SSP0 & SSP1 
 set on-demond mode on engine 0,1 for all channels 
 Enable Interrupt from both sides 
 clear IPC registers 
 first read registers 
 note: variable AR register array is not read 
 then get panic info 
 then get the stack 
 now try generic SOF status messages 
 provide some context for firmware debug 
  IPC Doorbell IRQ handler and thread.
 Interrupt arrived, check src 
 reply message from DSP 
 Mask Done interrupt before return 
		
		  handle immediate reply from DSP core. If the msg is
		  found, set done bit in cmd_done which is called at the
		  end of message processing function, else set it here
		  because the done bit can't be set in cmd_done function
		  which is triggered by msg
 new message from DSP 
 Mask Busy interrupt before return 
 Handle messages from DSP Core 
  IPC Mailbox IO
 send the message 
	
	  Sometimes, there is unexpected reply ipc arriving. The reply
	  ipc belongs to none of the ipcs sent from driver.
	  In this case, the driver must ignore the ipc.
 get reply 
 reply correct size ? 
 read the message 
 clear BUSY bit and set DONE bit - accept new messages 
 unmask busy interrupt 
 clear DONE bit - tell DSP we have completed 
 unmask Done interrupt 
  Probe and remove.
 LPE base 
 TODO: add offsets 
 PCI base 
 register our IRQ 
 enable the DSP SHIM 
 DSP DMA can only access low 31 bits of host memory 
 set default mailbox offset for FW ready message 
 Broadwell DAIs 
 broadwell ops 
Device init 
 DSP Core Control 
 Register IO 
 Block IO 
 Mailbox IO 
 ipc 
 machine driver 
 debug 
 stream callbacks 
 Module loading 
Firmware loading 
 DAI drivers 
 ALSA HW info flags 
 acpi_driver definition 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018-2021 Intel Corporation. All rights reserved.
 Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
 platform specific devices 
 PCI IDs 
 ICL-LP 
 ICL-H 
 ICL-N 
 JSL-N 
 pci_driver definition 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license.  When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 Authors: Liam Girdwood <liam.r.girdwood@linux.intel.com>
	    Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	    Rander Wang <rander.wang@intel.com>
          Keyon Jie <yang.jie@linux.intel.com>
  Hardware interface for generic Intel audio DSP HDA IP
 platform specific devices 
	
	  For static pipelines, the DAI widget would already be set up and calling
	  sof_widget_setup() simply returns without doing anything.
	  For dynamic pipelines, the DAI widget will be set up now.
 set HW_PARAMS flag 
 send DAI_CONFIG IPC 
 nothing to do if hw_free() is called without restarting the stream after resume. 
 set HW_FREE flag 
	
	  Reset the configured_flag and free the widget even if the IPC fails to keep
	  the widget use_count balanced
  The default for SoundWire clock stop quirks is to power gate the IP
  and do a Bus Reset, this will need to be modified when the DSP
  needs to remain in D0i3 so that the Master does not lose context
  and enumeration is not required on clock restart
 update config with link and stream ID 
 send invalid stream_id 
 save ACPI info for the probe step 
	
	  ops and arg fields are not populated for now,
	  they will be needed when the DAI callbacks are
	  provided
 we could filter links here if needed, e.g for quirks 
 save context 
 store status 
 invalid message ? 
 SDW message ? 
 IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL_SOUNDWIRE) 
 IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL_SOUNDWIRE) 
  Debug
 not for us, must be generic sof message 
 first read registers 
 note: variable AR register array is not read 
 then get panic info 
 then get the stack 
 dump the first 8 dwords representing the extended ROM status 
 print ROMFW status 
 read key IRQ stats and config registers 
 read IPC status 
 dump the IPC regs 
 TODO: parse the raw msg 
 HDA bus init 
 initialise hdac bus 
 HDA base 
 init i915 and HDMI codecs 
 get controller capabilities 
 this assumes a .tplg extension 
 first check NHLT for DMICs 
 allow for module parameter override 
 check if dsp is there 
 Init HDA controller after i915 init 
 scan SoundWire capabilities exposed by DSDT 
	
	  probeallocate SoundWire resources.
	  The hardware configuration takes place in hda_sdw_startup
	  after power rails are enabled.
	  It's entirely possible to have a mix of I2SDMICSoundWire
	  devices, so we allocate the resources in all cases.
 create codec instances 
	
	  we are done probing so decrement link counts
	
	  Get global interrupt status. It includes all hardware interrupt
	  sources in the Intel HD Audio controller.
 disable GIE interrupt 
 deal with streams and controller first 
 enable GIE interrupt 
	
	  detect DSP by checking classsubclassprog-id information
	  class=04 subclass 03 prog-if 00: no DSP, legacy driver is required
	  class=04 subclass 01 prog-if 00: DSP is present
	    (and may be required e.g. for DMIC or SSP support)
	  class=04 subclass 03 prog-if 80: either of DSP or legacy mode works
	
	  use position update IPC if either it is forced
	  or we don't have other choice
 set up HDA base 
 DSP base 
 allow 64bit DMA address if supported by HW 
 init streams 
		
		  not all errors are due to memory issues, but trying
		  to free everything does not harm
	
	  register our IRQ
	  let's try to enable msi firstly
	  if it fails, use legacy interrupt mode
	  TODO: support msi multiple vectors
 initialised to "false" by kzalloc() 
		
		  in IO-APIC mode, hda->irq and ipc_irq are using the same
		  irq number of pci->irq
	
	  clear TCSEL to clear playback on some HD Audio
	  codecs. PCI TCSEL is defined in the Intel manuals.
 init HDA capabilities 
 enable ppcap interrupt 
 set default mailbox offset for FW ready message 
 dsp_unmap: not currently used 
 cancel any attempt for DSP D0I3 
 codec removal, invoke bus_device_remove 
 disable DSP IRQ 
 disable CIE and GIE interrupts 
 disable cores 
 disable DSP 
 codec detection 
		
		  If no machine driver is found, then:
		 
		  generic hda machine driver can handle:
		   - one HDMI codec, andor
		   - one external HDAudio codec
 topology: use the info from hda_machines 
				
				  Prevent SoundWire links from starting when an external
				  HDaudio codec is used
 used by hda machine driver to create dai links 
 Check if all Slaves defined on the link can be found 
 find out how many identical parts were reported on that link 
 find out how many identical parts are expected 
				
				  we have to check unique id
				  if there is more than one
				  Slave on the link
	
	  Select SoundWire machine driver if needed using the
	  alternate tables. This case deals with SoundWire-only
	  machines, for mixed cases with I2CI2S the detection relies
	  on the HID list.
			
			  On some platforms such as Up Extreme all links
			  are enabled but only one link can be used by
			  external codec. Instead of exact match of two masks,
			  first check whether link_mask of mach is subset of
			  link_mask supported by hw and then go on searching
			  link_adr
 No need to match adr if there is no links defined 
				
				  Try next machine if any expected Slaves
				  are not found on this link.
 Found if all Slaves are checked 
			
			  DMICs use up to 4 pins and are typically pin-muxed with SoundWire
			  link 2 and 3, thus we only try to enable dmics if all conditions
			  are true:
			  a) link 2 and 3 are not used by SoundWire
			  b) the NHLT table reports the presence of microphones
		
		  If tplg file name is overridden, use it instead of
		  the one set in mach table
	
	  If I2S fails, try SoundWire
	
	  Choose HDA generic machine driver if mach is NULL.
	  Otherwise, set certain mach params.
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 Copyright(c) 2020 Intel Corporation. All rights reserved.
 Author: Fred Oh <fred.oh@linux.intel.com>
  Hardware interface for audio DSP on IceLake.
 Icelake ops 
 proberemoveshutdown 
 Register IO 
 Block IO 
 Mailbox IO 
 doorbell 
 ipc 
 machine driver 
 debug 
 stream callbacks 
 probe callbacks 
 firmware loading 
 prepost fw run 
 parse platform specific extended manifest 
 dsp core power updown 
 firmware run 
 trace callback 
 DAI drivers 
 PM 
 ALSA HW info flags 
 Icelake 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 Copyright 2019 NXP
 Author: Daniel Baluta <daniel.baluta@nxp.com>
 Hardware interface for audio DSP on i.MX8
 DSP memories 
 DSP IPC handler 
 System Controller IPC handler 
 Power domain handling 
 get reply 
 reply has correct size? 
 read the message 
 panic code 
 Read the message from the debug box. 
 Check to see if the message is a panic code (0x0dead) 
  DSP control.
 power up device associated power domains 
 DSP IPC driver not probed yet, try later 
 DSP base 
 set default mailbox offset for FW ready message 
 on i.MX8 there is 1 to 1 match between type and BAR idx 
 Only IRAM and SRAM bars are valid 
 i.MX8 ops 
 probe and remove 
 DSP core boot 
 Block IO 
 Mailbox IO 
 ipc 
 module loading 
 firmware loading 
 Debug information 
 stream callbacks 
 Firmware ops 
 DAI drivers 
 ALSA HW info flags 
 i.MX8X ops 
 probe and remove 
 DSP core boot 
 Block IO 
 Mailbox IO 
 ipc 
 module loading 
 firmware loading 
 Debug information 
 stream callbacks 
 Firmware ops 
 DAI drivers 
 ALSA HW info flags 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 Copyright 2020 NXP
 Common helpers for the audio DSP on i.MX8
  imx8_get_registers() - This function is called in case of DSP oops
  in order to gather information about the registers, filename and
  linenumber and stack.
  @sdev: SOF device
  @xoops: Stores information about registers.
  @panic_info: Stores information about filename and line number.
  @stack: Stores the stack dump.
  @stack_words: Size of the stack dump.
 first read registers 
 then get panic info 
 then get the stack 
  imx8_dump() - This function is called when a panic message is
  received from the firmware.
  @sdev: SOF device
  @flags: parameter not used but required by ops prototype
	 Get information about the panic status from the debug box area.
	  Compute the trace point based on the status.
	 Get information about the registers, the filename and line
	  number and the stack.
 Print the information to the console 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 Copyright 2020 NXP
 Author: Daniel Baluta <daniel.baluta@nxp.com>
 Hardware interface for audio DSP on i.MX8M
 DSP IPC handler 
 get reply 
 reply has correct size? 
 read the message 
 Panic code 
 Read the message from the debug box. 
 Check to see if the message is a panic code (0x0dead) 
  DSP control.
 TODO: start DSP using Audio MIX bits 
 DSP IPC driver not probed yet, try later 
 DSP base 
 set default mailbox offset for FW ready message 
 on i.MX8 there is 1 to 1 match between type and BAR idx 
 Only IRAM and SRAM bars are valid 
 i.MX8 ops 
 probe and remove 
 DSP core boot 
 Block IO 
 Mailbox IO 
 ipc 
 module loading 
 firmware loading 
 Debug information 
 stream callbacks 
 Firmware ops 
 DAI drivers 
 SPDX-License-Identifier: GPL-2.0
 Mediatek ALSA BT SCO CVSDMSBC Driver
 Copyright (c) 2019 MediaTek Inc.
 Author: KaiChieh Chuang <kaichieh.chuang@mediatek.com>
 TX 
 18 = 6  180  SCO_TX_ENCODE_SIZE 
 RX 
 spinlock for bt tx stream control 
 spinlock for bt rx stream control 
 write encoded mute data to bt sram 
 prepare encoded mute data 
 write mute data to bt tx sram buffer 
 bt return 0xdeadfeed if read register during bt sleep 
 bt return 0xdeadfeed if read register during bt sleep 
 store bt tx buffer sram info 
 bt return 0xdeadfeed if read reg during bt sleep 
				
				  free space is larger then
				  twice interrupt rx data size
 tx 
			 prepared data is larger then twice
			  interrupt tx data size
 one interrupt period = 22.5ms 
 in ns (10^9) 
			
			  error, -ERESTARTSYS if it was interrupted by
			  a signal
 conidtion is false after timeout 
 available data in RX packet buffer 
 count must be multiple of packet_size 
 calculate continue space 
	
	  save current timestamp & buffer time in times_tamp and
	  buf_data_equivalent_time
 return equivalent time(us) to data count 
	
	  save current timestamp & buffer time in time_stamp and
	  buf_data_equivalent_time
 return equivalent time(us) to data count 
 free space of TX packet buffer 
 count must be multiple of bt->tx->packet_size 
 calculate continue space 
 pcm ops 
 spinlock for bt stream control 
 get packet diff from last time 
 integer overflow 
 increased bytes 
 kcontrol 
 init btcvsd private data 
 init txrx 
 irq 
 iomap 
 get offset 
 init state 
 SPDX-License-Identifier: GPL-2.0
  mtk-afe-platform-driver.c  --  Mediatek afe platform driver
  Copyright (c) 2016 MediaTek Inc.
  Author: Garlic Tseng <garlic.tseng@mediatek.com>
 calcualte total dai driver size 
 combine sub_dais 
 dai driver 
 add routes after all widgets are added 
 SPDX-License-Identifier: GPL-2.0
  mtk-afe-fe-dais.c  --  Mediatek afe fe dai operator
  Copyright (c) 2016 MediaTek Inc.
  Author: Garlic Tseng <garlic.tseng@mediatek.com>
 enable agent 
	
	  Capture cannot use ping-pong buffer since hw_ptr at IRQ may be
	  smaller than period_size due to AFE's internal buffer.
	  This easily leads to overrun when avail_min is period_size.
	  One more period can hold the possible unread buffer.
 dynamic allocate irq to memif 
 link 
 set addr 
 set channel 
 set rate 
 set format 
 set irq counter 
 set irq fs 
 enable interrupt 
 disable interrupt 
 and clear pending IRQ 
 start 
 end 
 set start, end, upper 32 bits 
	
	  set MSB to 33-bit, for memif address
	  only for memif base address, if msb_end_reg exists
 set MSB to 33-bit, for memif end address 
 for specific configuration of memif mono mode 
 set hd mode 
 SPDX-License-Identifier: GPL-2.0
  mt2701-afe-clock-ctrl.c  --  Mediatek 2701 afe clock ctrl
  Copyright (c) 2016 MediaTek Inc.
  Author: Garlic Tseng <garlic.tseng@mediatek.com>
 	   Ryder Lee <ryder.lee@mediatek.com>
 Get I2S related clocks 
 Some platforms may support BT path 
 Enable infra clock gate 
 Enable top a1sys clock gate 
 Enable top a2sys clock gate 
 Internal clock gates 
 Enable audio system 
 Configure ASRC 
 Set mclk source 
 Set mclk divider 
 SPDX-License-Identifier: GPL-2.0
  mt2701-cs42448.c  --  MT2701 CS42448 ALSA SoC machine driver
  Copyright (c) 2016 MediaTek Inc.
  Author: Ir Lian <ir.lian@mediatek.com>
 	   Garlic Tseng <garlic.tseng@mediatek.com>
 mt2701 mclk 
 codec mclk 
 FE 
 BE 
 Module information 
 SPDX-License-Identifier: GPL-2.0
  mt2701-wm8960.c  --  MT2701 WM8960 ALSA SoC machine driver
  Copyright (c) 2017 MediaTek Inc.
  Author: Ryder Lee <ryder.lee@mediatek.com>
 FE 
 BE 
 Module information 
 SPDX-License-Identifier: GPL-2.0
  Mediatek ALSA SoC AFE platform driver for 2701
  Copyright (c) 2016 MediaTek Inc.
  Author: Garlic Tseng <garlic.tseng@mediatek.com>
 	   Ir Lian <ir.lian@mediatek.com>
 	   Ryder Lee <ryder.lee@mediatek.com>
 disable i2s 
 need to disable i2s-out path when disable i2s-in 
 disable mclk 
 now we support bck 64bits only 
 no need to enable if already done 
 0 
 enable i2s 
 reset i2s hw status before enable 
 need to enable i2s-out path when enable i2s-in 
 mclk 
 if the other direction stream is not occupied 
 can't run single DL & DLM at the same time 
 single DL use PAIR_INTERLEAVE 
 enable agent for all signal DL (due to hw design) 
 FE DAIs 
 I2S BE DAIs 
 MRG BE DAIs 
 FE DAIs: memory intefaces to CPU 
 BE DAIs 
 inter-connections 
 I02,03 link to UL2, also need to open I2S0 
 TODO - extend control registers supported by newer SoCs 
 memif initialize 
 irq initialize 
 I2S initialize 
 initial audio related clock 
 SPDX-License-Identifier: GPL-2.0
 MediaTek ALSA SoC Audio DAI I2S Control
 Copyright (c) 2020 MediaTek Inc.
 Author: Shane Chien <shane.chien@mediatek.com>
 bck sync length = 1 
 bck sync length = PCM_INTF_CON1[9:13] 
 slave mode & external modem uses different crystal 
 slave mode & external modem uses the same crystal 
 dai component 
 inter-connections 
 dai ops 
 dai driver 
 SPDX-License-Identifier: GPL-2.0
 Mediatek ALSA SoC AFE platform driver for 8192
 Copyright (c) 2020 MediaTek Inc.
 Author: Shane Chien <shane.chien@mediatek.com>
 FE DAIs: memory intefaces to CPU 
 dma widget & routes
 TINYCONN MUX 
 inter-connections 
 these auto-gen reg has read-only bit, so put it as volatile 
 volatile reg cannot be cached, so cannot be set when power off 
 reg bit controlled by CCF 
 reg bit controlled by CCF 
 [20:31] is monitor 
 [20:31] is monitor 
 get irq that is sent to MCU 
 only care IRQ which is sent to MCU 
 clear irq 
 disable AFE 
 make sure all irq status are cleared 
 reset sgen 
 cache only 
 enable audio sys DCM for power saving 
 force cpu use 8_24 format when writing 32bit data 
 set all output port to 24bit 
 enable AFE 
 init audio related clock 
 reset controller to reset audio regs before regmap cache 
 regmap init 
 enable clock for regcache get default value from hw 
 init memif 
 needed when dynamic irq 
 init irq 
 request irq 
 init sub_dais 
 init dai_driver and component_driver 
 others 
 register platform 
 disable afe clock 
 SPDX-License-Identifier: GPL-2.0
 MediaTek ALSA SoC Audio Control
 Copyright (c) 2020 MediaTek Inc.
 Author: Shane Chien <shane.chien@mediatek.com>
 SPDX-License-Identifier: GPL-2.0
 MediaTek ALSA SoC Audio DAI TDM Control
 Copyright (c) 2020 MediaTek Inc.
 Author: Shane Chien <shane.chien@mediatek.com>
 according to sample rate 
 interconnection 
 which apll 
 dai ops 
 calculate mclk_rate, if not set explicitly 
 calculate bck 
 set tdm 
 DAI mode
 DAI clock inversion
 dai driver 
 SPDX-License-Identifier: GPL-2.0
 MediaTek ALSA SoC Audio DAI I2S Control
 Copyright (c) 2020 MediaTek Inc.
 Author: Shane Chien <shane.chien@mediatek.com>
 for determine which apll to use 
 low jitter control 
 dai component 
 i2s virtual mux to output widget 
 Tinyconn Mux 
 i2s in lpbk 
 interconnection 
 i2s en
 i2s hd en 
 i2s mclk en 
 apll 
 allow i2s on without codec on 
 i2s in lpbk 
 check if share i2s need hd en 
 which apll 
 choose APLL from i2s rate 
 check if share i2s need mclk 
 which apll 
 i2s0 
 i2s1 
 i2s2 
 i2s3 
 i2s5 
 i2s6 
 i2s7 
 i2s8 
 i2s9 
 allow i2s on without codec on 
 i2s in lpbk 
 dai ops 
 non-inverse, i2s mode, proxy mode, 16bits, from connsys 
 use asrc 
 proxy mode, set i2s for asrc 
 Calibration setting 
 0:Stereo 1:Mono 
 i2s enable 
 calibrator enable 
 asrc enable 
 i2s disable 
 bypass asrc 
 i2s 
 set share i2s 
 dai driver 
 this enum is merely for mtk_afe_i2s_priv declare 
 set all dai i2s private data 
 parse share i2s 
 SPDX-License-Identifier: GPL-2.0
 mt8192-mt6359-rt1015-rt5682.c  --
	MT8192-MT6359-RT1015-RT6358 ALSA SoC machine driver
 Copyright (c) 2020 MediaTek Inc.
 Author: Jiaxin Yu <jiaxin.yu@mediatek.com>
 set clock protocol 2 
 set test type to synchronizer pulse 
 mt6359: 0 ~ 42 
 handle if never test done 
 disable rx fifo 
 set mtkaif protocol 
 mtkaif calibration 
 fix BE i2s format to 32bit, clean param mask first 
 FE 
 BE 
 Front End DAI links 
 Back End DAI links 
 speaker 
 headset 
 TDM 
 speaker 
 headset 
 Module information 
 SPDX-License-Identifier: GPL-2.0
 mt8192-afe-clk.c  --  Mediatek 8192 afe clock ctrl
 Copyright (c) 2020 MediaTek Inc.
 Author: Shane Chien <shane.chien@mediatek.com>
 180.6336  4 = 45.1584MHz 
 196.608  4 = 49.152MHz 
 setting for APLL 
 setting for APLL 
 mck 
 below will be deprecated 
 select apll 
 enable div, set rate 
 SPDX-License-Identifier: GPL-2.0
 MediaTek ALSA SoC Audio DAI ADDA Control
 Copyright (c) 2020 MediaTek Inc.
 Author: Shane Chien <shane.chien@mediatek.com>
 if you change level normal 
 you need to change formula of hp impedance and dc trim too 
 dai component 
 dmic mode, 3.25M
 turn on dmic, ch1, ch2 
 update setting to dmic 
 mtkaif_rxif_data_mode = 1, dmic 
 dmic mode, 3.25M
 should delayed 1fs(smallest is 8k) = 125us before afe off 
 update setting to dmic 
 mtkaif_rxif_data_mode = 1, dmic 
 dmic mode, 3.25M
		 when using adda6 without adda enabled,
		  RG_ADDA6_MTKAIF_RX_SYNC_WORD2_DISABLE_SFT need to be set or
		  data cannot be received.
 should delayed 1fs(smallest is 8k) = 125us before afe off 
 reset dmic 
 set protocol 2 
 mtkaif_rxif_clkinv_adc inverse for calibration 
 set delay for ch12 
 set delay between ch3 and ch2 
 ch3 
 ch2 
 should delayed 1fs(smallest is 8k) = 125us before afe off 
 should delayed 1fs(smallest is 8k) = 125us before afe off 
 stf 
 set side tone gain = 0 
 don't bypass stf 
 set stf half tap num 
 set side tone coefficient 
 wait until flag write_ready changed 
 flip => ok 
 need write -> read -> write to write next coeff 
 bypass stf 
 set side tone gain = 0 
 stf mux 
 ADDA UL MUX 
 inter-connections 
 stf 
 clock 
 playback 
 capture 
 sidetone filter 
 clk 
 dai ops 
 set sampling rate 
 set output mode, UP_SAMPLING_RATE_X8 
 turn off mute function 
 set voice input data if input sample rate is 8k or 16k 
 SA suggest apply -0.3db to audiospeech path 
 turn on down-link gain 
 clean predistortion 
 set sdm gain 
 2nd sdm 
 sdm auto reset 
 clean predistortion 
 set sdm gain 
 2nd sdm 
 sdm auto reset 
 default value 
 enable iir 
 35Hz @ 48k 
 Using Internal ADC 
 mtkaif_rxif_data_mode = 0, amic 
 35Hz @ 48k 
 Using Internal ADC 
 mtkaif_rxif_data_mode = 0, amic 
 ap dmic 
 dai driver 
 ap dmic priv share with adda 
 SPDX-License-Identifier: GPL-2.0
 mt8192-afe-gpio.c  --  Mediatek 8192 afe gpio ctrl
 Copyright (c) 2020 MediaTek Inc.
 Author: Shane Chien <shane.chien@mediatek.com>
 gpio status init 
 SPDX-License-Identifier: GPL-2.0
 MediaTek ALSA SoC Audio DAI TDM Control
 Copyright (c) 2018 MediaTek Inc.
 Author: KaiChieh Chuang <kaichieh.chuang@mediatek.com>
 according to sample rate 
 interconnection 
 which apll 
 dai ops 
 calculate mclk_rate, if not set explicitly 
 calculate bck 
 set tdm 
 enable Out control 
 enable tdm 
 disable tdm 
 disable Out control 
 DAI mode
 DAI clock inversion
 dai driver 
 SPDX-License-Identifier: GPL-2.0
 MediaTek ALSA SoC Audio DAI ADDA Control
 Copyright (c) 2018 MediaTek Inc.
 Author: KaiChieh Chuang <kaichieh.chuang@mediatek.com>
 if you change level normal 
 you need to change formula of hp impedance and dc trim too 
 dai component 
 update setting to dmic 
 mtkaif_rxif_data_mode = 1, dmic 
 dmic mode, 3.25M
 turn on dmic, ch1, ch2 
 should delayed 1fs(smallest is 8k) = 125us before afe off 
 mtkaif dmic 
 adda 
 playback 
 adda enable 
 clk 
 mtkaif_rxif_clkinv_adc inverse for calibration 
 dai ops 
 clean predistortion 
 set sampling rate 
 set output mode 
 UP_SAMPLING_RATE_X2 
 UP_SAMPLING_RATE_X4 
 UP_SAMPLING_RATE_X8 
 turn off mute function 
 set voice input data if input sample rate is 8k or 16k 
 SA suggest apply -0.3db to audiospeech path 
 turn on down-link gain 
 set sdm gain 
 default value 
 set mtkaif protocol 
 Using Internal ADC 
 enable iir 
 35Hz @ 48k 
 mtkaif_rxif_data_mode = 0, amic 
 dai driver 
 SPDX-License-Identifier: GPL-2.0
 MediaTek ALSA SoC Audio DAI Hostless Control
 Copyright (c) 2018 MediaTek Inc.
 Author: KaiChieh Chuang <kaichieh.chuang@mediatek.com>
 dai component 
 Hostless ADDA Loopback 
 Hostless Speech 
 dai ops 
 dai driver 
 SPDX-License-Identifier: GPL-2.0
 MediaTek ALSA SoC Audio DAI I2S Control
 Copyright (c) 2018 MediaTek Inc.
 Author: KaiChieh Chuang <kaichieh.chuang@mediatek.com>
 for determine which apll to use 
 low jitter control 
 dai component 
 interconnection 
 i2s en
 i2s hd en 
 i2s mclk en 
 apll 
 check if share i2s need hd en 
 which apll 
 choose APLL from i2s rate 
 check if share i2s need mclk 
 which apll 
 i2s0 
 i2s1 
 i2s2 
 i2s3 
 i2s5 
 dai ops 
 set share i2s 
 dai driver 
 this enum is merely for mtk_afe_i2s_priv declare 
 set all dai i2s private data 
 parse share i2s 
 SPDX-License-Identifier: GPL-2.0
 Mediatek ALSA SoC AFE platform driver for 8183
 Copyright (c) 2018 MediaTek Inc.
 Author: KaiChieh Chuang <kaichieh.chuang@mediatek.com>
 FE DAIs: memory intefaces to CPU 
 dma widget & routes
 memif 
 capture 
 control in tdm for sync start 
 these auto-gen reg has read-only bit, so put it as volatile 
 volatile reg cannot be cached, so cannot be set when power off 
 reg bit controlled by CCF 
 reg bit controlled by CCF 
 get irq that is sent to MCU 
 only care IRQ which is sent to MCU 
 clear irq 
 disable AFE 
 make sure all irq status are cleared, twice intended 
 cache only 
 enable audio sys DCM for power saving 
 force cpu use 8_24 format when writing 32bit data 
 set all output port to 24bit 
 enable AFE 
 initial audio related clock 
 regmap init 
 enable clock for regcache get default value from hw 
 init memif 
 init memif 
 irq initialize 
 request irq 
 init sub_dais 
 init dai_driver and component_driver 
 register component 
 SPDX-License-Identifier: GPL-2.0
 mt8183-afe-clk.c  --  Mediatek 8183 afe clock ctrl
 Copyright (c) 2018 MediaTek Inc.
 Author: KaiChieh Chuang <kaichieh.chuang@mediatek.com>
 apll related mux 
 apll 
 180.6336  8 = 22.5792MHz 
 196.608  8 = 24.576MHz 
 setting for APLL 
 setting for APLL 
 mck 
 i2s5 mck not support 
 select apll 
 enable div, set rate 
 i2s5 mck not support 
 SPDX-License-Identifier: GPL-2.0
 mt8183-da7219-max98357.c
	--  MT8183-DA7219-MAX98357 ALSA SoC machine driver
 Copyright (c) 2018 MediaTek Inc.
 Author: Shunli Wang <shunli.wang@mediatek.com>
 fix BE i2s format to 32bit, clean param mask first 
 fix BE i2s format to 32bit, clean param mask first 
 FE 
 BE 
 FE 
 BE 
 Enable Headset and 4 Buttons Jack detection 
 Module information 
 SPDX-License-Identifier: GPL-2.0
 mt8183-mt6358.c  --
	MT8183-MT6358-TS3A227-MAX98357 ALSA SoC machine driver
 Copyright (c) 2018 MediaTek Inc.
 Author: Shunli Wang <shunli.wang@mediatek.com>
 fix BE i2s format to 32bit, clean param mask first 
 fix BE i2s format to 32bit, clean param mask first 
 FE 
 BE 
 FE 
 BE 
 Enable Headset and 4 Buttons Jack detection 
 Module information 
 SPDX-License-Identifier: GPL-2.0
 MediaTek ALSA SoC Audio DAI I2S Control
 Copyright (c) 2018 MediaTek Inc.
 Author: KaiChieh Chuang <kaichieh.chuang@mediatek.com>
 bck sync length = 1 
 bck sync length = PCM_INTF_CON1[9:13] 
 slave mode & external modem uses different crystal 
 slave mode & external modem uses the same crystal 
 dai component 
 inter-connections 
 dai ops 
 dai driver 
 SPDX-License-Identifier: GPL-2.0
  mt8195-afe-clk.c  --  Mediatek 8195 afe clock ctrl
  Copyright (c) 2021 MediaTek Inc.
  Author: Bicycle Tsai <bicycle.tsai@mediatek.com>
          Trevor Wu <trevor.wu@mediatek.com>
 xtal 
 divider 
 mux 
 clock gate 
 afe clock gate 
 bus clock for infra 
 clock for ADSP bus 
 bus clock for DRAM access 
 bus clock for AFE SRAM access 
 audio 26M clock 
 AFE HW master switch 
 AFE HW clock
 AFE HW clock 
 SPDX-License-Identifier: GPL-2.0
  mt8195-audsys-clk.h  --  Mediatek 8195 audsys clock control
  Copyright (c) 2021 MediaTek Inc.
  Author: Trevor Wu <trevor.wu@mediatek.com>
 AUD0 
 AUD1 
 AUD3 
 AUD4 
 AUD5 
 AUD6 
 add clk_lookup for devm_clk_get(SND_SOC_DAPM_CLOCK_SUPPLY) 
 SPDX-License-Identifier: GPL-2.0
  MediaTek ALSA SoC Audio DAI ADDA Control
  Copyright (c) 2021 MediaTek Inc.
  Author: Bicycle Tsai <bicycle.tsai@mediatek.com>
          Trevor Wu <trevor.wu@mediatek.com>
 set rx protocol 2 & mtkaif_rxif_clkinv_adc inverse 
 set delay for ch1, ch2 
 set delay between ch3 and ch2 
 should delayed 1fs(smallest is 8k) = 125us before afe off 
 turn on dmic, ch1, ch2 
 should delayed 1fs(smallest is 8k) = 125us before afe off 
 should delayed 1fs(smallest is 8k) = 125us before afe off 
 set sampling rate 
 turn off saturation 
 turn off mute function 
 set voice input data if input sample rate is 8k or 16k 
 new 2nd sdm 
 dai driver 
 SPDX-License-Identifier: GPL-2.0
  Mediatek ALSA SoC AFE platform driver for 8195
  Copyright (c) 2021 MediaTek Inc.
  Author: Bicycle Tsai <bicycle.tsai@mediatek.com>
          Trevor Wu <trevor.wu@mediatek.com>
 DL8_DL10_MEM 
 DL8_DL10_AGENT 
 DL8_DL10_AGENT 
 DL8_DL10_MEM 
 FE DAIs: memory intefaces to CPU 
 DL6 
 DL3 
 DL11 
 DL11DL8 
 DL2 
 UL9 
 UL4 
 UL5 
 UL10 
 UL2 
 these auto-gen reg has read-only bit, so put it as volatile 
 volatile reg cannot be cached, so cannot be set when power off 
 only clr cpu irq 
 clear irq 
 initial audio related clock 
 irq initialize 
 init memif 
 request irq 
 init sub_dais 
 init dai_driver and component_driver 
 enable clock for regcache get default value from hw 
 register component 
 SPDX-License-Identifier: GPL-2.0
 mt8195-mt6359-rt1011-rt5682.c  --
	MT8195-MT6359-RT1011-RT5682 ALSA SoC machine driver
 Copyright (c) 2021 MediaTek Inc.
 Author: Trevor Wu <trevor.wu@mediatek.com>
 speaker 
 headset 
 set test type to synchronizer pulse 
 mt6359: 0 ~ 42 
 handle if never test done 
 set mtkaif protocol 
 mtkaif calibration 
 fix BE i2s format to 32bit, clean param mask first 
 fix BE i2s format to 32bit, clean param mask first 
 FE 
 BE 
 FE 
 BE 
 Module information 
 SPDX-License-Identifier: GPL-2.0
  MediaTek ALSA SoC Audio DAI eTDM Control
  Copyright (c) 2021 MediaTek Inc.
  Author: Bicycle Tsai <bicycle.tsai@mediatek.com>
          Trevor Wu <trevor.wu@mediatek.com>
dai id
dai_id
 HDMI_OUT_MUX 
 DPTX_OUT_MUX 
 HDMI_CH0_MUX ~ HDMI_CH7_MUX 
 eTDM_IN2 
 eTDM_IN1 
 eTDM_OUT2 
 eTDM_OUT1 
 eTDM_OUT3 
 dai ops 
 afifo 
 con1 
 con2 
 con3 
 con4 
 con5 
 con0 
 con1 
 con2 
 con4 
 con5 
 select apll 
 set rate 
 con0 
open master first
 close master at last
 dptx configure 
 enable dptx interface 
 enable etdm_out3 
 disable etdm_out3 
 disable dptx interface 
 dai driver 
 etdm in only 
 SPDX-License-Identifier: GPL-2.0
 mt8195-mt6359-rt1019-rt5682.c  --
	MT8195-MT6359-RT1019-RT6358 ALSA SoC machine driver
 Copyright (c) 2021 MediaTek Inc.
 Author: Trevor Wu <trevor.wu@mediatek.com>
 speaker 
 headset 
 set test type to synchronizer pulse 
 mt6359: 0 ~ 42 
 handle if never test done 
 set mtkaif protocol 
 mtkaif calibration 
 fix BE i2s format to 32bit, clean param mask first 
 fix BE i2s format to 32bit, clean param mask first 
 FE 
 BE 
 FE 
 BE 
 Module information 
 SPDX-License-Identifier: GPL-2.0
  MediaTek ALSA SoC Audio DAI PCM IF Control
  Copyright (c) 2020 MediaTek Inc.
  Author: Bicycle Tsai <bicycle.tsai@mediatek.com>
          Trevor Wu <trevor.wu@mediatek.com>
 sync freq mode 
 clk domain sel 
 pcm mode 
 pcm format 
 pcm sync length 
 pcm bits, word length 
 masterslave 
 TODO: add asrc setting for slave mode 
 dai ops 
 dai driver 
 SPDX-License-Identifier: GPL-2.0
 MediaTek ALSA SoC Audio DAI ADDA Control
 Copyright (c) 2018 MediaTek Inc.
 Author: KaiChieh Chuang <kaichieh.chuang@mediatek.com>
 dai component 
 should delayed 1fs(smallest is 8k) = 125us before afe off 
 adda 
 playback 
 adda enable 
 clk 
 dai ops 
 clean predistortion 
 set input sampling rate 
 set output mode 
 UP_SAMPLING_RATE_X2 
 UP_SAMPLING_RATE_X4 
 UP_SAMPLING_RATE_X8 
 turn off mute function 
 set voice input data if input sample rate is 8k or 16k 
 SA suggest apply -0.3db to audiospeech path 
			 SA suggest apply -0.3db to audiospeech path
			  with DL gain set to half,
			  0xFFFF = 0dB -> 0x8000 = 0dB when 96k, 192k
 turn on down-link gain 
 default value 
 Using Internal ADC 
 up8x txif sat on 
 hires 
 use hires format [1 0 23] 
 normal 8~48k 
 use fixed 260k anc path 
 ul_use_cic_out 
 dai driver 
 SPDX-License-Identifier: GPL-2.0
 MediaTek ALSA SoC Audio DAI Hostless Control
 Copyright (c) 2018 MediaTek Inc.
 Author: KaiChieh Chuang <kaichieh.chuang@mediatek.com>
 dai component 
 Hostless ADDA Loopback 
 Hostless Speech 
 dai ops 
 dai driver 
 SPDX-License-Identifier: GPL-2.0
 mt6797-mt6351.c  --  MT6797 MT6351 ALSA SoC machine driver
 Copyright (c) 2018 MediaTek Inc.
 Author: KaiChieh Chuang <kaichieh.chuang@mediatek.com>
 FE 
 BE 
 Module information 
 SPDX-License-Identifier: GPL-2.0
 mt6797-afe-clk.c  --  Mediatek 6797 afe clock ctrl
 Copyright (c) 2018 MediaTek Inc.
 Author: KaiChieh Chuang <kaichieh.chuang@mediatek.com>
 SPDX-License-Identifier: GPL-2.0
 MediaTek ALSA SoC Audio DAI I2S Control
 Copyright (c) 2018 MediaTek Inc.
 Author: KaiChieh Chuang <kaichieh.chuang@mediatek.com>
 bck sync length = 1 
 bck sync length = PCM_INTF_CON1[9:13] 
 slave mode & external modem uses different crystal 
 slave mode & external modem uses the same crystal 
 dai component 
 inter-connections 
 dai ops 
 dai driver 
 SPDX-License-Identifier: GPL-2.0
 Mediatek ALSA SoC AFE platform driver for 6797
 Copyright (c) 2018 MediaTek Inc.
 Author: KaiChieh Chuang <kaichieh.chuang@mediatek.com>
 FE DAIs: memory intefaces to CPU 
 dma widget & routes
 memif 
 capture 
 get irq that is sent to MCU 
 only clear IRQ which is sent to MCU 
 clear irq 
 disable AFE 
 make sure all irq status are cleared 
 irq signal to mcu only 
 force all memif use normal mode 
 force cpu use normal mode when access sram data 
 force cpu use 8_24 format when writing 32bit data 
 set all output port to 24bit 
 enable AFE 
 initial audio related clock 
 regmap init 
 init memif 
 irq initialize 
 request irq 
 init sub_dais 
 init dai_driver and component_driver 
 register component 
 SPDX-License-Identifier: GPL-2.0
  mt8173-rt5650-rt5514.c  --  MT8173 machine driver with RT56505514 codecs
  Copyright (c) 2016 MediaTek Inc.
  Author: Koro Chen <koro.chen@mediatek.com>
 pll from mclk 12.288M 
 sysclk from pll 
 enable jack detection 
 Digital audio interface glue - connects codec <---> CPU 
 Front End DAI links 
 Back End DAI links 
 Module information 
 SPDX-License-Identifier: GPL-2.0
  mt8173-rt5650.c  --  MT8173 machine driver with RT5650 codecs
  Copyright (c) 2016 MediaTek Inc.
  Author: Koro Chen <koro.chen@mediatek.com>
 0 = external oscillator; 1 = internal source from mt8173 
 mclk = 12.288M 
 mclk = sampling rate256 
 mclk = 12.288M 
 pll from mclk 
 sysclk from pll 
 enable jack detection 
 Playback 
 Capture 
 Digital audio interface glue - connects codec <---> CPU 
 Front End DAI links 
 Back End DAI links 
 Module information 
 SPDX-License-Identifier: GPL-2.0
  Mediatek 8173 ALSA SoC AFE platform driver
  Copyright (c) 2015 MediaTek Inc.
  Author: Koro Chen <koro.chen@mediatek.com>
              Sascha Hauer <s.hauer@pengutronix.de>
              Hidalgo Huang <hidalgo.huang@mediatek.com>
              Ir Lian <ir.lian@mediatek.com>
                   R E G I S T E R       D E F I N I T I O N
 Memory interface 
 AUDIO_TOP_CON0 (0x0000) 
 AFE_I2S_CON1 (0x0034) 
 AFE_I2S_CON2 (0x0038) 
 AFE_CONN_24BIT (0x006c) 
 AFE_HDMI_CONN0 (0x0390) 
 AFE_TDM_CON1 (0x0548) 
 from external ADC 
 set input 
 set output 
 input 
 output 
 config I2S 
 I2S mode 
 set tdm2 config 
 set connections:  O30~O37: LRLSRSCLFECH7CH8 
 enable Out control 
 enable tdm 
 disable tdm 
 disable Out control 
 BE DAIs 
 FE DAIs: memory intefaces to CPU 
 downlink 1 
 voice uplink 
 BE DAIs 
 FE DAIs 
 BE DAIs 
 inter-connections 
 clear irq 
 disable AFE 
 disable AFE clk 
 enable AFE clk 
 set O3O4 16bits 
 unmask all IRQs 
 enable AFE 
 22M 
 24M 
 initial audio related clock 
 memif % irq initialize
 SPDX-License-Identifier: GPL-2.0
  mt8173-rt5650-rt5676.c  --  MT8173 machine driver with RT56505676 codecs
  Copyright (c) 2015 MediaTek Inc.
  Author: Koro Chen <koro.chen@mediatek.com>
 IF2 ADC to 5650  
 DMIC from 5676 
 IF2 ADC to 5650  
 IF2 DAC from 5650  
 pll from mclk 12.288M 
 sysclk from pll 
 enable jack detection 
 Digital audio interface glue - connects codec <---> CPU 
 Front End DAI links 
 Back End DAI links 
 rt5676 <-> rt5650 intercodec link: Sets rt5676 I2S2 as master 
 Module information 
 SPDX-License-Identifier: GPL-2.0
  mt8173-max98090.c  --  MT8173 MAX98090 ALSA SoC machine driver
  Copyright (c) 2015 MediaTek Inc.
  Author: Koro Chen <koro.chen@mediatek.com>
 enable jack detection 
 Digital audio interface glue - connects codec <---> CPU 
 Front End DAI links 
 Back End DAI links 
 Module information 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) STMicroelectronics SA 2015
  Authors: Arnaud Pouliquen <arnaud.pouliquen@st.com>
           for STMicroelectronics.
  User frame size shall be 2, 4, 6 or 8 32-bits words length
  (i.e. 8, 16, 24 or 32 bytes)
  This constraint comes from allowed values for
  UNIPERIF_I2S_FMT_NUM_CH register
 Nb available player instances 
 player IP version 
 Reset uniperipheral uni 
 store info in unip context 
 unip is unidirectionnal 
 number of available timeslots 
 frame size in bytes 
 check frame size is allowed 
 clear remaining indexes 
	 word16_pos:
	  word16_pos[0] = WORDX_LSB
	  word16_pos[1] = WORDX_MSB,
	  word16_pos[2] = WORDX+1_LSB
	  word16_pos[3] = WORDX+1_MSB
 set unip word position 
  sti_uniperiph_dai_create_ctrl
  This function is used to create Ctrl associated to DAI but also pcm device.
  Request is done by front end to associate ctrl with pcm device id
		
		  Several Control can have same name. Controls are indexed on
		  Uniperipheral instance ID
  DAI
 transfer size = user frame size (in 32-bits FIFO cell) 
 The uniperipheral should be in stopped state 
 Pinctrl: switch pinstate to sleep 
 pinctrl: switch pinstate to default 
 DMA settings
 Populate data structure depending on compatibility 
 Get resources and base address 
 check if player should be configured for tdm 
 Allocate the private data and the CPU_DAI array 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) STMicroelectronics SA 2015
  Authors: Arnaud Pouliquen <arnaud.pouliquen@st.com>
           for STMicroelectronics.
  Some hardware-related definitions
 sys config registers definitions 
  Driver specific types.
 player id connected to I2STDM TX bus 
  Note: snd_pcm_hardware is linked to DMA controller but is declared here to
  integrate  DAI_CPU capability in term of rate and supported channels
  uni_player_irq_handler
  In case of error audio stream is stopped; stop action is protected via PCM
  stream lock to avoid race condition with trigger callback.
 Get interrupt status & clear them immediately 
 Check for fifo error (underrun) 
 Interrupt is just for information when underflow recovery 
 Update state to underflow 
 Disable interrupt so doesn't continually fire 
 Stop the player 
 Check for dma error (overrun) 
 Disable interrupt so doesn't continually fire 
 Stop the player 
 Check for underflow recovery done 
 Read the underflow recovery duration 
 Clear the underflow recovery duration 
 Update state to started 
 Check if underflow recovery failed 
 Stop the player 
	
	              a
	  F = f + ---------  f = f + d
	           1000000
	 
	          a
	  d = ---------  f
	       1000000
	 
	  where:
	    f - nominal rate
	    a - adjustment in ppm (parts per milion)
	    F - rate to be set in synthesizer
	    d - delta (difference) between f and F
 div64_64 operates on unsigned values... 
 500000 ppm is 0.5, which is used to round up values 
 Adjusted rate should never be == 0 
 If value is 0 means that clock or parent not valid 
	
	  Using ALSA's adjustment control, we can modify the rate to be up
	  to twice as much as requested, but no more
 div64_64 operates on unsigned values... 
 Frequency2 is added to round up result 
	
	  Some AVRs and TVs require the channel status to contain a correct
	  sampling frequency. If no sample rate is already specified, then
	  set one.
 Mark as sampling frequency not indicated 
	 Audio mode:
	  Use audio mode status to select PCM or encoded mode
 Clear user validity bits 
 Set user validity bits 
 Program the new channel status 
 Update the channel status 
 Oversampling must be multiple of 128 as iec958 frame is 32-bits 
 1616 memory format 
 16-bits per sub-frame 
 Set 16-bit sample precision 
 160 memory format 
 32-bits per sub-frame 
 Set 24-bit sample precision 
 Set parity to be calculated by the hardware 
 Set channel status bits to be inserted by the hardware 
 Set user data bits to be inserted by the hardware 
 Set validity bits to be inserted by the hardware 
 Set full software control to disabled 
 Update the channel status 
 Clear the user validity user bits 
 Disable one-bit audio mode 
 Enable consecutive frames repetition of Z preamble (not for HBRA) 
 Change to SUF0_SUBF1 and leftright channels swap! 
 Set data output as MSB first 
 Set rounding to off 
 Set clock divisor 
 Set the spdif latency to not wait before starting player 
	
	  Ensure iec958 formatting is off. It will be enabled in function
	  uni_player_start() at the same time as the operation
	  mode is set to work around a silicon issue.
 Force slot width to 32 in I2S mode (HW constraint) 
	
	  For 32 bits subframe clk_div must be a multiple of 128,
	  for 16 bits must be a multiple of 64
	
	  Number of bits per subframe (which is one channel sample)
	  on output - Transfer 16 or 32 bits from FIFO
 Configure data memory format 
 One data word contains two samples 
		
		  Actually "16 bits0 bits" means "322824201816 bits
		  on the left than zeros (if less than 32 bytes)"... ;-)
 Set rounding to off 
 Set clock divisor 
 Number of channelsmust be even
 Set 1-bit audio format to disabled 
 No iec958 formatting as outputting to DAC  
 unip tdm frame size in bytes 
 user tdm frame size in bytes 
 default unip TDM_WORD_POS_X_Y 
 fix 160 format 
 number of words inserted on the TDM line 
 Enable the tdm functionality 
 number of 8 bits timeslots avail in unip tdm frame 
 set the timeslot allocation for words in FIFO 
 set unip clk rate (not done vai set_sysclk ops) 
  ALSA uniperipheral iec958 controls
  uniperif rate adjustement control
 refine hw constraint in tdm mode 
 The player should be stopped 
 Calculate transfer size (in fifo cells and bytes) for frame count 
 transfer size = user frame size (in 32 bits FIFO cell) 
 Calculate number of empty cells available before asserting DREQ 
		
		  Since SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0
		  FDMA_TRIGGER_LIMIT also controls when the state switches
		  from OFF or STANDBY to AUDIO DATA.
 Trigger limit must be an even number 
 Uniperipheral setup depends on player type 
 The player should be stopped 
 Clear any pending interrupts 
 Set the interrupt mask 
 Enable underflow recovery interrupts 
	
	  Does not use IEC61937 features of the uniperipheral hardware.
	  Instead it performs IEC61937 in software and inserts it directly
	  into the audio data stream. As such, when encoded mode is selected,
	  linear pcm mode is still used, but with the differences of the
	  channel status bits set for encoded mode and the validity bits set.
	
	  If iec958 formatting is required for hdmi or spdif, then it must be
	  enabled after the operation mode is set. If set prior to this, it
	  will not take affect and hang the player.
 Force channel status update (no update if clk disable) 
 Update state to started 
 The player should not be in stopped state 
 Turn the player off 
 Disable interrupts 
 Disable clock 
 Update state to stopped and return 
 Select the frequency synthesizer clock 
 Stop the player 
 PCM_CLK_SEL 
 PCMP_VALID_SEL 
 Get PCM_CLK_SEL & PCMP_VALID_SEL from audio-glue-ctrl SoC reg 
 Underflow recovery is only supported on later ip revisions 
 Get uniperif resource 
 Select the frequency synthesizer clock 
 connect to I2STDM TX bus 
 Ensure that disabled by default 
 Set default iec958 status bits  
 Consumer, PCM, copyright, 2ch, mode 0 
 Broadcast reception category 
 Do not take into account source or channel number 
 Sampling frequency not indicated 
 Max sample word 24-bit, sample word length not indicated 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) STMicroelectronics SA 2015
  Authors: Arnaud Pouliquen <arnaud.pouliquen@st.com>
           for STMicroelectronics.
 reader id connected to I2STDM TX bus 
  Note: snd_pcm_hardware is linked to DMA controller but is declared here to
  integrate unireader capability in term of rate and supported channels
  uni_reader_irq_handler
  In case of error audio stream is stopped; stop action is protected via PCM
  stream lock  to avoid race condition with trigger callback.
 Unexpected IRQ: do nothing 
 Get interrupt status & clear them immediately 
 Check for fifo overflow error 
 Force slot width to 32 in I2S mode 
 Number of bits per subframe (i.e one channel sample) on input. 
 Configure data memory format 
 One data word contains two samples 
		
		  Actually "16 bits0 bits" means "322824201816 bits
		  on the MSB then zeros (if less than 32 bytes)"...
 Number of channels must be even 
 user tdm frame size in bytes 
 default unip TDM_WORD_POS_X_Y 
 fix 160 format 
 number of words inserted on the TDM line 
	
	  set the timeslots allocation for words in FIFO
	 
	  HW bug: (LSB word < MSB word) => this config is not possible
	          So if we want (LSB word < MSB) word, then it shall be
	          handled by user
 The reader should be stopped 
 Calculate transfer size (in fifo cells and bytes) for frame count 
 transfer size = unip frame size (in 32 bits FIFO cell) 
 Calculate number of empty cells available before asserting DREQ 
		
		  Since SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0
		  FDMA_TRIGGER_LIMIT also controls when the state switches
		  from OFF or STANDBY to AUDIO DATA.
 Trigger limit must be an even number 
 Data clocking (changing) on the risingfalling edge 
 Clear any pending interrupts 
 Set the interrupt mask 
 Enable underflow recovery interrupts 
 Reset uniperipheral reader 
 The reader should be stopped 
 Enable reader interrupts (and clear possible stalled ones) 
 Launch the reader 
 Update state to started 
 The reader should not be in stopped state 
 Turn the reader off 
 Disable interrupts 
 Update state to stopped and return 
 refine hw constraint in tdm mode 
 Stop the reader 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2011 Freescale Semiconductor, Inc.
  SAIF is a little different with other normal SOC DAIs on clock using.
  For MXS, two SAIF modules are instantiated on-chip.
  Each SAIF has a set of clock pins and can be operating in master
  mode simultaneously if they are connected to different off-chip codecs.
  Also, one of the two SAIFs can master or drive the clock pins while the
  other SAIF, in slave mode, receives clocking from the master SAIF.
  This also means that both SAIFs must operate at the same sample rate.
  We abstract this as each saif has a master, the master could be
  itself or other saifs. In the generic saif driver, saif does not need
  to know the different clkmux. Saif only needs to know who is its master
  and operating its master to generate the proper clock rate for it.
  The master id is provided in mach-specific layer according to different
  clkmux setting.
  Since SAIF may work on EXTMASTER mode, IOW, it's working BITCLK&LRCLK
  is provided by other SAIF, we provide a interface here to get its master
  from its master_id.
  Note that the master could be itself.
  Set SAIF clock and MCLK
 Set master saif to generate proper clock 
 Checking if can playback and capture simutaneously 
	
	  Set SAIF clock
	 
	  The SAIF clock should be either 384fs or 512fs.
	  If MCLK is used, the SAIF clk ratio needs to match mclk ratio.
	   For 256x, 128x, 64x, and 32x sub-rates, set saif clk as 512fs.
	   For 192x, 96x, and 48x sub-rates, set saif clk as 384fs.
	 
	  If MCLK is not used, we just set saif clk to 512fs.
 SAIF MCLK should be a sub-rate of 512x or 384x 
	
	  Program the over-sample rate for MCLK output
	 
	  The available MCLK range is 32x, 48x... 512x. The rate
	  could be from 8kHz to 192kH.
  Put and disable MCLK.
 disable MCLK output 
  Get MCLK and set clock rate, then enable it
  This interface is used for codecs who are using MCLK provided
  by saif.
 Clear Reset 
 FIXME: need clear clk gate for register rw 
 enable MCLK output 
  SAIF DAI format configuration.
  Should only be called when port is inactive.
	 If SAIF1 is configured as slave, the clk gate needs to be cleared
	  before the register can be written.
 DAI mode 
 data frame low 1clk before data 
 data frame high with data 
 DAI clock inversion 
	
	  Note: We simply just support master mode since SAIF TX can only
	  work as master.
	  Here the master is relative to codec side.
	  Saif internally could be slave when working on EXTMASTER mode.
	  We just hide this to machine driver.
 clear error status to 0 for each re-open 
 Clear Reset for normal operations 
 clear clock gate 
  Should only be called when port is inactive.
  although can be called multiple times by upper layers.
 mclk should already be set 
	
	  Set saif clk based on sample rate.
	  If mclk is used, we also set mclk, if not, saif->mclk is
	  default 0, means not used.
		
		 Set an initial clock rate for the saif internal logic to work
		 properly. This is important when working in EXTMASTER mode
		 that uses the other saif's BITCLK&LRCLK but it still needs a
		 basic clock which should be fast enough for the internal
		 logic.
 TxRx config 
 enable TX mode 
 enable RX mode 
 enable FIFO error irqs 
		
		  If the saif's master is not itself, we also need to enable
		  itself clk for its internal basic logic to work.
			
			  write data to saif data register to trigger
			  the transfer.
			  For 24-bit format the 32-bit FIFO register stores
			  only one channel, so we need to write twice.
			  This is also safe for the other non 24-bit formats.
			
			  read data from saif data register to trigger
			  the receive.
			  For 24-bit format the 32-bit FIFO register stores
			  only one channel, so we need to read twice.
			  This is also safe for the other non 24-bit formats.
 wait a while for the current sample to complete 
	
	  If there is no "fsl,saif-master" phandle, it's a saif
	  master.  Otherwise, it's a slave and its phandle points
	  to the master.
 We only support saif0 being tx and clock master 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2011 Freescale Semiconductor, Inc.
 sgtl5000 does not support 512rate when in 96000 fs 
 Set SGTL5000's SYSCLK (provided by SAIF MCLK) 
 The SAIF MCLK should be the same as SGTL5000_SYSCLK 
	
	  Set an init clock(11.28Mhz) for sgtl5000 initialization(i2c rw).
	  The Sgtl5000 sysclk is derived from saif0 mclk and it's range
	  should be >= 8MHz and <= 27M.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
  Based on soundsocimximx-pcm-dma-mx2.c
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2015 Andrea Venturi
  Andrea Venturi <be17068@iperbole.bo.it>
  Copyright (C) 2016 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
 Defines required for sun8i-h3 support 
 Defines required for sun50i-h6 support 
  struct sun4i_i2s_quirks - Differences between SoC variants.
  @has_reset: SoC needs reset deasserted.
  @reg_offset_txdata: offset of the tx fifo.
  @sun4i_i2s_regmap: regmap config to use.
  @field_clkdiv_mclk_en: regmap field to enable mclk output.
  @field_fmt_wss: regmap field to set word select size.
  @field_fmt_sr: regmap field to set sample resolution.
  @bclk_dividers: bit clock dividers array
  @num_bclk_dividers: number of bit clock dividers
  @mclk_dividers: mclk dividers array
  @num_mclk_dividers: number of mclk dividers
  @get_bclk_parent_rate: callback to get bclk parent rate
  @get_sr: callback to get sample resolution
  @get_wss: callback to get word select size
  @set_chan_cfg: callback to set channel configuration
  @set_fmt: callback to set format
 TX FIFO 
 Register fields for i2s 
	
	  In the set_chan_cfg() function pointer:
	  @slots: channels per frame + padding slots, regardless of format
	  @slot_width: bits per sample + padding bits, regardless of format
 Register fields for i2s 
 TODO - extend divide ratio supported by newer SoCs 
 TODO - extend divide ratio supported by newer SoCs 
 Map the channels for playback and capture 
 Configure the channels 
 Map the channels for playback and capture 
 Configure the channels 
 Map the channels for playback and capture 
 Configure the channels 
 Set significant bits in our FIFOs 
 DAI clock polarity 
 Invert both clocks 
 Invert bit clock 
 Invert frame clock 
 DAI Mode 
 DAI clock master masks 
 BCLK and LRCLK master 
 BCLK and LRCLK slave 
	
	  DAI clock polarity
	 
	  The setup for LRCK contradicts the datasheet, but under a
	  scope it's clear that the LRCK polarity is reversed
	  compared to the expected polarity on the bus.
 Invert both clocks 
 Invert bit clock 
 Invert frame clock 
 DAI Mode 
 DAI clock master masks 
 BCLK and LRCLK master 
 BCLK and LRCLK slave 
 Set sign extension to pad out LSB with 0 
	
	  DAI clock polarity
	 
	  The setup for LRCK contradicts the datasheet, but under a
	  scope it's clear that the LRCK polarity is reversed
	  compared to the expected polarity on the bus.
 Invert both clocks 
 Invert bit clock 
 Invert frame clock 
 DAI Mode 
 DAI clock master masks 
 BCLK and LRCLK master 
 BCLK and LRCLK slave 
 Set sign extension to pad out LSB with 0 
 Flush RX FIFO 
 Clear RX counter 
 Enable RX Block 
 Enable RX DRQ 
 Flush TX FIFO 
 Clear TX counter 
 Enable TX Block 
 Enable TX DRQ 
 Disable RX Block 
 Disable RX DRQ 
 Disable TX Block 
 Disable TX DRQ 
 Enable the whole hardware block 
 Enable the first output line 
 Disable our output lines 
 Disable the whole hardware block 
  This doesn't describe the TDM controller documented in the A83t
  datasheet, but the three undocumented I2S controller that use the
  older design.
 SPDX-License-Identifier: GPL-2.0-or-later
  ALSA SoC SPDIF Audio Layer
  Copyright 2015 Andrea Venturi <be17068@iperbole.bo.it>
  Copyright 2015 Marcus Cooper <codekipper@gmail.com>
  Based on the Allwinner SDK driver, released under the GPL.
 v even 
 Defines for Sampling Frequency 
  struct sun4i_spdif_quirks - Differences between SoC variants.
  @reg_dac_txdata: TX FIFO offset for DMA config.
  @has_reset: SoC needs reset deasserted.
  @val_fctl_ftx: TX FIFO flush bitmask.
 soft reset SPDIF 
 flush TX FIFO 
 clear TX counter 
 SPDIF TX ENABLE 
 DRQ ENABLE 
 Global enable 
 SPDIF TX DISABLE 
 DRQ DISABLE 
 Global disable 
 Add the PCM and raw data select interface 
 PCM mode 
 raw data mode 
 set non audio and bit depth 
 sentinel  }
 Initialize this copy of the CPU DAI driver structure 
 Get the addresses 
 Clocks 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2014 Emilio Lpez <emilio@elopez.com.ar>
  Copyright 2014 Jon Smirl <jonsmirl@gmail.com>
  Copyright 2015 Maxime Ripard <maxime.ripard@free-electrons.com>
  Copyright 2015 Adam Sampson <ats@offog.org>
  Copyright 2016 Chen-Yu Tsai <wens@csie.org>
  Based on the Allwinner SDK driver, released under the GPL.
 Codec DAC digital controls and FIFO registers 
 Codec DAC side analog signal controls 
 Codec ADC digital controls and FIFO registers 
 Codec ADC side analog signal controls 
 FIFO counters 
 Calibration register (sun7i only) 
 Microphone controls (sun7i only) 
  sun6i specific registers
  sun6i shares the same digital control and FIFO registers as sun4i,
  but only the DAC digital controls are at the same offset. The others
  have been moved around to accommodate extra analog controls.
 Codec DAC digital controls and FIFO registers 
 Output mixer and gain controls 
 Microphone, line out and phone out controls 
 ADC mixer controls 
 Analog performance tuning controls 
 Calibration controls 
 FIFO counters 
 headset jack detection and button support registers 
 TODO sun6i DAP (Digital Audio Processing) bits 
 FIFO counters moved on A23 
 TX FIFO moved on H3 
 TODO H3 DAP (Digital Audio Processing) bits 
 ADC_FIFOC register is at different offset on different SoCs 
 Flush TX FIFO 
 Enable DAC DRQ 
 Disable DAC DRQ 
 Enable ADC DRQ 
 Disable ADC DRQ 
 Flush RX FIFO 
 Set RX FIFO trigger level 
	
	  FIXME: Undocumented in the datasheet, but
	         Allwinner's code mentions that it is
	         related to microphone gain
 FIXME: Undocumented bits 
 Flush the TX FIFO 
 Set TX FIFO Empty Trigger Level 
 Use 64 bits FIR filter 
 Use 32 bits FIR filter 
 Send zeros when we have an underrun 
 Set ADC sample rate 
 Set the number of channels we want to use 
 Set the number of sample bits to either 16 or 24 bits 
 Fill most significant bits with valid data MSB 
 Set DAC sample rate 
 Set the number of channels we want to use 
 Set the number of sample bits to either 16 or 24 bits 
 Set TX FIFO mode to padding the LSBs with 0 
 Set TX FIFO mode to repeat the MSB 
	
	  Stop issuing DRQ when we have room for less than 16 samples
	  in our TX FIFO
 sun4i Codec 
 Digital parts of the ADCs 
 Digital parts of the DACs 
 Analog parts of the ADCs 
 Analog parts of the DACs 
 Mixers 
 Global Mixer Enable 
 VMIC 
 Mic Pre-Amplifiers 
 Power Amplifier 
 Left ADC  DAC Routes 
 Right ADC  DAC Routes 
 Right Mixer Routes 
 Left Mixer Routes 
 Power Amplifier Routes 
 Headphone Output Routes 
 Mic1 Routes 
 Mic2 Routes 
 sun6i Codec 
 mixer controls 
 ADC mixer controls 
 headphone controls 
 microphone controls 
 line out controls 
 volume  mute controls 
 Mixer pre-gains 
 Microphone Amp boost gains 
 Microphone inputs 
 Microphone Bias 
 Mic input path 
 Line In 
 Digital parts of the ADCs 
 Analog parts of the ADCs 
 ADC Mixers 
 Digital parts of the DACs 
 Analog parts of the DACs 
 Mixers 
 Headphone output path 
 Line Out path 
 DAC Routes 
 Microphone Routes 
 Left Mixer Routes 
 Right Mixer Routes 
 Left ADC Mixer Routes 
 Right ADC Mixer Routes 
 Headphone Routes 
 Line Out Routes 
 ADC Routes 
 sun8i A23 codec 
 Digital parts of the ADCs 
 Digital parts of the DACs 
		
		  Need a delay to wait for DAC to push the data. 700ms seems
		  to be the best compromise not to feel this delay while
		  playing a sound.
 Connect digital side enables to analog side widgets 
 ADC Routes 
 DAC Routes 
 used for regmap_field 
 TX FIFO offset for DMA config 
 RX FIFO offset for DMA config 
	
	  TODO Share the codec structure with A23 for now.
	  This should be split out when adding digital audio
	  processing support for the H3.
	
	  TODO The codec structure should be split out, like
	  H3, when adding digital audio processing support.
 Get the clocks from the DT 
 reg_field setup 
 Enable the bus clock 
 Deassert the reset control 
 DMA configuration for TX FIFO 
 DMA configuration for RX FIFO 
 SPDX-License-Identifier: GPL-2.0+
  This driver supports the analog controls for the internal codec
  found in Allwinner's A64 SoC.
  Copyright (C) 2016 Chen-Yu Tsai <wens@csie.org>
  Copyright (C) 2017 Marcus Cooper <codekipper@gmail.com>
  Copyright (C) 2018 Vasily Khoruzhick <anarsoul@gmail.com>
  Based on sun8i-codec-analog.c
 Codec analog control register offsets and bit fields 
 mixer controls 
 ADC mixer controls 
 volume  mute controls 
 Mixer pre-gain 
 Microphone Amp boost gain 
 Mixer pre-gain 
 Microphone Amp boost gain 
 ADC 
 Mixer pre-gain 
 DAC 
 ADC 
	
	  Due to this component and the codec belonging to separate DAPM
	  contexts, we need to manually link the above widgets to their
	  stream widgets at the card level.
 Microphone inputs 
 Microphone Bias 
 Mic input path 
 Microphone input 
 Microphone Bias 
 Mic input path 
 Line input 
 Mixers 
 Left Mixer Routes 
 Right Mixer Routes 
 Left ADC Mixer Routes 
 Right ADC Mixer Routes 
 ADC Routes 
 Headphone Routes 
 Microphone Routes 
 Microphone Routes 
 Line-out Routes 
 Earpiece Routes 
 SPDX-License-Identifier: GPL-2.0+
  This driver provides regmap to access to analog part of audio codec
  found on Allwinner A23, A31s, A33, H3 and A64 Socs
  Copyright 2016 Chen-Yu Tsai <wens@csie.org>
  Copyright (C) 2018 Vasily Khoruzhick <anarsoul@gmail.com>
 Analog control register access bits 
 PRCM base + 0x1c0 
 regmap access bits 
 De-assert reset 
 Clear write bit 
 Set register address 
 Read back value 
 De-assert reset 
 Set register address 
 Set data to write 
 Set write bit to signal a write 
 Clear write bit 
 SPDX-License-Identifier: GPL-2.0-or-later
  This driver supports the analog controls for the internal codec
  found in Allwinner's A31s, A23, A33 and H3 SoCs.
  Copyright 2016 Chen-Yu Tsai <wens@csie.org>
 Codec analog control register offsets and bit fields 
 H3 specific 
 mixer controls 
 mixer controls 
 ADC mixer controls 
 ADC mixer controls 
 volume  mute controls 
 Mixer pre-gain 
 Microphone Amp boost gain 
 ADC 
 ADC 
 DAC 
	
	  Due to this component and the codec belonging to separate DAPM
	  contexts, we need to manually link the above widgets to their
	  stream widgets at the card level.
 Microphone input 
 Mic input path 
 Microphone Routes 
 Left Mixer Routes 
 Right Mixer Routes 
 Left ADC Mixer Routes 
 Right ADC Mixer Routes 
 ADC Routes 
 headphone specific controls, widgets, and routes 
		
		  Need a delay to have the amplifier up. 700ms seems the best
		  compromise between the time to let the amplifier up and the
		  time not to feel this delay while playing a sound.
 mbias specific widget 
 hmic specific widget 
 line in specific controls, widgets and rines 
 Mixer pre-gain 
 Line input 
 line out specific controls, widgets and routes 
 It is unclear if this is a buffer or gate, model it as a supply 
 mic2 specific controls, widgets and routes 
 Mixer pre-gain 
 Microphone Amp boost gain 
 Microphone input 
 Mic input path 
		
		  Apply the special widget set which has uses a control
		  without MIC2 and Line In, for SoCs without these.
		  TODO: not all special cases are supported now, this case
		  is present because it's the case of V3s.
 Apply the generic mixer widget set. 
	
	  This would never return NULL unless someone directly registers a
	  platform device matching this driver's name, without specifying a
	  device tree node.
 Add controls, widgets, and routes for individual features 
 SPDX-License-Identifier: GPL-2.0-or-later
  This driver supports the digital controls for the internal codec
  found in Allwinner's A33 SoCs.
  (C) Copyright 2010-2016
  Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
  huangxin <huangxin@Reuuimllatech.com>
  Mylne Josserand <mylene.josserand@free-electrons.com>
 Set the sample rate for ADC->DAC passthrough when no AIF is active. 
 clock masters 
 Codec slave, DAI master 
 Codec Master, DAI slave 
 AIF3 only supports master mode. 
 Use the AIF2 BCLK and LRCK for AIF3. 
 DAI format 
 Set LRCK_INV to 0 
 Set LRCK_INV to 1 
 AIF3 only supports DSP mode. 
 clock inversion 
 Normal 
 Inverted LRCK 
 Inverted BCLK 
 Both inverted 
 Inverted LRCK is not available in DSP mode. 
 Instead, the bit selects between DSP AB formats. 
		
		  It appears that the DAI and the codec in the A33 SoC don't
		  share the same polarity for the LRCK signal when they mean
		  'normal' and 'inverted' in the datasheet.
		 
		  Since the DAI here is our regular i2s driver that have been
		  tested with way more codecs than just this one, it means
		  that the codec probably gets it backward, and we have to
		  invert the value here.
 hw_constraints is not relevant for codec2codec DAIs. 
 word size 
 LRCK divider (BCLKLRCK ratio) 
 AIF2 and AIF3 share AIF2's BCLK and LRCK generation circuitry. 
 BCLK divider (SYSCLKBCLK ratio) 
	
	  SYSCLK rate
	 
	  Clock rate protection is reference counted; but hw_params may be
	  called many times per substream, without matching calls to hw_free.
	  Protect the clock rate once per AIF, on the first hw_params call
	  for the first substream. clk_set_rate() will allow clock rate
	  changes on subsequent calls if only one AIF has open streams.
 Drop references when the last substream for the AIF is freed. 
 capture capabilities 
 playback capabilities 
 capture capabilities 
 playback capabilities 
 capture capabilities 
 playback capabilities 
 System Clocks 
 Module Clocks 
 Module Resets 
 Module Supplies 
 AIF "ADC" Outputs 
 AIF "ADC" MonoStereo Muxes 
 AIF "ADC" Output Muxes 
 AIF "ADC" Mixers 
 AIF "DAC" Input Muxes 
 AIF "DAC" MonoStereo Muxes 
 AIF "DAC" Inputs 
 ADC Inputs (connected to analog codec DAPM context) 
 DAC Outputs (connected to analog codec DAPM context) 
 DAC Mixers 
 Clock Routes 
 AIF "ADC" Output Routes 
 AIF "ADC" MonoStereo Mux Routes 
 AIF "ADC" Output Mux Routes 
 AIF "ADC" Mixer Routes 
 AIF "DAC" Input Mux Routes 
 AIF "DAC" MonoStereo Mux Routes 
 DAC Output Routes 
 DAC Mixer Routes 
 Legacy ADC Inputs (connected to analog codec DAPM context) 
 Legacy DAC Outputs (connected to analog codec DAPM context) 
 Legacy ADC Routes 
 Legacy DAC Routes 
 Add widgets for backward compatibility with old device trees. 
	
	  AIF1CLK and AIF2CLK share a pair of clock parents: PLL_AUDIO ("mod")
	  and MCLK (from the CPU DAI connected to AIF1). MCLK's parent is also
	  PLL_AUDIO, so using it adds no additional flexibility. Use PLL_AUDIO
	  directly to simplify the clock tree.
 Use AIF1CLK as the SYSCLK parent since AIF1 is used most often. 
 Program the default sample rate. 
 SPDX-License-Identifier: GPL-2.0-only
  AMD ALSA SoC PCM Driver for ACP 2.x
  Copyright 2014-2015 Advanced Micro Devices, Inc.
  Configure a given dma channel parameters - enabledisable,
  number of descriptors, priority
 disable the channel run field 
 program a DMA channel with first descriptor to be processed. 
	
	  program a DMA channel with the number of descriptors to be
	  processed in the transfer
 set DMA channel priority 
 Initialize a dma descriptor in SRAM based on descriptor information passed 
 program the source base address. 
 program the destination base address. 
 program the number of bytes to be transferred for this descriptor. 
 clear the reset bit 
 check the reset bit before programming configuration registers 
  Initialize the DMA descriptor information for transfer between
  system memory <-> ACP SRAM
  Initialize the DMA descriptor information for transfer between
  ACP SRAM <-> I2S
 dmadscr[i].dest is unused by hardware. 
 dmadscr[i].src is unused by hardware. 
 Configure the DMA channel with the above descriptor 
 Create page table entries in ACP SRAM for the allocated memory 
 Load the low address of page int ACP SRAM through SRBM 
 Load the High address of page int ACP SRAM through SRBM 
 page enable in ACP 
 Move to next physically contiguous page 
 Configure System memory <-> ACP SRAM DMA descriptors 
 Configure ACP SRAM <-> I2S DMA descriptors 
 Set 16bit resolution on capture 
 Start a given DMA channel transfer 
 read the dma control register and disable the channel run field 
 Invalidating the DAGB cache 
	
	  configure the DMA channel and start the DMA transfer
	  set dmachrun bit to start the transfer and enable the
	  interrupt on completion of the dma transfer
 enable for ACP to SRAM DMA channel 
 Stop a given DMA channel transfer 
	
	  clear the dma control register fields before writing zero
	  in reset bit
		
		  set the reset bit for this channel to stop the dma
		   transfer
 check the channel status bit for some time and return the status 
			
			  clear the reset flag after successfully stopping
			  the dma transfer and break from the loop
 bank is in off state 
 request to on 
 request to off 
 bank is in on state 
 request to off 
 request to on 
 Initialize and bring ACP hardware to default state. 
 Assert Soft reset of ACP 
 Enable clock to ACP and wait until the clock is enabled 
 Deassert the SOFT RESET flags 
 For BT instance change pins from UART to BT 
 initialize Onion control DAGB register 
 initialize Garlic control DAGB registers 
 Num of descriptors in SRAM 0x4, means 256 descriptors;(64  4) 
	 When ACP_TILE_P1 is turned on, all SRAM banks get turned on.
	 Now, turn off all of them. This can't be done in 'poweron' of
	 ACP pm domain, as this requires ACP to be initialized.
	 For Stoney, Memory gating is disabled,i.e SRAM Banks
	 won't be turned off. The default state for SRAM banks is ON.
	 Setting SRAM bank state code skipped for STONEY platform.
 Deinitialize ACP 
 Assert Soft reset of ACP 
 Disable ACP clock 
 ACP DMA irq handler routine for playback, capture usecases 
	
	  Enable ACP irq, when neither playback or capture streams are
	  active by the time when a new stream is being opened.
	  This enablement is not required for another stream, if current
	  stream is not closed
		
		  For Stoney, Memory gating is disabled,i.e SRAM Banks
		  won't be turned off. The default state for SRAM banks is ON.
		  Setting SRAM bank state code skipped for STONEY platform.
 Save for runtime private data 
 Fill the page table entries in ACP SRAM 
			
			  For Stoney, Memory gating is disabled,i.e SRAM Banks
			  won't be turned off. The default state for SRAM banks
			  is ON.Setting SRAM bank state code skipped for STONEY
			  platform. Added condition checks for Carrizo platform
			  only.
	
	  Disable ACP irq, when the current stream is being closed and
	  another stream is also not active.
	
	  The following members gets populated in device 'open'
	  function. Till then interrupts are disabled in 'acp_init'
	  and device doesn't generate any interrupts.
 Initialize the ACP 
		
		  For Stoney, Memory gating is disabled,i.e SRAM Banks
		  won't be turned off. The default state for SRAM banks is ON.
		  Setting SRAM bank state code skipped for STONEY platform.
 SPDX-License-Identifier: MIT
 Machine driver for AMD ACP Audio engine using DA7219, RT5682 & MAX98357 codec
Copyright 2017-2021 Advanced Micro Devices, Inc.
	
	  Set wclk to 48000 because the rate constraint of this driver is
	  48000. ADAU7002 spec: "The ADAU7002 requires a BCLK rate that is
	  minimum of 64x the LRCLK sample rate." DA7219 is the only clk
	  source so for all codecs we have to limit bclk to 64X lrclk.
 Set codec sysclk 
 set codec PLL 
	
	  Set wclk to 48000 because the rate constraint of this driver is
	  48000. ADAU7002 spec: "The ADAU7002 requires a BCLK rate that is
	  minimum of 64x the LRCLK sample rate." RT5682 is the only clk
	  source so for all codecs we have to limit bclk to 64X lrclk.
	
	  On this platform for PCM device we support stereo
	
	  On this platform for PCM device we support stereo
	
	  On this platform for PCM device we support stereo
	
	  On this platform for PCM device we support stereo
	
	  On this platform for PCM device we support stereo
	
	  On this platform for PCM device we support stereo
	
	  On this platform for PCM device we support stereo
	
	  On this platform for PCM device we support stereo
	
	  On this platform for PCM device we support stereo
	
	  On this platform for PCM device we support stereo
 C panel DMIC 
 AB panel DMIC 
 C panel DMIC 
 AB panel DMIC 
 1.8V 
 SPDX-License-Identifier: GPL-2.0+
 Machine driver for AMD ACP Audio engine using DA7219 & MAX98357 codec.
Copyright 2016 Advanced Micro Devices, Inc.
 set rt5682 dai fmt 
 set codec PLL 
 Set codec sysclk 
 Set tdmi2s1 master bclk ratio 
 RT5682 will support only 48K output with 48M mclk 
 speaker 
  Machine driver for AMD ACP Audio engine using Realtek RT5645 codec
  Copyright 2017 Advanced Micro Devices, Inc.
  This file is modified from rt288 machine driver
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
 SPDX-License-Identifier: GPL-2.0+
 AMD ALSA SoC PCM Driver
 Copyright (C) 2021 Advanced Micro Devices, Inc. All rights reserved.
 Group Enable 
 Load the low address of page int ACP SRAM through SRBM 
 Move to next physically contiguous page 
 SPDX-License-Identifier: GPL-2.0+
 AMD ALSA SoC PCM Driver
 Copyright (C) 2021 Advanced Micro Devices, Inc. All rights reserved.
 These values are as per Hardware Spec 
 These values are as per Hardware Spec 
 SPDX-License-Identifier: GPL-2.0+
  Machine driver for AMD Vangogh platform using NAU8821 & CS35L41
  codecs.
  Copyright 2021 Advanced Micro Devices, Inc.
	
	  Headset buttons map to the google Reference headset.
	  These can be configured by userspace.
 HP jack connectors - unknown if we have jack detection 
 SPDX-License-Identifier: GPL-2.0+
 AMD Vangogh ACP PCI Driver
 Copyright (C) 2021 Advanced Micro Devices, Inc. All rights reserved.
 power on 
 Reset 
 Reset 
 SPDX-License-Identifier: GPL-2.0+
 AMD Renoir ACP PCI Driver
Copyright 2020 Advanced Micro Devices, Inc.
  dmic_acpi_check = -1 - Use ACPIDMI method to detect the DMIC hardware presence at runtime
                  =  0 - Skip the DMIC device creation and return probe failure
                  =  1 - Force DMIC support
 power on 
 Reset 
 Reset 
 power off 
 Lenovo IdeaPad S340-14API 
 Lenovo IdeaPad Flex 5 14ARE05 
 Lenovo IdeaPad 5 15ARE05 
 Lenovo ThinkPad E14 Gen 2 
 Lenovo ThinkPad X395 
 Renoir device check 
 check for msi interrupt support 
 msi is not enabled 
 msi is enabled 
 SPDX-License-Identifier: GPL-2.0+
 AMD ALSA SoC PDM Driver
Copyright 2020 Advanced Micro Devices, Inc.
 Group Enable 
 Load the low address of page int ACP SRAM through SRBM 
 SPDX-License-Identifier: GPL-2.0+
 Machine driver for AMD Renoir platform using DMIC
Copyright 2020 Advanced Micro Devices, Inc.
 SPDX-License-Identifier: GPL-2.0+
  AMD Yellow Carp ACP PCI Driver
  Copyright 2021 Advanced Micro Devices, Inc.
 power on 
 Reset 
 Reset 
 Yellow Carp device check 
 SPDX-License-Identifier: GPL-2.0+
  Machine driver for AMD Yellow Carp platform using DMIC
  Copyright 2021 Advanced Micro Devices, Inc.
 SPDX-License-Identifier: GPL-2.0+
  AMD ALSA SoC Yellow Carp PDM Driver
  Copyright 2021 Advanced Micro Devices, Inc.
 Group Enable 
 Load the low address of page int ACP SRAM through SRBM 
 SPDX-License-Identifier: GPL-2.0+
 AMD ALSA SoC PCM Driver
Copyright 2016 Advanced Micro Devices, Inc.
 These values are as per Hardware Spec 
 These values are as per Hardware Spec 
 As we use devm_ memory alloc there is nothing TBD here 
 SPDX-License-Identifier: GPL-2.0+
 AMD ALSA SoC PCM Driver
Copyright 2016 Advanced Micro Devices, Inc.
 Group Enable 
 Load the low address of page int ACP SRAM through SRBM 
 Move to next physically contiguous page 
 SPDX-License-Identifier: GPL-2.0+
 AMD ACP PCI Driver
Copyright 2016 Advanced Micro Devices, Inc.
			 ACP power On clears PME_EN.
			  Restore the value to its prior state
 power on 
 Reset 
 Reset 
 Raven device detection 
 Save ACP_PME_EN state 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license. When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2021 Advanced Micro Devices, Inc.
 Authors: Ajit Kumar Pandey <AjitKumar.Pandey@amd.com>
  Machine Driver Legacy Support for ACP HW block
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license. When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2021 Advanced Micro Devices, Inc.
 Authors: Ajit Kumar Pandey <AjitKumar.Pandey@amd.com>
  Generic interface for ACP audio blck PCM component
 Use ATU base Group5 
 Group Enable 
 Load the low address of page int ACP SRAM through SRBM 
 Move to next physically contiguous page 
 Configure ACP DMA block with params 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license. When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2021 Advanced Micro Devices, Inc.
 Authors: Ajit Kumar Pandey <AjitKumar.Pandey@amd.com>
  Hardware interface for Renoir ACP block
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license. When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2021 Advanced Micro Devices, Inc.
 Authors: Ajit Kumar Pandey <AjitKumar.Pandey@amd.com>
	    Vijendar Mukunda <Vijendar.Mukunda@amd.com>
  Machine Driver Interface for ACP HW block
 Declare RT5682 codec components 
 Define card ops for RT5682 CODEC 
 Set tdmi2s1 master bclk ratio 
 Define RT5682S CODEC component
 Set tdmi2s1 master bclk ratio 
 Declare RT1019 codec components 
 Declare Maxim codec components 
 Declare DMIC codec components 
 Declare ACP CPU components 
 Use dummy codec if codec id not specified 
 Use dummy codec if codec id not specified 
 Use dummy codec if codec id not specified 
 Use dummy codec if codec id not specified 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license. When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2021 Advanced Micro Devices, Inc.
 Authors: Ajit Kumar Pandey <AjitKumar.Pandey@amd.com>
  Generic Hardware interface for ACP Audio I2S controller
 These values are as per Hardware Spec 
 Save runtime dai configuration in stream 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
 This file is provided under a dual BSDGPLv2 license. When using or
 redistributing this file, you may do so under either license.
 Copyright(c) 2021 Advanced Micro Devices, Inc.
 Authors: Ajit Kumar Pandey <AjitKumar.Pandey@amd.com>
  SOF Machine Driver Support for ACP HW block
 SPDX-License-Identifier: GPL-2.0-or-later
  imx-pcm-dma-mx2.c  --  ALSA Soc Audio Layer
  Copyright 2009 Sascha Hauer <s.hauer@pengutronix.de>
  This code is based on code copyrighted by Freescale,
  Liam Girdwood, Javier Martin and probably others.
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2012 Freescale Semiconductor, Inc.
 Copyright 2012 Linaro Ltd.
 Headphone jack detection 
	
	  The port numbering in the hardware manual starts at 1, while
	  the audmux API expects it starts at 0.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2012 Freescale Semiconductor, Inc.
 Copyright 2012 Linaro Ltd.
 Copyright 2009 Pengutronix, Sascha Hauer <s.hauer@pengutronix.de>
 Initial development of this code was funded by
 Phytec Messtechnik GmbH, https:
 There is an annoying discontinuity in the SSI numbering with regard
 sentinel  }
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0
 Copyright 2017-2020 NXP
  struct cpu_priv - CPU private data
  @sysclk_id: SYSCLK ids for set_sysclk()
  @slot_width: Slot width of each frame
  Note: [1] for tx and [0] for rx
 MCLK always is (256 or 192)  rate. 
 enable jack detection 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
 Freescale ALSA SoC Machine driver utility
 Author: Timur Tabi <timur@freescale.com>
 Copyright 2010 Freescale Semiconductor, Inc.
  fsl_asoc_get_dma_channel - determine the dma channel for a SSI node
  @ssi_np: pointer to the SSI device tree node
  @name: name of the phandle pointing to the dma channel
  @dai: ASoC DAI link pointer to be filled with platform_name
  @dma_channel_id: dma channel id to be returned
  @dma_id: dma id to be returned
  This function determines the dma and channel id for given SSI node.  It
  also discovers the platform_name for the ASoC DAI link.
	 Determine the dev_name for the device_node.  This code mimics the
	  behavior of of_device_make_bus_id(). We need this because ASoC uses
	  the dev_name() of the device to match the platform (DMA) device with
	  the CPU (SSI) device.  It's all ugly and hackish, but it works (for
	  now).
	 
	  dai->platform name should already point to an allocated buffer.
 SPDX-License-Identifier: GPL-2.0
 Phytec pcm030 driver for the PSC of the Freescale MPC52xx
 configured as AC97 interface
 Copyright 2008 Jon Smirl, Digispeaker
 Author: Jon Smirl <jonsmirl@gmail.com>
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2017-2020 NXP
  struct imx_audio_rpmsg: private data
  @rpmsg_pdev: pointer of platform device
 TYPE C is notification from M core 
 TYPE B is response msg 
 Register platform driver for rpmsg routine 
 SPDX-License-Identifier: GPL-2.0
 Copyright 2019 NXP
  fsl_easrc_set_rs_ratio
  According to the resample taps, calculate the resample ratio
  ratio = in_rate  out_rate
 integer bits = 5; 
 integer bits = 6; 
 integer bits = 7; 
 Normalize input and output sample rates 
 Divide by gcd to normalize the rate 
 Resets the pointer of the coeff memory pointers 
 This resets the prefilter memory pointer addr 
 This resets the resampling memory pointer addr 
	
	  To reset the write pointer back to zero, the register field
	  ASRC_CTX_CTRL_EXT1x[PF_COEFF_MEM_RST] can be toggled from
	  0x0 to 0x1 to 0x0.
	
	  RS_LOW - first half of center tap of the sinc function
	  RS_HIGH - second half of center tap of the sinc function
	  This is due to the fact the resampling function must be
	  symetrical - i.e. odd number of taps
	
	  Write Number of Resampling Coefficient Taps
	  00b - 32-Tap Resampling Filter
	  01b - 64-Tap Resampling Filter
	  10b - 128-Tap Resampling Filter
	  11b - NA
 Reset prefilter coefficient pointer back to 0 
	
	  When the filter is programmed to run in:
	  32-tap mode, 16-taps, 128-phases 4-coefficients per phase
	  64-tap mode, 32-taps, 64-phases 4-coefficients per phase
	  128-tap mode, 64-taps, 32-phases 4-coefficients per phase
	  This means the number of writes is constant no matter
	  the mode we are using
   fsl_easrc_normalize_filter - Scale filter coefficients (64 bits float)
   For input float32 normalized range (1.0,-1.0) -> output int[16,24,32]:
       scale it by multiplying filter coefficients by 2^31
   For input int[16, 24, 32] -> output float32
       scale it by multiplying filter coefficients by 2^-15, 2^-23, 2^-31
   input:
       @easrc:  Structure pointer of fsl_asrc
       @infilter : Pointer to non-scaled input filter
       @shift:  The multiply factor
   output:
       @outfilter: scaled filter
	
	  If exponent is zero (value == 0), or 7ff (value == NaNs)
	  dont touch the content
 coef  2^shift ==> exp + shift 
 If STx_NUM_TAPS is set to 0x0 then return 
	
	  When switching between stages, the address pointer
	  should be reset back to 0x0 before performing a write
	
	  The audio float point data range is (-1, 1), the asrc would output
	  all zero for float point input and integer output case, that is to
	  drop the fractional part of the data directly.
	 
	  In order to support float to int conversion or int to float
	  conversion we need to do special operation on the coefficient to
	  enlargereduce the data to the expected range.
	 
	  For float to int case:
	  Up sampling:
	  1. Create a 1 tap filter with center tap (only tap) of 2^31
	     in 64 bits floating point.
	     double value = (double)(((uint64_t)1) << 31)
	  2. Program 1 tap prefilter with center tap above.
	 
	  Down sampling,
	  1. If the filter is single stage filter, add "shift" to the exponent
	     of stage 1 coefficients.
	  2. If the filter is two stage filter , add "shift" to the exponent
	     of stage 2 coefficients.
	 
	  The "shift" is 31, same for int16, int24, int32 case.
	 
	  For int to float case:
	  Up sampling:
	  1. Create a 1 tap filter with center tap (only tap) of 2^-31
	     in 64 bits floating point.
	  2. Program 1 tap prefilter with center tap above.
	 
	  Down sampling,
	  1. If the filter is single stage filter, subtract "shift" to the
	     exponent of stage 1 coefficients.
	  2. If the filter is two stage filter , subtract "shift" to the
	     exponent of stage 2 coefficients.
	 
	  The "shift" is 15,23,31, different for int16, int24, int32 case.
	 
		
		  In prefilter coeff array, first st1_num_taps represent the
		  stage1 prefilter coefficients followed by next st2_num_taps
		  representing stage 2 coefficients
 only change stage2 coefficient for 2 stage case 
	
	  To modify the value of a prefilter coefficient, the user must
	  perform a write to the register ASRC_PRE_COEFF_FIFOn[COEFF_DATA]
	  while the respective context RUN_EN bit is set to 0b0
 Update ctx ST1_NUM_TAPS in Context Control Extended 2 register 
 Prefilter Coefficient Write Select to write in ST1 coeff 
		
		  Enable prefilter stage1 writeback floating point
		  which is used for FLOAT_LE case
 Update ctx ST2_NUM_TAPS in Context Control Extended 2 reg 
 Prefilter Coefficient Write Select to write in ST2 coeff 
  fsl_easrc_config_slot
  A single context can be split amongst any of the 4 context processing pipes
  in the design.
  The total number of channels consumed within the context processor must be
  less than or equal to 8. if a single context is configured to contain more
  than 8 channels then it must be distributed across multiple context
  processing pipe slots.
  fsl_easrc_release_slot
  Clear the slot configuration
 set registers 
 set registers 
  fsl_easrc_config_context
  Configure the register relate with context.
 Initialize the context coeficients 
	
	  Both prefilter and resampling filters can use following
	  initialization modes:
	  2 - zero-fil mode
	  1 - replication mode
	  0 - software control
	
	  Context Input FIFO Watermark
	  DMA request is generated when input FIFO < FIFO_WTMK
	
	  Context Output FIFO Watermark
	  DMA request is generated when output FIFO > FIFO_WTMK
	  So we set fifo_wtmk -1 to register.
 Number of channels 
	
	  Context Input Floating Point Format
	  0 - Integer Format
	  1 - Single Precision FP Format
 Get the data width 
	
	  Data Endianness
	  0 - Little-Endian
	  1 - Big-Endian
	
	  Input Data sign
	  0b - Signed Format
	  1b - Unsigned Format
 Get the bitfield values for input data format 
 In Sample Position 
 Get the bitfield values for input data format 
 Out Sample Position 
  The ASRC provides interleaving support in hardware to ensure that a
  variety of sample sources can be internally combined
  to conform with this format. Interleaving parameters are accessed
  through the ASRC_CTRL_IN_ACCESSa and ASRC_CTRL_OUT_ACCESSa registers
 input interleaving parameters 
 output interleaving parameters 
  Request one of the available contexts
  Returns a negative number on error and >=0 as context id
  on success
  Release the context
  This funciton is mainly doing the revert thing in request context
  Start the context
  Enable the DMA request and context
  Stop the context
  Disable the DMA request and context
 Read FIFO, drop the data 
 Check RUN_STOP_DONE 
Clear RUN_STOP_DONE
 Example of dma name: ctx0_rx 
	
	  Set the input and output ratio so we can compute
	  the resampling ratio in RS_LOWHIGH
	
	  Do only rate conversion and keep the same format for input
	  and output data
 Set default value 
	
	  Write Resampling Coefficients
	  The coefficient RAM must be configured prior to beginning of
	  any context processing within the ASRC
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2020 NXP
 DMA request when number of entries < WTMK_LOW 
 Disable interrupts
 Configure watermark 
 SPDX-License-Identifier: GPL-2.0
 Copyright 2019 NXP
 min=0x18, max=0x38 
 signed int, 2's compl., min=0x3FFF0000, max=0x00010000 
 unsigned int 
 Fout = Fref(MFI + MFNMFD), Fref is 24MHz 
 1.3 GHz 
 8000 Hz 
 11025 Hz 
 700 MHz 
  HDMI2.1 spec defines 6- and 12-channels layout for one bit audio
  stream. Todo: to check how this case can be considered below
 Capabilities data structure, bytes 
 nothing to do 
 Allow playback for SPDIF only 
 phy: true => phy, false => pll 
 Release AI interface from reset 
 PLL: BANDGAP_SET: EN_VBG (enable bandgap) 
 PLL: CTRL0: DIV_INTEGER 
 PLL: NUMERATOR: MFN 
 PLL: DENOMINATOR: MFD 
 PLL: CTRL0_SET: HOLD_RING_OFF, POWER_UP 
 PLL: CTRL0: Clear Hold Ring Off 
 TX is enabled for SPDIF only 
 PLL: POSTDIV: PDIV0 
 PLL: CTRL_SET: CLKMUX0_EN 
 eARC RX 
 PLL: POSTDIV: PDIV1 
 PLL: CTRL_SET: CLKMUX1_EN 
 SPDIF  ARC RX 
 PLL: POSTDIV: PDIV2 
 PLL: CTRL_SET: CLKMUX2_EN 
 eARC mode 
 PHY: CTRL_SET: TX_DIFF_OE, PHY_EN 
 PHY: CTRL2_SET: EARC_TX_MODE 
 SPDIF  ARC RX mode 
 PHY: CTRL_SET: SPDIF_EN 
 PHY: CTRL_SET: ARC RX setup 
 Release AI interface from reset 
 eARC mode 
 PHY: CTRL_SET: TX_DIFF_OE, PHY_EN 
 PHY: CTRL2_SET: EARC_TX_MODE 
 SPDIF mode 
 PHY: CTRL_SET: TX_CLK_AUD_SS | SPDIF_EN 
			
			  set SPDIF MODE - this flag is used to gate
			  SPDIF output, useless for SPDIF RX
			
			  Clear RX FIFO, flip RX FIFO bits,
			  disable eARC related HW mode detects
 Clear RX FIFO, flip RX FIFO bits 
 Enable eARC related HW mode detects 
 clear CMDC RESET 
 set TX_RX_MODE 
 set DPATH RESET 
 Disable XCVR controls if there is stream started 
 Enable XCVR controls if there is no stream started 
 clear SPDIF MODE 
 set CMDC RESET 
 set isr_cmdc_tx_en, w1c 
 enable DMA RDWR 
 clear DPATH RESET 
 disable DMA RDWR 
 clear ISR_CMDC_TX_EN, W1C 
 RAM is 20KiB = 16KiB code + 4KiB data => max 10 pages 2KiB each 
 IPG clock is assumed to be running, otherwise it will hang 
 write firmware into code memory 
 last part of firmware written 
 clean remaining part of code memory page 
 clean current page, including data memory 
 configure watermarks 
 disable DMA RDWR 
 Data RAM is 4KiB, last two pages: 8 and 9. Select page 8. 
 Store Capabilities Data Structure into Data RAM 
 Channel status controller 
 Capture channel status, bytes 
 Channel status controller 
 Playback channel status, bytes 
 Data RAM is 4KiB, last two pages: 8 and 9. Select page 8. 
 Find updated CS buffer 
 copy CS buffer 
 clear CS control register 
 sentinel  }
 get IRQs 
	
	  Register platform component before registering cpu dai for there
	  is not defer probe for platform component in snd_soc_add_pcm_runtime().
	
	  Clear interrupts, when streams starts or resumes after
	  suspend, interrupts are enabled in prepare(), so no need
	  to enable interrupts in resume().
 Assert M0+ reset 
 Release M0+ reset 
 Let M0+ core complete firmware initialization 
 SPDX-License-Identifier: GPL-2.0
 Freescale MPC8610HPCD ALSA SoC Machine driver
 Author: Timur Tabi <timur@freescale.com>
 Copyright 2007-2010 Freescale Semiconductor, Inc.
 There's only one global utilities register 
  mpc8610_hpcd_data: machine-specific ASoC device data
  This structure contains data for a single sound platform device on an
  MPC8610 HPCD.  Some of the data is taken from the device tree.
 0 = SSI1, 1 = SSI2, etc 
 0 = DMA1, 1 = DMA2, etc 
 0 = ch 0, 1 = ch 1, etc
 One for each DMA channel 
  mpc8610_hpcd_machine_probe: initialize the board
  This function is used to initialize the board-specific hardware.
  Here we program the DMACR and PMUXCR registers.
 Program the signal routing between the SSI and the DMA 
  mpc8610_hpcd_startup: program the board with various hardware parameters
  This function takes board-specific information, like clock frequencies
  and serial data formats, and passes that information to the codec and
  transport drivers.
 Tell the codec driver what the serial protocol is. 
	
	  Tell the codec driver what the MCLK frequency is, and whether it's
	  a slave or master.
  mpc8610_hpcd_machine_remove: Remove the sound device
  This function is called to remove the sound device for one SSI.  We
  de-program the DMACR and PMUXCR register.
 Restore the signal routing 
  mpc8610_hpcd_ops: ASoC machine driver operations
  mpc8610_hpcd_probe: platform probe function for the machine driver
  Although this is a machine driver, the SSI node is the "master" node with
  respect to audio hardware connections.  Therefore, we create a new ASoC
  device for each new SSI node that has a codec attached.
 ssi_pdev is the platform device for the SSI node that probed us 
 Find the codec node for this SSI. 
 ASoC core can match codec with device node 
 The DAI name from the codec (snd_soc_dai_driver.name) 
	 We register two DAIs per SSI, one for playback and the other for
	  capture.  Currently, we only support codecs that have one DAI for
	  both playback and capture.
 Get the device ID 
 Get the serial format and clock direction. 
		 In i2s-slave mode, the codec has its own clock source, so we
		  need to get the frequency from the device tree and pass it to
		  the codec driver.
 Find the playback DMA channel to use. 
 Find the capture DMA channel to use. 
 Initialize our DAI data structure.  
 The platform driver name 
 Register with ASoC 
  mpc8610_hpcd_remove: remove the platform device
  This function is called when the platform device is removed.
		 The name must match 'compatible' property in the device tree,
		  in lowercase letters.
  mpc8610_hpcd_init: machine driver initialization.
  This function is called when this module is loaded.
 Get the physical address of the global utilities registers 
  mpc8610_hpcd_exit: machine driver exit
  This function is called when this driver is unloaded.
 SPDX-License-Identifier: GPL-2.0
 Freescale ASRC ALSA SoC Platform (DMA) driver
 Copyright (C) 2014 Freescale Semiconductor, Inc.
 Author: Nicolin Chen <nicoleotsuka@gmail.com>
 Limited by SDMA engine 
 Prepare and submit Front-End DMA channel 
 Prepare and submit Back-End DMA channel 
 Fetch the Back-End dma_data from DPCM 
 Override dma_data of the Front-End and config its dmaengine 
 Request and config DMA channel for Back-End 
	
	  The Back-End device might have already requested a DMA channel,
	  so try to reuse it first, and then request a new one upon NULL.
	
	  An EDMA DEV_TO_DEV channel is fixed and bound with DMA event of each
	  peripheral, unlike SDMA channel that is allocated dynamically. So no
	  need to configure dma_request and dma_request2, but get dma_chan of
	  Back-End device directly via dma_request_slave_channel.
 Get DMA request of Back-End 
 Get DMA request of Front-End 
 Do not flag to release if we are reusing the Back-End one 
 release dev_to_dev chan if we aren't reusing the Back-End one 
	 Request a dummy pair, which will be released later.
	  Request pair function needs channel num as input, for this
	  dummy pair, we just request "1" channel temporarily.
 Request a dummy dma channel, which will be released later. 
 Refine the snd_imx_hardware according to caps of DMA. 
 SPDX-License-Identifier: GPL-2.0-only
 Freescale MPC5200 PSC DMA
 ALSA SoC Platform driver
 Copyright (C) 2008 Secret Lab Technologies Ltd.
 Copyright (C) 2009 Jon Smirl, Digispeaker
  Interrupt handlers
 Playback underrun error 
 Capture overrun error 
  psc_dma_bcom_enqueue_next_buffer - Enqueue another audio buffer
  @s: pointer to stream private data structure
  Enqueues another audio period buffer into the bestcomm queue.
  Note: The routine must only be called when there is space available in
  the queue.  Otherwise the enqueue will fail and the audio ring buffer
  will get out of sync
 Prepare and enqueue the next buffer descriptor 
 Update for next period 
 Bestcomm DMA irq handler 
	 For each finished period, dequeue the completed period buffer
	 If the stream is active, then also inform the PCM middle layer
  psc_dma_trigger: start and stop the DMA transfer.
  This function is called by ALSA to start, stop, pause, and resume the DMA
  transfer of data.
		 Fill up the bestcomm bd queue and enable DMA.
		  This will begin filling the PSC's fifo.
 Update interrupt enable settings 
 ---------------------------------------------------------------------
  The PSC DMA 'ASoC platform' driver
  Can be referenced by an 'ASoC machine' driver
  This driver only deals with the audio bus; it doesn't have any
  interaction with the attached codec
 Disable all interrupts and reset the PSC 
 reset error 
 Fetch the registers and IRQ of the PSC 
 Allocate and initialize the driver private data 
 Get the PSC ID 
	 Find the address of the fifo data registers and setup the
 Disable all interrupts and reset the PSC 
 reset receiver 
 reset transmitter 
 reset error 
 reset mode 
	 Set up mode register;
	  First write: RxRdy (FIFO Alarm) generates rx FIFO irq
	  Second write: register Normal mode for non loopback
 Set the TX and RX fifo alarm thresholds 
 Lookup the IRQ numbers 
 Save what we've done so it can be found again later 
 Tell the ASoC OF helpers about it 
 Release irqs 
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2017-2021 NXP
 No receive msg for TYPE_C command 
 wait response from rpmsg 
	
	  Reset the buffer pointer to be zero, actully we have
	  set the buffer pointer to be zero in imx_rpmsg_terminate_all
	  But if there is timer task queued in queue, after it is
	  executed the buffer pointer will be changed, so need to
	  reset it again with TERMINATE command.
	
	  Queue the work to workqueue.
	  If the queue is full, drop the message.
 reinitialize buffer counter
 reinitialize buffer counter
 Create timer
 Flush work in workqueue to make TX_CLOSE is the last message 
	
	  NON-MMAP mode, NONBLOCK, Version 2, enable lpa in dts
	  four conditions to determine the lpa is enabled.
		
		  Ignore suspend operation in low power mode
		  M core will continue playback music on A core suspend.
 Send buffer address and buffer size 
 Clear buffer count
 Clear buffer count
  imx_rpmsg_pcm_ack
  Send the period index to M core through rpmsg, but not send
  all the period index to M core, reduce some unnessesary msg
  to reduce the pressure of rpmsg bandwidth.
 There is update for period index 
 The notification message is updated to latest 
		
		  If the data in the buffer is less than one period before
		  this fill, which means the data may not enough on M
		  core side, we need to send message immediately to let
		  M core know the pointer is updated.
		  if there is more than one period data in the buffer before
		  this fill, which means the data is enough on M core side,
		  we can delay one period (using timer) to send the message
		  for reduce the message number in workqueue, because the
		  pointer may be updated by ack function later, we can
		  send latest pointer to M core side.
	
	  Every work in the work queue, first we check if there
	  is update for period is filled, because there may be not
	  enough data in M core side, need to let M core know
	  data is updated immediately.
 Skip the notification message for it has been processed above 
 update read index 
 Setup work queue 
 Write index initialize 1, make it differ with the read index 
 Initialize msg 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0+
 eukrea-tlv320.c  --  SoC audio for eukrea_cpuimxXX in I2S mode
 Copyright 2010 Eric Bnard, Eukra Electromatique <eric@eukrea.com>
 based on soundsocs3c24xxs3c24xx_simtec_tlv320aic23.c
 which is Copyright 2009 Simtec Electronics
 and on soundsocimxphycore-ac97.c which is
 Copyright 2009 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
 fsl_ssi lacks the set_sysclk ops 
		
		  The port numbering in the hardware manual starts at 1, while
		  the audmux API expects it starts at 0.
			 The eukrea,asoc-tlv320 driver was explicitly
			  requested (through the device tree).
			 Return happy.
			  We might run on a totally different machine.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
 ALSA SoC IMX MQS driver
 Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
 Copyright 2019 NXP
 codec private data 
	
	  mclk_rate  (oversample(32,64)  FS  2  divider ) = repeat_rate;
	  if repeat_rate is 8, mqs can achieve better quality.
	  oversample rate is fix to 32 currently.
 Only LEFT_J & SLAVE mode is supported. 
	 On i.MX6sx the MQS control register is in GPR domain
	  But in i.MX8QMi.MX8QXP the control register is moved
	  to its own domain.
 SPDX-License-Identifier: GPL-2.0
 Freescale SPDIF ALSA SoC Digital Audio Interface (DAI) driver
 Copyright (C) 2013 Freescale Semiconductor, Inc.
 Based on stmp3xxx_spdif_dai.c
 Vladimir Barinov <vbarinov@embeddedalley.com>
 Copyright 2008 SigmaTel, Inc
 Copyright 2008 Embedded Alley Solutions, Inc
 Index list for the values that has if (DPLL Locked) condition 
  struct fsl_spdif_soc_data: soc specific data
  @imx: for imx platform
  @shared_root_clock: flag of sharing a clock source with others;
                      so the driver shouldn't set root clock rate
  @raw_capture_mode: if raw capture mode support
  @interrupts: interrupt number
  @tx_burst: tx maxburst size
  @rx_burst: rx maxburst size
  @tx_formats: tx supported data format
  SPDIF control structure
  Defines channel status, subcode and Q sub
 spinlock to access control data 
 IEC958 channel tx status bit 
 User bits 
 Q subcode part of user bits 
 Buffer offset for UQ 
 Ready buffer index of the two buffers 
  struct fsl_spdif_priv - Freescale SPDIF private data
  @soc: SPDIF soc data
  @fsl_spdif_control: SPDIF control data
  @cpu_dai_drv: cpu dai driver
  @pdev: platform device pointer
  @regmap: regmap handler
  @dpll_locked: dpll lock flag
  @txrate: the best rates for playback
  @txclk_df: STC_TXCLK_DF dividers value for playback
  @sysclk_df: STC_SYSCLK_DF dividers value for playback
  @txclk_src: STC_TXCLK_SRC values for playback
  @rxclk_src: SRPC_CLKSRC_SEL values for capture
  @txclk: tx clock sources for playback
  @rxclk: rx clock sources for capture
  @coreclk: core clock for register access via DMA
  @sysclk: system clock for rx clock rate measurement
  @spbaclk: SPBA clock (optional, depending on SoC design)
  @dma_params_tx: DMA parameters for transmit channel
  @dma_params_rx: DMA parameters for receive channel
  @regcache_srpc: regcache for SRPC
  @bypass: status of bypass input to output
 regcache for SRPC 
 Applied for EDMA 
 Applied for EDMA 
 Applied for EDMA 
 Applied for EDMA 
 Applied for EDMA 
 Applied for EDMA 
 Check if clk is a root clock that does not share clock source with others 
 DPLL locked and lock loss interrupt handler 
 Receiver found illegal symbol interrupt handler 
 Clear illegal symbol if DPLL unlocked since no audio stream 
 UQ Channel receive register full 
 UQ Channel sync found 
 UQ buffer reset 
 Set ready to this buffer 
 UQ Channel framing error 
 Read UQ data to clear the irq and do buffer reset 
 Drop this UQ buffer 
 Get spdif interrupt status and clear the interrupt 
 FIXME: Write Tx FIFO to clear TxEm 
 FIXME: Read Rx FIFO to clear RxFIFOFul 
	
	  RESET bit would be cleared after finishing its reset procedure,
	  which typically lasts 8 cycles. 1000 cycles will keep it safe.
 Set SPDIF PhaseConfig register for rx clock 
 The SPDIF block needs a clock of 64  fs  txclk_df 
 set fs field in consumer channel status 
 select clock source and divisor 
 Reset module and interrupts only for first initialization 
 Disable all the interrupts 
 Power up SPDIF module 
 Power down SPDIF module only if tx&rx are both inactive 
 Setup rx clock source 
  FSL SPDIF IEC958 controller(mixer) functions
 	Channel status getput control
 	User bit value getput control
 	Valid bit value get control
 	DPLL lock status get control
 	User bit sync mode selection control
 Get channel status from SPDIF_RX_CCHAN register 
 Clear intr 
  Get User bits (subcode) from chip value which readed out
  in UChannel register.
 Q-subcode information. The byte size is SPDIF_UBITS_SIZE8 
 Get Q subcode from chip value which readed out in QChannel register 
 Get valid good bit from interrupt status register 
 nothing to do 
 Disable interrupts 
 Configure BYPASS mode 
 Power up SPDIF module 
 Power down SPDIF module, disable TX 
 Disable playback & capture if BYPASS mode is enabled, enable otherwise 
 DPLL lock information 
 Get RX data clock rate given the SPDIF bus_clk 
 Get bus clock from system 
 FreqMeas_CLK = (BUS_CLK  FreqMeas)  2 ^ 10  GAINSEL  128 
  Get DPLL lock or not info from stable interrupt status register.
  User application must use this control to get locked,
  then can do next PCM operation
  User bit sync mode:
  1 CD User channel subcode
  0 Non-CD data
  User bit sync mode:
  1 CD User channel subcode
  0 Non-CD data
 FSL SPDIF IEC958 controller defines 
 Status cchanel controller 
 User bits controller 
 Valid bit error controller 
 DPLL lock info get controller 
 RX bypass controller 
 User bit sync mode setget controller 
Clear the val bit for Tx
 FSL SPDIF REGMAP 
 The sysclk has an extra divisor [2, 512] 
 We are lucky 
 A little bigger than expect 
 A little smaller than expect 
 To quick catch a divisor, we allow a 0.1% deviation 
 Initialize this copy of the CPU DAI driver structure 
 Get the addresses and IRQ 
 Get system clock for rx clock rate calculation 
 Get core clock for data register access via DMA 
 Select clock source for rxtx clock 
 Initial spinlock for control data 
 Init tx channel status default value 
 Register with ASoC 
	
	  Register platform component before registering cpu dai for there
	  is not defer probe for platform component in snd_soc_add_pcm_runtime().
 Disable all the interrupts 
 CONFIG_PM 
 SPDX-License-Identifier: GPL-2.0
 Freescale SSI ALSA SoC Digital Audio Interface (DAI) driver
 Author: Timur Tabi <timur@freescale.com>
 Copyright 2007-2010 Freescale Semiconductor, Inc.
 Some notes why imx-pcm-fiq is used instead of DMA on some boards:
 The i.MX SSI core has some nasty limitations in AC97 mode. While most
 sane processor vendors have a FIFO per AC97 slot, the i.MX has only
 one FIFO which combines all valid receive slots. We cannot even select
 which slots we want to receive. The WM9712 with which this driver
 was developed with always sends GPIO status data in slot 12 which
 we receive in our (PCM-) data stream. The only chance we have is to
 manually skip this data in the FIQ handler. With sampling rates different
 from 48000Hz not every frame has valid receive data, so the ratio
 between pcm data and GPIO status data changes. Our FIQ handler is not
 able to handle this, hence this driver only works with 48000Hz sampling
 rate.
 Reading and writing AC97 registers is another challenge. The core
 provides us status bits when the read register is updated with another
 value. When we read the same register two times (and the register still
 contains the same value) these status bits are not set. We work
 around this by not polling these bits but only wait a fixed delay.
 Define RX and TX to index ssi->regvals array; Can be 0 or 1 only 
  FSLSSI_I2S_FORMATS: audio formats supported by the SSI
  The SSI has a limitation in that the samples must be in the same byte
  order as the host CPU.  This is because when multiple bytes are written
  to the STX register, the bytes and bits must be written in the same
  order.  The STX is a shift register, so all the bits need to be aligned
  (bit-endianness must match byte-endianness).  Processors typically write
  the bits within a byte in the same order that the bytes of a word are
  written in.  So if the host CPU is big-endian, then only big-endian
  samples will be written to STX properly.
  In AC97 mode, TXDIR bit is forced to 0 and TFDIR bit is forced to 1:
   - SSI inputs external bit clock and outputs frame sync clock -- CBM_CFS
   - Also have NB_NF to mark these two clocks will not be inverted
 imx21-class SSI - no SACC{ST,EN,DIS} regs 
  struct fsl_ssi - per-SSI private data
  @regs: Pointer to the regmap registers
  @irq: IRQ of this SSI
  @cpu_dai_drv: CPU DAI driver for this device
  @dai_fmt: DAI configuration this device is currently used with
  @streams: Mask of current active streams: BIT(TX) and BIT(RX)
  @i2s_net: I2S and Network mode configurations of SCR register
            (this is the initial settings based on the DAI format)
  @synchronous: Use synchronous mode - both of TX and RX use STCK and SFCK
  @use_dma: DMA is used or FIQ with stream filter
  @use_dual_fifo: DMA with support for dual FIFO mode
  @has_ipg_clk_name: If "ipg" is in the clock name list of device tree
  @fifo_depth: Depth of the SSI FIFOs
  @slot_width: Width of each DAI slot
  @slots: Number of slots
  @regvals: Specific RXTX register settings
  @clk: Clock source to access register
  @baudclk: Clock source to generate bit and frame-sync clocks
  @baudclk_streams: Active streams that are using baudclk
  @regcache_sfcsr: Cache sfcsr register value during suspend and resume
  @regcache_sacnt: Cache sacnt register value during suspend and resume
  @dma_params_tx: DMA transmit parameters
  @dma_params_rx: DMA receive parameters
  @ssi_phys: physical address of the SSI registers
  @fiq_params: FIQ stream filtering parameters
  @card_pdev: Platform_device pointer to register a sound card for PowerPC or
              to register a CODEC platform device for AC97
  @card_name: Platform_device name to register a sound card for PowerPC or
              to register a CODEC platform device for AC97
  @card_idx: The index of SSI to register a sound card for PowerPC or
             to register a CODEC platform device for AC97
  @dbg_stats: Debugging statistics
  @soc: SoC specific data
  @dev: Pointer to &pdev->dev
  @fifo_watermark: The FIFO watermark setting. Notifies DMA when there are
                   @fifo_watermark or fewer words in TX fifo or
                   @fifo_watermark or more empty words in RX fifo.
  @dma_maxburst: Max number of words to transfer in one go. So far,
                 this is always the same as fifo_watermark.
  @ac97_reg_lock: Mutex lock to serialize AC97 register access operations
  SoC specific data
  Notes:
  1) SSI in earlier SoCS has critical bits in control registers that
     cannot be changed after SSI starts running -- a software reset
     (set SSIEN to 0) is required to change their values. So adding
     an offline_config flag for these SoCs.
  2) SDMA is available since imx35. However, imx35 does not support
     DMA bits changing when SSI is running, so set offline_config.
  3) imx51 and later versions support register configurations when
     SSI is running (SSIEN); For these versions, DMA needs to be
     configured before SSI sends DMA request to avoid an undefined
     DMA request on the SDMA side.
  fsl_ssi_isr - Interrupt handler to gather states
  @irq: irq number
  @dev_id: context
 Clear the bits that we set 
  fsl_ssi_config_enable - Set SCR, SIER, STCR and SRCR registers with
  cached values in regvals
  @ssi: SSI context
  @tx: direction
  Notes:
  1) For offline_config SoCs, enable all necessary bits of both streams
     when 1st stream starts, even if the opposite stream will not start
  2) It also clears FIFO before setting regvals; SOR is safe to set online
 Clear dirty data in the FIFO; It also prevents channel slipping 
	
	  On offline_config SoCs, SxCR and SIER are already configured when
	  the previous stream started. So skip all SxCR and SIER settings
	  to prevent online reconfigurations, then jump to set SCR directly
		
		  Online reconfiguration not supported, so enable all bits for
		  both streams at once to avoid necessity of reconfigurations
 Otherwise, only set bits for the current stream 
 Configure SRCR, STCR and SIER at once 
	
	  Start DMA before setting TE to avoid FIFO underrun
	  which may cause a channel slip or a channel swap
	 
	  TODO: FIQ cases might also need this upon testing
 Enable SSI first to send TX DMA request 
 Busy wait until TX FIFO not empty -- DMA working 
 FIFO still empty -- something might be wrong 
 Enable all remaining bits in SCR 
 Log the enabled stream to the mask 
  Exclude bits that are used by the opposite stream
  When both streams are active, disabling some bits for the current stream
  might break the other stream if these bits are used by it.
  @vals : regvals of the current stream
  @avals: regvals of the opposite stream
  @aactive: active state of the opposite stream
   1) XOR vals and avals to get the differences if the other stream is active;
      Otherwise, return current vals if the other stream is not active
   2) AND the result of 1) with the current vals
  fsl_ssi_config_disable - Unset SCR, SIER, STCR and SRCR registers
  with cached values in regvals
  @ssi: SSI context
  @tx: direction
  Notes:
  1) For offline_config SoCs, to avoid online reconfigurations, disable all
     bits of both streams at once when the last stream is abort to end
  2) It also clears FIFO after unsetting regvals; SOR is safe to set online
 Check if the opposite stream is active 
 Get regvals of the opposite stream to keep opposite stream safe 
	
	  To keep the other stream safe, exclude shared bits between
	  both streams, and get safe bits to disable current stream
 Disable safe bits of SCR register for the current stream 
 Log the disabled stream to the mask 
	
	  On offline_config SoCs, if the other stream is active, skip
	  SxCR and SIER settings to prevent online reconfigurations
 Now there is only current stream active, disable all bits 
		
		  To keep the other stream safe, exclude shared bits between
		  both streams, and get safe bits to disable current stream
 Clear configurations of SRCR, STCR and SIER at once 
 Clear remaining data in the FIFO 
 no SACC{ST,EN,DIS} regs on imx21-class SSI 
 Disable all channel slots 
 Enable slots 3 & 4 -- PCM Playback Left & Right channels 
  fsl_ssi_setup_regvals - Cache critical bits of SIER, SRCR, STCR and
  SCR to later set them safely
  @ssi: SSI context
 AC97 has already enabled SSIEN, RE and TE, so ignore them 
 Setup the clock control register 
 Enable AC97 mode and startup the SSI 
 AC97 has to communicate with codec before starting a stream 
	
	  When using dual fifo mode, it is safer to ensure an even period
	  size. If appearing to an odd number while DMA always starts its
	  task from fifo0, fifo1 would be neglected at the end of each
	  period. But SSI would still access fifo1 with an invalid data.
  fsl_ssi_set_bclk - Configure Digital Audio Interface bit clock
  @substream: ASoC substream
  @dai: pointer to DAI
  @hw_params: pointers to hw_params
  Notes: This function can be only called when using SSI as DAI master
  Quick instruction for parameters:
  freq: Output BCLK frequency = samplerate  slots  slot_width
        (In 2-channel I2S Master mode, slot_width is fixed 32)
 Override slots and slot_width if being specifically set... 
 ...but force 32 bits for stereo audio using I2S Master Mode 
 Generate bit clock based on the slot number and slot width 
 Don't apply it to any non-baudclk circumstance 
	
	  Hardware limitation: The bclk rate must be
	  never greater than 15 IPG clock rate
 It should be already enough to divide clock by setting pm alone 
 Calculate the fraction 
 We are lucky 
 No proper pm found if it is still remaining the initial value 
 STCCR is used for RX in synchronous mode 
  fsl_ssi_hw_params - Configure SSI based on PCM hardware parameters
  @substream: ASoC substream
  @hw_params: pointers to hw_params
  @dai: pointer to DAI
  Notes:
  1) SxCCR.WL bits are critical bits that require SSI to be temporarily
     disabled on offline_config SoCs. Even for online configurable SoCs
     running in synchronous mode (both TX and RX use STCCR), it is not
     safe to re-configure them when both two streams start running.
  2) SxCCR.PM, SxCCR.DIV2 and SxCCR.PSR bits will be configured in the
     fsl_ssi_set_bclk() if SSI is the DAI clock master.
 Do not enable the clock if it is already enabled 
	
	  SSI is properly configured if it is enabled and running in
	  the synchronous mode; Note that AC97 mode is an exception
	  that should set separate configurations for STCCR and SRCCR
	  despite running in the synchronous mode.
		
		  Keep the ssi->i2s_net intact while having a local variable
		  to override settings for special use cases. Otherwise, the
		  ssi->i2s_net will lose the settings for regular use cases.
 Normal + Network mode to send 16-bit data in 32-bit frames 
 Use Normal mode to send mono data at 1st slot of 2 slots 
 In synchronous mode, the SSI uses STCCR for capture 
 Synchronize frame sync clock for TE to avoid data slipping 
 Set to default shifting settings: LSB_ALIGNED 
 Use Network mode as default 
 Data on rising edge of bclk, frame low, 1clk before data 
 Data on rising edge of bclk, frame high 
 Data on rising edge of bclk, frame high, 1clk before data 
 Data on rising edge of bclk, frame high 
 Data on falling edge of bclk, frame high, 1clk before data 
 DAI clock inversion 
 Nothing to do for both normal cases 
 Invert bit clock 
 Invert frame clock 
 Invert both clocks 
 DAI clock provider masks 
 Output bit and frame sync clocks 
 Input bit or frame sync clocks 
 Input bit clock but output frame sync clock 
 Set SYN mode and clear RXDIR bit when using SYN or AC97 mode 
  fsl_ssi_set_dai_fmt - Configure Digital Audio Interface (DAI) Format
  @dai: pointer to DAI
  @fmt: format mask
 AC97 configured DAIFMT earlier in the probe() 
  fsl_ssi_set_dai_tdm_slot - Set TDM slot number and slot width
  @dai: pointer to DAI
  @tx_mask: mask for TX
  @rx_mask: mask for RX
  @slots: number of slots
  @slot_width: number of bits per slot
 The word length should be 8, 10, 12, 16, 18, 20, 22 or 24 
 The slot number should be >= 2 if using Network mode or I2S mode 
 Save the SCR register value 
 Temporarily enable SSI to allow SxMSKs to be configurable 
 Restore the value of SSIEN bit 
  fsl_ssi_trigger - Start or stop SSI and corresponding DMA transaction.
  @substream: ASoC substream
  @cmd: trigger command
  @dai: pointer to DAI
  The DMA channel is in external master start and pause mode, which
  means the SSI completely controls the flow of data.
		
		  SACCST might be modified via AC Link by a CODEC if it sends
		  extra bits in their SLOTREQ requests, which'll accidentally
		  send valid data to slots other than normal playback slots.
		 
		  To be safe, configure SACCST right before TX starts.
 16-bit capture is broken (errata ERR003778) 
  fsl_ssi_hw_init - Initialize SSI registers
  @ssi: SSI context
 Initialize regvals 
 Set watermarks 
 Enable Dual FIFO mode 
 AC97 should start earlier to communicate with CODECs 
  fsl_ssi_hw_clean - Clear SSI registers
  @ssi: SSI context
 Disable registers for AC97 
 Disable TE and RE bits first 
 Disable AC97 mode 
 Unset WAIT bits 
 Disable SSI -- software reset 
  Make every character in a string lower-case
 Backward compatible for a DT without ipg clock name assigned 
 Enable the clock since regmap will not handle it in this case 
 Do not error out for consumer cases that live without a baud clock 
 Use even numbers to avoid channel swap due to SDMA script design 
		
		  Some boards use an incompatible codec. Use imx-fiq-pcm-audio
		  to get it working, as DMA is not possible in this situation.
 Get error code if not found 
 Check if being used in AC97 mode 
		
		  In synchronous mode, STCK and STFS ports are used by RX
		  as well. So the software should limit the sample rates,
		  sample bits and channels to be symmetric.
		 
		  This is exclusive with FSLSSI_AC97_FORMATS as AC97 runs
		  in the SSI synchronous mode however it does not have to
		  limit symmetric sample rates and sample bits.
 Select DMA or FIQ 
 Fetch FIFO depth; Set to 8 for older DT without this property 
 Use dual FIFO mode depending on the support from SDMA script 
	
	  Backward compatible for older bindings by manually triggering the
	  machine driver's probe(). Use compatible property, including the
	  address of CPU DAI driver structure, as the name of machine driver
	 
	  If card_name is set by AC97 earlier, bypass here since it uses a
	  different name to register the device.
 Strip "fsl," in the compatible name if applicable 
 Probe from DT 
 No SACC{ST,EN,DIS} regs in imx21-class SSI 
 Set software limitations for synchronous mode except AC97 
	
	  Configure TX and RX DMA watermarks -- when to send a DMA request
	 
	  Values should be tested to avoid FIFO underover run. Set maxburst
	  to fifo_watermark to maxiumize DMA transaction to reduce overhead.
		
		  Set to 8 as a balanced configuration -- When TX FIFO has 8
		  empty slots, send a DMA request to fill these 8 slots. The
		  remaining 7 slots should be able to allow DMA to finish the
		  transaction before TX FIFO underruns; Same applies to RX.
		 
		  Tested with cases running at 48kHz @ 16 bits x 16 channels
 Safely use old watermark configurations for older chips 
 Initially configures SSI registers 
 Register a platform device for older bindings or AC97 
		
		  Do not set SSI dev as the parent of AC97 CODEC device since
		  it does not have a DT node. Otherwise ASoC core will assume
		  CODEC has the same DT node as the SSI, so it may bypass the
		  dai_probe() of SSI and then cause NULL DMA data pointers.
 Clean up SSI registers 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0+
 Freescale ALSA SoC Digital Audio Interface (SAI) driver.
 Copyright 2012-2015 Freescale Semiconductor, Inc.
  fsl_sai_dir_is_synced - Check if stream is synced by the opposite stream
  SAI supports synchronous mode using bitframe clocks of either Transmitter's
  or Receiver's for both streams. This function is used to check if clocks of
  the stream's are synced by the opposite stream.
  @sai: SAI context
  @dir: stream direction
 current dir in async mode while opposite dir in sync mode 
	
	  Both IRQ status bits and IRQ mask bits are in the xCSR but
	  different shifts. And we here create a mask only for those
	  IRQs that we activated.
 Tx IRQ 
 FIFO reset for safety 
 Rx IRQ 
 FIFO reset for safety 
 DAI mode 
		
		  Frame low, 1clk before data, one word length for frame sync,
		  frame sync starts one serial clock cycle earlier,
		  that is, together with the last bit of the previous
		  data word.
		
		  Frame high, one word length for frame sync,
		  frame sync asserts with the first bit of the frame.
		
		  Frame high, 1clk before data, one bit for frame sync,
		  frame sync starts one serial clock cycle earlier,
		  that is, together with the last bit of the previous
		  data word.
		
		  Frame high, one bit for frame sync,
		  frame sync asserts with the first bit of the frame.
 To be done 
 DAI clock inversion 
 Invert both clocks 
 Invert bit clock 
 Invert frame clock 
 Nothing to do for both normal cases 
 DAI clock provider masks 
 Don't apply to consumer mode 
	
	  There is no point in polling MCLK0 if it is identical to MCLK1.
	  And given that MQS use case has to use MCLK1 though two clocks
	  are the same, we simply skip MCLK0 and start to find from MCLK1.
		
		  Drop the source that can not be
		  divided into the required rate.
	
	  1) For Asynchronous mode, we must set RCR2 register for capture, and
	     set TCR2 register for playback.
	  2) For Tx sync with Rx clock, we must set RCR2 register for playback
	     and capture.
	  3) For Rx sync with Tx clock, we must set TCR2 register for playback
	     and capture.
	  4) For Tx and Rx are both Synchronous with another SAI, we just
	     ignore it.
 Do not enable the clock if it is already enabled 
 Set to output mode to avoid tri-stated data pins 
	
	  For SAI provider mode, when Tx(Rx) sync with Rx(Tx) clock, Rx(Tx) will
	  generate bclk and frame clock for Tx(Rx), we should set RCR4(TCR4),
	  RCR5(TCR5) for playback(capture), or there will be sync error.
 TERE will remain set till the end of current frame 
	
	  For sai master mode, after several openclose sai,
	  there will be no frame clock, and can't recover
	  anymore. Add software reset to fix this issue.
	  This is a hardware bug, and will be fix in the
	  next sai version.
 Software Reset 
 Clear SR bit to finish the reset 
	
	  Asynchronous mode: Clear SYNC for both Tx and Rx.
	  Rx sync with Tx clocks: Clear SYNC for Tx, set it for Rx.
	  Tx sync with Rx clocks: Clear SYNC for Rx, set it for Tx.
	
	  It is recommended that the transmitter is the last enabled
	  and the first disabled.
		
		  Enable the opposite direction for synchronous mode
		  1. Tx sync with Rx: only set RE for Rx; set TE & RE for Tx
		  2. Rx sync with Tx: only set TE for Tx; set RE & TE for Rx
		 
		  RM recommends to enable RE after TE for case 1 and to enable
		  TE after RE for case 2, but we here may not always guarantee
		  that happens: "arecord 1.wav; aplay 2.wav" in case 1 enables
		  TE after RE, which is against what RM recommends but should
		  be safe to do, judging by years of testing results.
 Check if the opposite FRDE is also disabled 
		
		  If opposite stream provides clocks for synchronous mode and
		  it is inactive, disable it before disabling the current one
		
		  Disable current stream if either of:
		  1. current stream doesn't provide clocks for synchronous mode
		  2. current stream provides clocks for synchronous mode but no
		     more stream is active.
	
	  EDMA controller needs period size to be a multiple of
	  txrx maxburst
 Software Reset for both Tx and Rx 
 Clear SR bit to finish the reset 
 Set VERID and PARAM be volatile for reading value in probe 
 Max slots per frame, power of 2 
 Words per fifo, power of 2 
 Number of datalines implemented 
 Compatible with old DTB cases 
 -EPROBE_DEFER 
 Sync Tx with Rx as default by following old DT binding 
 error out if both synchronous and asynchronous are present 
 Sync Rx with Tx 
 Discard all settings for asynchronous mode 
 Get sai version 
 Select MCLK direction 
	
	  Register platform component before registering cpu dai for there
	  is not defer probe for platform component in snd_soc_add_pcm_runtime().
 sentinel  }
  Efika driver for the PSC of the Freescale MPC52xx
  configured as AC97 interface
  Copyright 2008 Jon Smirl, Digispeaker
  Author: Jon Smirl <jonsmirl@gmail.com>
  This file is licensed under the terms of the GNU General Public License
  version 2. This program is licensed "as is" without any warranty of any
  kind, whether express or implied.
 SPDX-License-Identifier: GPL-2.0
  NXP AUDMIX ALSA SoC Digital Audio Interface (DAI) driver
  Copyright 2017 NXP
 FSL_AUDMIX_CTR enums 
 FSL_AUDMIX_ATCR0 enums 
 FSL_AUDMIX_ATCR1 enums 
 DIS->DIS, do nothing 
 DIS->TDM1
 DIS->TDM2
 DIS->MIX 
 TDM1->DIS 
 TDM1->TDM1, do nothing 
 TDM1->TDM2 
 TDM1->MIX 
 TDM2->DIS 
 TDM2->TDM1 
 TDM2->TDM2, do nothing 
 TDM2->MIX 
 MIX->DIS 
 MIX->TDM1 
 MIX->TDM2 
 MIX->MIX, do nothing 
 Enforce all required TDMs are started 
 Set mix clock 
 Get current state 
	
	  Ensure the current selected mixer clock is available
	  for configuration propagation
 Get current state 
 "From" state 
 "To" state 
 Check if state is changing ... 
	
	  Ensure the current selected mixer clock is available
	  for configuration propagation
 Check state transition constraints 
 Complete transition to new state 
 FSL_AUDMIX_CTR controls 
 TDM1 Attenuation controls 
 TDM2 Attenuation controls 
 AUDMIX is working in DSP_A format only 
 For playback the AUDMIX is consumer, and for record is provider 
 Output data will be written on positive edge of the clock 
 Output data will be written on negative edge of the clock 
 Capture stream shall not be handled 
 sentinel  }
 Get the addresses 
 CONFIG_PM 
 SPDX-License-Identifier: GPL-2.0
 Freescale Generic ASoC Sound Card driver with ASRC
 Copyright (C) 2014 Freescale Semiconductor, Inc.
 Author: Nicolin Chen <nicoleotsuka@gmail.com>
 Default DAI format without Master and Slave flag 
  struct codec_priv - CODEC private data
  @mclk_freq: Clock rate of MCLK
  @free_freq: Clock rate of MCLK for hw_free()
  @mclk_id: MCLK (or main clock) id for set_sysclk()
  @fll_id: FLL (or secordary clock) id for set_sysclk()
  @pll_id: PLL id for set_pll()
  struct cpu_priv - CPU private data
  @sysclk_freq: SYSCLK rates for set_sysclk()
  @sysclk_dir: SYSCLK directions for set_sysclk()
  @sysclk_id: SYSCLK ids for set_sysclk()
  @slot_width: Slot width of each frame
  Note: [1] for tx and [0] for rx
  struct fsl_asoc_card_priv - Freescale Generic ASOC card private data
  @dai_link: DAI link structure including normal one and DPCM link
  @hp_jack: Headphone Jack structure
  @mic_jack: Microphone Jack structure
  @pdev: platform device pointer
  @codec_priv: CODEC private data
  @cpu_priv: CPU private data
  @card: ASoC card structure
  @streams: Mask of current active streams
  @sample_rate: Current sample rate
  @sample_format: Current sample format
  @asrc_rate: ASRC sample rate used by Back-Ends
  @asrc_format: ASRC sample format used by Back-Ends
  @dai_fmt: DAI format between CPU and CODEC
  @name: Card name
  This dapm route map exists for DPCM link only.
  The other routes shall go through Device Tree.
  Note: keep all ASRC routes in the second half
 	 to drop them easily for non-ASRC cases.
 1st half -- Normal DAPM routes 
 2nd half -- ASRC DAPM routes 
 1st half -- Normal DAPM routes 
 2nd half -- ASRC DAPM routes 
 1st half -- Normal DAPM routes 
 2nd half -- ASRC DAPM routes 
 1st half -- Normal DAPM routes 
 2nd half -- ASRC DAPM routes 
 Add all possible widgets into here without being redundant 
 Specific configurations of DAIs starts from here 
 Specific configuration for PLL 
 Force freq to be free_freq to avoid error message in codec 
 Default ASoC DAI Link
 DPCM Link between Front-End and Back-End (Optional) 
	
	  The port numbering in the hardware manual starts at 1, while
	  the AUDMUX API expects it starts at 0.
	
	  Use asynchronous mode (6 wires) for all cases except AC97.
	  If only 4 wires are needed, just set SSI into
	  synchronous mode and enable 4 PADs in IOMUX.
 Asynchronous mode can not be set along with RCLKDIR 
 Disable speaker if headphone is plugged in 
 Disable dmic if microphone is plugged in 
		
		  Use slots 34 for SPDIF so SSI won't try to enable
		  other slots and send some samples there
		  due to SLOTREQ bits for SPDIF received from codec
 Give a chance to old DT binding 
 Get the MCLK rate only, and leave it controlled by CODEC drivers 
 Default sample rate and format, will be updated in hw_params() 
 Assign a default DAI format, and allow each card to overwrite it 
 Diversify the card configurations 
 Format info from DT is optional. 
 Override dai_fmt with value from DT 
 Change direction according to format 
 Common settings for corresponding Freescale CPU DAI driver 
 Only SSI needs to configure AUDMUX 
 Initialize sound card 
 Drop the second half of DAPM routes -- ASRC 
 Normal DAI Link 
 DPCM DAI Links only if ASRC exsits 
 Fallback to old binding; translate to asrc_format 
 Finish card registering 
	
	  Properties "hp-det-gpio" and "mic-det-gpio" are optional, and
	  asoc_simple_init_jack uses these properties for creating
	  Headphone Jack and Microphone Jack.
	 
	  The notifier is initialized in snd_soc_card_jack_new(), then
	  snd_soc_jack_notifier_register can be called.
 SPDX-License-Identifier: GPL-2.0
 Copyright 2018 NXP
QUALITY 2-0 bits 
 Table 5. Quality Modes
  Medium	0 0 0
  High		0 0 1
  Very Low 2	1 0 0
  Very Low 1	1 0 1
  Very Low 0	1 1 0
  Low		1 1 1
 kfactor = 0.5 
 kfactor = 1 
 kfactor = 2 
 kfactor = 4 
 The SRES is a self-negated bit which provides the CPU with the
  capability to initialize the PDM Interface module through the
  slave-bus interface. This bit always reads as zero, and this
  bit is only effective when MDIS is cleared
		 DMA Interrupt Selection - DISEL bits
		  00 - DMA and IRQ disabled
		  01 - DMA req enabled
		  10 - IRQ enabled
		  11 - reserved
 Enable the module 
 Disable the module 
 set CICOSR 
 set CLK_DIV 
 1. Disable the module 
 enable channels 
 set qsel to medium 
 set default gain to max_gain 
 FIFO Watermark Control - FIFOWMK
 REGMAP 
 Write 1 to Clear 
 Write 1 to Clear 
 Write 1 to Clear 
 Write 1 to Clear 
 END OF REGMAP 
 Channel 0-7 Output Data Flags 
		 if DMA is not enabled, field must be written with 1
		  to clear
	 ipg_clk is used to control the registers
	  ipg_clk_app is used to operate the filter
 init regmap 
 dataline mask for RX 
 get IRQs 
 Digital Microphone interface interrupt 
 Digital Microphone interface error interrupt 
	
	  Register platform component before registering cpu dai for there
	  is not defer probe for platform component in snd_soc_add_pcm_runtime().
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2018-2021 NXP
 192kHz32bit2ch60s size is 0x574e00 
 Get current pll parent 
 Switch to another pll parent if needed. 
 sentinel  }
 Get the optional clocks 
 SPDX-License-Identifier: GPL-2.0-only
 Freescale MPC5200 PSC in I2S mode
 ALSA SoC Digital Audio Interface (DAI) driver
 Copyright (C) 2008 Secret Lab Technologies Ltd.
 Copyright (C) 2009 Jon Smirl, Digispeaker
  PSC_I2S_RATES: sample rates supported by the I2S
  This driver currently only supports the PSC running in I2S slave mode,
  which means the codec determines the sample rate.  Therefore, we tell
  ALSA that we support all rates and let the codec driver decide what rates
  are really supported.
  PSC_I2S_FORMATS: audio formats supported by the PSC I2S mode
  psc_i2s_set_sysclk: set the clock frequency and direction
  This function is called by the machine driver to tell us what the clock
  frequency and direction are.
  Currently, we only support operating as a clock slave (SND_SOC_CLOCK_IN),
  and we don't care about the frequency.  Return an error if the direction
  is not SND_SOC_CLOCK_IN.
  @clk_id: reserved, should be zero
  @freq: the frequency of the given clock ID, currently ignored
  @dir: SND_SOC_CLOCK_IN (clock slave) or SND_SOC_CLOCK_OUT (clock master)
  psc_i2s_set_fmt: set the serial format.
  This function is called by the machine driver to tell us what serial
  format to use.
  This driver only supports I2S mode.  Return an error if the format is
  not SND_SOC_DAIFMT_I2S.
  @format: one of SND_SOC_DAIFMT_xxx
 ---------------------------------------------------------------------
  ALSA SoC Bindings
  - Digital Audio Interface (DAI) template
  - createdestroy dai hooks
  psc_i2s_dai_template: template CPU Digital Audio Interface
 ---------------------------------------------------------------------
  OF platform bus binding code:
  - Proberemove operations
  - OF device match table
 Configure the serial interface mode; defaulting to CODEC8 mode 
	 Check for the codec handle.  If it is not present then we
	 Due to errata in the dma mode; need to line up enabling
	  the transmitter with a transition on the frame sync
 first make sure it is low 
 then wait for the transition to high 
	 Finally, enable the PSC.
	  Receiver must always be enabled; even when we only want
 Go 
 Match table for of_platform binding 
 SPDX-License-Identifier: GPL-2.0+
 imx-pcm-fiq.c  --  ALSA Soc Audio Layer
 Copyright 2009 Sascha Hauer <s.hauer@pengutronix.de>
 This code is based on code copyrighted by Freescale,
 Liam Girdwood, Javier Martin and probably others.
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2012 Freescale Semiconductor, Inc.
 Copyright 2012 Linaro Ltd.
	
	  The port numbering in the hardware manual starts at 1, while
	  the audmux API expects it starts at 0.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
 linuxsoundmpc5200-ac97.c -- AC97 support for the Freescale MPC52xx chip.
 Copyright (C) 2009 Jon Smirl, Digispeaker
 Author: Jon Smirl <jonsmirl@gmail.com>
 ALSA only supports a single AC97 device so static is recommend here 
 Wait for command send status zero = ready 
 Force clear the data valid bit 
 Send the read 
 Wait for the answer 
 Get the data 
 Wait for command status zero = ready 
 Write data 
 Notify the PSC that a reset has occurred 
 Re-enable RX and TX 
 Determine the set of enable bits to turn on 
 Set the slot enable bits 
 Clear the slot enable bits 
 Go 
 ---------------------------------------------------------------------
  ALSA SoC Bindings
  - Digital Audio Interface (DAI) template
  - createdestroy dai hooks
  psc_ac97_dai_template: template CPU Digital Audio Interface
 ---------------------------------------------------------------------
  OF platform bus binding code:
  - Proberemove operations
  - OF device match table
 Configure the serial interface mode to AC97 
 No slots active 
 Match table for of_platform binding 
 SPDX-License-Identifier: GPL-2.0
 Freescale DMA ALSA SoC PCM driver
 Author: Timur Tabi <timur@freescale.com>
 Copyright 2007-2010 Freescale Semiconductor, Inc.
 This driver implements ASoC support for the Elo DMA controller, which is
 the DMA controller on Freescale 83xx, 85xx, and 86xx SOCs. In ALSA terms,
 the PCM driver is what handles the DMA buffer.
 For the offset of stx0 and srx0 
  The formats that the DMA controller supports, which is anything
  that is 8, 16, or 32 bits.
  The number of DMA links to use.  Two is the bare minimum, but if you
  have really small links you might need more.
 fsl_dma_private: p-substream DMA data
  Each substream has a 1-to-1 association with a DMA channel.
  The link[] array is first because it needs to be aligned on a 32-byte
  boundary, so putting it first will ensure alignment without padding the
  structure.
  @link[]: array of link descriptors
  @dma_channel: pointer to the DMA channel's registers
  @irq: IRQ for this DMA channel
  @substream: pointer to the substream object, needed by the ISR
  @ssi_sxx_phys: bus address of the STX or SRX register to use
  @ld_buf_phys: physical address of the LD buffer
  @current_link: index into link[] of the link currently being processed
  @dma_buf_phys: physical address of the DMA buffer
  @dma_buf_next: physical address of the next period to process
  @dma_buf_end: physical address of the byte after the end of the DMA
  @buffer period_size: the size of a single period
  @num_periods: the number of periods in the DMA buffer
  fsl_dma_hardare: define characteristics of the PCM hardware.
  The PCM hardware is the Freescale DMA controller.  This structure defines
  the capabilities of that hardware.
  Since the sampling rate and data format are not controlled by the DMA
  controller, we specify no limits for those values.  The only exception is
  period_bytes_min, which is set to a reasonably low value to prevent the
  DMA controller from generating too many interrupts per second.
  Since each link descriptor has a 32-bit byte count field, we set
  period_bytes_max to the largest 32-bit number.  We also have no maximum
  number of periods.
  Note that we specify SNDRV_PCM_INFO_JOINT_DUPLEX here, but only because a
  limitation in the SSI driver requires the sample rates for playback and
  capture to be the same.
 A reasonable limit 
 A reasonable limit 
  fsl_dma_abort_stream: tell ALSA that the DMA transfer has aborted
  This function should be called by the ISR whenever the DMA controller
  halts data transfer.
  fsl_dma_update_pointers - update LD pointers to point to the next period
  As each period is completed, this function changes the link
  descriptor pointers for that period to point to the next period.
	 Update our link descriptors to point to the next period. On a 36-bit
	  system, we also need to update the ESAD bits.  We also set (keep) the
	  snoop bits.  See the comments in fsl_dma_hw_params() about snooping.
 Update our variables for next time 
  fsl_dma_isr: interrupt handler for the DMA controller
  @irq: IRQ of the DMA channel
  @dev_id: pointer to the dma_private structure for this DMA channel
	 We got an interrupt, so read the status register to see what we
	   were interrupted for.
 Tell ALSA we completed a period. 
		
		  Update our link descriptors to point to the next period. We
		  only need to do this if the number of periods is not equal to
		  the number of links.
 Clear the bits that we set 
  fsl_dma_new: initialize this PCM driver.
  This function is called when the codec driver calls snd_soc_new_pcms(),
  once for each .dai_link in the machine driver's snd_soc_card
  structure.
  snd_dma_alloc_pages() is just a front-end to dma_alloc_coherent(), which
  (currently) always allocates the DMA buffer in lowmem, even if GFP_HIGHMEM
  is specified. Therefore, any DMA buffers we allocate will always be in low
  memory, but we support for 36-bit physical addresses anyway.
  Regardless of where the memory is actually allocated, since the device can
  technically DMA to any 36-bit address, we do need to set the DMA mask to 36.
  fsl_dma_open: open a new substream.
  Each substream has its own DMA buffer.
  ALSA divides the DMA buffer into N periods.  We create NUM_DMA_LINKS link
  descriptors that ping-pong from one period to the next.  For example, if
  there are six periods and two link descriptors, this is how they look
  before playback starts:
       	   The last link descriptor
    ____________  points back to the first
   |   	 |
   V   	 |
   ___    ___   |
  |   |->|   |->|
  |___|  |___|
    |      |
    |      |
    V      V
   _________________________________________
  |      |      |      |      |      |      |  The DMA buffer is
  |      |      |      |      |      |      |    divided into 6 parts
  |______|______|______|______|______|______|
  and here's how they look after the first period is finished playing:
    ____________
   |   	 |
   V   	 |
   ___    ___   |
  |   |->|   |->|
  |___|  |___|
    |      |
    |______________
           |       |
           V       V
   _________________________________________
  |      |      |      |      |      |      |
  |      |      |      |      |      |      |
  |______|______|______|______|______|______|
  The first link descriptor now points to the third period.  The DMA
  controller is currently playing the second period.  When it finishes, it
  will jump back to the first descriptor and play the third period.
  There are four reasons we do this:
  1. The only way to get the DMA controller to automatically restart the
     transfer when it gets to the end of the buffer is to use chaining
     mode.  Basic direct mode doesn't offer that feature.
  2. We need to receive an interrupt at the end of every period.  The DMA
     controller can generate an interrupt at the end of every link transfer
     (aka segment).  Making each period into a DMA segment will give us the
     interrupts we need.
  3. By creating only two link descriptors, regardless of the number of
     periods, we do not need to reallocate the link descriptors if the
     number of periods changes.
  4. All of the audio data is still stored in a single, contiguous DMA
     buffer, which is what ALSA expects.  We're just dividing it into
     contiguous parts, and creating a link descriptor for each one.
 Pointer to next link descriptor 
	
	  Reject any DMA buffer whose size is not a multiple of the period
	  size.  We need to make sure that the DMA buffer can be evenly divided
	  into periods.
 Program the fixed DMA controller parameters 
 The last link descriptor points to the first 
 Tell the DMA controller where the first link descriptor is 
 The manual says the BCR must be clear before enabling EMP 
	
	  Program the mode register for interrupts, external master control,
	  and sourcedestination hold.  Also clear the Channel Abort bit.
	
	  We want External Master Start and External Master Pause enabled,
	  because the SSI is controlling the DMA controller.  We want the DMA
	  controller to be set up in advance, and then we signal only the SSI
	  to start transferring.
	 
	  We want End-Of-Segment Interrupts enabled, because this will generate
	  an interrupt at the end of each segment (each link descriptor
	  represents one segment).  Each DMA segment is the same thing as an
	  ALSA period, so this is how we get an interrupt at the end of every
	  period.
	 
	  We want Error Interrupt enabled, so that we can get an error if
	  the DMA controller is mis-programmed somehow.
	 For playback, we want the destination address to be held.  For
  fsl_dma_hw_params: continue initializing the DMA links
  This function obtains hardware parameters about the opened stream and
  programs the DMA controller accordingly.
  One drawback of big-endian is that when copying integers of different
  sizes to a fixed-sized register, the address to which the integer must be
  copied is dependent on the size of the integer.
  For example, if P is the address of a 32-bit register, and X is a 32-bit
  integer, then X should be copied to address P.  However, if X is a 16-bit
  integer, then it should be copied to P+2.  If X is an 8-bit register,
  then it should be copied to P+3.
  So for playback of 8-bit samples, the DMA controller must transfer single
  bytes from the DMA buffer to the last byte of the STX0 register, i.e.
  offset by 3 bytes. For 16-bit samples, the offset is two bytes.
  For 24-bit samples, the offset is 1 byte.  However, the DMA controller
  does not support 3-byte copies (the DAHTS register supports only 1, 2, 4,
  and 8 bytes at a time).  So we do not support packed 24-bit samples.
  24-bit data must be padded to 32 bits.
 Number of bits per sample 
 Number of bytes per frame 
 Bus address of SSI STX register 
 Size of the DMA buffer, in bytes 
 Number of bytes per period 
 Pointer to next period 
 Pointer to DMA controller 
 DMA Mode Register 
 Initialize our DMA tracking variables 
 This happens if the number of periods == NUM_DMA_LINKS 
	 Due to a quirk of the SSI's STX register, the target address
	  for the DMA operations depends on the sample size.  So we calculate
	  that offset here.  While we're at it, also tell the DMA controller
	  how much data to transfer per sample.
 We should never get here 
	
	  BWC determines how many bytes are sentreceived before the DMA
	  controller checks the SSI to see if it needs to stop. BWC should
	  always be a multiple of the frame size, so that we always transmit
	  whole frames.  Each frame occupies two slots in the FIFO.  The
	  parameter for CCSR_DMA_MR_BWC() is rounded down the next power of two
	  (MR[BWC] can only represent even powers of two).
	 
	  To simplify the process, we set BWC to the largest value that is
	  less than or equal to the FIFO watermark.  For playback, this ensures
	  that we transfer the maximum amount without overrunning the FIFO.
	  For capture, this ensures that we transfer the maximum amount without
	  underrunning the FIFO.
	 
	  f = SSI FIFO depth
	  w = SSI watermark value (which equals f - 2)
	  b = DMA bandwidth count (in bytes)
	  s = sample size (in bytes, which equals frame_size  2)
	 
	  For playback, we never transmit more than the transmit FIFO
	  watermark, otherwise we might write more data than the FIFO can hold.
	  The watermark is equal to the FIFO depth minus two.
	 
	  For capture, two equations must hold:
	 	w > f - (b  s)
	 	w >= b  s
	 
	  So, b > 2  s, but b must also be <= s  w.  To simplify, we set
	  b = s  w, which is equal to
	       (dma_private->ssi_fifo_depth - 2)  sample_bytes.
		 The snoop bit tells the DMA controller whether it should tell
		  the ECM to snoop during a read or write to an address. For
		  audio, we use DMA to transfer data between memory and an IO
		  device (the SSI's STX0 or SRX0 register). Snooping is only
		  needed if there is a cache, so we need to snoop memory
		  addresses only.  For playback, that means we snoop the source
		  but not the destination.  For capture, we snoop the
		  destination but not the source.
		 
		  Note that failing to snoop properly is unlikely to cause
		  cache incoherency if the period size is larger than the
		  size of L1 cache.  This is because filling in one period will
		  flush out the data for the previous period.  So if you
		  increased period_bytes_min to a large enough size, you might
		  get more performance by not snooping, and you'll still be
		  okay.  You'll need to update fsl_dma_update_pointers() also.
  fsl_dma_pointer: determine the current position of the DMA transfer
  This function is called by ALSA when ALSA wants to know where in the
  stream buffer the hardware currently is.
  For playback, the SAR register contains the physical address of the most
  recent DMA transfer.  For capture, the value is in the DAR register.
  The base address of the buffer is stored in the source_addr field of the
  first link descriptor.
	 Obtain the current DMA pointer, but don't read the ESAD bits if we
	  only have 32-bit DMA addresses.  This function is typically called
	  in interrupt context, so we need to optimize it.
	
	  When capture is started, the SSI immediately starts to fill its FIFO.
	  This means that the DMA controller is not started until the FIFO is
	  full.  However, ALSA calls this function before that happens, when
	  MR.DAR is still zero.  In this case, just return zero to indicate
	  that nothing has been received yet.
	
	  If the current address is just past the end of the buffer, wrap it
	  around.
  fsl_dma_hw_free: release resources allocated in fsl_dma_hw_params()
  Release the resources allocated in fsl_dma_hw_params() and de-program the
  registers.
  This function can be called multiple times.
 Stop the DMA 
 Reset all the other registers 
  fsl_dma_close: close the stream.
 Deallocate the fsl_dma_private structure 
  find_ssi_node -- returns the SSI node that points to its DMA channel node
  Although this DMA driver attempts to operate independently of the other
  devices, it still needs to determine some information about the SSI device
  that it's working with.  Unfortunately, the device tree does not contain
  a pointer from the DMA channel node to the SSI node -- the pointer goes the
  other way.  So we need to scan the device tree for SSI nodes until we find
  the one that points to the given DMA channel node.  It's ugly, but at least
  it's contained in this one function.
		 Check each DMA phandle to see if it points to us.  We
		  assume that device_node pointers are a valid comparison.
 Find the SSI node that points to us. 
 Store the SSI-specific information that we need 
 Older 8610 DTs didn't have the fifo-depth property 
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2017-2021 NXP
  Mapping LRCK fs and frame width, table 3 & 4 in datasheet
  @rmin: min rate
  @rmax: max rate
  @wmin: min frame ratio
  @wmax: max frame ratio
  Mapping TDM mode and frame width
  struct imx_card_plat_data - specific info for codecs
  @fs_mul: ratio of mclkfs for normal mode
  @tdm_fs_mul: ratio of mclkfs for tdm mode
  @support_rates: supported sample rate
  @support_tdm_rates: supported sample rate for tdm mode
  @support_channels: supported channels
  @support_tdm_channels: supported channels for tdm mode
  @num_fs_mul: ARRAY_SIZE of fs_mul
  @num_tdm_fs_mul: ARRAY_SIZE of tdm_fs_mul
  @num_rates: ARRAY_SIZE of support_rates
  @num_tdm_rates: ARRAY_SIZE of support_tdm_rates
  @num_channels: ARRAY_SIZE of support_channels
  @num_tdm_channels: ARRAY_SIZE of support_tdm_channels
  @type: codec type
  struct dai_link_data - specific info for dai link
  @slots: slot number
  @slot_width: slot width value
  @cpu_sysclk_id: sysclk id for cpu dai
  @one2one_ratio: true if mclk equal to bclk
  struct imx_card_data - platform device data
  @plat_data: pointer of imx_card_plat_data
  @dapm_routes: pointer of dapm_routes
  @link_data: private data for dai link
  @card: card instance
  @num_dapm_routes: number of dapm_routes
  @asrc_rate: asrc rates
  @asrc_format: asrc format
 Normal, < 32kHz 
 Normal, 32kHz 
 Normal 
 Double 
 Quad 
 Oct 
 Hex 
	
	  Table 13	- Audio Interface Format
	  For TDM mode, MCLK should is set to
	  obtained from 2  slots  slot_width
 TDM128 
 TDM256 
 TDM512 
	
	  Table 7      - mapping multiplier and speed mode
	  Tables 8 & 9 - mapping speed mode and LRCK fs
 Normal, <= 32kHz 
 Normal 
 Double 
 Quad 
 Oct 
 Hex 
  Auto MCLK selection based on LRCK for Normal Mode
  (Table 4 from datasheet)
  MCLK and BCLK selection based on TDM mode
  because of SAI we also add the restriction: MCLK >= 2  BCLK
  (Table 9 from datasheet)
 min = max = slots  slots_width 
 Adjust SAI bclk:mclk ratio 
 Let DAI manage clk frequency by default 
 Set MCLK freq 
 Use the maximum freq from DSD512 (51244100 = 22579200) 
 Identify maximum supported rate 
 Adjust SAI bclk:mclk ratio 
 Skip rates for which MCLK is beyond supported value 
 DAPM routes 
 Populate links 
 Allocate the DAI link array 
 sai sysclk id 
 sai may support mclkbclk = 1 
 Check the akcodec type 
 DPCM frontend 
 Fallback to old binding; translate to asrc_format 
 DPCM backend 
 Get dai fmt 
 Get tdm slot 
 default value 
 configure the dapm routes 
 default platform data for akcodecs 
 with asrc as front end 
 SPDX-License-Identifier: GPL-2.0
 Freescale SSI ALSA SoC Digital Audio Interface (DAI) debugging functions
 Copyright 2014 Markus Pargmann <mpa@pengutronix.de>, Pengutronix
 Split from fsl_ssi.c
  Show the statistics of a flag only if its interrupt is enabled
  Compilers will optimize it to a no-op if the interrupt is disabled
  Display the statistics for the current SSI device
  To avoid confusion, only show those counts that are enabled
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2017-2020 NXP
 rpmsg_pdev is the platform device for the rpmsg node that probed us 
 Optional codec node 
	
	  Inoder to use common api to get card name and audio routing.
	  Use parent of_node for this device, revert it after finishing using
 SPDX-License-Identifier: GPL-2.0
 Freescale ASRC ALSA SoC Digital Audio Interface (DAI) driver
 Copyright (C) 2014 Freescale Semiconductor, Inc.
 Author: Nicolin Chen <nicoleotsuka@gmail.com>
 Corresponding to process_option 
  The following tables map the relationship between asrc_inclkasrc_outclk in
  fsl_asrc.h and the registers of ASRCSR
 i.MX53 uses the same map for input and output 
	0x0  0x1  0x2  0x3  0x4  0x5  0x6  0x7  0x8  0x9  0xa  0xb  0xc  0xd  0xe  0xf 
	0x0  0x1  0x2  0x3  0x4  0x5  0x6  0x7  0x8  0x9  0xa  0xb  0xc  0xd  0xe  0xf 
  i.MX8QMi.MX8QXP uses the same map for input and output.
  clk_map_imx8qm[0] is for i.MX8QM asrc0
  clk_map_imx8qm[1] is for i.MX8QM asrc1
  clk_map_imx8qxp[0] is for i.MX8QXP asrc0
  clk_map_imx8qxp[1] is for i.MX8QXP asrc1
  fsl_asrc_sel_proc - Select the pre-processing and post-processing options
  @inrate: input sample rate
  @outrate: output sample rate
  @pre_proc: return value for pre-processing option
  @post_proc: return value for post-processing option
  Make sure to exclude following unsupported cases before
  calling this function:
  1) inrate > 8.125  outrate
  2) inrate > 16.125  outrate
 select pre_proc between [0, 2] 
 Condition for selection of post-processing 
  fsl_asrc_request_pair - Request ASRC pair
  @channels: number of channels
  @pair: pointer to pair
  It assigns pair by the order of A->C->B because allocation of pair B,
  within range [ANCA, ANCA+ANCB-1], depends on the channels of pair A
  while pair A and pair C are comparatively independent.
  fsl_asrc_release_pair - Release ASRC pair
  @pair: pair to release
  It clears the resource from asrc and releases the occupied channels.
 Make sure the pair is disabled 
  fsl_asrc_set_watermarks- configure input and output thresholds
  @pair: pointer to pair
  @in: input threshold
  @out: output threshold
  fsl_asrc_cal_asrck_divisor - Calculate the total divisor between asrck clock rate and sample rate
  @pair: pointer to pair
  @div: divider
  It follows the formula clk_rate = samplerate  (2 ^ prescaler)  divider
 Calculate the divisors: prescaler [2^0, 2^7], divder [1, 8] 
  fsl_asrc_set_ideal_ratio - Calculate and set the ratio for Ideal Ratio mode only
  @pair: pointer to pair
  @inrate: input rate
  @outrate: output rate
  The ratio is a 32-bit fixed point value with 26 fractional bits.
 Calculate the intergal part of the ratio 
 ... and then the 26 depth decimal part 
  fsl_asrc_config_pair - Configure the assigned ASRC pair
  @pair: pointer to pair
  @use_ideal_rate: boolean configuration
  It configures those ASRC registers according to a configuration instance
  of struct asrc_config which includes inoutput sample rate, width, channel
  and clock settings.
  Note:
  The ideal ratio configuration can work with a flexible clock rate setting.
  Using IDEAL_RATIO_RATE gives a faster converting speed but overloads ASRC.
  For a regular audio playback, the clock rate should not be slower than an
  clock rate aligning with the output sample rate; For a use case requiring
  faster conversion, set use_ideal_rate to have the faster speed.
 Validate channels 
 Validate input and output sample rates 
 Validate input and output clock sources 
 We only have output clock for ideal ratio mode 
	
	  The divider range is [1, 1024], defined by the hardware. For non-
	  ideal ratio configuration, clock rate has to be strictly aligned
	  with the sample rate. For ideal ratio configuration, clock rates
	  only result in different converting speeds. So remainder does not
	  matter, as long as we keep the divider within its valid range.
 Output divider has the same limitation as the input one 
 Set the channel number 
 Update channels for current pair 
 Default setting: Automatic selection for processing mode 
 Set the input and output clock sources 
 Calculate the input clock divisors 
 Suppose indiv and outdiv includes prescaler, so add its MASK too 
 Implement word_width configurations 
 Enable BUFFER STALL 
 Set default thresholds for input and output FIFO 
 Configure the following only for Ideal Ratio mode 
 Clear ASTSx bit to use Ideal Ratio mode 
 Enable Ideal Ratio mode 
 Apply configurations for pre- and post-processing 
  fsl_asrc_start_pair - Start the assigned ASRC pair
  @pair: pointer to pair
  It enables the assigned pair and makes it stopped at the stall level.
 Enable the current pair 
 Wait for status of initialization 
 Make the input fifo to ASRC STALL level 
 Enable overload interrupt 
  fsl_asrc_stop_pair - Stop the assigned ASRC pair
  @pair: pointer to pair
 Stop the current pair 
  fsl_asrc_get_dma_channel- Get DMA channel according to the pair and direction.
  @pair: pointer to pair
  @dir: DMA direction
 Odd channel number is not valid for older ASRC (channel_bits==3) 
 Select proper clock source for internal ratio mode 
 Array size 2 means IN and OUT 
 Select proper clock source for internal ratio mode 
 Only match a perfect clock source with no remainder 
 Switch to ideal ratio mode if there is no proper clock source 
  fsl_asrc_init - Initialize ASRC registers with a default configuration
  @asrc: ASRC context
 Halt ASRC internal FP when input FIFO needs data for pair A, B, C 
 Disable interrupt by default 
 Apply recommended settings for parameters from Reference Manual 
 Base address for task queue FIFO. Set to 0x7C 
	
	  Set the period of the 76KHz and 56KHz sampling clocks based on
	  the ASRC processing clock.
	  On iMX6, ipg_clk = 133MHz, REG_ASR76K = 0x06D6, REG_ASR56K = 0x0947
  fsl_asrc_isr- Interrupt handler for ASRC
  @irq: irq number
  @dev_id: ASRC context
 Clean overload error 
	
	  We here use dev_dbg() for all exceptions because ASRC itself does
	  not care if FIFO overflowed or underrun while a warning in the
	  interrupt would result a ridged conversion.
 Get the addresses and IRQ 
 Stop all pairs provisionally 
 Restore all registers 
 Restart enabled pairs 
 SPDX-License-Identifier: GPL-2.0+
 Copyright (C) 2013 Freescale Semiconductor, Inc.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
 Freescale P1022DS ALSA SoC Machine driver
 Author: Timur Tabi <timur@freescale.com>
 Copyright 2010 Freescale Semiconductor, Inc.
 P1022-specific PMUXCR and DMUXCR bit definitions 
 DMA controllerchannel set to pad 
 DMA controllerchannel set to SSI 
  Set the DMACR register in the GUTS
  The DMACR register determines the source of initiated transfers for each
  channel on each DMA controller.  Rather than have a bunch of repetitive
  macros for the bit patterns, we just have a function that calculates
  them.
  guts: Pointer to GUTS structure
  co: The DMA controller (0 or 1)
  ch: The channel on the DMA controller (0, 1, 2, or 3)
  device: The device to set as the target (CCSR_GUTS_DMUXCR_xxx)
 There's only one global utilities register 
  machine_data: machine-specific ASoC device data
  This structure contains data for a single sound platform device on an
  P1022 DS.  Some of the data is taken from the device tree.
 0 = SSI1, 1 = SSI2, etc 
 0 = DMA1, 1 = DMA2, etc 
 0 = ch 0, 1 = ch 1, etc
 One for each DMA channel 
  p1022_ds_machine_probe: initialize the board
  This function is used to initialize the board-specific hardware.
  Here we program the DMACR and PMUXCR registers.
 Enable SSI Tx signal 
 Enable SSI Rx signal 
 Enable DMA Channel for SSI 
  p1022_ds_startup: program the board with various hardware parameters
  This function takes board-specific information, like clock frequencies
  and serial data formats, and passes that information to the codec and
  transport drivers.
 Tell the codec driver what the serial protocol is. 
	
	  Tell the codec driver what the MCLK frequency is, and whether it's
	  a slave or master.
  p1022_ds_machine_remove: Remove the sound device
  This function is called to remove the sound device for one SSI.  We
  de-program the DMACR and PMUXCR register.
 Restore the signal routing 
  p1022_ds_ops: ASoC machine driver operations
  p1022_ds_probe: platform probe function for the machine driver
  Although this is a machine driver, the SSI node is the "master" node with
  respect to audio hardware connections.  Therefore, we create a new ASoC
  device for each new SSI node that has a codec attached.
 ssi_pdev is the platform device for the SSI node that probed us 
 Find the codec node for this SSI. 
 ASoC core can match codec with device node 
	 We register two DAIs per SSI, one for playback and the other for
	  capture.  We support codecs that have separate DAIs for both playback
	  and capture.
 The DAI names from the codec (snd_soc_dai_driver.name) 
 Get the device ID 
 Get the serial format and clock direction. 
		 In i2s-slave mode, the codec has its own clock source, so we
		  need to get the frequency from the device tree and pass it to
		  the codec driver.
 Find the playback DMA channel to use. 
 Find the capture DMA channel to use. 
 Initialize our DAI data structure.  
 The platform driver name 
 Register with ASoC 
  p1022_ds_remove: remove the platform device
  This function is called when the platform device is removed.
		
		  The name must match 'compatible' property in the device tree,
		  in lowercase letters.
  p1022_ds_init: machine driver initialization.
  This function is called when this module is loaded.
 Get the physical address of the global utilities registers 
  p1022_ds_exit: machine driver exit
  This function is called when this driver is unloaded.
 SPDX-License-Identifier: GPL-2.0
  Copyright 2017 NXP
  The code contained herein is licensed under the GNU General Public
  License. You may obtain a copy of the GNU General Public License
  Version 2 or later at the following locations:
  https:www.opensource.orglicensesgpl-license.html
  https:www.gnu.orgcopyleftgpl.html
 For playback the AUDMIX is consumer, and for record is provider 
 set DAI configuration 
	
	  Per datasheet, AUDMIX expects 8 slots and 32 bits
	  for every slot in TDM mode.
 For playback the AUDMIX is consumer 
 set AUDMIX DAI configuration 
 for CPUCodecPlatform x 2 
 Add AUDMIX Backend 
 SPDX-License-Identifier: GPL-2.0
 Freescale P1022RDK ALSA SoC Machine driver
 Author: Timur Tabi <timur@freescale.com>
 Copyright 2012 Freescale Semiconductor, Inc.
 Note: in order for audio to work correctly, the output controls need
 to be enabled, because they control the clock.  So for playback, for
 example:
      amixer sset 'Left Output Mixer PCM' on
      amixer sset 'Right Output Mixer PCM' on
 P1022-specific PMUXCR and DMUXCR bit definitions 
 DMA controllerchannel set to pad 
 DMA controllerchannel set to SSI 
  Set the DMACR register in the GUTS
  The DMACR register determines the source of initiated transfers for each
  channel on each DMA controller.  Rather than have a bunch of repetitive
  macros for the bit patterns, we just have a function that calculates
  them.
  guts: Pointer to GUTS structure
  co: The DMA controller (0 or 1)
  ch: The channel on the DMA controller (0, 1, 2, or 3)
  device: The device to set as the target (CCSR_GUTS_DMUXCR_xxx)
 There's only one global utilities register 
  machine_data: machine-specific ASoC device data
  This structure contains data for a single sound platform device on an
  P1022 RDK.  Some of the data is taken from the device tree.
 0 = DMA1, 1 = DMA2, etc 
 0 = ch 0, 1 = ch 1, etc
 One for each DMA channel 
  p1022_rdk_machine_probe: initialize the board
  This function is used to initialize the board-specific hardware.
  Here we program the DMACR and PMUXCR registers.
 Enable SSI Tx signal 
 Enable SSI Rx signal 
 Enable DMA Channel for SSI 
  p1022_rdk_startup: program the board with various hardware parameters
  This function takes board-specific information, like clock frequencies
  and serial data formats, and passes that information to the codec and
  transport drivers.
 Tell the codec driver what the serial protocol is. 
  p1022_rdk_machine_remove: Remove the sound device
  This function is called to remove the sound device for one SSI.  We
  de-program the DMACR and PMUXCR register.
 Restore the signal routing 
  p1022_rdk_ops: ASoC machine driver operations
  p1022_rdk_probe: platform probe function for the machine driver
  Although this is a machine driver, the SSI node is the "master" node with
  respect to audio hardware connections.  Therefore, we create a new ASoC
  device for each new SSI node that has a codec attached.
 ssi_pdev is the platform device for the SSI node that probed us 
 Find the codec node for this SSI. 
 ASoC core can match codec with device node 
	
	  We register two DAIs per SSI, one for playback and the other for
	  capture.  We support codecs that have separate DAIs for both playback
	  and capture.
 The DAI names from the codec (snd_soc_dai_driver.name) 
	
	  Configure the SSI for I2S slave mode.  Older device trees have
	  an fsl,mode property, but we ignore that since there's really
	  only one way to configure the SSI.
	
	  In i2s-slave mode, the codec has its own clock source, so we
	  need to get the frequency from the device tree and pass it to
	  the codec driver.
 Find the playback DMA channel to use. 
 Find the capture DMA channel to use. 
 Initialize our DAI data structure.  
 The platform driver name 
 Register with ASoC 
  p1022_rdk_remove: remove the platform device
  This function is called when the platform device is removed.
		
		  The name must match 'compatible' property in the device tree,
		  in lowercase letters.
  p1022_rdk_init: machine driver initialization.
  This function is called when this module is loaded.
 Get the physical address of the global utilities registers 
  p1022_rdk_exit: machine driver exit
  This function is called when this driver is unloaded.
 SPDX-License-Identifier: GPL-2.0
 Freescale ESAI ALSA SoC Digital Audio Interface (DAI) driver
 Copyright (C) 2014 Freescale Semiconductor, Inc.
  struct fsl_esai_soc_data - soc specific data
  @reset_at_xrun: flags for enable reset operaton
  struct fsl_esai - ESAI private data
  @dma_params_rx: DMA parameters for receive channel
  @dma_params_tx: DMA parameters for transmit channel
  @pdev: platform device pointer
  @regmap: regmap handler
  @coreclk: clock source to access register
  @extalclk: esai clock source to derive HCK, SCK and FS
  @fsysclk: system clock source to derive HCK, SCK and FS
  @spbaclk: SPBA clock (optional, depending on SoC design)
  @work: work to handle the reset operation
  @soc: soc specific data
  @lock: spin lock between hw_reset() and trigger()
  @fifo_depth: depth of txrx FIFO
  @slot_width: width of each DAI slot
  @slots: number of slots
  @tx_mask: slot mask for TX
  @rx_mask: slot mask for RX
  @channels: channel num for tx or rx
  @hck_rate: clock rate of desired HCKx clock
  @sck_rate: clock rate of desired SCKx clock
  @hck_dir: the direction of HCKx pads
  @sck_div: if using PSRPM dividers for SCKx clock
  @consumer_mode: if fully using DAI clock consumer mode
  @synchronous: if using txrx synchronous mode
  @name: driver name
 Protect hw_reset and trigger 
  fsl_esai_divisor_cal - This function is used to calculate the
  divisors of psr, pm, fp and it is supposed to be called in
  set_dai_sysclk() and set_bclk().
  @dai: pointer to DAI
  @tx: current setting is for playback or capture
  @ratio: desired overall ratio for the paticipating dividers
  @usefp: for HCK setting, there is no need to set fp divider
  @fp: bypass other dividers by setting fp directly if fp != 0
 Do not loop-search if PM (1 ~ 256) alone can serve the ratio 
 Set the max fluctuation -- 0.1% of the max devisor 
 Find the best value for PM 
 PSR (1 or 8)  PM (1 ~ 256)  FP (1 ~ 16) 
 Calculate the fraction 
 We are lucky 
 Bypass fp if not being required 
  fsl_esai_set_dai_sysclk - configure the clock frequency of MCLK (HCKTHCKR)
  @dai: pointer to DAI
  @clk_id: The clock source of HCKTHCKR
 	  (Input from outside; output from inside, FSYS or EXTAL)
  @freq: The required clock rate of HCKTHCKR
  @dir: The clock direction of HCKTHCKR
  Note: If the direction is input, we do not care about clk_id.
 Bypass divider settings if the requirement doesn't change 
 sck_div can be only bypassed if ETOERO=0 and SNC_SOC_CLOCK_OUT 
 Set the direction of HCKTHCKR pins 
 Block if clock source can not be divided into the required rate 
 Only EXTAL source can be output directly without using PSR and PM 
 Bypass all the dividers if not being needed 
 The ratio should be no less than 2 if using other sources 
  fsl_esai_set_bclk - configure the related dividers according to the bclk rate
  @dai: pointer to DAI
  @tx: direction boolean
  @freq: bclk freq
 Don't apply for fully consumer mode or unchanged bclk 
 Block if clock source can not be divided into the required rate 
 The ratio should be contented by FP alone if bypassing PM and PSR 
 Save current bclk rate 
 DAI mode 
 Data on rising edge of bclk, frame low, 1clk before data 
 Data on rising edge of bclk, frame high 
 Data on rising edge of bclk, frame high, right aligned 
 Data on rising edge of bclk, frame high, 1clk before data 
 Data on rising edge of bclk, frame high 
 DAI clock inversion 
 Nothing to do for both normal cases 
 Invert bit clock 
 Invert frame clock 
 Invert both clocks 
 DAI clock provider masks 
 Set synchronous mode 
 Set slots count 
 Override slot_width if being specifically set 
 Recording in synchronous mode needs to set TCR also 
 Use Normal mode to support monaural audio 
 Remove ESAI personal reset by configuring ESAI_PCRC and ESAI_PRRC 
 Reset ESAI unit 
	
	  We need to enable ESAI so as to access some of its registers.
	  Otherwise, we would fail to dump regmap from user space.
 FIFO reset for safety 
 FIFO reset done 
 Write initial words reqiured by ESAI as normal procedure 
	
	  When set the TERE in the end of enablement flow, there
	  will be channel swap issue for multi data line case.
	  In order to workaround this issue, we switch the bit
	  enablement sequence to below sequence
	  1) clear the xSMB & xSMA: which is done in probe and
	                            stop state.
	  2) set TERE
	  3) set xSMB
	  4) set xSMA:  xSMA is the last one in this flow, which
	                will trigger esai to start.
 Enable Exception interrupt 
 Disable and reset FIFO 
 Save the registers 
 Stop the tx & rx 
 Reset the esai, and ignore return value 
 Enforce ESAI personal resets for both TX and RX 
 Restore registers by regcache_sync, and ignore return value 
 Remove ESAI personal resets by configuring PCRC and PRRC also 
 Restart tx  rx, if they already enabled 
 Get the addresses and IRQ 
 Set a default slot number 
 Set a default clock provider state 
 Determine the FIFO depth 
 Implement full symmetry for synchronous mode 
 Clear the TSMA, TSMB, RSMA, RSMB 
	
	  Register platform component before registering cpu dai for there
	  is not defer probe for platform component in snd_soc_add_pcm_runtime().
	
	  Some platforms might use the same bit to gate all three or two of
	  clocks, so keep all clocks openclose at the same time for safety
  ALSA SoC SPDIF In Audio Layer for spear processors
  Copyright (C) 2012 ST Microelectronics
  Vipin Kumar <vipin.kumar@st.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  ALSA SoC SPDIF Out Audio Layer for spear processors
  Copyright (C) 2012 ST Microelectronics
  Vipin Kumar <vipin.kumar@st.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
		
		  The clock is multiplied by 10 to bring it to feasible range
		  of frequencies for sscg
 81.92 MHz 
 22.5792 MHz 
 24.576 MHz 
  ALSA PCM interface for ST SPEAr Processors
  soundsocspearspear_pcm.c
  Copyright (C) 2012 ST Microelectronics
  Rajeev Kumar<rajeevkumar.linux@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 max buffer size 
 1 msec data minimum period size 
 maximum period size 
 min # periods 
 max # of periods 
 fifo size in bytes 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) ST-Ericsson SA 2012
  Author: Ola Lilja <ola.o.lilja@stericsson.com>,
          Roger Nilsson <roger.xr.nilsson@stericsson.com>
          for ST-Ericsson.
  License terms:
 To avoid division by zero 
 Enable regulator 
 Prepare and enable clocks 
 Disable and unprepare clocks 
 Disable regulator 
 Set OPP-level 
		 If the bit-clock is higher than 19.2MHz, Vape should be
		  run in 100% OPP. Only when bit-clock is used (MSP master)
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) ST-Ericsson SA 2012
  Author: Ola Lilja (ola.o.lilja@stericsson.com)
          for ST-Ericsson.
  License terms:
 Define the whole MOP500 soundcard, linking platform to the codec-drivers  
 Both links use the same codec, which is refcounted only once 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) ST-Ericsson SA 2012
  Author: Ola Lilja <ola.o.lilja@stericsson.com>,
          Roger Nilsson <roger.xr.nilsson@stericsson.com>,
          Sandeep Kaushik <sandeep.kaushik@st.com>
          for ST-Ericsson.
  License terms:
 Protocol desciptors 
 I2S 
 PCM 
 Companded PCM 
 The code below should not be separated. 
 Enable bit-clock 
 Configure msp with protocol dependent settings 
 Make sure the correct DMA-directions are configured 
 Enable frame generation logic 
 First do the global config register 
 Flush FIFOs 
 Flush TX-FIFO 
 Disable TX-channel 
 Flush RX-FIFO 
 Disable Loopback and Receive channel 
 disable sample rate and frame generators 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) ST-Ericsson SA 2012
  Author: Ola Lilja <ola.o.lilja@stericsson.com>,
          Roger Nilsson <roger.xr.nilsson@stericsson.com>
          for ST-Ericsson.
  License terms:
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) ST-Ericsson SA 2012
  Author: Ola Lilja <ola.o.lilja@stericsson.com>,
          Kristoffer Karlsson <kristoffer.karlsson@stericsson.com>
          for ST-Ericsson.
  License terms:
 Slot configuration 
 Configuration consistency parameters 
 Clocks 
 Private data for machine-part MOP500<->AB8500 
 Clocks 
  Control-events
  Controls
 ASoC 
 Set audio-clock source 
 Reset slots configuration to default(s) 
 Ensure configuration consistency between DAIs 
 Setup codec depending on driver-mode 
 Setup format 
 Setup TDM-slots 
 Create driver private-data struct 
 Setup clocks 
 Set intclk default parent to ulpclk 
 Add controls 
 SPDX-License-Identifier: GPL-2.0-only
 tegra210_dmic.c - Tegra210 DMIC driver
 Copyright (c) 2020 NVIDIA CORPORATION.  All rights reserved.
 Below enables all filters - DCR, LP and SC 
 Below as per latest POR value 
 LP filter is configured for pass through and used to apply gain 
	
	  DMIC clock rate is a multiple of 'Over Sampling Ratio' and
	  'Sample Rate'. The supported OSR values are 64, 128 and 256.
 Reg 
 Mask 
 Value 
	
	  Use LP filter gain register to apply boost.
	  Boost Gain Volume control has 100x factor.
 "CH0" 
 SPDX-License-Identifier: GPL-2.0-only
 tegra210_adx.c - Tegra210 ADX driver
 Copyright (c) 2021 NVIDIA CORPORATION.  All rights reserved.
 Ensure if ADX status is disabled 
	
	  Soft Reset: Below performs module soft reset which clears
	  all FSM logic, flushes flow control of FIFO and resets the
	  state register. It also brings module back to disabled
	  state (without flushing the data in the pipe).
 update byte map and enable slot 
 reset byte map and disable slot 
 SPDX-License-Identifier: GPL-2.0-only
  tegra20_spdif.c - Tegra20 SPDIF driver
  Author: Stephen Warren <swarren@nvidia.com>
  Copyright (C) 2011-2012 - NVIDIA, Inc.
 SPDX-License-Identifier: GPL-2.0-only
 tegra210_i2s.c - Tegra210 I2S driver
 Copyright (c) 2020 NVIDIA CORPORATION.  All rights reserved.
	
	  Below update does not have any effect on Tegra186 and Tegra194.
	  On Tegra210, I2S4 has "i2s4a" and "i2s4b" pins and below update
	  is required to select i2s4b for it to be functional for I2S
	  operation.
 No need to set rates if I2S is being operated in slave 
		
		  Other IO modules in AHUB can use i2s bclk as reference
		  clock. Below sets sync input clock rate as per bclk,
		  which can be used as input to other IO modules.
 Store CIF and I2S control values 
 Reset to make sure the previous transactions are clean 
 Restore CIF and I2S control values 
 Ensure I2S is in disabled state before new session 
 Capture path 
 Playback path 
 I2S mode has data offset of 1 
	
	  For RJ mode data offset is dependent on the sample size
	  and the bclk ratio, and so is set when hw_params is called.
 Copy the required tx and rx mask 
		
		  Frame sync width is used only for FSYNC modes and not
		  applicable for LRCK modes. Reset value for this field is "0",
		  which means the width is one bit clock wide.
		  The width requirement may depend on the codec and in such
		  cases mixer control is used to update custom values. A value
		  of "N" here means, width is "N + 1" bit clock wide.
 I2S bit clock rate 
	
	  For LRCK mode, channel bit count depends on number of bit clocks
	  on the left channel, where as for FSYNC mode bit count depends on
	  the number of bit clocks in both left and right channels for DSP
	  mode or the number of bit clocks in one TDM frame.
	 
 Program sample size 
 For playback I2S RX-CIF and for capture TX-CIF is used 
 FIFO threshold in terms of frames 
 Playback route from XBAR 
 Capture route to XBAR 
	
	  Not an error, as this clock is needed only when some other IO
	  requires input clock from current I2S instance, which is
	  configurable from DT.
 SPDX-License-Identifier: GPL-2.0-only
 tegra210_amx.c - Tegra210 AMX driver
 Copyright (c) 2021 NVIDIA CORPORATION.  All rights reserved.
  The counter is in terms of AHUB clock cycles. If a frame is not
  received within these clock cycles, the AMX input channel gets
  automatically disabled. For now the counter is calculated as a
  function of sample rate (8 kHz) and AHUB clock (49.152 MHz).
  If later an accurate number is needed, the counter needs to be
  calculated at runtime.
      count = ahub_clk  sample_rate
 Ensure if AMX is disabled 
	
	  Soft Reset: Below performs module soft reset which clears
	  all FSM logic, flushes flow control of FIFO and resets the
	  state register. It also brings module back to disabled
	  state (without flushing the data in the pipe).
 Update byte map and enable slot 
 Reset byte map and disable slot 
 SPDX-License-Identifier: GPL-2.0-only
  tegra20_das.c - Tegra20 DAS driver
  Author: Stephen Warren <swarren@nvidia.com>
  Copyright (C) 2010 - NVIDIA, Inc.
 SPDX-License-Identifier: GPL-2.0-only
 tegra210_ahub.c - Tegra210 AHUB driver
 Copyright (c) 2020 NVIDIA CORPORATION.  All rights reserved.
	
	  Find the bit position of current MUX input.
	  If nothing is set, position would be 0 and it corresponds to 'None'.
 Find index related to the item in array _ahub_mux_texts[] 
 Get the register index and value to set 
	
	  Run through all parts of a MUX register to find the state changes.
	  There will be an additional update if new MUX input value is from
	  different part of the MUX register.
 Update widget power if state has changed 
 XBAR <-> I2S <-> Codec 
 XBAR <- DMIC <- Codec 
 XBAR -> SFC -> XBAR 
 XBAR -> MVC -> XBAR 
 XBAR -> AMX(4:1) -> XBAR 
 XBAR -> ADX(1:4) -> XBAR 
 XBAR -> MIXER(10:5) -> XBAR 
 XBAR <-> I2S <-> Codec 
 XBAR <- DMIC <- Codec 
 XBAR -> DSPK -> Codec 
 XBAR -> SFC -> XBAR 
 XBAR -> MVC -> XBAR 
 XBAR -> AMX(4:1) -> XBAR 
 XBAR -> ADX(1:4) -> XBAR 
 XBAR -> MIXER1(10:5) -> XBAR 
 ADMAIF 
 I2S 
 DMIC 
 SFC 
 MVC 
 AMX 
 ADX 
 MIXER 
 ADMAIF 
 I2S 
 ADMAIF 
 DMIC 
 SFC 
 MVC 
 AMX 
 ADX 
 MIXER 
 Controls for t210 
 Controls for t186 
  The number of entries in, and order of, this array is closely tied to the
  calculation of tegra210_ahub_codec.num_dapm_widgets near the end of
  tegra210_ahub_probe()
 Connect FEs with XBAR 
  The number of entries in, and order of, this array is closely tied to the
  calculation of tegra210_ahub_codec.num_dapm_routes near the end of
  tegra210_ahub_probe()
 SPDX-License-Identifier: GPL-2.0-only
 tegra210_mixer.c - Tegra210 MIXER driver
 Copyright (c) 2021 NVIDIA CORPORATION.  All rights reserved.
 Inputs 
 Outputs 
 Default gain parameters 
 Polynomial coefficients 
 Gain value 
 Duration Parameters 
 Check if busy 
 Write default gain poly coefficients 
 Write stored gain value 
 Write duration parameters 
 Trigger to apply gain configurations 
 Save gain value for specific MIXER input 
 Mixer Input 
 Mixer Output 
 Volume controls for all MIXER inputs 
 Input 
 Output 
 Use default gain value for all MIXER inputs 
 SPDX-License-Identifier: GPL-2.0-only
  tegra20_ac97.c - Tegra20 AC97 platform driver
  Copyright (c) 2012 Lucas Stach <dev@lynxeye.de>
  Partly based on code copyrightby:
  Copyright (c) 2011,2012 Toradex Inc.
 reset line is not driven by DAC pad group, have to toggle GPIO 
	
	  although sync line is driven by the DAC pad group warm reset using
	  the controller cmd is not working, have to toggle sync line
	  manually.
 XXX: crufty ASoC AC97 API - only one AC97 codec allowed 
 SPDX-License-Identifier: GPL-2.0-only
  tegra30_ahub.c - Tegra30 AHUB driver
  Copyright (c) 2011,2012, NVIDIA CORPORATION.  All rights reserved.
  clk_apbif isn't required for an I2S<->I2S configuration where no PCM data
  is read from or sent to memory. However, that's not something the rest of
  the driver supports right now, so we'll just treat the two clocks as one
  for now.
  These functions should not be a plain ref-count. Instead, each active stream
  contributes some requirement to the minimum clock rate, so starting or
  stopping streams should dynamically adjust the clock as required.  However,
  this is not yet implemented.
 Tegra114+ 
 Tegra114+ 
 Tegra124 
 Tegra124 
 Tegra124 
 Tegra124 
 Tegra124 
 Tegra124 
 Tegra124 
 Tegra124 
 SPDX-License-Identifier: GPL-2.0-only
  tegra_asoc_machine.c - Universal ASoC machine driver for NVIDIA Tegra boards.
 Headphones Jack 
 Headset Jack 
 Mic Jack 
 Don't set cdev1extern1 rate; it's locked to pll_a_out0 
	
	  If clock parents are not set in DT, configure here to use clk_out_1
	  as mclk and extern1 as parent for Tegra30 and higher.
		
		  AC97 rate is fixed at 24.576MHz and is used for both the
		  host controller and the external codec
	
	  FIXME: There is some unknown dependency between audio MCLK disable
	  and suspend-resume functionality on Tegra30, although audio MCLK is
	  only needed for audio.
 WM8753 machine 
 WM9712 machine 
 MAX98090 machine 
 SGTL5000 machine 
 TLV320AIC23 machine 
 RT5677 machine 
 RT5640 machine 
 RT5632 machine 
 SPDX-License-Identifier: GPL-2.0-only
  tegra20_i2s.c - Tegra20 I2S driver
  Author: Stephen Warren <swarren@nvidia.com>
  Copyright (C) 2010,2012 - NVIDIA, Inc.
  Based on code copyrightby:
  Copyright (c) 2009-2010, NVIDIA Corporation.
  Scott Peterson <speterson@nvidia.com>
  Copyright (C) 2010 Google, Inc.
  Iliyan Malchev <malchev@google.com>
 Final " 2" required by Tegra hardware 
 SPDX-License-Identifier: GPL-2.0-only
  tegra_pcm.c - Tegra PCM driver
  Author: Stephen Warren <swarren@nvidia.com>
  Copyright (C) 2010,2012 - NVIDIA, Inc.
  Based on code copyrightby:
  Copyright (c) 2009-2010, NVIDIA Corporation.
  Scott Peterson <speterson@nvidia.com>
  Vijay Mali <vmali@nvidia.com>
  Copyright (C) 2010 Google, Inc.
  Iliyan Malchev <malchev@google.com>
 Set HW params now that initialization is complete 
 Ensure period size is multiple of 8 
	
	  Fallback for backwards-compatibility with older device trees that
	  have the iommus property in the virtual, top-level "sound" node.
 SPDX-License-Identifier: GPL-2.0-only
 tegra210_mvc.c - Tegra210 MVC driver
 Copyright (c) 2021 NVIDIA CORPORATION.  All rights reserved.
	
	  Volume control read from mixer control is with
	  100x scaling; for CURVE_POLY the reg range
	  is 0-100 (linear, Q24) and for CURVE_LINEAR
	  it is -120dB to +40dB (Q8)
 Check if VOLUME_SWITCH is triggered 
 Check if VOLUME_SWITCH is triggered 
 Configure init volume same as target volume 
 Change volume to default init for new curve type 
 Program curve type 
 Init volume for all channels 
 Trigger volume switch 
	
	  Soft Reset: Below performs module soft reset which clears
	  all FSM logic, flushes flow control of FIFO and resets the
	  state register. It also brings module back to disabled
	  state (without flushing the data in the pipe).
 Set RX CIF 
 Set TX CIF 
 Program poly_n1, poly_n2, duration 
 Program duration_inv 
 Per channel volume control 
 Per channel mute 
 Input 
 Output 
 SPDX-License-Identifier: GPL-2.0-only
 tegra210_admaif.c - Tegra ADMAIF driver
 Copyright (c) 2020 NVIDIA CORPORATION.  All rights reserved.
 Disable TXRX channel 
 Wait until ADMAIF TXRX status is disabled 
 SW reset 
 Wait till SW reset is complete 
  Below macro is added to avoid looping over all ADMAIFx controls related
  to monostereo conversions in get()put() callbacks.
 SPDX-License-Identifier: GPL-2.0-only
  tegra_wm8903.c - Tegra machine ASoC driver for boards using WM8903 codec.
  Author: Stephen Warren <swarren@nvidia.com>
  Copyright (C) 2010-2012 - NVIDIA, Inc.
  Based on code copyrightby:
  (c) 2009, 2010 Nvidia Graphics Pvt. Ltd.
  Copyright 2007 Wolfson Microelectronics PLC.
  Author: Graeme Gregory
          graeme.gregory@wolfsonmicro.com or linux@wolfsonmicro.com
 FIXME: Codec only requires >= 3MHz if OSR==0 
	
	  Older version of machine driver was ignoring GPIO polarity,
	  forcing it to active-low.  This means that all older device-trees
	  which set the polarity to active-high are wrong and we need to fix
	  them up.
 older device-trees used wrong polarity for the headphones-detection GPIO 
 SPDX-License-Identifier: GPL-2.0-only
  tegra30_i2s.c - Tegra30 I2S driver
  Author: Stephen Warren <swarren@nvidia.com>
  Copyright (c) 2010-2012, NVIDIA CORPORATION.  All rights reserved.
  Based on code copyrightby:
  Copyright (c) 2009-2010, NVIDIA Corporation.
  Scott Peterson <speterson@nvidia.com>
  Copyright (C) 2010 Google, Inc.
  Iliyan Malchev <malchev@google.com>
 Final " 2" required by Tegra hardware 
 set the fsync width to minimum of 1 clock width 
 SPDX-License-Identifier: GPL-2.0-only
 tegra_audio_graph_card.c - Audio Graph based Tegra Machine Driver
 Copyright (c) 2020-2021 NVIDIA CORPORATION.  All rights reserved.
	
	  Sample rates multiple of 8000 Hz and below are supported:
	  ( 8000, 16000, 32000, 48000, 96000, 192000 Hz )
	
	  Sample rates multiple of 11025 Hz and below are supported:
	  ( 11025, 22050, 44100, 88200, 176400 Hz )
 Tegra audio chip data 
 Setup PLL clock as per the given sample rate 
	
	  Below is the clock relation:
	 
	 	PLLA
	 	  |
	 	  |--> PLLA_OUT0
	 		  |
	 		  |---> I2S modules
	 		  |
	 		  |---> DMIC modules
	 		  |
	 		  |---> DSPK modules
	 
	 
	  Default PLLA_OUT0 rate might be too high when IO is running
	  at minimum PCM configurations. This may result in incorrect
	  clock rates and glitchy audio. The maximum divider is 128
	  and any thing higher than that won't work. Thus reduce PLLA_OUT0
	  to work for lower configurations.
	 
	  This problem is seen for I2S only, as DMIC and DSPK minimum
	  clock requirements are under allowed divider limits.
 Set PLLA rate 
 Set PLLA_OUT0 rate 
	
	  This gets called for each DAI link (FE or BE) when DPCM is used.
	  We may not want to update PLLA rate for each call. So PLLA update
	  must be restricted to external IO links (I2S, DMIC or DSPK) since
	  they actually depend on it. IO modules update their clocks in
	  hw_param() of their respective component driver and PLLA rate
	  update here helps them to derive appropriate rates.
	 
	  TODO: When more HW accelerators get added (like sample rate
	  converter, volume gain controller etc., which don't really
	  depend on PLLA) we need a better way to filter here.
 audio_graph_parse_of() depends on below 
 PLLA 
 PLLA_OUT0 
 PLLA 
 PLLA_OUT0 
 SPDX-License-Identifier: GPL-2.0-only
 tegra186_dspk.c - Tegra186 DSPK driver
 Copyright (c) 2020 NVIDIA CORPORATION. All rights reserved.
 Client channel 
 RX FIFO threshold in terms of frames 
	
	  DSPK clock and PDM codec clock should be synchronous with 4:1 ratio,
	  this is because it takes 4 clock cycles to send out one sample to
	  codec by sigma delta modulator. Finally the clock rate is a multiple
	  of 'Over Sampling Ratio', 'Sample Rate' and 'Interface Clock Ratio'.
 Reg 
 Mask 
 Value 
 "Zero" 
 SPDX-License-Identifier: GPL-2.0-only
 tegra210_sfc.c - Tegra210 SFC driver
 Copyright (c) 2021 NVIDIA CORPORATION.  All rights reserved.
 coeff RAM tables required for SFC 
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
interpolation + IIR filter
input gain
ouptut gain
interpolation + IIR filter
input gain
Output gain
Farrow filter
interpolation + IIR Filter
input gain
ouptut gain
interpolation + IIR filter
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
interpolation + IIR filter
input gain
output gain
interpolation + IIR filter
input gain
output gain
Farrow Filter
IIR Filter + Decimator
input gain
output gain
interpolation + IIR Filter
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
IIR Filter
input gain
output gain
Farrow Filter + decimation
IIR Filter + Decimator
input gain
output gain
header
input gain
output gain
header
input gain
output gain
IIR Filter + interpolation
input gain
output gain
Farrow Filter + decimation
IIR Filter + Decimator
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
IIR Filter + Decimator
input gain
output gain
IIR Filter + Decimator
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
IIR Filter + Decimator
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
header
input gain
output gain
header
input gain
output gain
farrow
header
input gain
output gain
  Coefficient table for various sample rate conversions. The sample
  rates available are as per tegra210_sfc_rates[].
 Convertions from 8 kHz 
 Convertions from 11.025 kHz 
 Convertions from 16 kHz 
 Convertions from 22.05 kHz 
 Convertions from 24 kHz 
 Convertions from 32 kHz 
 Convertions from 44.1 kHz 
 Convertions from 48 kHz 
 Convertions from 88.2 kHz 
 Convertions from 96 kHz 
 Convertions from 176.4 kHz 
 Convertions from 192 kHz 
 Bypass 
	
	  Soft Reset: Below performs module soft reset which clears
	  all FSM logic, flushes flow control of FIFO and resets the
	  state register. It also brings module back to disabled
	  state (without flushing the data in the pipe).
 SPDX-License-Identifier: GPL-2.0-only
  omap-abe-twl6040.c  --  SoC audio for TI OMAP based boards with ABE and
 			   twl6040 codec
  Author: Misael Lopez Cruz <misael.lopez@ti.com>
 board can detect jack events 
 MCLK frequency speed for twl6040 
 set the codec mclk 
 Headset jack 
Headset jack detection DAPM pins 
 SDP4430 machine DAPM 
 Outputs 
 Inputs 
 Digital microphones 
 Routings for outputs 
 Routings for inputs 
	
	  Configure McPDM offset cancellation based on the HSOTRIM value from
	  twl6040.
 Headset jack detection only if it is supported 
 SPDX-License-Identifier: GPL-2.0-only
  omap-mcbsp.c  --  OMAP ALSA SoC DAI driver using McBSP port
  Copyright (C) 2008 Nokia Corporation
  Contact: Jarkko Nikula <jarkko.nikula@bitmer.com>
           Peter Ujfalusi <peter.ujfalusi@ti.com>
 Writing zero to XSYNC_ERR clears the IRQ 
 Writing zero to RSYNC_ERR clears the IRQ 
  omap_mcbsp_config simply write a config to the
  appropriate McBSP.
  You either call this function or set the McBSP registers
  by yourself before calling omap_mcbsp_start().
 We write the given config 
 Enable wakeup behavior 
 Enable TXRX sync error interrupts by default 
  omap_mcbsp_dma_reg_params - returns the address of mcbsp data register
  @mcbsp: omap_mcbsp struct for the McBSP instance
  @stream: Stream direction (playbackcapture)
  Returns the address of mcbsp data transmit register or data receive register
  to be used by DMA for transferringreceiving data
  omap_mcbsp_set_rx_threshold configures the transmit threshold in words.
  The threshold parameter is 1 based, and it is converted (threshold - 1)
  for the THRSH2 register.
  omap_mcbsp_set_rx_threshold configures the receive threshold in words.
  The threshold parameter is 1 based, and it is converted (threshold - 1)
  for the THRSH1 register.
  omap_mcbsp_get_tx_delay returns the number of used slots in the McBSP FIFO
 Returns the number of free locations in the buffer 
 Number of slots are different in McBSP ports 
  omap_mcbsp_get_rx_delay returns the number of free slots in the McBSP FIFO
  to reach the threshold value (when the DMA will be triggered to read it)
 Returns the number of used locations in the buffer 
 RX threshold 
 Return the number of location till we reach the threshold limit 
	
	  Make sure that transmitter, receiver and sample-rate generator are
	  not running before activating IRQs.
 Disable wakeup behavior 
 Disable wakeup behavior 
 Disable interrupt requests 
	
	  Select CLKS source from internal source unconditionally before
	  marking the McBSP port as free.
	  If the external clock source via MCBSP_CLKS pin has been selected the
	  system will refuse to enter idle if the CLKS pin source is not reset
	  back to internal source.
  Here we start the McBSP, by enabling transmitter, receiver or both.
  If no transmitter or receiver is active prior calling, then sample-rate
  generator and frame sync are started.
 Only enable SRG, if McBSP is master 
 Start the sample generator 
 Enable transmitter and receiver 
	
	  Worst case: CLKSRG2 = 8000khz: (18000)  2  2 usec
	  REVISIT: 100us may give enough time for two CLKSRG, however
	  due to some unknown PM related, clock gating etc. reason it
	  is now at 500us.
 Start frame sync 
 Release the transmitter and receiver 
 Dump McBSP Regs 
 Reset transmitter 
 Reset receiver 
 Reset the sample rate generator 
  McBSP1 and McBSP3 are directly mapped on 1610 and 1510.
  730 has only 2 McBSP, and both of them are MPU peripherals.
	
	  OMAP1, 2 uses two interrupt lines: TX, RX
	  OMAP2430, OMAP3 SoC have combined IRQ line as well.
	  OMAP4 and newer SoC only have the combined IRQ line.
	  Use the combined IRQ if available since it gives better debugging
	  possibilities.
		
		  Initially configure the maximum thresholds to a safe value.
		  The McBSP FIFO usage with these values should not go under
		  16 locations.
		  If the whole FIFO without safety buffer is used, than there
		  is a possibility that the DMA will be not able to push the
		  new data on time, causing channel shifts in runtime.
  Stream DMA parameters. DMA request line and port address are set runtime
  since they are different between OMAP1 and later OMAPs
 No need to proceed further if McBSP does not have FIFO 
	
	  Configure McBSP threshold based on either:
	  packet_size, when the sDMA is in packet mode, or based on the
	  period size in THRESHOLD mode, otherwise use McBSP threshold = 1
	  for mono streams.
 Configure McBSP internal buffer usage 
	
	  OMAP3 McBSP FIFO is word structured.
	  McBSP2 has 1024 + 256 = 1280 word long buffer,
	  McBSP1,3,4,5 has 128 word long buffer
	  This means that the size of the FIFO depends on the sample format.
	  For example on McBSP3:
	  16bit samples: size is 128  2 = 256 bytes
	  32bit samples: size is 128  4 = 512 bytes
	  It is simpler to place constraint for buffer and period based on
	  channels.
	  McBSP3 as example again (16 or 32 bit samples):
	  1 channel (mono): size is 128 frames (128 words)
	  2 channels (stereo): size is 128  2 = 64 frames (2  64 words)
	  4 channels: size is 128  4 = 32 frames (4  32 words)
		
		 Rule for the buffer size. We should not allow
		 smaller buffer than the FIFO size to avoid underruns.
		 This applies only for the playback stream.
 Make sure, that the period size is always even 
 Prevent omap hardware from hitting off between FIFO fills 
 No need to proceed further if McBSP does not have FIFO 
	
	  Divide the used locations with the channel count to get the
	  FIFO usage in samples (don't care about partial samples in the
	  buffer).
			
			  Use sDMA packet mode if McBSP is in threshold mode:
			  If period words less than the FIFO size the packet
			  size is set to the number of period words, otherwise
			  Look for the biggest threshold value which divides
			  the period size evenly.
 Use packet mode for non mono streams 
 McBSP already configured by another stream 
 Use dual-phase frames 
 Set 1 word per (McBSP) frame for phase1 and phase2 
 Set word lengths 
 Set word lengths 
 Unsupported PCM format 
	 In McBSP master modes, FRAME (i.e. sample rate) is generated
 Set FS period and length in terms of bit clock periods 
  This must be called before _set_clkdiv and _set_sysclk since McBSP register
  cache is initialized here
 Generic McBSP register settings 
 RFIG and XFIG are not defined in 2430 and on OMAP3+ 
 Configure XCCRRCCR only for revisions which have ccr registers 
 1-bit data delay 
 0-bit data delay 
 Invert FS polarity configuration 
 1-bit data delay 
 Invert FS polarity configuration 
 0-bit data delay 
 Invert FS polarity configuration 
 Unsupported data format 
 McBSP master. Set FS and bit clocks as outputs 
 Sample rate generator drives the FS 
 McBSP slave. FS clock as output 
 McBSP slave 
 Unsupported masterslave configuration 
 Set bit clock (CLKXCLKR) and FS polarities 
		
		  Normal BCLK + FS.
		  FS active low. TX data driven on falling edge of bit clock
		  and RX data sampled on rising edge of bit clock.
		
		  If McBSP is master but yet the CLKXCLKR pin drives the SRG,
		  disable output on those pins. This enables to inject the
		  reference clock through CLKXCLKR. For this to work
		  set_dai_sysclk() _needs_ to be called after set_dai_fmt().
 Disable ouput on CLKR pin in master mode 
 SPDX-License-Identifier: GPL-2.0-only
  osk5912.c  --  SoC audio for OSK 5912
  Copyright (C) 2008 Mistral Solutions
  Contact: Arun KS  <arunks@mistralsolutions.com>
 Set the codec system clock for DAC and ADC 
 Digital audio interface glue - connects codec <--> CPU 
 Audio machine driver 
	
	  Configure 12 MHz output on MCLK.
 SPDX-License-Identifier: GPL-2.0-only
  omap3pandora.c  --  SoC audio for Pandora Handheld Console
  Author: Gravydas Ignotas <notasas@gmail.com>
 Set the codec system clock for DAC and ADC 
 Set McBSP clock to external 
	
	  The PCM1773 DAC datasheet requires 1ms delay between switching
	  VCC power onoff and PD pin highlow
  Audio paths on Pandora board:
   |O| ---> PCM DAC +-> AMP -> Headphone Jack
   |M|         A    +--------> Line Out
   |A| <~~clk~~+
   |P| <--- TWL4030 <--------- Line In and MICs
 All TWL4030 output pins are floating 
 Not comnnected 
 Digital audio interface glue - connects codec <--> CPU 
 SoC card 
 SPDX-License-Identifier: GPL-2.0-only
  omap-dmic.c  --  OMAP ASoC DMIC DAI driver
  Copyright (C) 2010 - 2011 Texas Instruments
  Author: David Lambert <dlambert@ti.com>
 	   Misael Lopez Cruz <misael.lopez@ti.com>
 	   Liam Girdwood <lrg@ti.com>
 	   Peter Ujfalusi <peter.ujfalusi@ti.com>
 Configure DMA controller 
 Disable DMA request generation 
	
	  192KHz rate is only supported with 19.2MHz3.84MHz clock
	  configuration.
 Divider: 5 (192KHz sampling rate) 
 Divider: 16 
 Divider: 5 
 Divider: 8 
 Divider: 10 
 Divider: 8 
 Divider: 5 (96KHz sampling rate) 
 packet size is threshold  channels 
 Configure uplink threshold 
 Set dmic out format 
 Configure dmic clock divider 
 re-parent not allowed if a stream is ongoing 
 disable clock while reparenting 
 Disable lines while request is ongoing 
 Configure DMIC threshold value 
 SPDX-License-Identifier: GPL-2.0-only
  omap-twl4030.c  --  SoC audio for TI SoC based boards with twl4030 codec
  Copyright (C) 2012 Texas Instruments Incorporated - https:www.ti.com
  All rights reserved.
  Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
  This driver replaces the following machine drivers:
  omap3beagle (Author: Steve Sakoman <steve@sakoman.com>)
  omap3evm (Author: Anuj Aggarwal <anuj.aggarwal@ti.com>)
  overo (Author: Steve Sakoman <steve@sakoman.com>)
  igep0020 (Author: Enric Balletbo i Serra <eballetbo@iseebcn.com>)
  zoom2 (Author: Misael Lopez Cruz <misael.lopez@ti.com>)
  sdp3430 (Author: Misael Lopez Cruz <misael.lopez@ti.com>)
 board can detect jack events 
 Stereo I2S mode 
 Four channel TDM mode 
 Headset Stereophone:  HSOL, HSOR 
 External Speakers: HFL, HFR 
 External Speakers: PredrivL, PredrivR 
 Carkit speakers:  CARKITL, CARKITR 
 Earpiece 
 External Mics: MAINMIC, SUBMIC with bias 
 Headset Mic: HSMIC with bias 
 Digital Mics: DIGIMIC0, DIGIMIC1 with bias 
 Carkit In: CARKITMIC 
 Aux In: AUXL, AUXR 
 Headset jack detection DAPM pins 
 Headset jack detection gpios 
 Headset jack detection only if it is supported 
	
	  NULL pdata means we booted with DT. In this case the routing is
	  provided and the card is fully routed, no need to mark pins.
 Disable not connected paths if not used 
 Digital audio interface glue - connects codec <--> CPU 
 Audio machine driver 
 Optional: audio routing can be provided 
 SPDX-License-Identifier: GPL-2.0-or-later
  ALSA SoC Voice Codec Interface for TI DAVINCI processor
  Copyright (C) 2010 Texas Instruments.
  Author: Miguel Aguilar <miguel.aguilar@ridgerun.com>
 Start the sample generator and enable transmitterreceiver 
 Reset transmitterreceiver and sample rateframe sync generators 
 Restart the codec before setup 
 General line settings 
 Determine xfer data type 
 DMA tx params 
 DMA rx params 
 SPDX-License-Identifier: GPL-2.0-only
  edma-pcm.c - eDMA PCM driver using dmaengine for AM3xxx, AM4xxx
  Copyright (C) 2014 Texas Instruments, Inc.
  Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
  Based on: soundsoctegrategra_pcm.c
 Limit by edma dmaengine driver 
 SPDX-License-Identifier: GPL-2.0-only
  n810.c  --  SoC audio for Nokia N810
  Copyright (C) 2008 Nokia Corporation
  Contact: Jarkko Nikula <jarkko.nikula@bitmer.com>
 Set the codec system clock for DAC and ADC 
	
	  Note that the mic bias is coming from RetuVilma and we don't have
	  control over it atm. The analog HS mic is not working. <- TODO
 Digital audio interface glue - connects codec <--> CPU 
 Audio machine driver 
	
	  Configure 12 MHz output on SYS_CLKOUT2. Therefore we must use
	  96 MHz as its parent in order to get 12 MHz
 SPDX-License-Identifier: GPL-2.0-only
  ams-delta.c  --  SoC audio for Amstrad E3 (Delta) videophone
  Copyright (C) 2009 Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
  Initially based on soundsocomaposk5912.x
  Copyright (C) 2008 Mistral Solutions
 Board specific DAPM widgets 
 Handset 
 HandsfreeSpeakerphone 
 How they are connected to codec pins 
  Controls, functional after the modem line discipline is activated.
 Virtual switch: audio inputoutput constellations 
 Selection <-> pin translation 
  Used for passing a codec structure pointer
  from the board initialization code to the tty line discipline.
 Refuse any mode changes if we are not able to control the codec. 
 Translate selection to bitmap 
 Setup pins after corresponding bits if changed 
 Hook switch 
 After we are able to control the codec over the modem,
 Handset 
 Handsfree 
  Modem line discipline, required for making above controls functional.
  Activated from userspace with ldattach, possibly invoked from udev rule.
 To actually apply any modem controlled configuration changes to the codec,
  we must connect codec DAI pins to the modem for a moment.  Be careful not
	 Reconnect the codec DAI back from the modem to the CPU DAI
 Line discipline .open() 
	
	  Pass the codec structure pointer for use by other ldisc callbacks,
	  both the card and the codec specific parts.
 Line discipline .close() 
 Prevent the hook switch from further changing the DAPM pins 
 Revert back to default audio inputoutput constellation 
 Line discipline .hangup() 
 Line discipline .receive_buf() 
 First modem response, complete setup procedure 
 Initialize timer used for config pulse generation 
 Link hook switch to DAPM pins 
 Complete modem response received, apply config to codec 
		 Apply config pulse by connecting the codec to the modem
 Line discipline .write_wakeup() 
  Even if not very useful, the sound card can still work without any of the
  above functionality activated.  You can still control its audio inputoutput
  constellation and speakerphone gain from userspace by issuing AT commands
  over the modem port.
 Digital mute implemented using modemCPU multiplexer.
 Our codec DAI probably doesn't have its own .ops structure 
 Will be used if the codec ever has its own digital_mute function 
  Card initialization
 Codec is ready, now addactivate board specific controls 
 Store a pointer to the codec structure for tty ldisc use 
	 Add hook switch - can be used to control the codec from userspace
 Set up digital mute if not provided by the codec 
 Register optional line discipline for over the modem control 
 Set up initial pin constellation 
 DAI glue - connects codec <--> CPU 
 Audio card driver 
 Module initexit 
 SPDX-License-Identifier: GPL-2.0-only
  ALSA SoC I2S (McBSP) Audio Layer for TI DAVINCI processor
  Author:      Vladimir Barinov, <vbarinov@embeddedalley.com>
  Copyright:   (C) 2007 MontaVista Software, Inc., <source@mvista.com>
  DT support	(c) 2016 Petr Kulhavy, Barix AG <petr@barix.com>
 		based on davinci-mcasp.c DT support
  TODO:
  on DA850 implement HW FIFOs instead of DMA into DXR and DRR registers
  NOTE:  terminology here is confusing.
   - This driver supports the "Audio Serial Port" (ASP),
     found on dm6446, dm355, and other DaVinci chips.
   - But it labels it a "Multi-channel Buffered Serial Port"
     (McBSP) as on older chips like the dm642 ... which was
     backward-compatible, possibly explaining that confusion.
   - OMAP chips have a controller called McBSP, which is
     incompatible with the DaVinci flavor of McBSP.
   - Newer DaVinci chips have a controller called McASP,
     incompatible with ASP and with either McBSP.
  In short:  this uses ASP to implement I2S, not McBSP.
  And it won't be the only DaVinci implemention of I2S.
	
	  Combining both channels into 1 element will at least double the
	  amount of time between servicing the dma channel, increase
	  effiency, and reduce the chance of overrununderrun. But,
	  it will result in the left & right channels being swapped.
	 
	  If relabeling the left and right channels is not possible,
	  you may want to let the codec know to swap them back.
	 
	  It may allow x10 the amount of time to service dma requests,
	  if the codec is master and is using an unnecessarily fast bit clock
	  (ie. tlvaic23b), independent of the sample rate. So, having an
	  entire frame at once means it can be serviced at the sample rate
	  instead of the bit clock rate.
	 
	  In the now unlikely case that an underrun still
	  occurs, both the left and right samples will be repeated
	  so that no pops are heard, and the left and right channels
	  won't end up being swapped because of the underrun.
	 The clock needs to toggle to complete reset.
	  So, fake it by toggling the clk polarity.
 Enable transmitter or receiver 
 Start frame sync 
 Reset transmitterreceiver and sample rateframe sync generators 
 Attention srgr is updated by hw_params! 
 set masterslave audio interface 
 cpu is master 
		
		  Selection of the clock input pin that is the
		  input for the Sample Rate Generator.
		  McBSP FSR and FSX are driven by the Sample Rate
		  Generator.
 codec is master 
 interface format 
		 Davinci doesn't support TRUE I2S, but some codecs will have
		  the left and right channels contiguous. This allows
		  dsp_a mode to be used with an inverted normal frame clk.
		  If your codec is master and does not have contiguous
		  channels, then you will have sound on only one channel.
		  Try using a different mode, or codec as slave.
		 
		  The TLV320AIC33 is an example of a codec where this works.
		  It has a variable bit clock frequency allowing it to have
		  valid data on every bit clock.
		 
		  The TLV320AIC23 is an example of a codec where this does not
		  work. It has a fixed bit clock frequency with progressively
		  more empty bit clock slots between channels as the sample
		  rate is lowered.
		 CLKRP Receive clock polarity,
		 	1 - sampled on rising edge of CLKR
		 	valid on rising edge
		  CLKXP Transmit clock polarity,
		 	1 - clocked on falling edge of CLKX
		 	valid on rising edge
		  FSRP  Receive frame sync pol, 0 - active high
		  FSXP  Transmit frame sync pol, 0 - active high
		 CLKRP Receive clock polarity,
		 	0 - sampled on falling edge of CLKR
		 	valid on falling edge
		  CLKXP Transmit clock polarity,
		 	0 - clocked on rising edge of CLKX
		 	valid on falling edge
		  FSRP  Receive frame sync pol, 1 - active low
		  FSXP  Transmit frame sync pol, 1 - active low
		 CLKRP Receive clock polarity,
		 	1 - sampled on rising edge of CLKR
		 	valid on rising edge
		  CLKXP Transmit clock polarity,
		 	1 - clocked on falling edge of CLKX
		 	valid on rising edge
		  FSRP  Receive frame sync pol, 1 - active low
		  FSXP  Transmit frame sync pol, 1 - active low
		 CLKRP Receive clock polarity,
		 	0 - sampled on falling edge of CLKR
		 	valid on falling edge
		  CLKXP Transmit clock polarity,
		 	0 - clocked on rising edge of CLKX
		 	valid on falling edge
		  FSRP  Receive frame sync pol, 0 - active high
		  FSXP  Transmit frame sync pol, 0 - active high
 general line settings 
 symmetric waveforms 
 Clock and frame sync given from external sources 
 Determine xfer data type 
 start off disabled 
 Start the sample generator 
 Enable the transmitter 
 wait for any unexpected frame sync error to occur 
 Disable the transmitter to clear any outstanding XSYNCERR 
 setup DMA, first TX, then RX 
 SPDX-License-Identifier: GPL-2.0
  McBSP Sidetone support
  Copyright (C) 2004 Nokia Corporation
  Author: Samuel Ortiz <samuel.ortiz@nokia.com>
  Contact: Jarkko Nikula <jarkko.nikula@bitmer.com>
           Peter Ujfalusi <peter.ujfalusi@ti.com>
 OMAP3 sidetone control registers 
 McBSP SSELCR bit definitions 
 McBSP Sidetone SYSCONFIG bit definitions 
 McBSP Sidetone SGAINCR bit definitions 
 Bits 0:15 
 Bits 16:31 
 McBSP Sidetone SFIRCR bit definitions 
 Bits 0:15 
 McBSP Sidetone SSELCR bit definitions 
 Sidetone filter coefficients 
 Number of filter coefficients in use 
 Disable Sidetone clock auto-gating for normal operation 
 Enable McBSP Sidetone 
 Enable Sidetone from Sidetone Core 
 Enable Sidetone clock auto-gating to reduce power consumption 
 OMAP McBSP implementation uses index values 0..4 		\
 McBSP 2 
 McBSP 3 
 SPDX-License-Identifier: GPL-2.0
   Copyright (C) 2018 Texas Instruments Incorporated - https:www.ti.com
   Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
 Standard names for the directions: 'tx' and 'rx' 
 One direction only PCM 
 SPDX-License-Identifier: GPL-2.0-only
  omap-hdmi-audio.c -- OMAP4+ DSS HDMI audio support library
  Copyright (C) 2014 Texas Instruments Incorporated - https:www.ti.com
  Author: Jyri Sarha <jsarha@ti.com>
	
	  Make sure that the period bytes are multiple of the DMA packet size.
	  Largest packet size we use is 32 32-bit words = 128 bytes
	
	  fill the IEC-60958 channel status word
 initialize the word bytes 
 specify IEC-60958-3 (commercial use) 
 specify that the audio is LPCM
 specify the clock accuracy 
	
	  specify the word length. The same word length value can mean
	  two different lengths. Hence, we need to specify the maximum
	  word length as well.
	
	  Fill the CEA-861 audio infoframe (see spec for details)
 not used, all zeros 
 the expression is trivial but makes clear what we are doing 
 SPDX-License-Identifier: GPL-2.0-only
  omap-mcpdm.c  --  OMAP ALSA SoC DAI driver using McPDM port
  Copyright (C) 2009 - 2011 Texas Instruments
  Author: Misael Lopez Cruz <misael.lopez@ti.com>
  Contact: Jorge Eduardo Candelaria <x0107209@ti.com>
           Margarita Olaya <magi.olaya@ti.com>
           Peter Ujfalusi <peter.ujfalusi@ti.com>
 channel mask for the direction 
 FIFO threshold 
 PlaybackCapture configuration 
 McPDM dn offsets for rx1, and 2 channels 
 McPDM needs to be restarted due to runtime reconfiguration 
 pm state for suspendresume handling 
  Stream DMA parameters
  Enables the transfer through the PDM interface tofrom the Phoenix
  codec by enabling the corresponding UP or DN channels.
  Disables the transfer through the PDM interface tofrom the Phoenix
  codec by disabling the corresponding UP or DN channels.
  Is the physical McPDM interface active.
  Configures McPDM uplink, and downlink for audio.
  This function should be called before omap_mcpdm_start.
 Enable DN RX12 offset cancellation feature, if configured 
  Cleans McPDM uplink, and downlink configuration.
  This function should be called when the stream is closed.
 Disable irq request generation for downlink 
 Disable DMA request generation for downlink 
 Disable irq request generation for uplink 
 Disable DMA request generation for uplink 
 Disable RX12 offset cancellation 
 Acknowledge irq event 
 up to 3 channels for capture 
 up to 3 channels for capture 
 unsupported number of channels 
 Configure McPDM channels, and DMA packet size 
 If capture is not running assume a stereo stream to come 
 If playback is not running assume a stereo stream to come 
	
	  The DMA must act to a DMA request within latency time (usec) to avoid
	  underoverflow
 Check if we need to restart McPDM with this stream 
 Prevent omap hardware from hitting off between FIFO fills 
 Disable lines while request is ongoing 
 Configure McPDM threshold values 
 SPDX-License-Identifier: GPL-2.0-only
  ALSA SoC McASP Audio Layer for TI DAVINCI processor
  Multi-channel Audio Serial Port Driver
  Author: Nirmal Pandey <n-pandey@ti.com>,
          Suresh Rajashekara <suresh.r@ti.com>
          Steve Chen <schen@.mvista.com>
  Copyright:   (C) 2009 MontaVista Software, Inc., <source@mvista.com>
  Copyright:   (C) 2009  Texas Instruments, India
 for readwrite fifo control registers 
 for serializer configuration 
 Audio can not be enabled due to missing parameter(s) 
 McASP specific data 
 Pin direction bitfield 
 McASP FIFO related 
 Used for comstraint setting on the second stream 
 programming GBLCTL needs to read back from GBLCTL and verfiy 
 loop count is to avoid the lock-up 
 enable FIFO 
 Start clocks 
	
	  When ASYNC == 0 the transmit and receive sections operate
	  synchronously from the transmit clock and frame sync. We need to make
	  sure that the TX signlas are enabled when starting reception.
 Activate serializer(s) 
 Release RX state machine 
 Release Frame Sync generator 
 enable receive IRQs 
 enable FIFO 
 Start clocks 
 Activate serializer(s) 
 wait for XDATA to be cleared 
 Release TX state machine 
 Release Frame Sync generator 
 enable transmit IRQs 
 disable IRQ sources 
	
	  In synchronous mode stop the TX clocks if no other stream is
	  running
 disable FIFO 
 disable IRQ sources 
	
	  In synchronous mode keep TX clocks running if the capture stream is
	  still running.
 disable FIFO 
 Ack the handled event only 
 Ack the handled event only 
 1st data bit occur one ACLK cycle after the frame sync 
 No delay after FS 
 configure a full-word SYNC pulse (LRCLK) 
 1st data bit occur one ACLK cycle after the frame sync 
 FS need to be inverted 
 configure a full-word SYNC pulse (LRCLK) 
 No delay after FS 
 codec is clock and frame slave 
 BCLK 
 Frame Sync 
 codec is clock slave and frame master 
 BCLK 
 Frame Sync 
 codec is clock master and frame slave 
 BCLK 
 Frame Sync 
 codec is clock and frame master 
 BCLK 
 Frame Sync 
 MCLK divider 
 BCLK divider 
		
		  BCLKLRCLK ratio descries how many bit-clock cycles
		  fit into one frame. The clock ratio is given for a
		  full period of data (for I2S format both left and
		  right channels), so it has to be divided by number
		  of tdm-slots (for I2S - divided by 2).
		  Instead of storing this ratio, we calculate a new
		  tdm_slot width by dividing the ratio by the
		  number of configured tdm slots.
 Select AUXCLK as HCLK 
	
	  When AHCLK XR is selected to be output it means that the HCLK is
	  the same clock - coming via AUXCLK.
 All serializers must have equal number of channels 
	
	  TX rotation:
	  right aligned formats: rotate w slot_width
	  left aligned formats: rotate w sample_width
	 
	  RX rotation:
	  right aligned formats: no rotation needed
	  left aligned formats: rotate w (slot_width - sample_width)
 mapping of the XSSZ bit-field as described in the datasheet 
		
		  according to the TRM it should be TXROT=0, this one works:
		  16 bit to 23-8 (TXROT=6, rotate 24 bits)
		  24 bit to 23-0 (TXROT=0, rotate 0 bits)
		 
		  TXROT = 0 only works with 24bit samples
 In DIT mode we only allow maximum of one serializers for now 
 Default configuration 
 Inactive or unused pin, set it to inactive 
 If unused, set DISMOD for the pin 
 AFIFO is not in use 
 Configure the burst size for platform drivers 
			
			  If more than one serializers are in use we have one
			  DMA request to provide data for all serializers.
			  For example if three serializers are enabled the DMA
			  need to transfer three words per DMA request.
	
	  Calculate the optimal AFIFO depth for platform side:
	  The number of words for numevt need to be in steps of active
	  serializers.
 Configure the burst size for platform drivers 
	
	  If more than one serializer is needed, then use them with
	  all the specified tdm_slots. Otherwise, one serializer can
	  cope with the transaction using just as many slots as there
	  are channels in the stream.
		
		  If McASP is set to be TXRX synchronous and the playback is
		  not running already we need to configure the TX slots in
		  order to have correct FSX on the bus
 SPDIF 
 Set TX frame synch : DIT Mode, 1 bit width, internal, rising edge 
 Set the TX tdm : for all the slots 
 Set the TX clock controls : div = 1 and internal 
 Set SPDIF channel status bits 
 Enable the DIT 
	
	  Divide the used locations with the channel count to get the
	  FIFO usage in samples (don't care about partial samples in the
	  buffer).
	
	  If mcasp is BCLK master, and a BCLK divider was not provided by
	  the machine driver, we need to calculate the ratio.
 Do not allow more then one stream per direction 
	
	  Limit the maximum allowed channels for the first stream:
	  number of serializers for the direction  tdm slots per serializer
	
	  If the already active stream has less channels than the calculated
	  limit based on the seirializers  tdm_slots, and only one serializer
	  is in use we need to use that as a constraint for the second stream.
	  Otherwise (first stream or less allowed channels or more than one
	  serializer in use) we use the calculated constraint.
	
	  But we can always allow channels upto the amount of
	  the available tdm_slots.
		
		  Only allow formats which require same amount of bits on the
		  bus as the currently running stream
 Only allow formats require <= slot_width bits on the bus 
	
	  If we rely on implicit BCLK divider setting we should
	  set constraints based on what we can provide.
 Some HW specific values and defaults. The rest is filled in from DT. 
 The CFG port offset will be calculated if it is needed 
 sentinel  }
 sanity check for tdm slots parameter 
 Do not change the PIN yet 
 Set the direction to input 
 Set the pin as McASP pin 
 Set the pin as GPIO pin 
 Set the direction to output 
 Set the direction to input 
 Set the pin as GPIO pin 
 CONFIG_GPIOLIB 
 CONFIG_GPIOLIB 
 All PINS as McASP 
 Skip audio related setup code if the configuration is not adequat 
		
		  According to the TRM there should be 0x200 offset added to
		  the DAT port address
 RX is not valid in DIT mode 
 dma_params->dma_addr is pointing to the data port address 
	 Allocate memory for long enough list for all possible
	  scenarios. Maximum number tdm slots is 32 and there cannot
	  be more serializers than given in the configuration.  The
	  serializer directions could be taken into account, but it
	  would make code much more complex and save only couple of
	  bytes.
 SPDX-License-Identifier: GPL-2.0
   Copyright (C) 2020 Texas Instruments Incorporated - http:www.ti.com
   Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
  Maximum number of configuration entries for prefixes:
  CPB: 2 (mcasp10 + codec)
  IVI: 3 (mcasp0 + 2x codec)
 Reset TDM slots to 32 
 Set up initial clock configuration 
 Set initial tdm slots 
 CPB pcm3168a 
 PLL15 
 PLL4 
 CPB pcm3168a + 2x pcm3168a on IVI 
 PLL15 
 PLL4 
 CPB pcm3168a 
 PLL4 
	
	  Common Processor Board, two links
	  Link 1: McASP10 -> pcm3168a_1 DAC
	  Link 2: McASP10 <- pcm3168a_1 ADC
	
	  IVI extension, two links
	  Link 1: McASP0 -> pcm3168a_a DAC
	 		  \> pcm3168a_b DAC
	  Link 2: McASP0 <- pcm3168a_a ADC
	 		   \ pcm3168a_b ADC
 SPDX-License-Identifier: GPL-2.0
   Copyright (C) 2020 Texas Instruments Incorporated - https:www.ti.com
   Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
 SPDX-License-Identifier: GPL-2.0-only
  ASoC driver for TI DAVINCI EVM platform
  Author:      Vladimir Barinov, <vbarinov@embeddedalley.com>
  Copyright:   (C) 2007 MontaVista Software, Inc., <source@mvista.com>
 set the codec system clock 
 set the CPU system clock 
 davinci-evm machine dapm widgets 
 davinci-evm machine audio_mapnections to the codec pins 
 Headphone connected to HPLOUT, HPROUT 
 Line Out connected to LLOUT, RLOUT 
 Mic connected to (MIC3L | MIC3R) 
 Line In connected to (LINE1L | LINE2L), (LINE1R | LINE2R) 
 Logic for a aic3x as connected on a davinci-evm 
 Add davinci-evm specific widgets 
 Set up davinci-evm specific audio path audio_map 
 not connected 
 davinci-evm digital audio interface glue - connects codec <--> CPU 
 davinci dm6446 evm audio machine driver 
  ASP0 in DM6446 EVM is clocked by U55, as configured by
  board-dm644x-evm.c using GPIOs from U18.  There are six
  options; here we "know" we use a 48 KHz sample rate.
 davinci dm355 evm audio machine driver 
 ASP1 on DM355 EVM is clocked by an external oscillator 
 davinci dm365 evm audio machine driver 
 davinci dm6467 evm audio machine driver 
  The struct is used as place holder. It will be completely
  filled with data from dt node.
 sentinel  }
 davinci evm audio machine driver 
	
	  If dtb is there, the devices will be created dynamically.
	  Only register platfrom driver structure.
 SPDX-License-Identifier: GPL-2.0-only
  rx51.c  --  SoC audio for Nokia RX-51
  Copyright (C) 2008 - 2009 Nokia Corporation
  Contact: Peter Ujfalusi <peter.ujfalusi@ti.com>
           Eduardo Valentin <eduardo.valentin@nokia.com>
           Jarkko Nikula <jarkko.nikula@bitmer.com>
 tv-out with stereo output 
 headphone: stereo output, no mic 
 headset: stereo output with mic 
 Set the codec system clock for DAC and ADC 
 AV jack detection 
 prepare gpio for snd_soc_jack_add_gpios 
 Digital audio interface glue - connects codec <--> CPU 
 Audio card 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2019 Spreadtrum Communications Inc.
		
		  Configure the link-list address for the DMA engine link-list
		  mode.
		
		  We configure the DMA request mode, interrupt mode, channel
		  mode and channel trigger mode by the flags.
		
		  We just get current transfer address from the DMA engine, so
		  we need convert to current pointer.
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2019 Spreadtrum Communications Inc.
 MCDT registers definition 
 Channel water mark definition 
 DMA channel select definition 
 DMA channel ACK select definition 
 Channel FIFO definition 
  sprd_mcdt_chan_write - write data to the MCDT channel's fifo
  @chan: the MCDT channel
  @tx_buf: send buffer
  @size: data size
  Note: We can not write data to the channel fifo when enabling the DMA mode,
  otherwise the channel fifo data will be invalid.
  If there are not enough space of the channel fifo, it will return errors
  to users.
  Returns 0 on success, or an appropriate error code on failure.
  sprd_mcdt_chan_read - read data from the MCDT channel's fifo
  @chan: the MCDT channel
  @rx_buf: receive buffer
  @size: data size
  Note: We can not read data from the channel fifo when enabling the DMA mode,
  otherwise the reading data will be invalid.
  Usually user need start to read data once receiving the fifo full interrupt.
  Returns data size of reading successfully, or an error code on failure.
  sprd_mcdt_chan_int_enable - enable the interrupt mode for the MCDT channel
  @chan: the MCDT channel
  @water_mark: water mark to trigger a interrupt
  @cb: callback when a interrupt happened
  Now it only can enable fifo almost full interrupt for ADC channel and fifo
  almost empty interrupt for DAC channel. Morevoer for interrupt mode, user
  should use sprd_mcdt_chan_read() or sprd_mcdt_chan_write() to read or write
  data manually.
  For ADC channel, user can start to read data once receiving one fifo full
  interrupt. For DAC channel, user can start to write data once receiving one
  fifo empty interrupt or just call sprd_mcdt_chan_write() to write data
  directly.
  Returns 0 on success, or an error code on failure.
  sprd_mcdt_chan_int_disable - disable the interrupt mode for the MCDT channel
  @chan: the MCDT channel
  sprd_mcdt_chan_dma_enable - enable the DMA mode for the MCDT channel
  @chan: the MCDT channel
  @dma_chan: specify which DMA channel will be used for this MCDT channel
  @water_mark: water mark to trigger a DMA request
  Enable the DMA mode for the MCDT channel, that means we can use DMA to
  transfer data to the channel fifo and do not need readingwriting data
  manually.
  Returns 0 on success, or an error code on failure.
  sprd_mcdt_chan_dma_disable - disable the DMA mode for the MCDT channel
  @chan: the MCDT channel
  sprd_mcdt_request_chan - request one MCDT channel
  @channel: channel id
  @type: channel type, it can be one ADC channel or DAC channel
  Rreturn NULL if no available channel.
  sprd_mcdt_free_chan - free one MCDT channel
  @chan: the channel to be freed
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2019 Spreadtrum Communications Inc.
 Default values if userspace does not set 
 DSP FIFO size 
 Stage 0 IRAM buffer size definition 
 Stage 1 DDR buffer size definition 
  The Spreadtrum Audio compress offload mode will use 2-stage DMA transfer to
  save power. That means we can request 2 dma channels, one for source channel,
  and another one for destination channel. Once the source channel's transaction
  is done, it will trigger the destination channel's transaction automatically
  by hardware signal.
  For 2-stage DMA transfer, we can allocate 2 buffers: IRAM buffer (always
  power-on) and DDR buffer. The source channel will transfer data from IRAM
  buffer to the DSP fifo to decodingencoding, once IRAM buffer is empty by
  transferring done, the destination channel will start to transfer data from
  DDR buffer to IRAM buffer.
  Since the DSP fifo is only 512B, IRAM buffer is allocated by 32K, and DDR
  buffer is larger to 2M. That means only the IRAM 32k data is transferred
  done, we can wake up the AP system to transfer data from DDR to IRAM, and
  other time the AP system can be suspended to save power.
 DMA engine channel number 
 Stage 0 IRAM buffer 
 Stage 1 DDR buffer 
 DSP play information IRAM buffer 
 Data size copied to IRAM buffer 
 Total received data size from userspace 
 Stage 0 IRAM buffer received data size 
 Stage 1 DDR buffer received data size 
 Stage 1 DDR buffer pointer 
 Update data size copied to IRAM buffer 
	
	  Configure the link-list address for the DMA engine link-list
	  mode.
	
	  We configure the DMA request mode, interrupt mode, channel
	  mode and channel trigger mode by the flags.
 Only channel 1 transfer can wake up the AP system. 
	
	  Configure the DMA engine 2-stage transfer mode. Channel 1 set as the
	  destination channel, and channel 0 set as the source channel, that
	  means once the source channel's transaction is done, it will trigger
	  the destination channel's transaction automatically.
	
	  Allocate the stage 0 IRAM buffer size, including the DMA 0
	  link-list size and play information of DSP address size.
 Use to save link-list configuration for DMA 0. 
 Use to update the current data offset of DSP. 
	
	  Allocate the stage 1 DDR buffer size, including the DMA 1 link-list
	  size.
 Use to save link-list configuration for DMA 1. 
	
	  We usually set fragment size as 32K, and the stage 0 IRAM buffer
	  size is 32K too. So if now the received data size of the stage 0
	  IRAM buffer is less than 32K, that means we have some available
	  spaces for the stage 0 IRAM buffer.
			
			  Copy data to the stage 0 IRAM buffer directly if
			  spaces are enough.
			
			  If the data count is larger than the available spaces
			  of the stage 0 IRAM buffer, we should copy one
			  partial data to the stage 0 IRAM buffer, and copy
			  the left to the stage 1 DDR buffer.
	
	  Copy data to the stage 1 DDR buffer if no spaces for the stage 0 IRAM
	  buffer.
 Update the copied data size. 
 SPDX-License-Identifier: GPL-2.0-only
  IMG I2S output controller driver
  Copyright (C) 2015 Imagination Technologies Ltd.
  Author: Damien Horsley <Damien.Horsley@imgtec.com>
 If diffs are equal, use lower clock rate 
	
	  Another driver (eg alsa machine driver) may have rejected the above
	  change. Get the current rate and set the register bit according to
	  the new minimum diff
 SPDX-License-Identifier: GPL-2.0-only
  IMG parallel output controller driver
  Copyright (C) 2015 Imagination Technologies Ltd.
  Author: Damien Horsley <Damien.Horsley@imgtec.com>
 SPDX-License-Identifier: GPL-2.0-only
  IMG SPDIF output controller driver
  Copyright (C) 2015 Imagination Technologies Ltd.
  Author: Damien Horsley <Damien.Horsley@imgtec.com>
 If diffs are equal, use lower clock rate 
	
	  Another driver (eg machine driver) may have rejected the above
	  change. Get the current rate and set the register bit according to
	  the new min diff
 SPDX-License-Identifier: GPL-2.0-only
  Pistachio internal dac driver
  Copyright (C) 2015 Imagination Technologies Ltd.
  Author: Damien Horsley <Damien.Horsley@imgtec.com>
 codec private data 
 SPDX-License-Identifier: GPL-2.0-only
  IMG I2S input controller driver
  Copyright (C) 2015 Imagination Technologies Ltd.
  Author: Damien Horsley <Damien.Horsley@imgtec.com>
	
	  BLKP and LRD must be set during separate register writes
 SPDX-License-Identifier: GPL-2.0-only
  IMG SPDIF input controller driver
  Copyright (C) 2015 Imagination Technologies Ltd.
  Author: Damien Horsley <Damien.Horsley@imgtec.com>
 Write-only registers 
 Clock rate must be at least 24x the bit rate 
	
	  Calculate oversampling ratio, nominal phase increment and hold
	  increment for the given rate  frequency
 SPDX-License-Identifier: GPL-2.0-or-later
   als300.c - driver for Avance Logic ALS300ALS300+ soundcards.
   Copyright (C) 2005 by Ash Willis <ashwillis@programmer.net>
   TODO
   4 channel playback for ALS300+
   gameport
   mpu401
   opl3
   NOTES
   The BLOCK_COUNTER registers for the ALS300(+) return a figure related to
   the position in the current period, NOT the whole buffer. It is important
   to know which period we are in so we can calculate the correct pointer.
   This is why we always use 2 periods. We can then use a flip-flop variable
   to keep track of what period we are in.
 snd_als300_set_irq_flag 
 IO port layout 
 ALS300 Only 
 ALS300+ Only 
 ALS300 Rev. E+, ALS300+ 
 ALS300+ Only 
 General Control Registers 
 ALS300 or ALS300+ 
 EnableDisable Interrupts 
	 boolean XOR check, since old vs. new hardware have
	   directly reversed bit setting for ENABLE and DISABLE.
 shared IRQ, for different device?? Exit ASAP! 
 ACK everything ASAP 
 shared IRQ, for different device?? Exit ASAP! 
	 FIXME: Ack other interrupt types. Not important right now as
 hardware definition
  In AC97 mode, we always use 48k16bitstereo.
  Any request to change data type is ignored by
  the card when it is running outside of legacy
  mode.
 set block size 
 set dma area 
 set block size 
 set dma area 
 set operators 
 pre-allocation of buffers 
 Setup DRAM 
 Enable IRQ output 
	 Unmute hardware devices so their outputs get routed to
 Reset volumes 
 Make sure playback transfer is stopped 
		 don't know much about ALS300+ yet
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA modem driver for Intel ICH (i8x0) chipsets
 	Copyright (c) 2000 Jaroslav Kysela <perex@perex.cz>
    This is modified (by Sasha Khapyorsky <sashak@alsa-project.org>) version
    of ALSA ICH sound driver intel8x0.c .
 Exclude the first card 
 ID for this card 
 just for backward compatibility 
   Direct registers
 dword - buffer descriptor list base address  \
 byte - current index value  \
 byte - last valid index  \
 byte - status register  \
 word - position in current buffer  \
 byte - prefetched index value  \
 byte - control register  \
 busmaster blocks 
 offset 
 values for each busmaster block 
 LVI 
 SR 
 FIFO error 
 buffer completion interrupt status 
 last valid buffer completion interrupt 
 current equals last valid 
 DMA controller halted 
 PIV 
 mask 
 CR 
 interrupt on completion enable 
 fifo error interrupt enable 
 last valid buffer interrupt enable 
 reset busmaster registers 
 start busmaster operation 
 global block 
 dword - global control 
 tertiary resume interrupt enable 
 secondary resume interrupt enable 
 primary resume interrupt enable 
 AClink shut off 
 AC'97 warm reset 
 AC'97 cold reset 
 GPI interrupt enable 
 dword - global status 
 ICH4: tertiary (AC_SDIN2) resume interrupt 
 ICH4: tertiary (AC_SDIN2) codec ready 
 ICH4: bit clock stopped 
 ICH4: SPDIF interrupt 
 ICH4: PCM2-In interrupt 
 ICH4: Mic2-In interrupt 
 ICH4: sample capability bits (RO) 
 ICH4: multi-channel capability bits (RO) 
 modem power down semaphore 
 audio power down semaphore 
 read completion status 
 bit 3 slot 12 
 bit 2 slot 12 
 bit 1 slot 12 
 secondary (AC_SDIN1) resume interrupt 
 primary (AC_SDIN0) resume interrupt 
 secondary (AC_SDIN1) codec ready 
 primary (AC_SDIN0) codec ready 
 MIC capture interrupt 
 playback interrupt 
 capture interrupt 
 nforce spdif interrupt 
 modem playback interrupt 
 modem capture interrupt 
 GPI status change interrupt 
 byte - codec write semaphore 
 codec access semaphore 
 max hw frags 
 ich device number 
 offset to bmaddr 
 CPU address (32bit) 
 PCI bus address (32bit) 
 physical address (32bit) 
 interrupt status mask 
 ALI DMA slot 
 interrupt status register 
 interrupt status mask 
 82801AA 
 82901AB 
 82801BA 
 ICH3 
 ICH4 
 ICH5 
 ICH6 
 ICH7 
 440MX 
 AMD768 
 SI7013 
 NFORCE 
 NFORCE2 
 NFORCE2s 
 NFORCE3 
 AMD8111 
 Ali5455 
   Lowlevel IO - busmaster
   Lowlevel IO - AC'97 registers
   Basic IO
  access to AC97 codec via normal io (for ICH and SIS7013)
 return the GLOB_STA bit for the corresponding codec 
 codec ready ? 
 Anyone holding a semaphore for 1 msec should be shot... 
	 access to some forbidden (non existent) ac97 registers will not
	  reset the semaphore. So even if you don't get the semaphore, still
 clear semaphore flag 
 I don't care about the semaphore 
 reset RCS and preserve other RWC bits 
 clear semaphore 
  DMA IO
 interrupt on completion 
 interrupt on completion 
 interrupt on completion 
			
			dev_dbg(chip->card->dev, "bdbar[%i] = 0x%x [0x%x]\n",
			       idx + 0, bdbar[idx + 0], bdbar[idx + 1]);
 clear interrupts 
   Interrupt handler
 snd_printd("civ same %d\n", civ);
 if (step != 1)
	snd_printd("step = %d, %d -> %d\n", step, ichdev->civ, civ);
 we are not yet resumed 
 ack them 
   PCM part
 wait until DMA stopped 
 reset whole DMA things 
 activate PCM only when associated AC'97 codec 
   Mixer part
 clear the cold-reset bit for the next chance 
 put logic to right state 
 first clear status bits 
 ACLink on, 2 channels 
 finish cold or do warm reset 
 give warm reset some time 
		 wait for any codec ready status.
		  Once it becomes ready it should remain ready
		  as long as we do not disable the ac97 link.
 no codec is found 
 up to two codecs (modem cannot be tertiary with ICH4) 
 wait for other codecs ready status. 
 resume phase 
 wait until all the probed codecs are ready 
 unmute the output on SIS7012 
 clear semaphore flag 
 disable interrupts 
 reset channels 
 initialize Buffer Descriptor Lists 
 disable interrupts 
 reset channels 
  power management
 CONFIG_PM_SLEEP 
 ALI5455 has no ac97 region 
 ICH4 and Nforce 
 ICH4 
 initialize offsets 
 SiS 7013 swaps the registers 
 SIS7013 handles the pcm data in bytes, others are in words 
 allocate buffer descriptor lists 
 the start of each lists must be aligned to 8 bytes 
	 tables must be aligned to 8 bytes here, but the kernel pages
	 NOTE: we don't use devm version here since it's released 
	  re-acquired in PM callbacks.
	  It's released explicitly in snd_intel8x0m_free(), too.
 SPDX-License-Identifier: GPL-2.0-or-later
  azt3328.c - driver for Aztech AZF3328 based soundcards (e.g. PCI168).
   Copyright (C) 2002, 2005 - 2011 by Andreas Mohr <andi AT lisas.de>
   Framework borrowed from Bart Hartgers's als4000.c.
   Driver developed on PCI168 AP(W) version (PCI rev. 10, subsystem ID 1801),
   found in a Fujitsu-Siemens PC ("Cordant", aluminum case).
   Other versions are:
   PCI168 A(W), sub ID 1800
   PCI168 AAP, sub ID 8000
   Please give me feedback in case you try my driver with one of these!!
   Keywords: Windows XP Vista 168nt4-125.zip 168win95-125.zip PCI 168 download
   (XPVista do not support this card at all but every Linux distribution
    has very good support out of the box;
    just to make sure that the right people hit this and get to know that,
    despite the high level of Internet ignorance - as usual :-P -
    about very good support for this card - on Linux!)
  NOTES
   Since Aztech does not provide any chipset documentation,
   even on repeated request to various addresses,
   and the answer that was finally given was negative
   (and I was stupid enough to manage to get hold of a PCI168 soundcard
   in the first place >:-P}),
   I was forced to base this driver on reverse engineering
   (3 weeks' worth of evenings filled with driver work).
   (and no, I did NOT go the easy way: to pick up a SB PCI128 for 9 Euros)
   It is quite likely that the AZF3328 chip is the PCI cousin of the
   AZF3318 ("azt1020 pnp", "MM Pro 16") ISA chip, given very similar specs.
   The AZF3328 chip (note: AZF3328, not AZT3328, that's just the driver name
   for compatibility reasons) from Azfin (joint-venture of Aztech and Fincitec,
   Fincitec acquired by National Semiconductor in 2002, together with the
   Fincitec-related company ARSmikro) has the following features:
   - compatibility & compliance:
     - Microsoft PC 97 ("PC 97 Hardware Design Guide",
                        http:www.microsoft.comwhdcarchivepcguides.mspx)
     - Microsoft PC 98 Baseline Audio
     - MPU401 UART
     - Sound Blaster Emulation (DOS Box)
   - builtin AC97 conformant codec (SNR over 80dB)
     Note that "conformant" != "compliant"!! this chip's mixer register layout
     differs from the standard AC97 layout:
     they chose to not implement the headphone register (which is not a
     problem since it's merely optional), yet when doing this, they committed
     the grave sin of letting other registers follow immediately instead of
     keeping a headphone dummy register, thereby shifting the mixer register
     addresses illegally. So far unfortunately it looks like the very flexible
     ALSA AC97 support is still not enough to easily compensate for such a
     grave layout violation despite all tweaks and quirks mechanisms it offers.
     Well, not quite: now ac97 layer is much improved (bus-specific ops!),
     thus I was able to implement support - it's actually working quite well.
     An interesting item might be Aztech AMR 2800-W, since it's an AC97
     modem card which might reveal the Aztech-specific codec ID which
     we might want to pretend, too. Dito PCI168's brother, PCI368,
     where the advertising datasheet says it's AC97-based and has a
     Digital Enhanced Game Port.
   - builtin genuine OPL3 - verified to work fine, 20080506
   - full duplex 16bit playbackrecord at independent sampling rate
   - MPU401 (+ legacy address support, claimed by one official spec sheet)
     FIXME: how to enable legacy addr??
   - game port (legacy address support)
   - builtin DirectInput support, helps reduce CPU overhead (interrupt-driven
     features supported). - See common term "Digital Enhanced Game Port"...
     (probably DirectInput 3.0 spec - confirm)
   - builtin 3D enhancement (said to be YAMAHA Ymersion)
   - built-in General DirectX timer having a 20 bits counter
     with 1us resolution (see below!)
   - I2S serial output port for external DAC
     [FIXME: 3.3V or 5V level? maximum rate is 66.2kHz right?]
   - supports 33MHz PCI spec 2.1, PCI power management 1.0, compliant with ACPI
   - supports hardware volume control
   - single chip low cost solution (128 pin QFP)
   - supports programmable Sub-vendor and Sub-system ID [24C02 SEEPROM chip]
     required for Microsoft's logo compliance (FIXME: where?)
     At least the Trident 4D Wave DX has one bit somewhere
     to enable writes to PCI subsystem VID registers, that should be it.
     This might easily be in extended PCI reg space, since PCI168 also has
     some custom data starting at 0x80. What kind of config settings
     are located in our extended PCI space anyway??
   - PCI168 AP(W) card: power amplifier with 4 Wattschannel at 4 Ohms
     [TDA1517P chip]
   Note that this driver now is actually better than the Windows driver,
   since it additionally supports the card's 1MHz DirectX timer - just try
   the following snd-seq module parameters etc.:
   - options snd-seq seq_default_timer_class=2 seq_default_timer_sclass=0
     seq_default_timer_card=0 seq_client_load=1 seq_default_timer_device=0
     seq_default_timer_subdevice=0 seq_default_timer_resolution=1000000
   - "timidity -iAv -B2,8 -Os -EFreverb=0"
   - "pmidi -p 128:0 jazz.mid"
   OPL3 hardware playback testing, try something like:
   cat procasoundhwdep
   and
   aconnect -o
   Then use
   sbiload -Dhw:x,y --opl3 usrsharesoundsopl3std.o3 .......drums.o3
   where x,y is the xx-yy number as given in hwdep.
   Then try
   pmidi -p a:b jazz.mid
   where a:b is the client number plus 0 usually, as given by aconnect above.
   Oh, and make sure to unmute the FM mixer control (doh!)
   NOTE: power use during OPL3 playback is _VERY_ high (70W --> 90W!)
   despite no CPU activity, possibly due to hindering ACPI idling somehow.
   Shouldn't be a problem of the AZF3328 chip itself, I'd hope.
   Higher PCM  FM mixer levels seem to conflict (causes crackling),
   at least sometimes.   Maybe even use with hardware sequencer timer above :)
   adplayadplug-utils might soon offer hardware-based OPL3 playback, too.
   Certain PCI versions of this card are susceptible to DMA traffic underruns
   in some systems (resulting in sound cracklingclickingpopping),
   probably because they don't have a DMA FIFO buffer or so.
   Overview (PCI IDPCI subIDPCI rev.):
   - no DMA crackling on SiS735: 0x50DC0x180116
   - unknown performance: 0x50DC0x180110
     (well, it's not bad on an Athlon 1800 with now very optimized IRQ handler)
   Crackling happens with VIA chipsets or, in my case, an SiS735, which is
   supposed to be very fast and supposed to get rid of crackling much
   better than a VIA, yet ironically I still get crackling, like many other
   people with the same chipset.
   Possible remedies:
   - use speaker (amplifier) output instead of headphone output
     (in case crackling is due to overloaded output clipping)
   - plug card into a different PCI slot, preferably one that isn't shared
     too much (this helps a lot, but not completely!)
   - get rid of PCI VGA card, use AGP instead
   - upgrade or downgrade BIOS
   - fiddle with PCI latency settings (setpci -v -s BUSID latency_timer=XX)
     Not too helpful.
   - Disable ACPIpower management"Auto Detect RAMPCI Clk" in BIOS
  BUGS
   - full-duplex might still be problematic, however a recent test was fine
   - (non-bug) "BassTreble or 3D settings don't work" - they do get evaluated
     if you set PCM output switch to "pre 3D" instead of "post 3D".
     If this can't be set, then get a mixer application that Isn't Stupid (tm)
     (e.g. kmix, gamix) - unfortunately several are!!
   - locking is not entirely clean, especially the audio stream activity
     ints --> may be racy
   - an _unconnected_ secondary joystick at the gameport will be reported
     to be "active" (floating values, not precisely -1) due to the way we need
     to read the Digital Enhanced Game Port. Not sure whether it is fixable.
  TODO
   - use PCI_VDEVICE
   - verify driver status on x86_64
   - test multi-card driver operation
   - (ab)use 1MHz DirectX timer as kernel clocksource
   - test MPU401 MIDI playback etc.
   - add more power micro-management (disable various units of the card
     as long as they're unused, to improve audio quality and save power).
     However this requires more IO ports which I haven't figured out yet
     and which thus might not even exist...
     The standard suspendresume functionality could probably make use of
     some improvement, too...
   - figure out what all unknown port bits are responsible for
   - figure out some cleverly evil scheme to possibly make ALSA AC97 code
     fully accept our quite incompatible ""AC97"" mixer and thus save some
     code (but I'm not too optimistic that doing this is possible at all)
   - use MMIO (memory-mapped IO)? Slightly faster access, e.g. for gameport.
 WARN_ONCE 
  Config switch, to use ALSA's AC97 layer instead of old custom mixer crap.
  If the AC97 compatibility parts we needed to implement locally turn out
  to work nicely, then remove the old implementation eventually.
 === Debug settings ===
  Further diagnostic functionality than the settings below
  does not need to be provided, since one can easily write a POSIX shell script
  to dump the card's IO ports (those listed in lspci -v -v):
  dump()
  {
    local descr=$1; local addr=$2; local count=$3
    echo "${descr}: ${count} @ ${addr}:"
    dd if=devport skip=`printf %d ${addr}` count=${count} bs=1 \
      2>devnull| hexdump -C
  }
  and then use something like
  "dump joy200 0x200 8", "dump mpu388 0x388 4", "dump joy 0xb400 8",
  "dump codec00 0xa800 32", "dump mixer 0xb800 64", "dump synth 0xbc00 8",
  possibly within a "while true; do ... sleep 1; done" loop.
  Tweaking ports could be done using
  VALSTRING="`printf "%02x" $value`"
  printf "\x""$VALSTRING"|dd of=devport seek=`printf %d ${addr}` bs=1 \
    2>devnull
 Index 0-MAX 
 ID for this card 
 Enable this card 
 warning: fixed indices (also used for bitmask checks!) 
 keep first! (avoid offset calc) 
 helper to avoid an indirection in hotpath 
 TODO: convert to our own per-codec lock member 
 often-used fields towards beginning, then grouped 
 usually 0xb000, size 128 
 usually 0xb400, size 8 
 usually 0xb800, size 4 
 usually 0xbc00, size 8 
 usually 0xc000, size 64 
 playback, recording and I2S out codecs 
	 register 0x6a is write-only, thus need to remember setting.
	  If we need to add more registers here, then we might try to fold this
	  into some transparent combined shadow register handling with
	 register value containers for power management
 PCI1683328 
 3328 
	 Well, strictly spoken, the inboutb sequence isn't atomic
	   and would need locking. However we currently don't care
	 we need to always write the new value no matter whether it differs
	 the mute bit is on the second (i.e. right) register of a
 indicate whether it was muted before 
	 reset (close) mixer:
	  first mute master volume, then reset
 need to add some more or less clever emulation? 
  Need to have _special_ AC97 mixer hardware register index mapper,
  to compensate for the issue of a rather AC97-incompatible hardware layout.
		 Especially when taking into consideration
		  monostereo-based sequence of azf vs. AC97 control series,
		  it's quite obvious that azf simply got rid
		  of the AC97_HEADPHONE control at its intended offset,
		  thus shifted _all_ controls by one,
		  and _then_ simply added it as an FMSYNTH control at the end,
		  to make up for the offset.
		  This means we'll have to translate indices here as
		  needed and then do some tiny AC97 patch action
		  (snd_ac97_rename_vol_ctl() etc.) - that's it.
 AC97_RESET  IDX_MIXER_RESET
 AC97_MASTER  IDX_MIXER_PLAY_MASTER },
 note large shift: AC97_HEADPHONE to IDX_MIXER_FMSYNTH! 
 AC97_HEADPHONE  IDX_MIXER_FMSYNTH },
 AC97_MASTER_MONO  IDX_MIXER_MODEMOUT },
 AC97_MASTER_TONE  IDX_MIXER_BASSTREBLE },
 AC97_PC_BEEP  IDX_MIXER_PCBEEP },
 AC97_PHONE  IDX_MIXER_MODEMIN },
 AC97_MIC  IDX_MIXER_MIC },
 AC97_LINE  IDX_MIXER_LINEIN },
 AC97_CD  IDX_MIXER_CDAUDIO },
 AC97_VIDEO  IDX_MIXER_VIDEO },
 AC97_AUX  IDX_MIXER_AUX },
 AC97_PCM  IDX_MIXER_WAVEOUT },
 AC97_REC_SEL  IDX_MIXER_REC_SELECT },
 AC97_REC_GAIN  IDX_MIXER_REC_VOLUME },
 AC97_REC_GAIN_MIC  AZF_AC97_REG_EMU_IO_RW },
 AC97_GENERAL_PURPOSE  IDX_MIXER_ADVCTL2 },
 AC97_3D_CONTROL  IDX_MIXER_ADVCTL1 },
	 azf3328 supports the low-numbered and low-spec:ed range
 a translation-only entry means it's real readwrite: 
			 I don't know what the hll AC97 layer
			  would consult this _extended_ register for
			  given a base-AC97-advertised card,
			  but let's just emulate it anyway :-P
 Headphone is an FM Synth control here 
 no AC97_BC_LOUDNESS! 
	 mask 0x7c00 is
	   vendor-specific 3D enhancement
	   vendor indicator.
	   Since there actually _is_ an
	   entry for Aztech Labs
	   (13), make damn sure
 pretend everything to be active 
  Emulated, _inofficial_ vendor ID
  (there might be some devices such as the MR 2800-W
  which could reveal the real Aztech AC97 ID).
  We choose to use "AZT" prefix, and then use 1 to indicate PCI168
  (better don't use 0x68 since there's a PCI368 as well).
			
			  Proceed with dummy IO read,
			  to ensure compatible timing where this may matter.
			  (ALSA AC97 layer usually doesn't call IO functions
			  due to intelligent IO caching anyway)
			  Choose a mixer register that's thoroughly unrelated
			  to common audio (try to minimize distortion).
 AFAICS we simply can't support anything: 
				
				  Silently swallow these writes.
				  Since for most registers our card doesn't
				  actually support a comparable feature,
				  this is exactly what we should do here.
				  The AC97 layer's IO caching probably
				  automatically takes care of all the rest...
				  (remembers written values etc.)
 we support audio! 
	
	  ALSA's AC97 layer has terrible init crackling issues,
	  unfortunately, and since it makes use of AC97_RESET,
	  there's no use trying to mute Master Playback proactively.
		
		  Make sure to complain loudly in case of AC97 init failure,
		  since failure may happen quite often,
		  due to this card being a very quirky AC97 "lookalike".
	 If we return an error here, then snd_card_free() should
	  free up any ac97 codecs that got created, as well as the bus.
 AZF_USE_AC97_LAYER 
 take care of muting flag contained in left channel 
			 during volume change, the right channel is crackling
			  somewhat more than the left channel, unfortunately.
  general mixer element
  mixer switchesvolumes
 it's a volume control, so better take care 
 just set both channels, doesn't matter 
 modem out sel 
 mono sel source 
 PCM Out Path 
 PCM Out Path, place in front since it controls both 3D and BassTreble! 
 "3D Width" 
 "Hifi 3D" 
 mixer reset 
 mute and zero volume channels 
 add mixer controls 
 AZF_USE_AC97_LAYER 
 the AZF3328 names it "5510" for some strange reason 
 val = 0xff07; 3m27.993s (65301Hz; -> 64000Hz???) hmm, 66120, 65967, 66123 
 val = 0xff09; 17m15.098s (13123,478Hz; -> 12000Hz???) hmm, 13237.2Hz? 
 val = 0xff0a; 47m30.599s (4764,891Hz; -> 4800Hz???) yup, 4803Hz 
 val = 0xff0c; 57m0.510s (4010,263Hz; -> 4000Hz???) yup, 4003Hz 
 val = 0xff05; 5m11.556s (... -> 44100Hz) 
 val = 0xff03; 10m21.529s (21872,463Hz; -> 22050Hz???) 
 val = 0xff0f; 20m41.883s (10937,993Hz; -> 11025Hz???) 
 val = 0xff0d; 41m23.135s (5523,600Hz; -> 5512Hz???) 
 val = 0xff0e; 28m30.777s (8017Hz; -> 8000Hz???) 
 set bitrateformat 
	 changing the bitrateformat settings switches off the
	  audio output with an annoying click in case of 816bit format change
	  (maybe shutting down DACADC?), thus immediately
	  do some tweaking to reenable it and get rid of the clicking
	  (FIXME: yes, it works, but what exactly am I doing here?? :)
	  FIXME: does this have some side effects for full-duplex
 do it for non-capture codecs only 
	 choose lowest frequency for low power consumption.
	  While this will cause louder noise due to rather coarse frequency,
	  it should never matter since output should always
	 no idea what exactly is being done here, but I strongly assume it's
			 if enable codec, call enable_codecs func
			 ...otherwise call enable_codecs func
			   (which globally shuts down operation of codecs)
			   only in case the other codecs are currently
		 ...and adjust clock, too
 AZF3328 uses a two buffer pointer DMA transfer approach 
 width 32bit (prevent overflow): 
		 Hmm, are we really supposed to decrement this by 1??
		   Most definitely certainly not: configuring full length does
		   work properly (i.e. likely better), and BTW we
		   violated possibly differing frame sizes with this...
		area_length--; | max. index |
 build combined IO buffer length word 
 mute WaveOut (avoid clicking during setup) 
 first, remember current value: 
 stop transfer 
 FIXME: clear interrupts or what??? 
 FIXME: enable playbackrecording??? 
 start transfer again 
 FIXME: what is this value (0x0010)??? 
 NT4 
 now unmute WaveOut 
 resume codec if we were active 
 mute WaveOut (avoid clicking during setup) 
 first, remember current value: 
 stop transfer 
		 hmm, is this really required? we're resetting the same bit
 now unmute WaveOut 
 make sure codec is stopped 
 calculate offset 
	
	  skeleton handler only
	  (we do not want axis reading in interrupt handler - too much load!)
 this should ACK the gameport IRQ properly, hopefully. 
	 ok, this one is a bit dirty: cooked_read is being polled by a timer,
	  thus we're atomic and cannot actively wait in here
	  (which would be useful for us since it probably would be better
	  to trigger a measurement in here, then wait a short amount of
	  time until it's finished, then read values of _this_ measurement).
	 
	  Thus we simply resort to reading values if they're available already
	  and trigger the next measurement.
 configure the axis to read 
	 trigger next sampling of axes, to be evaluated the next time we
	 for some very, very strange reason we cannot enable
	  Measurement Ready monitoring for all axes here,
 we're able to monitor axes 1 and 2 only 
 seems ok 
 DISABLE legacy address: we don't need it! 
 SUPPORT_GAMEPORT 
 skip codec if there's no interrupt for it 
 ack all IRQ types immediately 
 fast path out, to ease interrupt sharing 
 must be interrupt for another device 
 debug-only ,
		 dev_dbg(chip->card->dev, "timer %ld\n",
			snd_azf3328_codec_inl(chip, IDX_IO_TIMER_VALUE)
				& TIMER_VALUE_MASK
 ACK timer 
	 MPU401 has less critical IRQ requirements
		 hmm, do we have to ack the IRQ here somehow?
 as long as we think we have identical snd_pcm_hardware parameters
   for playback, capture and i2s out, we can use the same physical struct
   since the struct is simply being copied into a member.
 FIXME!! Correct? 
	 We simply have two DMA areas (instead of a list of descriptors
	   such as other cards); I believe that this is a fixed hardware
	   attribute and there isn't much driver magic to be done to expand it.
	 FIXME: maybe that card actually has a FIFO?
	  Hmm, it seems newer revisions do have one, but we still don't know
 same parameters for all our codecs - at least we think so... 
 pcm devices 
 same pcm object for playbackcapture (see snd_pcm_new() above) 
 NOTE: the physical timer resolution actually is 1024000 ticks per second
  (probably derived from main crystal via a divider of 24),
  but announcing those attributes to user-space would make programs
  configure the timer to a 1 tick value, resulting in an absolutely fatal
  timer IRQ storm.
  Thus I chose to announce a down-scaled virtual timer to the outside and
  calculate real timer countdown values internally.
  (the scale factor can be set via module parameter "seqtimer_scaling").
		 uhoh, that's not good, since user-space won't know about
		  this timing tweak
 minimum time is 49 ticks 
 disable timer countdown and interrupt 
	 Hmm, should we write TIMER_IRQ_ACK here?
	   YES indeed, otherwise a rogue timer operation - which prompts
	   ALSA(?) to call repeated stop() in vain, but NOT start() -
	   will never end (value 0x03 is kept shown in control byte).
	   Simply manually poking 0x04 _once_ immediately successfully stops
 10000001024000 = 0.9765625us 
 max tick count, defined by the value register; actually it's not 1024000, but 1048576, but we don't care 
 check whether a bit can be modified 
 check if we can restrict PCI DMA transfers to 24 bits 
 create mixer interface & switches 
 standard codec init stuff 
 default DMA init value 
 shutdown codecs to reduce power  noise 
 have ...ctrl_codec_activity() act properly 
	 chose to use MPU401_HW_AZT2320 ID instead of MPU401_HW_MPU401,
 need to use IDs 1, 2 since ID 0 is snd_azf3328_timer above 
 make sure to disable master volume etc. to prevent looping sound 
 AZF_USE_AC97_LAYER 
	 unfortunately with 32bit transfers, IDX_MIXER_PLAY_MASTER (0x02)
	   and IDX_MIXER_RESET (offset 0x00) get touched at the same time,
	   resulting in a mixer reset condition persisting until _after_
 AZF_USE_AC97_LAYER 
 manually store the one currently relevant write-only reg, too 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0-or-later
   Driver for S3 SonicVibes soundcard
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
   BUGS:
     It looks like 86c617 rev 3 doesn't supports DDMA buffers above 16MB?
     Driver sometimes hangs... Nobody knows why at this moment...
 Index 0-MAX 
 ID for this card 
 Enable this card 
 DDMA io address 
  Enhanced port direct registers
 RW: CODECMixer control register 
 audio mode select - enhanced mode 
 test bit 
 reverb enable 
 wavetable active  FM active if not set 
 INTA driving - should be always 1 
 reset chip 
 RW: CODECMixer interrupt mask register 
 mask DMA-A interrupt 
 mask DMA-C interrupt 
 special interrupt mask - should be always masked 
 UpDown button interrupt mask 
 mask MIDI interrupt 
 RO: CODECMixer status register 
 DMA-A interrupt 
 DMA-C interrupt 
 special interrupt 
 UpDown interrupt 
 MIDI interrupt 
 RW: CODECMixer index address register 
 mode change enable 
 DMA transfer request disabled 
 RW: CODECMixer index data register 
  Enhanced port indirect registers
 Left ADC Input Control 
 Right ADC Input Control 
 Left AUX1 Input Control 
 Right AUX1 Input Control 
 Left CD Input Control 
 Right CD Input Control 
 Left Line Input Control 
 Right Line Input Control 
 MIC Input Control 
 Game Port Control 
 Left Synth Input Control 
 Right Synth Input Control 
 Left AUX2 Input Control 
 Right AUX2 Input Control 
 Left Analog Mixer Output Control 
 Right Analog Mixer Output Control 
 Left PCM Input Control 
 Right PCM Input Control 
 DMA Data Format 
 PlaybackCapture Enable Register 
 UpDown Button Register 
 Revision 
 ADC Output Control 
 DMA A Upper Base Count 
 DMA A Lower Base Count 
 DMA C Upper Base Count 
 DMA C Lower Base Count 
 PCM Sampling Rate Low Byte 
 PCM Sampling Rate High Byte 
 Synthesizer Sampling Rate Low Byte 
 Synthesizer Sampling Rate High Byte 
 ADC Clock Source Selection 
 ADC Alternative Sampling Rate Selection 
 ADC PLL M Register 
 ADC PLL N Register 
 Synthesizer PLL M Register 
 Synthesizer PLL N Register 
 MPU-401 UART Operation 
 Drive Control 
 SRS Space Control 
 SRS Center Control 
 Wavetable Sample Source Select 
 Analog Power Down Control 
 Digital Power Down Control 
   DMA registers
   Record sources
   constants
 S3FM 
   common IO routines
 note: dmac is working in word mode!!! 
 note: dmac is working in word mode!!! 
 slight violation of specs, needed for continuous sampling rates 
 35 
 use the alternate clock 
 use the PLL source 
 failure 
   PCM part
   Mixer part
 enable PCI device 
 check, if we can restrict PCI DMA transfers to 24 bits 
 enable + enhanced 
 enable 
 ok.. initialize S3 SonicVibes chip 
 reset chip 
 release reset 
 clear IRQs 
 drive current 16mA 
 drive current 8mA 
 disable playback & capture 
 clear IRQs 
 use PLL as clock source 
 power up analog parts 
 power up digital parts 
 SRS space off 
 SRS center off 
 MPU-401 switch 
 onboard ROM 
   MIDI section
 SPDX-License-Identifier: GPL-2.0-or-later
  cs5530.c - Initialisation code for CyrixNatSemi VSA1 softaudio
  	(C) Copyright 2007 Ash Willis <ashwillis@programmer.net>
 	(C) Copyright 2003 Red Hat Inc <alan@lxorguk.ukuu.org.uk>
  This driver was ported (shamelessly ripped ;) from osskahlua.c but I did
  mess with it a bit. The chip seems to have to have trouble with full duplex
  mode. If we're recording in 8bit 8000kHz, say, and we then attempt to
  simultaneously play back audio at 16bit 44100kHz, the device actually plays
  back in the same format in which it is capturing. By forcing the chip to
  always playcapture in 1644100, we can let alsa-lib convert the samples and
  that way we can hack up some full duplex audio. 
  XpressAudio(tm) is used on the Cyrix MediaGX (now NatSemi Geode) systems.
  The older version (VSA1) provides fairly good soundblaster emulation
  although there are a couple of bugs: large DMA buffers break record,
  and the MPU event handling seems suspect. VSA2 allows the native driver
  to control the AC97 audio engine directly and requires a different driver.
  Thanks to National Semiconductor for providing the needed information
  on the XpressAudio(tm) internals.
  TO DO:
 	Investigate whether we can portably support Cognac (5520) in the
 	same manner.
	 Map bits
		0:1	 0x20 + 0x200 = sb base
		2	sb enable
		3	adlib enable
		5	MPU enable 0x330
		6	MPU enable 0x300
 SPDX-License-Identifier: GPL-2.0-only
   Driver for SiS7019 Audio Accelerator
   Copyright (C) 2004-2007, David Dillow
   Written by David Dillow <dave@thedillows.org>
   Inspired by the Trident 4D-WaveDXNX driver.
   All rights reserved.
 Index 0-MAX 
 ID for this card 
 There are three timing modes for the voices.
  For both playback and capture, when the buffer is one or two periods long,
  we use the hardware's built-in Mid-Loop Interrupt and End-Loop Interrupt
  to let us know when the periods have ended.
  When performing playback with more than two periods per buffer, we set
  the "Stop Sample Offset" and tell the hardware to interrupt us when we
  reach it. We then update the offset and continue on until we are
  interrupted for the next period.
  Capture channels do not have a SSO, so we allocate a playback channel to
  use as a timer for the capture periods. We use the SSO on the playback
  channel to clock out virtual periods, and adjust the virtual period length
  to maintain synchronization. This algorithm came from the Trident driver.
  FIXME: It'd be nice to make use of some of the synth features in the
  hardware, but a woeful lack of documentation is a significant roadblock.
 We need four pages to store our wave parameters during a suspend. If
  we're not doing power management, we still need to allocate a page
  for the silence buffer.
	 Protect against more than one thread hitting the AC97
	  registers (in a more polite manner than pounding the hardware
	  semaphore)
	 voice_lock protects allocationfreeing of the voice descriptions
	 Allocate pages to store the internal wave state during
	  suspends. When we're operating, this can be used as a silence
	  buffer for a timing channel.
 These values are also used by the module param 'codecs' to indicate
  which codecs should be present.
 The HW offset parameters (Loop End, Stop Sample, End Sample) have a
  documented range of 8-0xfff8 samples. Given that they are 0-based,
  that places our periodbuffer range at 9-0xfff9 samples. That makes the
  max buffer size 0xfff9 samples  2 channels  2 bytes per sample, and
  max samples  min samples gives us the max periods in a buffer.
  We'll add a constraint upon open that limits the period and buffer sample
  size to values that are legal for the hardware.
 Enforce the documented hardware minimum offset 
 The SSO is in the upper 16 bits of the register. 
		 If we've not hit the end of the virtual period, update
		  our records and keep going.
		 Calculate our relative offset between the target and
		  the actual CSO value. Since we're operating in a loop,
		  if the value is more than half way around, we can
		  consider ourselves wrapped.
		 If sync is positive, then we interrupted too early, and
		  we'll need to come back in a few samples and try again.
		  There's a minimum wait, as it takes some time for the DMA
		  engine to startup, etc...
		 Ok, we interrupted right on time, or (hopefully) just
		  a bit late. We'll adjst our next waiting period based
		  on how close we got.
		 
		  We need to stay just behind the actual channel to ensure
		  it really is past a period when we get our interrupt --
		  otherwise we'll fall into the early code above and have
		  a minimum wait time, which makes us quite late here,
		  eating into the user's time to refresh the buffer, esp.
		  if using small periods.
		 
		  If we're less than 9 samples behind, we're on target.
		  Otherwise, shorten the next vperiod by the amount we've
		  been delayed.
	 We only use the DMA interrupts, and we don't enable any other
	  source of interrupts. But, it is possible to see an interrupt
	  status that didn't actually interrupt us, so eliminate anything
	  we're not expecting to avoid falsely claiming an IRQ, and an
	  ensuing endless loop.
	 This was copied from the trident driver, but it seems its gotten
	  around a bit... nevertheless, it works well.
	 
	  We special case 44100 and 8000 since rounding with the equation
	  does not give us an accurate enough value. For 11025 and 22050
	  the equation gives us the best answer. All other frequencies will
	  also use the equation. JDW
 Helper function: must hold sis->voice_lock on entry 
 Helper function: must hold sis->voice_lock on entry 
 Must hold the voice_lock on entry 
	 If there are one or two periods per buffer, we don't need a
	  timing voice, as we can use the capture channel's interrupts
	  to clock out the periods.
	 We rely on the PCM core to ensure that the parameters for this
	  substream do not change on us while we're programming the HW.
	 The baseline setup is for a single period per buffer, and
	  we add bells and whistles as needed from there.
	 Ok, we're ready to go, set up the channel.
 Force PCI writes to post. 
	 No locks needed, as the PCM core will hold the locks on the
	  substreams, and the HW will only startstop the indicated voices
	  without changing the state of the others.
 Make sure it is for us... 
		 voice could be NULL if this a recording stream, and it
		  doesn't have an external timing channel.
	 FIXME: The driver only supports recording from one channel
	  at the moment, but it could support more.
	 Set our initial buffer and period as large as we can given a
	  single page of silence.
	 Initially, we want to interrupt just a bit behind the end of
	  the period we're clocking out. 12 samples seems to give a good
	  delay.
	 
	  We want to spread our interrupts throughout the virtual period,
	  so that we don't end up with two interrupts back to back at the
	  end -- this helps minimize the effects of any jitter. Adjust our
	  clocking period size so that the last period is at least a fourth
	  of a full period.
	 
	  This is all moot if we don't need to use virtual periods.
		 The initial period will fit inside the buffer, so we
		  don't need to use virtual periods -- disable them.
	 The interrupt handler implements the timing synchronization, so
	  setup its state.
	 Using unsigned samples with the all-zero silence buffer
	  forces the output to the lower rail, killing playback.
	  So ignore unsigned vs signed -- it doesn't change the timing.
	 We've done the math, now configure the channel.
	 We rely on the PCM core to ensure that the parameters for this
	  substream do not change on us while we're programming the HW.
	 If we've got more than two periods per buffer, then we have
	  use a timing voice to clock out the periods. Otherwise, we can
	  use the capture channel's interrupts.
 Force the writes to post. 
	 We have 64 voices, and the driver currently records from
	  only one channel, though that could change in the future.
	 Try to preallocate some memory, but it's not the end of the
	  world if this fails.
	 Get the AC97 semaphore -- software first, so we don't spin
	  pounding out IO reads on the hardware semaphore...
	 ... and wait for any outstanding commands to complete ...
	 ... before sending our command and waiting for it to finish ...
	 ... and reading the results (if any).
	 If we return an error here, then snd_card_free() should
	  free up any ac97 codecs that got created, as well as the bus.
	 Reset the chip, and disable all interrputs.
	 Now, free everything we allocated.
	 Reset the audio controller
	 Get the AC-link semaphore, and reset the codecs
	 Command complete, we can let go of the semaphore now.
	 Now that we've finished the reset, find out what's attached.
	  There are some codecboard combinations that take an extremely
	  long time to come up. 350+ ms has been observed in the field,
	  so we'll give them up to 500ms.
	 All done, check for errors.
	 Let the hardware know that the audio driver is alive,
	  and enable PCM slots on the AC-link for LR playback (3 & 4) and
	  record channels. We're going to want to use Variable Rate Audio
	  for recording, to avoid needlessly resampling from 48kHZ.
	 All AC97 PCM slots should be sourced from sub-mixer 0.
	 There is only one valid DMA setup for a PCI environment.
	 Reset the synchronization groups for all of the channels
	  to be asynchronous. If we start doing SPDIF or 5.1 sound, etc.
	  we'll need to change how we handle these. Until then, we just
	  assign sub-mixer 0 to all playback channels, and avoid any
	  attenuation on the audio.
	 Don't attenuate any audio set for the wave amplifier.
	 
	  FIXME: Maximum attenuation is set for the music amp, which will
	  need to change if we start using the synth engine.
	 Ensure that the wave engine is in normal operating mode.
	 Go ahead and enable the DMA interrupts. They won't go live
	  until we start a channel.
	 snd_pcm_suspend_all() stopped all channels, so we're quiescent.
	 Save the internal state away
	 Restore saved state, then clear out the page we use for the
	  silence buffer.
 CONFIG_PM_SLEEP 
	 We need 16K to store the internal wave engine state during a
	  suspend, but we don't need it to be contiguous, so play nice
	  with the memory system. We'll also use this area for a silence
	  buffer.
	 The user can specify which codecs should be present so that we
	  can wait for them to show up if they are slow to recover from
	  the AC97 cold reset. We default to a single codec, the primary.
	 
	  We assume that SIS_PRIMARY__PRESENT matches bits 0-2.
 SPDX-License-Identifier: GPL-2.0-or-later
   Driver for Ensoniq ES1370ES1371 AudioPCI soundcard
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>,
 		     Thomas Sailer <sailer@ife.ee.ethz.ch>
 Power-Management-Code ( CONFIG_PM )
  for ens1371 only ( FIXME )
  derived from cs4281.c, atiixp.c and via82xx.c
  using http:www.alsa-project.org~tiwaiwriting-an-alsa-driver 
  by Kurt J. Bosch
 it can be ENS but just to keep compatibility... 
 Index 0-MAX 
 ID for this card 
 Enable switches 
 SUPPORT_JOYSTICK 
 ES1371 chip ID 
 This is a little confusing because all ES1371 compatible chips have the
   same DEVICE_ID, the only thing differentiating them is the REV_ID field.
   This is only significant if you want to enable features on the later parts.
   Yes, I know it's stupid and why didn't we use the sub IDs?
 ??? -jk 
 mw 
  Direct registers
 RW: InterruptChip select control register 
 disable capture buffer transfers 
 general purpose output bit 
 bypass SRC for PB1 
 bypass SRC for PB2 
 bypass SRC for REC 
 should be set to 0 for normal operation 
 mix record with playback for I2SSPDIF out 
 0 = SPDIF thru mode, 1 = SPDIF == dig out 
 joystick port mapping 
 mask for above 
 GPIO in [3:0] pins - RO 
 clock divide ratio for DAC2 
 mask for above 
 clock divide ratio for DAC2 
 GPIO out [3:0] pins - WR 
 mask for above 
 MPEG serial data format; 0 = SONY, 1 = I2S 
 clock source for DAC - 0 = clock generator; 1 = MPEG clocks 
 Warm AC97 reset 
 fixed frequency clock for DAC1 
 mask for above 
 disable CCB transfer capture information 
 power level change interrupts enable 
 DAC's are synchronous 
 capture clock source; 0 = AC'97 ADC; 1 = I2S 
 CCB voice interrupts enable 
 capture clock source; 0 = ADC; 1 = MPEG 
 generap purpose output bit 
 current power down level 
 mask for above 
 memory bus request enable 
 DAC1 playback channel enable 
 DAC2 playback channel enable 
 ADC capture channel enable 
 UART enable 
 Joystick module enable 
 Codec interface enable 
 Xtal clock disable 
 PCI serr signal disable 
 PCI clock disable 
 RO: InterruptChip select status register 
 Interrupt is pending 
 CT5880 AC'97 Reset bit 
 rear bits: 000 - front, 010 - mirror, 101 - separate 
 GPIO [3:0] pins - interrupt enable 
 SPDIF enable 
 SPDIF test 
 test ASIC 
 GPIO [3:0] pins - interrupt pending 
 CODEC is busy or register write in progress 
 CODEC is busy 
 CODEC register write in progress 
 CODEC synchronization error occurred 
 voice code from CCB module 
 voice code from CCB module 
 power level interrupt pending 
 CCB interrupt pending 
 UART interrupt pending 
 DAC1 channel interrupt pending 
 DAC2 channel interrupt pending 
 ADC channel interrupt pending 
 RW: UART data register 
 RO: UART status register 
 RX interrupt occurred 
 TX interrupt occurred 
 transmitter ready 
 receiver ready 
 WO: UART control register 
 RX interrupt enable 
 TX interrupt enable 
 mask for above 
 control 
 mask for above 
 RW: UART reserver register 
 test mode enabled 
 RW: Memory page register 
 memory page select - out 
 mask for above 
 memory page select - in 
 WO: Codec write register address 
 WR: Codec ReadWrite register address 
 codec ready 
 codec register access in progress 
 codec readwrite select register 
 WR: Codec rate converter interface register 
 address of the sample rate converter 
 mask for above 
 address of the sample rate converter 
 RW: readwrite control for sample rate converter 
 RO: sample rate memory is busy 
 sample rate converter disable 
 playback channel 1 accumulator update disable 
 playback channel 1 accumulator update disable 
 capture channel accumulator update disable 
 current value of the sample rate converter 
 mask for above 
 current value of the sample rate converter 
 WR: Legacy controlstatus register 
 fast joystick timing 
 host interrupt blocking enable 
 SB; 0 = addr 0x220xH, 1 = 0x22FxH 
 base register address; 0 = 0x320xH; 1 = 0x330xH; 2 = 0x340xH; 3 = 0x350xH 
 mask for above 
 base register address 
 CODEC; 0 = 0x530xH; 1 = undefined; 2 = 0xe80xH; 3 = 0xF40xH 
 mask for above 
 CODEC address 
 force an interrupt 
 enable event capture for slave DMA controller 
 enable event capture for slave IRQ controller 
 enable event capture for master DMA controller 
 enable event capture for master IRQ controller 
 enable event capture for ADLIB register; 0x388xH 
 enable event capture for SB registers 
 enable event capture for CODEC registers 
 enable event capture for SoundScape base address 
 event number 
 event significant IO address 
 event capture; 0 = read; 1 = write 
 interrupt for legacy events; 0 = interrupt did occur 
 RW: first 32-bits from SPDIF channel status block, es1373 
 RW: Serial interface control register 
 DAC test mode enable 
 binary offset value to increment  loop end 
 mask for above 
 binary offset value to increment  loop end 
 binary offset value to increment  start 
 mask for above 
 binary offset value to increment  start 
 ADC; 0 - loop mode; 1 = stop mode 
 DAC2; 0 - loop mode; 1 = stop mode 
 DAC1; 0 - loop mode; 1 = stop mode 
 DAC2; 0 - play mode; 1 = pause mode 
 DAC1; 0 - play mode; 1 = pause mode 
 ADC interrupt enable 
 DAC2 interrupt enable 
 DAC1 interrupt enable 
 force sample counter reload for DAC1 
 when stop mode: 0 - DAC2 play back zeros; 1 = DAC2 play back last sample 
 ADC mode; 0 = 8-bit mono; 1 = 8-bit stereo; 2 = 16-bit mono; 3 = 16-bit stereo 
 mask for above 
 DAC2 mode; -- '' -- 
 mask for above 
 DAC1 mode; -- '' -- 
 mask for above 
 RW: DAC1 sample count register 
 RW: DAC2 sample count register 
 RW: ADC sample count register 
 RW: PAGE 0x0c; DAC1 frame address 
 RW: PAGE 0x0c; DAC1 frame size 
 RW: PAGE 0x0c; DAC2 frame address 
 RW: PAGE 0x0c; DAC2 frame size 
 RW: PAGE 0x0d; ADC frame address 
 RW: PAGE 0x0d; ADC frame size 
 RW: PAGE 0x0d: phantom frame address 
 RW: PAGE 0x0d: phantom frame count 
 RW: PAGE 0x0e; UART FIFO register 
   Pages
   Sample rate converter addresses
   Some contants
   Open modes
 for MIDI 
 for MIDI 
 UART mode 
 control register 
 serial control register 
 control status register 
 uart control register 
 chip revision 
 DAC1ADC PCM 
 DAC2 PCM 
 ES1370 
 ES1371 
 ES1373 - CT5880 
 Ectiva EV1938 
   constants
   common IO routines
 wait for ready 
 expose the SRC state bits 
 now, wait for busy and the correct time to read 
 wait for the right state 
 hide the state bits 	
 CHIP1371 
 CHIP1370 
 save the current state for latter 
			 wait for not busy (state 0) first to avoid
 wait for a SAFE time to write addrdata and then do it, dammit 
 restore SRC reg 
 save the current state for latter 
			 wait for not busy (state 0) first to avoid
 wait for a SAFE time to write addrdata and then do it, dammit 
 restore SRC reg 
 wait for WIP again 
 now wait for the stinkin' data (RDY) 
 CHIP1371 
   PCM part
 48k doesn't need SRC (it breaks AC3-passthru) 
 5512Hz rate 
   Mixer section
  ENS1371 mixer (including SPDIF interface)
 spdif controls 
 switch line-in -> rear out 
 vendor ID 
 device ID 
 revision 
 GA-7DXR 
 GA-8IEXP 
 end 
 mirror rear to front speakers 
 CHIP1371 
 generic control callbacks for ens1370 
  ENS1370 mixer
 try reset AK4531 
 CHIP1370 
 disabled 
 auto-detect 
 auto_detect 
 SUPPORT_JOYSTICK 
 switch everything off 
 clear serial interface 
 switch everything off 
 clear serial interface 
 Gateway Solo 2150 
 EV1938 on Mebius PC-MJ100V 
 Targa Xtender300 
 IPC Topnote G notebook 
 end 
	 this code was part of snd_ensoniq_create before intruduction
	   of suspendresume
	     need to delay around 20ms(bleech) to give
 AC'97 warm reset to start the bitclk 
 Init the sample rate converter 
	 WARNING:
	  enabling the sample rate converter without properly programming
	  its parameters causes the chip to lock up (the SRC busy bit will
	  be stuck high, and I've found no way to rectify this other than
	  power cycle) - Thomas Sailer
 try reset codec directly 
 try to reset AK4531 
 CONFIG_PM_SLEEP 
 get microphone working 
 turn amplifier on 
   MIDI section
 do Rx at first 
 do Tx at second 
 empty input FIFO 
 fill UART FIFO buffer at first, and turn Tx interrupts only if necessary 
   Interrupt handler
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for ESS Maestro3Allegro (ES1988) soundcards.
  Copyright (c) 2000 by Zach Brown <zab@zabbo.net>
                        Takashi Iwai <tiwai@suse.de>
  Most of the hardware init stuffs are based on maestro3 driver for
  OSSFree by Zach Brown.  Many thanks to Zach!
  ChangeLog:
  Aug. 27, 2001
      - Fixed deadlock on capture
      - Added Canyon3D-2 support by Rob Riggs <rob@pangalactic.org>
 Index 0-MAX 
 ID for this card 
 all enabled 
  maestro3 registers
 Allegro PCI configuration registers 
 M3 
 Allegro registers 
  should be using the above defines, probably.
 default m3 amp 
 default allegro amp 
 M3 
  ASSP control regs
  Kernel data layout
  second 'segment' (?) reserved for mixer
  buffers..
  client data area offsets
  an arbitrary volume we set the internal
  volume settings to so that the ac97 volume
  range is a little less insane.  0x7fff is 
  max.
 for storing reset state..
 gpio pin #  for external amp, -1 = default 
 hardware-volume config bits 
	unsigned irda_workaround :1;	 avoid to touch 0x10 on GPIO_DIRECTION
 Do HP OmniBook GPIO magic? 
 midi 
 pcm streams 
 physical device path 
  pci ids
 END 
 END 
 hardware volume quirks 
 Allegro chips 
 HP OmniBook 6100 
 Maestro3 chips 
 END 
 HP Omnibook quirks 
 HP OmniBook 6000 
 HP OmniBook 500 
 END 
  lowlevel functions
  access 16bit words to the code or data regions of the dsp's memory.
  index addresses 16bit words.
  This makes me sad. the maestro3 has lists
  internally that must be packed.. 0 terminates,
  apparently, or maybe all unused entries have
  to be 0, the lists have static lengths set
  by the binary code images.
  startstop
 spinlock held! 
 spinlock held! 
 should return error? 
  setup
 host dma buffer pointers 
 dsp buffers 
	 
	  put us in the lists if we're not already there
 write to 'mono' word 
 write to '8bit' word 
 set up dacadc rate 
 +1, +2 are stereo16 bit 
 fraction? 
 first l 
 first r 
 second l 
 second r 
 delta l 
 delta r 
 round 
 higher bute mark 
 temp0 
 c fraction 
 counter 
 numin 
 numout 
 numstage 
 filtertap 
 booster 
 the mode passed should be already shifted and masked 
	
	  some per client initializers
 enable or disable low pass filter? 
 tell it which way dma is going? 
	
	  set an armload of static initializers
     Native record driver 
 +1, +2 are stereo16 bit 
 fraction? 
 first l 
 first r 
 second l 
 second r 
 delta l 
 delta r 
 round 
 higher bute mark 
 temp0 
 c fraction 
 counter 
 numin 
 numout 
 numstage 
 coef 
 filtertap 
 booster 
 skip lpf 
	
	  some per client initializers
 tell it which way dma is going? 
	
	  set an armload of static initializers
 set buffer address 
  get current pointer
	
	  try and get a valid answer
 update pointer 
 spinlock held! 
 try to avoid expensive modulo divisions 
 The m3's hardware volume works by incrementing  decrementing 2 counters
   (without wrap around) in response to volume button presses and then
   generating an interrupt. The pair of counters is stored in bits 1-3 and 5-7
	 Figure out which volume control button was pushed,
	   based on differences from the default register
	 Reset the volume counters to 4. Tests on the allegro integrated
	   into a Compaq N600C laptop, have revealed that:
	   1) Writing any value will result in the 2 counters being reset to
	      4 so writing 0x88 is not strictly necessary
	   2) Writing to any of the 4 involved registers will reset all 4
	      of them (and reading them always returns the same value for all
	      of them)
	   It could be that a maestro deviates from this, so leave the code
	 Ignore spurious HV interrupts during suspend  resume, this avoids
		 The counters have not changed, yet we've received a HV
		   interrupt. According to tests run by various people this
 counters increased by 1 -> volume up 
 counters decreased by 1 -> volume down 
		 The counters have not changed, yet we've received a HV
		   interrupt. According to tests run by various people this
 counters increased by 1 -> volume up 
 counters decreased by 1 -> volume down 
	
	  ack an assp int if its running
	  and has an int pending
 update adcdac info if it was a timer int 
 TODO: not supported yet 
 ack ints 
SNDRV_PCM_INFO_PAUSE |
SNDRV_PCM_INFO_PAUSE |
 set list owners 
 not opened properly 
 does this happen? 
  create pcm instance
  ac97 interface
  Wait for the ac97 serial bus to be free.
  return nonzero if the bus is still busy.
	
	  Workaround for buggy ES1988 integrated AC'97 codec. It remains silent
	  until the MASTER volume or mute is touched (alsactl restore does not
	  work).
 enable dock on Dell Latitude C810 
  hack, returns non zero on err 
		
		  the onboard codec on the allegro seems 
		  to want to wait a very long time before
		  coming back to life 
 maestro3 
 assuming pci bus master? 
 ok, bring back the ac-link 
	 more gung-ho reset that doesn't
	  seem to work anywhere :)
 seems ac97 PCM needs initialization.. hack hack.. 
  initialize ASSP
 zero kernel data 
 zero mixer data? 
 init dma pointer 
 write kernel into code memory.. 
	
	  We only have this one client and we know that 0x400
	  is free in our kernel's mem map, so lets just
	  drop it there.  It seems that the minisrc doesn't
	  need vectors, so we won't bother with them..
	
	  write the coefficients for the low pass filter?
	
	  the minisrc is the only thing on
	  our task list..
	
	  init the mixer number..
	
	  EXTREME KERNEL MASTER VOLUME
	
	  the revb memory map has 0x1100 through 0x1c00
	  free.  
	
	  align instance address to 256 bytes so that its
	  shifted list address is aligned.
	  list address = (mem address >> 1) >> 7;
  this works for the reference board, have to find
  out about others
  this needs more magic for 4 speaker, but..
	
	  Volume buttons on some HP OmniBook laptops
	  require some GPIO magic to work correctly.
 makes as much sense as 'n', no? 
 For some reason we must always use reduced debounce. 
 download DSP code before starting ASSP below 
 TODO: MPU401 not supported yet 
| MPU401_INT_ENABLE;
 check surviving pcms; this should not happen though.. 
 disable ints 
  APM support
 give the assp a chance to idle.. 
 save dsp image 
 first lets just bring everything back. .
 restore dsp image 
 tell the dma engine to restart itself 
 restore ac97 registers 
 CONFIG_PM_SLEEP 
 CONFIG_INPUT 
 check, if we can restrict PCI DMA transfers to 28 bits 
 presumably this is for all 'maestro3's.. 
 just to be sure 
 don't pick up modems 
 TODO: not supported yet 
 TODO enable MIDI IRQ and IO 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
   Universal routines for AK4531 codec
MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>");
MODULE_DESCRIPTION("Universal routines for AK4531 codec");
MODULE_LICENSE("GPL");
 00: Master Volume Lch 
 01: Master Volume Rch 
 02: Voice Volume Lch 
 03: Voice Volume Rch 
 04: FM Volume Lch 
 05: FM Volume Rch 
 06: CD Audio Volume Lch 
 07: CD Audio Volume Rch 
 08: Line Volume Lch 
 09: Line Volume Rch 
 0a: Aux Volume Lch 
 0b: Aux Volume Rch 
 0c: Mono1 Volume 
 0d: Mono2 Volume 
 0e: Mic Volume 
 0f: Mono-out Volume 
 10: Output Mixer SW1 
 11: Output Mixer SW2 
 12: Lch Input Mixer SW1 
 13: Rch Input Mixer SW1 
 14: Lch Input Mixer SW2 
 15: Rch Input Mixer SW2 
 16: Reset & Power Down 
 17: Clock Select 
 18: AD Input Select 
 19: Mic Amp Setup 
 no RST, PD 
 CODEC ADC and CODEC DAC use {LR,B}CLK2 and run off LRCLK2 PLL 
 recording source is mixer 
  power management
 mute 
 powerdown 
 initialize 
 restore mixer registers 
  proc interface
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for VIA VT82xx (South Bridge)
    VT82C686ABC, VT8233AC, VT8235
 	Copyright (c) 2000 Jaroslav Kysela <perex@perex.cz>
 	                   Tjeerd.Mulder <Tjeerd.Mulder@fujitsu-siemens.com>
                     2002 Takashi Iwai <tiwai@suse.de>
  Changes:
  Dec. 19, 2002	Takashi Iwai <tiwai@suse.de>
 	- use the DSX channels for the first pcm playback.
 	  (on VIA8233, 8233C and 8235 only)
 	  this will allow you play simultaneously up to 4 streams.
 	  multi-channel playback is assigned to the second device
 	  on these chips.
 	- support the secondary capture (on VIA8233C,8235)
 	- SPDIF support
 	  the DSX3 channel can be used for SPDIF output.
 	  on VIA8233A, this channel is assigned to the second pcm
 	  playback.
 	  the card config of alsa-lib will assign the correct
 	  device for applications.
 	- clean up the code, separate low-level initialization
 	  routines for each chipset.
  Sep. 26, 2005	Karsten Wiese <annabellesgarden@yahoo.de>
 	- Optimize position calculation for the 823x chips. 
 Index 0-MAX 
 ID for this card 
 just for backward compatibility 
 revision numbers for via686 
 revision numbers for via8233 
 not in market 
 2 rec, 4 pb, 1 multi-pb 
 2 rec, 4 pb, 1 multi-pb, spdif 
 1 rec, 1 multi-pb, spdf 
 2 rec, 4 pb, 1 multi-pb, spdif 
   Direct registers
 common offsets 
 byte - channel status 
 RO 
 RO 
 RO 
 RO 
 RWC 
 RWC 
 RWC 
 byte - channel control 
 WO 
 WO 
 RW 
 RW - probably reset? undocumented 
 byte - channel type (686 only) 
 RW - autostart at EOL 
 RW 
 RW 
 dword - channel table pointer 
 dword - channel current pointer 
 dword - stop index, channel type, sample rate 
 RW 
 RW 
 dword - channel current count (24 bit) 
 byte - channel current index (for via8233 only) 
 playback block 
 AC'97 
 dword 
 dword 
 via686 
 via8233 
 multi-channel and capture registers for via8233 
 via8233-specific registers 
 byte 
 byte 
 byte - format and channels 
 # channels << 4 (valid = 1,2,4,6) 
 byte - bit 6 = fifo  enable 
 max. volume (attenuation) of reg 0x3233 
 byte - input select 
 recording source codec (0 = primary) 
 pci space 
 secondary codec ready 
 low-power state 
 primary codec ready 
 0: disable, 1: enable 
 0: assert, 1: de-assert 
 0: release SYNC, 1: force SYNC hi 
 0: release SDO, 1: force SDO hi 
 0: disable VRA, 1: enable VRA 
 0: disable PCM, 1: enable PCM 
 via686 only 
 via686 only 
 FIXME: it's 0x40 in the datasheet! 
 FIXME: not documented! 
  pcm stream
 playback = 0, capture = 1 
 # descriptors 
 for recovery from the unexpected pointer 
 processed frame position in the buffer 
 4 playback, 1 multi, 2 capture 
 for VIA8233C8235; default = 0 
 for VIA8233C8235; default = 0 
 SGD_SHADOW mask to check interrupts 
 playback and capture 
 DXS channel accepts only 48kHz 
 no need to set VRA on DXS channels 
 use full SRC capabilities of DXS 
 only spdif rates work to external DACs 
 secondary AC'97 codec is present 
 0x1106, 0x3058 
 686A 
 0x1106, 0x3059 
 VT8233 
  allocate and initialize the descriptor buffers
  periods = number of periods
  fragsize = period size in bytes
		 the start of each lists must be aligned to 8 bytes,
		  but the kernel pages are much bigger, so we don't care
 fill the entries 
		 fill descriptors for a period.
		  a period can be split to several descriptors if it's
		  over page boundary.
 buffer boundary 
 period boundary 
 period continues to the next 
			
			dev_dbg(&pci->dev,
				"tbl %d: at %d  size %d (rest %d)\n",
				idx, ofs, r, rest);
   Basic IO
 1ms 
 1ms 
 here we need to wait fairly for long time.. 
 disable interrupts 
 clear interrupts 
 for via686 
 outl(0, VIADEV_REG(viadev, OFFSET_CURR_PTR));
   Interrupt handler
   Used for 686 and 8233A
 check mpu401 interrupt 
 check status for each stream 
			
			  Update hwptr_done based on 'period elapsed'
			  interrupts. We'll use it, when the chip returns 0 
			  for OFFSET_CURR_COUNT.
 ack 
   Interrupt handler
 check status for each stream 
			
			  Update hwptr_done based on 'period elapsed'
			  interrupts. We'll use it, when the chip returns 0 
			  for OFFSET_CURR_COUNT.
 ack 
   PCM callbacks
  trigger callback
  pointer callbacks
  calculate the linear position at the given sg-buffer index and the rest count
 check the validity of the calculated position 
			 Some mobos report count = 0 on the DMA boundary,
			  i.e. count = size indeed.
			  Let's check whether this step is above the expected size.
 count register returns full size when end of buffer is reached 
  get the current pointer on via686
	 The via686a does not have the current index register,
	  so we need to calculate the index from CURR_PTR.
 CURR_PTR holds the address + 8 
 remember the last position 
  get the current pointer on via823x
	 An apparent bug in the 8251 is worked around by sending a 
  hw_params callback:
  allocate the buffer and build up the buffer description table
  hw_free callback:
  clean up the buffer description table and release the buffer
  set up the table pointer
  prepare callback for playback and capture on via686
 this must be set after channel_reset 
  lock the current rate
 already set 
  prepare callback for DSX playback on via823x
 format 
 stereo 
 rate 
 STOP index is never reached 
  prepare callback for multi-channel playback on via823x
 set sample number to slot 3, 4, 7, 8, 6, 9 (for VIA8233C,8235) 
 corresponding to FL, FR, RL, RR, C, LFE ?? 
 STOP index is never reached 
  prepare callback for capture on via823x
 STOP index is never reached 
  pcm hardware definition, identical for both playback and capture
 SNDRV_PCM_INFO_RESUME | 
  open callback skeleton
 set the hw rate condition 
 DXS#3 and spdif is on 
 fixed DXS playback rate 
 use full SRC capabilities of DXS 
 a fixed rate 
	 we may remove following constaint when we modify table entries
  open callback for playback on via686
  open callback for playback on via823x DXS
  open callback for playback on via823x multi-channel
	 channels constraint for VIA8233A
	  3 and 5 channels are not supported
  open callback for capture on via686 and via823x
  close callback
 release the rate lock 
 via686 playback callbacks 
 via686 capture callbacks 
 via823x DSX playback callbacks 
 via823x multi-channel playback callbacks 
 via823x capture callbacks 
  create pcm instances for VIA8233, 8233C and 8235 (not 8233A)
 x 4 
 x 1 
 x 2 
 FLAG|EOL for rec0-1, mc, sdx0-3 
 PCM #0:  4 DSX playbacks and 1 capture 
 set up playbacks 
 capture 
 PCM #1:  multi-channel playback and 2nd capture 
 set up playback 
 set up capture 
  create pcm instances for VIA8233A
 FLAG|EOL for rec0, mc, sdx3 
 PCM #0:  multi-channel playback and capture 
 set up playback 
 capture 
 SPDIF supported? 
 PCM #1:  DXS3 playback (for spdif) 
 set up playback 
  create a pcm instance for via686ab
 FLAG | EOL for PB, CP, FM 
   Mixer part
	 formerly they were "Line" and "Mic", but it looks like that they
	  have nothing to do with the actual physical connections...
 save the spdif flag for rate filtering 
 .subdevice set later 
 VT1612A 
 FIXME: which codec? 
 VT1616 
launchpad.netbugs38546 
 terminator 
 use slot 1011 
 Enable legacy joystick port 
		 when no hw PCM volume control is found, use DXS volume control
		  as the PCM vol control
 Using DXS when PCM emulation is enabled is really weird 
 select spdif data slot 1011 
 SPDIF off as default 
 FIXME: correct? (disable MIDI) 
 disable joystick 
 force MIDI 
 force MIDI 
 no, use BIOS settings 
 enable PCI IO 2 
 disable PCI IO 2 
 enable MIDI interrupt 
  proc interface
 broken on K7M? 
 disable all legacy ports 
 codec not ready? 
 deassert ACLink reset, force SYNC 
 FIXME: should we do full reset here for all chip models? 
 deassert ACLink reset, force SYNC (warm AC'97 reset) 
 ACLink on, deassert ACLink reset, VSR, SGD data out 
 note - FM data out has trouble with non VRA codecs !! 
	 Make sure VRA is enabled, in case we didn't do a
 ACLink on, deassert ACLink reset, VSR, SGD data out 
 note - FM data out has trouble with non VRA codecs !! 
 wait until codec ready 
 primary codec ready 
 FIXME: we don't support the second codec yet so skip the detection now.. 
 This is ok, the most of motherboards have only one codec 
 route FM trap to IRQ, disable FM trap 
 disable all GPI interrupts 
		 Workaround for Award BIOS bug:
		  DXS channels don't work properly with VRA if MC97 is disabled.
 MC97 
  power management
 save misc values 
 CONFIG_PM_SLEEP 
 disable interrupts 
	 The 8233 ac97 controller does not implement the master bit
	  in the pci command register. IMHO this is a violation of the PCI spec.
  auto detection of DXS channel supports.
 terminator 
 for newer revision, default to DXS_SRC 
	
	  not detected, try 48k rate only to be sure.
			 force to use VIA8233 or 8233A model according to
			  dxs_support module option
 no slog assignment 
 chip->dxs_fixed = 1;  FIXME: use 48k for DXS #3? 
 disable interrupts 
 SPDX-License-Identifier: GPL-2.0-or-later
   Driver for ESS Solo-1 (ES1938, ES1946, ES1969) soundcard
   Copyright (c) by Jaromir Koutek <miri@punknet.cz>,
                    Jaroslav Kysela <perex@perex.cz>,
                    Thomas Sailer <sailer@ife.ee.ethz.ch>,
                    Abramo Bagnara <abramo@alsa-project.org>,
                    Markus Gruber <gruber@eikon.tum.de>
  Rewritten from sonicvibes.c source.
   TODO:
     Rewrite better spinlocks
  NOTES:
  - Capture data is written unaligned starting from dma_base + 1 so I need to
    disable mmap and to add a copy callback.
  - After several cycle of the following:
    while : ; do arecord -d1 -f cd -t raw | aplay -f cd ; done
    a "playback write error (DMA or IRQ trouble?)" may happen.
    This is due to playback interrupts not generated.
    I suspect a timing issue.
  - Sometimes the interrupt handler is invoked wrongly during playback.
    This generates some harmless "Unexpected hw_pointer: wrong interrupt
    acknowledge".
    I've seen that using small period sizes.
    Reproducible with:
    mpg123 test.mp3 &
    hdparm -t -T devhda
 Index 0-MAX 
 ID for this card 
 Enable this card 
 max. number of registers to save 
 Solo-1 
 -----------------------------------------------------------------
  Write to a mixer register
 -----------------------------------------------------------------
  Read from a mixer register
 -----------------------------------------------------------------
  Write to some bits of a mixer register (return old value)
 -----------------------------------------------------------------
  Write command to Controller Registers
 -----------------------------------------------------------------
  Read the Read Data Buffer
 -----------------------------------------------------------------
  Write value cmd register
 -----------------------------------------------------------------
  Read data from cmd register and return it
 -----------------------------------------------------------------
  Write data to cmd register and return old value
 --------------------------------------------------------------------
  Reset the chip
 Demand transfer DMA: 4 bytes per DMA request 
	 Change behaviour of register A1
	   4x oversampling
 enableselect DMA channel and IRQ channel 
 Set spatializer parameters to recommended values 
 --------------------------------------------------------------------
  Reset the FIFOs
 set filter register 
 --------------------------------------------------------------------
  Configure Solo1 builtin DMA Controller
 Enable DMA controller 
 1. Master reset 
 2. Mask DMA 
 3. Unmask DMA 
 Enable DMA controller 
 1. Master reset 
 2. Mask DMA 
 3. Unmask DMA 
 ----------------------------------------------------------------------
                             PCM part 
		 According to the documentation this should be:
                 This two stage init gives the FIFO -> DAC connection time to
                  settle before first data from DMA flows in.  This should ensure
 --------------------------------------------------------------------
  First channel for Extended Mode Audio 1 ADC Operation
 program type 
 set clock and counters 
 initialize and configure ADC 
	snd_es1938_reset_fifo(chip);	
 11. configure system interrupt controller and DMA controller 
 ------------------------------------------------------------------------------
  Second Audio channel DAC Operation
 set clock and counters 
 initialize and configure Audio 2 DAC 
 program DMA 
 reset 
 set clock and counters 
 initialized and configure DAC 
 program DMA 
 during the incrementing of dma counters the DMA register reads sometimes
   returns garbage. To ensure a valid hw pointer, the following checks which
   should be very unlikely to fail are used:
   - is the current DMA address in the valid DMA range ?
   - is the sum of DMA address and DMA counter pointing to the last DMA byte ?
   One can argue this could differ by one byte depending on which register is
   updated first, so the implementation below allows for that.
 This stuff is needed, don't ask why - AB 
 bad, use last saved 
 good, remember it 
 This stuff is needed, don't ask why - AB 
 ----------------------------------------------------------------------
  Audio1 Capture (ADC)
 DMA controller screws on higher values 
 -----------------------------------------------------------------------
  Audio2 Playback (DAC)
 DMA controller screws on higher values 
 -------------------------------------------------------------------
                         Mixer part 
 ---------------------------------------------------------------------------- 
 ---------------------------------------------------------------------------- 
  initialize the chip - used by resume callback, too
 reset chip 
 configure native mode 
 enable bus master 
 disable legacy audio 
 set DDMA base 
 set DMAIRQ policy 
 enable Audio 1, Audio 2, MPU401 IRQ and HW volume IRQ
 reset DMA 
  PM support
 save mixer-related registers 
 disable irqs 
 restore mixer-related registers 
 CONFIG_PM_SLEEP 
 SUPPORT_JOYSTICK 
 disable irqs 
 enable PCI device 
 check, if we can restrict PCI DMA transfers to 24 bits 
 still use non-managed irq handler as it's re-acquired at PM resume 
 fix from Thomas Sailer 
 --------------------------------------------------------------------
  Interrupt handler
 AUDIO 1 
 clear irq 
 AUDIO 2 
 clear irq 
 Hardware volume 
 ack interrupt 
 MPU401 
 the following line is evil! It switches off MIDI interrupt handling after the first interrupt received.
 replacing the last 0 by 0x40 works for ESS-Solo1, but just doing nothing works as well!
 andreas@flying-snail.de
 snd_es1938_mixer_bits(chip, ESSSB_IREG_MPU401CONTROL, 0x40, 0);  ack? 
 this line is vital for MIDI interrupt handling on ess-solo1
 andreas@flying-snail.de
 SPDX-License-Identifier: GPL-2.0-or-later
   Driver for Cirrus Logic CS4281 based PCI soundcard
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>,
 Index 0-MAX 
 ID for this card 
 Enable switches 
 dual codec 
   Direct registers
   BA0 registers
 Host Interrupt Status Register 
 Internal Interrupt Enable Bit 
 MIDI port interrupt 
 FIFO polled interrupt 
 DMA interrupt (half or end) 
 FIFO channel interrupt 
 DMA channel interrupt 
 General Purpose Input (Primary chip) 
 General Purpose Input (Secondary chip) 
 GPIO3 pin Interrupt 
 GPIO1 pin Interrupt 
 VOLUP pin Interrupt 
 VOLDN pin Interrupt 
 Host Interrupt Control Register 
 INTENA Change Mask 
 INTENA Value 
 End of Interrupt command 
 Host Interrupt Mask Register 
 Use same contants as for BA0_HISR 
 ISA Interrupt Enable Register 
 Host DMA Engine 0 Status Register 
 Host DMA Engine 1 Status Register 
 Host DMA Engine 2 Status Register 
 Host DMA Engine 3 Status Register 
 Channel 1 Pending 
 Channel 2 Pending 
 DMA Half Terminal Count 
 DMA Terminal Count 
 DMA Running 
 Pending Request 
 Host DMA Engine 0 Current Address 
 Host DMA Engine 0 Current Count 
 Host DMA Engine 0 Base Address 
 Host DMA Engine 0 Base Count 
 Host DMA Engine 1 Current Address 
 Host DMA Engine 1 Current Count 
 Host DMA Engine 1 Base Address 
 Host DMA Engine 1 Base Count 
 Host DMA Engine 2 Current Address 
 Host DMA Engine 2 Current Count 
 Host DMA Engine 2 Base Address 
 Host DMA Engine 2 Base Count 
 Host DMA Engine 3 Current Address 
 Host DMA Engine 3 Current Count 
 Host DMA Engine 3 Base Address 
 Host DMA Engine 3 Base Count 
 Host DMA Engine 0 Mode 
 Host DMA Engine 0 Command 
 Host DMA Engine 1 Mode 
 Host DMA Engine 1 Command 
 Host DMA Engine 2 Mode 
 Host DMA Engine 2 Command 
 Host DMA Engine 3 Mode 
 Host DMA Engine 3 Command 
 Enable DMA mode 
 Enable poll mode 
 Transfer By Channel 
 Count By Channel (0 = frame resolution) 
 Swap LeftRight Channels 
 Sample is 20-bit 
 Unsigned 
 Big Endian 
 Mono 
 Sample is 8-bit 
 Not supported 
 Access Increment (0) or Decrement (1) 
 Auto-Initialize 
 Verify Transfer 
 Write Transfer 
 Read Transfer 
 Half Terminal Count Interrupt 
 Terminal Count Interrupt 
 DMA Mask bit 
 FIFO Control 0 
 FIFO Control 1 
 FIFO Control 2 
 FIFO Control 3 
 FIFO Enable bit 
 DAC Zero 
 Previous Sample Hold 
 Right Slot Mapping 
 Left Slot Mapping 
 FIFO buffer size (in samples) 
 FIFO starting offset (in samples) 
 FIFO Polled Data 0 
 FIFO Polled Data 1 
 FIFO Polled Data 2 
 FIFO Polled Data 3 
 FIFO Channel Status 
 Right Channel Out 
 Left Channel Out 
 Move Read Pointer 
 FIFO Empty 
 FIFO Full 
 Internal Overrun Flag 
 Right Channel In 
 Left Channel In 
 FIFO Status and Interrupt Control 0 
 FIFO Status and Interrupt Control 1 
 FIFO Status and Interrupt Control 2 
 FIFO Status and Interrupt Control 3 
 FIFO Interrupt Count 
 FIFO OverRun Interrupt Enable 
 FIFO UnderRun Interrupt Enable 
 FIFO Sample Count Interrupt Enable 
 FIFO Sample Count 
 FIFO OverRun 
 FIFO UnderRun 
 FIFO Sample Count Reached 
 Power Management ControlStatus 
 Configuration Write Protect 
 Extended PCI Power Management Control 
 Full Power DowN 
 GPIO Pin Interface Register 
 Serial Port Power Management Control (& ASDIN2 enable) 
 GP INT Primary PME# Enable 
 GP INT Secondary PME# Enable 
 EEPROM Serial Port Disable 
 ASDIN2 Enable 
 Asynchronous ASDOUT Assertion 
 Wakeup for Secondary Input 
 Wakeup for Primary Input 
 Asynchronous ASYNC Assertion 
 Reset Not! 
 Configuration Load Register (EEPROM or BIOS) 
 CFLR must be in AC97 link mode 
 ISA Interrupt Select 
 Test Register 
 Subsystem ID register 
 Clock Control Register 1 
 Read Only 
 DLL Ready 
 DLL Output Select 
 Clock Enable 
 DLL PowerUp 
 DLL Source Select 
 Feature Reporting Register 
 Slot 12 GPIO Output Register for AC-Link 
 Serial Port Master Control 
 Force Codec Ready Not 
 On-Demand Support Enable ASDIN2 
 On-Demand Support Enable ASDIN1 
 ASDIN2 to ASDOUT Loopback 
 ASDOUT to ASDIN2 Loopback 
 Loopback Output Valid Frame bit 
 Target Secondary Codec ID 
 Primary Port External Loopback 
 Primary Port Internal Loopback 
 Port Timing Configuration 
 AC97 mode 
 Master Serial Port Enable 
 Serial Port Configuration 1 
 Primary Output Port Format 
 Primary Output Port Enable 
 Serial Port Configuration 2 
 Primary Input Port Format 
 Primary Input Port Enable 
 Slot 12 Monitor Register for Primary AC-Link 
 AC'97 Control 
 Target Codec 
 0=Write, 1=Read Command 
 Dynamic Command Valid 
 Valid Frame 
 Enable Sync 
 AC'97 Status 
 Valid Status 
 Codec Ready 
 AC'97 Output Slot Valid 
 AC'97 Command Address 
 AC'97 Command Data 
 AC'97 Input Slot Valid 
 AC'97 Status Address 
 AC'97 Status Data 
 Joystick polltrigger 
 Joystick control 
 Joystick control 
 Joystick control 
 MIDI Control 
 Reset MIDI Interface 
 MIDI Loop Back Enable 
 MIDI Transmuit Interrupt Enable 
 MIDI Receive Interrupt Enable 
 MIDI Receive Enable 
 MIDI Transmit Enable 
 MIDI Command (wo) 
 MIDI Status (ro) 
 Sticky bit (RBE 1->0) 
 Sticky bit (TBF 0->1) 
 Receive Buffer Empty 
 Transmit Buffer Full 
 MIDI Write 
 MIDI Read (ro) 
 AC'97 On-Demand Slot Disable for primary link (ro) 
 AC'97 On-Demand Slot Disable for secondary link (ro) 
 Configure Interface (EEPROM interface) 
 Slot 12 Monitor Register 2 for secondary AC-link 
 AC'97 Status Register 2 
 AC'97 Input Slot Valid Register 2 
 AC'97 Status Address Register 2 
 AC'97 Status Data Register 2 
 FM Synthesis Status (ro) 
 FM Bank 0 Address Port (wo) 
 FM Data Port 
 FM Bank 1 Address Port 
 FM Bank 1 Data Port 
 Sound System Power Management 
 Playback SRC + FMWavetable MIX 
 Capture Sample Rate Converter Enable 
 Playback Sample Rate Converter Enable 
 Joystick Enable 
 Serial Port Engine and AC-Link Enable 
 FM Synthesis Block Enable 
 DAC Sample Rate - Playback SRC 
 ADC Sample Rate - Capture SRC 
 Sound System Control Register 
 Hardwave Volume Step (0=1,1=2) 
 Master Volume Codec Select 
 Master Volume Line Out Disable 
 Master Volume Alternate Out Disable 
 Master Volume Mono Out Disable 
 External SRC Loopback Mode 
 SRC Loopback Mode 
 CD Transfer Data 
 Harware Volume Control Enable 
 FM Synthesis Left Volume Control 
 FM Synthesis Right Volume Control 
 SRC Slot Assignments 
 PCM Playback Left Volume Control 
 PCM Playback Right Volume Control 
 playback sample rate 
 capture sample rate 
 Source Slot Numbers - Playback 
 invalid for BA0_SRCSA 
 invalid for BA0_SRCSA 
 Source Slot Numbers - Capture 
 Source Slot Numbers - Others 
 MIDI modes 
 joystick bits 
 Bits for JSPT 
 Bits for JSCTL 
 Data register pairs masks 
 JS GPIO 
 offset to DBA register 
 offset to DCA register 
 offset to DBC register 
 offset to DCC register 
 offset to DMR register 
 offset to DCR register 
 offset to HDSR register 
 offset to FCR register 
 offset to FSIC register 
 DMA mode 
 DMA command 
 FIFO control 
 FIFO offset within BA1 
 FIFO left slot 
 FIFO right slot 
 period number 
 virtual (accessible) address 
 virtual (accessible) address 
 CS4281 
   constants
   common IO routines
	
	   1. Write ACCAD = Command Address Register = 46Ch for AC97 register address
	   2. Write ACCDA = Command Data Register = 470h    for data to write to AC97
	   3. Write ACCTL = Control Register = 460h for initiating the write
	   4. Read ACCTL = 460h, DCV should be reset by now and 460h = 07h
	   5. if DCV not cleared, break and return error
	
	   Setup the AC97 control registers on the CS461x to send the
	   appropriate command to the AC97 to perform the read.
	   ACCAD = Command Address Register = 46Ch
	   ACCDA = Command Data Register = 470h
	   ACCTL = Control Register = 460h
	   set DCV - will clear when process completed
	   reset CRW - Write command
	   set VFRM - valid frame enabled
	   set ESYN - ASYNC generation enabled
	   set RSTN - ARST# inactive, AC97 codec not reset
		
		   First, we want to wait for a short time.
		
		   Now, check to see if the write has completed.
		   ACCTL = 460h, DCV should be reset by now and 460h = 07h
 FIXME: volatile is necessary in the following due to a bug of
 some gcc versions
	
	   1. Write ACCAD = Command Address Register = 46Ch for AC97 register address
	   2. Write ACCDA = Command Data Register = 470h    for data to write to AC97 
	   3. Write ACCTL = Control Register = 460h for initiating the write
	   4. Read ACCTL = 460h, DCV should be reset by now and 460h = 17h
	   5. if DCV not cleared, break and return error
	   6. Read ACSTS = Status Register = 464h, check VSTS bit
	
	   Setup the AC97 control registers on the CS461x to send the
	   appropriate command to the AC97 to perform the read.
	   ACCAD = Command Address Register = 46Ch
	   ACCDA = Command Data Register = 470h
	   ACCTL = Control Register = 460h
	   set DCV - will clear when process completed
	   set CRW - Read command
	   set VFRM - valid frame enabled
	   set ESYN - ASYNC generation enabled
	   set RSTN - ARST# inactive, AC97 codec not reset
	
	   Wait for the read to occur.
		
		   First, we want to wait for a short time.
		
		   Now, check to see if the read has completed.
		   ACCTL = 460h, DCV should be reset by now and 460h = 17h
	
	   Wait for the valid status bit to go active.
		
		   Read the AC97 status register.
		   ACSTS = Status Register = 464h
		   VSTS - Valid Status
	
	   Read the data returned from the AC97 register.
	   ACSDA = Status Data Register = 474h
   PCM part
 Leave wave playback FIFO enabled for FM 
 special "hardcoded" rates 
 for workaround 
 Initialize DMA 
 Deactivate wave playback FIFO before changing slot assignments 
 Initialize FIFO 
 Activate FIFO again for FM playback 
 Clear FIFO Status and Interrupt Control Register 
	
	dev_dbg(chip->card->dev,
		"DCC = 0x%x, buffer_size = 0x%x, jiffies = %li\n",
		snd_cs4281_peekBA0(chip, dma->regDCC), runtime->buffer_size,
	       jiffies);
	 should be detected from the AC'97 layer, but it seems
	   that although CS4297A rev B reports 18-bit ADC resolution,
	 should be detected from the AC'97 layer, but it seems
	   that although CS4297A rev B reports 18-bit ADC resolution,
   Mixer section
  proc interface
  joystick support
 ?
 IS_REACHABLE(CONFIG_GAMEPORT) 
 Mask interrupts 
 Stop the DLL Clock logic. 
 Sound System Power Management - Turn Everything OFF 
 defined below 
 2 BARs 
 Having EPPMC.FPDN=1 prevent proper chip initialisation 
	 Set the 'Configuration Write Protect' register
	  to 4281h.  Allows vendor-defined configuration
 Sound System Power Management 
 Serial Port Power Management 
 	 Blast the clock control register to zero so that the
          PLL starts out in a known state, and blast the master serial
          port control register to zero so that the serial ports also
         Make ESYN go to zero to turn off
	  Drive the ARST# pin low for a minimum of 1uS (as defined in the AC97
	   spec) and then drive it high.  This is done for non AC97 modes since
	   there might be logic external to the CS4281 that uses the ARST# line
	
	   Set the serial port timing configuration.
	
	   Start the DLL Clock logic.
	
	  Wait for the DLL ready signal from the clock logic.
		
		   Read the AC97 status register to see if we've seen a CODEC
		   signal from the AC97 codec.
	
	   The first thing we do here is to enable sync generation.  As soon
	   as we start receiving bit clock, we'll start producing the SYNC
	   signal.
	
	  Wait for the codec ready signal from the AC97 codec.
		
		   Read the AC97 status register to see if we've seen a CODEC
		   signal from the AC97 codec.
	
	   Assert the valid frame signal so that we can start sending commands
	   to the AC97 codec.
	
	   Wait until we've sampled input slots 3 and 4 as valid, meaning that
	   the codec is pumping ADC data across the AC-link.
		
		   Read the input slot valid register and see if input slots 3
		   4 are valid yet.
	
	   Now, assert valid frame and the slot 3 and 4 valid bits.  This will
	   commense the transfer of digital audio data to the AC97 codec.
	
	   Initialize DMA structures
 AC'97 left PCM playback (3) 
 AC'97 right PCM playback (4) 
 AC'97 left PCM record (3) 
 AC'97 right PCM record (4) 
 Activate wave playback FIFO for FM playback 
 Initialize digital volume 
 Enable IRQs 
 Unmask interrupts 
   MIDI section
 fill UART FIFO buffer at first, and turn Tx interrupts only if necessary 
   Interrupt handler
 ack DMA IRQ 
 workaround, sometimes CS4281 acknowledges 
 end or middle transfer position twice 
 EOI to the PCI part... reenables interrupts 
  OPL3 command
 right port 
 left port 
  Power Management
 Disable interrupts. 
 remember the status registers 
 Turn off the serial ports. 
 Power off FM, Joystick, AC link, 
 DLL off. 
 AC link off. 
 restore the status registers 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0-or-later
   card-als4000.c - driver for Avance Logic ALS4000 based soundcards.
   Copyright (C) 2000 by Bart Hartgers <bart@etpmod.phys.tue.nl>,
 			  Jaroslav Kysela <perex@perex.cz>
   Copyright (C) 2002, 2008 by Andreas Mohr <hw7oshyuv3001@sneakemail.com>
   Framework borrowed from Massimo Piccioni's card-als100.c.
  NOTES
   Since Avance does not provide any meaningful documentation, and I
   bought an ALS4000 based soundcard, I was forced to base this driver
   on reverse engineering.
   Note: this is no longer true (thank you!):
   pretty verbose chip docu (ALS4000a.PDF) can be found on the ALSA web site.
   Page numbers stated anywhere below with the "SPECS_PAGE:" tag
   refer to: ALS4000a.PDF specs Ver 1.0, May 28th, 1998.
   The ALS4000 seems to be the PCI-cousin of the ALS100. It contains an
   ALS100-like SB DSPmixer, an OPL3 synth, a MPU401 and a gameport 
   interface. These subsystems can be mapped into ISA io-port space, 
   using the PCI-interface. In addition, the PCI-bit provides DMA and IRQ 
   services to the subsystems.
  While ALS4000 is very similar to a SoundBlaster, the differences in
  DMA and capturing require more changes to the SoundBlaster than
  desirable, so I made this separate driver.
  The ALS4000 can do real full duplex playbackcapture.
  FMDAC:
  - 0x4f -> port 0x14
  - port 0x15 |= 1
  Enabledisable 3D sound:
  - 0x50 -> port 0x14
  - change bit 6 (0x40) of port 0x15
  Set QSound:
  - 0xdb -> port 0x14
  - set port 0x15:
    0x3e (mode 3), 0x3c (mode 2), 0x3a (mode 1), 0x38 (mode 0)
  Set KSound:
  - value -> some port 0x0c0d
  ToDo:
  - by default, don't enable legacy game and use PCI game IO
  - power management? (card can do voice wakeup according to datasheet!!)
 Index 0-MAX 
 ID for this card 
 Enable this card 
 most frequent access first 
 ALS4000 
 IOx: B == Byte, W = Word, D = DWord; SPECS_PAGE: 37 
 2nd function 
 2nd function 
 2nd function 
 all registers 32bit wide; SPECS_PAGE: 38 to 42 
 SPECS_PAGE: 3738 
 all registers 8bit wide; SPECS_PAGE: 20 to 23 
 secondary PCM FIFO (recording) 
 for testing, activate via CR3A 
 IRQFIFO controlled for 01 
 IRQFIFO controlled for 01 
	 Control Register is reg | 0xc0 (bit 7, 6 set) on sbmixer_index
	  NOTE: assumes chip->mixer_lock to be locked externally already!
 NOTE: assumes chip->mixer_lock to be locked externally already! 
 SPECS_PAGE: 40 
 SPECS_PAGE: 38 
 structure for setting up playback 
 ALS4000_FORMAT_U8_MONO 
 ALS4000_FORMAT_S8_MONO 	
 ALS4000_FORMAT_U16L_MONO 
 ALS4000_FORMAT_S16L_MONO 
 ALS4000_FORMAT_U8_STEREO 
 ALS4000_FORMAT_S8_STEREO 	
 ALS4000_FORMAT_U16L_STEREO 
 ALS4000_FORMAT_S16L_STEREO 
 structure for setting up capture 
 ALS4000_FORMAT_U8_MONO 
 ALS4000_FORMAT_S8_MONO 	
 ALS4000_FORMAT_U16L_MONO 
 ALS4000_FORMAT_S16L_MONO 
 ALS4000_FORMAT_U8_STEREO 
 ALS4000_FORMAT_S8_STEREO 	
 ALS4000_FORMAT_U16L_STEREO 
 ALS4000_FORMAT_S16L_STEREO 
	 FIXME: from second playback on, there's a lot more clicks and pops
	  involved here than on first playback. Fiddling with
	  tons of different settings didn't help (DMA, speaker onoff,
	  reordering, ...). Something seems to get enabled on playback
	  that I haven't found out how to disable again, which then causes
 SPEAKER_ON not needed, since dma_on seems to also enable speaker 
 snd_sbdsp_command(chip, SB_DSP_SPEAKER_ON); 
	 FIXME race condition in here!!!
	   chip->mode non-atomic update gets consistently protected
	   by reg_lock always, _except_ for this place!!
	   Probably need to take reg_lock as outer (or inner??) lock, too.
	   (or serialize both lock operations? probably not, though... - racy?)
 FIXME: this IRQ routine doesn't really support IRQ sharing (we always
  return IRQ_HANDLED no matter whether we actually had an IRQ flag or not).
  ALS4000a.PDF writes that while ACKing IRQ in PCI block will not ACK
  the IRQ in the SB core, ACKing IRQ in SB block will ACK the PCI IRQ
  register (alt_port + ALS4K_IOB_0E_IRQTYPE_SB_CR1E_MPU). Probably something
  could be optimized here to querywrite one register only...
  And even if both registers need to be queried, then there's still the
  question of whether it's actually correct to ACK PCI IRQ before reading
  SB IRQ like we do now, since ALS4000a.PDF mentions that PCI IRQ will clear
  SB IRQ status.
  (hmm, SPECS_PAGE: 38 mentions it the other way around!)
  And do we really need the lock here for reading SB_DSP4_IRQSTATUS??
	 find out which bit of the ALS4000 PCI block produced the interrupt,
 playback 
 capturing 
 MPU401 interrupt 
 ACK the PCI block IRQ 
 SPECS_PAGE: 20 
	 dev_dbg(chip->card->dev, "als4000: irq 0x%04x 0x%04x\n",
 only ack the things we actually handled above 
 formats 
 formats 
 do some more configuration 
	 always select DMA channel 0, since we do not actually use DMA
 enable interrupts 
 SPECS_PAGE: 39 
 enable burst mode to prevent dropouts during high PCI bus usage 
 auto-detect 
 Enable legacy joystick port 
 disable joystick 
 make sure that interrupts are disabled 
 free resources 
 enable PCI device 
 check, if we can restrict PCI DMA transfers to 24 bits 
 private_data: acard ,
 disable all legacy ISA stuff 
 internally registered as IRQF_SHARED in case of ALS4000 SB 
	 FIXME: ALS4000 has interesting MPU401 configuration features
	  at ALS4K_CR1A_MPU401_UART_MODE_CONTROL
	  (pass-thru  UART switching, fast MIDI clock, etc.),
	  however there doesn't seem to be an ALSA API for this...
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ATI IXP 150200250 AC97 modem controllers
 	Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>
 Exclude the first card 
 ID for this card 
 just for backward compatibility 
 interrupt source 
 interrupt enable 
 (RO 
 (WO) modem is running 
 command 
 modem only 
 modem only 
 modem only 
 modem only 
 modem only 
 modem only 
 modem only 
 modem only 
 modem only 
 modem only 
 slot # 
 RO 
 RO 
 RO 
 output threshold 
 LINKPTR 
 max number of descriptor packets 
  DMA packate descriptor
 DMA buffer address 
 status bits 
 size of the packet in dwords 
 address of the next packet descriptor 
  stream enum
 DMAs 
 AC97 pcm slots 
 pcm devices 
  constants and callbacks for each DMA type
 ATI_DMA_XXX 
 LINKPTR offset 
 DT_CUR offset 
 called from open callback 
 called from trigger (STARTSTOP) 
 called from trigger (STOP only) 
  DMA stream
 assigned PCM substream 
 DMA buffer address, bytes 
 index # of ac97_pcm to access, -1 = not used 
  ATI IXP chip
 memory io 
 max. channels for PCM out 
 for codec detection 
 passed from the module option 
 playback open mutex 
 SB200 
 SB400 
  lowlevel functions
  update the bits of the given register.
  return 1 if the bits changed.
  macros for easy use
  handling DMA packets
  we allocate a linear buffer for the DMA, and split it to  each packet.
  in a future version, a scatter-gather buffer should be implemented.
  build packets ring for the given buffer size.
  IXP handles the buffer descriptors, which are connected as a linked
  list.  although we can change the list dynamically, in this version,
  a static RING of buffer descriptors is used.
  the ring is built in this function, and is set up to the hardware. 
 clear 
 reset DMA before changing the descriptor table 
 fill the entries 
 in dwords 
  remove the ring buffer and release it if assigned
  AC97 interface
 time out may happen during reset 
  reset AC link
 reset powerdoewn 
 perform a software reset 
 do a hard reset 
 deassert RESET and assert SYNC to make sure 
 if (atiixp_read(chip, MODEM_MIRROR) & 0x1)  modem running, too? 
	return -EBUSY;
  auto-detection of codecs
  the IXP chip can generate interrupts for the non-existing codecs.
  NEW_FRAME interrupt is used to make sure that the interrupt is generated
  even if all three codecs are connected.
 wait for the interrupts 
 disable irqs 
  enable DMA and irqs
 set up spdif, enable burst mode 
 clear all interrupt source 
 enable irqs 
  disable DMA and IRQs
 clear interrupt source 
 disable irqs 
  PCM section
  pointer callback simplly reads XXX_DMA_DT_CUR register as the current
  position.  when SG-buffer is implemented, the offset must be calculated
  correctly...
  XRUN detected, and stop the PCM substream
  the period ack.  update the substream.
 set BUS_BUSY interrupt bit if any DMA is running 
 call with spinlock held 
 common trigger callback
  calling the lowlevel callbacks in it
  lowlevel callbacks for each DMA type
  every callback is supposed to be called in chip->reg_lock spinlock
 flush FIFO of analog OUT DMA 
 enabledisable analog OUT DMA 
 startstop transfer over OUT DMA 
 enabledisable analog IN DMA 
 startstop analog IN DMA 
 flush FIFO of analog IN DMA 
 set up slots and formats for analog OUT 
 set output threshold 
 set up slots and formats for analog IN 
  hw_params - allocate the buffer and set up buffer descriptors
 set up modem rate 
  pcm hardware definition, identical for all DMA types
 enable DMA bits 
 disable DMA bits 
 AC97 playback 
 AC97 capture 
 initialize constants 
 PCM #0: analog IO 
  interrupt handler
 process audio DMA 
 for codec detection 
 disable the detected irqs 
 ack 
  ac97 mixer section
 to be sure 
 snd_ac97_tune_hardware(chip->ac97, ac97_quirks); 
  power management
 CONFIG_PM_SLEEP 
  proc interface for register dump
  destructor
  constructor for chip instance
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for C-Media CMI8338 and 8738 PCI soundcards.
  Copyright (c) 2000 by Takashi Iwai <tiwai@suse.de>
 Does not work. Warning may block system in capture mode 
 #define USE_VAR48KRATE 
 Index 0-MAX 
 ID for this card 
 Enable switches 
  CM8x38 registers definition
 ch1: enable 
 ch0: enable 
 ch1: pause 
 ch0: pause 
 ch1, 0:playback, 1:record 
 ch0, 0:playback, 1:record 
 channel 1 (DAC?) sampling frequency 
 channel 0 (ADC?) sampling frequency 
 SPDIF INOUT at channel B 
 SPDIF OUT only channel A 
 ext. SPDIIFIN -> OUT loopback 
 SPDIFOUT can be heard from internal DAC 
 master control block (MCB) interrupt enabled 
 bus master enabled 
 legacy voice (SB16,FM) 
 legacy UART 
 legacy joystick 
 ZVPORT 
 5,6 channels 
 initial FM PCM offset 2 when Fmute=1 
 4 channels 
 set latency timer 48h 
 emulated edge trigger legacy IRQ 
 24-bit spdif: model 039 
 enable AC3: model 037 
 for model <= 037 ? 
 24bit spdif: model 037 
 #define CM_SPDIF_INVERSE	0x00010000  
 model 037 
 model 039 
 model 055? 
 model 055? 
 model 055? 
 double SPDIF sample rate 88.296 
 inverse SPDIFIN valid bit 
 bit 3: 16 bits, bit 2: stereo 
 bit 1: 16 bits, bit 0: stereo 
 ? 
 Voice Control? CMI8738 
 Master Control Block abort cond.? 
 Modell 033? Direct programming EEPROM (read data register) 
 HighLow status from DMA ctrl register 
 Legacy is in High DMA channel 
 Legacy is in Stereo mode 
 don't map base reg dword->sample 
 MPU401 io port address 
 enable bus master to write 8237 base reg 
 SB16 base address 
 FM OPL3 base address 
 enable XSPDIFOUT to IO interface 
 spdif inout copyright bit 
 enable wave+fm_midi -> SPDIFOUT 
 internal vendor ID write enable, model 039? 
 0: legacy io wait (default), 1: legacy io bus retry 
 direct programming eeprom regs 
 5.1 channels support 
 line-in as center out 
 line-in as bass out 
 external bass input enable 
 power down 
 filter control at front end DAC, model 037? 
 analog master amp +6dB, model 039? 
 model 037? 
 copy front to rear 
 5V spdif output (1 = 0.5v (coax)) 
 write 
 read 
 enable double dac 
 0: front=ch0, 1: front=ch1 
 0: 16bit SPDIF, 1: 32bit 
 int. SPDIF-OUT -> int. IN 
 enable legacy FM 
 enable AC3: model 039 
 choose writable internal SUBID (audio) 
 model 037? 
 0: SPDIFOUT 44.1K, 1: 48K 
 activate channel mask on legacy DMA 
 choose writable internal SUBID (modem) 
 model 037? 
 filter stepping at front end DAC, model 037? 
 model DAA interface mode 
 for model > 039 ? 
 force modem link detection on, model 037 
 mute PCI ch1 to DAC 
 force modem link detection off, model 037 
 12 interpolation at front end DAC 
 TDMA position update notification 
 model 037 
 FM io cycle, 0: 48, 1: 64 PCICLKs 
 io cycle, 0: 4, 1: 6 PCICLKs 
 current byteword count 
 current address 
 byte 
 write: sb16 version 
 read: hardware device version 
 ? 
 SB16 ADPCM enable 
 SBPro leftright channel switching 
 SB16 compatible 
 14.31818 Mhz reference clock frequency pin XIN 
 Guessed (487 best for 44.1kHz, not for 88176kHz) 
 Tolerance sample rate pitch (1000ppm) 
 Note more than 80MHz 
 mute FM 
 mute PCM 
 lin-in -> rear line out 
 exchange rearfront 
 digital wave rec. left chan 
 digical wave rec. right 
 3D surround enable 
 enable SPDIFIN PCM -> DAC 
 AUX right capture 
 AUX left capture 
 AUX right mute 
 AUX left mute 
 mic gain level (0-3) << 1 
 mic boost 
 ? 
 #define CM_XGPBIO		0x04
 mic as centerlfe out? (model 039 or later?) 
 spdif input phase inverse (model 037) 
 spdif input valid check 
 SB16 DMA auto detect 
 hmmm.. do we have ac97 link? 
  For CMI-8338 (0x28 - 0x2b) .. is this valid for CMI-8738
  or identical with AC97 codec?
  MPU401 pci port index address 0x40 - 0x4f (CMI-8738 spec ver. 0.6)
  FM pci port index address 0x50 - 0x5f (CMI-8738 spec ver. 0.6)
  access from SB-mixer port
 Phone volume control (0-3) << 5 
 Phone mute control 
 Speaker mute control, default high 
 Rec. R-channel enable 
 Rec. L-channel enable 
 Mic record boost 
  CMI-8338 spec ver 0.5 (this is not valid for CMI-8738):
  the 8 registers 0xf8 - 0xff are used for programming mn counter by the PLL
  unit (readonly?).
  extended registers
 write: base address 
 read: current address 
 0-15: count of samples at bus master; buffer size 
 16-31: count of samples at codec; fragment size 
 ADC parameters group, 0: 44k, 1: 48k 
 7.1 channels support 
 SPDIFIN 32k sample rate 
 ADC output to SPDIFOUT 
 DAC in ADC as CenterLFE 
 monitor the CMPLCMPR of ADC 
 invert ZVPORT's LRCK 
 ? 
  size of io region
  channels for playback  capture
  flags to check device openclose
  driver data
 dacadc running? 
 format bits 
 in frames 
 channel (01) 
 physical address of the buffer 
 mixer elements toggledresumed during ac3 playback 
 switch to toggle 
 value to change when ac3 mode 
 {"IEC958 Out To DAC", 1}, 
 device ID 
 FUNCTRL0 current value 
 DACADC PCM 
 2nd DAC 
 SPDIF 
 samplerate above 48k 
 spdif ready? 
 spdif switch enabled? 
 for software AC3 
 for playbacks 
 open mode 
 ch0 - DAC, ch1 - ADC or 2nd DAC 
 external MIDI 
 readwrite operations for dword register 
 readwrite operations for word register 
 readwrite operations for byte register 
 bit operations for dword register 
 bit operations for byte register 
  PCM interface
  calculate frequency
  Determine PLL values for frequency setup, maybe the CMI8338 (CMI8738???)
  does it this way .. maybe not.  Never get any information from C-Media about
  that <werner@suse.de>.
			
			  If we found one, remember this,
			  and try to find a closer one
  Program pll register bits, I assume that the 8 registers 0xf8 up to 0xff
  are mapped onto the 8 ADCDAC sampling frequency which can be chosen
  at the register CM_REG_FUNCTRL1 (0x04).
  Problem: other ways are also possible (any information about that?)
	
	  Guess that this programs at reg. 0x04 the pos 15:1312:10
	  for DSFCASFC (000 up to 111).
 FIXME: Init (Do we've to set an other register first before programming?) 
 FIXME: Is this correct? Or shouldn't the mnr values be used for that? 
 FIXME: Setup (Do we've to set an other register first to enable this?) 
 USE_VAR48KRATE 
 reserve the channel A 
 stereo 16bit only 
  prepare playbackcapture channel
  channel to be used must have been set in rec->ch.
 2432bit 
 buffer and period sizes in frame 
 multi-channels 
 set buffer address 
 program sample counts 
 set adcdac flag 
 dev_dbg(cm->card->dev, "functrl0 = %08x\n", cm->ctrl); 
 set sample rate 
 set format 
  PCM triggerstop
 set interrupt 
 enable channel 
 disable interrupt 
 reset 
  return the current pointer
 this seems better..
  playback
  capture
  hw preparation for spdif
 save mixer setting and mute for AC3 playback 
 toggle 
 restore the previously saved mixer status 
		cm->mixer_insensitive = 0;  at first clear this;
 spinlock held! 
 AC3EN for 037 
 AC3EN for 039 
 SPD24SEL for 037, 0x02 
 SPD24SEL for 039, 0x20, but cannot be set 
 can_ac3_sw 
 SPD32SEL for 037 & 039, 0x20 
 set 176K sample rate to fix 033 HW bug 
 chip model >= 37 
 they are controlled via "IEC958 Output Switch" 
 snd_cmipci_set_bit(cm, CM_REG_LEGACY_CTRL, CM_ENSPDOUT); 
 snd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_SPDO2DAC); 
 they are controlled via "IEC958 Output Switch" 
 snd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_ENSPDOUT); 
 snd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_SPDO2DAC); 
  preparation
 playback - enable spdif only on the certain condition 
 playback  (via device #2) - enable spdif always 
 doesn't matter 
  Apparently, the samples last played on channel A stay in some buffer, even
  after the channel is reset, and get added to the data for the rear DACs when
  playing a multichannel stream on channel B.  This is likely to generate
  wraparounds and thus distortions.
  To avoid this, we play at least one zero sample after the actual stream has
  stopped.
 set up a small silence buffer 
 configure for 16 bits, 2 channels, 8 kHz 
 start stream (we don't need interrupts) 
 stop and reset stream 
 capture 
 capture with spdif (via device #2) 
  interrupt handler
 fastpath out, to ease interrupt sharing 
 acknowledge interrupt 
  hw infos
 playback on channel A 
 capture on channel B 
 playback on channel B - stereo 16bit only? 
 spdif playback on channel A 
 spdif playback on channel A (32bit, IEC958 subframes) 
 spdif capture on channel B 
  check device openclose
	 FIXME: a file should wait until the device becomes free
	  when it's opened on blocking mode.  however, since the current
	  pcm framework doesn't pass file pointer before actually opened,
	  we can't know whether blocking mode or not in open callback..
 disable dual DAC mode 
 enable dual DAC mode again 
 8768 only supports 44k48k recording
 use channel B 
 use channel A 
 use channel B 
 channel B 
 channel B 
 channel B 
 set up rate 
  mixer interface:
  - CM83388738 has a compatible mixer interface with SB16, but
    lack of some elements like tone control, io gain and AGC.
  - Access to native registers:
    - A 3D switch
    - Output mute switches
  general mixer element
  input route (left,right) -> (left,right)
  native mixer switchesvolumes
  special case - check mixer sensitivity
struct cmipci cm = snd_kcontrol_chip(kcontrol);
 ignored 
CMIPCI_MIXER_SW_MONO("PCM Playback Switch", CM_REG_MIXER1, CM_WSMUTE_SHIFT, 1),
 switch with sensitivity 
  other switches
 register index 
 mask bits 
 mask bits to turn on 
 byte access? 
	unsigned int ac3_sensitive: 1;	 access forbidden during
					  non-audio operation?
 ignored 
 these will be controlled in pcm device 
 inverse: 0 = 5V 
 DEFINE_BIT_SWITCH_ARG(spdo_48k, CM_REG_MISC_CTRL, CM_SPDF_AC97|CM_SPDIF48K, 0, 1);
 DEFINE_BIT_SWITCH_ARG(spdi_phase, CM_REG_CHFORMAT, CM_SPDIF_INVERSE, 0, 0); 
 reversed 
 DEFINE_BIT_SWITCH_ARG(line_rear, CM_REG_MIXER1, CM_REAR2LIN, 1, 0);
 DEFINE_BIT_SWITCH_ARG(line_bass, CM_REG_LEGACY_CTRL, CM_CENTR2LIN|CM_BASE2LIN, 0, 0);
 DEFINE_BIT_SWITCH_ARG(joystick, CM_REG_FUNCTRL1, CM_JYSTK_EN, 0, 0);  now module option 
  callbacks for spdif output switch
  needs toggle two registers..
 same bit as spdi_phase 
 both for CM83388738 
 for non-multichannel chips 
 only for CM8738 
 controlled in pcm device 
 DEFINE_MIXER_SWITCH("IEC958 Output Switch", spdif_enable),
	DEFINE_MIXER_SWITCH("IEC958 InOut 48KHz", spdo_48k),
 only for model 033037 
 only for model 039 or later 
 card control switches 
 mixer reset 
 8768 has no PCM volume
 mixer switches 
 card switches 
	
	  newer chips don't have the register bits to force modem link
	  detection; the bit that was FLINKON now mutes CH1
  proc interface
  check chip version and capabilities
  driver name is modified according to the chip model
 check reg 0Ch, bit 24-31 
 check reg 08h, bit 24-28 
 4 or 6 channels 
 FIXME: majority is 0x201? 
 auto-detect 
 disable ints 
 disable channels 
 reset mixer 
 first try FM regs in PCI port range 
 then try legacy ports 
 enable FM 
 dual DAC mode 
	
	  check chip version, max channels and capabilities
 added -MCx suffix for chip supporting multi-channels 
 default FUNCNTRL0 
 default FUNCNTRL0 
 initialize codec registers 
 disable ints 
 disable channels 
 magic 
 more magic 
 Set Bus Master Request 
 Assume TX and compatible chip set (Autodetection required for VX chip sets) 
 enable UART 
 reset mixer 
 create pcm devices 
 create mixer interface & switches 
	
	  (Re-)Enable external switch spdo_48k
 USE_VAR48KRATE 
  power management
 save registers 
 disable ints 
 reset  initialize to a sane state 
 restore registers 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0-or-later
   The driver for the ForteMedia FM801 based soundcards
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
 Index 0-MAX 
 ID for this card 
 Enable this card 
   Enable TEA575x tuner
     1 = MediaForte 256-PCS
     2 = MediaForte 256-PCP
     3 = MediaForte 64-PCR
    16 = setup tuner only (this is additional bit), i.e. SF64-PCR FM card
   High 16-bits are video (radio) device number + 1
   Direct registers
 PCM Output Volume 
 FM Output Volume 
 I2S Volume 
 Record Source 
 Playback Control 
 Playback Count 
 Playback Bufer I 
 Playback Buffer II 
 Capture Control 
 Capture Count 
 Capture Buffer I 
 Capture Buffer II 
 Codec Control 
 I2S Mode Control 
 Volume UpDownMute Status 
 I2C Control 
 AC'97 Command 
 AC'97 Data 
 MPU401 Data 
 MPU401 Command 
 General Purpose IO Control 
 General Control 
 Interrupt Mask 
 Interrupt Status 
 OPL3 Status Read  Bank 0 Write 
 OPL3 Data 0 Write 
 OPL3 Bank 1 Write 
 OPL3 Bank 1 Write 
 Blocks Power Down Control 
 codec access 
 read=1, write=0 
 port valid=1 
 busy=1 
 codec id (2bit) 
 playback and record control register bits 
 playback only 
 playback only 
 playback only 
 IRQ status bits 
 GPIO control register 
 readwrite 
 directions: 1 = input, 0 = output
 function select: 
    1 = GPIO 
    0 = other (SPDIF, VOL) 
  struct fm801 - describes FM801 chip
  @dev:		device for this chio
  @irq:		irq number
  @port:		IO port number
  @multichannel:	multichannel support
  @secondary:		secondary codec
  @secondary_addr:	address of the secondary codec
  @tea575x_tuner:	tuner access method & flags
  @ply_ctrl:		playback control
  @cap_ctrl:		capture control
  @ply_buffer:		playback buffer
  @ply_buf:		playback buffer index
  @ply_count:		playback buffer count
  @ply_size:		playback buffer size
  @ply_pos:		playback position
  @cap_buffer:		capture buffer
  @cap_buf:		capture buffer index
  @cap_count:		capture buffer count
  @cap_size:		capture buffer size
  @cap_pos:		capture position
  @ac97_bus:		ac97 bus handle
  @ac97:		ac97 handle
  @ac97_sec:		ac97 secondary handle
  @card:		ALSA card
  @pcm:		PCM devices
  @rmidi:		rmidi device
  @playback_substream:	substream for playback
  @capture_substream:	substream for capture
  @p_dma_size:		playback DMA size
  @c_dma_size:		capture DMA size
  @reg_lock:		lock
  @proc_entry:		proc entry
  @v4l2_dev:		v4l2 device
  @tea:		tea575a structure
  @saved_regs:		context saved during suspend
  IO accessors
 FM801 
 Gallant Odyssey Sound 4 
   common IO routines
	
	   Wait until the codec interface is not ready..
 write data and address 
	
	   Wait until the write command is not completed..
	
	   Wait until the codec interface is not ready..
 read command 
   Sample rate routines
   PCM part
 ack first 
 TODO 
   TEA5757 radio
 GPIO to TEA575x maps 
 WRITE_ENABLE is inverted 
 use GPIO lines and set write enable bit 
 all of lines are in the write direction 
 clear data and clock lines 
 use GPIO lines, set data direction to input 
 all of lines are in the write direction, except data 
 clear data, write enable and clock lines 
   Mixer routines
   initialization routines
 codec cold reset + AC'97 warm reset 
 flush posting data 
 my card has the secondary codec 
 at address #3, so the loop is inverted 
 the recovery phase, it seems that probing for non-existing codec might 
 cause timeout problems 
 init volume 
 I2S control - I2S mode 
 interrupt setup 
 mask everything, no PCM nor MPU 
 unmask MPU, PLAYBACK & CAPTURE 
 interrupt clear 
 interrupt setup - mask everything 
 FM801-AU 
 autodetect tuner connection 
 FIXME: tea575x suspend 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0-only
 Analog Devices 1889 audio driver
  This is a driver for the AD1889 PCI audio chipset found
  on the HP PA-RISC [BCJ]-xxx0 workstations.
  Copyright (C) 2004-2005, Kyle McMartin <kyle@parisc-linux.org>
  Copyright (C) 2005, Thibaut Varene <varenet@parisc-linux.org>
    Based on the OSS AD1889 driver by Randolph Chung <tausq@debian.org>
  TODO:
 	Do we need to take care of CCS register?
 	Maybe we could use finer grained locking (separate locks for pbcap)?
  Wishlist:
 	Control Interface (mixer) support
 	Better AC97 support (VSR...)?
 	PM support
 	MIDI support
 	Game Port support
 	SG DMA support (this will need a lot of work)
 keep track of some hw registers 
 reg setup 
 dma base address 
 DMA buffer size 
 playback register state 
 Disable wave channel 
 disable IRQs 
 clear IRQ and address counters and pointers 
 flush 
 Disable ADC channel 
 flush 
 average needs 352 msec 
 docs say 7000, but we're lazy 
.fifo_size = 0,
 docs say we could to VSR, but we're lazy 
.fifo_size = 0,
 Mask out 16-bit  Stereo 
 let's make sure we don't clobber ourselves 
 Set sample rates on the codec 
 Set up DMA 
 writes flush 
 Mask out 16-bit  Stereo 
 let's make sure we don't clobber ourselves 
 Set up DMA 
 writes flush 
 this is called in atomic context with IRQ disabled.
   Must be as fast as possible and not sleep.
   DMA should be triggered by this call.
 enable DMA loop & interrupts 
 1 to clear CHSS bit 
 flush 
 reset the chip when STOP - will disable IRQs 
 this is called in atomic context with IRQ disabled.
   Must be as fast as possible and not sleep.
   DMA should be triggered by this call.
 enable DMA loop & interrupts 
 1 to clear CHSS bit 
 flush 
 reset the chip when STOP - will disable IRQs 
 Called in atomic context with IRQ disabled 
 Called in atomic context with IRQ disabled 
 clear ISR 
 WARQ is at offset 12 
 SYRQ is at offset 4 
 ACRQ is at offset 4 
 RERQ is at offset 12 
	 doc says LSB represents -1.5dB, but the max value (-94.5dB)
	suggests that LSB is -3dB, which is more coherent with the logarithmic
 AD 
 AD1889 
 terminator 
 Reset Disable 
 flush posted write 
 Interface Enable 
 Audio Stream Output | Variable Sample Rate Mode 
 flush posted write 
 doing that here, it works. 
 Turn off interrupt on count and zero DMA registers 
 clear DISR. If we don't, we'd better jump off the Eiffel Tower 
 flush, dammit! 
 check PCI availability (32bit DMA) 
 (1) PCI resource allocation 
 only now can we call ad1889_free 
 (2) initialization of the chip hardware 
 turn on clock 
 flush posted write 
 enable Master and Target abort interrupts 
 (1) 
 (2) 
 (3) 
 (4) 
 (5) 
 register AC97 mixer 
 register proc interface 
 (6) 
 (7) 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for RME Digi32, Digi328 and Digi32 PRO audio interfaces
       Copyright (c) 2002-2004 Martin Langer <martin-langer@gmx.de>,
                               Pilo Chambert <pilo.c@wanadoo.fr>
       Thanks to :        Anders Torger <torger@ludd.luth.se>,
                          Henk Hesselink <henk@anda.nl>
                          for writing the digi96-driver 
                          and RME for all informations.
  Note #1 "Sek'd models" ................................... martin 2002-12-07
  Identical soundcards by Sek'd were labeled:
  RME Digi 32     = Sek'd Prodif 32
  RME Digi 32 Pro = Sek'd Prodif 96
  RME Digi 328   = Sek'd Prodif Gold
  Note #2 "full duplex mode" ............................... martin 2002-12-07
  Full duplex doesn't work. All cards (32, 328, 32Pro) are working identical
  in this mode. Rec data and play data are using the same buffer therefore. At
  first you have got the playing bits in the buffer and then (after playing
  them) they were overwitten by the captured sound of the CS841214. Both 
  modes (playrecord) are running harmonically hand in hand in the same buffer
  and you have only one start bit plus one interrupt bit to control this 
  paired action.
  This is opposite to the latter rme96 where playing and capturing is totally
  separated and so their full duplex mode is supported by alsa (using two 
  start bits and two interrupts for two different buffers). 
  But due to the wrong sequence of playing and capturing ALSA shows no solved
  full duplex support for the rme32 at the moment. That's bad, but I'm not
  able to solve it. Are you motivated enough to solve this problem now? Your
  patch would be welcome!
  "The story after the long seeking" -- tiwai
  Ok, the situation regarding the full duplex is now improved a bit.
  In the fullduplex mode (given by the module parameter), the hardware buffer
  is split to halves for read and write directions at the DMA pointer.
  That is, the half above the current DMA pointer is used for write, and
  the half below is used for read.  To mangle this strange behavior, an
  software intermediate buffer is introduced.  This is, of course, not good
  from the viewpoint of the data transfer efficiency.  However, this allows
  you to use arbitrary buffer sizes, instead of the fixed IO buffer size.
 Index 0-MAX 
 ID for this card 
 Enable this card 
 = {[0 ... (SNDRV_CARDS - 1)] = 1};
 Defines for RME Digi32 series 
 Playback and capture buffer size 
 IO area size 
 IO area offsets 
 Write control register bits 
 startbit 
#define RME32_WCR_MONO      (1 << 1)     0=stereo, 1=mono
                                           Setting the whole card to mono
                                           doesn't seem to be very useful.
                                           A software-solution can handle 
                                           full-duplex with one direction in
                                           stereo and the other way in mono. 
                                           So, the hardware should work all 
 0=16bit, 1=32bit 
 0=input on output, 1=normal playbackcapture 
 frequency (play) 
 input switch 
 Reset address 
 digital mute for output 
 1=professional, 0=consumer 
 1=DoubleSpeed (only PRO-Version); 1=BlockMode (only Adat-Version) 
 Adat Mode (only Adat-Version) 
 AutoSync 
 DAC Reset (only PRO-Version) 
 1=Emphasis on (only PRO-Version) 
 Read control register bits 
 1=locked, 0=not locked 
 1=Error, 0=no Error 
 CS841x frequency (record) 
 card mode: 1=PLL, 0=quartz 
 interrupt 
 Input types 
 Clock modes 
 Block sizes in bytes 
 Software intermediate buffer (max) size 
 Hardware revisions 
 cached write control register value 
 SPDIF setup 
 SPDIF setup (temporary) 
 cached read control register value 
 card revision number 
 log2 of framesize 
 in bytes, zero if not used 
 in bytes, zero if not used 
 silence callback for halfduplex mode 
 copy callback for halfduplex mode 
 copy callback for halfduplex mode 
  SPDIF IO capabilities (half-duplex mode)
  ADAT IO capabilities (half-duplex mode)
  SPDIF IO capabilities (full-duplex mode)
  ADAT IO capabilities (full-duplex mode)
 ADAT rate 
 SPDIF rate 
 supporting the CS8414 
 supporting the CS8412 
 change tofrom double-speed: reset the DAC (if available) 
 AutoSync 
 Internal 32.0kHz 
 Internal 44.1kHz 
 Internal 48.0kHz 
 assume 8 channels 
 AutoSync 
 SPDIF setup 
 enable AutoSync for record-preparing 
 AutoSync off for recording 
	
	  Check if there is an unconfirmed IRQ, if so confirm it, or else
	  the hardware will not stop generating interrupts
 AutoSync 
 AutoSync 
 remember the current DMA position 
 pointer callback for halfduplex mode 
 ack and pointer callbacks for fullduplex mode 
 for halfduplex mode 
 for fullduplex mode 
 read the card's revision number 
 set up ALSA pcm device for SPDIF 
 set up ALSA pcm device for ADAT 
 ADAT is not available on DIGI32 and DIGI32 Pro 
 make sure playbackcapture is stopped, if by some reason active 
 reset DAC 
 reset buffer pointer 
 set default values in registers 
 normal playback 
 input select 
 muting on 
 init switch interface 
 init proc interface 
  proc interface
 master output frequency 
  control interface
 IEC958 (SPDIF) Stream 
  Card initialisation
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for RME Digi96, Digi968 and Digi968 PROPADPST audio
    interfaces 
 	Copyright (c) 2000, 2001 Anders Torger <torger@ludd.luth.se>
       Thanks to Henk Hesselink <henk@anda.nl> for the analog volume control
       code.
 note, two last pcis should be equal, it is not a bug 
 Index 0-MAX 
 ID for this card 
 Enable this card 
  Defines for RME Digi96 series, from internal RME reference documents
  dated 12.01.00
 Playback and capture buffer size 
 IO area size 
 IO area offsets 
 Write control register bits 
 Read control register bits 
 Additional register bits 
 Monitor tracks 
 Attenuation 
 Input types 
 Clock modes 
 Block sizes in bytes 
 Volume control 
 Defines for snd_rme96_trigger 
 cached write control register value 
 SPDIF setup 
 SPDIF setup (temporary) 
 cached read control register value 
 cached additional register value 
 cached volume of analog output 
 card revision number 
 log2 of framesize 
 in bytes, zero if not used 
 in bytes, zero if not used 
  Digital output capabilities (SPDIF)
  Digital input capabilities (SPDIF)
  Digital output capabilities (ADAT)
  Digital input capabilities (ADAT)
  The CDATA, CCLK and CLATCH bits can be used to write to the SPI interface
  of the AD1852 or AD1852 DA converter on the board.  CDATA must be set up
  on the falling edge of CCLK and be stable on the rising edge.  The rising
  edge of CLATCH after the last data bit clocks in the whole data word.
  A fast processor could probably drive the SPI interface faster than the
  DAC can handle (3MHz for the 1855, unknown for the 1852).  The udelay(1)
  limits the data rate to 500KHz and only causes a delay of 33 microsecs.
  NOTE: increased delay from 1 to 10, since there where problems setting
  the volume.
 Analog input, overrides SPDIF setting 
 ADAT rate 
 SPDIF rate 
 slave clock 
 change tofrom double-speed: reset the DAC (if available) 
 need to restore volume 
 AutoSync  
 Internal 
 Word clock is a master mode 
 Only Digi968 PRO and Digi968 PAD supports XLR 
			
			  Revision less than 004 does not support 64 and
			  88.2 kHz
 assume 8 channels 
 slave clock 
 need to restore volume later? 
 SPDIF setup 
 fastpath out, to ease interrupt sharing 
 playback 
 capture 
 slave clock 
 slave clock 
                 makes no sense to use analog input. Note that analog
 read the card's revision number 
 set up ALSA pcm device for SPDIF 
 set up ALSA pcm device for ADAT 
 ADAT is not available on the base model 
 make sure playbackcapture is stopped, if by some reason active 
 set default values in registers 
 set 44.1 kHz playback 
 normal playback 
 set to master clock mode 
 set coaxial input 
 set 44.1 kHz analog capture 
 reset the ADC 
 reset and enable the DAC (order is important). 
 reset playback and record buffer pointers 
 reset volume 
 init switch interface 
 init proc interface 
  proc interface
  control interface
 PST 
 Analog instead of XLR 
 PAD 
 for handling PST case, (INPUT_ANALOG is moved to INPUT_XLR 
 special case for PST 
 IEC958 (SPDIF) Stream 
  Card initialisation
 save capture & playback pointers 
 save playback and capture buffers 
 disable the DAC  
 reset playback and record buffer pointers 
 restore playback and capture buffers 
 reset the ADC 
 reset and enable DAC, restore analog volume 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0-or-later
   Driver for ESS Maestro 122E Sound Card (started 21.8.99)
   Copyright (c) by Matze Braun <MatzeBraun@gmx.de>.
                    Takashi Iwai <tiwai@suse.de>
   Most of the driver code comes from Zach Brown(zab@redhat.com)
 	Alan Cox OSS Driver
   Rewritted from card-es1938.c source.
   TODO:
    Perhaps Synth
   Notes from Zach Brown about the driver code
   Hardware Description
 	A working Maestro setup contains the Maestro chip wired to a 
 	codec or 2.  In the Maestro we have the APUs, the ASSP, and the
 	Wavecache.  The APUs can be though of as virtual audio routing
 	channels.  They can take data from a number of sources and perform
 	basic encodings of the data.  The wavecache is a storehouse for
 	PCM data.  Typically it deals with PCI and interracts with the
 	APUs.  The ASSP is a wacky DSP like device that ESS is loth
 	to release docs on.  Thankfully it isn't required on the Maestro
 	until you start doing insane things like FM emulation and surround
 	encoding.  The codecs are almost always AC-97 compliant codecs, 
 	but it appears that early Maestros may have had PT101 (an ESS
 	part?) wired to them.  The only real difference in the Maestro
 	families is external goop like docking capability, memory for
 	the ASSP, and initialization differences.
   Driver Operation
 	We only drive the APUWavecache as typical DACs and drive the
 	mixers in the codecs.  There are 64 APUs.  We assign 6 to each
 	devdsp? device.  2 channels for output, and 4 channels for
 	input.
 	Each APU can do a number of things, but we only really use
 	3 basic functions.  For playback we use them to convert PCM
 	data fetched over PCI by the wavecahche into analog data that
 	is handed to the codec.  One APU for mono, and a pair for stereo.
 	When in stereo, the combination of smarts in the APU and Wavecache
 	decide which wavecache gets the left or right channel.
 	For record we still use the old overly mono system.  For each in
 	coming channel the data comes in from the codec, through a 'input'
 	APU, through another rate converter APU, and then into memory via
 	the wavecache and PCI.  If its stereo, we mash it back into LRLR in
 	software.  The pass between the 2 APUs is supposedly what requires us
 	to have a 512 byte buffer sitting around in wavecachememory.
 	The wavecache makes our life even more fun.  First off, it can
 	only address the first 28 bits of PCI address space, making it
 	useless on quite a few architectures.  Secondly, its insane.
 	It claims to fetch from 4 regions of PCI space, each 4 meg in length.
 	But that doesn't really work.  You can only use 1 region.  So all our
 	allocations have to be in 4meg of each other.  Booo.  Hiss.
 	So we have a module parameter, dsps_order, that is the order of
 	the number of dsps to provide.  All their buffer space is allocated
 	on open time.  The sonicvibes OSS routines we inherited really want
 	power of 2 buffers, so we have all those next to each other, then
 	512 byte regions for the recording wavecaches.  This ends up
 	wasting quite a bit of memory.  The only fixes I can see would be 
 	getting a kernel allocator that could work in zones, or figuring out
 	just how to coerce the WP into doing what we want.
 	The indirection of the various registers means we have to spinlock
 	nearly all register accesses.  We have the main register indirection
 	like the wave cache, maestro registers, etc.  Then we have beasts
 	like the APU interface that is indirect registers gotten at through
 	the main maestro indirection.  Ouch.  We spinlock around the actual
 	ports on a per card basis.  This means spinlock activity at each IO
 	operation, but the only IO operation clusters are in non critical 
 	paths and it makes the code far easier to follow.  Interrupts are
 	blocked while holding the locks because the int handler has to
 	get at some of them :(.  The mixer interface doesn't, however.
 	We also have an OSS state lock that is thrown around in a few
 	places.
 Index 1-MAX 
 ID for this card 
 Enable this card 
 NEC Versas ? 
 Mode Flags 
 Values for the ESM_LEGACY_AUDIO_CONTROL 
 Values for the ESM_CONFIG_A 
 Values for the ESM_CONFIG_B 
undoc 
undoc 
undoc 
 Values for Ring Bus Control B 
 Port Addresses 
   Write & Read 
   AC97 + RingBus 
   WaveCache
   ASSP
 Midi 
 Others 
 PCI Register 
 Bob Bits 
 Host IRQ Control Bits 
 What's that? 
 Host IRQ Status Bits 
 default rate 48000 
 APU Modes: reg 0x00, bit 4-7 
 16-Bit Linear Sample Player 
 16-Bit Stereo Sample Player 
 8-Bit Linear Sample Player 
 8-Bit Stereo Sample Player 
 8-Bit Differential Sample Playrer 
 Digital Delay Line 
 Dual Tap Reader 
 Correlator 
 Input Mixer 
 Wave Table Mode 
 Sample Rate Convertor 
 16-Bit Ping-Pong Sample Player 
 Reserved 1 
 Reserved 2 
 Reserved 3 
 reg 0x00 
 APU Filtey Q Control 
 reg 0x02 
 reg 0x03 
 reg 0x04 
 most 8bit of wave start offset 
 reg 0x05 - wave start offset 
 reg 0x06 - wave end offset 
 reg 0x07 - wave loop length 
 reg 0x08 
 reg 0x09 
 bit 0-7 amplitude dest? 
 reg 0x0a 
 Polar Pan Control 
 reg 0x0b 
 reg 0x0c 
 APU Filter Control 
 APU ATFP Type 
 APU ATFP Flags 
 capture mixing buffer size 
 APU use in the driver 
 chip type 
 DMA Hack! 
 status 
 Playback Channel 
 playbackcapture pcm buffer 
 capture mixer buffer 
 current hw pointer in bytes 
 sample counter in bytes 
 total buffer size in bytes 
 period size in bytes 
 offset for ptr 
 stereo16bit flag 
 playback  capture 
 required timer frequency 
 linked list 
 Module Config 
 in bytes 
 clock 
 for clock measurement 
 buffer 
 Resources... 
 power-management enabled 
 DMA memory block 
 ALSA Stuff 
 Maestro Stuff 
 active timer instancs 
 timer frequency 
 memory lock 
 APU states 
 active substreams 
 physical device path 
 for hw volume control 
 Maestro 1 
 Maestro 2 
 Maestro 2E 
    Low Level Funcs!  
 no spinlock 
 no spinlock 
 Wait for the codec bus to be free 
 timeout 
 timeout 
 Write the bus 
msleep(1);
msleep(1);
msleep(1);
msleep(1);
 no spinlock 
 no spinlock 
 no spinlock 
 ASSP is not supported 
    Bob the Timer!  
 compute ideal interrupt frequency for buffer size & play rate 
 first, find best prescaler value to match freq 
 next, back off prescaler whilst getting divider into optimum range 
 now fine-tune the divider for best match 
 divide = 0 is illegal, but don't let prescale = 4! 
 set reg 
 Now set IDR 1117 
 call with substream spinlock 
 call with substream spinlock 
 check reduction of timer frequency 
 we acquire 4 interrupts per period for precise control.. 
   PCM Part 
 XXX: do we need this?  
 get current pointer 
 hardware is in words 
 spin lock held 
 set the APU mode 
 set the wavecache control reg 
 8bit 
 stereo 
 set the wavecache control reg 
 Offset to PCMBAR 
 words 
 System RAM (Bit 22) 
 Enable stereo 
 (Bit 23) 
		 base offset of dma calcs when reading the pointer
 Load the buffer into the wave engine 
 setting loop == sample len 
 clear effectsenv.. 
 set amp now to 0xd0 (?), low byte is 'amplitude dest'? 
 clear routing stuff 
 dma on, no envelopes, filter to all 1s) 
 set panning: left or right 
			 Check: different panning. On my Canyon 3D Chipset the
			   Channels are swapped. I don't know, about the output
			   to the SPDif Link. Perhaps you have to change this
 stereo 
 clear WP interrupts 
 enable WP ints 
 set frequency 
 hmmm.. 
 Load the frequency, turn on 6dB 
 set the wavecache control reg 
 Offset to PCMBAR 
 words 
	 base offset of dma calcs when reading the pointer
 bit 22 -> System RAM 
 Begin loading the APU 
	 need to enable subgroups.. and we should probably
 Load the buffer into the wave engine 
 clear effectsenv.. 
 amplitude now?  sure.  why not.  
 set filter tune, radius, polar pan 
 route input 
 dma on, no envelopes, filter to all 1s) 
	 APU assignments:
	   0 = monoleft SRC
	   1 = right SRC
	   2 = monoleft Input Mixer
	   3 = right Input Mixer
	 data seems to flow from the codec, through an apu into
	   the 'mixbuf' bit of page, then through the SRC apu
 input mixer (leftmono) 
 parallel in crap, see maestro reg 0xC [8-11] 
 in words 
 SRC (leftmono); get input from inputing apu 
 input mixer (right) 
 in words 
 SRC (right) 
 Sample Rate conversion APUs don't like 0x10000 for their rate 
 Load the frequency, turn on 6dB 
 fix mixer rate at 48khz.  and its _must_ be 0x10000. 
 clear WP interrupts 
 enable WP ints 
   ALSA Interface 
 maestro handles always 16bit 
 8bit is already word shifted 
SNDRV_PCM_INFO_PAUSE |
SNDRV_PCM_INFO_PAUSE |
SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
    DMA memory management 
 Because the Maestro can only take addresses relative to the PCM base address
 allocate a new memory chunk with the specified size 
 free a memory chunk 
 allocate an empty chunk 
 setup the dma_areas 
 buffer is extracted from the pre-allocated memory chunk 
 area was changed 
 remove dma areas if allocated 
  allocate APU pair
  release APU pair
  PCM openclose 
 search 2 APUs 
 get mixbuffer 
 keep MIXBUF size 
  measure clock
 enough large for a single shot 
 default clock value 
 search 2 APUs (although one apu is enough) 
 System RAM (Bit 22) 
 initialize apu 
 clear WP interrupts 
 enable WP ints 
 48000 Hz 
 stop 
 check the current position 
 get DMA buffer 
 set PCMBAR 
  suppress jitter on some maestros when playing stereo
  update pointer
 The hardware volume works by incrementing  decrementing 2 counters
   (without wrap around) in response to volume button presses and then
   generating an interrupt. The pair of counters is stored in bits 1-3 and 5-7
	 Figure out which volume control button was pushed,
	   based on differences from the default register
 Reset the volume control registers. 
 mute 
 volume up 
 volume down 
		 The counters have not changed, yet we've received a HV
		   interrupt. According to tests run by various people this
 counters increased by 1 -> volume up 
 counters decreased by 1 -> volume down 
  interrupt handler
 else ack 'em all, i imagine 
   Mixer stuff
 ES1968 doesn't need VRA 
 attach master switch  volumes for hw volume control 
  reset ac97 codec
 save configuration 
outw(inw(ioaddr + 0x38) & 0xfffc, ioaddr + 0x38);  clear second codec id? 
 set commandstatus address io to 1st codec 
 disable ac link 
 something magical with gpio and bus arb. 
 unmask gpio 0 
 gpio write 
 write 0 to gpio 0 
 write 1 to gpio 1 
 now restore .. 
 now the second codec 
 disable ac link 
 unmask gpio 3 
 gpio write 0 & 3 ?? 
 write 1 to gpio 
 write 9 to gpio 
outw(inw(ioaddr + 0x38) & 0xfffc, ioaddr + 0x38);
 the loop here needs to be much better if we want it.. 
 try and do a software reset 
 do a software reset 
 oh my.. 
 turn on external amp? 
 restore.. 
	 Turn on the 978 docking chip.
	   First frob the "master output enable" bit,
 Reset 
  initialize maestro chip
	 We used to muck around with pci config space that
	  we had no business messing with.  We don't know enough
	  about the machine to know which DMA mode is appropriate, 
	  etc.  We were guessing wrong on some machines and making
	  them unhappy.  We now trust in the BIOS to do things right,
	  which almost certainly means a new host of problems will
	  arise with broken BIOS implementations.  screw 'em. 
	  We're already intolerant of machines that don't assign
	  IRQs.
 Config Reg A 
 Clear DMA bits 
 Clear Pic Snoop Mode Bits 
 Safeguard off 
 Posted write 
 PCI timing on 
 XXX huh?  claims to be reserved.. 
	w &= ~SWAP_LR;		 swap leftright 
				   seems to only have effect on SB
 Subtractive decode off 
 Config Reg B 
 Turn off internal clock multiplier 
 XXX how do we know which to use? 
 External clock 
 disable SPDIF output 
 HWV on 
 Debounce off: easier to push the HW buttons 
 GPIO 4:5 
 Disconnect from the CHI.  Enabling this made a dell 7500 work. 
 IDMA off (undocumented) 
 MIDI fix off (undoc) 
 reserved, always write 0 
 IRQ to ISA off (undoc) 
 DDMA off 
	
	 	Legacy mode
 Disable Legacy Audio 
 Disable SIRQ 
 disable mpu irqio, game port, fm, SB 
 Set up 978 docking control chip. 
 Enable 978. 
 Turn on 978 hardware volume control. 
 Turn on 978 mixer volume control. 
 Sound Reset 
	
	 	Ring Bus Setup
 setup usual 0x34 stuff.. 0x36 may be chip specific 
 direct sound, stereo 
 enable ringbusserial 
	
	 	Reset the CODEC
 Ring Bus Control B 
 SPDIF off 
w |= RINGB_EN_2CODEC;	 enable 2nd codec 
	 Set hardware volume control registers to midpoints.
	 it appears some maestros (dell 7500) only work if these are set,
 M: Reserved bits... 
 M: Disable ASSP, ASSP IRQ's and FM Port 
	
	  set up wavecache
 Write 0 into the buffer area 0x1E0->1EF 
		 The 1.10 test program seem to write 0 into the buffer area
 Now back to the DirectSound stuff 
 audio serial configuration.. ? 
 parallel in, has something to do with recording :) 
 parallel out 
	 Wave cache control on - test off, sg off, 
 Seems to be reserved? I don't know 
 reserved... I don't know 
	w &= ~0x0200;		 Channels 56,57,58,59 as Extra Play,Rec Channel enable
 Wave Cache Operation Enabled 
 Channels 6061 as PlacbackRecord enabled 
 Clear Wavtable Size 
 Wavetable Size : 1MB 
 Bit 4 is reserved 
 DMA Stuff? I don't understand what the datasheet means 
 Bit 1 is reserved 
 Test Mode off 
 Now clear the APU control ram 
 Enable IRQ's 
  PM support
 need to restore the base pointers..  
 set PCMBAR 
 restore ac97 state 
 start timer again 
 CONFIG_PM_SLEEP 
 CONFIG_SND_ES1968_INPUT 
#define IO_MASK		4       mask      register offset from GPIO_DATA
#define IO_DIR		8       direction register offset from GPIO_DATA
 GPIO to TEA575x maps 
 clear WP interrupts 
 disable IRQ 
 chip type 
 subsystem vendor id 
 Compaq Armada 
 HP omnibook 4150 
 a PCI card, e.g. Terratec DMX 
 a PCI card, e.g. SF64-PCE2 
 enable PCI device 
 check, if we can restrict PCI DMA transfers to 28 bits 
 Set Vars 
 in bytes 
 Clear Maestro_map 
 Clear Apu Map 
 just to be sure 
 disable power-management if not on the allowlist 
 not matched; disabling pm 
 don't play with GPIOs on laptops 
 in bytes 
 check the deny list 
 SPDX-License-Identifier: GPL-2.0-or-later
  bt87x.c - Brooktree Bt878Bt879 driver for ALSA
  Copyright (c) Clemens Ladisch <clemens@ladisch.de>
  based on btaudio.c by Gerd Knorr <kraxel@bytesex.org>
 Exclude the first card 
 ID for this card 
 Enable this card 
 digital input rate 
 allow to load cards not the allowlist 
 register offsets 
 interrupt status 
 interrupt mask 
 audio control 
 audio packet lengths 
 RISC program start address 
 RISC program counter 
 interrupt bits 
 audio AD overflow 
 RISC instruction IRQ bit set 
 FIFO overrun due to bus access latency 
 FIFO overrun due to target latency 
 FIFO data stream resynchronization 
 PCI parity error 
 RISC instruction parity error 
 PCI master or target abort 
 invalid opcode 
 sync counter overflow 
 DMA controller running 
 RISC status bits 
 audio control bits 
 enable audio data FIFO 
 enable audio DMA controller 
 packet mode FIFO trigger point - 4 DWORDs 
 8 DWORDs 
 16 DWORDs 
 enable audio capture 
 GPIO input 
 audio AD input 
 digital audio input 
 DDF first stage decimation rate 
 limit audio data values 
 enable DDF stage 2 
 samples rounded to 8 bits 
 data packet mode 
 ALRCK delay 
 MSBLSB format 
 leftright indication 
 sample clock edge 
 TV tuner audio input 
 FM audio input 
 micline audio input 
 MUX bypass 
 analog audio power-down 
 audio gain boost 
 audio input gain 
 RISC instruction opcodes 
 write FIFO data to memory at address 
 write FIFO data to memory at current address 
 skip FIFO data 
 jump to address 
 synchronize with FIFO 
 RISC instruction bits 
 byte enable bits 
 disable FDSR errors 
 set status bits 
 clear status bits 
 interrupt 
 end of line 
 start of line 
 SYNC status bits values 
 SYNC, one WRITE per line, one extra WRITE per page boundary, SYNC, JUMP 
 Cards with configuration information 
 both an & dig interfaces, 32kHz 
 board with no external AD 
 Card configuration 
 Digital input sampling rate 
 Register settings for digital input 
 No analog input 
 No digital input 
 just a guess 
 error 'handling' similar to aic7xxx_pci.c: 
 assume that exactly one line has been recorded 
 but check if some interrupts have been skipped 
 set at runtime 
 driver_data is the card id for that device 
 Hauppauge WinTV series 
 Hauppauge WinTV series 
 Viewcast Osprey 200 
 Viewcast Osprey 440 (rate is configurable via gpio) 
 ATI TV-Wonder 
 Leadtek Winfast tv 2000xp delux 
 Pinnacle PCTV 
 Voodoo TV 200 
 Askey Computer Corp. MagicTView'99 
 AVerMedia Studio No. 103, 203, ...? 
 Prolink PixelView PV-M4900 
 Pinnacle  Studio PCTV rave 
 cards known not to have audio
 Nebula Electronics DigiTV 
 Pinnacle PCTV Sat 
 Pinnacle PCTV SAT CI 
 AVermedia AverTV DVB-T 
 AVermedia DVB-T 771 
 Twinhan VisionPlus DVB-T 
 DVICO FusionHDTV 5 Lite 
 DVICO FusionHDTV DVB-T Lite 
 Ultraview DVB-T Lite 
 Chaintech Digitop DST-1000 DVB-S 
 pcHDTV HD-2000 TV 
 return the id of the card, or a negative value if it's on the denylist 
 default entries for all Bt87x cards - it's not exported 
 driver_data is set to 0 to call detection 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for Intel ICH (i8x0) chipsets
 	Copyright (c) 2000 Jaroslav Kysela <perex@perex.cz>
    This code also contains alpha support for SiS 735 chipsets provided
    by Mike Pieper <mptei@users.sourceforge.net>. We have no datasheet
    for SiS735, so the code is not fully functional.
 Index 0-MAX 
 ID for this card 
 auto-check 
 just for backward compatibility 
   Direct registers
 dword - buffer descriptor list base address  \
 byte - current index value  \
 byte - last valid index  \
 byte - status register  \
 word - position in current buffer  \
 byte - prefetched index value  \
 byte - control register  \
 busmaster blocks 
 offset 
 PCM in 
 PCM out 
 Mic in 
 ICH4 busmaster blocks 
 Mic in 2 
 PCM in 2 
 SPDIF out 
 values for each busmaster block 
 LVI 
 SR 
 FIFO error 
 buffer completion interrupt status 
 last valid buffer completion interrupt 
 current equals last valid 
 DMA controller halted 
 PIV 
 mask 
 CR 
 interrupt on completion enable 
 fifo error interrupt enable 
 last valid buffer interrupt enable 
 reset busmaster registers 
 start busmaster operation 
 global block 
 dword - global control 
 spdif pcm slot mask (ICH4) 
 reserved - undefined 
 spdif pcm on slots 7&8 
 spdif pcm on slots 6&9 
 spdif pcm on slots 10&11 
 20-bit samples (ICH4) 
 chan mask (not all chips) 
 8 channels (not all chips) 
 6 channels (not all chips) 
 4 channels (not all chips) 
 2 channels (stereo) 
 6 channels (SIS7012) 
 6 channels (SIS7012) 
 4 channels (SIS7012) 
 2 channels (SIS7012) 
 tertiary resume interrupt enable 
 secondary resume interrupt enable 
 primary resume interrupt enable 
 AClink shut off 
 AC'97 warm reset 
 AC'97 cold reset 
 GPI interrupt enable 
 dword - global status 
 ICH4: tertiary (AC_SDIN2) resume interrupt 
 ICH4: tertiary (AC_SDIN2) codec ready 
 ICH4: bit clock stopped 
 ICH4: SPDIF interrupt 
 ICH4: PCM2-In interrupt 
 ICH4: Mic2-In interrupt 
 ICH4: sample capability bits (RO) 
 ICH4: 16- and 20-bit samples 
 ICH4: multi-channel capability bits (RO) 
 SIS: tertiary resume irq 
 SIS: tertiary codec ready 
 modem power down semaphore 
 audio power down semaphore 
 read completion status 
 bit 3 slot 12 
 bit 2 slot 12 
 bit 1 slot 12 
 secondary (AC_SDIN1) resume interrupt 
 primary (AC_SDIN0) resume interrupt 
 secondary (AC_SDIN1) codec ready 
 primary (AC_SDIN0) codec ready 
 MIC capture interrupt 
 playback interrupt 
 capture interrupt 
 nforce spdif interrupt 
 modem playback interrupt 
 modem capture interrupt 
 GPI status change interrupt 
 byte - codec write semaphore 
 codec access semaphore 
 PCM In 2, Mic In 2 data in line 
 PCM In 1, Mic In 1 data in line 
 steer enable 
 last codec read data input 
 max hw frags 
  registers for Ali5455
 ALi 5455 busmaster blocks 
 ALi PCM in 
 Ali PCM out 
 Ali Mic in 
 Ali Codec SPDIF out 
 Ali center out 
 Ali center out 
 Ali Controller SPDIF in 
 Ali Controller SPDIF out 
 Ali I2S in 
 Ali PCM2 in 
 Ali Mic2 in 
 System Control Register 
 System Status Register  
 DMA Control Register    
 FIFO Control Register 1  
 Interface Control Register 
 Interrupt control Register 
 Interrupt  Status Register 
 FIFO Control Register 2   
 Command Port Register     
 ac97 addr write 
 Status Port Register      
 ac97 addr read 
 FIFO Control Register 3  
 Transmit Tag Slot Register 
 Receive Tag Slot  Register 
 CommandStatus Port Status Register 
 Codec Write Semaphore Register 
 hardware volume controlstatus 
 I2S controlstatus 
 spdif channel status register  
 spdif interface controlstatus  
 interrupts for the whole chip by interrupt status register finish 
 controller spdif out INTERRUPT 
 command port available 
 status port available 
 master reset 
 1=78, 2=69, 3=1011 
 01 = slot 36 
 01 = slot 36 
 00 = PCM, 01 = AC97-in, 10 = spdif-in, 11 = i2s 
 00 = PCM, 10 = spdif-in, 11 = i2s 
 ich device number 
 offset to bmaddr 
 CPU address (32bit) 
 PCI bus address (32bit) 
 physical address (32bit) 
 interrupt status mask 
 ALI DMA slot 
 during ac97 clock measurement 
 workaround for 440MX 
 workaround for buggy mobos 
 workaround for Xbox AC'97 detection 
 workaround for buggy codec semaphore 
 enable VM optimization 
 SPDIF BAR index; _SPBAR or -1 if use PCMOUT 
 SDM reg value 
 interrupt status register 
 interrupt status mask 
 82801AA 
 82901AB 
 82801BA 
 ICH3 
 ICH4 
 ICH5 
 ESB 
 ICH6 
 ICH7 
 ESB2 
 440MX 
 SI7012 
 NFORCE 
 MCP04 
 NFORCE2 
 CK804 
 CK8 
 NFORCE3 
 CK8S 
 MCP51 
 AMD8111 
 AMD768 
 Ali5455 
   Lowlevel IO - busmaster
   Lowlevel IO - AC'97 registers
   Basic IO
  access to AC97 codec via normal io (for ICH and SIS7012)
 we don't know the ready bit assignment at the moment 
 so we check any 
 codec ready ? 
 just ignore ... 
 Anyone holding a semaphore for 1 msec should be shot... 
	 access to some forbidden (non existent) ac97 registers will not
	  reset the semaphore. So even if you don't get the semaphore, still
 clear semaphore flag 
 I don't care about the semaphore 
 reset RCS and preserve other RWC bits 
 reset RCS and preserve other RWC bits 
  access to AC97 for Ali5455
 just ignore ... 
  DMA IO
 interrupt on completion 
 interrupt on completion 
 interrupt on completion 
 clear interrupts 
   Interrupt handler
 snd_printd("civ same %d\n", civ);
 if (step != 1)
	snd_printd("step = %d, %d -> %d\n", step, ichdev->civ, civ);
 we are not yet resumed 
 ack 
 ack them 
   PCM part
 wait until DMA stopped 
 reset whole DMA things 
 clear FIFO for synchronization of channels 
 clear PAUSE flag 
 start DMA 
 pause 
 reset whole DMA things 
 clear interrupts 
 Force SPDIF setting 
			 reset to 2ch once to keep the 6 channel data in alignment,
			  to start from Front Left always
 grrr... 
		 IO read operation is very expensive inside virtual machine
		  as it is emulated. The probability that subsequent PICB read
		  will return different result is high enough to loop till
		  timeout here.
		  Same CIV is strict enough condition to be sure that PICB
			 another sanity check; ptr1 can go back to full
			  before the base position is updated
 also needs to set ALI_SC_CODEC_SPDF correctly 
 NYI
 NYI
 NYI
 .capture_ops = &snd_intel8x0_ali_spdifin_ops, 
 NYI
 activate PCM only when associated AC'97 codec 
   Mixer part
 front PCM 
 PCM IN #1 
 MIC IN #1 
 SPDIF PCM 
 PCM IN #2 
 MIC IN #2 
 AD1885 
 AD1885 
 AD1981B 
 AD1885 
 which model?  AD1885 
 AD1981A 
 AD1981A 
 AD1981B
 which model?  AD1981B
 AD1981B 
 STAC975051 
 STAC975051 
 STAC975051 
 STAC975051 
 cf. Malone #41015 
 cf. Malone #41015 
AD1981B
 FIXME: which codec? 
 AD1981B
 AD1981B
AD1981B
AD1981B
 STAC975051 
 AD1981? 
 ALC650 
 AD1981? 
 AD1981B 
 AD1981 
 AD1885 
 FIXME: this seems wrong on most boards 
 terminator 
 use PCMOUT (or disabled) 
 detect the secondary codec 
 FIXME: my test board doesn't work well with VRA... 
 tune up the primary codec 
 enable separate SDINs for ICH4 
 find the available PCM streams 
 do not allocate PCM2IN and MIC2 
 do not allocate SPDIF 
 enable separate SDINs for ICH4 
 steer enable for multiple SDINs 
 steer disable 
 48kHz only 
 use slot 1011 for SPDIF 
 clear the cold-reset bit for the next chance 
 end 
 ACLink on, 2 channels 
	 do cold reset - the full ac97 powerdown may leave the controller
	  in a warm state but actually it cannot communicate with the codec.
 ACLink on, 2 channels 
 finish cold or do warm reset 
 put logic to right state 
 first clear status bits 
		 wait for any codec ready status.
		  Once it becomes ready it should remain ready
		  as long as we do not disable the ac97 link.
 no codec is found 
 wait for other codecs ready status. 
 resume phase 
 wait until all the probed codecs are ready 
 unmute the output on SIS7012 
 enable SPDIF interrupt 
 Cold required 
 Warm 
 ACLink on 
 primary codec 
 clear semaphore flag 
 disable interrupts 
 reset channels 
 initialize Buffer Descriptor Lists 
 disable interrupts 
 reset channels 
 stop the spdif interrupt 
 --- 
  power management
 re-initialize mixer stuff 
 enable separate SDINs for ICH4 
 use slot 1011 for SPDIF 
 resume status 
 CONFIG_PM_SLEEP 
 enough large for one shot 
 specified in module option 
 no measurement on VM 
 don't process interrupts 
 set rate 
 trigger 
 check the position 
 oops, this value is not reliable 
 stop 
 abnormal value. hw problem? 
 first exception - 41000Hz reference clock 
 second exception - 44100HZ reference clock 
 not 48000Hz, tuning the clock.. 
 terminator 
 check module parameter first (override detection) 
 check for known (emulated) devices 
 KVM emulated sound, PCI SSID: 1af4:1100 
 Parallels VM emulated sound, PCI SSID: 1ab8:xxxx 
 DEVICE_INTEL 
 DEVICE_INTEL_ICH4 
 DEVICE_SIS 
 DEVICE_ALI 
 DEVICE_NFORCE 
 module parameters 
	
	  Intel 82443MX running a 100MHz processor system bus has a hardware
	  bug, which aborts PCI busmaster for audio transfer.  A workaround
	  is to set the pages as non-cached.  For details, see the errata in
	      http:download.intel.comdesignchipsetsspecupdt24505108.pdf
 enable workaround 
 ALI5455 has no ac97 region 
 ICH4 and Nforce 
 ICH4 
 initialize offsets 
 SiS 7012 swaps the registers 
 SIS7012 handles the pcm data in bytes, others are in samples 
 allocate buffer descriptor lists 
 the start of each lists must be aligned to 8 bytes 
	 tables must be aligned to 8 bytes here, but the kernel pages
 ICH4 can have three codecs 
 recent SIS7012 can have three codecs 
 others up to two codecs 
 request irq after initializaing int_sta_mask, etc 
	 NOTE: we don't use devm version here since it's released 
	  re-acquired in PM callbacks.
	  It's released explicitly in snd_intel8x0_free(), too.
 end 
 look up allowdeny list for SPDIF over ac-link 
		 some Nforce[2] and ICH boards have problems with IRQ handling.
		  Needs to return IRQ_HANDLED for unknown irqs.
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ATI IXP 150200250300 AC97 controllers
 	Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>
 Index 0-MAX 
 ID for this card 
 just for backward compatibility 
 interrupt source 
 interrupt enable 
 (RO 
 (WO) audio is running 
 command 
 slot # 
 RO 
 RO 
 RO 
 RO 
 RO 
 RO 
 RO 
 RO 
 RO 
 RO 
 reorder slots for 6ch 
 3,4,7,8,6,9 -> 3,4,6,9,7,8 
 LINKPTR 
 [INT|OUT|SPDIF]_DMA_DT_SIZE 
 max number of descriptor packets 
  DMA packate descriptor
 DMA buffer address 
 status bits 
 size of the packet in dwords 
 address of the next packet descriptor 
  stream enum
 DMAs 
 AC97 pcm slots 
 pcm devices 
  constants and callbacks for each DMA type
 ATI_DMA_XXX 
 LINKPTR offset 
 DT_CUR offset 
 called from open callback 
 called from trigger (STARTSTOP) 
 called from trigger (STOP only) 
  DMA stream
 assigned PCM substream 
 DMA buffer address, bytes 
 index # of ac97_pcm to access, -1 = not used 
  ATI IXP chip
 max. channels for PCM out 
 for codec detection 
 passed from the module option 
 playback open mutex 
 SB200 
 SB300 
 SB400 
 SB600 
 terminator 
  lowlevel functions
  update the bits of the given register.
  return 1 if the bits changed.
  macros for easy use
  handling DMA packets
  we allocate a linear buffer for the DMA, and split it to  each packet.
  in a future version, a scatter-gather buffer should be implemented.
  build packets ring for the given buffer size.
  IXP handles the buffer descriptors, which are connected as a linked
  list.  although we can change the list dynamically, in this version,
  a static RING of buffer descriptors is used.
  the ring is built in this function, and is set up to the hardware. 
 clear 
 reset DMA before changing the descriptor table 
 fill the entries 
 in dwords 
  remove the ring buffer and release it if assigned
  AC97 interface
 time out may happen during reset 
  reset AC link
 reset powerdoewn 
 perform a software reset 
 do a hard reset 
 deassert RESET and assert SYNC to make sure 
 if (atiixp_read(chip, MODEM_MIRROR) & 0x1)  modem running, too? 
	return -EBUSY;
  auto-detection of codecs
  the IXP chip can generate interrupts for the non-existing codecs.
  NEW_FRAME interrupt is used to make sure that the interrupt is generated
  even if all three codecs are connected.
 this hardware doesn't need workarounds.  Probe for codec 
 wait for the interrupts 
 disable irqs 
  enable DMA and irqs
 set up spdif, enable burst mode 
 clear all interrupt source 
 enable irqs 
  disable DMA and IRQs
 clear interrupt source 
 disable irqs 
  PCM section
  pointer callback simplly reads XXX_DMA_DT_CUR register as the current
  position.  when SG-buffer is implemented, the offset must be calculated
  correctly...
  XRUN detected, and stop the PCM substream
  the period ack.  update the substream.
 set BUS_BUSY interrupt bit if any DMA is running 
 call with spinlock held 
 common trigger callback
  calling the lowlevel callbacks in it
  lowlevel callbacks for each DMA type
  every callback is supposed to be called in chip->reg_lock spinlock
 flush FIFO of analog OUT DMA 
 enabledisable analog OUT DMA 
 startstop transfer over OUT DMA 
 enabledisable analog IN DMA 
 startstop analog IN DMA 
 FIXME: this causes the endless loop 
 wait until slot 34 are finished 
 flush FIFO of analog IN DMA 
 enabledisable SPDIF OUT DMA 
 startstop SPDIF OUT DMA 
 flush FIFO of SPDIF OUT DMA 
 DMA off, transfer on 
 set up slots and formats for SPDIF OUT 
 enable slots 1011 
 set up slots and formats for analog OUT 
 set output threshold 
	
	  enable 6 channel re-ordering bit if needed
 set up slots and formats for analog IN 
  hw_params - allocate the buffer and set up buffer descriptors
		 PCM is bound to AC97 codec(s)
		  set up the AC97 codecs
  pcm hardware definition, identical for all DMA types
 direct SPDIF 
 enable DMA bits 
 disable DMA bits 
 channels must be even 
 share DMA_PLAYBACK 
 AC97 playback 
 AC97 capture 
 SPDIF playback 
 front PCM 
 PCM IN #1 
 SPDIF OUT (optional) 
 initialize constants 
 assign AC97 pcm 
 PCM #0: analog IO 
 no SPDIF support on codec? 
 FIXME: non-48k sample rate doesn't work on my test machine with AD1888 
 PCM #1: spdif playback 
 pre-select AC97 SPDIF slots 1011 
  interrupt handler
 process audio DMA 
 for codec detection 
 disable the detected irqs 
 ack 
  ac97 mixer section
 terminator 
 to be sure 
  power management
 CONFIG_PM_SLEEP 
  proc interface for register dump
  destructor
  constructor for chip instance
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA modem driver for VIA VT82xx (South Bridge)
    VT82C686ABC, VT8233AC, VT8235
 	Copyright (c) 2000 Jaroslav Kysela <perex@perex.cz>
 	                   Tjeerd.Mulder <Tjeerd.Mulder@fujitsu-siemens.com>
                     2002 Takashi Iwai <tiwai@suse.de>
  Changes:
  Sep. 2,  2004  Sasha Khapyorsky <sashak@alsa-project.org>
       Modified from original audio driver 'via82xx.c' to support AC97
       modems.
 Exclude the first card 
 ID for this card 
 just for backward compatibility 
   Direct registers
 common offsets 
 byte - channel status 
 RO 
 RO 
 RO 
 RWC 
 RWC 
 RWC 
 byte - channel control 
 WO 
 WO 
 RW 
 RW - probably reset? undocumented 
 byte - channel type (686 only) 
 RW - autostart at EOL 
 RW 
 RW 
 dword - channel table pointer 
 dword - channel current pointer 
 dword - stop index, channel type, sample rate 
 dword - channel current count (24 bit) 
 byte - channel current index (for via8233 only) 
 modem block 
 AC'97 
 dword 
 dword 
 pci space 
 secondary codec ready 
 low-power state 
 primary codec ready 
 0: disable, 1: enable 
 0: assert, 1: de-assert 
 0: release SYNC, 1: force SYNC hi 
 0: release SDO, 1: force SDO hi 
 0: disable VRA, 1: enable VRA 
 0: disable PCM, 1: enable PCM 
 via686 only 
 via686 only 
 FIXME: it's 0x40 in the datasheet! 
 FIXME: not documented! 
  pcm stream
 playback = 0, capture = 1 
 # descriptors 
 for recovery from the unexpected pointer 
 SGD_SHADOW mask to check interrupts 
 secondary AC'97 codec is present 
  allocate and initialize the descriptor buffers
  periods = number of periods
  fragsize = period size in bytes
		 the start of each lists must be aligned to 8 bytes,
		  but the kernel pages are much bigger, so we don't care
 fill the entries 
		 fill descriptors for a period.
		  a period can be split to several descriptors if it's
		  over page boundary.
 buffer boundary 
 period boundary 
 period continues to the next 
			
			dev_dbg(&pci->dev,
				"tbl %d: at %d  size %d (rest %d)\n",
				idx, ofs, r, rest);
   Basic IO
 1ms 
 1ms 
 here we need to wait fairly for long time.. 
 disable interrupts 
 clear interrupts 
 for via686 
 outl(0, VIADEV_REG(viadev, OFFSET_CURR_PTR));
   Interrupt handler
 _skip_sgd:
 check status for each stream 
 ack 
   PCM callbacks
  trigger callback
  pointer callbacks
  calculate the linear position at the given sg-buffer index and the rest count
 check the validity of the calculated position 
 bogus count 0 on the DMA boundary? 
				 count register returns full size
				  when end of buffer is reached
 remember the last position 
  get the current pointer on via686
	 The via686a does not have the current index register,
	  so we need to calculate the index from CURR_PTR.
 CURR_PTR holds the address + 8 
  hw_params callback:
  allocate the buffer and build up the buffer description table
  hw_free callback:
  clean up the buffer description table and release the buffer
  set up the table pointer
  prepare callback for playback and capture
 this must be set after channel_reset 
  pcm hardware definition, identical for both playback and capture
 SNDRV_PCM_INFO_RESUME | 
  open callback skeleton
	 we may remove following constaint when we modify table entries
  open callback for playback
  open callback for capture
  close callback
 via686 playback callbacks 
 via686 capture callbacks 
  create a pcm instance for via686ab
 FLAGS | EOL for MR, MW 
   Mixer part
  proc interface
 codec not ready? 
 deassert ACLink reset, force SYNC 
 FIXME: should we do full reset here for all chip models? 
 deassert ACLink reset, force SYNC (warm AC'97 reset) 
 ACLink on, deassert ACLink reset, VSR, SGD data out 
 ACLink on, deassert ACLink reset, VSR, SGD data out 
 wait until codec ready 
 primary codec ready 
 This is ok, the most of motherboards have only one codec 
 route FM trap to IRQ, disable FM trap 
 pci_write_config_byte(chip->pci, VIA_FM_NMI_CTRL, 0);
 disable all GPI interrupts 
  power management
 CONFIG_PM_SLEEP 
 disable interrupts 
	 The 8233 ac97 controller does not implement the master bit
	  in the pci command register. IMHO this is a violation of the PCI spec.
 disable interrupts 
 SPDX-License-Identifier: GPL-2.0-or-later
   Matt Wu <Matt_Wu@acersoftech.com.cn>
   Apr 26, 2001
   Routines for control of ALi pci audio M5451
   BUGS:
     --
   TODO:
     --
 Index 
 ID for this card 
 just for backward compatibility 
   Constants definition
   Direct Registers
 ADR0 
 CNT0 
 MOD  
 MMR  
 bit 10 
 bit 11 
 bit 15 
 bit 19 
 bit 31 
 register data 
 register addresses 
 PCM data 
 final ESO value for channel 
 runtime->period_size 
 --- 
 num of opened channels 
 bitmap for opened channels 
 SPDIF Mask 
   AC97 ACCESS
 bit 15
 	AC97 Reset
 non-fatal if you have a non PM capable codec 
 dev_warn(codec->card->dev, "ali5451: reset time out\n"); 
   ALI 5451 Controller
 recording 
 playback... 
     SPDIF Part
 select right 
 select left 
	wVal = inw(ALI_REG(codec, ALI_SPDIF_CS));
	if (flag & ALI_SPDIF_OUT_NON_PCM)
   		wVal |= 0x0002;
	else	
		wVal &= (~0x0002);
   	outw(wVal, ALI_REG(codec, ALI_SPDIF_CS));
 check if interrupt occurred for channel 
 pcm interrupt 
 synth interrupt 
 midi interrupt 
 unknown interrupt 
 get interrupt status for all channels 
 Still Mode 
 Still Mode 
	 set ctrl mode
	   CTRL default: 8-bit (unsigned) mono, loop mode enabled
 16-bit data 
 signed data 
 stereo data 
   PCM part
 voice management 
 set Delta (rate) value 
 set Loop Back Address 
 set interrupt count size 
 set target ESO for channel 
 set ESO to capture first MIDLP interrupt 
 set ctrl mode 
 cso 
 alpha 
 cso 
 alpha 
 Prepare capture intr channel 
 set target ESO for channel  
 set interrupt count size  
 set Loop Back Address  
 set ESO to capture first MIDLP interrupt  
 cso 
 alpha 
   Capture support device description
  Modem PCM
 spdif aplayback switch 
 FIXME: "IEC958 Playback Switch" may conflict with one on ac97_codec 
 spdif out to spdif channel 
 spdif in from spdif channel 
 im->regs[ALI_START >> 2] = inl(ALI_REG(chip, ALI_START)); 
 disable all IRQ bits 
 stop all HW channel 
 start HW channel 
 restore IRQ enable bits 
 CONFIG_PM_SLEEP 
 secondary codec - modem 
 proc for register dump 
 enable PCI device 
 check, if we can restrict PCI DMA transfers to 31 bits 
 M1533: southbridge 
 M7101: power management 
 initialise synth voices
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for RME Hammerfall DSP MADI audio interface(s)
       Copyright (c) 2003 Winfried Ritsch (IEM)
       code based on hdsp.c   Paul Davis
                              Marcus Andersson
                              Thomas Charbonnel
       Modified 2006-06-01 for AES32 support by Remy Bruno
                                                <remy.bruno@trinnov.com>
       Modified 2009-04-13 for proper metering by Florian Faber
                                                <faber@faberman.de>
       Modified 2009-04-14 for native float support by Florian Faber
                                                <faber@faberman.de>
       Modified 2009-04-26 fixed bug in rms metering by Florian Faber
                                                <faber@faberman.de>
       Modified 2009-04-30 added hw serial number support by Florian Faber
       Modified 2011-01-14 added SPDIF input on RayDATs by Adrian Knoth
 	Modified 2011-01-25 variable period sizes on RayDATAIO by Adrian Knoth
       Modified 2019-05-23 fix AIO single speed ADAT capture and playback
       by Philippe.Bekaert@uhasselt.be
     Register Documentation   
  Work in progress! Documentation is based on the code in this file.
  --------- HDSPM_controlRegister ---------
  :7654.3210:7654.3210:7654.3210:7654.3210: bit number per byte
  :||||.||||:||||.||||:||||.||||:||||.||||:
  :3322.2222:2222.1111:1111.1100:0000.0000: bit number
  :1098.7654:3210.9876:5432.1098:7654.3210: 0..31
  :||||.||||:||||.||||:||||.||||:||||.||||:
  :8421.8421:8421.8421:8421.8421:8421.8421: hex digit
  :    .    :    .    :    .    :  x .    :  HDSPM_AudioInterruptEnable \_ setting both bits
  :    .    :    .    :    .    :    .   x:  HDSPM_Start                  enables audio IO
  :    .    :    .    :    .    :   x.    :  HDSPM_ClockModeMaster - 1: Master, 0: Slave
  :    .    :    .    :    .    :    .210 :  HDSPM_LatencyMask - 3 Bit value for latency
  :    .    :    .    :    .    :    .    :      0:64, 1:128, 2:256, 3:512,
  :    .    :    .    :    .    :    .    :      4:1024, 5:2048, 6:4096, 7:8192
  :x   .    :    .    :    .   x:xx  .    :  HDSPM_FrequencyMask
  :    .    :    .    :    .    :10  .    :  HDSPM_Frequency1|HDSPM_Frequency0: 1=32K,2=44.1K,3=48K,0=??
  :    .    :    .    :    .   x:    .    :  <MADI> HDSPM_DoubleSpeed
  :x   .    :    .    :    .    :    .    :  <MADI> HDSPM_QuadSpeed
  :    .  3 :    .  10:  2 .    :    .    :  HDSPM_SyncRefMask :
  :    .    :    .   x:    .    :    .    :  HDSPM_SyncRef0
  :    .    :    .  x :    .    :    .    :  HDSPM_SyncRef1
  :    .    :    .    :  x .    :    .    :  <AES32> HDSPM_SyncRef2
  :    .  x :    .    :    .    :    .    :  <AES32> HDSPM_SyncRef3
  :    .    :    .  10:    .    :    .    :  <MADI> sync ref: 0:WC, 1:Madi, 2:TCO, 3:SyncIn
  :    .  3 :    .  10:  2 .    :    .    :  <AES32>  0:WC, 1:AES1 ... 8:AES8, 9: TCO, 10:SyncIn?
  :    .  x :    .    :    .    :    .    :  <MADIe> HDSPe_FLOAT_FORMAT
  :    .    :    .    : x  .    :    .    :  <MADI> HDSPM_InputSelect0 : 0=optical,1=coax
  :    .    :    .    :x   .    :    .    :  <MADI> HDSPM_InputSelect1
  :    .    :    .x   :    .    :    .    :  <MADI> HDSPM_clr_tms
  :    .    :    .    :    . x  :    .    :  <MADI> HDSPM_TX_64ch
  :    .    :    .    :    . x  :    .    :  <AES32> HDSPM_Emphasis
  :    .    :    .    :    .x   :    .    :  <MADI> HDSPM_AutoInp
  :    .    :    . x  :    .    :    .    :  <MADI> HDSPM_SMUX
  :    .    :    .x   :    .    :    .    :  <MADI> HDSPM_clr_tms
  :    .    :   x.    :    .    :    .    :  <MADI> HDSPM_taxi_reset
  :    .   x:    .    :    .    :    .    :  <MADI> HDSPM_LineOut
  :    .   x:    .    :    .    :    .    :  <AES32> ??????????????????
  :    .    :   x.    :    .    :    .    :  <AES32> HDSPM_WCK48
  :    .    :    .    :    .x   :    .    :  <AES32> HDSPM_Dolby
  :    .    : x  .    :    .    :    .    :  HDSPM_Midi0InterruptEnable
  :    .    :x   .    :    .    :    .    :  HDSPM_Midi1InterruptEnable
  :    .    :  x .    :    .    :    .    :  HDSPM_Midi2InterruptEnable
  :    . x  :    .    :    .    :    .    :  <MADI> HDSPM_Midi3InterruptEnable
  :    . x  :    .    :    .    :    .    :  <AES32> HDSPM_DS_DoubleWire
  :    .x   :    .    :    .    :    .    :  <AES32> HDSPM_QS_DoubleWire
  :   x.    :    .    :    .    :    .    :  <AES32> HDSPM_QS_QuadWire
  :    .    :    .    :    .  x :    .    :  <AES32> HDSPM_Professional
  : x  .    :    .    :    .    :    .    :  HDSPM_wclk_sel
  :    .    :    .    :    .    :    .    :
  :7654.3210:7654.3210:7654.3210:7654.3210: bit number per byte
  :||||.||||:||||.||||:||||.||||:||||.||||:
  :3322.2222:2222.1111:1111.1100:0000.0000: bit number
  :1098.7654:3210.9876:5432.1098:7654.3210: 0..31
  :||||.||||:||||.||||:||||.||||:||||.||||:
  :8421.8421:8421.8421:8421.8421:8421.8421:hex digit
  AIO  RayDAT only
  ------------ HDSPM_WR_SETTINGS ----------
  :3322.2222:2222.1111:1111.1100:0000.0000: bit number per byte
  :1098.7654:3210.9876:5432.1098:7654.3210:
  :||||.||||:||||.||||:||||.||||:||||.||||: bit number
  :7654.3210:7654.3210:7654.3210:7654.3210: 0..31
  :||||.||||:||||.||||:||||.||||:||||.||||:
  :8421.8421:8421.8421:8421.8421:8421.8421: hex digit
  :    .    :    .    :    .    :    .   x: HDSPM_c0Master 1: Master, 0: Slave
  :    .    :    .    :    .    :    .  x : HDSPM_c0_SyncRef0
  :    .    :    .    :    .    :    . x  : HDSPM_c0_SyncRef1
  :    .    :    .    :    .    :    .x   : HDSPM_c0_SyncRef2
  :    .    :    .    :    .    :   x.    : HDSPM_c0_SyncRef3
  :    .    :    .    :    .    :   3.210 : HDSPM_c0_SyncRefMask:
  :    .    :    .    :    .    :    .    :  RayDat: 0:WC, 1:AES, 2:SPDIF, 3..6: ADAT1..4,
  :    .    :    .    :    .    :    .    :          9:TCO, 10:SyncIn
  :    .    :    .    :    .    :    .    :  AIO: 0:WC, 1:AES, 2: SPDIF, 3: ATAT,
  :    .    :    .    :    .    :    .    :          9:TCO, 10:SyncIn
  :    .    :    .    :    .    :    .    :
  :    .    :    .    :    .    :    .    :
  :3322.2222:2222.1111:1111.1100:0000.0000: bit number per byte
  :1098.7654:3210.9876:5432.1098:7654.3210:
  :||||.||||:||||.||||:||||.||||:||||.||||: bit number
  :7654.3210:7654.3210:7654.3210:7654.3210: 0..31
  :||||.||||:||||.||||:||||.||||:||||.||||:
  :8421.8421:8421.8421:8421.8421:8421.8421: hex digit
 Index 0-MAX 
 ID for this card 
 Enable this card 
 --- Write registers. ---
 not in specs ???????? 
 for setting arbitrary clock values (DDS feature) 
 just believe in old code 
 for AES32 
 DMA enable for 64 channels, only Bit 0 is relevant 
 512-767  input  DMA 
 768-1023 output DMA 
 16 page addresses for each of the 64 channels DMA buffer in and out
 32768-65535 for 2x64x64 Fader 
 = 26464  4 Byte => 32kB 
 --- Read registers. ---
#define HDSPM_statusRegister2  96 
 after RME Windows driver sources, status2 is 4-byte word # 48 = word at
  offset 192, for AES32 and MADI
 AIO, RayDAT 
 status is data bytes in MIDI-FIFO (0-128) 
 the meters are regular io-mapped registers, but offset
   considerably from the rest. the peak registers are reset
   when read; the least-significant 4 bits are full-scale counters;
   the actual peak value is in the most-significant 24 bits.
 --- Control Register bits --------- 
 start engine 
 buffer size = 2^n 
 where n is defined 
 by Latency{2,1,0} 
 1=Master, 0=Autosync 
#define HDSPM_c0Master		0x1     Master clock bit in settings
 what do you think ? 
 0=44.1kHz88.2kHz 1=48kHz96kHz 
 0=32kHz64kHz 
 0=normal speed, 1=double speed 
 quad speed bit 
 Professional  
#define HDSPM_TX_64ch     (1<<10)  Output 64channel MODE=1,
 MADI ONLY
 Emphasis  
#define HDSPM_AutoInp     (1<<11)  Auto Input (takeover) == Safe Mode,
 MADI ONLY 
 Dolby = "NonAudio" ??  
#define HDSPM_InputSelect0 (1<<14)  Input select 0= optical, 1=coax
				     -- MADI ONLY
 should be 0 
 Frame ???  
#define HDSPM_clr_tms      (1<<19)  clear track marker, do not use
                                      AES additional bits in
 ???  
 Frame ??? = HDSPM_SMUX  
 Analog Out on channel 6364 on=1, mute=0 
 AES32 ONLY 
 AES32 ONLY 
 AES32 ONLY 
 additional control register bits for AIO
 also RayDAT 
 --- bit helper defines 
 Preferred sync reference 
 choices - used by "pref_sync_ref" 
 Synccheck Status 
 AutoSync References - used by "autosync_ref" control switch 
 Possible sources of MADI input 
 optical   
 BNC 
 --- control2 register bits --- 
#define HDSPM_VERSION_BIT     (1<<8) not defined any more
 --- Status Register bits ---   MADI ONLY   Bits defined here and
     that do not conflict with specific bits for AES32 seem to be valid also
     for the AES32
 IRQ is high and pending 
 Input 64chan. MODE=1, 56chn MODE=0 
#define HDSPM_AB_int             (1<<2)	 InputChannel Opt=0, Coax=1
					  (like inp0)
 MADI Locked =1, no=0 
 MADI is in sync 
 Optional TCO locked status for HDSPe MADI
 Optional TCO sync status for HDSPe MADI and AES32!
 Sync In lock status for HDSPe MADI! 
 Sync In sync status for HDSPe MADI! 
 Bit 6..15 : hw buffer pointer 
 since 64byte accurate, last 6 bits are not used 
 (input) card in double speed 
 system freq 0=error 
 1=32, 2=44.1 3=48 
 4=64, 5=88.2 6=96 
 7=128, 8=176.4 9=192 
#define HDSPM_BufferID          (1<<26)	 (Double)Buffer ID toggles with
					  Interrupt
 Optional TCO locked status for HDSPe AES 
 --- status bit helpers 
 Status2 Register bits  
 not really defined but I guess 
 in former cards it was ??? 
 Wordclock is detected and locked 
 Wordclock is in sync with systemclock 
 input freq detected via autosync  
 001=32, 010==44.1, 011=48, 
 100=64, 101=88.2, 110=96, 111=128 
 1000=176.4, 1001=192 
 Sync Reference 
 AutoSync Source 
 000=word, 001=MADI, 
 111=no valid signal 
   For AES32, bits for status, status2 and timecode are different
 status 
 (status >> HDSPM_AES32_wcFreq_bit) & 0xF gives WC frequency (cf function
 (status >> HDSPM_AES32_syncref_bit) & 0xF gives sync source 
  status2 
 HDSPM_LockAES_bit is given by HDSPM_LockAES >> (AES# - 1) 
   Timecode
   After windows driver sources, bits 4i to 4i+3 give the input frequency on
   AES i+1
 bits 3210
      0001  32kHz
      0010  44.1kHz
      0011  48kHz
      0100  64kHz
      0101  88.2kHz
      0110  96kHz
      0111  128kHz
      1000  176.4kHz
      1001  192kHz
  NB: Timecode register doesn't seem to work on AES32 card revision 230
 Mixer Values 
 = 655362 
 Number of channels for different Speed Modes 
 the size of a substream (1 mono data stream) 
 the size of the area we need to allocate for DMA transfers. the
   size is the same regardless of the number of channels, and
   also the latency to use.
   for one direction !!!
 speed factor modes 
 names for speed modes 
 These tables map the ALSA channels 1..N to the channels that we
   need to use in order to find the relevant channel buffer. RME
   refers to this kind of mapping as between "the ADAT channel and
   the DMA channel." We index it using the logical audio channel,
   and the value is the DMA channel (i.e. channel buffer number)
   where the data for that channel can be readwritten fromto.
 ADAT 1 
 ADAT 2 
 ADAT 3 
 ADAT 4 
 AES 
 SPDIF 
 ADAT 1 
 ADAT 2 
 ADAT 3 
 ADAT 4 
 AES 
 SPDIF 
 ADAT 1 
 ADAT 2 
 ADAT 3 
 ADAT 4 
 AES 
 SPDIF 
 line in 
 aes in, 
 spdif in 
 ADAT in 
 AEB 
 line out 
 aes out 
 spdif out 
 ADAT out 
 phone out 
 AEB 
 line in 
 aes in 
 spdif in 
 adat in 
 AEB 
 line out 
 aes out 
 spdif out 
 adat out 
 phone out 
 AEB 
 line in 
 aes in 
 spdif in 
 adat in 
 AEB 
 line out 
 aes out 
 spdif out 
 adat out 
 phone out 
 AEB 
 timer in use 
 0: LTC, 1:Video, 2: WC
 0=24, 1=25, 2=29.97, 3=29.97d, 4=30, 5=30d 
 0=1:1, 1=44.1->48, 2=48->44.1 
 0=44.1, 1=48, 2= freq from app 
   0=0, 1=+0.1%, 2=-0.1%, 3=+4%, 4=-4%
 0 = off, 1 = on 
 only one playback andor capture stream 
 for procinfo 
 dont know if relevant (yes if AES32)
 set up monitoring outs init flag 
 cached value 
 cached value 
 cached value for AIO  RayDat (sync reference, masterslave) 
 suitably aligned address 
 suitably aligned address 
 process id which uses capture 
 process id which uses capture 
 running status 
 samplerate mystic ... 
 Hardware vars... 
 for debug 
 one card 
 has one pcm 
 and a hwdep for additional ioctl 
 and an pci info 
 Mixer vars 
 fast alsa mixer 
 but input to much, so not used 
 full mixer accessible over mixer ioctl or hwdep-device 
 NULL if no TCO detected 
 prototypes 
 Writeread tofrom HDSPM with Adresses in Bytes
 for each output channel (chan) I have an Input (in) and Playback (pb) Fader
   mixer is write only on hardware so we have to cache him for read
 enable DMA for specific channels, now available for DSP-MADI 
 check if same process is writing and reading 
 round arbitrary sample rates to commonly known rates 
 QS and DS rates normally can not be detected
  automatically by the card. Only exception is MADI
  in 96k frame mode.
  So if we read SS values (32 .. 48k), check for
  user-provided DSQS bits in the control register
  and multiply the base frequency accordingly.
 check for external sample rate, returns the sample rate in Hz
 Check WC sync and get sample rate 
 Check AES sync and get sample rate 
 Check TCO sync and get sample rate 
 end switch(syncref) 
 no lock 
 if wordclock has synced freq and wordclock is valid 
		 if rate detected and Syncref is Word than have it,
		  word has priority to MADI
 maybe a madi input (which is taken if sel sync is madi) 
 endif HDSPM_madiLock 
 check sample rate from TCO or SYNC_IN 
 return latency in samples per period 
	 Special case for new RME cards with 32 samples period size.
	  The three latency bits in the control register
	  (HDSP_LatencyMask) encode latency values of 64 samples as
	  0, 128 samples as 1 ... 4096 samples as 6. For old cards, 7
	  denotes 8192 samples, but on new cards like RayDAT or AIO,
	  it corresponds to 32 samples.
 Latency function 
 Bytes per sample 
 should I silence all or only opened ones ? doit all for first even is 4MB
		 Special case for new RME cards like RayDATAIO which
		  support period sizes of 32 samples. Since latency is
		  encoded in the three bits of HDSP_LatencyMask, we can only
		  have values from 0 .. 7. While 0 still means 64 samples and
		  6 represents 4096 samples on all cards, 7 represents 8192
		  on older cards and 32 samples on new cards.
		 
		  In other words, period size in samples is calculated by
		  2^(n+6) with n ranging from 0 .. 7.
 125 MHz 
 105 MHz 
 100 MHz 
 n should be less than 2^32 for being written to FREQ register 
 dummy set rate lets see what happens 
	 ASSUMPTION: hdspm->lock is either set, or there is no need for
	   it (e.g. during module initialization).
 SLAVE --- 
			 request from ctl or card initialization
			   just make a warning an remember setting
 hw_param request while in AutoSync mode 
	 Changing between Singe, Double and Quad speed is not
	   allowed if any substreams are open. This is because such a change
	   causes a shift in the location of the DMA buffers and a reduction
	   in the number of available buffers.
	   Note that a similar but essentially insoluble problem exists for
	   externally-driven rate changes. All we can do is to flag rate
	   changes in the readwrite routines.
	 For AES32, need to set DDS value in FREQ register
 mainly for init to 0 on load 
----------------------------------------------------------------------------
   MIDI
 the hardware already does the relevant bit-mask with 0xff 
 the hardware already does the relevant bit-mask with 0xff 
 Output is not interrupt driven 
	unsigned char buf[128];  this buffer is designed to match the MIDI
				  input FIFO size
 flush the MIDI input FIFO 
	 this does not bump hmidi->istimer, because the
	   kernel automatically removed the timer when it
	   expired, and we are now adding it back, thus
	   leaving istimer wherever it was set before.
 MIDI-over-MADI on HDSPe MADIface 
 MIDI-over-MADI on HDSPe MADI 
 TCO MTC, read only 
 TCO MTC on HDSPe MADI 
 TCO MTC, read only 
-----------------------------------------------------------------------------
  Status Interface
 get the system sample rate which is set 
  Calculate the real sample rate from the
  current DDS value.
 Unreasonable high sample rate as seen on PCI MADI cards. 
 master mode, return internal sample rate 
 slave mode, return external sample rate 
  Returns the WordClock sample rate class for the given card.
  Returns the TCO sample rate class for the given card.
  Returns the SYNC_IN sample rate class for the given card.
  Returns the AES sample rate class for the given card.
  Returns the sample rate class for input source <idx> for
  'new style' cards like the AIO and RayDAT.
 Helper function to query the external sample rate and return the
  corresponding enum to be returned to userspace.
 WC 
 TCO 
 SYNC_IN 
 WC 
 TCO 
 SYNC_IN 
 External Rate 
 AES1 to AES8 
  Returns the system clock mode for the given card.
  @returns 0 - master, 1 - slave
  Sets the system clock mode.
  @param mode 0 - master, 1 - slave
  Returns the current preferred sync reference setting.
  The semantics of the return value are depending on the
  card, please see the comments for clarification.
 WC 
 AES 1 
 AES 2 
 AES 3 
 AES 4 
 AES 5 
 AES 6 
 AES 7 
 AES 8 
 TCO 
 WC 
 MADI 
 TCO 
 SYNC_IN 
 WC 
 MADI 
 SYNC_IN 
 WC 
 ADAT 1 
 ADAT 2 
 ADAT 3 
 ADAT 4 
 AES 
 SPDIF 
 TCO 
 SYNC_IN 
 WC 
 ADAT 1 
 ADAT 2 
 ADAT 3 
 ADAT 4 
 AES 
 SPDIF 
 SYNC_IN 
 WC 
 ADAT 
 AES 
 SPDIF 
 TCO 
 SYNC_IN 
 WC 
 ADAT 
 AES 
 SPDIF 
 SYNC_IN 
  Set the preferred sync reference to <pref>. The semantics
  of <pref> are depending on the card type, see the comments
  for clarification.
 WC  
 AES 1 
 AES 2 
 AES 3 
 AES 4 
 AES 5 
 AES 6 
 AES 7 
 AES 8 
 TCO 
 WC 
 MADI 
 TCO 
 SYNC_IN 
 WC 
 MADI 
 SYNC_IN 
 WC 
 ADAT 1 
 ADAT 2 
 ADAT 3 
 ADAT 4 
 AES 
 SPDIF 
 TCO 
 SYNC_IN 
 WC 
 ADAT 1 
 ADAT 2 
 ADAT 3 
 ADAT 4 
 AES 
 SPDIF 
 SYNC_IN 
 WC 
 ADAT 
 AES 
 SPDIF 
 TCO 
 SYNC_IN 
 WC 
 ADAT 
 AES 
 SPDIF 
 SYNC_IN 
 This looks at the autosync selected sync reference 
 syncref >= HDSPM_AES32_AUTOSYNC_FROM_WORD is always true 
 ntsc 
 pal 
 no video 
 24 fps 
 25 fps 
 29.97 fps 
 30 fps 
 The simple mixer control(s) provide gain control for the
   basic 1:1 mappings of playback streams to output
   streams.
 Sync 
 Lock 
 No signal 
 NA 
 WC 
 TCO 
 SYNC IN 
 WC 
 TCO 
 SYNC IN 
 WC 
 MADI 
 TCO 
 SYNC_IN 
 MADI 
 WC 
 TCO 
 SYNC IN :
 AES1 to AES8 
 Check TCO for lock state of its current input 
 Check TCO for valid time code on LTC input. 
  TCO controls
 TODO freq from app could be supported here, see tco->samplerate 
		
		   HDSPM_INPUT_SELECT("Input Select", 0),
		   HDSPM_SPDIF_OPTICAL("SPDIF Out Optical", 0),
		   HDSPM_PROFESSIONAL("SPDIF Out Professional", 0);
		   HDSPM_SPDIF_IN("SPDIF In", 0);
		   HDSPM_BREAKOUT_CABLE("Breakout Cable", 0);
		   HDSPM_INPUT_LEVEL("Input Level", 0);
		   HDSPM_OUTPUT_LEVEL("Output Level", 0);
		   HDSPM_PHONES("Phones", 0);
 Control elements for the optional TCO module 
 create simple 1:1 playback mixer controls 
 add tco control elements 
------------------------------------------------------------
   proc interface
 no TCO possible 
 rate = freq_constperiod; 
 call readout function for TCO specific status 
 call readout function for TCO specific status 
 s1 
 freq 
 s2 
 102464 ; i += j) {
 read = snd_hdspm_proc_read_madiface; 
 debug file to read all hdspm registers 
------------------------------------------------------------
   hdspm intitialize
	 ASSUMPTION: hdspm->lock is either held, or there is no need to
	   hold it (e.g. during module initialization).
 set defaults:       
		 Magic values are: LAT_0, LAT_2, Master, freq1, tx64ch, inp_0,
 Master Clock Mode on 
 latency max=8192samples 
 AES1 is syncclock 
 Analog output in 
 Professional mode 
 No control2 register for AES32 
 silence everything 
 set a default rate so that the channel map is set up. 
------------------------------------------------------------
   interrupt
 cycles_t now; 
 now = get_cycles(); 
	
	    LAT_2..LAT_0 period  counter (win)  counter (mac)
	           6       4096   ~256053425     ~514672358
	           5       2048   ~128024983     ~257373821
	           4       1024    ~64023706     ~128718089
	           3        512    ~32005945      ~64385999
	           2        256    ~16003039      ~32260176
	           1        128     ~7998738      ~16194507
	           0         64     ~3998231       ~8191558
	
	  dev_info(hdspm->card->dev, "snd_hdspm_interrupt %llu @ %llx\n",
	   now-hdspm->last_interrupt, status & 0xFFC0);
	   hdspm->last_interrupt = now;
				 we disable interrupts for this input until
				  processing is done
------------------------------------------------------------
   pcm interface
		 The other stream is open, and not by the same
		   task as this one. Make sure that the parameters
		   that matter are the same.
 We're fine. 
 how to make sure that the rate matches an externally-set one ?   
	 Memory allocation, takashi's method, dont know if we should
	  spinlock
 malloc all buffer even if not enabled to get sure 
	 Update for MADI rev 204: we need to allocate for all channels,
 just make sure 
	
	   dev_dbg(hdspm->card->dev,
	   "Allocated sample buffer for %s at 0x%08X\n",
	   substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
	   "playback" : "capture",
	   snd_pcm_sgbuf_get_addr(substream, 0));
	
	   dev_dbg(hdspm->card->dev,
	   "set_hwparams: %s %d Hz, %d channels, bs = %d\n",
	   substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
	   "playback" : "capture",
	   params_rate(params), params_channels(params),
	   params_buffer_size(params));
	  For AES cards, the float format bit is the same as the
	   preferred sync reference. Since we don't want to break
	   sync settings, we have to skip the remaining part of this
	   function.
 Switch to native float format if requested 
 Just disable all channels. The saving when disabling a 
 smaller set is not worth the trouble. 
 RayDAT & AIO have a fixed buffer of 16384 samples per channel 
 we have nothing to initialize but the call is required 
			 dev_err(hdspm->card->dev, "copy_to_user(.., .., %lu): %lu
			 [Levels]\n", sizeof(struct hdspm_peak_rms), s);
			
 TODO: Mac driver sets it when f_s>48kHz 
------------------------------------------------------------
   memory interface
 Inform the card what DMA addresses to use for the indicated channel. 
 Each channel got 16 4K pages allocated for DMA transfers. 
 ------------- ALSA Devices ---------------------------- 
 TCO detection 
 texts 
		 id contains either a user-provided value or the default
		  NULL. If it's the default, we're safe to
		  fill card->id with the serial number.
		 
		  If the serial number is 0xFFFFFF, then we're dealing with
		  an old PCI revision that comes without a sane number. In
		  this case, we don't set card->id to avoid collisions
		  when running with multiple cards.
 stop th audio, and cancel all interrupts 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for RME Digi9652 audio interfaces 
 	Copyright (c) 1999 IEM - Winfried Ritsch
       Copyright (c) 1999-2001  Paul Davis
 Index 0-MAX 
 ID for this card 
 Enable this card 
 Enable precise pointer 
 The Hammerfall has two sets of 24 ADAT + 2 SPDIF channels, one for
   capture, one for playback. Both the ADAT and SPDIF channels appear
   to the host CPU in the same block of memory. There is no functional
   difference between them in terms of access.
   The Hammerfall Light is identical to the Hammerfall, except that it
   has 2 sets 18 channels (16 ADAT + 2 SPDIF) for capture and playback.
 Preferred sync source choices - used by "sync_pref" control switch 
 Possible sources of SPDIF input 
 optical (ADAT1) 
 coaxial (RCA) 
 internal (CDROM) 
 ------------- Status-Register bits --------------------- 
 IRQ is High if not reset by irq_clear 
 ADAT 3-PLL: 1=locked, 0=unlocked 
 ADAT 2-PLL: 1=locked, 0=unlocked 
 ADAT 1-PLL: 1=locked, 0=unlocked 
 sample rate is 0=44.188.2,1=4896 Khz 
 if Word-Clock is used and valid then 1 
 bits 6-15 encode hw buffer pointer position 
 if ADAT-IN 3 in sync to system clock 
 if ADAT-IN 2 in sync to system clock 
 if ADAT-IN 1 in sync to system clock 
 1=Double Speed Mode, 0=Normal Speed 
 1=time-code copy in progress (960ms) 
 time-code out bit 
 000=64kHz, 100=88.2kHz, 011=96kHz  
 111=32kHz, 110=44.1kHz, 101=48kHz, 
 external Crystal Chip if ERF=1 
 Error-Flag of SDPIF Receiver (1=No Lock) 
 toggles by each interrupt on recplay 
 1 = a signal is detected on time-code input 
 byte available from Rev 1.5+ SPDIF interface 
 Bit 6..15 : hw buffer pointer 
 Bits 31,30,29 are bits 5,4,3 of hw pointer position on later
   Rev G EEPROMS and Rev 1.5 cards or later.
 amount of io space we remap for register access. i'm not sure we
   even need this much, but 1K is nice round number :)
 holds ptr to 26x64kBit host RAM 
 holds ptr to 26x64kBit host RAM 
 useful if used with alesis adat 
 132...228 Thru for 26 channels 
 Read-only registers 
 Writing to any of the register locations writes to the status
   register. We'll use the first location as our point of access.
 --------- Control-Register Bits ---------------- 
 start recordplay 
 bits 1-3 encode buffersizelatency 
 Clock Mode Master=1,SlaveAuto=0 
 Interrupt Enable 
 samplerate 0=44.188.2, 1=4896 kHz 
 if 0, 32kHz, else always 1 
 Doule Speed 0=44.148, 1=88.296 Khz 
 SPDIF out: 0=consumer, 1=professional 
  Emphasis 0=None, 1=ON 
  Non-audio bit 1=set, 0=unset 
 Use 1st optical OUT as SPDIF: 1=yes,0=no 
 use Wordclock as sync (overwrites master) 
 SPDIF-IN: 00=optical (ADAT1),     
 01=koaxial (Cinch), 10=Internal CDROM 
 Rev 1.5+: hw SPDIF receiver 
 Rev 1.5+: if set, internal CD connector carries ADAT 
 buffersize = 512Bytes  2^n, where n is made from Bit2 ... Bit0 
 the size of a substream (1 mono data stream) 
 the size of the area we need to allocate for DMA transfers. the
   size is the same regardless of the number of channels - the 
   9636 still uses the same memory area.
   Note that we allocate 1 more channel than is apparently needed
   because the hw seems to write 1 byte beyond the end of the last
   page. Sigh.
 cached value 
 thru 1=on, 0=off channel 1=Bit1... channel 26= Bit26 
 hammerfall or hammerfall light names 
 &-with status register to get real hw_offset 
 previous hw offset 
	size_t max_jitter;		 maximum jitter in frames for 
 guess what this is 
 different for hammerfallhammerfall-light 
	 DMA buffers; those are copied instances from the original snd_dma_buf
	  objects (which are managed via devres) for the address alignments
 suitably aligned address 
 suitably aligned address 
 non-zero if doing pass-thru 
 hw rev  10 (i.e. 1.5 has hw_rev = 15) 
 so that we can catch externally ... 
 ... induced rate changes            
 These tables map the ALSA channels 1..N to the channels that we
   need to use in order to find the relevant channel buffer. RME
   refer to this kind of mapping as between "the ADAT channel and
   the DMA channel." We index it using the logical audio channel,
   and the value is the DMA channel (i.e. channel buffer number)
   where the data for that channel can be readwritten fromto.
 channels 16 and 17 are SPDIF 
 channels 18-25 don't exist 
 ADAT channels are remapped 
 channels 12 and 13 are SPDIF 
 others don't exist 
 ADAT channels are remapped 
 channels 8 and 9 are SPDIF 
 others don't exist 
 RME Digi9652 
	 The hardware may give a backward movement for up to 80 frames
           Martin Kirst <martin.kirst@freenet.de> knows the details.
	 reset the FIFO pointer to zero. We do this by writing to 8
	   registers, each of which is a 32bit wide register, and set
	   them all to zero. Note that s->iobase is a pointer to
	   int32, not pointer to char.  
	 Changing from a "single speed" to a "double speed" rate is
	   not allowed if any substreams are open. This is because
	   such a change causes a shift in the location of 
	   the DMA buffers and a reduction in the number of available
	   buffers. 
	   Note that a similar but essentially insoluble problem
	   exists for externally-driven rate changes. All we can do
	   is to flag rate changes in the readwrite routines.
 set thru for all channels 
		 we don't want interrupts, so do a
		   custom version of rme9652_start().
 XXX what unsets this ? 
 error condition 
-----------------------------------------------------------------------------
  Control Interface
 XXX do we actually need to stop the card when we do this ? 
 Not reachable 
 Read-only switches 
 FIXME: this routine needs a port to the new control API --jk 
 timecode request 
 XXX bug alert: loop-based timing !!!! 
 ALSA_HAS_STANDARD_WAY_OF_RETURNING_TIMECODE 
 IEC958 (SPDIF) Stream 
------------------------------------------------------------
   proc interface 
 Sync Check 
 thru modes 
 copy to the own data for alignment 
 Align to bus-space 64K boundary 
 Tell the card where it is 
	 ASSUMPTION: rme9652->lock is either held, or
	   there is no need to hold it (e.g. during module
	   initialization).
	 set defaults:
	   SPDIF Input via Coax 
	   autosync clock mode
	   maximum latency (7 = 8192 samples, 64Kbyte buffer,
	   which implies 2 4096 sample, 32Kbyte periods).
	   
	   if rev 1.5, initialize the SPDIF receiver.
 default: thru off for all channels 
 set a default rate so that the channel map is set up 
		 The other stream is open, and not by the same
		   task as this one. Make sure that the parameters
		   that matter are the same.
 We're fine. 
	 how to make sure that the rate matches an externally-set one ?
 who knows? 
	 Determine the hw rev level of the card. This seems like
	   a particularly kludgy way to encode it, but its what RME
	   chose to do, so we follow them ...
	 Differentiate between the standard Hammerfall, and the
	   "Light", which does not have the expansion board. This
	   method comes from information received from Mathhias
	   Clausen at RME. Display the EEPROM and hw revID where
	   relevant.  
 original eprom 
 W36_G EPROM 
 W52_G EPROM 
 original eprom 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for RME Hammerfall DSP audio interface(s)
       Copyright (c) 2002  Paul Davis
                           Marcus Andersson
                           Thomas Charbonnel
 Index 0-MAX 
 ID for this card 
 Enable this card 
 This does not include possible Analog Extension Boards
   AEBs are detected at card initialization
 Write registers. These are defined as byte-offsets from the iobase value.
 Read registers. These are defined as byte-offsets from the iobase value
 the meters are regular io-mapped registers, but offset
   considerably from the rest. the peak registers are reset
   when read; the least-significant 4 bits are full-scale counters;
   the actual peak value is in the most-significant 24 bits.
 26  32 bit values 
 26  32 bit values 
 (26+2)  32 bit values 
 26  64 bit values 
 26  64 bit values 
 This is for H9652 cards
   Peak values are read downward from the base
   Rms values are read upward
   There are rms values for the outputs too
   263 values are read in ss mode
   143 in ds mode, with no gap between values
 c.f. the hdsp_9632_meters_t struct 
 control2 register bits 
 dummy, purpose of 0x100 unknown 
 Control Register bits 
 start engine 
 buffer size = 2^n where n is defined by Latency{2,1,0} 
 [ see above ] 
 [ see above ] 
 1=Master, 0=SlaveAutosync 
 what do you think ? 
 0=44.1kHz88.2kHz176.4kHz 1=48kHz96kHz192kHz 
 0=32kHz64kHz128kHz 
 0=normal speed, 1=double speed 
 0=consumer, 1=professional 
 0=none, 1=on 
 0=off, 1=on 
 1=use 1st ADAT connector for SPDIF, 0=do not 
 For H9632 cards 
 For H9632 cards 
 From here : H9632 specific 
 RPM uses some of the registers for special purposes 
 Dolby 
 .. 
 inp_0 
 Dolby+PRO 
 PRO 
 SyncRef1 
 .. 
 SyncRef2 
 SyncRef1+SyncRef0 
 SyncRef0 
 Sample Clock Sources 
 Preferred sync reference choices - used by "pref_sync_ref" control switch 
 SyncCheck status 
 AutoSync references - used by "autosync_ref" control switch 
 Possible sources of SPDIF input 
 optical  (ADAT1) 
 coaxial (RCA) 
 internal (CDROM) 
 xlr for H9632 (AES)
 For H9632 cards 
 RME says n = 104857600000000, but in the windows MADI driver, I see:
	return 104857600000000  rate;  100 MHz
	return 110100480000000  rate;  105 MHz
  =  2^20  10^8 
 Status Register bits 
 this is for Digiface and H9652 
 this is for H9632 only 
 Bit 6..15 : hw buffer pointer 
 H9632 specific Analog Extension Boards 
 0 = present, 1 = absent 
 This is for H9632 cards 
 Status2 Register bits 
 FIXME : more values for 9632 cards ? 
 Card state flags 
 FIFO wait times, defined in terms of 110ths of msecs 
 the size of a substream (1 mono data stream) 
 the size of the area we need to allocate for DMA transfers. the
   size is the same regardless of the number of channels - the
   Multiface still uses the same memory area.
   Note that we allocate 1 more channel than is apparently needed
   because the hw seems to write 1 byte beyond the end of the last
   page. Sigh.
 timer in use 
 cached value 
 cached value 
 digifacemultifacerpm 
 ditto, but for code use 
 stores state bits 
 guess what this is 
 quad speed mode for H9632 
 different for multifacedigiface 
 output loopback channel states
	 DMA buffers; those are copied instances from the original snd_dma_buf
	  objects (which are managed via devres) for the address alignments
 suitably aligned address 
 suitably aligned address 
 last value written to freq register 
 These tables map the ALSA channels 1..N to the channels that we
   need to use in order to find the relevant channel buffer. RME
   refer to this kind of mapping as between "the ADAT channel and
   the DMA channel." We index it using the logical audio channel,
   and the value is the DMA channel (i.e. channel buffer number)
   where the data for that channel can be readwritten fromto.
 Multiface 
 Analog 
 ADAT 2 
 SPDIF 
 ADAT channels are remapped 
 channels 12 and 13 are SPDIF 
 others don't exist 
 ADAT channels 
 SPDIF 
 Analog 
 AO4S-192 and AI4S-192 extension boards 
 others don't exist 
 ADAT 
 SPDIF 
 Analog 
 AO4S-192 and AI4S-192 extension boards 
 others don't exist 
 ADAT is disabled in this mode 
 SPDIF 
 Analog 
 AO4S-192 and AI4S-192 extension boards 
 others don't exist 
 RME Hammerfall-DSP 
 prototypes 
 firmware was already loaded, get iobox type 
 try to load firmware 
	 the fifoStatus registers reports on how many words
	   are available in the command FIFO.
		 not very friendly, but we only do this during a firmware
		   load and changing the mixer, so we just put up with it.
		 from martin bjornsen:
		   "You can only write dwords to the
		   mixer memory which contain two
		   mixer values in the low and high
		   word. So if you want to change
		   value 0 you have to read value 1
		   from the cache and write both to
		   the first dword in the mixer
		   memory."
		 `addr' addresses a 16-bit wide address, but
		   the address space accessed via hdsp_write
		   uses byte offsets. put another way, addr
		   varies from 0 to 1351, but to access the
		   corresponding memory location, we need
		   to access 0 to 2703 ...
 For the 9632, the mask is different 
	 For the 9632 card, there seems to be no bit for indicating external
	  sample rate greater than 96kHz. The card reports the corresponding
	  single speed. So the best means seems to get spdif rate when
		 HDSP_resetPointer = HDSP_freqReg, which is strange and
		  requires (?) to write again DDS value after a reset pointer
 n should be less than 2^32 for being written to FREQ register 
	 HDSP_freqReg and HDSP_resetPointer are the same, so keep the DDS
	 ASSUMPTION: hdsp->lock is either held, or
	   there is no need for it (e.g. during module
	   initialization).
 request from ctl or card initialization 
 hw_param request while in AutoSync mode 
	 Changing from a "single speed" to a "double speed" rate is
	   not allowed if any substreams are open. This is because
	   such a change causes a shift in the location of
	   the DMA buffers and a reduction in the number of available
	   buffers.
	   Note that a similar but essentially insoluble problem
	   exists for externally-driven rate changes. All we can do
 For HDSP9632 rev 152, need to set DDS value in FREQ register 
 should never happen 
----------------------------------------------------------------------------
   MIDI
 the hardware already does the relevant bit-mask with 0xff 
 the hardware already does the relevant bit-mask with 0xff 
 Output is not interrupt driven 
 this buffer is designed to match the MIDI input FIFO size 
 flush the MIDI input FIFO 
	 this does not bump hmidi->istimer, because the
	   kernel automatically removed the timer when it
	   expired, and we are now adding it back, thus
	   leaving istimer wherever it was set before.
-----------------------------------------------------------------------------
  Control Interface
	 Notice that this looks at the requested sync source,
	   not the one actually in use.
 clear SyncRef bits 
 This looks at the autosync selected sync reference 
	
	  dds_value = n  rate
	  rate = n  dds_value
 'Sample Clock Source' complies with the alsa control naming scheme 
 'External Rate' complies with the alsa control naming scheme 
 RPM Bypass switch 
 RPM Disconnect switch 
 RPM Bypass, Disconnect and Input switches 
 IEC958 (SPDIF) Stream 
 ADAT SyncCheck status 
 DA, AD and Phone gain and XLR breakout cable controls for H9632 cards 
 Output loopback controls for H9632 cards 
 AEB control for H96xx card 
------------------------------------------------------------
   proc interface
 Sync Check 
 relax 
 Informations about H9632 specific controls 
 copy to the own data for alignment 
 Align to bus-space 64K boundary 
 Tell the card where it is 
	 ASSUMPTION: hdsp->lock is either held, or
	   there is no need to hold it (e.g. during module
	   initialization).
	 set defaults:
	   SPDIF Input via Coax
	   Master clock mode
	   maximum latency (7 => 2^7 = 8192 samples, 64Kbyte buffer,
	                    which implies 2 4096 sample, 32Kbyte periods).
           Enable line out.
 silence everything 
 H9632 specific defaults 
	 set a default rate so that the channel map is set up.
 we disable interrupts for this input until processing is done 
 we disable interrupts for this input until processing is done 
		 The other stream is open, and not by the same
		   task as this one. Make sure that the parameters
		   that matter are the same.
 We're fine. 
	 how to make sure that the rate matches an externally-set one ?
 no auto-loading in trigger 
 helper functions for copying meter values 
 SNDRV_HDSP_IOCTL_GET_VERSION must have been called 
 HDSP_AEBx bits are low when AEB are connected 
		 Disable loopback of output channels, as the set function
		  only sets on a change we fake all bits (channels) as enabled.
 should never get here 
 load firmware via hotplug fw loader 
 caution: max length of firmware filename is 30! 
	 From Martin Bjoernsen :
	    "It is important that the card's latency timer register in
	    the PCI configuration space is set to a value much larger
	    than 0 by the computer's BIOS or the driver.
	    The windows driver always sets this 8 bit register [...]
	    to its maximum 255 to avoid problems with some computers."
		 we wait a maximum of 10 seconds to let freshly
				 we don't fail as this can happen
				   if userspace is not ready for
				   firmware upload
 init is complete, we return 
 we defer initialization 
 stop the audio, and cancel all interrupts 
 SPDX-License-Identifier: GPL-2.0-or-later
   Support for Digigram Lola PCI-e boards
   Copyright (c) 2011 Takashi Iwai <tiwai@suse.de>
 direct codec access for debugging 
  dump some registers
 SPDX-License-Identifier: GPL-2.0-or-later
   Support for Digigram Lola PCI-e boards
   Copyright (c) 2011 Takashi Iwai <tiwai@suse.de>
 Standard options 
 Lola-specific options 
 for instance use always max granularity which is compatible
  with all sample rates
 below a sample_rate of 16kHz the analogue audio quality is NOT excellent 
  pseudo-codec readwrite via CORBRIRB
 retrieve RIRB entry - called from interrupt handler 
 an RIRB entry is 8-bytes 
 aynchronous write of a codec verb with data 
 write a codec verb with data and read the returned status 
 flush all pending codec writes 
  interrupt handler
 clear Input Interrupts 
 error 
 notify 
 clear 
 clear Output Interrupts 
 error 
 notify 
 ring status is byte access 
 clear global fifo error interrupt 
  controller
 to be sure 
 enalbe all IO streams 
 enable global irqs 
 disable ringbuffer DMAs 
 CORB set up 
 set the corb size to 256 entries 
 set the corb write pointer to 0 
 reset the corb hw read pointer 
 enable corb dma 
 clear flags if set 
 RIRB set up 
 set the rirb size to 256 entries 
 reset the rirb hw write pointer 
 set N=1, get RIRB response interrupt for new entry 
 enable rirb dma and response irq 
 clear flags if set 
 disable ringbuffer DMAs 
 update the granularity 
 update the sample clock 
 enable unsolicited events of the clock widget 
 update the analog gains 
 input, update 
 update SRC configuration if applicable 
 update the analog outputs 
 output, update 
 enable unsolicited events of the clock widget 
	 if last ResetController was not a ColdReset, we don't know
	  the state of the card; initialize here again
 set the granularity if it is not the default 
 Test LOLA_BAR1_DEVER 
 PCI IDs 
 pci_driver definition 
 SPDX-License-Identifier: GPL-2.0-or-later
   Support for Digigram Lola PCI-e boards
   Copyright (c) 2011 Takashi Iwai <tiwai@suse.de>
 test TYPE and bits 0..11 
 Type = 4, Digital = 1 
 Dig=0, InAmpovrd 
 Dig=0, OutAmpovrd 
	 analog parameters only following, so continue in case of Digital pin
 zero as mute state 
 10 bits 
 test SubType and Type 
 reserve memory to copy mixer data for sleep mode transitions 
 mixer matrix sources are physical input data and play streams 
 mixer matrix destinations are record streams and physical output 
	 mixer matrix may have unused areas between PhysIn and
	  Play or Record and PhysOut zones
	 example : MixerMatrix of LoLa881 (LoLa16161 uses unused zones)
	  +-+  0-------8------16-------8------16
	  | |  |       |       |       |       |
	  |s|  | INPUT |       | INPUT |       |
	  | |->|  ->   |unused |  ->   |unused |
	  |r|  |CAPTURE|       | OUTPUT|       |
	  | |  |  MIX  |       |  MIX  |       |
	  |c|  8--------------------------------
	  | |  |       |       |       |       |
	  | |  |       |       |       |       |
	  |g|  |unused |unused |unused |unused |
	  | |  |       |       |       |       |
	  |a|  |       |       |       |       |
	  | |  16-------------------------------
	  |i|  |       |       |       |       |
	  | |  | PLAYBK|       | PLAYBK|       |
	  |n|->|  ->   |unused |  ->   |unused |
	  | |  |CAPTURE|       | OUTPUT|       |
	  | |  |  MIX  |       |  MIX  |       |
	  |a|  8--------------------------------
	  |r|  |       |       |       |       |
	  |r|  |       |       |       |       |
	  |a|  |unused |unused |unused |unused |
	  |y|  |       |       |       |       |
	  | |  |       |       |       |       |
	  +++  16--|---------------|------------
	       +---V---------------V-----------+
	       |  dest_mix_gain_enable array   |
	       +-------------------------------+
	 example : MixerMatrix of LoLa280
	  +-+  0-------8-2
	  | |  |       | |
	  |s|  | INPUT | |     INPUT
	  |r|->|  ->   | |      ->
	  |c|  |CAPTURE| | <-  OUTPUT
	  | |  |  MIX  | |      MIX
	  |g|  8----------
	  |a|  |       | |
	  |i|  | PLAYBK| |     PLAYBACK
	  |n|->|  ->   | |      ->
	  | |  |CAPTURE| | <-  OUTPUT
	  |a|  |  MIX  | |      MIX
	  |r|  8---|----|-
	  |r|  +---V----V-------------------+
	  |a|  | dest_mix_gain_enable array |
	  |y|  +----------------------------+
 test if values unchanged 
 inform micro-controller about the new source gain 
 not used 
 update for all srcs at once 
 update manually 
 not used 
 not used 
 update for all dests at once 
 not used 
 set volume and do not save the value 
 mute analog output 
 store contents of mixer array 
 output mute 
lola_reset_setups(chip);
 restore contents of mixer array 
		 inform micro-controller about all restored values
		  and ignore return values
 SRC can be activated and the dwInputSRCMask is valid? 
 handle all even Inputs - SRC is a stereo setting !!! 
 handle the stereo case 
 if one IO needs SRC, both stereo IO will get SRC 
 nothing to change for this IO 
 all sample rate converters on 
 clear all mixer matrix settings 
 inform firmware about all updated matrix columns - capture part 
 inform firmware about all updated matrix columns - output part 
 set all digital input source (master) gains to 0dB 
 0dB 
 set all digital playback source (master) gains to 0dB 
 0dB 
 set gain value 0dB diagonally in matrix - part INPUT -> CAPTURE 
	 set gain value 0dB diagonally in matrix , part PLAYBACK -> OUTPUT
	  (LoLa280 : playback channel 0,2,4,6 linked to output channel 0)
	  (LoLa280 : playback channel 1,3,5,7 linked to output channel 1)
  analog mixer control element
 no analog volumes on digital only adapters 
  Hardware sample rate converter on digital input
  Lola16161 or Lola881 can have Hardware sample rate converters
  on its digital input pins
  src gain mixer
 raw value: 0 = -84dB, 336 = 0dB, 408=18dB, incremented 1 for mute 
 not used 
  destination gain (matrix-like) mixer
 not used 
 FIXME: buggy mixer matrix handling 
 FIXME 
 SPDX-License-Identifier: GPL-2.0-or-later
   Support for Digigram Lola PCI-e boards
   Copyright (c) 2011 Takashi Iwai <tiwai@suse.de>
 base frequency 
 error 
 multiplier  devisor 
 error 
 ajustement 
 error 
  Granualrity
 change Gran only if there are no streams allocated ! 
 audio function group 
 this can be a very slow function !!! 
  Clock widget handling
 test SubType and Type 
 video clock has a format (0:NTSC, 1:PAL)
 keep the index used with the board 
 enable unsolicited events of the clock widget 
	 the current EXTERNAL clock information gets updated by interrupt
	  with an unsolicited response
 only for current = external clocks 
 current clock is allowed 
 internal clocks allowed 
 update new settings 
 search for new dwClockIndex 
 SPDX-License-Identifier: GPL-2.0-or-later
   Support for Digigram Lola PCI-e boards
   Copyright (c) 2011 Takashi Iwai <tiwai@suse.de>
 clear any pending interrupt status 
 sync for FIFO readyempty for all linked streams;
  clear paused flag when FIFO gets ready again
 finish pause - prepare for a new resume 
 sample rate is locked 
 period size = multiple of chip->granularity (8, 16 or 32 frames)
 release sample rate 
  set up a BDL entry
 program the address field of the BDL entry 
 program the size field of the BDL entry 
		 program the IOC to enable interrupt
		  only when the whole fragment is processed
  set up BDL entries
 program the initial BDL entries 
	 set format info for all channels
	  (with only one command for the first channel)
 update stream - channel config 
  set up the SD for streaming
 set up BDL 
 program the stream LVI (last valid index) of the BDL 
 sample rate gets locked 
	
	  sample correct synchronization is only needed starting several
	  streams. On stop or if only one stream do as quick as possible
 buffer pre-allocation 
 test TYPE and bits 0..11 (no test bit9 : Digital = 01) 
		 test TYPE and bits 0..11 (no test bit9 : Digital = 01)
		  (bug : ignore bit8: Conn list = 01)
 test bit9:DIGITAL and bit12:SRC_PRESENT
 SPDX-License-Identifier: GPL-2.0-only
    AudioScience HPI driver
    Copyright (C) 1997-2014  AudioScience Inc. <support@audioscience.com>
 Hardware Programming Interface (HPI) Utility functions.
 (C) Copyright AudioScience Inc. 2007
 The actual message size for each object type 
 The actual response size for each object type 
 Flag to enable alternate message type for SSX2 bypass. 
 \internal
   initialize the HPI message structure
 Expect actual adapter index to be set by caller 
 \internal
   initialize the HPI response structure
	 default error return if the response is
 Expect adapter index to be set by caller 
 SPDX-License-Identifier: GPL-2.0-only
   Asihpi soundcard
   Copyright (c) by AudioScience Inc <support@audioscience.com>
   The following is not a condition of use, merely a request:
   If you modify this program, particularly if you fix errors, AudioScience Inc
   would appreciate it if you grant us the right to use those modifications
   for any purpose including commercial applications.
  snd_printddd - very verbose debug printk
  @format: format string
  Works like snd_printk() for debugging purposes.
  Ignored when CONFIG_SND_DEBUG_VERBOSE is not set.
  Must set snd module debug parameter to 3 to enable at runtime.
 index 0-MAX 
 ID for this card 
 identify driver 
 set to 1 to dump every control from adapter to log 
 defaults 
 Per card data 
	 In low latency mode there is only one stream, a pointer to its
	  private data is stored here on trigger and cleared on stop.
	  The interrupt handler uses it as a parameter when calling
	  snd_card_asihpi_timer_function().
 Per stream data 
 Host RW pos 
 DMA RW offset in buffer 
 DMA RW offset in buffer 
 universal stream verbs work with out or in stream handles 
 Functions to allow driver to give a buffer to HPI for busmastering 
 handle to outstream. 
 size in bytes of bus mastering buffer 
 GENERAL PCM 
 INVALID 
 HPI_FORMAT_PCM8_UNSIGNED        1 
 HPI_FORMAT_PCM16_SIGNED         2 
 HPI_FORMAT_MPEG_L1              3 
 HPI_FORMAT_MPEG_L2              4 
 HPI_FORMAT_MPEG_L3              5 
 HPI_FORMAT_DOLBY_AC2            6 
 HPI_FORMAT_DOLBY_AC3            7 
 HPI_FORMAT_PCM16_BIGENDIAN      8 
 HPI_FORMAT_AA_TAGIT1_HITS       9 
 HPI_FORMAT_AA_TAGIT1_INSERTS   10 
 HPI_FORMAT_PCM32_SIGNED        11 
 HPI_FORMAT_RAW_BITSTREAM       12 
 HPI_FORMAT_AA_TAGIT1_HITS_EX1  13 
 HPI_FORMAT_PCM32_FLOAT         14 
	 ALSA can't handle 3 byte sample size together with power-of-2
	   constraint on buffer_bytes, so disable this format
 SNDRV_PCM_FORMAT_S24_3LE  
		 on cards without SRC,
 some other rate 
 don't let it be zero! 
 don't link Cap and Play 
				 How do I know how much valid data is present
				 in buffer? Must be at least one period!
				 Guessing 2 periods, but if
				 buffer is bigger it may contain even more
				 data??
 start the master stream 
 don't link Cap and Play 
			? workaround linked streams don't
 _prepare and _hwparams reset the stream 
algorithm outline
 Without linking degenerates to getting single stream pos etc
 Without mmap 2nd loop degenerates to snd_pcm_period_elapsed
pcm_buf_dma_ofs=get_buf_pos(s);
for_each_linked_stream(s) {
	pcm_buf_dma_ofs=get_buf_pos(s);
	min_buf_pos = modulo_min(min_buf_pos, pcm_buf_dma_ofs, buffer_bytes)
	new_data = min(new_data, calc_new_data(pcm_buf_dma_ofs,irq_pos)
}
timer.expires = jiffies + predict_next_period_ready(min_buf_pos);
for_each_linked_stream(s) {
	s->pcm_buf_dma_ofs = min_buf_pos;
	if (new_data > period_bytes) {
		if (mmap) {
			irq_pos = (irq_pos + period_bytes) % buffer_bytes;
			if (playback) {
				write(period_bytes);
			} else {
				read(period_bytes);
			}
		}
		snd_pcm_period_elapsed(s);
	}
}
 Minimum of 2 modulo values.  Works correctly when the difference between
 the values is less than half the modulus
 Timer function, equivalent to interrupt service routine for cards
 find minimum newdata and buffer pos in group 
 don't link Cap and Play 
 number of bytes in on-card buffer 
 can't statically init min when wrap is involved 
 a multiple of period_bytes 
	 come back when on_card_bytes has decreased enough to allow
	   write to happen, or when data has been consumed to make another
	   period
 don't link Cap and Play 
 Store dma offset for use by pointer callback 
 Limit use of on card fifo for playback 
 buffer wrap is handled at lower level 
 ? host_rw_ofs always ahead of elapsed_dma_ofs by preload size? 
 PLAYBACK OPS 
	 on cards without SRC, must query at valid rate,
	 maybe set by external sync
	? also check ASI5000 samplerate source
	    If external, only support external rate.
	    If internal and other stream playing, can't switch
 snd_card_asihpi_playback.fifo_size = 0; 
 struct is copied, so can create initializer dynamically 
 CAPTURE OPS 
	 NOTE Unlike playback can't use actual samples_played
		for the capture position, because those samples aren't yet in
		the local buffer available for reading.
	 on cards without SRC, must query at valid rate,
 snd_card_asihpi_capture.fifo_size = 0; 
 pointer to ops struct is stored, dont change ops afterwards! 
	? do we want to emulate MMAP for non-BBM cards?
 MIXER CONTROLS 
 copied to snd_ctl_elem_id.name[44]; 
 Number of strings must match the enumerations for HPI_TUNER_BAND in hpi.h 
 Number of strings must match the enumerations for HPI_SOURCENODES in hpi.h 
 Number of strings must match the enumerations for HPI_DESTNODES in hpi.h 
 Convert HPI control name and location into ALSA control name 
 clock is neither capture nor playback 
 On or towards a PCM capture destination
 On a source node that is not PCM playback 
 Between an input and an output 
 PCM Playback source, or  output node 
	 printk(KERN_INFO "Adding %s %d to %d ",  hpi_ctl->name,
------------------------------------------------------------
   Volume controls
 native gains are in millibels 
	  change = asihpi->mixer_volume[addr][0] != left ||
	   asihpi->mixer_volume[addr][1] != right;
	 HPI currently only supports all or none muting of multichannel volume
	ALSA Switch element has opposite sense to HPI mute: on==unmuted, off=muted
------------------------------------------------------------
   Level controls
	  change = asihpi->mixer_level[addr][0] != left ||
	   asihpi->mixer_level[addr][1] != right;
 can't use 'volume' cos some nodes have volume as well 
------------------------------------------------------------
   AESEBU controls
 AESEBU format 
 default to NA 
 return success but set the control to NA 
 default to SPDIF 
------------------------------------------------------------
   Tuner controls
 Gain 
	
	struct snd_card_asihpi asihpi = snd_kcontrol_chip(kcontrol);
	
	struct snd_card_asihpi asihpi = snd_kcontrol_chip(kcontrol);
 Band  
	
	struct snd_card_asihpi asihpi = snd_kcontrol_chip(kcontrol);
	
	struct snd_card_asihpi asihpi = snd_kcontrol_chip(kcontrol);
 Freq 
 skip band with bogus stepping 
 Tuner control group initializer  
------------------------------------------------------------
   Meter controls
 linear values for 10dB steps 
 0dB 
 -60dB 
 -80 
 -100 
			 -ve is log value in millibels < -60dB,
			 convert to (roughly!) linear,
------------------------------------------------------------
   Multiplexer controls
 Should cache this search result! 
------------------------------------------------------------
   Channel mode controls
	 HPI channel mode values can be from 1 to 6
	Some adapters only support a contiguous subset
------------------------------------------------------------
   Sampleclock source  controls
 Number of strings must match expected enumerated values 
------------------------------------------------------------
   Clkrate controls
 Need to change this to enumerated control with list of rates 
	  change = asihpi->mixer_clkrate[addr][0] != left ||
	   asihpi->mixer_clkrate[addr][1] != right;
 already will have picked up index 0 above 
------------------------------------------------------------
   Mixer
		 ASI50xx in SSX mode has multiple meters on the same node.
		   Use subindex to create distinct ALSA controls
		   for any duplicated controls.
 ignore these 
------------------------------------------------------------
   proc interface
------------------------------------------------------------
   HWDEP
 results in devsndhwC#D0 file for each card with index #
   also procasoundhwdep will contain '#-00: asihpi (HPI) for each card'
------------------------------------------------------------
   CARD
 Should this be enable[hpi->index] ? 
 Initialise low-level HPI driver 
 first try to give the card the same index as its hardware index 
 if that fails, try the default index==next available 
 assume LL mode 
	 always create, can be enabled or disabled dynamically
 Stop interrupts 
 SPDX-License-Identifier: GPL-2.0-only
    AudioScience HPI driver
    Copyright (C) 1997-2014  AudioScience Inc. <support@audioscience.com>
Extended Message Function With Response Caching
(C) Copyright AudioScience Inc. 2002
		 HPI_DEBUG_LOG(DEBUG, " %x,%lx\n", i,
 Globals 
 use these to keep track of opens from user mode appsDLLs 
 return major.minor 
 return major.minor.release 
do not propagate the message down the chain 
do not propagate the message down the chain 
 Initialize this module's internal state 
 Init subsys_findadapters response to no-adapters 
 individual HPIs dont implement driver load 
 Must explicitly handle every subsys message in this switch 
 NOTE: HPI_Message() must be defined in the driver as a wrapper for
  HPI_MessageEx so that functions in hpifunc.c compile.
 issue a reset 
		 HPI_DEBUG_LOG(INFO,"closing adapter %d "
		   "instream %d owned by %p\n",
 issue a reset 
 issue a reset 
		 HPI_DEBUG_LOG(INFO,"closing adapter %d "
		   "outstream %d owned by %p\n",
 issue a reset 
 Open the adapter and streams 
 call to HPI_ADAPTER_OPEN 
 call to HPI_ADAPTER_GET_INFO 
 call to HPI_OSTREAM_OPEN 
 call to HPI_ISTREAM_OPEN 
 call to HPI_MIXER_OPEN 
 HPI_SUBSYS_CREATE_ADAPTER structure with 
 resource list or NULL=find all 
 response from HPI_ADAPTER_GET_INFO 
 Init response here so we can pass in previous adapter list 
		 the adapter was created successfully
 prepare adapter (pre-open streams etc.) 
      printk(KERN_INFO "Cleanup adapter #%d\n",wAdapter); 
 SPDX-License-Identifier: GPL-2.0-only
    AudioScience HPI driver
    Functions for reading DSP code using hotplug firmware loader
    Copyright (C) 1997-2014  AudioScience Inc. <support@audioscience.com>
  Firmware descriptor 
-------------------------------------------------------------------
 "CODE" 
 Major version change probably means Host-DSP protocol change 
-------------------------------------------------------------------
-------------------------------------------------------------------
 Go back to start of  data, after header 
-------------------------------------------------------------------
-------------------------------------------------------------------
 SPDX-License-Identifier: GPL-2.0-only
    AudioScience HPI driver
    Copyright (C) 1997-2014  AudioScience Inc. <support@audioscience.com>
\file hpicmn.c
 Common functions used by hpixxxx.c modules
(C) Copyright AudioScience Inc. 1998-2003
  hpi_validate_response - Given an HPI Message that was sent out and
  a response that was received, validate that the response has the
  correct fields filled in, i.e ObjectType, Function etc
  @phm: message
  @phr: response
HPI_ASSERT(pao->type); 
  hpi_find_adapter - FindAdapter returns a pointer to the struct
  hpi_adapter_obj with index wAdapterIndex in an HPI_ADAPTERS_LIST
  structure.
  @adapter_index: value in [0, HPI_MAX_ADAPTERS[
		
		   HPI_DEBUG_LOG(VERBOSE, "Found adapter index %d\n",
		   wAdapterIndex);
		
		   HPI_DEBUG_LOG(VERBOSE, "No adapter index %d\n",
		   wAdapterIndex);
  wipe_adapter_list - wipe an HPI_ADAPTERS_LIST structure.
 find the nCount'th nonzero adapter in array 
				 The cache is invalid.
				  Minimum valid entry size is
				  sizeof(struct hpi_control_cache_info)
 dummy cache entry 
			 quit loop early if whole cache has been scanned.
			  dwControlCount is the maximum possible entries
			  but some may be absent from the cache
 have seen last control index 
 Find a control.
 allow unified treatment of several string fields within struct 
 HPI_PAD_CHANNEL_NAME 
 HPI_PAD_ARTIST 
 HPI_PAD_TITLE 
 HPI_PAD_COMMENT 
 CheckControlCache checks the cache and fills the struct hpi_response
  accordingly. It returns one if a cache hit occurred, zero otherwise.
 set the default response size 
 Ensure null terminator 
 Updates the cache with Set values.
Only update if no error.
Volume and Level return the limited values in the response, so use these
Multiplexer does so use sent values
 mux does not return its setting on Set command. 
 mode does not return its setting on Set command. 
	 pC is the default cached control strucure.
	   May be cast to something else in the following switch statement.
 Allocate control cache.
\return Cache pointer, or NULL if allocation fails.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-only
    AudioScience HPI driver
    Copyright (C) 1997-2011  AudioScience Inc. <support@audioscience.com>
Debug macro translation.
 Debug level; 0 quiet; 1 informative, 2 debug, 3 verbose debug.  
 SPDX-License-Identifier: GPL-2.0-only
    AudioScience HPI driver
    Copyright (C) 1997-2011  AudioScience Inc. <support@audioscience.com>
 Hardware Programming Interface (HPI) for AudioScience ASI6200 series adapters.
 These PCI bus adapters are based on the TI C6711 DSP.
 Exported functions:
 void HPI_6000(struct hpi_message phm, struct hpi_response phr)
 #defines
 HIDE_PCI_ASSERTS to show the PCI asserts
 PROFILE_DSP2 get profile data from DSP2 if present (instead of DSP 1)
(C) Copyright AudioScience Inc. 1998-2003
 start of C67xx internal RAM 
 HPI6000 specific error codes 
 not actually used anywhere 
 operationalmessaging errors 
 Initialisationbootload errors 
 can't access PCI2040 
 can't access DSP HPI if 
 can't access internal DSP memory 
 can't access SDRAM - test#1 
 can't access SDRAM - test#2 
 local defines 
 for PCI2040 if chip 
 HPI CSR registers 
 word offsets from CSR base 
 use when io addresses defined as u32  
 HPI registers, spaced 8K bytes = 2K words apart 
A, B 
 local globals 
 used to count PCI2040 errors 
 used to count PCI2040 errors 
		 Don't let these messages go to the HW function because
		  they're called without locking the spinlock.
		  For the HPI6000 adapters the HW would return
		  HPI_ERROR_INVALID_FUNC anyway.
		 Don't let these messages go to the HW function because
		  they're called without locking the spinlock.
		  For the HPI6000 adapters the HW would return
		  HPI_ERROR_INVALID_FUNC anyway.
 HPI_6000()
  Entry point from HPIMAN
  All calls to the HPI start here
 Don't even try to communicate with crashed DSP 
 Init default response including the size field 
 SUBSYSTEM 
 create an adapter object and initialise it based on resource information
  passed in in the message
  NOTE - you cannot use this function AND the FindAdapters function at the
  same time, the application must use only one of them to get the adapters
 create temp adapter obj, because we don't know what index yet 
 create the adapter object based on the resource information 
 need to update paParentAdapter 
 We just added this adapter, why can't we find it!? 
 this routine is called from SubSysFindAdapter and SubSysCreateAdapter 
 The PCI2040 has the following address map 
 BAR0 - 4K = HPI control and status registers on PCI2040 (HPI CSR) 
 BAR1 - 32K = HPI registers on DSP 
 set addresses for the possible DSP HPI interfaces 
 Set the default number of DSPs on this card 
 This is (conditionally) adjusted after bootloading 
 of the first DSP in the bootload section. 
 get info about the adapter by asking the adapter 
 send a HPI_ADAPTER_GET_INFO message 
 response from DSP 0 
 response from DSP 1 
 Read the control cache length to figure out if it is turned on 
 reset DSPs on adapter 
 ADAPTER 
 if we have PCI2040 asserts then collect them 
 assert count 
 "dsp index" 
get DSP asserts 
 LOW-LEVEL 
 NOTE don't use wAdapterType in this routine. It is not setup yet 
 ASI5100 revB or higher with C6711D 
 ASI5200 PCIe version of ASI5100 
	 reset all DSPs, indicate two DSPs are present
	  set RST3-=1 to disconnect HAD8 to set DSP in little endian mode
	 read back register to make sure PCI2040 chip is functioning
	  note that bits 4..15 are read-only and so should always return zero,
	  even though we wrote 1 to them
 Indicate that DSP#0,1 is a C6X 
	 set Bit30 and 29 - which will prevent Target aborts from being
	  issued upon HPI or GP error
	 isolate DSP HAD8 line from PCI2040 so that
	  Little endian can be set by pullup
 revB 
 revB 
Take both DSPs out of reset, setting HAD8 to the correct Endian 
 start DSP 0 
 start DSP 1 
 set HAD8 back to PCI2040, now that DSP set to little endian mode 
delay to allow DSP to get going 
 loop through all DSPs, downloading DSP code 
 configure DSP so that we download code into the SRAM 
 set control reg for little endian, HWOB=1 
 test access to the HPI address register (HPIA) 
 if C6713 the setup PLL to generate 225MHz from 25MHz.
 Since the PLLDIV1 read is sometimes wrong, even on a C6713,
 we're going to do this unconditionally
 PLLDIV1 should have a value of 8000 after reset 
	if (HpiReadWord(pdo,0x01B7C118) == 0x8000)
			 C6713 datasheet says we cannot program PLL from HPI,
			  and indeed if we try to set the PLL multiply from the
			  HPI, the PLL does not seem to lock,
			  so we enable the PLL and use the default of x 7
 bypass PLL 
   use default of PLL  x7  
 EMIF = 2253=75MHz 
 peri = 2252 
 cpu  = 2251 
 ~2ms delay 
 PLL not bypassed 
 ~2ms delay 
		 test rw to internal DSP memory
		  C6711 has L2 cache mapped to 0x0 when reset
		 
		   revB - because of bug 3.0.1 last HPI read
		  (before HPI address issued) must be non-autoinc
 test each bit in the 32bit word 
		 memory map of ASI6200
		   00000000-0000FFFF    16Kx32 internal program
		   01800000-019FFFFF    Internal peripheral
		   80000000-807FFFFF    CE0 2Mx32 SDRAM running @ 100MHz
		   90000000-9000FFFF    CE1 Async peripherals:
		   EMIF config
		   ------------
		   Global EMIF control
		   0 -
		   1 -
		   2 -
		   3 CLK2EN = 1   CLKOUT2 enabled
		   4 CLK1EN = 0   CLKOUT1 disabled
		   5 EKEN = 1 <--!! C6713 specific, enables ECLKOUT
		   6 -
		   7 NOHOLD = 1   external HOLD disabled
		   8 HOLDA = 0    HOLDA output is low
		   9 HOLD = 0             HOLD input is low
		   10 ARDY = 1    ARDY input is high
		   11 BUSREQ = 0   BUSREQ output is low
		   12,13 Reserved = 1
		 EMIF CE0 setup - 2Mx32 Sync DRAM
		   31..28       Wr setup
		   27..22       Wr strobe
		   21..20       Wr hold
		   19..16       Rd setup
		   15..14       -
		   13..8        Rd strobe
		   7..4         MTYPE   0011            Sync DRAM 32bits
		   3            Wr hold MSB
		   2..0         Rd hold
		 EMIF SDRAM Extension
		   31-21        0
		   20           WR2RD = 0
		   19-18        WR2DEAC = 1
		   17           WR2WR = 0
		   16-15        R2WDQM = 2
		   14-12        RD2WR = 4
		   11-10        RD2DEAC = 1
		   9            RD2RD = 1
		   8-7          THZP = 10b
		   6-5          TWR  = 2-1 = 01b (tWR = 10ns)
		   4            TRRD = 0b = 2 ECLK (tRRD = 14ns)
		   3-1          TRAS = 5-1 = 100b (Tras=42ns = 5 ECLK)
		   1            CAS latency = 3 ECLK
		   (for Micron 2M32-7 operating at 100Mhz)
 need to use this else DSP code crashes 
		 EMIF SDRAM control - set up for a 2Mx32 SDRAM (512x32x4 bank)
		   31           -               -
		   30           SDBSZ   1               4 bank
		   29..28       SDRSZ   00              11 row address pins
		   27..26       SDCSZ   01              8 column address pins
		   25           RFEN    1               refersh enabled
		   24           INIT    1               init SDRAM
		   23..20       TRCD    0001
		   19..16       TRP             0001
		   15..12       TRC             0110
		   11..0        -               -
      need to use this else DSP code crashes 
 EMIF SDRAM Refresh Timing 
		MIF CE1 setup - Async peripherals
		   @100MHz bus speed, each cycle is 10ns,
		   31..28       Wr setup  = 1
		   27..22       Wr strobe = 3                   30ns
		   21..20       Wr hold = 1
		   19..16       Rd setup =1
		   15..14       Ta = 2
		   13..8        Rd strobe = 3                   30ns
		   7..4         MTYPE   0010            Async 32bits
		   3            Wr hold MSB =0
		   2..0         Rd hold = 1
 delay a little to allow SDRAM and DSP to "get going" 
 test access to SDRAM 
 test each bit in the 32bit word 
 test every Nth address in the DRAM 
2_mx32 
 write the DSP code down into the DSPs memory 
 end of code 
 verify that code was written correctly 
 this time through, assume no errors in DSP code filearray 
 end of code 
 zero out the hostmailbox 
 write the DSP number into the hostmailbox 
 structure before starting the DSP 
 write the DSP adapter Info into the 
 hostmailbox before starting the DSP 
 step 3. Start code by sending interrupt 
		 wait for a non-zero value in hostcmd -
		  indicating initialization is complete
		 
		  Init could take a while if DSP checks SDRAM memory
		  Was 200000. Increased to 2000000 for ASI8801 so we
		  don't get 938 errors.
			 The following is a workaround for bug #94:
			  Bluescreen on install and subsequent boots on a
			  DELL PowerEdge 600SC PC with 1.8GHz P4 and
			  ServerWorks chipset. Without this delay the system
			  locks up with a bluescreen (NOT GPF or pagefault).
 read the DSP adapter Info from the 
 hostmailbox structure after starting the DSP 
u32 dwTestData=0; 
 all 6200 cards have this many DSPs 
 test that the PLD is programmed 
 and we can readwrite 24bits 
for ASI610062008800 
 ASI61006200 has 24bit path to FPGA 
 ASI5100 uses AX6 code, 
 but has no PLD rw register to test 
 ASI5200 uses AX6 code, 
 but has no PLD rw register to test 
 ASI8800 has 16bit path to FPGA 
 write to 24 bit Debug register (D31-D8) 
 for numDSP 
 write one word to the HPI port 
 read one word from the HPI port 
? No way to return error 
 take care of errata in revB DSP (2.0.1) 
 write a block of 32bit words to the DSP HPI port using auto-inc mode 
 take care of errata in revB DSP (2.0.1) 
 must end with non auto-inc 
 read a block of 32bit words from the DSP HPI port using auto-inc mode
 take care of errata in revB DSP (2.0.1) 
 must end with non auto-inc 
 get the message address and size 
 send the message 
 get the response address 
 read the length of the response back from the DSP 
 get the response 
 set if back to idle 
 have to set up the below defines to match stuff in the MAP file 
 comment this line in to enable checking 
 round dwDataSize down to nearest 4 bytes 
 get the address and size 
 DSP returns number of DWORDS 
		 send the data. break data into 512 DWORD blocks (2K bytes)
		  and send using block write. 2Kbytes is the max as this is the
		  memory window given to the HPI data register by the PCI2040
 this parameter not used! 
 round dwDataSize down to nearest 4 bytes 
 get the address and size 
 read the data 
 DSPINT 
 set command 
 flush the FIFO 
 reset the interrupt bit 
 if the PCI2040 has recorded an HPI timeout, reset the error and return 1 
 read the error bits from the PCI2040 
 reset the error flag 
 inc global 
 wait for host interrupt to signal ack is ready 
 0x04 = HINT from DSP 
 wait for dwAckValue 
 read the ack mailbox 
for (i=0;i<1000;i++) 
      dwPause=i+1; 
		 indicates bad read from DSP -
 read the cached controls 
 flush the FIFO 
 Get dsp index for multi DSP adapters only 
 Complete transaction with DSP
Send message, get response, send or get stream data if any.
 is this  checked on the DSP anyway? 
 something failed in the HPIDSP interface 
 something failed in the DSP 
 dsp 0 default 
 no assert from dsp 0, check dsp 1 
 just the header of the response is valid 
 SPDX-License-Identifier: GPL-2.0-only
    AudioScience HPI driver
    Copyright (C) 1997-2014  AudioScience Inc. <support@audioscience.com>
 Hardware Programming Interface (HPI) for AudioScience
 ASI50xx, AS51xx, ASI6xxx, ASI87xx ASI89xx series adapters.
 These PCI and PCIe bus adapters are based on a
 TMS320C6205 PCI bus mastering DSP,
 and (except ASI50xx) TI TMS320C6xxx floating point DSP
 Exported function:
 void HPI_6205(struct hpi_message phm, struct hpi_response phr)
(C) Copyright AudioScience Inc. 1998-2010
 HPI6205 specific error codes 
 not actually used anywhere 
 operationalmessaging errors 
 initializationbootload errors 
 for C6205 PCI if 
 Host Status Register (HSR) bitfields 
 Host-to-DSP Control Register (HDCR) bitfields 
 DSP Page Register (DSPP) bitfields, 
 defines 4 Mbyte page that BAR0 points to 
 BAR0 maps to prefetchable 4 Mbyte memory block set by DSPP.
  BAR1 maps to non-prefetchable 8 Mbyte memory block
  of DSP memory mapped registers (starting at 0x01800000).
  0x01800000 is hardcoded in the PCI if, so that only the offset from this
  needs to be added to the BAR1 base address set in the PCI config reg
 used to control LED (revA) and reset C6713 (revB) 
 For first 6713 in CE1 space, using DA17,16,2 
 PCI registers 
 a non-NULL handle means there is an HPI allocated buffer 
 non-zero size means a buffer exists, may be external 
 local prototypes 
 make sure we see updates DMAed from DSP 
 Entry point to this HPI backend
  All calls to the HPI start here
 allow last resort debug read even after crash 
 Init default response  
 normal messages must have valid adapter index 
 subsys messages don't address an adapter 
 SUBSYSTEM 
 Create an adapter object and initialise it based on resource information
  passed in in the message
   NOTE - you cannot use this function AND the FindAdapters function at the
  same time, the application must use only one of them to get the adapters 
 create temp adapter obj, because we don't know what index yet 
 delete an adapter - required by WDM driver 
 reset adapter hw 
 Reset C6713 #1 
 reset C6205 
 Create adapter object
  allocate buffers, bootload DSPs, initialise control cache
 init error reporting 
 The C6205 memory area 1 is 8Mbyte window into DSP registers 
 no need to clean up as SubSysCreateAdapter 
 calls DeleteAdapter on error. 
 allow boot load even if mem alloc wont work 
 make sure the DSP has started ok 
	 Note that pao, phw are zeroed after allocation,
	  so pointers and flags are NULL by default.
	  Allocate bus mastering control cache buffer and tell the DSP about it
 wAdapterIndex == version == 0 
 Free memory areas allocated by adapter
  this routine is called from AdapterDelete,
   and SubSysCreateAdapter if duplicate index
?phw->InStreamHostBuffers[i] = NULL; 
 Adapter functions 
 reset the interrupt from the DSP 
 OutStream Host buffer functions 
 Allocate or attach buffer for busmastering
		 ALLOC phase, allocate a buffer with power of 2 size,
		   get its bus address for PCI bus mastering
		 return old size and allocated size,
 Same size, no action required 
		 get the phys addr into msg for single call alloc caller
		  needs to do this for split alloc (or use the same message)
		  return the phy address for split alloc in the respose too
		 GRANT phase.  Set up the BBM status, tell the DSP about
		   the buffer so it can start using BBM.
 Tell adapter to stop using the host buffer. 
	 Should HPI_ERROR_INVALID_OPERATION be returned
 there  is no BBM buffer, write via message 
	 HostBuffers is used to indicate host buffer is internally allocated.
		 either all data,
 remaining data if any 
	
	  This version relies on the DSP code triggering an OStream buffer
	  update immediately following a SET_FORMAT call. The host has
	  already written data into the BBM buffer, but the DSP won't know
	  about it until dwHostIndex is adjusted.
 Format can only change after reset. Must tell DSP. 
 send the format to the DSP 
 InStream Host buffer functions 
 Same size, no action required 
		 get the phys addr into msg for single call alloc. Caller
		 Should HPI_ERROR_INVALID_OPERATION be returned
		 either all data,
 remaining data if any 
 LOW-LEVEL 
 fix up cases where bootcode id[1] != subsys id 
 reset DSP by writing a 1 to the WARMRESET bit 
 check that PCI if was configured by EEPROM 
 disable PINTA interrupt 
 check control register reports PCI boot mode 
 try writing a few numbers to the DSP page register 
 and reading them back. 
 reset DSP page to the correct number 
	 release 6713 from reset before 6205 is bootloaded.
	   This ensures that the EMIF is inactive,
	   and the 6713 HPI gets the correct bootmode etc
 DSP 1 is a C6713 
 CLKX0 <- '1' release the C6205 bootmode pulldowns 
 Reset the 6713 #1 - revB 
 value of bit 3 is unknown after DSP reset, other bits shoudl be 0 
 Release C6713 from reset - revB 
 is there a DSP to load? 
 write the DSP code down into the DSPs memory 
 end of code 
 dummy read every 4 words 
 for 6205 advisory 1.4.4 
 verify code 
 end of code 
	 After bootloading all DSPs, start DSP0 running
	  The DSP0 code will handle starting and synchronizing with its slaves
 we need to tell the card the physical PCI address 
 set ack so we know when DSP is ready to go 
 (dwDspAck will be changed to HIF_RESET) 
 ensure ack is written before dsp writes back 
 locate the host mailbox on the DSP. 
 enable interrupts 
 start code running... 
 give the DSP 10ms to start up 
 Bootloader utility functions 
 DSP 0 is always C6205 
 BAR1 register access 
			 HPI_DEBUG_LOG(WARNING,
 INDENT OFF 
 INDENT-ON 
 address within 4M page 
 BAR0 memory access 
 DSP 1 is a C6713 
      u32 dwVerifyData=0; 
 DSP 0 is always C6205 
 BAR1 - DSP  register access using 
 Non-prefetchable PCI access 
 BAR0 access - all of DSP memory using 
 pre-fetchable PCI access 
 INDENT-OFF 
 INDENT-ON 
 address within 4M page 
 DSP 1 is a C6713 
 dummy read every 4 words for 6205 advisory 1.4.4 
 dummy read every 4 words for 6205 advisory 1.4.4 
 DSP 0 is always C6205 
 Set the EMIF 
 memory map of C6205 
 00000000-0000FFFF    16Kx32 internal program 
 00400000-00BFFFFF    CE0     2Mx32 SDRAM running @ 100MHz 
 EMIF config 
------------ 
 Global EMIF control 
 EMIF CE0 setup - 2Mx32 Sync DRAM on ASI5000 cards only 
 EMIF CE1 setup - 32 bit async. This is 6713 #1 HPI, 
 which occupies D15..0. 6713 starts at 27MHz, so need 
 plenty of wait states. See dsn8701.rtf, and 6713 errata. 
 WST should be 71, but 63  is max possible 
 EMIF CE2 setup - 32 bit async. This is 6713 #2 HPI, 
 which occupies D15..0. 6713 starts at 27MHz, so need 
 plenty of wait states 
 EMIF CE3 setup - 32 bit async. 
 This is the PLD on the ASI5000 cards only 
 set EMIF SDRAM control for 2Mx32 SDRAM (512x32x4 bank) 
  need to use this else DSP code crashes? 
 EMIF SDRAM Refresh Timing 
 EMIF SDRAM timing  (orig = 0x410, emulator = 0x61a) 
 test access to the C6713s HPI registers 
 Set up HPIC for little endian, by setiing HPIC:HWOB=1 
 C67 HPI is on lower 16bits of 32bit EMIF 
 HPIA - walking ones test 
		 setup C67x PLL
		    C6713 datasheet says we cannot program PLL from HPI,
		  and indeed if we try to set the PLL multiply from the HPI,
		  the PLL does not seem to lock, so we enable the PLL and
		  use the default multiply of x 7, which for a 27MHz clock
		  gives a DSP speed of 189MHz
 bypass PLL 
 EMIF = 1893=63MHz 
 peri = 1892 
 cpu  = 1891 
  SGT test to take GPO3 high when we start the PLL 
 and low when the delay is completed 
 FSX0 <- '1' (GPO3) 
 PLL not bypassed 
 FSX0 <- '0' (GPO3) 
 6205 EMIF CE1 resetup - 32 bit async. 
 Now 6713 #1 is running at 189MHz can reduce waitstates 
 CE1 
 check that we can read one of the PLL registers 
 PLL should not be bypassed! 
		 setup C67x EMIF  (note this is the only use of
		 EMIF CE0 setup - 2Mx32 Sync DRAM
		   31..28       Wr setup
		   27..22       Wr strobe
		   21..20       Wr hold
		   19..16       Rd setup
		   15..14       -
		   13..8        Rd strobe
		   7..4         MTYPE   0011            Sync DRAM 32bits
		   3            Wr hold MSB
		   2..0         Rd hold
		 EMIF SDRAM Extension
		   0x00
		   31-21        0000b 0000b 000b
		   20           WR2RD = 2cycles-1  = 1b
		   19-18        WR2DEAC = 3cycle-1 = 10b
		   17           WR2WR = 2cycle-1   = 1b
		   16-15        R2WDQM = 4cycle-1  = 11b
		   14-12        RD2WR = 6cycles-1  = 101b
		   11-10        RD2DEAC = 4cycle-1 = 11b
		   9            RD2RD = 2cycle-1   = 1b
		   8-7          THZP = 3cycle-1    = 10b
		   6-5          TWR  = 2cycle-1    = 01b (tWR = 17ns)
		   4            TRRD = 2cycle      = 0b  (tRRD = 14ns)
		   3-1          TRAS = 5cycle-1    = 100b (Tras=42ns)
		   1            CAS latency = 3cyc = 1b
		   (for Micron 2M32-7 operating at 100MHz)
		 EMIF SDRAM control - set up for a 2Mx32 SDRAM (512x32x4 bank)
		   31           -       0b       -
		   30           SDBSZ   1b              4 bank
		   29..28       SDRSZ   00b             11 row address pins
		   27..26       SDCSZ   01b             8 column address pins
		   25           RFEN    1b              refersh enabled
		   24           INIT    1b              init SDRAM!
		   23..20       TRCD    0001b                   (TrcdTcyc)-1 = (2010)-1 = 1
		   19..16       TRP     0001b                   (TrpTcyc)-1 = (2010)-1 = 1
		   15..12       TRC     0110b                   (TrcTcyc)-1 = (7010)-1 = 6
		   11..0        -       0000b 0000b 0000b
		 SDRAM refresh timing
		   Need 4,096 refresh cycles every 64ms = 15.625us = 1562cycles of 100MHz = 0x61A
 DSP 2 is a C6713 
 for 1st word, test each bit in the 32bit word, 
 dwLength specifies number of 32bit words to test 
for(i=0; i<dwLength; i++) 
 error 
 for(j) 
 for(i) 
 for the next 100 locations test each location, leaving it as zero 
 write a zero to the next word in memory before we read 
 the previous write to make sure every memory location is unique 
 error 
 leave location as zero 
 zero out entire memory block 
 DSP 0 is a C6205 
 64K prog mem 
 64K data mem 
 DSP 1 is a C6713 
 192K internal mem 
 64K internal mem  L2 cache 
 only test for SDRAM if an ASI5000 card 
 DSP 0 is always C6205 
dwDRAMinc=1024; 
 DSP 1 is a C6713 
dwDRAMinc=1024; 
 only test for DSP0 PLD on ASI5000 card 
 PLD is located at CE3=0x03000000 
 DSP 1 is a C6713 
 PLD is located at CE1=0x90000000 
 8713 - LED on 
 Transfer data to or from DSP
 nOperation = H620_H620_HIF_SEND_DATA or H620_HIF_GET_DATA
 round data_size down to nearest 4 bytes 
 make sure state is IDLE 
 DSP must change this back to nOperation 
 timed out 
                      err=HPI_ERROR_DSP_HARDWARE; 
 wait for up to timeout_us microseconds for the DSP
   to signal state by DMA into dwDspAck
 ensure interface->dsp_ack is up to date 
 DSP changes dsp_ack by DMA 
HPI_DEBUG_LOG(VERBOSE, "Spun %d for %d\n", timeout_us4-t, state); 
 set the busmaster interface to cmd, then interrupt the DSP 
 DSP gets state by DMA, make sure it is written to memory 
 before we interrupt the DSP 
	 Assume buffer of type struct bus_master_interface_62
 signal we want a response 
 spin waiting on HIF interrupt flag (end of msg process) 
 read the result 
 set interface back to idle 
 special case for adapter close - 
 wait for the DSP to indicate it is idle 
 maybe an error response 
 something failed in the HPIDSP interface 
 just the header of the response is valid 
 something failed in the DSP 
 SPDX-License-Identifier: GPL-2.0-only
    AudioScience HPI driver
    Common Linux HPI ioctl and module proberemove functions
    Copyright (C) 1997-2014  AudioScience Inc. <support@audioscience.com>
 Allow the debug level to be changed after module load.
 E.g.   echo 2 > sysmoduleasihpiparametershpiDebugLevel
 List of adapters found 
 Wrapper function to HPI_Message to enable dumping of the
   message and response types.
 This is called from hpifunc.c functions, called by ALSA
  (or other kernel process) In this case there is no file descriptor
  available for the message cache code
 for radio-asihpi 
 HPI_DEBUG_LOG(INFO,"hpi_release file %p, pid %d\n", file, current->pid); 
 close the subsystem just in case the application forgot to. 
 Read the message and response pointers from user space.  
 Now read the message size and data from user space.  
 printk(KERN_INFO "message size %d\n", hm->h.wSize); 
 Override h.size in case it is changed between two userspace fetches 
 printk(KERN_INFO "user response size %d\n", res_max_size); 
 Application must not use these functions! 
 -1=no data 0=read from user mem, 1=write to user mem 
 Dig out any pointers embedded in the message.  
 Yes, sparse, this is correct. 
				 Allocate buffer according to application request.
				   ?Is it better to allocfree for the duration
				   of the transaction?
 from card, WRITE to user mem 
 on return response size must be set 
printk(KERN_INFO "response size %d\n", hr->h.wSize); 
	 printk(KERN_INFO "asihpi_isr %d ASI%04X:%d irq handled\n",
 also sets latency timer if < 16 
 unmap previously mapped pci mem space 
 call CreateAdapterObject on the relevant hpi module 
 Check if current mode == Low Latency mode 
 Check if IRQs are supported 
	 WARNING can't init mutex in 'adapter'
	  and then copy it to adapters[] ?!?!
 Disable IRQ generation on DSP side by setting the rate to 0 
 Note: request_irq calls asihpi_isr here 
 Disable IRQ generation on DSP side 
 unmap PCI memory space, mapped during device init. 
 SPDX-License-Identifier: GPL-2.0-only
    AudioScience HPI driver
    Copyright (C) 1997-2012  AudioScience Inc. <support@audioscience.com>
HPI Operating System function implementation for Linux
(C) Copyright AudioScience Inc. 1997-2003
 MUST NOT SCHEDULE IN INTERRUPT CONTEXT! 
 Allocate an area of locked memory for bus master DMA operations.
If allocation fails, return 1, and pMemArea.size = 0
?? any benefit in using managed dmam_alloc_coherent? 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
                    Creative Labs, Inc.
   Routines for control of EMU10K1 chips
   Copyright (c) by James Courtier-Dutton <James@superbug.co.uk>
       Added support for Audigy 2 Value.
   	Added EMU 1010 support.
   	General bug fixes and enhancements.
   BUGS:
     --
   TODO:
     --
  EMU10K1 init  done
 1 Hz 
 1 Hz 
 these are last so OFF prevents writing 
 Audigy extra stuffs 
 ?? 
 ?? 
 ?? 
 ?? 
 Reset 
 Timeout 
 Interface control 
 Master mode control 
 Powerdown control 
 Attenuation Left  0x01 = -103dB, 0xff = 24dB 
 Attenuation Right 0.5dB steps 
 ALC Control 1 
 ALC Control 2 
 ALC Control 3 
 Noise gate control 
 Limiter control 
 ADC Mixer control. Mic for A2ZS Notebook 
 disable audio and lock cache 
 reset recording buffers 
 disable channel interrupt 
 set SPDIF bypass mode 
 enable rear left + rear right AC97 slots 
 init envelope engine 
 audigy2 
 Hacks for Alice3 to work independent of haP16V driver 
 Setup SRCMulti_I2S SamplingRate 
 Setup SRCSel (Enable Spdif,I2S SRCMulti) 
 Setup SRCMulti Input Audio Enable 
 Use 0xFFFFFFFF to enable P16V sounds. 
 Enabled Phased (8-channel) P16V playback 
 Set playback routing. 
 audigy2 Value 
 Hacks for Alice3 to work independent of haP16V driver 
 Setup SRCMulti_I2S SamplingRate 
 Setup SRCSel (Enable Spdif,I2S SRCMulti) 
 Setup SRCMulti Input Audio Enable 
 Setup SPDIF Out Audio Enable 
		 The Audigy 2 Value has a separate SPDIF out,
		  so no need for a mixer switch
 Clear bit 3 
 Audigy 2 ZS Notebook with DAC Wolfson WM8768WM8568 
		 Enable GPIOs
		  GPIO0: Unknown
		  GPIO1: Speakers-enabled.
		  GPIO2: Unknown
		  GPIO3: Unknown
		  GPIO4: IEC958 Output on.
		  GPIO5: Unknown
		  GPIO6: Unknown
		  GPIO7: Unknown
 Windows uses 0x3f76 
 Audigy 2 ZS Notebook with ADC Wolfson WM8775 
 Set bit 2 for mic input 
 taken from original driver 
 taken from original driver 
	
	   Hokay, setup HCFG
	    Mute Disable Audio = 0
	    Lock Tank Memory = 1
	    Lock Sound Memory = 0
	    Auto Mute = 1
 audigy2 
	 FIXME: Remove all these emu->model and replace it with a card recognition parameter,
 With on-chip joystick 
 enable IR for SB Live 
 Disable all access to A_IOCFG for the emu1010 
 Disable A_IOCFG for Audigy 2 ZS Notebook 
 Disable all access to A_IOCFG for the emu1010 
 Disable A_IOCFG for Audigy 2 ZS Notebook 
 enable analog output 
 use 16M in 4G 
	
	   Enable the audio bit
 Enable analogdigital outs on audigy 
 Disable all access to A_IOCFG for the emu1010 
 Disable A_IOCFG for Audigy 2 ZS Notebook 
 audigy2 
			 Unmute Analog now.  Set GPO6 to 1 for Apollo.
			  This has to be done after init ALice3 I2SOut beyond 48KHz.
 audigy2 value 
 Unmute Analog now. 
 Disable routing from AC97 line out to Front speakers 
 FIXME: the following routine disables LiveDrive-II !! 
 TOSLink detection 
	
	   Shutdown the chip
 reset recording buffers 
 disable channel interrupt 
 disable audio and lock cache 
  ECARD functional implementation
 In A1 Silicon, these bits are in the HC register 
#define EC_CURRENT_PROM_VERSION 0x01	 Self-explanatory.  This should
					  be incremented any time the EEPROM's
 ECARD EEPROM has 64 16-bit words 
 Addresses for special values stored in to EEPROM 
 Address of the current prom version 
 LSW of board rev 
 MSW of board rev 
#define EC_SERIALNUM_ADDR	0x30	 First word of serial number.  The
					  can be up to 30 characters in length
					  and is stored as a NULL-terminated
					  ASCII string.  Any unused bytes must be
 Location at which checksum is stored 
 Most of this stuff is pretty self-evident.  According to the hardware
  dudes, we need to leave the ADCCAL bit low in order to avoid a DC
  offset problem.  Weird.
  @func Clock bits into the Ecard's control latch.  The Ecard uses a
   control latch will is loaded bit-serially by toggling the Modem control
   lines from function 2 on the E8010.  This function hides these details
   and presents the illusion that we are actually writing to a distinct
   register.
 Set up the value 
 Clock the shift register 
 Latch the bits 
  @func Set the gain of the ECARD's CS3310 Trimgain controller.  The
  trim value consists of a 16bit value which is composed of two
  8 bit gaintrim values, one for the left channel and one for the
  right channel.  The following table maps from the GainAttenuation
  value in decibels into the corresponding bit pattern for a single
  channel.
 Enable writing to the TRIM registers 
 Do it again to insure that we meet hold time requirements 
 Clock the bit 
 Set up the initial settings 
	 Step 0: Set the codec type in the hardware control register
 Step 1: Turn off the led and deassert TRIM_CS 
 Step 2: Calibrate the ADC and DAC 
	 Step 3: Wait for awhile;   XXX We can't get away with this
	  under a real operating system; we'll need to block and wait that
	 Step 4: Switch off the DAC and ADC calibration.  Note
	  That ADC_CAL is actually an inverted signal, so we assert
 Step 4: Switch into run mode 
 Step 5: Set the analog input gain 
	 Special initialisation routine
	  before the rest of the IO-Ports become active.
 Defaults to 0x30303030 
 Delay to give time for ADC chip to switch on. It needs 113ms 
 The FPGA is a Xilinx Spartan IIE XC2S50E 
	 GPIO7 -> FPGA PGMN
	  GPIO6 -> FPGA CCLK
	  GPIO5 -> FPGA DIN
	  FPGA CONFIG OFF -> FPGA PGMN
 Set PGMN low for 1uS. 
 Leave bit 7 set during netlist setup. 
 Allow FPGA memory to clean 
 After programming, set GPIO bit 4 high again. 
 firmware file names, per model, init-fw and dock-fw (optional) 
 IRQ Status 
 OPTIONS: Which cards are attached to the EMU 
 Audio Dock attached 
 Return to Audio Dock programming mode 
 ID, should read & 0x7f = 0x55 when FPGA programmed. 
 FPGA failed to be programmed 
 Sync clocking between 1010 and Dock 
 Allow DLL to settle 
 Unmute all. Default is muted after a firmware load 
 Audio Dock removed 
 Unmute all 
  EMU-1010 - details found out from this driver, official MS Win drivers,
  testing the card:
  Audigy2 (aka Alice2):
  ---------------------
  	 communication over PCI
  	 conversion of 32-bit data coming over EMU32 links from HANA FPGA
 	  to 2 x 16-bit, using internal DSP instructions
  	 slave mode, clock supplied by HANA
  	 linked to HANA using:
  		32 x 32-bit serial EMU32 output channels
  		16 x EMU32 input channels
  		(?) x I2S IO channels (?)
  FPGA (aka HANA):
  ---------------
  	 provides all (?) physical inputs and outputs of the card
  		(ADC, DAC, SPDIF IO, ADAT IO, etc.)
  	 provides clock signal for the card and Alice2
  	 two crystals - for 44.1kHz and 48kHz multiples
  	 provides internal routing of signal sources to signal destinations
  	 inputsoutputs to Alice2 - see above
  Current status of the driver:
  ----------------------------
  	 only 44.148kHz supported (the MS Win driver supports up to 192 kHz)
  	 PCM device nb. 2:
 		16 x 16-bit playback - snd_emu10k1_fx8010_playback_ops
  		16 x 32-bit capture - snd_emu10k1_capture_efx_ops
	 AC97 2.1, Any 16Meg of 4Gig address, Auto-Mute, EMU32 Slave,
	  Lock Sound Memory Cache, Lock Tank Memory Cache,
	  Mute all codecs.
	 AC97 2.1, Any 16Meg of 4Gig address, Auto-Mute, EMU32 Slave,
	  Lock Tank Memory Cache,
	  Mute all codecs.
	 AC97 2.1, Any 16Meg of 4Gig address, Auto-Mute, EMU32 Slave,
	  Mute all codecs.
	 AC97 2.1, Any 16Meg of 4Gig address, Auto-Mute, EMU32 Slave,
	  Mute all codecs.
 Disable 48Volt power to Audio Dock 
 ID, should read & 0x7f = 0x55. (Bit 7 is the IRQ bit) 
 FPGA netlist already present so clear it 
 Return to programming mode 
 FPGA failed to return to programming mode 
 ID, should read & 0x7f = 0x55 when FPGA programmed. 
 FPGA failed to be programmed 
 Enable 48Volt power to Audio Dock 
 Optical -> ADAT IO  
	 0 : SPDIF
	  1 : ADAT
 IN_ADAT 
 IN_ADAT 
 Set no attenuation on Audio Dock pads. 
 Unmute Audio dock DACs, Headphone source DAC-4. 
 DAC PADs. 
 SPDIF Format. Set Consumer mode, 24bit, copy enable 
 MIDI routing 
 Unknown. 
 IRQ Enable: All on 
 snd_emu1010_fpga_write(emu, 0x09, 0x0f ); 
 IRQ Enable: All off 
 Default WCLK set to 48kHz. 
 Word Clock source, Internal 48kHz x1 
 snd_emu1010_fpga_write(emu, EMU_HANA_WCLOCK, EMU_HANA_WCLOCK_INT_48K | EMU_HANA_WCLOCK_4X); 
 Audio Dock LEDs. 
 For 96kHz 
 For 192kHz 
 For 48kHz 
	 Pavel Hofman - setting defaults for 8 more capture channels
	  Defaults only, users will set their own values anyways, let's
	  just copypaste.
 Original 
 AudioDock Elink <- Silence 
 Hana SPDIF Out <- Silence 
 Hamoa DAC <- Silence 
 Hana ADAT Out <- Silence 
 Unmute all 
	 AC97 1.03, Any 32Meg of 2Gig address, Auto-Mute, EMU32 Slave,
	  Lock Sound Memory Cache, Lock Tank Memory Cache,
	  Mute all codecs.
	 AC97 1.03, Any 32Meg of 2Gig address, Auto-Mute, EMU32 Slave,
	  Lock Sound Memory Cache, Lock Tank Memory Cache,
	  Un-Mute all codecs.
 Initial boot complete. Now patches 
 MIDI Route 
 Unknown 
 MIDI Route 
 Unknown 
 SPDIF Format spdif  (or 0x11 for aesebu) 
 ALICE2 bus 0xa2 
 ALICE2 bus 0xa3 
 ALICE2 bus 0xb2 
 ALICE2 bus 0xb3 
 Default outputs 
 1616(M) cardbus default outputs 
 ALICE2 bus 0xa0 
 ALICE2 bus 0xa0 
 ALICE2 bus 0xa0 
 ALICE2 bus 0xa0 
 ALICE2 bus 0xa0 
 ALICE2 bus 0xa0 
 ALICE2 bus 0xa0 
 ALICE2 bus 0xa0 
 TEMP: Select SPDIF inout 
 snd_emu1010_fpga_write(emu, EMU_HANA_OPTICAL_TYPE, 0x0);  
 TEMP: Select 48kHz SPDIF out 
 Mute all 
 Default fallback clock 48kHz 
 Word Clock source, Internal 48kHz x1 
 snd_emu1010_fpga_write(emu, EMU_HANA_WCLOCK, EMU_HANA_WCLOCK_INT_48K | EMU_HANA_WCLOCK_4X); 
 48000 
 Set LEDs on Audio Dock 
 Unmute all 
 snd_emu1010_fpga_write(emu, 0x7, 0x0);  
 snd_emu1010_fpga_write(emu, 0x7, 0x1);  
 snd_emu1010_fpga_write(emu, 0xe, 0x12);  
   Create the EMU10K1 instance
 avoid access to already used hardware 
 Disable 48Volt power to Audio Dock 
 Audigy 5Rx SB1550 
 Tested by michael@gernoth.net 28 Mar 2015 
	 DSP: CA10300-IAT LF
	  DAC: Cirrus Logic CS4382-KQZ
	  ADC: Philips 1361T
	  AC97: Sigmatel STAC9750
	  CA0151: None
 24 bit capture instead of 16bit 
 Audigy4 (Not PRO) SB0610 
 Tested by James@superbug.co.uk 4th April 2006 
	 A_IOCFG bits
	  Output
	  0: ?
	  1: ?
	  2: ?
	  3: 0 - Digital Out, 1 - Line in
	  4: ?
	  5: ?
	  6: ?
	  7: ?
	  Input
	  8: ?
	  9: ?
	  A: Green jack sense (Front)
	  B: ?
	  C: Black jack sense (RearSide Right)
	  D: Yellow jack sense (CenterLFESide Left)
	  E: ?
	  F: ?
	 
	  Digital OutLine in switch using A_IOCFG bit 3 (0x08)
	  0 - Digital Out
	  1 - Line in
	 Mic input not tested.
	  Analog CD input not tested
	  Digital Out not tested.
	  Line in working.
	  Audio output 5.1 working. Side outputs not working.
	 DSP: CA10300-IAT LF
	  DAC: Cirrus Logic CS4382-KQZ
	  ADC: Philips 1361T
	  AC97: Sigmatel STAC9750
	  CA0151: None
 24 bit capture instead of 16bit 
	 Audigy 2 Value AC3 out does not work yet.
	  Need to find out how to turn off interpolators.
 Tested by James@superbug.co.uk 3rd July 2005 
	 DSP: CA0108-IAT
	  DAC: CS4382-KQ
	  ADC: Philips 1361T
	  AC97: STAC9750
	  CA0151: None
 Audigy 2 ZS Notebook Cardbus card.
 Tested by James@superbug.co.uk 6th November 2006 
	 Audio output 7.1Headphones working.
	  Digital output working. (AC3 not checked, only PCM)
	  Audio MicLine inputs working.
	  Digital input not tested.
	 DSP: Tina2
	  DAC: Wolfson WM8768WM8568
	  ADC: Wolfson WM8775
	  AC97: None
	  CA0151: None
 Tested by James@superbug.co.uk 4th April 2006 
	 A_IOCFG bits
	  Output
	  0: Not Used
	  1: 0 = Mute all the 7.1 channel out. 1 = unmute.
	  2: Analog input 0 = line in, 1 = mic in
	  3: Not Used
	  4: Digital output 0 = off, 1 = on.
	  5: Not Used
	  6: Not Used
	  7: Not Used
	  Input
	       All bits 1 (0x3fxx) means nothing plugged in.
	  8-9: 0 = Line inMic, 2 = Optical in, 3 = Nothing.
	  A-B: 0 = Headphones, 2 = Optical out, 3 = Nothing.
	  C-D: 2 = FrontRearetc, 3 = nothing.
	  E-F: Always 0
	 
 Tested by James@superbug.co.uk 4th Nov 2007. 
 Tested by James@superbug.co.uk 4th Nov 2007. 
 This is MAEM8960, 0202 is MAEM 8980 
 EMU 1010 new revision 
 Tested by Maxim Kachur <mcdebugger@duganet.ru> 17th Oct 2012. 
 This is MAEM8986, 0202 is MAEM8980 
 EMU 1010 PCIe 
 Tested by James@superbug.co.uk 8th July 2005. 
 This is MAEM8810, 0202 is MAEM8820 
 EMU 1010 old revision 
 EMU0404b 
 EMU 0404 new revision 
 Tested by James@superbug.co.uk 20-3-2007. 
 EMU 0404 
 EMU0404 PCIe 
 EMU 0404 PCIe ver_03 
 Note that all E-mu cards require kernel 2.6 or newer. 
 Tested by James@superbug.co.uk 3rd July 2005 
 Tested by shane-alsa@cm.nu 5th Nov 2005 
	 The 0x20061102 does have SB0350 written on it
	  Just like 0x20021102
 digitalanalog switch swapped 
	 0x20051102 also has SB0350 written on it, treated as Audigy 2 ZS by
 digitalanalog switch swapped 
 digitalanalog switch swapped 
 digitalanalog switch swapped 
 Audigy 2 
 Tested by James@superbug.co.uk 3rd July 2005 
	 DSP: CA0102-IAT
	  DAC: CS4382-KQ
	  ADC: Philips 1361T
	  AC97: STAC9721
	  CA0151: Yes
 24 bit capture instead of 16bit 
 Dell OEMCreative Labs Audigy 2 ZS 
 See ALSA bug#1365 
 digitalanalog switch swapped 
 digitalanalog switch swapped 
 24 bit capture instead of 16bit. Fixes ALSA bug#324 
 Tested by ALSA bug#1680 26th December 2005 
 note: It really has SB0220 written on the card, 
 but it's SB0228 according to kx.inf 
 Tested by Thomas Zehetbauer 27th Aug 2005 
 Tested by alsa bugtrack user "hus" bug #1297 12th Aug 2005 
	 .ac97_chip = 2,  ac97 is optional; both SBLive 5.1 and platinum
			   share the same IDs!
 Tested by James@superbug.co.uk 3rd July 2005 
 terminator 
  The chip (at least the Audigy 2 CA0102 chip, but most likely others, too)
  has a problem that from time to time it likes to do few DMA reads a bit
  beyond its normal allocation and gets very confused if these reads get
  blocked by a IOMMU.
  This behaviour has been observed for the first (reserved) page
  (for which it happens multiple times at every playback), often for various
  synth pages and sometimes for PCM playback buffers and the page table
  memory itself.
  As a workaround let's widen these DMA allocations by an extra page if we
  detect that the device is behind a non-passthrough IOMMU.
 enable PCI device 
 read revision & serial 
 set addressing mode 
 set the DMA transfer mask 
		 5.1: Enable the additional AC97 Slots. If the emu10k1 version
 initialize TRAM setup 
 irq handler must be registered after IO ports are activated 
	
	   Init to 0x02109204 :
	   Clock accuracy    = 0     (1000ppm)
	   Sample Rate       = 2     (48kHz)
	   Audio Channel     = 1     (Left of 2)
	   Source Number     = 0     (Unspecified)
	   Generation Status = 1     (Original for Cat Code 12)
	   Cat Code          = 12    (Digital Signal Mixer)
	   Mode              = 0     (Mode 0)
	   Emphasis          = 0     (None)
	   CP                = 1     (Copyright unasserted)
	   AN                = 0     (Audio data)
	   P                 = 0     (Consumer)
 Clear silent pages and set up pointers 
 set up voice indices 
  Initialize the effect engine 
 end 
 end 
 resore for spdif 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
                    Creative Labs, Inc.
   Routines for control of EMU10K1 chips  proc interface routines
   Copyright (c) by James Courtier-Dutton <James@superbug.co.uk>
   	Added EMU 1010 support.
   BUGS:
     --
   TODO:
     --
 From ((Rate  48000 )  262144); 
 FIXME - output names are in emufx.c too 
 00  "AC97 Left",
 01  "AC97 Right",
 02  "Optical IEC958 Left",
 03  "Optical IEC958 Right",
 04  "Center",
 05  "LFE",
 06  "Headphone Left",
 07  "Headphone Right",
 08  "Surround Left",
 09  "Surround Right",
 10  "PCM Capture Left",
 11  "PCM Capture Right",
 12  "MIC Capture",
 13  "AC97 Surround Left",
 14  "AC97 Surround Right",
 15  "???",
 16  "???",
 17  "Analog Center",
 18  "Analog LFE",
 19  "???",
 20  "???",
 21  "???",
 22  "???",
 23  "???",
 24  "???",
 25  "???",
 26  "???",
 27  "???",
 28  "???",
 29  "???",
 30  "???",
 31  "???"
 00  "Digital Front Left",
 01  "Digital Front Right",
 02  "Digital Center",
 03  "Digital LEF",
 04  "Headphone Left",
 05  "Headphone Right",
 06  "Digital Rear Left",
 07  "Digital Rear Right",
 08  "Front Left",
 09  "Front Right",
 10  "Center",
 11  "LFE",
 12  "???",
 13  "???",
 14  "Rear Left",
 15  "Rear Right",
 16  "AC97 Front Left",
 17  "AC97 Front Right",
 18  "ADC Capture Left",
 19  "ADC Capture Right",
 20  "???",
 21  "???",
 22  "???",
 23  "???",
 24  "???",
 25  "???",
 26  "???",
 27  "???",
 28  "???",
 29  "???",
 30  "???",
 31  "???",
 32  "FXBUS2_0",
 33  "FXBUS2_1",
 34  "FXBUS2_2",
 35  "FXBUS2_3",
 36  "FXBUS2_4",
 37  "FXBUS2_5",
 38  "FXBUS2_6",
 39  "FXBUS2_7",
 40  "FXBUS2_8",
 41  "FXBUS2_9",
 42  "FXBUS2_10",
 43  "FXBUS2_11",
 44  "FXBUS2_12",
 45  "FXBUS2_13",
 46  "FXBUS2_14",
 47  "FXBUS2_15",
 48  "FXBUS2_16",
 49  "FXBUS2_17",
 50  "FXBUS2_18",
 51  "FXBUS2_19",
 52  "FXBUS2_20",
 53  "FXBUS2_21",
 54  "FXBUS2_22",
 55  "FXBUS2_23",
 56  "FXBUS2_24",
 57  "FXBUS2_25",
 58  "FXBUS2_26",
 59  "FXBUS2_27",
 60  "FXBUS2_28",
 61  "FXBUS2_29",
 62  "FXBUS2_30",
 63  "FXBUS2_31"
 0x%04x: 0x%08x%08x \n",
 0x%04x: 0x%08x%08x \n",
| S_IWUSR;
| S_IWUSR;
| S_IWUSR;
| S_IWUSR;
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (C) 2000 Takashi Iwai <tiwai@suse.de>
   Routines for control of EMU10K1 WaveTable synth
  create a new hardware dependent device for Emu10k1
 nothing 
 maximum two ports 
 audigy has two external midis 
 FIXED 
 not registered actually 
   INIT part
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
                    Creative Labs, Inc.
   Routines for control of EMU10K1 chips
   BUGS:
     --
   TODO:
     --
 This function is not re-entrant, so protect against it. 
 PTR20, reg 0x3c 
		 For other chip types the SPI register
 Only 16bit values allowed 
 Set xxx20000 
 Set xxx1xxxx 
 write post 
 Wait for status bit to return to 0 
 Timed out 
 Write post 
 The ADC does not support i2c read, so only write is implemented 
 This function is not re-entrant, so protect against it. 
 This controls the I2C connected to the WM8775 ADC Codec 
 write post 
 Send the data to i2c 
 Wait till the transaction ends 
Read back and see if the transaction is successful
 dump_stack(); 
 0x40 upwards are registers. 
 0 to 0x3f are values 
 High bit clocks the value into the fpga. 
 High bit clocks the value into the fpga. 
 0x40 upwards are registers. 
 High bit clocks the value into the fpga. 
 Each Destination has one and only one Source,
  but one Source can feed any number of Destinations simultaneously.
 voice interrupt 
 voice interrupt 
 voice interrupt 
 voice interrupt 
 voice interrupt 
 voice interrupt 
 voice interrupt 
 voice interrupt 
   convert rate to pitch
 Bail out if no leading "1" 
 Scale 48000 to 0x20002380 
 Detect leading "1" 
 Should never reach this point 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
                    Creative Labs, Inc.
                    Lee Revell <rlrevell@joe-job.com>
   Routines for control of EMU10K1 chips - voice manager
   Rewrote voice allocator for multichannel support - rlrevell 122004
   BUGS:
     --
   TODO:
     --
 Previously the voice allocator started at 0 every time.  The new voice 
  allocator uses a round robin scheme.  The next free voice is tracked in 
  the card record and each allocation begins where the last left off.  The 
  hardware requires stereo interleaved voices be aligned to an evenodd 
  boundary.  For multichannel voice allocation we ensure than the block of 
  voices does not cross the 32 voice boundary.  This simplifies the 
  multichannel support and ensures we can use a single write to the 
  (set|clear)_loop_stop registers.  Otherwise (for example) the voices would 
  get out of sync when pausingresuming a stream.
 							--rlrevell
		
		dev_dbg(emu->card->dev, "i %d j %d next free %d!\n",
		       i, j, emu->next_free_voice);
 stereo voices must be evenodd 
 dev_dbg(emu->card->dev, "allocated voice %d\n", i); 
		
		dev_dbg(emu->card->dev, "voice alloc - %i, %i of %i\n",
		       voice->number, idx-first_voice+1, number);
 free a voice from synth 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
   Routines for control of EMU10K1 MPU-401 in UART mode
 mpu401_clear_rx(emu, midi); 
 try to send some amount of bytes here before interrupts 
 no more data 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>
   Driver EMU10K1X chips
   Parts of this code were adapted from audigyls.c driver which is
   Copyright (c) by James Courtier-Dutton <James@superbug.demon.co.uk>
   BUGS:
     --
   TODO:
   Chips (SB0200 model):
     - EMU10K1X-DBQ
     - STAC 9708T
 module parameters (see "Module Parameters")
 some definitions were borrowed from emu10k1 driver as they seem to be the same
 PCI function 0 registers, address = <val> + PCIBASE0						
 Indexed register set pointer register	
 NOTE: The CHANNELNUM and ADDRESS words can	
 be modified independently of each other.	
 Indexed register set data register		
 Global interrupt pending register		
 Clear pending interrupts by writing a 1 to	
 the relevant bits and zero to the other bits	
 MIDI UART transmit buffer empty		
 MIDI UART receive buffer empty		
 Channel 0 loop                               
 Channel 0 half loop                          
 Channel capture loop                         
 Channel capture half loop                    
 Interrupt enable register			
 Enable MIDI transmit-buffer-empty interrupts	
 Enable MIDI receive-buffer-empty interrupts	
 Channel 0 loop                               
 Channel 0 half loop                          
 Channel capture loop                         
 Channel capture half loop                    
 Hardware config register			
 1 = Cancel bustmaster accesses to soundcache 
 NOTE: This should generally never be used.  	
 0 = CODECs transmit zero-valued samples	
 Should be set to 1 when the EMU10K1 is	
 completely initialized.			
 Defaults: 00001080-Analog, 00001000-SPDIF.   
 AC97 register set data register (16 bit)	
 AC97 register set address register (8 bit)	
 Emu10k1x pointer-offset register set, accessed through the PTR and DATA registers			
 Base DMA address of a list of pointers to each periodsize 
						 One list entry: 4 bytes for DMA address, 
						  4 bytes for period_size << 16.
						  One list entry is 8 bytes long.
						  One list entry for each period in the buffer.
 Size of list in bytes << 16. E.g. 8 periods -> 0x00380000  
 Pointer to the current period being played 
 Playback DMA address 
 Playback period size 
 Playback period pointer. Sample currently in DAC 
 Only one capture channel supported 
 Capture DMA address 
 Capture buffer size 
 Capture buffer pointer. Sample currently in ADC 
 From 0x20 - 0x3f, last samples played on each channel 
 Trigger channel playback                     
 Trigger channel 0                            
 Trigger channel 1                            
 Trigger channel 2                            
 Trigger capture channel                      
 Setup sound routing ?                        
 SPDIF output Channel Status 0 register	
 SPDIF output Channel Status 1 register	
 SPDIF output Channel Status 2 register	
 Clock accuracy				
 1000 parts per million			
 50 parts per million				
 Variable accuracy				
 Sample rate					
 44.1kHz sample rate				
 48kHz sample rate				
 32kHz sample rate				
 Channel number				
 Unspecified channel number			
 Left channel					
 Right channel				
 Source number				
 Unspecified source number			
 Originality flag (see IEC-958 spec)		
 Category code (see IEC-958 spec)		
 Mode (see IEC-958 spec)			
 Emphasis					
 No emphasis					
 5015 usec 2 channel				
 Copyright asserted flag -- do not modify	
 0 = Digital audio, 1 = not audio		
 0 = Consumer (IEC-958), 1 = pro (AES3-1992)	
 Enables SPDIF or Analogue outputs 0-Analogue, 0x700-SPDIF 
 This is the MPU port on the card                      					
 From 0x50 - 0x5f, last samples captured 
  The hardware has 3 channels for playback and 1 for capture.
   - channel 0 is the front channel
   - channel 1 is the rear channel
   - channel 2 is the centerlfe channel
  Volume is controlled by the AC97 for the front and rear channels by
  the PCM Playback Volume, Sigmatel Surround Playback Volume and 
  Surround Playback Volume. The Sigmatel 4-Speaker Stereo switch affects
  the frontrear channel mixing in the REAR OUT jack. When using the
  4-Speaker Stereo, both front and rear channels will be mixed in the
  REAR OUT.
  The centerlfe channel has no volume control and cannot be muted during
  playback.
 definition of the chip-specific record
 chip revision 
 serial number 
 subsystem id 
 SPDIF out setup
 hardware definition 
 open callback 
 close callback 
 hw_params callback 
 hw_free callback 
 prepare callback 
 trigger callback 
	
	dev_dbg(emu->card->dev,
		"trigger - emu10k1x = 0x%x, cmd = %i, pointer = %d\n",
		(int)emu, cmd, (int)substream->ops->pointer(substream));
 pointer callback 
 operators 
 open_capture callback 
 close callback 
 hw_params callback 
 hw_free callback 
 prepare capture callback 
 buffer size in bytes
 trigger_capture callback 
 pointer_capture callback 
 we don't need VRA 
 disable interrupts
 disable audio
 capture interrupt
 acknowledge the interrupt if necessary
 dev_dbg(chip->card->dev, "interrupt %08x\n", status); 
 read revision & serial 
	
	   Init to 0x02109204 :
	   Clock accuracy    = 0     (1000ppm)
	   Sample Rate       = 2     (48kHz)
	   Audio Channel     = 1     (Left of 2)
	   Source Number     = 0     (Unspecified)
	   Generation Status = 1     (Original for Cat Code 12)
	   Cat Code          = 12    (Digital Signal Mixer)
	   Mode              = 0     (Mode 0)
	   Emphasis          = 0     (None)
	   CP                = 1     (Copyright unasserted)
	   AN                = 0     (Audio data)
	   P                 = 0     (Consumer)
 disable SPDIF
 routing
 analog mode
 enable spdif output
 disable spdif output
 mpu401_clear_rx(emu, midi); 
 try to send some amount of bytes here before interrupts 
 no more data 
 PCI IDs
 Dell OEM version (EMU10K1) 
 pci_driver definition
 SPDX-License-Identifier: GPL-2.0-or-later
   Patch transfer callback for Emu10k1
   Copyright (C) 2000 Takashi iwai <tiwai@suse.de>
  All the code for loading in a patch.  There is very little that is
  chip specific here.  Just the actual writing to the board.
  allocate a sample block and copy data from userspace
 recalculate address offset 
 some samples have invalid data.  the addresses are corrected in voice info 
 be sure loop points start < end 
 compute true data size to be loaded 
 not supported 
 try to allocate a memory block 
 not ENOMEM (for compatibility with OSS) 
 set the total size 
 write blank samples at head 
 copy start->loopend 
 not supported yet 
 handle reverse (or bidirectional) loop 
 copy loop in reverse 
 modify loop pointers 
 add sample pointer 
 loopend -> sample end 
 clear rest of samples (if any) 
 if no blank loop is attached in the sample, add it 
 not supported yet 
 unsigned -> signed 
 recalculate offset 
  free a sample block
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Lee Revell <rlrevell@joe-job.com>
                    Clemens Ladisch <clemens@ladisch.de>
   Routines for control of EMU10K1 chips
   BUGS:
     --
   TODO:
     --
 minimum time is 5 ticks 
 1 sample @ 48KHZ = 20.833...us 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by James Courtier-Dutton <James@superbug.demon.co.uk>
   Driver p16v chips
   Version: 0.25
   FEATURES currently supported:
     Output fixed at S32_LE, 2 channel to hw:0,0
     Rates: 44.1, 48, 96, 192.
   Changelog:
   0.8
     Use separate card based buffer for periods table.
   0.9
     Use 2 channel output streams instead of 8 channel.
        (8 channel output streams might be good for ASIO type output)
     Corrected speaker output, so Front -> Front etc.
   0.10
     Fixed missed interrupts.
   0.11
     Add Sound card model number and names.
     Add Analog volume controls.
   0.12
     Corrected playback interrupts. Now interrupt per period, instead of half period.
   0.13
     Use single trigger for multichannel.
   0.14
     Mic capture now works at fixed: S32_LE, 96000Hz, Stereo.
   0.15
     Force buffer_size  period_size == INTEGER.
   0.16
     Update p16v.c to work with changed alsa api.
   0.17
     Update p16v.c to work with changed alsa api. Removed boot_devs.
   0.18
     Merging with snd-emu10k1 driver.
   0.19
     One stereo channel at 24bit now works.
   0.20
     Added better register defines.
   0.21
     Integrated with snd-emu10k1 driver.
   0.22
     Removed #if 0 ... #endif
   0.23
     Implement different capture rates.
   0.24
     Implement different capture source channels.
     e.g. When HD Capture source is set to SPDIF,
     setting HD Capture channel to 0 captures from CDROM digital input.
     setting HD Capture channel to 1 captures from SPDIF in.
   0.25
     Include capture buffer sizes.
   BUGS:
     Some stability problems when unloading the snd-p16v kernel module.
     --
   TODO:
     SPDIF out.
     Find out how to change capture sample rates. E.g. To record SPDIF at 48000Hz.
     Currently capture fixed at 48000Hz.
     --
   GENERAL INFO:
     Model: SB0240
     P16V Chip: CA0151-DBS
     Audigy 2 Chip: CA0102-IAT
     AC97 Codec: STAC 9721
     ADC: Philips 1361T (Stereo 24bit)
     DAC: CS4382-K (8-channel, 24bit, 192Khz)
   This code was initially based on code from ALSA's emu10k1x.c which is:
   Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>
 Testing channel outputs 0=Front, 1=CenterLFE, 2=Unknown, 3=Rear 
 Card IDs:
  Class 0401: 1102:0004 (rev 04) Subsystem: 1102:2002 -> Audigy2 ZS 7.1 Model:SB0350
  Class 0401: 1102:0004 (rev 04) Subsystem: 1102:1007 -> Audigy2 6.1    Model:SB0240
  Class 0401: 1102:0004 (rev 04) Subsystem: 1102:1002 -> Audigy2 Platinum  Model:SB msb0240230009266
  Class 0401: 1102:0004 (rev 04) Subsystem: 1102:2007 -> Audigy4 Pro Model:SB0380 M1SB0380472001901E
 hardware definition 
 Only supports 24-bit samples padded to 32 bits. 
 size has to be N64 bytes 
 open_playback callback 
 dev_dbg(emu->card->dev, "epcm kcalloc: %p\n", epcm); 
	
	dev_dbg(emu->card->dev, "epcm device=%d, channel_id=%d\n",
		   substream->pcm->device, channel_id);
 debug 
 debug 
 channel->interrupt = snd_p16v_pcm_channel_interrupt; 
 open_capture callback 
 dev_dbg(emu->card->dev, "epcm kcalloc: %p\n", epcm); 
	
	dev_dbg(emu->card->dev, "epcm device=%d, channel_id=%d\n",
		   substream->pcm->device, channel_id);
 debug 
 debug 
 channel->interrupt = snd_p16v_pcm_channel_interrupt; 
 close callback 
struct snd_pcm_runtime runtime = substream->runtime;
struct snd_emu10k1_pcm epcm = runtime->private_data;
 FIXME: maybe zero others 
 close callback 
struct snd_pcm_runtime runtime = substream->runtime;
struct snd_emu10k1_pcm epcm = runtime->private_data;
 FIXME: maybe zero others 
 Only using channel 0 for now, but the card has 2 channels.
 prepare playback callback 
 debug 
 debug 
 FIXME: Check emu->buffer.size before actually writing to it. 
snd_emu10k1_ptr20_write(emu, PLAYBACK_PERIOD_SIZE, channel, frames_to_bytes(runtime, runtime->period_size)<<16); 
 buffer size in bytes
 prepare capture callback 
	
	dev_dbg(emu->card->dev, "prepare capture:channel_number=%d, rate=%d, "
	       "format=0x%x, channels=%d, buffer_size=%ld, period_size=%ld, "
	       "frames_to_bytes=%d\n",
	       channel, runtime->rate, runtime->format, runtime->channels,
	       runtime->buffer_size, runtime->period_size,
	       frames_to_bytes(runtime, 1));
 FIXME: Check emu->buffer.size before actually writing to it. 
 buffer size in bytes
snd_emu10k1_ptr20_write(emu, CAPTURE_SOURCE, 0x0, 0x333300e4);  Select MIC or Line in 
snd_emu10k1_ptr20_write(emu, EXTENDED_INT_MASK, 0, snd_emu10k1_ptr20_read(emu, EXTENDED_INT_MASK, 0) | (0x110000<<channel));
 trigger_playback callback 
 dev_dbg(emu->card->dev, "p16v channel=%d\n", channel); 
 dev_dbg(emu->card->dev, "basic=0x%x, inte=0x%x\n", basic, inte); 
 trigger_capture callback 
snd_emu10k1_ptr20_write(emu, EXTENDED_INT_MASK, 0, snd_emu10k1_ptr20_read(emu, EXTENDED_INT_MASK, 0) & ~(0x110000<<channel));
 pointer_playback callback 
 pointer_capture callback 
	
	dev_dbg(emu->card->dev, "ptr1 = 0x%lx, ptr2=0x%lx, ptr=0x%lx, "
	       "buffer_size = 0x%x, period_size = 0x%x, bits=%d, rate=%d\n",
	       ptr1, ptr2, ptr, (int)runtime->buffer_size,
	       (int)runtime->period_size, (int)runtime->frame_bits,
	       (int)runtime->rate);
 operators 
 dev_dbg(emu->card->dev, "snd_p16v_pcm called. device=%d\n", device); 
 Single playback 8 channel device.
 Single capture 2 channel device.
		
		dev_dbg(emu->card->dev,
			   "preallocate playback substream: err=%d\n", err);
		
		dev_dbg(emu->card->dev,
			   "preallocate capture substream: err=%d\n", err);
 Left 
 Right 
 Left 
 Right 
 up to 4, but only first channel is used 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
                    Creative Labs, Inc.
   Routines for control of EMU10K1 chips  PCM routines
   Multichannel PCM support Copyright (c) Lee Revell <rlrevell@joe-job.com>
   BUGS:
     --
   TODO:
     --
 already allocated 
			
			dev_dbg(emu->card->dev, "pcm_channel_alloc: "
			       "failed extra: voices=%d, frame=%d\n",
			       voices, frame);
 really supported? 
  calculate cache invalidate size 
  stereo: channel is stereo
  w_16: using 16bit samples
  returns: cache invalidate size in samples
 volume parameters 
 mono, left, right (master voice = left) 
 setup routing 
 Stop CA 
 Assumption that PT is already 0 so no harm overwriting 
 Disable interpolators on emu1010 card 
 Clear filter delay memory 
 invalidate maps 
 modulation envelope 
 volume envelope 
 filter envelope 
 pitch envelope 
 change 
	
	  the kX driver leaves some space between voices
 only difference with the master voice is we use it for the pointer 
 zeroing the buffer size will stop capture 
 set cs to 2  number of cache registers beside the invalidated 
 reset cache 
 fill cache 
 skip second voice for mono 
 skip second voice for mono 
 Disable interpolators on emu1010 card 
	 try to sychronize the current position for the interrupt
	
	dev_dbg(emu->card->dev,
		"trigger - emu10k1 = 0x%x, cmd = %i, pointer = %i\n",
	       (int)emu, cmd, substream->ops->pointer(substream))
 do we need this? 
 hmm this should cause full and half full interrupt to be raised? 
		
		dev_dbg(emu->card->dev, "adccr = 0x%x, adcbs = 0x%x\n",
		       epcm->adccr, epcm->adcbs);
 Perex's code 
 EMU10K1 Open Source code from Creative 
	
	dev_dbg(emu->card->dev,
	       "ptr = 0x%lx, buffer_size = 0x%lx, period_size = 0x%lx\n",
	       (long)ptr, (long)runtime->buffer_size,
	       (long)runtime->period_size);
 prepare voices 
 hack, it takes awhile until capture is started 
   Playback support device description
   Capture support device description
  Nb. of channels has been increased to 16 
		 TODO
		  SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE
		  SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |
		  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
		  SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000
		  rate_min = 44100,
		  rate_max = 192000,
		  channels_min = 16,
		  channels_max = 16,
		  Need to add mixer control to fix sample rate
		                  
		  There are 32 mono channels of 16bits each.
		  24bit Audio uses 2x channels over 16bit
		  96kHz uses 2x channels over 48kHz
		  192kHz uses 4x channels over 48kHz
		  So, for 48kHz 24bit, one has 16 channels
		  for 96kHz 24bit, one has 8 channels
		  for 192kHz 24bit, one has 4 channels
		 
 For 44.1kHz 
 For 48kHz 
 For 96kHz 
 For 192kHz 
		 efx_voices_mask[0] is expected to be zero
 		  efx_voices_mask[1] is expected to have 32bits set
 EFX playback 
 playback substream can't use managed buffers due to alignment 
 EFX playback 
	
	dev_dbg(emu->card->dev,
		"tram_poke1: dst_left = 0x%p, dst_right = 0x%p, "
	       "src = 0x%p, count = 0x%x\n",
	       dst_left, dst_right, src, count);
	
	dev_dbg(emu->card->dev, "prepare: etram_pages = 0x%p, dma_area = 0x%x, "
	       "buffer_size = 0x%x (0x%x)\n",
	       emu->fx8010.etram_pages, runtime->dma_area,
	       runtime->buffer_size, runtime->buffer_size << 2);
 byte size 
 reset 
 reset 
 reset ptr number 
 follow thru 
 roll the ball 
 byte pointer 
 SNDRV_PCM_INFO_MMAP_VALID |  SNDRV_PCM_INFO_PAUSE |
	 EFX capture - record the "FXBUS2" channels, by default we connect the EXTINs 
	  to these
 emu->efx_voices_mask[0] = FXWC_DEFAULTROUTE_C | FXWC_DEFAULTROUTE_A; 
			 Pavel Hofman - 32 voices will be used for
			  capture (write mode) -
			  each bit = corresponding voice
	 For emu1010, the control has to set 32 upper bits (voices)
	  out of the 64 bits (voices) to true for the 16-channels capture
	  to work correctly. Correct A_FXWC2 initial value (0xffffffff)
	  is already defined but the snd_emu10k1_pcm_efx_voices_mask
	  control can override this register's value.
 SPDX-License-Identifier: GPL-2.0-or-later
   synth callback routines for Emu10k1
   Copyright (C) 2000 Takashi Iwai <tiwai@suse.de>
 voice status 
 Keeps track of what we are finding 
  prototypes
  Ensure a value is between two points
  macro evaluates its args more than once, so changed to upper-case.
  set up operators
  get more voice for pcm
  terminate most inactive voice and give it as a pcm voice.
  voice_lock is already held.
 no OFF voices 
				
				dev_warn(emu->card->dev,
				       "synth_get_voice: ch < 0 (%d) ??", i);
 not found 
  turn off the voice (not terminated)
  terminate the voice
  release the voice to system
 FIXME: emu10k1_synth is broken. 
 This can get called with hw == 0 
 Problem apparent on plug, unplug then plug 
 on the Audigy 2 ZS Notebook. 
 snd_emu10k1_ptr_write(hw, DCYSUSV, vp->ch, 0);
  update registers
  look up voice table - get the best voice in order of preference
 spinlock held! 
 XXX MAX_?INT really 
	
	  Go through them all and get a best one to use.
	  NOTE: could also look at volume and pick the quietest one.
 check if sample is finished playing (non-looping only) 
  get an empty voice
  emu->voice_lock is already held.
 allocate a voice 
 not found 
  prepare envelopes and LFOs
 dev_err(hw->card->devK, "emu: cannot map!\n"); 
 set channel routing 
 A = left(0), B = right(1), C = reverb(c), D = chorus(d) 
 channel to be silent and idle 
 set pitch offset 
 set envelope parameters 
	 decaysustain parameter for volume envelope is used
 cutoff and volume 
 modulation envelope heights 
 lfo12 delay 
 lfo1 pitch & cutoff shift 
 lfo1 volume & freq 
 lfo2 pitch & freq 
 reverb and loop start (reverb 8bit, MSB) 
 chorus & loop end (chorus 8bit, MSB) 
 clear filter delay memory 
 invalidate maps 
 cache 
 cache 
 invalidate maps 
 fill cache 
 Q & current address (Q 4bit value, MSB) 
 reset volume 
  Start envelope
 not mapped 
 set pitch target and pan (volume) 
 pitch target 
 trigger voice 
 set lfo1 modulation height and cutoff 
 set lfo2 pitch & frequency 
 set filterQ 
 SPDX-License-Identifier: GPL-2.0-or-later
   The driver for the EMU10K1 (SB Live!) based soundcards
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
   Copyright (c) by James Courtier-Dutton <James@superbug.demon.co.uk>
       Added support for Audigy 2 Value.
 Index 0-MAX 
 ID for this card 
 Enable this card 
 Force card subsystem model 
  Class 0401: 1102:0008 (rev 00) Subsystem: 1102:1001 -> Audigy2 Value  Model:SB0400
 EMU10K1 
 Audigy 
 Audigy 2 Value SB0400 
  Audigy 2 Value notes:
  A_IOCFG Input (GPIO)
  0x400  = Front analog jack plugged in. (Green socket)
  0x1000 = Read analog jack plugged in. (Black socket)
  0x2000 = CenterLFE analog jack plugged in. (Orange socket)
  A_IOCFG Output (GPIO)
  0x60 = Sound out of front Left.
  Win sets it to 0xXX61
 This stores the periods table. 
 P16V 	
 P16V 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>,
                    Takashi Iwai <tiwai@suse.de>
                    Creative Labs, Inc.
   Routines for control of EMU10K1 chips  mixer routines
   Multichannel PCM support Copyright (c) Lee Revell <rlrevell@joe-job.com>
   Copyright (c) by James Courtier-Dutton <James@superbug.co.uk>
   	Added EMU 1010 support.
   BUGS:
     --
   TODO:
     --
 WM8775 gain scale 
 Limit: emu->spdif_bits 
  Items labels in enum mixer controls assigning source data to
  each destination
 1616(m) cardbus 
  List of data sources available for each destination
 0 
 1 
 2 
 3 
 4 
 5 
 6 
 7 
 8 
 9 
 10 
 11 
 12 
 13 
 14 
 15 
 16 
 17 
 18 
 19 
 20 
 21 
 22 
 23 
 24 
 25 
 26 
 27 
 28 
 29 
 30 
 31 
 32 
 33 
 34 
 35 
 36 
 37 
 38 
 39 
 40 
 41 
 42 
 43 
 44 
 45 
 46 
 47 
 48 
 49 
 50 
 51 
 52 
 1616(m) cardbus 
  Data destinations - physical EMU outputs.
  Each destination has an enum mixer control to choose a data source
 0 
 1 
 2 
 3 
 4 
 5 
 6 
 7 
 8 
 9 
 10 
 11 
 12 
 13 
 14 
 15 
 16 
 17 
 18 
 19 
 20 
 21 
 22 
 23 
 1616(m) cardbus 
  Data destinations - HANA outputs going to Alice2 (audigy) for
    capture (EMU32 + I2S links)
  Each destination has an enum mixer control to choose a data source
 Limit: emu1010_output_dst, emu->emu1010.output_source 
 Limit: emu1010_output_dst, emu->emu1010.output_source 
 Limit: emu1010_input_dst, emu->emu1010.input_source 
 Limit: emu1010_input_dst, emu->emu1010.input_source 
 1616(m) cardbus 
 Limit: uinfo->value.enumerated.items = 4; 
 44100 
 Mute all 
 Default fallback clock 48kHz 
 Word Clock source, Internal 44.1kHz x1 
 Set LEDs on Audio Dock 
 Allow DLL to settle 
 Unmute all 
 48000 
 Mute all 
 Default fallback clock 48kHz 
 Word Clock source, Internal 48kHz x1 
 Set LEDs on Audio Dock 
 Allow DLL to settle 
 Unmute all 
 Take clock from SPDIF IN 
 Mute all 
 Default fallback clock 48kHz 
 Word Clock source, sync to SPDIF input 
 Set LEDs on Audio Dock 
 FIXME: We should set EMU_HANA_DOCK_LEDS_2_LOCK only when clock signal is present and valid 	
 Allow DLL to settle 
 Unmute all 
 Take clock from ADAT IN 
 Mute all 
 Default fallback clock 48kHz 
 Word Clock source, sync to ADAT input 
 Set LEDs on Audio Dock 
 FIXME: We should set EMU_HANA_DOCK_LEDS_2_LOCK only when clock signal is present and valid 	
 Allow DLL to settle 
   Unmute all 
 Limit: uinfo->value.enumerated.items = 2; 
 Limit: uinfo->value.enumerated.items = 2; 
	 If the capture source has changed,
	  update the capture volume from the cached value
	  for the particular source.
 Limit: uinfo->value.enumerated.items = 2; 
        emu->i2c_capture_volume 
 Mute input 
 Left 
 Left 
 Right 
 Right 
 Set source 
 Limit: emu->i2c_capture_volume 
        capture_source: uinfo->value.enumerated.items = 2 
 Limit: emu->i2c_capture_volume 
        capture_source: uinfo->value.enumerated.items = 2 
 Left 
 Right 
 Limit: emu->spdif_bits 
 PCM stream controls 
 Mutichannel PCM stream controls 
 Do nothing for Audigy 2 ZS Notebook 
 workaround for too low volume on Audigy due to 16bit24bit conversion 
 FIXME: better to use a cached version 
 no AC97 mono, surround, centerlfe 
 MasterPCM controls on ac97 of Audigy has no effect 
		 On the Audigy2 the AC97 playback is piped into
 remove unused AC97 capture controls 
 use conventional names 
 "Wave Capture Volume", "PCM Capture Volume", 
"Analog Mix Capture Volume","OLD Analog Mix Capture Volume",
		 On the Audigy2 ZS Notebook
		 On the Audigy2 the AC97 playback is piped into
 we don't need VRA 
 FIXME: get rid of ugly gotos.. 
 set master volume to 0 dB 
 set capture source to mic 
 set mono output (TAD) to mic 
			
			  Credits for cards based on STAC9758:
			    James Courtier-Dutton <James@superbug.demon.co.uk>
			    Voluspa <voluspa@comhem.se>
 remove unused AC97 controls 
 SB Live! Platinum CT4760P 
 Audigy 4 Pro 
 initialize the routing and volume table for each pcm playback stream 
 initialize the routing and volume table for the multichannel playback stream 
 FIXME: APS has these controls? 
 sb live! and audigy 
 Disable the snd_audigy_spdif_shared_spdif 
 sb live! 
 P16V 
 1616(m) cardbus 
 all other e-mu cards for now 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
                    Creative Labs, Inc.
   Routines for effect processor FX8010
   Copyright (c) by James Courtier-Dutton <James@superbug.co.uk>
   	Added EMU 1010 support.
   BUGS:
     --
   TODO:
     --
 for testing purposes - digital out -> capture 
 for testing purposes - set SPDIF to AC3 output 
 for testing purposes - feed the front signal to CenterLFE outputs 
   Tables
 0x00  "PCM Left",
 0x01  "PCM Right",
 0x02  "PCM Surround Left",
 0x03  "PCM Surround Right",
 0x04  "MIDI Left",
 0x05  "MIDI Right",
 0x06  "Center",
 0x07  "LFE",
 0x08  NULL,
 0x09  NULL,
 0x0a  NULL,
 0x0b  NULL,
 0x0c  "MIDI Reverb",
 0x0d  "MIDI Chorus",
 0x0e  NULL,
 0x0f  NULL
 0x00  "AC97 Left",
 0x01  "AC97 Right",
 0x02  "TTL IEC958 Left",
 0x03  "TTL IEC958 Right",
 0x04  "Zoom Video Left",
 0x05  "Zoom Video Right",
 0x06  "Optical IEC958 Left",
 0x07  "Optical IEC958 Right",
 0x08  "LineMic 1 Left",
 0x09  "LineMic 1 Right",
 0x0a  "Coaxial IEC958 Left",
 0x0b  "Coaxial IEC958 Right",
 0x0c  "LineMic 2 Left",
 0x0d  "LineMic 2 Right",
 0x0e  NULL,
 0x0f  NULL
 0x00  "AC97 Left",
 0x01  "AC97 Right",
 0x02  "Audigy CD Left",
 0x03  "Audigy CD Right",
 0x04  "Optical IEC958 Left",
 0x05  "Optical IEC958 Right",
 0x06  NULL,
 0x07  NULL,
 0x08  "LineMic 2 Left",
 0x09  "LineMic 2 Right",
 0x0a  "SPDIF Left",
 0x0b  "SPDIF Right",
 0x0c  "Aux2 Left",
 0x0d  "Aux2 Right",
 0x0e  NULL,
 0x0f  NULL
 0x00  "AC97 Left",
 0x01  "AC97 Right",
 0x02  "Optical IEC958 Left",
 0x03  "Optical IEC958 Right",
 0x04  "Center",
 0x05  "LFE",
 0x06  "Headphone Left",
 0x07  "Headphone Right",
 0x08  "Surround Left",
 0x09  "Surround Right",
 0x0a  "PCM Capture Left",
 0x0b  "PCM Capture Right",
 0x0c  "MIC Capture",
 0x0d  "AC97 Surround Left",
 0x0e  "AC97 Surround Right",
 0x0f  NULL,
 0x10  NULL,
 0x11  "Analog Center",
 0x12  "Analog LFE",
 0x13  NULL,
 0x14  NULL,
 0x15  NULL,
 0x16  NULL,
 0x17  NULL,
 0x18  NULL,
 0x19  NULL,
 0x1a  NULL,
 0x1b  NULL,
 0x1c  NULL,
 0x1d  NULL,
 0x1e  NULL,
 0x1f  NULL,
 0x00  "Digital Front Left",
 0x01  "Digital Front Right",
 0x02  "Digital Center",
 0x03  "Digital LEF",
 0x04  "Headphone Left",
 0x05  "Headphone Right",
 0x06  "Digital Rear Left",
 0x07  "Digital Rear Right",
 0x08  "Front Left",
 0x09  "Front Right",
 0x0a  "Center",
 0x0b  "LFE",
 0x0c  NULL,
 0x0d  NULL,
 0x0e  "Rear Left",
 0x0f  "Rear Right",
 0x10  "AC97 Front Left",
 0x11  "AC97 Front Right",
 0x12  "ADC Capture Left",
 0x13  "ADC Capture Right",
 0x14  NULL,
 0x15  NULL,
 0x16  NULL,
 0x17  NULL,
 0x18  NULL,
 0x19  NULL,
 0x1a  NULL,
 0x1b  NULL,
 0x1c  NULL,
 0x1d  NULL,
 0x1e  NULL,
 0x1f  NULL,
 dB gain = (float) 20  log10( float(db_table_value)  0x8000000 ) 
 EMU10k1EMU10k2 DSP control db gain 
 EMU10K1 basstreble db gain 
    controls
    Interrupt handler
 irq ptr can be removed from list 
  EMU10K1 effect manager
 FIXME: we need to check the WRITE access 
 inverted, we want to write new value in gpr_ctl_put() 
 overwrite 
	 stop FX processor - this may be dangerous, but it's better to miss
 ok, do the main job 
 start FX processor when the DSP code is updated 
 ok, do the main job 
 remove 
 FIXME: we need to add universal code to the PCM transfer routine 
  Used for emu1010 - conversion from 32-bit capture inputs from HANA
  to 2 x 16-bit registers in audigy - their values are read via DMA.
  Conversion is performed by Audigy DSP instructions of FX8010.
  initial DSP configuration for Audigy
 we reserve 10 voices 
 clear free GPRs 
 clear TRAM data & address lines 
 stop FX processor 
	 PCM front Playback Volume (independent from stereo mix)
	  playback = 0 + ( gpr  FXBUS_PCM_LEFT_FRONT >> 31)
	  where gpr contains attenuation from corresponding mixer control
	  (snd_emu10k1_init_stereo_control)
 PCM Surround Playback (independent from stereo mix) 
 PCM Side Playback (independent from stereo mix) 
 PCM Center Playback (independent from stereo mix) 
 PCM LFE Playback (independent from stereo mix) 
	
	  Stereo Mix
 Wave (PCM) Playback Volume (will be renamed later) 
 Synth Playback 
 Wave (PCM) Capture 
 Synth Capture 
	
	  inputs
 emu1212 DSP 0 and DSP 1 Capture 
 Note:JCD:No longer bit shift lower 16bits to upper 16bits of 32bit value. 
 AC'97 Playback Volume - used only for mic (renamed later) 
 AC'97 Capture Volume - used only for mic 
 mic capture buffer 	
 Audigy CD Playback Volume 
 Audigy CD Capture Volume 
 Optical SPDIF Playback Volume 
 Optical SPDIF Capture Volume 
 Line2 Playback Volume 
 Line2 Capture Volume 
 Philips ADC Playback Volume 
 Philips ADC Capture Volume 
 Aux2 Playback Volume 
 Aux2 Capture Volume 
 Stereo Mix Front Playback Volume 
 Stereo Mix Surround Playback 
 Stereo Mix Center Playback 
 Center = sub = Left2 + Right2 
 Stereo Mix LFE Playback 
 Stereo Mix Side Playback 
	
	  outputs
	
	   Process tone control
 left 
 right 
 rear left 
 rear right 
 center 
 LFE 
 side left 
 side right 
 frontrearcenter-lfeside 
 leftright 
 center 
 Master volume (will be renamed later) 
 analog speakers 
 headphone 
 digital outputs 
 A_PUT_STEREO_OUTPUT(A_EXTOUT_FRONT_L, A_EXTOUT_FRONT_R, playback + SND_EMU10K1_PLAYBACK_CHANNELS); 
 EMU1010 Outputs from PCM Front, Rear, Center, LFE, Side 
 IEC958 Optical Raw Playback Switch  
 Due to a SPDIF output bug on some Audigy cards, this code delays the Right channel by 1 sample 
 ADC buffer 
 Capture 16 (originally 8) channels of S32_LE sound 
			
			dev_dbg(emu->card->dev, "emufx.c: gpr=0x%x, tmp=0x%x\n",
			       gpr, tmp);
 For the EMU1010: How to get 32bit values from the DSP. High 16bits into L, low 16bits into R. 
			 A_P16VIN(0) is delayed by one sample,
			  so all other A_P16VIN channels will need to also be delayed
 Left ADC in. 1 of 2 
 Right ADC in 1 of 2 
			 Delaying by one sample: instead of copying the input
			  value A_P16VIN to output A_FXBUS2 as in the first channel,
			  we use an auxiliary register, delaying the value by one
			  sample
 For 96kHz mode 
 Left ADC in. 2 of 2 
 Right ADC in 2 of 2 
			 Pavel Hofman - we still have voices, A_FXBUS2s, and
			  A_P16VINs available -
			  let's add 8 more capture channels - total of 16
 EFX capture - capture the 16 EXTINs 
 Capture 16 channels of S16_LE sound 
 JCD test 
	
	  ok, set up done..
 clear remaining instruction memory 
 support TLV 
 clear again 
  initial DSP configuration for Emu10k1
 when volume = max, then copy only to avoid volume modification 
 with iMAC0 (negative values) 
 clear free GPRs 
 clear TRAM data & address lines 
 we have 12 inputs 
 we have 6 playback channels and tone control doubles 
 we need 4 temporary GPR 
 from 0x8c to 0xff is the area for tone control 
 stop FX processor 
	
	   Process FX Buses
 SPDIF left 
 SPDIF right 
 Raw SPDIF PCM 
 skip at 01 to 22 
 skip at 06 to 22 
 skip at 0a to 24 
 if the trigger flag is not set, skip 
 00:  OP(icode, &ptr, iMAC0, C_00000000, GPR(ipcm->gpr_trigger), C_00000000, C_00000000);
 01:  OP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_ZERO, GPR(gpr + 6));
 if the running flag is set, we're running 
 02:  OP(icode, &ptr, iMAC0, C_00000000, GPR(ipcm->gpr_running), C_00000000, C_00000000);
 03:  OP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_NONZERO, C_00000004);
 wait until ((GPR_DBAC>>11) & 0x1f) == 0x1c) 
 04:  OP(icode, &ptr, iANDXOR, GPR(tmp + 0), GPR_DBAC, GPR(gpr + 4), C_00000000);
 05:  OP(icode, &ptr, iMACINT0, C_00000000, GPR(tmp + 0), C_ffffffff, GPR(gpr + 5));
 06:  OP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_NONZERO, GPR(gpr + 7));
 07:  OP(icode, &ptr, iACC3, GPR(gpr + 12), C_00000010, C_00000001, C_00000000);
 08:  OP(icode, &ptr, iANDXOR, GPR(ipcm->gpr_running), GPR(ipcm->gpr_running), C_00000000, C_00000001);
 09:  OP(icode, &ptr, iACC3, GPR(gpr + 12), GPR(gpr + 12), C_ffffffff, C_00000000);
 0a:  OP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_NONZERO, GPR(gpr + 11));
 0b:  OP(icode, &ptr, iACC3, GPR(gpr + 12), C_00000001, C_00000000, C_00000000);
 0c:  OP(icode, &ptr, iANDXOR, GPR(tmp + 0), ETRAM_DATA(ipcm->etram[0]), GPR(gpr + 0), C_00000000);
 0d:  OP(icode, &ptr, iLOG, GPR(tmp + 0), GPR(tmp + 0), GPR(gpr + 3), C_00000000);
 0e:  OP(icode, &ptr, iANDXOR, GPR(8), GPR(tmp + 0), GPR(gpr + 1), GPR(gpr + 2));
 0f:  OP(icode, &ptr, iSKIP, C_00000000, GPR_COND, CC_REG_MINUS, C_00000001);
 10:  OP(icode, &ptr, iANDXOR, GPR(8), GPR(8), GPR(gpr + 1), GPR(gpr + 2));
 11:  OP(icode, &ptr, iANDXOR, GPR(tmp + 0), ETRAM_DATA(ipcm->etram[1]), GPR(gpr + 0), C_00000000);
 12:  OP(icode, &ptr, iLOG, GPR(tmp + 0), GPR(tmp + 0), GPR(gpr + 3), C_00000000);
 13:  OP(icode, &ptr, iANDXOR, GPR(9), GPR(tmp + 0), GPR(gpr + 1), GPR(gpr + 2));
 14:  OP(icode, &ptr, iSKIP, C_00000000, GPR_COND, CC_REG_MINUS, C_00000001);
 15:  OP(icode, &ptr, iANDXOR, GPR(9), GPR(9), GPR(gpr + 1), GPR(gpr + 2));
 16:  OP(icode, &ptr, iACC3, GPR(tmp + 0), GPR(ipcm->gpr_ptr), C_00000001, C_00000000);
 17:  OP(icode, &ptr, iMACINT0, C_00000000, GPR(tmp + 0), C_ffffffff, GPR(ipcm->gpr_size));
 18:  OP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_MINUS, C_00000001);
 19:  OP(icode, &ptr, iACC3, GPR(tmp + 0), C_00000000, C_00000000, C_00000000);
 1a:  OP(icode, &ptr, iACC3, GPR(ipcm->gpr_ptr), GPR(tmp + 0), C_00000000, C_00000000);
 1b:  OP(icode, &ptr, iACC3, GPR(ipcm->gpr_tmpcount), GPR(ipcm->gpr_tmpcount), C_ffffffff, C_00000000);
 1c:  OP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_NONZERO, C_00000002);
 1d:  OP(icode, &ptr, iACC3, GPR(ipcm->gpr_tmpcount), GPR(ipcm->gpr_count), C_00000000, C_00000000);
 1e:  OP(icode, &ptr, iACC3, GPR_IRQ, C_80000000, C_00000000, C_00000000);
 1f:  OP(icode, &ptr, iANDXOR, GPR(ipcm->gpr_running), GPR(ipcm->gpr_running), C_00000001, C_00010000);
 20:  OP(icode, &ptr, iANDXOR, GPR(ipcm->gpr_running), GPR(ipcm->gpr_running), C_00010000, C_00000001);
 21:  OP(icode, &ptr, iSKIP, C_00000000, C_7fffffff, C_7fffffff, C_00000002);
 22:  OP(icode, &ptr, iMACINT1, ETRAM_ADDR(ipcm->etram[0]), GPR(gpr + 8), GPR_DBAC, C_ffffffff);
 23:  OP(icode, &ptr, iMACINT1, ETRAM_ADDR(ipcm->etram[1]), GPR(gpr + 9), GPR_DBAC, C_ffffffff);
 24: 
 Wave Playback Volume 
 Wave Surround Playback Volume 
 Wave CenterLFE Playback Volume 
 Wave Capture Volume + Switch 
 Synth Playback Volume 
 Synth Capture Volume + Switch 
 Surround Digital Playback Volume (renamed later without Digital) 
 Surround Capture Volume + Switch 
 Center Playback Volume (renamed later without Digital) 
 LFE Playback Volume + Switch (renamed later without Digital) 
 Front Playback Volume 
 Front Capture Volume + Switch 
	
	   Process inputs
 AC'97 Playback Volume 
 AC'97 Capture Volume 
 IEC958 TTL Playback Volume 
 IEC958 TTL Capture Volume + Switch 
 Zoom Video Playback Volume 
 Zoom Video Capture Volume + Switch 
 IEC958 Optical Playback Volume 
 IEC958 Optical Capture Volume 
 Line LiveDrive Playback Volume 
 Line LiveDrive Capture Volume + Switch 
 IEC958 Coax Playback Volume 
 IEC958 Coax Capture Volume + Switch 
 Line LiveDrive Playback Volume 
 Line LiveDrive Capture Volume 
	
	   Process tone control
 left 
 right 
 rear left 
 rear right 
 center 
 LFE 
 frontrearcenter-lfe 
 leftright 
 center 
	
	   Process outputs
 AC'97 Playback Volume 
 IEC958 Optical Raw Playback Switch 
 Headphone Playback Volume 
 AC'97 can have also Headphone control 
 EFX capture - capture the 16 EXTINS 
		 On the Live! 5.1, FXBUS2(1) and FXBUS(2) are shared with EXTOUT_ACENTER
		  and EXTOUT_ALFE, so we can't connect inputs to them for multitrack recording.
		 
		  Since only 14 of the 16 EXTINs are used, this is not a big problem.  
		  We route AC97L and R to FX capture 14 and 15, SPDIF CD in to FX capture 
		  0 and 3, then the rest of the EXTINs to the corresponding FX capture 
		  channel.  Multitrack recorders will still see the centerlfe output signal 
		  on the second and third channels.
 clear remaining instruction memory 
 support TLV 
 clear again 
 stop processor 
 FIXME: who use them? 
 size is in samples 
  saverestore GPR, TRAM and codes
 set up TRAM 
 start FX processor when the DSP code is updated 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
                    Creative Labs, Inc.
   Routines for IRQ control of EMU10K1 chips
   BUGS:
     --
   TODO:
     --
 Full Loop 
 dev_dbg(emu->card->dev, "status2=0x%x\n", status2); 
 dev_info(emu->card->dev, "capture int found\n"); 
 dev_info(emu->card->dev, "capture period_elapsed\n"); 
 ack all 
make sure any interrupts we don't handle are disabled:
 ack all 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
   Copyright (c) by Takashi Iwai <tiwai@suse.de>
   EMU10K1 memory page allocation (PTB area)
 page arguments of these two macros are Emu page (4096 bytes), not like
  aligned pages in others
 get aligned page from offset address 
 get offset address from aligned page 
 fill PTB entrie(s) corresponding to page with addr 
 fill PTB entrie(s) corresponding to page with silence pointer 
 fill PTB entries -- we need to fill UNIT_PAGES entries 
 do not increment ptr 
 PAGE_SIZE 
 initialize emu10k1 part 
  search empty region on PTB with the given size
  if an empty region is found, return the page and store the next mapped block
  in nextp
  if not found, return a negative error code.
 we look for the maximum empty hole 
  map a memory block onto emu10k1's PTB
  call with memblk_lock held
 not found 
 insert this block in the proper position of mapped list 
 append this as a newest block in order list 
 fill PTB 
  unmap the block
  return the size of resultant empty pages
  call with memblk_lock held
 calculate the expected size of empty region 
 remove links 
 clear PTB 
 return the new empty size 
  search empty pages with the given size, and create a memory block
  unlike synth_alloc the memory block is aligned to the page start
 create a new memory block 
 set aligned offset 
  check if the given pointer is valid for pages
  map the given memory block on PTB.
  if the block is already mapped, update the link order.
  if no empty pages are found, tries to release unused memory blocks
  and retry the mapping.
 update order link 
 no enough page - try to unmap some blocks 
 starting from the oldest block 
 ok the empty region is enough large 
  page allocation for DMA
	 fill buffer addresses but pointers are not stored so that
	  snd_free_pci_page() is not called in in synth_free()
 set PTB entries 
 do not unmap this block! 
  release DMA buffer from page table
  allocate DMA pages, widening the allocation if necessary
  See the comment above snd_emu10k1_detect_iommu() in emu10k1_main.c why
  this might be needed.
  If you modify this function check whether __synth_free_pages() also needs
  changes.
		
		  The device has been observed to accesses up to 256 extra
		  bytes, but use 1k to be safe.
  memory allocation using multiple pages (for synth)
  Unlike the DMA allocation above, non-contiguous pages are assined.
  allocate a synth sample area
  free a synth sample area
 check new allocation range 
 first page was already allocated 
 last page was already allocated 
 release allocated pages 
		
		  please keep me in sync with logic in
		  snd_emu10k1_alloc_pages_maybe_wider()
  allocate kernel pages
 allocate kernel pages 
 release allocated pages 
  free pages
 calculate buffer pointer from offset address 
  bzero(blk + offset, size)
  copy_from_user(blk + offset, data, size)
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.
  @File	cthw20k2.c
  @Brief
  This file contains the implementation of hardware access method for 20k2.
  @Author	Liu Chun
  @Date 	May 14 2008
 for i2c 
  Type definition block.
  The layout of control structures can be directly applied on 20k2 chip.
  SRC control block definitions.
 SRC resource control block 
 Mixer Parameter Ring ram Low and Hight register.
 SRC resource register dirty flags 
 Clear Z-Buffers 
 SRC manager control block 
 SRCIMP manager control block 
 SRCIMP manager register dirty flags 
  Function implementation block.
 Clear Z-Buffer registers 
		 Take the parameter mixer resource in the same group as that
		  the idx src is in for simplicity. Unlike src, all conjugate
		  parameter mixer resources must be programmed for
 Write srccf register 
  AMIXER control block definitions.
 AMIXER resource register dirty flags 
 AMIXER resource control block 
  DAIO control block definitions.
 Receiver Sample Rate Tracker Control register 
 DAIO Receiver register dirty flags 
 DAIO Receiver control block 
 Audio Input Mapper RAM 
 Audio Transmitter Control and Status register 
 XDIF Transmitter register dirty flags 
 XDIF Transmitter control block 
 XDIF Transmitter Channel Status Low Register 
 Audio Receiver Control register 
 DAIO manager register dirty flags 
 DAIO manager control block 
 SPDIF SPOSx 
 SPDIF output 
 CDIF 
 Non-audio 
 Non-audio 
 I2S output 
idx %= 4; 
 Timer interrupt 
 Card hardware initialization block 
 master sample rate in rsrs 
 master sample rate in rsrs 
 the input source of ADC 
 boost mic by 20db if input is microphone 
 master sample rate in rsrs 
	 Program I2S with proper sample rate and enable the correct I2S
 PCM4220 on Titanium HD is different. 
		 Specify all playing 96khz
		  EA [0]	- Enabled
		  RTA [4:5]	- 96kHz
		  EB [8]	- Enabled
		  RTB [12:13]	- 96kHz
		  EC [16]	- Enabled
		  RTC [20:21]	- 96kHz
		  ED [24]	- Enabled
 This comment looks wrong since loop is over 4  
 channels and emu20k2 supports 4 spdif IOs.     
 1st 3 channels are SPDIFs (SB0960) 
			 Initialize the SPDIF Out Channel status registers.
			  The value specified here is based on the typical
			  values provided in the specification, namely: Clock
			  Accuracy of 1000ppm, Sample Rate of 48KHz,
			  unspecified source number, Generation status = 1,
			  Category code = 0x12 (Digital Signal Mixer),
			  Mode = 0, Emph = 0, Copy Permitted, AN = 0
			  (indicating that we're transmitting digital audio,
 Default to 48kHz 
 Again, loop is over 4 channels not 5. 
 Next 5 channels are I2S (SB0960) 
 Four channels per sample period 
 FIXME: check this against the chip spec 
 TRANSPORT operations 
 Set up device page table 
 32-bit, 4k-size page 
 64bit address 
 Write page table physical address to all PTPAL registers 
 Enable virtual memory transfer 
 Enable transport bus master and queueing of request 
 Enable transport ring 
 Card initialization 
 DAC operations 
 I2C status 
 Used with I2C_IF_STATUS 
 Used with I2C_IF_STATUS 
 Send keys for forced BIOS mode 
 Check whether the chip is unlocked 
 Write twice 
 Direct control mode 
 I2C id 
 I2C mode 
 Force a read operation 
 Dummy write to trigger the write operation 
 This is the real data 
 Mode Control 1 
 Mode Control 2 
 Mode Control 3 
 Filter Control 
 Invert Control 
 Mixing Control Pair 1 
 Vol Control A1 
 Vol Control B1 
 Mixing Control Pair 2 
 Vol Control A2 
 Vol Control B2 
 Mixing Control Pair 3 
 Vol Control A3 
 Vol Control B3 
 Mixing Control Pair 4 
 Vol Control A4 
 Vol Control B4 
 Single Speed Mode 0-50kHz 
 Double Speed Mode 50-100kHz 
 Quad Speed Mode 100-200kHz 
 Set DAC reset bit as output 
		 Reset DAC twice just in-case the chip
	 Note: Every I2C write must have some delay.
 ADC operations 
 Titanium HD has two ADC chips, one for line in and one 
 for MIC. We don't need to switch the ADC input. 
 Link L+R gain... 
 ...so there should be no need for the following. 
 Mic, 20dB 
 Line-in, 0dB 
  Set ADC reset bit as output 
 Initialize I2C 
 Reset the ADC (reset is active low). 
 Set up the PCM4220 ADC on Titanium HD 
 Single Speed Mode 32-50kHz 
 Double Speed Mode 50-108kHz 
 Quad Speed Mode 108kHz-216kHz 
 Return the ADC to normal operation. 
 I2C write to register offset 0x0B to set ADC LRCLK polarity 
 invert bit, interface format to I2S, word length to 24-bit, 
 enable ADC high pass filter. Fixes bug 5323?		
 Set the master mode (256fs) 
 slave mode, 128x oversampling 256fs 
 slave mode, 64x oversampling, 256fs 
 Configure GPIO bit 14 change to line-inmic-in 
 Mute line and headphones (intended for anti-pop). 
 Unmute line and headphones. 
 Mic, 0dB 
 FP Mic, 0dB 
 Aux Ext, 0dB 
 Set DMA transfer mask 
 Switch to 20k2 mode from UAA mode. 
error3:
	iounmap((void )hw->mem_base);
 disable transport bus master and queueing of request 
 disable pll 
 TODO: Disable interrupt and so on... 
	 Get PCI io portmemory base address and
 PLL init 
 kick off auto-init 
 Reset all global pending interrupts 
 Reset all SRC pending interrupts 
 TODO: detect the card ID and configure GPIO accordingly. 
 Configures GPIO (0xD802 0x98028) 
hw_write_20kx(hw, GPIO_CTRL, 0x7F07);
 Configures GPIO (SB0880) 
hw_write_20kx(hw, GPIO_CTRL, 0xFF07);
 Enable audio ring 
 Enables input from the audio ring 
 Re-initialize card hardware. 
 SPDX-License-Identifier: GPL-2.0-only
  PCM timer handling on ctxfi
 timer instance -- assigned to each PCM stream 
 timer instance manager 
 global timer lock (for xfitimer) 
 lock for instance list 
 current wallclock 
 in IRQ handling 
 need to reprogram the internval 
 global timer running 
  system-timer-based updates
	 Add extra HZ51000 to avoid overrun issue when recording
  Handling multiple streams using a global emu20k1 timer irq
  reprogram the timer interval;
  checks the running instance list and determines the next timer interval.
  also updates the each stream position, returns the number of streams
  to call snd_pcm_period_elapsed() appropriately
  call this inside the lock and irq disabled
 clear flag 
 pending to the next irq 
 clear flag 
 look through the instance list and call period_elapsed if needed 
 Handle timer-interrupt 
 startstop the timer 
 reached from IRQ handler; let it handle later 
  timer instance
 to be sure 
  timer manager
 Interval timer interrupt 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.
  @File    ctatc.c
  @Brief
  This file contains the implementation of the device resource management
  object.
  @Author Liu Chun
  @Date Mar 28 2008
 2^(-0.5) in 14-bit floating format 
 terminator 
 terminator 
 20k1 models 
 20k2 models 
  Only mono and interleaved modes are supported now.
  Always allocates a contiguous channel block.
 get pitch and convert to fixed-point 8.24 format. 
 0.26 <= pitch <= 1.72 
 pitch == 1.8375 
 pitch == 2 
 0 <= pitch <= 8 
 first release old resources 
 Get SRC resource 
 Get AMIXER resource 
 Set up device virtual mem map 
 Connect resources 
 Undo device virtual mem map 
 get pitch and convert to fixed-point 8.24 format. 
 FIXME: do we really need SRC here if pitch==1 
			 Need two-stage SRCs, SRCIMPs and
			 Need one-stage SRCs, SRCIMPs and
 first release old resources 
	 The numbers of converting SRCs and SRCIMPs should be determined
 get pitch and convert to fixed-point 8.24 format. 
		 Need extra AMIXERs and SRCIMPs for special treatment
 Allocate SRCs for sample rate conversion if needed 
 Allocate AMIXERs for routing SRCs of conversion if needed 
 Allocate a SUM resource to mix all input channels together 
 Allocate SRCIMP resources 
 Allocate a SRC for writing data to host memory 
 Set up device virtual mem map 
 Get needed resources. 
 Connect resources 
		 Special connection for interleaved
 Set up converting SRCs 
  Set up recording SRC 
 Disable relevant SRCs firstly 
 Enable SRCs respectively 
 Enable relevant SRCs synchronously 
 first release old resources 
 Get SRC resource 
 Get AMIXER resource 
 Set up device virtual mem map 
	 Configure SPDIFOO and PLL to passthrough mode;
 Get needed resources. 
 Connect resources 
 Connect to SPDIFOO 
 Restore PLL to atc->rsr if needed. 
 disconnect internal mixer objects 
 Destroy internal mixer objects 
 Destroy device virtual memory manager object 
 Initialize card hardware. 
 Actually disable SRCs 
 Synchronously enable SRCs 
 Titanium HD has a dedicated ADC for the Mic. 
 Re-initialize card hardware. 
 Get resources 
 Build topology 
 Do hardware resume. 
   ct_atc_create - create and initialize a hardware manager
   @card: corresponding alsa card object
   @pci: corresponding kernel pci device object
   @rsr: reference sampling rate
   @msr: master sampling rate
   @chip_type: CHIPTYP enum values
   @ssid: vendor ID (upper 16 bits) and device ID (lower 16 bits)
   @ratc: return created object address in it
   Creates and initializes a hardware manager.
   Creates kmallocated ct_atc structure. Initializes hardware.
   Returns 0 if succeeds, or negative error code if fails.
 Set operations 
 Find card model 
 Set up device virtual memory management object 
 Create all atc hw devices 
 Get resources 
 Build topology 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.
  @File	ctpcm.c
  @Brief
  This file contains the definition of the pcm device functions.
  @Author	Liu Chun
  @Date 	Apr 2 2008
 Hardware descriptions for playback 
 Hardware descriptions for capture 
 pcm playback operations 
 TODO: Notify mixer inactive. 
 The ct_atc_pcm object will be freed by runtime->private_free 
 clear previous resources 
 clear previous resources 
 Read out playback position 
 pcm capture operations 
 The ct_atc_pcm object will be freed by runtime->private_free 
 TODO: Notify mixer inactive. 
 Read out playback position 
 PCM operators for playback 
 PCM operators for capture 
 Create ALSA pcm device 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.
  @File	cthardware.c
  @Brief
  This file contains the implementation of hardware access methord.
  @Author	Liu Chun
  @Date 	Jun 26 2008
 20k1 device 
 20k2 device 
 @field should always be greater than 0 
 @field should always be greater than 0 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.
  @File	ctamixer.c
  @Brief
  This file contains the implementation of the Audio Mixer
  resource management object.
  @Author	Liu Chun
  @Date 	May 21 2008
 y is a 14-bit immediate constant 
 Program master and conjugate resources 
 Set amixer specific operations 
 Allocate mem for amixer resource 
	 Check whether there are sufficient
 SUM resource management 
 Allocate mem for sum resource 
 Check whether there are sufficient sum resources to meet request. 
 SPDX-License-Identifier: GPL-2.0-only
  xfi linux driver.
  Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.
 only X-Fi is supported, so... 
 Create alsa devices supported by this card 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.
  @File    ctvmem.c
  @Brief
  This file contains the implementation of virtual memory management object
  for card device.
  @Author Liu Chun
  @Date Apr 1 2008
  Find or create vm block based on requested @size.
  @size must be page aligned.
 found a block that is big enough 
 Move the vm node from unused list to used list directly 
 found a position 
 Map host addr (kmallocedvmalloced) to device logical addr. 
 do unmapping 
  return the host physical addr of the @index-th device
  page table page on success, or ~0UL on failure.
  The first returned ~0UL indicates the termination.
 Allocate page table pages 
 no page table pages are allocated 
 The caller must ensure no mapping pages are being used
 free used and unused list nodes 
 free allocated page table pages 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.
  @File	ctmixer.c
  @Brief
  This file contains the implementation of alsa mixer device functions.
  @Author	Liu Chun
  @Date 	May 28 2008
 volume control mixers 
 this should always be the last one 
 volume control mixers 
 switch control mixers 
 this should always be the last one 
 FIXME: this static looks like it would fail if more than one card was 
 installed. 
 not used 
 Map integer value ranging from 0 to 65535 to 14-bit float value ranging
 i <= 6 
 not used 
 Synchronize MasterPCM playback AMIXERs. 
 Do changes in mixer. 
 Do changes out of mixer. 
 Create snd kcontrol instances on demand 
 Allocate sum resources for mixer obj 
 Allocate amixer resources for mixer obj 
 Allocate mem for mixer obj 
 Build topology from destination to source 
 Set up Master mixer 
 Set up Wave-out mixer 
 Set up SPDIF-out mixer 
 Set up PCM-in mixer 
 Set up Line-in mixer 
 Set up Mic-in mixer 
 Set up SPDIF-in mixer 
 Set up Master recording mixer 
 Set up PCM-in recording mixer 
 Set up Line-in recording mixer 
 Set up Mic-in recording mixer 
 Set up SPDIF-in recording mixer 
 resume topology and volume gain. 
 resume switch state. 
 Release amixer resources 
 Release sum resources 
 Release mem assigned to mixer object 
 Allocate mem for mixer obj 
 Set operations 
 Allocate chip resources for mixer obj 
 Build internal mixer topology 
 Create snd kcontrol instances on demand 
 vol_ctl.device = swh_ctl.device = device;  
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.
  @File	ctresource.c
  @Brief
  This file contains the implementation of some generic helper functions.
  @Author	Liu Chun
  @Date 	May 15 2008
 Resource allocation based on bit-map management mechanism 
 Check whether there are sufficient resources to meet request. 
 found sufficient contiguous resources 
 Can not find sufficient contiguous resources 
 Mark the contiguous bits in resource bit-map as used 
 Mark the contiguous bits in resource bit-map as used 
 SRC channel is at Audio Ring slot 1 every 16 slots. 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.
  @File	ctdaio.c
  @Brief
  This file contains the implementation of Digital Audio Input Output
  resource management object.
  @Author	Liu Chun
  @Date 	May 23 2008
	 Actually, this is not the resource index of DAIO.
	  For DAO, it is the input mapper index. And, for DAI,
 Program master and conjugate resources 
 Program master and conjugate resources 
 Program conjugate resources 
 Program conjugate resources 
 Set daio->rsclr->ops to daio specific ones 
 default to disabling control of a SRC 
 default to disabling SRT 
 Check whether there are sufficient daio resources to meet request. 
 Allocate mem for daio resource 
 free daio input mapper list 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.
  @File	ctimap.c
  @Brief
  This file contains the implementation of generic input mapper operations
  for input mapper management.
  @Author	Liu Chun
  @Date 	May 23 2008
 found a position in list 
 entry is the only one node in mappers list 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.
  @File	ctsrc.c
  @Brief
  This file contains the implementation of the Sample Rate Convertor
  resource management object.
  @Author	Liu Chun
  @Date 	May 13 2008
 Save dirty flags for conjugate resource programming 
 Program conjugate parameter mixer resources 
hw->src_set_sa(src->rsc.ctrl_blk, 0x100);
hw->src_set_la(src->rsc.ctrl_blk, 0x03ffffe0);
 Initialize src specific rsc operations 
 Set @intlv of the last SRC to NULL 
 Check whether there are sufficient src resources to meet request. 
 Allocate mem for master src resource 
 Disable all SRC resources. 
 SRCIMP resource manager operations 
 Program master and conjugate resources 
 Program master and conjugate resources 
 Reserve memory for imapper nodes 
 Set srcimp specific operations 
 Allocate mem for SRCIMP resource 
 Check whether there are sufficient SRCIMP resources. 
 free src input mapper list 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.
  @File	cthw20k1.c
  @Brief
  This file contains the implementation of hardware access methord for 20k1.
  @Author	Liu Chun
  @Date 	Jun 24 2008
  Type definition block.
  The layout of control structures can be directly applied on 20k2 chip.
  SRC control block definitions.
 SRC resource control block 
 Mixer Parameter Ring ram Low and Hight register.
 SRC resource register dirty flags 
 Clear Z-Buffers 
 SRC manager control block 
 SRCIMP manager control block 
 SRCIMP manager register dirty flags 
  Function implementation block.
 Clear Z-Buffer registers 
		 Take the parameter mixer resource in the same group as that
		  the idx src is in for simplicity. Unlike src, all conjugate
		  parameter mixer resources must be programmed for
 Write srccf register 
  AMIXER control block definitions.
 AMIXER resource register dirty flags 
 AMIXER resource control block 
 20k1 amixer does not have this field 
amixer_mgr_ctrl_blk_t blk;
	blk = kzalloc(sizeof(blk), GFP_KERNEL);
	if (!blk)
		return -ENOMEM;
kfree((amixer_mgr_ctrl_blk_t )blk);
  DAIO control block definitions.
 Receiver Sample Rate Tracker Control register 
 DAIO Receiver register dirty flags 
 DAIO Receiver control block 
 SPDIF Transmitter register dirty flags 
 SPDIF Transmitter control block 
 SPDIF Output Channel Status Register 
 Audio Input Mapper RAM 
 I2S TransmitterReceiver Control register 
 SPDIF Transmitter Control register 
 SPDIF Receiver Control register 
 DAIO manager register dirty flags 
 DAIO manager control block 
 SPDIF SRTs 
 I2S SRT 
 SPDIF SPOSx 
 SPDIF input 
 I2S input 
 SPDIF input 
 I2S input 
 SPDIF output 
 I2S output 
 SPDIF output 
 I2S output 
 SPDIF output 
 CDIF 
 Non-audio 
 Non-audio 
 Raw 
 I2S output 
idx %= 4; 
 Timer interrupt 
 Card hardware initialization block 
 master sample rate in rsrs 
 master sample rate in rsrs 
 the input source of ADC 
 boost mic by 20db if input is microphone 
 master sample rate in rsrs 
 Read I2S CTL.  Keep original value. 
i2sorg = hw_read_20kx(hw, I2SCTL);
 enable all audio out and I2S-D input 
	 Program I2S with proper master sample rate and enable
	 Enable SPDIF-out-A in fixed 24-bit data
 Disable all before doing any changes. 
 Enable SPDIF-in-A in fixed 24-bit data format. 
 Disable all before doing any changes. 
 TRANSPORT operations 
 Set up device page table 
 32-bit, 4k-size page 
 64bit address 
 Only 4k hw pages for simplicitiy 
 really needed? 
 Card initialization 
 DAC operations 
 write to i2c status control 
 To be effective, need to reset the DAC twice. 
 set gpio 
 SB055x, unmute outputs 
 set GPIO6 to low 
 set GPIO1 to high 
 mute outputs 
 write to i2c status control 
 unmute outputs 
 ADC operations 
 Digital IO 
	
	  check and set the following GPIO bits accordingly
	  ADC_Gain		= GPIO2
	  DRM_off		= GPIO3
	  Mic_Pwr_on		= GPIO7
	  Digital_IO_Sel	= GPIO8
	  Mic_Sw		= GPIO9
	  AuxMicLine_Sw	= GPIO12
 set to digital 
 i2c ready poll 
 set i2c access mode as Direct Control 
 Mic-in 
 Line-in 
 set to Digital 
 +12dB boost 
 +12dB boost 
 No boost 
 No boost 
 i2c ready poll 
 set i2c access mode as Direct Control 
 Mic-in 
 Line-in 
 +12dB boost 
 +12dB boost 
 No boost 
 No boost 
 default to analog 
 set GPIO7 to select Mic 
 set to Digital 
 i2c ready poll 
 write to i2c status control 
 SB073x and Vista compatible cards have no digit IO switch 
 By default, Hendrix card UAA Bar0 should be using memory... 
 Read current mode from Mode Change Register 
 Determine current mode... 
 Not in UAA mode currently. Return directly. 
 Set up X-Fi core PCI configuration space. 
 Switch to X-Fi config space with BAR0 exposed. 
 Copy UAA's BAR5 into X-Fi BAR0 
 Switch to X-Fi config space without BAR0 exposed. 
 Switch to X-Fi mode 
 Set DMA transfer mask 
 Switch to X-Fi mode from UAA mode if neeeded 
 disable transport bus master and queueing of request 
 disable pll 
 Get PCI io port base address and do Hendrix switch if needed. 
 PLL init 
 kick off auto-init 
 Enable audio ring 
 Reset all global pending interrupts 
 Reset all SRC pending interrupts 
 Detect the card ID and configure GPIO accordingly. 
 Enables input from the audio ring 
 Switch to UAA config space. 
 Re-initialize card hardware. 
 SPDX-License-Identifier: GPL-2.0-only
  C-Media CMI8788 driver - helper functions
  Copyright (c) Clemens Ladisch <clemens@ladisch.de>
	
	  Reading the status register also clears the bits, so we have to save
	  the read bits in status.
	
	  Check even after a timeout because this function should not require
	  the AC'97 interrupt to be enabled.
  About 10% of AC'97 register reads or writes fail to complete, but even those
  where the controller indicates completion aren't guaranteed to have actually
  happened.
  It's hard to assign blame to either the controller or the codec because both
  were made by C-Media ...
 require two "completed" writes, just to be sure 
 we require two consecutive reads of the same value 
			
			  Invert the register value bits to make sure that two
			  consecutive unsuccessful reads do not return the same
			  value.
	
	  Higher timeout to be sure: 200 us;
	  actual transaction should not need more than 40 us.
	
	  We need to wait AFTER initiating the SPI transaction,
	  otherwise read operations will not work.
 should not need more than about 300 us 
 wait for ACK 
 SPDX-License-Identifier: GPL-2.0-only
  card driver for the Xonar DGDGX
  Copyright (c) Clemens Ladisch <clemens@ladisch.de>
  Copyright (c) Roman Volkov <v1ron@mail.ru>
  Xonar DGDGX
  ------------
  CS4245 and CS4361 both will mute all outputs if any clock ratio
  is invalid.
  CMI8788:
    SPI 0 -> CS4245
    Playback:
    IS 1 -> CS4245
    IS 2 -> CS4361 (centerLFE)
    IS 3 -> CS4361 (surround)
    IS 4 -> CS4361 (front)
    Capture:
    IS ADC 1 <- CS4245
    GPIO 3 <- ?
    GPIO 4 <- headphone detect
    GPIO 5 -> enable ADC analog circuit for the left channel
    GPIO 6 -> enable ADC analog circuit for the right channel
    GPIO 7 -> switch green rear output jack between CS4245 and the first
              channel of CS4361 (mechanical relay)
    GPIO 8 -> enable output to speakers
  CS4245:
    input 0 <- mic
    input 1 <- aux
    input 2 <- front mic
    input 4 <- line
    DAC out -> headphones
    aux out -> front panel headphones
 save the initial state: codec version, registers 
	
	  Power up the CODEC internals, enable soft ramp & zero cross, work in
	  async. mode, enable aux output from DAC. Invert DAC output as in the
	  Windows driver.
 anti-pop delay, wait some time before enabling the output 
 SPDX-License-Identifier: GPL-2.0-only
  helper functions for Asus Xonar cards
  Copyright (c) Clemens Ladisch <clemens@ladisch.de>
 TODO: stop PCMs 
 SPDX-License-Identifier: GPL-2.0-only
  helper functions for HDMI models (Xonar HDAV1.3HDAV1.3 Slim)
  Copyright (c) Clemens Ladisch <clemens@ladisch.de>
 1 = non-audio 
 96000 
 ? 
 SPDX-License-Identifier: GPL-2.0-only
  C-Media CMI8788 driver - PCM code
  Copyright (c) Clemens Ladisch <clemens@ladisch.de>
 most DMA channels have a 16-bit counter for 32-bit words 
 the multichannel DMA channel has a 24-bit counter 
 48000 
 2 
 no spinlock, this read should be atomic 
 SPDX-License-Identifier: GPL-2.0-only
  card driver for models with PCM1796 DACs (Xonar D2D2XHDAV1.3STSTX)
  Copyright (c) Clemens Ladisch <clemens@ladisch.de>
  Xonar D2D2X
  ------------
  CMI8788:
    SPI 0 -> 1st PCM1796 (front)
    SPI 1 -> 2nd PCM1796 (surround)
    SPI 2 -> 3rd PCM1796 (centerLFE)
    SPI 4 -> 4th PCM1796 (back)
    GPIO 2 -> M0 of CS5381
    GPIO 3 -> M1 of CS5381
    GPIO 5 <- external power present (D2X only)
    GPIO 7 -> ALT
    GPIO 8 -> enable output to speakers
  CM9780:
    LINE_OUT -> input of ADC
    AUX_IN   <- aux
    VIDEO_IN <- CD
    FMIC_IN  <- mic
    GPO 0 -> route line-in (0) or AC97 output (1) to CS5381 input
  Xonar HDAV1.3 (Deluxe)
  ----------------------
  CMI8788:
    IC <-> PCM1796 (addr 1001100) (front)
    GPI 0 <- external power present
    GPIO 0 -> enable HDMI (0) or speaker (1) output
    GPIO 2 -> M0 of CS5381
    GPIO 3 -> M1 of CS5381
    GPIO 4 <- daughterboard detection
    GPIO 5 <- daughterboard detection
    GPIO 6 -> ?
    GPIO 7 -> ?
    GPIO 8 -> route input jack to line-in (0) or mic-in (1)
    UART <-> HDMI controller
  CM9780:
    LINE_OUT -> input of ADC
    AUX_IN <- aux
    CD_IN  <- CD
    MIC_IN <- mic
    GPO 0 -> route line-in (0) or AC97 output (1) to CS5381 input
  no daughterboard
  ----------------
    GPIO 4 <- 1
  H6 daughterboard
  ----------------
    GPIO 4 <- 0
    GPIO 5 <- 0
    IC <-> PCM1796 (addr 1001101) (surround)
        <-> PCM1796 (addr 1001110) (centerLFE)
        <-> PCM1796 (addr 1001111) (back)
  unknown daughterboard
  ---------------------
    GPIO 4 <- 0
    GPIO 5 <- 1
    IC <-> CS4362A (addr 0011000) (surround, centerLFE, back)
  Xonar Essence ST (Deluxe)STX (II)
  ----------------------------------
  CMI8788:
    IC <-> PCM1792A (addr 1001100)
        <-> CS2000 (addr 1001110) (ST only)
    ADC1 MCLK -> REF_CLK of CS2000 (ST only)
    GPI 0 <- external power present (STX only)
    GPIO 0 -> enable output to speakers
    GPIO 1 -> route HP to front panel (0) or rear jack (1)
    GPIO 2 -> M0 of CS5381
    GPIO 3 -> M1 of CS5381
    GPIO 4 <- daughterboard detection
    GPIO 5 <- daughterboard detection
    GPIO 6 -> ?
    GPIO 7 -> route output to speaker jacks (0) or HP (1)
    GPIO 8 -> route input jack to line-in (0) or mic-in (1)
  PCM1792A:
    SCK <- CLK_OUT of CS2000 (ST only)
  CM9780:
    LINE_OUT -> input of ADC
    AUX_IN <- aux
    MIC_IN <- mic
    GPO 0 -> route line-in (0) or AC97 output (1) to CS5381 input
  H6 daughterboard
  ----------------
  GPIO 4 <- 0
  GPIO 5 <- 0
  Xonar Xense
  -----------
  CMI8788:
    IC <-> PCM1796 (addr 1001100) (front)
        <-> CS4362A (addr 0011000) (surround, centerLFE, back)
        <-> CS2000 (addr 1001110)
    ADC1 MCLK -> REF_CLK of CS2000
    GPI 0 <- external power present
    GPIO 0 -> enable output
    GPIO 1 -> route HP to front panel (0) or rear jack (1)
    GPIO 2 -> M0 of CS5381
    GPIO 3 -> M1 of CS5381
    GPIO 4 -> enable output
    GPIO 5 -> enable output
    GPIO 6 -> ?
    GPIO 7 -> route output to HP (0) or speaker (1)
    GPIO 8 -> route input jack to mic-in (0) or line-in (1)
  CM9780:
    LINE_OUT -> input of ADC
    AUX_IN   <- aux
    VIDEO_IN <- ?
    FMIC_IN  <- mic
    GPO 0 -> route line-in (0) or AC97 output (1) to CS5381 input
    GPO 1 -> route mic-in from input jack (0) or front panel header (1)
 10011, ii, W=0 
 100111, 0, W=0 
 maps ALSA channel pair number to SPI output 
 set ATLD before ATLATR 
 1.0 
 PLL lock delay 
 PLL lock delay 
 CD in is actually connected to the video in pin 
 no volumemute, as IC to the third DAC does not work 
 SPDX-License-Identifier: GPL-2.0-only
  C-Media CMI8787 driver for the Studio Evolution SE6X
  Copyright (c) Clemens Ladisch <clemens@ladisch.de>
  CMI8787:
    SPI    -> microcontroller (not actually used)
    GPIO 0 -> do.
    GPIO 2 -> do.
    DAC0   -> both PCM1792A (L+R, each in mono mode)
    ADC1  <-  1st PCM1804
    ADC2  <-  2nd PCM1804
    ADC3  <-  3rd PCM1804
 no DAC volumemute 
 nothing to do (the microcontroller monitors DAC_LRCK) 
 route the same stereo pair to DAC0 and DAC1 
 SPDX-License-Identifier: GPL-2.0-only
  C-Media CMI8788 driver for Asus Xonar cards
  Copyright (c) Clemens Ladisch <clemens@ladisch.de>
 SPDX-License-Identifier: GPL-2.0-only
  C-Media CMI8788 driver for C-Media's reference design and similar models
  Copyright (c) Clemens Ladisch <clemens@ladisch.de>
  CMI8788:
    SPI 0 -> 1st AK4396 (front)
    SPI 1 -> 2nd AK4396 (surround)
    SPI 2 -> 3rd AK4396 (centerLFE)
    SPI 3 -> WM8785
    SPI 4 -> 4th AK4396 (back)
    GPIO 0 -> DFS0 of AK5385
    GPIO 1 -> DFS1 of AK5385
  X-Meridian models:
    GPIO 4 -> enable extension SPDIF input
    GPIO 6 -> enable on-board SPDIF input
  Claro models:
    GPIO 6 -> SPDIF from optical (0) or coaxial (1) input
    GPIO 8 -> enable headphone amplifier
  CM9780:
    LINE_OUT -> input of ADC
    AUX_IN <- aux
    CD_IN  <- CD
    MIC_IN <- mic
    GPO 0 -> route line-in (0) or AC97 output (1) to ADC input
 C-Media's reference design 
 Asus Xonar DG 
 Asus Xonar DGX 
 PCI 2.0 HD Audio 
 Kuroutoshikou CMI8787-HG2PCI 
 TempoTec HiFier Fantasia 
 TempoTec HiFier Serenade 
 AuzenTech X-Meridian 
 AuzenTech X-Meridian 2G 
 HT-Omega Claro 
 HT-Omega Claro halo 
 maps ALSA channel pair number to SPI output 
 wait for the new MCLK to become stable 
 SPDX-License-Identifier: GPL-2.0-only
  card driver for models with WM8776WM8766 DACs (Xonar DSHDAV1.3 Slim)
  Copyright (c) Clemens Ladisch <clemens@ladisch.de>
  Xonar DS
  --------
  CMI8788:
    SPI 0 -> WM8766 (surround, centerLFE, back)
    SPI 1 -> WM8776 (front, input)
    GPIO 4 <- headphone detect, 0 = plugged
    GPIO 6 -> route input jack to mic-in (0) or line-in (1)
    GPIO 7 -> enable output to front LR speaker channels
    GPIO 8 -> enable output to other speaker channels and front panel headphone
  WM8776:
    input 1 <- line
    input 2 <- mic
    input 3 <- front mic
    input 4 <- aux
  Xonar HDAV1.3 Slim
  ------------------
  CMI8788:
    IC <-> WM8776 (addr 0011010)
    GPIO 0  -> disable HDMI output
    GPIO 1  -> enable HP output
    GPIO 6  -> firmware EEPROM IC clock
    GPIO 7 <-> firmware EEPROM IC data
    UART <-> HDMI controller
  WM8776:
    input 1 <- mic
    input 2 <- aux
 001101, 0, W=0 
 reg >= WM8776_HPLVOL is always true 
 reg >= WM8766_LDA1 is always true 
	
	  The WM8766 can mix left and right channels, but this setting
	  applies to all three stereo pairs.
 line-in and mic-in are exclusive 
 SPDX-License-Identifier: GPL-2.0-only
  C-Media CMI8788 driver - main driver module
  Copyright (c) Clemens Ladisch <clemens@ladisch.de>
 no data, but read it anyway to clear the interrupt 
 write the interrupt bit(s) to clear 
	
	  This function gets called when there is new activity on the SPDIF
	  input, or when we lose lock on the input signal, or when the rate
	  changes.
		
		  If we detect activity on the SPDIF input but cannot lock to
		  a signal, the clock bit is likely to be wrong.
 nothing detected with either clock; give up 
				
				  Reset clock to <= 96 kHz because this is
				  more likely to be received next time.
		
		  We don't actually know that any channel status bits have
		  changed, but let's send a notification just to be sure.
	
	  Make sure the EEPROM pins are available, i.e., not used for SPI.
	  (This function is called before we initialize or use SPI.)
	
	  Read the subsystem device ID directly from the EEPROM, because the
	  chip didn't if the first EEPROM word was overwritten.
 use default ID if EEPROM is missing 
	
	  We use only the subsystem device ID for searching because it is
	  unique even without the subsystem vendor ID, which may have been
	  overwritten in the EEPROM.
		
		  This function gets called only when a known card model has
		  been detected, i.e., we know there is a valid subsystem
		  product ID at index 2 in the EEPROM.  Therefore, we have
		  been able to deduce the correct subsystem vendor ID, and
		  this is enough information to restore the original EEPROM
		  contents.
 PLX PEX8111PEX8112 PCIePCI bridge 
 enable blind prefetching 
 enable beacon generation 
 set prefetch size to 128 bytes 
 Pericom PI7C9X110 PCIePCI bridge 
 park the PCI arbiter to the sound chip 
 Texas Instruments XIO2001 PCIePCI bridge 
 request length limit: 64 bytes 
 request count limit: one buffer 
 power down unused ADCs and DACs 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0-only
  Mixer controls for the Xonar DGDGX
  Copyright (c) Clemens Ladisch <clemens@ladisch.de>
  Copyright (c) Roman Volkov <v1ron@mail.ru>
 analog output select 
 mute FP (aux output) amplifier, switch rear jack to CS4245 
		
		  Unmute FP amplifier, switch rear jack to CS4361;
		  I2S channels 2,3,4 should be inactive.
		
		  2.0, 4.0, 5.1: switch to CS4361, mute FP amp.,
		  and change playback routing.
 CS4245 Headphone Channels A&B Volume Control 
 Headphone Mute 
 capture volume for all sources 
 Capture Source 
 ADC high-pass filter 
 SPDX-License-Identifier: GPL-2.0-only
  C-Media CMI8788 driver - mixer code
  Copyright (c) Clemens Ladisch <clemens@ladisch.de>
 DAC 0: front, DAC 1: surround, DAC 2: centerLFE, DAC 3: back 
 stereo -> front 
 stereo -> front+surround 
 stereo -> front+surround+back 
 stereo -> front+surround+centerLFE 
 stereo -> front+surround+centerLFE+back 
 in 7.1 mode, "rear" channels go to the "back" jack 
 OXYGEN_RATE_48000 
 SPDIF rate was already set by the caller 
 category and original 
 I'm too lazy to write a function for each control :-) 
 SPDX-License-Identifier: GPL-2.0-only
  card driver for models with CS4398CS4362A DACs (Xonar D1DX)
  Copyright (c) Clemens Ladisch <clemens@ladisch.de>
  Xonar D1DX
  -----------
  CMI8788:
    IC <-> CS4398 (addr 1001111) (front)
        <-> CS4362A (addr 0011000) (surround, centerLFE, back)
    GPI 0 <- external power present (DX only)
    GPIO 0 -> enable output to speakers
    GPIO 1 -> route output to front panel
    GPIO 2 -> M0 of CS5361
    GPIO 3 -> M1 of CS5361
    GPIO 6 -> ?
    GPIO 7 -> ?
    GPIO 8 -> route input jack to line-in (0) or mic-in (1)
  CM9780:
    LINE_OUT -> input of ADC
    AUX_IN  <- aux
    MIC_IN  <- mic
    FMIC_IN <- front mic
    GPO 0 -> route line-in (0) or AC97 output (1) to CS5361 input
 10011, AD1=1, AD0=1, W=0 
 001100, AD0=0, W=0 
 set CPEN (control port mode) and power down 
 configure 
 clear power down 
 SPDX-License-Identifier: GPL-2.0-or-later
 -- linux-c -- 
  ALSA driver for the digigram lx6464es interface
  Copyright (c) 2008, 2009 Tim Blechmann <tim@klingt.org>
 LX6464ES 
 LX6464ES-CAE 
 LX6464ESe 
 LX6464ESe-CAE 
 PGO pour USERo dans le registre pci_0x06loc_0xEC 
 alsa callbacks 
 copy the struct snd_pcm_hardware struct 
 buffer-size should better be multiple of period-size 
 the clock rate cannot be changed 
 constrain period size 
 reset the dsp during initialization 
 activate reset of xilinx 
 deactivate reset of xilinx 
 todo: add some error handling? 
 clear mr 
 le xilinx ES peut ne pas etre encore pret, on attend. 
 TEST if we have access to XilinxMicroBlaze 
 PCI9056_SPACE0_REMAP 
 seems to be appropriate 
 initialize ethersound 
 configure 64 io channels 
	
	  write it to the card !
	  this actually kicks the ES xilinx, the first time since poweron.
	  the MAC address in the Reg_ADMACESMSB Reg_ADMACESLSB registers
	  is not ready before this is done, and the bit 2 in Reg_CSES is set.
 later: what firmware version do we expect? 
 retrieve PlayRec features 
		 done here because we may have to handle alternate
 later 
 init the EtherSound sample rate 
 blocksize is a power of 2 
 initialize and test the xilinx dsp chip 
	 \todo the mac address should be ready by not, but it isn't,
 channels 
 24 bit samples 
 periods 
 frames per period 
 duplex 
 hardcoded device name & channel count 
 enable PCI device 
 check if we can restrict PCI DMA transfers to 32 bits 
 initialize synchronization structs 
 request resources 
 plx port 
 dsp port 
 SPDX-License-Identifier: GPL-2.0-or-later
 -- linux-c -- 
  ALSA driver for the digigram lx6464es interface
  low-level interface
  Copyright (c) 2009 Tim Blechmann <tim@klingt.org>
 #define RMH_DEBUG 1 
 low-level register access 
 we cannot use memcpy_fromio 
 we cannot use memcpy_to 
 rmh 
	u32    dcCodeOp;	 Op Code of the command (usually 1st 24-bits
 Command length in words of 24 bits.
	u16    dcStatusType;	 Status type: 0 for fixed length, 1 for
 Status length (if fixed).
  Initialization and control data for the Microblaze interface
  - OpCode:
    the opcode field of the command set at the proper offset
  - CmdLength
    the number of command words
  - StatusType
    offset in the status registers: 0 means that the return value may be
    different from 0, and must be read
  - StatusLength
    the number of status words (in addition to the return value)
custom
		    , CMD_NAME("INFO_DEBUG") },
		    , CMD_NAME("GET_SYS_CFG") },
		    , CMD_NAME("SET_GRANULARITY") },
		    , CMD_NAME("SET_TIMER_IRQ") },
up to 10     , CMD_NAME("GET_EVENT") },
up to 4      , CMD_NAME("GET_PIPES") },
		    , CMD_NAME("ALLOCATE_PIPE") },
		    , CMD_NAME("RELEASE_PIPE") },
up to 2      , CMD_NAME("STOP_PIPE") },
up to 2      , CMD_NAME("GET_PIPE_SPL_COUNT") },
up to 5
		    , CMD_NAME("TOGGLE_PIPE_STATE") },
up to 4
		    , CMD_NAME("DEF_STREAM") },
		    , CMD_NAME("SET_MUTE") },
		    , CMD_NAME("GET_STREAM_SPL_COUNT") },
up to 4
		    , CMD_NAME("UPDATE_BUFFER") },
		    , CMD_NAME("GET_BUFFER") },
up to 4      , CMD_NAME("CANCEL_BUFFER") },
		    , CMD_NAME("GET_PEAK") },
		    , CMD_NAME("SET_STREAM_STATE") },
 sleep 500 - 100 = 400 times 100us -> the timeout is >= 40 ms 
 write command 
 MicoBlaze gogogo 
 wait for device to answer 
 read response 
 clear Reg_CSM_MR 
 low-level dsp access 
 unknown 
 todo: endianess handling 
 we don't necessarily need the full length 
 low-level pipe handling 
 finished 
 free 
 need all words here! 
 don't sleep! 
 hi part 
 lo part 
	 max 2PCMOnlyGranularity = 21024 at 44100 = < 50 ms:
 low-level stream handling 
 16 bit format 
 little endianintel format 
 hi part 
 lo part 
 low-level buffer handling 
 request interrupt notification 
 todo: pause request, circular buffer 
	chip->rmh.cmd[0] |= MASK_BUFFER_ID;  ask for the current buffer: the
 low-level gainpeak handling
  \todo: can we unmute captureplayback channels independently?
 bit set to 1: channel muted 
 hi part 
 lo part 
 -90.308dB 
 -72.247dB 
 -60.205dB 
 -48.030dB 
 -36.005dB 
 -30.001dB 
 -24.002dB 
 -18.000dB 
 -15.000dB 
 -12.001dB 
 -9.000dB 
 -6.004dB 
 -3.000dB 
 -2.000dB 
 -1.000dB 
 FS 
 interrupt handling 
 Test if PCI Doorbell interrupt is active 
 RAZ interrupt 
	irq_async = irqsrc & MASK_SYS_ASYNC_EVENTS;  + EtherSound response
 dev_dbg(chip->card->dev, "interrupt: async event pending\n"); 
 answer from CMD_04_GET_EVENT 
	 We can optimize this to not read dumb events.
	  Answer words are in the following order:
	  Stat[0]	general status
	  Stat[1]	end of buffer OUT pF
	  Stat[2]	end of buffer OUT pf
	  Stat[3]	end of buffer IN pF
	  Stat[4]	end of buffer IN pf
	  Stat[5]	MSB underrun
	  Stat[6]	LSB underrun
	  Stat[7]	MSB overrun
	  Stat[8]	LSB overrun
 todo: handle xrun notification 
 this device did not cause the interrupt 
		 backdoor for ethersound commands
		 
		  for now, we do not need this
		 
 handle async events 
	 enabledisable interrupts
	 
	  Set the Doorbell and PCI interrupt enable bits
	 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ICEnsemble ICE1712 (Envy24)
    Lowlevel functions for Hoontech STDSP24
 	Copyright (c) 2000 Jaroslav Kysela <perex@perex.cz>
 Hoontech-specific setting 
 select box 
 prepare for write 
 select box 
 let's go - activate only functions in first box 
			     ICE1712_STDSP24_MUTE |
			       ICE1712_STDSP24_INSEL |
	  These boxconfigs have caused problems in the past.
	   The code is not optimal, but should now enable a working config to
	   be achieved.
	    MIDI IN can only be configured on one box 
	   ICE1712_STDSP24_BOX_MIDI1 needs to be set for that box.
	   Tests on a ADAC2000 box suggest the box config flags do not
	   work as would be expected, and the inputs are crossed.
	   Setting ICE1712_STDSP24_BOX_MIDI1 and ICE1712_STDSP24_BOX_MIDI2
	   on the same box connects MIDI-In to both 401 uarts; both outputs
	   are then active on all boxes.
	   The default config here sets up everything on the first box.
	   Alan Horstmann  5.2.2008
  AK4524 access
 start callback for STDSP24 with modified hardware 
 Hoontech STDSP24 with modified hardware 
 CIF high 
 set the analog DACs 
 set the analog ADCs 
 analog section 
 ak4524 controls 
 entry point 
 a dummy id 
 a dummy id 
		 STAudio ADCIII has the same SSID as Hoontech StA DSP24,
		  thus identified only via the explicit model option
 a dummy id 
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
 	ALSA driver for ICEnsemble VT1724 (Envy24HT)
 	Lowlevel functions for Ego Sys Waveterminal 192M
 		Copyright (c) 2006 Guedez Clement <klem.dev@gmail.com>
 		Some functions are taken from the Prodigy192 driver
 		source
 rate change needs atomic muteunmute of all dacs
 	2ADC 6DAC no1 ringbuffer rw on i2c bus
 	2ADC 2DAC no2 ringbuffer rw on i2c bus
 	DAC mute control
stac9460 1
stac9460 2
  	DAC volume attenuation mixer control
 mute 
 0dB 
  ADC mute control
 ADC gain mixer control
 0dB 
 22.5dB 
  MIC  LINE switch fonction
  Handler for setting correct codec rate - called when rate change is detected
 no hint - SPDIF input is master, simply return 
 256x, base rate mode 
 256x, mid rate mode 
 128x, high rate mode 
 change detected, setting master clock, muting first 
 due to possible conflicts with mute controls - mutexing 
 we have to remember current mute status for each DAC 
printk(KERN_DEBUG "Rate change: %d, new MC: 0x%02x\n", rate, new);
	 unmuting - only originally unmuted dacs -
Limits value in dB for fader
  Control tabs
INIT
WTM 192M
init mutex for dac mute conflict
initialize codec
	[ICE_EEP2_SYSCONF]      = 0x67, SYSCONF: clock 192KHz, mpu401,
 ACLINK : I2S 
 I2S: vol; 96k, 24bit, 192k 
SPDIF: out-en, spidf ext out
entry point
terminator
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ICEnsemble VT1724 (Envy24HT)
    Lowlevel functions for ONKYO WAVIO SE-90PCI and SE-200PCI
 	Copyright (c) 2007 Shin-ya Okada  sh_okada(at)d4.dion.ne.jp
                                         (at) -> @
  ONKYO WAVIO SE-200PCI                                                   
   system configuration ICE_EEP2_SYSCONF=0x4b
     XIN1 49.152MHz
     not have UART
     one stereo ADC and a SPDIF receiver connected
     four stereo DACs connected
   AC-Link configuration ICE_EEP2_ACLINK=0x80
     use I2C, not use AC97
   I2S converters feature ICE_EEP2_I2S=0x78
     I2S codec has no volumemute control feature
     I2S codec supports 96KHz and 192KHz
     I2S codec 24bits
   SPDIF configuration ICE_EEP2_SPDIF=0xc3
     Enable integrated SPDIF transmitter
     internal SPDIF out implemented
     SPDIF is stereo
     External SPDIF out implemented
   connected chips 
   WM8740
       A 2ch-DAC of main outputs.
       It setuped as I2S mode by wire, so no way to setup from software.
       The sample-rate are automatically changed. 
           MLI2S (28pin) --------+
           MCDM1 (27pin) -- 5V   |
           MDDM0 (26pin) -- GND  |
           MUTEB  (25pin) -- NC   |
           MODE   (24pin) -- GND  |
           CSBIW  (23pin) --------+
                                  |
           RSTB   (22pin) --R(1K)-+
       Probably it reduce the noise from the control line.
   WM8766
       A 6ch-DAC for surrounds.
       It's control wire was connected to GPIOxx (3-wire serial interface)
           MLI2S (11pin) -- GPIO18
           MCIWL (12pin) -- GPIO17
           MDDM  (13pin) -- GPIO16
           MUTE   (14pin) -- GPIO01
   WM8776
      A 2ch-ADC(with 10ch-selector) plus 2ch-DAC.
      It's control wire was connected to SDASCLK (2-wire serial interface)
           MODE (16pin) -- R(1K) -- GND
           CE   (17pin) -- R(1K) -- GND  2-wire mode (address=0x34)
           DI   (18pin) -- SDA
           CL   (19pin) -- SCLK
   output pins and device names 
    7.1ch name -- output connector color -- device (-D option)
       FRONT 2ch                  -- green  -- plughw:0,0
       CENTER(Lch) SUBWOOFER(Rch) -- black  -- plughw:0,2,0
       SURROUND 2ch               -- orange -- plughw:0,2,1
       SURROUND BACK 2ch          -- white  -- plughw:0,2,2
  WM8740 interface                                                        
 nothing to do 
 nothing to do 
  WM8766 interface                                                        
 RESET ALL 
 volume L=0 R=0 
 volume L=0 R=0 
 volume L=0 R=0 
 serial mode I2S-24bits 
 MCLK=256fs 
 MDP=0 
 MDP=0 
 demp=off mute=off 
 ch-assign L=L R=R RESET 
 ch-assign L=L R=R 
 MCLK=128fs 
 MCLK=256fs 
  WM8776 interface                                                        
 LINE, CD, MIC, ALL, GND 
 AFL -- After Fader Listening 
 AGC -- Auto Gain Control of the input 
 Off 
 LimiterMode 
 ALCMode 
 reset all 
 ADC and DAC interface is I2S 24bits mode 
 The sample-rate are automatically changed 
 BUT my board can not do reset all, so I load all by manually. 
 head phone mute and power down 
 nothing to do 
  runtime interface                                                       
 mute 
 0dB 
  ONKYO WAVIO SE-90PCI                                                    
   system configuration ICE_EEP2_SYSCONF=0x4b
   AC-Link configuration ICE_EEP2_ACLINK=0x80
   I2S converters feature ICE_EEP2_I2S=0x78
   SPDIF configuration ICE_EEP2_SPDIF=0xc3
    connected chip 
    WM8716
       A 2ch-DAC of main outputs.
       It setuped as I2S mode by wire, so no way to setup from software.
          MLI2S (28pin) -- +5V
          MCDM1 (27pin) -- GND
          MCDM0 (26pin) -- GND
          MUTEB  (25pin) -- open (internal pull-up)
          MODE   (24pin) -- GND
          CSBIWO (23pin) -- +5V
 Nothing to do for this chip. 
  probeinitializesetup                                                  
 nothing to do for VT1724_SUBDEVICE_SE90PCI 
  entry point                                                             
 49.152Hz, spdif-inADC, 4DACs 
 I2S 
 96k-ok, 24bit, 192k-ok 
 out-en, out-int, spdif-in 
 WM8766 mute      1=output 
 not used 
 WM8766 MLMCMD  1=output 
 0=writable 
 0=writable 
 0=writable 
 WM8766 mute=0 
 not used 
 WM8766 MLMCMD 
 49.152Hz, spdif-inADC, 4DACs 
 I2S 
 96k-ok, 24bit, 192k-ok 
 out-en, out-int, spdif-in 
 ALL GPIO bits are in input mode 
terminator
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for VT1724 ICEnsemble ICE1724  VIA VT1724 (Envy24HT)
                    VIA VT1720 (Envy24PT)
 	Copyright (c) 2000 Jaroslav Kysela <perex@perex.cz>
                     2002 James Stafford <jstafford@ampltd.com>
                     2003 Takashi Iwai <tiwai@suse.de>
 lowlevel routines 
 Index 0-MAX 
 ID for this card 
 Enable this card 
 Both VT1720 and VT1724 have the same PCI IDs 
   Basic IO
   default rates, default clock routines
 check whether the clock mode is spdif-in 
  locking rate makes sense only for internal clock mode
  ac97 section
  GPIO operations
 set gpio direction 0 = read, 1 = write 
 dummy read for pci-posting 
 get gpio direction 0 = read, 1 = write 
 set the gpio mask (0 = writable) 
 VT1720 supports only 16 GPIO bits 
 dummy read for pci-posting 
 dummy read for pci-posting 
  MIDI
	 mask irq when all bytes have been transmitted.
	  enabled again in output_trigger when the new data comes in.
 call with ice->reg_lock 
 32 bytes should be transmitted in less than about 12 ms 
   Interrupt handler
			 Due to mysterical reasons, MPU_TX is always
			  generated (and can't be cleared) when a PCM
			  playback is going.  So let's ignore at the
			  next loop.
 ack MPU irq 
			
			  Multi-track PCM
			  PCM assignment are:
			  Playback DMA0 (MC) = playback_pro_substream
			  Playback DMA1 = playback_con_substream_ds[0]
			  Playback DMA2 = playback_con_substream_ds[1]
			  Playback DMA3 = playback_con_substream_ds[2]
			  Playback DMA4 (SPDIF) = playback_con_substream
			  Record DMA0 = capture_pro_substream
			  Record DMA1 = capture_con_substream
 ack anyway to avoid freeze 
 ought to really handle this properly 
 If I don't do this, I get machine lockup due to continual interrupts 
   PCM code - professional part (multitrack)
 up to 96000 
 up to 48000 
 ADDR register offset 
 SIZE register offset 
 COUNT register offset 
 start & pause bit 
 apps will have to restart stream 
 check MT02 
 128x MCLK 
 256x MCLK 
 master clock changed 
 no change in master clock 
 running? we cannot change the rate now... 
		 comparing required and current rate - makes sense for
		 force means the rate was switched by ucontrol, otherwise
 setting master clock 
 set up codecs 
 mark surround channels 
 PDMA0 can be multi-channel up to 8 
 check individual playback stream 
 unmark surround channels 
 outl(size, ICEMT1724(ice, PLAYBACK_SIZE)); 
 outl(size, ICEMT1724(ice, PLAYBACK_COUNT)); 
	
	dev_dbg(ice->card->dev, "pro prepare: ch = %d, addr = 0x%x, "
	       "buffer = 0x%x, period = 0x%x\n",
	       substream->runtime->channels,
	       (unsigned int)substream->runtime->dma_addr,
	       snd_pcm_lib_buffer_bytes(substream),
	       snd_pcm_lib_period_bytes(substream));
 read PLAYBACK_ADDR 
 read PLAYBACK_SIZE 
 use ADDR register 
 use SIZE register 
 19bits dword 
 FIXME: constraints needed 
 16bits dword 
 16bits dword 
  set rate constraints
 I2S 
 VT1720 doesn't support more than 96kHz 
 ACLINK 
 if the card has the internal rate locked (is_pro_locked), limit runtime
   hw rates to the current internal rate only.
 multi-channel playback needs alignment 8x32bit regardless of the channels
  actually used
 calculate the currently available channels 
 channels must be even 
  SPDIF PCM
 update spdif control bits; call with reg_lock 
 update SPDIF control bits according to the given rate 
 no spdif device 
  independent surround PCMs
 already used by PDMA0? 
 FIXME: should handle blocking mode properly 
   Mixer section
 cold reset 
 FIXME 
 I2S mixer only 
 professional, non-audio 
 professional 
 96k 
 192k 
 88.2k 
 176.4k 
 consumer 
 copyright 
 category 
 fs 
 professional, non-audio 
 professional 
 consumer 
 copyright 
 category 
 fs 
 FIXME: the following conflict with IEC958 Playback Route 
 .name =         SNDRV_CTL_NAME_IEC958("", PLAYBACK, SWITCH), 
 NOT USED YET 
  GPIO access from extern
 NOT USED YET 
   rate
 internal clocks 
 external clocks 
 upper limit - keep at top 
 ext_clock items 
 int clock items 
 standard external clock - only single type - SPDIF IN 
 setting clock to external - SPDIF 
 setting 256fs 
 if rate = 0 => external clock 
 switching to external clock 
 internal on-card clock 
 the first switch to the ext. clock mode? 
 notify akm chips as well 
  routing
 0 
 1-2 
 3-4 
 we now have 3 bits per output 
 PCM 
 PSDIN0 Left 
 PSDIN0 Right 
 SPDIN Left 
 SPDIN Right 
 FIXME: for compatibility with ice1712... 
  ooAoo cards with no controls
	[ICE_EEP2_SYSCONF]     = 0x4c,	 49MHz crystal, no mpu401, no ADC,
 I2S 
 no volume, 96k, 24bit, 192k 
 out-en, out-int, out-ext 
 no GPIOs are used 
 inputs 
	[ICE_EEP2_GPIO_STATE1] = 0x00,  all 1, but GPIO_CPLD_RW
 inputs 
 terminator 
	
	dev_dbg(ice->card->dev, "i2c_read: [0x%x,0x%x] = 0x%x\n", dev, addr, val);
	
	dev_dbg(ice->card->dev, "i2c_write: [0x%x,0x%x] = 0x%x\n", dev, addr, data);
 EEPROM device address 
			 invalid subvendor from EEPROM, try the PCI
			  subststem ID instead
 if the EEPROM is given by the driver, use it 
 assume AC97-only card which can suspend without additional code 
 pci posting flush 
 pci posting flush 
 MPU_RX and TX irq masks are cleared later dynamically 
	 don't handle FIFO overrununderruns (just yet),
	  since they cause machine lockups
 use default only 
 mask all interrupts 
 enable PCI device 
  Registration
 field init before calling chip_init 
 specific driver? 
	
	 VT1724 has separate DMAs for the analog and the SPDIF streams while
	 ICE1712 has only one for both (mixed up).
	
	 Confusingly the analog PCM is named "professional" here because it
	 was called so in ice1712 driver, and vt1724 driver is derived from
	 ice1712 driver.
 has SPDIF IO 
 set watermarks 
 set UART mode 
 switching to external clock via SPDIF 
 internal on-card clock 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ICEnsemble VT1724 (Envy24HT)
    Lowlevel functions for AudioTrak Prodigy 192 cards
    Supported IEC958 input from optional MIODIO add-on card.
    Specifics (SW, HW):
    -------------------
    	 49.5MHz crystal
    	 SPDIF-OUT on the card:
   	  - coax (through isolation transformer)toslink supplied by
           74HC04 gates - 3 in parallel
    	  - output switched between on-board CD drive dig-out connector
           and ice1724 SPDTX pin, using 74HC02 NOR gates, controlled
           by GPIO20 (0 = CD dig-out, 1 = SPDTX)
    	 SPDTX goes straight to MIODIO card's SPDIF-OUT coax
    	 MIODIO card: AK4114 based, used for iec958 input only
    		- toslink input -> RX0
    		- coax input -> RX1
    		- 4wire protocol:
    			AK4114		ICE1724
    			------------------------------
  			CDTO (pin 32) -- GPIO11 pin 86
  			CDTI (pin 33) -- GPIO10 pin 77
  			CCLK (pin 34) -- GPIO9 pin 76
  			CSN  (pin 35) -- GPIO8 pin 75
    		- output data Mode 7 (24bit, I2S, slave)
 		- both MCKO1 and MCKO2 of ak4114 are fed to FPGA, which
 		  outputs master clock to SPMCLKIN of ice1724.
 		  Experimentally I found out that only a combination of
 		  OCKS0=1, OCKS1=1 (128fs, 64fs output) and ice1724 -
 		  VT1724_MT_I2S_MCLK_128X=0 (256fs input) yields correct
 		  sampling rate. That means that the FPGA doubles the
 		  MCK01 rate.
 	Copyright (c) 2003 Takashi Iwai <tiwai@suse.de>
       Copyright (c) 2003 Dimitromanolakis Apostolos <apostol@cs.utoronto.ca>
       Copyright (c) 2004 Kouichi ONO <co2b@ceres.dti.ne.jp>
 rate change needs atomic muteunmute of all dacs
  DAC mute control
  idx = STAC9460 volume register number, mute: 0 = mute, 1 = unmute
 dev_dbg(ice->card->dev, "Volume register 0x%02x: 0x%02x\n", idx, new);
 due to possible conflicts with stac9460_set_rate_val, mutexing 
	
	dev_dbg(ice->card->dev, "Mute put: reg 0x%02x, ctrl value: 0x%02x\n", idx,
	       ucontrol->value.integer.value[0]);
  DAC volume attenuation mixer control
 mute 
 0dB 
		
		dev_dbg(ice->card->dev, "DAC Volume: reg 0x%02x: 0x%02x\n",
		       idx, ovol);
  ADC mute control
  ADC gain mixer control
 0dB 
 22.5dB 
  Handler for setting correct codec rate - called when rate change is detected
 no hint - SPDIF input is master, simply return 
 256x, base rate mode 
 256x, mid rate mode 
 128x, high rate mode 
 change detected, setting master clock, muting first 
 due to possible conflicts with mute controls - mutexing 
 we have to remember current mute status for each DAC 
dev_dbg(ice->card->dev, "Rate change: %d, new MC: 0x%02x\n", rate, new);
	 unmuting - only originally unmuted dacs -
  mixers
 AK4114 - ICE1724 connections on Prodigy192 + MIODIO 
 CDTO (pin 32) -- GPIO11 pin 86
  CDTI (pin 33) -- GPIO10 pin 77
  CCLK (pin 34) -- GPIO9 pin 76
  CSN  (pin 35) -- GPIO8 pin 75
#define AK4114_ADDR	0x00  C1-C0: Chip Address
			       (According to datasheet fixed to 00)
  4wire ak4114 protocol - writing data
 drop clock 
 set data 
 raise clock 
  4wire ak4114 protocol - reading data
 drop clock 
 read data 
 raise clock 
  4wire ak4114 protocol - starting sequence
 high at init 
 drop chip select 
  4wire ak4114 protocol - final sequence
 raise chip select 
  Write data to addr register of ak4114
  Read data from addr register of ak4114
	 AK4114_IPS0 bit = 0 -> RX0 = Toslink
	  AK4114_IPS0 bit = 1 -> RX1 = Coax
 AK4114_IPS0 could be any bit 
		 ice1724 expects I2S and provides clock,
		  DEM0 disables the deemphasis filter
 default input RX0 
	 AK4114 in Prodigy192 cannot detect external rate correctly.
 registers 0x0 - 0x14 
 ak4114 is connected 
 ak4114 in MIODIO handles no IEC958 output 
  check for presence of MIODIO add-on card with digital inputs
 random value 
 random SAFE address 
 ak4114 seems to communicate, apparently exists 
 writing back original value 
  initialize the chip
		STAC946X_MASTER_VOLUME, 0,
		STAC946X_LF_VOLUME, 0,
		STAC946X_RF_VOLUME, 0,
		STAC946X_LR_VOLUME, 0,
		STAC946X_RR_VOLUME, 0,
		STAC946X_CENTER_VOLUME, 0,
 prodigy 192 
 ice1724, e.g. 23 GPIOs 
 initialize codec 
 MIODIO add on card with AK4114 
		 from this moment if err = 0 then
		  spec->ak4114 should not be null
  Aureon boards don't provide the EEPROM data except for the vendor IDs.
  hence the driver needs to sets up it properly.
	[ICE_EEP2_SYSCONF]     = 0x6a,	 49MHz crystal, mpu401,
					  spdif-in+ 1 stereo ADC,
					  3 stereo DACs
 I2S 
 vol, 96k, 24bit, 192k 
 out-en, out-int, spdif-in 
	[ICE_EEP2_GPIO_STATE2] = 0x10,   GPIO20: 0 = CD drive dig. input
					  passthrough,
					  1 = SPDIF-OUT from ice1724
 entry point 
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ICEnsemble VT17xx
    Lowlevel functions for WM8766 codec
 	Copyright (c) 2012 Ondrej Zary <linux@rainbow-software.org>
 low-level access 
 mixer controls 
 exported functions 
 reset 
 load defaults 
 restore volume after MCLK stopped 
 mixer callbacks 
 this also works for enum because value is a union 
 both stereo controls in one register 
 stereo controls in different registers 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ICEnsemble VT17xx
    Lowlevel functions for WM8776 codec
 	Copyright (c) 2012 Ondrej Zary <linux@rainbow-software.org>
 low-level access 
 addr + 9th data bit 
 remaining 8 data bits 
 register-level functions 
 Off 
 Limiter 
 ALC Right 
 ALC Left 
 ALC Stereo 
 mixer controls 
 .enum_names item count 
 .enum_names item count 
 .enum_names item count 
 .enum_names item count 
 .enum_names item count 
 .enum_names item count 
 .enum_names item count 
 exported functions 
 reset 
 load defaults 
 restore volume after MCLK stopped 
 mixer callbacks 
 this also works for enum because value is a union 
 both stereo controls in one register 
 stereo controls in different registers 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ICEnsemble VT1724 (Envy24HT)
    Lowlevel functions for ESI Maya44 cards
 	Copyright (c) 2009 Takashi Iwai <tiwai@suse.de>
 	Based on the patches by Rainer Zimmermann <mail@lightshed.de>
 WM8776 register indexes 
 clock ratio identifiers for snd_wm8776_set_rate() 
 write the given register and save the data to the cache 
	
	  WM8776 registers are up to 9 bits wide, bit 8 is placed in the LSB
	  of the address field
  update the given register with andor mask and save the data to the cache
  WM8776 volume controls
 volume range: 0..maxval 
 left and right registers 
 value mask 
 zero-value offset 
 mute bit 
 update bits 
 extra bits for ADC mute 
 update and zero-cross enable 
 zero-cross enable 
 update 
 ADCMUX bits 
  dB tables
 headphone output: mute, -73..+6db (1db step) 
 DAC output: mute, -127..0db (0.5db step) 
 ADC gain: mute, -21..+24db (0.5db step) 
  WM8776 switch controls
  GPIO pins (known ones for maya44)
  GPIO switch controls
  capture source selection
 known working input slots (0-4) 
 in-2 
 in-4 
  Maya44 routing switch settings have different meanings than the standard
  ice1724 switches as defined in snd_vt1724_pro_route_info (ice1724.c).
 0 
  controls to be added
 FIXME: do controls 5-9 have any meaning? 
  initialize a wm8776 chip
 R2: headphone L+R muted + update 
 R5: DAC output L+R muted + update 
 R6: DAC output phase normal 
		0x07, 0x091,  R7: DAC enable zero cross detection,
 R8: DAC soft mute off 
 R9: no deemph, DAC zero detect disabled 
 R10: DAC I2C mode, std polarities, 24bit 
		0x0b, 0x022,  R11: ADC I2C mode, std polarities, 24bit,
 R12: ADC+DAC slave, ADC+DAC 44,1kHz 
 R13: all power up 
		0x0e, 0x100,  R14: ADC left muted,
		0x0f, 0x100,  R15: ADC right muted,
 R16: ALC...
 R17: disable ALC 
 R18: ALC...
 R19: noise gate...
 R21: ADC input mux init, mute all inputs 
 R22: output mux, select DAC 
 enable DAC output; mute bypass, aux & all inputs 
  change the rate on the WM8776 codecs.
  this assumes that the VT17xx's rate is changed by the calling function.
  NOTE: even though the WM8776's are running in slave mode and rate
  selection is automatic, we need to call snd_wm8776_set_rate() here
  to make sure some flags are set correctly.
 no hint - SPDIF input is master, simply return 
	
	  this currently sets the same rate for ADC and DAC, but limits
	  ADC rate to 256X (96kHz). For 256X mode (96kHz), this sets ADC
	  oversampling to 64x, as recommended by WM8776 datasheet.
	  Setting the rate is not really necessary in slave mode.
  supported sample rates (to override the default one)
 playback rates: 32..192 kHz 
  chip addresses on I2C bus
 codec 0 & 1 
  initialize the chip
 initialise codecs 
 set card specific rates 
 register change rate notifier 
 RDMA1 (2nd input channel) is used for ADC by default 
 have an own routing control 
  Maya44 boards don't provide the EEPROM data except for the vendor IDs.
  hence the driver needs to sets up it properly.
 clock xin1=49.152MHz, mpu401, 2 stereo ADCs+DACs 
 I2S 
 vol, 96k, 24bit, 192k 
 enable spdif out, spdif out supp, spdif-in, ext spdif out 
0x9f,
0xff,
0x7f,
 entry point 
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ICEnsemble VT1724 (Envy24HT)
    Lowlevel functions for Infrasonic Quartet
 	Copyright (c) 2009 Pavel Hofman <pavel.hofman@ivitera.com>
 system control register 
 monitoring control register 
 cpld register 
 chip address on I2C bus 
 SPDIF receiver 
 chip address on SPI bus 
 ADCDAC 
  GPIO pins
 GPIO0 - O - DATA0, def. 0 
 GPIO1 - IO - DATA1, Jack Detect Input0 (0:present, 1:missing), def. 1 
 GPIO2 - IO - DATA2, Jack Detect Input1 (0:present, 1:missing), def. 1 
 GPIO3 - IO - DATA3, def. 1 
 GPIO4 - IO - DATA4, SPI CDTO, def. 1 
 GPIO5 - IO - DATA5, SPI CCLK, def. 1 
 GPIO6 - IO - DATA6, Cable Detect Input (0:detected, 1:not detected 
 GPIO7 - IO - DATA7, Device Detect Input (0:detected, 1:not detected 
 GPIO8 - O - CPLD Chip Select, def. 1 
 GPIO9 - O - CPLD register readwrite (0:write, 1:read), def. 0 
 GPIO10 - O - SPI Chip Select for CODEC#0, def. 1 
 GPIO11 - O - SPI Chip Select for CODEC#1, def. 1 
 GPIO12 - O - Ex. Register Output Enable (0:enable, 1:disable), def. 1,
 GPIO13 - O - Ex. Register0 Chip Select for System Control Register,
 GPIO14 - O - Ex. Register1 Chip Select for Monitor Control Register,
 System Control Register GPIO_SCR data bits 
 MicLine select relay (0:line, 1:mic) 
 Phantom power drive control (0:5V, 1:48V) 
 HW mute control (0:Normal, 1:Mute) 
 Phantom power control (0:Phantom on, 1:off) 
 Analog input 12 Source Select 
 Analog input 34 Source Select (0:line, 1:hi-z) 
 Codec Power Down (0:power down, 1:normal) 
 Monitor Control Register GPIO_MCR data bits 
 Input 12 to Monitor 12 (0:off, 1:on) 
 Input 12 to Monitor 34 (0:off, 1:on) 
 Input 34 to Monitor 12 (0:off, 1:on) 
 Input 34 to Monitor 34 (0:off, 1:on) 
 Output to Monitor 12 (0:off, 1:on) 
 Output to Monitor 34 (0:off, 1:on) 
 CPLD Register DATA bits 
 Clock Rate Select 
 Sync Source Select (0:Internal, 1:External) 
 Word Clock FS Select (0:FS, 1:256FS) 
 Coaxial Output Source (IS-Link) (0:SPDIF, 1:I2S) 
 Input 12 Source Select (0:Analog12, 1:An34) 
 Input 34 Source Select (0:Analog34, 1:Digital In) 
 internal clock (CPLD_SYNC_SEL = 0) options 
 external clock (CPLD_SYNC_SEL = 1) options 
 external clock - SPDIF 
 external clock - WordClock 1xfs 
 external clock - WordClock 256xfs 
 Clock and Format Control register 
 Deem and Volume Control register 
  Conversion from int value to its binary form. Used for debugging.
  The output buffer must be allocated prior to calling the function.
  Initial setup of the conversion array GPIO <-> rate
  AK4620 section
  Write data to addr register of ak4620
	dev_dbg(ice->card->dev, "Writing to AK4620: chip=%d, addr=0x%x,
 set mask - only SPI bits 
 high all 
 drop chip select 
 CODEC 1 
 build I2C address + data byte 
 drop clock 
 set data 
 raise clock 
 all back to 1 
 return all gpios to non-writable 
 restore GPIOs direction 
 clear the bits 
 set the new bits 
  change the rate of AK4620
	if (rate == 0)   no hint - SPDIF input is master or the new spdif
 adjust DFS on codecs - see datasheet 
 set new value 
	.num_dacs = 4,	 DAC1 - Output 12
	.num_adcs = 4,	 ADC1 - Input 12
 Communication routines with the CPLD 
 Writes data to external register reg, both reg and data are
 set direction of used GPIOs
 all outputs 
 mask - writable bits 
 write the data 
 drop output enable 
 drop the register gpio 
 raise the register GPIO 
 raise all data gpios 
 mask - immutable bits 
 outputs only 8-15 
 unmute 
 un-smuting DAC 
 mute 
 smuting DAC 
 set smute 
 no change 
 BUG - no other combinations allowed 
 binary 10 is not supported 
 shifting to SCR_AIN12_SEL0 
 change requested 
 turn off relay 
 turn on relay 
 turn on relay 
 no change 
 if phantom voltage =48V, phantom on 
 phantom on requested 
 0 = voltage 5V  {
 is off, turn on 
 turn voltage on first, = 1 
 turn phantom on, = 0 
 phantom off requested and 1 = voltage 48V 
 is on, turn off 
 turn voltage off first, = 0 
 turn phantom off, = 1 
 no change 
 no change 
 Create virtual master control 
 only capture SPDIF over AK4113 
 CPLD_SYNC_SEL: 0 = internal, 1 = external (i.e. spdif master) 
 setting new rate 
 switching ice1724 to external clock - supplied by ext. circuits 
 switch to internal clock, drop CPLD_SYNC_SEL 
	 dev_dbg(ice->card->dev, "QT - set_rate: old %x, new %x\n",
 no change in master clock 
 setting clock to external - SPDIF 
 changed 
 checking only rateclock-related bits 
 switched to internal clock, is not any external type 
 undefined combination of external clock setup 
 Called when ak4113 detects change in the input SPDIF stream 
 only for SPDIF master mode, rate was changed 
		 dev_dbg(ice->card->dev, "ak4113 - input rate changed to %d\n",
  If clock slaved to SPDIF-IN, setting runtime rate
  to the detected external rate
 not external SPDIF, no rate limitation 
 only external SPDIF can detect incoming sample rate 
  initialize the chip
 AK4113_REG_PWRDN 	AK4113_RST | AK4113_PWN |
 AK4113_REQ_FORMAT 	AK4113_DIF_I24I2S | AK4113_VTX |
 AK4113_REG_IO0 	AK4113_OPS2 | AK4113_TXE |
 AK4113_REG_IO1 	AK4113_EFH_1024LRCLK | AK4113_IPS(0),
 AK4113_REG_INT0_MASK 	0,
 AK4113_REG_INT1_MASK 	0,
 AK4113_REG_DATDTS 		0,
 switching ice1724 to external clock - supplied by ext. circuits 
 qtet is clocked by Xilinx array 
	 since Qtet can detect correct SPDIF-in rate, all streams can be
 Mute Off 
 SCR Initialize
 keep codec power down first 
 codec power up 
 MCR Initialize 
 CPLD Initialize 
 only one codec with two chips 
 callback for codecs rate setting 
	 AK41143 in Quartet can detect external rate correctly
	[ICE_EEP2_SYSCONF]     = 0x28,	 clock 256(24MHz), mpu401, 1xADC,
 I2S 
 96k, 24bit, 192k 
 out-en, out-int, in, out-ext 
	[ICE_EEP2_GPIO_DIR]    = 0x00,	 0-7 inputs, switched to output
 8-15 outputs 
 changed only for OUT operations 
 inputs 
	[ICE_EEP2_GPIO_STATE1] = 0x7d,  all 1, but GPIO_CPLD_RW
 inputs 
 entry point 
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ICEnsemble ICE1712 (Envy24)
    Lowlevel functions for M-Audio Audiophile 192, Revolution 7.1 and 5.1
 	Copyright (c) 2003 Takashi Iwai <tiwai@suse.de>
 a non-standard I2C device for revo51 
 assert PRST# to converters; MT05 bit 7 
 deassert PRST# 
  change the rate of Envy24HT, AK4355 and AK4381
 no hint - SPDIF input is master, simply return 
 adjust DFS on codecs 
 reset DFS 
 snd_akm4xxx_write(ak, 0, reg, tmp); 
 value is written in reset(0) 
  I2C access to the PT2258 volume controller on GPIO 67 (Revolution 5.1)
 write SCL 
 write SDA 
 create the I2C bus 
 create the I2C device 
  initialize the chips on M-Audio Revolution cards
 front channels DAC supports muting 
 high at init 
 high at init 
 high at init 
 high at init 
 AK4358 for AP192 DAC, AK5385A for ADC 
 reset CKS 
 reset DFS pins of AK5385A for ADC, too 
 reset ADC 
 high at init 
 AK4114 support on Audiophile 192 
 CDTO (pin 32) -- GPIO2 pin 52
  CDTI (pin 33) -- GPIO3 pin 53 (shared with AK4358)
  CCLK (pin 34) -- GPIO1 pin 51 (shared with AK4358)
  CSN  (pin 35) -- GPIO7 pin 59
 drop clock 
 set data 
 raise clock 
 drop clock 
 read data 
 raise clock 
 high at init 
	 AK4114 in Revo cannot detect external rate correctly.
 determine I2C, DACs and ADCs 
 second stage of initialization, analog parts and others 
 unmute all codecs 
 unmute all codecs 
 unmute all codecs 
 only capture SPDIF over AK4114 
 entry point 
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ICEnsemble VT1724 (Envy24HT)
    Lowlevel functions for Advanced Micro Peripherals Ltd AUDIO2000
 	Copyright (c) 2000 Jaroslav Kysela <perex@perex.cz>
 0 db 
 0 db 
 24bit I2S 
 24bit I2S 	
 only use basic functionality for now 
 VT1616 6ch codec connected to PSDOUT0 using packed mode 
	 Chaintech AV-710 has another WM8728 codec connected to PSDOUT4
	   (shared with the SPDIF output). Mixer control for this codec
		 we use pins 39 and 41 of the VT1616 for left and right
 entry point 
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ICEnsemble ICE1712 (Envy24)
    Lowlevel functions for M-Audio Delta 1010, 1010E, 44, 66, 66E, Dio2496,
 			    Audiophile, Digigram VX442
 	Copyright (c) 2000 Jaroslav Kysela <perex@perex.cz>
  CS8427 via SPI mode (for Audiophile), emulated I2C
 send 8 bits 
 read 8 bits 
 assert chip select 
 deassert chip select 
 sequential write 
 address + write mode 
 sequential read 
 address + read mode 
 send byte to transmitter 
  AK4524 on Delta 44 and 66 to choose the chip mask
  AK4524 on Delta1010LT to choose the chip address
  AK4524 on Delta66 rev E to choose the chip address
  AK4528 on VX442 to choose the chip mask
  change the DFS bit according rate for Delta1010
 no hint - SPDIF input is master, simply return 
  change the rate of AK4524 on Delta 4466, AP, 1010LT
 no hint - SPDIF input is master, simply return 
 check before reset ak4524 to avoid unnecessary clicks 
 do it again 
  change the rate of AK4524 on VX442
  SPDIF ops for Delta 1010, Dio, 66
 open callback 
 set up 
 consumer 
 CS8427 receiver error register 
  initialize the chips on M-Audio cards
 the default level of the CIF pin from AK4524 
 set later 
 the default level of the CIF pin from AK4524 
 set later 
 the default level of the CIF pin from AK4524 
 set later 
 set later 
 init spdif 
 nothing 
 Set spdif defaults 
 init codec and restore registers 
 reset & mute codec 
 determine I2C, DACs and ADCs 
 two AK4324 codecs 
 omni not supported yet 
 initialize the SPI clock to high 
 initialize spdif 
 Set spdif defaults 
 no analog? 
 second stage of initialization, analog parts and others 
  additional controls for M-Audio cards
 1010 and dio specific controls 
 normal spdif controls 
 spdif status in 
 ak4524 controls 
 entry point 
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ICEnsemble ICE1712 (Envy24)
    AK4524  AK4528  AK4529  AK4355  AK4381 interface
 	Copyright (c) 2000 Jaroslav Kysela <perex@perex.cz>
  write AK4xxx register
 start without chip select 
 chip select low 
 doesn't handle cf=1 yet 
 build I2C address + data byte 
 drop clock 
 set data 
 raise clock 
 assert a cs pulse to trigger 
 chip select high to trigger 
 deselect address 
  initialize the struct snd_akm4xxx record with the template
  build AK4xxx controls
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ICEnsemble VT1724 (Envy24HT)
    Lowlevel functions for Pontis MS300
 	Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>
 I2C addresses 
 WM8776 registers 
 headphone left attenuation 
 headphone left attenuation 
 headphone master (both channels) 
 override LLR 
 digital left attenuation 
 DAC phase swap 
  GPIO
 CS 
 CLK 
 CS8416 -> VT1720 
 VT1720 -> CS8416 
  get the current register value of WM codec
  set the register value of WM codec and remember it
  DAC volume attenuation mixer control (-64dB to 0dB)
 mute 
 0dB, 0.5dB step 
  ADC gain mixer control (-64dB to 0dB)
 mute (-64dB) 
 0dB, 0.5dB step 
  ADC input mux mixer control
  Analog bypass (In -> Out)
  LeftRight swap
  write data in the SPI mode
 WRITE 
 MAP 
 DATA 
 trigger 
 restore 
 WRITE 
 MAP 
 trigger 
 READ 
 trigger 
 restore 
  SPDIF input source
 RXP0 
 RXP1 
 RXP2 
  GPIO controls
 16bit 
 4-7 reserved 
 4-7 reserved 
 4-7 reserved 
 4-7 reserved 
  mixers
 FIXME: which interface? 
  WM codec registers
  initialize the chip
 These come first to reduce init pop noise 
 ADC mute 
 DAC softmute 
 DAC mute 
 All power-up except HP 
 reset 
 256fs, slave mode 
 I2S, normal polarity, 24bit 
 I2S, normal polarity, 24bit 
 DAC LR 
 OUT DAC 
 HP 0dB 
 HP 0dB 
 DAC 0dB 
 DAC 0dB 
 DAC 0dB 
 DAC 0dB 
 WM_DAC_MASTER,	0x0100, 	
 phase normal 
 no deemphasis, no ZFLG 
 ADC muted 
 ADC muted 
 DAC unmute 
 ADC unmute, both CDLine On 
 RUN, RXP0 
 slave, 24bit 
 to remember the register values 
	 HACK - use this as the SPDIF source.
	  don't call snd_ice1712_gpio_getput(), otherwise it's overwritten
 initialize WM8776 codec 
 initialize CS8416 codec 
 assert PRST#; MT05 bit 7 
 deassert PRST# 
  Pontis boards don't provide the EEPROM data at all.
  hence the driver needs to sets up it properly.
 clock 256, mpu401, spdif-inADC, 1DAC 
 I2S 
 vol, 96k, 24bit, 192k 
 out-en, out-int, spdif-in 
 ignored 
 4-7 reserved for CS8416 
 ignored 
 0-low, 1-high, 2-high 
 ignored 
 entry point 
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ICEnsemble VT1724 (Envy24HT)
    Lowlevel functions for Philips PSC724 Ultimate Edge
 	Copyright (c) 2012 Ondrej Zary <linux@rainbow-software.org>
  PHILIPS PSC724 ULTIMATE EDGE                                            
   VT1722 (Envy24GT) - 6 outputs, 4 inputs (only 2 used), 24-bit96kHz
   system configuration ICE_EEP2_SYSCONF=0x42
     XIN1 49.152MHz
     no MPU401
     one stereo ADC, no SPDIF receiver
     three stereo DACs (FRONT, REAR, CENTER+LFE)
   AC-Link configuration ICE_EEP2_ACLINK=0x80
     use I2S, not AC97
   I2S converters feature ICE_EEP2_I2S=0x30
     I2S codec has no volumemute control feature (bug!)
     I2S codec does not support 96KHz or 192KHz (bug!)
     I2S codec 24bits
   SPDIF configuration ICE_EEP2_SPDIF=0xc1
     Enable integrated SPDIF transmitter
     internal SPDIF out implemented
     No SPDIF input
     External SPDIF out implemented
   connected chips 
   WM8776
      2-channel DAC used for main output and stereo ADC (with 10-channel MUX)
      AIN1: LINE IN, AIN2: CDVIDEO, AIN3: AUX, AIN4: Front MIC, AIN5: Rear MIC
      Controlled by I2C using VT1722 I2C interface:
           MODE (pin16) -- GND
           CE   (pin17) -- GND  I2C mode (address=0x34)
           DI   (pin18) -- SDA  (VT1722 pin70)
           CL   (pin19) -- SCLK (VT1722 pin71)
   WM8766
       6-channel DAC used for rear & centerLFE outputs (only 4 channels used)
       Controlled by SPI using VT1722 GPIO pins:
           MODE   (pin 1) -- GPIO19 (VT1722 pin99)
           MLI2S (pin11) -- GPIO18 (VT1722 pin98)
           MCIWL (pin12) -- GPIO17 (VT1722 pin97)
           MDDM  (pin13) -- GPIO16 (VT1722 pin96)
           MUTE   (pin14) -- GPIO20 (VT1722 pin101)
   GPIO14 is used as input for headphone jack detection (1 = connected)
   GPIO22 is used as MUTE ALL output, grounding all 6 channels
   output pins and device names 
    5.1ch name -- output connector color -- device (-D option)
       FRONT 2ch                  -- green  -- plughw:0,0
       CENTER(Lch) SUBWOOFER(Rch) -- orange -- plughw:0,2,0
       REAR 2ch                   -- black  -- plughw:0,2,1
 codec access low-level functions 
 MSB first 
 CLOCK high 
 LOAD high 
 LOAD low, DATA and CLOCK high 
 mute all 
 jack detection 
 notify about master speaker mute change 
 and headphone mute change 
 mixer controls 
 restore codec volume settings after rate change (PMCLK stop) 
 power management 
 init 
 PSC724 has buggy EEPROM (no 96&192kHz, all FFh GPIOs), so override it here 
 49.152MHz, 1 ADC, 3 DACs 
 I2S 
 I2S volume, 96kHz, 24bit 
 spdif out-en, out-int, no input 
 GPIO outputs 
 MUTE_ALL,WM8766 MUTEMODEMLMCMD 
 GPIO write enable 
 read-only 
 read-only 
 MUTE_ALL,WM8766 MUTEMODEMLMCMD 
 GPIO initial state 
 unmuted, all WM8766 pins low 
terminator
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ICEnsemble VT1724 (Envy24HT)
    Lowlevel functions for ESI Juli@ cards
 	Copyright (c) 2004 Jaroslav Kysela <perex@perex.cz>
 	              2008 Pavel Hofman <dustin@seznam.cz>
  chip addresses on I2C bus
 SPDIF receiver 
 DAC 
  Juli does not use the standard ICE1724 clock scheme. Juli's ice1724 chip is
  supplied by external clock provided by Xilinx array and MK73-1 PLL frequency
  multiplier. Actual frequency is set by ice1724 GPIOs hooked to the Xilinx.
  The clock circuitry is supplied by the two ice1724 crystals. This
  arrangement allows to generate independent clock signal for AK4114's input
  rate detection circuit. As a result, Juli, unlike most other
  ice1724+ak4114-based cards, detects spdif input rate correctly.
  This fact is applied in the driver, allowing to modify PCM stream rate
  parameter according to the actual input rate.
  Juli uses the remaining three stereo-channels of its DAC to optionally
  monitor analog input, digital input, and digital output. The corresponding
  I2S signals are routed by Xilinx, controlled by GPIOs.
  The master mute is implemented using output muting transistors (GPIO) in
  combination with smuting the DAC.
  The card itself has no HW master volume control, implemented using the
  vmaster control.
  TODO:
  researching and fixing the input monitors
  GPIO pins
 also external 
 0 = external, 1 = internal 
 RO only: 0 = present 
 must be 0 
 1 = active 
 1 = active 
 1 = active 
 must be 0 
 output mute, 1 = muted 
  Initial setup of the conversion array GPIO <-> rate
  If SPDIF capture and slaved to SPDIF-IN, setting runtime rate
  to the external rate
  AK4358 section
  change the rate of envy24HT, AK4358, AK5385
	if (rate == 0)   no hint - SPDIF input is master or the new spdif
 adjust DFS on codecs 
 AK5385 first, since it requires cold reset affecting both codecs 
	 dev_dbg(ice->card->dev, "JULI - ak5385 set_rate_val: new gpio 0x%x\n",
 cold reset 
 AK4358 
 set new value, reset DFS 
 reinit ak4114 
	.num_dacs = 8,	 DAC1 - analog out
			   DAC2 - analog in monitor
			   DAC3 - digital out monitor
			   DAC4 - digital in monitor
 val 0 = signal on 
 val 1 = signal on 
 unmute 
 0 = signal on 
 un-smuting DAC 
 1 = signal on 
 mute 
 1 = signal off 
 smuting DAC 
 0 = signal off 
	 dev_dbg(ice->card->dev,
		"JULI - muteunmute: control_value: 0x%x, old_gpio: 0x%x, "
		"new_gpio 0x%x\n",
		(unsigned int)ucontrol->value.integer.value[0], old_gpio,
 no change 
	 Although the following functionality respects the succint NDA'd
	  documentation from the card manufacturer, and the same way of
	  operation is coded in OSS Juli driver, only Digital Out monitor
	  seems to work. Surprisingly, Analog input monitor outputs Digital
	  output data. The two are independent, as enabling both doubles
	  volume of the monitor sound.
	 
	  Checking traces on the board suggests the functionality described
	  by the manufacturer is correct - I2S from ADC and AK4114
	  go to ICE as well as to Xilinx, I2S inputs of DAC2,3,4 (the monitor
	  inputs) are fed from Xilinx.
	 
	  I even checked traces on board and coded a support in driver for
	  an alternative possibility - the unused I2S ICE output channels
	  switched to HW-INSPDIF-IN and providing the monitoring signal to
	  the DAC - to no avail. The I2S outputs seem to be unconnected.
	 
	  The windows driver supports the monitoring correctly.
 dev_dbg(card->dev, "add_followers - %s\n", list); 
 dev_dbg(card->dev, "follower %s found\n", list); 
 Create virtual master control 
 only capture SPDIF over AK4114 
  suspendresume
 akm4358 un-reset, un-mute 
 reinit ak4114 
 akm4358 reset and soft-mute 
  initialize the chip
 setting new rate 
	 dev_dbg(ice->card->dev, "JULI - set_rate: old %x, new %x\n",
			old & GPIO_RATE_MASK,
 switching to external clock - supplied by external circuits 
 no change in master clock 
 setting clock to external - SPDIF 
 external clock (= 0), multiply 1x, 48kHz 
 Called when ak4114 detects change in the input SPDIF stream 
 only for SPDIF master mode, rate was changed 
		 dev_dbg(ice->card->dev, "ak4114 - input rate changed to %d\n",
 AK4117_REG_PWRDN 	AK4114_RST | AK4114_PWN |
 AK4114_REQ_FORMAT 	AK4114_DIF_I24I2S,
 AK4114_REG_IO0 	AK4114_TX1E,
 AK4114_REG_IO1 	AK4114_EFH_1024 | AK4114_DIT |
 AK4114_REG_INT0_MASK  0,
 AK4114_REG_INT1_MASK  0
 callback for codecs rate setting 
 AK4114 in Juli can detect external rate correctly 
  it seems that the analog doughter board detection does not work reliably, so
  force the analog flag; it should be very rare (if ever) to come at Juli@
  used without the analog daughter board
 juli is clocked by Xilinx array 
  Juli@ boards don't provide the EEPROM data except for the vendor IDs.
  hence the driver needs to sets up it properly.
	[ICE_EEP2_SYSCONF]     = 0x2b,	 clock 512, mpu401, 1xADC, 1xDACs,
 I2S 
 vol, 96k, 24bit, 192k 
 out-en, out-int, spdif-in 
 5, 6:inputs; 7, 4-0 outputs
 5, 6: locked; 7, 4-0 writable 
 0-7 writable 
 internal clock, multiple 1x, 48kHz
 unmuted 
 entry point 
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ICEnsemble VT1724 (Envy24HT)
    Lowlevel functions for Terratec Aureon cards
 	Copyright (c) 2003 Takashi Iwai <tiwai@suse.de>
  NOTES:
  - we reuse the struct snd_akm4xxx record for storing the wm8770 codec data.
    both wm and akm codecs are pretty similar, so we can integrate
    both controls in the future, once if wm codecs are reused in
    many boards.
  - DAC digital volumes are not implemented in the mixer.
    if they show better response than DAC analog volumes, we can use them
    instead.
    Lowlevel functions for AudioTrak Prodigy 7.1 (and possibly 192) cards
       Copyright (c) 2003 Dimitromanolakis Apostolos <apostol@cs.utoronto.ca>
    version 0.82: Stable  not all features work yet (no communication with AC97 secondary)
        added 64x128x oversampling switch (should be 64x only for 96khz)
        fixed some recording labels (still need to check the rest)
        recording is working probably thanks to correct wm8770 initialization
    version 0.5: Initial release:
            working: analog output, mixer, headphone amplifier switch
        not working: prety much everything else, at least i could verify that
                     we have no digital output, no capture, pretty bad clicks and poops
                     on mixer switch and other coll stuff.
 AC97 register cache for Aureon 
 WM8770 registers 
 DAC1-8 analog attenuation 
 DAC master analog attenuation 
 DAC1-8 digital attenuation 
 DAC master digital attenuation 
 DAC phase 
 DAC control bits 
 mute controls 
 de-emphasis and zefo-flag 
 interface control 
 master clock and mode 
 power-down controls 
 ADC gain L(19)R(1a) 
 input MUX 
 output MUX 
 output MUX 
 software reset 
 CS8415A registers 
 PCA9554 registers 
 I2C device address 
 input port 
 output port 
 input invert 
 port directions 
  Aureon Universe additional controls using PCA9554
  Send data to pca9554
 ID 0100000, write 
 disable SPI devices 
	
	  send i2c stop condition and start condition
	  to obtain sane state
	
	  send device address, command and value,
	  skipping ack cycles in between
 Send address to XILINX chip 
 Send low-order byte to XILINX chip 
 Send high-order byte to XILINX chip 
 Instruct XILINX chip to parse the data to the STAC9744 chip 
 Store the data in out private buffer 
  Initialize STAC9744 chip
 Cold reset 
 Unmute AC'97 master volume permanently - muting is done by WM8770 
  AC'97 volume controls
  AC'97 mute controls
  AC'97 mute controls
  write data in the SPI mode
  Read data in SPI mode
  get the current register value of WM codec
  set the register value of WM codec
  set the register value of WM codec and remember it
  AC'97 master playback mute controls (Mute on WM8770 chip)
 0dB .. -100dB 
  DAC mute control
  Master volume attenuation mixer control
  DAC volume attenuation mixer control
 mute (-101dB) 
 0dB 
  WM8770 mute control
  WM8770 master mute control
 digital master volume 
 -64dB 
 mute (-64dB) 
 0dB 
 prelatch 
 update 
  ADC mute control
  ADC gain mixer control
 -12dB 
 19dB 
  ADC input mux mixer control
 AIN1 
 AIN2 
 AIN3 
 AIN4 
 AIN5 
 AIN1 
 AIN2 
 AIN3 
 AIN4 
 AIN5 
 AIN6 
 AIN7 
 AIN8 
  CS8415 Input mux
 RXP0 
 RXP1 
 snd_ice1712_save_gpio_status(ice); 
 val = aureon_cs8415_get(ice, CS8415_CTRL2); 
 snd_ice1712_restore_gpio_status(ice); 
  CS8415A Mute
  CS8415A Q-Sub info
  Headphone Amplifier
  Deemphasis
  ADC Oversampling
  mixers
 no side 
  reset the chip
 These come first to reduce init pop noise 
 ADC Mux (AC'97 source) 
 Out Mux1 (VOUT1 = DAC+AUX, VOUT2 = DAC) 
 Out Mux2 (VOUT2 = DAC, VOUT3 = DAC) 
 All power-up 
 I2S, normal polarity, 24bit 
 256fs, slave mode 
 DAC1 analog mute 
 DAC2 analog mute 
 DAC3 analog mute 
 DAC4 analog mute 
 DAC5 analog mute 
 DAC6 analog mute 
 DAC7 analog mute 
 DAC8 analog mute 
 master analog mute 
 DAC1 digital full 
 DAC2 digital full 
 DAC3 digital full 
 DAC4 digital full 
 DAC5 digital full 
 DAC6 digital full 
 DAC7 digital full 
 DAC8 digital full 
 master digital full 
 phase normal 
 unmute DAC LR 
 all unmute 
 no deemphasis, no ZFLG 
 -12dB ADCL 
 -12dB ADCR 
 These come first to reduce init pop noise 
 ADC Mux 
 Out Mux1 
 Out Mux2 
 All power-up 
 I2S, normal polarity, 24bit, high-pass on 
 128fs, slave mode 
 DAC1 analog mute 
 DAC2 analog mute 
 DAC3 analog mute 
 DAC4 analog mute 
 DAC5 analog mute 
 DAC6 analog mute 
 DAC7 analog mute 
 DAC8 analog mute 
 master analog mute 
 DAC1 digital full 
 DAC2 digital full 
 DAC3 digital full 
 DAC4 digital full 
 DAC5 digital full 
 DAC6 digital full 
 DAC7 digital full 
 DAC8 digital full 
 master digital full 
 phase normal 
 unmute DAC LR 
 all unmute 
 no deemphasis, no ZFLG 
 -12dB ADCL 
 -12dB ADCR 
 RUN 
 no mute, OMCK output on RMCK pin 
 SPDIF source on RXP1 
 slave, 24bit, MSB on second OSCLK, SDOUT for right channel when OLRCK is high 
 fix this for the time being 
 reset the wm codec as the SPI mode 
 initialize WM8770 codec 
 initialize CS8415A codec 
 initialize PCA9554 pin directions & set default input 
 internal AUX 
  suspendresume
	 workaround for poking volume with alsamixer after resume:
  initialize the chip
 aureon 7.1 and prodigy 7.1 
 to remember the register values of CS8415 
  Aureon boards don't provide the EEPROM data except for the vendor IDs.
  hence the driver needs to sets up it properly.
 clock 512, spdif-inADC, 3DACs 
 I2S 
 vol, 96k, 24bit, 192k 
 out-en, out-int, spdif-in 
 clock 512, spdif-inADC, 4DACs 
 I2S 
 vol, 96k, 24bit, 192k 
 out-en, out-int, spdif-in 
	[ICE_EEP2_SYSCONF]     = 0x2b,	 clock 512, mpu401, spdif-inADC,
					  4DACs
 I2S 
 vol, 96k, 24bit, 192k 
 out-en, out-int, spdif-in 
 clock 384, spdif-inADC, 4DACs 
 I2S 
 vol, 96k, 24bit, 192k 
 out-en, out-int, spdif-in 
 entry point 
 keep in 15 letters 
 should be identical with Aureon71 
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ICEnsemble ICE1712 (Envy24)
 	Copyright (c) 2000 Jaroslav Kysela <perex@perex.cz>
  NOTES:
  - spdif nonaudio consumer mode does not work (at least with my
    Sony STR-DB830)
  Changes:
   2002.09.09	Takashi Iwai <tiwai@suse.de>
 	split the code to several files.  each low-level routine
 	is stored in the local file and called from registration
 	function from card_info struct.
   2002.11.26	James Stafford <jstafford@ampltd.com>
 	Added support for VT1724 (Envy24HT)
 	I have left out support for 176.4 and 192 KHz for the moment.
   I also haven't done anything with the internal SPDIF transmitter or the MPU-401
   2003.02.20  Taksahi Iwai <tiwai@suse.de>
 	Split vt1724 part to an independent driver.
 	The GPIO is accessed through the callback functions now.
  2004.03.31 Doug McLain <nostar@comcast.net>
     Added support for Event Electronics EZ8 card to hoontech.c.
 lowlevel routines 
 Index 0-MAX 
 ID for this card 
 Enable this card 
 Delta44 & 66 Omni IO support 
 CS8427 SPDIF transceiver reset timeout value in msec 
 DXR enable for DMX6FIRE 
 ICE1712 
   Basic IO
 check whether the clock mode is spdif-in 
 timeout 
  pro ac97 section
 timeout 
  consumer ac97 digital mix
  gpio operations
 dummy read for pci-posting 
 dummy read for pci-posting 
 dummy read for pci-posting 
  CS8427 interface
  change the input clock selection
  spdif_clock = 1 - IEC958 input, 0 - Envy24
 CS8427 auto increment | register number 4 + data 
  spdif callbacks
  create and initialize callbacks for cs8427 interface
 change CS8427 clock source too 
 notify ak4524 chip as well 
   Interrupt handler
 dev_dbg(ice->card->dev, "pbkstatus = 0x%x\n", pbkstatus); 
   PCM part - consumer IO
   PCM code - professional part (multitrack)
 assign channels to iec958 
   Mixer section
 multi-channel mixer 
 initialize volumes 
 mute 
 mute 
 mute 
 I2S mixer only 
   rate
 0: 6 
 1: 3 
 2: 10 
 3: 2 
 4: 5 
 5: 9 
 6: 1 
 7: 4 
 8: 8 
 9: 0 
 10: 15 
 11: 11 
 12: 7 
 13: -- 
 0: 6 
 1: 3 
 2: 10 
 3: 2 
 4: 5 
 5: 9 
 6: 1 
 7: 4 
 8: 8 
 9: 0 
 10: 15 
 11: 11 
 12: 7 
 "IEC958 Input",	13: -- 
  routing
 0 
 1-4 
 5-8 
 9-10 
 11 - optional 
 update PSDOUT 
 dig mixer (or pcm) 
 spdif in 
 analog in 
 pcm 
 dig mixer of pcm 
 update CAPTURE 
 analog in 
 spdif in 
 update SPDOUT 
  list of available boards
 I2C EEPROM device address 
 invalid subvendor from EEPROM, try the PCI subststem ID instead 
 if the EEPROM is given by the driver, use it 
 FIXME: any cards without the correct size? 
 return -EIO; 
		  Set eeprom value to limit active ADCs and DACs to 6;
		   Also disable AC97 as no hardware in standard 6fire cardbox
		   Note: DXR extensions are not currently supported
 unmask used interrupts 
 mask all interrupts 
 enable PCI device 
 check, if we can restrict PCI DMA transfers to 28 bits 
 consumer format 
 no emphasis 
 PCM encoderdecoder 
 disable legacy emulation 
  Registration
 specific driver? 
  Preferred name available in card_info 
  2nd port used  
  Preferred name available in card_info 
 switching to external clock via SPDIF 
 internal on-card clock 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ICEnsemble ICE1724 (Envy24)
    Lowlevel functions for Terratec PHASE 22
 	Copyright (c) 2005 Misha Zhilin <misha@epiphan.com>
 PHASE 22 overview:
    Audio controller: VIA Envy24HT-S (slightly trimmed down Envy24HT, 4in4out)
    Analog chip: AK4524 (partially via Philip's 74HCT125)
    Digital receiver: CS8414-CS (supported in this release)
 		PHASE 22 revision 2.0 and TerrasoniqMusonik TS22PCI have CS8416
 		(support status unknown, please test and report)
    Envy connects to AK4524
 	- CS directly from GPIO 10
 	- CCLK via 74HCT125's gate #4 from GPIO 4
 	- CDTI via 74HCT125's gate #2 from GPIO 5
 		CDTI may be completely blocked by 74HCT125's gate #1
 		controlled by GPIO 3
 PHASE 28 overview:
    Audio controller: VIA Envy24HT (full untrimmed version, 4in8out)
    Analog chip: WM8770 (8 channel 192k DAC, 2 channel 96k ADC)
    Digital receiver: CS8414-CS (supported in this release)
 AC97 register cache for Phase28 
 WM8770 registers 
 DAC1-8 analog attenuation 
 DAC master analog attenuation 
 DAC1-8 digital attenuation 
 DAC master digital attenuation 
 DAC phase 
 DAC control bits 
 mute controls 
 de-emphasis and zefo-flag 
 interface control 
 master clock and mode 
 power-down controls 
 ADC gain L(19)R(1a) 
 input MUX 
 output MUX 
 output MUX 
 software reset 
  Logarithmic volume values for WM8770
  Computed as 20  Log10(255  x)
 Configure DACADC description for generic part of ice1724 
 Envy24HT-S have 16 bit wide GPIO 
 Initialize analog chips 
	[ICE_EEP2_SYSCONF]     = 0x28,   clock 512, mpu 401,
 I2S 
 vol, 96k, 24bit 
 out-en, out-int, spdif-in 
	[ICE_EEP2_SYSCONF]     = 0x2b,   clock 512, mpu401,
 I2S 
 vol, 96k, 24bit, 192k 
 out-en, out-int, spdif-in 
  write data in the SPI mode
  get the current register value of WM codec
  set the register value of WM codec
  set the register value of WM codec and remember it
  DAC mute control
  Master volume attenuation mixer control
 These come first to reduce init pop noise 
 ADC Mux (AC'97 source) 
 Out Mux1 (VOUT1 = DAC+AUX, VOUT2 = DAC) 
 Out Mux2 (VOUT2 = DAC, VOUT3 = DAC) 
 All power-up 
 I2S, normal polarity, 24bit 
 256fs, slave mode 
 DAC1 analog mute 
 DAC2 analog mute 
 DAC3 analog mute 
 DAC4 analog mute 
 DAC5 analog mute 
 DAC6 analog mute 
 DAC7 analog mute 
 DAC8 analog mute 
 master analog mute 
 DAC1 digital full 
 DAC2 digital full 
 DAC3 digital full 
 DAC4 digital full 
 DAC5 digital full 
 DAC6 digital full 
 DAC7 digital full 
 DAC8 digital full 
 master digital full 
 phase normal 
 unmute DAC LR 
 all unmute 
 no deemphasis, no ZFLG 
 -12dB ADCL 
 -12dB ADCR 
 Initialize analog chips 
 fix this for time being 
 reset the wm codec as the SPI mode 
  DAC volume attenuation mixer control
 mute (-101dB) 
 0dB 
  WM8770 mute control
  WM8770 master mute control
 digital master volume 
 -64dB 
 mute (-64dB) 
 0dB 
 prelatch 
 update 
  Deemphasis
  ADC Oversampling
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for VT1720VT1724 (Envy24PTEnvy24HT)
    Lowlevel functions for VT1720-based motherboards
 	Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>
 VT1616 codec 
 WM8728 codec 
 FIXME: TODO 
 FIXME: needs some quirks for VT1616? 
 EEPROM image 
 clock 256, 1ADC, 2DACs 
 ACLINK, packed 
 - 
 - 
 - 
 - 
 - 
 clock 256, 1ADC, 2DACs 
 ACLINK, packed 
 - 
 - 
 - 
 - 
 - 
 entry point 
 identical with k8x800 
 identical with k8x800 
 identical with k8x800 
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ICEnsemble ICE1712 (Envy24)
    Lowlevel functions for Terratec EWS88MTD, EWX2496, DMX 6Fire
 	Copyright (c) 2000 Jaroslav Kysela <perex@perex.cz>
                     2002 Takashi Iwai <tiwai@suse.de>
 additional i2c devices for EWS boards 
  access via i2c mode (for EWX 2496, EWS 88MT&D)
 send SDA and SCL 
 set RW pin to low 
 set RW pin to high 
 reset write mask 
 set RW high 
 CS high also 
 CS high also 
 write SCL 
 write SDA 
  AK4524 access
 AK4524 chip select; address 0x48 bit 0-3 
 start callback for EWS88MT, needs to select a certain chip mask 
 assert AK4524 CS 
 stop callback for EWS88MT, needs to deselect chip mask 
 start callback for EWX2496 
 start callback for DMX 6fire 
  CS8404 interface on EWS88MTD
 open callback 
 set up SPDIF for EWS88MT  EWS88D 
 consumer 
 CIF high 
 no chip select on gpio 
 set rw bit high 
 CIF high 
 set rw bit high 
 CIF high 
 set later 
 set rw bit high 
  initialize the chip
 6fire specific 
 set the analog DACs 
 Note: not analog but ADAT IO 
 create i2c 
 create i2c devices 
 Check if the front module is connected 
 set up SPDIF interface 
 set up CS8404 
 Set spdif defaults 
 no analog? 
 analog section 
  EWX 2496 specific controls
 io sensitivity - this callback is shared among other devices, too 
  EWS88MT specific controls
 analog output sensitivity;; address 0x48 bit 6 
 high = -10dBV, low = +4dBu 
 analog output sensitivity;; address 0x48 bit 6 
 analog input sensitivity; address 0x46 
 reversed; high = +4dBu, low = -10dBV 
 analog output sensitivity; address 0x46 
  EWS88D specific controls
 inverted 
  DMX 6Fire specific controls
 DMX6FIRE_CONTROL("Master Clock Select", 3, 0),
 all terratec cards have spdif, but cs8427 module builds it's own controls 
 ak4524 controls 
 card specific controls 
 entry point 
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
    ALSA driver for ICEnsemble VT1724 (Envy24HT)
    Lowlevel functions for Audiotrak Prodigy 7.1 Hifi
    based on pontis.c
       Copyright (c) 2007 Julian Scheel <julian@jusst.de>
       Copyright (c) 2007 allank
       Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>
 I2C addresses 
 WM8776 registers 
 headphone left attenuation 
 headphone left attenuation 
#define WM_HP_MASTER		0x02	 headphone master (both channels),
 digital left attenuation 
 DAC phase swap 
 Analog Recording Source :- Mic, LineIn, CDVideo, 
 implement capture source select control for WM8776 
 GPIO pins of envy24ht connected to wm8766 
 CLK, Pin97 on ICE1724 
 DATA VT1724 -> WM8766, Pin96 
 Latch, Pin98 
 WM8766 registers 
 DAC Control 
 Interface Control 
  Prodigy HD2
 CSN->GPIO8, pin 75 
 CCLK->GPIO9, pin 76 
 CDTI->GPIO10, pin 77 
 ak4396 registers 
  get the current register value of WM codec
  set the register value of WM codec and remember it
  write data in the SPI mode
  SPI implementation for WM8766 codec - only writing supported, no readback
 latch must be low when writing 
 REGISTER ADDRESS 
 release latch 
 restore 
  serial interface for ak4396 - only writing supported, no readback
 latch must be low when writing 
 REGISTER ADDRESS 
 release latch 
 restore 
  ak4396 mixers
  DAC volume attenuation mixer control (-64dB to 0dB)
 mute 
 linear 
 --------------- 
  DAC volume attenuation mixer control (-64dB to 0dB)
 mute 
 0dB, 0.5dB step 
  WM8766 DAC volume attenuation mixer control
 mute 
 0dB 
  Master volume attenuation mixer control  applied to WM8776+WM8766
 Apply to front DAC 
 KONSTI 
 KONSTI 
  ADC gain mixer control (-64dB to 0dB)
 mute (-64dB) 
 0dB, 0.5dB step 
  ADC input mux mixer control
  Analog bypass (In -> Out)
  LeftRight swap
  mixers
  WM codec registers
 I2S Normal Mode, 24 bit 
 These come first to reduce init pop noise 
 ADC mute 
 0x00c0 replaced by 0x0003 
 DAC softmute 
 DAC mute 
 All power-up except HP 
 reset 
 no DAC attenuation here 
 reinitialize WM8776 and re-apply old register values 
 reinitialize WM8766 and re-apply volumes for all DACs 
 unmute WM8776 DAC 
  initialize the chip
 256fs, slave mode 
 I2S, normal polarity, 24bit 
 I2S, normal polarity, 24bit 
 DAC LR 
 OUT DAC 
 HP 0dB 
 HP 0dB 
 DAC 0dB 
 DAC 0dB 
 DAC 0dB 
 DAC 0dB 
 phase normal 
 DAC master muted 
 no deemphasis, no ZFLG 
 ADC muted 
 ADC muted 
 DAC unmute 
 ADC unmute, both CDLine On 
	 HACK - use this as the SPDIF source.
	 don't call snd_ice1712_gpio_getput(), otherwise it's overwritten
 to remember the register values 
 initialize WM8776 codec 
  initialize the chip
 I2S Normal Mode, 24 bit 
 initialize ak4396 codec 
 reset codec 
 initialize ak4396 codec and restore previous mixer volumes 
	 HACK - use this as the SPDIF source.
	 don't call snd_ice1712_gpio_getput(), otherwise it's overwritten
 to remember the register values 
 SYSCONF: clock 512, spdif-inADC, 4DACs 
 ACLINK: I2S 
 I2S: vol, 96k, 24bit, 192k 
 SPDIF: out-en, out-int, spdif-in 
 GPIO_DIR 
 GPIO_DIR1 
 GPIO_DIR2 
 GPIO_MASK 
 GPIO_MASK1 
 GPIO_MASK2 
 GPIO_STATE 
 GPIO_STATE1 
 GPIO_STATE2 
 SYSCONF: clock 512, spdif-inADC, 4DACs 
 ACLINK: I2S 
 I2S: vol, 96k, 24bit, 192k 
 SPDIF: out-en, out-int, spdif-in 
 GPIO_DIR 
 GPIO_DIR1 
 GPIO_DIR2 
 GPIO_MASK 
 GPIO_MASK1 
 GPIO_MASK2 
 GPIO_STATE 
 GPIO_STATE1 
 GPIO_STATE2 
 SYSCONF: clock 512, ADC, 4DACs 	
 ACLINK: I2S 
 I2S: vol, 96k, 24bit, 192k 
 SPDIF: out-en, out-int 
 GPIO_DIR 
 GPIO_DIR1 
 GPIO_DIR2 
 GPIO_MASK 
 GPIO_MASK1 
 GPIO_MASK2 
 GPIO_STATE 
 GPIO_STATE1 
 GPIO_STATE2 
 entry point 
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for Digigram miXart soundcards
  mixer callbacks
  Copyright (c) 2003 by Digigram <alsa@digigram.com>
 [000] -96.0 dB 
 [001] -95.5 dB 
 [002] -95.0 dB 
 [003] -94.5 dB 
 [004] -94.0 dB 
 [005] -93.5 dB 
 [006] -93.0 dB 
 [007] -92.5 dB 
 [008] -92.0 dB 
 [009] -91.5 dB 
 [010] -91.0 dB 
 [011] -90.5 dB 
 [012] -90.0 dB 
 [013] -89.5 dB 
 [014] -89.0 dB 
 [015] -88.5 dB 
 [016] -88.0 dB 
 [017] -87.5 dB 
 [018] -87.0 dB 
 [019] -86.5 dB 
 [020] -86.0 dB 
 [021] -85.5 dB 
 [022] -85.0 dB 
 [023] -84.5 dB 
 [024] -84.0 dB 
 [025] -83.5 dB 
 [026] -83.0 dB 
 [027] -82.5 dB 
 [028] -82.0 dB 
 [029] -81.5 dB 
 [030] -81.0 dB 
 [031] -80.5 dB 
 [032] -80.0 dB 
 [033] -79.5 dB 
 [034] -79.0 dB 
 [035] -78.5 dB 
 [036] -78.0 dB 
 [037] -77.5 dB 
 [038] -77.0 dB 
 [039] -76.5 dB 
 [040] -76.0 dB 
 [041] -75.5 dB 
 [042] -75.0 dB 
 [043] -74.5 dB 
 [044] -74.0 dB 
 [045] -73.5 dB 
 [046] -73.0 dB 
 [047] -72.5 dB 
 [048] -72.0 dB 
 [049] -71.5 dB 
 [050] -71.0 dB 
 [051] -70.5 dB 
 [052] -70.0 dB 
 [053] -69.5 dB 
 [054] -69.0 dB 
 [055] -68.5 dB 
 [056] -68.0 dB 
 [057] -67.5 dB 
 [058] -67.0 dB 
 [059] -66.5 dB 
 [060] -66.0 dB 
 [061] -65.5 dB 
 [062] -65.0 dB 
 [063] -64.5 dB 
 [064] -64.0 dB 
 [065] -63.5 dB 
 [066] -63.0 dB 
 [067] -62.5 dB 
 [068] -62.0 dB 
 [069] -61.5 dB 
 [070] -61.0 dB 
 [071] -60.5 dB 
 [072] -60.0 dB 
 [073] -59.5 dB 
 [074] -59.0 dB 
 [075] -58.5 dB 
 [076] -58.0 dB 
 [077] -57.5 dB 
 [078] -57.0 dB 
 [079] -56.5 dB 
 [080] -56.0 dB 
 [081] -55.5 dB 
 [082] -55.0 dB 
 [083] -54.5 dB 
 [084] -54.0 dB 
 [085] -53.5 dB 
 [086] -53.0 dB 
 [087] -52.5 dB 
 [088] -52.0 dB 
 [089] -51.5 dB 
 [090] -51.0 dB 
 [091] -50.5 dB 
 [092] -50.0 dB 
 [093] -49.5 dB 
 [094] -49.0 dB 
 [095] -48.5 dB 
 [096] -48.0 dB 
 [097] -47.5 dB 
 [098] -47.0 dB 
 [099] -46.5 dB 
 [100] -46.0 dB 
 [101] -45.5 dB 
 [102] -45.0 dB 
 [103] -44.5 dB 
 [104] -44.0 dB 
 [105] -43.5 dB 
 [106] -43.0 dB 
 [107] -42.5 dB 
 [108] -42.0 dB 
 [109] -41.5 dB 
 [110] -41.0 dB 
 [111] -40.5 dB 
 [112] -40.0 dB 
 [113] -39.5 dB 
 [114] -39.0 dB 
 [115] -38.5 dB 
 [116] -38.0 dB 
 [117] -37.5 dB 
 [118] -37.0 dB 
 [119] -36.5 dB 
 [120] -36.0 dB 
 [121] -35.5 dB 
 [122] -35.0 dB 
 [123] -34.5 dB 
 [124] -34.0 dB 
 [125] -33.5 dB 
 [126] -33.0 dB 
 [127] -32.5 dB 
 [128] -32.0 dB 
 [129] -31.5 dB 
 [130] -31.0 dB 
 [131] -30.5 dB 
 [132] -30.0 dB 
 [133] -29.5 dB 
 [134] -29.0 dB 
 [135] -28.5 dB 
 [136] -28.0 dB 
 [137] -27.5 dB 
 [138] -27.0 dB 
 [139] -26.5 dB 
 [140] -26.0 dB 
 [141] -25.5 dB 
 [142] -25.0 dB 
 [143] -24.5 dB 
 [144] -24.0 dB 
 [145] -23.5 dB 
 [146] -23.0 dB 
 [147] -22.5 dB 
 [148] -22.0 dB 
 [149] -21.5 dB 
 [150] -21.0 dB 
 [151] -20.5 dB 
 [152] -20.0 dB 
 [153] -19.5 dB 
 [154] -19.0 dB 
 [155] -18.5 dB 
 [156] -18.0 dB 
 [157] -17.5 dB 
 [158] -17.0 dB 
 [159] -16.5 dB 
 [160] -16.0 dB 
 [161] -15.5 dB 
 [162] -15.0 dB 
 [163] -14.5 dB 
 [164] -14.0 dB 
 [165] -13.5 dB 
 [166] -13.0 dB 
 [167] -12.5 dB 
 [168] -12.0 dB 
 [169] -11.5 dB 
 [170] -11.0 dB 
 [171] -10.5 dB 
 [172] -10.0 dB 
 [173] -9.5 dB 
 [174] -9.0 dB 
 [175] -8.5 dB 
 [176] -8.0 dB 
 [177] -7.5 dB 
 [178] -7.0 dB 
 [179] -6.5 dB 
 [180] -6.0 dB 
 [181] -5.5 dB 
 [182] -5.0 dB 
 [183] -4.5 dB 
 [184] -4.0 dB 
 [185] -3.5 dB 
 [186] -3.0 dB 
 [187] -2.5 dB 
 [188] -2.0 dB 
 [189] -1.5 dB 
 [190] -1.0 dB 
 [191] -0.5 dB 
 [192] 0.0 dB 
 [193] 0.5 dB 
 [194] 1.0 dB 
 [195] 1.5 dB 
 [196] 2.0 dB 
 [197] 2.5 dB 
 [198] 3.0 dB 
 [199] 3.5 dB 
 [200] 4.0 dB 
 [201] 4.5 dB 
 [202] 5.0 dB 
 [203] 5.5 dB 
 [204] 6.0 dB 
 [205] 6.5 dB 
 [206] 7.0 dB 
 [207] 7.5 dB 
 [208] 8.0 dB 
 [209] 8.5 dB 
 [210] 9.0 dB 
 [211] 9.5 dB 
 [212] 10.0 dB 
 [213] 10.5 dB 
 [214] 11.0 dB 
 [215] 11.5 dB 
 [216] 12.0 dB 
 [217] 12.5 dB 
 [218] 13.0 dB 
 [219] 13.5 dB 
 [220] 14.0 dB 
 [221] 14.5 dB 
 [222] 15.0 dB 
 [223] 15.5 dB 
 [224] 16.0 dB 
 [225] 16.5 dB 
 [226] 17.0 dB 
 [227] 17.5 dB 
 [228] 18.0 dB 
 [229] 18.5 dB 
 [230] 19.0 dB 
 [231] 19.5 dB 
 [232] 20.0 dB 
 [233] 20.5 dB 
 [234] 21.0 dB 
 [235] 21.5 dB 
 [236] 22.0 dB 
 [237] 22.5 dB 
 [238] 23.0 dB 
 [239] 23.5 dB 
 [240] 24.0 dB 
 [241] 24.5 dB 
 [242] 25.0 dB 
 [243] 25.5 dB 
 [244] 26.0 dB 
 [245] 26.5 dB 
 [246] 27.0 dB 
 [247] 27.5 dB 
 [248] 28.0 dB 
 [249] 28.5 dB 
 [250] 29.0 dB 
 [251] 29.5 dB 
 [252] 30.0 dB 
 [253] 30.5 dB 
 [254] 31.0 dB 
 [255] 31.5 dB 
 -96.0 dB + 8.0 dB = -88.0 dB 
  31.5 dB + 8.0 dB =  39.5 dB 
  -8.0 dB + 8.0 dB =  0.0 dB 
 -96.0 dB + 1.5 dB = -94.5 dB (possible is down to (-114.0+1.5)dB) 
   0.0 dB + 1.5 dB =  1.5 dB 
  -1.5 dB + 1.5 dB =  0.0 dB 
 left and right 
  analog level control
 playback 
 -96 dB 
 0 dB 
 capture 
 -96 dB 
 31.5 dB 
 playback 
 capture 
 name will be filled later 
 shared 
 update playback levels 
 shared 
 [000] = 0.00e+000 = mute if <= -109.5dB 
 [001] = 3.55e-006 = pow(10.0, 0.05  -109.0dB) 
 [002] = 3.76e-006 = pow(10.0, 0.05  -108.5dB) 
 [003] = 3.98e-006 = pow(10.0, 0.05  -108.0dB) 
 [004] = 4.22e-006 = pow(10.0, 0.05  -107.5dB) 
 [005] = 4.47e-006 = pow(10.0, 0.05  -107.0dB) 
 [006] = 4.73e-006 = pow(10.0, 0.05  -106.5dB) 
 [007] = 5.01e-006 = pow(10.0, 0.05  -106.0dB) 
 [008] = 5.31e-006 = pow(10.0, 0.05  -105.5dB) 
 [009] = 5.62e-006 = pow(10.0, 0.05  -105.0dB) 
 [010] = 5.96e-006 = pow(10.0, 0.05  -104.5dB) 
 [011] = 6.31e-006 = pow(10.0, 0.05  -104.0dB) 
 [012] = 6.68e-006 = pow(10.0, 0.05  -103.5dB) 
 [013] = 7.08e-006 = pow(10.0, 0.05  -103.0dB) 
 [014] = 7.50e-006 = pow(10.0, 0.05  -102.5dB) 
 [015] = 7.94e-006 = pow(10.0, 0.05  -102.0dB) 
 [016] = 8.41e-006 = pow(10.0, 0.05  -101.5dB) 
 [017] = 8.91e-006 = pow(10.0, 0.05  -101.0dB) 
 [018] = 9.44e-006 = pow(10.0, 0.05  -100.5dB) 
 [019] = 1.00e-005 = pow(10.0, 0.05  -100.0dB) 
 [020] = 1.06e-005 = pow(10.0, 0.05  -99.5dB) 
 [021] = 1.12e-005 = pow(10.0, 0.05  -99.0dB) 
 [022] = 1.19e-005 = pow(10.0, 0.05  -98.5dB) 
 [023] = 1.26e-005 = pow(10.0, 0.05  -98.0dB) 
 [024] = 1.33e-005 = pow(10.0, 0.05  -97.5dB) 
 [025] = 1.41e-005 = pow(10.0, 0.05  -97.0dB) 
 [026] = 1.50e-005 = pow(10.0, 0.05  -96.5dB) 
 [027] = 1.58e-005 = pow(10.0, 0.05  -96.0dB) 
 [028] = 1.68e-005 = pow(10.0, 0.05  -95.5dB) 
 [029] = 1.78e-005 = pow(10.0, 0.05  -95.0dB) 
 [030] = 1.88e-005 = pow(10.0, 0.05  -94.5dB) 
 [031] = 2.00e-005 = pow(10.0, 0.05  -94.0dB) 
 [032] = 2.11e-005 = pow(10.0, 0.05  -93.5dB) 
 [033] = 2.24e-005 = pow(10.0, 0.05  -93.0dB) 
 [034] = 2.37e-005 = pow(10.0, 0.05  -92.5dB) 
 [035] = 2.51e-005 = pow(10.0, 0.05  -92.0dB) 
 [036] = 2.66e-005 = pow(10.0, 0.05  -91.5dB) 
 [037] = 2.82e-005 = pow(10.0, 0.05  -91.0dB) 
 [038] = 2.99e-005 = pow(10.0, 0.05  -90.5dB) 
 [039] = 3.16e-005 = pow(10.0, 0.05  -90.0dB) 
 [040] = 3.35e-005 = pow(10.0, 0.05  -89.5dB) 
 [041] = 3.55e-005 = pow(10.0, 0.05  -89.0dB) 
 [042] = 3.76e-005 = pow(10.0, 0.05  -88.5dB) 
 [043] = 3.98e-005 = pow(10.0, 0.05  -88.0dB) 
 [044] = 4.22e-005 = pow(10.0, 0.05  -87.5dB) 
 [045] = 4.47e-005 = pow(10.0, 0.05  -87.0dB) 
 [046] = 4.73e-005 = pow(10.0, 0.05  -86.5dB) 
 [047] = 5.01e-005 = pow(10.0, 0.05  -86.0dB) 
 [048] = 5.31e-005 = pow(10.0, 0.05  -85.5dB) 
 [049] = 5.62e-005 = pow(10.0, 0.05  -85.0dB) 
 [050] = 5.96e-005 = pow(10.0, 0.05  -84.5dB) 
 [051] = 6.31e-005 = pow(10.0, 0.05  -84.0dB) 
 [052] = 6.68e-005 = pow(10.0, 0.05  -83.5dB) 
 [053] = 7.08e-005 = pow(10.0, 0.05  -83.0dB) 
 [054] = 7.50e-005 = pow(10.0, 0.05  -82.5dB) 
 [055] = 7.94e-005 = pow(10.0, 0.05  -82.0dB) 
 [056] = 8.41e-005 = pow(10.0, 0.05  -81.5dB) 
 [057] = 8.91e-005 = pow(10.0, 0.05  -81.0dB) 
 [058] = 9.44e-005 = pow(10.0, 0.05  -80.5dB) 
 [059] = 1.00e-004 = pow(10.0, 0.05  -80.0dB) 
 [060] = 1.06e-004 = pow(10.0, 0.05  -79.5dB) 
 [061] = 1.12e-004 = pow(10.0, 0.05  -79.0dB) 
 [062] = 1.19e-004 = pow(10.0, 0.05  -78.5dB) 
 [063] = 1.26e-004 = pow(10.0, 0.05  -78.0dB) 
 [064] = 1.33e-004 = pow(10.0, 0.05  -77.5dB) 
 [065] = 1.41e-004 = pow(10.0, 0.05  -77.0dB) 
 [066] = 1.50e-004 = pow(10.0, 0.05  -76.5dB) 
 [067] = 1.58e-004 = pow(10.0, 0.05  -76.0dB) 
 [068] = 1.68e-004 = pow(10.0, 0.05  -75.5dB) 
 [069] = 1.78e-004 = pow(10.0, 0.05  -75.0dB) 
 [070] = 1.88e-004 = pow(10.0, 0.05  -74.5dB) 
 [071] = 2.00e-004 = pow(10.0, 0.05  -74.0dB) 
 [072] = 2.11e-004 = pow(10.0, 0.05  -73.5dB) 
 [073] = 2.24e-004 = pow(10.0, 0.05  -73.0dB) 
 [074] = 2.37e-004 = pow(10.0, 0.05  -72.5dB) 
 [075] = 2.51e-004 = pow(10.0, 0.05  -72.0dB) 
 [076] = 2.66e-004 = pow(10.0, 0.05  -71.5dB) 
 [077] = 2.82e-004 = pow(10.0, 0.05  -71.0dB) 
 [078] = 2.99e-004 = pow(10.0, 0.05  -70.5dB) 
 [079] = 3.16e-004 = pow(10.0, 0.05  -70.0dB) 
 [080] = 3.35e-004 = pow(10.0, 0.05  -69.5dB) 
 [081] = 3.55e-004 = pow(10.0, 0.05  -69.0dB) 
 [082] = 3.76e-004 = pow(10.0, 0.05  -68.5dB) 
 [083] = 3.98e-004 = pow(10.0, 0.05  -68.0dB) 
 [084] = 4.22e-004 = pow(10.0, 0.05  -67.5dB) 
 [085] = 4.47e-004 = pow(10.0, 0.05  -67.0dB) 
 [086] = 4.73e-004 = pow(10.0, 0.05  -66.5dB) 
 [087] = 5.01e-004 = pow(10.0, 0.05  -66.0dB) 
 [088] = 5.31e-004 = pow(10.0, 0.05  -65.5dB) 
 [089] = 5.62e-004 = pow(10.0, 0.05  -65.0dB) 
 [090] = 5.96e-004 = pow(10.0, 0.05  -64.5dB) 
 [091] = 6.31e-004 = pow(10.0, 0.05  -64.0dB) 
 [092] = 6.68e-004 = pow(10.0, 0.05  -63.5dB) 
 [093] = 7.08e-004 = pow(10.0, 0.05  -63.0dB) 
 [094] = 7.50e-004 = pow(10.0, 0.05  -62.5dB) 
 [095] = 7.94e-004 = pow(10.0, 0.05  -62.0dB) 
 [096] = 8.41e-004 = pow(10.0, 0.05  -61.5dB) 
 [097] = 8.91e-004 = pow(10.0, 0.05  -61.0dB) 
 [098] = 9.44e-004 = pow(10.0, 0.05  -60.5dB) 
 [099] = 1.00e-003 = pow(10.0, 0.05  -60.0dB) 
 [100] = 1.06e-003 = pow(10.0, 0.05  -59.5dB) 
 [101] = 1.12e-003 = pow(10.0, 0.05  -59.0dB) 
 [102] = 1.19e-003 = pow(10.0, 0.05  -58.5dB) 
 [103] = 1.26e-003 = pow(10.0, 0.05  -58.0dB) 
 [104] = 1.33e-003 = pow(10.0, 0.05  -57.5dB) 
 [105] = 1.41e-003 = pow(10.0, 0.05  -57.0dB) 
 [106] = 1.50e-003 = pow(10.0, 0.05  -56.5dB) 
 [107] = 1.58e-003 = pow(10.0, 0.05  -56.0dB) 
 [108] = 1.68e-003 = pow(10.0, 0.05  -55.5dB) 
 [109] = 1.78e-003 = pow(10.0, 0.05  -55.0dB) 
 [110] = 1.88e-003 = pow(10.0, 0.05  -54.5dB) 
 [111] = 2.00e-003 = pow(10.0, 0.05  -54.0dB) 
 [112] = 2.11e-003 = pow(10.0, 0.05  -53.5dB) 
 [113] = 2.24e-003 = pow(10.0, 0.05  -53.0dB) 
 [114] = 2.37e-003 = pow(10.0, 0.05  -52.5dB) 
 [115] = 2.51e-003 = pow(10.0, 0.05  -52.0dB) 
 [116] = 2.66e-003 = pow(10.0, 0.05  -51.5dB) 
 [117] = 2.82e-003 = pow(10.0, 0.05  -51.0dB) 
 [118] = 2.99e-003 = pow(10.0, 0.05  -50.5dB) 
 [119] = 3.16e-003 = pow(10.0, 0.05  -50.0dB) 
 [120] = 3.35e-003 = pow(10.0, 0.05  -49.5dB) 
 [121] = 3.55e-003 = pow(10.0, 0.05  -49.0dB) 
 [122] = 3.76e-003 = pow(10.0, 0.05  -48.5dB) 
 [123] = 3.98e-003 = pow(10.0, 0.05  -48.0dB) 
 [124] = 4.22e-003 = pow(10.0, 0.05  -47.5dB) 
 [125] = 4.47e-003 = pow(10.0, 0.05  -47.0dB) 
 [126] = 4.73e-003 = pow(10.0, 0.05  -46.5dB) 
 [127] = 5.01e-003 = pow(10.0, 0.05  -46.0dB) 
 [128] = 5.31e-003 = pow(10.0, 0.05  -45.5dB) 
 [129] = 5.62e-003 = pow(10.0, 0.05  -45.0dB) 
 [130] = 5.96e-003 = pow(10.0, 0.05  -44.5dB) 
 [131] = 6.31e-003 = pow(10.0, 0.05  -44.0dB) 
 [132] = 6.68e-003 = pow(10.0, 0.05  -43.5dB) 
 [133] = 7.08e-003 = pow(10.0, 0.05  -43.0dB) 
 [134] = 7.50e-003 = pow(10.0, 0.05  -42.5dB) 
 [135] = 7.94e-003 = pow(10.0, 0.05  -42.0dB) 
 [136] = 8.41e-003 = pow(10.0, 0.05  -41.5dB) 
 [137] = 8.91e-003 = pow(10.0, 0.05  -41.0dB) 
 [138] = 9.44e-003 = pow(10.0, 0.05  -40.5dB) 
 [139] = 1.00e-002 = pow(10.0, 0.05  -40.0dB) 
 [140] = 1.06e-002 = pow(10.0, 0.05  -39.5dB) 
 [141] = 1.12e-002 = pow(10.0, 0.05  -39.0dB) 
 [142] = 1.19e-002 = pow(10.0, 0.05  -38.5dB) 
 [143] = 1.26e-002 = pow(10.0, 0.05  -38.0dB) 
 [144] = 1.33e-002 = pow(10.0, 0.05  -37.5dB) 
 [145] = 1.41e-002 = pow(10.0, 0.05  -37.0dB) 
 [146] = 1.50e-002 = pow(10.0, 0.05  -36.5dB) 
 [147] = 1.58e-002 = pow(10.0, 0.05  -36.0dB) 
 [148] = 1.68e-002 = pow(10.0, 0.05  -35.5dB) 
 [149] = 1.78e-002 = pow(10.0, 0.05  -35.0dB) 
 [150] = 1.88e-002 = pow(10.0, 0.05  -34.5dB) 
 [151] = 2.00e-002 = pow(10.0, 0.05  -34.0dB) 
 [152] = 2.11e-002 = pow(10.0, 0.05  -33.5dB) 
 [153] = 2.24e-002 = pow(10.0, 0.05  -33.0dB) 
 [154] = 2.37e-002 = pow(10.0, 0.05  -32.5dB) 
 [155] = 2.51e-002 = pow(10.0, 0.05  -32.0dB) 
 [156] = 2.66e-002 = pow(10.0, 0.05  -31.5dB) 
 [157] = 2.82e-002 = pow(10.0, 0.05  -31.0dB) 
 [158] = 2.99e-002 = pow(10.0, 0.05  -30.5dB) 
 [159] = 3.16e-002 = pow(10.0, 0.05  -30.0dB) 
 [160] = 3.35e-002 = pow(10.0, 0.05  -29.5dB) 
 [161] = 3.55e-002 = pow(10.0, 0.05  -29.0dB) 
 [162] = 3.76e-002 = pow(10.0, 0.05  -28.5dB) 
 [163] = 3.98e-002 = pow(10.0, 0.05  -28.0dB) 
 [164] = 4.22e-002 = pow(10.0, 0.05  -27.5dB) 
 [165] = 4.47e-002 = pow(10.0, 0.05  -27.0dB) 
 [166] = 4.73e-002 = pow(10.0, 0.05  -26.5dB) 
 [167] = 5.01e-002 = pow(10.0, 0.05  -26.0dB) 
 [168] = 5.31e-002 = pow(10.0, 0.05  -25.5dB) 
 [169] = 5.62e-002 = pow(10.0, 0.05  -25.0dB) 
 [170] = 5.96e-002 = pow(10.0, 0.05  -24.5dB) 
 [171] = 6.31e-002 = pow(10.0, 0.05  -24.0dB) 
 [172] = 6.68e-002 = pow(10.0, 0.05  -23.5dB) 
 [173] = 7.08e-002 = pow(10.0, 0.05  -23.0dB) 
 [174] = 7.50e-002 = pow(10.0, 0.05  -22.5dB) 
 [175] = 7.94e-002 = pow(10.0, 0.05  -22.0dB) 
 [176] = 8.41e-002 = pow(10.0, 0.05  -21.5dB) 
 [177] = 8.91e-002 = pow(10.0, 0.05  -21.0dB) 
 [178] = 9.44e-002 = pow(10.0, 0.05  -20.5dB) 
 [179] = 1.00e-001 = pow(10.0, 0.05  -20.0dB) 
 [180] = 1.06e-001 = pow(10.0, 0.05  -19.5dB) 
 [181] = 1.12e-001 = pow(10.0, 0.05  -19.0dB) 
 [182] = 1.19e-001 = pow(10.0, 0.05  -18.5dB) 
 [183] = 1.26e-001 = pow(10.0, 0.05  -18.0dB) 
 [184] = 1.33e-001 = pow(10.0, 0.05  -17.5dB) 
 [185] = 1.41e-001 = pow(10.0, 0.05  -17.0dB) 
 [186] = 1.50e-001 = pow(10.0, 0.05  -16.5dB) 
 [187] = 1.58e-001 = pow(10.0, 0.05  -16.0dB) 
 [188] = 1.68e-001 = pow(10.0, 0.05  -15.5dB) 
 [189] = 1.78e-001 = pow(10.0, 0.05  -15.0dB) 
 [190] = 1.88e-001 = pow(10.0, 0.05  -14.5dB) 
 [191] = 2.00e-001 = pow(10.0, 0.05  -14.0dB) 
 [192] = 2.11e-001 = pow(10.0, 0.05  -13.5dB) 
 [193] = 2.24e-001 = pow(10.0, 0.05  -13.0dB) 
 [194] = 2.37e-001 = pow(10.0, 0.05  -12.5dB) 
 [195] = 2.51e-001 = pow(10.0, 0.05  -12.0dB) 
 [196] = 2.66e-001 = pow(10.0, 0.05  -11.5dB) 
 [197] = 2.82e-001 = pow(10.0, 0.05  -11.0dB) 
 [198] = 2.99e-001 = pow(10.0, 0.05  -10.5dB) 
 [199] = 3.16e-001 = pow(10.0, 0.05  -10.0dB) 
 [200] = 3.35e-001 = pow(10.0, 0.05  -9.5dB) 
 [201] = 3.55e-001 = pow(10.0, 0.05  -9.0dB) 
 [202] = 3.76e-001 = pow(10.0, 0.05  -8.5dB) 
 [203] = 3.98e-001 = pow(10.0, 0.05  -8.0dB) 
 [204] = 4.22e-001 = pow(10.0, 0.05  -7.5dB) 
 [205] = 4.47e-001 = pow(10.0, 0.05  -7.0dB) 
 [206] = 4.73e-001 = pow(10.0, 0.05  -6.5dB) 
 [207] = 5.01e-001 = pow(10.0, 0.05  -6.0dB) 
 [208] = 5.31e-001 = pow(10.0, 0.05  -5.5dB) 
 [209] = 5.62e-001 = pow(10.0, 0.05  -5.0dB) 
 [210] = 5.96e-001 = pow(10.0, 0.05  -4.5dB) 
 [211] = 6.31e-001 = pow(10.0, 0.05  -4.0dB) 
 [212] = 6.68e-001 = pow(10.0, 0.05  -3.5dB) 
 [213] = 7.08e-001 = pow(10.0, 0.05  -3.0dB) 
 [214] = 7.50e-001 = pow(10.0, 0.05  -2.5dB) 
 [215] = 7.94e-001 = pow(10.0, 0.05  -2.0dB) 
 [216] = 8.41e-001 = pow(10.0, 0.05  -1.5dB) 
 [217] = 8.91e-001 = pow(10.0, 0.05  -1.0dB) 
 [218] = 9.44e-001 = pow(10.0, 0.05  -0.5dB) 
 [219] = 1.00e+000 = pow(10.0, 0.05  0.0dB) 
 [220] = 1.06e+000 = pow(10.0, 0.05  0.5dB) 
 [221] = 1.12e+000 = pow(10.0, 0.05  1.0dB) 
 [222] = 1.19e+000 = pow(10.0, 0.05  1.5dB) 
 [223] = 1.26e+000 = pow(10.0, 0.05  2.0dB) 
 [224] = 1.33e+000 = pow(10.0, 0.05  2.5dB) 
 [225] = 1.41e+000 = pow(10.0, 0.05  3.0dB) 
 [226] = 1.50e+000 = pow(10.0, 0.05  3.5dB) 
 [227] = 1.58e+000 = pow(10.0, 0.05  4.0dB) 
 [228] = 1.68e+000 = pow(10.0, 0.05  4.5dB) 
 [229] = 1.78e+000 = pow(10.0, 0.05  5.0dB) 
 [230] = 1.88e+000 = pow(10.0, 0.05  5.5dB) 
 [231] = 2.00e+000 = pow(10.0, 0.05  6.0dB) 
 [232] = 2.11e+000 = pow(10.0, 0.05  6.5dB) 
 [233] = 2.24e+000 = pow(10.0, 0.05  7.0dB) 
 [234] = 2.37e+000 = pow(10.0, 0.05  7.5dB) 
 [235] = 2.51e+000 = pow(10.0, 0.05  8.0dB) 
 [236] = 2.66e+000 = pow(10.0, 0.05  8.5dB) 
 [237] = 2.82e+000 = pow(10.0, 0.05  9.0dB) 
 [238] = 2.99e+000 = pow(10.0, 0.05  9.5dB) 
 [239] = 3.16e+000 = pow(10.0, 0.05  10.0dB) 
 [240] = 3.35e+000 = pow(10.0, 0.05  10.5dB) 
 [241] = 3.55e+000 = pow(10.0, 0.05  11.0dB) 
 [242] = 3.76e+000 = pow(10.0, 0.05  11.5dB) 
 [243] = 3.98e+000 = pow(10.0, 0.05  12.0dB) 
 [244] = 4.22e+000 = pow(10.0, 0.05  12.5dB) 
 [245] = 4.47e+000 = pow(10.0, 0.05  13.0dB) 
 [246] = 4.73e+000 = pow(10.0, 0.05  13.5dB) 
 [247] = 5.01e+000 = pow(10.0, 0.05  14.0dB) 
 [248] = 5.31e+000 = pow(10.0, 0.05  14.5dB) 
 [249] = 5.62e+000 = pow(10.0, 0.05  15.0dB) 
 [250] = 5.96e+000 = pow(10.0, 0.05  15.5dB) 
 [251] = 6.31e+000 = pow(10.0, 0.05  16.0dB) 
 [252] = 6.68e+000 = pow(10.0, 0.05  16.5dB) 
 [253] = 7.08e+000 = pow(10.0, 0.05  17.0dB) 
 [254] = 7.50e+000 = pow(10.0, 0.05  17.5dB) 
 [255] = 7.94e+000 = pow(10.0, 0.05  18.0dB) 
 -109.5 dB 
  18.0 dB 
  0.0 dB 
 AES playback 
 analog playback 
 only when pipe exists ! 
 only when pipe exists ! 
 shared 
 -109.5 dB 
   18.0 dB 
 index 
 AES capture 
 analog capture 
 AES playback 
 analog playback 
 index 
 AES capture 
 analog capture 
 AES playback 
 analog playback 
 name will be filled later 
 count will be filled later 
 shared 
 index 
 AES playback 
 index 
 name will be filled later 
 shared 
 no pipe defined 
  monitoring level control
 shared 
  monitoring switch control
 mask 0x01 ans 0x02 
 allocate or release resources for monitoring 
 allocate the playback pipe for monitoring 
 allocate the capture pipe for monitoring 
 release the capture pipe for monitoring 
 release the playback pipe for monitoring 
 shared 
 analog volumes can be set even if there is no pipe 
 analog levels for capture only on the first two chips 
 can be in another place 
 analog output level control 
 playback 
 output mute controls 
 analog input level control only on first two chips !
 capture 
 playback analog 
 capture analog 
 playback AESEBU 
 capture AESEBU 
 playback analog 
 playback AESEBU 
 monitoring 
 init all mixer data and program the master volumesswitches 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for Digigram miXart soundcards
  main file with alsa callbacks
  Copyright (c) 2003 by Digigram <alsa@digigram.com>
 Index 0-MAX 
 ID for this card 
 Enable this card 
 MC8240 
 already started 
 already stopped 
 function called with wrong pipe status 
 the event ! (take care: the MSB and two LSB's have to be 0) 
 wait on the last MSG_SYSTEM_SEND_SYNCHRO_CMD command to be really finished 
 start or stop the pipe (1 pipe) 
(struct mixart_uid){0,0};
 in case of start same command once again with pipe_count=0 
 in case of start send a synchro top 
 !start 
 nothing to do 
 only one entry in uid_caller ! 
   Allocate or reference output pipe for analog IOs (pcmp01)
 analog inputs 
 digital inputs 
 analog outputs 
 digital outputs 
 a new stream is opened and there are already all streams in use 
 pipe is not yet defined 
 should be StreamManagerUID, but zero is OK if there is only one ! 
 the left connector 
 we don't yet know the format, so config 16 bit pcm audio for instance 
 is 4.0f 
 find the right bufferinfo_array 
 in the array capture is behind playback 
 1 will set the miXart to ring-buffer mode ! 
 buffer is not yet allocated 
 buffer is not yet allocated 
 construct the identifier of the stream buffer received in the interrupts ! 
 id of the pipe, as returned by embedded 
 pipe->stream_uid[i] = buf->sgroup_resp.stream[i].stream_uid; 
 release the clock 
 stop the pipe 
 the streaming group ! 
 delete the pipe 
 reset stream pos      
   Trigger callback
 START_STREAM 
 STOP_STREAM 
 TODO 
 TODO 
   prepare callback for all pcms
 TODO de faon non bloquante, rappliquer les hw_params (rate, bits, codec) 
 only the first stream can choose the sample rate 
 the further opened streams will be limited to its frequency (see open) 
 set the clock only once (first stream) on the same pipe 
 if frequency not yet defined, use some default 
 TODO: what else to configure ? 
 stream_param.samples_per_frame = 2; 
 stream_param.bytes_per_frame = 4; 
 stream_param.bytes_per_sample = 2; 
 set to 1 
 set to 1 
   HW_PARAMS callback for all pcms
 set up channels 
  set up format for the stream 
 update the stream levels 
 set the format to the board 
 in array capture is behind playback 
 bufferinfo[i].buffer_id  is already defined 
   TODO CONFIGURATION SPACE for all pcms, mono pcm must update channels_max
 256 frames U8 mono
 256 frames U8 mono
 get stream info 
 streams in use 
 get pipe pointer (out pipe) 
 start the pipe if necessary 
 not configured yet 
 if a sample rate is already used, another stream cannot change 
 for instance, no mono 
 get stream info 
 streams in use 
 get pipe pointer (in pipe) 
 start the pipe if necessary 
 not configured yet 
 if a sample rate is already used, another stream cannot change 
 sample rate released 
 delete pipe 
 set up the unique device id with the chip index 
  release all the cards assigned to a manager instance
 stop mailbox 
 release irq  
 reset board if some firmware was loaded 
 release the io ports 
 free flowarray 
 free bufferarray 
  proc interface
  mixart_BA0 proc interface for BAR 0 - read callback
 make sure the read size is a multiple of 4 bytes 
  mixart_BA1 proc interface for BAR 1 - read callback
 make sure the read size is a multiple of 4 bytes 
 stats available when embedded OS is running 
 get perf reference 
 endif elf loaded 
 text interface to read perf and temp meters 
 end of proc interface 
     probe function - creates the card manager
	
 enable PCI device 
 check if we can restrict PCI DMA transfers to 32 bits 
	
 resource assignment 
 init mailbox  
 init setup mutex
 card assignment 
 4  FIXME: configurable? 
 init proc interface only for chip0 
 init firmware status (mgr->dsp_loaded reset in hwdep_new) 
 create array of streaminfo 
 init streaminfo_array 
 create array of bufferinfo 
 init bufferinfo_array 
 set up firmware 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for Digigram miXart soundcards
  low level interface with interrupt handling and mail box implementation
  Copyright (c) 2003 by Digigram <alsa@digigram.com>
 400 ms 
 mask for following types 
 embedded -> driver (only notification, do not get_msg() !) 
 driver <-> embedded (a command has no answer) 
 driver -> embedded (request will get an answer back) 
 embedded -> driver 
 this bit is set for a notification that has been canceled 
 read the message frame fifo 
 no message posted 
 error 
 error 
 increment the tail index 
 copy message descriptor from miXart to driver 
 size of descriptor + response 
 dwMessageID 
 uidDest 
 swap if necessary 
 u32 size 
	
	  free message frame address
 give address back to outbound fifo 
 increment the outbound free head 
  send a message to miXart. return: the msg_frame used for this message
 call with mgr->msg_lock held! 
 get message frame address 
 set address to zero on this fifo position 
 increment the inbound free tail 
 TODO : use memcpy_toio() with intermediate buffer to copy the message 
 copy message descriptor to card memory 
 size of descriptor + request 
 dwMessageID 
 uidDest 
 SizeHeader 
 OffsetDLL_T16 
 SizeDLL_T16 
 OffsetDLL_DRV 
 SizeDLL_DRV 
 dwExpectedAnswerSize 
 copy message data to card memory 
 the pending event is the notification we wait for ! 
 the pending event is the answer we wait for (same address than the request)! 
 copy address back to caller 
 mark the frame as a request (will have an answer) 
 post the frame 
 increment the inbound post head 
 set to 0, so it's no notification to wait for, but the answer 
 send the message 
 send and mark the answer pending 
 error - no ack 
 retrieve the answer into the same struct mixart_msg 
 send the message 
 send and mark the notification event pending 
 error - no ack 
 just send the message (do not mark it as a pending one) 
 the answer will be handled by snd_struct mixart_msgasklet()  
 common buffer of interrupt to sendreceive messages 
 process the message ... 
 answer to a message on that we did not wait for (send_msg_nonblock) 
 msg contains no address ! do not get_msg() ! 
 get_msg() necessary 
 switch type 
 decrement counter 
 while there is a msg in fifo 
 this device did not cause the interrupt 
 mask all interrupts 
 outdoorbell register clear 
 clear interrupt 
 process interrupt 
 card0 to 3 
 pcm0 to 3  
 0 to MIXART_PLAYBACK_STREAMS 
 playback == 0  capture == 1 
 while 
 Traces are text: the swapped msg_data has to be swapped back ! 
 answer or notification to a message we are waiting for
 answer to a message we did't want to wait for 
 TODO : are there things to do here ? 
 switch on msg type 
 while there are msgs 
 allow interrupt again 
 allow outbound messagebox to generate interrupts 
 no more interrupts on outbound messagebox 
 reset miXart 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for Digigram miXart soundcards
  DSP firmware management
  Copyright (c) 2003 by Digigram <alsa@digigram.com>
  mixart_wait_nice_for_register_value - wait for a value on a peudo register,
  exit with a timeout
  @mgr: pointer to miXart manager structure
  @offset: unsigned pseudo_register base + offset of value
  @is_egal: wait for the equal value
  @value: value
  @timeout: timeout in centisenconds
	do {	 we may take too long time in this loop.
		  so give controls back to kernel if needed.
 wait for different value 
  structures needed to upload elf code packets 
  get basic information and init miXart
 audio IDs for request to the board 
 board num = 0 
 odd 
 even 
 dev_dbg(&mgr->pci->dev, "playback connector[%d].object_id = %x\n", k, connector->uid[k].object_id); 
 TODO: really need send_msg MSG_CONNECTOR_GET_AUDIO_INFO for each connector ? perhaps for analog level caps ? 
dev_dbg(&mgr->pci->dev, "play  analog_info.analog_level_present = %x\n", audio_info->info.analog_info.analog_level_present);
 board num = 0 
 odd 
 even 
 dev_dbg(&mgr->pci->dev, "capture connector[%d].object_id = %x\n", k, connector->uid[k].object_id); 
 TODO: really need send_msg MSG_CONNECTOR_GET_AUDIO_INFO for each connector ? perhaps for analog level caps ? 
dev_dbg(&mgr->pci->dev, "rec  analog_info.analog_level_present = %x\n", audio_info->info.analog_info.analog_level_present);
 get the uid for the console manager 
 cardindex = 0 
 used later for clock issues ! 
 min 2 phys io per card (analog in + analog out) 
 send a synchro command to card (necessary to do this before first MSG_STREAM_START_STREAM_GRP_PACKET) 
 though why not here 
 this command has no data. response is a 32 bit status 
 firmware base addresses (when hard coded) 
 read motherboard xilinx status 
 read elf status 
 read daughterboard xilinx status 
 motherboard xilinx status 5 will say that the board is performing a reset 
 try again later 
 xilinx already loaded ?  
 the status should be 0 == "idle" 
 modprob -r may help ? 
 check xilinx validity 
 set xilinx status to copying 
 setup xilinx base address 
 setup code size for xilinx file 
 copy xilinx code 
 set xilinx status to copy finished 
 return, because no further processing needed 
 the status should be 0 == "idle" 
 modprob -r may help ? 
 wait for xilinx status == 4 
 5sec 
 init some data on the card 
 set miXart boardnumber to 0 
 reset pointer to flow table on miXart 
 set elf status to copying 
 process the copying of the elf packets 
 set elf status to copy finished 
 wait for elf status == 4 
 3sec 
 miXart waits at this point on the pointer to the flow table 
 give pointer of flow table to miXart 
 return, another xilinx file has to be loaded before 
 elf and xilinx should be loaded 
 modprob -r may help ? 
 wait for daughter detection != 0 
 300msec 
 the board type can now be retrieved 
 no daughter board; the file does not have to be loaded, continue after the switch 
 only if aesebu daughter board presence (elf code must run)   
 daughter should be idle 
 modprob -r may help ? 
 check daughterboard xilinx validity 
 inform mixart about the size of the file 
 set daughterboard status to 1 
 wait for status == 2 
 300msec 
 get the address where to write the file 
 copy daughterboard xilinx code 
 set daughterboard status to 4 
 continue with init 
 end of switch file index
 wait for daughter status == 3 
 3sec 
 init mailbox (communication with embedded) 
 first communication with embedded 
 create devices and mixer in accordance with HW options
 fake hwdep dsp record 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) 2004 James Courtier-Dutton <James@superbug.demon.co.uk>
   Driver CA0106 chips. e.g. Sound Blaster Audigy LS and Live 24bit
   Version: 0.0.18
   FEATURES currently supported:
     See ca0106_main.c for features.
   Changelog:
     Support interrupts per period.
     Removed noise from CenterLFE channel when in Analog mode.
     Rename and remove mixer controls.
   0.0.6
     Use separate card based DMA buffer for periods table list.
   0.0.7
     Change remove and rename ctrls into lists.
   0.0.8
     Try to fix capture sources.
   0.0.9
     Fix AC3 output.
     Enable S32_LE format support.
   0.0.10
     Enable playback 48000 and 96000 rates. (Rates other that these do not work, even with "plug:front".)
   0.0.11
     Add Model name recognition.
   0.0.12
     Correct interrupt timing. interrupt at end of period, instead of in the middle of a playback period.
     Remove redundent "voice" handling.
   0.0.13
     Single trigger call for multi channels.
   0.0.14
     Set limits based on what the sound card hardware can do.
     playback periods_min=2, periods_max=8
     capture hw constraints require period_size = n  64 bytes.
     playback hw constraints require period_size = n  64 bytes.
   0.0.15
     Separated ca0106.c into separate functional .c files.
   0.0.16
     Modified Copyright message.
   0.0.17
     Implement Mic and Line in Capture.
   0.0.18
     Add support for mute control on SB Live 24bit (cards w SPI DAC)
   This code was initially based on code from ALSA's emu10k1x.c which is:
   Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>
 Digital 
 Analog 
 Mute input 
 Left 
 Left 
 Right 
 Right 
 Set source 
 snd_ca0106_i2c_write(emu, ADC_MUX, 0);  
 snd_ca0106_i2c_write(emu, ADC_MUX, ADC_MUX_MIC); 
 snd_ca0106_i2c_write(emu, ADC_MUX, 0);  
 snd_ca0106_i2c_write(emu, ADC_MUX, ADC_MUX_LINEIN); 
	 If the capture source has changed,
	  update the capture volume from the cached value
	  for the particular source.
		 FIXME: this isn't safe, but needed to keep the compatibility
		  with older alsa-lib config
 Left 
 Right 
 Left 
 Right 
 bit already cleared, do nothing 
 bit already set, do nothing 
 Unused channel 
 FIXME: strcpy is bad. 
 gpio_type == 2 
 Create virtual master controls 
 save volumes 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) 2004 James Courtier-Dutton <James@superbug.demon.co.uk>
   Driver CA0106 chips. e.g. Sound Blaster Audigy LS and Live 24bit
   Version: 0.0.18
   FEATURES currently supported:
     See ca0106_main.c for features.
   Changelog:
     Support interrupts per period.
     Removed noise from CenterLFE channel when in Analog mode.
     Rename and remove mixer controls.
   0.0.6
     Use separate card based DMA buffer for periods table list.
   0.0.7
     Change remove and rename ctrls into lists.
   0.0.8
     Try to fix capture sources.
   0.0.9
     Fix AC3 output.
     Enable S32_LE format support.
   0.0.10
     Enable playback 48000 and 96000 rates. (Rates other that these do not work, even with "plug:front".)
   0.0.11
     Add Model name recognition.
   0.0.12
     Correct interrupt timing. interrupt at end of period, instead of in the middle of a playback period.
     Remove redundent "voice" handling.
   0.0.13
     Single trigger call for multi channels.
   0.0.14
     Set limits based on what the sound card hardware can do.
     playback periods_min=2, periods_max=8
     capture hw constraints require period_size = n  64 bytes.
     playback hw constraints require period_size = n  64 bytes.
   0.0.15
     Separate ca0106.c into separate functional .c files.
   0.0.16
     Modified Copyright message.
   0.0.17
     Add iec958 file in proc file system to show status of SPDIF in.
   0.0.18
     Implement support for Line-in capture on SB Live 24bit.
   This code was initially based on code from ALSA's emu10k1x.c which is:
   Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>
 consumer 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright 10162005 Tilman Kranz <tilde@tk-sls.de>
   Creative Audio MIDI, for the CA0106 Driver
   Version: 0.0.1
   Changelog:
     Implementation is based on mpu401 and emu10k1x and
     tested with ca0106.
     mpu401: Copyright (c) by Jaroslav Kysela <perex@perex.cz>
     emu10k1x: Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>
 ca_midi_clear_rx(midi); 
 try to send some amount of bytes here before interrupts 
 no more data 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) 2004 James Courtier-Dutton <James@superbug.demon.co.uk>
   Driver CA0106 chips. e.g. Sound Blaster Audigy LS and Live 24bit
   Version: 0.0.25
   FEATURES currently supported:
     Front, Rear and CenterLFE.
     Surround40 and Surround51.
     Capture from MIC an LINE IN input.
     SPDIF digital playback of PCM stereo and AC3DTS works.
     (One can use a standard mono mini-jack to one RCA plugs cable.
      or one can use a standard stereo mini-jack to two RCA plugs cable.
      Plug one of the RCA plugs into the Coax input of the external decoderreceiver.)
     ( In theory one could output 3 different AC3 streams at once, to 3 different SPDIF outputs. )
     Notes on how to capture sound:
       The AC97 is used in the PLAYBACK direction.
       The output from the AC97 chip, instead of reaching the speakers, is fed into the Philips 1361T ADC.
       So, to record from the MIC, set the MIC Playback volume to max,
       unmute the MIC and turn up the MASTER Playback volume.
       So, to prevent feedback when capturing, minimise the "Capture feedback into Playback" volume.
     The only playback controls that currently do anything are: -
     Analog Front
     Analog Rear
     Analog CenterLFE
     SPDIF Front
     SPDIF Rear
     SPDIF CenterLFE
     For capture from Mic in or Line in.
     DigitalAnalog ( switch must be in Analog mode for CAPTURE. )
     CAPTURE feedback into PLAYBACK
   Changelog:
     Support interrupts per period.
     Removed noise from CenterLFE channel when in Analog mode.
     Rename and remove mixer controls.
   0.0.6
     Use separate card based DMA buffer for periods table list.
   0.0.7
     Change remove and rename ctrls into lists.
   0.0.8
     Try to fix capture sources.
   0.0.9
     Fix AC3 output.
     Enable S32_LE format support.
   0.0.10
     Enable playback 48000 and 96000 rates. (Rates other that these do not work, even with "plug:front".)
   0.0.11
     Add Model name recognition.
   0.0.12
     Correct interrupt timing. interrupt at end of period, instead of in the middle of a playback period.
     Remove redundent "voice" handling.
   0.0.13
     Single trigger call for multi channels.
   0.0.14
     Set limits based on what the sound card hardware can do.
     playback periods_min=2, periods_max=8
     capture hw constraints require period_size = n  64 bytes.
     playback hw constraints require period_size = n  64 bytes.
   0.0.15
     Minor updates.
   0.0.16
     Implement 192000 sample rate.
   0.0.17
     Add support for SB0410 and SB0413.
   0.0.18
     Modified Copyright message.
   0.0.19
     Finally fix support for SB Live 24 bit. SB0410 and SB0413.
     The output codec needs resetting, otherwise all output is muted.
   0.0.20
     Merge "pci_disable_device(pci);" fixes.
   0.0.21
     Add 4 capture channels. (SPDIF only comes in on channel 0. )
     Add SPDIF capture using optional digital IO module for SB Live 24bit. (Analog capture does not yet work.)
   0.0.22
     Add support for MSI K8N Diamond Motherboard with onboard SB Live 24bit without AC97. From kiksen, bug #901
   0.0.23
     Implement support for Line-in capture on SB Live 24bit.
   0.0.24
     Add support for mute control on SB Live 24bit (cards w SPI DAC)
   0.0.25
     Powerdown SPI DAC channels when not in use
   BUGS:
     Some stability problems when unloading the snd-ca0106 kernel module.
     --
   TODO:
     4 Capture channels, only one implemented so far.
     Other capture rates apart from 48khz not implemented.
     MIDI
     --
   GENERAL INFO:
     Model: SB0310
     P17 Chip: CA0106-DAT
     AC97 Codec: STAC 9721
     ADC: Philips 1361T (Stereo 24bit)
     DAC: WM8746EDS (6-channel, 24bit, 192Khz)
   GENERAL INFO:
     Model: SB0410
     P17 Chip: CA0106-DAT
     AC97 Codec: None
     ADC: WM8775EDS (4 Channel)
     DAC: CS4382 (114 dB, 24-Bit, 192 kHz, 8-Channel DA Converter with DSD Support)
     SPDIF Out control switches between Mic in and SPDIF out.
     No sound out or mic input working yet.
   GENERAL INFO:
     Model: SB0413
     P17 Chip: CA0106-DAT
     AC97 Codec: None.
     ADC: Unknown
     DAC: Unknown
     Trying to handle it like the SB0410.
   This code was initially based on code from ALSA's emu10k1x.c which is:
   Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>
 module parameters (see "Module Parameters")
 Force card subsystem model 
 Sound Blaster X-Fi Extreme Audio. This does not have an AC97. 53SB079000000 
 It is really just a normal SB Live 24bit. 
	  Tested:
	   See ALSA bug#3251
 Sound Blaster X-Fi Extreme Audio. This does not have an AC97. 53SB079000000 
 It is really just a normal SB Live 24bit. 
	 
 	   CTRL:CA0111-WTLF
	   ADC: WM8775SEDS
	   DAC: CS4382-KQZ
	  Tested:
	   Playback on front, rear, centerlfe speakers
	   Capture from Mic in.
	   Not-Tested:
	   Capture from Line in.
	   Playback to digital out.
 New Dell Sound Blaster Live! 7.1 24bit. This does not have an AC97.  
 AudigyLS[SB0310] 
 Unknown AudigyLS that also says SB0310 on it 
 New Sound Blaster Live! 7.1 24bit. This does not have an AC97. 53SB041000001 
 New Dell Sound Blaster Live! 7.1 24bit. This does not have an AC97.  
 New Audigy SE. Has a different DAC. 
	  SB0570:
	   CTRL:CA0106-DAT
	   ADC: WM8775EDS
	   DAC: WM8768GEDS
 New Audigy LS. Has a different DAC. 
	  SB0570:
	   CTRL:CA0106-DAT
	   ADC: WM8775EDS
	   DAC: WM8768GEDS
	 Sound Blaster 5.1vx
	  Tested: Playback on front, rear, centerlfe speakers
	  Not-Tested: Capture
 MSI K8N Diamond Motherboard with onboard SB Live 24bit without AC97 
	  SB0438
	   CTRL:CA0106-DAT
	   ADC: WM8775SEDS
	   DAC: CS4382-KQZ
 MSI K8N Diamond PLUS MB 
	 Giga-byte GA-G1975X mobo
	  Novell bnc#395807
 FIXME: the GPIO and I2C setting aren't tested well 
	  Shuttle XPC SD31P which has an onboard Creative Labs
	   Sound Blaster Live! 24-bit EAX
	   high-definition 7.1 audio processor".
	   Added using info from andrewvegan in alsa bug #1298
	 Shuttle XPC SD11G5 which has an onboard Creative Labs
	  Sound Blaster Live! 24-bit EAX
	  high-definition 7.1 audio processor".
	  Fixes ALSA bug#1600
 hardware definition 
1,
6,
 FIXME: looks like 44.1kHz capture causes noisy output on 48kHz 
 FIXME 
 Only 16bit values allowed 
 Set xxx20000 
 Set xxx1xxxx 
 write post 
 Wait for status bit to return to 0 
 Timed out 
 Write post 
 The ADC does not support i2c read, so only write is implemented 
	
	dev_dbg(emu->card->dev, "I2C-write:reg=0x%x, value=0x%x\n", reg, value);
 Not sure what this I2C channel controls. 
 snd_ca0106_ptr_write(emu, I2C_D0, 0, tmp); 
 This controls the I2C connected to the WM8775 ADC Codec 
 Send the data to i2c 
tmp = snd_ca0106_ptr_read(emu, I2C_A, 0);
tmp = tmp & ~(I2C_A_ADC_READ|I2C_A_ADC_LAST|I2C_A_ADC_START|I2C_A_ADC_ADD_MASK);
 Wait till the transaction ends 
dev_dbg(emu->card->dev, "I2C:status=0x%x\n", status);
Read back and see if the transaction is successful
 Power up 
 Power down 
 open_playback callback 
	
	dev_dbg(chip->card->dev, "open:channel_id=%d, chip=%p, channel=%p\n",
	       channel_id, chip, channel);
channel->interrupt = snd_ca0106_pcm_channel_interrupt;
 Front channel dac should already be on 
 close callback 
 Front channel dac should stay on 
 FIXME: maybe zero others 
 open_capture callback 
	
	dev_dbg(chip->card->dev, "open:channel_id=%d, chip=%p, channel=%p\n",
	       channel_id, chip, channel);
channel->interrupt = snd_ca0106_pcm_channel_interrupt;
snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, &hw_constraints_capture_period_sizes);
 close callback 
 FIXME: maybe zero others 
 prepare playback callback 
 FIXME: Depending on mixer selection of SPDIF out or not, select the spdif rate or the DAC rate. 
 Global. Set SPDIF rate. We only support 44100 to spdif, not to DAC. 
 debug 
 debug 
 Rate can be set per channel. 
 reg40 control host to fifo 
 reg71 controls DAC rate. 
 Format is a global setting 
 FIXME: Only let the first channel accessed set this. 
 FIXME: Check emu->buffer->size before actually writing to it. 
 buffer size in bytes
 FIXME  test what 0 bytes does. 
 buffer size in bytes
 Unmute output 
 prepare capture callback 
 Global. Set ADC rate. 
 debug 
 debug 
 reg71 controls ADC rate. 
 Format is a global setting 
 FIXME: Only let the first channel accessed set this. 
 The SB0410 and SB0413 use I2C to control ADC. 
 Adjust the over sampler to better suit the capture rate. 
	
	dev_dbg(emu->card->dev,
	       "prepare:channel_number=%d, rate=%d, format=0x%x, channels=%d, "
	       "buffer_size=%ld, period_size=%ld, frames_to_bytes=%d\n",
	       channel, runtime->rate, runtime->format, runtime->channels,
	       runtime->buffer_size, runtime->period_size,
	       frames_to_bytes(runtime, 1));
 buffer size in bytes
 trigger_playback callback 
 dev_dbg(emu->card->dev, "channel=%d\n", channel); 
 dev_dbg(emu->card->dev, "basic=0x%x, extended=0x%x\n",basic, extended); 
 trigger_capture callback 
 pointer_playback callback 
 pointer_capture callback 
	
	dev_dbg(emu->card->dev, "ptr1 = 0x%lx, ptr2=0x%lx, ptr=0x%lx, "
	       "buffer_size = 0x%x, period_size = 0x%x, bits=%d, rate=%d\n",
	       ptr1, ptr2, ptr, (int)runtime->buffer_size,
	       (int)runtime->period_size, (int)runtime->frame_bits,
	       (int)runtime->rate);
 operators 
 we don't need VRA 
	
	dev_dbg(emu->card->dev, "interrupt status = 0x%08x, stat76=0x%08x\n",
		   status, stat76);
	dev_dbg(emu->card->dev, "ptr=0x%08x\n",
		   snd_ca0106_ptr_read(chip, PLAYBACK_POINTER, 0));
 0x1 for one half, 0x10 for the other half period. 
 FIXME: Select the correct substream for period elapsed 
 dev_dbg(emu->card->dev, "interrupt [%d] used\n", i); 
		
		dev_dbg(emu->card->dev, "channel=%p\n", pchannel);
		dev_dbg(emu->card->dev, "interrupt stat76[%d] = %08x, use=%d, channel=%d\n", i, stat76, pchannel->use, pchannel->number);
 0x1 for one half, 0x10 for the other half period. 
 FIXME: Select the correct substream for period elapsed 
 dev_dbg(emu->card->dev, "interrupt [%d] used\n", i); 
		
		dev_dbg(emu->card->dev, "channel=%p\n", pchannel);
		dev_dbg(emu->card->dev, "interrupt stat76[%d] = %08x, use=%d, channel=%d\n", i, stat76, pchannel->use, pchannel->number);
 acknowledge the interrupt if necessary
 0dB dig. attenuation 
 Reset 
 Timeout 
 Interface control 
 Master mode control 
 Powerdown control 
 Attenuation Left  0x01 = -103dB, 0xff = 24dB 
 Attenuation Right 0.5dB steps 
 ALC Control 1 
 ALC Control 2 
 ALC Control 3 
 Noise gate control 
 Limiter control 
 ADC Mixer control 
	
	   Init to 0x02109204 :
	   Clock accuracy    = 0     (1000ppm)
	   Sample Rate       = 2     (48kHz)
	   Audio Channel     = 1     (Left of 2)
	   Source Number     = 0     (Unspecified)
	   Generation Status = 1     (Original for Cat Code 12)
	   Cat Code          = 12    (Digital Signal Mixer)
	   Mode              = 0     (Mode 0)
	   Emphasis          = 0     (None)
	   CP                = 1     (Copyright unasserted)
	   AN                = 0     (Audio data)
	   P                 = 0     (Consumer)
 Only SPCS1 has been tested 
 Write 0x8000 to AC97_REC_GAIN to mute it. 
 FIXME: what are these? 
 OSS drivers set this. 
 snd_ca0106_ptr_write(chip, SPDIF_SELECT2, 0, 0xf0f003f); 
 Analog or Digital output 
	 0x0b000000 for digital, 0x000b0000 for analog, from win2000 drivers.
	  Use 0x000f0000 for surround71
 Set digital SPDIF output off 
snd_ca0106_ptr_write(chip, 0x45, 0, 0); 
snd_ca0106_ptr_write(chip, 0x45, 0, 0xf00); 
 goes to 0x40c80000 when doing SPDIF INOUT 
	 (Mute) CAPTURE feedback into PLAYBACK volume.
	  Only lower 16 bits matter.
 SPDIF IN Volume 
 SPDIF IN Volume, 0x70 = (vol & 0x3f) | 0x40 
 Only high 16 bits matter 
 Mute 
 Select MIC, Line in, TAD in, AUX in 
 Default to CAPTURE_SOURCE to i2s in 
 Default to AC97 in 
 Default to CAPTURE_SOURCE to AC97 in 
 Select MIC, Line in, TAD in, AUX in 
 Default to Set CAPTURE_SOURCE to i2s in 
 The SB0438 use GPIO differently. 
		 FIXME: Still need to find out what the other GPIO bits do.
		  E.g. For digital spdif out.
 outl(0x00f0e000, chip->port+GPIO);  
 Analog 
 The SB0410 and SB0413 use GPIO differently. 
		 FIXME: Still need to find out what the other GPIO bits do.
		  E.g. For digital spdif out.
 outl(0x00f0e000, chip->port+GPIO);  
 Analog 
 Analog 
 outl(0x005f02a2, chip->port+GPIO);  
 Win2000 uses 0x1e0 
 outl(HCFG_LOCKSOUNDCACHE|HCFG_AUDIOENABLE, chip->port+HCFG); 
 0x1000 causes AC3 to fails. Maybe it effects 24 bit output. 
 outl(0x00001409, chip->port+HCFG); 
 outl(0x00000009, chip->port+HCFG); 
 AC97 2.0, Enable outputs. 
 The SB0410 and SB0413 use I2C to control ADC. 
 dev_dbg(emu->card->dev, "I2C:array size=0x%x\n", size); 
 Line in 
 Enable Line-in capture. MIC in currently untested. 
 snd_ca0106_i2c_write(chip, ADC_MUX, ADC_MUX_LINEIN); 
 The SB0570 use SPI to control DAC. 
 Enable front dac only 
 disable interrupts 
 disable audio 
 outl(HCFG_LOCKSOUNDCACHE, chip->port + HCFG); 
	 FIXME: We need to stop and DMA transfers here.
	         But as I am not sure how yet, we cannot from the dma pages.
	  So we can fix: snd-malloc: Memory leak?  pages not freed = 8
 This stores the periods table. 
 read serial 
 The SB0410 and SB0413 do not have an AC97 chip. 
 PCI IDs
 Audigy LS or Live 24bit 
 pci_driver definition
 SPDX-License-Identifier: GPL-2.0
 Playback 
 capture 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for NeoMagic 256AV and 256ZX chipsets.
  Copyright (c) 2000 by Takashi Iwai <tiwai@suse.de>
  Based on nm256_audio.c OSS driver in linux kernel.
  The original author of OSS nm256 driver wishes to remain anonymous,
  so I just put my acknoledgment to himher here.
  The original author's web page is found at
 	http:www.uglx.orgsony.html
  some compile conditions.
 Index 
 ID for this card 
 disabled as default 
 not specified 
 disabled 
 disabled 
 just for backward compatibility 
  hw definitions
 The BIOS signature. 
 Signature mask. 
 Size of the second memory area. 
 The base offset of the mixer in the second memory area. 
 The maximum size of a coefficient entry. 
 The interrupt register. 
 And its bits. 
 The AV's "mixer ready" status bit and location. 
  For the ZX.  It uses the same interrupt register, but it holds 32
  bits instead of 16.
 The ZX's "mixer ready" status bit and location. 
 The playback registers start from here. 
 The record registers start from here. 
 The rate register is located 2 bytes from the start of the register area. 
 Monostereo flag, number of bits on playback, and rate mask. 
 Playback enable register. 
 Mutes the audio output. 
 Recording enable register. 
 coefficient buffer pointer 
 DMA buffer offsets 
 offset from chip->buffer 
 buffer size in bytes 
 mapped pointer 
 physical address of the mapped pointer 
 buffer size of the substream in bytes 
 period size in bytes 
 # of periods 
 bit shifts 
 current period # 
 control port 
 physical address 
 buffer 
 buffer phyiscal address 
 start offset from pci resource 0 
 end offset 
 total buffer size 
 coefficient buffer 
 coefficient buffer for each stream 
 coeff. table is loaded? 
 use one big coef. table 
 Workaround for some laptops to avoid freeze 
 Extended workaround for some other laptops to avoid freeze 
 register offset of ac97 mixer 
 offset of mixer status reg. 
 bit mask to test the mixer status 
 counter to check bogus interrupts 
 register caches, only for valid regs 
  include coefficient table
  PCI ids
  lowlvel stuffs
  coefficient handlers -- what a magic!
 ???  Record seems to behave differently than playback.  
 The enable register for the specified engine.  
 The recording engine uses coefficient values 8-15.  
 The actual rates supported by the card. 
  return the index of the target rate
  set sample rate and format
 0 = playback 
 1 = record 
 acquire interrupt 
 release interrupt 
  start  stop
 update the watermark (current period) 
 program buffer pointers 
 Enable playback engine and interrupts. 
 Enable both channels. 
 program buffer pointers 
 Enable playback engine and interrupts. 
 Stop the play engine. 
 Shut off sound from both channels. 
 Disable play engine. 
 Disable recording engine. 
  prepare playbackcapture channel
  get the current pointer
 Remapped IO space can be accessible as pointer on i386 
 This might be changed in the future 
  silence  copy for playback
  copy to user
 !__i386__ 
  update playbackcapture watermarks
 spinlock held! 
 spinlock held! 
  hardware info
SNDRV_PCM_INFO_PAUSE |
24k | SNDRV_PCM_RATE_8000_48000,
SNDRV_PCM_INFO_PAUSE |
24k | SNDRV_PCM_RATE_8000_48000,
 set dma transfer size 
 area and addr are already set and unchanged 
  open
  close - we don't have to do special..
  create a pcm instance
  Initialize the hardware. 
 Reset everything. 
 stop sounds.. 
snd_nm256_playback_stop(chip);
snd_nm256_capture_stop(chip);
		
		  I'm not sure if the best thing is to stop the card from
		  playing or just release the interrupt (after all, we're in
		  a bad situation, so doing fancy stuff may not be such a good
		  idea).
		 
		  I worry about the card engine continuing to play noise
		  over and over, however--that could become a very
		  obnoxious problem.  And we know that when this usually
		  happens things are fairly safe, it just means the user's
		  inserted a PCMCIA card and someone's spamming us with IRQ 9s.
  Handle a potential interrupt for the device referred to by DEV_ID. 
  I don't like the cut-n-paste job here either between the two routines,
  but there are sufficient differences between the two interrupt handlers
  that parameterizing it isn't all that great either.  (Could use a macro,
  I suppose...yucky bleah.)
 Not ours. 
 Rather boring; check for individual interrupts and process them. 
 Unknown interrupt. 
 Pray. 
  Handle a potential interrupt for the device referred to by DEV_ID.
  This handler is for the 256ZX, and is very similar to the non-ZX
  routine.
 Not ours. 
 Rather boring; check for individual interrupts and process them. 
 Unknown interrupt. 
 Pray. 
  AC97 interface
  Waits for the mixer to become ready to be written; returns a zero value
  if it timed out.
	 
	  Loop around waiting for the mixer to become ready. 
  Initial register values to be written to the AC97 mixer.
  While most of these are identical to the reset values, we do this
  so that we have most of the register contents cached--this avoids
  reading from the mixer directly (which seems to be problematic,
  probably due to ignorance).
  some nm256 easily crash when reading from mixer registers
  thus we're treating it as a write-only mixer and cache the
  written values
 Wait for the write to take, too. 
 a little delay here seems better.. 
 successful write: set cache 
 static resolution table 
 terminator 
 initialize the ac97 into a known state 
 Reset the mixer.  'Tis magic!  
 Dell latitude LS will lock up by this 
 Dell latitude CSx will lock up by this 
			 preload the cache, so as to avoid even a single
			  read of the mixer regs
 create an ac97 mixer interface 
 we support audio! 
 looks like an invalid id 
  See if the signature left by the NM256 BIOS is intact; if so, we use
  the associated address as the end of our audio buffer in the video
  RAM.
 The signature is located 1K below the end of video RAM.  
 Default buffer end is 5120 bytes below the top of RAM.  
		
		  If it's obviously invalid, don't use it
  APM event handler, so the card is properly reinitialized after a power
  event.
 Perform a full reset on the hardware 
 restore ac97 
 CONFIG_PM_SLEEP 
 store buffer sizes in bytes 
	 
	  The NM256 has two memory ports.  The first port is nothing
	  more than a chunk of video RAM, which is used as the IO ring
	  buffer.  The second port has the actual juicy stuff (like the
	  mixer and the playback engine control registers).
 Init the memory port info.  
 remap control port (#2) 
 Ok, try to see if this is a non-AC97 version of the hardware. 
 Not sure if there is any relevant detect for the ZX or not.  
 get buffer end pointer from signature 
 set offsets 
 Fixed setting. 
 pci_set_master(pci);  needed? 
 HP omnibook 4150 has cs4232 codec internally 
 Reset workarounds to avoid lock-ups 
 terminator 
 this avoids conflicts with XFree86 server 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for Digigram VX222 V2Mic PCI soundcards
  Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>
 Index 0-MAX 
 ID for this card 
 Enable this card 
 microphone 
 microphone 
 PLX 
 PLX 
 hw specs 
 hw specs 
 hw specs 
 enable PCI device 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for Digigram VX222 V2Mic soundcards
  VX222-specific low-level routines
  Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>
 Write: POTENTIOMETER ; Read: COMPRESSION LEVEL activate
 Read: COMPRESSION THRESHOLD activate
 Read: LEVEL LIMITATION activate
 VX_INTCSR_REGISTER_OFFSET
 VX_CNTRL_REGISTER_OFFSET
 VX_GPIOC (new with PLX9030)
 on the PLX 
 on the PLX 
 on the PLX 
  vx2_inb - read a byte from the register
  @chip: VX core instance
  @offset: register enum
  vx2_outb - write a byte on the register
  @chip: VX core instance
  @offset: the register offset
  @val: the value to write
	
	dev_dbg(chip->card->dev, "outb: %x -> %x\n", val, vx2_reg_addr(chip, offset));
  vx2_inl - read a 32bit word from the register
  @chip: VX core instance
  @offset: register enum
  vx2_outl - write a 32bit word on the register
  @chip: VX core instance
  @offset: the register enum
  @val: the value to write
	
	dev_dbg(chip->card->dev, "outl: %x -> %x\n", val, vx2_reg_addr(chip, offset));
  redefine macros to call directly
  vx_reset_dsp - reset the DSP
 ms 
 set the reset dsp bit to 0 
 set the reset dsp bit to 1 
	 This test uses several writeread sequences on TEST0 and TEST1 bits
	  to figure out whever or not the xilinx was correctly loaded
 We write 1 on CDSP.TEST0. We should get 0 on STATUS.TEST0. 
 We write 0 on CDSP.TEST0. We should get 1 on STATUS.TEST0. 
 not implemented on VX_2_BOARDS 
 We write 1 on CDSP.TEST1. We should get 0 on STATUS.TEST1. 
 We write 0 on CDSP.TEST1. We should get 1 on STATUS.TEST1. 
  vx2_setup_pseudo_dma - set up the pseudo dma readwrite mode.
  @chip: VX core instance
  @do_write: 0 = read, 1 = set up for DMA write
	 Interrupt mode and HREQ pin enabled for host transmit data transfers
	  (in case of the use of the pseudo-dma facility).
	 Reset the pseudo-dma register (in case of the use of the
	  pseudo-dma facility).
  vx_release_pseudo_dma - disable the pseudo-DMA mode
 HREQ pin disabled. 
 pseudo-dma write 
	 Transfer using pseudo-dma.
 in 32bit words 
 Transfer using pseudo-dma. 
 in 32bit words 
 Transfer using pseudo-dma. 
 pseudo dma read 
	 Transfer using pseudo-dma.
 in 32bit words 
 Transfer using pseudo-dma. 
 in 32bit words 
 Transfer using pseudo-dma. 
  transfer counts bits to PLX
 set the clock bit to 0. 
 set the clock bit to 1. 
  load the xilinx image
 XILINX reset (wait at least 1 millisecond between reset on and off). 
 VX222 V2 and VX222_MIC_BOARD with new PLX9030 use this register 
 don't take too much time in this loop... 
 end signature 
 test after loading (is buggy with VX222) 
 Test if load successful: test bit 8 of register GPIOC (VX222: use CNTRL) ! 
  load the bootdsp images
 xilinx image 
 DSP boot 
 DSP image 
  vx_test_and_ack - test and acknowledge interrupt
  called from irq hander, too
  spinlock held!
 not booted yet? 
 ok, interrupts generated, now ack it 
 set ACQUIT bit up and down 
	 useless read just to spend some time and maintain
	  the ACQUIT signal up for a while ( a bus cycle )
 ack 
	 useless read just to spend some time and maintain
 clear 
  vx_validate_irq - enabledisable IRQ
 Set the interrupt enable bit to 1 in CDSP register 
 Set the PCI interrupt enable bit to 1.
 Set the PCI interrupt enable bit to 0. 
  write an AKM codec data (24bit)
 We have to send 24 bits (3 x 8 bits). Start with most signif. Bit 
 Terminate access to codec registers 
 [000] =  +0.000 dB  ->  AKM(0x7f) =  +0.000 dB  error(+0.000 dB)
 [001] =  -0.500 dB  ->  AKM(0x7d) =  -0.572 dB  error(-0.072 dB)
 [002] =  -1.000 dB  ->  AKM(0x7c) =  -0.873 dB  error(+0.127 dB)
 [003] =  -1.500 dB  ->  AKM(0x7a) =  -1.508 dB  error(-0.008 dB)
 [004] =  -2.000 dB  ->  AKM(0x79) =  -1.844 dB  error(+0.156 dB)
 [005] =  -2.500 dB  ->  AKM(0x77) =  -2.557 dB  error(-0.057 dB)
 [006] =  -3.000 dB  ->  AKM(0x76) =  -2.937 dB  error(+0.063 dB)
 [007] =  -3.500 dB  ->  AKM(0x75) =  -3.334 dB  error(+0.166 dB)
 [008] =  -4.000 dB  ->  AKM(0x73) =  -4.188 dB  error(-0.188 dB)
 [009] =  -4.500 dB  ->  AKM(0x72) =  -4.648 dB  error(-0.148 dB)
 [010] =  -5.000 dB  ->  AKM(0x71) =  -5.134 dB  error(-0.134 dB)
 [011] =  -5.500 dB  ->  AKM(0x70) =  -5.649 dB  error(-0.149 dB)
 [012] =  -6.000 dB  ->  AKM(0x6f) =  -6.056 dB  error(-0.056 dB)
 [013] =  -6.500 dB  ->  AKM(0x6d) =  -6.631 dB  error(-0.131 dB)
 [014] =  -7.000 dB  ->  AKM(0x6c) =  -6.933 dB  error(+0.067 dB)
 [015] =  -7.500 dB  ->  AKM(0x6a) =  -7.571 dB  error(-0.071 dB)
 [016] =  -8.000 dB  ->  AKM(0x69) =  -7.909 dB  error(+0.091 dB)
 [017] =  -8.500 dB  ->  AKM(0x67) =  -8.626 dB  error(-0.126 dB)
 [018] =  -9.000 dB  ->  AKM(0x66) =  -9.008 dB  error(-0.008 dB)
 [019] =  -9.500 dB  ->  AKM(0x65) =  -9.407 dB  error(+0.093 dB)
 [020] = -10.000 dB  ->  AKM(0x64) =  -9.826 dB  error(+0.174 dB)
 [021] = -10.500 dB  ->  AKM(0x62) = -10.730 dB  error(-0.230 dB)
 [022] = -11.000 dB  ->  AKM(0x61) = -11.219 dB  error(-0.219 dB)
 [023] = -11.500 dB  ->  AKM(0x60) = -11.738 dB  error(-0.238 dB)
 [024] = -12.000 dB  ->  AKM(0x5f) = -12.149 dB  error(-0.149 dB)
 [025] = -12.500 dB  ->  AKM(0x5e) = -12.434 dB  error(+0.066 dB)
 [026] = -13.000 dB  ->  AKM(0x5c) = -13.033 dB  error(-0.033 dB)
 [027] = -13.500 dB  ->  AKM(0x5b) = -13.350 dB  error(+0.150 dB)
 [028] = -14.000 dB  ->  AKM(0x59) = -14.018 dB  error(-0.018 dB)
 [029] = -14.500 dB  ->  AKM(0x58) = -14.373 dB  error(+0.127 dB)
 [030] = -15.000 dB  ->  AKM(0x56) = -15.130 dB  error(-0.130 dB)
 [031] = -15.500 dB  ->  AKM(0x55) = -15.534 dB  error(-0.034 dB)
 [032] = -16.000 dB  ->  AKM(0x54) = -15.958 dB  error(+0.042 dB)
 [033] = -16.500 dB  ->  AKM(0x53) = -16.404 dB  error(+0.096 dB)
 [034] = -17.000 dB  ->  AKM(0x52) = -16.874 dB  error(+0.126 dB)
 [035] = -17.500 dB  ->  AKM(0x51) = -17.371 dB  error(+0.129 dB)
 [036] = -18.000 dB  ->  AKM(0x50) = -17.898 dB  error(+0.102 dB)
 [037] = -18.500 dB  ->  AKM(0x4e) = -18.605 dB  error(-0.105 dB)
 [038] = -19.000 dB  ->  AKM(0x4d) = -18.905 dB  error(+0.095 dB)
 [039] = -19.500 dB  ->  AKM(0x4b) = -19.538 dB  error(-0.038 dB)
 [040] = -20.000 dB  ->  AKM(0x4a) = -19.872 dB  error(+0.128 dB)
 [041] = -20.500 dB  ->  AKM(0x48) = -20.583 dB  error(-0.083 dB)
 [042] = -21.000 dB  ->  AKM(0x47) = -20.961 dB  error(+0.039 dB)
 [043] = -21.500 dB  ->  AKM(0x46) = -21.356 dB  error(+0.144 dB)
 [044] = -22.000 dB  ->  AKM(0x44) = -22.206 dB  error(-0.206 dB)
 [045] = -22.500 dB  ->  AKM(0x43) = -22.664 dB  error(-0.164 dB)
 [046] = -23.000 dB  ->  AKM(0x42) = -23.147 dB  error(-0.147 dB)
 [047] = -23.500 dB  ->  AKM(0x41) = -23.659 dB  error(-0.159 dB)
 [048] = -24.000 dB  ->  AKM(0x40) = -24.203 dB  error(-0.203 dB)
 [049] = -24.500 dB  ->  AKM(0x3f) = -24.635 dB  error(-0.135 dB)
 [050] = -25.000 dB  ->  AKM(0x3e) = -24.935 dB  error(+0.065 dB)
 [051] = -25.500 dB  ->  AKM(0x3c) = -25.569 dB  error(-0.069 dB)
 [052] = -26.000 dB  ->  AKM(0x3b) = -25.904 dB  error(+0.096 dB)
 [053] = -26.500 dB  ->  AKM(0x39) = -26.615 dB  error(-0.115 dB)
 [054] = -27.000 dB  ->  AKM(0x38) = -26.994 dB  error(+0.006 dB)
 [055] = -27.500 dB  ->  AKM(0x37) = -27.390 dB  error(+0.110 dB)
 [056] = -28.000 dB  ->  AKM(0x36) = -27.804 dB  error(+0.196 dB)
 [057] = -28.500 dB  ->  AKM(0x34) = -28.699 dB  error(-0.199 dB)
 [058] = -29.000 dB  ->  AKM(0x33) = -29.183 dB  error(-0.183 dB)
 [059] = -29.500 dB  ->  AKM(0x32) = -29.696 dB  error(-0.196 dB)
 [060] = -30.000 dB  ->  AKM(0x31) = -30.241 dB  error(-0.241 dB)
 [061] = -30.500 dB  ->  AKM(0x31) = -30.241 dB  error(+0.259 dB)
 [062] = -31.000 dB  ->  AKM(0x30) = -30.823 dB  error(+0.177 dB)
 [063] = -31.500 dB  ->  AKM(0x2e) = -31.610 dB  error(-0.110 dB)
 [064] = -32.000 dB  ->  AKM(0x2d) = -31.945 dB  error(+0.055 dB)
 [065] = -32.500 dB  ->  AKM(0x2b) = -32.659 dB  error(-0.159 dB)
 [066] = -33.000 dB  ->  AKM(0x2a) = -33.038 dB  error(-0.038 dB)
 [067] = -33.500 dB  ->  AKM(0x29) = -33.435 dB  error(+0.065 dB)
 [068] = -34.000 dB  ->  AKM(0x28) = -33.852 dB  error(+0.148 dB)
 [069] = -34.500 dB  ->  AKM(0x27) = -34.289 dB  error(+0.211 dB)
 [070] = -35.000 dB  ->  AKM(0x25) = -35.235 dB  error(-0.235 dB)
 [071] = -35.500 dB  ->  AKM(0x24) = -35.750 dB  error(-0.250 dB)
 [072] = -36.000 dB  ->  AKM(0x24) = -35.750 dB  error(+0.250 dB)
 [073] = -36.500 dB  ->  AKM(0x23) = -36.297 dB  error(+0.203 dB)
 [074] = -37.000 dB  ->  AKM(0x22) = -36.881 dB  error(+0.119 dB)
 [075] = -37.500 dB  ->  AKM(0x21) = -37.508 dB  error(-0.008 dB)
 [076] = -38.000 dB  ->  AKM(0x20) = -38.183 dB  error(-0.183 dB)
 [077] = -38.500 dB  ->  AKM(0x1f) = -38.726 dB  error(-0.226 dB)
 [078] = -39.000 dB  ->  AKM(0x1e) = -39.108 dB  error(-0.108 dB)
 [079] = -39.500 dB  ->  AKM(0x1d) = -39.507 dB  error(-0.007 dB)
 [080] = -40.000 dB  ->  AKM(0x1c) = -39.926 dB  error(+0.074 dB)
 [081] = -40.500 dB  ->  AKM(0x1b) = -40.366 dB  error(+0.134 dB)
 [082] = -41.000 dB  ->  AKM(0x1a) = -40.829 dB  error(+0.171 dB)
 [083] = -41.500 dB  ->  AKM(0x19) = -41.318 dB  error(+0.182 dB)
 [084] = -42.000 dB  ->  AKM(0x18) = -41.837 dB  error(+0.163 dB)
 [085] = -42.500 dB  ->  AKM(0x17) = -42.389 dB  error(+0.111 dB)
 [086] = -43.000 dB  ->  AKM(0x16) = -42.978 dB  error(+0.022 dB)
 [087] = -43.500 dB  ->  AKM(0x15) = -43.610 dB  error(-0.110 dB)
 [088] = -44.000 dB  ->  AKM(0x14) = -44.291 dB  error(-0.291 dB)
 [089] = -44.500 dB  ->  AKM(0x14) = -44.291 dB  error(+0.209 dB)
 [090] = -45.000 dB  ->  AKM(0x13) = -45.031 dB  error(-0.031 dB)
 [091] = -45.500 dB  ->  AKM(0x12) = -45.840 dB  error(-0.340 dB)
 [092] = -46.000 dB  ->  AKM(0x12) = -45.840 dB  error(+0.160 dB)
 [093] = -46.500 dB  ->  AKM(0x11) = -46.731 dB  error(-0.231 dB)
 [094] = -47.000 dB  ->  AKM(0x11) = -46.731 dB  error(+0.269 dB)
 [095] = -47.500 dB  ->  AKM(0x10) = -47.725 dB  error(-0.225 dB)
 [096] = -48.000 dB  ->  AKM(0x10) = -47.725 dB  error(+0.275 dB)
 [097] = -48.500 dB  ->  AKM(0x0f) = -48.553 dB  error(-0.053 dB)
 [098] = -49.000 dB  ->  AKM(0x0e) = -49.152 dB  error(-0.152 dB)
 [099] = -49.500 dB  ->  AKM(0x0d) = -49.796 dB  error(-0.296 dB)
 [100] = -50.000 dB  ->  AKM(0x0d) = -49.796 dB  error(+0.204 dB)
 [101] = -50.500 dB  ->  AKM(0x0c) = -50.491 dB  error(+0.009 dB)
 [102] = -51.000 dB  ->  AKM(0x0b) = -51.247 dB  error(-0.247 dB)
 [103] = -51.500 dB  ->  AKM(0x0b) = -51.247 dB  error(+0.253 dB)
 [104] = -52.000 dB  ->  AKM(0x0a) = -52.075 dB  error(-0.075 dB)
 [105] = -52.500 dB  ->  AKM(0x0a) = -52.075 dB  error(+0.425 dB)
 [106] = -53.000 dB  ->  AKM(0x09) = -52.990 dB  error(+0.010 dB)
 [107] = -53.500 dB  ->  AKM(0x09) = -52.990 dB  error(+0.510 dB)
 [108] = -54.000 dB  ->  AKM(0x08) = -54.013 dB  error(-0.013 dB)
 [109] = -54.500 dB  ->  AKM(0x08) = -54.013 dB  error(+0.487 dB)
 [110] = -55.000 dB  ->  AKM(0x07) = -55.173 dB  error(-0.173 dB)
 [111] = -55.500 dB  ->  AKM(0x07) = -55.173 dB  error(+0.327 dB)
 [112] = -56.000 dB  ->  AKM(0x06) = -56.512 dB  error(-0.512 dB)
 [113] = -56.500 dB  ->  AKM(0x06) = -56.512 dB  error(-0.012 dB)
 [114] = -57.000 dB  ->  AKM(0x06) = -56.512 dB  error(+0.488 dB)
 [115] = -57.500 dB  ->  AKM(0x05) = -58.095 dB  error(-0.595 dB)
 [116] = -58.000 dB  ->  AKM(0x05) = -58.095 dB  error(-0.095 dB)
 [117] = -58.500 dB  ->  AKM(0x05) = -58.095 dB  error(+0.405 dB)
 [118] = -59.000 dB  ->  AKM(0x05) = -58.095 dB  error(+0.905 dB)
 [119] = -59.500 dB  ->  AKM(0x04) = -60.034 dB  error(-0.534 dB)
 [120] = -60.000 dB  ->  AKM(0x04) = -60.034 dB  error(-0.034 dB)
 [121] = -60.500 dB  ->  AKM(0x04) = -60.034 dB  error(+0.466 dB)
 [122] = -61.000 dB  ->  AKM(0x04) = -60.034 dB  error(+0.966 dB)
 [123] = -61.500 dB  ->  AKM(0x03) = -62.532 dB  error(-1.032 dB)
 [124] = -62.000 dB  ->  AKM(0x03) = -62.532 dB  error(-0.532 dB)
 [125] = -62.500 dB  ->  AKM(0x03) = -62.532 dB  error(-0.032 dB)
 [126] = -63.000 dB  ->  AKM(0x03) = -62.532 dB  error(+0.468 dB)
 [127] = -63.500 dB  ->  AKM(0x03) = -62.532 dB  error(+0.968 dB)
 [128] = -64.000 dB  ->  AKM(0x03) = -62.532 dB  error(+1.468 dB)
 [129] = -64.500 dB  ->  AKM(0x02) = -66.054 dB  error(-1.554 dB)
 [130] = -65.000 dB  ->  AKM(0x02) = -66.054 dB  error(-1.054 dB)
 [131] = -65.500 dB  ->  AKM(0x02) = -66.054 dB  error(-0.554 dB)
 [132] = -66.000 dB  ->  AKM(0x02) = -66.054 dB  error(-0.054 dB)
 [133] = -66.500 dB  ->  AKM(0x02) = -66.054 dB  error(+0.446 dB)
 [134] = -67.000 dB  ->  AKM(0x02) = -66.054 dB  error(+0.946 dB)
 [135] = -67.500 dB  ->  AKM(0x02) = -66.054 dB  error(+1.446 dB)
 [136] = -68.000 dB  ->  AKM(0x02) = -66.054 dB  error(+1.946 dB)
 [137] = -68.500 dB  ->  AKM(0x02) = -66.054 dB  error(+2.446 dB)
 [138] = -69.000 dB  ->  AKM(0x02) = -66.054 dB  error(+2.946 dB)
 [139] = -69.500 dB  ->  AKM(0x01) = -72.075 dB  error(-2.575 dB)
 [140] = -70.000 dB  ->  AKM(0x01) = -72.075 dB  error(-2.075 dB)
 [141] = -70.500 dB  ->  AKM(0x01) = -72.075 dB  error(-1.575 dB)
 [142] = -71.000 dB  ->  AKM(0x01) = -72.075 dB  error(-1.075 dB)
 [143] = -71.500 dB  ->  AKM(0x01) = -72.075 dB  error(-0.575 dB)
 [144] = -72.000 dB  ->  AKM(0x01) = -72.075 dB  error(-0.075 dB)
 [145] = -72.500 dB  ->  AKM(0x01) = -72.075 dB  error(+0.425 dB)
 [146] = -73.000 dB  ->  AKM(0x01) = -72.075 dB  error(+0.925 dB)
 [147] = -73.500 dB  ->  AKM(0x00) =  mute       error(+infini)
  pseudo-codec write entry
	 `data' is a value between 0x0 and VX2_AKM_LEVEL_MAX = 0x093, in the case of the AKM codecs, we need
	   a look up table, as there is no linear matching between the driver codec values
	   and the real dBu value
  write codec bit for old VX222 board
 activate access to codec registers 
 Terminate access to codec registers 
  reset codec bit
 Set the reset CODEC bit to 0. 
 Set the reset CODEC bit to 1. 
 additionnel wait time for AKM's 
 DAC power up, ADC power up, Vref power down 
 default 
 Mute = ON ,Deemphasis = OFF 
 DAC and ADC normal operation 
 set up the micro input selector 
 reset phantom power supply 
  change the audio source
  set the clock source
  reset the board
 initialize the register values 
  input level controls for VX222 Mic
 Micro level is specified to be adjustable from -96dB to 63 dB (board coded 0x00 ... 318),
  318 = 210 + 36 + 36 + 36   (210 = +9dB variable) (3  36 = 3 steps of 18dB pre ampli)
  as we will mute if less than -110dB, so let's simply use line input coded levels and add constant offset !
 add 318 - 0xff 
 limitation to +9dB of 3310 real gain 
 raise pre ampli + 18dB 
 lower level 18 dB (2 because of 0.5 dB steps !) 
 set pre-amp level 
 Activate input level programming 
 We have to send 32 bits (4 x 8 bits) 
 Terminate input level programming 
  controls API for input levels
 input levels 
 mic level 
  FIXME: compressorlimiter implementation is missing yet...
 mute input levels 
 controls 
  callbacks
 for old VX222 board 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
   Universal interface for Audio Codec '97
   For more details look to AC '97 component specification revision 2.2
   by Intel Corporation (http:developer.intel.com).
  This is an _inofficial_ Aztech Labs entry
  (value might differ from unknown official Aztech ID),
  currently used by the AC97 emulation of the almost-AC97 PCI168 card.
 already patched 
 already patched 
 already patched 
 already patched 
 SmartMC II
 SmartAMC fixme: the mask might be different
 same as TR28028?
 alias VIA VT1611A?
 VT1616 compatible (chipset integrated)
 only guess --jk
 volume wrap fix 
 added by xin jin [070999]
 only guess --jk [TR28023 = eMicro EM28023 (new CT1297)]
 modified ICE1232 with SPDIF
 modified VT1616 with SPDIF
 patch?
 patch?
 patch?
   IO routines
 filter some registers for buggy codecs 
 AD1819 
 AD1881 
 AD1881A 
 0x59 
 AD1885 
 AD1886 
 AD1886A - !!verify!! --jk 
 AD1887 - !!verify!! --jk 
 0x59 
  snd_ac97_write - write a value on the given register
  @ac97: the ac97 instance
  @reg: the register to change
  @value: the value to set
  Writes a value on the given register.  This will invoke the write
  callback directly after the register check.
  This function doesn't change the register cache unlike
  #snd_ca97_write_cache(), so use this only when you don't want to
  reflect the change to the suspendresume state.
 Fix HW bug of ALC100100P 
 reset audio codec 
  snd_ac97_read - read a value from the given register
  @ac97: the ac97 instance
  @reg: the register to read
  Reads a value from the given register.  This will invoke the read
  callback directly after the register check.
  Return: The read value.
 read a register - return the cached value if already read 
 set_bit(reg, ac97->reg_accessed);
  snd_ac97_write_cache - write a value on the given register and update the cache
  @ac97: the ac97 instance
  @reg: the register to change
  @value: the value to set
  Writes a value on the given register and updates the register
  cache.  The cached values are used for the cached-read and the
  suspendresume.
  snd_ac97_update - update the value on the given register
  @ac97: the ac97 instance
  @reg: the register to change
  @value: the value to set
  Compares the value with the register cache and updates the value
  only when the value is changed.
  Return: 1 if the value is changed, 0 if no change, or a negative
  code on failure.
  snd_ac97_update_bits - update the bits on the given register
  @ac97: the ac97 instance
  @reg: the register to change
  @mask: the bit-mask to change
  @value: the value to set
  Updates the masked-bits on the given register only when the value
  is changed.
  Return: 1 if the bits are changed, 0 if no change, or a negative
  code on failure.
 no lock version - see snd_ac97_update_bits() 
 select single codec 
 update PCM bits 
 select all codecs 
  Controls
 saverestore ac97 v2.3 paging 
 lock paging 
 unlock paging 
 volume and switch controls 
 check analog mixer power-down 
 change the existing EAPD control as inverted 
 EAPD up 
 FIXME: AC'97 spec doesn't say which bits are used for what 
 category + original
 44.1
 48.0
 illegal.
 turn off 
 turn on again 
 int invert = (kcontrol->private_value >> 24) & 0xff;
 turn off 
 turn on again 
 for avoiding click noises during shut down 
 if nonzero - fixed and we can't set it 
 center 
 lfe 
 nothing seems to be here - mute flag is not set 
 try another test 
 nothing here 
 success, useable 
 first look up the static resolution table 
		 Do the read twice due to buffers on some ac97 codecs.
		  e.g. The STAC9704 returns exactly what you wrote to the register
		  if you read it immediately. This causes the detect routine to fail.
 check the volume resolution of centerlfe 
 reset volume to zero 
  create mute switch(es) for normal stereo controls
 check whether both mute bits work 
 mute as default 
  set dB information
  create a volume for normal stereomono controls
 invert 
 invert 
  create a mute-switch and a volume for normal stereomono controls
 build master controls 
 AD claims to remove this control from AD1887, although spec v2.2 does not allow this 
 build center controls 
 build LFE controls 
 build surround controls 
 Surround Master (0x38) is with stereo mutes 
 build headphone controls 
 build master mono controls 
 build master tone controls 
 build Beep controls 
 build Phone controls 
 build MIC controls 
 build Line controls 
 build CD controls 
 build Video controls 
 build Aux controls 
 build PCM controls 
 build Capture controls 
 build MIC Capture controls 
 build PCM out path & mute control 
 build Simulated Stereo Enhancement control 
 build 3D Stereo Enhancement control 
 build Loudness control 
 build Mono output select control 
 build Mic select control 
 build ADCDAC loopback control 
 build 3D controls 
 build SPDIF controls 
 Hack for ASUS P5P800-VM, which does not indicate SPDIF capability 
 set default PCM SPDIF params 
 consumer,PCM audio,no copyright,no preemphasis,PCM coder,original,48000Hz 
 build chip specific controls 
	
	ac97_dbg(ac97, "AC97_GPIO_CFG = %x\n",
	       snd_ac97_read(ac97,AC97_GPIO_CFG));
 build modem switches 
 build chip specific controls 
 test a non-standard rate 
 let's try to obtain standard rates 
 test standard double rates 
 some codecs don't support variable double rates 
 restore the default value 
 check AC97_SPDIF register to accept which sample rates 
 look for the codec id table matching with the given id 
  snd_ac97_get_short_name - retrieve codec name
  @ac97: the codec instance
  Return: The short identifying name of the codec.
 wait for a while until registers are accessible after RESET
  return 0 if ok, negative not ready
 use preliminary reads to settle the communication 
 modem? 
 probably only Xbox issue - all registers are read as zero 
			 because the PCM or MASTER volume registers can be modified,
			  the REC_GAIN register is used for tests
 test if we can write to the record gain volume register 
  snd_ac97_bus - create an AC97 bus component
  @card: the card instance
  @num: the bus number
  @ops: the bus callbacks table
  @private_data: private data pointer for the new instance
  @rbus: the pointer to store the new AC97 bus instance.
  Creates an AC97 bus component.  An struct snd_ac97_bus instance is newly
  allocated and initialized.
  The ops table must include valid callbacks (at least read and
  write).  The other callbacks, wait and reset, are not mandatory.
  The clock is set to 48000.  If another clock is needed, set
  ``(rbus)->clock`` manually.
  The AC97 bus instance is registered as a low-level device, so you don't
  have to release it manually.
  Return: Zero if successful, or a negative error code on failure.
 stop no dev release warning 
 register ac97 codec to bus 
 disconnect ac97 codec 
 build_ops to do nothing 
  snd_ac97_mixer - create an Codec97 component
  @bus: the AC97 bus which codec is attached to
  @template: the template of ac97, including index, callbacks and
          the private data.
  @rac97: the pointer to store the new ac97 instance.
  Creates an Codec97 component.  An struct snd_ac97 instance is newly
  allocated and initialized from the template.  The codec
  is then initialized by the standard procedure.
  The template must include the codec number (num) and address (addr),
  and the private data (private_data).
  The ac97 instance is registered as a low-level device, so you don't
  have to release it manually.
  Return: Zero if successful, or a negative error code on failure.
 reset to defaults 
 proceed anyway - it's often non-critical 
 test for AC'97 
 test if we can write to the record gain volume register 
 invalid combination 
 test for MC'97 
 invalid combination 
 FIXME: always skipping?
 FIXME: add powerdown control 
 nothing should be in powerdown mode 
 reset to defaults 
 nothing should be in powerdown mode 
 FIXME: add powerdown control 
 nothing should be in powerdown mode 
 note: it's important to set the rate at first 
 nothing should be in powerdown mode 
 LR, MIC, SDAC, LDAC VRA support 
 LDACSDACCDAC 
 VRAVRM 
		 Intel controllers require double rate data to be put in
 restore to slots 1011 to avoid the confliction with surrounds 
 VRA support 
 codec specific code (patch) should override these values 
 MIC VRA support 
 SDAC support 
 LDAC support 
 additional initializations 
 ac97->id might be changed in the special setup code
  Power down the chip.
  MASTER and HEADPHONE registers are muted but the register cache values
  are not changed, so that the values can be restored in snd_ac97_resume().
 some codecs have stereo mute bits 
 surround, CLFE, mic powerdown 
 powerdown external amplifier 
 Headphone amplifier powerdown 
 ADC & DAC powerdown 
 Analog Mixer powerdown (Vref on) 
 Analog Mixer powerdown 
 AC-link powerdown, internal Clk disable 
 FIXME: this may cause click noises on some boards 
  snd_ac97_update_power - update the powerdown register
  @ac97: the codec instance
  @reg: the rate register, e.g. AC97_PCM_FRONT_DAC_RATE
  @powerup: non-zero when power up the part
  Update the AC97 powerdown register bits of the given part.
  Return: Zero.
 SPDIF requires DAC power, too 
		 adjust power-down bits after two seconds delay
		  (for avoiding loud click noises for many (OSS) apps
		   that openclose frequently)
 CONFIG_SND_AC97_POWER_SAVE 
 needs power-up analog mix and vref 
 power down analog mix and vref 
  snd_ac97_suspend - General suspend function for AC97 codec
  @ac97: the ac97 instance
  Suspends the codec, power down the chip.
  restore ac97 status
		 restore only accessible registers
		  some chip (e.g. nm256) may hang up when unsupported registers
		  are accessed..!
  restore IEC958 status
 reset spdif status 
 turn on again 
  snd_ac97_resume - General resume function for AC97 codec
  @ac97: the ac97 instance
  Do the standard resume procedure, power up and restoring the
  old register values.
 FIXME: extra delay 
  Hardware tuning
 remove the control with the given name and optional suffix 
 rename the control with the given name and optional suffix 
 rename both Volume and Switch controls - don't check the return value 
 swap controls 
 bind hp and master controls instead of using only hp control 
 ac97 tune: bind Master and Headphone controls 
 ac97 tune: use Headphone control as master 
 ac97 tune: swap Headphone and Master controls 
 ac97 tune: swap Surround and Master controls 
 ac97 tune: set up mic sharing for AD codecs 
 Turn on OMS bit to route microphone to back panel 
 ac97 tune: set up ALC jack-select 
 select jack detect function 
 Line-out auto mute 
 ac97 tune: inversed EAPD bit 
 ac97 tune: EAPD controls mute LED bound with the master mute 
 mute LED on 
 mute LED on 
 apply the quirk with the given type 
 apply the quirk with the given name 
 for compatibility, accept the numbers, too 
  snd_ac97_tune_hardware - tune up the hardware
  @ac97: the ac97 instance
  @quirk: quirk list
  @override: explicit quirk value (overrides the list if non-NULL)
  Do some workaround for each pci device, such as renaming of the
  headphone (true line-out) control as "Master".
  The quirk-list must be terminated with a zero-filled entry.
  Return: Zero if successful, or a negative error code on failure.
 quirk overriden? 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
   Universal interface for Audio Codec '97
   For more details look to AC '97 component specification revision 2.2
   by Intel Corporation (http:developer.intel.com) and to datasheets
   for specific codecs.
   PCM support
 standard rates 
 3&4 front, 7&8 rear, 6&9 centerlfe 
 slot 3 
 slot 4 
 slot 5 
 slot 6 
 slot 7 
 slot 8 
 slot 9 
 slot 10 
 slot 11 
 7&8 front, 6&9 rear, 10&11 centerlfe 
 slot 3 
 slot 4 
 slot 5 
 slot 6 
 slot 7 
 slot 8 
 slot 9 
 slot 10 
 slot 11 
 6&9 front, 10&11 rear, 3&4 centerlfe 
 slot 3 
 slot 4 
 slot 5 
 slot 6 
 slot 7 
 slot 8 
 slot 9 
 slot 10 
 slot 11 
 10&11 front, 3&4 rear, 7&8 centerlfe 
 slot 3 
 slot 4 
 slot 5 
 slot 6 
 slot 7 
 slot 8 
 slot 9 
 slot 10 
 slot 11 
 double rates 
 3&4 front, 7&8 front (t+1) 
 slot 3 
 slot 4 
 slot 5 
 slot 6 
 slot 7 
 slot 8 
 slot 9 
 slot 10 
 slot 11 
 not specified in the specification 
 slot 3 
 slot 4 
 slot 5 
 slot 6 
 slot 7 
 slot 8 
 slot 9 
 slot 10 
 slot 11 
 slot 3 
 slot 4 
 slot 5 
 slot 6 
 slot 7 
 slot 8 
 slot 9 
 slot 10 
 slot 11 
 slot 3 
 slot 4 
 slot 5 
 slot 6 
 slot 7 
 slot 8 
 slot 9 
 slot 10 
 slot 11 
 FIXME: more various mappings for ADC? 
 3 
 4 
 5 
 6 
 7 
 8 
 9 
 10 
 11 
 pseudo register 
 TODO: double rate support 
 invalid - disable output 
 invalid - disable output 
 update the internal spdif bits 
  snd_ac97_set_rate - change the rate of the given inputoutput.
  @ac97: the ac97 instance
  @reg: the register to change
  @rate: the sample rate to set
  Changes the rate of the given inputoutput on the codec.
  If the codec doesn't support VAR, the rate must be 48000 (except
  for SPDIF).
  The valid registers are AC97_PMC_MIC_ADC_RATE,
  AC97_PCM_FRONT_DAC_RATE, AC97_PCM_LR_ADC_RATE.
  AC97_PCM_SURR_DAC_RATE and AC97_PCM_LFE_DAC_RATE are accepted
  if the codec supports them.
  AC97_SPDIF is accepted as a pseudo register to modify the SPDIF
  status bits.
  Return: Zero if successful, or a negative error code on failure.
 MIC VRA 
 VRA 
 special case 
		 Intel controllers require double rate data to be put in
		  slots 7+8
 Note: it's simply emulation of AMAP behaviour 
  snd_ac97_pcm_assign - assign AC97 slots to given PCM streams
  @bus: the ac97 bus instance
  @pcms_count: count of PCMs to be assigned
  @pcms: PCMs to be assigned
  It assigns available AC97 slots for given PCMs. If none or only
  some slots are available, pcm->xxx.slots and pcm->xxx.rslots[] members
  are reduced and might be zero.
  Return: Zero if successful, or a negative error code on failure.
 first step - exclusive devices 
 low-level driver thinks that it's more clever 
 exclusive access 
 non-exclusive access 
 for double rate, we check the first codec only 
 not used 
  snd_ac97_pcm_open - opens the given AC97 pcm
  @pcm: the ac97 pcm instance
  @rate: rate in Hz, if codec does not support VRA, this value must be 48000Hz
  @cfg: output stream characteristics
  @slots: a subset of allocated slots (snd_ac97_pcm_assign) for this pcm
  It locks the specified slots and sets the given rate to AC97 registers.
  Return: Zero if successful, or a negative error code on failure.
  snd_ac97_pcm_close - closes the given AC97 pcm
  @pcm: the ac97 pcm instance
  It frees the locked AC97 slots.
  Return: Zero.
  snd_ac97_pcm_double_rate_rules - set double rate constraints
  @runtime: the runtime of the ac97 front playback pcm
  Installs the hardware constraint rules to prevent using double rates and
  more than two channels at the same time.
  Return: Zero if successful, or a negative error code on failure.
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
   Universal interface for Audio Codec '97
   For more details look to AC '97 component specification revision 2.2
   by Intel Corporation (http:developer.intel.com) and to datasheets
   for specific codecs.
   Forward declarations
   Chip specific initialization
 replace with a new TLV 
 set to the page, update bits and restore the page 
 unlock paging 
  shared line-inmic controls
 6ch 
 4ch 
 8ch 
 system has shared jacks with surround out enabled 
 system has shared jacks with centerlfe out enabled 
 system has shared jacks with line in enabled 
 system has shared jacks with mic in enabled 
 The following snd_ac97_ymf753_... items added by David Shust (dshust@shustring.com) 
 Modified for YMF743 by Keita Maehara <maehara@debian.org> 
 It is possible to indicate to the Yamaha YMF7x3 the type of
 0 = invalid 
 It is possible to indicate to the Yamaha YMF7x3 the source to
 set default PCM SPDIF params 
 PCM audio,no copyright,no preemphasis,PCM coder,original 
 Yamaha 3D enhancement 
 48k only 
 force the detection of spdif 
 The AC'97 spec states that the SPDIF signal is to be output at pin 48.
   The YMF753 will output the SPDIF signal to pin 43, 47 (EAPD), or 48.
   By default, no output pin is selected, and the SPDIF signal is not output.
	 The following can be used to direct SPDIF output to pin 47 (EAPD).
	 Patch for Yamaha YMF753, Copyright (c) by David Shust, dshust@shustring.com.
	   This chip has nonstandard and extended behaviour with regard to its SPDIF output.
	   The AC'97 spec states that the SPDIF signal is to be output at pin 48.
	   The YMF753 will ouput the SPDIF signal to pin 43, 47 (EAPD), or 48.
	   By default, no output pin is selected, and the SPDIF signal is not output.
	   There is also a bit to mute SPDIF output in a vendor-specific register.
 Yamaha 3D enhancement 
  May 2, 2003 Liam Girdwood <lrg@slimlogic.co.uk>
   removed broken wolfson00 patch.
   added support for WM9705,WM9708,WM9709,WM9710,WM9711,WM9712 and WM9717.
	 This is known to work for the ViewSonic ViewPad 1000
	  Randolph Bentson <bentson@holmsjoen.com>
	  WM9703970797089717 
 patch for DVD noise 
 WM9704M9704Q 
 WM9705, WM9710 
 WM9705 touchscreen uses AUX and VIDEO for touch 
 WM9711, WM9712 
 WM9713, WM9714 
  Tritech codec
  Sigmatel STAC97xx codecs
 "Sigmatel " removed due to excessive name length: 
 the register bit is writable, but the function is not implemented: 
 HP (sigmatel surround) support 
 nothing 
 patch for SigmaTel
 patch for SigmaTel
 is this correct? --jk 
 patch for SigmaTel
 is this correct? --jk 
 DAC-A direct 
 DAC-A to Mix = PCM 
 DAC-B direct = Surround 
 DAC-B to Mix 
 DAC-C direct = CenterLFE 
 OUTSEL  0xd794, 
 IOMISC  0x2001,
 INSEL  0x0201, 
 VARIOUS  0x0040
 OUTSEL  0xfc70, 
 IOMISC  0x2102, 
 INSEL  0x0203, 
 VARIOUS  0x0041 
 Gateway M675 notebook 
 patch for SigmaTel
 FIXME: assume only page 0 for writing cache 
  Cirrus Logic CS42xx codecs
 con mask, pro mask, default 
 switch, spsa 
 set default PCM SPDIF params 
 consumer,PCM audio,no copyright,no preemphasis,PCM coder,original,48000Hz 
	 Basically, the cs4201cs4205cs4297a has non-standard spdif registers.
	   WHY CAN'T ANYONE FOLLOW THE BLOODY SPEC?  sigh
	   - spdif EA ID is not set, but spdif is always present.
	   - enabledisable is spdif register bit 15.
	   - spdif control register is 0x68.  differs from AC97:
	   - valid is bit 14 (vs 15)
	   - no DRS
	   - only 44.148k [00 = 48, 01=44,1] (AC97 is 00=44.1, 10=48)
	   - spdif ssource select is in 0x5e bits 0,1.
 force the detection of spdif 
 force the detection of PC Beep 
  Conexant codecs
 con mask, pro mask, default 
 switch 
 set default PCM SPDIF params 
 consumer,PCM audio,no copyright,no preemphasis,PCM coder,original,48000Hz 
 force the detection of spdif 
 48k only 
  Analog Devices AD18xx, AD19xx codecs
 normal restore 
 restore the AD18xx codec configurations 
 select single codec 
 select all codecs 
 restore status 
 handle multi codecs for AD18xx 
 select single codec 
 update PCM bits 
 select all codecs 
 ignore 
 terminator 
 patch for Analog Devices
 select all codecs 
 test for unchained codec
 ID0C, ID1C, SDIE = off 
 SDIE
 already detected?
 test for chained codecs
 ID1C
 SDIE | ID1C
 SDIE | ID1C
 patch for Analog Devices
 select all codecs 
 check if only one codec is present 
 ok, deselect all ID bits 
 required for AD1886AD1885 combination 
 AC97_SINGLE("Digital Audio Mode", AC97_AD_MISC, 12, 1, 0),  
 inverted 
 inverted 
 This is required to deal with the Intel D815EEAL2 
 i.e. Line out is actually headphone out from codec 
 set default 
 Presario700 workaround 
 for Jack SenseSPDIF Register misetting causing 
 MISC bits (AD1888AD1980AD1985 register 0x76) 
 mic boost 
 +20dB 
 +10dB 
 +30dB 
 VREF high-Z 
 0=2.25V, 1=3.7V 
 0V (AD1985 only) 
 sample rate unlock 
 LINE_OUT amplifiers input select 
 2-channel mic select 
 SPREAD enable 
 downmix mode: 
  0 = 6-to-4, 1 = 6-to-2 downmix 
 downmix mode: 1 = enabled 
 headphone amplifier input select 
 centerlfe disable 
 LINE_OUT disable 
 mute split 
 AC97 no compatible mode 
 DAC zero-fill mode 
 MISC 1 bits (AD1986 register 0x76) 
 mic boost 
 +20dB 
 +10dB 
 +30dB 
 LINE_IN select bit 0 
 LINE_IN select bit 1 
 LINE_IN pins as LINE_IN source 
 SURROUND pins as LINE_IN source 
 MIC_12 pins as LINE_IN source 
 sample rate unlock 
 SURROUND_OUT amplifiers input sel 
 2-channel mic select 
 SPREAD enable 
 downmix mode: 
  0 = 6-to-4, 1 = 6-to-2 downmix 
 downmix mode: 1 = enabled 
 centerlfe disable 
 SURROUND_OUT disable 
 mute split (read only 1) 
 AC97 no compatible mode (ro 1) 
 DAC zero-fill mode 
 MISC 2 bits (AD1986 register 0x70) 
 Misc Control Bits 2 (AD1986) 
 CLFE VREF_OUT 2.25V 
 CLFE VREF_OUT 0V 
 CLFE VREF_OUT 3.7V 
 Jack Sense Mapping 1 = alternate 
 Mono Mute Disable 
 MIC VREF_OUT 2.25V 
 MIC VREF_OUT 0V 
 MIC VREF_OUT 3.7V 
 MISC 3 bits (AD1986 register 0x7a) 
 Misc Control Bits 3 (AD1986) 
 Mic Mix, leftright 
 General Purpose Out 
 LINE_OUT headphone drive 
 LINE_OUT VREF_OUT 2.25V 
 LINE_OUT VREF_OUT 0V 
 LINE_OUT VREF_OUT 3.7V 
 Jack Sense Invert SENSE_A 
 LINE_OUT amplifiers input select 
 Headphone amplifiers 
   input select Surround DACs 
 Headphone amplifiers input 
   select CLFE DACs 
 Jack Sense Invert SENSE_B 
 Serial Config bits (AD1986 register 0x74) (incomplete) 
 Optional Mic Selector bit 0 
 Optional Mic Selector bit 1 
 Optional Mic Selector bit 2 
 MIC_12 pins are MIC sources 
 LINE_IN pins are MIC sources 
 CenterLFE pins are MCI sources 
 Mix of MIC and CLFE pins 
   are MIC sources 
 MIX of MIC and LINE_IN pins 
   are MIC sources 
 MIX of LINE_IN and CLFE pins 
   are MIC sources 
 MIX of MIC, LINE_IN, CLFE pins 
   are MIC sources 
 deny list to avoid HPLine jack-sense controls
  (SS vendor << 16 | device)
 Thinkpad R40 
 Thinkpad X31 
 Thinkpad T41p 
 Thinkpad R40e 
 Thinkpad T42pR50p 
 Thinkpad T43p 2668-G7U 
 Thinkpad X41-2527 
 Dell Dimension 2400 
 Asus A7V8X-MX 
 Toshiba Satellite A-15 S127 
 Toshiba P500 
 Samsung NP-X20C004SEG 
 end 
 allow list to enable HP jack-sense bits
  (SS vendor << 16 | device)
 HP nc40004010 
 HP nc6000 
 HP nc4220 
 HP nx6110 
 HP nc6220 
 HP nc8220 
 HP nx9105 
 HP Compaq dc5100 SFF(PT003AW) 
 FSC Scenic-W 
 end 
 enable headphone jack sense 
 clear LODIS if shared jack is to be used for Surround out 
 clear CLDIS if shared jack is to be used for CLFE out 
 shared Line-In 
 rename 0x04 as "Master" and 0x02 as "Master Surround" 
	
	  LO can be used as a real line-out on some devices,
	  and we need to revert the frontsurround mixer switches
 ASUS A9T laptop 
 AD-compatible mode 
 Stereo mutes enabled 
 Switch FRONTSURROUND LINE-OUTHP-OUT default connection 
		 it seems that most vendors connect line-out connector to
		  headphone out of AC'97
 clear OMS if shared jack is to be used for CLFE out 
 rename 0x04 as "Master" and 0x02 as "Master Surround" 
 switch frontsurround line-outhp-out 
 AD-compatible mode 
 Stereo mutes enabled 
 update current jack configuration 
 on AD1985 rev. 3, AC'97 revision bits are zero 
 SOSEL is set to values of "Spread" or "Exchange FS" controls 
 SOSEL is set to values of "Spread" or "Exchange FS" controls 
 Use MIC_12 V_REFOUT as the "get" value 
 High-Z 
 3.7 V 
 2.25 V 
 0 V 
 disable SURROUND and CENTERLFE if not surround mode 
 select line input (default=LINE_IN, SURROUND or MIC_12) 
 select microphone input (MIC_12, CenterLFE or LINE_IN) 
 update current jack configuration 
  realtek ALC203: use mono-out for pin 37
  realtek ALC65x850 codecs
 shared Line-In  Surround Out 
 update shared Mic In  CenterLFE Out 
 disableenable vref 
 turn onoff center-on-mic 
 GPIO0 high for mic 
 4: Analog Input To Surround 
 5: Analog Input To CenterLFE 
 6: Independent Master Volume Right 
 7: Independent Master Volume Left 
 8: reserved 
 9: Line-InSurround share 
 10: MicCLFE share 
 11-13: in IEC958 controls 
 always set in patch_alc650 
 disable this controls since it doesn't work as expected 
 AC97_SINGLE("IEC958 Input Monitor", AC97_ALC650_MULTICH, 13, 1, 0), 
 determine the revision 
 Old version 
 D version 
 E version 
 F version 
 revision E or F 
 FIXME: what about revision D ? 
 enable AC97_ALC650_GPIO_SETUP, AC97_ALC650_CLOCK for RW 
 Enable SPDIF-IN only on Rev.E and above 
 SPDIF IN with pin 47 
 ASUS A6KM requires EAPD 
 enable 
 disable 
	 set default: slot 3,4,7,8,6,9
	   spdif-in monitor off, analog-spdif off, spdif-in off
	   center on mic off, surround on line-in off
	   downmix off, duplicate front off
 set GPIO0 for mic bias 
 GPIO0 pin output, no interrupt, high 
 full DAC volume 
 shared Line-In  Surround Out 
 update shared Mic In  CenterLFE Out 
 misc control; vrefout disable 
 disable this controls since it doesn't work as expected 
 AC97_PAGE_SINGLE("IEC958 Input Monitor", AC97_ALC650_MULTICH, 14, 1, 0, 0), 
 ALC658 
 assume only page 0 for writing cache 
 adjust default values 
 misc control 
 ALC658 
 Pin 47 is spdif input pin 
 ALC655 
 MSI S270 laptop 
 LG K1 Express 
 MSI L725 laptop 
 MSI L720 laptop 
 MSI S250 laptop 
 Pin 47 is EAPD (for internal speaker) 
 Pin 47 is spdif input pin 
 this seems missing on some hardwares 
 vref enable 
	 set default: spdif-in enabled,
	   spdif-in monitor off, spdif-in PCM off
	   center on mic off, surround on line-in off
	   duplicate front off
 full DAC volume 
 update undocumented bit... 
 shared Line-In  Surround Out 
 SURR 1kOhm (bit4), Amp (bit5) 
 LINE-IN = 0, SURROUND = 2 
 update shared Mic In  CenterLFE Out 
 Vref disable (bit12), 1kOhm (bit13) 
 MIC-IN = 1, CENTER-LFE = 5 
 Aux is Back Surround 
 for IEC958 playback route - ALC655 compatible 
 assume only page 0 for writing cache 
 adjust default values 
	 set default: spdif-in enabled,
	   spdif-in monitor off, spdif-in PCM off
	   center on mic off, surround on line-in off
	   duplicate front off
	   NB default bit 10=0 = Aux is Capture, not Back Surround
	 SURR_OUT: on, Surr 1kOhm: on, Surr Amp: off, Front 1kOhm: off
	  Front Amp: on, Vref: enable, Center 1kOhm: on, Mix: on
	 detection UIO2,3: all path floating, UIO3: MIC, Vref2: disable,
	  UIO1: FRONT, Vref3: disable, UIO3: LINE, Front-Mic: mute
 full DAC volume 
	
	  3D register is different from AC97 standard layout
	  (also do some renaming, to resemble Windows driver naming)
	 Aztech Windows driver calls the
  C-Media CM97xx codecs
 shared Line-In  Surround Out 
 FIXME: can anyone confirm below? 
 CM9738 has no PCM volume although the register reacts 
 BIT 0: SPDI_EN - always true 
 BIT 1: SPDIFS 
 BIT 2: IG_SPIV 
 BIT 3: SPI2F 
 BIT 4: SPI2SDI 
 BIT 8: SPD32 - 32bit SPDIF - not supported yet 
 shared Line-In  Surround Out 
 shared Mic In  CenterLFE Out 
 CM9739A has no Master and PCM volume although the register reacts 
 check spdif 
 enable spdif in 
 48k only 
 disable extended-id 
 set-up multi channel 
 bit 14: 0 = SPDIF, 1 = EAPD 
 bit 13: enable internal vref output for mic 
 bit 12: disable centerlfe (switchable) 
 bit 10: disable surroundline (switchable) 
 bit 9: mix 2 surround off 
 bit 4: undocumented; 0 mutes the CM9739A, which defaults to 1 
 bit 3: undocumented; surround? 
 bit 0: dB 
 FIXME: set up GPIO 
 Special exception for ASUS W1000CMI9739. It does not have an SPDIF in. 
	 FIXME: check the bits for each model
	         model 83 is confirmed to work
 9761-78 & 82 
 9761-82 rev.B 
 9761-83 
 9761-78 & 82 
 9761-82 rev.B 
 9761-83 
 9761-78 & 82 
 9761-82 rev.B 
 9761-83 
 9761-78 & 82 
 9761-82 rev.B 
 9761-83 
 SPDIF-loopback 
 ADC loopback 
 AC-link 
 BIT 1: SPDIFS 
 BIT 2: IG_SPIV 
 BIT 3: SPI2F 
 BIT 4: SPI2SDI 
 BIT 9-10: DAC_CTL 
 CM9761 has no PCM volume although the register reacts 
	 Master volume seems to have _some_ influence on the analog
	  input sounds
AC97_HAS_NO_MASTER_VOL | AC97_HAS_NO_PCM_VOL;
 1 = model 82 revision B, 2 = model 83 
 check page 1, reg 0x60 
 revision B? 
 enable spdif 
 force the SPDIF bit in ext_id - codec doesn't set this bit! 
 to be sure: we overwrite the ext status bits 
 Don't set 0x0200 here.  This results in the silent analog output 
 enable spdif-in 
 48k only 
 set-up multi channel 
	 bit 15: pc master beep off
	  bit 14: pin47 = EAPDSPDIF
	  bit 13: vref ctl [= cm9739]
	  bit 12: CLFE control (reverted on rev B)
	  bit 11: Miccenter share (reverted on rev B)
	  bit 10: suddoundline share
	  bit  9: Analog-in mix -> surround
	  bit  8: Analog-in mix -> CLFE
	  bit  7: MicLFE share (miccenterlfe)
	  bit  5: vref select (9761A)
	  bit  4: front control
	  bit  3: surround control (revereted with rev B)
	  bit  2: front mic
	  bit  1: stereo mic
	  bit  0: mic boost level (0=20dB, 1=30dB)
 front on 
 FIXME: set up GPIO 
 identical with CM9761 
 enable spdif 
 48k only 
 SPDI_EN 
  VIA VT1613 codec
  VIA VT1616 codec
 find a mixer control element with the given name 
 create a virtual master control and add followers 
 There is already a misnamed master switch.  Rename it.  
  VT1617A codec
  unfortunately, the vt1617a stashes the twiddlers required for
  noodling the io jacks on 2 different regs. that means that we can't
  use the easy way provided by AC97_ENUM_DOUBLE() we have to write
  are own funcs.
  NB: this is absolutely and utterly different from the vt1618. dunno
  about the 1616.
 copied from ac97_surround_jack_mode_info() 
	 ordering in this list reflects vt1617a docs for Reg 20 and
	  7a and Table 6 that lays out the matrix NB WRT Table6: SM51
	  is SM51EN AND it's Bit14, not Bit15 so the table is very
 grab codec handle 
	 grab our desired bits, then mash them together in a manner
 grab codec handle 
	 push our values into the register - consider that things will be left
	
	  These are used to enabledisable surround sound on motherboards
	  that have 3 bidirectional analog jacks
	 we choose to not fail out at this point, but we tell the
	 bring analog power consumption to normal by turning off the
	  headphone amplifier, like WinXP driver for EPIA SP
	 We need to check the bit before writing it.
	  On some (many?) hardwares, setting bit actually clears it!
 force the detection of spdif 
 VIA VT1618 8 CHANNEL AC97 CODEC
  VIA implements 'Smart 5.1' completely differently on the 1618 than
  it does on the 1617a. awesome! They seem to have sourced this
  particular revision of the technology from somebody else, it's
  called Universal Audio Jack and it shows up on some other folk's chips
  as well.
  ordering in this list reflects vt1618 docs for Reg 60h and
  the block diagram, DACs are as follows:
         OUT_O -> Front,
 	  OUT_1 -> Surround,
 	  OUT_2 -> CLFE
  Unlike the 1617a, each OUT has a consistent set of mappings
  for all bitpatterns other than 00:
         01       Unmixed Output
         10       Line In
         11       Mic  In
  Special Case of 00:
         OUT_0    Mixed Output
         OUT_1    Reserved
         OUT_2    Reserved
  I have no idea what the hell Reserved does, but on an MSI
  CN700T, i have to set it to get 5.1 output - YMMV, bad
  shit may happen.
  If other chips use Universal Audio Jack, then this code might be applicable
  to them.
 This list reflects the vt1618 docs for Vendor Defined Register 0x60. 
 speaker jack 
 line jack 
 mic jack 
 All of the vt1618 Universal Audio Jack twiddlers are on
  Vendor Defined Register 0x60, page 0. The bits, and thus
  the mask, are the only thing that changes
 config aux in jack - not found on 3 jack motherboards or soundcards 
 toggle surround rear dac power 
 toggle aux in surround rear out jack 
 shared Line-In  Surround Out 
 shared Mic  CenterLFE Out 
 full DAC volume 
  Si3036 codec
  LM 4550 Codec
  We use a static resolution table since LM4550 codec cannot be
  properly autoprobed to determine the resolution via
  check_volume_resolution().
 LSB is ignored 
 terminator 
   UCB1400 codec (http:www.semiconductors.philips.comacrobat_downloaddatasheetsUCB1400-02.pdf)
 enabledisable headphone driver which allows direct connection to
   stereo headphone without the use of external DC blocking
 Filter used to compensate the DC offset is added in the ADC to remove idle
 Control smart-low-power mode feature. Allows automatic power down
 enable headphone driver and smart low power mode by default 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
   Universal interface for Audio Codec '97
   For more details look to AC '97 component specification revision 2.2
   by Intel Corporation (http:developer.intel.com).
  proc interface
   0  "No 3D Stereo Enhancement",
   1  "Analog Devices Phat Stereo",
   2  "Creative Stereo Enhancement",
   3  "National Semi 3D Stereo Enhancement",
   4  "YAMAHA Ymersion",
   5  "BBE 3D Stereo Enhancement",
   6  "Crystal Semi 3D Stereo Enhancement",
   7  "Qsound QXpander",
   8  "Spatializer 3D Stereo Enhancement",
   9  "SRS 3D Stereo Enhancement",
  10  "Platform Tech 3D Stereo Enhancement",
  11  "AKM 3D Audio",
  12  "Aureal Stereo Enhancement",
  13  "Aztech 3D Enhancement",
  14  "Binaura 3D Audio Enhancement",
  15  "ESS Technology Stereo Enhancement",
  16  "Harman International VMAx",
  17  "NvideaIC EnsembleKS Waves 3D Stereo Enhancement",
  18  "Philips Incredible Sound",
  19  "Texas Instruments 3D Stereo Enhancement",
  20  "VLSI Technology 3D Stereo Enhancement",
  21  "TriTech 3D Stereo Enhancement",
  22  "Realtek 3D Stereo Enhancement",
  23  "Samsung 3D Stereo Enhancement",
  24  "Wolfson Microelectronics 3D Enhancement",
  25  "Delta Integration 3D Enhancement",
  26  "SigmaTel 3D Enhancement",
  27  "IC EnsembleKS Waves",
  28  "Rockwell 3D Stereo Enhancement",
  29  "Reserved 29",
  30  "Reserved 30",
  31  "Reserved 31"
 val = snd_ac97_read(ac97, AC97_RESET);
 VRA 
 ALC650 specific
 Analog Devices AD18818586
 select single codec 
 select all codecs 
 direct register write for debugging 
 register must be even 
 Analog Devices AD18818586
 select single codec 
 select all codecs 
 SPDX-License-Identifier: GPL-2.0-or-later
  HD audio interface patch for Creative X-Fi CA0110-IBG chip
  Copyright (c) 2008 Takashi Iwai <tiwai@suse.de>
  patch entries
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
  HD audio interface patch for Conexant HDA audio codec
  Copyright (c) 2006 Pototskiy Akex <alex.pototskiy@gmail.com>
  		      Takashi Iwai <tiwai@suse.de>
  		      Tobin Davis  <tdavis@dsl-only.net>
 extra EAPD pins 
 flag for snd_hda_parse_pin_defcfg() 
 OPLC XO specific 
 offset into olpc_xo_dc_bias 
 additional beep mixers; private_value will be overwritten 
  Automatic parser for CX20641 & co
 parse EAPDs 
	 NOTE: below is a wild guess; if we have more than two EAPDs,
	  it's a new chip, where EAPDs are supposed to be associated to
	  pins, and we can control EAPD per pin.
	  OTOH, if only one or two EAPDs are found, it's an old chip,
	  thus it might control over all pins.
 turn onoff EAPD according to Master switch 
 turn onoff EAPD according to Master switch (inversely!) for mute LED 
	 Turn the problematic codec into D3 to avoid spurious noises
  pin fix-up
 for hda_fixup_thinkpad_acpi() 
 The verbs used in this function were tested on a Conexant CX207512 codec. 
 enable merged mode for analog int-mic 
 disable merged mode for analog int-mic 
 OPLC XO 1.5 fixup 
 OLPC XO-1.5 supports DC input mode (e.g. for use with analog sensors)
  through the microphone jack.
  When the user enables this through a mixer switch, both internal and
  external microphones are disabled. Gain is fixed at 0dB. In this mode,
  we also allow the bias to be configured through a separate mixer
	 Set up mic pins for port-B, C and F dynamically as the recording
	  LED is turned onoff by these pin controls
 disable DC bias path and pin for port F 
 update port B (ext mic) and C (int mic) 
		 OLPC defers mic widget control until when capture is
		  started because the microphone LED comes on as soon as
		  these settings are put in place. if we did this before
		  recording, it would give the false indication that
		  recording is happening when it is not.
 enable normal mic path 
 disable normal mic path 
		 Even though port F is the DC input, the bias is controlled
		  on port B.  We also leave that port as an active input (but
		  unselected) in DC mode just in case that is necessary to
		  make the bias setting take effect.
 enable DC bias path and pin 
 mic_autoswitch hook 
 in DC mode, we don't handle automic 
 pcm_capture hook 
	 toggle spec->recording flag and update mic pins accordingly
	  for turning onoff LED
 overriding mic boost put callback; update mic boost volume only when
  DC mode is disabled
	 OLPC's microphone port is DC coupled for use with external sensors,
	  therefore we use a 50% mic bias in order to center the input signal
	  with the DC input range of the codec.
 override mic boost control 
  Fix max input level on mixer widget to 0dB
  (originally it has 0x2b steps with 0dB offset 0x14)
  Fix max input level on mixer widget to 0dB
  (originally it has 0x1e steps with 0 dB offset 0x17)
	 the mic pin (0x19) doesn't give an unsolicited event;
	  probe the mic pin together with the headphone pin (0x16)
 update LED status via GPIO 
 turn onoff mute LED via GPIO per vmaster hook 
 turn onoff mic-mute LED via GPIO per capture hook 
 ThinkPad X200 & co with cxt5051 
 HP (seq# overridden) 
 dock-mic 
 dock-HP 
 dock SPDIF out 
 ThinkPad 410420510520, X201 & co with cxt5066 
 HP (seq# overridden) 
 dock-mic 
 dock-HP 
 Lemote A1004A1205 with cxt5066 
 Internal mic 
 External mic 
 Not used 
 Not used 
 Not used 
 Not used 
 Not used 
 0x17 was falsely set up as a mic, it should 0x1d 
 use as headphone mic, without its own jack detect 
 speakerhp 
 ext mic 
 int mic 
 int mic 
 line-out 
 line-in 
 enable NID 0x1d for the speaker on top 
	 HP, Packard Bell, Fujitsu-Siemens & Lenovo laptops have
	  really bad sound over 0dB on NID 0x17.
	 HP laptops have really bad sound over 0 dB on NID 0x10.
 add "fake" mute amp-caps to DACs on cx5051 so that mixer mute switches
  can be created (bko#42825)
	 Some laptops with Conexant chips show stalls in S3 resume,
	  which falls into the single-cmd mode.
	  Better to make reset, then.
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
  Universal Interface for Intel High Definition Audio Codec
  Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>
  Send and receive a verb - passed to exec_verb override for hdac_device
 clear reset-flag when the communication gets recovered 
  snd_hda_sequence_write - sequence writes
  @codec: the HDA codec
  @seq: VERB array to send
  Send the commands sequentially from the given array.
  The array must be terminated with NID=0.
 connection list element 
 look up the cached results 
 read the connection and add to the cache 
  snd_hda_get_conn_list - get connection list
  @codec: the HDA codec
  @nid: NID to parse
  @listp: the pointer to store NID list
  Parses the connection list of the given widget and stores the pointer
  to the list of NIDs.
  Returns the number of connections, or a negative error code.
  Note that the returned pointer isn't protected against the list
  modification.  If snd_hda_override_conn_list() might be called
  concurrently, protect with a mutex appropriately.
 if the connection-list is already cached, read it 
  snd_hda_get_connections - copy connection list
  @codec: the HDA codec
  @nid: NID to parse
  @conn_list: connection list array; when NULL, checks only the size
  @max_conns: max. number of connections to store
  Parses the connection list of the given widget and stores the list
  of NIDs.
  Returns the number of connections, or a negative error code.
  snd_hda_override_conn_list - addmodify the connection-list to cache
  @codec: the HDA codec
  @nid: NID to parse
  @len: number of connection list entries
  @list: the list of connection entries
  Add or modify the given connection-list to the cache.  If the corresponding
  cache already exists, invalidate it and append a new one.
  Returns zero or a negative error code.
  snd_hda_get_conn_index - get the connection index of the given NID
  @codec: the HDA codec
  @mux: NID containing the list
  @nid: NID to select
  @recursive: 1 when searching NID recursively, otherwise 0
  Parses the connection list of the widget @mux and checks whether the
  widget @nid is present.  If it is, return the connection index.
  Otherwise it returns -1.
  snd_hda_get_num_devices - get DEVLIST_LEN parameter of the given widget
   @codec: the HDA codec
   @nid: NID of the pin to parse
  Get the device entry number on the given widget. This is a feature of
  DP MST audio. Each pin can have several device entries in it.
  snd_hda_get_devices - copy device list without cache
  @codec: the HDA codec
  @nid: NID of the pin to parse
  @dev_list: device list array
  @max_devices: max. number of devices to store
  Copy the device list. This info is dynamic and so not cached.
  Currently called only from hda_proc.c, so not exported.
 not multi-stream capable 
 error 
  snd_hda_get_dev_select - get device entry select on the pin
  @codec: the HDA codec
  @nid: NID of the pin to get device entry select
  Get the devcie entry select on the pin. Return the device entry
  id selected on the pin. Return 0 means the first device entry
  is selected or MST is not supported.
 not support dp_mst will always return 0, using first dev_entry 
  snd_hda_set_dev_select - set device entry select on the pin
  @codec: the HDA codec
  @nid: NID of the pin to set device entry select
  @dev_id: device entry id to be set
  Set the device entry select on the pin nid.
 not support dp_mst will always return 0, using first dev_entry 
 AC_PAR_DEVLIST_LEN is 0 based. 
	 If Device List Length is 0 (num_device = 1),
	  the pin is not multi stream capable.
	  Do nothing in this case.
	 Behavior of setting index being equal to or greater than
	  Device List Length is not predictable
  read widget caps for each widget and store in cache
 read all pin default configurations and save codec->init_pins 
		
		  all device entries are the same widget control so far
		  fixme: if any codec is different, need fix here
 look up the given pin config list and return the item matching with NID 
 set the current pin config value for the given NID.
  the value is cached, and read via snd_hda_codec_get_pincfg()
	 the check below may be invalid when pins are added by a fixup
	  dynamically (e.g. via snd_hda_codec_update_widgets()), so disabled
	  for now
	
	if (get_wcaps_type(get_wcaps(codec, nid)) != AC_WID_PIN)
		return -EINVAL;
  snd_hda_codec_set_pincfg - Override a pin default configuration
  @codec: the HDA codec
  @nid: NID to set the pin config
  @cfg: the pin default config value
  Override a pin default configuration value in the cache.
  This value can be read by snd_hda_codec_get_pincfg() in a higher
  priority than the real hardware value.
  snd_hda_codec_get_pincfg - Obtain a pin-default configuration
  @codec: the HDA codec
  @nid: NID to get the pin config
  Get the current pin config value of the given pin NID.
  If the pincfg value is cached or overridden via sysfs or driver,
  returns the cached value.
  snd_hda_codec_set_pin_target - remember the current pinctl target value
  @codec: the HDA codec
  @nid: pin NID
  @val: assigned pinctl value
  This function stores the given value to a pinctl target value in the
  pincfg table.  This isn't always as same as the actually written value
  but can be referred at any time via snd_hda_codec_get_pin_target().
  snd_hda_codec_get_pin_target - return the current pinctl target value
  @codec: the HDA codec
  @nid: pin NID
  snd_hda_shutup_pins - Shut up all pins
  @codec: the HDA codec
  Clear all pin controls to shup up before suspend for avoiding click noise.
  The controls aren't cached so that they can be resumed properly.
	 don't shut up pins when unloading the driver; otherwise it breaks
	  the default pin setup at the next load of the driver
 use read here for syncing after issuing each verb 
 Restore the pin controls cleared previously via snd_hda_shutup_pins() 
 for non-polling trigger: we need nothing if already powered on 
 the power-updown sequence triggers the runtime resume 
 update jacks manually if polling is required, too 
 release all pincfg lists 
  audio-converter setup caches
 cvt is currently used 
 setups should be cleared 
 get or create a cache entry for the given audio converter NID 
  PCM device
  codec destructor
 pm_runtime_put() is called in snd_hdac_device_exit() 
 free only driver_pins so that init_pins + user_pins are restored 
 enabledisable display power per codec 
 also called from hda_bind.c 
 it was powered up in snd_hda_codec_new(), now all done 
	
	  snd_hda_codec_device_new() is used by legacy HDA and ASoC driver.
	  We can't unregister ASoC device since it will be unregistered in
	  snd_hdac_ext_bus_device_remove().
	
	  In the case of ASoC HD-audio bus, the device refcount is released in
	  snd_hdac_ext_bus_device_remove() explicitly.
	
	  In the case of ASoC HD-audio, hda_codec is device managed.
	  It will be freed when the ASoC device is removed.
  snd_hda_codec_new - create a HDA codec
  @bus: the bus to assign
  @card: card for this codec
  @codec_addr: the codec address
  @codecp: the pointer to store the generated codec
  Returns 0 if successful, or a negative error code.
 power-up all before initialization 
 PM runtime needs to be enabled later after binding codec 
  snd_hda_codec_update_widgets - Refresh widget caps and pin defaults
  @codec: the HDA codec
  Forcibly refresh the all widget caps and the init pin configurations of
  the given codec.
	 Assume the function group node does not change,
	  only the widget nodes may change.
 update the stream-id if changed 
 update the format-id if changed 
  snd_hda_codec_setup_stream - set up the codec for streaming
  @codec: the CODEC to set up
  @nid: the NID to set up
  @stream_tag: stream tag to pass, it's between 0x1 and 0xf.
  @channel_id: channel id to pass, zero based.
  @format: stream format.
 make other inactive cvts with the same stream-tag dirty 
  __snd_hda_codec_cleanup_stream - clean up the codec for closing
  @codec: the CODEC to clean up
  @nid: the NID to clean up
  @do_now: really clean up the stream instead of clearing the active flag
		 here we just clear the active flag when do_now isn't set;
		  actual clean-ups will be done later in
		  purify_inactive_streams() called from snd_hda_codec_prpapre()
 clean up the all conflicting obsolete streams 
 clean up all streams; called from suspend 
  amp access functions
  query_amp_caps - query AMP capabilities
  @codec: the HD-auio codec
  @nid: the NID to query
  @direction: either #HDA_INPUT or #HDA_OUTPUT
  Query AMP capabilities for the given widget and direction.
  Returns the obtained capability bits.
  When cap bits have been already read, this doesn't read again but
  returns the cached value.
  snd_hda_check_amp_caps - query AMP capabilities
  @codec: the HD-audio codec
  @nid: the NID to query
  @dir: either #HDA_INPUT or #HDA_OUTPUT
  @bits: bit mask to check the result
  Check whether the widget has the given amp capability for the direction.
  snd_hda_override_amp_caps - Override the AMP capabilities
  @codec: the CODEC to clean up
  @nid: the NID to clean up
  @dir: either #HDA_INPUT or #HDA_OUTPUT
  @caps: the capability bits to set
  Override the cached AMP caps bits value by the given one.
  This function is useful if the driver needs to adjust the AMP ranges,
  e.g. limit to 0dB, etc.
  Returns zero if successful or a negative error code.
 enable fake mute if no hw mute but min=mute 
  snd_hda_codec_amp_update - update the AMP mono value
  @codec: HD-audio codec
  @nid: NID to read the AMP value
  @ch: channel to update (0 or 1)
  @dir: #HDA_INPUT or #HDA_OUTPUT
  @idx: the index value (only for input direction)
  @mask: bit mask to set
  @val: the bits value to set
  Update the AMP values for the given channel, direction and index.
  snd_hda_codec_amp_stereo - update the AMP stereo values
  @codec: HD-audio codec
  @nid: NID to read the AMP value
  @direction: #HDA_INPUT or #HDA_OUTPUT
  @idx: the index value (only for input direction)
  @mask: bit mask to set
  @val: the bits value to set
  Update the AMP values like snd_hda_codec_amp_update(), but for a
  stereo widget with the same mask and value.
  snd_hda_codec_amp_init - initialize the AMP value
  @codec: the HDA codec
  @nid: NID to read the AMP value
  @ch: channel (left=0 or right=1)
  @dir: #HDA_INPUT or #HDA_OUTPUT
  @idx: the index value (only for input direction)
  @mask: bit mask to set
  @val: the bits value to set
  Works like snd_hda_codec_amp_update() but it writes the value only at
  the first access.  If the amp was already initialized  updated beforehand,
  this does nothing.
  snd_hda_codec_amp_init_stereo - initialize the stereo AMP value
  @codec: the HDA codec
  @nid: NID to read the AMP value
  @dir: #HDA_INPUT or #HDA_OUTPUT
  @idx: the index value (only for input direction)
  @mask: bit mask to set
  @val: the bits value to set
  Call snd_hda_codec_amp_init() for both stereo channels.
 get num steps 
  snd_hda_mixer_amp_volume_info - Info callback for a standard AMP mixer
  @kcontrol: referred ctl element
  @uinfo: pointer to getstore the data
  The control element is supposed to have the private_value field
  set up via HDA_COMPOSE_AMP_VAL() or related macros.
 ofs = 0: raw max value 
  snd_hda_mixer_amp_volume_get - Get callback for a standard AMP mixer volume
  @kcontrol: ctl element
  @ucontrol: pointer to getstore the data
  The control element is supposed to have the private_value field
  set up via HDA_COMPOSE_AMP_VAL() or related macros.
  snd_hda_mixer_amp_volume_put - Put callback for a standard AMP mixer volume
  @kcontrol: ctl element
  @ucontrol: pointer to getstore the data
  The control element is supposed to have the private_value field
  set up via HDA_COMPOSE_AMP_VAL() or related macros.
 inquiry the amp caps and convert to TLV 
  snd_hda_mixer_amp_tlv - TLV callback for a standard AMP mixer volume
  @kcontrol: ctl element
  @op_flag: operation flag
  @size: byte size of input TLV
  @_tlv: TLV data
  The control element is supposed to have the private_value field
  set up via HDA_COMPOSE_AMP_VAL() or related macros.
  snd_hda_set_vmaster_tlv - Set TLV for a virtual master control
  @codec: HD-audio codec
  @nid: NID of a reference widget
  @dir: #HDA_INPUT or #HDA_OUTPUT
  @tlv: TLV data to be stored, at least 4 elements
  Set (static) TLV data for a virtual master volume using the AMP caps
  obtained from the reference NID.
  The volume range is recalculated as if the max volume is 0dB.
 find a mixer control element with the given name 
  snd_hda_find_mixer_ctl - Find a mixer control element with the given name
  @codec: HD-audio codec
  @name: ctl id name string
  Get the control element with the given id string and IFACE_MIXER.
 16 ctlrs should be large enough 
  snd_hda_ctl_add - Add a control element and assign to the codec
  @codec: HD-audio codec
  @nid: corresponding NID (optional)
  @kctl: the control element to assign
  Add the given control element to an array inside the codec instance.
  All control elements belonging to a codec are supposed to be added
  by this function so that a proper clean-up works at the free or
  reconfiguration time.
  If non-zero @nid is passed, the NID is assigned to the control element.
  The assignment is shown in the codec proc file.
  snd_hda_ctl_add() checks the control subdev id field whether
  #HDA_SUBDEV_NID_FLAG bit is set.  If set (and @nid is zero), the lower
  bits value is taken as the NID to assign. The #HDA_NID_ITEM_AMP bit
  specifies if kctl->private_value is a HDA amplifier value.
  snd_hda_add_nid - Assign a NID to a control element
  @codec: HD-audio codec
  @nid: corresponding NID (optional)
  @kctl: the control element to assign
  @index: index to kctl
  Add the given control element to an array inside the codec instance.
  This function is used when #snd_hda_ctl_add cannot be used for 1:1
  NID:KCTL mapping - for example "Capture Source" selector.
  snd_hda_ctls_clear - Clear all controls assigned to the given codec
  @codec: HD-audio codec
  snd_hda_lock_devices - pseudo device locking
  @bus: the BUS
  toggle card->shutdown to allowdisallow the device access (as a hack)
  snd_hda_unlock_devices - pseudo device unlocking
  @bus: the BUS
  snd_hda_codec_reset - Clear all objects assigned to the codec
  @codec: HD-audio codec
  This frees the all PCM and control elements assigned to the codec, and
  clears the caches and restores the pin default configurations.
  When a device is being used, it returns -EBSY.  If successfully freed,
  returns zero.
 OK, let it free 
 allow device access again 
 apply the function to all matching follower ctls in the mixer list 
 call kctl->put with the given value(s) 
 initialize the follower volume with 0dB via snd_ctl_apply_vmaster_followers() 
 ignore 
 unmute the follower via snd_ctl_apply_vmaster_followers() 
  __snd_hda_add_vmaster - create a virtual master control and add followers
  @codec: HD-audio codec
  @name: vmaster control name
  @tlv: TLV data (optional)
  @followers: follower control names (optional)
  @suffix: suffix string to each follower name (optional)
  @init_follower_vol: initialize followers to unmute0dB
  @access: kcontrol access rights
  @ctl_ret: store the vmaster kcontrol in return
  Create a virtual master control with the given name.  The TLV data
  must be either NULL or a valid data.
  @followers is a NULL-terminated array of strings, each of which is a
  follower control name.  All controls with these names are assigned to
  the new virtual master control.
  This function returns zero if successful or a negative error code.
 init with master mute & zero volume 
 meta hook to call each driver's vmaster hook 
  snd_hda_add_vmaster_hook - Add a vmaster hw specific hook
  @codec: the HDA codec
  @hook: the vmaster hook object
  Add a hw specific hook (like EAPD) with the given vmaster switch kctl.
  snd_hda_sync_vmaster_hook - Sync vmaster hook
  @hook: the vmaster hook
  Call the hook with the current value for synchronization.
  Should be called in init callback.
	 don't call vmaster hook in the destructor since it might have
	  been already destroyed
  snd_hda_mixer_amp_switch_info - Info callback for a standard AMP mixer switch
  @kcontrol: referred ctl element
  @uinfo: pointer to getstore the data
  The control element is supposed to have the private_value field
  set up via HDA_COMPOSE_AMP_VAL() or related macros.
  snd_hda_mixer_amp_switch_get - Get callback for a standard AMP mixer switch
  @kcontrol: ctl element
  @ucontrol: pointer to getstore the data
  The control element is supposed to have the private_value field
  set up via HDA_COMPOSE_AMP_VAL() or related macros.
  snd_hda_mixer_amp_switch_put - Put callback for a standard AMP mixer switch
  @kcontrol: ctl element
  @ucontrol: pointer to getstore the data
  The control element is supposed to have the private_value field
  set up via HDA_COMPOSE_AMP_VAL() or related macros.
  SPDIF out controls
 convert from SPDIF status bits to HDA SPDIF bits
  bit 0 (DigEn) is always set zero (to be filled later)
 convert to SPDIF status bits from HDA SPDIF bits
 set digital convert verbs both for the given NID and its followers 
 unmute amp switch (if any) 
 end 
  snd_hda_create_dig_out_ctls - create Output SPDIF-related controls
  @codec: the HDA codec
  @associated_nid: NID that new ctls associated with
  @cvt_nid: converter NID
  @type: HDA_PCM_TYPE_
  Creates controls related with the digital output.
  Called from each patch supporting the digital out.
  Returns 0 if successful, or a negative error code.
 suppose a single SPDIF device 
  snd_hda_spdif_out_of_nid - get the hda_spdif_out entry from the given NID
  @codec: the HDA codec
  @nid: widget NID
  call within spdif_mutex lock
  snd_hda_spdif_ctls_unassign - Unassign the given SPDIF ctl
  @codec: the HDA codec
  @idx: the SPDIF ctl index
  Unassign the widget from the given SPDIF control.
  snd_hda_spdif_ctls_assign - Assign the SPDIF controls to the given NID
  @codec: the HDA codec
  @idx: the SPDIF ctl idx
  @nid: widget NID
  Assign the widget to the SPDIF control with the given index.
  SPDIF sharing with analog output
  snd_hda_create_spdif_share_sw - create Default PCM switch
  @codec: the HDA codec
  @mout: multi-out instance
 ATTENTION: here mout is passed as private_data, instead of codec 
  SPDIF input
 end 
  snd_hda_create_spdif_in_ctls - create Input SPDIF-related controls
  @codec: the HDA codec
  @nid: audio in widget NID
  Creates controls related with the SPDIF input.
  Called from each patch supporting the SPDIF in.
  Returns 0 if successful, or a negative error code.
  snd_hda_codec_set_power_to_all - Set the power state to all widgets
  @codec: the HDA codec
  @fg: function group (not used now)
  @power_state: the power state to set (AC_PWRST_)
  Set the given power state to all widgets that have the power control.
  If the codec has power_filter set, it evaluates the power state and
  filter out if it's unchanged as D3.
  snd_hda_codec_eapd_power_filter - A power filter callback for EAPD
  @codec: the HDA codec
  @nid: widget NID
  @power_state: power state to evalue
  Don't power down the widget if it controls eapd and EAPD_BTLENABLE is set.
  This can be used a codec power_filter callback.
  set power state of the codec, and return the power state
 this delay seems necessary to avoid click noise at power-down 
 repeat power states setting at most 10 times
 sync power states of all widgets;
  this is called at the end of codec parsing
 don't care if no filter is used 
 execute additional init verbs 
 update the power onoff account with the current jiffies 
  call suspend and power-down; used both from PM and power-save
  this function returns the power state in the end
  kick up codec; used both from PM and power-save
 Nothing to do if card registration fails and the component driver never probes 
 Nothing to do if card registration fails and the component driver never probes 
 CONFIG_PM 
 If no other pm-functions are called between prepare() and complete() 
 CONFIG_PM_SLEEP 
 referred in hda_bind.c 
 CONFIG_PM_SLEEP 
 suspend the codec at shutdown; called from driver's shutdown callback 
  add standard channel maps if not specified
 default channel maps for 2.1 speakers;
  since HD-audio supports only stereo, odd number channels are omitted
 continue to initialize... 
 we create chmaps here instead of build_pcms 
 call at the last init point 
  PCM stuff
 query support PCM information from the given NID 
  codec preparecleanup entries
  snd_hda_codec_prepare - Prepare a stream
  @codec: the HDA codec
  @hinfo: PCM information
  @stream: stream tag to assign
  @format: format id to assign
  @substream: PCM substream to assign
  Calls the prepare callback set by the codec with the given arguments.
  Clean up the inactive streams when successful.
  snd_hda_codec_cleanup - Clean up stream resources
  @codec: the HDA codec
  @hinfo: PCM information
  @substream: PCM substream
  Calls the cleanup callback set by the codec with the given arguments.
 global 
  get the empty PCM device number to assign
 audio device indices; not linear to keep compatibility 
	 assigned to static slots up to dev#10; if more needed, assign
	  the later slot dynamically (when CONFIG_SND_DYNAMIC_MINORS=y)
 non-fixed slots starting from 10 
 call build_pcms ops of the given codec and set up the default parameters 
 already parsed 
 assign all PCMs of the given codec 
 attach a new PCM streams 
 already attached 
 no substreams assigned 
 no fatal error 
 no fatal error 
  snd_hda_add_new_ctls - create controls from the array
  @codec: the HDA codec
  @knew: the array of struct snd_kcontrol_new
  This helper function creates and add new controls in the given array.
  The array must be terminated with an empty entry as terminator.
  Returns 0 if successful, or a negative error code.
 skip this codec private value 
			 try first with another device index corresponding to
			  the codec addr; if it still fails (or it's the
			  primary codec), then try another control index
  snd_hda_set_power_save - reprogram autosuspend for the given delay
  @bus: HD-audio bus
  @delay: autosuspend delay in msec, 0 = off
  Synchronize the runtime PM autosuspend state from the power_save option.
  snd_hda_check_amp_list_power - Check the amp list and update the power
  @codec: HD-audio codec
  @check: the object containing an AMP list and the status
  @nid: NID to check  update
  Check whether the given NID is in the amp list.  If it's in the list,
  check the current AMP status, and update the power-status according
  to the mute status.
  This function is supposed to be set or called from the check_power_status
  patch ops.
 nothing changed 
  input MUX helper
  snd_hda_input_mux_info - Info callback helper for the input-mux enum
  @imux: imux helper object
  @uinfo: pointer to getstore the data
  snd_hda_input_mux_put - Put callback helper for the input-mux enum
  @codec: the HDA codec
  @imux: imux helper object
  @ucontrol: pointer to getstore the data
  @nid: input mux NID
  @cur_val: pointer to getstore the current imux value
  snd_hda_enum_helper_info - Helper for simple enum ctls
  @kcontrol: ctl element
  @uinfo: pointer to getstore the data
  @num_items: number of enum items
  @texts: enum item string array
  process kcontrol info callback of a simple string enum array
  when @num_items is 0 or @texts is NULL, assume a boolean enum array
  Multi-channel  digital-out PCM helper functions
 setup SPDIF output stream 
	 Add sanity check to pass klockwork check.
	  This should never happen.
	 turn off SPDIF if needed; otherwise the IEC958 bits won't be
 turn on again (if needed) 
  snd_hda_multi_out_dig_open - open the digital out in the exclusive mode
  @codec: the HDA codec
  @mout: hda_multi_out object
 already opened as analog dup; reset it once 
  snd_hda_multi_out_dig_prepare - prepare the digital out stream
  @codec: the HDA codec
  @mout: hda_multi_out object
  @stream_tag: stream tag to assign
  @format: format id to assign
  @substream: PCM substream to assign
  snd_hda_multi_out_dig_cleanup - clean-up the digital out stream
  @codec: the HDA codec
  @mout: hda_multi_out object
  snd_hda_multi_out_dig_close - release the digital out stream
  @codec: the HDA codec
  @mout: hda_multi_out object
  snd_hda_multi_out_analog_open - open analog outputs
  @codec: the HDA codec
  @mout: hda_multi_out object
  @substream: PCM substream to assign
  @hinfo: PCM information to assign
  Open analog outputs and set up the hw-constraints.
  If the digital outputs can be opened as follower, open the digital
  outputs, too.
 FIXME: need notify? 
  snd_hda_multi_out_analog_prepare - Preapre the analog outputs.
  @codec: the HDA codec
  @mout: hda_multi_out object
  @stream_tag: stream tag to assign
  @format: format id to assign
  @substream: PCM substream to assign
  Set up the io for analog out.
  When the digital out is available, copy the front out to digital out, too.
 front 
 headphone out will just decode front leftright (stereo) 
 extra outputs copied from front 
 surrounds 
 independent out 
 copy front 
 extra surrounds 
  snd_hda_multi_out_analog_cleanup - clean up the setting for analog out
  @codec: the HDA codec
  @mout: hda_multi_out object
  snd_hda_get_default_vref - Get the default (mic) VREF pin bits
  @codec: the HDA codec
  @pin: referred pin NID
  Guess the suitable VREF pin bits to be set as the pin-control value.
  Note: the function doesn't set the AC_PINCTL_IN_EN bit.
 Exception: if the default pin setup is vref50, we give it priority 
  snd_hda_correct_pin_ctl - correct the pin ctl value for matching with the pin cap
  @codec: the HDA codec
  @pin: referred pin NID
  @val: pin ctl value to audit
 don't know what to do... 
  _snd_hda_set_pin_ctl - Helper to set pin ctl value
  @codec: the HDA codec
  @pin: referred pin NID
  @val: pin control value to set
  @cached: access over codec pinctl cache or direct write
  This function is a helper to set a pin ctl value more safely.
  It corrects the pin ctl value via snd_hda_correct_pin_ctl(), stores the
  value in pin target array via snd_hda_codec_set_pin_target(), then
  actually writes the value via either snd_hda_codec_write_cache() or
  snd_hda_codec_write() depending on @cached flag.
  snd_hda_add_imux_item - Add an item to input_mux
  @codec: the HDA codec
  @imux: imux helper object
  @label: the name of imux item to assign
  @index: index number of imux item to assign
  @type_idx: pointer to store the resultant label index
  When the same label is used already in the existing items, the number
  suffix is appended to the label.  This label index number is stored
  to type_idx when non-NULL pointer is given.
  snd_hda_bus_reset_codecs - Reset the bus
  @bus: HD-audio bus
 FIXME: maybe a better way needed for forced reset 
  snd_print_pcm_bits - Print the supported PCM fmt bits to the string buffer
  @pcm: PCM caps bits
  @buf: the string buffer to write
  @buflen: the max buffer length
  used by hda_proc.c and hda_eld.c
 necessary when j == 0 
 SPDX-License-Identifier: GPL-2.0
 Fixes for HP X360 laptops with top B&O speakers
  to be included from codec driver
 SPDX-License-Identifier: GPL-2.0-only
  sysfs interface for HD-audio codec
  Copyright (c) 2014 Takashi Iwai <tiwai@suse.de>
  split from hda_hwdep.c
 hint string pair 
 contained in the same alloc as key 
 CONFIG_PM 
  sysfs interface
  allocate a string at most len chars, and remove the trailing EOL
 extract key and val 
 replace 
 allocate a new hint entry 
 sysfs attributes exposed only when CONFIG_SND_HDA_RECONFIG=y 
  snd_hda_get_hint - Look for hint string
  @codec: the HDA codec
  @key: the hint key string
  Look for a hint keyvalue pair matching with the given key string
  and returns the value string.  If nothing found, returns NULL.
  snd_hda_get_bool_hint - Get a boolean hint value
  @codec: the HDA codec
  @key: the hint key string
  Look for a hint keyvalue pair matching with the given key string
  and returns a boolean value parsed from the value.  If no matching
  key is found, return a negative value.
 true 
 yes 
  snd_hda_get_int_hint - Get an integer hint value
  @codec: the HDA codec
  @key: the hint key string
  @valp: pointer to store a value
  Look for a hint keyvalue pair matching with the given key string
  and stores the integer value to @valp.  If no matching key is found,
  return a negative error code.  Otherwise it returns zero.
 CONFIG_SND_HDA_RECONFIG 
  common sysfs attributes
 parser mode 
 parse the contents after the line "[codec]"
  accept only the line with three numbers, and assign the current codec
 parse the contents after the other command tags, [pincfg], [verb],
  [vendor_id], [subsystem_id], [revision_id], [chip_name], [hint] and [model]
  just pass to the sysfs helper (only when any codec was specified)
 check the line starting with '[' -- change the parser mode accodingly 
 copy one line from the buffer in fw, and update the fields in fw
  return zero if it reaches to the end of the buffer, or non-zero
  if successfully copied a line
  the spaces at the beginning and the end of the line are stripped
  snd_hda_load_patch - load a "patch" firmware file and parse it
  @bus: HD-audio bus
  @fw_size: the firmware byte size
  @fw_buf: the firmware data
 CONFIG_SND_HDA_PATCH_LOADER 
  sysfs entries
 clear init verbs 
 clear hints 
 we don't need to free hint->val 
 SPDX-License-Identifier: GPL-2.0
 Fixes for Lenovo Ideapad S740, to be included from codec driver 
 SPDX-License-Identifier: GPL-2.0-or-later
  Jack-detection handling for HD-audio
  Copyright (c) 2011 Takashi Iwai <tiwai@suse.de>
  is_jack_detectable - Check whether the given pin is jack-detectable
  @codec: the HDA codec
  @nid: pin NID
  Check whether the given pin is capable to report the jack detection.
  The jack detection might not work by various reasons, e.g. the jack
  detection is prohibited in the codec level, the pin config has
  AC_DEFCFG_MISC_NO_PRESENCE bit, no unsol support, etc.
 execute pin sense measurement 
 need trigger? 
  snd_hda_jack_tbl_get_mst - query the jack-table entry for the given NID
  @codec: the HDA codec
  @nid: pin NID to refer to
  @dev_id: pin device entry id
  snd_hda_jack_tbl_get_from_tag - query the jack-table entry for the given tag
  @codec: the HDA codec
  @tag: tag value to refer to
  @dev_id: pin device entry id
  snd_hda_jack_tbl_new - create a jack-table entry for the given NID
  @codec: the HDA codec
  @nid: pin NID to assign
  @dev_id: pin device entry id
		
		  Copy jack_detect from existing_nid_jack to avoid
		  snd_hda_jack_detect_enable_callback_mst() making multiple
		  SET_UNSOLICITED_ENABLE calls on the same pin.
 free jack instances manually when clearingreconfiguring 
 update the cached value and notification flag if needed 
 A gating jack indicates the jack is invalid if gating is unplugged 
 If a jack is gated by this one update it. 
  snd_hda_jack_set_dirty_all - Mark all the cached as dirty
  @codec: the HDA codec
  This function sets the dirty flag to all entries of jack table.
  It's called from the resume path in hda_codec.c.
  snd_hda_jack_pin_sense - execute pin sense measurement
  @codec: the CODEC to sense
  @nid: the pin NID to sense
  @dev_id: pin device entry id
  Execute necessary pin sense measurement and return its Presence Detect,
  Impedance, ELD Valid etc. status bits.
  snd_hda_jack_detect_state_mst - query pin Presence Detect status
  @codec: the CODEC to sense
  @nid: the pin NID to sense
  @dev_id: pin device entry id
  Query and return the pin's Presence Detect status, as either
  HDA_JACK_NOT_PRESENT, HDA_JACK_PRESENT or HDA_JACK_PHANTOM.
  snd_hda_jack_detect_enable_callback_mst - enable the jack-detection
  @codec: the HDA codec
  @nid: pin NID to enable
  @func: callback function to register
  @dev_id: pin device entry id
  In the case of error, the return value will be a pointer embedded with
  errno.  Check and handle the return value appropriately with standard
  macros such as @IS_ERR() and @PTR_ERR().
 already registered 
 No unsol if we're polling instead 
  snd_hda_jack_detect_enable - Enable the jack detection on the given pin
  @codec: the HDA codec
  @nid: pin NID to enable jack detection
  @dev_id: pin device entry id
  Enable the jack detection with the default callback.  Returns zero if
  successful or a negative error code.
  snd_hda_jack_set_gating_jack - Set gating jack.
  @codec: the HDA codec
  @gated_nid: gated pin NID
  @gating_nid: gating pin NID
  Indicates the gated jack is only valid when the gating jack is plugged.
  snd_hda_jack_bind_keymap - bind keys generated from one NID to another jack.
  @codec: the HDA codec
  @key_nid: key event is generated by this pin NID
  @keymap: map of key type and key code
  @jack_nid: key reports to the jack of this pin NID
  This function is used in the case of key is generated from one NID while is
  reported to the jack of another NID.
  snd_hda_jack_set_button_state - report button event to the hda_jack_tbl button_state.
  @codec: the HDA codec
  @jack_nid: the button event reports to the jack_tbl of this NID
  @button_state: the button event captured by codec
  Codec driver calls this function to report the button event.
  snd_hda_jack_report_sync - sync the states of all jacks and report if changed
  @codec: the HDA codec
 update all jacks at first 
	 report the updated jacks; it's done after updating all jacks
	  to make sure that all gating jacks properly have been set
 button released 
 guess the jack type from the pin-config 
  snd_hda_jack_add_kctl_mst - Add a kctl for the given pin
  @codec: the HDA codec
  @nid: pin NID to assign
  @dev_id : pin device entry id
  @name: string name for the jack
  @phantom_jack: flag to deal as a phantom jack
  @type: jack type bits to be reported, 0 for guessing from pincfg
  @keymap: optional jack  key mapping
  This assigns a jack-detection kctl to the given pin.  The kcontrol
  will have the given name and index.
 already created 
 Example final name: "Internal Mic Phantom Jack" 
  snd_hda_jack_add_kctls - Add kctls for all pins included in the given pincfg
  @codec: the HDA codec
  @cfg: pin config table to parse
		 If we have headphone mics; make sure they get the right name
 might be duplicated 
 might be duplicated 
  snd_hda_jack_unsol_event - Handle an unsolicited event
  @codec: the HDA codec
  @res: the unsolicited event data
  snd_hda_jack_poll_all - Poll all jacks
  @codec: the HDA codec
  Poll all detectable jacks with dirty flag, update the status, call
  callbacks and call snd_hda_jack_report_sync() if any changes are found.
 SPDX-License-Identifier: GPL-2.0-or-later
  HD audio interface patch for Creative CA0132 chip
  Copyright (c) 2011, Creative Technology Ltd.
  Based on patch_ca0110.c
  Copyright (c) 2008 Takashi Iwai <tiwai@suse.de>
 Enable this to see controls for tuning purpose. 
#define ENABLE_TUNING_CONTROLS
 Strings for Input Source Enum Control 
 Speaker vnid 
 Effects values size
  Default values for the effect slider controls, they are in order of their
  effect NID's. Surround, Crystalizer, Dialog Plus, Smart Volume, and then
  X-bass.
 Amount of effect level sliders for ca0132_alt controls. 
 Latency introduced by DSP blocks in milliseconds. 
effect module ID
effect module request
 0:output; 1:input
 number of default non-onoff params 
effect default values, 1st is onoff. 
 Tuning controls 
effect module ID
effect module request
 0:output; 1:input
effect default values
 Voice FX Presets 
effect module request
preset name
 ca0132 EQ presets, taken from Windows Sound Blaster Z Driver 
effect module request
preset name
  DSP reqs for handling full-range speakersbass redirection. If a speaker is
  set as not being full range, and bass redirection is enabled, all
  frequencies below the crossover frequency are redirected to the LFE
  channel. If the surround configuration has no LFE channel, this can't be
  enabled. X-Bass must be disabled when using these.
 Between 0x16-0x1a are the X-Bass reqs. 
  Definitions for the DSP req's to handle speaker tuning. These all belong to
  module ID 0x96, the output effects module.
	
	  Currently, this value is always set to 0.0f. However, on Windows,
	  when selecting certain headphone profiles on the new Sound Blaster
	  connect software, the QUERY_SPEAKER_EQ_ADDRESS req on mid 0x80 is
	  sent. This gets the speaker EQ address area, which is then used to
	  send over (presumably) an equalizer profile for the specific
	  headphone setup. It is sent using the same method the DSP
	  firmware is uploaded with, which I believe is why the 'ctspeq.bin'
	  file exists in linux firmware tree but goes unused. It would also
	  explain why the QUERY_SPEAKER_EQ_ADDRESS req is defined but unused.
	  Once this profile is sent over, SPEAKER_TUNING_USE_SPEAKER_EQ is
	  set to 1.0f.
	
	  Inversion is used when setting headphone virtualization to line
	  out. Not sure why this is, but it's the only place it's ever used.
 Delay is used when setting surround speaker distance in Windows. 
 Of these two, only mute seems to ever be used. 
 Surround output channel count configuration structures. 
  DSP volume setting structs. Req 1 is left volume, req 2 is right volume,
  and I don't know what the third req is, but it's always zero. I assume it's
  some sort of update or set command to tell the DSP there's new volume info.
 module ID
 scp req ID 
 Values for ca0113_mmio_command_set for selecting output. 
 Speakers. 
 Headphones. 
 Speakers. 
 Headphones. 
 ae5 ca0113 command sequences to set headphone gain levels. 
  Data structures for storing audio router remapping data. These are used to
  remap a currently active streams ports.
 for DspIO node 
 for ChipIO node 
   Control flag IDs
 Connection manager stream setup is bypassedenabled 
 DSP DMA is bypassedenabled 
 8051 'idle' mode is disabledenabled 
 Tracker for the SPDIF-in path is bypassedenabled 
 DigitalOut to Spdif2Out connection is disabledenabled 
 Digital Microphone is disabledenabled 
 ADC_B rate is 48 kHz96 kHz 
 ADC_C rate is 48 kHz96 kHz 
 DAC rate is 48 kHz96 kHz (affects all DACs) 
 DSP rate is 48 kHz96 kHz 
 SRC clock is 98 MHz196 MHz (196 MHz forces rate to 96 KHz) 
 SRC rate is 48 kHz96 kHz (48 kHz disabled when clock is 196 MHz) 
 Decode Loop (DSP->SRC->DSP) is disabledenabled 
 De-emphasis filter on DAC-1 disabledenabled 
 De-emphasis filter on DAC-2 disabledenabled 
 De-emphasis filter on DAC-3 disabledenabled 
 High-pass filter on ADC_B disabledenabled 
 High-pass filter on ADC_C disabledenabled 
 Common mode on Port_A disabledenabled 
 Common mode on Port_D disabledenabled 
 Impedance for ramp generator on Port_A 16 Ohm10K Ohm 
 Impedance for ramp generator on Port_D, 16 Ohm10K Ohm 
 ASI rate is 48kHz96kHz 
 DAC power settings able to control attached ports noyes 
 Clock Stop OK reporting is disabledenabled 
 Number of control flags 
  Control parameter IDs
 0: None, 1: Mic1In
 0: force HDA, 1: allow DSP if HDA Spdif1Out stream is idle 
	 Port A output stage gain setting to use when 16 Ohm output
	 Port D output stage gain setting to use when 16 Ohm output
	
	  This control param name was found in the 8051 memory, and makes
	  sense given the fact the AE-5 uses it and has the ASI flag set.
 Stream Control 
 Select stream with the given ID 
 Source connection point for the selected stream 
 Destination connection point for the selected stream 
 Number of audio channels in the selected stream 
Enable control for the selected stream 
 Connection Point Control 
 Select connection point with the given ID 
 Connection point sample rate 
 Node Control 
 Select HDA node with the given ID 
   Dsp Io Status codes
 Success 
 Busy, unable to accept new command, the host must retry 
 SCP command queue is full 
 SCP response queue is empty 
   Chip Io Status codes
 Success 
 Busy, unable to accept new command, the host must retry 
   CA0132 sample rate
 retrieve parameters from hda format 
  CA0132 specific
 Nodes configurations 
 for desktop ca0132 codecs 
 chip access 
 chip access mutex 
 DSP download related 
 mixer and effects related 
 ca0132_alt control related values 
 AE-5 Control values 
 ZxR Control Values 
	
	  The Recon3D, Sound Blaster Z, Sound Blaster ZxR, and Sound Blaster
	  AE-5 all use PCI region 2 to toggle GPIO and other currently unknown
	  things.
	
	  Whether or not to use the alt functions like alt_select_out,
	  alt_select_in, etc. Only used on desktop codecs for now, because of
	  surround sound support.
	
	  Whether or not to use alt controls:	volume effect sliders, EQ
	  presets, smart volume presets, and new control names with FX prefix.
	  Renames PlayEnhancement and CrystalVoice too.
  CA0132 quirks table
 Builtin Speaker 
 NA 
 NA 
 NA 
 HP 
 Headset?  disabled for now 
 Mic 
 Builtin Mic 
 NA 
 NA 
 Sound Blaster Z pin configs taken from Windows Driver 
 Port G -- Lineout FRONT LR 
 SPDIF Out 1 
 Digital Out 
 SPDIF In 
 Port A -- BackPanel HP 
 Port D -- CenterLFE or FP Hp 
 Port B -- LineMicIn2  Rear LR 
 Port C -- LineIn1 
 What U Hear In
 NA 
 Sound Blaster ZxR pin configs taken from Windows Driver 
 Port G -- Lineout FRONT LR 
 SPDIF Out 1 - Disabled
 Digital Out 
 SPDIF In - Disabled
 Port A -- BackPanel HP 
 Port D -- CenterLFE 
 Port B -- LineMicIn2  Rear LR 
 Port C -- LineIn1 
 What U Hear In
 NA 
 Recon3D pin configs taken from Windows Driver 
 Port G -- Lineout FRONT LR 
 SPDIF Out 1 
 Digital Out 
 SPDIF In 
 Port A -- BackPanel HP 
 Port D -- CenterLFE or FP Hp 
 Port B -- LineMicIn2  Rear LR 
 Port C -- LineIn1 
 What U Hear In
 NA 
 Sound Blaster AE-5 pin configs taken from Windows Driver 
 Port G -- Lineout FRONT LR 
 SPDIF Out 1 
 Digital Out 
 SPDIF In 
 Port A -- Rear LR. 
 Port D -- CenterLFE or FP Hp 
 Port B -- LineMicIn2  Rear Headphone 
 Port C -- LineIn1 
 What U Hear In
 NA 
 Recon3D integrated pin configs taken from Windows Driver 
 Port G -- Lineout FRONT LR 
 SPDIF Out 1 
 Digital Out 
 SPDIF In 
 Port A -- BackPanel HP 
 Port D -- CenterLFE or FP Hp 
 Port B -- LineMicIn2  Rear LR 
 Port C -- LineIn1 
 What U Hear In
 NA 
 Output selection quirk info structures. 
 ParamID 0x0d value. 
 Speakers. 
 Headphones. 
 Speakers. 
 Headphones. 
 Speakers. 
 Headphones. 
 Speakers. 
 Headphones. 
 Speakers. 
 Headphones. 
 Speakers. 
 Headphones. 
  CA0132 codec access
 Chip access helper function 
 send bits of data specified by reg 
  Write chip address through the vendor widget -- NOT protected by the Mutex!
 send low 16 bits of the address 
 send high 16 bits of the address 
  Write data through the vendor widget -- NOT protected by the Mutex!
 send low 16 bits of the data 
 send high 16 bits of the data 
	If no error encountered, automatically increment the address
  Write multiple data through the vendor widget -- NOT protected by the Mutex!
  Read data through the vendor widget -- NOT protected by the Mutex!
 post read 
 read status 
 read data 
	If no error encountered, automatically increment the address
  Write given value to the given address through the chip IO widget.
  protected by the Mutex
 write the address, and if successful proceed to write data 
  Write given value to the given address through the chip IO widget.
  not protected by the Mutex
 write the address, and if successful proceed to write data 
  Write multiple values to the given address through the chip IO widget.
  protected by the Mutex
  Read the given address through the chip IO widget
  protected by the Mutex
 write the address, and if successful proceed to write data 
  Set chip control flags through the chip IO widget.
  Set chip parameters through the chip IO widget.
  Set chip parameters through the chip IO widget. NO MUTEX.
  Connect stream to a source point, and then connect
  that source point to a destination point.
  Set number of channels in the selected stream.
  EnableDisable audio stream.
  Get ChipIO audio stream's status.
  Set sampling rate of the connection point. NO MUTEX.
  Set sampling rate of the connection point.
  Writes to the 8051's internal address space directly instead of indirectly,
  giving access to the special function registers located at addresses
  0x80-0xFF.
  Writes to the 8051's exram, which has 16-bits of address space.
  Data at addresses 0x2000-0x7fff is mirrored to 0x8000-0xdfff.
  Data at 0x8000-0xdfff can also be used as program memory for the 8051 by
  setting the pmem bank selection SFR.
  0xe000-0xffff is always mapped as program memory, with only 0xf000-0xffff
  being writable.
 Lower 8-bits. 
 Upper 8-bits. 
 8-bits of data. 
 PLL_PMU writes share the lower address register of the 8051 exram writes. 
 8-bits of data. 
 Readback data from the 8051's exram. No mutex. 
  Enable clocks.
  CA0132 DSP IO stuffs
 send bits of data specified by reg to dsp 
  Wait for DSP to be ready for commands
  Write SCP data to DSP
 OK, now check if the write itself has executed
  Write multiple SCP data to DSP
  Construct the SCP header using corresponding fields
  Extract corresponding fields from SCP header
 Structure to contain any SCP message 
 clear all from the response queue 
  Send SCP message to DSP
 get scp header from buffer 
 swap source id with target id 
  dspio_scp - Prepare and send the SCP message to DSP
  @codec: the HDA codec
  @mod_id: ID of the DSP module to send the command
  @src_id: ID of the source
  @req: ID of request to send to the DSP module
  @dir: SET or GET
  @data: pointer to the data to send with the request, request specific
  @len: length of the data, in bytes
  @reply: point to the buffer to hold data returned for a reply
  @reply_len: length of the reply buffer returned from GET
  Returns zero or a negative error code.
 extract send and reply headers members 
  Set DSP parameters
  Allocate a DSP DMA channel via an SCP message
  Free a DSP DMA via an SCP message
  (Re)start the DSP
  Reset the DSP
  Convert chip address to DSP address
  Check if the DSP DMA is active
  Setup the DSP DMA per-transfer-specific registers
  Start the DSP DMA
  Stop the DSP DMA
  dsp_allocate_router_ports - Allocate router ports
  @codec: the HDA codec
  @num_chans: number of channels in the stream
  @ports_per_channel: number of ports per channel
  @start_device: start device
  @port_map: pointer to the port list to hold the allocated ports
  Returns zero or a negative error code.
  Free router ports
  Allocate DSP ports for the download stream
  free DSP ports
   HDA DMA engine stuffs for DSP code download
   Reset DMA for DSP download
  CA0132 chip DSP transfer stuffs.  For DSP download.
  Program a list of addressdata pairs via the ChipIO widget.
  The segment data is in the format of successive pairs of words.
  These are repeated as indicated by the segment's count field.
  dspxfr_one_seg - Write a block of data into DSP code or data RAM using pre-allocated DMA engine.
  @codec: the HDA codec
  @fls: pointer to a fast load image
  @reloc: Relocation address for loading single-segment overlays, or 0 for
 	   no relocation
  @dma_engine: pointer to DMA engine to be used for DSP download
  @dma_chan: The number of DMA channels used for DSP download
  @port_map_mask: port mapping
  @ovly: TRUE if overlay format is required
  Returns zero or a negative error code.
  dspxfr_image - Write the entire DSP image of a DSP codedata overlay to DSP memories
  @codec: the HDA codec
  @fls_data: pointer to a fast load image
  @reloc: Relocation address for loading single-segment overlays, or 0 for
 	   no relocation
  @sample_rate: sampling rate of the stream used for DSP download
  @channels: channels of the stream used for DSP download
  @ovly: TRUE if overlay format is required
  Returns zero or a negative error code.
  CA0132 DSP download stuffs.
set DSP speaker to 2.0 configuration
update write pointer
  dspload_image - Download DSP from a DSP Image Fast Load structure.
  @codec: the HDA codec
  @fls: pointer to a fast load image
  @ovly: TRUE if overlay format is required
  @reloc: Relocation address for loading single-segment overlays, or 0 for
 	   no relocation
  @autostart: TRUE if DSP starts after loading; ignored if ovly is TRUE
  @router_chans: number of audio router channels to be allocated (0 means use
 		  internal defaults; max is 32)
  Download DSP from a DSP Image Fast Load structure. This structure is a
  linear, non-constant sized element array of structures, each of which
  contain the count of the data to be loaded, the data itself, and the
  corresponding starting chip address of the starting data location.
  Returns zero or a negative error code.
  ca0113 related functions. The ca0113 acts as the HDA bus for the pci-e
  based cards, and has a second mmio region, region2, that's used for special
  commands.
  For cards with PCI-E region2 (Sound Blaster ZZxR, Recon3D, and AE-5)
  the mmio address 0x320 is used to set GPIO pins. The format for the data
  The first eight bits are just the number of the pin. So far, I've only seen
  this number go to 7.
  AE-5 note: The AE-5 seems to use pins 2 and 3 to somehow set the color value
  of the on-card LED. It seems to use pin 2 for data, then toggles 3 to on and
  then off to send that bit.
  Special pci region2 commands that are only used by the AE-5. They follow
  a set format, and require reads at certain points to seemingly 'clear'
  the response data. My first tests didn't do these reads, and would cause
  the card to get locked up until the memory was read. These commands
  seem to work with three distinct values that I've taken to calling group,
  target-id, and value.
	
	  Need delay here or else it goes too fast and works inconsistently.
  This second type of command is used for setting the sound filter type.
  Setup GPIO for the other variants of Core3D.
  Sets up the GPIO pins so that they are discoverable. If this isn't done,
  the card shows as having no GPIO pins.
 Sets the GPIO for audio output. 
  GPIO control functions for the Recon3D integrated.
 Bit 1 - Switch between frontrear mic. 0 = rear, 1 = front 
 Bit 2 - Switch between headphoneline out. 0 = Headphone, 1 = Line 
	
	  I dunno what this actually does, but it stays on until the dsp
	  is downloaded.
	
	  Same as above, no clue what it does, but it comes on after the dsp
	  is downloaded.
 Set GPIO bit 1 to 0 for rear mic 
 Set GPIO bit 1 to 1 for front microphone
 Set GPIO bit 2 to 0 for headphone 
 Set GPIO bit 2 to 1 for speaker 
 Set GPIO bit 3 to 1 until DSP is downloaded 
 Set GPIO bit 4 to 1 once DSP is downloaded 
 Get the current GPIO Data setup 
 Get the current GPIO Data setup 
 Set DOWNLOADING bit to 0. 
  PCM callbacks
	If Playback effects are on, allow stream some time to flush
 Add latency if playback enhancement and either effect is enabled. 
 Applying Speaker EQ adds latency as well. 
  Digital out
  Analog capture
  Controls stuffs.
  Mixer controls helpers.
  Creates a mixer control that uses defaults of HDA_CODEC_VOL except for the
  volume put, which is used for setting the DSP volume. This was done because
  the ca0132 functions were taking too much time and causing lag.
 stereo 
 lookup tables 
  Lookup table with decibel values for the DSP. When volume is changed in
  Windows, the DSP is also sent the dB value in floating point. In Windows,
  these values have decimal points, probably because the Windows driver
  actually uses floating point. We can't here, so I made a lookup table of
  values -90 to 9. -90 is the lowest decibel value for both the ADC's and the
  DAC's, and 9 is the maximum.
  This table counts from float 0 to 1 in increments of .01, which is
  useful for a few different sliders.
  This table counts from float 10 to 1000, which is the range of the x-bass
  crossover slider in Windows.
 The following are for tuning of products 
 any change? 
 any change? 
 any change? 
 Wedge Angle defaults to 30.  10 below is 30 - 20.  20 is min. 
 SVM level defaults to 0.74. 
 EQ defaults to 0dB. 
ENABLE_TUNING_CONTROLS
  Select the active output.
  If autodetect is enabled, output will be selected based on jack detection.
  If jack inserted, headphone will be selected, else built-in speakers
  If autodetect is disabled, output will be selected based on selection.
speaker out config
enable speaker EQ
 Setup EAPD 
 disable headphone node 
 enable speaker node 
headphone out config
disable speaker EQ
 Setup EAPD 
 disable speaker
 enable headphone
 2.04.0 setup has no LFE channel, so setting full-range does nothing. 
 Set front LR full range. Zero for full-range, one for redirection. 
 When setting full-range rear, both rear and centerlfe are set. 
	
	  Only the AE series cards set this value when setting full-range,
	  and it's always 1.0f.
 If it is enabled, make sure to set the crossover frequency. 
  These are the commands needed to setup output on each of the different card
  types.
  This function behaves similarly to the ca0132_select_out funciton above,
  except with a few differences. It adds the ability to select the current
  output with an enumerated control "output source" if the auto detect
  mute switch is set to off. If the auto detect mute switch is enabled, it
  will detect either headphone or lineout(SPEAKER_OUT) from jack detection.
  It also adds the ability to auto-detect the front headphone port.
 Default Headphone is rear headphone 
	
	  If headphone rear or front is plugged in, set to headphone.
	  If neither is plugged in, set to rear line out. Only if
	  hpspeaker auto detect is enabled.
 Begin DSP output switch, mute DSP volume. 
 Enable EAPD 
 Disable headphone node. 
 Set front L-R to output. 
 Set CenterLFE to output. 
 Set rear surround to output. 
		
		  Without PlayEnhancement being enabled, if we've got a 2.0
		  setup, set it to floating point eight to disable any DSP
		  processing effects.
 Disable all speaker nodes. 
 enable headphone, either front or rear 
	
	  If output effects are enabled, set the X-Bass effect value again to
	  make sure that it's properly enableddisabled for speaker
	  configurations with an LFE channel.
 Set speaker EQ bypass attenuation to 0. 
	
	  Although unused on all cards but the AE series, this is always set
	  to zero when setting the output.
 Unmute DSP now that we're done with output selection. 
  Select the active VIP source
 if CrystalVoice if off, vipsource should be 0 
 if CrystalVoice is off, vipsource should be 0 
  Select the active microphone.
  If autodetect is enabled, mic will be selected based on jack detection.
  If jack inserted, ext.mic will be selected, else built-in mic
  If autodetect is disabled, mic will be selected based on selection.
 enable digital Mic 
 set voice focus 
 disable digital Mic 
 disable voice focus 
  Select the active input.
  Mic detection isn't used, because it's kind of pointless on the SBZ.
  The front mic has no jack-detection, so the only way to switch to it
  is to do it manually in alsamixer.
  Check if VNODE settings take effect immediately.
 The following functions are control change helpers.
 They return 0 if no changed.  Return 1 if changed.
 based on CrystalVoice state to enable VoiceFX. 
  Set the effects parameters
 no changed 
 for out effect, qualify with PE 
 if PE if off, turn off out effects. 
 for in effect, qualify with CrystalVoice 
 if CrystalVoice if off, turn off in effects. 
 Voice Focus applies to 2-ch Mic, Digital Mic 
 If Voice Focus on SBZ, set to two channel. 
		
		  For SBZ noise reduction, there's an extra command
		  to module ID 0x47. No clue why.
 If rear line in disable effects. 
 no changed 
  Turn onoff Playback Enhancements
 PE affects all out effects 
 Check if Mic1 is streaming, if so, stop streaming 
 Resume Mic1 streaming if it was stopped. 
 Restore the previous stream and channel 
  Turn onoff CrystalVoice
 CrystalVoice affects all in effects 
 including VoiceFX 
 set correct vipsource 
 on 
 off 
  gpio pin 1 is a relay that switches onoff, apparently setting the headphone
  amplifier to handle a 600 ohm load.
 if effective conditions, then update hw immediately. 
 End of control change helpers. 
  Below I've added controls to mess with the effect levels, I've only enabled
  them on the Sound Blaster Z, but they would probably also work on the
  Chromebook. I figured they were probably tuned specifically for it, and left
  out for a reason.
 Sets DSP effect level from the sliders above the controls 
	
	  For X_BASS, req 2 is actually crossover freq instead of
	  effect level
 Find the actual effect structure 
  The X-bass crossover starts at 10hz, so the min is 1. The
  frequency is set in multiples of 10.
 any change? 
 any change? 
  Mic Boost Enum for alternative ca0132 codecs. I didn't like that the original
  only has off or full 30 dB, and didn't like making a volume slider that has
  traditional 0-100 in alsamixer that goes in big steps. I like enum better.
  Sound BlasterX AE-5 Headphone Gain Controls.
  Sound BlasterX AE-5 sound filter enumerated control.
  Input Select Control for alternative ca0132 codecs. This exists because
  front microphone has no auto-detect, and we need a way to set the rear
  as line-in
	
	  The AE-7 has no front microphone, so limit items to 2: rear mic and
	  line-in.
 Sound Blaster Z Output Select Control 
 Select surround output type: 2.1, 4.0, 4.1, or 5.1. 
  Smart Volume output setting control. Three different settings, Normal,
  which takes the value from the smart volume slider. The two others, loud
  and night, disregard the slider value and have uneditable values.
 Req 2 is the Smart Volume Setting req. 
 Sound Blaster Z EQ preset controls 
	
	  Idx 0 is default.
	  Default needs to qualify with CrystalVoice state.
	
	  Idx 0 is default.
	  Default needs to qualify with CrystalVoice state.
 enable voice fx 
 vnode 
 effects, include PE and CrystalVoice 
 mic boost 
 vnode 
 PE 
 CrystalVoice 
 out and in effects 
 mic boost 
 Mic boost does not apply to Digital Mic 
  Volume related
  Sets the internal DSP decibel level to match the DAC for output, and the
  ADC for input. Currently only the SBZ sets dsp capture volume level, and
  all alternative codecs set DSP playback volume.
 follow shared_out info 
 follow shared_mic info 
 store the left and right volume 
 store the left and right volume 
 if effective conditions, then update hw immediately. 
  This function is the same as the one above, because using an if statement
  inside of the above volume control for the DSP volume would cause too much
  lag. This is a lot more smooth.
 store the left and right volume 
 follow shared_out tlv 
 follow shared_mic tlv 
 Add volume slider control for effect level 
  Added FX: prefix for the alternative codecs, because otherwise the surround
  effect would conflict with the Surround sound volume control. Also seems more
  clear as to what the switches do. Left alone for others.
	 If using alt_controls, add FX: prefix. But, don't add FX:
	  prefix to OutFX or InFX enable controls.
 Create the EQ Preset control 
  Add enumerated control for the three different settings of the smart volume
  output effect. Normal just uses the slider value, and loud and night are
  their own things that ignore that value.
  Create an Output Select enumerated control for codecs with surround
  out capabilities.
  Add a control for selecting channel count on speaker output. Setting this
  allows the DSP to do bass redirection and channel upmixing on surround
  configurations.
  Full range front stereo and rear surround switches. When these are set to
  full range, the lower frequencies from these channels are no longer
  redirected to the LFE channel.
  Bass redirection redirects audio below the crossover frequency to the LFE
  channel on speakers that are set as not being full-range. On configurations
  without an LFE channel, it does nothing. Bass redirection seems to be the
  replacement for X-Bass on configurations with an LFE channel.
  Create an Input Source enumerated control for the alternate ca0132 codecs
  because the front microphone has no auto-detect, and Line-in has to be set
  somehow.
  Add mic boost enumerated control. Switches through 0dB to 30dB. This adds
  more control than the original mic boost, which is either full 30dB or off.
  Add headphone gain enumerated control for the AE-5. This switches between
  three modes, low, medium, and high. When non-headphone outputs are selected,
  it is automatically set to high. This is the same behavior as Windows.
  Add sound filter enumerated control for the AE-5. This adds three different
  settings: Slow Roll Off, Minimum Phase, and Fast Roll Off. From what I've
  read into it, it changes the DAC's interpolation filter.
  Need to create follower controls for the alternate codecs that have surround
  capabilities.
  Also need special channel map, because the default one is incorrect.
  I think this has to do with the pin for rear surround being 0x11,
  and the centerlfe being 0x10. Usually the pin order is the opposite.
 Add the correct chmap for streams with 6 channels. 
  When changing Node IDs for Mixer Controls below, make sure to update
  Node IDs in ca0132_config() as well.
 end 
  Desktop specific control mixer. Removes auto-detect for mic, and adds
  surround controls. Also sets both the Front Playback and Capture Volume
  controls to alt so they set the DSP's decibel level.
 end 
  Same as the Sound Blaster Z, except doesn't use the alt volume for capture
  because it doesn't set decibel levels for the DSP for capture.
 end 
 Add Mixer controls 
 Setup vmaster with surround followers for desktop ca0132 devices 
	 Add in and out effects controls.
	  VoiceFX, PE and CrystalVoice are added separately.
 Desktop cards break if Echo Cancellation is used. 
	
	  If codec has use_alt_controls set to true, add effect level sliders,
	  EQ presets, and Smart Volume presets. Also, change names to add FX
	  prefix, and change PlayEnhancement and CrystalVoice to match.
	
	  If the codec uses alt_functions, you need the enumerated controls
	  to select the new outputs and inputs, plus add the new mic boost
	  setting control.
		
		  ZxR only has microphone input, there is no front panel
		  header on the card, and aux-in is handled by the DBPro board.
 spec->multiout.share_spdif = 1; 
  PCM
 With the DSP enabled, desktops don't use this ADC. 
 init to 0 dB and unmute. 
  Switch between Digital built-in mic and analog mic.
 set DMic input as 2-ch 
 set AMic input as mono 
 clear bit7 and bit5 to disable dmic 
  Initialization for Digital Mic.
	 Setup Digital Mic here, but don't enable.
	  Enable based on jack detect.
	 MCLK uses MPIO1, set to enable.
	  Bit 2-0: MPIO select
	  Bit   3: set to disable
	  Bit 7-4: reserved
	 Data1 uses MPIO3. Data2 not use
	  Bit 2-0: Data1 MPIO select
	  Bit   3: set disable Data1
	  Bit 6-4: Data2 MPIO select
	  Bit   7: set disable Data2
	 Use Ch-0 and Ch-1. Rate is 48K, mode 1. Disable DMic first.
	  Bit 3-0: Channel mask
	  Bit   4: set for 48KHz, clear for 32KHz
	  Bit   5: mode
	  Bit   6: set to select Data2, clear for Data1
	  Bit   7: set to enable DMic, clear for AMic
 keep a copy of dmic ctl val for enabledisable dmic purpuse 
  Initialization for Analog Mic 2
 If there is an active channel for some reason, find it and free it. 
 Read active DSPDMAC channel register. 
 AND against 0xfff to get the active channel bits. 
 If there are no active channels, nothing to free. 
	
	  Check each DSP DMA channel for activity, and if the channel is
	  active, free it.
  In the case of CT_EXTENSIONS_ENABLE being set to 1, and the DSP being in
  use, audio is no longer routed directly to the DACADC from the HDA stream.
  Instead, audio is now routed through the DSP's DMA controllers, which
  the DSP is tasked with setting up itself. Through debugging, it seems the
  cause of most of the no-audio on startup issues were due to improperly
  configured DSP DMA channels.
  Normally, the DSP configures these the first time an HDA audio stream is
  started post DSP firmware download. That is why creating a 'dummy' stream
  worked in fixing the audio in some cases. This works most of the time, but
  sometimes if a stream is startedstopped before the DSP can setup the DMA
  configuration registers, it ends up in a broken state. Issues can also
  arise if streams are started in an unusual order, i.e the audio output dma
  channel being sandwiched between the mic1 and mic2 dma channels.
  The solution to this is to make sure that the DSP has no DMA channels
  in use post DSP firmware download, and then to manually start each default
  DSP stream that uses the DMA channels. These are 0x0c, the audio output
  stream, 0x03, analog mic 1, and 0x04, analog mic 2.
	
	  Check if any of the default streams are active, and if they are,
	  stop them.
	
	  If all DSP streams are inactive, there should be no active DSP DMA
	  channels. Check and make sure this is the case, and if it isn't,
	  free any active channels.
 Make sure stream 0x0c is six channels. 
 Give the DSP some time to setup the DMA channel. 
  The region of ChipIO memory from 0x190000-0x1903fc is a sort of 'audio
  router', where each entry represents a 48khz audio channel, with a format
  of an 8-bit destination, an 8-bit source, and an unknown 2-bit number
  value. The 2-bit number value is seemingly 0 if inactive, 1 if active,
  and 3 if it's using Sample Rate Converter ports.
  An example is:
  0x0001f8c0
  In this case, f8 is the destination, and c0 is the source. The number value
  is 1.
  This region of memory is normally managed internally by the 8051, where
  the region of exram memory from 0x1477-0x1575 has each byte represent an
  entry within the 0x190000 range, and when a range of entries is in use, the
  ending value is overwritten with 0xff.
  0x1578 in exram is a table of 0x25 entries, corresponding to the ChipIO
  streamID's, where each entry is a starting 0x190000 port offset.
  0x159d in exram is the same as 0x1578, except it contains the ending port
  offset for the corresponding streamID.
  On certain cards, such as the SBZZxRAE7, these are originally setup by
  the 8051, then manually overwritten to remap the ports to work with the
  new DACs.
  Currently known portID's:
  0x00-0x1f: HDA audio stream inputoutput ports.
  0x80-0xbf: Sample rate converter inputoutputs. Only valid ports seem to
             have the lower-nibble set to 0x1, 0x2, and 0x9.
  0xc0-0xdf: DSP DMA inputoutput ports. Dynamically assigned.
  0xe0-0xff: DACADC audio inputoutput ports.
  Currently known streamID's:
  0x03: Mic1 ADC to DSP.
  0x04: Mic2 ADC to DSP.
  0x05: HDA node 0x02 audio stream to DSP.
  0x0f: DSP Mic exit to HDA node 0x07.
  0x0c: DSP processed audio to DACs.
  0x14: DAC0, front LR.
  It is possible to route the HDA audio streams directly to the DAC and
  bypass the DSP entirely, with the only downside being that since the DSP
  does volume control, the only volume control you'll get is through PCM on
  the PC side, in the same way volume is handled for optical out. This may be
  useful for debugging.
 Get the starting port for the stream to be remapped. 
	
	  Check if the stream's port value is 0xff, because the 8051 may not
	  have gotten around to setting up the stream yet. Wait until it's
	  setup to remap it's ports.
 Offset isn't in bytes, its in 32-bit words, so multiply it by 4. 
 Update stream map configuration. 
  Default speaker tuning values setup for alternative codecs.
 Non-zero values are floating point 0.000198. 
 Non-zero values are floating point 0.000220. 
 Non-zero values are floating point 0.000100. 
  If we never change these, probably only need them on initialization.
  Initialize mic for non-chromebook ca0132 implementations.
 Mic 1 Setup 
 Mic 2 setup (not present on desktop cards) 
  Sets the source of stream 0x14 to connpointID 0x48, and the destination
  connpointID to 0x91. If this isn't done, the destination is 0x71, and
  you get no sound. I'm guessing this has to do with the Sound Blaster Z
  having an updated DAC, which changes the destination to that DAC.
 This value is 0x43 for 96khz, and 0x83 for 192khz. 
 Setup stream 0x14 with it's source and destination points 
  Write data through ChipIO to setup proper stream destinations.
  Not sure how it exactly works, but it seems to direct data
  to different destinations. Example is f8 to c0, e0 to c0.
  All I know is, if you don't set these, you get no sound.
 Remap DAC0's output ports. 
 Remap DSP audio output stream ports. 
	
	  Param3 in the 8051's memory is represented by the ascii string 'mch'
	  which seems to be 'multichannel'. This is also mentioned in the
	  AE-5's registry values in Windows.
	
	  I believe ASI is 'audio serial interface' and that it's used to
	  change colors on the external LED strip connected to the AE-5.
 Seems to share the same port remapping as the SBZ. 
	
	  In the 8051's memory, this param is referred to as 'n2sid', which I
	  believe is 'node to streamID'. It seems to be a way to assign a
	  stream to a given HDA node.
	
	  Now, at this point on Windows, an actual stream is setup and
	  seemingly sends data to the HDA node 0x09, which is the digital
	  audio input node. This is left out here, because obviously I don't
	  know what data is being sent. Interestingly, the AE-5 seems to go
	  through the motions of getting here and never actually takes this
	  step, but the AE-7 does.
	
	  Runs again, this has been repeated a few times, but I'm just
	  following what the Windows driver does.
  The Windows driver has commands that seem to setup ASI, which I believe to
  be some sort of audio serial interface. My current speculation is that it's
  related to communicating with the new DAC.
  Setup default parameters for DSP
 out, in effects + voicefx 
remove DSP headroom
set speaker EQ bypass attenuation
 set AMic1 and AMic2 as mono mic 
 set AMic1 as CrystalVoice input 
 set WUH source 
  Setup default parameters for Recon3DRecon3Di DSP.
remove DSP headroom
 set WUH source 
 Set speaker source? 
 Disable mute on CenterLFE. 
 Setup effect defaults 
  Setup default parameters for the Sound Blaster Z DSP. A lot more going on
  than the Chromebook setup.
	
	  Sets internal input loopback to off, used to have a switch to
	  enable input loopback, but turned out to be way too buggy.
remove DSP headroom
 set WUH source 
 Set speaker source? 
 out, in effects + voicefx 
  Setup default parameters for the Sound BlasterX AE-5 DSP.
 New, unknown SCP req's 
 Internal loopback off 
remove DSP headroom
 set WUH source 
 Set speaker source? 
 out, in effects + voicefx 
  Setup default parameters for the Sound Blaster AE-7 DSP.
 New, unknown SCP req's 
 Internal loopback off 
remove DSP headroom
 set WUH source 
 Set speaker source? 
	
	  This is the second time we've called this, but this is seemingly
	  what Windows does.
	
	  Not sure why, but these are both set to 1. They're only set to 0
	  upon shutdown.
 Volume control related. 
 out, in effects + voicefx 
  Initialization of flags in chip
  Initialization of parameters in chip
	
	  Alternate firmwares for different variants. The Recon3Di apparently
	  can use the default firmware, but I'll leave the option in case
	  it needs it again.
	
	  Use default ctefx.bin if no alt firmware is detected, or if none
	  exists for your particular codec.
 NOP 
 don't retry failures 
 For codecs using alt functions, this is already done earlier 
	 Delay enabling the HP amp, to let the mic-detection
	  state machine run.
 Front headphone jack detection 
  Verbs tables.
 Sends before DSP download. 
enable ct extension
 Send at exit. 
set afg to D3
disable ct extension
 Other verbs tables. Sends after DSP download. 
 chip init verbs 
 Extra init verbs for desktop cards. 
	
	  The Windows driver always does this upon startup, which seems to
	  clear out any previous configuration. This should help issues where
	  a boot into Windows prior to a boot into Linux breaks things. Also,
	  Windows always sends the reset twice.
	
	  Default states for effects are in ca0132_effects[].
	
	  Sets defaults for the effect slider controls, only for alternative
	  ca0132 codecs. Also sets x-bass crossover frequency to 80hz.
 Set speakers to default to full range. 
	
	  The ZxR doesn't have a front panel header, and it's line-in is on
	  the daughter board. So, there is no input enum control, and we need
	  to make sure that spec->in_enum_val is set properly.
  Recon3Di exit specific commands.
 prevents popping noise on shutdown 
  Sound Blaster Z exit specific commands.
 On shutdown, sends commands in sets of three 
 Mess with GPIO 
 put any chip cleanup stuffs here. 
  This fixes a problem that was hard to reproduce. Very rarely, I would
  boot up, and there would be no sound, but the DSP indicated it had loaded
  properly. I did a few memory dumps to see if anything was different, and
  there were a few areas of memory uninitialized with a1a2a3a4. This function
  checks if those areas are uninitialized, and if they are, it'll attempt to
  reload the card 3 times. Usually it fixes by the second.
	
	  While the failure condition is true, and we haven't reached our
	  three reload limit, continue trying to reload the driver and
	  fix the issue.
  This is for the extra volume verbs 0x797 (left) and 0x798 (right). These add
  extra precision for decibel values. If you had the dB value in floating point
  you would take the value after the decimal point, multiply by 64, and divide
  by 2. So for 8.59, it's (59  64)  100. Useful if someone wanted to
  implement fixed point or floating point dB volumes. For now, I'll set them
  to 0 just incase a value has lingered from a boot into Windows.
  Extra commands that don't really fit anywhere else.
  The ZxR seems to use alternative DAC's for the surround channels, which
  require PLL PMU setup for the clock rate, I'm guessing. Without setting
  this up, we get no audio out of the surround jacks.
	
	  This writes a RET instruction at the entry point of the function at
	  0xfa92 in exram. This function seems to have something to do with
	  ASI. Might be some way to prevent the card from reconfiguring the
	  ASI stuff itself.
  These are sent before the DSP is downloaded. Not sure
  what they do, or if they're necessary. Could possibly
  be removed. Figure they're better to leave in.
		
		  AE-7 shares all writes with the AE-5, except that it writes
		  a different value to 0x20c.
  This function writes to some SFR's, does some region2 writes, and then
  eventually resets the codec with the 0x7ff verb. Not quite sure why it does
  what it does.
	
	  First writes are in single bytes, final are in 4 bytes. So, we use
	  writeb, then writel.
  Extra init functions for alternative ca0132 codecs. Done
  here so they don't clutter up the main ca0132_init function
  anymore than they have to.
	
	  If the DSP is already downloaded, and init has been entered again,
	  there's only two reasons for it. One, the codec has awaken from a
	  suspended state, and in that case dspload_is_loaded will return
	  false, and the init will be ran again. The other reason it gets
	  re entered is on startup for some reason it triggers a suspend and
	  resume state. In this case, it will check if the DSP is downloaded,
	  and not run the init function again. For codecs using alt_functions,
	  it will check if the DSP is loaded properly.
	
	  Re set the PlayEnhancement switch on a resume event, because the
	  controls will not be reloaded.
 speaker out 
 digital mic  analog mic1 
 analog mic2 
 what u hear 
 Line out 
 Rear headphone out 
 Front Headphone  CenterLFE
 Rear surround 
 Rear Mic  Line-in 
 Front Mic, but only if no DSP 
 what u hear 
 Rear Mic  Line-in 
 What U Hear 
 SPDIF IO 
 Line out 
 Rear headphone out 
 CenterLFE 
 Rear surround 
 Rear Mic  Line-in 
 Not connected, no front mic 
 what u hear 
 Rear Mic  Line-in 
 What U Hear 
 ZxR DBPro Aux In 
 RCA Line-in 
 Line out 
 Rear headphone out 
 Front Headphone  CenterLFE
 Rear surround 
 Rear Mic  Line-in 
 Front Mic, but only if no DSP 
 what u hear 
 Rear Mic  Line-in 
 What U Hear 
 SPDIF IO 
 Line out 
 Rear headphone out 
 Front Headphone  CenterLFE
 Rear surround 
 Rear Mic  Line-in 
 Front Mic, but only if no DSP 
 what u hear 
 Rear Mic  Line-in 
 What U Hear 
 SPDIF IO 
 speaker out 
 headphone out 
 digital mic  analog mic1 
 analog mic2 
 what u hear 
 SPDIF IO 
 Verbs + terminator (an empty element) 
	
	  Since desktop cards use pci_mmio, this can be used to determine
	  whether or not to use these verbs instead of a separate bool.
 config EAPD 
 Previously commented configuration 
	
	spec->spec_init_verbs[2].nid = 0x0b;
	spec->spec_init_verbs[2].param = AC_VERB_SET_EAPD_BTLENABLE;
	spec->spec_init_verbs[2].verb = 0x02;
	spec->spec_init_verbs[3].nid = 0x10;
	spec->spec_init_verbs[3].param = 0x78D;
	spec->spec_init_verbs[3].verb = 0x02;
	spec->spec_init_verbs[4].nid = 0x10;
	spec->spec_init_verbs[4].param = AC_VERB_SET_EAPD_BTLENABLE;
	spec->spec_init_verbs[4].verb = 0x02;
 Terminator: spec->spec_init_verbs[NUM_SPEC_VERBS-1] 
  The Sound Blaster ZxR shares the same PCI subsystem ID as some regular
  Sound Blaster Z cards. However, they have different HDA codec subsystem
  ID's. So, we check for the ZxR's subsystem ID, as well as the DBPro
  daughter boards ID.
 Detect codec quirk 
 Set which mixers each quirk uses. 
 Setup whether or not to use alt functionscontrolspci_mmio 
  patch entries
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
  Universal Interface for Intel High Definition Audio Codec
  HD audio interface patch for C-Media CMI9880
  Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>
  stuff for auto-parser
	 mask NID 0x10 from the playback volume selection;
	  it's a headphone boost volume handled manually below
  patch entries
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
   patch_hdmi.c - routines for HDMIDisplayPort codecs
   Copyright(c) 2008-2010 Intel Corporation. All rights reserved.
   Copyright (c) 2006 ATI Technologies Inc.
   Copyright (c) 2008 NVIDIA Corp.  All rights reserved.
   Copyright (c) 2008 Wei Ni <wni@nvidia.com>
   Copyright (c) 2013 Anssi Hannula <anssi.hannula@iki.fi>
   Authors:
 			Wu Fengguang <wfg@linux.intel.com>
   Maintained by:
 			Wu Fengguang <wfg@linux.intel.com>
 max. connections to a widget 
 pin idx, different device entries on the same pin use the same idx 
 pointer to spec->pcm_rec[n] dynamically
 which pcm is attached. -1 means no pcm is attached 
 the stream has been set up by prepare callback 
 current number of channels 
 channel-map override by ALSA API? 
 ALSA API channel-map 
 operations used by generic code that can be overridden by patches 
 enabledisable HBR (HD passthrough) 
 struct hdmi_spec_per_cvt 
 only for haswell fix 
	
	  num_pins is the number of virtual pins
	  for example, there are 3 pins, and each pin
	  has 4 device entries, then the num_pins is 12
	
	  num_nids is the number of real pins
	  In the above example, num_nids is 3
	
	  dev_num is the number of device entries
	  on each pin.
	  In the above example, dev_num is 4
 struct hdmi_spec_per_pin 
 for audio component binding 
 pcm_bitmap means which pcms have been assigned to pins
 counter of pcm_rec[] 
	 bitmap shows whether the pcm is opened in user space
	  bit 0 means the first playback PCM (PCM3);
	  bit 1 means the second playback PCM, and so on.
 apply Intel platform-specific fixups 
	
	  Non-generic VIANVIDIA specific
 use eld_notify callback for hotplug 
 audio component registered in this driver 
 force connectivity 
 reverse portpin mapping 
 Flag to enable silent stream feature 
 0x84 
 0x01 
 0x0a 
 CC in bits 0:2, CT in 4:7 
 0x84 
 0x1b 
 0x11 << 2 
 match with HDMI infoframe from this on 
  HDMI routines
 obtain hdmi_pcm object assigned to idx 
 obtain hda_pcm object assigned to idx 
	
	  (dev_id == -1) means it is NON-MST pin
	  return the first virtual pin on this port
 no pin is bound to the pcm 
 no pin is bound to the pcm 
	 no pin nid is associated with the kctl now
	  tbd: associate pin nid to eld ctl later
 Unmute 
 Disable pin out until stream is active 
		 Enable pin out: some machines with GM965 gets broken output
		  when the pin is disabled or changed while using with HDMI
  ELD proc files
  Audio InfoFrame routines
  Enable Audio InfoFrame Transmission
  Disable Audio InfoFrame Transmission
 byte index wrapped around 
 be paranoid 
 HDMI 
 DisplayPort 
	
	  sizeof(ai) is used instead of sizeof(hdmi_ai) or
	  sizeof(dp_ai) to avoid partial matchupdate problems when
	  the user switches between HDMIDP monitors.
 some HW (e.g. HSW+) needs reprogramming the amp at each time 
	
	  always configure channel mapping, it may have been changed by the
	  user in the meantime
  Unsolicited events
 stop polling when notification is enabled 
 TODO 
	 For Haswell, the converter 12 may keep in D3 state after bootup,
	  thus pins could only choose converter 0 for use. Make sure the
  Callbacks
 HBR should be Non-PCM, 8 channels 
		
		  on recent platforms IEC Coding Type is required for HBR
		  support, read current Digital Converter settings and set
		  ICT bitfield if needed.
 on recent platforms ICT mode is required for HBR support 
 Try to find an available converter
  If pin_idx is less then zero, just try to find an available converter.
  Otherwise, try to find an available converter and get the cvt mux index
  of the pin.
 pin_idx < 0 means no pin will be bound to the converter 
 Dynamically assign converter to stream 
 Must not already be assigned 
 Must be in pin's mux's list of converters 
 Not in mux list 
 No free converters 
 Assure the pin select the right convetor 
 get the mux index for the converter of the pins
  converter's mux index is the same for all pins on Intel platform
 Intel HDMI workaround to fix audio routing issue:
  For some Intel display codecs, pins share the same connection list.
  So a conveter can be selected by multiple pins and playback on any of these
  pins will generate sound on the external display, because audio flows from
  the same converter to the display pipeline. Also muting one pin may make
  other pins have no sound output.
  So this function assures that an assigned converter for a pin is not selected
  by any other pins.
 configure the pins connections 
		
		  pin not connected to monitor
		  no need to operate on it
		
		  if per_pin->dev_id >= dev_num,
		  snd_hda_get_dev_select() will fail,
		  and the following operation is unpredictable.
		  So skip this situation.
		
		  Calling this function should not impact
		  on the device entry selection
		  So let's save the dev id for each pin,
		  and restore it when return
		 choose an unassigned converter. The conveters in the
		  connection list are in the same order as in the codec.
 A wrapper of intel_not_share_asigned_cvt() 
	 On Intel platform, the mapping of converter nid to
	  mux index of the pins are always the same.
	  The pin nid may be 0, this means all pins will not
	  share the converter.
 skeleton caller of pin_cvt_fixup ops 
 called in hdmi_pcm_open when no pin is assigned to the PCM
  in dyn_pcm_assign mode.
 todo: setup spdif ctls assign 
 Initially set the converter's capabilities 
 Store the updated parameters 
  HDA PCM callbacks
 Validate hinfo 
		 no pin is assigned to the PCM
		  PA need pcm open successfully when probe
 Claim converter 
 flip stripe flag for the assigned stream if supported 
 configure unused pins to choose other converters 
 Initially set the converter's capabilities 
 Restrict capabilities by ELD if this isn't disabled 
 Store the updated parameters 
  HDAHDMI auto parsing
 all the device entries on the same pin have the same conn list 
	 on the new machines, try to assign the pcm slot dynamically,
	  not use the preferred fixed map (legacy way) anymore.
	
	  generic_hdmi_build_pcms() may allocate extra PCMs on some
	  platforms (with maximum of 'num_nids + dev_num - 1')
	 
	  The per_pin of pin_nid_idx=n and dev_id=m prefers to get pcm-n
	  if m==0. This guarantees that dynamic pcm assignments are compatible
	  with the legacy static per_pin-pcm assignment that existed in the
	  days before DP-MST.
	 
	  Intel DP-MST prefers this legacy behavior for compatibility, too.
	 
	  per_pin of m!=0 prefers to get pcm=(num_nids + (m - 1)).
 have a second try; check the area over num_nids 
 the last try; check the empty slots in pins 
 pcm already be attached to the pin 
 pcm already be detached from the pin 
 hdmi audio only uses playback and one substream 
 update per_pin ELD from the given new ELD;
  setup info frame and notification accordingly
  also notify ELD kctl and report jack status changes
 for monitor disconnection, save pcm_idx firstly 
	
	  pcm_idx >=0 before update_eld() means it is in monitor
	  disconnected event. Jack must be fetched before update_eld().
	 if pcm_idx == -1, it means this is in monitor connection event
	  we can get the correct pcm_idx now.
	
	  Re-setup pin and infoframe. This is needed e.g. when
	  - sink is first plugged-in
	  - transcoder can change during stream playback on Haswell
	    and this can make HW reset converter selection on a pin.
 update ELD and jack state via HD-audio verbs 
	
	  Always execute a GetPinSense verb here, even when called from
	  hdmi_intrinsic_event; for some NVIDIA HW, the unsolicited
	  response's PD bit is not the real PD value, but indicates that
	  the real PD value changed. An older version of the HD-audio
	  specification worked this way. Hence, we just ignore the data in
	  the unsolicited response to avoid custom WARs.
 configure unused pins to choose other converters 
 trigger silent stream generation in hw 
 update ELD and jack state via audio component 
	
	  Power-up will call hdmi_present_sense, so the PM calls
	  have to be done without mutex held.
	
	  For DP MST audio, Configuration Default is the same for
	  all device entries on the same pin
	
	  To simplify the implementation, malloc all
	  the virtual pins in the initialization statically
		
		  On Intel platforms, device entries count returned
		  by AC_PAR_DEVLIST_LEN is dynamic, and depends on
		  the type of receiver that is connected. Allocate pin
		  structures based on worst case.
		
		  spec->dev_num is the maxinum number of device entries
		  among all the pins
		
		  If the platform doesn't support DP MST,
		  manually set dev_num to 1. This means
		  the pin has only one device entry.
	
	  hdmi_add_pin() assumes total amount of converters to
	  be known, so first discover all converters
 discover audio pins 
	 Add sanity check to pass klockwork check.
	  This should never happen.
  HDMI callbacks
		 when dyn_pcm_assign and pcm is not bound to a pin
		  skip pin setup and return 0 to make audio playback
		  be ongoing
	 Verify pin:cvt selections to avoid silent audio after S3.
	  After S3, the audio driver restores pin:cvt selections
	  but this can happen before gfx is ready and such selection
	  is overlooked by HW. Thus multiple pins can share a same
	  default convertor and mute control will affect each other,
	  which can cause a resumed audio playback become silent
	  after S3.
 Call sync_audio_rate to set the NCTSM manually if necessary 
 Todo: add DP1.2 MST audio support later 
 snd_hda_set_dev_select() has been called before 
 chmap is already set to 0 in caller 
	
	  for non-mst mode, pcm number is the same as before
	  for DP MST mode without extra PCM, pcm number is same
	  for DP MST mode with extra PCMs, pcm number is
	   (nid number + dev_num - 1)
	  dev_num is the device entry number in a pin
 pcm number is less than 16 
 other pstr fields are set in open 
 no PCM: mark this for skipping permanently 
		 create the spdif for each pcm
		  pin will be bound when monitor is connected
 add control for ELD Bytes 
 add channel maps 
 allocate codec->spec and assigninitialize generic parser ops 
 initialize to 1 
 generic HDMI parser 
  generic audio component binding
 turn on  off the unsol event jack detection dynamically 
		 clear unsol even if component notifier is used, or re-enable
		  if notifier is cleared
 set up  clear component notifier dynamically 
 reprogram each jack detection logic depending on the notifier 
 enable  disable the notifier via master bind  unbind 
 check whether both HD-audio and DRM PCI devices belong to the same bus 
 audio component notifier for AMDNvidia HDMI codecs 
	 skip notification during system suspend (but not in runtime PM);
	  the state will be updated at resume
 ditto during suspendresume process itself 
 set up the private drm_audio_ops from the template 
	 intel_audio_codec_enable() or intel_audio_codec_disable()
	  will call pin_eld_notify with using audio_ptr pointer
	  We need make sure audio_ptr is really setup
 initialize the generic HDMI audio component 
  Intel codec parsers and helpers
 enable DP 1.2 features 
 enable 2nd & 3rd pins and convertors 
 enable DP1.2 mode 
 Haswell needs to re-issue the vendor-specific verbs before turning to D0.
  Otherwise you may get severe hw communication errors.
 There is a fixed mapping between audio pin node and display port.
  on SNB, IVY, HSW, BSW, SKL, BXT, KBL:
  Pin Widget 5 - PORT B (port = 1 in i915 driver)
  Pin Widget 6 - PORT C (port = 2 in i915 driver)
  Pin Widget 7 - PORT D (port = 3 in i915 driver)
  on VLV, ILK:
  Pin Widget 4 - PORT B (port = 1 in i915 driver)
  Pin Widget 5 - PORT C (port = 2 in i915 driver)
  Pin Widget 6 - PORT D (port = 3 in i915 driver)
 ILK 
 ILK 
 VLV 
	
	  looking for the pin number in the mapping table and return
	  the index which indicate the port number
 we assume only from port-B to port-D 
	 skip notification during system suspend (but not in runtime PM);
	  the state will be updated at resume
 ditto during suspendresume process itself 
 register i915 component pin_eld_notify callback 
 no need for forcible resume for jack check thanks to notifier 
 setup_stream ops override for HSW+ 
 pin_cvt_fixup ops override for HSW+ and VLV+ 
 precondition and allocation for Intel codecs 
 requires i915 binding 
 set probe_id here to prevent generic fallback binding 
 no need to handle unsol events 
 parse and post-process for Intel codecs 
 Intel Haswell and onwards; audio component with eld notifier 
	
	  Enable silent stream feature, if it is enabled via
	  module param or Kconfig option
	
	  pin to port mapping table where the value indicate the pin number and
	  the index indicate the port number.
	
	  pin to port mapping table where the value indicate the pin number and
	  the index indicate the port number.
 Intel Baytrail and Braswell; with eld notifier 
	 For ValleyviewCherryview, only the display codec is in the display
	  power well and can use link_power ops to requestrelease the power.
 Intel IronLake, SandyBridge and IvyBridge; with eld notifier 
  Shared non-generic implementations
 unsolicited event for jack sensing 
 generic_hdmi_build_jack can be used for simple_hdmi, too,
  as long as spec->pins[] is set correctly
 some codecs require to unmute the pin 
  Nvidia specific implementations
front, rear, clfe, rear_surr 
 set audio protect on 
 enable digital output on pin widget 
 terminator 
 set audio protect on 
 enable digital output on pin widget 
 terminator 
 support only the safe format and rate 
 support all rates and formats 
 no analog 
	 Set the audio infoframe channel allocation and checksum fields.  The
 set the stream id 
 set the stream format 
	 The audio hardware sends a channel count of 0x7 (8ch) when all the
 turn off SPDIF once; otherwise the IEC958 bits won't be updated 
 set the stream id 
 set the stream format 
 turn on again (if needed) 
 enable and set the channel status audiodata flag 
		 turn off SPDIF once;
		 otherwise the IEC958 bits won't be updated
 set the stream id 
 set the stream format 
 turn on again (if needed) 
 enable and set the channel status audiodata flag 
 override the PCM rates, etc, as the codec doesn't give full list 
 add channel maps 
	 Initialize the audio infoframe channel mask and checksum to something
  NVIDIA codecs ignore ASP mapping for 2ch - confirmed on:
  - 0x10de0015
  - 0x10de0040
 If the speaker allocation matches the channel count, it is OK. 
 all channels are remappable freely 
 map from pin NID to port; port is 0-based 
 for Nvidia: assume widget NID starting from 4, with step 1 (4, 5, 6, ...) 
 reverse-map from port to pin NID: see above 
  The HDA codec on NVIDIA Tegra contains two scratch registers that are
  accessed using vendor-defined verbs. These registers can be used for
  interoperability between the HDA and HDMI drivers.
 Audio Function Group node 
  The SCRATCH0 register is used to notify the HDMI codec of changes in audio
  format. On Tegra, bit 31 is used as a trigger that causes an interrupt to
  be raised in the HDMI codec. The remainder of the bits is arbitrary. This
  implementation stores the HDA format (see AC_FMT_) in bits [15:0] and an
  additional bit (at position 30) to signal the validity of the format.
  | 31      | 30    | 29  16 | 15   0 |
  +---------+-------+--------+--------+
  | TRIGGER | VALID | UNUSED | FORMAT |
  +-----------------------------------|
  Note that for the trigger bit to take effect it needs to change value
  (i.e. it needs to be toggled).
  The format parameter is the HDA audio format (see AC_FMT_). If set to 0,
  the format is invalidated so that the HDMI codec can be disabled.
 bits [31:30] contain the trigger and valid bits 
 bits [15:0] are used to store the HDA format 
 bits [16:24] are unused 
	
	  Bit 30 signals that the data is valid and hence that HDMI audio can
	  be enabled.
	
	  Whenever the trigger bit is toggled, an interrupt is raised in the
	  HDMI codec. The HDMI driver will use that as trigger to update its
	  configuration.
 notify the HDMI codec of the format change 
 invalidate the format in the HDMI codec 
	
	  Override ->prepare() and ->cleanup() operations to notify the HDMI
	  codec about format changes.
  ATIAMD-specific implementations
 ATIAMD specific HDA pin verbs, see the AMD HDA Verbs specification 
 AMD specific HDA cvt verbs 
 call hda_eld.c ATIAMD-specific function 
	
	  ATIAMD have automatic FCLFE swap built-in
	  when in pairwise mapping mode.
 see channel_allocations[].speakers[] 
 check that only channel pairs need to be remapped on old pre-rev3 ATIAMD 
 channel is in a supported position 
 even channel, check the odd companion 
 companion channel already checked 
		 In case this is an odd slot but without stream channel, do not
		  disable the slot since the corresponding even slot could have a
		  channel. In case neither have a channel, the slot pair will be
 ati_channel_setup format: [7..4] = stream_channel_id, [1] = mute, [0] = enable 
	
	  Pre-rev3 ATIAMD codecs operate in a paired channel mode, so
	  we need to take that into account (a single channel may take 2
	  channel slots if we need to carry a silent channel next to it).
	  On Rev3+ AMD codecs this function is not used.
 We only produce even-numbered channel count TLVs 
 produce paired maps for pre-rev3 ATIAMD codecs 
 add NA channel if the companion channel is occupied 
 default as per AMD spec 
 disable ramp-updown for non-pcm as per AMD spec 
 make sure downmix information in infoframe is zero 
 enable channel-wise remap mode if supported 
 map from pin NID to port; port is 0-based 
 for AMD: assume widget NID starting from 3, with step 2 (3, 5, 7, ...) 
 reverse-map from port to pin NID: see above 
 override to ATIAMD-specific versions with pairwise mapping 
 ATIAMD converters do not advertise all of their capabilities 
	 AMD GPUs have neither EPSS nor CLKSTOP bits, hence preventing
	  the link-down as is.  Tell the core to allow it.
 VIA HDMI Implementation 
 audio converter1 
 HDMI output pin1 
  patch entries
 17 is known to be absent 
 special ID for generic HDMI 
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
  Universal Interface for Intel High Definition Audio Codec
  HD audio interface patch for Silicon Labs 30545 modem codec
  Copyright (c) 2005 Sasha Khapyorsky <sashak@alsa-project.org>
                     Takashi Iwai <tiwai@suse.de>
 si3054 verbs 
 si3054 nodes (registers) 
 extended MID 
 line level 
 GPIO bits 
 chipid and revisions 
 si3054 codec registers (nodes) access macros 
  Modem mixer
  PCM callbacks
  Init part
 let's pray that this is no fatal error 
 return -EACCES; 
  patch entries
 VIA HDA on Clevo m540 
 Asus A8J Modem (SM56) 
 LG LW20 modem 
 SPDX-License-Identifier: GPL-2.0-or-later
  Universal Interface for Intel High Definition Audio Codec
  HD audio interface patch for Realtek ALC codecs
  Copyright (c) 2004 Kailang Yang <kailang@realtek.com.tw>
                     PeiSen Hou <pshou@realtek.com.tw>
                     Takashi Iwai <tiwai@suse.de>
                     Jonathan Woithe <jwoithe@just42.net>
 keep halting ALC5505 DSP, for power saving 
 extra amp-initialization sequence types 
 Means that this sku is set by driver, not read from hw 
 must be at head 
 codec parameterization 
 flag for snd_hda_parse_pin_defcfg() 
 GPIO bits 
 add a delay before writing gpio_data 
 mute LED for HP laptops, see vref_mute_led_set() 
 hooks 
 flag for other variants 
 for PLL fix 
  COEF access helper functions
 a special bypass for COEF 0; read the cached value at the second time 
 coef writesupdates batch 
  GPIO setup tables, used in initialization
 Enable GPIO mask and set output 
  Fix hardware PLL issue
  On some codecs, the analog PLL gating control must be off while
  the default value is 1.
 update the master volume per volume-knob's unsol event 
	 For some reason, the res given from ALC880 is broken.
 Change EAPD to verb control 
 EAPD Ctrl 
 EAPD Ctrl 
 additional initialization for ALC888 variants 
 alc888-VA 
 alc888-VB 
 Turn EAPD to High 
 turn onoff EAPD control (only if available) 
 turn onoff EAPD controls of the codec 
 We currently only handle front, HP 
	 don't shut up pins when unloading the driver; otherwise it breaks
	  the default pin setup at the next load of the driver
 use read here for syncing after issuing each verb 
 generic shutup callback;
  just turning off EAPD and a little pause for avoiding pop-noise
 generic EAPD initialization 
 get a primary headphone pin if available 
  Realtek SSID verification
 Could be any non-zero and even value. When used as fixup, tells
  the driver to ignore any present sku defines.
 assume always enabled 
 check sum 
 return the position of NID in the list, or -1 if not found 
 return true if the given NID is found in the list 
 check subsystem ID and set up device-specific initialization;
  return 1 if initialized, 0 if invalid SSID
 32-bit subsystem ID for BIOS loading in HD Audio codec.
 	31 ~ 16 :	Manufacture ID
 	15 ~ 8	:	SKU ID
 	7  ~ 0	:	Assembly ID
 	port-A --> pin 3941, port-E --> pin 1415, port-D --> pin 3536
 invalid SSID, check the special NID pin defcfg instead 
	
	  31~30	: port connectivity
	  29~21	: reserve
	  20		: PCBEEP input
	  19~16	: Check sum (15:1)
	  15~1		: Custom
	  0		: override
 no physical connection 
 check sum 
	
	  0 : override
	  1 :	Swap Jack
	  2 : 0 --> Desktop, 1 --> Laptop
	  3~5 : External Amplifier control
	  7~6 : Reserved
 external Amp control 
	 is laptop or Desktop and enable the function "Mute internal speaker
	  when the external headphone out jack is plugged"
	
	  10~8 : Jack location
	  12~11: Headphone out -> 00: PortA, 01: PortE, 02: PortD, 03: Resvered
	  14~13: Resvered
	  15   : 1 --> enable the function "Mute internal speaker
	 	        when the external headphone out jack is plugged"
 HP to chassis 
 Check the validity of ALC subsystem-id
  Common callbacks
 hibernation resume needs the full chip initialization 
 applied in below 
 apply verbs here after own init 
 disabled explicitly by hints 
 to avoid pop noise 
  Rename codecs appropriately from COEF value or subvendor id
 terminator 
 terminator 
  Digital-beep handlers
 additional beep mixers; private_value will be overwritten 
 set up and create beep controls 
 denylist -- no beep available 
 parse the BIOS configuration and set up the alc_spec 
 return 1 if successful, 0 if the proper config is not found,
  or a negative error code
 common preparation job for alc_spec 
 FIXME: do we need this for all Realtek codec models? 
  ALC880 fix-ups
 enable the volume-knob widget support on NID 0x21 
 disable bogus unused pins 
 line-in 
 headphone 
 disable bogus unused pins 
 change to EAPD mode 
 change to EAPD mode 
 override all pins as BIOS on old Amilo is broken 
 HP 
 speaker 
 bass speaker 
 NA 
 NA 
 mic-in 
 NA 
 NA 
 NA 
 NA 
 SPDIF out 
 almost compatible with FUJITSU, but no bass and SPDIF 
 HP 
 speaker 
 NA 
 NA 
 NA 
 mic-in 
 NA 
 NA 
 NA 
 NA 
 NA 
 need to fix HP and speaker pins to be parsed correctly 
 HP 
 speaker 
 bass speaker 
 disable bogus unused pins 
 set up the whole pins as BIOS is utterly broken 
 speaker 
 HP 
 NA 
 NA 
 mic-in 
 NA 
 line-in 
 NA 
 NA 
 NA 
 SPDIF 
 set up the whole pins as BIOS is utterly broken 
 HP 
 NA 
 NA 
 NA 
 mic 
 NA 
 NA 
 NA 
 NA 
 NA 
 SPDIF out 
 line-out 
 NA 
 NA 
 NA 
 mic-in 
 HP 
 line-in 
 front-mic 
 NA 
 NA 
 0x1e is filled in below 
 NA 
 NA 
 SPDIF 
 front 
 NA 
 CLFE 
 surr 
 mic-in 
 HP 
 line-in 
 front-mic 
 NA 
 NA 
 0x1e is filled in below 
 NA 
 NA 
 SPDIF 
 front 
 surr 
 CLFE 
 side 
 mic-in 
 front-mic 
 line-in 
 HP 
 NA 
 NA 
 0x1e is filled in below 
 NA 
 NA 
 SPDIF 
 HP with jack detect 
	 Below is the copied entries from alc880_quirks.c.
	  It's not quite sure whether BIOS sets the correct pin-config table
	  on these machines, thus they are kept to be compatible with
	  the old static quirks.  Once when it's confirmed to work without
	  these overrides, it'd be better to remove.
 broken BIOS 
 default Intel 
  OK, here we have finally the patch for ALC880
 automatic parse from the BIOS config 
  ALC260 support
  Pin config fixes
		 although the machine has only one output pin, we need to
		  toggle GPIO1 according to the jack state
 copy it for automute 
 HPspeaker 
 int mic 
 ext mic 
 SPDIF out 
 disable bogus IO pins 
 speaker 
 HP 
 Pin configs are missing completely on some VAIOs 
	 as quite a few machines require HP amp for speaker outputs,
	  it's easier to enable it unconditionally; even if it's unneeded,
	  it's almost harmless.
 automatic parse from the BIOS config 
  ALC882883885888889 support
  ALC882 is almost identical with ALC880 but has cleaner and more flexible
  configuration.  Each pin widget can choose any input DACs and a mixer.
  Each ADC is connected from a mixer of all inputs.  This makes possible
  6-channel independent captures.
  In addition, an independent DAC for the multi-playback (not used in this
  driver yet).
  Pin config fixes
 set up GPIO at initialization 
 Fix the connection of some pins for ALC889:
  At least, Acer Aspire 5935 shows the connections to DAC34 don't
  work correctly (bko#42740)
 fake the connections during parsing the tree 
 restore the connections 
 Set VREF on HP pin 
 Set VREF on speaker pins on imac91 
 Set VREF on speaker pins on mba11 
 Set VREF on speaker pins on mba21 
 Don't take HP output as primary
  Strangely, the speaker output doesn't work on Vaio Z and some Vaio
  all-in-one desktop PCs (for example VGC-LN51JGB) through DAC 0x05
 For dual-codec configuration, we need to disable some features to avoid
  conflicts of kctls and PCM streams
 disable vmaster 
 auto-mute and auto-mic switch don't work with multiple codecs 
 disable aamix as well 
 add location prefix to avoid conflicts 
 override card longname to provide a unique UCM profile 
 rename Capture controls depending on the codec 
	 We therefore want to make sure 0x14 (front headphone) and
	  0x1b (speakers) use the stereo DAC 0x02
 side 
 rear 
 clfe 
 rear int speakers 
 subwoofer 
 fix sequence for CLFE 
 CD 
 Front HP jack is flaky, disable jack detect 
 hidden surround speaker 
 change to EAPD mode 
 change to EAPD mode 
 change to EAPD mode 
 eanable EAPD on Acer laptops 
 CLFE speaker 
 surround speaker 
 CLFE speaker 
 surround speaker 
 additional init verbs for Acer Aspire 8930G 
 Enable all DACs 
 DAC DISABLEMUTE 1? 
			  setting bits 1-5 disables DAC nids 0x02-0x06
 DAC DISABLEMUTE 2? 
			  some bit here disables the other DACs.
			 DMIC fix
			  This laptop has a stereo digital microphone.
			  The mics are only 1cm apart which makes the stereo
			  useless. However, either the mic or the ALC889
			  makes the signal become a differencesum signal
			  instead of standard stereo, which is annoying.
			  So instead we flip this bit which makes the
			  codec replicate the sum signal to both channels,
			  turning it into a normal mono mic.
 DMIC_CONTROL? Init value = 0x0001 
 bass speaker 
 use as headset mic, without its own jack detect 
 use as headset mic, without its own jack detect 
 All Apple entries are in codec SSIDs 
  BIOS auto configuration
 almost identical with ALC880 parser... 
 ALC883 and variants 
 automatic parse from the BIOS config 
  ALC262 support
  Pin config fixes
 speaker 
 front HP 
 rear HP 
 speaker 
 internal speaker 
 int AUX 
	 pshou 071105  set a zero PCM sample to DAC when FIFO is
	  under-run
 automatic parse from the BIOS config 
   ALC268
 bind Beep switches of both NID 0x0f and 0x10 
 set PCBEEP vol = 0, mute connections 
 enable SPDIF out 
	 below is codec SSID since multiple Toshiba laptops have the
	  same PCI SSID 1179:ff00
  BIOS auto configuration
 ALC268 has no aa-loopback mixer 
 automatic parse from the BIOS config 
 override the amp caps for beep generator 
  ALC269
 fixed rate 
 fixed rate 
 different alc269-variants 
  BIOS auto configuration
 Volume up key 
 Volume down key 
 Power Down Control 
 FIFO and filter clock 
 DMIC control 
 Analog clock 
 JD 
 JD offset1 
 JD offset2 
 LDO123, DACADC 
 JD 
 Capless 
 Class D test 4 
 IO power down directly 
 ANC 
 AGC MUX 
 DAC simple content protection 
 ADC simple content protection 
 DAC ADC Zero Detection 
 PLL 
 capless control 2 
 capless control 3 
 capless control 4 
 capless control 5 
 class D test 2 
 class D test 3 
 class D test 5 
 class D test 6 
 classD OCP 
 classD pure DC test 
 Class D amp control 
 Index 0x78 Direct Drive HP AMP LPM Control 1 
 Headphone capless set to high power mode 
 Headphone capless set to normal mode 
 Power Down Control 
 FIFO and filter clock 
 DMIC control 
 Analog clock 
 JD 
 JD offset1 
 JD offset2 
 LDO123, DACADC 
 JD 
 Capless 
 Class D test 4 
 IO power down directly 
 ANC 
 AGC MUX 
 DAC simple content protection 
 ADC simple content protection 
 DAC ADC Zero Detection 
 PLL 
 capless control 2 
 capless control 3 
 capless control 4 
 capless control 5 
 class D test 2 
 class D test 3 
 class D test 5 
 class D test 6 
 classD OCP 
 classD pure DC test 
 test mode 
 Class D DC enable 
 DC offset 
 Class D amp control 
 HP JD control 
 Index 0x43 Direct Drive HP AMP LPM Control 1 
 Headphone capless set to high power mode 
 Index 0x46 Combo jack auto switch control 2 
 3k pull low control for Headset jack. 
 Headphone capless set to normal mode 
depop hp during suspend
 Low power 
 Hight power 
 Clear bit 
	
	  Expose headphone mic (or possibly Line In on some machines) instead
	  of PC Beep on 1Ah, and disable 1Ah loopback for all outputs. See
	  Documentationsoundhd-audiorealtek-pc-beep.rst for details of
	  this register.
 3k pull low control for Headset jack. 
 NOTE: call this before clearing the pin, otherwise codec stalls 
	 If disable 3k pulldown control for alc257, the Mic detection will not work correctly
	  when booting with headset plugged. So skip setting it for the codec alc257
 Reset HP JD 
 Amp control 
 Digital Misc control 
 Passthrough Control 
 Set HP depop to manual mode 
 HP depop procedure start 
 Wait for depop procedure finish  
 write back the result 
 required only at boot or S3 and S4 resume time 
 Low power 
 Hight power 
 3k pull low control for Headset jack. 
 Set HP depop to manual mode 
 HP depop procedure start 
 Wait for depop procedure finish  
 Set HP depop to auto mode 
 required only at boot or S4 resume time 
 LSB 
 MSB 
 DSP CPU stop 
 DDR enter self refresh 
 Clock control for PLL and CPU 
 Disable Input OP 
 Stop PLL2 
 Stop PLL1 
 Stop PLL3 
 switch Ringbuffer clock to DBUS clock 
 PLL1 control 
 PLL2 control 
 PLL3 control
 Function reset 
 DRAM control 
 DRAM control 
 DRAM control 
 Read revision ID 
 IO PAD Configuration 
 Clock control 
 PLL2 control 
 OSC Control 
 DRAM Function control 
 NOP 
 NOP 
	 on some machine, the BIOS will clear the codec gpio data when enter
	  suspend, and won't restore the data after resume, so we restore it
	  in the driver.
 CONFIG_PM 
 Fix the speaker amp after resume, etc 
	 Due to a hardware problem on Lenovo Ideadpad, we need to
	  fix the sample rate of analog IO to 44.1kHz
	 The digital-mic unit sends PDM (differential signal) instead of
	  the standard PCM, thus you can't record a valid mono stream as is.
	  Below is a workaround specific to ALC269 to control the dmic
	  signal source as mono.
  Magic sequence to make Huawei Matebook X right speaker working (bko#197801)
 Initialization magic 
 Start 
 temporarily power updown for setting VREF 
 update mute-LED according to the speaker mute state via mic VREF pin 
 Make sure the led works even in runtime suspend 
 Set pin ctl again, it might have just been set to 0 
 update LED status via GPIO 
 muted -> LED on 
 turn onoff mute LED via GPIO per vmaster hook 
 turn onoff mic-mute LED via GPIO per capture hook 
 setup mute and mic-mute GPIO bits, add hooks appropriately 
 turn onoff mic-mute LED per capture hook via VREF change 
		 Like hp_gpio_mic1_led, but also needs GPIO4 low to
		  enable headphone amp
 HP Spectre x360 14 model needs a unique workaround for enabling the amp;
  it needs to toggle the GPIO0 once on and off at each time (bko#210633)
 need to toggle GPIO to enable the amp 
 toggle GPIO2 at each time stream is started; we use PREPARE state instead 
 temporarily power updown for setting COEF bit 
 update mute-LED according to the speaker mute state via COEF bit 
 turn onoff mic-mute LED per capture hook by coef bit 
	 GPIO2 just toggles on a keypresskeyrelease cycle. Therefore
 GPIO1 = set according to SKU external amp
  GPIO2 = mic mute hotkey
  GPIO3 = mute LED
  GPIO4 = mic mute LED
 Line2 = mic mute hotkey
  GPIO2 = mic mute LED
 INPUT 
 INPUT 
 LDO and MISC control 
 UAJ function set to menual mode 
 Direct Drive HP Amp control(Set to verb control)
 Set MIC2 Vref gate with HP 
 Direct Drive HP Amp control 
 LDO and MISC control 
 UAJ function set to menual mode 
 Set MIC2 Vref gate with HP 
 Direct Drive HP Amp control 
 Direct Drive HP Amp control(Set to verb control)
 SET Line1 JD to 0 
 SET charge pump by verb 
 SET EN_OSW to 1 
 Combo JD gating with LINE1-VREFO 
 Set to TRS type 
 Combo Jack auto detect 
 Set MIC2 Vref gate to normal 
 Direct Drive HP Amp control(Set to verb control)
 Set MIC2 Vref gate to normal 
 SET charge pump by verb 
 SET EN_OSW to 0 
 Combo JD gating without LINE1-VREFO 
 Set to TRS mode 
 Direct Drive HP Amp control(Set to verb control)
 Set to TRS type 
 Combo Jack auto detect 
 Set to TRS type 
 Combo JD gating without LINE1-VREFO 
 Iphone type 
 Set to CTIA type 
 Set to CTIA type 
 Set to ctia type 
 SET Line1 JD to 1 
 Nokia type 
 Set to OMTP Type 
 Set to OMTP Type 
 Set to omtp type 
 SET Line1 JD to 1 
 Headset output enable 
 combo jack auto switch control(Check type)
		WRITE_COEF(0x49, 0x0149),  combo jack auto switch control(Vref
 Check Type 
 Combo Jack auto detect 
 Set to ctia type 
 Find mic pins 
 Set to iphone type 
 Headset Mic enable or disable, only for Dell Dino 
 toggled via hp_automute_hook 
 Disable AA-loopback as it causes white noise 
 fixup for Thinkpad docks: add dock pins, avoid HP parser fixup 
 dock headphone 
 dock mic 
 avoid click noises 
 dock headphone 
 dock mic 
 Enable DOCK device 
 Enable DOCK device 
	 Assure the speaker pin to be coupled with DAC NID 0x03; otherwise
	  the speaker output becomes too low by some reason on Thinkpads with
	  ALC298 codec
 Prevent pop noises when headphones are plugged in 
		 mic pin 0x19 must be initialized with Vref Hi-Z, otherwise
		  it causes a click noise at start up
 Make the internal mic the default input source. 
 Mic-in is same pin as headphone 
		 Disable boost for mic-in permanently. (This code is only called
 Returns the nid of the external mic input pin, or 0 if it cannot be found. 
	 The mic boosts on level 2 and 3 are too noisy
	   on the internal mic input.
 Disable AA-loopback as it causes white noise 
 MIC2-VREF control 
 Set to manual mode 
 Enable Line1 input control by verb 
 MIC2-VREF control 
 Set to manual mode 
 mute tablet speaker pin (0x14) via dock plugging in addition 
 dock speaker pin 
 TX300 needs to set up GPIO2 for the speaker amp 
		 this is a bit tricky; give more sane names for the main
		  (tablet) speaker and the dock speaker, respectively
		 DAC node 0x03 is giving mono output. We therefore want to
		   make sure 0x14 (front speaker) and 0x15 (headphones) use the
		 The speaker is routed to the Node 0x06 by a mistake, as a result
		   we can't adjust the speaker's volume since this node does not has
		   Amp-out capability. we change the speaker's route to:
		   Node 0x02 (Audio Output) -> Node 0x0c (Audio Mixer) -> Node 0x17 (
		   Pin Complex), since Node 0x02 has Amp-out caps, we can adjust
 disable DAC3 (0x06) selection on NID 0x17 as it has no volume amp control 
 force NID 0x17 (Bass Speaker) to DAC1 to share it with the main speaker 
 Hook to update amp GPIO4 for automute 
 mute_led_polarity is set to 0, so we pass inverted value here 
 Manage GPIOs for HP EliteBook Folio 9480m.
  GPIO4 is the headphone amplifier power control
  GPIO3 is the audio output mute indicator LED
 amp at GPIO4; toggled via alc280_hp_gpio4_automute_hook() 
 set data bit low 
 Quirk for Thinkpad X1 7th and 8th Gen
  The following fixed routing needed
  DAC1 (NID 0x02) -> Speaker (NID 0x14); some eq applied secretly
  DAC2 (NID 0x03) -> Bass (NID 0x17) & Headphone (NID 0x21); sharing a DAC
  DAC3 (NID 0x06) -> Unused, due to the lack of volume amp
 exclude 0x06 
		 The generic parser creates somewhat unintuitive volume ctls
		  with the fixed routing above, and the shared DAC2 may be
		  confusing for PA.
		  Rename those to unique names so that PA doesn't touch them
		  and use only Master volume.
 override card longname to provide a unique UCM profile 
 rename Capture controls depending on the codec 
 Forcibly assign NID 0x03 to HPLO while NID 0x02 to SPK for EQ 
 avoid DAC 0x06 for bass speaker 0x17; it has no volume control 
 The DAC of NID 0x3 will introduce clickpop noise on headphones, so invalidate it 
 Reset HP JD 
 Reset HP JD 
	 The Windows driver sets the codec up in a very different way where
	  it appears to leave 0x10 = 0x8a20 set. For Linux we need to toggle it
 Pin 0x21: headphonesheadset mic 
		 Make sure to start in a correct state, i.e. if
		  headphones have been plugged in before powering up the system
	 Windows sets 0x10 to 0x8420 for Node 0x20 which is
	  responsible from changes between speakers and headphones
 Mic RING SLEEVE swap for combo jack 
 GPIO1 = amplifier onoff
  GPIO3 = mic mute LED
 fronthigh speakers 
 backbass speakers 
enable micmute led
 needed for amp of back speakers 
 share DAC to have unified volume control 
 need to toggle GPIO to enable the amp of back speakers 
 rear speaker 
 force front speaker to DAC1 
 for hda_fixup_thinkpad_acpi() 
 reduce click noise 
 Fixup for Lenovo Legion 15IMHg05 speaker output on headset removal. 
 for alc295_fixup_hp_top_speakers 
 for alc285_fixup_ideapad_s740_coef() 
	
	 A certain other OS sets these coeffs to different values. On at least one TongFang
	 barebone these settings might survive even a cold reboot. So to restore a clean slate the
	 values are explicitly reset to default here. Without this, the external microphone is
	 always in a plugged-in state, while the internal microphone is always in an unplugged
	 state, breaking the ability to use the internal microphone.
 Enables internal speaker 
 subwoofer 
 dock line-out 
 dock mic-in 
 headset mic, with jack detect 
 HP out 
 speaker 
 HP out 
 mic 
 int-mic 
 int-mic 
 speaker 
 HP out 
 mic 
 speaker 
 mic 
 int-mic 
 HP out 
 int-mic 
 speaker 
 mic 
 HP out 
 dock mic 
 dock headphone 
 use as headset mic, without its own jack detect 
 use as headphone mic, without its own jack detect 
 dock line out 
 dock mic 
 use as headset mic, without its own jack detect 
 use as headset mic, without its own jack detect 
 use as headset mic, without its own jack detect 
 use as headphone mic, without its own jack detect 
 headset mic wo jack detect 
 use as headset mic, without its own jack detect 
 Headset mic 
 speaker 
 mic 
 int-mic 
 HP out 
 int-mic 
 speaker 
 mic 
 SPDIF1 
 HP out 
 class-D output amp +5dB 
 int-mic 
 mic 
 Unused bogus pin 
 subwoofer 
 subwoofer 
 use as headset mic, without its own jack detect 
 use as headset mic, without its own jack detect 
 use as headset mic, without its own jack detect 
 use as headphone mic, without its own jack detect 
 use as headset mic, without its own jack detect 
 use as headphone mic, without its own jack detect 
 use as headset mic, without its own jack detect 
 line-out 
 headset mic 
 line-in 
 line-out 
 line-in 
 use as headset mic, without its own jack detect 
 use as headphone mic, without its own jack detect 
 micmute fixup must be applied at last 
 headset mic wo jack detect 
 use as headset mic, without its own jack detect 
 use as headphone mic, without its own jack detect 
 use as headset mic, without its own jack detect 
 Enables internal speaker 
 Disable pass-through path for FRONT 14h 
 Front Mic 
 use as headset mic, without its own jack detect 
 use as headphone mic, without its own jack detect 
 use as internal mic 
 use as headset mic, without its own jack detect 
 Set up GPIO2 for the speaker amp 
 use as headset mic, without its own jack detect 
 Enables internal speaker 
			 Change the mic location from front to right, otherwise there are
			   two front mics with the same name, pulseaudio can't handle them.
			   This is just a temporary workaround, after applying this fixup,
			   there will be one "Front Mic" and one "Mic" in this machine.
 Rear Headset HP 
 use as Front headset mic, without its own jack detect 
 Rear Headset MIC 
 Enables internal speaker 
 use as headset mic, without its own jack detect 
 use as headset mic, without its own jack detect 
 use as internal mic 
 use as headset mic, without its own jack detect 
 use as headset mic 
 Set EAPD high 
 use as headset mic, without its own jack detect 
 Disable PCBEEP-IN passthrough 
 use as internal mic 
 Rear Line out 
 use as Front headset mic, without its own jack detect 
 headset mic with jack detect 
 use as headset mic, without its own jack detect 
 use as headset mic, without its own jack detect 
 bass spk 
 The GPIO must be pulled to initialize the AMP 
 Set EAPD high 
 front HP mic 
 rear external mic 
 front HP out 
 set 0x15 to HP-OUT ctrl 
 unmute the 0x15 amp 
 rear HP mic 
 rear external mic 
 rear HP out 
 set 0x15 to HP-OUT ctrl 
 unmute the 0x15 amp 
 set 0x1b to HP-OUT 
			 Set bit 10 to correct noisy output after reboot from
			  Windows 10 (due to pop noise reduction?)
 use as headset mic, without its own jack detect 
 use as internal speaker 
 use as headset mic, without its own jack detect 
 use as line out 
 use as headset mic 
 use as headset mic, without its own jack detect 
 headset mic with jack detect 
 use as headset mic, without its own jack detect 
 speaker 
 HP out 
 mic 
 speaker 
 HP out 
 mic 
 speaker 
 HP out 
 mic 
 speaker 
 mic1 
 mic2 
 speaker 
 HP out 
 rear  mic 
 front mic 
 front lineout 
 use as headset mic, without its own jack detect 
 use as headset mic, without its own jack detect 
 Set EAPD high 
 use as headset mic, without its own jack detect 
 use as headset mic, without its own jack detect 
 use as internal mic 
 Change the Headphone location to Left 
.v.verbs = legion_15imhg05_coefs,
 set left speaker Legion 7i.
 set right speaker Legion 7i.
 set left speaker Yoga 7i.
 set right speaker Yoga 7i.
 use as headset mic, without its own jack detect 
 Also known as Malata PC-B1303 
	 Below is a quirk table taken from the old code.
	  Basically the device should work as is without the fixup table.
	  If BIOS doesn't give a proper info, enable the corresponding
	  fixup entry.
 This is the fallback pin_fixup_tbl for alc269 family, to make the tbl match
  more machines, don't need to match all valid pins, just need to match
  all the pins defined in the tbl. Just because of this reason, it is possible
  that a single machine matches multiple tbls, so there is one limitation:
    at most one tbl is allowed to define for the same vendor and same codec
 Power up output pin 
 Capless ramp up clock control 
 Class D power on reset 
 HP 
 ALC256 does not have any loopback mixer path 
 no loopback on ALC225, ALC295 and ALC299 
 no loopback on ALC287 
 ALC2x4 does not have any loopback mixer path 
 UAJ MIC Vref control by verb 
 no loopback on ALC300 
 ALC700 does not have any loopback mixer path 
 Combo jack auto trigger control 
	 FIXME: both TX300 and ROG Strix G17 have the same SSID, and
	  the quirk breaks the latter (bko#214101).
	  Clear the wrong entry.
 automatic parse from the BIOS config 
  ALC861
 Pin config fixes 
 On some laptops, VREF of pin 0x0f is abused for controlling the main amp 
 suppress the jack-detection 
 HP 
 speaker 
			 ASUS W7J needs a magic pin setup on unused NID 0x10
			  for enabling outputs
 automatic parse from the BIOS config 
  ALC861-VD support
  Based on ALC882
  In addition, an independent DAC
 exclude VREF80 
 reset GPIO1 
 automatic parse from the BIOS config 
  ALC662 support
  ALC662 is almost identical with ALC880 but has cleaner and more flexible
  configuration.  Each pin widget can choose any input DACs and a mixer.
  Each ADC is connected from a mixer of all inputs.  This makes possible
  6-channel independent captures.
  In addition, an independent DAC for the multi-playback (not used in this
  driver yet).
  BIOS auto configuration
 LFE only on right 
 override the 2.1 chmap 
 avoid D3 for keeping GPIO up 
	 surround speakers at 0x1b already get muted automatically when
	  headphones are plugged in, but we have to muteunmute the remaining
	  channels manually:
	  0x15 - front leftfront right
	  0x18 - front center LFE
 Pin 0x1b: shared headphones jack and surround speakers 
 subwoofer needs an extra GPIO setting to become audible 
		 Make sure to start in a correct state, i.e. if
		  headphones have been plugged in before powering up the system
 use as headset mic, with its own jack detect 
 subwoofer 
 subwoofer 
 speaker 
 mic 
 int-mic 
 HP out 
 speaker 
 mic 
 int-mic 
 HP out 
 speaker 
 mic 
 int-mic 
 HP out 
 speaker 
 HP 
 mic 
 int-mic 
 HP2 
 speaker 
 speaker 
 mic 
 int-mic 
 HP 
 speaker 
 HP 
 speaker 
 mic 
 int-mic 
 speaker 
 HP2 
 mic 
 int-mic 
 HP 
 speaker 
 speaker 
 mic 
 int-mic 
 HP 
 HP 
 speaker 
 int-mic 
 HP 
 speaker 
 mic 
 HP 
 Front HP 
 use as headset mic, without its own jack detect 
 headphone mic by setting pin control of 0x1b (headphone out) to in + vref_50 
 use as headphone mic, without its own jack detect 
 use as headset mic, without its own jack detect 
 bass speaker 
 bass speaker 
 use as headphone mic, without its own jack detect 
 bass speaker 
 use as headset mic, without its own jack detect 
 HP 
 use as headphone mic, without its own jack detect 
 use as headset mic, without its own jack detect 
 no internal speaker 
 disabled 
 disabled 
 use as headset mic, without its own jack detect 
 front speakers 
 centersubwoofer 
 surround plus jack for HP 
 use as headset mic, without its own jack detect 
 use as headset mic, without its own jack detect 
	 Below is a quirk table taken from the old code.
	  Basically the device should work as is without the fixup table.
	  If BIOS doesn't give a proper info, enable the corresponding
	  fixup entry.
 handle multiple HPs as is 
 automatic parse from the BIOS config 
  ALC680 support
 ALC680 has no aa-loopback mixer 
 automatic parse from the BIOS config 
  patch entries
 terminator 
 SPDX-License-Identifier: GPL-2.0
 Helper functions for Thinkpad LED control;
  to be included from codec driver
 CONFIG_THINKPAD_ACPI 
 CONFIG_THINKPAD_ACPI 
 SPDX-License-Identifier: GPL-2.0-or-later
  Generic routines and proc interface for ELD(EDID Like Data) information
  Copyright(c) 2008 Intel Corporation.
  Copyright (c) 2013 Anssi Hannula <anssi.hannula@iki.fi>
  Authors:
  		Wu Fengguang <wfg@linux.intel.com>
 also include valid xtypes below 
  0  "undefined",
  1  "LPCM",
  2  "AC-3",
  3  "MPEG1",
  4  "MP3",
  5  "MPEG2",
  6  "AAC-LC",
  7  "DTS",
  8  "ATRAC",
  9  "DSD (One Bit Audio)",
 10  "E-AC-3DD+ (Dolby Digital Plus)",
 11  "DTS-HD",
 12  "MLP (Dolby TrueHD)",
 13  "DST",
 14  "WMAPro",
 15  "HE-AAC",
 16  "HE-AACv2",
 17  "MPEG Surround",
  The following two lists are shared between
  	- HDMI audio InfoFrame (source to sink)
  	- CEA E-EDID Extension (sink to source)
  SS1:SS0 index => sample size
 0: Refer to Stream Header 
 1: 16 bits 
 2: 20 bits 
 3: 24 bits 
  SF2:SF1:SF0 index => sampling frequency
 0: Refer to Stream Header 
 1:  32000Hz 
 2:  44100Hz 
 3:  48000Hz 
 4:  88200Hz 
 5:  96000Hz 
 6: 176400Hz 
 7: 192000Hz 
  Be careful, ELD buf could be totally rubbish!
 not specified, but the spec's tendency is little endian 
	
	  HDMI sink's ELD info cannot always be retrieved for now, e.g.
	  in console or for audio devices. Assume the highest speakers
	  configuration, to _not_ prohibit multi-channel audio playback.
	
	  ELD size is initialized to zero in caller function. If no errors and
	  ELD is valid, actual eld_size is assigned.
 wfg: workaround for ASUS P5E-VM HDMI board 
 set ELD buffer 
		
		  Graphics driver might be writing to ELD buffer right now.
		  Just abort. The caller will repoll after a while.
		
		  The first byte cannot be zero. This can happen on some DVI
		  connections. Some Intel chips may also need some 250ms delay
		  to return non-zero ELD data, even when the graphics driver
		  correctly writes ELD content before setting ELD_valid bit.
  SNDRV_PCM_RATE_ and AC_PAR_PCM values don't match, print correct rates with
  hdmi-specific routine.
 necessary when j == 0 
		
		  We don't allow modification to these fields:
		  	monitor_name manufacture_id product_id
		  	eld_version edid_version
 CONFIG_SND_PROC_FS 
 update PCM info based on ELD 
	 assume basic audio support (the basic audio flag is not in ELD;
	  however, all audio capable sinks are required to support basic
 restrict the parameters by the values the codec provides 
 ATIAMD specific stuff (ELD emulation) 
 first three bytes are just standard SAD 
 in standard HDMI VSDB format 
 max len 18 bytes 
 ATIAMD does not have ELD, emulate it 
 version 
 speaker allocation from EDID 
 is DisplayPort? 
 not handled by ATIAMD 
 format is supported, copy SAD as-is 
 for PCM there is a separate stereo rate mask 
 rates from the extra byte 
	
	  HDMI VSDB latency format:
	  separately for both audio and video:
	   0          field not valid or unknown latency
	   [1..251]   msecs = (x-1)2  (max 500ms with x = 251 = 0xfb)
	   255        audiovideo not supported
	 
	  HDA latency format:
	  single value indicating video latency relative to audio:
	   0          unknown or 0ms
	   [1..250]   msecs = x2  (max 500ms with x = 250 = 0xfa)
	   [251..255] reserved
 else unknowninvalid or 0ms or video ahead of audio, so use zero 
 SAD count 
 Baseline ELD block length is 4-byte aligned 
 Baseline ELD length (4-byte header is not counted in) 
 SPDX-License-Identifier: GPL-2.0-only
  HD-audio codec driver binding
  Copyright (c) Takashi Iwai <tiwai@suse.de>
  find a matching codec id
 check probe_id instead of vendor_id if set 
 process an unsolicited event 
 ignore unsol events during shutdown 
 ignore unsol events during system suspendresume 
  snd_hda_codec_set_name - set the codec name
  @codec: the HDA codec
  @name: name string to set
 update the mixer name 
 only register after the bus probe finished; otherwise it's racy 
 try to auto-load codec module 
 MODULE 
 try to auto-load and bind the codec module 
 if all audio out widgets are digital, let's assume the codec as a HDMIDP 
 HDMI parser supports only HDMI out 
 no HDMI codec parser support 
 CONFIG_SND_HDA_CODEC_HDMI 
  snd_hda_codec_configure - (Re-)configure the HD-audio codec
  @codec: the HDA codec
  Start parsing of the given codec tree and (re-)initialize the whole
  patch instance.
  Returns 0 if successful or a negative error code.
 SPDX-License-Identifier: GPL-2.0-or-later
  HWDEP Interface for HD-audio codec
  Copyright (c) 2007 Takashi Iwai <tiwai@suse.de>
  writeread an out-of-bound verb
 open-code get_wcaps(verb>>24) with nospec 
 for sysfs 
 SPDX-License-Identifier: GPL-2.0-or-later
   Implementation of primary alsa driver code base for Intel HD Audio.
   Copyright(c) 2004 Intel Corporation. All rights reserved.
   Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>
                      PeiSen Hou <pshou@realtek.com.tw>
 for art-tsc conversion 
 DSP lock helpers 
 assign a stream for the PCM 
 release the assigned stream 
  PCM ops
 reset BDL address 
 CA-IBG chips need the playback stream starting from 1 
 first, set SYNC bits of corresponding streams 
 reset SYNC bits 
 use the position buffer as default 
  azx_scale64: Scale base by multdiv while not overflowing sanely
  Derived from scale64_check_overflow in kerneltimetimekeeping.c
  The tmestamps for a 48Khz stream can overflow after (2^6410^9)48K which
  is about 384307 ie ~4.5 days.
  This scales the calculation so that overflow will happen but after 2^64 
  48000 secs, which is pretty large!
  In caln below:
 	base may overflow, but since there isnt any additional division
 	performed on base its OK
 	rem cant overflow because both are 32-bit values
 0th stream tag is not used, so DMA ch 0 is for 1st stream tag 
 Enable the capture 
 Read wall clock counter 
 Read TSC counter 
 Read Link counter 
 Ack: registers read done 
		
		  An error occurs near frame "rollover". The clocks in
		  frame value indicates whether this error may have
		  occurred. Here we use the value of 10 i.e.,
		  HDA_MAX_CYCLE_OFFSET
		
		  Sleep before we read again, else we may again get
		  value near to MAX_CYCLE. Try to sleep for different
		  amount of time so we dont hit the same number again
 can be optimized 
 rest of structure is valid 
 24 MHz WallClock == 42ns resolution 
 24 MHz WallClock == 42ns resolution 
 No full-resume yet implemented 
 SNDRV_PCM_INFO_RESUME |
 legacy 
 avoid wrap-around with wall-clock 
		 constrain buffer sizes to be multiple of 128
		   bytes. This is more efficient in terms of memory
		   access but isn't required by the HDA spec and
		   prevents users from specifying exact periodbuffer
		   sizes. For example for 44.1kHz, a period size set
		 Don't enforce steps on buffer sizes, still need to
		   be multiple of 4 bytes (HDA spec). Tested on Intel
		   HDA controllers, may not work on all devices where
 sanity check 
	 disable LINK_ATIME timestamps for capture streams
 legacy 
 buffer pre-allocation 
 receive a response 
		 If this critical timeout happens during the codec probing
		  phase, this is likely an access to a non-existing codec
		  slot.  Better to return an error and reset the system.
 no fallback mechanism? 
	 a fatal communication error; need either to reset or to fallback
	  to the single_cmd mode
 give a chance to retry 
  Use the single immediate command instead of CORBRIRB for simplicity
  Note: according to Intel, this is not preferred use.  The command was
        intended for the BIOS only, and may get confused with unsolicited
        responses.  So, we shouldn't use it for normal operation from the
        driver.
        I left the codes, however, for debuggingtesting purposes.
 receive a response 
 check IRV busy bit 
 reuse rirb.res as the response return value 
 send a command 
 check ICB busy bit 
 Clear IRV valid bit 
 receive a response 
  The below are the main callbacks from hda_codec.
  They are just the skeleton to call sub-callbacks according to the
  current setting of chip->single_cmd.
 send a command 
 get a response 
  DSP loading code (e.g. for CA0132)
 use the first stream for loading DSP 
 CONFIG_SND_HDA_DSP_LOADER 
  reset and start the controller registers
 correct RINTCNT for CXT 
  interrupt handler
 check whether this IRQ is really acceptable 
 count for avoiding endless loop 
			
			  Clearing the interrupt status here ensures that no
			  interrupt gets masked after the RIRB wp is read in
			  snd_hdac_bus_update_rirb. This avoids a possible
			  race condition where codec response in RIRB may
			  remain unserviced by IRQ, eventually falling back
			  to polling mode in azx_rirb_get_response.
  Codec initerface
  Probe the given codec address
 HD-audio bus initialization 
 enable sync_write flag for stable communication as default 
 Probe codecs 
 First try to probe all given codec slots 
				 Some BIOSen give you wrong codec addresses
				  that don't exist
				 More badly, accessing to a non-existing
				  codec often screws up the controller chip,
				  and disturbs the further communications.
				  Thus if an error occurs during probing,
				  better to reset the controller chip to
				  get back to the sanity state.
 Then create codec instances 
 configure each codec instance 
 unregister failed codecs if any codec has been probed 
 initialize SD streams 
	 initialize each stream (aka device)
	  assign the starting bdl address to each stream (device)
	  and initialize
		 stream tag must be unique throughout
		  the stream direction group,
		  valid values 1...15
		  use separate stream tag if the flag
		  AZX_DCAPS_SEPARATE_STREAM_TAG is used
 SPDX-License-Identifier: GPL-2.0-only
  Implementation of primary ALSA driver code base for NVIDIA Tegra HDA.
 Defines for Nvidia Tegra HDA support 
 IPFS 
 FPCI 
 max number of SDs 
  Tegra194 does not reflect correct number of SDO lines. Below macro
  is used to update the GCAP register to workaround the issue.
 nothing special 
 Enable PCI access 
 Enable MEMIO space and bus master 
  power management
 enable controller wake up event 
 disable controller wake up event
  destructor
	
	  Tegra194 has 4 SDO lines and the STRIPE can be used to
	  indicate how many of the SDO lines the stream should be
	  striped. But GCAP register does not reflect the true
	  capability of HW. Below workaround helps to fix this.
	 
	  GCAP_NSDO is bits 19:18 in T_AZA_DBG_CFG_2,
	  0 for 1 SDO, 1 for 2 SDO, 2 for 4 SDO lines.
	 read number of streams from GCAP register instead of using
	  hardcoded value
 gcap didn't give any info, switching to old method 
 initialize streams 
 initialize chip 
	
	  Playback (for 44.1K48K, 2-channel, 16-bps) fails with
	  4 SDO lines due to legacy design limitation. Following
	  is, from HD Audio Specification (Revision 1.0a), used to
	  control striping of the stream across multiple SDO lines
	  for sample rates <= 48K.
	 
	  { ((num_channels  bits_per_sample)  number of SDOs) >= 8 }
	 
	  Due to legacy design issue it is recommended that above
	  ratio must be greater than 8. Since number of SDO lines is
	  in powers of 2, next available ratio is 16 which can be
	  used as a limiting factor here.
 codec detection 
 driver name 
 shortname for card 
 longname for card 
  constructor
 create codec instances 
 no error return from async probe 
 SPDX-License-Identifier: GPL-2.0-or-later
  Universal Interface for Intel High Definition Audio Codec
  Generic proc interface
  Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>
 always use noncached version 
 is this a stereo widget or a stereo-to-mono mix? 
	 check for a stereo-to-mono mix; it must be:
	  only a single connection, only for input, and only a mixer widget
 the connection source is a stereo? 
  Parse the pin default config value and returns the string of the
  jack location, e.g. "Rear", "Front", etc.
  Parse the pin default config value and returns the string of the
  jack connectivity, i.e. external or internal connection.
  Parse the pin default config value and returns the string of the
  jack type, i.e. the purpose of the jack, such as Line-Out or CD.
 Realtek uses this bit as a different meaning 
	 Default association and sequence values refer to default grouping
	  of pin complexes and their sequence within the group. This is used
	  for priority and resource allocation.
		 Miscellaneous bit indicates external hardware does not
		  support presence detection even if the pin complex
		  indicates it is supported.
	 Note: This is racy - another process could run in parallel and change
 Get Cache connections info 
 FIXME: add GPO and GPI pin information 
		 volume knob is a special widget that always have connection
		  list
  create a proc read
 SPDX-License-Identifier: GPL-2.0-or-later
   hda_intel.c - Implementation of primary alsa driver code base
                 for Intel HD Audio.
   Copyright(c) 2004 Intel Corporation. All rights reserved.
   Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>
                      PeiSen Hou <pshou@realtek.com.tw>
   CONTACTS:
   Matt Jared		matt.jared@intel.com
   Andy Kopp		andy.kopp@intel.com
   Dan Kogan		dan.d.kogan@intel.com
   CHANGES:
   2004.12.01	Major rewrite by tiwai, merged the work of pshou
 for snoop control 
 position fix mode 
 Defines for ATI HD Audio support in SB450 south bridge 
 Defines for Nvidia HDA support 
 Defines for Intel SCH HDA snoop control 
 Define VIA HD Audio Device ID
 max number of SDs 
 ICH, ATI and VIA have 4 playback and 4 capture 
 ULI has 6 playback and 5 capture 
 ATI HDMI may have up to 8 playbacks and 0 capture 
 TERA has 4 playback and 3 capture 
 reset the HD-audio controller in power save mode.
  this may give more power-saving, but will take longer time to
  wake up.
 CONFIG_PM 
 driver types 
 keep this as last entry 
 quirks for old Intel chipsets 
 quirks for Intel PCH 
 PCH up to IVB; no runtime PM; bind with i915 gfx 
 PCH for HSWBDW; with runtime PM 
 no i915 binding for this as HSWBDW has another controller for HDMI 
 HSW HDMI 
AZX_DCAPS_ALIGN_BUFSIZE | AZX_DCAPS_COUNT_LPIB_DELAY |\
 Broadwell HDMI can't use position buffer reliably, force to use LPIB 
AZX_DCAPS_ALIGN_BUFSIZE | AZX_DCAPS_POSFIX_LPIB |\
 quirks for ATI SB  AMD Hudson 
 quirks for ATIAMD HDMI 
 quirks for ATI HDMI with snoop off 
 quirks for AMD SB 
 quirks for Nvidia 
  vga_switcheroo support
 kept old name for compatibility 
  initialize the PCI registers
 update bits in a PCI register byte 
	 Clear bits 0-2 of PCI register TCSEL (at offset 0x44)
	  TCSEL == Traffic Class Select Register, which sets PCI express QOS
	  Ensuring these bits are 0 clears playback static on some HD Audio
	  codecs.
	  The PCI register TCSEL is defined in the Intel manuals.
	 For ATI SB450600700800900 and AMD Hudson azalia HD audio,
	  we need to enable snoop.
 For NVIDIA HDA, enable snoop 
 Enable SCHPCH snoop if needed 
  In BXT-P A0, HD-Audio DMA requests is later than expected,
  and makes an audio stream sensitive to system latencies when
  2432 bits are playing.
  Adjusting threshold of DMA fifo to force the DMA request
  sooner to improve latency tolerance at the expense of power.
  ML_LCAP bits:
   bit 0: 6 MHz Supported
   bit 1: 12 MHz Supported
   bit 2: 24 MHz Supported
   bit 3: 48 MHz Supported
   bit 4: 96 MHz Supported
   bit 5: 192 MHz Supported
	
	  the codecs are sharing the first link setting by default
	  If other links are enabled for stream, they need similar fix
 wait for CPA 
 0. check lctl register value is correct or not 
 if SCF is already set, let's use it 
	
	  Before operating on SPA, CPA must match SPA.
	  Any deviation may result in undefined behavior.
 1. turn link down: set SPA to 0 and wait CPA to 0 
 2. update SCF to select a properly audio clock
 4. turn link up: set SPA to 1 and wait CPA to 1 
 reduce dma latency to avoid noise 
 calculate runtime delay from LPIB 
 called from IRQ 
 bogus IRQ, process it later 
  Check whether the current DMA position is acceptable for updating
  periods.  Returns non-zero if it's OK.
  Many HD-audio controllers appear pretty inaccurate about
  the update-IRQ timing.  The IRQ is issued before actually the
  data is processed.  So, we need to process it afterwords in a
  workqueue.
  Returns 1 if OK to proceed, 0 for delay handling, -1 for skipping update
 bogus (too early) interrupt 
 use the position buffer as default 
 this shouldn't happen! 
 NG - it's below the first next period boundary 
 OK, no need to check period boundary 
 OK, already in hwptr updating process 
 check whether the period gets really elapsed 
 too early wakeup, process it later 
 OK, it's fine 
  The work for pending PCM period updates.
 too early 
 clear irq_pending flags and assure no on-going workq 
 get the current DMA position with correction on VIA chips 
 Playback, no problem using link position 
 Capture 
	 For new chipset,
	  use mod to get the DMA position just like old chipset
 Link position never gather than FIFO size 
 Find nearest previous boudary 
 Calculate real DMA position we want 
 get the current DMA position with FIFO size correction 
 correct the DMA position for capture stream 
 just read back the calculated value in the above 
 trigger power-save check at writing parameter 
  power management
 Read STATESTS before controller reset 
 Avoid codec resume if runtime resume is for system suspend 
 power down again for link-controlled chips 
	 HDA controller always requires different WAKEEN for runtime suspend
	  and system suspend, so don't use direct-complete here.
 put codec down to D3 at hibernation for Intel SKL+;
  otherwise BIOS may still access the codec and screw up the driver
 CONFIG_PM_SLEEP 
 enable controller wake up event 
 disable controller Wake Up event
 ELD notification gets broken when HD-audio bus is off 
 NOP 
 NOP 
 CONFIG_PM 
			 when we get suspended by vga_switcheroo we end up in D3cold,
			  however we have no ACPI handle, so pciacpi can't put us there,
  The discrete GPU cannot power down unless the HDA controller runtime
  suspends, so activate runtime PM on codecs even if power_save == 0.
 reset the power save setup 
		 cleared in either gpu_bound op or codec probe, or when its
		  upstream port has _PR3 (i.e. dGPU).
 NOP 
 NOP 
 SUPPORT_VGA_SWITCHER 
  destructor
 to be sure 
 ATPX is in the integrated GPU's namespace 
  Check of disabled HDMI controller by vga_switcheroo
 check only discrete GPU 
				 ATPX is in the integrated GPU's ACPI namespace
				  rather than the dGPU's namespace. However,
				  the dGPU is the one who is involved in
				  vgaswitcheroo.
 SUPPORT_VGA_SWITCHEROO 
  allowdeny-listing for position_fix
 Check VIAATI HD Audio Controller exist 
 combo mode uses LPIB only for playback 
  deny-lists for probe_mask
	 Thinkpad often breaks the controller communication when accessing
	  to the non-working (or non-existing) modem codec slot.
 broken BIOS 
 including bogus ALC268 in slot#2 that conflicts with ALC888 
 forced codec slots 
 WinFast VP200 H (Teradici) user reported broken communication 
 check forced option 
  allowdeny-list for enable_msi
 AMD Hudson 
 AMD Hudson 
 AMD Hudson 
 AMD Hudson 
 Athlon64 X2 + nvidia 
 nvidia 
 Athlon64 X2 + nvidia MCP55 
 AMD Hudson 
 Athlon64 X2 + nvidia 
 ICH6 
 enable MSI as default 
 NVidia chipsets seem to cause troubles with MSI 
 check the snoop mode availability 
		 force to non-snoop mode for a new VIA controller
		  when BIOS is set
 C-Media requires non-cached pages only for CORBRIRB 
 some exceptions: Atoms seem problematic with value 1 
 Baytrail 
 Braswell 
  constructor
 allow fallback to single_cmd at errors 
 explicitly set to single_cmd or not 
 use the non-cached pages in non-snoop mode 
 continue probing in work context as may trigger request module 
 Fix up base address on ULI M5461 
	
	  Some Intel CPUs has always running timer (ART) feature and
	  controller may have Global time sync reporting capability, so
	  check both of these before declaring synchronized time reporting
	  capability SNDRV_PCM_INFO_HAS_LINK_SYNCHRONIZED_ATIME
 AMD devices support 40 or 48bit DMA, take the safe one 
 disable SB600 64bit support for safety 
 NVidia hardware normally only supports up to 40 bits of DMA 
 disable 64bit DMA address on some devices 
 disable buffer size rounding to 128-byte multiples if supported 
 allow 64bit DMA address if supported by HW 
	 read number of streams from GCAP register instead of using
	  hardcoded value
 gcap didn't give any info, switching to old method 
 sanity check for the SDxCTL.STRM field overflow 
 initialize streams 
 initialize chip 
 codec detection 
 keep running the rest for the runtime PM 
 callback from request_firmware_nowait() 
 continue probing 
 Denylist for skipping the whole probe:
  some HD-audio PCI entries are exposed without any codecs, and such devices
  should be ignored from the beginning.
 ASUS ROG Zenith II  Strix 
 MSI TRX40 Creator 
 MSI TRX40 
	
	  stop probe if another Intel's DSP driver should be activated
 continued in azx_firmware_cb() 
 CONFIG_SND_HDA_PATCH_LOADER 
 On some boards setting power_save to a non 0 value leads to clicking 
  popping sounds when ever we enterleave powersaving mode. Ideally we would
  figure out how to avoid these sounds, but that is not always feasible.
  So we keep a list of devices where we disable powersaving as its known
  to causes problems on these devices.
bugzilla.redhat.comshow_bug.cgi?id=1525104 
bugzilla.redhat.comshow_bug.cgi?id=1525104 
bugzilla.redhat.comshow_bug.cgi?id=1525104 
bugzilla.redhat.comshow_bug.cgi?id=1525104 
bugzilla.redhat.comshow_bug.cgi?id=1525104 
bugzilla.redhat.comshow_bug.cgi?id=1525104 
 Note the P55A-UD3 and Z87-D3HP share the subsys id for the HDA dev 
bugzilla.redhat.comshow_bug.cgi?id=1525104 
bugzilla.kernel.orgshow_bug.cgi?id=199607 
bugs.launchpad.netbugs1821663 
bugzilla.redhat.comshow_bug.cgi?id=1520902 
bugzilla.kernel.orgshow_bug.cgi?id=198611 
bugzilla.redhat.comshow_bug.cgi?id=1689623 
bugzilla.redhat.comshow_bug.cgi?id=1572975 
bugs.launchpad.netbugs1821663 
 CONFIG_PM 
 CONFIG_PM 
 number of codec slots for each chipset: 0 = default slots (i.e. 4) 
 bind with i915 if needed 
			 if the controller is bound only with HDMIDP
			  (for HSW and BDW), we need to abort the probe;
			  for other chips, still continue probing as other
			  codecs can be on the same link.
 don't bother any longer 
 HSWBDW controllers need this power 
	 Request display power well for the HDA controller or codec. For
	  HaswellBroadwell, both the display HDA controller and codec need
	  this power. For other platforms, like BaytrailBraswell, only the
	  display codec needs the power and it can be released after probe.
 create codec instances 
 no longer needed 
 keep things up 
 cancel the pending probing work 
		 FIXME: below is an ugly workaround.
		  Both device_release_driver() and driver_probe_device()
		  take both the device's and its parent's lock before
		  calling the remove() and probe() callbacks.  The codec
		  probe takes the locks of both the codec itself and its
		  parent, i.e. the PCI controller dev.  Meanwhile, when
		  the PCI controller is unbound, it takes its lock, too
		  ==> ouch, a deadlock!
		  As a workaround, we unlock temporarily here the controller
		  device during cancel_work_sync() call.
 PCI IDs 
 CPT 
 PBG 
 Panther Point 
 Lynx Point 
 9 Series 
 Wellsburg 
 Lewisburg 
 Lynx Point-LP 
 Lynx Point-LP 
 Wildcat Point-LP 
 Sunrise Point 
 Sunrise Point-LP 
 Kabylake 
 Kabylake-LP 
 Kabylake-H 
 Coffelake 
 Cannonlake 
 CometLake-LP 
 CometLake-H 
 CometLake-S 
 CometLake-R 
 Icelake 
 Icelake-H 
 Jasperlake 
 Tigerlake 
 Tigerlake-H 
 DG1 
 Alderlake-S 
 Alderlake-P 
 Alderlake-M 
 Elkhart Lake 
 Broxton-P(Apollolake) 
 Broxton-T 
 Gemini-Lake 
 Haswell 
 Broadwell 
 5 Series3400 
 Poulsbo 
 Oaktrail 
 BayTrail 
 Braswell 
 ICH6 
 ICH7 
 ESB2 
 ICH8 
 ICH9 
 ICH9 
 ICH10 
 ICH10 
 Generic Intel 
 ATI SB 450600700800900 
 AMD Hudson 
 AMD, X370 & co 
 AMD, X570 & co 
 AMD Stoney 
 AMD Raven 
 ATI HDMI 
 VIA VT8251VT8237A 
 VIA GFX VT7122VX900 
 VIA GFX VT6122VX11 
 SIS966 
 ULI M5461 
 NVIDIA MCP 
 Teradici 
 Creative X-Fi (CA0110-IBG) 
 CTHDA chips 
	 the following entry conflicts with snd-ctxfi driver,
	  as ctxfi driver mutates from HD-audio to native mode with
	  a special command sequence.
 this entry seems still valid -- i.e. without emu20kx chip 
 CM8888 
 Vortex86MX 
 VMware HDAudio 
 AMDATI Generic, PCI class code and Vendor ID for HD Audio 
 Zhaoxin 
 pci_driver definition 
 SPDX-License-Identifier: GPL-2.0+
  Digital Beep Input Interface for HD-audio codec
  Author: Matt Ranostay <matt.ranostay@konsulko.com>
  Copyright (c) 2008 Embedded Alley Solutions Inc
 46.875 Hz 
 93.750 Hz 
 12 KHz 
 generate or stop tone 
 (non-standard) Linear beep tone calculation for IDTSTAC codecs 
  The tone frequency of beep generator on IDTSTAC codecs is
  defined from the 8bit tone parameter, in Hz,
     freq = 48000  (257 - tone)  1024
  that is from 12kHz to 93.75Hz in steps of 46.875 Hz
 fixed point 
 round to nearest step 
 turn off PC beep
 max frequency 
 HD-audio standard beep tone parameter calculation
  The tone frequency in Hz is calculated as
    freq = 48000  (tone  4)
  from 47Hz to 12kHz
 disabled 
 schedule beep event 
 turn off beep 
  snd_hda_enable_beep_device - Turn onoff beep sound
  @codec: the HDA codec
  @enable: flag to turn onoff
  snd_hda_attach_beep_device - Attach a beep input device
  @codec: the HDA codec
  @nid: beep NID
  Attach a beep object to the given widget.  If beep hint is turned off
  explicitly or beep_mode of the codec is turned off, this doesn't nothing.
  Currently, only one beep device is allowed to each codec.
 disabled explicitly by hints 
 disabled by module option 
 enable linear scale 
 setup digital beep device 
  snd_hda_detach_beep_device - Detach the beep device
  @codec: the HDA codec
 getput callbacks for beep mute mixer switches 
  snd_hda_mixer_amp_switch_get_beep - Get callback for beep controls
  @kcontrol: ctl element
  @ucontrol: pointer to getstore the data
  snd_hda_mixer_amp_switch_put_beep - Put callback for beep controls
  @kcontrol: ctl element
  @ucontrol: pointer to getstore the data
 SPDX-License-Identifier: GPL-2.0-or-later
  HD audio interface patch for Cirrus Logic CS8409 HDA bridge chip
  Copyright (C) 2021 Cirrus Logic, Inc. and
                     Cirrus Logic International Semiconductor Ltd.
                         CS8409 Specific Functions
 keep the ADCs powered up when it's dynamically switchable 
  cs8409_enable_i2c_clock - Disable I2C clocks
  @codec: the codec instance
  Disable I2C clocks.
  This must be called when the i2c mutex is unlocked.
  cs8409_disable_i2c_clock_worker - Worker that disable the I2C Clock after 25ms without use
  cs8409_enable_i2c_clock - Enable I2C clocks
  @codec: the codec instance
  Enable I2C clocks.
  This must be called when the i2c mutex is locked.
	 Cancel the disable timer, but do not wait for any running disable functions to finish.
	  If the disable timer runs out before cancel, the delayed work thread will be blocked,
	  waiting for the mutex to become unlocked. This mutex will be locked for the duration of
	  any i2c transaction, so the disable function will run to completion immediately
	  afterwards in the scenario. The next enable call will re-enable the clock, regardless.
  cs8409_i2c_wait_complete - Wait for I2C transaction
  @codec: the codec instance
  Wait for I2C transaction to complete.
  Return -ETIMEDOUT if transaction wait times out.
  cs8409_set_i2c_dev_addr - Set i2c address for transaction
  @codec: the codec instance
  @addr: I2C Address
  cs8409_i2c_set_page - CS8409 I2C set page register.
  @scodec: the codec instance
  @i2c_reg: Page register
  Returns negative on error.
  cs8409_i2c_read - CS8409 I2C Read.
  @scodec: the codec instance
  @addr: Register to read
  Returns negative on error, otherwise returns read value in bits 0-7.
 Register in bits 15-8 and the data in 7-0 
  cs8409_i2c_bulk_read - CS8409 I2C Read Sequence.
  @scodec: the codec instance
  @seq: Register Sequence to read
  @count: Number of registeres to read
  Returns negative on error, values are read into value element of cs8409_i2c_param sequence.
  cs8409_i2c_write - CS8409 I2C Write.
  @scodec: the codec instance
  @addr: Register to write to
  @value: Data to write
  Returns negative on error, otherwise returns 0.
  cs8409_i2c_bulk_write - CS8409 I2C Write Sequence.
  @scodec: the codec instance
  @seq: Register Sequence to write
  @count: Number of registeres to write
  Returns negative on error.
 EnableDisable Unsolicited Response 
	 CS8409 is simple HDA bridge and intended to be used with a remote
	  companion codec. Most of inputoutput PIN(s) have only basic
	  capabilities. Receive and Transmit NID(s) have only OUTC and INC
	  capabilities and no presence detect capable (PDC) and call to
	  snd_hda_gen_build_controls() will mark them as non detectable
	  phantom jacks. However, a companion codec may be
	  connected to these pins which supports jack detect
	  capabilities. We have to override pin capabilities,
	  otherwise they will not be created as input devices.
                         CS42L42 Specific Functions
 Configure CS42L42 slave codec for jack autodetect 
 Clear WAKE# 
 Wait ~2.5ms 
 Set mode WAKE# output follows the combination logic directly 
 Clear interrupts status 
 Enable interrupt 
 Enable and run CS42L42 slave codec jack auto detect 
 Clear interrupts 
 Wait ~100us
 TIP_SENSE INSERTREMOVE 
 jack in transition 
 Read jack detect status registers 
 If status values are < 0, read error has occurred. 
 HSDET_AUTO_DONE 
 Disable HSDET_AUTO_DONE 
 Type 4 not supported	
 type = 3 has no mic 
 Configure the HSDET mode. 
 Enable the HPOUT ground clamp and configure the HP pull-down 
 Re-Enable Tip Sense Interrupt 
 Bring CS42L42 out of Reset 
 Initialize CS42L42 companion codec 
 Clear interrupts, by reading interrupt status registers 
 Power down CS42L42 ASPEQMIXHP 
 Put CS42L42 into Reset 
 Cancel i2c clock disable timer, and disable clock if left enabled 
                    BULLSEYE  WARLOCK  CYBORG Specific Functions
                                CS8409CS42L42
  In the case of CS8409 we do not have unsolicited events from NID's 0x24
  and 0x34 where hs mic and hp are connected. Companion codec CS42L42 will
  generate interrupt via gpio 4 to notify jack events. We have to overwrite
  generic snd_hda_jack_unsol_event(), read CS42L42 jack detect status registers
  and then notify status via generic snd_hda_jack_unsol_event() call.
	 jack_unsol_event() will be called every time gpio line changing state.
	  In this case gpio4 line goes up as a result of reading interrupt status
	  registers in previous cs8409_jack_unsol_event() call.
	  We don't need to handle this event, ignoring...
 Report jack
 Report jack
 Manage PDREF, when transition to D3hot 
 Cancel i2c clock disable timer, and disable clock if left enabled 
 Vendor specific HW configuration
  PLL, ASP, I2C, SPI, GPIOs, DMIC etc...
 DMIC1_MO=00b, DMIC12_SR=1 
 Enable Unsolicited Response 
	 CS8409 pins have no AC_PINSENSE_PRESENCE
	  capabilities. We have to intercept 2 calls for pins 0x24 and 0x34
	  and return correct pin sense values for read_pin_sense() call from
	  hda_jack based on CS42L42 jack detect status.
 verb exec op override 
 GPIO 5 out, 3,4 in 
 Basic initial sequence for specific hw configuration 
		 Set TIP_SENSE_EN for analog front-end of tip sense.
		  Additionally set HSBIAS_SENSE_EN and Full Scale volume for some variants.
 Fix Sample Rate to 48kHz 
 add hooks 
 Set initial DMIC volume to -26 dB 
 Disable Unsolicited Response during boot 
		 Run jack auto detect first time on boot
		  after controls have been added, to check if jack has
		  been already plugged in.
		  Run immediately after init.
                           Dolphin Specific Functions
                                CS8409 2 X CS42L42
  In the case of CS8409 we do not have unsolicited events when
  hs mic and hp are connected. Companion codec CS42L42 will
  generate interrupt via irq_mask to notify jack events. We have to overwrite
  generic snd_hda_jack_unsol_event(), read CS42L42 jack detect status registers
  and then notify status via generic snd_hda_jack_unsol_event() call.
 Vendor specific HW configuration
  PLL, ASP, I2C, SPI, GPIOs, DMIC etc...
 Enable Unsolicited Response 
	 CS8409 pins have no AC_PINSENSE_PRESENCE
	  capabilities. We have to intercept calls for CS42L42 pins
	  and return correct pin sense values for read_pin_sense() call from
	  hda_jack based on CS42L42 jack detect status.
 verb exec op override 
 GPIO 1,5 out, 0,4 in 
 Basic initial sequence for specific hw configuration 
 Fix Sample Rate to 48kHz 
 add hooks 
 Update Line Out kcontrol template 
		 Run jack auto detect first time on boot
		  after controls have been added, to check if jack has
		  been already plugged in.
		  Run immediately after init.
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
  HD audio interface patch for Cirrus Logic CS420x chip
  Copyright (c) 2009 Takashi Iwai <tiwai@suse.de>
 EAPD GPIO bit for headphones 
 EAPD GPIO bit for speakers 
 CS421x 
 for MBP SPDIF control 
 available models with CS420x 
 aliases 
 CS421x boards 
 Vendor-specific processing widget 
 coef indices 
 SZC bitmask, 4 modes below:
  0 = immediate,
  1 = digital immediate, analog zero-cross
  2 = digtail & analog soft-ramp
  3 = digital soft-ramp, analog zero-cross
 SZC setup for mic 
 SZC setup for line-in 
 PGA mode: 0 = differential, 1 = signle-ended 
 PGA setup for mic 
 PGA setup for line-in 
 SZC bitmask, 4 modes below:
  0 = Immediate
  1 = zero-cross
  2 = soft-ramp
  3 = soft-ramp on zero-cross
 nid 0x02 
 nid 0x03 
 nid 0x04 
 0x0008 - test reg key 
 0x0009 - 0x0014 -> 12 test regs 
 0x0015 - visibility reg 
 Cirrus Logic CS4208 
  Cirrus Logic CS4210
  1 DAC => HP(sense)  Speakers,
  1 ADC <= LineIn(sense)  MicIn  DMicIn,
  1 SPDIF OUT => SPDIF Trasmitter(sense)
 Port E 
 Port H 
 Cirrus Logic CS4213 is like CS4210 but does not have SPDIF inputoutput 
  auto-mute and auto-mic switching
  CS421x auto-output redirecting
  HPSPKSPDIF
 mute HPs if spdif jack (SENSE_B) is present 
 CS420x has multiple ADC, CS421x has single ADC 
 DMIC2 2 chan on, GPIO1 off 
			coef |= 1 << 3;  DMIC1 2 chan on, GPIO0 off
					  No effect if SPDIF_OUT2 is
					  selected in IDX_SPDIF_CTL.
 DAC123 SZCMode Soft Ramp 
 Mute DACs on FIFO error 
 Enable DACs High Pass Filter 
 Disable Coefficient Auto increment 
 ADC12 - Digital and Analog Soft Ramp 
 Beep 
 Enable Beep thru DAC123 
 terminator 
 AFG: D0 
 VPW: processing on 
 A1 ICS 
 A1 Enable, A Thresh = 300mV 
 terminator 
 Errata: CS4207 rev C0C1C2 Silicon
  http:www.cirrus.comenpubserrataER880C3.pdf
  6. At high temperature (TA > +85C), the digital supply current (IVD)
  may be excessive (up to an additional 200 A), which is most easily
  observed while the part is being held in reset (RESET# active low).
  Root Cause: At initial powerup of the device, the logic that drives
  the clock and write enable to the SPDIF SRC RAMs is not properly
  initialized.
  Certain random patterns will cause a steady leakage current in those
  RAM cells. The issue will resolve once the SRCs are used (turned on).
  Workaround: The following verb sequence briefly turns on the SPDIF SRC
  blocks, which will alleviate the issue.
 AFG: D0 
 VPW: processing on 
 SPDIF Rx: D0 
 SPDIF Tx: D0 
 terminator 
 SPDIF setup 
 SRC_MUTE soft-mute on SPDIF (if no lock) 
 Replace with mute on error 
		coef |= 0x4000;  RX to TX1 or TX2 Loopthru  SPDIF2
				  SPDIF_OUT2 is shared with GPIO1 and
				  DMIC_SDA2.
 init_verb sequence for C0C1C2 errata
 keep the ADCs powered up when it's dynamically switchable 
 this conflicts with too many other models 
SND_PCI_QUIRK(0x8086, 0x7270, "IMac 27 Inch", CS420X_IMAC27),
 codec SSID 
 terminator 
 terminator 
 terminator 
 terminator 
 terminator 
 HP 
 speaker 
 mic 
 terminator 
 HP 
 Speaker 
 Mic 
 terminator 
 GPIO1 = headphones 
 GPIO3 = speakers 
 GPIO2 = headphones 
 GPIO3 = speakers 
 internal mic ADC2: right only, single ended 
  CS4208 support:
  Its layout is no longer compatible with CS4206CS4207
 terminator 
 codec SSID matching 
 terminator 
 remap the fixup from codec SSID and apply it 
 default fixup 
 MacMini 7,1 has the inverted jack detection 
 mic (audio-in) jack: disable detect 
 SPDIF: disable detect 
 HP pin (0x10) has an inverted detection 
 disable the bogus Mic and SPDIF jack detections 
 hook the SPDIF switch 
 correct the 0dB offset of input pins 
 exclude NID 0x10 (HP) from output volumes due to different steps 
  Cirrus Logic CS4210
  1 DAC => HP(sense)  Speakers,
  1 ADC <= LineIn(sense)  MicIn  DMicIn,
  1 SPDIF OUT => SPDIF Trasmitter(sense)
 CS4210 board names 
 Test Intel board + CDB2410  
 terminator 
 CS4210 board pinconfigs 
 Default CS4210 (CDB4210)
 terminator 
 Stumpy ChromeBox 
 terminator 
 Setup GPIOSENSE for each board (if used) 
	
	   Disable Coefficient Index Auto-Increment(DAI)=1,
	   PDREF=0
 ADC SZCMode = Digital Soft Ramp 
 DAC SZCMode = Digital Soft Ramp 
 Mute DAC on FIFO error 
 Enable DAC High Pass Filter 
 terminator 
 Errata: CS4210 rev A1 Silicon
  http:www.cirrus.comenpubserrata
  Description:
  1. Performance degredation is present in the ADC.
  2. Speaker output is not completely muted upon HP detect.
  3. Noise is present when clipping occurs on the amplified
     speaker outputs.
  Workaround:
  The following verb sequence written to the registers during
  initialization will correct the issues listed above.
 VPW: processing on 
 Test mode: on 
 Chop double 
 Increase ADC current 
 Mute speaker 
 Remove noise 
 terminator 
 Speaker Amp Gain is controlled by the vendor widget's coef 4 
 GPIO, DMIC_SCL, DMIC_SDA and SENSE_B are multiplexed 
 B1,B2 are GPIOs 
 B2 is SENSE_B, not inverted  
		
		   GPIO or SENSE_B forced - disconnect the DMIC pin.
 detect on spdif is specific to CS4210 
 SPDIF TX onoff 
 set the upper-limit for mixer amp to 0dB 
 	Manage PDREF, when transitioning to D3hot
 	(DAC,ADC) -> D3, PDREF=1, AFG->D3
 PDREF 
	
	   Update the GPIODMICSENSE_B pinmux before the configuration
	    is auto-parsed. If GPIO or SENSE_B is forced, DMIC input
	    is disabled.
  patch entries
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
  Universal Interface for Intel High Definition Audio Codec
  Generic widget tree parser
  Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>
  snd_hda_gen_spec_init - initialize hda_gen_spec struct
  @spec: hda_gen_spec object to initialize
  Initialize the given hda_gen_spec object.
  snd_hda_gen_add_kctl - Add a new kctl_new struct from the template
  @spec: hda_gen_spec object
  @name: name string to override the template, NULL if unchanged
  @temp: template for the new kctl
  Add a new kctl (actually snd_kcontrol_new to be instantiated later)
  element based on the given snd_kcontrol_new template @temp and the
  name string @name to the list in @spec.
  Returns the newly created object or NULL as error.
  store user hints
 the following two are just for compatibility 
  pin control value accesses
 restore the pinctl based on the cached value 
 set the pinctl target value and write it if requested 
 set pinctl target values for all given pins 
  parsing paths
 return the position of NID in the list, or -1 if not found 
 return true if the given NID is contained in the path 
  snd_hda_get_path_idx - get the index number corresponding to the path
  instance
  @codec: the HDA codec
  @path: nid_path object
  The returned index starts from 1, i.e. the actual array index with offset 1,
  and zero is handled as an invalid path
  snd_hda_get_path_from_idx - get the path instance corresponding to the
  given index number
  @codec: the HDA codec
  @idx: the path index
 check whether the given DAC is already found in any existing paths 
 check whether the given two widgets can be connected 
 nid, dir and idx 
 check whether the given ctl is already assigned in any path elements 
 check whether a control with the given (nid, dir, idx) was assigned 
 called recursively 
 anchor passed 
 hit the exclusive nid 
			 special case: when from_nid is 0,
			  try to find an empty DAC
 anchor is not requested or already passed? 
  snd_hda_parse_nid_path - parse the widget path from the given nid to
  the target nid
  @codec: the HDA codec
  @from_nid: the NID where the path start from
  @to_nid: the NID where the path ends at
  @anchor_nid: the anchor indication
  @path: the path object to store the result
  Returns true if a matching path is found.
  The parsing behavior depends on parameters:
  when @from_nid is 0, try to find an empty DAC;
  when @anchor_nid is set to a positive value, only paths through the widget
  with the given value are evaluated.
  when @anchor_nid is set to a negative value, paths through the widget
  with the negative of given value are excluded, only other paths are chosen.
  when @anchor_nid is zero, no special handling about path selection.
  snd_hda_add_new_path - parse the path between the given NIDs and
  add to the path list
  @codec: the HDA codec
  @from_nid: the NID where the path start from
  @to_nid: the NID where the path ends at
  @anchor_nid: the anchor indication, see snd_hda_parse_nid_path()
  If no valid path is found, returns NULL.
 check whether the path has been already added 
 push back 
 clear the given path as invalid so that it won't be picked up later 
 return a DAC if paired to the given pin by codec driver 
 look for an empty DAC slot 
 replace the channels in the composed amp value with the given number 
 look for a widget suitable for assigning a mute switch in the path 
 look for a widget suitable for assigning a volume ctl in the path 
  path activation  deactivation
 can have the amp-in capability? 
 only for input pins 
 can have the amp-out capability? 
 only for output pins 
 check whether the given (nid,dir,idx) is active 
 ignore unplugged paths except for DACADC 
 check whether the NID is referred by any active paths 
 get the default amp value for the target state 
 set to 0dB 
 is this a stereo widget or a stereo-to-mono mix? 
 initialize the amp value (only at the first time) 
 update the amp, doing in stereo or mono depending on NID 
 calculate amp value mask we can modify;
  if the given amp is controlled by mixers, don't touch it
 check whether the given amp is still used by others 
	 here is a little bit tricky in comparison with activate_amp_out();
	  when aa-mixer is available, we need to enable the path as well
 when aamix is disabled, force to off 
 sync power of each widget in the given path 
			 all known codecs seem to be capable to handl
			  widgets state even in D3, so far.
			  if any new codecs need to restore the widget
			  states after D0 transition, call the function
			  below.
 disabled 
 do sync with the last power state change 
  snd_hda_activate_path - activate or deactivate the given path
  @codec: the HDA codec
  @path: the path to activatedeactivate
  @enable: flag to activate or not
  @add_aamix: enable the input from aamix NID
  If @add_aamix is set, enable the input from aa-mix NID as well (if any).
 make sure the widget is powered up 
 if the given path is inactive, put widgets into D3 (only if suitable) 
 turn onoff EAPD on the given pin 
 re-initialize the path specified by the given path index 
  Helper functions for creating mixer ctl elements
 only the put callback is replaced for handling the special mute 
 replaced 
 replaced 
 add dynamic controls from template 
 return the channel bits suitable for the given path->ctls[] 
 mono (left only) 
 stereo 
 create a mute-switch for the given mixer widget;
  if it has multiple sources (e.g. DAC and loopback), create a bind-mute
 playback mute control with the software mute bit check 
  Bound mute controls
 index 0 
 any ctl assigned to the path with the given index? 
 give some appropriate ctl name prefix for the given line out channel 
	 if there is really a single DAC used in the whole output paths,
	  use it master (or "PCM" if a vmaster hook is present)
 multi-io channels 
		 if the primary channel volmute is shared with HP volume,
		  don't name it as Speaker
		 if the primary channel volmute is shared with spk volume,
		  don't name it as Headphone
 for multi-io case, only the primary out 
		 This deals with the case where one HP or one Speaker or
		  one HP + one Speaker need to share the DAC with LO
 for a single channel output, we don't have to name the channel 
  Parse output paths
 badness definition 
 No primary DAC is found for the main output 
 No DAC is found for the extra output 
 No possible multi-ios 
 No individual DAC for extra output 
 No individual DAC for extra surrounds 
 Primary DAC shared with main surrounds 
 No independent HP possible 
 Primary DAC shared with main CLFE 
 Primary DAC shared with extra surrounds 
 Volume widget is shared 
 look for widgets in the given path which are appropriate for
  volume and mute controls, and assign the values to ctls[].
  When no appropriate widget is found in the path, the badness value
  is incremented depending on the situation.  The function returns the
  total badness for both volume and mute controls.
 already evaluated 
 get the DAC of the primary output corresponding to the given array index 
 return the DAC if it's reachable, otherwise zero 
 try to assign DACs to pins and return the resultant badness 
 try to steal the DAC of surrounds for the front 
 try with aamix 
 print_nid_path(codec, "output", path); 
 return NID if the given pin has only a single connection to a certain DAC 
 check whether the given pin can be a multi-io pin 
 count the number of input pins that are capable to be multi-io 
  multi-io helper
  When hardwired is set, try to fill ony hardwired pins, and returns
  zero if any pins are filled, non-zero if nothing found.
  When hardwired is off, try to fill possible input pins, and returns
  the badness value.
 print_nid_path(codec, "multiio", path); 
 nothing found 
 no badness if nothing found 
 cancel newly assigned paths 
 assign volume and mute controls 
 map DACs for all pins in the list if they are single connections 
 print_nid_path(codec, "output", path); 
 create a new path including aamix if available, and return its index 
 print_nid_path(codec, "output-aamix", path); 
 unused as default 
 static route 
 check whether the independent HP is available with the current config 
 assume no path conflicts unless aamix is involved 
 check whether output paths contain aamix 
 fill the empty entries in the dac array for speakerhp with the
  shared dac pointed by the paths
 fill in the dac_nids table from the parsed pin configuration 
 set num_dacs once to full for look_for_dac() 
 clear path indices 
 fill hard-wired DACs first 
 try to fill multi-io first 
 we don't count badness at this stage yet 
 give badness 
 re-count num_dacs and squash invalid entries 
 re-fill the shared DAC for speaker  headphone 
 NOP 
 find all available DACs of the codec 
 set initial pinctl targets 
 clear indep_hp flag if not available 
 add playback controls from the parsed DAC table 
 CenterLFE 
 add playback controls for speaker and HP outputs 
  independent HP controls
 update HP aamix paths in case it conflicts with indep HP 
  channel mode enum control
 Default value to be passed as aamix argument for snd_hda_activate_path();
  used for output paths
 update jack retasking in case it modifies any of them 
  aamix loopback enabledisable switch
	 if HP aamix path is driven from a different DAC and the
	  independent HP mode is ON, can't turn on aamix path
 re-initialize the output paths; only called from loopback_mixing_put() 
  shared headphonemic handling
 for shared IO, change the pin-control accordingly 
	 if the HP pin doesn't support VREF and the codec driver gives an
	  alternative pin, set up the VREF on that pin instead
 create a shared input with the headphone out 
		 automatic detection: only if no input or a single internal
		  input pin is found, try to detect the shared hpmic
 clear once 
 no input 
 we can't handle auto-mic together with HP-mic 
  output jack mode
  input jack mode
 from AC_PINCTL_VREF_HIZ to AC_PINCTL_VREF_100 
 filter out unusual vrefs 
 convert from the enum item index to the vref ctl index (0=HIZ, 1=50%...) 
 convert back from the vref ctl index to the enum item index 
 set the right text 
 already done in create_out_jack_mode() 
 no jack mode for fixed pins 
 no multiple vref caps? 
  HPmic shared jack mode
  Parse input paths
 add the powersave loopback-list entry 
 return true if either a volume or a mute amp is found for the given
  aamix path; the amp has to be either in the mixer node or its direct leaf
 check leaf node 
 create input playbackcapture controls for the given pin 
 no DACADC involved 
 static route 
 no DACADC involved 
 Parse the codec tree and retrieve ADCs 
 copy the detected ADCs to all_adcs[] 
 filter out invalid adc_nids that don't give all active input pins;
  if needed, check whether dynamic ADC-switching is available
 check whether ADC-switch is possible 
 shrink the invalid adcs and input paths 
 reduce to a single ADC 
 single index for individual volumes ctls 
 parse capture source paths from the given pin and create imux items 
  create playbackcapture controls for input pins
 fill the label for each input at first 
 a dummy cfg->input idx for stereo mix 
 add stereo mix when explicitly enabled via hint 
  input source mux
 get the input path specified by the given adc and imux indices 
 the ctls are created at once with multiple counts 
  capture volume and capture switch ctls
 call the given amp update function for all amps in the imux list at once 
 capture volume ctl callbacks 
 capture switch ctl callbacks 
 capture switch put callback for a single control with hook call 
 Make independent right kcontrol 
 create single (and simple) capture volume and switch controls 
 create bound capture volume and switch controls 
 return the vol ctl when used first in the imux list 
 create individual capture volume and switch controls per input 
  add mic boosts if needed
 check whether the given amp is feasible as a boost volume 
 look for a boost amp in a widget close to the pin 
 check only line-in and mic pins 
 create a boost control 
  vmaster mute LED hook helpers
  snd_hda_gen_add_mute_led_cdev - Create a LED classdev and enable as vmaster mute LED
  @codec: the HDA codec
  @callback: the callback for LED classdev brightness_set_blocking
  snd_hda_gen_add_micmute_led_cdev - Create a LED classdev and enable as mic-mute LED
  @codec: the HDA codec
  @callback: the callback for LED classdev brightness_set_blocking
  Called from the codec drivers for offering the mic mute LED controls.
  This creates a LED classdev and sets up the cap_sync_hook that is called at
  each time when the capture mixer switch changes.
  When NULL is passed to @callback, no classdev is created but only the
  LED-trigger is set up.
  Returns 0 or a negative error.
 CONFIG_SND_HDA_GENERIC_LEDS 
  parse digital IOs and set up NIDs in BIOS auto-parse mode
 support multiple SPDIFs; the secondary is set up as a follower 
 no jack detection 
 no jack 
  input MUX handling
 select the given imux item; either unmute exclusively or select the route 
 power updown widgets in the all paths that match with the given NID
  as terminals (either start- or endpoint)
  returns the last changed NID, or zero if unchanged.
 check the jack status for power control 
 power updown the paths of the given pin according to the jack state;
  power = 01 : only power updown if it matches with the jack state,
        < 0   : force power updown to follow the jack sate
  returns the last changed NID, or zero if unchanged.
 callback only doing power up -- called at first 
 callback only doing power down -- called at last 
 set up the power updown callbacks 
 enabled power callback to each available IO pin with jack detections;
  the digital IO pins are excluded because of the unreliable detectsion
 sync path power updown with the jack states of given pins 
 sync path power updown with pins; called at init and resume 
 add fake paths if not present yet 
 create fake paths to all outputs from beep 
 power updown beep widget and its output paths 
  snd_hda_gen_fix_pin_power - Fix the power of the given pin widget to D0
  @codec: the HDA codec
  @pin: NID of pin to fix
  Jack detections for HP auto-mute and mic-switch
 check each pin in the given array; returns true if any of them is plugged 
 don't detect pins retasked as inputs 
 standard HPline-out auto-mute helper 
 no mute for inputs 
			 don't reset VREF value in case it's controlling
			  the amp (see alc861_fixup_asus_amp_vref_0f())
			 here we call update_pin_ctl() so that the pinctl is
			  changed without changing the pinctl target value;
			  the original target value will be still referred at
			  the init  resume again
  snd_hda_gen_update_outputs - Toggle outputs muting
  @codec: the HDA codec
  Update the mute status of all outputs based on the current jack states.
	 Control HP pinsamps depending on master_mute state;
	  in general, HP pinsamps control should be enabled in all cases,
	  but currently set only for master_mute, just to be safe
 toggle line-out mutes if needed, too 
 if LO is a copy of either HP or Speaker, don't need to handle it 
 sync the whole vmaster followers to reflect the new auto-mute status 
  snd_hda_gen_hp_automute - standard HP-automute helper
  @codec: the HDA codec
  @jack: jack object, NULL for the whole
 No detection for the first HP jack during indep-HP mode 
  snd_hda_gen_line_automute - standard line-out-automute helper
  @codec: the HDA codec
  @jack: jack object, NULL for the whole
 check LO jack only when it's different from HP 
  snd_hda_gen_mic_autoswitch - standard mic auto-switch helper
  @codec: the HDA codec
  @jack: jack object, NULL for the whole
 don't detect pins retasked as outputs 
 call appropriate hooks 
 update jack retasking 
  Auto-Mute mode mixer enum support
  Check the availability of HPline-out auto-mute;
  Set up appropriately if really supported
 need two different output types 
 create a control for automute mode 
 check whether all auto-mic pins are valid; setup indices if OK 
 no corresponding imux 
 we don't need the jack detection for the first pin 
  Check the availability of auto-mic switch;
  Set up if really supported
 already occupied 
 invalid type 
 invalid entry 
 invalid type 
 only mic is allowed 
 no unsol support 
	 sort the am_entry in the order of attr so that the pin with a
	  higher attr will be selected when the jack is plugged.
  snd_hda_gen_path_power_filter - power_filter hook to make inactive widgets
  into power down
  @codec: the HDA codec
  @nid: NID to evalute
  @power_state: target power state
 mute all aamix inputs initially; parse up to the first leaves 
  snd_hda_gen_stream_pm - Stream power management callback
  @codec: the HDA codec
  @nid: audio widget
  @on: power onoff flag
  Set this in patch_ops.stream_pm.  Only valid with power_save_node flag.
  snd_hda_gen_parse_auto_config - Parse the given BIOS configuration and
  set up the hda_gen_spec
  @codec: the HDA codec
  @cfg: Parsed pin configuration
  return 1 if successful, 0 if the proper config is not found,
  or a negative error code
 can't find valid BIOS pin config 
 use HP as primary out 
 add power-down pin callbacks at first 
 check the multiple speaker and headphone pins 
 add stereo mix if available and not enabled yet 
	 create "Headphone Mic Jack Mode" if no input selection is
	  available (or user specifies add_jack_modes hint)
 add power-up pin callbacks at last 
 mute all aamix input initially 
  Build control elements
 follower controls for virtual master 
  snd_hda_gen_build_controls - Build controls from the parsed results
  @codec: the HDA codec
  Pass this to build_controls patch_ops.
 if we have no master control, let's create it 
 no longer needed 
  PCM definitions
  Analog playback callbacks
  Digital out
  Analog capture
 NID is set in build_pcms 
 NID is set in build_pcms 
 NID is set in build_pcms 
 can be overridden 
 NID is set in build_pcms 
 NID is set in build_pcms 
 NID is set in build_pcms 
 Used by build_pcms to flag that a PCM has no playback stream 
  dynamic changing ADC PCM streams
 stream is running, let's swap the current ADC 
 analog capture with dynamic dual-adc changes 
 fill later 
 drop non-alnum chars after a space 
 copy PCM stream info from @default_str, and override non-NULL entries
  from @spec_str and @nid
  snd_hda_gen_build_pcms - build PCM streams based on the parsed results
  @codec: the HDA codec
  Pass this to build_pcms patch_ops.
 SPDIF for stream index #1 
	 If the use of more than one ADC is requested for the current
	  model, configure a second analog capture-only PCM.
 Additional Analaog capture for index #2 
  Standard auto-parser initializations
 configure the given path as a proper output 
 initialize primary output paths 
 initialize hp and speaker paths 
 initialize multi-io paths 
 set up input pins and loopback paths 
 init loopback inputs 
 initialize ADC paths 
 set right pin controls for digital IO 
 clear unsol-event tags on unused pins; Conexant codecs seem to leave
  invalid unsol tags by some reason
  snd_hda_gen_init - initialize the generic spec
  @codec: the HDA codec
  This can be put as patch_ops init function.
 call init functions of standard auto-mute helpers 
  snd_hda_gen_free - free the generic spec
  @codec: the HDA codec
  This can be put as patch_ops free function.
  snd_hda_gen_check_power_status - check the loopback power save state
  @codec: the HDA codec
  @nid: NID to inspect
  This can be put as patch_ops check_power_status function.
  the generic codec support
  snd_hda_parse_generic_codec - Generic codec parser
  @codec: the HDA codec
 terminator 
 SPDX-License-Identifier: GPL-2.0-only
  patch_cs8409-tables.c  --  HD audio interface patch for Cirrus Logic CS8409 HDA bridge chip
  Copyright (C) 2021 Cirrus Logic, Inc. and
                     Cirrus Logic International Semiconductor Ltd.
  Author: Lucas Tanure <tanureal@opensource.cirrus.com>
                           CS42L42 Specific Data
 fixed rate 
 fixed rate 
                    BULLSEYE  WARLOCK  CYBORG Specific Arrays
                                CS8409CS42L42
 WAKE from GPIO 3,4 
 Enable VPW processing 
 Configure GPIO 6,7 
 I2C mode 
 Set I2C bus speed 
 100kHz I2C_STO = 2 
 terminator 
 ASP-1-TX 
 ASP-1-RX 
 ASP-2-TX 
 DMIC-1 
 terminator 
 Vendor specific HW configuration for CS42L42 
 Vendor specific hw configuration for CS8409 
 +PLL12_EN, +I2C_EN 
 ASP12_EN=0, ASP1_STP=1 
 ASP12_BUS_IDLE=10, +GPIO_I2C 
 ASP1.A: TX.LAP=0, TX.LSZ=24 bits, TX.LCS=0 
 ASP1.A: TX.RAP=0, TX.RSZ=24 bits, TX.RCS=32 
 ASP2.A: TX.LAP=0, TX.LSZ=24 bits, TX.LCS=0 
 ASP2.A: TX.RAP=1, TX.RSZ=24 bits, TX.RCS=0 
 ASP1.A: RX.LAP=0, RX.LSZ=24 bits, RX.LCS=0 
 ASP1.A: RX.RAP=0, RX.RSZ=24 bits, RX.RCS=0 
 ASP1: LCHI = 00h 
 ASP1: MCSC_SRCSEL=PLL1, LCPR=FFh 
 ASP1: MCEN=0, FSD=011, SCPOL_INOUT=0, SCDIV=1:4 
 ASP2: LCHI=1Fh 
 ASP2: MCSC_SRCSEL=PLL1, LCPR=3Fh 
 ASP2: 5050=1, MCEN=0, FSD=010, SCPOL_INOUT=1, SCDIV=1:16 
 DMIC1_MO=10b, DMIC12_SR=1 
 ASP12_BEEP=0 
 ASP12_EN=1, ASP1_STP=1 
 -PLL2_EN 
 TX2.A: pre-scale att.=0 dB 
 ASP12_xxx_EN=1, ASP12_MCLK_EN=0, DMIC1_SCL_EN=1 
 test mode on 
 GPIO hysteresis = 30 us 
 test mode off 
 Terminator 
 EQ_SEL=1, EQ12_EN=0 
 +EQ_ACC 
 +EQ2_EN 
 EQ_DATA_HI=0x0647 
 +EQ_WRT, +EQ_ACC, EQ_ADR=0, EQ_DATA_LO=0x67 
 EQ_DATA_HI=0x0647 
 +EQ_WRT, +EQ_ACC, EQ_ADR=1, EQ_DATA_LO=0x67 
 EQ_DATA_HI=0xf370 
 +EQ_WRT, +EQ_ACC, EQ_ADR=2, EQ_DATA_LO=0x71 
 EQ_DATA_HI=0x1ef8 
 +EQ_WRT, +EQ_ACC, EQ_ADR=3, EQ_DATA_LO=0x48 
 EQ_DATA_HI=0xc110 
 +EQ_WRT, +EQ_ACC, EQ_ADR=4, EQ_DATA_LO=0x5a 
 EQ_DATA_HI=0x1f29 
 +EQ_WRT, +EQ_ACC, EQ_ADR=5, EQ_DATA_LO=0x74 
 EQ_DATA_HI=0x1d7a 
 +EQ_WRT, +EQ_ACC, EQ_ADR=6, EQ_DATA_LO=0x53 
 EQ_DATA_HI=0xc38c 
 +EQ_WRT, +EQ_ACC, EQ_ADR=7, EQ_DATA_LO=0x14 
 EQ_DATA_HI=0x1ca3 
 +EQ_WRT, +EQ_ACC, EQ_ADR=8, EQ_DATA_LO=0xc7 
 EQ_DATA_HI=0xc38c 
 +EQ_WRT, +EQ_ACC, EQ_ADR=9, EQ_DATA_LO=0x14 
 -EQ_ACC, -EQ_WRT 
 Terminator 
                           Dolphin Specific Arrays
                             CS8409 2 X CS42L42
 WAKE from GPIO 0,4 
 Enable VPW processing  
 Configure GPIO 6,7 
 I2C mode 
 Set I2C bus speed 
 100kHz I2C_STO = 2 
 terminator 
 ASP-1-TX-A 
 ASP-1-TX-B 
 ASP-1-RX 
 terminator 
 Vendor specific HW configuration for CS42L42 
 Vendor specific hw configuration for CS8409 
 +PLL12_EN, +I2C_EN 
 ASP1_EN=0, ASP1_STP=1 
 ASP12_BUS_IDLE=10, +GPIO_I2C 
 ASP1.A: TX.LAP=0, TX.LSZ=24 bits, TX.LCS=0 
 ASP1.A: TX.RAP=0, TX.RSZ=24 bits, TX.RCS=32 
 ASP1.B: TX.LAP=0, TX.LSZ=24 bits, TX.LCS=128 
 ASP1.B: TX.RAP=0, TX.RSZ=24 bits, TX.RCS=160 
 ASP1.A: RX.LAP=0, RX.LSZ=24 bits, RX.LCS=0 
 ASP1.A: RX.RAP=0, RX.RSZ=24 bits, RX.RCS=0 
 ASP1: LCHI = 00h 
 ASP1: MCSC_SRCSEL=PLL1, LCPR=FFh 
 ASP1: MCEN=0, FSD=011, SCPOL_INOUT=0, SCDIV=1:4 
 ASP12_BEEP=0 
 ASP1_EN=1, ASP1_STP=1 
 -PLL2_EN 
 ASP1_xxx_EN=1, ASP1_MCLK_EN=0 
 test mode on 
 GPIO hysteresis = 30 us 
 test mode off 
 Terminator 
                          CS8409 Patch Driver Structs
                     Arrays Used for all projects using CS8409
 terminator 
 Dell Inspiron models with cs8409cs42l42 
 SPDX-License-Identifier: GPL-2.0-or-later
  BIOS auto-parser helper functions for HD-audio
  Copyright (c) 2012 Takashi Iwai <tiwai@suse.de>
  Helper for automatic pin configuration
 a pair of input pin and its sequence 
  Sort an associated group of pins according to their sequence numbers.
  then store it to a pin array.
 add the found input-pin to the cfg->inputs[] table 
 If has both hs_mic and hp_mic, pick the hs_mic ahead of hp_mic. 
 don't swap 
 swap 
	 In case one has boost and the other one has not,
 Reorder the surround channels
  ALSA sequence is frontsurrclfeside
  HDA sequence is:
     4-ch: frontsurr  =>  OK as it is
     6-ch: frontclfesurr
     8-ch: frontclferearside|fc
 check whether the given pin has a proper pin IO capability bit 
 some old hardware don't return the proper pincaps 
 Already assigned 
  Parse all pin widgets and store the useful pin nids to cfg
  The number of line-outs or any primary output is stored in line_outs,
  and the corresponding output pins are assigned to line_out_pins[],
  in the order of front, rear, CLFE, side, ...
  If more extra outputs (speaker and headphone) are found, the pins are
  assisnged to hp_pins[] and speaker_pins[], respectively.  If no line-out jack
  is detected, one of speaker of HP pins is assigned as the primary
  output, i.e. to line_out_pins[0].  So, line_outs is always positive
  if any analog output exists.
  The analog input pins are assigned to inputs array.
  The digital inputoutput pins are assigned to dig_in_pin and dig_out_pin,
  respectively.
 read all default configuration for pin complex 
 ignore the given nids (e.g. pc-beep returns error) 
 workaround for buggy BIOS setups 
 Find a pin that could be a headset or headphone mic 
 If we didn't find our sequence number mark, fall back to any sequence number 
	 FIX-UP:
	  If no line-out is defined but multiple HPs are found,
	  some of them might be the real line-outs.
 The real HPs should have the sequence 0x0f 
 Move it to the line-out table 
 sort by sequence 
	
	  FIX-UP: if no line-outs are detected, try to use speaker or HP pin
	  as a primary output
 sort inputs in the order of AUTO_PIN_ type 
	
	  debug prints of the parsed results
  snd_hda_get_input_pin_attr - Get the input pin attribute from pin config
  @def_conf: pin configuration value
  Guess the input pin attribute (INPUT_PIN_ATTR_XXX) from the given
  default pin configuration value.
 Windows may claim the internal mic to be BOTH, too 
  hda_get_input_pin_label - Give a label for the given input pin
  @codec: the HDA codec
  @item: ping config item to refer
  @pin: the pin NID
  @check_location: flag to add the jack location prefix
  When @check_location is true, the function checks the pin location
  for mic and line-in pins, and set an appropriate prefix like "Front",
  "Rear", "Internal".
 Check whether the location prefix needs to be added to the label.
  If all mic-jacks are in the same location (e.g. rear panel), we don't
  have to put "Front" prefix to each label.  In such a case, returns false.
 for internal or docking mics, we need locations 
 different locations found 
  hda_get_autocfg_input_label - Get a label for the given input
  @codec: the HDA codec
  @cfg: the parsed pin configuration
  @input: the input index number
  Get a label for the given input pin defined by the autocfg item.
  Unlike hda_get_input_pin_label(), this function checks all inputs
  defined in autocfg and avoids the redundant micline prefix as much as
  possible.
 return the position of NID in the list, or -1 if not found 
 get a unique suffix or an index number 
 check the location 
 handle as a speaker if it's a fixed line-out 
 try to give a unique suffix if needed 
 don't add channel suffix for Headphone controls 
  snd_hda_get_pin_label - Get a label for the given IO pin
  @codec: the HDA codec
  @nid: pin NID
  @cfg: the parsed pin configuration
  @label: the string buffer to store
  @maxlen: the max length of string buffer (including termination)
  @indexp: the pointer to return the index number (for multiple ctls)
  Get a label for the given pin.  This function works for both input and
  output pins.  When @cfg is given as non-NULL, the function tries to get
  an optimized label using hda_get_autocfg_input_label().
  This function tries to give a unique label string for the pin as much as
  possible.  For example, when the multiple line-outs are present, it adds
  the channel suffix like "Front", "Surround", etc (only when @cfg is given).
  If no unique name with a suffix is available and @indexp is non-NULL, the
  index number is stored in the pointer.
  snd_hda_add_verbs - Add verbs to the init list
  @codec: the HDA codec
  @list: zero-terminated verb list to add
  Append the given verb list to the execution list.  The verbs will be
  performed at init and resume time via snd_hda_apply_verbs().
  snd_hda_apply_verbs - Execute the init verb lists
  @codec: the HDA codec
  snd_hda_apply_pincfgs - Set each pin config in the given list
  @codec: the HDA codec
  @cfg: NULL-terminated pin config table
  snd_hda_apply_fixup - Apply the fixup chain with the given action
  @codec: the HDA codec
  @action: fixup action (HDA_FIXUP_ACT_XXX)
  snd_hda_pick_pin_fixup - Pick up a fixup matching with the pin quirk list
  @codec: the HDA codec
  @pin_quirk: zero-terminated pin quirk list
  @fixlist: the fixup list
  @match_all_pins: all valid pins must match with the table entries
  snd_hda_pick_fixup - Pick up a fixup matching with PCIcodec SSID or model string
  @codec: the HDA codec
  @models: NULL-terminated model string list
  @quirk: zero-terminated PCIcodec SSID quirk list
  @fixlist: the fixup list
  Pick up a fixup entry matching with the given model string or SSID.
  If a fixup was already set beforehand, the function doesn't do anything.
  When a special model string "nofixup" is given, also no fixup is applied.
  The function tries to find the matching model name at first, if given.
  If the model string contains the SSID alias, try to look up with the given
  alias ID.
  If nothing matched, try to look up the PCI SSID.
  If still nothing matched, try to look up the codec SSID.
 when model=nofixup is given, don't pick up any fixups 
 match with the model name string 
 match with the SSID alias given by the model string "XXXX:YYYY" 
 match with the PCI SSID 
 match with the codec SSID 
 no matching 
 SPDX-License-Identifier: GPL-2.0-or-later
  Universal Interface for Intel High Definition Audio Codec
  HD audio interface patch for VIA VT17xxVT18xxVT20xx codec
   (C) 2006-2009 VIA Technology, Inc.
   (C) 2006-2008 Takashi Iwai <tiwai@suse.de>
              Release History                 
									     
 2006-03-03  Lydia Wang  Create the basic patch to support VT1708 codec    
 2006-03-14  Lydia Wang  Modify hard code for some pin widget nid	     
 2006-08-02  Lydia Wang  Add support to VT1709 codec			     
 2006-09-08  Lydia Wang  Fix internal loopback recording source select bug 
 2007-09-12  Lydia Wang  Add EAPD enable during driver initialization	     
 2007-09-17  Lydia Wang  Add VT1708B codec support			    
 2007-11-14  Lydia Wang  Add VT1708A codec HP and CD pin connect config    
 2008-02-03  Lydia Wang  Fix Rear channels and Back channels inverse issue 
 2008-03-06  Lydia Wang  Add VT1702 codec and VT1708S codec support	     
 2008-04-09  Lydia Wang  Add mute front speaker when HP plugin	     
 2008-04-09  Lydia Wang  Add Independent HP feature			     
 2008-05-28  Lydia Wang  Add second SPDIF Out support for VT1702	     
 2008-09-15  Logan Li	   Add VT1708S Mic Boost workaroundbackdoor	     
 2009-02-16  Logan Li	   Add support for VT1718S			     
 2009-03-13  Logan Li	   Add support for VT1716S			     
 2009-04-14  Lydai Wang  Add support for VT1828S and VT2020		     
 2009-07-08  Lydia Wang  Add support for VT2002P			     
 2009-07-21  Lydia Wang  Add support for VT1812			     
 2009-09-19  Lydia Wang  Add support for VT1818S			     
									     
 Pin Widget NID 
 HP mode source 
 analog low-power control 
 work to check hp jack state 
 defined below 
 VT1708BCE & VT1708S are almost same 
 get codec type 
 codec->power_save_node = val;  
 additional beep mixers; the actual parameters are overwritten at build 
 check AA path's mute status 
 enterexit analog low-current mode 
 decide low current mode's verb & parameter 
 0x02: 23x, 0x00: 1x 
 0x51: 428x, 0xe1: 1x 
 0x01: 440x, 0x1d: 1x 
 0x00: 440x, 0xe0: 1x 
 0x00: 440x, 0xe0: 1x 
 other codecs are not supported 
 send verb 
 Fix pop noise on headphones 
 some delay here to make jack detection working (bko#98921) 
 power down jack detect function 
 disable widget PM at start for compatibility 
 init power states 
	 In order not to create "Phantom Jack" controls,
	 We got noisy outputs on the right channel on VT1708 when
	  24bit samples are used.  Until any workaround is found,
	  disable the 24bit format, so far.
 create a codec specific record 
 override some patch_ops 
 set jackpoll_interval while parsing the codec 
 don't support the input jack switching due to lack of unsol event 
 (it may work with polling, though, but it needs testing) 
 Some machines show the broken speaker mute 
 Add HP and CD pin config connect bit re-config action 
 automatic parse from the BIOS config 
 add jack detect onoff control 
 clear jackpoll_interval again; it's set dynamically 
 create a codec specific record 
 create a codec specific record 
 automatic parse from the BIOS config 
 Patch for VT1708S 
 Enable Mic Boost Volume backdoor 
 don't bybass mixer 
 create a codec specific record 
 correct names for VT1708BCE 
 correct names for VT1705 
 automatic parse from the BIOS config 
 Patch for VT1702 
 mixer enable 
 GPIO 0~2 
 create a codec specific record 
 limit AA path volume to 0 dB 
 automatic parse from the BIOS config 
 Patch for VT1718S 
 Enable MW0 adjust Gain 5 
 Enable Boost Volume backdoor 
 Add a connection to the primary DAC from AA-mixer for some codecs
  This isn't listed from the raw info, but the chip has a secret connection.
 find the primary DAC and add to the connection list 
 create a codec specific record 
 automatic parse from the BIOS config 
 Patch for VT1716S 
 mono-out mixer elements 
 Enable Boost Volume backdoor 
 don't bybass mixer 
 Enable mono output 
 create a codec specific record 
 automatic parse from the BIOS config 
 for vt2002P 
 Class-D speaker related verbs 
 Enable Boost Volume backdoor 
 Enable AOW0 to MW9 
 Enable Boost Volume backdoor 
 Enable AOW0 to MW9 
  pin fix-up
 set 0x24 and 0x33 as speakers 
 subwoofer 
 NIDs 0x24 and 0x33 on VT1802 have connections to non-existing NID 0x3e
  Replace this with mixer NID 0x1c
 patch for vt2002P 
 create a codec specific record 
 automatic parse from the BIOS config 
 for vt1812 
 Enable Boost Volume backdoor 
 Enable AOW0 to MW9 
 patch for vt1812 
 create a codec specific record 
 automatic parse from the BIOS config 
 patch for vt3476 
 Enable DMic 81632K 
 Enable Boost Volume backdoor 
 Enable AOW-MW9 path 
 create a codec specific record 
 automatic parse from the BIOS config 
  patch entries
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
  HD audio interface patch for AD1882, AD1884, AD1981HD, AD1983, AD1984,
    AD1986A, AD1988
  Copyright (c) 2005-2007 Takashi Iwai <tiwai@suse.de>
 for auto parser 
 beep amp value, set via set_beep_amp() 
 additional beep mixers; the actual parameters are overwritten at build 
 end 
 mono 
 NOP 
 We currently only handle front, HP 
 follow EAPD via vmaster hook 
  Automatic parse of IO pins from the BIOS configuration
  AD1986A specific
  AD1986A fixup codes
 Lenovo N100 seems to report the reversed bit for HP jack-sensing 
 Toshiba Satellite L40 implements EAPD in a standard way unlike others 
 enable stereo-mix input for avoiding regression on KDE (bko#88251) 
 speaker 
 int mic 
 speaker 
 int mic 
 NA 
 NA 
 headphone 
 front 
 line-in 
 rear mic 
 NA 
 mic 
 NA 
 headphone 
 speaker 
 NA 
 NA 
 NA 
 mic 
 NA 
 int mic 
 headphone 
 speaker 
 NA 
 int mic 
 NA 
 mic 
 NA 
 NA 
 NA 
 NA 
 NA 
 NA 
 alias 
 AD1986A has the inverted EAPD implementation 
	 AD1986A has a hardware problem that it can't share a stream
	  with multiple output pins.  The copy of front to surrounds
	  causes noisy or silent outputs at a certain timing, e.g.
	  changing the volume.
	  So, let's disable the shared stream.
 give fixed DACpin pairs 
 AD1986A can't manage the dynamic pin onoff smoothly 
  AD1983 specific
  SPDIF mux control for AD1983 auto-parser
 limit the loopback routes not to confuse the parser 
  AD1981 HD specific
 set the upper-limit for mixer amp to 0dB for avoiding the possible
  damage by overloading
 HP nx6320 (reversed SSID, HW bug) 
  AD1988
  Output pins and routes
         Pin               Mix     Sel     DAC ()
  port-A 0x11 (mutehp) <- 0x22 <- 0x37 <- 030406
  port-B 0x14 (mutehp) <- 0x2b <- 0x30 <- 030406
  port-C 0x15 (mute)    <- 0x2c <- 0x31 <- 050a
  port-D 0x12 (mutehp) <- 0x29         <- 04
  port-E 0x17 (mutehp) <- 0x26 <- 0x32 <- 050a
  port-F 0x16 (mute)    <- 0x2a         <- 06
  port-G 0x24 (mute)    <- 0x27         <- 05
  port-H 0x25 (mute)    <- 0x28         <- 0a
  mono   0x13 (muteamp)<- 0x1e <- 0x36 <- 030406
  DAC0 = 03h, DAC1 = 04h, DAC2 = 05h, DAC3 = 06h, DAC4 = 0ah
  () DAC234 are swapped to DAC342 on AD198A rev.2 due to a hw bug.
  Input pins and routes
         pin     boost   mix input #  adc input #
  port-A 0x11 -> 0x38 -> mix 2, ADC 0
  port-B 0x14 -> 0x39 -> mix 0, ADC 1
  port-C 0x15 -> 0x3a -> 33:0 - mix 1, ADC 2
  port-D 0x12 -> 0x3d -> mix 3, ADC 8
  port-E 0x17 -> 0x3c -> 34:0 - mix 4, ADC 4
  port-F 0x16 -> 0x3b -> mix 5, ADC 3
  port-G 0x24 -> NA  -> 33:1 - mix 1, 34:1 - mix 4, ADC 6
  port-H 0x25 -> NA  -> 33:2 - mix 1, 34:2 - mix 4, ADC 7
  DAC assignment
    6stack - frontsurrCLFEsideopt DACs - 0406050a03
    3stack - frontsurrCLFEopt DACs - 04050a03
  Inputs of Analog Mix (0x20)
    0:Port-B (front mic)
    1:Port-CGH (line-in)
    2:Port-A
    3:Port-D (line-in2)
    4:Port-EGH (mic-in)
    5:Port-F (mic2-in)
    6:CD
    7:Beep
  ADC selection
    0:Port-A
    1:Port-B (front mic-in)
    2:Port-C (line-in)
    3:Port-F (mic2-in)
    4:Port-E (mic-in)
    5:CD
    6:Port-G
    7:Port-H
    8:Port-D (line-in2)
    9:Mix
  Proposed pin assignments by the datasheet
  6-stack
  Port-A front headphone
       B front mic-in
       C rear line-in
       D rear front-out
       E rear mic-in
       F rear surround
       G rear CLFE
       H rear side
  3-stack
  Port-A front headphone
       B front mic
       C rear line-insurround
       D rear front-out
       E rear mic-inCLFE
  laptop
  Port-A headphone
       B mic-in
       C docking station
       D internal speaker (with EAPD)
       EF quad mic array
	 we create four static faked paths, since AD codecs have odd
	  widget connections regarding the SPDIF out source
 SPDIF source mux appears to be present only on AD1988A 
 front-hp 
 line-out 
 front-mic 
 line-in 
 line-out 
 mic 
 SPDIF 
 line-out 
 line-out 
  AD1884  AD1984
  port-B - front linemic-in
  port-E - aux inout
  port-F - aux inout
  port-C - rear linemic-in
  port-D - rear linehp-out
  port-A - front linehp-out
  AD1984 = AD1884 + two digital mic-ins
  AD1883  AD1884A  AD1984A  AD1984B
  port-B (0x14) - front mic-in
  port-E (0x1c) - rear mic-in
  port-F (0x16) - CD  ext out
  port-C (0x15) - rear line-in
  port-D (0x12) - rear line-out
  port-A (0x11) - front hp-out
  AD1984A = AD1884A + digital-mic
  AD1883 = equivalent with AD1984A
  AD1984B = AD1984A + extra SPDIF-out
 set the upper-limit for mixer amp to 0dB for avoiding the possible
  damage by overloading
 toggle GPIO1 according to the mute state 
 Analog PC Beeper - allow firmwareACPI beeps 
 no digital beep 
 set magic COEFs for dmic 
  AD1882  AD1882A
  port-A - front hp-out
  port-B - front mic-in
  port-C - rear line-in, shared surr-out (3stack)
  port-D - rear line-out
  port-E - rear mic-in, shared clfe-out (3stack)
  port-F - rear surr-out (6stack)
  port-G - rear clfe-out (6stack)
  patch entries
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
  Universal Interface for Intel High Definition Audio Codec
  HD audio interface patch for SigmaTel STAC92xx
  Copyright (c) 2005 Embedded Alley Solutions, Inc.
  Matt Porter <mporter@embeddedalley.com>
  Based on patch_cmedia.c and patch_realtek.c
  Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>
 no jack-detection 
 no jack-detection 
 4-pin headset jack (hp + mono mic) 
 special volume-knob initialization 
 gpio lines 
 pin NID for mute-LED vref control 
 capture mute LED GPIO 
 current mic mute state (bitmask) 
 stream 
 analog loopback 
 power management 
 beep widgets 
 SPDIF-out mux 
  PCM hooks
  Early 2006 Intel Macintoshes with STAC9220X5 codecs seem to have a
  funky external mute control using GPIO pins.
 Configure GPIOx as CMOS 
 sync 
 sync 
 hook for controlling mic-mute LED GPIO 
 prevent codec AFG to D3 state when vref-out pin is used for mute LED 
 this hook is set in stac_setup_gpio() 
 update mute-LED accoring to the master switch 
 LED state is inverted on these systems 
 vmaster hook to update mute LED 
 automute hook to handle GPIO mute and EAPD updates 
 power down unused output ports 
 update power bit per jack plugunplug 
 update all jacks 
 toggle VREF state based on GPIOx status 
 initialize the power map and enable the power event to jacks that
  haven't been assigned to automute
 override some hints from the hwdep entry 
  loopback controls
	 Only return the bits defined by the shift value of the
	  first two bytes of the mask
  Mute LED handling on HP laptops
 check whether it's a HP laptop with a docking port 
 HP ProBook 6550b 
 GPIO 3 
 GPIO 0 
  This method searches for the mute LED GPIO configuration
  provided as OEM string in SMBIOS. The format of that string
  is HP_Mute_LED_P_G or HP_Mute_LED_P
  where P can be 0 or 1 and defines mute LED GPIO control state (lowhigh)
  that corresponds to the NOT muted state of the master volume
  and G is the index of the GPIO to use as the mute LED control (0..9)
  If _G portion is missing it is assigned based on the codec ID
  So, HP B-series like systems may have HP_Mute_LED_0 (current models)
  or  HP_Mute_LED_0_3 (future models) OEM SMBIOS strings
  The dv-series laptops don't seem to have the HP_Mute_LED strings in
  SMBIOS - at least the ones I have seen do not have them - which include
  my own system (HP Pavilion dv6-1110ax) and my cousin's
  HP Pavilion dv9500t CTO.
  Need more information on whether it is true across the entire series.
  -- kunal
 BIOS bug: unfilled OEM string 
	
	  Fallback case - if we don't find the DMI strings,
	  we statically set the GPIO - if not a B-series system
	  and default polarity is provided
 check whether a built-in speaker is included in parsed pins 
  PC beep controls
 create PC beep volume controls 
 check for mute support for the amp 
 check to see if there is volume support for the amp 
  SPDIF-out mux controls
 count set later 
 set dac0mux for dac converter 
	 set master volume to max value without distortion
 set master volume and direct control 
 power state controls amps 
 set master volume and direct control 
 unmute right and left channels for nodes 0x0f, 0xa, 0x0d 
 set dac0mux for dac converter 
 mute the master volume 
 set master volume and direct control 
 unmute node 0x1b 
 select node 0x03 as DAC 
 don't set delta bit 
 unmute node 0x1b 
 select node 0x03 as DAC 
 set master volume and direct control 
 enable analog pc beep path 
 don't set delta bit 
 enable analog pc beep path 
 set master volume and direct control 
 enable analog pc beep path 
    STAC 9200 pin configs for
    102801A8
    102801DE
    102801E8
    STAC 9200 pin configs for
    102801C0
    102801C1
    STAC 9200 pin configs for
    102801C4 (Dell Dimension E310)
    102801C5
    102801C7
    102801D9
    102801DA
    102801E3
    STAC 9200-32 pin configs for
    102801B5 (Dell Inspiron 630m)
    102801D8 (Dell Inspiron 640m)
    STAC 9200-32 pin configs for
    102801C2 (Dell Latitude D620)
    102801C8 
    102801CC (Dell Latitude D820)
    102801D4 
    102801D6 
    STAC 9200-32 pin configs for
    102801CE (Dell XPS M1710)
    102801CF (Dell Precision M90)
    STAC 9200-32 pin configs for 
    102801C9
    102801CA
    102801CB (Dell Latitude 120L)
    102801D3
    STAC 9200-32 pin configs for
    102801BD (Dell Inspiron E1505n)
    102801EE
    102801EF
    STAC 9200-32 pin configs for
    102801F5 (Dell Inspiron 1501)
    102801F6
    STAC 9200-32
    102801CD (Dell Inspiron E17059400)
   STAC 92HD700
   18881000 Amigaone X1000
 Front panel HP socket 
 Front Mic 
 Line in 
 Line out 
 Rear Mic 
 Rear speakers 
 Center speaker 
 Side speakers (7.1) 
 Motherboard CD line in connector 
 Unused 
 Unused 
 SPDIF line out 
 Unused 
 Unused 
		 CF-74 has no headphone detection, and the driver should NOT
		  do detection and HPspeaker toggle because the hardware does it.
 SigmaTel reference board 
 Dell laptops have BIOS problem 
 Panasonic 
 Gateway machines needs EAPD to be set on resume 
 OQO Mobile 
 terminator 
 SigmaTel reference board 
 Default table for unknown ID 
 gateway machines are checked via codec ssid 
 Not sure about the brand name for those 
 terminator 
 Analog Mics 
 Digital Mics 
 Both 
 enable 5.1 and SPDIF out 
 SigmaTel reference board 
 codec SSID matching 
 terminator 
 allow auto-switching of dock line-in 
 GPIO3 
 resetting controller clears GPIO, so we need to keep on 
 GPIO4 
 44.1KHz base 
 48KHz base 
 common 
 SigmaTel reference board 
 match both for 0xfa91 and 0xfa93 
 terminator 
 HP dv7 bass switch - GPIO5 
 Enable VREF power saving on GPIO1 detect 
 enable internal microphone 
 enable bass on HP dv7 
 count line-out, too, as BIOS sets often so 
	 It was changed in the BIOS to just satisfy MS DTM.
	  Lets turn it back into follower HP
	 when both output A and F are assigned, these are supposedly
	  dock and built-in headphones; fix both pin configs
 SigmaTel reference board 
 HDX18 
 HDX16 
 HP dv6-1110ax 
 terminator 
    STAC 922X pin configs for
    102801A7
    102801AB
    102801A9
    102801D1
    102801D2
    STAC 922X pin configs for
    102801AC
    102801D0
    STAC 922X pin configs for
    102801BF
    STAC 9221 A1 pin configs for
    102801D7 (Dell XPS M1210)
 codec SSIDs for Intel Mac sharing the same PCI SSID 8384:7680 
 remap the fixup from codec SSID and apply it 
 for backward compatibility 
 SigmaTel reference board 
 Intel 945G based systems 
 Intel D945G 5-stack systems 
 Intel 945P based systems 
 other intel 
 other systems  
 Apple Intel Mac (Mac Mini, MacBook, MacBook Pro...) 
 Dell systems  
 ECSPC Chips boards 
 terminator 
 no jack detecion for ref-no-jd model 
 GPIO2 High = Enable EAPD 
 correct the front output jack as a hp out 
 correct the front input jack as a mic 
 configure the analog microphone on some laptops 
 correct the device field to SPDIF out 
 SigmaTel reference board 
 Intel 946 based systems 
 965 based 3 stack systems 
 Dell 3 stack systems 
 Dell 3 stack systems with verb table in BIOS 
 965 based 5 stack systems 
 Nemo 
 volume-knob fixes 
 terminator 
    STAC 9205 pin configs for
    102801F1
    102801F2
    102801FC
    102801FD
    10280204
    1028021F
    10280228 (Dell Vostro 1500)
    10280229 (Dell Vostro 1700)
    STAC 9205 pin configs for
    102801F9
    102801FA
    102801FE
    102801FF (Dell Precision M4300)
    10280206
    10280200
    10280201
 Enable SPDIF inout 
 SPDIF-In enabled 
 Enable unsol response for GPIO4Dock HP connection 
		 GPIO0 High = EAPD, GPIO1 Low = Headphone Mute,
		  GPIO3 Low = DRM
 SigmaTel reference board 
 Dell 
 Gateway 
 terminator 
 HPF to 100Hz 
 terminator 
 add hooks 
 setup analog beep controls 
 setup digital beep controls and input device 
 IDTSTAC codecs have linear beep tone parameter 
 if no beep switch is available, make its own one 
 override some hints 
 set up GPIO 
	 turn on EAPD statically when spec->eapd_switch isn't set.
	  otherwise, unsol event will turn it onoff dynamically
 sync the power-map 
 power down inactive ADCs 
 stac92hd71bxx, stac92hd73xx 
 CONFIG_PM 
 seems common with STACIDT codecs 
	 enable power_save_node only for new 92HD89xx chips, as it causes
	  click noises on old 92HD73xx chips.
 6 Channel 
 8 Channel 
 10 Channel 
 digital beep 
 GPIO0 High = Enable EAPD 
	 Don't GPIO-mute speakers if there are no internal speakers, because
	  the GPIO might be necessary for Headphone
 longer delay needed for D3 
 digital beep 
 no default cfg 
 longer delay needed for D3 
 digital beep 
 disabled power_save_node since it causes noises on a Dell machine 
 codec->power_save_node = 1; 
 GPIO0 = EAPD 
 4 Port without Analog Mixer 
 5 Port with Analog Mixer 
 40 milliseconds 
 disable VSW 
 6 Port with Analog Mixer 
 40 milliseconds 
 digital beep 
 Fix Mux capture level; max to 2 
 digital beep 
 GPIO0 High = Enable EAPD 
	
	  !!FIXME!!
	  The STAC927x seem to require fairly long delays for certain
	  command sequences.  With too short delays (even if the answer
	  is set to RIRB properly), it results in the silence output
	  on some hardwares like Dell.
	 
	  The below flag enables the longer delay (see get_response
	  in hda_intel.c).
 digital beep 
 GPIO0 High = EAPD 
 Turn onoff EAPD per HP plugging 
  STAC9872 hack
 mic-sel: 0a,0d,14,02 
 Mic-in -> 0x9 
 terminator 
  patch entries
	 The following does not take into account .id=0x83847661 when subsys =
	  104D0C00 which is STAC9225s. Because of this, some SZ Notebooks are
	  currently not fully supported.
 terminator 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
   Routines for control of YMF724740744754 chips
   common IO routines
   Misc routines
 FIXME: What's the right value? 
   Hardware start management
   Playback voice management
 TODO: synthmidi voice deallocation 
   PCM part
			
			dev_dbg(chip->card->dev,
			       "done - active_bank = 0x%x, start = 0x%x\n",
			       chip->active_bank,
			       voice->bank[chip->active_bank].start);
			
			dev_dbg(chip->card->dev,
			       "done - active_bank = 0x%x, start = 0x%x\n",
			       chip->active_bank,
			       voice->bank[chip->active_bank].start);
 already allocated 
 already allocated 
        			 The SPDIF out channels seem to be swapped, so we have
        			  to swap them here, too.  The rear analog out channels
        			  will be wrong, but otherwise AC3 would not work.
 snd_ymfpci_irq_wait(chip);
 wait, until the PCI operations are not finished 
 wait, until the PCI operations are not finished 
 FIXME: enough? 
 FIXME: enough? 
 FIXME: enough? 
 FIXME: enough? 
 FIXME? True value is 25648 = 5.33333 ms 
 call with spinlock held 
 set AC3 
 enable second codec (4CHEN) 
 call with spinlock held 
 FIXME? True value is 25648 = 5.33333 ms 
 global setup 
 global setup 
 global setup 
 global setup 
   Mixer controls
  4ch duplication
  GPIO
 set the level mode for input line 
  PCM voice volume
   Mixer routines
 YMFPCI doesn't need VRA 
 to be sure 
 add SPDIF control 
 direct recording source 
	
	  shared rearline-in
 per-voice volume 
  timer
		
		  Divisor 1 is not allowed; fake it by using divisor 2 and
		  counting two ticks for each interrupt.
 1  96 kHz = 10.41666...us 
   proc interface
   initialization routines
 force to reset
 setup DSP instruction code 
 setup control instruction code 
	 work_ptr must be aligned to 256 bytes, but it's already
 for sure 
 SPDIF output initialization 
 SPDIF input initialization 
 digital mixer setup 
 spdif 
 volumes 
 address bases 
 capture set up 
 start hw again 
 CONFIG_PM_SLEEP 
 enable PCI device 
 seems we need a delay after downloading image.. 
 SPDX-License-Identifier: GPL-2.0-or-later
   The driver for the Yamaha's DS1DS1E cards
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
 Index 0-MAX 
 ID for this card 
 Enable this card 
 YMF724 
 YMF724F 
 YMF740 
 YMF740C 
 YMF744 
 YMF754 
 YMF 744754 
 auto-detect 
 auto-detect 
 YMF 744754 
 SUPPORT_JOYSTICK 
 SBEN = 0, SMOD = 01, LAD = 0 
 YMF 744754 
 auto-detect 
 auto-detect 
 disable MPU401 irq 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008 Cedric Bregardis <cedric.bregardis@free.fr> and
  Jean-Christian Hassler <jhassler@free.fr>
  This file is part of the Audiowerk2 ALSA driver
 chip-specific destructor 
 disable all irqs 
 reset saa7146 
 Unset base addr 
	 set PCI burstthreshold
	   Burst length definition
	   VALUE    BURST LENGTH
	   000      1 Dword
	   001      2 Dwords
	   010      4 Dwords
	   011      8 Dwords
	   100      16 Dwords
	   101      32 Dwords
	   110      64 Dwords
	   111      128 Dwords
	   Threshold definition
	   VALUE    WRITE MODE              READ MODE
	   00       1 Dword of valid data   1 empty Dword
	   01       4 Dwords of valid data  4 empty Dwords
	   10       8 Dwords of valid data  8 empty Dwords
 Set base addr 
 disable all irqs 
 reset saa7146 
 enable audio interface 
 WS0_CTRL, WS0_SYNC: input TSL1, I2S 
 At initialization WS1 and WS2 are disabled (configured as input) 
	 WS4 is not used. So it must not restart A2.
 WS3_CTRL, WS3_SYNC: output TSL2, I2S 
 A1 and A2 are active and asynchronous 
	 The following comes from original windows driver.
	   It is needed to have a correct behavior of input and output
 enable audio port pins 
 enable I2C 
 enable interrupts 
 audio configuration 
 By default use analog input 
 TSL setup 
	 Configure DMA for substream
	   Configuration informations: ALSA has allocated continuous memory
	   pages. So we don't need to use MMU of saa7146.
	 No MMU -> nothing to do with PageA1, we only configure the limit of
 Disable MMU 
	 Configure Limit for DMA access.
	   The limit register defines an address limit, which generates
	   an interrupt if passed by the actual PCI address pointer.
	   '0001' means an interrupt will be generated if the lower
	   6 bits (64 bytes) of the PCI address are zero. '0010'
	   defines a limit of 128 bytes, '0011' one of 256 bytes, and
	   so on up to 1 Mbyte defined by '1111'. This interrupt range
	   can be calculated as follows:
	   Range = 2^(5 + Limit) bytes.
 Base address for DMA transfert. 
 This address has been reserved by ALSA. 
 This is a physical address 
 Define upper limit for DMA access 
 Base address for DMA transfert. 
 This address has been reserved by ALSA. 
 This is a physical address 
 Define upper limit for DMA access 
	 Configure DMA for substream
	   Configuration informations: ALSA has allocated continuous memory
	   pages. So we don't need to use MMU of saa7146.
	 No MMU -> nothing to do with PageA1, we only configure the limit of
 Disable MMU 
	 Configure Limit for DMA access.
	   The limit register defines an address limit, which generates
	   an interrupt if passed by the actual PCI address pointer.
	   '0001' means an interrupt will be generated if the lower
	   6 bits (64 bytes) of the PCI address are zero. '0010'
	   defines a limit of 128 bytes, '0011' one of 256 bytes, and
	   so on up to 1 Mbyte defined by '1111'. This interrupt range
	   can be calculated as follows:
	   Range = 2^(5 + Limit) bytes.
 Base address for DMA transfert. 
 This address has been reserved by ALSA. 
 This is a physical address 
 Define upper limit for DMA access  
	 In aw8 driver, dma transfert is always active. It is
 WS2_CTRL, WS2_SYNC: output TSL2, I2S 
 WS1_CTRL, WS1_SYNC: output TSL1, I2S 
 WS2_CTRL, WS2_SYNC: output TSL2, I2S 
 WS1_CTRL, WS1_SYNC: output TSL1, I2S 
	 In aw8 driver, dma transfert is always active. It is
	 FIXME: switch between analog and digital input does not always work.
	   It can produce a kind of white noise. It seams that received data
	   are inverted sometime (endian inversion). Why ? I don't know, maybe
	   a problem of synchronization... However for the time being I have
	   not found the problem. Workaround: switch again (and again) between
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008 Cedric Bregardis <cedric.bregardis@free.fr> and
  Jean-Christian Hassler <jhassler@free.fr>
  This file is part of the Audiowerk2 ALSA driver
  DEFINES
  TYPEDEFS
 hardware definition 
  FUNCTION DECLARATIONS
  VARIABLES
 pci_driver definition 
 operators for playback PCM alsa interface 
 operators for capture PCM alsa interface 
  FUNCTION IMPLEMENTATIONS
 component-destructor 
 Free hardware 
 chip-specific constructor 
 initialize the PCI entry 
 check PCI availability (32bit DMA) 
 initialize the stuff 
 (1) PCI resource allocation 
 (2) initialization of the chip hardware 
 constructor 
 (1) Continue if device is not enabled, else inc dev 
 (2) Create card instance 
 (3) Create main component 
 initialize mutex 
 init spinlock 
 (4) Define driver ID and name string 
 (5) Create other components 
 (6) Register card instance 
 (7) Set PCI driver data 
 open callback 
 close callback 
 close callback 
 TODO: something to do ? 
 prepare callback for playback 
 Define Interrupt callback 
 prepare callback for capture 
 Define Interrupt callback 
 playback trigger callback 
 capture trigger callback 
 playback pointer callback 
 get the current hardware pointer 
 capture pointer callback 
 get the current hardware pointer 
 create a pcm device 
 Create new Alsa PCM device 
 Creation ok 
 Set PCM device name 
 Associate private data to PCM device 
 set operators of PCM device 
 store PCM device 
	 give base chip pointer to our internal pcm device
 Give stream number to PCM device 
 pre-allocation of buffers 
 Preallocate continuous pages. 
 Creation ok 
 Set PCM device name 
 Associate private data to PCM device 
 set operators of PCM device 
 store PCM device 
	 give base chip pointer to our internal pcm device
 Give stream number to PCM device 
 pre-allocation of buffers 
 Preallocate continuous pages. 
 Creation ok 
 Set PCM device name 
 Associate private data to PCM device 
 set operators of PCM device 
 store PCM device 
	 give base chip pointer to our internal pcm device
 Give stream number to PCM device 
 pre-allocation of buffers 
 Preallocate continuous pages. 
 Create control 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008 Cedric Bregardis <cedric.bregardis@free.fr> and
  Jean-Christian Hassler <jhassler@free.fr>
  Copyright 1998 Emagic Soft- und Hardware GmbH
  Copyright 2002 Martijn Sipkema
  This file is part of the Audiowerk2 ALSA driver
 Audiowerk8 hardware setup: 
      WS0, SD4, TSL1  - Analog digital in 
      WS1, SD0, TSL1  - Analog out #1, digital out 
      WS2, SD2, TSL1  - Analog out #2 
      WS3, SD1, TSL2  - Analog out #3 
      WS4, SD3, TSL2  - Analog out #4 
 Audiowerk8 timing: 
      Timeslot:     | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | ... 
      A1_INPUT: 
      SD4:          <_ADC-L_>-------<_ADC-R_>-------< 
      WS0:          _______________---------------\_ 
      A1_OUTPUT: 
      SD0:          <_1-L___>-------<_1-R___>-------< 
      WS1:          _______________---------------\_ 
      SD2:          >-------<_2-L___>-------<_2-R___> 
      WS2:          -------\_______________--------- 
      A2_OUTPUT: 
      SD1:          <_3-L___>-------<_3-R___>-------< 
      WS3:          _______________---------------\_ 
      SD3:          >-------<_4-L___>-------<_4-R___> 
      WS4:          -------\_______________--------- 
 SPDX-License-Identifier: GPL-2.0-or-later
    Driver for the Korg 1212 IO PCI card
 	Copyright (c) 2001 Haroldo Gamal <gamal@alternex.com.br>
 ----------------------------------------------------------------------------
 Debug Stuff
 ----------------------------------------------------------------------------
 ----------------------------------------------------------------------------
 RecordPlay Buffer Allocation Method. If K1212_LARGEALLOC is defined all 
 buffers are alocated as a large piece inside KorgSharedBuffer.
 ----------------------------------------------------------------------------
#define K1212_LARGEALLOC		1
 ----------------------------------------------------------------------------
 Valid states of the Korg 1212 IO card.
 ----------------------------------------------------------------------------
 there is no card here
 the card is awaiting DSP download
 the card is currently downloading its DSP code
 the card has finished the DSP download
 the card can be opened by an application.  Any application
    requests prior to this state should fail.  Only an open
    request can be made at this state.
 an application has opened the card
 the card has been setup for play
 the card is playing
 the card is in the monitor mode
 the card is currently calibrating
 the card has stopped itself because of an error and we
    are in the process of cleaning things up.
 state values of this and beyond are invalid
 ----------------------------------------------------------------------------
 The following enumeration defines the constants written to the card's
 host-to-card doorbell to initiate a command.
 ----------------------------------------------------------------------------
 sent by the card to request a buffer fill.
 starts playbackrecord on the card.
 select monitor, playback setup, or stop.
 tells card where the host audio buffers are.
 asks the card for the latest ADAT timecode value.
 sets the clock source and rate for the card.
 tells card where other buffers are.
 tells card to trigger from Adat at a specific
    timecode value.
 DMA Error - the PCI bus is congestioned.
 Card has stopped by user request.
 instructs the card to reboot.
 instructs the card to boot from the DSP microcode
    on page 4 (local page to card).
 sent by the card to indicate the download has
    completed.
 tells the card to download its DSP firmware.
 ----------------------------------------------------------------------------
 The following enumeration defines return codes 
 to the Korg 1212 IO driver.
 ----------------------------------------------------------------------------
 command was successfully placed
 the DeviceIoControl call failed
 the protected mode call failed
 unspecified failure
 the specified command can not be given in
    the card's current state. (or the wave device's
    state)
 the card is uninitialized and cannot be used
 an out of range card index was specified
 an invalid card handle was specified
 a play request has been made before a fill routine set
 can't set a new fill routine while one is in use
 the card never acknowledged a command
 bad parameters were provided by the caller
 the specified wave device was out of range
 the specified wave format is unsupported
 ----------------------------------------------------------------------------
 The following enumeration defines the constants used to select the play
 mode for the card in the SelectPlayMode command.
 ----------------------------------------------------------------------------
 provides card with pre-play information
 tells card to turn on monitor mode
 tells card to turn off monitor mode
 stops playback on the card
 ----------------------------------------------------------------------------
 The following enumeration defines the constants used to select the monitor
 mode for the card in the SetMonitorMode command.
 ----------------------------------------------------------------------------
 tells card to turn off monitor mode
 tells card to turn on monitor mode
 location of mailbox 0 relative to base address
 location of mailbox 1 relative to base address
 location of mailbox 2 relative to base address
 location of mailbox 3 relative to base address
 location of PCI to local doorbell
 location of local to PCI doorbell
 location of interrupt controlstatus register
 location of the EEPROM, PCI, User IO, init control
    register
 location of the input sensitivity setting register.
    this is the upper word of the PCI control reg.
 location of the device and vendor ID register
 maximum number of times the driver will attempt
    to send a command before giving up.
 the MSB is set in the command acknowledgment from
    the card.
 the doorbell value is one byte
 -----------------------------------------------------------------
 the following bits are used for controlling interrupts in the
 interrupt controlstatus reg
 -----------------------------------------------------------------
 -----------------------------------------------------------------
 the following bits are defined for the PCI command register
 -----------------------------------------------------------------
 -----------------------------------------------------------------
 the following bits are defined for the PCI status register
 -----------------------------------------------------------------
 ------------------------------------------------------------------------
 the following constants are used in setting the 1212 IO card's input
 sensitivity.
 ------------------------------------------------------------------------
 --------------------------------------------------------------------------
 WaitRTCTicks
    This function waits the specified number of real time clock ticks.
    According to the DDK, each tick is ~0.8 microseconds.
    The defines following the function declaration can be used for the
    numTicksToWait parameter.
 --------------------------------------------------------------------------
 max # RTC ticks for the card to stop once we write
    the command register.  (could be up to 180 us)
 number of RTC ticks to wait for an acknowledgement
    from the card after sending a command.
 selects source as ADAT at 44.1 kHz
 selects source as ADAT at 48 kHz
 selects source as SPDIF at 44.1 kHz
 selects source as SPDIF at 48 kHz
 selects source as local clock at 44.1 kHz
 selects source as local clock at 48 kHz
 used to check validity of the index
 selects source as ADAT
 selects source as SPDIF
 selects source as local clock
 channels 0-9 use 16 bit samples 
 channels 10-11 use 32 bits - only 20 are sent across SPDIF 
 holds the ADAT timecode value 
 buffer definition 
 ADAT timecode value
 timer callback for checking ack of stop request 
 counter for stop pending check 
 address of the interrupt statuscontrol register
 address of the host->card doorbell register
 address of the card->host doorbell register
 address of mailbox 0 on the card
 address of mailbox 1 on the card
 address of mailbox 2 on the card
 address of mailbox 3 on the card
 address of the EEPROM, PCI, IO, Init ctrl reg
 address of the sensitivity setting register
 address of the device and vendor ID registers
 indicates whether the card is in idle monitor mode.
 tracks how many times we have retried sending to the card.
 sample rate and clock source
 clock source
 clock rate
 ADC left channel input sensitivity
 ADC right channel input sensitivity
 OpenClose count
 SetupForPlay count
 TriggerPlay count
 Error Count
 Total Error Count
 Index 0-MAX 
 ID for this card 
 Enable this card 
 selects source as ADAT at 44.1 kHz
 selects source as ADAT at 48 kHz
 selects source as SPDIF at 44.1 kHz
 selects source as SPDIF at 48 kHz
 selects source as local clock at 44.1 kHz
 selects source as local clock at 48 kHz
 interrupt the card
 --------------------------------------------------------------
 the reboot command will not give an acknowledgement.
 --------------------------------------------------------------
 --------------------------------------------------------------
 See if the card acknowledged the command.  Wait a bit, then
 read in the low word of mailbox3.  If the MSB is set and the
 low byte is equal to the doorbell value, then it ack'd.
 --------------------------------------------------------------
 spinlock already held 
 program the timer 
 timer callback for checking the ack of stop request 
 ack'ed 
 reprogram timer 
 spinlock already held 
 spinlock already held 
 spinlock already held 
 not used 
 not used 
 this keeps the current value to be written to
  the card's eeprom control register.
 ----------------------------------------------------------------------------
 initialize things.  The local init bit is always set when writing to the
 card's control register.
 ----------------------------------------------------------------------------
 init the control value
 ----------------------------------------------------------------------------
 make sure the card is not in monitor mode when we do this update.
 ----------------------------------------------------------------------------
 ----------------------------------------------------------------------------
 we are about to send new values to the card, so clear the new values queued
 flag.  Also, clear out mailbox 3, so we don't lockup.
 ----------------------------------------------------------------------------
 ----------------------------------------------------------------------------
 determine whether we are running a 48K or 44.1K clock.  This info is used
 later when setting the SPDIF FF after the volume has been shifted in.
 ----------------------------------------------------------------------------
 ----------------------------------------------------------------------------
 start the update.  Setup the bit structure and then shift the bits.
 ----------------------------------------------------------------------------
 ----------------------------------------------------------------------------
 now start shifting the bits in.  Start with the left channel then the right.
 ----------------------------------------------------------------------------
 ----------------------------------------------------------------------------
 Bring the loadshift line low, then wait - the spec says >150ns from load
 shift low to the first rising edge of the clock.
 ----------------------------------------------------------------------------
 loadshift goes low
 for all the bits
 data bit set high
 data bit set low
 data bit set high
 data bit set low
 clock goes low
 clock goes high
 ----------------------------------------------------------------------------
 finish up SPDIF for left.  Bring the loadshift line high, then write a one
 bit if the clock rate is 48K otherwise write 0.
 ----------------------------------------------------------------------------
 load shift goes high - clk low
 setclear data bit
 clock goes high
 clock goes low
 ----------------------------------------------------------------------------
 The update is complete.  Set a timeout.  This is the inter-update delay.
 Also, if the card was in monitor mode, restore it.
 ----------------------------------------------------------------------------
 ----------------------------------------------------
 tell the card to boot
 ----------------------------------------------------
 --------------------------------------------------------------------------------
 Let the card know where all the buffers are.
 --------------------------------------------------------------------------------
 size given to the card
 is based on 2 buffers
 --------------------------------------------------------------------------------
 Initialize the routing and volume tables, then update the card's state.
 --------------------------------------------------------------------------------
korg1212->sharedBufferPtr->routeData[channel] = channel;
 ------------------------------------------------------------------------
 an error occurred - stop the card
 ------------------------------------------------------------------------
 ------------------------------------------------------------------------
 the card has stopped by our request.  Clear the command word and signal
 the semaphore in case someone is waiting for this.
 ------------------------------------------------------------------------
 ---------------------------------------------------------------
 verify the state of the card before proceeding.
 ---------------------------------------------------------------
 timeout 
		 The other stream is open, and not by the same
		   task as this one. Make sure that the parameters
		   that matter are the same.
 FIXME: we should wait for ack! 
		
		korg1212->sharedBufferPtr->cardCommand = 0;
		del_timer(&korg1212->timer);
		korg1212->stop_pending_cnt = 0;
			if (korg1212->running) {
				K1212_DEBUG_PRINTK_VERBOSE("K1212_DEBUG: snd_korg1212_trigger: Already running?\n");
				break;
			}
			if (!korg1212->running) {
				K1212_DEBUG_PRINTK_VERBOSE("K1212_DEBUG: snd_korg1212_trigger: Already stopped?\n");
				break;
			}
 not used (interleaved data) 
  Control Interface
  proc interface
 K1212_LARGEALLOC
 K1212_LARGEALLOC
  Card initialisation
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for Digigram pcxhr compatible soundcards
  hwdep device manager
  Copyright (c) 2004 by Digigram <alsa@digigram.com>
  get basic information and init pcxhr card
 calc the number of all streams used 
 enable interrupts 
 test 4, 8 or 12 phys out 
 test 4, 8 or 2 phys in 
 test max nb substream per board 
 test max nb substream per pipe 
 firmware num for DSP 
 transfer granularity in samples (should be multiple of 48) 
 get options 
 analog addon board found 
 unmute inputs 
 unmute outputs (a write to IO_NUM_REG_MUTE_OUT mutes!) 
 unmute digital plugs 
 mute outputs 
 a read to IO_NUM_REG_MUTE_OUT register unmutes! 
 mute inputs 
 stereo cards mute with reset of dsp 
 reset pcxhr dsp 
 reset second xilinx 
   allocate a playbackcapture pipe (pcmp0pcmc0)
 always stereo 
 define pipe (P_PCM_ONLY_MASK (0x020000) is not necessary) 
 add P_PCM_ONLY_MASK 
 add channel mask to command 
   free playbackcapture pipe (pcmp0pcmc0)
 stop one pipe 
 release the pipe 
 allocate the pipes on the dsp 
 start all the pipes on the dsp 
 continue with first init 
 end of switch file index
 first communication with embedded 
 create devices and mixer in accordance with HW options
  fw loader entry
 fake hwdep dsp record 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for Digigram pcxhr compatible soundcards
  low level interface with interrupt and message handling implementation
  Copyright (c) 2004 by Digigram <alsa@digigram.com>
 registers used on the PLX (port 1) 
 registers used on the DSP (port 2) 
 access to the card 
 attention : access the PCXHR_DSP_ registers with inb and outb only ! 
 params used with PCXHR_PLX_MBOX0 
 params used with PCXHR_PLX_IRQCS 
 params used with PCXHR_PLX_CHIPSC 
 params used with PCXHR_DSP_ICR 
 params used with PCXHR_DSP_CVR 
 params used with PCXHR_DSP_ISR 
 constants used for delay in msec 
  pcxhr_check_reg_bit - wait for the specified bit is setreset on a register
  @reg: register to check
  @mask: bit mask
  @bit: resultant bit to be checked
  @time: time-out of loop in msec
  returns zero if a bit matches, or a negative error code.
 constants used with pcxhr_check_reg_bit() 
 clear hf5 bit 
 wait for CVR_HI08_HC == 0 
 wait for hf5 bit 
 retry not handled here 
 reset second xilinx 
 enabledisable interrupts 
 disable interrupts 
 let's reset the DSP 
 wait 2 msec 
 wait 2 msec 
 reset mailbox 
 enable interrupts 
  load the xilinx image
 test first xilinx 
 REV01 cards do not support the PCXHR_CHIPSC_GPI_USERI bit anymore 
	 this bit will always be 1;
	  no possibility to test presence of first xilinx
 activate second xilinx 
 wait 2 msec 
 don't take too much time in this loop... 
 wait 2 msec (time to boot the xilinx before any access) 
  send an executable file to the DSP
 check the length of boot image 
 transfert data buffer from PC to DSP 
 test data header consistency 
 wait DSP ready for new transfer 
 send host data 
 don't take too much time in this loop... 
 give some time to boot the DSP 
  load the eeprom image
 init value of the ICR register 
		 no need to load the eeprom binary,
		  but init the HI08 interface
 wait for chk bit 
  load the boot image
 send the hostport address to the DSP (only the upper 24 bit !) 
 clear hf5 bit 
 wait for hf5 bit 
  load the final dsp image
 wait for chk bit 
 command word 
 status length 
 status type (RMH_SSIZE_XXX) 
 RMH status type 
 status size fix (st_length = 0..x) 
 status size given in the LSB byte 
 status size given in bitmask 
  Array of DSP commands
 wait for receiver full 
 read data 
 need to update rmh->stat_len on the fly ?? 
 rmh->dsp_stat == RMH_SSIZE_MASK 
 wait for chk bit 
 reset irq chk 
 wait for chk bit == 0
 MASK_MORE_THAN_1_WORD_COMMAND 
 MASK_1_WORD_COMMAND 
 send length 
 send other words 
 wait for chk bit 
 test status ISR 
 ERROR, wait for receiver full 
 read error code 
 read the response data 
 reset semaphore 
  pcxhr_init_rmh - initialize the RMH instance
  @rmh: the rmh pointer to be initialized
  @cmd: the rmh command to be set
 COMMAND_RECORD_MASK 
  pcxhr_send_msg - send a DSP message with spinlock
  @rmh: the rmh record to send and receive
  returns 0 if successful, or a negative error code.
	 least segnificant 12 bits are the pipe states
	  for the playback audios
	  next 12 bits are the pipe states for the capture audios
	  (PCXHR_PIPE_STATE_CAPTURE_OFFSET)
 can start playback pipe 
 can start capture pipe 
			 if the pipe couldn't be prepaired for start,
			  retry it later
 stop playback pipe 
 stop capture pipe 
 now fire the interrupt on the card 
 current pipe state (playback + record) 
 start only pipes that are not yet started 
 success, all pipes prepaired 
 wait 1 millisecond and retry 
 stop only pipes that are started 
 have all pipes the new state ? 
 wait 10 microseconds 
 already programmed 
 clear events FREQ_CHANGE and TIME_CODE 
 add SEL_ASYNC_EVENTS 
 this is the only one extra long response command 
 if BIT_END 
 get sample count for one stream 
 rmh.stat_len = 2; 	
 add default if no hardware_read possible 
					 sub security offset because of
					  jitter and finer granularity of
					  dsp time (MBOX4)
			 if we didn't try to sync the position, increment it
			  by PCXHR_GRANULARITY every timer interrupt
 this device did not cause the interrupt 
 clear interrupt 
 timer irq occurred 
 other irq's handled in the thread 
			 as we didn't request any async notifications,
			  some kind of xrun error will probably occurred
 better resynchronize all streams next interrupt : 
 is a 24 bit counter 
 handle dsp counter wraparound without resync 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for Digigram pcxhr compatible soundcards
  main file with alsa callbacks
  Copyright (c) 2004 by Digigram <alsa@digigram.com>
 Index 0-MAX 
 ID for this card 
 Enable this card 
 capture  mono only 
 boards without hw AES1 and SRC onboard are all using fw_file_set==4 
 VX222HR, VX222e, PCX22HR and PCX22e 
 some boards do not support 192kHz on digital AES input plugs 
 clock by quartz or pll 
 get the value for the pll register 
 codec speed modes 
 single speed 
 dual speed 
 quad speed 
 mute outputs 
 set speed ratio 
 set the new frequency 
 unmute after codec speed modes 
 unmute outputs 
 save new codec speed 
 nothing to do 
 resync fifos  
 wait minimum 2 sample_frames at 32kHz ! 
   start or stop playbackcapture substream
 reset theoretical stream pos 
 bug with old dsp versions: 
 bit 12 also sets the format of the playback stream 
 add channels and set bit 19 if channels>2 
 playback : add channel mask to command 
 max buffer size is 2 MByte 
 size in bits 
 most significant byte 
 this is a circular buffer 
 least 3 significant bytes 
 check the pipes concerned and build pipe_array 
				break;	 add only once, as all playback
					  streams of one chip use the same pipe
 synchronous stop of all the pipes concerned 
 the dsp lost format and buffer info with the stop pipe 
 start all the streams 
 synchronous start of all the pipes concerned 
	 put the streams into the running state now
	  (increment pointer by interrupt)
 playback will already have advanced ! 
   trigger callback
 TODO 
 last dsp time invalid 
   prepare callback for all pcms
 only the first stream can choose the sample rate 
 set the clock only once (first stream) 
 start the DSP-timer 
 do only once (so we can use break instead of goto) 
   HW_PARAMS callback for all pcms
 set up channels 
 set up format for the stream 
   CONFIGURATION SPACE for all pcms, mono pcm must update channels_max
 1 byte == 1 frame U8 mono (PCXHR_GRANULARITY is frames!) 
 copy the struct snd_pcm_hardware struct 
 streams in use 
 float format support is in some cases buggy on stereo cards 
 buffer-size should better be multiple of period-size 
	 if a sample rate is already used or fixed by external clock,
	  the stream cannot change
 cannot detect the external clock rate 
 not configured yet 
 better get a divisor of granularity values (96 or 192) 
 sample rate released 
 the sample rate is no more locked 
 stop the DSP-timer 
 get the period fragment and the nb of periods in the buffer 
 stereo or mono streams 
 2 mono streams 
 or 1 stereo stream 
 proc interface 
 stats available when embedded DSP is running 
 calc cpu load of the dsp 
 debug zone dsp 
 commands available when embedded DSP is running 
 commands available when embedded DSP is running 
 gpio ports on stereo boards only available 
 GPI 
 GP0 
 commands available when embedded DSP is running 
 GP0 
 Access to the results of the CMD_GET_TIME_CODE RMH 
 Values for the CMD_MANAGE_SIGNAL RMH 
 linear time code read proc
 commands available when embedded DSP is running 
	snd_iprintf(buffer, "dsp ref time: 0x%06x%06x\n",
 gpio available on stereo sound cards only 
 end of proc interface 
  release all the cards assigned to a manager instance
 reset board if some firmware was loaded 
 release irq  
 free hostport purgebuffer 
     probe function - creates the card manager
 enable PCI device 
 check if we can restrict PCI DMA transfers to 32 bits 
 alloc card manager 
 resource assignment 
 ISR lock  
 init setup mutex
 init proc interface only for chip0 
 create hostport purgebuffer 
 init purgebuffer 
 create a DSP loader 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for Digigram pcxhr compatible soundcards
  mixer callbacks
  Copyright (c) 2004 by Digigram <alsa@digigram.com>
 -112.0 dB 
 +15.5 dB 
 0.0 dB ( 0 dBu -> 0 dBFS ) 
 -104.0 dB 
 +24.0 dB 
 0.0 dB ( 0 dBFS -> 0 dBu ) 
 playback analog levels are inversed 
 audio mask 
  analog level control
 playback 
 -25 dB 
 +24 dB 
-104 dB 
 +24 dB 
 capture 
-112 dB 
 +15.5 dB 
-112 dB 
 +15.5 dB 
 playback 
 capture 
 name will be filled later 
 tlv will be filled later 
 shared 
 update playback levels 
 shared 
 -110 dB 
 +18 dB 
  0 dB 
 add pipe and stream mask 
 volume left->left  right->right panoramic level 
 add channel mask 
	 TODO : if mask (3 << pipe->first_audio) is used, left and right
		 VALID_AUDIO_IO_MUTE_LEVEL not yet handled
		 VALID_AUDIO_IO_DIGITAL_LEVEL and VALID_AUDIO_IO_MUTE_LEVEL
		  not yet handled (playback pipe level)
 shared 
 -109.5 dB 
   18.0 dB 
 index 
 digital capture 
 digital playback 
 index 
 digital capture 
 digital playback 
 update capture volume 
 update playback volume 
 name will be filled later 
 count will be filled later 
 shared 
 index 
 index 
 shared 
  monitoring level control
 update monitoring volume and mute 
 do only when monitoring is unmuted 
 shared 
  monitoring switch control
 mask 0x01 and 0x02 
 update left monitoring volume and mute 
 update right monitoring volume and mute 
 shared 
  audio source select
 audio source from digital plug 
 audio source from analog plug 
 set the input source 
 resync them (otherwise channel inversion possible) 
 update all src configs with one call 
 set codec SRC on off 
 set codec SRC on off 
 no SRC, no Mic available 
 SRC available 
 Mic and MicroMix available 
 no SRC, no Mic available 
 SRC available 
 Mic and MicroMix available 
  clock type selection
  enum pcxhr_clock_type {
 	PCXHR_CLOCK_TYPE_INTERNAL = 0,
 	PCXHR_CLOCK_TYPE_WORD_CLOCK,
 	PCXHR_CLOCK_TYPE_AES_SYNC,
 	PCXHR_CLOCK_TYPE_AES_1,
 	PCXHR_CLOCK_TYPE_AES_2,
 	PCXHR_CLOCK_TYPE_AES_3,
 	PCXHR_CLOCK_TYPE_AES_4,
 	PCXHR_CLOCK_TYPE_MAX = PCXHR_CLOCK_TYPE_AES_4,
 	HR22_CLOCK_TYPE_INTERNAL = PCXHR_CLOCK_TYPE_INTERNAL,
 	HR22_CLOCK_TYPE_AES_SYNC,
 	HR22_CLOCK_TYPE_AES_1,
 	HR22_CLOCK_TYPE_MAX = HR22_CLOCK_TYPE_AES_1,
  };
 at least Internal and AES Sync clock 
 add AES x 
 add word clock 
 at least Internal and AES Sync clock 
 add AES x 
 add word clock 
 return 1 even if the set was not done. ok ? 
  clock rate control
  specific control that scans the sample rates on the external plugs
 clock not present 
 max sample rate 192 kHz 
  IEC958 status bits
 instead of CS8420_01_CS use CS8416_01_CS for AES SYNC plug 
 instead of CS8420_CSB0 use CS8416_CSBx for AES SYNC plug 
 size and code the chip id for the fpga 
 chip signature + map for spi read 
 reversed bit order (not with CS8416_01_CS) 
 playback 
 capture 
 chip index 0..3 
 new bit used if chip_idx>3 (PCX1222HR) 
 add bit offset 
 add bit value 
 playback 
 playback 
 capture 
 at boot time the digital volumes are unmuted 0dB 
			 after boot, only two bits are set on the uer
			  interface
			 analog volumes for playback
			  (is LEVEL_MIN after boot)
 stereo cards need to be initialised after boot 
 at boot time the digital volumes are unmuted 0dB 
			 analog volumes for playback
			  (is LEVEL_MIN after boot)
 stereo cards need to be initialised after boot 
 can be in another place 
 analog output level control 
 playback 
 output mute controls 
 playback 
 IEC958 controls 
 analog input level control 
 capture 
 capture 
 Audio source 
 IEC958 controls 
 monitoring only if playback and capture device available 
 monitoring 
 clock mode only one control per pcxhr 
			 non standard control used to scan
			  the external clock presencefrequencies
 init values for the mixer data 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for Digigram pcxhr compatible soundcards
  mixer interface for stereo cards
  Copyright (c) 2004 by Digigram <alsa@digigram.com>
 registers used on the DSP and Xilinx (port 2) : HR stereo cards only 
 byte access only ! 
 values for PCHR_DSP_RESET register 
 values for PCHR_XLX_CFG register 
 0 (UER0), 1(UER1) 
 0 (ana), 1 (UER) 
 0 (Bypass), 1 (SRC Actif) 
 0 (UER0), 1(UER1) 
 0 (internal), 1 (AESEBU) 
 values for PCHR_XLX_DATA register 
 values for PCHR_XLX_STATUS register - READ 
 values for PCHR_XLX_STATUS register - WRITE 
 values for PCHR_XLX_CSUER register 
 values for PCXHR_XLX_SELMIC register - WRITE 
 [000] -49.5 dB:	AKM[000] = -1.#INF dB	(mute) 
 [001] -49.0 dB:	AKM[001] = -48.131 dB	(diff=0.86920 dB) 
 [002] -48.5 dB:	AKM[001] = -48.131 dB	(diff=0.36920 dB) 
 [003] -48.0 dB:	AKM[001] = -48.131 dB	(diff=0.13080 dB) 
 [004] -47.5 dB:	AKM[001] = -48.131 dB	(diff=0.63080 dB) 
 [005] -46.5 dB:	AKM[001] = -48.131 dB	(diff=1.63080 dB) 
 [006] -47.0 dB:	AKM[001] = -48.131 dB	(diff=1.13080 dB) 
 [007] -46.0 dB:	AKM[001] = -48.131 dB	(diff=2.13080 dB) 
 [008] -45.5 dB:	AKM[001] = -48.131 dB	(diff=2.63080 dB) 
 [009] -45.0 dB:	AKM[002] = -42.110 dB	(diff=2.88980 dB) 
 [010] -44.5 dB:	AKM[002] = -42.110 dB	(diff=2.38980 dB) 
 [011] -44.0 dB:	AKM[002] = -42.110 dB	(diff=1.88980 dB) 
 [012] -43.5 dB:	AKM[002] = -42.110 dB	(diff=1.38980 dB) 
 [013] -43.0 dB:	AKM[002] = -42.110 dB	(diff=0.88980 dB) 
 [014] -42.5 dB:	AKM[002] = -42.110 dB	(diff=0.38980 dB) 
 [015] -42.0 dB:	AKM[002] = -42.110 dB	(diff=0.11020 dB) 
 [016] -41.5 dB:	AKM[002] = -42.110 dB	(diff=0.61020 dB) 
 [017] -41.0 dB:	AKM[002] = -42.110 dB	(diff=1.11020 dB) 
 [018] -40.5 dB:	AKM[002] = -42.110 dB	(diff=1.61020 dB) 
 [019] -40.0 dB:	AKM[003] = -38.588 dB	(diff=1.41162 dB) 
 [020] -39.5 dB:	AKM[003] = -38.588 dB	(diff=0.91162 dB) 
 [021] -39.0 dB:	AKM[003] = -38.588 dB	(diff=0.41162 dB) 
 [022] -38.5 dB:	AKM[003] = -38.588 dB	(diff=0.08838 dB) 
 [023] -38.0 dB:	AKM[003] = -38.588 dB	(diff=0.58838 dB) 
 [024] -37.5 dB:	AKM[003] = -38.588 dB	(diff=1.08838 dB) 
 [025] -37.0 dB:	AKM[004] = -36.090 dB	(diff=0.91040 dB) 
 [026] -36.5 dB:	AKM[004] = -36.090 dB	(diff=0.41040 dB) 
 [027] -36.0 dB:	AKM[004] = -36.090 dB	(diff=0.08960 dB) 
 [028] -35.5 dB:	AKM[004] = -36.090 dB	(diff=0.58960 dB) 
 [029] -35.0 dB:	AKM[005] = -34.151 dB	(diff=0.84860 dB) 
 [030] -34.5 dB:	AKM[005] = -34.151 dB	(diff=0.34860 dB) 
 [031] -34.0 dB:	AKM[005] = -34.151 dB	(diff=0.15140 dB) 
 [032] -33.5 dB:	AKM[005] = -34.151 dB	(diff=0.65140 dB) 
 [033] -33.0 dB:	AKM[006] = -32.568 dB	(diff=0.43222 dB) 
 [034] -32.5 dB:	AKM[006] = -32.568 dB	(diff=0.06778 dB) 
 [035] -32.0 dB:	AKM[006] = -32.568 dB	(diff=0.56778 dB) 
 [036] -31.5 dB:	AKM[007] = -31.229 dB	(diff=0.27116 dB) 
 [037] -31.0 dB:	AKM[007] = -31.229 dB	(diff=0.22884 dB) 
 [038] -30.5 dB:	AKM[008] = -30.069 dB	(diff=0.43100 dB) 
 [039] -30.0 dB:	AKM[008] = -30.069 dB	(diff=0.06900 dB) 
 [040] -29.5 dB:	AKM[009] = -29.046 dB	(diff=0.45405 dB) 
 [041] -29.0 dB:	AKM[009] = -29.046 dB	(diff=0.04595 dB) 
 [042] -28.5 dB:	AKM[010] = -28.131 dB	(diff=0.36920 dB) 
 [043] -28.0 dB:	AKM[010] = -28.131 dB	(diff=0.13080 dB) 
 [044] -27.5 dB:	AKM[011] = -27.303 dB	(diff=0.19705 dB) 
 [045] -27.0 dB:	AKM[011] = -27.303 dB	(diff=0.30295 dB) 
 [046] -26.5 dB:	AKM[012] = -26.547 dB	(diff=0.04718 dB) 
 [047] -26.0 dB:	AKM[013] = -25.852 dB	(diff=0.14806 dB) 
 [048] -25.5 dB:	AKM[014] = -25.208 dB	(diff=0.29176 dB) 
 [049] -25.0 dB:	AKM[014] = -25.208 dB	(diff=0.20824 dB) 
 [050] -24.5 dB:	AKM[015] = -24.609 dB	(diff=0.10898 dB) 
 [051] -24.0 dB:	AKM[016] = -24.048 dB	(diff=0.04840 dB) 
 [052] -23.5 dB:	AKM[017] = -23.522 dB	(diff=0.02183 dB) 
 [053] -23.0 dB:	AKM[018] = -23.025 dB	(diff=0.02535 dB) 
 [054] -22.5 dB:	AKM[019] = -22.556 dB	(diff=0.05573 dB) 
 [055] -22.0 dB:	AKM[020] = -22.110 dB	(diff=0.11020 dB) 
 [056] -21.5 dB:	AKM[021] = -21.686 dB	(diff=0.18642 dB) 
 [057] -21.0 dB:	AKM[023] = -20.896 dB	(diff=0.10375 dB) 
 [058] -20.5 dB:	AKM[024] = -20.527 dB	(diff=0.02658 dB) 
 [059] -20.0 dB:	AKM[026] = -19.831 dB	(diff=0.16866 dB) 
 [060] -19.5 dB:	AKM[027] = -19.504 dB	(diff=0.00353 dB) 
 [061] -19.0 dB:	AKM[029] = -18.883 dB	(diff=0.11716 dB) 
 [062] -18.5 dB:	AKM[030] = -18.588 dB	(diff=0.08838 dB) 
 [063] -18.0 dB:	AKM[032] = -18.028 dB	(diff=0.02780 dB) 
 [064] -17.5 dB:	AKM[034] = -17.501 dB	(diff=0.00123 dB) 
 [065] -17.0 dB:	AKM[036] = -17.005 dB	(diff=0.00475 dB) 
 [066] -16.5 dB:	AKM[038] = -16.535 dB	(diff=0.03513 dB) 
 [067] -16.0 dB:	AKM[040] = -16.090 dB	(diff=0.08960 dB) 
 [068] -15.5 dB:	AKM[043] = -15.461 dB	(diff=0.03857 dB) 
 [069] -15.0 dB:	AKM[045] = -15.067 dB	(diff=0.06655 dB) 
 [070] -14.5 dB:	AKM[048] = -14.506 dB	(diff=0.00598 dB) 
 [071] -14.0 dB:	AKM[051] = -13.979 dB	(diff=0.02060 dB) 
 [072] -13.5 dB:	AKM[054] = -13.483 dB	(diff=0.01707 dB) 
 [073] -13.0 dB:	AKM[057] = -13.013 dB	(diff=0.01331 dB) 
 [074] -12.5 dB:	AKM[060] = -12.568 dB	(diff=0.06778 dB) 
 [075] -12.0 dB:	AKM[064] = -12.007 dB	(diff=0.00720 dB) 
 [076] -11.5 dB:	AKM[068] = -11.481 dB	(diff=0.01937 dB) 
 [077] -11.0 dB:	AKM[072] = -10.984 dB	(diff=0.01585 dB) 
 [078] -10.5 dB:	AKM[076] = -10.515 dB	(diff=0.01453 dB) 
 [079] -10.0 dB:	AKM[081] = -9.961 dB	(diff=0.03890 dB) 
 [080] -9.5 dB:	AKM[085] = -9.542 dB	(diff=0.04243 dB) 
 [081] -9.0 dB:	AKM[090] = -9.046 dB	(diff=0.04595 dB) 
 [082] -8.5 dB:	AKM[096] = -8.485 dB	(diff=0.01462 dB) 
 [083] -8.0 dB:	AKM[102] = -7.959 dB	(diff=0.04120 dB) 
 [084] -7.5 dB:	AKM[108] = -7.462 dB	(diff=0.03767 dB) 
 [085] -7.0 dB:	AKM[114] = -6.993 dB	(diff=0.00729 dB) 
 [086] -6.5 dB:	AKM[121] = -6.475 dB	(diff=0.02490 dB) 
 [087] -6.0 dB:	AKM[128] = -5.987 dB	(diff=0.01340 dB) 
 [088] -5.5 dB:	AKM[135] = -5.524 dB	(diff=0.02413 dB) 
 [089] -5.0 dB:	AKM[143] = -5.024 dB	(diff=0.02408 dB) 
 [090] -4.5 dB:	AKM[152] = -4.494 dB	(diff=0.00607 dB) 
 [091] -4.0 dB:	AKM[161] = -3.994 dB	(diff=0.00571 dB) 
 [092] -3.5 dB:	AKM[170] = -3.522 dB	(diff=0.02183 dB) 
 [093] -3.0 dB:	AKM[181] = -2.977 dB	(diff=0.02277 dB) 
 [094] -2.5 dB:	AKM[191] = -2.510 dB	(diff=0.01014 dB) 
 [095] -2.0 dB:	AKM[203] = -1.981 dB	(diff=0.01912 dB) 
 [096] -1.5 dB:	AKM[215] = -1.482 dB	(diff=0.01797 dB) 
 [097] -1.0 dB:	AKM[227] = -1.010 dB	(diff=0.01029 dB) 
 [098] -0.5 dB:	AKM[241] = -0.490 dB	(diff=0.00954 dB) 
 [099] +0.0 dB:	AKM[255] = +0.000 dB	(diff=0.00000 dB) 
 activate access to codec registers 
 termiate access to codec registers 
 conversion from PmBoardCodedLevel to AKM nonlinear programming 
 program all input levels at the same time 
 no PCX22 
 micro is mono, but apply 
 level on both channels 
 line input right channel 
 line input left channel 
 activate input codec 
 send 32 bits (4 x 8 bits) 
 close input level codec 
 analog always available 
 microphone available 
 reset codec 
 hr222_write_gpo(mgr, 0); does the same 
 config AKM 
 init micro boost 
 calc PLL register 
 TODO : there is a very similar fct in pcxhr.c 
 set clock source 
 codec speed modes 
 other clocks not supported 
 no external clock locked 
 calculate freq 
 save the measured clock frequency 
 wait min 2 cycles of lowest freq (8000) 
 save 
 get the frequency 
 rounding 
 we have to update all levels 
texts[5] = {"Line", "Digital", "Digi+SRC", "Mic", "Line+Mic"}
 default analog source 
 get data from the AES1 plug 
 chip->mic_active = 0; 
 chip->analog_capture_active = 0; 
 capture: update all 3 mutesunmutes with one call 
 set the source infos (max 3 bits modified) 
 idx < 192 
 idx < 192 
 write C and U bit 
 only values form 0 to 3 accepted 
 mic level 
 -98 dB 
 gains from 9 dB to 31.5 dB not recommended; use micboost instead 
  +7 dB 
 mic boost level 
  0 dB 
 54 dB 
 Phantom power switch 
 controls 
   Copyright Echo Digital Audio Corporation (c) 1998 - 2004
   All rights reserved
   www.echoaudio.com
   This file is part of Echo Digital Audio's generic driver library.
   Echo Digital Audio's generic driver library is free software;
   you can redistribute it andor modify it under the terms of
   the GNU General Public License as published by the Free Software
   Foundation.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston,
   MA  02111-1307, USA.
 Translation from C++ and adaptation for use in ALSA-Driver
 were made by Giuliano Pochini <pochini@shiny.it>
	 Since this card has no ASIC, mark it as loaded so everything
	 Map the DSP clock detect bits to the generic driver clock
 The Darla24 has no ASIC. Just do nothing 
 Override the sample rate if this card is set to Echo sync. 
 ignored by the DSP ? 
This file is part of Echo Digital Audio's generic driver library.
Copyright Echo Digital Audio Corporation (c) 1998 - 2005
All rights reserved
www.echoaudio.com
This library is free software; you can redistribute it andor
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.
You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 Translation from C++ and adaptation for use in ALSA-Driver
 were made by Giuliano Pochini <pochini@shiny.it>
	 Since this card has no ASIC, mark it as loaded so everything
This file is part of Echo Digital Audio's generic driver library.
Copyright Echo Digital Audio Corporation (c) 1998 - 2005
All rights reserved
www.echoaudio.com
This library is free software; you can redistribute it andor
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.
You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 Translation from C++ and adaptation for use in ALSA-Driver
 were made by Giuliano Pochini <pochini@shiny.it>
	 Since this card has no ASIC, mark it as loaded so everything
 SPDX-License-Identifier: GPL-2.0-only
   ALSA driver for Echoaudio soundcards.
   Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>
 Pipe indexes 
 8 
 0 
 2 
 0 
 Bus indexes 
 2 
 0 
 2 
 0 
 Indigo IO
 SPDX-License-Identifier: GPL-2.0-only
   ALSA driver for Echoaudio soundcards.
   Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>
   Copyright (C) 2020 Mark Hills <mark@xwax.org>
	PCM interface
 >=2 channels cannot be S32_BE 
 > 2 channels cannot be U8 and S32_BE 
 Mono is ok with any format 
 S32_BE is mono (and stereo) only 
 U8 can be only mono or stereo 
 S16_LE, S24_3LE and S32_LE support any number of channels. 
 >2 channels must be S16_LE, S24_3LE or S32_LE 
 1 channel must be S32_BE or S32_LE 
 2 channels cannot be S32_BE 
 S32_BE is mono (and stereo) only 
 U8 is stereo only 
 S16_LE and S24_3LE must be at least stereo 
 Since the sample rate is a global setting, do allow the user to change the
 Not configured yet 
 Set up hw capabilities and contraints 
 Only mono and any even number of channels are allowed 
 All periods should have the same size 
	 The hw accesses memory in chunks 32 frames long and they should be
	32-bytes-aligned. It's not a requirement, but it seems that IRQs are
 Allocate a page for the scatter-gather list 
	
	  Sole ownership required to set the rate
	else	 If the card has ADAT, subtract the 6 channels
		  that SPDIF doesn't have
 See the note in snd_echo_new_pcm() 
	else	 If the card has ADAT, subtract the 6 channels
		  that SPDIF doesn't have
 !ECHOCARD_HAS_VMIXER 
 ECHOCARD_HAS_DIGITAL_IO 
	 Nothing to do here. Audio is already off and pipe will be
	  freed by its callback
 Channel allocation and scatter-gather list setup 
	 Sets up che hardware. If it's already initialized, reset and
	  redo with the new parameters
 Close the ring buffer 
	 This stuff is used by the irq handler, so it must be
	  initialized before chip->substream
 See the note in snd_echo_new_pcm() 
 !ECHOCARD_HAS_VMIXER 
 ECHOCARD_HAS_DIGITAL_IO 
	
	  We passed checks we can do independently; now take
	  exclusive control
	
	  IRQ handling runs concurrently. Do not share tracking of
	  counter with it, which would race or require locking
 presumed atomic 
 handles wrapping 
	 counter doesn't neccessarily wrap on a multiple of
	  buffer_size, so can't derive the position; must
 wrap 
 pcm _ops structures 
 !ECHOCARD_HAS_VMIXER 
 ECHOCARD_HAS_DIGITAL_IO 
 Preallocate memory only for the first substream because it's the most
  used one
<--snd_echo_probe() 
	 This card has a Vmixer, that is there is no direct mapping from PCM
	streams to physical outputs. The user can mix the streams as he wishes
	via control interface and it's possible to send any stream to any
	output, thus it makes no sense to keep analog and digital outputs
 PCM#0 Virtual outputs and analog inputs 
 PCM#1 Digital inputs, no outputs 
 ECHOCARD_HAS_DIGITAL_IO 
 ECHOCARD_HAS_VMIXER 
	 The card can manage substreams formed by analog and digital channels
	at the same time, but I prefer to keep analog and digital channels
	separated, because that mixed thing is confusing and useless. So we
 PCM#0 Analog io 
 PCM#1 Digital io 
 ECHOCARD_HAS_DIGITAL_IO 
 ECHOCARD_HAS_VMIXER 
	Control interface
 PCM output volume 
 Ignore out of range values 
 On the Mia this one controls the line-out volume 
 !ECHOCARD_HAS_VMIXER || ECHOCARD_HAS_LINE_OUT_GAIN 
 Analog input volume 
 Ignore out of range values 
 ECHOCARD_HAS_INPUT_GAIN 
 Analog output nominal level (+4dBu  -10dBV) 
 ECHOCARD_HAS_OUTPUT_NOMINAL_LEVEL 
 Analog input nominal level (+4dBu  -10dBV) 
		update_output_line_level(chip);	 "Output" is not a mistake
						  here.
 ECHOCARD_HAS_INPUT_NOMINAL_LEVEL 
 Monitor mixer 
 ECHOCARD_HAS_MONITOR 
 Vmixer 
 ECHOCARD_HAS_VMIXER 
 Digital mode switch 
		 mode_mutex is required to make this operation atomic wrt
		 Do not allow the user to change the digital mode when a pcm
		device is open because it also changes the number of channels
 If we had to change the clock source, report it 
 No errors 
 ECHOCARD_HAS_DIGITAL_MODE_SWITCH 
 SPDIF mode switch 
 ECHOCARD_HAS_DIGITAL_IO 
 Select input clock source 
 no errors 
 ECHOCARD_HAS_EXTERNAL_CLOCK 
 Phantom power switch 
 no errors 
 ECHOCARD_HAS_PHANTOM_POWER 
 Digital input automute switch 
 no errors 
 ECHOCARD_HAS_DIGITAL_IN_AUTOMUTE 
 VU-meters switch 
 Read VU-meters (input, output, analog and digital together) 
 Channels info - it exports informations about the number of channels 
 Compute the bitmask of the currently valid input clocks 
	IRQ Handling
 Check if a period has elapsed since last interrupt
  Don't make any updates to state; PCM core handles this with the
  correct locks.
  \return true if a period has elapsed, otherwise false
 presumed atomic 
 handles wrapping 
 acknowledge whole periods only 
 haven't advanced a whole period yet 
 used exclusively by us 
	 The hardware doesn't tell us which substream caused the irq,
	Module construction  destruction
 release chip data 
 <--snd_echo_probe() 
 Allocate chip if needed 
 PCI resource allocation 
 We map only the required part 
	 Create the DSP comm page - this is the area of memory used for most
 constructor 
 Some Mia's do not have midi 
 ECHOCARD_HAS_VMIXER 
 ECHOCARD_HAS_VMIXER 
 Creates a list of available digital modes 
 ECHOCARD_HAS_DIGITAL_MODE_SWITCH 
 Creates a list of available clock sources 
 ECHOCARD_HAS_EXTERNAL_CLOCK 
 This call can sleep 
	 Temporarily set chip->pipe_alloc_mask=0 otherwise
	  restore_dsp_settings() fails.
 CONFIG_PM_SLEEP 
	Everything starts and ends here
 pci_driver definition 
 SPDX-License-Identifier: GPL-2.0-only
   ALSA driver for Echoaudio soundcards.
   Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>
 Pipe indexes 
 8 
 2 
 2 
 2 
 Bus indexes 
 8 
 2 
 2 
 2 
 DSP 56301 Gina20 rev.0 
	 One page (4k) contains 512 instructions. I don't know if the hw
	supports lists longer than this. In this case periods_max=220 is a
   Copyright Echo Digital Audio Corporation (c) 1998 - 2004
   All rights reserved
   www.echoaudio.com
   This file is part of Echo Digital Audio's generic driver library.
   Echo Digital Audio's generic driver library is free software;
   you can redistribute it andor modify it under the terms of
   the GNU General Public License as published by the Free Software
   Foundation.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston,
   MA  02111-1307, USA.
 Translation from C++ and adaptation for use in ALSA-Driver
 were made by Giuliano Pochini <pochini@shiny.it>
 These functions are common for all "3G" cards 
 Most configuration of 3G cards is accomplished by writing the control
 Set the digital mode - currently for Gina24, Layla24, Mona, 3G 
 All audio channels must be closed before changing the digital mode 
	 If we successfully changed the digital mode from or to ADAT,
	  then make sure all output, input and monitor levels are
 Set the SPDIF output format 
 detect_input_clocks() returns a bitmask consisting of all the input clocks
currently connected to the hardware; this changes as the user connects and
disconnects clock inputs. You should use this information to determine which
	 Map the DSP clock detect bits to the generic driver clock
 Give the DSP a few milliseconds to settle down 
 Now give the new ASIC some time to set up 
 See if it worked 
	 Set up the control register if the load succeeded -
 Only set the clock for internal mode. 
 Save the rate anyhow 
 ignored by the DSP 
 Tell the DSP about it - DSP reads both control reg & freq reg 
 Set the sample clock source to internal, SPDIF, ADAT 
 Mask off the clock select bits 
 Set clock to "internal" if it's not compatible with the new mode 
 Clear the current digital mode 
 Tweak the control reg 
 E3G_SPDIF_OPTICAL_MODE bit cleared 
 @@ useless 
   Copyright Echo Digital Audio Corporation (c) 1998 - 2004
   All rights reserved
   www.echoaudio.com
   This file is part of Echo Digital Audio's generic driver library.
   Echo Digital Audio's generic driver library is free software;
   you can redistribute it andor modify it under the terms of
   the GNU General Public License as published by the Free Software
   Foundation.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston,
   MA  02111-1307, USA.
 Translation from C++ and adaptation for use in ALSA-Driver
 were made by Giuliano Pochini <pochini@shiny.it>
 Map the DSP clock detect bits to the generic driver clock detect bits 
 ASIC status check - some cards have one or two ASICs that need to be
loaded.  Once that load is complete, this function is called to see if
the load was successful.
If this load fails, it does not necessarily mean that the hardware is
defective - the external box may be disconnected or turned off.
This routine sometimes fails for Layla20; for Layla20, the loop runs
		 The DSP will return a value to indicate whether or not
 Layla20 has an ASIC in the external box 
 Check if ASIC is alive and well. 
	 Only set the clock for internal mode. Do not return failure,
 Set input bus gain (one unit is 0.5dB !) 
 Tell the DSP to reread the flags from the comm page 
 SPDX-License-Identifier: GPL-2.0-only
   ALSA driver for Echoaudio soundcards.
   Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>
 Pipe indexes 
 8 
 0 
 2 
 0 
 Bus indexes 
 8 
 0 
 2 
 0 
 DSP 56301 Darla24 rev.0 
 DSP 56301 Darla24 rev.1 
	 One page (4k) contains 512 instructions. I don't know if the hw
	supports lists longer than this. In this case periods_max=220 is a
   Copyright Echo Digital Audio Corporation (c) 1998 - 2004
   All rights reserved
   www.echoaudio.com
   This file is part of Echo Digital Audio's generic driver library.
   Echo Digital Audio's generic driver library is free software;
   you can redistribute it andor modify it under the terms of
   the GNU General Public License as published by the Free Software
   Foundation.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston,
   MA  02111-1307, USA.
 Translation from C++ and adaptation for use in ALSA-Driver
 were made by Giuliano Pochini <pochini@shiny.it>
 Gina24 comes in both '301 and '361 flavors 
	 Map the DSP clock detect bits to the generic driver clock
 Gina24 has an ASIC on the PCI card which must be loaded for anything
 Give the DSP a few milliseconds to settle down 
 Pick the correct ASIC for '301 or '361 Gina24 
 Now give the new ASIC a little time to set up 
 See if it worked 
	 Set up the control register if the load succeeded -
 Only set the clock for internal mode. 
 Save the rate anyhow 
 Professional mode ? 
 ignored by the DSP 
 Mask off the clock select bits 
 Set clock to "internal" if it's not compatible with the new mode 
 Switch to 48KHz, internal 
 Clear the current digital mode 
 Tweak the control reg 
 '361 Gina24 cards do not have the SPDIF CD-ROM mode 
 GML_SPDIF_OPTICAL_MODE bit cleared 
   Copyright Echo Digital Audio Corporation (c) 1998 - 2004
   All rights reserved
   www.echoaudio.com
   This file is part of Echo Digital Audio's generic driver library.
   Echo Digital Audio's generic driver library is free software;
   you can redistribute it andor modify it under the terms of
   the GNU General Public License as published by the Free Software
   Foundation.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston,
   MA  02111-1307, USA.
 Translation from C++ and adaptation for use in ALSA-Driver
 were made by Giuliano Pochini <pochini@shiny.it>
	 Since this card has no ASIC, mark it as loaded so everything
 The IndigoIO has no ASIC. Just do nothing 
 This function routes the sound from a virtual channel to a real output 
 Tell the DSP to read and update virtual mixer levels in comm page. 
   Copyright Echo Digital Audio Corporation (c) 1998 - 2004
   All rights reserved
   www.echoaudio.com
   This file is part of Echo Digital Audio's generic driver library.
   Echo Digital Audio's generic driver library is free software;
   you can redistribute it andor modify it under the terms of
   the GNU General Public License as published by the Free Software
   Foundation.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston,
   MA  02111-1307, USA.
 Translation from C++ and adaptation for use in ALSA-Driver
 were made by Giuliano Pochini <pochini@shiny.it>
 Some vector commands involve the DSP reading or writing data to and from the
comm page; if you send one of these commands to the DSP, it will complete the
command and then write a non-zero value to the Handshake field in the
 Wait up to 20ms for the handshake from the DSP 
 Look for the handshake value 
 Much of the interaction between the DSP and the driver is done via vector
commands; send_vector writes a vector command to the DSP.  Typically, this
causes the DSP to read or write fields in the comm page.
 Flush all pending writes before sending the command 
 Wait up to 100ms for the "vector busy" bit to be off 
if (i)  DE_ACT(("send_vector time: %d\n", i));
 write_dsp writes a 32-bit value to the DSP; this is used almost
 timeout = 10s 
 write it immediately 
 Set true until DSP re-loaded 
 read_dsp reads a 32-bit value from the DSP; this is used almost
 Set true until DSP re-loaded 
	Firmware loading functions
 This function is used to read back the serial number from the DSP;
this is triggered by the SET_COMMPAGE_ADDR command.
Only some early Echogals products have serial numbers in the ROM;
the serial number is not used, but you still need to do this as
 This card has no ASIC, just return ok 
 !ECHOCARD_HAS_ASIC 
 Load ASIC code - done after the DSP is loaded 
 Send the "Here comes the ASIC" command 
 Write length of ASIC file in bytes 
 ECHOCARD_HAS_ASIC 
 Install the resident loader for 56361 DSPs;  The resident loader is on
the EPROM on the board for 56301 DSP. The resident loader is a tiny little
	 56361 cards only!  This check is required by the old 56301-based
	 Look to see if the resident loader is present.  If the resident
	 The DSP code is an array of 16 bit words.  The array is divided up
	into sections.  The first word of each section is the size in words,
	followed by the section type.
	Since DSP addresses and data are 24 bits wide, they each take up two
	16 bit words in the array.
	This is a lot like the other loader loop, but it's not a loop, you
 Set DSP format bits for 24 bit mode 
	 Skip the header section; the first word in the array is the size
	of the first section, so the first real section of code is pointed
 Skip the section size, LRS block type, and DSP memory type 
 Get the number of DSP words to write 
 Get the DSP address for this block; 24 bits, so build from two words 
 Write the count to the DSP 
 Write the DSP address 
 Write out this block of code to the DSP 
 Wait for flag 5 to come up 
 Timeout is 50us  200 = 10ms 
 DSP_56361 
 Set true until DSP loaded 
 Current DSP code not loaded 
 Loading the DSP code will reset the ASIC 
 If this board requires a resident loader, install it. 
 Send software reset command 
 Delay 10us 
 Wait 10ms for HF3 to indicate that software reset is complete 
 Timeout is 10us  1000 = 10ms 
 Set DSP format bits for 24 bit mode now that soft reset is done 
 Main loader loop 
 Total Block Size 
 Block Type 
 We're finished 
 Memory Type  P=0,X=1,Y=2 
 Block Code Size 
 We're finished 
 Start Address 
 Code 
 We're done!!! 
 Timeout is 100us  5000 = 500ms 
 Wait for flag 4 - indicates that the DSP loaded OK 
			 Get the serial number via slave mode.
			This is triggered by the SET_COMMPAGE_ADDR command.
			We don't actually use the serial number but we have to
 Show which DSP code loaded 
 DSP OK 
 load_firmware takes care of loading the DSP and any ASIC code. 
 See if the ASIC is present and working - only if the DSP is already loaded 
 ASIC check failed; force the DSP to reload 
 error 
	Mixer functions
 Set the nominal level for an input or output bus (true = -10dBV, false = +4dBu) 
 Wait for the handshake (OK even if ASIC is not loaded) 
 ECHOCARD_HAS__NOMINAL_LEVEL 
 Set the gain for a single physical output channel (dB). 
 Save the new value 
 Set the monitor level from an input bus to an output bus. 
 ECHOCARD_HAS_MONITOR 
 Tell the DSP to read and update output, nominal & monitor levels in comm page. 
 Tell the DSP to read and update input levels in comm page 
 set_meters_on turns the meters on or off.  If meters are turned on, the DSP
 Fill out an the given array using the current values in the comm page.
Meters are written in the comm page by the DSP in this order:
 Output busses
 Input busses
 Output pipes (vmixer cards only)
This function assumes there are no more than 16 inout busses or pipes
 Skip unused meters 
 Gina20Darla20 only. Should be harmless for other cards. 
 Restore output busses 
 ECHOCARD_HAS_VMIXER 
 ECHOCARD_HAS_MONITOR 
 ECHOCARD_HAS_INPUT_GAIN 
 set_input_clock() also restores automute setting 
	Transport functions
 set_audio_format() sets the format of the audio data in host memory for
this pipe.  Note that _MS_ (mono-to-stereo) playback modes are not used by ALSA
 Look for super-interleave (no big-endian and 8 bits) 
 For big-endian data, only 32 bit samples are supported 
 32 bit little-endian mono->mono case 
 Handle the other little-endian formats 
 start_transport starts transport for a set of pipes.
The bits 1 in channel_mask specify what pipes to start. Only the bit of the
first channel must be set, regardless its interleave.
 Keep track of which pipes are transporting 
 Keep track of which pipes are transporting 
 Keep track of which pipes are transporting 
 Stops everything and turns off the DSP. All pipes should be already
 Stops all active pipes (just to be sure) 
 Go to sleep 
 Make load_firmware do a complete reload 
 Put the DSP to sleep 
 Fills the comm page with default values 
 Check if the compiler added extra padding inside the structure 
 Init all the basic stuff 
 Set true until DSP loaded 
 Current DSP code not loaded 
 Init the comm page 
 Set line levels so we don't blast any inputs on startup 
 This function initializes the chip structure with default values, ie. all
  muted and internal clock source. Then it copies the settings to the DSP.
  This MUST be called after the DSP is up and running !
 This is low level part of the interrupt handler.
It returns -1 if the IRQ is not ours, or N>=0 if it is, where N is the number
 Read the DSP status register and see if this DSP generated this interrupt 
 Get and parse midi data if present 
 The count is at index 0 
 Returns how many midi bytes we received 
 Clear the hardware interrupt 
	Functions for opening and closing pipes
 allocate_pipes is used to reserve audio pipes for your exclusive use.
 This driver uses cyclic buffers only 
	 The counter register is where the DSP writes the 32 bit DMA
	position for a pipe.  The DSP is constantly updating this value as
	Functions for managing the scatter-gather list
 SPDX-License-Identifier: GPL-2.0-only
   ALSA driver for Echoaudio soundcards.
   Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>
 Pipe indexes 
 Bus indexes 
 Echo 3G 
   Copyright Echo Digital Audio Corporation (c) 1998 - 2004
   All rights reserved
   www.echoaudio.com
   This file is part of Echo Digital Audio's generic driver library.
   Echo Digital Audio's generic driver library is free software;
   you can redistribute it andor modify it under the terms of
   the GNU General Public License as published by the Free Software Foundation.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston,
   MA  02111-1307, USA.
 Translation from C++ and adaptation for use in ALSA-Driver
 were made by Giuliano Pochini <pochini@shiny.it>
 Map the DSP clock detect bits to the generic driver clock detect bits 
 Layla24 has an ASIC on the PCI card and another ASIC in the external box;
 Give the DSP a few milliseconds to settle down 
 Load the ASIC for the PCI card 
 Now give the new ASIC a little time to set up 
 Do the external one 
 Now give the external ASIC a little time to set up 
 See if it worked 
	 Set up the control register if the load succeeded -
 Only set the clock for internal mode. 
 Save the rate anyhow 
 Get the control register & clear the appropriate bits 
 Professional mode 
		 If this is a non-standard rate, then the driver needs to
 ignored by the DSP ? 
 Mask off the clock select bits 
 Pick the new clock 
 Layla24 doesn't support 96KHz SPDIF 
 Depending on what digital mode you want, Layla24 needs different ASICs
loaded.  This function checks the ASIC needed for the new mode and sees
  Check to see if this is already loaded 
 Load the desired ASIC 
 Set clock to "internal" if it's not compatible with the new mode 
 Switch to 48KHz, internal 
 switch_asic() can sleep 
 Tweak the control register 
 GML_SPDIF_OPTICAL_MODE bit cleared 
 SPDX-License-Identifier: GPL-2.0-only
   ALSA driver for Echoaudio soundcards.
   Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>
 Pipe indexes 
 8 
 0 
 0 
 0 
 Bus indexes 
 2 
 0 
 0 
 0 
 Indigo 
   Copyright Echo Digital Audio Corporation (c) 1998 - 2004
   All rights reserved
   www.echoaudio.com
   This file is part of Echo Digital Audio's generic driver library.
   Echo Digital Audio's generic driver library is free software;
   you can redistribute it andor modify it under the terms of
   the GNU General Public License as published by the Free Software
   Foundation.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston,
   MA  02111-1307, USA.
 Translation from C++ and adaptation for use in ALSA-Driver
 were made by Giuliano Pochini <pochini@shiny.it>
	 Since this card has no ASIC, mark it as loaded so everything
 The Indigo has no ASIC. Just do nothing 
 Set the control register if it has changed 
 ignored by the DSP 
 This function routes the sound from a virtual channel to a real output 
 Tell the DSP to read and update virtual mixer levels in comm page. 
 SPDX-License-Identifier: GPL-2.0-only
   ALSA driver for Echoaudio soundcards.
   Copyright (C) 2009 Giuliano Pochini <pochini@shiny.it>
 Pipe indexes 
 8 
 0 
 2 
 0 
 Bus indexes 
 2 
 0 
 2 
 0 
 Indigo IOx 
   Copyright Echo Digital Audio Corporation (c) 1998 - 2004
   All rights reserved
   www.echoaudio.com
   This file is part of Echo Digital Audio's generic driver library.
   Echo Digital Audio's generic driver library is free software;
   you can redistribute it andor modify it under the terms of
   the GNU General Public License as published by the Free Software
   Foundation.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston,
   MA  02111-1307, USA.
 Translation from C++ and adaptation for use in ALSA-Driver
 were made by Giuliano Pochini <pochini@shiny.it>
	MIDI lowlevel code
 Start and stop Midi input 
 Send a buffer full of MIDI data to the DSP
 HF4 indicates that it is safe to write MIDI output data 
 Run the state machine for MIDI input data
MIDI time code sync isn't supported by this code right now, but you still need
this state machine to parse the incoming MIDI data stream.  Every time the DSP
sees a 0xF1 byte come in, it adds the DSP sample position to the MIDI data
stream. The DSP sample position is represented as a 32 bit unsigned value,
with the high 16 bits first, followed by the low 16 bits. Since these aren't
 This function is called from the IRQ handler and it reads the midi data
 The count is at index 0, followed by actual data 
 Get the MIDI data from the comm page 
 Get the MIDI byte 
		 Parse the incoming MIDI stream. The incoming MIDI data
		consists of MIDI bytes and timestamps for the MIDI time code
		0xF1 bytes. mtc_process_data() is a little state machine that
		parses the stream. If you get MIDI_IN_SKIP_DATA back, then
		this is a timestamp byte, not a MIDI byte, so don't store it
	MIDI interface
	 No interrupts are involved: we have to check at regular intervals
 retry later 
			 Buffer is full. DSP's internal buffer is 64 (128 ?)
 We restart the timer only if there is some data left to send 
		 The timer will expire slightly after the data has been
 825=0.32ms to send a byte 
 <--snd_echo_probe() 
   Copyright Echo Digital Audio Corporation (c) 1998 - 2004
   All rights reserved
   www.echoaudio.com
   This file is part of Echo Digital Audio's generic driver library.
   Echo Digital Audio's generic driver library is free software;
   you can redistribute it andor modify it under the terms of
   the GNU General Public License as published by the Free Software
   Foundation.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston,
   MA  02111-1307, USA.
 Translation from C++ and adaptation for use in ALSA-Driver
 were made by Giuliano Pochini <pochini@shiny.it>
	 Since this card has no ASIC, mark it as loaded so everything
 The IndigoDJ has no ASIC. Just do nothing 
 Set the control register if it has changed 
 ignored by the DSP 
 This function routes the sound from a virtual channel to a real output 
 Tell the DSP to read and update virtual mixer levels in comm page. 
 SPDX-License-Identifier: GPL-2.0-only
   ALSA driver for Echoaudio soundcards.
   Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>
 Pipe indexes 
 8 
 0 
 2 
 0 
 Bus indexes 
 8 
 0 
 2 
 0 
 DSP 56301 Darla20 rev.0 
	 One page (4k) contains 512 instructions. I don't know if the hw
	supports lists longer than this. In this case periods_max=220 is a
   Copyright Echo Digital Audio Corporation (c) 1998 - 2004
   All rights reserved
   www.echoaudio.com
   This file is part of Echo Digital Audio's generic driver library.
   Echo Digital Audio's generic driver library is free software;
   you can redistribute it andor modify it under the terms of
   the GNU General Public License as published by the Free Software
   Foundation.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston,
   MA  02111-1307, USA.
 Translation from C++ and adaptation for use in ALSA-Driver
 were made by Giuliano Pochini <pochini@shiny.it>
	 Load the DSP code and the ASIC on the PCI card and get
 SPDX-License-Identifier: GPL-2.0-only
   ALSA driver for Echoaudio soundcards.
   Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>
 Pipe indexes 
 10 
  2 
  8 
  2 
 Bus indexes 
 10 
  2 
  8 
  2 
 DSP 56301 Layla20 rev.0 
 DSP 56301 Layla20 rev.1 
	 One page (4k) contains 512 instructions. I don't know if the hw
	supports lists longer than this. In this case periods_max=220 is a
   Copyright Echo Digital Audio Corporation (c) 1998 - 2004
   All rights reserved
   www.echoaudio.com
   This file is part of Echo Digital Audio's generic driver library.
   Echo Digital Audio's generic driver library is free software;
   you can redistribute it andor modify it under the terms of
   the GNU General Public License as published by the Free Software
   Foundation.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston,
   MA  02111-1307, USA.
 Translation from C++ and adaptation for use in ALSA-Driver
 were made by Giuliano Pochini <pochini@shiny.it>
	 Since this card has no ASIC, mark it as loaded so everything
 The Darla20 has no external clock sources 
 The Darla20 has no ASIC. Just do nothing 
 magic number - should always be 3 
 Save the new audio state if it changed 
 SPDX-License-Identifier: GPL-2.0-only
   ALSA driver for Echoaudio soundcards.
   Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>
 Pipe indexes 
 8 
 8 
 2 
 8 
 Bus indexes 
 8 
 8 
 2 
 8 
 DSP 56301 Gina24 rev.0 
 DSP 56301 Gina24 rev.1 
 DSP 56361 Gina24 rev.0 
 DSP 56361 Gina24 rev.1 
	 One page (4k) contains 512 instructions. I don't know if the hw
	supports lists longer than this. In this case periods_max=220 is a
	safe limit to make sure the list never exceeds 512 instructions.
This file is part of Echo Digital Audio's generic driver library.
Copyright Echo Digital Audio Corporation (c) 1998 - 2005
All rights reserved
www.echoaudio.com
This library is free software; you can redistribute it andor
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.
You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 Translation from C++ and adaptation for use in ALSA-Driver
 were made by Giuliano Pochini <pochini@shiny.it>
 This function routes the sound from a virtual channel to a real output 
 Tell the DSP to read and update virtual mixer levels in comm page. 
 The IndigoIO has no ASIC. Just do nothing 
   Copyright Echo Digital Audio Corporation (c) 1998 - 2004
   All rights reserved
   www.echoaudio.com
   This file is part of Echo Digital Audio's generic driver library.
   Echo Digital Audio's generic driver library is free software;
   you can redistribute it andor modify it under the terms of
   the GNU General Public License as published by the Free Software
   Foundation.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston,
   MA  02111-1307, USA.
 Translation from C++ and adaptation for use in ALSA-Driver
 were made by Giuliano Pochini <pochini@shiny.it>
 Mona comes in both '301 and '361 flavors 
	 Map the DSP clock detect bits to the generic driver clock
 Mona has an ASIC on the PCI card and another ASIC in the external box; 
 Do the external one 
	 Set up the control register if the load succeeded -
 Depending on what digital mode you want, Mona needs different ASICs
loaded.  This function checks the ASIC needed for the new mode and sees
	 Check the clock detect bits to see if this is
	a single-speed clock or a double-speed clock; load
 Load the desired ASIC 
 Only set the clock for internal mode. 
 Save the rate anyhow 
 Now, check to see if the required ASIC is loaded 
 Load the desired ASIC (load_asic_generic() can sleep) 
 Compute the new control register value 
 Professional mode 
 ignored by the DSP 
 Mask off the clock select bits 
 Set clock to "internal" if it's not compatible with the new mode 
 Switch to 48KHz, internal 
 Clear the current digital mode 
 Tweak the control reg 
 GML_SPDIF_OPTICAL_MODE bit cleared 
		 If the current ASIC is the 96KHz ASIC, switch the ASIC
   Copyright Echo Digital Audio Corporation (c) 1998 - 2004
   All rights reserved
   www.echoaudio.com
   This file is part of Echo Digital Audio's generic driver library.
   Echo Digital Audio's generic driver library is free software;
   you can redistribute it andor modify it under the terms of
   the GNU General Public License as published by the Free Software
   Foundation.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston,
   MA  02111-1307, USA.
 Translation from C++ and adaptation for use in ALSA-Driver
 were made by Giuliano Pochini <pochini@shiny.it>
	 Since this card has no ASIC, mark it as loaded so everything
	 Map the DSP clock detect bits to the generic driver clock
 The Gina20 has no ASIC. Just do nothing 
 magic number - should always be 3 
 Save the new audio state if it changed 
 Reset the audio state to unknown (just in case) 
 Set input bus gain (one unit is 0.5dB !) 
 Tell the DSP to reread the flags from the comm page 
 SPDX-License-Identifier: GPL-2.0-only
   ALSA driver for Echoaudio soundcards.
   Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>
 Pipe indexes 
 6 
 8 
 4 
 8 
 Bus indexes 
 6 
 8 
 4 
 8 
 DSP 56301 Mona rev.0 
 DSP 56301 Mona rev.1 
 DSP 56301 Mona rev.2 
 DSP 56361 Mona rev.0 
 DSP 56361 Mona rev.1 
 DSP 56361 Mona rev.2 
	 One page (4k) contains 512 instructions. I don't know if the hw
	supports lists longer than this. In this case periods_max=220 is a
   Copyright Echo Digital Audio Corporation (c) 1998 - 2004
   All rights reserved
   www.echoaudio.com
   This file is part of Echo Digital Audio's generic driver library.
   Echo Digital Audio's generic driver library is free software;
   you can redistribute it andor modify it under the terms of
   the GNU General Public License as published by the Free Software
   Foundation.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston,
   MA  02111-1307, USA.
 Translation from C++ and adaptation for use in ALSA-Driver
 were made by Giuliano Pochini <pochini@shiny.it>
 These functions are common for Gina24, Layla24 and Mona cards 
 ASIC status check - some cards have one or two ASICs that need to be
loaded.  Once that load is complete, this function is called to see if
the load was successful.
If this load fails, it does not necessarily mean that the hardware is
	 The DSP will return a value to indicate whether or not the
 Most configuration of Gina24, Layla24, or Mona is accomplished by writing
the control register.  write_control_reg sends the new control register
 Handle the digital input auto-mute 
 Write the control register 
 Gina24, Layla24, and Mona support digital input auto-mute.  If the digital
input auto-mute is enabled, the DSP will only enable the digital inputs if
the card is syncing to a valid clock on the ADAT or SPDIF inputs.
If the auto-mute is disabled, the digital inputs are enabled regardless of
	 Re-set the input clock to the current value - indirectly causes
 SPDIF coax  SPDIF optical  ADAT - switch 
 All audio channels must be closed before changing the digital mode 
	 If we successfully changed the digital mode from or to ADAT,
	   then make sure all output, input and monitor levels are
 Set the SPDIF output format 
 Clear the current SPDIF flags 
 Set the new SPDIF flags depending on the mode 
 Professional mode 
 Consumer mode 
 SPDX-License-Identifier: GPL-2.0-only
   ALSA driver for Echoaudio soundcards.
   Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>
 Pipe indexes 
 8 
 8 
 8 
 8 
 Bus indexes 
 8 
 8 
 8 
 8 
 DSP 56361 Layla24 rev.0 
	 One page (4k) contains 512 instructions. I don't know if the hw
	supports lists longer than this. In this case periods_max=220 is a
   Copyright Echo Digital Audio Corporation (c) 1998 - 2004
   All rights reserved
   www.echoaudio.com
   This file is part of Echo Digital Audio's generic driver library.
   Echo Digital Audio's generic driver library is free software;
   you can redistribute it andor modify it under the terms of
   the GNU General Public License as published by the Free Software
   Foundation.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston,
   MA  02111-1307, USA.
 Translation from C++ and adaptation for use in ALSA-Driver
 were made by Giuliano Pochini <pochini@shiny.it>
	 Since this card has no ASIC, mark it as loaded so everything
	 Map the DSP clock detect bits to the generic driver clock
 The Mia has no ASIC. Just do nothing 
 Override the clock setting if this Mia is set to SPDIF clock 
 Set the control register if it has changed 
 ignored by the DSP 
 This function routes the sound from a virtual channel to a real output 
 Tell the DSP to read and update virtual mixer levels in comm page. 
 Tell the DSP to reread the flags from the comm page 
 SPDX-License-Identifier: GPL-2.0-only
   ALSA driver for Echoaudio soundcards.
   Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>
 Pipe indexes 
 8 
 0 
 0 
 0 
 Bus indexes 
 4 
 0 
 0 
 0 
 Indigo DJ
 SPDX-License-Identifier: GPL-2.0-only
   ALSA driver for Echoaudio soundcards.
   Copyright (C) 2009 Giuliano Pochini <pochini@shiny.it>
 Pipe indexes 
 8 
 0 
 0 
 0 
 Bus indexes 
 4 
 0 
 0 
 0 
 Indigo DJx
 SPDX-License-Identifier: GPL-2.0-only
   ALSA driver for Echoaudio soundcards.
   Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>
 Pipe indexes 
 8 
 0 
 2 
 2 
 Bus indexes 
 2 
 2 
 2 
 2 
 DSP 56361 Mia rev.0 
 DSP 56361 Mia rev.1 
	 One page (4k) contains 512 instructions. I don't know if the hw
	supports lists longer than this. In this case periods_max=220 is a
 SPDX-License-Identifier: GPL-2.0-or-later
   The driver for the Cirrus Logic's Sound Fusion CS46XX based soundcards
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  NOTES:
  - sometimes the sound is metallic and sibilant, unloading and 
    reloading the module may solve this.
 Index 0-MAX 
 ID for this card 
 Enable this card 
 CS4280 
 CS4612 
 CS4615 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
                    Abramo Bagnara <abramo@alsa-project.org>
                    Cirrus Logic, Inc.
   Routines for control of Cirrus Logic CS461x chips
   KNOWN BUGS:
     - Sometimes the SPDIF input DSP tasks get's unsynchronized
       and the SPDIF get somewhat "distorcionated", orand left right channel
       are swapped. To get around this problem when it happens, mute and unmute 
       the SPDIF input mixer control.
     - On the Hercules Game Theater XP the amplifier are sometimes turned
       off on inadecuate moments which causes distorcions on sound.
   TODO:
     - Secondary CODEC on some soundcards
     - SPDIF input support for other sample rates then 48khz
     - Posibility to mix the SPDIF output with analog sources.
     - PCM channels for Center and LFE on secondary codec
   NOTE: with CONFIG_SND_CS46XX_NEW_DSP unset uses old DSP image (which
         is default configuration), no SPDIF, no secondary codec, no
         multi channel PCM.  But known to work.
   FINALLY: A credit to the developers Tom and Jordan 
            at Cirrus for have helping me out with the DSP, however we
            still don't have sufficient documentation and technical
            references to be able to implement all fancy feutures
            supported by the cs46xx DSP's. 
            Benny <benny@hostmobility.com>
	
	   1. Write ACCAD = Command Address Register = 46Ch for AC97 register address
	   2. Write ACCDA = Command Data Register = 470h    for data to write to AC97 
	   3. Write ACCTL = Control Register = 460h for initiating the write7---55
	   4. Read ACCTL = 460h, DCV should be reset by now and 460h = 17h
	   5. if DCV not cleared, break and return error
	   6. Read ACSTS = Status Register = 464h, check VSTS bit
	
	   Setup the AC97 control registers on the CS461x to send the
	   appropriate command to the AC97 to perform the read.
	   ACCAD = Command Address Register = 46Ch
	   ACCDA = Command Data Register = 470h
	   ACCTL = Control Register = 460h
	   set DCV - will clear when process completed
	   set CRW - Read command
	   set VFRM - valid frame enabled
	   set ESYN - ASYNC generation enabled
	   set RSTN - ARST# inactive, AC97 codec not reset
 clear ACCTL_DCV  ACCTL_CRW | 
	
	   Wait for the read to occur.
		
		   First, we want to wait for a short time.
		
		   Now, check to see if the read has completed.
		   ACCTL = 460h, DCV should be reset by now and 460h = 17h
	
	   Wait for the valid status bit to go active.
		
		   Read the AC97 status register.
		   ACSTS = Status Register = 464h
		   VSTS - Valid Status
	
	   Read the data returned from the AC97 register.
	   ACSDA = Status Data Register = 474h
snd_cs46xx_peekBA0(chip, BA0_ACCAD);
	
	   1. Write ACCAD = Command Address Register = 46Ch for AC97 register address
	   2. Write ACCDA = Command Data Register = 470h    for data to write to AC97
	   3. Write ACCTL = Control Register = 460h for initiating the write
	   4. Read ACCTL = 460h, DCV should be reset by now and 460h = 07h
	   5. if DCV not cleared, break and return error
	
	   Setup the AC97 control registers on the CS461x to send the
	   appropriate command to the AC97 to perform the read.
	   ACCAD = Command Address Register = 46Ch
	   ACCDA = Command Data Register = 470h
	   ACCTL = Control Register = 460h
	   set DCV - will clear when process completed
	   reset CRW - Write command
	   set VFRM - valid frame enabled
	   set ESYN - ASYNC generation enabled
	   set RSTN - ARST# inactive, AC97 codec not reset
 clear ACCTL_DCV  ACCTL_VFRM |
		
		   First, we want to wait for a short time.
		
		   Now, check to see if the write has completed.
		   ACCTL = 460h, DCV should be reset by now and 460h = 07h
   Chip initialization
 writel already converts 32-bit value to right endianess 
 firmware binary format:
  le32 nsymbols;
  struct {
 	le32 address;
 	char symbol_name[DSP_MAX_SYMBOL_NAME];
 	le32 symbol_type;
  } symbols[nsymbols];
  le32 nsegments;
  struct {
 	le32 segment_type;
 	le32 offset;
 	le32 size;
 	le32 data[size];
  } segments[nsegments];
 writel already converts 32-bit value to right endianess 
 old DSP image 
 sanity check 
 CONFIG_SND_CS46XX_NEW_DSP 
   Chip reset
	
	   Write the reset bit of the SP control register.
	
	   Write the control register.
	
	   Clear the trap registers.
	
	   Set the frame timer to reflect the number of cycles per frame.
	
	  Make sure the previous FIFO write operation has completed.
	
	   See if the devices are powered down.  If so, we must power them up first
	   or they will not respond.
	
	   We want to clear out the serial port FIFOs so we don't end up playing
	   whatever random garbage happens to be in them.  We fill the sample FIFOS
	   with zero (silence).
	
	   Fill all 256 sample FIFO locations.
		
		   Make sure the previous FIFO write operation has completed.
		
		   Write the serial port FIFO index.
		
		   Tell the serial port to load the new value into the FIFO location.
	
	   Now, if we powered up the devices, then power them back down again.
	   This is kinda ugly, but should never happen.
	
	   Set the frame timer to reflect the number of cycles per frame.
	
	   Turn on the run, run at frame, and DMA enable bits in the local copy of
	   the SP control register.
	
	   Wait until the run at frame bit resets itself in the SP control
	   register.
	
	   Turn off the run, run at frame, and DMA enable bits in the local copy of
	   the SP control register.
   Sample rate routines
	
	   Compute the values used to drive the actual sample rate conversion.
	   The following formulas are being computed, using inline assembly
	   since we need to use 64 bit arithmetic to compute the values:
	 
	   phiIncr = floor((Fs,in  2^26)  Fs,out)
	   correctionPerGOF = floor((Fs,in  2^26 - Fs,out  phiIncr) 
                                            GOF_PER_SEC)
           ulCorrectionPerSec = Fs,in  2^26 - Fs,out  phiIncr -M
                                GOF_PER_SEC  correctionPerGOF
	 
	   i.e.
	 
	   phiIncr:other = dividend:remainder((Fs,in  2^26)  Fs,out)
	   correctionPerGOF:correctionPerSec =
	       dividend:remainder(ulOther  GOF_PER_SEC)
	
	   Fill in the SampleRateConverter control block.
	
	   We can only decimate by up to a factor of 19th the hardware rate.
	   Correct the value if an attempt is made to stray outside that limit.
	
	   We can not capture at a rate greater than the Input Rate (48000).
	   Return an error if an attempt is made to stray outside that limit.
	
	   Compute the values used to drive the actual sample rate conversion.
	   The following formulas are being computed, using inline assembly
	   since we need to use 64 bit arithmetic to compute the values:
	 
	      coeffIncr = -floor((Fs,out  2^23)  Fs,in)
	      phiIncr = floor((Fs,in  2^26)  Fs,out)
	      correctionPerGOF = floor((Fs,in  2^26 - Fs,out  phiIncr) 
	                                 GOF_PER_SEC)
	      correctionPerSec = Fs,in  2^26 - Fs,out  phiIncr -
	                           GOF_PER_SEC  correctionPerGOF
	      initialDelay = ceil((24  Fs,in)  Fs,out)
	 
	  i.e.
	 
	      coeffIncr = neg(dividend((Fs,out  2^23)  Fs,in))
	      phiIncr:ulOther = dividend:remainder((Fs,in  2^26)  Fs,out)
	      correctionPerGOF:correctionPerSec =
	  	    dividend:remainder(ulOther  GOF_PER_SEC)
	      initialDelay = dividend(((24  Fs,in) + Fs,out - 1)  Fs,out)
	
	   Fill in the VariDecimate control block.
	
	   Figure out the frame group length for the write back task.  Basically,
	   this is just the factors of 24000 (2^635^3) that are not present in
	   the output sample rate.
	
	  Fill in the WriteBack control block.
   PCM part
struct snd_pcm_runtime runtime = substream->runtime;
 magic value to unmute PCM stream  playback volume 
 magic mute channel 
 If PCMReaderSCB and SrcTaskSCB not created yet ... 
 if sample rate is changed 
struct snd_cs46xx chip = snd_pcm_substream_chip(substream);
	 if play_back open fails, then this function
 old dsp 
 if to convert from stereo to mono 
 if to convert from 8 bit to 16 bit 
 if to convert to unsigned 
 Never convert byte order when sample stream is 8 bit 
 convert from big endian to little endian 
 playback transaction count register 
 playback format && interrupt enable 
	
	   Read the Interrupt Status Register to clear the interrupt
 old dsp 
	
	   EOI to the PCI part....reenables interrupts
|
SNDRV_PCM_INFO_RESUME |
|
SNDRV_PCM_INFO_RESUME |
 HACK 
 when playback_open fails, then cpcm can be NULL 
 global setup 
 global setup 
 global setup 
 global setup 
   Mixer routines
 restore volume 
 should never happen ... 
 	Game Theatre XP card - EGPIO[0] is used to select SPDIF input optical or coaxial.
 optical is default 
 enable EGPIO0 output 
 open-drain on output 
 coaxial 
 disable 
 disable 
	 checking diff from the EGPIO direction register 
 left and right validity bit 
 left and right validity bit 
 CONFIG_SND_CS46XX_NEW_DSP 
 Input IEC958 volume does not work for the moment. (Benny) 
 set primary cs4294 codec into Extended Audio Mode 
 Only available on the Hercules Game Theater XP soundcard 
 reset to defaults 
 set the desired CODEC mode 
 should never happen ... 
 it's necessary to wait awhile until registers are accessible after RESET 
 because the PCM or MASTER volume registers can be modified, 
 the REC_GAIN register is used for tests 
 use preliminary reads to settle the communication 
 modem? 
 test if we can write to the record gain volume register 
 detect primary codec 
 try detect a secondary codec 
 CONFIG_SND_CS46XX_NEW_DSP 
 add cs4630 mixer controls 
 get EAPD mixer switch (for voyetra hack) 
 CS4294 and CS4298 
 do soundcard specific mixer setup 
 turn on amplifier 
   RawMIDI interface
 fill UART FIFO buffer at first, and turn Tx interrupts only if necessary 
  gameport interface
outb(gameport->io, 0xFF);
inb(gameport->io);
 ?
 CONFIG_GAMEPORT 
   proc interface
 !CONFIG_SND_PROC_FS 
  stop the hw
 playback interrupt disable 
 capture interrupt disable 
	
           Stop playback DMA.
	
           Stop capture DMA.
	
           Reset the processor.
	
	   Power down the PLL.
	
	   Turn off the Processor by turning off the software clock enable flag in 
	   the clock control register.
 force to off 
   initialize chip
	 
	   First, blast the clock control register to zero so that the PLL starts
           out in a known state, and blast the master serial port control register
           to zero so that the serial ports also start out in a known state.
	
	   If we are in AC97 mode, then we must set the part to a host controlled
           AC-link.  Otherwise, we won't be able to bring up the link.
 2.00 dual codecs 
 snd_cs46xx_pokeBA0(chip, BA0_SERACC, SERACC_HSP | SERACC_CHIP_TYPE_2_0);  
 1.03 codec 
           Drive the ARST# pin low for a minimum of 1uS (as defined in the AC97
           spec) and then drive it high.  This is done for non AC97 modes since
           there might be logic external to the CS461x that uses the ARST# line
           for a reset.
	
	   The first thing we do here is to enable sync generation.  As soon
	   as we start receiving bit clock, we'll start producing the SYNC
	   signal.
	
	   Now wait for a short while to allow the AC97 part to start
	   generating bit clock (so we don't try to start the PLL without an
	   input clock).
	
	   Set the serial port timing configuration, so that
	   the clock control circuit gets its clock from the correct place.
	
	   Write the selected clock control setup to the hardware.  Do not turn on
	   SWCE yet (if requested), so that the devices clocked by the output of
	   PLL are not clocked until the PLL is stable.
	
	   Power up the PLL.
	
           Wait until the PLL has stabilized.
	
	   Turn on clocking of the core so that we can setup the serial ports.
	
	  Enable FIFO  Host Bypass
	
	   Fill the serial port FIFOs with silence.
	
	   Set the serial port FIFO pointer to the first sample in the FIFO.
 snd_cs46xx_pokeBA0(chip, BA0_SERBSP, 0); 
	
	   Write the serial port configuration to the part.  The master
	   enable bit is not set until all other values have been written.
	
	  Wait for the codec ready signal from the AC97 codec.
		
		   Read the AC97 status register to see if we've seen a CODEC READY
		   signal from the AC97 codec.
 First, we want to wait for a short time. 
		
		   Make sure CODEC is READY.
	
	   Assert the vaid frame signal so that we can start sending commands
	   to the AC97 codec.
	
	   Wait until we've sampled input slots 3 and 4 as valid, meaning that
	   the codec is pumping ADC data across the AC-link.
		
		   Read the input slot valid register and see if input slots 3 and
		   4 are valid yet.
	 This may happen on a cold boot with a Terratec SiXPack 5.1.
	   Reloading the driver may help, if there's other soundcards 
	
	   Now, assert valid frame and the slot 3 and 4 valid bits.  This will
	   commense the transfer of digital audio data to the AC97 codec.
	
	   Power down the DAC and ADC.  We will power them up (if) when we need
	   them.
 snd_cs46xx_pokeBA0(chip, BA0_AC97_POWERDOWN, 0x300); 
	
	   Turn off the Processor by turning off the software clock enable flag in 
	   the clock control register.
 tmp = snd_cs46xx_peekBA0(chip, BA0_CLKCR1) & ~CLKCR1_SWCE; 
 snd_cs46xx_pokeBA0(chip, BA0_CLKCR1, tmp); 
   start and load DSP 
 playback interrupt enable 
 capture interrupt enable 
	
	   Reset the processor.
	
	   Download the image to the processor.
 old image 
	
           Stop playback DMA.
	
           Stop capture DMA.
 set the attenuation to 0dB  
 	AMP control - null AMP
	
	   See if the devices are powered down.  If so, we must power them up first
	   or they will not respond.
	
	  Clear PRA.  The Bonzo chip will be used for GPIO not for modem
	  stuff.
	
	  Set GPIO pin's 7 and 8 so that they are configured for output.
	
	  Set GPIO pin's 7 and 8 so that they are compatible with CMOS logic.
	
	  Fill slots 12 with the correct value for the GPIO pins. 
		
		  Initialize the fifo so that bits 7 and 8 are on.
		 
		  Remember that the GPIO pins in bonzo are shifted by 4 bits to
		  the left.  0x1800 corresponds to bits 7 and 8.
		
		  Wait for command to complete
		
		  Write the serial port FIFO index.
		
		  Tell the serial port to load the new value into the FIFO location.
 wait for last command to complete 
	
	   Now, if we powered up the devices, then power them back down again.
	   This is kinda ugly, but should never happen.
 	Crystal EAPD mode
	 Manage the EAPD bit on the Crystal 4297 
 Turn the EAPD amp on 
 Turn the EAPD amp off 
 default: AMP off, and SPDIF input optical 
 	Game Theatre XP card - EGPIO[2] is used to enable the external amp.
 enable EGPIO2 output 
 open-drain on output 
 disable 
 disable 
 Enable SPDIF out 
 set EGPIO to default 
 	Untested
 Switch the GPIO pins 7 and 8 to open drain 
 Now wake the AMP (this might be backwards) 
 	Handle the CLKRUN on a thinkpad. We must disable CLKRUN support
 	whenever we need to beat on the chip.
 	The original idea and code for this hack comes from David Kaiser at
 	Linuxcare. Perhaps one day Crystal will document their chips well
 	enough to make them useful.
 Read ACPI port 	
 Flip CLKRUN off while running 
  detect intel piix4
 Not a thinkpad thats for sure 
 Find the control port 		
  Card subid table
 nothing special 
 Hercules Game Theatre XP 
 Guillemot Corporation 
 Herculess Fortissimo 
 Teratec 
 Not sure if the 570 needs the clkrun hack 
 terminator 
  APM support
BA0_ASER_FADDR,
 chip->ac97_powerdown = snd_cs46xx_codec_read(chip, AC97_POWER_CONTROL);
 chip->ac97_general_purpose = snd_cs46xx_codec_read(chip, BA0_AC97_GENERAL_PURPOSE);
 save some registers 
 turn off amp 
 disable CLKRUN 
 restore the status 
 force to on 
 restore some registers 
	
           Stop capture DMA.
 reset playbackcapture 
 turn amp on 
 disable CLKRUN 
 CONFIG_PM_SLEEP 
 enable PCI device 
 set up amp and clkrun hack 
 enable CLKRUN 
 disable CLKRUN 
 SPDX-License-Identifier: GPL-2.0-or-later
  2002-07 Benny Sjostrand benny@hostmobility.com
 unlink parent SCB 
 last and only node in parent sublist 
 first node in parent sublist 
 update next node parent ptr. 
 update next node parent ptr. 
 update parent first entry in DSP RAM 
 then update entry in DSP RAM 
 check integrety 
	 can't remove a SCB with childs before 
 !!!! THIS IS A PIECE OF SHIT MADE BY ME !!! 
 register to proc 
 CONFIG_SND_PROC_FS 
 fill the data that will be wroten to DSP 
 update parent SCB 
 link to  parent SCB 
 update entry in DSP RAM 
 extraSampleAccum:TMreserved 
 codecFIFOptr:codecFIFOsyncd 
 fracSampAccumQm1:TMfrmsLeftInGroup 
 fracSampCorrectionQm1:TMfrmGroupLength 
 nSampPerFrmQ15 
 COstrmRsConfig 
 COstrmBufPtr 
 leftChanBaseIOaddr:rightChanIOdisp 
 (!AC97!) COexpVolChangeRate:COscaleShiftCount 
 COreserved - need child scb to work with rom code 
 cs4620 
 strmRsConfig 
 strmBufPtr; defined as a dword ptr, used as a byte ptr 
		channel_disp,fifo_addr,            (!AC97!) leftChanBaseINaddr=AC97primary 
		0x0000,0x0000,                     (!AC97!) ????:scaleShiftCount; no shift needed 
 ??clw cwcgame.scb has 0 
		
		  Play DMA Task xfers data from host buffer to SP buffer
		  initruntime variables:
		  PlayAC: Play Audio Data Conversion - SCB loc: 2nd dword, mask: 0x0000F000L
		  DATA_FMT_16BIT_ST_LTLEND(0x00000000L)   from 16-bit stereo, little-endian
		  DATA_FMT_8_BIT_ST_SIGNED(0x00001000L)   from 8-bit stereo, signed
		  DATA_FMT_16BIT_MN_LTLEND(0x00002000L)   from 16-bit mono, little-endian
		  DATA_FMT_8_BIT_MN_SIGNED(0x00003000L)   from 8-bit mono, signed
		  DATA_FMT_16BIT_ST_BIGEND(0x00004000L)   from 16-bit stereo, big-endian
		  DATA_FMT_16BIT_MN_BIGEND(0x00006000L)   from 16-bit mono, big-endian
		  DATA_FMT_8_BIT_ST_UNSIGNED(0x00009000L) from 8-bit stereo, unsigned
		  DATA_FMT_8_BIT_MN_UNSIGNED(0x0000b000L) from 8-bit mono, unsigned
		  ? Other combinations possible from:
		  DMA_RQ_C2_AUDIO_CONVERT_MASK    0x0000F000L
		  DMA_RQ_C2_AC_NONE               0x00000000L
		  DMA_RQ_C2_AC_8_TO_16_BIT        0x00001000L
		  DMA_RQ_C2_AC_MONO_TO_STEREO     0x00002000L
		  DMA_RQ_C2_AC_ENDIAN_CONVERT     0x00004000L
		  DMA_RQ_C2_AC_SIGNED_CONVERT     0x00008000L
		  HostBuffAddr: Host Buffer Physical Byte Address - SCB loc:3rd dword, Mask: 0xFFFFFFFFL
		  aligned to dword boundary
 Basic (non scattergather) DMA requestor (4 ints) 
 source buffer is on the host 
 source buffer is 1024 dwords (4096 bytes) 
 dest buffer(PCMreaderBuf) is 32 dwords
 ?? 
 ?? 
 DwordCount-1: picked 16 for DwordCount because Jim 
        Barnette said that is what we should use since 
        we are not running in optimized mode? 
 set play interrupt (bit0) in HISR when source 
   buffer (on host) crosses half-way point 
 Play DMA channel arbitrarily set to 0 
 HostBuffAddr (source) 
 destination buffer is in SP Sample Memory 
 SP Buffer Address (destination) 
 Scattergather DMA requestor extension   (5 ints) 
 Sublist pointer & next stream control block (SCB) link. 
 Pointer to this tasks parameter block & stream function pointer 
 rsConfig register for stream buffer (rsDMA reg. is loaded from basicReq.daw 
   for incoming streams, or basicReq.saw, for outgoing streams) 
 enable DMA 
 MAX_DMA_SIZE picked to be 19 since SPUD  
  uses it for some reason 
 stream number = SCBaddr16 
 dest buffer(PCMreaderBuf) is 32 dwords (256 bytes) 
 Stream sample pointer & MAC-unit mode for this stream 
 Fractional increment per output sample in the input sample buffer 
			 Standard stereo volume control
	
	   Compute the values used to drive the actual sample rate conversion.
	   The following formulas are being computed, using inline assembly
	   since we need to use 64 bit arithmetic to compute the values:
	 
	   phiIncr = floor((Fs,in  2^26)  Fs,out)
	   correctionPerGOF = floor((Fs,in  2^26 - Fs,out  phiIncr) 
	                                    GOF_PER_SEC)
	   ulCorrectionPerSec = Fs,in  2^26 - Fs,out  phiIncr -M
	                        GOF_PER_SEC  correctionPerGOF
	 
	   i.e.
	 
	   phiIncr:other = dividend:remainder((Fs,in  2^26)  Fs,out)
	   correctionPerGOF:correctionPerSec =
	       dividend:remainder(ulOther  GOF_PER_SEC)
 next_scb, sub_list_ptr 
 entry, this_spb 
 clear buffers 
			 wont work with any other rate than
 not used 
 not used 
 0  { 0,
 1    0,
 2   mix_buffer_addr,
 3   0
    },
 4   0,
 5   0,
 6   0,
 7   0,
 8   0x00000080
 9  0,0,
 A  0,0,
 B  RSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_32,
 C  (mix_buffer_addr  + (16  4)) << 0x10, 
 D  0,
 E  0x8000,0x8000,
 F  0x8000,0x8000
 Basic (non scattergather) DMA requestor (4 ints) 
 0xD  0,input_scb->address,
 0xE    0x8000,0x8000,
 0xF 	  0x8000,0x8000
  Prototype sample buffer size of 256 dwords 
 Min Delta 7 dwords == 28 bytes 
 : Max delta 25 dwords == 100 bytes 
 Point to HFG task SCB 
 Initialize current Delta and Consumer ptr adjustment count 
 Initialize accumulated Phi to 0 
 Const 13 
 Define the unused elements 
 Stereo, 256 dword 
		(asynch_buffer_address) << 0x10,   This should be automagically synchronized
		 There is no correct initial value, it will depend upon the detected
 Phi increment for approx 32k operation 
 Volume controls are unused at this time 
  Prototype sample buffer size of 128 dwords 
 Min Delta 7 dwords == 28 bytes 
 : Max delta 25 dwords == 100 bytes 
 Point to HFG task SCB 
 Initialize current Delta and Consumer ptr adjustment count 
 Define the unused elements 
 Stereo, 128 dword 
		( (asynch_buffer_address + (16  4))  << 0x10),    This should be automagically 
		 There is no correct initial value, it will depend upon the detected
 Set IEC958 input volume 
 not used 
  not used.  Zero 
 not used.  Zero 
 not used 
   SPIOWAddress2:SPIOWAddress1; 
   SPIOWData1; 
   SPIOWData2; 
   SPIOWAddress4:SPIOWAddress3; 
   SPIOWData3; 
   SPIOWData4; 
   SPIOWDataPtr:Unused1; 
   Unused2[2]; 
   SPIOWChildPtr:SPIOWSiblingPtr; 
   SPIOWThisPtr:SPIOWEntryPoint; 
   Unused3[5];  
 0  0, 
 1  0, 
 2  snoop_buffer_address << 0x10,
 3  0,snoop_scb->address,
 4  0, 
 5  0, 
 6  0, 
 7  0, 
 8  0, 
 9  0,0, 
 A  0,0, 
 B  RSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_64,
 C  snoop_buffer_address  << 0x10,
 D  0,
 E  { 0x8000,0x8000,
 F    0xffff,0xffff
 1 
 2 
 3 
 4 
 5 
 6 
 7 
 8 
 9 
 10 
 11 
 12 
 13 
 14 
 15 
 16 
 17 
 18 
 19 
 20 
 21 
 22 
 23 
 24 
 25 
 26 
 27 
 28 
 29 
 30 
 31 
 32 
 struct dsp_scb_descriptor  pcm_parent_scb; 
 TODO 
		 if sample rate is set to 48khz we pass
		   the Sample Rate Converted (which could
 Hack to bypass creating a new SRC 
 default sample rate is 44100 
 search for a already created SRC SCB with the same sample rate 
		 virtual channel reserved 
 find a free slot 
 we need to create a new SRC SCB 
 0x400 - 0x600 source SCBs 
 cs46xx_dsp_set_src_sample_rate(chip,src_scb,sample_rate); 
 0x200 - 400 PCMreader SCBs 
 virtual channel 0-31 
 pcm hw addr 
 parent SCB ptr 
 insert point  
 update SCB entry in DSP RAM 
 update parent SCB entry 
 mute SCB 
 update entry in DSP RAM 
 dont touch anything if SPDIF is open 
		 when cs46xx_iec958_post_close(...) is called it
		   will call this function if necessary depending on
 reset output snooper sample buffer pointer 
 The asynch. transfer task 
 monitor state 
 dont touch anything if SPDIF is open 
 check integrety 
 clear buffer to prevent any undesired noise 
 monitor state 
 remove AsynchFGTxSCB and PCMSerialInput_II 
 save state 
 if not enabled already 
 Create the asynch. transfer task  for playback 
 set spdif channel status value for streaming 
 restore settings 
 deallocate stuff 
 clear buffer to prevent any undesired noise 
 restore state 
 SPDX-License-Identifier: GPL-2.0-or-later
  2002-07 Benny Sjostrand benny@hostmobility.com
 check for wide type instruction 
 need to reallocate instruction 
 wide_opcodes[j] == wide_op 
 for 
 mod_type == 0 ... 
 ins->code.offset > 0 
				module->symbol_table.symbols[i].symbol_name); 
#endif
		}
	}
	return 0;
}
static struct dsp_symbol_entry 
add_symbol (struct snd_cs46xx  chip, char  symbol_name, u32 address, int type)
{
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	struct dsp_symbol_entry  symbol = NULL;
	int index;
	if (ins->symbol_table.nsymbols == (DSP_MAX_SYMBOLS - 1)) {
		dev_err(chip->card->dev, "dsp_spos: symbol table is full\n");
		return NULL;
	}
	if (cs46xx_dsp_lookup_symbol(chip,
				     symbol_name,
				     type) != NULL) {
		dev_err(chip->card->dev,
			"dsp_spos: symbol <%s> duplicated\n", symbol_name);
		return NULL;
	}
	index = find_free_symbol_index (ins);
	strcpy (ins->symbol_table.symbols[index].symbol_name, symbol_name);
	ins->symbol_table.symbols[index].address = address;
	ins->symbol_table.symbols[index].symbol_type = type;
	ins->symbol_table.symbols[index].module = NULL;
	ins->symbol_table.symbols[index].deleted = 0;
	symbol = (ins->symbol_table.symbols + index);
	if (index > ins->symbol_table.highest_frag_index) 
		ins->symbol_table.highest_frag_index = index;
	if (index == ins->symbol_table.nsymbols)
		ins->symbol_table.nsymbols++;  no frag. in list 
	return symbol;
}
struct dsp_spos_instance cs46xx_dsp_spos_create (struct snd_cs46xx  chip)
{
	struct dsp_spos_instance  ins = kzalloc(sizeof(struct dsp_spos_instance), GFP_KERNEL);
	if (ins == NULL)
		return NULL;
	 better to use vmalloc for this big table 
	ins->symbol_table.symbols =
		vmalloc(array_size(DSP_MAX_SYMBOLS,
				   sizeof(struct dsp_symbol_entry)));
	ins->code.data = kmalloc(DSP_CODE_BYTE_SIZE, GFP_KERNEL);
	ins->modules = kmalloc_array(DSP_MAX_MODULES,
				     sizeof(struct dsp_module_desc),
				     GFP_KERNEL);
	if (!ins->symbol_table.symbols || !ins->code.data || !ins->modules) {
		cs46xx_dsp_spos_destroy(chip);
		goto error;
	}
	ins->symbol_table.nsymbols = 0;
	ins->symbol_table.highest_frag_index = 0;
	ins->code.offset = 0;
	ins->code.size = 0;
	ins->nscb = 0;
	ins->ntask = 0;
	ins->nmodules = 0;
 default SPDIF input sample rate
	   to 48000 khz 
	ins->spdif_in_sample_rate = 48000;
	 maximize volume 
	ins->dac_volume_right = 0x8000;
	ins->dac_volume_left = 0x8000;
	ins->spdif_input_volume_right = 0x8000;
	ins->spdif_input_volume_left = 0x8000;
 set left and right validity bits and
	   default channel status 
	ins->spdif_csuv_default =
		ins->spdif_csuv_stream =
	  byte 0   ((unsigned int)_wrap_all_bits(  (SNDRV_PCM_DEFAULT_CON_SPDIF        & 0xff)) << 24) |
	  byte 1   ((unsigned int)_wrap_all_bits( ((SNDRV_PCM_DEFAULT_CON_SPDIF >> 8) & 0xff)) << 16) |
	  byte 3    (unsigned int)_wrap_all_bits(  (SNDRV_PCM_DEFAULT_CON_SPDIF >> 24) & 0xff) |
	  left and right validity bits  (1 << 13) | (1 << 12);
	return ins;
error:
	kfree(ins->modules);
	kfree(ins->code.data);
	vfree(ins->symbol_table.symbols);
	kfree(ins);
	return NULL;
}
void  cs46xx_dsp_spos_destroy (struct snd_cs46xx  chip)
{
	int i;
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	if (snd_BUG_ON(!ins))
		return;
	mutex_lock(&chip->spos_mutex);
	for (i = 0; i < ins->nscb; ++i) {
		if (ins->scbs[i].deleted) continue;
		cs46xx_dsp_proc_free_scb_desc ( (ins->scbs + i) );
#ifdef CONFIG_PM_SLEEP
		kfree(ins->scbs[i].data);
#endif
	}
	kfree(ins->code.data);
	vfree(ins->symbol_table.symbols);
	kfree(ins->modules);
	kfree(ins);
	mutex_unlock(&chip->spos_mutex);
}
static int dsp_load_parameter(struct snd_cs46xx chip,
			      struct dsp_segment_desc parameter)
{
	u32 doffset, dsize;
	if (!parameter) {
		dev_dbg(chip->card->dev,
			"dsp_spos: module got no parameter segment\n");
		return 0;
	}
	doffset = (parameter->offset  4 + DSP_PARAMETER_BYTE_OFFSET);
	dsize   = parameter->size  4;
	dev_dbg(chip->card->dev,
		"dsp_spos: downloading parameter data to chip (%08x-%08x)\n",
		    doffset,doffset + dsize);
	if (snd_cs46xx_download (chip, parameter->data, doffset, dsize)) {
		dev_err(chip->card->dev,
			"dsp_spos: failed to download parameter data to DSP\n");
		return -EINVAL;
	}
	return 0;
}
static int dsp_load_sample(struct snd_cs46xx chip,
			   struct dsp_segment_desc sample)
{
	u32 doffset, dsize;
	if (!sample) {
		dev_dbg(chip->card->dev,
			"dsp_spos: module got no sample segment\n");
		return 0;
	}
	doffset = (sample->offset  4  + DSP_SAMPLE_BYTE_OFFSET);
	dsize   =  sample->size  4;
	dev_dbg(chip->card->dev,
		"dsp_spos: downloading sample data to chip (%08x-%08x)\n",
		    doffset,doffset + dsize);
	if (snd_cs46xx_download (chip,sample->data,doffset,dsize)) {
		dev_err(chip->card->dev,
			"dsp_spos: failed to sample data to DSP\n");
		return -EINVAL;
	}
	return 0;
}
int cs46xx_dsp_load_module (struct snd_cs46xx  chip, struct dsp_module_desc  module)
{
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	struct dsp_segment_desc  code = get_segment_desc (module,SEGTYPE_SP_PROGRAM);
	u32 doffset, dsize;
	int err;
	if (ins->nmodules == DSP_MAX_MODULES - 1) {
		dev_err(chip->card->dev,
			"dsp_spos: to many modules loaded into DSP\n");
		return -ENOMEM;
	}
	dev_dbg(chip->card->dev,
		"dsp_spos: loading module %s into DSP\n", module->module_name);
	if (ins->nmodules == 0) {
		dev_dbg(chip->card->dev, "dsp_spos: clearing parameter area\n");
		snd_cs46xx_clear_BA1(chip, DSP_PARAMETER_BYTE_OFFSET, DSP_PARAMETER_BYTE_SIZE);
	}
	err = dsp_load_parameter(chip, get_segment_desc(module,
							SEGTYPE_SP_PARAMETER));
	if (err < 0)
		return err;
	if (ins->nmodules == 0) {
		dev_dbg(chip->card->dev, "dsp_spos: clearing sample area\n");
		snd_cs46xx_clear_BA1(chip, DSP_SAMPLE_BYTE_OFFSET, DSP_SAMPLE_BYTE_SIZE);
	}
	err = dsp_load_sample(chip, get_segment_desc(module,
						     SEGTYPE_SP_SAMPLE));
	if (err < 0)
		return err;
	if (ins->nmodules == 0) {
		dev_dbg(chip->card->dev, "dsp_spos: clearing code area\n");
		snd_cs46xx_clear_BA1(chip, DSP_CODE_BYTE_OFFSET, DSP_CODE_BYTE_SIZE);
	}
	if (code == NULL) {
		dev_dbg(chip->card->dev,
			"dsp_spos: module got no code segment\n");
	} else {
		if (ins->code.offset + code->size > DSP_CODE_BYTE_SIZE) {
			dev_err(chip->card->dev,
				"dsp_spos: no space available in DSP\n");
			return -ENOMEM;
		}
		module->load_address = ins->code.offset;
		module->overlay_begin_address = 0x000;
 if module has a code segment it must have
		   symbol table 
		if (snd_BUG_ON(!module->symbol_table.symbols))
			return -ENOMEM;
		if (add_symbols(chip,module)) {
			dev_err(chip->card->dev,
				"dsp_spos: failed to load symbol table\n");
			return -ENOMEM;
		}
		doffset = (code->offset  4 + ins->code.offset  4 + DSP_CODE_BYTE_OFFSET);
		dsize   = code->size  4;
		dev_dbg(chip->card->dev,
			"dsp_spos: downloading code to chip (%08x-%08x)\n",
			    doffset,doffset + dsize);   
		module->nfixups = shadow_and_reallocate_code(chip,code->data,code->size,module->overlay_begin_address);
		if (snd_cs46xx_download (chip,(ins->code.data + ins->code.offset),doffset,dsize)) {
			dev_err(chip->card->dev,
				"dsp_spos: failed to download code to DSP\n");
			return -EINVAL;
		}
		ins->code.offset += code->size;
	}
 NOTE: module segments and symbol table must be
	   not generated by the ospparser 
	ins->modules[ins->nmodules] = module;
	ins->nmodules++;
	return 0;
}
struct dsp_symbol_entry 
cs46xx_dsp_lookup_symbol (struct snd_cs46xx  chip, char  symbol_name, int symbol_type)
{
	int i;
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	for ( i = 0; i < ins->symbol_table.nsymbols; ++i ) {
		if (ins->symbol_table.symbols[i].deleted)
			continue;
		if (!strcmp(ins->symbol_table.symbols[i].symbol_name,symbol_name) &&
		    ins->symbol_table.symbols[i].symbol_type == symbol_type) {
			return (ins->symbol_table.symbols + i);
		}
	}
#if 0
	dev_err(chip->card->dev, "dsp_spos: symbol <%s> type %02x not found\n",
		symbol_name,symbol_type);
#endif
	return NULL;
}
#ifdef CONFIG_SND_PROC_FS
static struct dsp_symbol_entry 
cs46xx_dsp_lookup_symbol_addr (struct snd_cs46xx  chip, u32 address, int symbol_type)
{
	int i;
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	for ( i = 0; i < ins->symbol_table.nsymbols; ++i ) {
		if (ins->symbol_table.symbols[i].deleted)
			continue;
		if (ins->symbol_table.symbols[i].address == address &&
		    ins->symbol_table.symbols[i].symbol_type == symbol_type) {
			return (ins->symbol_table.symbols + i);
		}
	}
	return NULL;
}
static void cs46xx_dsp_proc_symbol_table_read (struct snd_info_entry entry,
					       struct snd_info_buffer buffer)
{
	struct snd_cs46xx chip = entry->private_data;
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	int i;
	snd_iprintf(buffer, "SYMBOLS:\n");
	for ( i = 0; i < ins->symbol_table.nsymbols; ++i ) {
		char module_str = "system";
		if (ins->symbol_table.symbols[i].deleted)
			continue;
		if (ins->symbol_table.symbols[i].module != NULL) {
			module_str = ins->symbol_table.symbols[i].module->module_name;
		}
		snd_iprintf(buffer, "%04X <%02X> %s [%s]\n",
			    ins->symbol_table.symbols[i].address,
			    ins->symbol_table.symbols[i].symbol_type,
			    ins->symbol_table.symbols[i].symbol_name,
			    module_str);    
	}
}
static void cs46xx_dsp_proc_modules_read (struct snd_info_entry entry,
					  struct snd_info_buffer buffer)
{
	struct snd_cs46xx chip = entry->private_data;
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	int i,j;
	mutex_lock(&chip->spos_mutex);
	snd_iprintf(buffer, "MODULES:\n");
	for ( i = 0; i < ins->nmodules; ++i ) {
		snd_iprintf(buffer, "\n%s:\n", ins->modules[i].module_name);
		snd_iprintf(buffer, "   %d symbols\n", ins->modules[i].symbol_table.nsymbols);
		snd_iprintf(buffer, "   %d fixups\n", ins->modules[i].nfixups);
		for (j = 0; j < ins->modules[i].nsegments; ++ j) {
			struct dsp_segment_desc  desc = (ins->modules[i].segments + j);
			snd_iprintf(buffer, "   segment %02x offset %08x size %08x\n",
				    desc->segment_type,desc->offset, desc->size);
		}
	}
	mutex_unlock(&chip->spos_mutex);
}
static void cs46xx_dsp_proc_task_tree_read (struct snd_info_entry entry,
					    struct snd_info_buffer buffer)
{
	struct snd_cs46xx chip = entry->private_data;
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	int i, j, col;
	void __iomem dst = chip->region.idx[1].remap_addr + DSP_PARAMETER_BYTE_OFFSET;
	mutex_lock(&chip->spos_mutex);
	snd_iprintf(buffer, "TASK TREES:\n");
	for ( i = 0; i < ins->ntask; ++i) {
		snd_iprintf(buffer,"\n%04x %s:\n",ins->tasks[i].address,ins->tasks[i].task_name);
		for (col = 0,j = 0;j < ins->tasks[i].size; j++,col++) {
			u32 val;
			if (col == 4) {
				snd_iprintf(buffer,"\n");
				col = 0;
			}
			val = readl(dst + (ins->tasks[i].address + j)  sizeof(u32));
			snd_iprintf(buffer,"%08x ",val);
		}
	}
	snd_iprintf(buffer,"\n");  
	mutex_unlock(&chip->spos_mutex);
}
static void cs46xx_dsp_proc_scb_read (struct snd_info_entry entry,
				      struct snd_info_buffer buffer)
{
	struct snd_cs46xx chip = entry->private_data;
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	int i;
	mutex_lock(&chip->spos_mutex);
	snd_iprintf(buffer, "SCB's:\n");
	for ( i = 0; i < ins->nscb; ++i) {
		if (ins->scbs[i].deleted)
			continue;
		snd_iprintf(buffer,"\n%04x %s:\n\n",ins->scbs[i].address,ins->scbs[i].scb_name);
		if (ins->scbs[i].parent_scb_ptr != NULL) {
			snd_iprintf(buffer,"parent [%s:%04x] ", 
				    ins->scbs[i].parent_scb_ptr->scb_name,
				    ins->scbs[i].parent_scb_ptr->address);
		} else snd_iprintf(buffer,"parent [none] ");
		snd_iprintf(buffer,"sub_list_ptr [%s:%04x]\nnext_scb_ptr [%s:%04x]  task_entry [%s:%04x]\n",
			    ins->scbs[i].sub_list_ptr->scb_name,
			    ins->scbs[i].sub_list_ptr->address,
			    ins->scbs[i].next_scb_ptr->scb_name,
			    ins->scbs[i].next_scb_ptr->address,
			    ins->scbs[i].task_entry->symbol_name,
			    ins->scbs[i].task_entry->address);
	}
	snd_iprintf(buffer,"\n");
	mutex_unlock(&chip->spos_mutex);
}
static void cs46xx_dsp_proc_parameter_dump_read (struct snd_info_entry entry,
						 struct snd_info_buffer buffer)
{
	struct snd_cs46xx chip = entry->private_data;
	struct dsp_spos_instance  ins = chip->dsp_spos_instance; 
	unsigned int i, col = 0;
	void __iomem dst = chip->region.idx[1].remap_addr + DSP_PARAMETER_BYTE_OFFSET;
	struct dsp_symbol_entry  symbol; 
	for (i = 0;i < DSP_PARAMETER_BYTE_SIZE; i += sizeof(u32),col ++) {
		if (col == 4) {
			snd_iprintf(buffer,"\n");
			col = 0;
		}
		symbol = cs46xx_dsp_lookup_symbol_addr(chip, i  sizeof(u32), SYMBOL_PARAMETER);
		if (symbol) {
			col = 0;
			snd_iprintf (buffer,"\n%s:\n",symbol->symbol_name);
		}
		if (col == 0) {
			snd_iprintf(buffer, "%04X ", i  (unsigned int)sizeof(u32));
		}
		snd_iprintf(buffer,"%08X ",readl(dst + i));
	}
}
static void cs46xx_dsp_proc_sample_dump_read (struct snd_info_entry entry,
					      struct snd_info_buffer buffer)
{
	struct snd_cs46xx chip = entry->private_data;
	int i,col = 0;
	void __iomem dst = chip->region.idx[2].remap_addr;
	snd_iprintf(buffer,"PCMREADER:\n");
	for (i = PCM_READER_BUF1;i < PCM_READER_BUF1 + 0x30; i += sizeof(u32),col ++) {
		if (col == 4) {
			snd_iprintf(buffer,"\n");
			col = 0;
		}
		if (col == 0) {
			snd_iprintf(buffer, "%04X ",i);
		}
		snd_iprintf(buffer,"%08X ",readl(dst + i));
	}
	snd_iprintf(buffer,"\nMIX_SAMPLE_BUF1:\n");
	col = 0;
	for (i = MIX_SAMPLE_BUF1;i < MIX_SAMPLE_BUF1 + 0x40; i += sizeof(u32),col ++) {
		if (col == 4) {
			snd_iprintf(buffer,"\n");
			col = 0;
		}
		if (col == 0) {
			snd_iprintf(buffer, "%04X ",i);
		}
		snd_iprintf(buffer,"%08X ",readl(dst + i));
	}
	snd_iprintf(buffer,"\nSRC_TASK_SCB1:\n");
	col = 0;
	for (i = 0x2480 ; i < 0x2480 + 0x40 ; i += sizeof(u32),col ++) {
		if (col == 4) {
			snd_iprintf(buffer,"\n");
			col = 0;
		}
		
		if (col == 0) {
			snd_iprintf(buffer, "%04X ",i);
		}
		snd_iprintf(buffer,"%08X ",readl(dst + i));
	}
	snd_iprintf(buffer,"\nSPDIFO_BUFFER:\n");
	col = 0;
	for (i = SPDIFO_IP_OUTPUT_BUFFER1;i < SPDIFO_IP_OUTPUT_BUFFER1 + 0x30; i += sizeof(u32),col ++) {
		if (col == 4) {
			snd_iprintf(buffer,"\n");
			col = 0;
		}
		if (col == 0) {
			snd_iprintf(buffer, "%04X ",i);
		}
		snd_iprintf(buffer,"%08X ",readl(dst + i));
	}
	snd_iprintf(buffer,"\n...\n");
	col = 0;
	for (i = SPDIFO_IP_OUTPUT_BUFFER1+0xD0;i < SPDIFO_IP_OUTPUT_BUFFER1 + 0x110; i += sizeof(u32),col ++) {
		if (col == 4) {
			snd_iprintf(buffer,"\n");
			col = 0;
		}
		if (col == 0) {
			snd_iprintf(buffer, "%04X ",i);
		}
		snd_iprintf(buffer,"%08X ",readl(dst + i));
	}
	snd_iprintf(buffer,"\nOUTPUT_SNOOP:\n");
	col = 0;
	for (i = OUTPUT_SNOOP_BUFFER;i < OUTPUT_SNOOP_BUFFER + 0x40; i += sizeof(u32),col ++) {
		if (col == 4) {
			snd_iprintf(buffer,"\n");
			col = 0;
		}
		if (col == 0) {
			snd_iprintf(buffer, "%04X ",i);
		}
		snd_iprintf(buffer,"%08X ",readl(dst + i));
	}
	snd_iprintf(buffer,"\nCODEC_INPUT_BUF1: \n");
	col = 0;
	for (i = CODEC_INPUT_BUF1;i < CODEC_INPUT_BUF1 + 0x40; i += sizeof(u32),col ++) {
		if (col == 4) {
			snd_iprintf(buffer,"\n");
			col = 0;
		}
		if (col == 0) {
			snd_iprintf(buffer, "%04X ",i);
		}
		snd_iprintf(buffer,"%08X ",readl(dst + i));
	}
#if 0
	snd_iprintf(buffer,"\nWRITE_BACK_BUF1: \n");
	col = 0;
	for (i = WRITE_BACK_BUF1;i < WRITE_BACK_BUF1 + 0x40; i += sizeof(u32),col ++) {
		if (col == 4) {
			snd_iprintf(buffer,"\n");
			col = 0;
		}
		if (col == 0) {
			snd_iprintf(buffer, "%04X ",i);
		}
		snd_iprintf(buffer,"%08X ",readl(dst + i));
	}
#endif
	snd_iprintf(buffer,"\nSPDIFI_IP_OUTPUT_BUFFER1: \n");
	col = 0;
	for (i = SPDIFI_IP_OUTPUT_BUFFER1;i < SPDIFI_IP_OUTPUT_BUFFER1 + 0x80; i += sizeof(u32),col ++) {
		if (col == 4) {
			snd_iprintf(buffer,"\n");
			col = 0;
		}
		if (col == 0) {
			snd_iprintf(buffer, "%04X ",i);
		}
		
		snd_iprintf(buffer,"%08X ",readl(dst + i));
	}
	snd_iprintf(buffer,"\n");
}
int cs46xx_dsp_proc_init (struct snd_card card, struct snd_cs46xx chip)
{
	struct snd_info_entry entry;
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	int i;
	ins->snd_card = card;
	entry = snd_info_create_card_entry(card, "dsp", card->proc_root);
	if (entry)
		entry->mode = S_IFDIR | 0555;
	ins->proc_dsp_dir = entry;
	if (!ins->proc_dsp_dir)
		return -ENOMEM;
	entry = snd_info_create_card_entry(card, "spos_symbols",
					   ins->proc_dsp_dir);
	if (entry)
		snd_info_set_text_ops(entry, chip,
				      cs46xx_dsp_proc_symbol_table_read);
	entry = snd_info_create_card_entry(card, "spos_modules",
					   ins->proc_dsp_dir);
	if (entry)
		snd_info_set_text_ops(entry, chip,
				      cs46xx_dsp_proc_modules_read);
	entry = snd_info_create_card_entry(card, "parameter",
					   ins->proc_dsp_dir);
	if (entry)
		snd_info_set_text_ops(entry, chip,
				      cs46xx_dsp_proc_parameter_dump_read);
	entry = snd_info_create_card_entry(card, "sample",
					   ins->proc_dsp_dir);
	if (entry)
		snd_info_set_text_ops(entry, chip,
				      cs46xx_dsp_proc_sample_dump_read);
	entry = snd_info_create_card_entry(card, "task_tree",
					   ins->proc_dsp_dir);
	if (entry)
		snd_info_set_text_ops(entry, chip,
				      cs46xx_dsp_proc_task_tree_read);
	entry = snd_info_create_card_entry(card, "scb_info",
					   ins->proc_dsp_dir);
	if (entry)
		snd_info_set_text_ops(entry, chip,
				      cs46xx_dsp_proc_scb_read);
	mutex_lock(&chip->spos_mutex);
	 registerupdate SCB's entries on proc 
	for (i = 0; i < ins->nscb; ++i) {
		if (ins->scbs[i].deleted) continue;
		cs46xx_dsp_proc_register_scb_desc (chip, (ins->scbs + i));
	}
	mutex_unlock(&chip->spos_mutex);
	return 0;
}
int cs46xx_dsp_proc_done (struct snd_cs46xx chip)
{
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	int i;
	if (!ins)
		return 0;
	mutex_lock(&chip->spos_mutex);
	for (i = 0; i < ins->nscb; ++i) {
		if (ins->scbs[i].deleted) continue;
		cs46xx_dsp_proc_free_scb_desc ( (ins->scbs + i) );
	}
	mutex_unlock(&chip->spos_mutex);
	snd_info_free_entry(ins->proc_dsp_dir);
	ins->proc_dsp_dir = NULL;
	return 0;
}
#endif  CONFIG_SND_PROC_FS 
static void _dsp_create_task_tree (struct snd_cs46xx chip, u32  task_data,
				   u32  dest, int size)
{
	void __iomem spdst = chip->region.idx[1].remap_addr + 
		DSP_PARAMETER_BYTE_OFFSET + dest  sizeof(u32);
	int i;
	for (i = 0; i < size; ++i) {
		dev_dbg(chip->card->dev, "addr %p, val %08x\n",
			spdst, task_data[i]);
		writel(task_data[i],spdst);
		spdst += sizeof(u32);
	}
}
static void _dsp_create_scb (struct snd_cs46xx chip, u32  scb_data, u32 dest)
{
	void __iomem spdst = chip->region.idx[1].remap_addr + 
		DSP_PARAMETER_BYTE_OFFSET + dest  sizeof(u32);
	int i;
	for (i = 0; i < 0x10; ++i) {
		dev_dbg(chip->card->dev, "addr %p, val %08x\n",
			spdst, scb_data[i]);
		writel(scb_data[i],spdst);
		spdst += sizeof(u32);
	}
}
static int find_free_scb_index (struct dsp_spos_instance  ins)
{
	int index = ins->nscb, i;
	for (i = ins->scb_highest_frag_index; i < ins->nscb; ++i) {
		if (ins->scbs[i].deleted) {
			index = i;
			break;
		}
	}
	return index;
}
static struct dsp_scb_descriptor  _map_scb (struct snd_cs46xx chip, char  name, u32 dest)
{
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	struct dsp_scb_descriptor  desc = NULL;
	int index;
	if (ins->nscb == DSP_MAX_SCB_DESC - 1) {
		dev_err(chip->card->dev,
			"dsp_spos: got no place for other SCB\n");
		return NULL;
	}
	index = find_free_scb_index (ins);
	memset(&ins->scbs[index], 0, sizeof(ins->scbs[index]));
	strcpy(ins->scbs[index].scb_name, name);
	ins->scbs[index].address = dest;
	ins->scbs[index].index = index;
	ins->scbs[index].ref_count = 1;
	desc = (ins->scbs + index);
	ins->scbs[index].scb_symbol = add_symbol (chip, name, dest, SYMBOL_PARAMETER);
	if (index > ins->scb_highest_frag_index)
		ins->scb_highest_frag_index = index;
	if (index == ins->nscb)
		ins->nscb++;
	return desc;
}
static struct dsp_task_descriptor 
_map_task_tree (struct snd_cs46xx chip, char  name, u32 dest, u32 size)
{
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	struct dsp_task_descriptor  desc = NULL;
	if (ins->ntask == DSP_MAX_TASK_DESC - 1) {
		dev_err(chip->card->dev,
			"dsp_spos: got no place for other TASK\n");
		return NULL;
	}
	if (name)
		strcpy(ins->tasks[ins->ntask].task_name, name);
	else
		strcpy(ins->tasks[ins->ntask].task_name, "(NULL)");
	ins->tasks[ins->ntask].address = dest;
	ins->tasks[ins->ntask].size = size;
	 quick find in list 
	ins->tasks[ins->ntask].index = ins->ntask;
	desc = (ins->tasks + ins->ntask);
	ins->ntask++;
	if (name)
		add_symbol (chip,name,dest,SYMBOL_PARAMETER);
	return desc;
}
#define SCB_BYTES	(0x10  4)
struct dsp_scb_descriptor 
cs46xx_dsp_create_scb (struct snd_cs46xx chip, char  name, u32  scb_data, u32 dest)
{
	struct dsp_scb_descriptor  desc;
#ifdef CONFIG_PM_SLEEP
	 copy the data for resume 
	scb_data = kmemdup(scb_data, SCB_BYTES, GFP_KERNEL);
	if (!scb_data)
		return NULL;
#endif
	desc = _map_scb (chip,name,dest);
	if (desc) {
		desc->data = scb_data;
		_dsp_create_scb(chip,scb_data,dest);
	} else {
		dev_err(chip->card->dev, "dsp_spos: failed to map SCB\n");
#ifdef CONFIG_PM_SLEEP
		kfree(scb_data);
#endif
	}
	return desc;
}
static struct dsp_task_descriptor 
cs46xx_dsp_create_task_tree (struct snd_cs46xx chip, char  name, u32  task_data,
			     u32 dest, int size)
{
	struct dsp_task_descriptor  desc;
	desc = _map_task_tree (chip,name,dest,size);
	if (desc) {
		desc->data = task_data;
		_dsp_create_task_tree(chip,task_data,dest,size);
	} else {
		dev_err(chip->card->dev, "dsp_spos: failed to map TASK\n");
	}
	return desc;
}
int cs46xx_dsp_scb_and_task_init (struct snd_cs46xx chip)
{
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	struct dsp_symbol_entry  fg_task_tree_header_code;
	struct dsp_symbol_entry  task_tree_header_code;
	struct dsp_symbol_entry  task_tree_thread;
	struct dsp_symbol_entry  null_algorithm;
	struct dsp_symbol_entry  magic_snoop_task;
	struct dsp_scb_descriptor  timing_master_scb;
	struct dsp_scb_descriptor  codec_out_scb;
	struct dsp_scb_descriptor  codec_in_scb;
	struct dsp_scb_descriptor  src_task_scb;
	struct dsp_scb_descriptor  master_mix_scb;
	struct dsp_scb_descriptor  rear_mix_scb;
	struct dsp_scb_descriptor  record_mix_scb;
	struct dsp_scb_descriptor  write_back_scb;
	struct dsp_scb_descriptor  vari_decimate_scb;
	struct dsp_scb_descriptor  rear_codec_out_scb;
	struct dsp_scb_descriptor  clfe_codec_out_scb;
	struct dsp_scb_descriptor  magic_snoop_scb;
	
	int fifo_addr, fifo_span, valid_slots;
	static const struct dsp_spos_control_block sposcb = {
		 0  HFG_TREE_SCB,HFG_STACK,
		 1  SPOSCB_ADDR,BG_TREE_SCB_ADDR,
		 2  DSP_SPOS_DC,0,
		 3  DSP_SPOS_DC,DSP_SPOS_DC,
		 4  0,0,
		 5  DSP_SPOS_UU,0,
		 6  FG_TASK_HEADER_ADDR,0,
		 7  0,0,
		 8  DSP_SPOS_UU,DSP_SPOS_DC,
		 9  0,
		 A  0,HFG_FIRST_EXECUTE_MODE,
		 B  DSP_SPOS_UU,DSP_SPOS_UU,
		 C  DSP_SPOS_DC_DC,
		 D  DSP_SPOS_DC_DC,
		 E  DSP_SPOS_DC_DC,
		 F  DSP_SPOS_DC_DC
	};
	cs46xx_dsp_create_task_tree(chip, "sposCB", (u32 )&sposcb, SPOSCB_ADDR, 0x10);
	null_algorithm  = cs46xx_dsp_lookup_symbol(chip, "NULLALGORITHM", SYMBOL_CODE);
	if (null_algorithm == NULL) {
		dev_err(chip->card->dev,
			"dsp_spos: symbol NULLALGORITHM not found\n");
		return -EIO;
	}
	fg_task_tree_header_code = cs46xx_dsp_lookup_symbol(chip, "FGTASKTREEHEADERCODE", SYMBOL_CODE);  
	if (fg_task_tree_header_code == NULL) {
		dev_err(chip->card->dev,
			"dsp_spos: symbol FGTASKTREEHEADERCODE not found\n");
		return -EIO;
	}
	task_tree_header_code = cs46xx_dsp_lookup_symbol(chip, "TASKTREEHEADERCODE", SYMBOL_CODE);  
	if (task_tree_header_code == NULL) {
		dev_err(chip->card->dev,
			"dsp_spos: symbol TASKTREEHEADERCODE not found\n");
		return -EIO;
	}
	task_tree_thread = cs46xx_dsp_lookup_symbol(chip, "TASKTREETHREAD", SYMBOL_CODE);
	if (task_tree_thread == NULL) {
		dev_err(chip->card->dev,
			"dsp_spos: symbol TASKTREETHREAD not found\n");
		return -EIO;
	}
	magic_snoop_task = cs46xx_dsp_lookup_symbol(chip, "MAGICSNOOPTASK", SYMBOL_CODE);
	if (magic_snoop_task == NULL) {
		dev_err(chip->card->dev,
			"dsp_spos: symbol MAGICSNOOPTASK not found\n");
		return -EIO;
	}
	{
		 create the null SCB 
		static struct dsp_generic_scb null_scb = {
			{ 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 0 },
			NULL_SCB_ADDR, NULL_SCB_ADDR,
			0, 0, 0, 0, 0,
			{
				0,0,
				0,0,
			}
		};
		null_scb.entry_point = null_algorithm->address;
		ins->the_null_scb = cs46xx_dsp_create_scb(chip, "nullSCB", (u32 )&null_scb, NULL_SCB_ADDR);
		ins->the_null_scb->task_entry = null_algorithm;
		ins->the_null_scb->sub_list_ptr = ins->the_null_scb;
		ins->the_null_scb->next_scb_ptr = ins->the_null_scb;
		ins->the_null_scb->parent_scb_ptr = NULL;
		cs46xx_dsp_proc_register_scb_desc (chip,ins->the_null_scb);
	}
	{
		 setup foreground task tree 
		static struct dsp_task_tree_control_block fg_task_tree_hdr =  {
			{ FG_TASK_HEADER_ADDR | (DSP_SPOS_DC << 0x10),
			  DSP_SPOS_DC_DC,
			  DSP_SPOS_DC_DC,
			  0x0000,DSP_SPOS_DC,
			  DSP_SPOS_DC, DSP_SPOS_DC,
			  DSP_SPOS_DC_DC,
			  DSP_SPOS_DC_DC,
			  DSP_SPOS_DC_DC,
			  DSP_SPOS_DC,DSP_SPOS_DC },
			{
				BG_TREE_SCB_ADDR,TIMINGMASTER_SCB_ADDR, 
				0,
				FG_TASK_HEADER_ADDR + TCBData,                  
			},
			{    
				4,0,
				1,0,
				2,SPOSCB_ADDR + HFGFlags,
				0,0,
				FG_TASK_HEADER_ADDR + TCBContextBlk,FG_STACK
			},
			{
				DSP_SPOS_DC,0,
				DSP_SPOS_DC,DSP_SPOS_DC,
				DSP_SPOS_DC,DSP_SPOS_DC,
				DSP_SPOS_DC,DSP_SPOS_DC,
				DSP_SPOS_DC,DSP_SPOS_DC,
				DSP_SPOS_DCDC,
				DSP_SPOS_UU,1,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC 
			},                                               
			{ 
				FG_INTERVAL_TIMER_PERIOD,DSP_SPOS_UU,
				0,0
			}
		};
		fg_task_tree_hdr.links.entry_point = fg_task_tree_header_code->address;
		fg_task_tree_hdr.context_blk.stack0 = task_tree_thread->address;
		cs46xx_dsp_create_task_tree(chip,"FGtaskTreeHdr",(u32 )&fg_task_tree_hdr,FG_TASK_HEADER_ADDR,0x35);
	}
	{
		 setup foreground task tree 
		static struct dsp_task_tree_control_block bg_task_tree_hdr =  {
			{ DSP_SPOS_DC_DC,
			  DSP_SPOS_DC_DC,
			  DSP_SPOS_DC_DC,
			  DSP_SPOS_DC, DSP_SPOS_DC,
			  DSP_SPOS_DC, DSP_SPOS_DC,
			  DSP_SPOS_DC_DC,
			  DSP_SPOS_DC_DC,
			  DSP_SPOS_DC_DC,
			  DSP_SPOS_DC,DSP_SPOS_DC },
			{
				NULL_SCB_ADDR,NULL_SCB_ADDR,   Set up the background to do nothing 
				0,
				BG_TREE_SCB_ADDR + TCBData,
			},
			{    
				9999,0,
				0,1,
				0,SPOSCB_ADDR + HFGFlags,
				0,0,
				BG_TREE_SCB_ADDR + TCBContextBlk,BG_STACK
			},
			{
				DSP_SPOS_DC,0,
				DSP_SPOS_DC,DSP_SPOS_DC,
				DSP_SPOS_DC,DSP_SPOS_DC,
				DSP_SPOS_DC,DSP_SPOS_DC,
				DSP_SPOS_DC,DSP_SPOS_DC,
				DSP_SPOS_DCDC,
				DSP_SPOS_UU,1,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC,
				DSP_SPOS_DCDC 
			},                                               
			{ 
				BG_INTERVAL_TIMER_PERIOD,DSP_SPOS_UU,
				0,0
			}
		};
		bg_task_tree_hdr.links.entry_point = task_tree_header_code->address;
		bg_task_tree_hdr.context_blk.stack0 = task_tree_thread->address;
		cs46xx_dsp_create_task_tree(chip,"BGtaskTreeHdr",(u32 )&bg_task_tree_hdr,BG_TREE_SCB_ADDR,0x35);
	}
	 create timing master SCB 
	timing_master_scb = cs46xx_dsp_create_timing_master_scb(chip);
	 create the CODEC output task 
	codec_out_scb = cs46xx_dsp_create_codec_out_scb(chip,"CodecOutSCB_I",0x0010,0x0000,
							MASTERMIX_SCB_ADDR,
							CODECOUT_SCB_ADDR,timing_master_scb,
							SCB_ON_PARENT_SUBLIST_SCB);
	if (!codec_out_scb) goto _fail_end;
	 create the master mix SCB 
	master_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,"MasterMixSCB",
							MIX_SAMPLE_BUF1,MASTERMIX_SCB_ADDR,
							codec_out_scb,
							SCB_ON_PARENT_SUBLIST_SCB);
	ins->master_mix_scb = master_mix_scb;
	if (!master_mix_scb) goto _fail_end;
	 create codec in 
	codec_in_scb = cs46xx_dsp_create_codec_in_scb(chip,"CodecInSCB",0x0010,0x00A0,
						      CODEC_INPUT_BUF1,
						      CODECIN_SCB_ADDR,codec_out_scb,
						      SCB_ON_PARENT_NEXT_SCB);
	if (!codec_in_scb) goto _fail_end;
	ins->codec_in_scb = codec_in_scb;
	 create write back scb 
	write_back_scb = cs46xx_dsp_create_mix_to_ostream_scb(chip,"WriteBackSCB",
							      WRITE_BACK_BUF1,WRITE_BACK_SPB,
							      WRITEBACK_SCB_ADDR,
							      timing_master_scb,
							      SCB_ON_PARENT_NEXT_SCB);
	if (!write_back_scb) goto _fail_end;
	{
		static struct dsp_mix2_ostream_spb mix2_ostream_spb = {
			0x00020000,
			0x0000ffff
		};
		if (!cs46xx_dsp_create_task_tree(chip, NULL,
						 (u32 )&mix2_ostream_spb,
						 WRITE_BACK_SPB, 2))
			goto _fail_end;
	}
	 input sample converter 
	vari_decimate_scb = cs46xx_dsp_create_vari_decimate_scb(chip,"VariDecimateSCB",
								VARI_DECIMATE_BUF0,
								VARI_DECIMATE_BUF1,
								VARIDECIMATE_SCB_ADDR,
								write_back_scb,
								SCB_ON_PARENT_SUBLIST_SCB);
	if (!vari_decimate_scb) goto _fail_end;
	 create the record mixer SCB 
	record_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,"RecordMixerSCB",
							MIX_SAMPLE_BUF2,
							RECORD_MIXER_SCB_ADDR,
							vari_decimate_scb,
							SCB_ON_PARENT_SUBLIST_SCB);
	ins->record_mixer_scb = record_mix_scb;
	if (!record_mix_scb) goto _fail_end;
	valid_slots = snd_cs46xx_peekBA0(chip, BA0_ACOSV);
	if (snd_BUG_ON(chip->nr_ac97_codecs != 1 && chip->nr_ac97_codecs != 2))
		goto _fail_end;
	if (chip->nr_ac97_codecs == 1) {
 output on slot 5 and 11 
		   on primary CODEC 
		fifo_addr = 0x20;
		fifo_span = 0x60;
		 enable slot 5 and 11 
		valid_slots |= ACOSV_SLV5 | ACOSV_SLV11;
	} else {
 output on slot 7 and 8 
		   on secondary CODEC 
		fifo_addr = 0x40;
		fifo_span = 0x10;
		 enable slot 7 and 8 
		valid_slots |= ACOSV_SLV7 | ACOSV_SLV8;
	}
	 create CODEC tasklet for rear speakers output
	rear_codec_out_scb = cs46xx_dsp_create_codec_out_scb(chip,"CodecOutSCB_Rear",fifo_span,fifo_addr,
							     REAR_MIXER_SCB_ADDR,
							     REAR_CODECOUT_SCB_ADDR,codec_in_scb,
							     SCB_ON_PARENT_NEXT_SCB);
	if (!rear_codec_out_scb) goto _fail_end;
	
	
	 create the rear PCM channel  mixer SCB 
	rear_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,"RearMixerSCB",
						      MIX_SAMPLE_BUF3,
						      REAR_MIXER_SCB_ADDR,
						      rear_codec_out_scb,
						      SCB_ON_PARENT_SUBLIST_SCB);
	ins->rear_mix_scb = rear_mix_scb;
	if (!rear_mix_scb) goto _fail_end;
	
	if (chip->nr_ac97_codecs == 2) {
 create CODEC tasklet for rear CenterLFE output 
		   slot 6 and 9 on secondary CODEC 
		clfe_codec_out_scb = cs46xx_dsp_create_codec_out_scb(chip,"CodecOutSCB_CLFE",0x0030,0x0030,
								     CLFE_MIXER_SCB_ADDR,
								     CLFE_CODEC_SCB_ADDR,
								     rear_codec_out_scb,
								     SCB_ON_PARENT_NEXT_SCB);
		if (!clfe_codec_out_scb) goto _fail_end;
		
		
		 create the rear PCM channel  mixer SCB 
		ins->center_lfe_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,"CLFEMixerSCB",
									 MIX_SAMPLE_BUF4,
									 CLFE_MIXER_SCB_ADDR,
									 clfe_codec_out_scb,
									 SCB_ON_PARENT_SUBLIST_SCB);
		if (!ins->center_lfe_mix_scb) goto _fail_end;
		 enable slot 6 and 9 
		valid_slots |= ACOSV_SLV6 | ACOSV_SLV9;
	} else {
		clfe_codec_out_scb = rear_codec_out_scb;
		ins->center_lfe_mix_scb = rear_mix_scb;
	}
	 enable slots depending on CODEC configuration 
	snd_cs46xx_pokeBA0(chip, BA0_ACOSV, valid_slots);
	 the magic snooper 
	magic_snoop_scb = cs46xx_dsp_create_magic_snoop_scb (chip,"MagicSnoopSCB_I",OUTPUTSNOOP_SCB_ADDR,
							     OUTPUT_SNOOP_BUFFER,
							     codec_out_scb,
							     clfe_codec_out_scb,
							     SCB_ON_PARENT_NEXT_SCB);
	if (!magic_snoop_scb) goto _fail_end;
	ins->ref_snoop_scb = magic_snoop_scb;
	 SP IO access 
	if (!cs46xx_dsp_create_spio_write_scb(chip,"SPIOWriteSCB",SPIOWRITE_SCB_ADDR,
					      magic_snoop_scb,
					      SCB_ON_PARENT_NEXT_SCB))
		goto _fail_end;
	 SPDIF input sampel rate converter 
	src_task_scb = cs46xx_dsp_create_src_task_scb(chip,"SrcTaskSCB_SPDIFI",
						      ins->spdif_in_sample_rate,
						      SRC_OUTPUT_BUF1,
						      SRC_DELAY_BUF1,SRCTASK_SCB_ADDR,
						      master_mix_scb,
						      SCB_ON_PARENT_SUBLIST_SCB,1);
	if (!src_task_scb) goto _fail_end;
	cs46xx_src_unlink(chip,src_task_scb);
 NOTE: when we now how to detect the SPDIF input
	   sample rate we will use this SRC to adjust it 
	ins->spdif_in_src = src_task_scb;
	cs46xx_dsp_async_init(chip,timing_master_scb);
	return 0;
 _fail_end:
	dev_err(chip->card->dev, "dsp_spos: failed to setup SCB's in DSP\n");
	return -EINVAL;
}
static int cs46xx_dsp_async_init (struct snd_cs46xx chip,
				  struct dsp_scb_descriptor  fg_entry)
{
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	struct dsp_symbol_entry  s16_async_codec_input_task;
	struct dsp_symbol_entry  spdifo_task;
	struct dsp_symbol_entry  spdifi_task;
	struct dsp_scb_descriptor  spdifi_scb_desc,  spdifo_scb_desc,  async_codec_scb_desc;
	s16_async_codec_input_task = cs46xx_dsp_lookup_symbol(chip, "S16_ASYNCCODECINPUTTASK", SYMBOL_CODE);
	if (s16_async_codec_input_task == NULL) {
		dev_err(chip->card->dev,
			"dsp_spos: symbol S16_ASYNCCODECINPUTTASK not found\n");
		return -EIO;
	}
	spdifo_task = cs46xx_dsp_lookup_symbol(chip, "SPDIFOTASK", SYMBOL_CODE);
	if (spdifo_task == NULL) {
		dev_err(chip->card->dev,
			"dsp_spos: symbol SPDIFOTASK not found\n");
		return -EIO;
	}
	spdifi_task = cs46xx_dsp_lookup_symbol(chip, "SPDIFITASK", SYMBOL_CODE);
	if (spdifi_task == NULL) {
		dev_err(chip->card->dev,
			"dsp_spos: symbol SPDIFITASK not found\n");
		return -EIO;
	}
	{
		 0xBC0 
		struct dsp_spdifoscb spdifo_scb = {
			 0  DSP_SPOS_UUUU,
			{
				 1  0xb0, 
				 2  0, 
				 3  0, 
				 4  0, 
			},
 NOTE: the SPDIF output task read samples in mono
			
			 5  RSCONFIG_SAMPLE_16MONO + RSCONFIG_MODULO_256,
			 6  ( SPDIFO_IP_OUTPUT_BUFFER1 << 0x10 )  |  0xFFFC,
			 7  0,0, 
			 8  0, 
			 9  FG_TASK_HEADER_ADDR, NULL_SCB_ADDR, 
			 A  spdifo_task->address,
			SPDIFO_SCB_INST + SPDIFOFIFOPointer,
			{
				 B  0x0040, DSP_SPOS_UUUU,
				 C  0x20ff, DSP_SPOS_UUUU,
			},
			 D  0x804c,0,							   SPDIFOFIFOPointer:SPDIFOStatRegAddr; 
			 E  0x0108,0x0001,					   SPDIFOStMoFormat:SPDIFOFIFOBaseAddr; 
			 F  DSP_SPOS_UUUU	  			           SPDIFOFree; 
		};
		 0xBB0 
		struct dsp_spdifiscb spdifi_scb = {
			 0  DSP_SPOS_UULO,DSP_SPOS_UUHI,
			 1  0,
			 2  0,
			 3  1,4000,         SPDIFICountLimit SPDIFICount  
			 4  DSP_SPOS_UUUU,  SPDIFIStatusData 
			 5  0,DSP_SPOS_UUHI,  StatusData, Free4 
			 6  DSP_SPOS_UUUU,   Free3 
			 7  DSP_SPOS_UU,DSP_SPOS_DC,   Free2 BitCount
			 8  DSP_SPOS_UUUU,	 TempStatus 
			 9  SPDIFO_SCB_INST, NULL_SCB_ADDR,
			 A  spdifi_task->address,
			SPDIFI_SCB_INST + SPDIFIFIFOPointer,
 NOTE: The SPDIF input task write the sample in mono
			
			 B  RSCONFIG_SAMPLE_16MONO + RSCONFIG_MODULO_128,
			 C  (SPDIFI_IP_OUTPUT_BUFFER1 << 0x10) | 0xFFFC,
			 D  0x8048,0,
			 E  0x01f0,0x0001,
			 F  DSP_SPOS_UUUU  SPDIN_STATUS monitor 
		};
		 0xBA0 
		struct dsp_async_codec_input_scb async_codec_input_scb = {
			 0  DSP_SPOS_UUUU,
			 1  0,
			 2  0,
			 3  1,4000,
			 4  0x0118,0x0001,
			 5  RSCONFIG_SAMPLE_16MONO + RSCONFIG_MODULO_64,
			 6  (ASYNC_IP_OUTPUT_BUFFER1 << 0x10) | 0xFFFC,
			 7  DSP_SPOS_UU,0x3,
			 8  DSP_SPOS_UUUU,
			 9  SPDIFI_SCB_INST,NULL_SCB_ADDR,
			 A  s16_async_codec_input_task->address,
			HFG_TREE_SCB + AsyncCIOFIFOPointer,
			 B  RSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_64,
			 C  (ASYNC_IP_OUTPUT_BUFFER1 << 0x10),  (ASYNC_IP_OUTPUT_BUFFER1 << 0x10) | 0xFFFC,
#ifdef UseASER1Input
 short AsyncCIFIFOPointer:AsyncCIStatRegAddr;	       
			   0000:8044: for ASER2 
			 D  0x8042,0,
 short AsyncCIStMoFormat:AsyncCIFIFOBaseAddr;
			   Init 1 Stereo : 0100 ASER1 (Set by script) 
			 E  0x0100,0x0001,
#endif
#ifdef UseASER2Input
 short AsyncCIFIFOPointer:AsyncCIStatRegAddr;
			   0000:8044: for ASER2 
			 D  0x8044,0,
 short AsyncCIStMoFormat:AsyncCIFIFOBaseAddr;
			   Init 1 Stereo : 0100 ASER1 (Set by script) 
			 E  0x0110,0x0001,
#endif
 short AsyncCIOutputBufModulo:AsyncCIFree;
			   the output buffer of this task 
			 F  0,  DSP_SPOS_UUUU 
		};
		spdifo_scb_desc = cs46xx_dsp_create_scb(chip,"SPDIFOSCB",(u32 )&spdifo_scb,SPDIFO_SCB_INST);
		if (snd_BUG_ON(!spdifo_scb_desc))
			return -EIO;
		spdifi_scb_desc = cs46xx_dsp_create_scb(chip,"SPDIFISCB",(u32 )&spdifi_scb,SPDIFI_SCB_INST);
		if (snd_BUG_ON(!spdifi_scb_desc))
			return -EIO;
		async_codec_scb_desc = cs46xx_dsp_create_scb(chip,"AsynCodecInputSCB",(u32 )&async_codec_input_scb, HFG_TREE_SCB);
		if (snd_BUG_ON(!async_codec_scb_desc))
			return -EIO;
		async_codec_scb_desc->parent_scb_ptr = NULL;
		async_codec_scb_desc->next_scb_ptr = spdifi_scb_desc;
		async_codec_scb_desc->sub_list_ptr = ins->the_null_scb;
		async_codec_scb_desc->task_entry = s16_async_codec_input_task;
		spdifi_scb_desc->parent_scb_ptr = async_codec_scb_desc;
		spdifi_scb_desc->next_scb_ptr = spdifo_scb_desc;
		spdifi_scb_desc->sub_list_ptr = ins->the_null_scb;
		spdifi_scb_desc->task_entry = spdifi_task;
		spdifo_scb_desc->parent_scb_ptr = spdifi_scb_desc;
		spdifo_scb_desc->next_scb_ptr = fg_entry;
		spdifo_scb_desc->sub_list_ptr = ins->the_null_scb;
		spdifo_scb_desc->task_entry = spdifo_task;
 this one is faked, as the parnet of SPDIFO task
		   is the FG task tree 
		fg_entry->parent_scb_ptr = spdifo_scb_desc;
		 for proc fs 
		cs46xx_dsp_proc_register_scb_desc (chip,spdifo_scb_desc);
		cs46xx_dsp_proc_register_scb_desc (chip,spdifi_scb_desc);
		cs46xx_dsp_proc_register_scb_desc (chip,async_codec_scb_desc);
		 Async MASTER ENABLE, affects both SPDIF input and output 
		snd_cs46xx_pokeBA0(chip, BA0_ASER_MASTER, 0x1 );
	}
	return 0;
}
static void cs46xx_dsp_disable_spdif_hw (struct snd_cs46xx chip)
{
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	 set SPDIF output FIFO slot 
	snd_cs46xx_pokeBA0(chip, BA0_ASER_FADDR, 0);
	 SPDIF output MASTER ENABLE 
	cs46xx_poke_via_dsp (chip,SP_SPDOUT_CONTROL, 0);
	 right and left validate bit 
	cs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV, ins->spdif_csuv_default);
	cs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV, 0x0);
	 clear fifo pointer 
	cs46xx_poke_via_dsp (chip,SP_SPDIN_FIFOPTR, 0x0);
	 monitor state 
	ins->spdif_status_out &= ~DSP_SPDIF_STATUS_HW_ENABLED;
}
int cs46xx_dsp_enable_spdif_hw (struct snd_cs46xx chip)
{
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	 if hw-ctrl already enabled, turn off to reset logic ... 
	cs46xx_dsp_disable_spdif_hw (chip);
	udelay(50);
	 set SPDIF output FIFO slot 
	snd_cs46xx_pokeBA0(chip, BA0_ASER_FADDR, ( 0x8000 | ((SP_SPDOUT_FIFO >> 4) << 4) ));
	 SPDIF output MASTER ENABLE 
	cs46xx_poke_via_dsp (chip,SP_SPDOUT_CONTROL, 0x80000000);
	 right and left validate bit 
	cs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV, ins->spdif_csuv_default);
	 monitor state 
	ins->spdif_status_out |= DSP_SPDIF_STATUS_HW_ENABLED;
	return 0;
}
int cs46xx_dsp_enable_spdif_in (struct snd_cs46xx chip)
{
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	 turn on amplifier 
	chip->active_ctrl(chip, 1);
	chip->amplifier_ctrl(chip, 1);
	if (snd_BUG_ON(ins->asynch_rx_scb))
		return -EINVAL;
	if (snd_BUG_ON(!ins->spdif_in_src))
		return -EINVAL;
	mutex_lock(&chip->spos_mutex);
	if ( ! (ins->spdif_status_out & DSP_SPDIF_STATUS_INPUT_CTRL_ENABLED) ) {
		 time countdown enable 
		cs46xx_poke_via_dsp (chip,SP_ASER_COUNTDOWN, 0x80000005);
 NOTE: 80000005 value is just magic. With all values
		   Got no explication why. (Benny) 
		 SPDIF input MASTER ENABLE 
		cs46xx_poke_via_dsp (chip,SP_SPDIN_CONTROL, 0x800003ff);
		ins->spdif_status_out |= DSP_SPDIF_STATUS_INPUT_CTRL_ENABLED;
	}
	 create and start the asynchronous receiver SCB 
	ins->asynch_rx_scb = cs46xx_dsp_create_asynch_fg_rx_scb(chip,"AsynchFGRxSCB",
								ASYNCRX_SCB_ADDR,
								SPDIFI_SCB_INST,
								SPDIFI_IP_OUTPUT_BUFFER1,
								ins->spdif_in_src,
								SCB_ON_PARENT_SUBLIST_SCB);
	spin_lock_irq(&chip->reg_lock);
	 reset SPDIF input sample buffer pointer 
snd_cs46xx_poke (chip, (SPDIFI_SCB_INST + 0x0c) << 2,
	  (SPDIFI_IP_OUTPUT_BUFFER1 << 0x10) | 0xFFFC);
	 reset FIFO ptr 
	cs46xx_poke_via_dsp (chip,SP_SPDIN_FIFOPTR, 0x0);
	cs46xx_src_link(chip,ins->spdif_in_src);
	 unmute SRC volume 
	cs46xx_dsp_scb_set_volume (chip,ins->spdif_in_src,0x7fff,0x7fff);
	spin_unlock_irq(&chip->reg_lock);
 set SPDIF input sample rate and unmute
	   NOTE: only 48khz support for SPDIF input this time 
	 cs46xx_dsp_set_src_sample_rate(chip,ins->spdif_in_src,48000); 
	 monitor state 
	ins->spdif_status_in = 1;
	mutex_unlock(&chip->spos_mutex);
	return 0;
}
int cs46xx_dsp_disable_spdif_in (struct snd_cs46xx chip)
{
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	if (snd_BUG_ON(!ins->asynch_rx_scb))
		return -EINVAL;
	if (snd_BUG_ON(!ins->spdif_in_src))
		return -EINVAL;
	mutex_lock(&chip->spos_mutex);
	 Remove the asynchronous receiver SCB 
	cs46xx_dsp_remove_scb (chip,ins->asynch_rx_scb);
	ins->asynch_rx_scb = NULL;
	cs46xx_src_unlink(chip,ins->spdif_in_src);
	 monitor state 
	ins->spdif_status_in = 0;
	mutex_unlock(&chip->spos_mutex);
	 restore amplifier 
	chip->active_ctrl(chip, -1);
	chip->amplifier_ctrl(chip, -1);
	return 0;
}
int cs46xx_dsp_enable_pcm_capture (struct snd_cs46xx chip)
{
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	if (snd_BUG_ON(ins->pcm_input))
		return -EINVAL;
	if (snd_BUG_ON(!ins->ref_snoop_scb))
		return -EINVAL;
	mutex_lock(&chip->spos_mutex);
	ins->pcm_input = cs46xx_add_record_source(chip,ins->ref_snoop_scb,PCMSERIALIN_PCM_SCB_ADDR,
                                                  "PCMSerialInput_Wave");
	mutex_unlock(&chip->spos_mutex);
	return 0;
}
int cs46xx_dsp_disable_pcm_capture (struct snd_cs46xx chip)
{
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	if (snd_BUG_ON(!ins->pcm_input))
		return -EINVAL;
	mutex_lock(&chip->spos_mutex);
	cs46xx_dsp_remove_scb (chip,ins->pcm_input);
	ins->pcm_input = NULL;
	mutex_unlock(&chip->spos_mutex);
	return 0;
}
int cs46xx_dsp_enable_adc_capture (struct snd_cs46xx chip)
{
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	if (snd_BUG_ON(ins->adc_input))
		return -EINVAL;
	if (snd_BUG_ON(!ins->codec_in_scb))
		return -EINVAL;
	mutex_lock(&chip->spos_mutex);
	ins->adc_input = cs46xx_add_record_source(chip,ins->codec_in_scb,PCMSERIALIN_SCB_ADDR,
						  "PCMSerialInput_ADC");
	mutex_unlock(&chip->spos_mutex);
	return 0;
}
int cs46xx_dsp_disable_adc_capture (struct snd_cs46xx chip)
{
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	if (snd_BUG_ON(!ins->adc_input))
		return -EINVAL;
	mutex_lock(&chip->spos_mutex);
	cs46xx_dsp_remove_scb (chip,ins->adc_input);
	ins->adc_input = NULL;
	mutex_unlock(&chip->spos_mutex);
	return 0;
}
int cs46xx_poke_via_dsp (struct snd_cs46xx chip, u32 address, u32 data)
{
	u32 temp;
	int  i;
 santiy check the parameters.  (These numbers are not 100% correct.  They are
	   a rough guess from looking at the controller spec.) 
	if (address < 0x8000 || address >= 0x9000)
		return -EINVAL;
	 initialize the SP_IO_WRITE SCB with the data. 
	temp = ( address << 16 ) | ( address & 0x0000FFFF);    offset 0 <-- address2 : address1 
	snd_cs46xx_poke(chip,( SPIOWRITE_SCB_ADDR      << 2), temp);
	snd_cs46xx_poke(chip,((SPIOWRITE_SCB_ADDR + 1) << 2), data);  offset 1 <-- data1 
	snd_cs46xx_poke(chip,((SPIOWRITE_SCB_ADDR + 2) << 2), data);  offset 1 <-- data2 
	 Poke this location to tell the task to start 
	snd_cs46xx_poke(chip,((SPIOWRITE_SCB_ADDR + 6) << 2), SPIOWRITE_SCB_ADDR << 0x10);
	 Verify that the task ran 
	for (i=0; i<25; i++) {
		udelay(125);
		temp =  snd_cs46xx_peek(chip,((SPIOWRITE_SCB_ADDR + 6) << 2));
		if (temp == 0x00000000)
			break;
	}
	if (i == 25) {
		dev_err(chip->card->dev,
			"dsp_spos: SPIOWriteTask not responding\n");
		return -EBUSY;
	}
	return 0;
}
int cs46xx_dsp_set_dac_volume (struct snd_cs46xx  chip, u16 left, u16 right)
{
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	struct dsp_scb_descriptor  scb; 
	mutex_lock(&chip->spos_mutex);
	
	 main output 
	scb = ins->master_mix_scb->sub_list_ptr;
	while (scb != ins->the_null_scb) {
		cs46xx_dsp_scb_set_volume (chip,scb,left,right);
		scb = scb->next_scb_ptr;
	}
	 rear output 
	scb = ins->rear_mix_scb->sub_list_ptr;
	while (scb != ins->the_null_scb) {
		cs46xx_dsp_scb_set_volume (chip,scb,left,right);
		scb = scb->next_scb_ptr;
	}
	ins->dac_volume_left = left;
	ins->dac_volume_right = right;
	mutex_unlock(&chip->spos_mutex);
	return 0;
}
int cs46xx_dsp_set_iec958_volume (struct snd_cs46xx  chip, u16 left, u16 right)
{
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	mutex_lock(&chip->spos_mutex);
	if (ins->asynch_rx_scb != NULL)
		cs46xx_dsp_scb_set_volume (chip,ins->asynch_rx_scb,
					   left,right);
	ins->spdif_input_volume_left = left;
	ins->spdif_input_volume_right = right;
	mutex_unlock(&chip->spos_mutex);
	return 0;
}
#ifdef CONFIG_PM_SLEEP
int cs46xx_dsp_resume(struct snd_cs46xx  chip)
{
	struct dsp_spos_instance  ins = chip->dsp_spos_instance;
	int i, err;
	 clear parameter, sample and code areas 
	snd_cs46xx_clear_BA1(chip, DSP_PARAMETER_BYTE_OFFSET,
			     DSP_PARAMETER_BYTE_SIZE);
	snd_cs46xx_clear_BA1(chip, DSP_SAMPLE_BYTE_OFFSET,
			     DSP_SAMPLE_BYTE_SIZE);
	snd_cs46xx_clear_BA1(chip, DSP_CODE_BYTE_OFFSET, DSP_CODE_BYTE_SIZE);
	for (i = 0; i < ins->nmodules; i++) {
		struct dsp_module_desc module = &ins->modules[i];
		struct dsp_segment_desc seg;
		u32 doffset, dsize;
		seg = get_segment_desc(module, SEGTYPE_SP_PARAMETER);
		err = dsp_load_parameter(chip, seg);
		if (err < 0)
			return err;
		seg = get_segment_desc(module, SEGTYPE_SP_SAMPLE);
		err = dsp_load_sample(chip, seg);
		if (err < 0)
			return err;
		seg = get_segment_desc(module, SEGTYPE_SP_PROGRAM);
		if (!seg)
			continue;
		doffset = seg->offset  4 + module->load_address  4
			+ DSP_CODE_BYTE_OFFSET;
		dsize   = seg->size  4;
		err = snd_cs46xx_download(chip,
					  ins->code.data + module->load_address,
					  doffset, dsize);
		if (err < 0)
			return err;
	}
	for (i = 0; i < ins->ntask; i++) {
		struct dsp_task_descriptor t = &ins->tasks[i];
		_dsp_create_task_tree(chip, t->data, t->address, t->size);
	}
	for (i = 0; i < ins->nscb; i++) {
		struct dsp_scb_descriptor s = &ins->scbs[i];
		if (s->deleted)
			continue;
		_dsp_create_scb(chip, s->data, s->address);
	}
	for (i = 0; i < ins->nscb; i++) {
		struct dsp_scb_descriptor s = &ins->scbs[i];
		if (s->deleted)
			continue;
		if (s->updated)
			cs46xx_dsp_spos_update_scb(chip, s);
		if (s->volume_set)
			cs46xx_dsp_scb_set_volume(chip, s,
						  s->volume[0], s->volume[1]);
	}
	if (ins->spdif_status_out & DSP_SPDIF_STATUS_HW_ENABLED) {
		cs46xx_dsp_enable_spdif_hw(chip);
		snd_cs46xx_poke(chip, (ins->ref_snoop_scb->address + 2) << 2,
				(OUTPUT_SNOOP_BUFFER + 0x10) << 0x10);
		if (ins->spdif_status_out & DSP_SPDIF_STATUS_PLAYBACK_OPEN)
			cs46xx_poke_via_dsp(chip, SP_SPDOUT_CSUV,
					    ins->spdif_csuv_stream);
	}
	if (chip->dsp_spos_instance->spdif_status_in) {
		cs46xx_poke_via_dsp(chip, SP_ASER_COUNTDOWN, 0x80000005);
		cs46xx_poke_via_dsp(chip, SP_SPDIN_CONTROL, 0x800003ff);
	}
	return 0;
}
#endif
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for audio on multifunction CS55356 companion device
  Copyright (C) Jaya Kumar
  Based on Jaroslav Kysela and Takashi Iwai's examples.
  This work was sponsored by CIS(M) Sdn Bhd.
 Not yet confirmed if all 5536 boards are HP only 
 set any OLPC-specific scaps 
 SPDX-License-Identifier: GPL-2.0-or-later
  OLPC XO-1 additional sound features
  Copyright  2006  Jaya Kumar <jayakumar.lkml@gmail.com>
  Copyright  2007-2008  Andres Salomon <dilinger@debian.org>
  OLPC has an additional feature on top of the regular AD1888 codec features.
  It has an Analog Input mode that is switched into (after disabling the
  High Pass Filter) via GPIO.  It is supported on B2 and later models.
 update the High Pass Filter (via AC97_AD_TEST2) 
 set Analog Input through GPIO 
  OLPC XO-1's V_REFOUT is a mic bias enable.
 invert EAPD if on an OLPC B3 or higher 
 drop the original AD1888 HPF control 
 drop the original V_REFOUT control 
 add the OLPC-specific controls 
 turn off the mic by default 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for audio on multifunction CS5535 companion device
  Copyright (C) Jaya Kumar
  Based on Jaroslav Kysela and Takashi Iwai's examples.
  This work was sponsored by CIS(M) Sdn Bhd.
  todo: add be fmt support, spdif, pm
	 the u32 cast is okay because in sndcreate we successfully told
 we reserved one dummy descriptor at the end to do the PRD jump 
 SPDX-License-Identifier: GPL-2.0-or-later
  Power management for audio on multifunction CS5535 companion device
  Copyright (C) Jaya Kumar
	 
	we depend on snd_ac97_suspend to tell the
	AC97 codec to shutdown. the amd spec suggests
	that the LNK_SHUTDOWN be done at the same time
	that the codec power-down is issued. instead,
	we do it just after rather than at the same 
	time. excluding codec specific build_ops->suspend
	ac97 powerdown hits:
	0x8000 EAPD 
	0x4000 Headphone amplifier 
	0x0300 ADC & DAC 
	0x0400 Analog Mixer powerdown (Vref on) 
	I am not sure if this is the best that we can do.
	The remainder to be investigated are:
	- analog mixer (vref off) 0x0800
	- AC-link powerdown 0x1000
	- codec internal clock 0x2000
 set LNK_SHUTDOWN to shutdown AC link 
 save important regs, then disable aclink in hw 
 set LNK_WRM_RST to reset AC link 
 set up rate regs, dma. actual initiation is done in trig 
 we depend on ac97 to perform the codec power up 
 SPDX-License-Identifier: GPL-2.0-or-later
   Driver for Trident 4DWave DXNX & SiS SI7018 Audio PCI soundcard
   Driver was originated by Trident <audio@tridentmicro.com>
   			     Fri Feb 19 15:55:28 MST 1999
 Index 0-MAX 
 ID for this card 
 Enable this card 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
   Copyright (c) by Takashi Iwai <tiwai@suse.de>
   Copyright (c) by Scott McNab <sdm@fractalgraphics.com.au>
   Trident 4DWave-NX memory page allocation (TLB area)
   Trident chip can handle only 16MByte of the memory at the same time.
 page arguments of these two macros are Trident page (4096 bytes), not like
  aligned pages in others
 page size == SNDRV_TRIDENT_PAGE_SIZE 
 minimum page size for allocation 
 maxmium aligned pages 
 fill TLB entrie(s) corresponding to page with ptr 
 fill TLB entrie(s) corresponding to page with silence pointer 
 get aligned page from offset address 
 get offset address from aligned page 
 get PCI physical address from aligned page 
 page size == SNDRV_TRIDENT_PAGE_SIZE x 2
 fill TLB entries -- we need to fill two entries 
 arbitrary size 
 Note: if alignment doesn't match to the maximum size, the last few blocks
  become unusable.  To use such blocks, you'll need to check the validity
  of accessing page in set_tlb_bus and set_silent_tlb.  search_empty()
  should also check it, too.
 fill TLB entries -- UNIT_PAGES entries must be filled 
 PAGE_SIZE 
 first and last (aligned) pages of memory block 
  search empty pages which may contain given size
 create a new memory block 
 set aligned offset 
  check if the given pointer is valid for pages
  page allocation for DMA (Scatter-Gather version)
 set TLB entries 
  page allocation for DMA (contiguous version)
 set TLB entries 
  page allocation for DMA
  release DMA buffer from page table
 reset TLB entries 
 free memory block 
 SPDX-License-Identifier: GPL-2.0-or-later
   Maintained by Jaroslav Kysela <perex@perex.cz>
   Originated by audio@tridentmicro.com
   Fri Feb 19 15:55:28 MST 1999
   Routines for control of Trident 4DWave (DX and NX) chip
   BUGS:
   TODO:
     ---
   SiS7018 SPDIF support by Thomas Winischhofer <thomas@winischhofer.net>
   common IO routines
 TRIDENT_DEVICE_ID_NX
---------------------------------------------------------------------------
   unsigned short snd_trident_codec_read(struct snd_ac97 ac97, unsigned short reg)
   Description: This routine will do all of the reading from the external
                CODEC (AC97).
   Parameters:  ac97 - ac97 codec structure
                reg - CODEC register index, from AC97 Hal.
   returns:     16 bit value read from the AC97.
---------------------------------------------------------------------------
   void snd_trident_codec_write(struct snd_ac97 ac97, unsigned short reg,
   unsigned short wdata)
   Description: This routine will do all of the writing to the external
                CODEC (AC97).
   Parameters:	ac97 - ac97 codec structure
   	        reg - CODEC register index, from AC97 Hal.
                data  - Lower 16 bits are the data to write to CODEC.
   returns:     TRUE if everything went ok, else FALSE.
 read AC-97 write register status 
 read AC-97 write register status 
 read AC-97 write register status 
 keep GCC happy 
 return 
---------------------------------------------------------------------------
   void snd_trident_enable_eso(struct snd_trident trident)
   Description: This routine will enable end of loop interrupts.
                End of loop interrupts will occur when a running
                channel reaches ESO.
                Also enables middle of loop interrupts.
   Parameters:  trident - pointer to target device class for 4DWave.
---------------------------------------------------------------------------
   void snd_trident_disable_eso(struct snd_trident trident)
   Description: This routine will disable end of loop interrupts.
                End of loop interrupts will occur when a running
                channel reaches ESO.
                Also disables middle of loop interrupts.
   Parameters:  
                trident - pointer to target device class for 4DWave.
   returns:     TRUE if everything went ok, else FALSE.
---------------------------------------------------------------------------
   void snd_trident_start_voice(struct snd_trident  trident, unsigned int voice)
    Description: Start a voice, any channel 0 thru 63.
                 This routine automatically handles the fact that there are
                 more than 32 channels available.
    Parameters : voice - Voice number 0 thru n.
                 trident - pointer to target device class for 4DWave.
    Return Value: None.
---------------------------------------------------------------------------
   void snd_trident_stop_voice(struct snd_trident  trident, unsigned int voice)
    Description: Stop a voice, any channel 0 thru 63.
                 This routine automatically handles the fact that there are
                 more than 32 channels available.
    Parameters : voice - Voice number 0 thru n.
                 trident - pointer to target device class for 4DWave.
    Return Value: None.
---------------------------------------------------------------------------
    int snd_trident_allocate_pcm_channel(struct snd_trident trident)
    Description: Allocate hardware channel in Bank B (32-63).
    Parameters :  trident - pointer to target device class for 4DWave.
    Return Value: hardware channel - 32-63 or -1 when no channel is available
---------------------------------------------------------------------------
    void snd_trident_free_pcm_channel(int channel)
    Description: Free hardware channel in Bank B (32-63)
    Parameters :  trident - pointer to target device class for 4DWave.
	          channel - hardware channel number 0-63
    Return Value: none
---------------------------------------------------------------------------
    unsigned int snd_trident_allocate_synth_channel(void)
    Description: Allocate hardware channel in Bank A (0-31).
    Parameters :  trident - pointer to target device class for 4DWave.
    Return Value: hardware channel - 0-31 or -1 when no channel is available
---------------------------------------------------------------------------
    void snd_trident_free_synth_channel( int channel )
    Description: Free hardware channel in Bank B (0-31).
    Parameters :  trident - pointer to target device class for 4DWave.
	          channel - hardware channel number 0-63
    Return Value: none
---------------------------------------------------------------------------
   snd_trident_write_voice_regs
   Description: This routine will complete and write the 5 hardware channel
                registers to hardware.
   Parameters:  trident - pointer to target device class for 4DWave.
                voice - synthesizer voice structure
                Each register field.
---------------------------------------------------------------------------
   snd_trident_write_cso_reg
   Description: This routine will write the new CSO offset
                register to hardware.
   Parameters:  trident - pointer to target device class for 4DWave.
                voice - synthesizer voice structure
                CSO - new CSO value
---------------------------------------------------------------------------
   snd_trident_write_eso_reg
   Description: This routine will write the new ESO offset
                register to hardware.
   Parameters:  trident - pointer to target device class for 4DWave.
                voice - synthesizer voice structure
                ESO - new ESO value
---------------------------------------------------------------------------
   snd_trident_write_vol_reg
   Description: This routine will write the new voice volume
                register to hardware.
   Parameters:  trident - pointer to target device class for 4DWave.
                voice - synthesizer voice structure
                Vol - new voice volume
 dev_dbg(trident->card->dev, "voice->Vol = 0x%x\n", voice->Vol); 
---------------------------------------------------------------------------
   snd_trident_write_pan_reg
   Description: This routine will write the new voice pan
                register to hardware.
   Parameters:  trident - pointer to target device class for 4DWave.
                voice - synthesizer voice structure
                Pan - new pan value
---------------------------------------------------------------------------
   snd_trident_write_rvol_reg
   Description: This routine will write the new reverb volume
                register to hardware.
   Parameters:  trident - pointer to target device class for 4DWave.
                voice - synthesizer voice structure
                RVol - new reverb volume
---------------------------------------------------------------------------
   snd_trident_write_cvol_reg
   Description: This routine will write the new chorus volume
                register to hardware.
   Parameters:  trident - pointer to target device class for 4DWave.
                voice - synthesizer voice structure
                CVol - new chorus volume
---------------------------------------------------------------------------
   snd_trident_convert_rate
   Description: This routine converts rate in HZ to hardware delta value.
   Parameters:  trident - pointer to target device class for 4DWave.
                rate - Real or Virtual channel number.
   Returns:     Delta value.
 We special case 44100 and 8000 since rounding with the equation
 does not give us an accurate enough value. For 11025 and 22050
 the equation gives us the best answer. All other frequencies will
 also use the equation. JDW
---------------------------------------------------------------------------
   snd_trident_convert_adc_rate
   Description: This routine converts rate in HZ to hardware delta value.
   Parameters:  trident - pointer to target device class for 4DWave.
                rate - Real or Virtual channel number.
   Returns:     Delta value.
 We special case 44100 and 8000 since rounding with the equation
 does not give us an accurate enough value. For 11025 and 22050
 the equation gives us the best answer. All other frequencies will
 also use the equation. JDW
---------------------------------------------------------------------------
   snd_trident_spurious_threshold
   Description: This routine converts rate in HZ to spurious threshold.
   Parameters:  trident - pointer to target device class for 4DWave.
                rate - Real or Virtual channel number.
   Returns:     Delta value.
---------------------------------------------------------------------------
   snd_trident_control_mode
   Description: This routine returns a control mode for a PCM channel.
   Parameters:  trident - pointer to target device class for 4DWave.
                substream  - PCM substream
   Returns:     Control value.
	 set ctrl mode
	   CTRL default: 8-bit (unsigned) mono, loop mode enabled
 16-bit data
 signed data
 stereo data
   PCM part
---------------------------------------------------------------------------
   snd_trident_allocate_pcm_mem
   Description: Allocate PCM ring buffer for given substream
   Parameters:  substream  - PCM substream class
		hw_params  - hardware parameters
   Returns:     Error status
---------------------------------------------------------------------------
   snd_trident_allocate_evoice
   Description: Allocate extra voice as interrupt generator
   Parameters:  substream  - PCM substream class
		hw_params  - hardware parameters
   Returns:     Error status
 voice management 
---------------------------------------------------------------------------
   snd_trident_hw_params
   Description: Set the hardware parameters for the playback device.
   Parameters:  substream  - PCM substream class
		hw_params  - hardware parameters
   Returns:     Error status
---------------------------------------------------------------------------
   snd_trident_playback_hw_free
   Description: Release the hardware resources for the playback device.
   Parameters:  substream  - PCM substream class
   Returns:     Error status
---------------------------------------------------------------------------
   snd_trident_playback_prepare
   Description: Prepare playback device for playback.
   Parameters:  substream  - PCM substream class
   Returns:     Error status
 set delta (rate) value 
 set Loop Begin Address 
 in samples 
 in samples 
 mute 
 mute 
 mute 
---------------------------------------------------------------------------
   snd_trident_capture_hw_params
   Description: Set the hardware parameters for the capture device.
   Parameters:  substream  - PCM substream class
		hw_params  - hardware parameters
   Returns:     Error status
---------------------------------------------------------------------------
   snd_trident_capture_prepare
   Description: Prepare capture device for playback.
   Parameters:  substream  - PCM substream class
   Returns:     Error status
 Initialize the channel and set channel Mode
 Set DMA channel operation mode register
 Set channel buffer Address, DMAR0 expects contiguous PCI memory area	
 set ESO
 Set channel sample rate, 4.12 format
 Set channel interrupt blk length
 Right now, set format and start to run captureing, 
 continuous run loop enable.
 0001 1001b
 Prepare capture intr channel
 Set voice parameters
 mute 
 mute 
---------------------------------------------------------------------------
   snd_trident_si7018_capture_hw_params
   Description: Set the hardware parameters for the capture device.
   Parameters:  substream  - PCM substream class
		hw_params  - hardware parameters
   Returns:     Error status
---------------------------------------------------------------------------
   snd_trident_si7018_capture_hw_free
   Description: Release the hardware resources for the capture device.
   Parameters:  substream  - PCM substream class
   Returns:     Error status
---------------------------------------------------------------------------
   snd_trident_si7018_capture_prepare
   Description: Prepare capture device for playback.
   Parameters:  substream  - PCM substream class
   Returns:     Error status
 Set voice parameters
 in samples 
 in samples, 20 means correction 
 mute 
 mute 
 mute 
---------------------------------------------------------------------------
   snd_trident_foldback_prepare
   Description: Prepare foldback capture device for playback.
   Parameters:  substream  - PCM substream class
   Returns:     Error status
 Set channel buffer Address 
 set target ESO for channel 
 in samples 
 set sample rate 
 mute 
 mute 
 set up capture channel 
 in samples 
 mute 
 mute 
 mute 
---------------------------------------------------------------------------
   snd_trident_spdif_hw_params
   Description: Set the hardware parameters for the spdif device.
   Parameters:  substream  - PCM substream class
		hw_params  - hardware parameters
   Returns:     Error status
 prepare SPDIF channel 
 48000 Hz
 44100 Hz
 32000 Hz
---------------------------------------------------------------------------
   snd_trident_spdif_prepare
   Description: Prepare SPDIF device for playback.
   Parameters:  substream  - PCM substream class
   Returns:     Error status
 set delta (rate) value 
 set Loop Back Address 
 set target ESO for channel 
 set ctrl mode 
 prepare surrogate IRQ channel 
 set SPDIF setting 
 SiS 
 set delta (rate) value 
 set Loop Begin Address 
 in samples 
 in samples 
 mute 
 mute 
 mute 
---------------------------------------------------------------------------
   snd_trident_trigger
   Description: Startstop devices
   Parameters:  substream  - PCM substream class
   		cmd	- trigger command (STOP, GO)
   Returns:     Error status
---------------------------------------------------------------------------
   snd_trident_playback_pointer
   Description: This routine return the playback position
   Parameters:	substream  - PCM substream class
   Returns:     position of buffer
 ID_4DWAVE_NX
---------------------------------------------------------------------------
   snd_trident_capture_pointer
   Description: This routine return the capture position
   Parameters:   pcm1    - PCM device class
   Returns:     position of buffer
---------------------------------------------------------------------------
   snd_trident_spdif_pointer
   Description: This routine return the SPDIF playback position
   Parameters:	substream  - PCM substream class
   Returns:     position of buffer
   Playback support device description
 | SNDRV_PCM_INFO_RESUME ),
   Capture support device description
 | SNDRV_PCM_INFO_RESUME ),
   Foldback capture support device description
 | SNDRV_PCM_INFO_RESUME ),
   SPDIF playback support device description
 | SNDRV_PCM_INFO_RESUME ),
 | SNDRV_PCM_INFO_RESUME ),
---------------------------------------------------------------------------
   snd_trident_playback_close
   Description: This routine will close the 4DWave playback device. For now 
                we will simply free the dma transfer buffer.
   Parameters:	substream  - PCM substream class
---------------------------------------------------------------------------
   snd_trident_spdif_open
   Description: This routine will open the 4DWave SPDIF device.
   Parameters:	substream  - PCM substream class
   Returns:     status  - success or failure flag
---------------------------------------------------------------------------
   snd_trident_spdif_close
   Description: This routine will close the 4DWave SPDIF device.
   Parameters:	substream  - PCM substream class
 restore default SPDIF setting
---------------------------------------------------------------------------
   snd_trident_capture_open
   Description: This routine will open the 4DWave capture device.
   Parameters:	substream  - PCM substream class
   Returns:     status  - success or failure flag
---------------------------------------------------------------------------
   snd_trident_capture_close
   Description: This routine will close the 4DWave capture device. For now 
                we will simply free the dma transfer buffer.
   Parameters:	substream  - PCM substream class
---------------------------------------------------------------------------
   snd_trident_foldback_open
   Description: This routine will open the 4DWave foldback capture device.
   Parameters:	substream  - PCM substream class
   Returns:     status  - success or failure flag
---------------------------------------------------------------------------
   snd_trident_foldback_close
   Description: This routine will close the 4DWave foldback capture device. 
		For now we will simply free the dma transfer buffer.
   Parameters:	substream  - PCM substream class
 stop capture channel 
---------------------------------------------------------------------------
   PCM operations
---------------------------------------------------------------------------
   snd_trident_pcm
   Description: This routine registers the 4DWave device for PCM support.
   Parameters:  trident - pointer to target device class for 4DWave.
   Returns:     None
---------------------------------------------------------------------------
   snd_trident_foldback_pcm
   Description: This routine registers the 4DWave device for foldback PCM support.
   Parameters:  trident - pointer to target device class for 4DWave.
   Returns:     None
---------------------------------------------------------------------------
   snd_trident_spdif
   Description: This routine registers the 4DWave-NX device for SPDIF support.
   Parameters:  trident - pointer to target device class for 4DWave-NX.
   Returns:     None
   Mixer part
---------------------------------------------------------------------------
    snd_trident_spdif_control
    Description: enabledisable SPDIF out from ac97 mixer
 SPDIF C Channel bits 0-31 : 48khz, SCMS disabled 
---------------------------------------------------------------------------
    snd_trident_spdif_default
    Description: putget the SPDIF default settings
---------------------------------------------------------------------------
    snd_trident_spdif_mask
    Description: putget the SPDIF mask
---------------------------------------------------------------------------
    snd_trident_spdif_stream
    Description: putget the SPDIF stream settings
---------------------------------------------------------------------------
    snd_trident_ac97_control
    Description: enabledisable rear path for ac97
---------------------------------------------------------------------------
    snd_trident_vol_control
    Description: wave & music volume control
---------------------------------------------------------------------------
    snd_trident_pcm_vol_control
    Description: PCM front volume control
 FIXME: no tlv yet 
---------------------------------------------------------------------------
    snd_trident_pcm_pan_control
    Description: PCM front pan control
---------------------------------------------------------------------------
    snd_trident_pcm_rvol_control
    Description: PCM reverb volume control
---------------------------------------------------------------------------
    snd_trident_pcm_cvol_control
    Description: PCM chorus volume control
---------------------------------------------------------------------------
   snd_trident_mixer
   Description: This routine registers the 4DWave device for mixer support.
   Parameters:  trident - pointer to target device class for 4DWave.
   Returns:     None
 secondary codec? 
 only for my testing purpose --jk
  gameport interface
 CONFIG_GAMEPORT 
  delay for 1 tick
   SiS reset routine
 count of retries 
 SOFTWARE RESET 
 disable AC97 GPIO interrupt 
 initialize serial interface, force cold reset 
 remove cold reset 
 wait, until the codec is ready 
 wait for the second codec 
 enable 64 channel mode 
   proc interface
---------------------------------------------------------------------------
   snd_trident_tlb_alloc
   Description: Allocate and set up the TLB page table on 4D NX.
		Each entry has 4 bytes (physical PCI address).
   Parameters:  trident - pointer to target device class for 4DWave.
   Returns:     0 or negative error code
	 TLB array must be aligned to 16kB !!! so we allocate
 allocate and setup silent page and initialise TLB entries 
 use emu memory block manager code to manage tlb page allocation 
  initialize 4D DX chip
 reset the legacy configuration and whole audiowavetable block 
 DDMA 
 ports 
 Legacy DMA 
 reset 
 release reset 
 warm reset of the AC'97 codec 
 DAC on, disable SB IRQ and try to force ADC valid signal 
 wait, until the codec is ready 
  initialize 4D NX chip
 reset the legacy configuration and whole audiowavetable block 
 DDMA 
 ports 
 Legacy DMA 
 reset 
 release reset 
 warm reset of the AC'97 codec 
 wait, until the codec is ready 
 DAC on 
 disable SB IRQ 
 enable virtual addressing via TLB 
 initialize SPDIF 
  initialize sis7018 chip
 initialize SPDIF 
---------------------------------------------------------------------------
   snd_trident_create
   Description: This routine will create the device specific class for
                the 4DWave card. It will also perform basic initialization.
   Parameters:  card  - which card to create
                pci   - interface to PCI bus resource info
                dma1ptr - playback dma buffer
                dma2ptr - capture dma buffer
                irqptr  -  interrupt resource info
   Returns:     4DWave device class private data
 enable PCI device 
 check, if we can restrict PCI DMA transfers to 30 bits 
 allocate 16k-aligned TLB for NX cards 
 initialize chip 
 initialise synth voices 
 initialize pcm mixer entries 
---------------------------------------------------------------------------
   snd_trident_free
   Description: This routine will free the device specific class for
                the 4DWave card. 
   Parameters:  card - card to release
   Returns:     None.
 Disable SPDIF out
---------------------------------------------------------------------------
   snd_trident_interrupt
   Description: ISR for Trident 4DWave device
   Parameters:  trident  - device specific private data for 4DWave card
   Problems:    It seems that Trident chips generates interrupts more than
                one time in special cases. The spurious interrupts are
                detected via sample timer (T4D_STIMER) and computing
                corresponding delta value. The limits are detected with
                the method try & fail so it is possible that it won't
                work on all computers. [jaroslav]
   Returns:     None.
 get interrupt status for all channels
 ack 
 do some statistics here 
 update ESO for IRQ voice to preserve sync 
 write original ESO and update CSO for IRQ voice to preserve sync 
 update CSO for extra voice to preserve sync 
 ack 
 outl((ST_TARGET_REACHED | MIXER_OVERFLOW | MIXER_UNDERFLOW), TRID_REG(trident, T4D_MISCINT));
 restore some registers 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0-or-later
             au88x0_a3d.c
   Fri Jul 18 14:16:22 2003
   Copyright  2003  mjander
   mjander@users.sourceforge.net
  A3D. You may think i'm crazy, but this may work someday. Who knows...
 stub!
 Atmospheric absorption. 
 HRTF 
 FIXME: verify this!
 Interaural Time Difference. 
  "The other main clue that humans use to locate sounds, is called 
  Interaural Time Difference (ITD). The differences in distance from 
  the sound source to a listeners ears means  that the sound will 
hwwrite(vortex->mmio, addr(0x191DF+5, this04, this08), (ritd<<0x10)|litd);
hwwrite(vortex->mmio, addr(0x191DF+1, this04, this08), (ritd<<0x10)|litd);
 45 != 40 -> Check this ! 
 This is may be used for ILD Interaural Level Difference. 
 CA3dIO this func seems to be inlined all over this place. 
 Generic A3D stuff 
hwwrite(vortex->mmio, 0x19C38 + (this08<<0xd), esp0);
hwwrite(vortex->mmio, 0x19C38 + (this08<<0xd), 0xF0000001);
	sr = ((hwread(vortex->mmio, 0x19C38 + (this08<<0xd))>>3)&0x1f);
}
static void a3dsrc_GetA3DControlReg(a3dsrc_t  a, unsigned long ctrl)
{
	vortex_t vortex = (vortex_t ) (a->vortex);
	ctrl = hwread(vortex->mmio, A3D_SLICE_Control + ((a->slice) << 0xd));
}
static void a3dsrc_GetA3DPointerReg(a3dsrc_t  a, unsigned long ptr)
{
	vortex_t vortex = (vortex_t ) (a->vortex);
	ptr = hwread(vortex->mmio, A3D_SLICE_Pointers + ((a->slice) << 0xd));
}
#endif
static void a3dsrc_ZeroSliceIO(a3dsrc_t  a)
{
	vortex_t vortex = (vortex_t ) (a->vortex);
	int i;
	for (i = 0; i < 8; i++)
		hwwrite(vortex->mmio,
			A3D_SLICE_VDBDest +
			((((a->slice) << 0xb) + i) << 2), 0);
	for (i = 0; i < 4; i++)
		hwwrite(vortex->mmio,
			A3D_SLICE_VDBSource +
			((((a->slice) << 0xb) + i) << 2), 0);
}
 Reset Single A3D source. 
static void a3dsrc_ZeroState(a3dsrc_t  a)
{
	
	a3dsrc_SetAtmosState(a, 0, 0, 0, 0);
	a3dsrc_SetHrtfState(a, A3dHrirZeros, A3dHrirZeros);
	a3dsrc_SetItdDline(a, A3dItdDlineZeros);
	a3dsrc_SetHrtfOutput(a, 0, 0);
	a3dsrc_SetTimeConsts(a, 0, 0, 0, 0);
	a3dsrc_SetAtmosCurrent(a, 0, 0, 0, 0, 0);
	a3dsrc_SetAtmosTarget(a, 0, 0, 0, 0, 0);
	a3dsrc_SetItdCurrent(a, 0, 0);
	a3dsrc_SetItdTarget(a, 0, 0);
	a3dsrc_SetGainCurrent(a, 0, 0);
	a3dsrc_SetGainTarget(a, 0, 0);
	a3dsrc_SetHrtfCurrent(a, A3dHrirZeros, A3dHrirZeros);
	a3dsrc_SetHrtfTarget(a, A3dHrirZeros, A3dHrirZeros);
}
 Reset entire A3D engine 
static void a3dsrc_ZeroStateA3D(a3dsrc_t a, vortex_t v)
{
	int i, var, var2;
	if ((a->vortex) == NULL) {
		dev_err(v->card->dev,
			"ZeroStateA3D: ERROR: a->vortex is NULL\n");
		return;
	}
	a3dsrc_SetA3DControlReg(a, 0);
	a3dsrc_SetA3DPointerReg(a, 0);
	var = a->slice;
	var2 = a->source;
	for (i = 0; i < 4; i++) {
		a->slice = i;
		a3dsrc_ZeroSliceIO(a);
		a3dsrc_ZeroState(a);
	}
	a->source = var2;
	a->slice = var;
}
 Program A3D block as pass through 
static void a3dsrc_ProgramPipe(a3dsrc_t  a)
{
	a3dsrc_SetTimeConsts(a, 0, 0, 0, 0);
	a3dsrc_SetAtmosCurrent(a, 0, 0x4000, 0, 0, 0);
	a3dsrc_SetAtmosTarget(a, 0x4000, 0, 0, 0, 0);
	a3dsrc_SetItdCurrent(a, 0, 0);
	a3dsrc_SetItdTarget(a, 0, 0);
	a3dsrc_SetGainCurrent(a, 0x7fff, 0x7fff);
	a3dsrc_SetGainTarget(a, 0x7fff, 0x7fff);
	 SET HRTF HERE 
	 Single spike leads to identity transfer function. 
	a3dsrc_SetHrtfCurrent(a, A3dHrirImpulse, A3dHrirImpulse);
	a3dsrc_SetHrtfTarget(a, A3dHrirImpulse, A3dHrirImpulse);
	 Test: Sounds saturated. 
	a3dsrc_SetHrtfCurrent(a, A3dHrirSatTest, A3dHrirSatTest);
	a3dsrc_SetHrtfTarget(a, A3dHrirSatTest, A3dHrirSatTest);      
}
 VDB = Vortex audio Dataflow Bus 
#if 0
static void a3dsrc_ClearVDBData(a3dsrc_t  a, unsigned long aa)
{
	vortex_t vortex = (vortex_t ) (a->vortex);
	 ((aa >> 2) << 8) - (aa >> 2)
	hwwrite(vortex->mmio,
		a3d_addrS(a->slice, A3D_SLICE_VDBDest) + (a->source << 2), 0);
	hwwrite(vortex->mmio,
		a3d_addrS(a->slice,
			  A3D_SLICE_VDBDest + 4) + (a->source << 2), 0);
	 
}
#endif
 A3D HwSource stuff. 
static void vortex_A3dSourceHw_Initialize(vortex_t  v, int source, int slice)
{
	a3dsrc_t a3dsrc = &(v->a3d[source + (slice  4)]);
	a3dsrc_t a3dsrc = &(v->a3d[source + (slice4)]);
	a3dsrc->vortex = (void )v;
	a3dsrc->source = source;	 source 
	a3dsrc->slice = slice;	 slice 
	a3dsrc_ZeroState(a3dsrc);
	 Added by me. 
	a3dsrc_SetA3DSampleRate(a3dsrc, 0x11);
}
static int Vort3DRend_Initialize(vortex_t  v, unsigned short mode)
{
	v->xt_mode = mode;	 this_14 
	vortex_XtalkHw_init(v);
	vortex_XtalkHw_SetGainsAllChan(v);
	switch (v->xt_mode) {
	case XT_SPEAKER0:
		vortex_XtalkHw_ProgramXtalkNarrow(v);
		break;
	case XT_SPEAKER1:
		vortex_XtalkHw_ProgramXtalkWide(v);
		break;
	default:
	case XT_HEADPHONE:
		vortex_XtalkHw_ProgramPipe(v);
		break;
	case XT_DIAMOND:
		vortex_XtalkHw_ProgramDiamondXtalk(v);
		break;
	}
	vortex_XtalkHw_SetSampleRate(v, 0x11);
	vortex_XtalkHw_Enable(v);
	return 0;
}
 3D Sound entry points. 
static int vortex_a3d_register_controls(vortex_t  vortex);
static void vortex_a3d_unregister_controls(vortex_t  vortex);
 A3D base support initshudown 
static void vortex_Vort3D_enable(vortex_t v)
{
	int i;
	Vort3DRend_Initialize(v, XT_HEADPHONE);
	for (i = 0; i < NR_A3D; i++) {
		vortex_A3dSourceHw_Initialize(v, i % 4, i >> 2);
		a3dsrc_ZeroStateA3D(&v->a3d[0], v);
	}
	 Register ALSA controls 
	vortex_a3d_register_controls(v);
}
static void vortex_Vort3D_disable(vortex_t  v)
{
	vortex_XtalkHw_Disable(v);
	vortex_a3d_unregister_controls(v);
}
 Make A3D subsystem connections. 
static void vortex_Vort3D_connect(vortex_t  v, int en)
{
	int i;
	
 Disable AU8810 routes, since they seem to be wrong (in au8810.h).
#ifdef CHIP_AU8810
	return;
#endif
	
#if 1
	 Alloc Xtalk mixin resources 
	v->mixxtlk[0] =
	    vortex_adb_checkinout(v, v->fixed_res, en, VORTEX_RESOURCE_MIXIN);
	if (v->mixxtlk[0] < 0) {
		dev_warn(v->card->dev,
			 "vortex_Vort3D: ERROR: not enough free mixer resources.\n");
		return;
	}
	v->mixxtlk[1] =
	    vortex_adb_checkinout(v, v->fixed_res, en, VORTEX_RESOURCE_MIXIN);
	if (v->mixxtlk[1] < 0) {
		dev_warn(v->card->dev,
			 "vortex_Vort3D: ERROR: not enough free mixer resources.\n");
		return;
	}
#endif
	 Connect A3D -> XTALK 
	for (i = 0; i < 4; i++) {
		 2 outputs per each A3D slice. 
		vortex_route(v, en, 0x11, ADB_A3DOUT(i  2), ADB_XTALKIN(i));
		vortex_route(v, en, 0x11, ADB_A3DOUT(i  2) + 1, ADB_XTALKIN(5 + i));
	}
#if 0
	vortex_route(v, en, 0x11, ADB_XTALKOUT(0), ADB_EQIN(2));
	vortex_route(v, en, 0x11, ADB_XTALKOUT(1), ADB_EQIN(3));
#else
	 Connect XTalk -> mixer 
	vortex_route(v, en, 0x11, ADB_XTALKOUT(0), ADB_MIXIN(v->mixxtlk[0]));
	vortex_route(v, en, 0x11, ADB_XTALKOUT(1), ADB_MIXIN(v->mixxtlk[1]));
	vortex_connection_mixin_mix(v, en, v->mixxtlk[0], v->mixplayb[0], 0);
	vortex_connection_mixin_mix(v, en, v->mixxtlk[1], v->mixplayb[1], 0);
	vortex_mix_setinputvolumebyte(v, v->mixplayb[0], v->mixxtlk[0],
				      en ? MIX_DEFIGAIN : VOL_MIN);
	vortex_mix_setinputvolumebyte(v, v->mixplayb[1], v->mixxtlk[1],
				      en ? MIX_DEFIGAIN : VOL_MIN);
	if (VORTEX_IS_QUAD(v)) {
		vortex_connection_mixin_mix(v, en, v->mixxtlk[0],
					    v->mixplayb[2], 0);
		vortex_connection_mixin_mix(v, en, v->mixxtlk[1],
					    v->mixplayb[3], 0);
		vortex_mix_setinputvolumebyte(v, v->mixplayb[2],
					      v->mixxtlk[0],
					      en ? MIX_DEFIGAIN : VOL_MIN);
		vortex_mix_setinputvolumebyte(v, v->mixplayb[3],
					      v->mixxtlk[1],
					      en ? MIX_DEFIGAIN : VOL_MIN);
	}
#endif
}
 Initialize one single A3D source. 
static void vortex_Vort3D_InitializeSource(a3dsrc_t a, int en, vortex_t v)
{
	if (a->vortex == NULL) {
		dev_warn(v->card->dev,
			 "Vort3D_InitializeSource: A3D source not initialized\n");
		return;
	}
	if (en) {
		a3dsrc_ProgramPipe(a);
		a3dsrc_SetA3DSampleRate(a, 0x11);
		a3dsrc_SetTimeConsts(a, HrtfTCDefault,
				     ItdTCDefault, GainTCDefault,
				     CoefTCDefault);
		 Remark: zero gain is muted. 
		a3dsrc_SetGainTarget(a,0,0);
		a3dsrc_SetGainCurrent(a,0,0);
		a3dsrc_EnableA3D(a);
	} else {
		a3dsrc_DisableA3D(a);
		a3dsrc_ZeroState(a);
	}
}
 Conversion of coordinates into 3D parameters. 
static void vortex_a3d_coord2hrtf(a3d_Hrtf_t hrtf, int coord)
{
	 FIXME: implement this. 
}
static void vortex_a3d_coord2itd(a3d_Itd_t itd, int coord)
{
	 FIXME: implement this. 
}
static void vortex_a3d_coord2ild(a3d_LRGains_t ild, int left, int right)
{
	 FIXME: implement this. 
}
static void vortex_a3d_translate_filter(a3d_atmos_t filter, int params)
{
	 FIXME: implement this. 
}
 ALSA control interface.  
static int
snd_vortex_a3d_hrtf_info(struct snd_kcontrol kcontrol, struct snd_ctl_elem_info uinfo)
{
	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
	uinfo->count = 6;
	uinfo->value.integer.min = 0x00000000;
	uinfo->value.integer.max = 0xffffffff;
	return 0;
}
static int
snd_vortex_a3d_itd_info(struct snd_kcontrol kcontrol, struct snd_ctl_elem_info uinfo)
{
	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
	uinfo->count = 2;
	uinfo->value.integer.min = 0x00000000;
	uinfo->value.integer.max = 0xffffffff;
	return 0;
}
static int
snd_vortex_a3d_ild_info(struct snd_kcontrol kcontrol, struct snd_ctl_elem_info uinfo)
{
	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
	uinfo->count = 2;
	uinfo->value.integer.min = 0x00000000;
	uinfo->value.integer.max = 0xffffffff;
	return 0;
}
static int
snd_vortex_a3d_filter_info(struct snd_kcontrol kcontrol,
			   struct snd_ctl_elem_info uinfo)
{
	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
	uinfo->count = 4;
	uinfo->value.integer.min = 0x00000000;
	uinfo->value.integer.max = 0xffffffff;
	return 0;
}
static int
snd_vortex_a3d_get(struct snd_kcontrol kcontrol, struct snd_ctl_elem_value ucontrol)
{
	a3dsrc_t a = kcontrol->private_data;
	 No read yet. Would this be really useableneeded ? 
	return 0;
}
static int
snd_vortex_a3d_hrtf_put(struct snd_kcontrol kcontrol,
			struct snd_ctl_elem_value ucontrol)
{
	a3dsrc_t a = kcontrol->private_data;
	int i;
	int coord[6];
	for (i = 0; i < 6; i++)
		coord[i] = ucontrol->value.integer.value[i];
	 Translate orientation coordinates to a3d params. 
	vortex_a3d_coord2hrtf(a->hrtf[0], coord);
	vortex_a3d_coord2hrtf(a->hrtf[1], coord);
	a3dsrc_SetHrtfTarget(a, a->hrtf[0], a->hrtf[1]);
	a3dsrc_SetHrtfCurrent(a, a->hrtf[0], a->hrtf[1]);
	return 1;
}
static int
snd_vortex_a3d_itd_put(struct snd_kcontrol kcontrol,
		       struct snd_ctl_elem_value ucontrol)
{
	a3dsrc_t a = kcontrol->private_data;
	int coord[6];
	int i;
	for (i = 0; i < 6; i++)
		coord[i] = ucontrol->value.integer.value[i];
	 Translate orientation coordinates to a3d params. 
	vortex_a3d_coord2itd(a->hrtf[0], coord);
	vortex_a3d_coord2itd(a->hrtf[1], coord);
	 Inter aural time difference. 
	a3dsrc_SetItdTarget(a, a->itd[0], a->itd[1]);
	a3dsrc_SetItdCurrent(a, a->itd[0], a->itd[1]);
	a3dsrc_SetItdDline(a, a->dline);
	return 1;
}
static int
snd_vortex_a3d_ild_put(struct snd_kcontrol kcontrol,
		       struct snd_ctl_elem_value ucontrol)
{
	a3dsrc_t a = kcontrol->private_data;
	int l, r;
	 There may be some scale tranlation needed here. 
	l = ucontrol->value.integer.value[0];
	r = ucontrol->value.integer.value[1];
	vortex_a3d_coord2ild(a->ild, l, r);
	 Left Right panning. 
	a3dsrc_SetGainTarget(a, l, r);
	a3dsrc_SetGainCurrent(a, l, r);
	return 1;
}
static int
snd_vortex_a3d_filter_put(struct snd_kcontrol kcontrol,
			  struct snd_ctl_elem_value ucontrol)
{
	a3dsrc_t a = kcontrol->private_data;
	int i;
	int params[6];
	for (i = 0; i < 6; i++)
		params[i] = ucontrol->value.integer.value[i];
	 Translate generic filter params to a3d filter params. 
	vortex_a3d_translate_filter(a->filter, params);
	 Atmospheric absorption and filtering. 
	a3dsrc_SetAtmosTarget(a, a->filter[0],
			      a->filter[1], a->filter[2],
			      a->filter[3], a->filter[4]);
	a3dsrc_SetAtmosCurrent(a, a->filter[0],
			       a->filter[1], a->filter[2],
			       a->filter[3], a->filter[4]);
	return 1;
}
static const struct snd_kcontrol_new vortex_a3d_kcontrol = {
	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
	.name = "Playback PCM advanced processing",
	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
	.info = snd_vortex_a3d_hrtf_info,
	.get = snd_vortex_a3d_get,
	.put = snd_vortex_a3d_hrtf_put,
};
 Control (un)registration. 
static int vortex_a3d_register_controls(vortex_t vortex)
{
	struct snd_kcontrol kcontrol;
	int err, i;
	 HRTF controls. 
	for (i = 0; i < NR_A3D; i++) {
		kcontrol = snd_ctl_new1(&vortex_a3d_kcontrol, &vortex->a3d[i]);
		if (!kcontrol)
			return -ENOMEM;
		kcontrol->id.numid = CTRLID_HRTF;
		kcontrol->info = snd_vortex_a3d_hrtf_info;
		kcontrol->put = snd_vortex_a3d_hrtf_put;
		err = snd_ctl_add(vortex->card, kcontrol);
		if (err < 0)
			return err;
	}
	 ITD controls. 
	for (i = 0; i < NR_A3D; i++) {
		kcontrol = snd_ctl_new1(&vortex_a3d_kcontrol, &vortex->a3d[i]);
		if (!kcontrol)
			return -ENOMEM;
		kcontrol->id.numid = CTRLID_ITD;
		kcontrol->info = snd_vortex_a3d_itd_info;
		kcontrol->put = snd_vortex_a3d_itd_put;
		err = snd_ctl_add(vortex->card, kcontrol);
		if (err < 0)
			return err;
	}
	 ILD (gains) controls. 
	for (i = 0; i < NR_A3D; i++) {
		kcontrol = snd_ctl_new1(&vortex_a3d_kcontrol, &vortex->a3d[i]);
		if (!kcontrol)
			return -ENOMEM;
		kcontrol->id.numid = CTRLID_GAINS;
		kcontrol->info = snd_vortex_a3d_ild_info;
		kcontrol->put = snd_vortex_a3d_ild_put;
		err = snd_ctl_add(vortex->card, kcontrol);
		if (err < 0)
			return err;
	}
	 Filter controls. 
	for (i = 0; i < NR_A3D; i++) {
		kcontrol = snd_ctl_new1(&vortex_a3d_kcontrol, &vortex->a3d[i]);
		if (!kcontrol)
			return -ENOMEM;
		kcontrol->id.numid = CTRLID_FILTER;
		kcontrol->info = snd_vortex_a3d_filter_info;
		kcontrol->put = snd_vortex_a3d_filter_put;
		err = snd_ctl_add(vortex->card, kcontrol);
		if (err < 0)
			return err;
	}
	return 0;
}
static void vortex_a3d_unregister_controls(vortex_t  vortex)
{
}
 End of File
 SPDX-License-Identifier: GPL-2.0-or-later
             au88x0_a3ddata.c
   Wed Nov 19 21:11:32 2003
   Copyright  2003  mjander
   mjander@users.sourceforge.org
 Constant initializer values. 
 SPDX-License-Identifier: GPL-2.0
 Data structs 
 More coef sets can be found in the win2k "inf" file. 
 _rodatab60 
 _rodatab7c:  ProgramPipe 
 _rodatab78 
_rodataba0:
 SPDX-License-Identifier: GPL-2.0
  Vortex Mixer support.
  There is much more than just the AC97 mixer...
 Initialize AC97 codec stuff.
 SPDX-License-Identifier: GPL-2.0-or-later
             au88x0_eq.c
   Aureal Vortex Hardware EQ controlaccess.
   Sun Jun  8 18:19:19 2003
   2003  Manuel Jander (mjander@users.sourceforge.net)
   02 July 2003: First time something works :)
   November 2003: A3D Bypass code completed but untested.
   TODO:
      - Debug (testing)
      - Test peak visualization support.
 The Aureal Hardware EQ is found on AU8810 and AU8830 chips only.
 it has 4 inputs (2 for general mix, 2 for A3D) and 2 outputs (supposed 
 to be routed to the codec).
 CEqHw.s 
 -(-32768) -> -32768 so we do -(-32768) -> 32767 to make the result positive 
esp2c ;
esp2c ;
 Mix Gains 
 EQ band levels settings 
 set left peaks 
 set right peaks 
 Global Control 
 Reset (zero) buffers 
vortex_EqHw_SetCurrBypassGain(vortex, 0, 0);
vortex_EqHw_SetCurrA3DBypassGain(vortex, 0, 0);
 Program coeficients as pass through 
 Program EQ block as 10 band Equalizer 
 Read all EQ peaks. (think VU meter) 
 CEqlzr.s 
 EQ enabled 
 EQ disabled. 
 Set EQ BiQuad filter coeficients 
 Set EQ Band gain levels and dump into hardware registers. 
 Object constructor 
eq->this04 = 0;
 Bypass gain with EQ in use. 
 Bypass gain with EQ disabled. 
 10 eq frequency bands. 
 if 1 => Allow read access to this130 (gains) 
 if 1 => Dont Allow access to hardware (gains) 
 Set gains. 
 Actual init. 
 ALSA interface 
 Control interface 
int i = kcontrol->private_value;
int i = kcontrol->private_value;
 Allways changes 
 EQ band gain labels. 
 ALSA driver entry points. Init and exit. 
 EQ gain controls 
vortex->eqctrl[i] = kcontrol;
 EQ band levels 
	
	   FIXME: segfault because vortex->eqctrl[i] == 4
	   int i;
	   for (i=0; i<10; i++) {
	   if (vortex->eqctrl[i])
	   snd_ctl_remove(vortex->card, vortex->eqctrl[i]);
	   }
 End 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-or-later
   Manuel Jander.
   Based on the work of:
   Vojtech Pavlik
   Raymond Ingles
  Should you need to contact me, the author, you can do so either by
  e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
  Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
  Based 90% on Vojtech Pavlik pcigame driver.
  Merged and modified by Manuel Jander, for the OpenVortex
  driver. (email: mjander@embedded.cl).
 20 ms 
 SPDX-License-Identifier: GPL-2.0-or-later
  Vortex PCM ALSA driver.
  Supports ADB and WT DMA. Unfortunately, WT channels do not run yet.
  It remains stuck,and DMA transfers do not happen. 
 hardware definition 
 SNDRV_PCM_INFO_RESUME | 
 SNDRV_PCM_INFO_RESUME | 
 SNDRV_PCM_INFO_RESUME | 
 SNDRV_PCM_RATE_48000,
 open callback 
 Force equal size periods 
 Avoid PAGE_SIZE boundary to fall inside of a period. 
 close callback 
vortex_t chip = snd_pcm_substream_chip(substream);
 the hardware-specific codes will be here
 hw_params callback 
	
	   pr_info( "Vortex: periods %d, period_bytes %d, channels = %d\n", params_periods(hw_params),
	   params_period_bytes(hw_params), params_channels(hw_params));
 Make audio routes and config buffer DMA.
 Dealloc any routes. 
 Alloc routes. 
 Setup Buffers. 
		 if (stream != NULL)
 hw_free callback 
 Delete audio routes.
 prepare callback 
 set up the hardware with the current configuration.
 FIXME: Set rate (i guess using vortex_wt_writereg() somehow).
 trigger callback 
 do something to start the PCM engine
printk(KERN_INFO "vortex: start %d\n", dma);
 do something to stop the PCM engine
printk(KERN_INFO "vortex: stop %d\n", dma);
printk(KERN_INFO "vortex: pause %d\n", dma);
printk(KERN_INFO "vortex: resume %d\n", dma);
 pointer callback 
printk(KERN_INFO "vortex: pointer = 0x%x\n", current_ptr);
 operators 
  definitions of capture are omitted here...
 SPDIF kcontrol 
 spdif controls 
 subdevice PCM Volume control 
 create a pcm device 
	 idx indicates which kind of PCM device. ADB, SPDIF, I2S and A3D share the 
 This is an evil hack, but it saves a lot of duplicated code.
 set operators 
 pre-allocation of Scatter-Gather buffers 
 SPDX-License-Identifier: GPL-2.0-or-later
  Someday its supposed to make use of the WT DMA engine
  for a Wavetable synthesizer.
 WT 
 Put 2 WT channels together for one stereo interlaced channel. 
temp = hwread(vortex->mmio, 0x80 + ((wt >> 0x5)<< 0xf) + (((wt & 0x1f) >> 1) << 2));
hwwrite(vortex->mmio, 0x80 + ((wt >> 0x5)<< 0xf) + (((wt & 0x1f) >> 1) << 2), temp);
 Join to mixdown route. 
 There is one DSREG register for each bank (32 voices each). 
 Setup WT route. 
FIXME: WT audio routing.
 Set mixdown mode. 
 Set other parameter registers. 
hwwrite(vortex->mmio, WT_GMODE(0), 0xffffffff);
hwwrite(vortex->mmio, WT_GMODE(1), 0xffffffff);
hwwrite(vortex->mmio, WT_PARM(wt, 3), temp);
 Read WT Register 
int eax, esi;
 WT hardware abstraction layer generic register interface. 
	
	   int eax, edx;
	   if (wt >= NR_WT)   0x40 -> NR_WT
	   return 0;
	   if ((reg - 0x20) > 0) {
	   if ((reg - 0x21) != 0) 
	   return 0;
	   eax = ((((b & 0xff) << 0xb) + (edx & 0xff)) << 4) + 0x208;  param 2
	   } else {
	   eax = ((((b & 0xff) << 0xb) + (edx & 0xff)) << 4) + 0x20a;  param 3
	   }
	   hwwrite(vortex->mmio, eax, c);
public: static void __thiscall CWTHal::SetReg(unsigned char,int,unsigned long) 
 Voice specific parameters 
 running 
		
		pr_debug( "vortex: WT SetReg(0x%x) = 0x%08x\n",
		       WT_RUN(wt), (int)val);
 param 0 
		
		pr_debug( "vortex: WT SetReg(0x%x) = 0x%08x\n",
		       WT_PARM(wt,0), (int)val);
 param 1 
		
		pr_debug( "vortex: WT SetReg(0x%x) = 0x%08x\n",
		       WT_PARM(wt,1), (int)val);
 param 2 
		
		pr_debug( "vortex: WT SetReg(0x%x) = 0x%08x\n",
		       WT_PARM(wt,2), (int)val);
 param 3 
		
		pr_debug( "vortex: WT SetReg(0x%x) = 0x%08x\n",
		       WT_PARM(wt,3), (int)val);
 mute 
		
		pr_debug( "vortex: WT SetReg(0x%x) = 0x%08x\n",
		       WT_MUTE(wt), (int)val);
 delay 
		
		pr_debug( "vortex: WT SetReg(0x%x) = 0x%08x\n",
		       WT_DELAY(wt,0), (int)val);
 Global WT block parameters 
 sramp 
 aramp 
 mramp 
 ctrl 
 ds_reg 
	
	pr_debug( "vortex: WT SetReg(0x%x) = 0x%08x\n", ecx, (int)val);
 var10 = 0x1AA2
 Init Bank registers. 
 ds_reg 
 ctrl  
 mramp 
 aramp 
 sramp 
 Init Voice registers. 
 param 3 0x20c 
 param 2 0x208 
 param 1 0x204 
 param 0 0x200 
 delay 0x400 - 0x40c 
 ctrl 
 Extract of CAdbTopology::SetVolume(struct _ASPVOLUME ) 
 This is pure guess 
 This is real 
 Extract of CAdbTopology::SetFrequency(unsigned long arg_0) 
FIXME: 64 bit operation.
 Wt: this_1D4
AuWt::WriteReg((ulong)(this_1DC<<4)+0x200, (ulong)this_1E4);
AuWt::WriteReg((ulong)(this_1DC<<4)+0x204, (ulong)this_1E8);
 End of File 
 SPDX-License-Identifier: GPL-2.0-or-later
             au88x0_cxtalk.c
   Wed Nov 19 16:29:47 2003
   Copyright  2003  mjander
   mjander@users.sourceforge.org
 Data (a whole lot of data.... ) 
 Input gain for 4 A3D slices. One possible input pair is left zero.
 XTalk EQ and XT 
 Gains 
 Delay parameters 
 ControlGlobal stuff 
 inlined
 inlined
 inlined
 inlined
 inlined
 inlined
 inlined
 inlined
 inlined
 inlined
sDiamondKLeftEq,sDiamondKRightXt,asDiamondCoefsLeftEq
 inlined
 End of file 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) by Jaroslav Kysela <perex@perex.cz>
   Routines for control of MPU-401 in UART mode
    Modified for the Aureal Vortex based Soundcards
    by Manuel Jander (mjande@embedded.cl).
 Check for mpu401 mmio support. 
 MPU401 legacy support is only provided as a emergency fallback 
 Vortex MPU401 defines. 
 Standart MPU401 defines. 
 EnableHardCodedMPU401Port() 
 Enable Legacy MIDI Interface port. 
 FIXME: static address. 0x330 
 Disable Legacy MIDI Interface port. 
 Mpu401UartInit() 
 Check if anything is OK. 
0xfe  ) {
 Enable MPU401 interrupts. 
 Create MPU401 instance. 
 Overwrite MIDI name 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-only
  ALSA driver for the Aureal Vortex family of soundprocessors.
  Author: Manuel Jander (mjander@embedded.cl)
    This driver is the result of the OpenVortex Project from Savannah
  (savannah.nongnu.orgprojectsopenvortex). I would like to thank
  the developers of OpenVortex, Jeff Muizelaar and Kester Maddock, from
  whom i got plenty of help, and their codebase was invaluable.
    Thanks to the ALSA developers, they helped a lot working out
  the ALSA part.
    Thanks also to Sourceforge for maintaining the old binary drivers,
  and the forum, where developers could comunicate.
  Now at least i can play Legacy DOOM with MIDI music :-)
 module parameters (see "Module Parameters")
	
	  only set the bit (Extend PCI#2 Internal Master for
	  Efficient Handling of Dummy Requests) if the can
	  read the config and it is not already set
 autodetect if workarounds are required 
 VIA KT133 
 VIA Apollo 
 AMD Irongate 
 component-destructor
 (see "Management of Cards and Components")
 chip-specific constructor
 (see "Management of Cards and Components")
 check PCI availability (DMA).
 initialize the stuff
 (1) PCI resource allocation
 Get MMIO area
	 Init audio core.
	  This must be done before we do request_irq otherwise we can get spurious
 End of PCI setup.
 constructor -- see "Constructor" sub-section
 (1)
 (2)
 (3)
 Card details needed in snd_vortex_midi
 (4) Alloc components.
 ADB pcm.
 ADB SPDIF
 A3D
	
	    ADB I2S
	   if ((err = snd_vortex_new_pcm(chip, VORTEX_PCM_I2S, 1)) < 0) {
	   return err;
	   }
 WT pcm.
 (5)
 (6)
 (7)
 pci_driver definition
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-or-later
    Vortex core low level functions.
	
 Author: Manuel Jander (mjander@users.sourceforge.cl)
 These functions are mainly the result of translations made
 from the original disassembly of the au88x0 binary drivers,
 written by Aureal before they went down.
 Many thanks to the Jeff Muizelaar, Kester Maddock, and whoever
 contributed to the OpenVortex project.
 The author of this file, put the few available pieces together
 and translated the rest of the riddle (Mix, Src and connection stuff).
 Some things are still to be discovered, and their meanings are unclear.
 Some of these functions aren't intended to be really used, rather
 to help to understand how does the AU88X0 chips work. Keep them in, because
 they could be used somewhere in the future.
 This code hasn't been tested or proof read thoroughly. If you wanna help,
 take a look at the AU88X0 assembly and check if this matches.
 Functions tested ok so far are (they show the desired effect
 at least):
   vortex_routes(); (1 bug fixed).
   vortex_adb_addroute();
   vortex_adb_addroutes();
   vortex_connect_codecplay();
   vortex_src_flushbuffers();
   vortex_adbdma_setmode();  note: still some unknown arguments!
   vortex_adbdma_startfifo();
   vortex_adbdma_stopfifo();
   vortex_fifo_setadbctrl(); note: still some unknown arguments!
   vortex_mix_setinputvolumebyte();
   vortex_mix_enableinput();
   vortex_mixer_addWTD(); (fixed)
   vortex_connection_adbdma_src_src();
   vortex_connection_adbdma_src();
   vortex_src_change_convratio();
   vortex_src_addWTD(); (fixed)
 History:
 01-03-2003 First revision.
 01-21-2003 Some bug fixes.
 17-02-2003 many bugfixes after a big versioning mess.
 18-02-2003 JAAAAAHHHUUUUUU!!!! The mixer works !! I'm just so happy !
			 (2 hours later...) I cant believe it! Im really lucky today.
			 Now the SRC is working too! Yeah! XMMS works !
 20-02-2003 First steps into the ALSA world.
 28-02-2003 As my birthday present, i discovered how the DMA buffer pages really
            work :-). It was all wrong.
 12-03-2003 ALSA driver starts working (2 channels).
 16-03-2003 More srcblock_setupchannel discoveries.
 12-04-2003 AU8830 playback support. Recording in the works.
 17-04-2003 vortex_route() and vortex_routes() bug fixes. AU8830 recording
 			works now, but chipn' dale effect is still there.
 16-05-2003 SrcSetupChannel cleanup. Moved the Src setup stuff entirely
            into au88x0_pcm.c .
 06-06-2003 Buffer shifter bugfix. Mixer volume fix.
 07-12-2003 A3D routing finally fixed. Believed to be OK.
 25-03-2004 Many thanks to Claudia, for such valuable bug reports.
  MIXER (CAsp4Mix.s and CAsp4Mixer.s) 
 FIXME: get rid of this.
FP2LinearFrac(a);
	
	   if (rampchs[mix] == 0)
	   a = FP2LinearFrac(a);
	   else
	   a = FP2LinearFracWT(a);
 WOW! what a complex function! 
 This function is intended for ramping down only (see vortex_disableinput()).
if (this_10) 
 this_10, initialized to 1. 
 Mute input. Astatic void crackling? 
 Looks like clear buffer. 
 Write enable bit. 
0x80 : mute 
 Register callback.
vortex_mix_startrampvolume(vortex);
printk(KERN_INFO "vortex: mixAddWTD: while addr=%x, val=%x\n", prev, temp);
int esp1f=edi(while)=src, esp10=ch;
7b60
7ad3
printk(KERN_INFO "vortex: mixdelWTD: 1 addr=%x, val=%x, src=%x\n", ebx, edx, src);
printk(KERN_INFO "vortex: mixdelWTD: while addr=%x, val=%x\n", ebp, edx);
7b30
 Delete entry in between others 
7b60
printk(KERN_INFO "vortex mixdelWTD between addr= 0x%x, val= 0x%x\n", ebp, edx);
 Delete last entry 
7b83
printk(KERN_INFO "vortex mixdelWTD last addr= 0x%x, val= 0x%x\n", esp14, ebx);
printk(KERN_INFO "removed last mix\n");
7be0
 FIXME: get rid of this crap.
 Set clipping ceiling (this may be all wrong). 
	
	for (x = 0; x < 0x80; x++) {
		hwwrite(vortex->mmio, VORTEX_MIXER_CLIP + (x << 2), 0x3ffff);
	}
	
	   call CAsp4Mix__Initialize_CAsp4HwIO____CAsp4Mixer____
	   Register ISR callback for volume smooth fade out.
	   Maybe this avoids clicks when press "stop" ?
  SRC (CAsp4Src.s and CAsp4SrcBlock) 
 Objective: Set samplerate for given SRC module.
 Arguments:
	card:	pointer to vortex_t strcut.
	src:	Integer index of the SRC module.
	cr:		Current sample rate conversion factor.
	b:		unknown 16 bit value.
	sweep:	Enable Samplerate fade from cr toward tr flag.
	dirplay: 1: playback, 0: recording.
	sl:		Slow Lock flag.
	tr:		Target samplerate conversion.
	thsource: Throttle source flag (no idea what that means).
 noplayback: d=2,4,7,0xa,0xb when using first 2 src's.
 c: enables pitch sweep.
 looks like g is c related. Maybe g is a sweep parameter ?
 g = cvr
 dirplay: 0 = recording, 1 = playback
 d = src hw index.
ebx = 0 
 0xc0   esi=0xc c=f=0 d=0 
 0   b=0 
 0x30f00 e=g=1 esp10=0 ebp=f 
printk(KERN_INFO "vortex: SRC %d, d=0x%x, esi=0x%x, esp10=0x%x, ebp=0x%x\n", src, d, esi, esp10, ebp);
	
	   for (x=0; x<0x10; x++) {
	   vortex_src_init(&vortex_src[x], x);
	   }
addr = 0xcc3c;
addr = 0x26c3c;
addr = 0xcc94;
addr = 0x26c94;
 esp13 = src
ebp 
while (temp & NR_SRC) {
esp12 
prev = VORTEX_SRC_RTBASE + ((temp & (NR_SRC-1)) << 2); esp12
printk(KERN_INFO "vortex: srcAddWTD: while addr=%x, val=%x\n", prev, temp);
hwwrite(vortex->mmio, prev, (temp & (NR_SRC-1)) | NR_SRC);
int esp1f=edi(while)=src, esp10=ch;
7b60
7ad3
printk(KERN_INFO "vortex: srcdelWTD: 1 addr=%x, val=%x, src=%x\n", ebx, edx, src);
printk(KERN_INFO "vortex: srcdelWTD: while addr=%x, val=%x\n", ebp, edx);
7b30
 Delete entry in between others 
7b60
printk(KERN_INFO "vortex srcdelWTD between addr= 0x%x, val= 0x%x\n", ebp, edx);
 Delete last entry 
7b83
printk(KERN_INFO"vortex srcdelWTD last addr= 0x%x, val= 0x%x\n", esp14, ebx);
7be0
FIFO 
int this_8[NR_ADB] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};  position 
	 f seems priority related.
	  CAsp4AdbDma::SetPriority is the only place that calls SetAdbCtrl with f set to 1
	  every where else it is set to 0. It seems, however, that CAsp4AdbDma::SetPriority
	  is never called, thus the f related bits remain a mystery for now.
 AU8830 semes to take some special care about fifo content (data).
 But i'm just to lazy to translate that :)
this_8[fifo] = 0;
 this_4
if (this_8[fifo]) 
 this_4
if (this_8[fifo]) 
	
    do {
		temp = hwread(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2));
		if (lifeboat++ > 0xbb8) {
			pr_err( "Vortex: vortex_fifo_setwtctrl fail (hanging)\n");
			break;
		}
    } while ((temp & FIFO_RDONLY)&&(temp & FIFO_VALID)&&(temp != 0xFFFFFFFF));
	
	
	if (valid) {
		if (temp & FIFO_VALID) {
			temp = 0x40000;
			temp |= 0x08000000;
			temp |= 0x10000000;
			temp |= 0x04000000;
			temp |= 0x00400000;
			temp |= 0x1c400000;
			temp &= 0xFFFFFFF3;
			temp &= 0xFFFFFFEF;
			temp |= (valid & 1) << 4;
			hwwrite(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2), temp);
			return;
		} else {
			vortex_fifo_clearwtdata(vortex, fifo, FIFO_SIZE);
			return;
		}
	} else {
		temp &= 0xffffffef;
		temp |= 0x08000000;
		temp |= 0x10000000;
		temp |= 0x04000000;
		temp |= 0x00400000;
		hwwrite(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2), temp);
		temp = hwread(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2));
		((temp >> 6) & 0x3f) 
		
		priority = 0;
		if (((temp & 0x0fc0) ^ ((temp >> 6) & 0x0fc0)) & 0FFFFFFC0)
			vortex_fifo_clearwtdata(vortex, fifo, FIFO_SIZE);
		valid = 0xfb;
		temp = (temp & 0xfffffffd) | ((ctrl & 1) << 1);
		temp = (temp & 0xfffdffff) | ((f & 1) << 0x11);
		temp = (temp & 0xfffffff3) | ((priority & 3) << 2);
		temp = (temp & 0xffffffef) | ((valid & 1) << 4);
		temp = (temp & 0xffffffdf) | ((empty & 1) << 5);
		hwwrite(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2), temp);
	}
	
	
	   temp = (temp & 0xfffffffd) | ((ctrl & 1) << 1);
	   temp = (temp & 0xfffdffff) | ((f & 1) << 0x11);
	   temp = (temp & 0xfffffff3) | ((priority & 3) << 2);
	   temp = (temp & 0xffffffef) | ((valid & 1) << 4);
	   temp = (temp & 0xffffffdf) | ((empty & 1) << 5);
	   #ifdef FIFO_BITS
	   temp = temp | FIFO_BITS | 40000;
	   #endif
	    0x1c440010, 0x1c400000
	   hwwrite(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2), temp);
 ADB DMA channels fifos. 
 WT DMA channels fifos. 
 trigger... 
0x0843 0xd6b
 wt a 
 wt b 
 adb 
 ADBDMA 
hwwrite(vortex->mmio, VORTEX_ADBDMA_START + (adbdma << 2), sb << (((NR_ADB-1)-((adbdma&0xf)2))));
 Four or more pages 
 3 pages 
 2 pages 
 1 page 
	
	pr_debug( "vortex: cfg0 = 0x%x\nvortex: cfg1=0x%x\n",
	       dma->cfg0, dma->cfg1);
 Enable PCMOUT interrupts. 
 refresh hw page table 
 p: audio buffer page index 
 pp: hardware DMA page index. 
hwwrite(vortex->mmio, VORTEX_ADBDMA_BUFBASE+(((adbdma << 2)+pp) << 2), dma->table[p].addr);
 Force write thru cache. 
 refresh hw page table 
 p: audio buffer page index 
 pp: hardware DMA page index. 
 Force write thru cache. 
empty  , this_4 = 0 
 WTDMA 
int this_7c=dma_ctrl;
hwwrite(vortex->mmio, VORTEX_WTDMA_START + (wtdma << 2), sb << ((0x1f-(wtdma&0xf)2)));
 Four or more pages 
 3 pages 
 2 pages 
 1 page 
int e,  u32 offset)
dma->this_08 = e;
 PCMOUT interrupt 
 Always playback. 
 Audio Format 
 Write into hardware 
 refresh hw page table 
 p: audio buffer page index 
 pp: hardware DMA page index. 
 Force write thru cache. 
 ADB Routes 
	 it looks like we are writing more than we need to...
 Write last routes. 
 Write first route. 
 First entry on this channel. 
 Not first entry on this channel. Need to link. 
 Find route. 
 Make bridge over deleted route. 
 Route two sources to same target. Sources must be of same class !!! 
 fifo A 
 Connection stuff 
 Connect adbdma to src('s).
 Connect SRC to mixin.
 Connect mixin with mix output.
 added to original code.
 Connect absolut address to mixin.
 mix to absolut address.
 added to original code.
 mixer to src.
 added to original code.
 Connect two mix to AdbDma.
 CODEC connect. 
 Connect front channels through EQ.
 Lower volume, since EQ has some gain. 
 Check if reg 0x28 has SDAC bit set. 
 Rear channel. Note: ADB_CODECOUT(0+2) and (1+2) is for AC97 modem 
 pr_debug( "SDAC detected "); 
 Use plain direct output to codec.
	
	   Enable: 0x1, 0x1
	   Channel: 0x11, 0x11
	   ADB Source address: 0x48, 0x49
	   Destination Asp4Topology_0x9c,0x98
 Higher level ADB audio path (de)allocator.
 Resource manager 
 CheckoutCheckin resource of given type. 
 resmap: resource map to be used. If NULL means that we want to allocate
 a DMA resource (root of all other resources of a dma channel).
 out: Mean checkout if != 0. Else mean Checkin resource.
 restype: Indicates type of resource to be checked in or out.
 Gather used resources by all streams. 
 Find and take free resource. 
				
				pr_debug(
				       "vortex: ResManager: type %d out %d\n",
				       restype, i);
 Checkin first resource of type restype. 
				
				pr_debug(
				       "vortex: ResManager: type %d in %d\n",
				       restype, i);
 Default Connections  
 Connect AC97 codec.
 Connect SPDIF
 Connect WT
 A3D (crosstalk canceler and A3D slices). AU8810 disabled for now.
 Connect I2S
 Connect DSP interface for SQ3500 turbo (not here i think...)
 Connect AC98 modem codec
  Allocate nr_ch pcm audio routes if dma < 0. If dma >= 0, existing routes
  are deallocated.
  dma: DMA engine routes to be deallocated when dma >= 0.
  nr_ch: Number of channels to be deallocated.
  dir: direction of stream. Uses same values as substream->stream.
  type: Type of audio outputsource (codec, spdif, i2s, dsp, etc)
  Return: Return allocated DMA or same DMA passed as "dma" when dma >= 0.
 PLAYBACK ROUTES. 
 Get SRC and MIXER hardware resources. 
 (De)Initialize A3D hardware source. 
 Make SPDIF out exclusive to "spdif" device when in use. 
 Make playback routes. 
 XTalk test. 
vortex_route(vortex, en, 0x11, dma, ADB_XTALKIN(i?9:4));
vortex_route(vortex, en, 0x11, ADB_SRCOUT(src[i]), ADB_XTALKIN(i?4:9));
 Reconnect SPDIF out when "spdif" device is down. 
 CAPTURE ROUTES. 
 Get SRC and MIXER hardware resources. 
 Make capture routes. 
 AC97 Codec channel setup. FIXME: this has no effect on some cards !! 
 Copy stereo to rear channel (surround) 
 Allow separate front and rear channels. 
 Set the SampleRate of the SRC's attached to the given DMA engine.
 dir=1:play ; dir=0:rec 
 Setup SRC's 
 Timer and ISR functions.
set the timer period to <period> 48000ths of a second.
 CAsp4ISR__EnableVortexInt_void_
check if the interrupt is ours.
 This is the Interrupt Enable flag we set before (consistency check).
 Reset IRQ flags.
 Is at least one IRQ flag set?
 Attend every interrupt source.
 ALSA period acknowledge. 
				 FIXME: we ignore the return value from
				  vortex_wtdma_bufshift() below as the delta
				  calculation seems not working for wavetable
				  by some reason
Acknowledge the Timer interrupt
 Codec 
 the windows driver writes -i, so we write -i 
 Enable codec channels 0 and 1. 
 wait for transactions to clear 
 write register 
 Flush Caches. 
 wait for transactions to clear 
 set up read address 
 wait for address 
 return data. 
 SPDIF support  
 CAsp4Spdif::InitializeSpdifHardware(void) 
for (i=0x291D4; i<0x29200; i+=4)
hwwrite(vortex->mmio, 0x29190, hwread(vortex->mmio, 0x29190) | 0xc0000);
 CAsp4Spdif::ProgramSRCInHardware(enum  SPDIF_SR,enum  SPDIFMODE) 
 this_04 and this_08 are the CASp4Src's (samplerate converters) 
 set 32khz samplerate 
 set 48khz samplerate 
 J. Gordon Wolfe: I think this stuff is for AC3 
	 looks like the next 2 lines transfer a 16-bit value into 2 8-bit 
	   registers. seems to be for the standard IECSPDIF initialization 
 Initialization 
 Hardware Init. 
 Reset IRQ flags 
 Init audio engine. 
, 0xc83c7e58, 0xc5f93e58
 Init processing blocks. 
 Moved to au88x0.c
vortex_connect_default(vortex, 1);
 Enable Interrupts.
 vortex_enable_int() must be first !!
  hwwrite(vortex->mmio, VORTEX_IRQ_CTRL, 0);
 vortex_enable_int(vortex);
vortex_enable_timer_int(vortex);
vortex_disable_timer_int(vortex);
vortex_disable_timer_int(vortex);
 Reset all DMA fifos. 
 Erase all audio routes. 
 Disable MPU401 
hwwrite(vortex->mmio, VORTEX_IRQ_CTRL, hwread(vortex->mmio, VORTEX_IRQ_CTRL) & ~IRQ_MIDI);
hwwrite(vortex->mmio, VORTEX_CTRL, hwread(vortex->mmio, VORTEX_CTRL) & ~CTRL_MIDI_EN);
 Alsa support. 
 guess. 
 guess. 
 check this... 
 Some not yet useful translations. 
 0x8 
 0x1 
 0x2 
 0x3 
 ? 
 ? 
 16 bit
 8 bit
 U_LAW
 A_LAW
 SPDX-License-Identifier: GPL-2.0-or-later
    Driver for the Conexant Riptide Soundchip
 	Copyright (c) 2004 Peter Gruber <nokos@gmx.net>
  History:
   - 02152004 first release
  This Driver is based on the OSS Driver version from Linuxant (riptide-0.6lnxtbeta03111100)
  credits from the original files:
  MODULE NAME:        cnxt_rt.h                       
  AUTHOR:             K. Lazarev  (Transcribed by KNL)
  HISTORY:         Major Revision               Date        By
            -----------------------------     --------     -----
            Created                           0212000     KNL
  MODULE NAME:     int_mdl.c                       
  AUTHOR:          Konstantin Lazarev    (Transcribed by KNL)
  HISTORY:         Major Revision               Date        By
            -----------------------------     --------     -----
            Created                           100199      KNL
	    
  MODULE NAME:        riptide.h                       
  AUTHOR:             O. Druzhinin  (Transcribed by OLD)
  HISTORY:         Major Revision               Date        By
            -----------------------------     --------     -----
            Created                           101697      OLD
  MODULE NAME:        Rp_Cmdif.cpp                       
  AUTHOR:             O. Druzhinin  (Transcribed by OLD)
                      K. Lazarev    (Transcribed by KNL)
  HISTORY:         Major Revision               Date        By
            -----------------------------     --------     -----
            Adopted from NT4 driver            62299      OLD
            Ported to Linux                    90199      KNL
  MODULE NAME:        rt_hw.c                       
  AUTHOR:             O. Druzhinin  (Transcribed by OLD)
                      C. Lazarev    (Transcribed by CNL)
  HISTORY:         Major Revision               Date        By
            -----------------------------     --------     -----
            Created                           111897      OLD
            Hardware functions for RipTide    112497      CNL
            (ES1) are coded
            Hardware functions for RipTide    122497      CNL
            (A0) are coded
            Hardware functions for RipTide    032098      CNL
            (A1) are coded
            Boot loader is included           050798      CNL
            Redesigned for WDM                072798      CNL
            Redesigned for Linux              090199      CNL
  MODULE NAME:        rt_hw.h
  AUTHOR:             C. Lazarev    (Transcribed by CNL)
  HISTORY:         Major Revision               Date        By
            -----------------------------     --------     -----
            Created                           111897      CNL
  MODULE NAME:     rt_mdl.c                       
  AUTHOR:          Konstantin Lazarev    (Transcribed by KNL)
  HISTORY:         Major Revision               Date        By
            -----------------------------     --------     -----
            Created                           100199      KNL
  MODULE NAME:        mixer.h                        
  AUTHOR:             K. Kenney
  HISTORY:         Major Revision                   Date          By
            -----------------------------          --------     -----
            Created from MS W95 Sample             112895      KRS
            RipTide                                101597      KRS
            Adopted for Windows NT driver          012098      CNL
 legacy device options 
 cmd interface limits 
 global reset switch 
 interrupt enable 
 interrupt acknowledge 
 cmd empty 
 data filled 
 error ! 
 interrupt status 
 command flags 
 shifts and masks 
 get version 
 memory access for firmware write 
 memory access for firmware write 
 memory access for firmware write 
 memory access for firmware write 
 memory access for firmware write 
 start stream 
 pause stream 
 stop stream 
 stop all dma 
 get position in dma 
 set sample format at mixer 
 activate lbus path 
 deactivate lbus path 
 select paths for internal connections 
 configure source 
 read source config 
 set digital mixer 
 read digital mixer 
 set AC97 register 
 get AC97 register 
 status flags : block boundary 
              : stoppped 
              : stream end 
 enable interrupts for status notification above 
 stream states 
 config for I2S link 
 config for modem link 
 config for FMOPL3 link 
 path splitting flag 
 cmd,param 
 param 
 status 
 status registers 
 command ports 
 cmd statistics 
 scatter gather desriptor 
 pcm descriptor 
 free pending data 
 put data 
 write cmd 
 read response 
 update command statistics 
 CONFIG_PM_SLEEP 
 OK 
 OK 
 On failure unregister formerly registered audio driver 
 SPDX-License-Identifier: GPL-2.0
 getdelays.c
  Utility to get per-pid and per-tgid delay accounting statistics
  Also illustrates usage of the taskstats interface
  Copyright (C) Shailabh Nagar, IBM Corp. 2005
  Copyright (C) Balbir Singh, IBM Corp. 2006
  Copyright (c) Jay Lan, SGI. 2006
  Compile with
 	gcc -Iusrsrclinuxinclude getdelays.c -o getdelays
  Generic macros for dealing with netlink sockets. Might be duplicated
  elsewhere. It is recommended that commercial grade applications use
  libnl or libnetlink and use the interfaces provided by the library
 Maximum size of response requested or message sent 
 Maximum number of cpus expected to be specified in a cpumask 
  Create a raw netlink socket and bind
  Probe the controller in genetlink to find the family id
  for the TASKSTATS family
 sendto() failure? 
 Block SIGCHLD for sigwait() later 
 forkexec a child 
 Set the command type and avoid further processing 
	
	  If we forked a child, wait for it to exit. Cannot use waitpid()
	  as all the delicious data would be reaped as part of the wait
 Fall through 
 For nested attributes, na follows 
 SPDX-License-Identifier: GPL-2.0-only
  lsgpio - example on how to list the GPIO lines on a system
  Copyright (C) 2015 Linus Walleij
  Usage:
 	lsgpio <-n device-name>
 Inspect this GPIO chip 
 Loop over the lines and print info 
 List all GPIO devices one at a time 
 SPDX-License-Identifier: GPL-2.0-only
  gpio-watch - monitor unrequested lines for property changes using the
               character device
  Copyright (C) 2019 BayLibre SAS
  Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
 SPDX-License-Identifier: GPL-2.0-only
  GPIO tools - helpers library for the GPIO tools
  Copyright (C) 2015 Linus Walleij
  Copyright (C) 2016 Bamvor Jian Zhang
  DOC: Operation of gpio
  Provide the api of gpiochip for chardev interface. There are two
  types of api.  The first one provide as same function as each
  ioctl, including request and release for lines of gpio, readwrite
  the value of gpio. If the user want to do lots of read and write of
  lines of gpio, user should use this type of api.
  The second one provide the easy to use api for user. Each of the
  following api will request gpio lines, do the operation and then
  release these lines.
  gpiotools_request_line() - request gpio lines in a gpiochip
  @device_name:	The name of gpiochip without prefix "dev",
 			such as "gpiochip0"
  @lines:		An array desired lines, specified by offset
 			index for the associated GPIO device.
  @num_lines:		The number of lines to request.
  @config:		The new config for requested gpio. Reference
 			"linuxgpio.h" for config details.
  @consumer:		The name of consumer, such as "sysfs",
 			"powerkey". This is useful for other users to
 			know who is using.
  Request gpio lines through the ioctl provided by chardev. User
  could call gpiotools_set_values() and gpiotools_get_values() to
  read and write respectively through the returned fd. Call
  gpiotools_release_line() to release these lines after that.
  Return:		On success return the fd;
 			On failure return the errno.
  gpiotools_set_values() - Set the value of gpio(s)
  @fd:			The fd returned by
 			gpiotools_request_line().
  @values:		The array of values want to set.
  Return:		On success return 0;
 			On failure return the errno.
  gpiotools_get_values() - Get the value of gpio(s)
  @fd:			The fd returned by
 			gpiotools_request_line().
  @values:		The array of values get from hardware.
  Return:		On success return 0;
 			On failure return the errno.
  gpiotools_release_line() - Release the line(s) of gpiochip
  @fd:			The fd returned by
 			gpiotools_request_line().
  Return:		On success return 0;
 			On failure return the errno.
  gpiotools_get() - Get value from specific line
  @device_name:	The name of gpiochip without prefix "dev",
 			such as "gpiochip0"
  @line:		number of line, such as 2.
  Return:		On success return 0;
 			On failure return the errno.
  gpiotools_gets() - Get values from specific lines.
  @device_name:	The name of gpiochip without prefix "dev",
 			such as "gpiochip0".
  @lines:		An array desired lines, specified by offset
 			index for the associated GPIO device.
  @num_lines:		The number of lines to request.
  @values:		The array of values get from gpiochip.
  Return:		On success return 0;
 			On failure return the errno.
  gpiotools_set() - Set value to specific line
  @device_name:	The name of gpiochip without prefix "dev",
 			such as "gpiochip0"
  @line:		number of line, such as 2.
  @value:		The value of gpio, must be 0(low) or 1(high).
  Return:		On success return 0;
 			On failure return the errno.
  gpiotools_sets() - Set values to specific lines.
  @device_name:	The name of gpiochip without prefix "dev",
 			such as "gpiochip0".
  @lines:		An array desired lines, specified by offset
 			index for the associated GPIO device.
  @num_lines:		The number of lines to request.
  @values:		The array of values set to gpiochip, must be
 			0(low) or 1(high).
  Return:		On success return 0;
 			On failure return the errno.
 SPDX-License-Identifier: GPL-2.0-only
  gpio-event-mon - monitor GPIO line events from userspace
  Copyright (C) 2016 Linus Walleij
  Usage:
 	gpio-event-mon -n <device-name> -o <offset>
 Read initial states 
 SPDX-License-Identifier: GPL-2.0-only
  gpio-hammer - example swiss army knife to shake GPIO lines on a system
  Copyright (C) 2016 Linus Walleij
  Usage:
 	gpio-hammer -n <device-name> -o <offset1> -o <offset2>
 Hammertime! 
 Invert all lines so we blink 
 Re-read values to get status 
			
			  Avoid overflow. Do not immediately error, we want to
			  be able to accurately report on the amount of times
			  '-o' was given to give an accurate error message
 SPDX-License-Identifier: GPL-2.0-only
  Parserloader for IHEX formatted data.
  Copyright  2008 David Woodhouse <dwmw2@infradead.org>
  Copyright  2005 Jan Harkes <jaharkes@cs.cmu.edu>
 not part of the real data structure 
  nybblehex are little helpers to parse hexadecimal numbers to a byte value
 search for the start of record character 
 Minimum record length would be about 10 characters 
 now check if we have enough data to read everything 
 check CRC 
 Done reading the record 
 old style EOF record? 
 End-Of-File Record 
 Extended Segment Address Record (HEX86) 
 Extended Linear Address Record (HEX386) 
		 We shouldn't really be using the offset for HEX86 because
 Start Segment Address Record 
 Start Linear Address Record 
		 These records contain the CSIP or EIP where execution
	 EOF record is zero length, since we don't bother to represent
 SPDX-License-Identifier: GPL-2.0-only
 crc32hash.c - derived from linuxlibcrc32.c, GNU GPL v2 
 Usage example:
$ .crc32hash "Dual Speed"
 SPDX-License-Identifier: GPL-2.0
  "Optimize" a list of dependencies as spit out by gcc -MD
  for the build framework.
  Original author:
    Copyright    2002 by Kai Germaschewski  <kai.germaschewski@gmx.de>
  This code has been borrowed from kbuild's fixdep (scriptsbasicfixdep.c),
  Please check it for detailed explanation. This fixdep borow only the
  base transformation of dependecies without the CONFIG mangle.
  Print out the commandline prefixed with cmd_<target filename> :=
  Important: The below generated source_foo.o and deps_foo.o variable
  assignments are parsed not only by make, but also by the rather simple
  parser in scriptsmodsumversion.c.
 Skip any "white space" 
 Find next "white space" 
 Is the token we found a target name? 
 Don't write any target names into the dependency file 
 The next file is the first dependency 
 Save this tokenfilename 
			
			  Do not list the source file as dependency,
			  so that kbuild is not confused if a .c file
			  is rewritten into .S or vice versa. Storing
			  it in source_ is needed for modpost to
			  compute srcversions.
				
				  If processing the concatenation of
				  multiple dependency files, only
				  process the first target name, which
				  will be the original source name,
				  and ignore any other target names,
				  which will be intermediate temporary
				  files.
		
		  Start searching for next token immediately after the first
		  "whitespace" character that follows this token.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  test for timerfd functions used by perf-kvm-stat-live
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  test-all.c: Try to build all the main testcases at once.
  A well-configured system will have all the prereqs installed, so we can speed
  up auto-detection on such systems.
  Quirk: Python and Perl headers cannot be in arbitrary places, so keep
  these 3 testcases at the top:
  Disable libbabeltrace check for test-all, because the requested
  library version is not released yet in most distributions. Will
  reenable later.
 SPDX-License-Identifier: GPL-2.0
	
	  This function is guarded via: __nonnull_attribute__ (1, 2).
	  Passing '1' as arguments value. This code is never executed,
	  only compiled.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
SIGEV_NONE;
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2018, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Check fields in attr 
	
	  Test existence of __NR_bpf and BPF_PROG_LOAD.
	  This call should fail if we run the testcase.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2019, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  Check OpenCSD library version is sufficient to provide required features
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-only
   Sample application for SMBIOS communication over WMI interface
   Performs the following:
   - Simple cmd_classcmd_select lookup for TPM information
   - Simple query of known tokens and their values
   - Simple activation of a token
   Copyright (C) 2017 Dell, Inc.
 if uapi header isn't installed, this might not yet exist 
 It would be better to discover these using udev, but for a simple
  application they're hardcoded
 simple SMBIOS call for looking up TPM info 
 query some tokens 
 activate UEFI capsule token if disabled 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright(c) 2021 Intel Corporation. All rights reserved. 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright(c) 2021 Intel Corporation. All rights reserved. 
 TODO walk DVSEC to find component register base 
 SPDX-License-Identifier: GPL-2.0
	
	  These kconfig symbols must be set to "m" for cxl_test to load
	  and operate.
 SPDX-License-Identifier: GPL-2.0-only
Copyright(c) 2021 Intel Corporation. All rights reserved.
		
		  Simulate 2 root ports per host-bridge and no
		  depth recursion.
 SPDX-License-Identifier: GPL-2.0-only
 Copyright(c) 2021 Intel Corporation. All rights reserved.
 FIXME: Add partition support 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright(c) 2021 Intel Corporation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0+
  xarray.c: Userspace shim for XArray test-suite
  Copyright (c) 2018 Matthew Wilcox <willy@infradead.org>
 SPDX-License-Identifier: GPL-2.0-only
  idr-test.c: Test the IDR API
  Copyright (c) 2016 Matthew Wilcox <willy@infradead.org>
  Unlike the radix tree, you can put a NULL pointer -- with care -- into
  the IDR.  Some interfaces, like idr_find() do not distinguish between
  "present, value is NULL" and "not present", but that's exactly what some
  users want.
  There are always either 1 or 2 objects in the IDR.  If we find nothing,
  or we find something at an ID we didn't expect, that's a bug.
  Check that we get the correct error when we run out of memory doing
  allocations.  In userspace, GFP_NOWAIT will always fail an allocation.
  The first test is for not having a bitmap available, and the second test
  is for not being able to allocate a level of the radix tree.
  Check handling of conversions between exceptional entries and full bitmaps.
 SPDX-License-Identifier: GPL-2.0
  Regression1
  Description:
  Salman Qazi describes the following radix-tree bug:
  In the following case, we get can get a deadlock:
  0.  The radix tree contains two items, one has the index 0.
  1.  The reader (in this case find_get_pages) takes the rcu_read_lock.
  2.  The reader acquires slot(s) for item(s) including the index 0 item.
  3.  The non-zero index item is deleted, and as a consequence the other item
      is moved to the root of the tree. The place where it used to be is queued
      for deletion after the readers finish.
  3b. The zero item is deleted, removing it from the direct slot, it remains in
      the rcu-delayed indirect node.
  4.  The reader looks at the index 0 slot, and finds that the page has 0 ref
      count
  5.  The reader looks at it again, hoping that the item will either be freed
      or the ref count will increase. This never happens, as the slot it is
      looking at will never be updated. Also, this slot can never be reclaimed
      because the reader is holding rcu_read_lock and is in an infinite loop.
  The fix is to re-use the same "indirect" pointer case that requires a slot
  lookup retry into a general "retry the lookup" bit.
  Running:
  This test should run to completion in a few seconds. The above bug would
  cause it to hang indefinitely.
  Upstream commit:
  Not yet
 don't actually update page refcount 
 Has the page moved? 
 Regression #1 
 SPDX-License-Identifier: GPL-2.0-only
  benchmark.c:
  Author: Konstantin Khlebnikov <koct9i@gmail.com>
 SPDX-License-Identifier: GPL-2.0
  Scan only the passed (start, start+nr] for present items
  Scan the entire tree, only expecting present items (start, start+nr]
	printf("%s(0x%08lx, 0x%08lx, %d)\n", __FUNCTION__, start, nr, chunk);
		printf("At 0x%08lx, nfound=%d\n", into, nfound);
		printf("Found 0x%08lx->0x%08lx\n",
			items[0]->index, items[nfound-1]->index);
 Use the same pattern as tag_pages_for_writeback() in mmpage-writeback.c 
 Verify consistency at this level 
 Go for next level 
 SPDX-License-Identifier: GPL-2.0-only
  multiorder.c: Multi-order radix tree entry testing
  Copyright (c) 2016 Intel Corporation
  Author: Ross Zwisler <ross.zwisler@linux.intel.com>
  Author: Matthew Wilcox <matthew.r.wilcox@intel.com>
 'order' is set up to ensure we have sibling entries 
 SPDX-License-Identifier: GPL-2.0
  Regression2
  Description:
  Toshiyuki Okajima describes the following radix-tree bug:
  In the following case, we can get a hangup on
    radix_radix_tree_gang_lookup_tag_slot.
  0.  The radix tree contains RADIX_TREE_MAP_SIZE items. And the tag of
      a certain item has PAGECACHE_TAG_DIRTY.
  1.  radix_tree_range_tag_if_tagged(, start, end, , PAGECACHE_TAG_DIRTY,
      PAGECACHE_TAG_TOWRITE) is called to add PAGECACHE_TAG_TOWRITE tag
      for the tag which has PAGECACHE_TAG_DIRTY. However, there is no tag with
      PAGECACHE_TAG_DIRTY within the range from start to end. As the result,
      There is no tag with PAGECACHE_TAG_TOWRITE but the root tag has
      PAGECACHE_TAG_TOWRITE.
  2.  An item is added into the radix tree and then the level of it is
      extended into 2 from 1. At that time, the new radix tree node succeeds
      the tag status of the root tag. Therefore the tag of the new radix tree
      node has PAGECACHE_TAG_TOWRITE but there is not slot with
      PAGECACHE_TAG_TOWRITE tag in the child node of the new radix tree node.
  3.  The tag of a certain item is cleared with PAGECACHE_TAG_DIRTY.
  4.  All items within the index range from 0 to RADIX_TREE_MAP_SIZE - 1 are
      released. (Only the item which index is RADIX_TREE_MAP_SIZE exist in the
      radix tree.) As the result, the slot of the radix tree node is NULL but
      the tag which corresponds to the slot has PAGECACHE_TAG_TOWRITE.
  5.  radix_tree_gang_lookup_tag_slot(PAGECACHE_TAG_TOWRITE) calls
      __lookup_tag. __lookup_tag returns with 0. And __lookup_tag doesn't
      change the index that is the input and output parameter. Because the 1st
      slot of the radix tree node is NULL, but the tag which corresponds to
      the slot has PAGECACHE_TAG_TOWRITE.
      Therefore radix_tree_gang_lookup_tag_slot tries to get some items by
      calling __lookup_tag, but it cannot get any items forever.
  The fix is to change that radix_tree_tag_if_tagged doesn't tag the root tag
  if it doesn't set any tags within the specified range.
  Running:
  This test should run to completion immediately. The above bug would cause it
  to hang indefinitely.
  Upstream commit:
  Not yet
 0. 
 1. 
 2. 
 3. 
 4. 
 5. 
 NOTE: start should not be 0 because radix_tree_gang_lookup_tag_slot
       can return.
 We remove all the remained nodes 
 libbitmap.c pulls in at least two other files. 
 SPDX-License-Identifier: GPL-2.0-or-later
  iteration_check_2.c: Check that deleting a tagged entry doesn't cause
  an RCU walker to finish early.
  Copyright (c) 2020 Oracle
  Author: Matthew Wilcox <willy@infradead.org>
 SPDX-License-Identifier: GPL-2.0-only
  iteration_check.c: test races having to do with xarray iteration
  Copyright (c) 2016 Intel Corporation
  Author: Ross Zwisler <ross.zwisler@linux.intel.com>
 relentlessly fill the array with tagged entries 
  Iterate over tagged entries, retrying when we find ourselves in a deleted
  node and randomly pausing the iteration.
  Iterate over the entries, retrying when we find ourselves in a deleted
  node and randomly pausing the iteration.
  Randomly remove entries to help induce retries in the
  two iteration functions.
 This is a unit test for a bug found by the syzkaller tester 
 SPDX-License-Identifier: GPL-2.0
  Regression3
  Description:
  Helper radix_tree_iter_retry resets next_index to the current index.
  In following radix_tree_next_slot current chunk size becomes zero.
  This isn't checked and it tries to dereference null pointer in slot.
  Helper radix_tree_iter_resume reset slot to NULL and next_index to index + 1,
  for tagger iteraction it also must reset cached tags in iterator to abort
  next radix_tree_next_slot and go to slow-path into radix_tree_next_chunk.
  Running:
  This test should run to completion immediately. The above bug would
  cause it to segfault.
  Upstream commit:
  Not yet
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  Check that tags propagate correctly when extending a tree.
 crash 
  Check that tags propagate correctly when contracting a tree.
  Stupid tag thrasher
  Create a large linear array corresponding to the tree.   Each element in
  the array is coherent with each node in the tree
 SPDX-License-Identifier: GPL-2.0
		printf("0x%08lx\n", start);
		if (i % 1000 == 0)
	printf("generating radix tree indices...\n");
	 Specifically create items around the start and the end of the range
		if (i % 1000 == 0)
	printf("\ncopying tags...\n");
	printf("checking copied tags\n");
 Copy tags in several rounds 
	printf("\ncopying tags...\n");
	printf("%lu %lu %lu\n", tagged, tmp, count);
	printf("checking copied tags\n");
	printf("\n");
 Free any remaining preallocated nodes 
 ADJ_FREQ Skew change test
 		by: john stultz (johnstul@us.ibm.com)
 		(C) Copyright IBM 2012
 		Licensed under the GPLv2
   NOTE: This is a meta-test which cranks the ADJ_FREQ knob and
   then uses other tests to detect problems. Thus this test requires
   that the raw_skew, inconsistency-check and nanosleep tests be
   present in the same directory it is run from.
   To build:
 	$ gcc change_skew.c -o change_skew -lrt
    This program is free software: you can redistribute it andor modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 Kill ntpd 
 Make sure there's no offset adjustment going on 
 Set things back 
 Set tai offset
               by: John Stultz <john.stultz@linaro.org>
               (C) Copyright Linaro 2013
               Licensed under the GPLv2
    This program is free software: you can redistribute it andor modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 Time inconsistency check test
 		by: john stultz (johnstul@us.ibm.com)
 		(C) Copyright IBM 2003, 2004, 2005, 2012
 		(C) Copyright Linaro Limited 2015
 		Licensed under the GPLv2
   To build:
 	$ gcc inconsistency-check.c -o inconsistency-check -lrt
    This program is free software: you can redistribute it andor modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 returns 1 if a <= b, 0 otherwise 
 use unsigned to avoid false positives on 2038 rollover 
 timestamp start of test 
 Fill list 
 Check for inconsistencies 
 display inconsistency 
 timestamp inconsistency
 Process arguments 
 Make sure timers don't return early
               by: john stultz (johnstul@us.ibm.com)
 		    John Stultz (john.stultz@linaro.org)
               (C) Copyright IBM 2012
               (C) Copyright Linaro 2013 2015
               Licensed under the GPLv2
   To build:
 	$ gcc nanosleep.c -o nanosleep -lrt
    This program is free software: you can redistribute it andor modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 returns 1 if a <= b, 0 otherwise 
 First check abs time 
 Second check reltime 
 Skip cputime clockids since nanosleep won't increment cputime 
 ADJ_FREQ Skew consistency test
 		by: john stultz (johnstul@us.ibm.com)
 		(C) Copyright IBM 2012
 		Licensed under the GPLv2
   NOTE: This is a meta-test which cranks the ADJ_FREQ knob back
   and forth and watches for consistency problems. Thus this test requires
   that the inconsistency-check tests be present in the same directory it
   is run from.
   To build:
 	$ gcc skew_consistency.c -o skew_consistency -lrt
    This program is free software: you can redistribute it andor modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 Set things back 
 Clocksource change test
 		by: john stultz (johnstul@us.ibm.com)
 		(C) Copyright IBM 2012
 		Licensed under the GPLv2
   NOTE: This is a meta-test which quickly changes the clocksource and
   then uses other tests to detect problems. Thus this test requires
   that the inconsistency-check and nanosleep tests be present in the
   same directory it is run from.
   To build:
 	$ gcc clocksource-switch.c -o clocksource-switch -lrt
    This program is free software: you can redistribute it andor modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 Find the next space 
 Check everything is sane before we start switching asynchronously 
 Set tz value
               by: John Stultz <john.stultz@linaro.org>
               (C) Copyright Linaro 2016
               Licensed under the GPLv2
    This program is free software: you can redistribute it andor modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 alarmtimer suspend test
 		John Stultz (john.stultz@linaro.org)
               (C) Copyright Linaro 2013
               Licensed under the GPLv2
    This test makes sure the alarmtimer & RTC wakeup code is
    functioning.
   To build:
 	$ gcc alarmtimer-suspend.c -o alarmtimer-suspend -lrt
    This program is free software: you can redistribute it andor modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 hopefully we resume in 5 secs 
 Set up signal handler: 
 Set up timer: 
 First 5 alarms, do nothing 
 SPDX-License-Identifier: GPL-2.0-only
  This test checks the response of the system clock to frequency
  steps made with adjtimex(). The frequency error and stability of
  the CLOCK_MONOTONIC clock relative to the CLOCK_MONOTONIC_RAW clock
  is measured in two intervals following the step. The test fails if
  values from the second interval exceed specified limits.
  Copyright (C) Miroslav Lichvar <mlichvar@redhat.com>  2017
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2013 Red Hat, Inc., Frederic Weisbecker <fweisbec@redhat.com>
  Selftests for a few posix timers interface.
  Kernel loop code stolen from Steven Rostedt <srostedt@redhat.com>
 Busy loop in userspace to elapse ITIMER_VIRTUAL 
  Try to spend as much time as possible in kernelspace
  to elapse ITIMER_PROF.
  Sleep until ITIMER_REAL expiration.
  Check the expected timer expiration matches the GTOD elapsed delta since
  we armed the timer. Keep a 0.5 sec error margin due to various jitter.
	
	  It's unfortunately hard to reliably test a timer expiration
	  on parallel multithread cputime. We could arm it to expire
	  on DELAY  nr_threads, with nr_threads busy looping, then wait
	  the normal DELAY since the time is elapsing nr_threads faster.
	  But for that we need to ensure we have real physical free CPUs
	  to ensure true parallelism. So test only one thread until we
	  find a better solution.
 adjtimex() tick adjustment test
 		by:   John Stultz <john.stultz@linaro.org>
 		(C) Copyright Linaro Limited 2015
 		Licensed under the GPLv2
   To build:
 	$ gcc adjtick.c -o adjtick -lrt
    This program is free software: you can redistribute it andor modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 Try to get a more tightly bound pairing 
	
	  Here we use 100ppm difference as an error bound.
	  We likely should see better, but some coarse clocksources
	  cannot match the HZ tick size accurately, so we have a
	  internal correction factor that doesn't scale exactly
	  with the adjustment, resulting in > 10ppm error during
	  a 10% adjustment. 100ppm also gives us more breathing
	  room for interruptions during the measurement.
 +- 10% 
 in 4 steps each side 
 Reset things to zero 
 Time bounds setting test
 		by: john stultz (johnstul@us.ibm.com)
 		(C) Copyright IBM 2012
 		Licensed under the GPLv2
   NOTE: This is a meta-test which sets the time to edge cases then
   uses other tests to detect problems. Thus this test requires that
   the inconsistency-check and nanosleep tests be present in the same
   directory it is run from.
   To build:
 	$ gcc set-2038.c -o set-2038 -lrt
    This program is free software: you can redistribute it andor modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
overflows 32bit time_t 
overflows 64bit ktime_t 
overflows 64bit time_t 
 Process arguments 
 First test that crazy values don't work 
 Now test behavior near edges 
 The rest of the tests can blowup on 32bit systems 
 Test rollover behavior 32bit edge 
 restore clock 
 threadtest.c
 		by: john stultz (johnstul@us.ibm.com)
 		(C) Copyright IBM 2004, 2005, 2006, 2012
 		Licensed under the GPLv2
   To build:
 	$ gcc threadtest.c -o threadtest -lrt
    This program is free software: you can redistribute it andor modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 serializes shared list access 
 serializes console output 
 scan the list 
 look for any time inconsistencies 
 flag other threads 
serialize printing to avoid junky output
 dump the list 
 The shared thread shares a global list
  that each thread fills while holding the lock.
  This stresses clock synchronization across cpus.
 protect the list 
 see if we're ready to check the list 
 Each independent thread fills in its own
  list. This stresses clock_gettime() lock contention.
 fill the list 
 Process arguments 
 spawn 
 wait 
 die 
 CLOCK_MONOTONIC vs CLOCK_MONOTONIC_RAW skew test
 		by: john stultz (johnstul@us.ibm.com)
 		    John Stultz <john.stultz@linaro.org>
 		(C) Copyright IBM 2012
 		(C) Copyright Linaro Limited 2015
 		Licensed under the GPLv2
   To build:
 	$ gcc raw_skew.c -o raw_skew -lrt
    This program is free software: you can redistribute it andor modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 calculate measured ppm between MONOTONIC and MONOTONIC_RAW 
 Avg the two actual freq samples adjtimex gave us 
 Measure mqueue timeout latency
               by: john stultz (john.stultz@linaro.org)
 		(C) Copyright Linaro 2013
 		Inspired with permission from example test by:
 			Romain Francoise <romain@orebokech.com>
               Licensed under the GPLv2
   To build:
 	$ gcc mqueue-lat.c -o mqueue-lat -lrt
    This program is free software: you can redistribute it andor modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 100ms in nanoseconds 
 40ms in nanosecs 
 100ms 
 SPDX-License-Identifier: GPL-2.0
  Real Time Clock Periodic Interrupt test program
  Since commit 6610e0893b8bc ("RTC: Rework RTC code to use timerqueue for
  events"), PIE are completely handled using hrtimers, without actually using
  any underlying hardware RTC.
  This expects the new RTC class driver framework, working with
  clocks that will often not be clones of what the PC-AT had.
  Use the command line to specify another RTC if you need one.
 Read periodic IRQ rate 
 not all RTCs support periodic IRQs 
 The frequencies 128Hz, 256Hz, ... 8192Hz are only allowed for root. 
 not all RTCs can change their periodic IRQ rate 
 Enable periodic interrupts 
 This blocks 
 Disable periodic interrupts 
 valid adjtimex test
               by: John Stultz <john.stultz@linaro.org>
               (C) Copyright Linaro 2015
               Licensed under the GPLv2
   This test validates adjtimex interface with valid
   and invalid test data.
   Usage: valid-adjtimex
   To build:
 	$ gcc valid-adjtimex.c -o valid-adjtimex -lrt
    This program is free software: you can redistribute it andor modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 clear NTP time_status & time_state 
 Set the leap second insert flag 
 this case only applies to 64bit systems 
 reset freq to zero 
 Test valid values 
 Test invalid values 
 Leap second stress test
               by: John Stultz (john.stultz@linaro.org)
               (C) Copyright IBM 2012
               (C) Copyright 2013, 2015 Linaro Limited
               Licensed under the GPLv2
   This test signals the kernel to insert a leap second
   every day at midnight GMT. This allows for stressing the
   kernel's leap-second behavior, as well as how well applications
   handle the leap-second discontinuity.
   Usage: leap-a-day [-s] [-i <num>]
   Options:
 	-s:	Each iteration, set the date to 10 seconds before midnight GMT.
 		This speeds up the number of leapsecond transitions tested,
 		but because it calls settimeofday frequently, advancing the
 		time by 24 hours every ~16 seconds, it may cause application
 		disruption.
 	-i:	Number of iterations to run (default: infinite)
   Other notes: Disabling NTP prior to running this is advised, as the two
 		 may conflict in their commands to the kernel.
   To build:
 	$ gcc leap-a-day.c -o leap-a-day -lrt
    This program is free software: you can redistribute it andor modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 returns 1 if a <= b, 0 otherwise 
 clear NTP time_status & time_state 
	
	  We have to call adjtime twice here, as kernels
	  prior to 6b1859dba01c7 (included in 3.5 and
	  -stable), had an issue with the state machine
	  and wouldn't clear the STA_INSDEL flag directly.
 Clear maxerror, as it can cause UNSYNC to be set 
 Clear the status 
 Make sure we cleanup on ctrl-c 
 Test for known hrtimer failure 
 Process arguments 
 Make sure TAI support is present if -t was used 
 Set up timer signal handler: 
 Get the current time 
 Calculate the next possible leap second 23:59:60 GMT 
 Reset NTP time state 
 Set the leap second insert flag 
 Validate STA_INS was set 
 Set up timer 
 Wake up 3 seconds before leap 
 Validate STA_INS is still set 
 Check adjtimex output every half second 
remove trailing\n 
 Sleep for another half second 
 Switch to using other mode 
 Note if kernel has known hrtimer failure 
 set_timer latency test
 		John Stultz (john.stultz@linaro.org)
               (C) Copyright Linaro 2014
               Licensed under the GPLv2
    This test makes sure the set_timer api is correct
   To build:
 	$ gcc set-timer-lat.c -o set-timer-lat -lrt
    This program is free software: you can redistribute it andor modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 40ms in nanosecs 
 Set up timer: 
 Indicate timer isn't set, so caller doesn't wait 
 Unsupported case - return 0 to not fail the test 
 Unsupported case - return 0 to not fail the test 
 Set up signal handler: 
 Demo leapsecond deadlock
               by: John Stultz (john.stultz@linaro.org)
               (C) Copyright IBM 2012
               (C) Copyright 2013, 2015 Linaro Limited
               Licensed under the GPL
  This test demonstrates leapsecond deadlock that is possible
  on kernels from 2.6.26 to 3.3.
  WARNING: THIS WILL LIKELY HARD HANG SYSTEMS AND MAY LOSE DATA
  RUN AT YOUR OWN RISK!
   To build:
 	$ gcc leapcrash.c -o leapcrash -lrt
 clear NTP time_status & time_state 
	
	  We have to call adjtime twice here, as kernels
	  prior to 6b1859dba01c7 (included in 3.5 and
	  -stable), had an issue with the state machine
	  and wouldn't clear the STA_INSDEL flag directly.
 Make sure we cleanup on ctrl-c 
 Get the current time 
 Calculate the next possible leap second 23:59:60 GMT 
 set the time to 2 seconds before the leap 
 hammer on adjtime w STA_INS 
 Set the leap second insert flag 
 Measure nanosleep timer latency
               by: john stultz (john.stultz@linaro.org)
 		(C) Copyright Linaro 2013
               Licensed under the GPLv2
   To build:
 	$ gcc nsleep-lat.c -o nsleep-lat -lrt
    This program is free software: you can redistribute it andor modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 40ms in nanosecs 
 First check relative latency 
 Next check absolute latency 
 Skip cputime clockids since nanosleep won't increment cputime 
 SPDX-License-Identifier: GPL-2.0
  GPIO mockup cdev test helper
  Copyright (C) 2020 Kent Gibson
 SPDX-License-Identifier: GPL-2.0
  Memory Bandwidth Monitoring (MBM) test
  Copyright (C) 2018 Intel Corporation
  Authors:
     Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>,
     Fenghua Yu <fenghua.yu@intel.com>
	
	  Discard the first value which is inaccurate due to monitoring setup
	  transition phase.
 Run NUM_OF_RUNS times 
 Set up shemata with 100% allocation on the first run. 
 SPDX-License-Identifier: GPL-2.0
  Memory Bandwidth Allocation (MBA) test
  Copyright (C) 2018 Intel Corporation
  Authors:
     Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>,
     Fenghua Yu <fenghua.yu@intel.com>
  Change schemata percentage from 100 to 10%. Write schemata to specified
  con_mon grp, mon_grp in resctrl FS.
  For each allocation, run 5 times in order to get average values.
 Only set up schemata once every NUM_OF_RUNS of allocations 
 Memory bandwidth from 100% down to 10% 
		
		  The first run is discarded due to inaccurate value from
		  phase transition.
 Field 3 is perf imc value 
 Field 5 is resctrl value 
 SPDX-License-Identifier: GPL-2.0
  Memory bandwidth monitoring and allocation library
  Copyright (C) 2018 Intel Corporation
  Authors:
     Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>,
     Fenghua Yu <fenghua.yu@intel.com>
 The value of the event 
 if PERF_FORMAT_TOTAL_TIME_ENABLED 
 if PERF_FORMAT_TOTAL_TIME_RUNNING 
 if PERF_FORMAT_ID 
  get_event_and_umask:	Parse config into event and umask
  @cas_count_cfg:	Config
  @count:		iMC number
  @op:			Operation (readwrite)
 Get type and config (read and write) of an iMC counter 
 Get type of iMC counter 
 Get read config 
 Get write config 
  A system can have 'n' number of iMC (Integrated Memory Controller)
  counters, get that 'n'. For each iMC counter get it's type and config.
  Also, each counter has two configs, one for read and the other for write.
  A config again has two parts, event and umask.
  Enumerate all these details into an array of structures.
  Return: >= 0 on success. < 0 on failure.
			
			  imc counters are named as "uncore_imc_<n>", hence
			  increment the pointer to point to <n>. Note that
			  sizeof(UNCORE_IMC) would count for null character as
			  well and hence the last underscore character in
			  uncore_imc'_' need not be counted.
			
			  Some directories under "DYN_PMU_PATH" could have
			  names like "uncore_imc_free_running", hence, check if
			  first character is a numerical digit or not.
 Initialize perf_event_attr structures for all iMC's 
  get_mem_bw_imc:	Memory band width as reported by iMC counters
  @cpu_no:		CPU number that the benchmark PID is binded to
  @bw_report:		Bandwidth report type (reads, writes)
  Memory BW utilized by a process on a socket can be calculated using
  iMC counters. Perf events are used to read these counters.
  Return: = 0 on success. < 0 on failure.
 Start all iMC counters to log values (both read and write) 
 Stop counters after a second to get results (both read and write) 
	
	  Get results which are stored in struct type imc_counter_config
	  Take over flow into consideration before calculating total bw
  initialize_mem_bw_resctrl:	Appropriately populate "mbm_total_path"
  @ctrlgrp:			Name of the control monitor group (con_mon grp)
  @mongrp:			Name of the monitor group (mon grp)
  @cpu_no:			CPU number that the benchmark PID is binded to
  @resctrl_val:		Resctrl feature (Eg: mbm, mba.. etc)
  Get MBM Local bytes as reported by resctrl FS
  For MBM,
  1. If con_mon grp and mon grp are given, then read from con_mon grp's mon grp
  2. If only con_mon grp is given, then read from con_mon grp
  3. If both are not given, then read from root con_mon grp
  For MBA,
  1. If con_mon grp is given, then read from it
  2. If con_mon grp is not given, then read from root con_mon grp
  print_results_bw:	the memory bandwidth results are stored in a file
  @filename:		file that stores the results
  @bm_pid:		child pid that runs benchmark
  @bw_imc:		perf imc counter value
  @bw_resc:		memory bandwidth value
  Return:		0 on success. non-zero on failure.
  initialize_llc_occu_resctrl:	Appropriately populate "llc_occup_path"
  @ctrlgrp:			Name of the control monitor group (con_mon grp)
  @mongrp:			Name of the monitor group (mon grp)
  @cpu_no:			CPU number that the benchmark PID is binded to
  @resctrl_val:		Resctrl feature (Eg: cat, cmt.. etc)
	
	  Measure memory bandwidth from resctrl and from
	  another source which is perf imc value or could
	  be something else if perf imc event is not available.
	  Compare the two values to validate resctrl value.
	  It takes 1sec to measure the data.
  resctrl_val:	execute benchmark and measure memory bandwidth on
 			the benchmark
  @benchmark_cmd:	benchmark command and its arguments
  @param:		parameters passed to resctrl_val()
  Return:		0 on success. non-zero on failure.
	
	  If benchmark wasn't successfully started by child, then child should
	  kill parent, so save parent's pid
	
	  Fork to start benchmark, save child's pid so that it can be killed
	  when needed
		
		  Mask all signals except SIGUSR1, parent uses SIGUSR1 to
		  start benchmark
 Register for "SIGUSR1" signal from parent 
 Tell parent that child is ready 
 Suspend child until delivery of "SIGUSR1" from parent 
	
	  Register CTRL-C handler for parent, as it has to kill benchmark
	  before exiting
 Taskset benchmark to specified cpu 
 Write benchmark to specified control&monitoring grp in resctrl FS 
 Parent waits for child to be ready. 
 Signal child to start benchmark 
 Give benchmark enough time to fully run 
 Test runs until the callback setup() tells the test to stop. 
 SPDX-License-Identifier: GPL-2.0
  Resctrl tests
  Copyright (C) 2018 Intel Corporation
  Authors:
     Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>,
     Fenghua Yu <fenghua.yu@intel.com>
	
	  Typically we need root privileges, because:
	  1. We write to resctrl FS
	  2. We execute perf commands
 Detect AMD vendor 
 Extract benchmark command from command line. 
 If no benchmark is given by "-b" argument, use fill_buf. 
 SPDX-License-Identifier: GPL-2.0
  fill_buf benchmark
  Copyright (C) 2018 Intel Corporation
  Authors:
     Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>,
     Fenghua Yu <fenghua.yu@intel.com>
 mem size in cache llines 
 Consume read result so that reading memory is not optimized out. 
	
	  It's better to touch the memory once to avoid any compiler
	  optimizations
 Flush the memory before using to avoid "cache hot pages" effect 
 set up ctrl-c handler 
 SPDX-License-Identifier: GPL-2.0
 The number of events 
 The value of the event 
 Initialize perf_event_attr structures for HW_CACHE_MISSES 
 Start counters to log values 
  get_llc_perf:	llc cache miss through perf events
  @cpu_no:		CPU number that the benchmark PID is binded to
  Perf events like HW_CACHE_MISSES could be used to validate number of
  cache lines allocated.
  Return: =0 on success.  <0 on failure.
 Stop counters after one span to get miss rate 
  Get LLC Occupancy as reported by RESCTRL FS
  For CMT,
  1. If con_mon grp and mon grp given, then read from mon grp in
  con_mon grp
  2. If only con_mon grp given, then read from con_mon grp
  3. If both not given, then read from root con_mon grp
  For CAT,
  1. If con_mon grp given, then read from it
  2. If con_mon grp not given, then read from root con_mon grp
  Return: =0 on success.  <0 on failure.
  print_results_cache:	the cache results are stored in a file
  @filename:		file that stores the results
  @bm_pid:		child pid that runs benchmark
  @llc_value:		perf miss value 
 			llc occupancy value reported by resctrl FS
  Return:		0 on success. non-zero on failure.
	
	  Measure cache miss from perf.
	
	  Measure llc occupancy from resctrl.
  cache_val:		execute benchmark and measure LLC occupancy resctrl
  and perf cache miss for the benchmark
  @param:		parameters passed to cache_val()
  Return:		0 on success. non-zero on failure.
 Taskset benchmark to specified cpu 
 Write benchmark to specified con_mon grp, mon_grp in resctrl FS
 Test runs until the callback setup() tells the test to stop. 
  show_cache_info:	show cache test result information
  @sum_llc_val:	sum of LLC cache result data
  @no_of_bits:		number of bits
  @cache_span:		cache span in bytes for CMT or in lines for CAT
  @max_diff:		max difference
  @max_diff_percent:	max difference percentage
  @num_of_runs:	number of runs
  @platform:		show test information on this platform
  @cmt:		CMT test or CAT test
  Return:		0 on success. non-zero on failure.
 SPDX-License-Identifier: GPL-2.0
  Cache Allocation Technology (CAT) test
  Copyright (C) 2018 Intel Corporation
  Authors:
     Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>,
     Fenghua Yu <fenghua.yu@intel.com>
  Change schemata. Write schemata to specified
  con_mon grp, mon_grp in resctrl FS.
  Run 5 times in order to get average values.
 Run NUM_OF_RUNS times 
		
		  Discard the first value which is inaccurate due to monitoring
		  setup transition phase.
 Get default cbm mask for L3L2 cache 
 Get L3L2 cache size 
 Get max number of bits from default-cabm mask 
 Get core id from same socket for running another thread 
	 Set param values for parent thread which will be allocated bitmask
	  with (max_bits - n) bits
	 Set param values for child thread which will be allocated bitmask
	  with n bits
 Tell parent that child is ready 
 Parent waits for child to be ready. 
 SPDX-License-Identifier: GPL-2.0
  Basic resctrl file system operations
  Copyright (C) 2018 Intel Corporation
  Authors:
     Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>,
     Fenghua Yu <fenghua.yu@intel.com>
  remount_resctrlfs - Remount resctrl FS at sysfsresctrl
  @mum_resctrlfs:	Should the resctrl FS be remounted?
  If not mounted, mount it.
  If mounted and mum_resctrlfs then remount resctrl FS.
  If mounted and !mum_resctrlfs then noop
  Return: 0 on success, non-zero on failure
  get_resource_id - Get socket numberl3 id for a specified CPU
  @cpu_no:	CPU number
  @resource_id: Socket number or l3_id
  Return: >= 0 on success, < 0 on failure.
  get_cache_size - Get cache size for a specified CPU
  @cpu_no:	CPU number
  @cache_type:	Cache level L2L3
  @cache_size:	pointer to cache_size
  Return: = 0 on success, < 0 on failure.
  get_cbm_mask - Get cbm mask for given cache
  @cache_type:	Cache level L2L3
  @cbm_mask:	cbm_mask returned as a string
  Return: = 0 on success, < 0 on failure.
  get_core_sibling - Get sibling core id from the same socket for given CPU
  @cpu_no:	CPU number
  Return:	> 0 on success, < 0 on failure.
 Skipping core 0 as we don't want to run test on core 0 
  taskset_benchmark - Taskset PID (i.e. benchmark) to a specified cpu
  @bm_pid:	PID that should be binded
  @cpu_no:	CPU number at which the PID would be binded
  Return: 0 on success, non-zero on failure
  run_benchmark - Run a specified benchmark or fill_buf (default benchmark)
 		   in specified signal. Direct benchmark stdio to devnull.
  @signum:	signal number
  @info:	signal info
  @ucontext:	user context in signal handling
  Return: void
	
	  Direct stdio of child to devnull, so that only parent writes to
	  stdio (console)
 Execute default fill_buf benchmark 
 Execute specified benchmark 
  create_grp - Create a group only if one doesn't exist
  @grp_name:	Name of the group
  @grp:	Full path and name of the group
  @parent_grp:	Full path and name of the parent group
  Return: 0 on success, non-zero on failure
	
	  At this point, we are guaranteed to have resctrl FS mounted and if
	  length of grp_name == 0, it means, user wants to use root con_mon
	  grp, so do nothing
 Check if requested grp exists or not 
 Requested grp doesn't exist, hence create it 
  write_bm_pid_to_resctrl - Write a PID (i.e. benchmark) to resctrl FS
  @bm_pid:		PID that should be written
  @ctrlgrp:		Name of the control monitor group (con_mon grp)
  @mongrp:		Name of the monitor group (mon grp)
  @resctrl_val:	Resctrl feature (Eg: mbm, mba.. etc)
  If a con_mon grp is requested, create it and write pid to it, otherwise
  write pid to root con_mon grp.
  If a mon grp is requested, create it and write pid to it, otherwise
  pid is not written, this means that pid is in con_mon grp and hence
  should consult con_mon grp's mon_data directory for results.
  Return: 0 on success, non-zero on failure
 Create control and monitoring group and write pid into it 
 Create mon grp and write pid into it for "mbm" and "cmt" test 
  write_schemata - Update schemata of a con_mon grp
  @ctrlgrp:		Name of the con_mon grp
  @schemata:		Schemata that should be updated to
  @cpu_no:		CPU number that the benchmark PID is binded to
  @resctrl_val:	Resctrl feature (Eg: mbm, mba.. etc)
  Update schemata of a con_mon grp only if requested resctrl feature is
  allocation type
  Return: 0 on success, non-zero on failure
  validate_resctrl_feature_request - Check if requested feature is valid.
  @resctrl_val:	Requested feature
  Return: True if the feature is supported, else false
 SPDX-License-Identifier: GPL-2.0
  Cache Monitoring Technology (CMT) test
  Copyright (C) 2018 Intel Corporation
  Authors:
     Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>,
     Fenghua Yu <fenghua.yu@intel.com>
 Run NUM_OF_RUNS times 
 Field 3 is llc occ resc value 
 SPDX-License-Identifier: GPL-2.0
  vdso_full_test.c: Sample code to test all the timers.
  Copyright (c) 2019 Arm Ltd.
  Compile with:
  gcc -std=gnu99 vdso_full_test.c parse_vdso.c
 Find gettimeofday. 
 Find clock_gettime. 
 Find time. 
 Find clock_getres. 
  This function calls vdso_test_clock_gettime and vdso_test_clock_getres
  with different values for clock_id.
 A skipped test is considered passed 
 A skipped test is considered passed 
 SPDX-License-Identifier: GPL-2.0-only
  vdso_test.c: Sample code to test parse_vdso.c on x86
  Copyright (c) 2011-2014 Andy Lutomirski
  You can amuse yourself by compiling with:
  gcc -std=gnu99 -nostdlib
      -Os -fno-asynchronous-unwind-tables -flto -lgcc_s
       vdso_standalone_test_x86.c parse_vdso.c
  to generate a small binary.  On x86_64, you can omit -lgcc_s
  if you want the binary to be completely standalone.
 We need a libc functions... 
 This implementation is buggy: it never returns -1. 
 ...and two syscalls.  This is x86-specific. 
 Parse the stack 
 Now we're pointing at the environment.  Skip it. 
 Now we're pointing at auxv.  Initialize the vDSO parser. 
 Find gettimeofday. 
  This is the real entry point.  It passes the initial stack into
  the C entry point.
 SPDX-License-Identifier: GPL-2.0-only
  vdso_test_gettimeofday.c: Sample code to test parse_vdso.c and
                            vDSO gettimeofday()
  Copyright (c) 2014 Andy Lutomirski
  Compile with:
  gcc -std=gnu99 vdso_test_gettimeofday.c parse_vdso_gettimeofday.c
  Tested on x86, 32-bit and 64-bit.  It may work on other architectures, too.
  ARM64's vDSO exports its gettimeofday() implementation with a different
  name and version from other architectures, so we need to handle it as
  a special case.
 Find gettimeofday. 
 SPDX-License-Identifier: GPL-2.0
  ldt_gdt.c - Test cases for LDT and GDT access
  Copyright (c) 2011-2015 Andrew Lutomirski
 max length of lines in procselfmaps - anything longer is skipped here 
 might still be present, but ignore it here, as we test vDSO not vsyscall 
 sscanf() is safe here as strlen(name) >= strlen(line) 
 assume entries are OK, as we test vDSO here not vsyscall 
 Also test some invalid clock ids 
 Also test some invalid clock ids 
 And make sure that passing NULL for tz doesn't crash. 
	
	  Test getcpu() last so that, if something goes wrong setting affinity,
	  we still run the other tests.
 SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
  vdso_clock_getres.c: Sample code to test clock_getres.
  Copyright (c) 2019 Arm Ltd.
  Compile with:
  gcc -std=gnu99 vdso_clock_getres.c
  Tested on ARM, ARM64, MIPS32, x86 (32-bit and 64-bit),
  Power (32-bit and 64-bit), S390x (32-bit and 64-bit).
  Might work on other architectures.
  This function calls clock_getres in vdso and by system call
  with different values for clock_id.
  Example of output:
  clock_id: CLOCK_REALTIME [PASS]
  clock_id: CLOCK_BOOTTIME [PASS]
  clock_id: CLOCK_TAI [PASS]
  clock_id: CLOCK_REALTIME_COARSE [PASS]
  clock_id: CLOCK_MONOTONIC [PASS]
  clock_id: CLOCK_MONOTONIC_RAW [PASS]
  clock_id: CLOCK_MONOTONIC_COARSE [PASS]
 SPDX-License-Identifier: GPL-2.0-only
  vdso_test_getcpu.c: Sample code to test parse_vdso.c and vDSO getcpu()
  Copyright (c) 2020 Arm Ltd
  parse_vdso.c: Linux reference vDSO parser
  Written by Andrew Lutomirski, 2011-2014.
  This code is meant to be linked in to various programs that run on Linux.
  As such, it is available with as few restrictions as possible.  This file
  is licensed under the Creative Commons Zero License, version 1.0,
  available at http:creativecommons.orgpublicdomainzero1.0legalcode
  The vDSO is a regular ELF DSO that the kernel maps into user space when
  it starts a program.  It works equally well in statically and dynamically
  linked binaries.
  This code is tested on x86.  In principle it should work on any
  architecture that has a vDSO.
 And here's the code. 
 Load information 
 load_addr - recorded vaddr 
 Symbol table 
 Version table 
 Straight from the ELF specification. 
 Wrong ELF class -- check ELF_BITS 
	
	  We need two things from the segment table: the load offset
	  and the dynamic table.
 Failed 
	
	  Fish out the useful bits of the dynamic table.
 Failed 
 Parse the hash table header. 
 That's all we need. 
	
	  This is a helper function to check if the version indexed by
	  ver matches name (which hashes to hash).
	 
	  The version definition table is a mess, and I don't know how
	  to do this in better than linear time without allocating memory
	  to build an index.  I also don't know why the table has
	  variable size entries in the first place.
	 
	  For added fun, I can't find a comprehensible specification of how
	  to parse all the weird flags in the table.
	 
	  So I just parse the whole table every time.
 First step: find the version definition 
 Apparently bit 15 means "hidden" 
 No definition. 
 Now figure out whether it matches. 
 Check for a defined global or weak function w right name. 
 Check symbol version. 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Functions needed from modify_srcu.c 
 Simpler implementation of synchronize_srcu that ignores batching. 
	
	  This code assumes that try_check_zero will succeed anyway,
	  so there is no point in multiple tries.
 Ignore the lock, as multiple writers aren't working yet anyway. 
 For comments see srcu_advance_batches. 
 SPDX-License-Identifier: GPL-2.0
 Support NR_CPUS of at most 64 
  Simulate disabling preemption by locking a particular cpu. NR_CPUS
  should be the actual number of cpus, not just the maximum.
 SPDX-License-Identifier: GPL-2.0
 Include all source files. 
 Used by test.c files 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0+
 Remove a file, ignoring the result if it didn't exist. 
 for mknod() 
 devloop0 
 devzero 
 S_IFSOCK 
  Copyright (c) 2019 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 Test that pointing #! script interpreter to self doesn't recurse. 
 Require "exec" filesystem. 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 Google, Inc.
  Selftests for execveat(2).
 to get O_PATH, AT_EMPTY_PATH 
 Child: do execveat(). 
 should not reach here 
 Parent: wait for & check child's exit status. 
 Create a filename close to PATH_MAX in length 
	
	  Execute as a pre-opened file descriptor, which works whether this is
	  a script or not (because the interpreter sees a filename like
	  "devfd20").
	
	  Execute as a long pathname relative to "".  If this is a script,
	  the interpreter will launch but fail to open the script because its
	  name ("devfd5xxx....") is bigger than PATH_MAX.
	 
	  The failure code is usually 127 (POSIX: "If a command is not found,
	  the exit status shall be 127."), but some systems give 126 (POSIX:
	  "If the command name is found, but it is not an executable utility,
	  the exit status shall be 126."), so allow either.
 Check if we have execveat at all, and bail early if not 
 Change file position to confirm it doesn't affect anything 
 Normal executable file: 
   dfd + path 
   absolute path 
   absolute path with nonsense dfd 
   fd + no path 
   O_CLOEXEC fd + no path 
   O_PATH fd 
 Mess with executable file that's already open: 
   fd + no path to a file that's been renamed 
   fd + no path to a file that's been deleted 
 remove the file now fd open 
 Mess with executable file that's already open with O_PATH 
   fd + no path to a file that's been deleted 
 Invalid argument failures 
 Symlink to executable file: 
   dfd + path 
   absolute path 
   fd + no path, even with AT_SYMLINK_NOFOLLOW (already followed) 
 Symlink fails when AT_SYMLINK_NOFOLLOW set: 
   dfd + path 
   absolute path 
  Non-regular file failure 
 Shell script wrapping executable file: 
   dfd + path 
   absolute path 
   fd + no path 
   O_CLOEXEC fd fails for a script (as script file inaccessible) 
 Mess with script file that's already open: 
   fd + no path to a file that's been renamed 
   fd + no path to a file that's been deleted 
 remove the file while fd open 
 Rename a subdirectory in the path: 
 Remove the subdir and its contents 
 Shell loads via deleted subdir OK because name starts with .. 
 Flag values other than AT_SYMLINK_NOFOLLOW => EINVAL 
 Invalid path => ENOENT 
 Attempt to execute directory => EACCES 
 Attempt to execute non-executable => EACCES 
 Attempt to execute nonsense FD => EBADF 
 Attempt to execute relative to non-directory => ENOTDIR 
 Create ephemeral copies of files 
 If we are invoked with an argument, don't run tests. 
 Check expected environment transferred. 
 Use the final argument as an exit code. 
 SPDX-License-Identifier: GPL-2.0-only
 Ignore headers from other than the executable.
 Terminate dl_iterate_phdr.
 SPDX-License-Identifier: GPL-2.0
 Do not follow symlinks 
 Do not follow symlinks 
 SPDX-License-Identifier: GPL-2.0
 parent 
 system("cat procselfmounts"); 
 system("cat procselfmounts"); 
 parent 
 system("cat procselfmounts"); 
 SPDX-License-Identifier: GPL-2.0
 Test triggering of loading of firmware from different mount
  namespaces. Expect firmware to be always loaded from the mount
 parent 
	 Mount tmpfs to libfirmware so we don't have to assume
 Positive case: firmware in PID1 mount namespace 
 Negative case: firmware in child mount namespace, expected to fail 
 SPDX-License-Identifier: GPL-2.0
  Watchdog Driver Test Program
  This function simply sends an IOCTL to the driver, which in turn ticks
  the PC Watchdog card to reset its internal timer so it doesn't trigger
  a computer reset.
  The main program.  Run the program with "-d" to disable the card,
  or "-e" to enable the card.
	
	  Validate that `file` is a watchdog device
 Handled above 
			
			  watchdog_info was obtained as part of file open
			  validation. So we just show it here.
 SPDX-License-Identifier: GPL-2.0
  memfd GUP test-case
  This tests memfd interactions with get_user_pages(). We require the
  fuse_mnt.c program to provide a fake direct-IO FUSE mount-point for us. This
  file-system delays _all_ reads by 1s and forces direct-IO. This means, any
  read() on files in that file-system will pin the receive-buffer pages for at
  least 1s via get_user_pages().
  We use this trick to race ADD_SEALS against a write on a memfd object. The
  ADD_SEALS must fail if the memfd pages are still pinned. Note that we use
  the read() syscall with our memory-mapped memfd object as receive buffer to
  force the kernel to write into our memfd object.
	
	  This thread first waits 200ms so any pending operation in the parent
	  is correctly started. After that, it tries to seal @global_mfd as
	  SEAL_WRITE. This _must_ fail as the parent thread has a read() into
	  that memory mapped object still ongoing.
	  We then wait one more second and try sealing again. This time it
	  must succeed as there shouldn't be anyone else pinning the pages.
 wait 200ms for FUSE-request to be active 
 unmount mapping before sealing to avoid i_mmap_writable failures 
	 Try sealing the global file; expect EBUSY or success. Current
	  kernels will never succeed, but in the future, kernels might
	  implement page-replacements or other fancy ways to avoid racing
 wait 1s more so the FUSE-request is done 
 try sealing the global file again 
 open FUSE memfd file for GUP testing 
 create new memfd-object 
 mmap memfd-object for writing 
	 pass mfd+mapping to a separate sealing-thread which tries to seal
	 Use read() on the FUSE file to read into our memory-mapped memfd
	  object. This races the other thread which tries to seal the
	  memfd-object.
	  If @fd is on the memfd-fake-FUSE-FS, the read() is delayed by 1s.
	  This guarantees that the receive-buffer is pinned for 1s until the
	  data is written into it. The racing ADD_SEALS should thus fail as
	 Wait for sealing-thread to finish and verify that it
	 IF the memfd-object was sealed at the time our read() returned,
	  then the kernel did a page-replacement or canceled the read() (or
	  whatever magic it did..). In that case, the memfd object is still
	  all zero.
	  In case the memfd-object was not sealed, the read() was successfull
	  and the memfd object must not be all zero.
	  Note that in real scenarios, there might be a mixture of both, but
	  in this test-cases, we have explicit 200ms delays which should be
 SPDX-License-Identifier: GPL-2.0
  memfd test file-system
  This file uses FUSE to create a dummy file-system with only one file memfd.
  This file is read-only and takes 1s per read.
  This file-system is used by the memfd test-cases to force the kernel to pin
  pages during reads(). Due to the 1s delay of this file-system, this is a
  nice way to test race-conditions against get_user_pages() in the kernel.
  We use direct_io==1 to force the kernel to use direct-IO for this
  file-system.
 force direct-IO 
 SPDX-License-Identifier: GPL-2.0
  Copied from mlock2-tests.c
 SPDX-License-Identifier: GPL-2.0
  Default is not to test hugetlbfs
 verify PROT_READ is allowed 
 verify MAP_PRIVATE is always allowed (even writable) 
 Test that PROT_READ + MAP_SHARED mappings work. 
 verify PROT_READ and MAP_SHARED is allowed 
	
	  huegtlbfs does not support write, but we want to
	  verify everything else here.
 verify write() succeeds 
 verify PROT_READ | PROT_WRITE is allowed 
 verify PROT_WRITE is allowed 
	 verify PROT_READ with MAP_SHARED is allowed and a following
 verify PUNCH_HOLE works 
 verify write() fails 
 verify PROT_READ | PROT_WRITE is not allowed 
 verify PROT_WRITE is not allowed 
	 Verify PROT_READ with MAP_SHARED with a following mprotect is not
 verify PUNCH_HOLE fails 
 hugetlbfs does not support write 
 hugetlbfs does not support write 
 dummy waiter; SIGTERM terminates us anyway 
  Test memfd_create() syscall
  Verify syscall-argument validation, including name checks, flag validation
  and more.
 test NULL name 
 test over-long name (not zero-terminated) 
 test over-long zero-terminated name 
 verify "" is a valid name 
 verify invalid O_ open flags 
 verify MFD_CLOEXEC is allowed 
 verify MFD_ALLOW_SEALING is allowed 
 verify MFD_ALLOW_SEALING | MFD_CLOEXEC is allowed 
  Test basic sealing
  A very basic sealing test to see whether settingretrieving seals works.
 add basic seals 
 add them again 
 add more seals and seal against sealing 
 verify that sealing no longer works 
 verify sealing does not work without MFD_ALLOW_SEALING 
  Test SEAL_WRITE
  Test whether SEAL_WRITE actually prevents modifications.
  Test SEAL_FUTURE_WRITE
  Test whether SEAL_FUTURE_WRITE actually prevents modifications.
 read should pass, writes should fail 
 read should pass, writes should still fail 
  Test SEAL_SHRINK
  Test whether SEAL_SHRINK actually prevents shrinking
  Test SEAL_GROW
  Test whether SEAL_GROW actually prevents growing
  Test SEAL_SHRINK | SEAL_GROW
  Test whether SEAL_SHRINK | SEAL_GROW actually prevents resizing
  Test sharing via dup()
  Test that seals are shared between dupped FDs and they're all equal.
  Test sealing with active mmap()s
  Modifying seals is only allowed if no other mmap() refs exist.
 sharedwritable ref prevents sealing WRITE, but allows others 
 readable ref allows sealing 
  Test sealing with open(procselffd%d)
  Via proc we can get access to a separate file-context for the same memfd.
  This is not like dup(), but like a real separate open(). Make sure the
  semantics are as expected and we correctly check for RDONLY  WRONLY  RDWR.
  Test sharing via fork()
  Test whether seal-modifications work as expected with forked childs.
	 Run test-suite in a multi-threaded environment with a shared
 SPDX-License-Identifier: GPL-2.0+
 This testcase operates with the test_fpu kernel driver.
  It modifies the FPU control register in user mode and calls the kernel
  module to perform floating point operations in the kernel. The control
  register value should be independent between kernel and user mode.
	 Note: the tests up to this point are quite safe and will only return
	  an error. But the exception mask setting can cause misbehaving kernel
	  to crash.
 SPDX-License-Identifier: GPL-2.0
 test ir decoder
 Copyright (C) 2018 Sean Young <sean@mess.org>
 When sending LIRC_MODE_SCANCODE, the IR will be encoded. rc-loopback
 will send this IR to the receiver side, where we try to read the decoded
 IR. Decoding happens in a separate kernel thread, so we will need to
 wait until that is scheduled, hence we use poll to check for read
 readiness.
RESULT=`echo $RESULT | sed -e 's. \((.)\) \((.)\) .\1 \2'`
'`
"`
    cat trace | grep -v '^#' | sed -e 's[^-]-\([0-9]\).\1' | grep $pid | wc -l
}
count_no_pid() {
    pid=$1
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2020 HiSilicon Limited.
 average map latency in 100ns 
 standard deviation of map latency 
 as above 
 how many threads will do mapunmap in parallel 
 how long the test will last 
 which numa node this benchmark will run on 
 DMA addressing capability 
 DMA data direction 
 time for DMA transmission in ns 
 how many PAGE_SIZE will do mapunmap once a time 
 For future use 
 default single thread, run 20 seconds on NUMA_NO_NODE 
 default dma mask 32bit, bidirectional DMA 
 default granule 1 PAGESIZE 
 suppose the mininum DMA zone is 1MB in the world 
 SPDX-License-Identifier: GPL-2.0
  Landlock tests - Common user space base
  Copyright  2017-2020 Mickal Salan <mic@digikod.net>
  Copyright  2019-2020 ANSSI
 Checks copy_from_user(). 
 The size if less than sizeof(struct landlock_attr_enforce). 
 The size if less than sizeof(struct landlock_attr_enforce). 
 Checks non-zero value. 
 Similar to struct landlock_path_beneath_attr.parent_fd = 0 
 Tests enforcement of a ruleset FD transferred through a UNIX socket. 
 Aligned ancillary data buffer. 
 Creates a test ruleset with a simple rule. 
 Sends the ruleset FD over a socketpair and then close it. 
 Enforces the received ruleset on the child. 
 Checks that the ruleset enforcement. 
 Checks that the parent is unrestricted. 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  Landlock tests - Filesystem
  Copyright  2017-2020 Mickal Salan <mic@digikod.net>
  Copyright  2020 ANSSI
  Copyright  2020-2021 Microsoft Corporation
 Paths (sibling number and depth) 
 dir_s3d2 is a mount point. 
  layout1 hierarchy:
  tmp
   s1d1
    f1
    f2
    s1d2
        f1
        f2
        s1d3
            f1
            f2
   s2d1
    f1
    s2d2
        f1
        s2d3
            f1
            f2
   s3d1
       s3d2
           s3d3
	
	  Do not pollute the rest of the system: creates a private mount point
	  for tests relying on pivot_root(2) and move_mount(2).
  This helper enables to use the ASSERT_ macros and print the line number
  pointing to the test caller.
 Works with file and directories. 
	
	  Mixing error codes from close(2) and open(2) should not lead to any
	  (access type) confusion for this test.
 Returns EBADF because ruleset_fd is not a landlock-ruleset FD. 
 Returns EBADFD because ruleset_fd is not a valid ruleset. 
 Gets a real ruleset. 
 Tests without O_PATH. 
 Tests with a ruleset FD. 
 Checks unhandled allowed_access. 
 Test with legitimate values. 
 Test with unknown (64-bits) value. 
 Test with no access. 
 Enforces the ruleset. 
 Tests access rights for files. 
	
	  Because nsfs is an internal filesystem, procselfnsmnt is a
	  disconnected path.  Such path cannot be identified and must then be
	  allowed.
	
	  Checks that it is not possible to add nsfs-like filesystem
	  references to a ruleset.
 enforce_ruleset() calls prctl(no_new_privs). 
 Tests on a directory. 
 Tests on a file. 
 Checks effective read and write actions. 
 Just in case, double-checks effective actions. 
 Here, we only handle read accesses, not write accesses. 
	
	  Because the policy does not handle LANDLOCK_ACCESS_FS_WRITE_FILE,
	  opening for write-only should be allowed, but not read-write.
 These rules should be ORed among them. 
 Checks s1d1 hierarchy. 
 Checks s1d2 hierarchy. 
 Checks s1d3 hierarchy. 
 Unchanged accesses for file creation. 
 Checks file removing. 
	
	  Checks overly restrictive rules:
	  layer 1: allows R   s1d1s1d2s1d3file1
	  layer 2: allows RW  s1d1s1d2s1d3
	           allows  W  s1d1s1d2
	           denies R   s1d1s1d2
	  layer 3: allows R   s1d1
	  layer 4: allows R   s1d1s1d2
	           denies  W  s1d1s1d2
	  layer 5: allows R   s1d1s1d2
	  layer 6: allows   X ----
	  layer 7: allows  W  s1d1s1d2
	           denies R   s1d1s1d2
 Allows read access to file1_s1d3 with the first layer. 
 First rule with write restrictions. 
 Start by granting read-write access via its parent directory... 
 ...but also denies read access via its grandparent directory. 
 Allows read access via its great-grandparent directory. 
		
		  Try to confuse the deny access by denying write (but not
		  read) access via its grandparent directory.
		
		  Try to override layer2's deny read access by explicitly
		  allowing read access via file1_s1d3's grandparent.
		
		  Restricts an unrelated file hierarchy with a new access
		  (non-overlapping) type.
		
		  Finally, denies read access to file1_s1d3 via its
		  grandparent.
 Checks that read access is granted for file1_s1d3 with layer 1. 
 Checks that previous access rights are unchanged with layer 2. 
 Checks that previous access rights are unchanged with layer 3. 
 This time, denies write access for the file hierarchy. 
	
	  Checks that the only change with layer 4 is that write access is
	  denied.
 Checks that previous access rights are unchanged with layer 5. 
 Checks that previous access rights are unchanged with layer 6. 
 Checks read access is now denied with layer 7. 
 Write access is forbidden. 
 Readdir access is allowed. 
 Write access is forbidden. 
 Readdir access is allowed. 
	
	  Tests shared rule extension: the following rules should not grant
	  any new access, only remove some.  Once enforced, these rules are
	  ANDed with the previous ones.
	
	  According to ruleset_fd, dir_s1d2 should now have the
	  LANDLOCK_ACCESS_FS_READ_FILE and LANDLOCK_ACCESS_FS_WRITE_FILE
	  access rights (even if this directory is opened a second time).
	  However, when enforcing this updated ruleset, the ruleset tied to
	  the current process (i.e. its domain) will still only have the
	  dir_s1d2 with LANDLOCK_ACCESS_FS_READ_FILE and
	  LANDLOCK_ACCESS_FS_READ_DIR accesses, but
	  LANDLOCK_ACCESS_FS_WRITE_FILE must not be allowed because it would
	  be a privilege escalation.
 Same tests and results as above. 
 It is still forbidden to write in file1_s1d2. 
 Readdir access is still allowed. 
 It is still forbidden to write in file1_s1d3. 
 Readdir access is still allowed. 
	
	  Try to get more privileges by adding new access rights to the parent
	  directory: dir_s1d1.
 Same tests and results as above. 
 It is still forbidden to write in file1_s1d2. 
 Readdir access is still allowed. 
 It is still forbidden to write in file1_s1d3. 
 Readdir access is still allowed. 
	
	  Now, dir_s1d3 get a new rule tied to it, only allowing
	  LANDLOCK_ACCESS_FS_WRITE_FILE.  The (kernel internal) difference is
	  that there was no rule tied to it before.
	
	  Same tests and results as above, except for open(dir_s1d3) which is
	  now denied because the new rule mask the rule previously inherited
	  from dir_s1d2.
 Same tests and results as above. 
 It is still forbidden to write in file1_s1d2. 
 Readdir access is still allowed. 
 It is still forbidden to write in file1_s1d3. 
	
	  Readdir of dir_s1d3 is still allowed because of the OR policy inside
	  the same layer.
 Readdir access is denied for dir_s1d2. 
 Readdir access is allowed for dir_s1d3. 
 File access is allowed for file1_s1d3. 
 Now dir_s1d2, parent of dir_s1d3, gets a new rule tied to it. 
 Readdir access is still denied for dir_s1d2. 
 Readdir access is still allowed for dir_s1d3. 
 File access is still allowed for file1_s1d3. 
 Tests empty handled_access_fs. 
 Enforces policy which deny read access to all files. 
 Nests a policy which deny read access to all directories. 
 Enforces a second time with the same ruleset. 
 dir_s3d2 is a mount point. 
 dir_s3d2 is a mount point. 
  This test verifies that we can apply a landlock rule on the root directory
  (which might require special handling).
 Checks allowed access. 
 Checks denied access (on a directory). 
 Checks denied access (on a directory). 
 Unmount a file hierarchy while it is being used by a ruleset. 
 This dir_s3d3 would not be allowed and does not exist anyway. 
	
	  Common layer to check that chroot doesn't ignore it (i.e. a chroot
	  is not a disconnected root directory).
 Do chroot into dir_s1d2 (relative to dir_s2d2). 
 Do chroot into dir_s1d2. 
 The current directory is dir_s2d2. 
 The current directory is dir_s1d2. 
 Checks the root dir_s1d2. 
 Denies linking because of reparenting. 
	
	  Tries to replace a file, from a directory that allows file removal,
	  but to a different directory (which also allows file removal).
	
	  Tries to replace a file, from a directory that denies file removal,
	  to a different directory (which allows file removal).
 Exchanges files and directories that partially allow removal. 
 Renames files with different parents. 
 Exchanges and renames files with same parent. 
 Exchanges files and directories with same parent, twice. 
 Empties dir_s1d3 to allow renaming. 
 Exchanges and renames directory to a different parent. 
	
	  Exchanges directory to the same parent, which doesn't allow
	  directory removal.
	
	  Exchanges and renames directory to the same parent, which allows
	  directory removal.
 dir_s1d2 itself cannot be removed. 
 Creates a devnull device. 
 Creates a devloop0 device. 
 Uses file_ as directory names. 
 Limits read and write access to files tied to the filesystem. 
 Checks enforcement for normal files. 
 Checks access to pipes through FD. 
 Checks write access to pipe through procselffd . 
 Checks read access to pipe through procselffd . 
  layout1_bind hierarchy:
  tmp
   s1d1
    f1
    f2
    s1d2
        f1
        f2
        s1d3
            f1
            f2
   s2d1
    f1
    s2d2
        f1
        f2
        s1d3
            f1
            f2
   s3d1
       s3d2
           s3d3
	
	  Sets access right on parent directories of both source and
	  destination mount points.
	
	  Sets access rights on the same bind-mounted directories.  The result
	  should be ACCESS_RW for both directories, but not both hierarchies
	  because of the first layer.
 Only allow read-access to the s1d3 hierarchies. 
 Removes all access rights. 
 Sets rules for the parent directories. 
 Checks source hierarchy. 
 Checks destination hierarchy. 
 Sets rules for the mount points. 
 Checks source hierarchy. 
 Checks destination hierarchy. 
 Sets a (shared) rule only on the source. 
 Checks source hierarchy. 
 Checks destination hierarchy. 
 Sets a (shared) rule only on the destination. 
 Checks source hierarchy. 
 Checks destination hierarchy. 
  layout2_overlay hierarchy:
  tmp
   lower
    data
        dl1
         fl2
        do1
         fl3
         fo2
        fl1
        fo1
   merge
    data
        dl1
         fl2
        do1
         fl3
         fo2
         fu3
        du1
         fu2
        fl1
        fo1
        fu1
   upper
       data
        do1
         fo2
         fu3
        du1
         fu2
        fo1
        fu1
       work
           work
 Creates tmpfs mount points to get deterministic overlayfs. 
 Sets access right on parent directories of both layers. 
 Sets access right on directories inside both layers. 
 Tighten access rights to the files. 
 Sets rules on base directories (i.e. outside overlay scope). 
 Checks lower layer. 
 Checks upper layer. 
	
	  Checks that access rights are independent from the lower and upper
	  layers: write access to upper files viewed through the merge point
	  is still allowed, and write access to lower file viewed (and copied)
	  through the merge point is still allowed.
 Sets rules on data directories (i.e. inside overlay scope). 
 Checks merge. 
 Same checks with tighter rules. 
 Checks changes for lower layer. 
 Checks changes for upper layer. 
 Checks all merge accesses. 
 Sets rules directly on overlayed files. 
 Checks unchanged accesses on lower layer. 
 Checks unchanged accesses on upper layer. 
 Checks all merge accesses. 
 Only allowes access to the merge hierarchy. 
 Checks new accesses on lower layer. 
 Checks new accesses on upper layer. 
 Checks all merge accesses. 
 SPDX-License-Identifier: GPL-2.0
  Landlock tests - Ptrace
  Copyright  2017-2020 Mickal Salan <mic@digikod.net>
  Copyright  2019-2020 ANSSI
	
	  Mixing error codes from close(2) and open(2) should not lead to any
	  (access type) confusion for this test.
  Test multiple tracing combinations between a parent process P1 and a child
  process P2.
  Yama's scoped ptrace is presumed disabled.  If enabled, this optional
  restriction is enforced in addition to any Landlock check, which means that
  all P2 requests to trace P1 would be denied.
         No domain
    P1-.               P1 -> P2 : allow
        \              P2 -> P1 : allow
         'P2
         Child domain
    P1--.              P1 -> P2 : allow
         \             P2 -> P1 : deny
         .'-----.
         |  P2  |
         '------'
         Parent domain
  .------.
  |  P1  --.           P1 -> P2 : deny
  '------'  \          P2 -> P1 : allow
             '
             P2
         Parent + child domain (siblings)
  .------.
  |  P1  ---.          P1 -> P2 : deny
  '------'   \         P2 -> P1 : deny
          .---'--.
          |  P2  |
          '------'
          Same domain (inherited)
  .-------------.
  | P1----.     |      P1 -> P2 : allow
  |        \    |      P2 -> P1 : allow
  |         '   |
  |         P2  |
  '-------------'
          Inherited + child domain
  .-----------------.
  |  P1----.        |  P1 -> P2 : allow
  |         \       |  P2 -> P1 : deny
  |        .-'----. |
  |        |  P2  | |
  |        '------' |
  '-----------------'
          Inherited + parent domain
  .-----------------.
  |.------.         |  P1 -> P2 : deny
  ||  P1  ----.     |  P2 -> P1 : allow
  |'------'    \    |
  |             '   |
  |             P2  |
  '-----------------'
          Inherited + parent and child domain (siblings)
  .-----------------.
  | .------.        |  P1 -> P2 : deny
  | |  P1  .        |  P2 -> P1 : deny
  | '------'\       |
  |          \      |
  |        .--'---. |
  |        |  P2  | |
  |        '------' |
  '-----------------'
 Test PTRACE_TRACEME and PTRACE_ATTACH for parent and child. 
	
	  Removes all effective and permitted capabilities to not interfere
	  with cap_ptrace_access_check() in case of PTRACE_MODE_FSCREDS.
 Aborts before forking. 
 Waits for the parent to be in a domain, if any. 
 Tests PTRACE_ATTACH and PTRACE_MODE_READ on the parent. 
 Tests child PTRACE_TRACEME. 
		
		  Signals that the PTRACE_ATTACH test is done and the
		  PTRACE_TRACEME test is ongoing.
 Waits for the parent PTRACE_ATTACH test. 
 Signals that the parent is in a domain, if any. 
	
	  Waits for the child to test PTRACE_ATTACH on the parent and start
	  testing PTRACE_TRACEME.
 Tests child PTRACE_TRACEME. 
 The child should not be traced by the parent. 
 Tests PTRACE_ATTACH and PTRACE_MODE_READ on the child. 
 Signals that the parent PTRACE_ATTACH test is done. 
 SPDX-License-Identifier: GPL-2.0
 skip unsupported attribute in user-space 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2013-2015, Michael Ellerman, IBM Corp.
 For CPU_ZERO etc. 
 We prefer a primary thread, but skip 0 
 Search for anything, but in reverse 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2013, Michael Ellerman, IBM Corp.
 Setting timeout to -1 disables the alarm 
 Make sure output is flushed before forking 
 Wake us up in timeout seconds 
 Kill anything else in the process group that is still running 
 Signal or other 
 Just wake us up from waitpid 
 so that skipped test is not marked as failed 
 SPDX-License-Identifier: GPL-2.0-only
  POWER Data Stream Control Register (DSCR) SPR test
  This test modifies the DSCR value through both the SPR number
  based mtspr instruction and then makes sure that the same is
  reflected through mfspr instruction using either of the SPR
  numbers.
  When using the privilege state SPR, the instructions such as
  mfspr or mtspr are priviledged and the kernel emulates them
  for us. Instructions using problem state SPR can be exuecuted
  directly without any emulation if the HW supports them. Else
  they also get emulated by the kernel.
  Copyright 2013, Anton Blanchard, IBM Corporation.
  Copyright 2015, Anshuman Khandual, IBM Corporation.
 SPDX-License-Identifier: GPL-2.0-only
  POWER Data Stream Control Register (DSCR) explicit test
  This test modifies the DSCR value using mtspr instruction and
  verifies the change with mfspr instruction. It uses both the
  privilege state SPR and the problem state SPR for this purpose.
  When using the privilege state SPR, the instructions such as
  mfspr or mtspr are priviledged and the kernel emulates them
  for us. Instructions using problem state SPR can be exuecuted
  directly without any emulation if the HW supports them. Else
  they also get emulated by the kernel.
  Copyright 2012, Anton Blanchard, IBM Corporation.
  Copyright 2015, Anshuman Khandual, IBM Corporation.
 SPDX-License-Identifier: GPL-2.0-only
  POWER Data Stream Control Register (DSCR) fork exec test
  This testcase modifies the DSCR using mtspr, forks & execs and
  verifies that the child is using the changed DSCR using mfspr.
  When using the privilege state SPR, the instructions such as
  mfspr or mtspr are privileged and the kernel emulates them
  for us. Instructions using problem state SPR can be executed
  directly without any emulation if the HW supports them. Else
  they also get emulated by the kernel.
  Copyright 2012, Anton Blanchard, IBM Corporation.
  Copyright 2015, Anshuman Khandual, IBM Corporation.
 SPDX-License-Identifier: GPL-2.0-only
  POWER Data Stream Control Register (DSCR) default test
  This test modifies the system wide default DSCR through
  it's sysfs interface and then verifies that all threads
  see the correct changed DSCR value immediately.
  Copyright 2012, Anton Blanchard, IBM Corporation.
  Copyright 2015, Anshuman Khandual, IBM Corporation.
 System DSCR default 
 Initial DSCR default 
 Spawn all testing threads 
 Keep changing the DSCR default 
 Individual testing thread exit status 
 SPDX-License-Identifier: GPL-2.0-only
  POWER Data Stream Control Register (DSCR) sysfs thread test
  This test updates the system wide DSCR default value through
  sysfs interface which should then update all the CPU specific
  DSCR default values which must also be then visible to threads
  executing on individual CPUs on the system.
  Copyright 2015, Anshuman Khandual, IBM Corporation.
 SPDX-License-Identifier: GPL-2.0-only
  POWER Data Stream Control Register (DSCR) fork test
  This testcase modifies the DSCR using mtspr, forks and then
  verifies that the child process has the correct changed DSCR
  value using mfspr.
  When using the privilege state SPR, the instructions such as
  mfspr or mtspr are priviledged and the kernel emulates them
  for us. Instructions using problem state SPR can be exuecuted
  directly without any emulation if the HW supports them. Else
  they also get emulated by the kernel.
  Copyright 2012, Anton Blanchard, IBM Corporation.
  Copyright 2015, Anshuman Khandual, IBM Corporation.
 SPDX-License-Identifier: GPL-2.0-only
  POWER Data Stream Control Register (DSCR) sysfs interface test
  This test updates to system wide DSCR default through the sysfs interface
  and then verifies that all the CPU specific DSCR defaults are updated as
  well verified from their sysfs interfaces.
  Copyright 2015, Anshuman Khandual, IBM Corporation.
 SPDX-License-Identifier: GPL-2.0-or-later
  Test that a syscall does not get restarted twice, handled by trap_norestart()
  Based on Al's description, and a test for the bug fixed in this commit:
  commit 9a81c16b527528ad307843be5571111aa8d35a80
  Author: Al Viro <viro@zeniv.linux.org.uk>
  Date:   Mon Sep 20 21:48:57 2010 +0100
   powerpc: fix double syscall restarts
   Make sigreturn zero regs->trap, make do_signal() do the same on all
   paths.  As it is, signal interrupting e.g. read() from fd 512 (==
   ERESTARTSYS) with another signal getting unblocked when the first
   handler finishes will lead to restart one insn earlier than it ought
   to.  Same for multiple signals with in-kernel handlers interrupting
   that sucker at the same time.  Same for multiple signals of any kind
   interrupting that sucker on 64bit...
	
	  SIGUSR2 is blocked until the handler exits, at which point it will
	  be raised again and think there is a restart to be done because the
	  pending restarted syscall has 512 (ERESTARTSYS) in r3. The second
	  restart will retreat NIP another 4 bytes to fail case branch.
 Child reads from pipe 
 Let's get ERESTARTSYS into r3 
 Hack to get reader waiting 
 SPDX-License-Identifier: GPL-2.0
  Test that we can take signals with and without the VDSO mapped, which trigger
  different paths in the signal handling code.
  See handle_rt_signal64() and setup_trampoline() in signal_64.c
 Ensure assert() is not compiled out
 Confirm the VDSO is mapped, and work out where it is
 Remap the VDSO somewhere else
 Confirm the VDSO is not mapped anymore
 Make the stack executable
 SPDX-License-Identifier: GPL-2.0
  Copyright 2018, Breno Leitao, IBM Corp.
  Licensed under GPLv2.
  Sigfuz(tm): A PowerPC TM-aware signal fuzzer.
  This is a new selftest that raises SIGUSR1 signals and handles it in a set
  of different ways, trying to create different scenario for testing
  purpose.
  This test works raising a signal and calling sigreturn interleaved with
  TM operations, as starting, suspending and terminating a transaction. The
  test depends on random numbers, and, based on them, it sets different TM
  states.
  Other than that, the test fills out the user context struct that is passed
  to the sigreturn system call with random data, in order to make sure that
  the signal handler syscall can handle different and invalid states
  properly.
  This selftest has command line parameters to control what kind of tests the
  user wants to run, as for example, if a transaction should be started prior
  to signal being raised, or, after the signal being raised and before the
  sigreturn. If no parameter is given, the default is enabling all options.
  This test does not check if the user context is being read and set
  properly by the kernel. Its purpose, at this time, is basically
  guaranteeing that the kernel does not crash on invalid scenarios.
 Selftest defaults 
 Number of interactions 
 Number of threads 
 Arguments options 
 checkpoint context 
 Return true with 1x probability 
 Change TM states 
 Starts a transaction 33% of the time 
 And suspended half of them 
 Call 'tend' in 5% of the runs 
 Signal handler that will be invoked with raise() 
	
	  Set uc_link in three possible ways:
	   - Setting a single 'int' in the whole chunk
	   - Cloning ucp into uc_link
	   - Allocating a new memory chunk
 Trying to cause a major page fault at Kernel level 
 Changing the checkpointed registers 
 Checking the current register context 
 Nested transaction start 
 Return without changing any other context info 
 Clear exit for process that segfaults 
 Main signal handler 
 SIGSEGV signal handler 
 The signal handler will enable MSR_TS 
 If it does not crash, it will segfault, avoid it to retest 
 Once seed per process 
 If not freed already, free now 
 Default test suite 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2016, Cyril Bur, IBM Corp.
  Sending one self a signal should always get delivered.
 Don't do this for MAX_ATTEMPT, its simply too long 
 Disable any pending 
 For the line number 
 Otherwise we'll loop too fast and fork() will eventually fail 
 Disable any pending 
 For the line number 
 For the line number 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2016, Cyril Bur, IBM Corp.
  Sending one self a signal should always get delivered.
		
		  If anything bad happens in ASM and we fail to set ret
		  because handwave TM this will cause failure
 Disable any pending 
			
			  This basically means the transaction aborted before we
			  even got to the suspend... this is crazy but it
			  happens.
			  Yes this also means we might never make forward
			  progress... the alarm() will trip eventually...
 Ret is actually an errno 
 For the line number 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
 For CPU_ZERO etc. 
 sometimes expected 
 Signal or other 
	
	  We are just here to eat cpu and die. So make sure we can be killed,
	  and also don't do any custom SIGTERM handling.
 Soak up cpu forever 
 This skips line with no executable which is what we want 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2013, Michael Ellerman, IBM Corp.
 Run for 1M instructions 
 Tolerate a difference below 0.0001 % 
 Count how many instructions it takes to do a null loop 
 Run for 1Mi instructions 
 Run for 10Mi instructions 
 Run for 100Mi instructions 
 Run for 1Bi instructions 
 Run for 16Bi instructions 
 Run for 64Bi instructions 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Test that per-event excludes work.
	
	  We need to create the events disabled, otherwise the runningenabled
	  counts don't match up.
	
	  The open here will fail if we don't have per event exclude support,
	  because the second event has an incompatible set of exclude settings
	  and we're asking for the events to be in a group.
	
	  Even though the above will fail without per-event excludes we keep
	  testing in order to be thorough.
 Spin for a while 
	
	  We should see that all events have enabled == running. That
	  shows that they were all on the PMU at once.
	
	  We can also check that the result for instructions is >= all the
	  other counts. That's because it is counting all instructions while
	  the others are counting a subset.
  Copyright 2013, Michael Ellerman, IBM Corp.
  Licensed under GPLv2.
 Run for 1M instructions 
 Tolerate a difference below 0.0001 % 
 Count how many instructions it takes to do a null loop 
 The STCX_FAIL event we use works on Power8 or later
 Run for 1Mi instructions 
 Run for 10Mi instructions 
 Run for 100Mi instructions 
 Run for 1Bi instructions 
 Run for 16Bi instructions 
 Run for 64Bi instructions 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2013, Michael Ellerman, IBM Corp.
 This has to match the structure layout in the header 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
 Ought to be enough .. 
  Tests that the L3 bank handling is correct. We fixed it in commit e9aaac1.
 The L3 bank logic is only used on Power8 or later
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Test of counting cycles while manipulating the user accessible bits in MMCR2.
 We use two values because the first freezes PMC1 and so we would get no EBBs 
 (FC1P|FC2P|FC3P|FC4P|FC5P|FC6P) 
 (     FC2P|FC3P|FC4P|FC5P|FC6P) 
 XXX Set of MMCR2 must be after enable 
 Make sure we loop until we take at least one EBB 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Test that PMC5 & 6 are frozen (ie. don't overflow) when they are not being
  used. Tests the MMCR0_FC56 logic in the kernel.
 Use PMC2 so we set PMCjCE, which enables PMC56 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Test that if we overflow the counter while in the EBB handler, we take
  another EBB on exiting from the handler.
  We do this by counting with a stupidly low sample period, causing us to
  overflow the PMU while we're still in the EBB handler, leading to another
  EBB.
  We get out of what would otherwise be an infinite loop by leaving the
  counter frozen once we've taken enough EBBs.
 Resets the PMC 
 Reset but leave counters frozen 
 Unfreezes 
 Do some stuff to chew some cycles and pop the counter 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Test that the kernel properly handles PMAE across context switches.
  We test this by calling into the kernel inside our EBB handler, where PMAE
  is clear. A cpu eater companion thread is running on the same CPU as us to
  encourage the scheduler to switch us.
  The kernel must make sure that when it context switches us back in, it
  honours the fact that we had PMAE clear.
  Observed to hit the failing case on the first EBB with a broken kernel.
 Try and get ourselves scheduled, to force a PMU context switch 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2021, Athira Rajeev, IBM Corp.
  Test that closing the EBB event clears MMCR0_PMCC and
  sets MMCR0_PMCCEXT preventing further read access to the
  group B PMU registers.
	
	  For ISA v3.1, verify the test takes a SIGILL when reading
	  PMU regs after the event is closed. With the control bit
	  in MMCR0 (PMCCEXT) restricting access to group B PMU regs,
	  sigill is expected.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Test that a fork clears the PMU state of the child. eg. BESCREBBHREBBRR
  are cleared, and MMCR0_PMCC is reset, preventing the child from accessing
  the PMU.
 Even though we have EBE=0 we can still see the EBB regs 
 We can still read from the event, though it is on our parent 
 Tests that fork clears EBB state 
 Don't need to actually take any EBBs 
 Child does the actual testing 
 After fork 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Test that closing the EBB event clears MMCR0_PMCC, preventing further access
  by userspace to the PMU hardware.
	 The real test is here, do we take a SIGILL when writing PMU regs now
 We should still be able to read EBB regs though 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Basic test that counts user cycles and takes EBBs.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Tests a per-task event vs an EBB - in that order. The EBB should push the
  per-task event off the PMU.
 NB order of pipes looks reversed 
 We setup the task event first 
 Signal the child to install its EBB event and wait 
 If it fails, wait for it to exit 
 Signal the child to run 
 The EBB event should push the task event off so the child should succeed 
 The task event may have run, or not so we can't assert anything about it 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Run a calibrated instruction loop and count instructions executed using
  EBBs. Make sure the counts look right.
 Tolerate a difference of up to 0.0001 % 
 Count how many instructions it takes to do a null loop 
 Run for 1M instructions 
 Run for 10M instructions 
 Run for 100M instructions 
 Run for 1G instructions 
 Run for 16G instructions 
 Run for 64G instructions 
 Run for 128G instructions 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Test basic access to the EBB regs, they should be user accessible with no
  kernel interaction required.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Test of counting cycles while using MMCR0_FC (freeze counters) to only count
  parts of the code. This is complicated by the fact that FC is set by the
  hardware when the event overflows. We may take the EBB after we have set FC,
  so we have to be careful about whether we clear FC at the end of the EBB
  handler or not.
 Make sure we loop until we take at least one EBB 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Tests an EBB vs a cpu event - in that order. The EBB should force the cpu
  event off the PMU.
 NB order of pipes looks reversed 
 Signal the child to install its EBB event and wait 
 Now try to install our CPU event 
 Signal the child to run 
 .. and wait for it to complete 
 The cpu event may have run, but we don't expect 100% 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Tests a pinned cpu event vs an EBB - in that order. The pinned cpu event
  should remain and the EBB event should fail to enable.
 NB order of pipes looks reversed 
 We setup the cpu event first 
 Signal the child to install its EBB event and wait 
 If it fails, wait for it to exit 
 Signal the child to run 
 We expect it to fail to read the event 
 The cpu event should have run 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Test that tries to trigger CPU_FTR_PMAO_BUG. Which is a hardware defect
  where an exception triggers but we context switch before it is delivered and
  lose the exception.
 We use PMC4 to make sure the kernel switches all counters correctly 
	
	  We want a low sample period, but we also want to get out of the EBB
	  handler without tripping up again.
	 
	  This value picked after much experimentation.
		
		  We are trying to get the EBB exception to race exactly with
		  us entering the kernel to do the syscall. We then need the
		  kernel to decide our timeslice is up and context switch to
		  the other thread. When we come back our EBB will have been
		  lost and we'll spin in this while loop forever.
 Change the sample period slightly to try and hit the race 
 We vary our sample period so we need extra fudge here 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Test counting multiple events using EBBs.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
 For CPU_ZERO etc. 
 2) clear MMCR0[PMAO] - docs say BESCR[PMEO] should do this 
 3) set MMCR0[PMAE]	- docs say BESCR[PME] should do this 
 4) clear BESCR[PMEO] 
 5) set BESCR[PME] 
 6) rfebb 1 - done in our caller 
 Called outside of the EBB handler to check MMCR0 is sane 
 It's OK if we see FC & PMAO, but not FC by itself 
 Ensure ebb_user_func is set before we set the handler 
 Make sure the handler is set before we return 
 0) Read PMC 
 1) Reset PMC 
 Report if we overflowed 
 Ensure any SPR writes are ordered vs us 
 Ditto 
 Unfreeze counters 
 Enable EBBs globally and PMU EBBs 
 Disable EBBs & freeze counters, events are still scheduled 
 EBB requires at least POWER8 
		
		  Some tests expect to fail here, so don't report an error on
		  this line, and return a distinguisable error code. Tell the
		  parent an error happened.
 To try and hit SIGILL case 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Tests a cpu event vs an EBB - in that order. The EBB should force the cpu
  event off the PMU.
 NB order of pipes looks reversed 
 We setup the cpu event first 
 Signal the child to install its EBB event and wait 
 If it fails, wait for it to exit 
 Signal the child to run 
 We expect the child to succeed 
 The cpu event may have run 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Test various attributes of the EBB event are enforced.
 Expected to succeed 
 CYCLES - no PMC specified 
 Expected to fail, no PMC specified 
 Expected to fail, not exclusive 
 Expected to fail, sets freq 
 Expected to fail, sets sample_period 
 Expected to fail, sets enable_on_exec 
 Expected to fail, sets inherit 
 Expected to succeed 
 Expected to fail, event doesn't request EBB, leader does 
 Clear the EBB flag 
 Expected to fail, leader doesn't request EBB 
 Expected to fail, leader isn't exclusive 
 Expected to fail, leader isn't pinned 
 Expected to fail, not a task event 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Tests we can setup an EBB on our child. The child expects this and enables
  EBBs, which are then delivered to the child, even though the event is
  created by the parent.
 Setup our EBB handler, before the EBB event is created 
 Tests we can setup an EBB on our child - if it's expecting it 
 NB order of pipes looks reversed 
 Signal the child to setup its EBB handler 
 Child is running now 
 Child show now take EBBs and then exit 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Tests a pinned per-task event vs an EBB - in that order. The pinned per-task
  event should prevent the EBB event from being enabled.
 NB order of pipes looks reversed 
 We setup the task event first 
 Signal the child to install its EBB event and wait 
 If it fails, wait for it to exit 
 Signal the child to run 
 We expect it to fail to read the event 
	
	  For reasons I don't understand enabled is usually just slightly
	  lower than running. Would be good to confirm why.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Tests we can setup an EBB on our child. Nothing interesting happens, because
  even though the event is enabled and running the child hasn't enabled the
  actual delivery of the EBBs.
 Parent creates EBB event 
 Check the EBB is enabled by writing PMC1 
 EBB event is enabled here 
 NB order of pipes looks reversed 
 Child is running now 
 Child should just exit happily 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
 Test that things work sanely if we have no handler 
 Make sure it overflows quickly 
 Spin to make sure the event has time to overflow 
 We expect to see the PMU frozen & PMAO set 
 The real test is that we never took an EBB at 0x0 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
  Test running multiple EBB using processes at once on a single CPU. They
  should all run happily without interfering with each other.
 Have them all run for "a while" 
 Tell them to stop 
 And wait 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014, Michael Ellerman, IBM Corp.
	
	  If we ever overflowed don't allow any more input. This prevents us
	  from dropping a large item and then later logging a small one. The
	  buffer should just stop when overflow happened, not be patchy. If
	  you're overflowing, make your buffer bigger.
 We NULL terminate to make printing easier 
 SPDX-License-Identifier: GPL-2.0
 test all offsets and lengths 
 SPDX-License-Identifier: GPL-2.0
  Copied from linuxlibstring.c
   Copyright (C) 1991, 1992  Linus Torvalds
  strlen - Find the length of a string
  @s: The string to be sized
 nothing ;
 SPDX-License-Identifier: GPL-2.0
 This is big enough to fit LARGE_SIZE and works on 4K & 64K kernels 
 test all offsets and lengths 
 Trick to compare sign 
 check for zero 
 Put s1s2 at the end of a page 
 And unmap the subsequent page to force a fault if we overread 
 change one byte 
 change multiple bytes, 18 of total 
 vcmpequd used in memcmp_64.S is v2.07
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2016, Chris Smart, IBM Corporation.
  Calls to copy_first which are not 128-byte aligned should be
  caught and sent a SIGBUS.
	
	  Check that the signal was on the correct instruction, using a
	  mask because the compiler assigns the register at RB.
 We hit the right instruction 
 Only run this test on a P9 or later 
 Register our signal handler with SIGBUS 
 +1 makes buf unaligned 
 We should not get here 
 SPDX-License-Identifier: GPL-2.0-or-later
  Test the powerpc alignment handler on POWER8POWER9
  Copyright (C) 2017 IBM Corporation (Michael Neuling, Andrew Donnellan)
  This selftest exercises the powerpc alignment fault handler.
  We create two sets of source and destination buffers, one in regular memory,
  the other cache-inhibited (by default we use devfb0 for this, but an
  alterative path for cache-inhibited memory may be provided, e.g. memtrace).
  We initialise the source buffers, then use whichever set of loadstore
  instructions is under test to copy bytes from the source buffers to the
  destination buffers. For the regular buffers, these instructions will
  execute normally. For the cache-inhibited buffers, these instructions
  will trap and cause an alignment fault, and the alignment fault handler
  will emulate the particular instruction under test. We then compare the
  destination buffers to ensure that the native and emulated cases give the
  same result.
  TODO:
    - Any FIXMEs below
    - Test VSX regs < 32 and > 32
    - Test all loads and stores
    - Check update forms do update register
    - Test alignment faults over page boundary
  Some old binutils may not support all the instructions.
 FIXME: Unimplemented tests: 
 STORE_DFORM_TEST(stq)    FIXME: need two registers for quad 
 STORE_DFORM_TEST(stswi)  FIXME: string instruction 
 STORE_XFORM_TEST(stwat)  AMO can't emulate or run on CI 
 STORE_XFORM_TEST(stdat)  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
 preload byte by byte 
 run the actual test 
  Do two memcpy tests using the same instructions. One cachable
  memory and the other doesn't.
	
	  offset = 0 is aligned but tests the workaround for the P9N
	  DD2.1 vector CI load issue (see 5080332c2c89 "powerpc64s:
	  Add workaround for P9 vector CI load issue")
 vsx == 16 bytes 
 load pattern into memory byte by byte 
 FIXME: remove??
 initialise output to the same 
 sanity check 
	
	  FIXME: These loads only load part of the register, so our
	  testing method doesn't work. Also they don't take alignment
	  faults, so it's kinda pointless anyway
	 
	 LOAD_VMX_XFORM_TEST(lvebx)
	 LOAD_VMX_XFORM_TEST(lvehx)
	 LOAD_VMX_XFORM_TEST(lvewx)
	 LOAD_VMX_XFORM_TEST(lvxl)
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2015, Michael Neuling, IBM Corp.
  Test the kernel's signal delievery code to ensure that we don't
  trelaim twice in the kernel signal delivery code.  This can happen
  if we trigger a signal when in a transaction and the stack pointer
  is bogus.
  This test case registers a SEGV handler, sets the stack pointer
  (r1) to NULL, starts a transaction and then generates a SEGV.  The
  SEGV should be handled but we exit here as the stack pointer is
  invalid and hance we can't sigreturn.  We only need to check that
  this flow doesn't crash the kernel.
 This should never actually run since stack is foobar 
 Parent 
		
		  It's likely the whole machine will crash here so if
		  the child ever exits, we are good.
	
	  The flow here is:
	  1) register a signal handler (so signal delievery occurs)
	  2) make stack pointer (r1) = NULL
	  3) start transaction
	  4) cause segv
 stack ptr == NULL 
 retry forever 
 trigger segv" 
 This should never get here due to above segv 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2017, Michael Neuling, IBM Corp.
  Original: Breno Leitao <brenohl@br.ibm.com> &
            Gustavo Bueno Romero <gromero@br.ibm.com>
  Edited: Michael Neuling
  Force VMX unavailable during a transaction and see if it corrupts
  the checkpointed VMX register state after the abort.
 Stick non-zero value in VMX0 
 Wait here a bit so we get scheduled out 255 times 
 Kernel will hopefully turn VMX off now 
 Cause VMX unavail. Any VMX instruction 
 Check VMX0 sanity after abort 
 HTM aborted and VMX0 is corrupted 
 HTM aborted but VMX0 is correct 
	printf("!");
	printf(".");
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2016, Cyril Bur, IBM Corp.
  Test the kernel's signal frame code.
  The kernel sets up two sets of ucontexts if the signal was to be
  delivered while the thread was in a transaction (referred too as
  first and second contexts).
  Expected behaviour is that the checkpointed state is in the user
  context passed to the signal handler (first context). The speculated
  state can be accessed with the uc_link pointer (second context).
  The rationale for this is that if TM unaware code (which linked
  against TM libs) installs a signal handler it will not know of the
  speculative nature of the 'live' registers and may infer the wrong
  thing.
 Number of non-volatile FP registers 
 First non-volatile FP register to check in f14-31 subset 
 Test only non-volatile registers, i.e. 18 fpr registers from f14 to f31 
 First context will be set with these values, i.e. non-speculative 
 Second context will be set with these values, i.e. speculative 
 Check first context. Print all mismatches. 
 Check second context. Print all mismatches. 
		
		  tm_signal_self_context_load will set both first and second
		  contexts accordingly to the values passed through non-NULL
		  array pointers to it, in that case 'fps', and invoke the
		  signal handler installed for SIGUSR1.
 SPDX-License-Identifier: GPL-2.0
  Copyright 2018, Breno Leitao, Gustavo Romero, IBM Corp.
  A test case that creates a signal and starts a suspended transaction
  inside the signal handler.
  It returns from the signal handler with the CPU at suspended state, but
  without setting usercontext MSR Transaction State (TS) fields.
 Skip 'trap' instruction if it succeed 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2016, Cyril Bur, IBM Corp.
  Test the kernel's signal frame code.
  The kernel sets up two sets of ucontexts if the signal was to be
  delivered while the thread was in a transaction (referred too as
  first and second contexts).
  Expected behaviour is that the checkpointed state is in the user
  context passed to the signal handler (first context). The speculated
  state can be accessed with the uc_link pointer (second context).
  The rationale for this is that if TM unaware code (which linked
  against TM libs) installs a signal handler it will not know of the
  speculative nature of the 'live' registers and may infer the wrong
  thing.
 Number of VSX registers to check. 
 First VSX register to check in vsr20-vsr31 subset 
 FPR20 overlaps VSX20 most significant doubleword 
 Test only 12 vsx registers from vsr20 to vsr31 
 First context will be set with these values, i.e. non-speculative 
 VSX20     ,  VSX21      , ... 
 Second context will be set with these values, i.e. speculative 
 VSX20         ,  VSX21          , ... 
	
	  FP registers and VMX registers overlap the VSX registers.
	 
	  FP registers (f0-31) overlap the most significant 64 bits of VSX
	  registers vsr0-31, whilst VMX registers vr0-31, being 128-bit like
	  the VSX registers, overlap fully the other half of VSX registers,
	  i.e. vr0-31 overlaps fully vsr32-63.
	 
	  Due to compatibility and historical reasons (VMXAltivec support
	  appeared first on the architecture), VMX registers vr0-31 (so VSX
	  half vsr32-63 too) are stored right after the v_regs pointer, in an
	  area allocated for 'vmx_reverse' array (please see
	  archpowerpcincludeuapiasmsigcontext.h for details about the
	  mcontext_t structure on Power).
	 
	  The other VSX half (vsr0-31) is hence stored below vr0-31vsr32-63
	  registers, but only the least significant 64 bits of vsr0-31. The
	  most significant 64 bits of vsr0-31 (f0-31), as it overlaps the FP
	  registers, is kept in fp_regs.
	 
	  v_regs is a 16 byte aligned pointer at the start of vmx_reserve
	  (vmx_reserve may or may not be 16 aligned) where the v_regs structure
	  exists, so v_regs points to where vr0-31  vsr32-63 registers are
	  fully stored. Since v_regs type is elf_vrregset_t, v_regs + 1
	  skips all the slots used to store vr0-31  vsr32-64 and points to
	  part of one VSX half, i.e. v_regs + 1 points to the least significant
	  64 bits of vsr0-31. The other part of this half (the most significant
	  part of vsr0-31) is stored in fp_regs.
	 
 Get pointer to least significant doubleword of vsr0-31 
 Check first context. Print all mismatches. 
		
		  Copy VSX most significant doubleword from fp_regs and
		  copy VSX least significant one from 64-bit slots below
		  saved VMX registers.
 Check second context. Print all mismatches. 
		
		  Copy VSX most significant doubleword from fp_regs and
		  copy VSX least significant one from 64-bit slots below
		  saved VMX registers.
                 tm_signal_self_context_load will set both first and second
                 contexts accordingly to the values passed through non-NULL
                 array pointers to it, in that case 'vsxs', and invoke the
                 signal handler installed for SIGUSR1.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2017, Gustavo Romero, IBM Corp.
  Check if thread endianness is flipped inadvertently to BE on trap
  caught in TM whilst MSR.FP and MSR.VEC are zero (i.e. just after
  load_fp and load_vec overflowed).
  The issue can be checked on LE machines simply by zeroing load_fp
  and load_vec and then causing a trap in TM. Since the endianness
  changes to BE on return from the signal handler, 'nop' is
  thread as an illegal instruction in following sequence:
 	tbegin.
 	beq 1f
 	trap
 	tend.
  1:	nop
  However, although the issue is also present on BE machines, it's a
  bit trickier to check it on BE machines because MSR.LE bit is set
  to zero which determines a BE endianness that is the native
  endianness on BE machines, so nothing notably critical happens,
  i.e. no illegal instruction is observed immediately after returning
  from the signal handler (as it happens on LE machines). Thus to test
  it on BE machines LE endianness is forced after a first trap and then
  the endianness is verified on subsequent traps to determine if the
  endianness "flipped back" to the native endianness (BE).
 Get thread endianness: extract bit LE from MSR 
	
	  Little-Endian Machine
 First trap event 
			 Do nothing. Since it is returning from this trap
			  event that endianness is flipped by the bug, so just
			  let the process return from the signal handler and
			  check on the second trap event if endianness is
			  flipped or not.
 Second trap event 
			
			  Since trap was caught in TM on first trap event, if
			  endianness was still LE (not flipped inadvertently)
			  after returning from the signal handler instruction
			  (1) is executed (basically a 'nop'), as it's located
			  at address of tbegin. +4 (rollback addr). As (1) on
			  LE endianness does in effect nothing, instruction (2)
			  is then executed again as 'trap', generating a second
			  trap event (note that in that case 'trap' is caught
			  not in transacional mode). On te other hand, if after
			  the return from the signal handler the endianness in-
			  advertently flipped, instruction (1) is tread as a
			  branch instruction, i.e. b .+8, hence instruction (3)
			  and (4) are executed (tbegin.; trap;) and we get sim-
			  ilaly on the trap signal handler, but now in TM mode.
			  Either way, it's now possible to check the MSR LE bit
			  once in the trap handler to verify if endianness was
			  flipped or not after the return from the second trap
			  event. If endianness is flipped, the bug is present.
			  Finally, getting a trap in TM mode or not is just
			  worth noting because it affects the math to determine
			  the offset added to the NIP on return: the NIP for a
			  trap caught in TM is the rollback address, i.e. the
			  next instruction after 'tbegin.', whilst the NIP for
			  a trap caught in non-transactional mode is the very
			  same address of the 'trap' instruction that generated
			  the trap event.
 Go to 'success', i.e. instruction (6) 
				
				  Thread endianness is BE, so it flipped
				  inadvertently. Thus we flip back to LE and
				  set NIP to go to 'failure', instruction (5).
	
	  Big-Endian Machine
 First trap event 
			
			  Force thread endianness to be LE. Instructions (1),
			  (3), and (4) will be executed, generating a second
			  trap in TM mode.
 Second trap event 
			
			  Do nothing. If bug is present on return from this
			  second trap event endianness will flip back "automat-
			  ically" to BE, otherwise thread endianness will
			  continue to be LE, just as it was set above.
 A third trap event 
			
			  Once here it means that after returning from the sec-
			  ond trap event instruction (4) (trap) was executed
			  as LE, generating a third trap event. In that case
			  endianness is still LE as set on return from the
			  first trap event, hence no bug. Otherwise, bug
			  flipped back to BE on return from the second trap
			  event and instruction (4) was executed as 'tdi' (so
			  basically a 'nop') and branch to 'failure' in
			  instruction (5) was taken to indicate failure and we
			  never get here.
			
			  Flip back to BE and go to instruction (6), i.e. go to
			  'success'.
 Got a USR1 signal from ping(), so just tell pong() to exit 
	
	  Wait an amount of context switches so load_fp and load_vec overflows
	  and MSR_[FP|VEC|V] is 0.
		
		  [NA] means "Native Endianness", i.e. it tells how a
		  instruction is executed on machine's native endianness (in
		  other words, native endianness matches kernel endianness).
		  [OP] means "Opposite Endianness", i.e. on a BE machine, it
		  tells how a instruction is executed as a LE instruction; con-
		  versely, on a LE machine, it tells how a instruction is
		  executed as a BE instruction. When [NA] is omitted, it means
		  that the native interpretation of a given instruction is not
		  relevant for the test. Likewise when [OP] is omitted.
 (0) tbegin. [NA]                    
 (1) nop     [NA]; b (3) [OP]        
 (2) trap    [NA]                    
 (3) tbegin. [OP]                    
 (4) trap    [OP]; nop   [NA]        
 (5) b [NA]; MSR.LE flipped (bug)    
 (6) b [NA]; MSR.LE did not flip (ok)
 Tell pong() to exit before leaving 
		
		  Induce context switches on ping() thread
		  until ping() finishes its job and signs
		  to exit from this loop.
 Set only one CPU in the mask. Both threads will be bound to that CPU.
 Init pthread attribute 
	
	  Bind thread ping() and pong() both to CPU 0 so they ping-pong and
	  speed up context switches on ping() thread, speeding up the load_fp
	  and load_vec overflow.
 Figure out the machine endianness 
 Launch ping() 
 Launch pong() 
 no, endianness did not flip inadvertently 
 yes, endianness did flip inadvertently 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2020, Gustavo Luiz Duarte, IBM Corp.
  This test starts a transaction and triggers a signal, forcing a pagefault to
  happen when the kernel signal handling code touches the user signal stack.
  In order to avoid pre-faulting the signal stack memory and to force the
  pagefault to happen precisely in the kernel signal handling code, the
  pagefault handling is done in userspace using the userfaultfd facility.
  Further pagefaults are triggered by crafting the signal handler's ucontext
  to point to additional memory regions managed by the userfaultfd, so using
  the same mechanism used to avoid pre-faulting the signal stack memory.
  On failure (bug is present) kernel crashes or never returns control back to
  userspace. If bug is not present, tests completes almost immediately.
 10 x 64k pages 
 Memory handled by userfaultfd 
  Data that will be copied into the faulting pages (instead of zero-filled
  pages). This is used to make the test more reliable and avoid segfaulting
  when we return from the signal handler. Since we are making the signal
  handler's ucontext point to newly allocated memory, when that memory is
  paged-in it will contain the expected content.
  Return a chunk of at least 'size' bytes of memory that will be handled by
  userfaultfd. If 'backing_data' is not NULL, its content will be save to
  'backing_mem' and then copied into the faulting pages when the page fault
  is handled.
 Save the data that will be copied into the faulting page 
 Reserve the requested amount of uf_mem 
 Keep uf_mem_offset aligned to the page size (round up) 
 Data read from userfaultfd 
 userfaultfd file descriptor 
 We expect only one kind of event 
		
		  We need to handle page faults in units of pages(!).
		  So, round faulting address down to page boundary.
 userfaultfd file descriptor 
 Create and enable userfaultfd object 
	
	  Create a private anonymous mapping. The memory will be demand-zero
	  paged, that is, not yet allocated. When we actually touch the memory
	  the related page will be allocated via the userfaultfd mechanism.
	
	  Register the memory range of the mapping we've just mapped to be
	  handled by the userfaultfd object. In 'mode' we request to track
	  missing pages (i.e. pages that have not yet been faulted-in).
 Create a thread that will process the userfaultfd events 
  Assumption: the signal was delivered while userspace was in transactional or
  suspended state, i.e. uc->uc_link != NULL.
 Skip 'trap' after returning, otherwise we get a SIGTRAP again 
	
	  Set an alternative stack that will generate a page fault when the
	  signal is raised. The page fault will be treated via userfaultfd,
	  i.e. via fault_handler_thread.
 Trigger a SIGTRAP in transactional state 
 Trigger a SIGTRAP in suspended state 
	
	  Depending on kernel config, the TM Bad Thing might not result in a
	  crash, instead the kernel never returns control back to userspace, so
	  set a tight timeout. If the test passes it completes almost
	  immediately.
 SPDX-License-Identifier: GPL-2.0
  Copyright 2015, Laurent Dufour, IBM Corp.
  Test the kernel's signal returning code to check reclaim is done if the
  sigreturn() is called while in a transaction (suspended since active is
  already dropped trough the system call path).
  The kernel must discard the transaction when entering sigreturn, since
  restoring the potential TM SPRS from the signal frame is requiring to not be
  in a transaction.
	
	  We return from the signal handle while in a suspended transaction
 trigger SEGV 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2015, Michael Neuling, IBM Corp.
  Original: Michael Neuling 342014
  Modified: Rashmica Gupta 8122015
  Check if any of the Transaction Memory SPRs get corrupted.
  - TFIAR  - stores address of location of transaction failure
  - TFHAR  - stores address of software failure handler (if transaction
    fails)
  - TEXASR - lots of info about the transacion(s)
  (1) create more threads than cpus
  (2) in each thread:
  	(a) set TFIAR and TFHAR a unique value
  	(b) loop for awhile, continually checking to see if
  	either register has been corrupted.
  (3) Loop:
  	(a) begin transaction
     	(b) abort transaction
 	(c) check TEXASR to see if FS has been corrupted
 TFIAR: Last bit has to be high so userspace can read register 
 TFHAR: Last two bits are reserved 
 Abort handler 
 Check the TEXASR 
 To cause some context switching 
 Test TFIAR and TFHAR 
 Test TEXASR 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2019, Gustavo Romero, Michael Neuling, IBM Corp.
  This test will spawn two processes. Both will be attached to the same
  CPU (CPU 0). The child will be in a loop writing to FP register f31 and
  VMXVECAltivec register vr31 a known value, called poison, calling
  sched_yield syscall after to allow the parent to switch on the CPU.
  Parent will set f31 and vr31 to 1 and in a loop will check if f31 and
  vr31 remain 1 as expected until a given timeout (2m). If the issue is
  present child's poison will leak into parent's f31 or vr31 registers,
  otherwise, poison will never leak into parent's f31 and vr31 registers.
 Attach both Child and Parent to the same CPU
		
		  child
 f31 = poison
 vr31 = poison
	
	  parent
		
		  Set r3, r4, and f31 to known value 1 before entering
		  in transaction. They won't be written after that.
		
		  The Time Base (TB) is a 64-bit counter register that is
		  independent of the CPU clock and which is incremented
		  at a frequency of 512000000 Hz, so every 1.953125ns.
		  So it's necessary 120s0.000000001953125s = 61440000000
		  increments to get a 2 minutes timeout. Below we set that
		  value in r5 and then use r6 to track initial TB value,
		  updating TB values in r7 at every iteration and comparing it
		  to r6. When r7 (current) - r6 (initial) > 61440000000 we bail
		  out since for sure we spent already 2 minutes in the loop.
		  SPR 268 is the TB register.
 r5 = 61440000000
 r6 (TB initial)
 r7 (TB current)
 r7 - r6 > 61440000000 ?
 yes, exit
		
		  Main loop to check f31
 no, try again
 restart if no timeout
 read f31
 f31 == 1 ?
 broken :-(
 try another transaction
 commit transaction
 record r3
	
	  On leak 'unknown' will contain 'poison' value from child,
	  otherwise (no leak) 'unknown' will contain the same value
	  as r3 before entering in transactional mode, i.e. 0x1.
		
		  Set r3, r4, and vr31 to known value 1 before entering
		  in transaction. They won't be written after that.
 r5 = 61440000000
 r6 (TB initial)
 r7 (TB current)
 r7 - r6 > 61440000000 ?
 yes, exit
		
		  Main loop to check vr31
 no, try again
 restart if no timeout
 read vr31
 vr31 == 1 ?
 broken :-(
 try another transaction
 commit transaction
 record r3
	
	  On leak 'unknown' will contain 'poison' value from child,
	  otherwise (no leak) 'unknown' will contain the same value
	  as r3 before entering in transactional mode, i.e. 0x1.
 Test completes in about 4m 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2016, Cyril Bur, IBM Corp.
  Test the kernel's signal frame code.
  The kernel sets up two sets of ucontexts if the signal was to be
  delivered while the thread was in a transaction (referred too as
  first and second contexts).
  Expected behaviour is that the checkpointed state is in the user
  context passed to the signal handler (first context). The speculated
  state can be accessed with the uc_link pointer (second context).
  The rationale for this is that if TM unaware code (which linked
  against TM libs) installs a signal handler it will not know of the
  speculative nature of the 'live' registers and may infer the wrong
  thing.
 Number of non-volatile GPR registers 
 First non-volatile register to check in r14-r31 subset 
 Test only non-volatile general purpose registers, i.e. r14-r31 
 First context will be set with these values, i.e. non-speculative 
 R14, R15, ... 
 Second context will be set with these values, i.e. speculative 
 R14, R15, ... 
 Check first context. Print all mismatches. 
 Check second context. Print all mismatches. 
                  tm_signal_self_context_load will set both first and second
                  contexts accordingly to the values passed through non-NULL
                  array pointers to it, in that case 'gprs', and invoke the
                  signal handler installed for SIGUSR1.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2015, Michael Neuling, IBM Corp.
  Edited: Rashmica Gupta, Nov 2015
  This test does a fork syscall inside a transaction. Basic sniff test
  to see if we can enter the kernel during a transaction.
 fork syscall 
	 If we reach here, we've passed.  Otherwise we've probably crashed
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2016, Cyril Bur, IBM Corp.
  Syscalls can be performed provided the transactions are suspended.
  The exec() class of syscall is unique as a new process is loaded.
  It makes little sense for after an exec() call for the previously
  suspended transaction to still exist.
 Shouldn't get here 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2017, Gustavo Romero, Breno Leitao, Cyril Bur, IBM Corp.
  Force FP, VEC and VSX unavailable exception during transaction in all
  possible scenarios regarding the MSR.FP and MSR.VEC state, e.g. when FP
  is enable and VEC is disable, when FP is disable and VEC is enable, and
  so on. Then we check if the restored state is correctly set for the
  FP and VEC registers to the previous state we set just before we entered
  in TM, i.e. we check if it corrupts somehow the recheckpointed FP and
  VECAltivec registers on abortion due to an unavailable exception in TM.
  N.B. In this test we do not test all the FPAltivecVSX registers for
  corruption, but only for registers vs0 and vs32, which are respectively
  representatives of FP and VECAltivec reg sets.
 Unavailable exceptions to test in HTM 
	
	  If both FP and VEC are touched it does not mean that touching VSX
	  won't raise an exception. However since FP and VEC state are already
	  correctly loaded, the transaction is not aborted (i.e.
	  treclaimedtrecheckpointed) and MSR.VSX is just set as 1, so a TM
	  failure is not expected also in this case.
 Check if failure occurred whilst in transaction. 
	
	  When failure handling occurs, CR0 is set to 0b1010 (0xa). Otherwise
	  transaction completes without failure and hence reaches out 'tend.'
	  that sets CR0 to 0b0100 (0x4).
	
	  Expected values for vs0 and vs32 after a TM failure. They must never
	  change, otherwise they got corrupted.
 Counter for busy wait 
	
	  Variable to keep a copy of CR register content taken just after we
	  leave the transactional state.
	
	  Wait a bit so thread can get its name "ping". This is not important
	  to reproduce the issue but it's nice to have for systemtap debugging.
 Prepare to merge low and high. 
		
		  Adjust VS0 expected value after an TM failure,
		  i.e. vs0 = 0x5555555555555555555FFFFFFFFFFFFFFFF
		
		  Adjust VS32 expected value after an TM failure,
		  i.e. vs32 = 0x5555555555555555555FFFFFFFFFFFFFFFF
		
		  Wait an amount of context switches so load_fp and load_vec
		  overflow and MSR.FP, MSR.VEC, and MSR.VSX become zero (off).
 Decrement CTR branch if CTR non zero. 
		
		  Check if we want to touch FP prior to the test in order
		  to set MSR.FP = 1 before provoking an unavailable
		  exception in TM.
		
		  Check if we want to touch VEC prior to the test in order
		  to set MSR.VEC = 1 before provoking an unavailable
		  exception in TM.
		
		  Perhaps it would be a better idea to do the
		  compares outside transactional context and simply
		  duplicate code.
 Do we do FP Unavailable? 
 Do we do VEC Unavailable? 
		
		  Not FP or VEC, therefore VSX. Ensure this
		  instruction always generates a VSX Unavailable.
		  ISA 3.0 is tricky here.
		  (xxmrghd will on ISA 2.07 and ISA 3.0)
 Give values back to C. 
 Give CR back to C so that it can check what happened. 
	
	  Check if we were expecting a failure and it did not occur by checking
	  CR0 state just after we leave the transaction. Either way we check if
	  vs0 or vs32 got corrupted.
 Check if we were not expecting a failure and a it occurred. 
	
	  Check if TM failed due to the cause we were expecting. 0xda is a
	  TM_CAUSE_FAC_UNAV cause, otherwise it's an unexpected cause, unless
	  it was caused by a reschedule.
 0x4 is a success and 0xa is a fail. See comment in is_failure(). 
 Check FP (vs0) for the expected value. 
 Check VEC (vs32) for the expected value. 
 Thread to force context switch 
 Wait thread get its name "pong". 
 Classed as an interactive-like thread. 
 Function that creates a thread and launches the "ping" task. 
	
	  Without luck it's possible that the transaction is aborted not due to
	  the unavailable exception caught in the middle as we expect but also,
	  for instance, due to a context switch or due to a KVM reschedule (if
	  it's running on a VM). Thus we try a few times before giving up,
	  checking if the failure cause is the one we expect.
 Bind to CPU 0, as specified in 'attr'. 
 FP = 0, VEC = 1, VSX = 2 
 Set only one CPU in the mask. Both threads will be bound to that CPU.
 Init pthread attribute. 
 Set CPU 0 mask into the pthread attribute. 
 Bind to CPU 0 , tm_una_pong, NULL);
 Name it for systemtap convenience 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2015, Michael Neuling, IBM Corp.
  Test the kernel's signal return code to ensure that it doesn't
  crash when both the transactional and suspend MSR bits are set in
  the signal context.
  For this test, we send ourselves a SIGUSR1.  In the SIGUSR1 handler
  we modify the signal context to set both MSR TM S and T bits (which
  is "reserved" by the PowerISA). When we return from the signal
  handler (implicit sigreturn), the kernel should detect reserved MSR
  value and send us with a SIGSEGV.
 Link tm checkpointed context to normal context 
 Set all TM bits so that the context is now invalid 
 Should segv on return becuase of invalid context 
 We shouldn't get here as we exit in the segv handler 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2018, Breno Leitao, Gustavo Romero, IBM Corp.
  This test raises a SIGUSR1 signal, and toggle the MSR[TS]
  fields at the signal handler. With MSR[TS] being set, the kernel will
  force a recheckpoint, which may cause a segfault when returning to
  user space. Since the test needs to re-run, the segfault needs to be
  caught and handled.
  In order to continue the test even after a segfault, the context is
  saved prior to the signal being raised, and it is restored when there is
  a segmentation fault. This happens for COUNT_MAX times.
  This test never fails (as returning EXIT_FAILURE). It either succeeds,
  or crash the kernel (on a buggy kernel).
 Number of interactions 
  This test only runs on 64 bits system. Unsetting MSR_TS_S to avoid
  compilation issue on 32 bits system. There is no side effect, since the
  whole test will be skipped if it is not running on 64 bits system.
 Setting contexts because the test will crash and we want to recover 
 count is changed in the signal handler, so it must be volatile 
	
	  Allocating memory in a signal handler, and never freeing it on
	  purpose, forcing the heap increase, so, the memory leak is what
	  we want here.
 Forcing the page to be allocated in a page fault 
 Forcing to enable MSR[TM] 
	
	  A fork inside a signal handler seems to be more efficient than a
	  fork() prior to the signal being raised.
		
		  Both child and parent will return, but, child returns
		  with count set so it will exit in the next segfault.
		  Parent will continue to loop.
	
	  If the change above does not hit the bug, it will cause a
	  segmentation fault, since the ck structures are NULL.
 Reexecute the test 
	
	  Set initial context. Will get back here from
	  seg_signal_handler()
 Allocated an alternative signal stack area 
 Force the allocation through a page fault 
		
		  Setting an alternative stack to generate a page fault when
		  the signal is raised.
 The signal handler will enable MSR_TS 
 If it does not crash, it might segfault, avoid it to retest 
	
	  Skipping if not running on 64 bits system, since I think it is
	  not possible to set mcontext's [MSR] with TS, due to it being 32
	  bits.
 SPDX-License-Identifier: GPL-2.0
 Test context switching to see if the DSCR SPR is correctly preserved
  when within a transaction.
  Note: We assume that the DSCR has been left at the default value (0)
  for all CPUs.
  Method:
  Set a value into the DSCR.
  Start a transaction, and suspend it ().
  Hard loop checking to see if the transaction has become doomed.
  Now that we may have been preempted, record the DSCR and TEXASR SPRS.
  If the abort was because of a context switch, check the DSCR value.
  Otherwise, try again.
  () If the transaction is not suspended we can't see the problem because
  the transaction abort handler will restore the DSCR to it's checkpointed
  value before we regain control.
 set a known value into the DSCR 
 start and suspend a transaction 
 hard loop until the transaction becomes doomed 
 record DSCR and TEXASR 
 make sure the transaction aborted 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2016, Cyril Bur, IBM Corp.
  Test the kernel's signal frame code.
  The kernel sets up two sets of ucontexts if the signal was to be
  delivered while the thread was in a transaction (referred too as
  first and second contexts).
  Expected behaviour is that the checkpointed state is in the user
  context passed to the signal handler (first context). The speculated
  state can be accessed with the uc_link pointer (second context).
  The rationale for this is that if TM unaware code (which linked
  against TM libs) installs a signal handler it will not know of the
  speculative nature of the 'live' registers and may infer the wrong
  thing.
 Number of non-volatile VMX registers 
 First non-volatile register to check in vr20-31 subset 
 Test only non-volatile registers, i.e. 12 vmx registers from vr20 to vr31 
 First context will be set with these values, i.e. non-speculative 
 VMX20     ,  VMX21      , ... 
 Second context will be set with these values, i.e. speculative 
 VMX20        , VMX21            , ... 
 Check first context. Print all mismatches. 
 Print actual value in first context. 
 Print expected value. 
 Check second context. Print all mismatches. 
 Print actual value in second context. 
 Print expected value. 
		
		  tm_signal_self_context_load will set both first and second
		  contexts accordingly to the values passed through non-NULL
		  array pointers to it, in that case 'vms', and invoke the
		  signal handler installed for SIGUSR1.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2015, Sam Bobroff, IBM Corp.
  Test the kernel's system call code to ensure that a system call
  made from within an active HTM transaction is aborted with the
  correct failure code.
  Conversely, ensure that a system call made from within a
  suspended transaction can succeed.
 scv syscall 
 seconds 
		
		  Test a syscall within a suspended transaction and verify
		  that it succeeds.
 Should succeed. 
		
		  Test a syscall within an active transaction and verify that
		  it fails with the correct failure code.
 Should fail... 
 ...persistently... 
 ...with code syscall. 
 Now do it all again with scv if it is available. 
 Should succeed. 
 Should fail... 
 ...persistently... 
 ...with code syscall. 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2015, Michael Neuling, IBM Corp.
  Original: Michael Neuling 1972013
  Edited: Rashmica Gupta 01122015
  Do some transactions, see if the tar is corrupted.
  If the transaction is aborted, the TAR should be rolled back to the
  checkpointed value before the transaction began. The value written to
  TAR in suspended mode should only remain in TAR if the transaction
  completes.
 tar = 1 
 Loop lots, to use time 
 Start loop 
 tar = 2 
 tar = 3 
 Transaction sucess! TAR should be 3 
 res = 3|4 = 7
 Abort handler. TAR should be rolled back to 1 
 res = 1|8 = 9
		 If result is anything else other than 7 or 9, the tar
 A low number of iterations (eg 100) can cause a false pass 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2015, Michael Neuling, IBM Corp.
  Original: Michael Neuling 4122013
  Edited: Rashmica Gupta 4122015
  See if the altivec state is leaked out of an aborted transaction due to
  kernel vmx copy loops.
  When the transaction aborts, VSR values should rollback to the values
  they held before the transaction commenced. Using VSRs while transaction
  is suspended should not affect the checkpointed values.
  (1) write A to a VSR
  (2) start transaction
  (3) suspend transaction
  (4) change the VSR to B
  (5) trigger kernel vmx copy loop
  (6) abort transaction
  (7) check that the VSR value is A
 set 40 to initial value
 set 40 to 0 
 cause kernel vmx copy page 
 Abort handler 
 SPDX-License-Identifier: GPL-2.0
  Test that loadsstores expand the stack segment, or trigger a SEGV, in
  various conditions.
  Based on test code by Tom Lane.
  Consume stack until the stack pointer is below @target_sp, then do an access
  (load or store) at offset @delta from either the base of the stack or the
  current stack pointer.
 We don't really need this, but without it GCC might not
 generate a recursive call above.
 Do something to prevent the stack frame being popped prior to
 our access above.
 We don't expect a non-zero exit that's not a signal
 This is fairly arbitrary but is well below any of the targets below,
 so that the delta between the stack pointer and the target is large.
 We should be able to access anywhere within the rlimit
 But if we go past the rlimit it should fail
 SPDX-License-Identifier: GPL-2.0
 This must match the huge page & THP size 
		
		  Typically the mmap will fail because no huge pages are
		  allocated on the system. But if there are huge pages
		  allocated the mmap will succeed. That's fine too, we just
		  munmap here before continuing.  munmap() length of
		  MAP_HUGETLB memory must be hugepage aligned.
	
	  Either a user or kernel access is sufficient to trigger the bug.
	  A kernel access is easier to spot & debug, as it will trigger the
	  softlockup or RCU stall detectors, and when the system is kicked
	  into xmon we get a backtrace in the kernel.
	 
	  A good option is:
	   getcwd(p, SIZE);
	 
	  For the purposes of this testcase it's preferable to spin in
	  userspace, so the harness can kill us if we get stuck. That way we
	  see a test failure rather than a dead system.
 10,000 because it's a "bunch", and completes reasonably quickly 
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2019, Michael Ellerman, IBM Corp.
 Test that allocating memory beyond the memory limit and then forking is
 handled correctly, ie. the child is able to access the mappings beyond the
 memory limit and the child's writes are not visible to the parent.
 "Should be safe" above 512TB
 Create a mapping at 512TB to allocate an extended_id
 Prevent compiler optimisation
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2018, Michael Ellerman, IBM Corp.
  Test that an out-of-bounds branch to counter behaves as expected.
 inputs
 outputs
 we didn't segv? 
 SPDX-License-Identifier: GPL-2.0
  Test that signal delivery is able to expand the stack segment without
  triggering a SEGV.
  Based on test code by Tom Lane.
 Test with used stack from 1MB - 64K to 1MB + 64K
 Increment by 64 to get more coverage of odd sizes
 SPDX-License-Identifier: GPL-2.0
  Copyright 2020, Sandipan Das, IBM Corp.
  Test if the signal information reports the correct memory protection
  key upon getting a key access violation fault for a page that was
  attempted to be protected by two different keys from two competing
  threads at the same time.
 Check if this fault originated from a pkey access violation 
 Check if this fault originated from the expected address 
 Check if this fault originated from the restrictive pkey 
 Check if too many faults have occurred for the same iteration 
	
	  If the current fault occurred due to lack of execute rights,
	  reassociate the page with the exec-only pkey since execute
	  rights cannot be changed directly for the faulting pkey as
	  IAMR is inaccessible from userspace.
	 
	  Otherwise, if the current fault occurred due to lack of
	  read-write rights, change the AMR permission bits for the
	  pkey.
	 
	  This will let the test continue.
 No read, write and execute restrictions 
 Allocate the permissive pkey 
	
	  Repeatedly try to protect the common region with a permissive
	  pkey
		
		  Wait until the other thread has finished allocating the
		  restrictive pkey or until the next iteration has begun
 Try to associate the permissive pkey with the region 
 Free the permissive pkey 
 Allocate the restrictive pkey 
	
	  Repeatedly try to protect the common region with a restrictive
	  pkey and read, write or execute from it
		
		  Wait until the other thread has finished allocating the
		  permissive pkey or until the next iteration has begun
 Try to associate the restrictive pkey with the region 
 Choose a random instruction word address from the region 
 Read protection test 
			
			  Read an instruction word from the region and
			  verify if it has not been overwritten to
			  something unexpected
 Write protection test 
			
			  Write an instruction word to the region and
			  verify if the overwrite has succeeded
 Execute protection test 
 Jump to the region and execute instructions 
		
		  Restore the restrictions originally imposed by the
		  restrictive pkey as the signal handler would have
		  cleared out the corresponding AMR bits
 Free restrictive pkey 
 Exhaustively allocate all available pkeys 
 Free all allocated pkeys 
 Allocate the region 
	
	  Fill the region with no-ops with a branch at the end
	  for returning to the caller
 Setup SIGSEGV handler 
	
	  For these tests, the parent process should clear all bits of
	  AMR and IAMR, i.e. impose no restrictions, for all available
	  pkeys. This will be the base for the initial AMR and IAMR
	  values for all the test thread pairs.
	 
	  If the AMR and IAMR bits of all available pkeys are cleared
	  before running the tests and a fault is generated when
	  attempting to read, write or execute instructions from a
	  pkey protected region, the pkey responsible for this must be
	  the one from the protect-and-access thread since the other
	  one is fully permissive. Despite that, if the pkey reported
	  by siginfo is not the restrictive pkey, then there must be a
	  kernel bug.
 Setup barrier for protect and protect-and-access threads 
 Setup and start protect and protect-and-read threads 
 Setup and start protect and protect-and-write threads 
 Setup and start protect and protect-and-execute threads 
 Cleanup 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2017 John Sperbeck
  Test that an access to a mapped but inaccessible area causes a SEGV and
  reports si_code == SEGV_ACCERR.
	
	  We just need a compiler barrier, but mb() works and has the nice
	  property of being easy to spot in the disassembly.
 SPDX-License-Identifier: GPL-2.0
  Copyright 2019, Nick Piggin, Gautham R. Shenoy, Aneesh Kumar K.V, IBM Corp.
  Test tlbiemtpidr race. We have 4 threads doing flushloadcomparestore
  sequence in a loop. The same threads also rung a context switch task
  that does sched_yield() in loop.
  The snapshot thread mark the mmap area PROT_READ in between, make a copy
  and copy it back to the original area. This helps us to detect if any
  store continued to happen after we marked the memory PROT_READ.
  A "rim-sequence" is defined to be the sequence of the following
  operations performed on a memory word:
 	1) FLUSH the contents of that word.
 	2) LOAD the contents of that word.
 	3) COMPARE the contents of that word with the content that was
 	           previously stored at that word
 	4) STORE new content into that word.
  The threads in this test that perform the rim-sequence are termed
  as rim_threads.
  A "corruption" is defined to be the failed COMPARE operation in a
  rim-sequence.
  A rim_thread that detects a corruption informs about it to all the
  other rim_threads, and the mem_snapshot thread.
  This defines the maximum number of rim_threads in this test.
  The THREAD_ID_BITS denote the number of bits required
  to represent the thread_ids [0..MAX_THREADS - 1].
  We are being a bit paranoid here and set it to 8 bits,
  though 6 bits suffice.
  Each rim_thread works on an exclusive "chunk" of size
  RIM_CHUNK_SIZE.
  The ith rim_thread works on the ith chunk.
  The ith chunk begins at
  map1 + (i  RIM_CHUNK_SIZE)
  The "word-offset" of a word-aligned address inside a chunk, is
  defined to be the number of words that precede the address in that
  chunk.
  WORD_OFFSET_BITS denote the number of bits required to represent
  the word-offsets of all the word-aligned addresses of a chunk.
  A "sweep" is defined to be the sequential execution of the
  rim-sequence by a rim_thread on its chunk one word at a time,
  starting from the first word of its chunk and ending with the last
  word of its chunk.
  Each sweep of a rim_thread is uniquely identified by a sweep_id.
  SWEEP_ID_BITS denote the number of bits required to represent
  the sweep_ids of rim_threads.
  As to why SWEEP_ID_BITS are computed as a function of THREAD_ID_BITS,
  WORD_OFFSET_BITS, and WORD_BITS, see the "store-pattern" below.
  A "store-pattern" is the word-pattern that is stored into a word
  location in the 4)STORE step of the rim-sequence.
  In the store-pattern, we shall encode:
       - The thread-id of the rim_thread performing the store
         (The most significant THREAD_ID_BITS)
       - The word-offset of the address into which the store is being
         performed (The next WORD_OFFSET_BITS)
       - The sweep_id of the current sweep in which the store is
         being performed. (The lower SWEEP_ID_BITS)
  Store Pattern: 32 bits
  |------------------|--------------------|---------------------------------|
  |    Thread id     |  Word offset       |         sweep_id                |
  |------------------|--------------------|---------------------------------|
     THREAD_ID_BITS     WORD_OFFSET_BITS          SWEEP_ID_BITS
  In the store pattern, the (Thread-id + Word-offset) uniquely identify the
  address to which the store is being performed i.e,
     address == map1 +
               (Thread-id  RIM_CHUNK_SIZE) + (Word-offset  WORD_SIZE)
  And the sweep_id in the store pattern identifies the time when the
  store was performed by the rim_thread.
  We shall use this property in the 3)COMPARE step of the
  rim-sequence.
  Compute the store pattern for a given thread with id @tid, at
  location @addr in the sweep identified by @sweep_id
 Extract the thread-id from the given store-pattern 
 Extract the word-offset from the given store-pattern 
 Extract the sweep-id from the given store-pattern 
           Logging the output of the verification          
  When a COMPARE step of a rim-sequence fails, the rim_thread informs
  everyone else via the shared_memory pointed to by
  corruption_found variable. On seeing this, every thread verifies the
  content of its chunk as follows.
  Suppose a thread identified with @tid was about to store (but not
  yet stored) to @next_store_addr in its current sweep identified
  @cur_sweep_id. Let @prev_sweep_id indicate the previous sweep_id.
  This implies that for all the addresses @addr < @next_store_addr,
  Thread @tid has already performed a store as part of its current
  sweep. Hence we expect the content of such @addr to be:
     |-------------------------------------------------|
     | tid   | word_offset(addr) |    cur_sweep_id     |
     |-------------------------------------------------|
  Since Thread @tid is yet to perform stores on address
  @next_store_addr and above, we expect the content of such an
  address @addr to be:
     |-------------------------------------------------|
     | tid   | word_offset(addr) |    prev_sweep_id    |
     |-------------------------------------------------|
  The verifier function @verify_chunk does this verification and logs
  any anamolies that it finds.
Flush before reading
 haven't reproduced with this setting, it kills random preemption which may be a factor 
  This function is executed by every rim_thread.
  This function performs sweeps over the exclusive chunks of the
  rim_threads executing the rim-sequence one word at a time.
 word access 
	
	  Let us initialize the chunk:
	 
	  Each word-aligned address addr in the chunk,
	  is initialized to :
	     |-------------------------------------------------|
	     | tid   | word_offset(addr) |         0           |
	     |-------------------------------------------------|
			
			  Compute the pattern that we would have
			  stored at this location in the previous
			  sweep.
			
			  FLUSH:Ensure that we flush the contents of
			        the cache before loading
Flush
 LOAD: Read the value 
Load
			
			  COMPARE: Is it the same as what we had stored
			           in the previous sweep ? It better be!
 No it isn't! Tell everyone 
			
			  Before performing a store, let us check if
			  any rim_thread has found a corruption.
				
				  Yes. Someone (including us!) has found
				  a corruption :(
				 
				  Let us verify that our chunk is
				  correct.
 But first, let us allow the dust to settle down! 
			
			  Compute the new pattern that we are going
			  to write to this location
			
			  STORE: Now let us write this pattern into
			         the location
 Stop memory migration once corruption is found 
		
		  Load from the working alias (map1). Loading from map2
		  also fails.
		
		  Stores must go via map2 which has write permissions, but
		  the corrupted data tends to be seen in the snapshot buffer,
		  so corruption does not appear to be introduced at the
		  copy-back via map2 alias here.
		
		  Before releasing other threads, must ensure the copy
		  back to
 This value makes a big difference 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2016, Michael Ellerman, IBM Corp.
	
	  SAO was introduced in 2.06 and removed in 3.1. It's disabled in
	  guestsLPARs by default, so also skip if we are running in a guest.
	
	  Ensure we can ask for PROT_SAO.
	  We can't really verify that it does the right thing, but at least we
	  confirm the kernel will accept it.
 Write to the mapping, to at least cause a fault 
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2020, Sandipan Das, IBM Corp.
  Test if applying execute protection on pages using memory
  protection keys works as expected.
 Check if this fault originated from the expected address 
 Check if this fault originated from the expected address 
 Check if too many faults have occurred for a single test case 
 Restore permissions in order to continue 
			
			  Reassociate the exec-only pkey with the region
			  to be able to continue. Unlike AMR, we cannot
			  set IAMR directly from userspace to restore the
			  permissions.
 Setup SIGSEGV handler 
 Setup SIGTRAP handler 
 Setup executable region 
 Write the instruction words 
	
	  Set the first instruction as an unconditional trap. If
	  the last write to this address succeeds, this should
	  get overwritten by a no-op.
	
	  Later, to jump to the executable region, we use a branch
	  and link instruction (bctrl) which sets the return address
	  automatically in LR. Use that to return back.
 Allocate a pkey that restricts execution 
	
	  Pick the first instruction's address from the executable
	  region.
 The following two cases will avoid SEGV_PKUERR 
	
	  Read an instruction word from the address when AMR bits
	  are not set i.e. the pkey permits both read and write
	  access.
	 
	  This should not generate a fault as having PROT_EXEC
	  implies PROT_READ on GNU systems. The pkey currently
	  restricts execution only based on the IAMR bits. The
	  AMR bits are cleared.
	
	  Write an instruction word to the address when AMR bits
	  are not set i.e. the pkey permits both read and write
	  access.
	 
	  This should generate an access fault as having just
	  PROT_EXEC also restricts writes. The pkey currently
	  restricts execution only based on the IAMR bits. The
	  AMR bits are cleared.
 The following three cases will generate SEGV_PKUERR 
	
	  Read an instruction word from the address when AMR bits
	  are set i.e. the pkey permits neither read nor write
	  access.
	 
	  This should generate a pkey fault based on AMR bits only
	  as having PROT_EXEC implicitly allows reads.
	
	  Write an instruction word to the address when AMR bits
	  are set i.e. the pkey permits neither read nor write
	  access.
	 
	  This should generate two faults. First, a pkey fault
	  based on AMR bits and then an access fault since
	  PROT_EXEC does not allow writes.
 Free the current pkey 
		
		  Allocate pkeys with all valid combinations of read,
		  write and execute restrictions.
		
		  Jump to the executable region. AMR bits may or may not
		  be set but they should not affect execution.
		 
		  This should generate pkey faults based on IAMR bits which
		  may be set to restrict execution.
		 
		  The first iteration also checks if the overwrite of the
		  first instruction word from a trap to a no-op succeeded.
 Free the current pkey 
 Find next valid combination of pkey rights 
 Cleanup 
  Copyright IBM Corp.
  This program is free software; you can redistribute it andor modify it
  under the terms of version 2.1 of the GNU Lesser General Public License
  as published by the Free Software Foundation.
  This program is distributed in the hope that it would be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
	
	  for each page, mark subpage i % 16 read only and subpage
	  (i + 3) % 16 inaccessible
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2019, Michael Ellerman, IBM Corp.
 Test that out-of-bounds readswrites behave as expected.
 Old distros (Ubuntu 16.04 at least) don't define this
 64-bit kernel is always here
 If we see MAPERR that means we took a page fault rather than an SLB
 miss. We only expect to take page faults for addresses within the
 valid kernel range.
 We have 7 512T regions (4 kernel linear, vmalloc, io, vmemmap)
 We have 7 64T regions (4 kernel linear, vmalloc, io, vmemmap)
 This generates access patterns like:
   0x0010000000000000
   0x0010000000010000
   0x0010000000020000
   ...
   0x0014000000000000
   0x0018000000000000
   0x0020000000000000
   0x0020000000010000
   0x0020000000020000
   ...
   0xf400000000000000
   0xf800000000000000
 SPDX-License-Identifier: GPL-2.0-or-later
  Ptrace test for GPRFPR registers
  Copyright (C) 2015 Anshuman Khandual, IBM Corporation.
 Tracer and Tracee Shared Data 
 SPDX-License-Identifier: GPL-2.0+
  Ptrace test for Memory Protection Key registers
  Copyright (C) 2015 Anshuman Khandual, IBM Corporation.
  Copyright (C) 2018 IBM Corporation.
 Information shared between the parent and the child. 
 AMR value the parent expects to read from the child. 
 AMR value the parent is expected to write to the child. 
 AMR value that ptrace should refuse to write to the child. 
 IAMR value the parent expects to read from the child. 
 UAMOR value the parent expects to read from the child. 
	
	  IAMR and UAMOR values that ptrace should refuse to write to the child
	  (even though they're valid ones) because userspace doesn't have
	  access to those registers.
 Wait until parent fills out the initial register values. 
 Get some pkeys so that we can change their bits in the AMR. 
	
	  invalid amr value where we try to force write
	  things which are deined by a uamor setting.
	
	  if PKEY_DISABLE_EXECUTE succeeded we should update the expected_iamr
	
	  We allocated pkey2 and pkey 3 above. Clear the IAMR bits.
	
	  Create an IAMR value different from expected value.
	  Kernel will reject an IAMR and UAMOR change.
 Wait for parent to read our AMR value and write a new one. 
	
	  Wait for parent to try to write an invalid AMR value.
	
	  Wait for parent to try to write an IAMR and a UAMOR value. We can't
	  verify them, but we can verify that the AMR didn't change.
 Now let parent now that we are finished. 
	
	  Get the initial values for AMR, IAMR and UAMOR and communicate them
	  to the child.
 Wake up child so that it can set itself up. 
 Verify that we can read the pkey registers from the child. 
 Write valid AMR value in child. 
 Wake up child so that it can verify it changed. 
 Write invalid AMR value in child. 
 Wake up child so that it can verify it didn't change. 
 Try to write to IAMR. 
 Try to write to IAMR and UAMOR. 
 Verify that all registers still have their expected values. 
 Wake up child so that it can verify AMR didn't change and wrap up. 
 SPDX-License-Identifier: GPL-2.0-or-later
  Ptrace test for GPRFPR registers in TM context
  Copyright (C) 2015 Anshuman Khandual, IBM Corporation.
 Tracer and Tracee Shared Data 
 Transaction abort handler 
 SPDX-License-Identifier: GPL-2.0-or-later
  Ptrace test for VMXVSX registers in the TM Suspend context
  Copyright (C) 2015 Anshuman Khandual, IBM Corporation.
 SPDX-License-Identifier: GPL-2.0-or-later
  Ptrace test for VMXVSX registers
  Copyright (C) 2015 Anshuman Khandual, IBM Corporation.
 Tracer and Tracee Shared Data 
 SPDX-License-Identifier: GPL-2.0-or-later
  Ptrace test for TAR, PPR, DSCR registers
  Copyright (C) 2015 Anshuman Khandual, IBM Corporation.
 Tracer and Tracee Shared Data 
 Wait on parent 
 Unblock the parent now 
 TAR was added in v2.07
 Unblock the child now 
 Wait on child 
 SPDX-License-Identifier: GPL-2.0
  A ptrace test for testing PTRACE_SYSEMU, PTRACE_SETREGS and
  PTRACE_GETREG.  This test basically create a child process that executes
  syscalls and the parent process check if it is being traced appropriated.
  This test is heavily based on toolstestingselftestsx86ptrace_syscall.c
  test, and it was adapted to run on Powerpc by
  Breno Leitao <leitao@debian.org>
 Bitness-agnostic defines for user_regs_struct fields. 
	
	  Child process is running 4 syscalls after ptrace.
	 
	  1) getpid()
	  2) gettid()
	  3) tgkill() -> Send SIGSTOP
	  4) gettid() -> Where the tests will happen essentially
 Parent process below 
 Wait for SIGSTOP sent by tgkill above. 
	
	  Ptrace trapped prior to executing the syscall, thus r3 still has
	  the syscall number instead of the sys_gettid() result
	
	  Rewind to retry the same syscall again. This will basically test
	  the rewind process together with PTRACE_SETREGS and PTRACE_GETREGS.
	
	  Inject a new syscall (getpid) in the same place the previous
	  syscall (gettid), rewind and re-execute.
	 Check that ptrace stopped at the new syscall that was
	  injected, and guarantee that it haven't executed, i.e, user_args
	  contain the arguments and not the syscall return value, for
	  instance.
 Guarantee that the process executed properly, returning 0 
 SPDX-License-Identifier: GPL-2.0-or-later
  perf events self profiling example test case for hw breakpoints.
  This tests perf PERF_TYPE_BREAKPOINT parameters
  1) tests all variants of the break on readwrite flags
  2) tests exclude_user == 0 and 1
  3) test array matches (if DAWR is supported))
  4) test different numbers of breakpoints matches
  Configure this breakpoint, then read and write the data a number of
  times. Then check the output count from perf is as expected.
  Based on:
    http:ozlabs.org~antonjunkcodeperf_events_example1.c
  Copyright (C) 2018 Michael Neuling, IBM Corporation.
 Assume online processors are 0 to nprocs for simplisity 
 bp_addr can point anywhere but needs to be aligned 
 provide some variability 
 align to 0x400 boundary as required by DAWR 
 start counters 
 Test a bunch of reads and writes 
 stop counters 
 read and check counters 
 we read and write each loop, so subtract the ones we are counting 
 watch middle half of target array 
 Shouldn't hit. 
 Hit 
 Hit 
 Shouldn't Hit 
 Hit 
 There is no perf api to find number of available watchpoints. Use ptrace. 
	
	  perf defines rwflag as two bits read and write and at least
	  one must be set.  So range 1-3.
 if we have the dawr, we can do an array test 
 SPDX-License-Identifier: GPL-2.0-or-later
  Ptrace test for TAR, PPR, DSCR registers in the TM Suspend context
  Copyright (C) 2015 Anshuman Khandual, IBM Corporation.
 TAR_1 
 DSCR_1 
 PPR_1
 TAR_2 
 DSCR_2 
 PPR_2 
 TAR_3 
 DSCR_3 
 PPR_3 
 Transaction abort handler 
 TM failed, analyse 
 SPDX-License-Identifier: GPL-2.0+
  Ptrace test for hw breakpoints
  Based on toolstestingselftestsbreakpointsbreakpoint_test.c
  This test forks and the parent then traces the child doing various
  types of ptrace enabled breakpoints
  Copyright (C) 2018 Michael Neuling, IBM Corporation.
  Use volatile on all global var so that compiler doesn't
  optimise their loadstores. Otherwise selftest can fail.
 double word aligned 
 double word unaligned 
 Wake up father so that it sets up the first test 
 PTRACE_SET_DEBUGREG, WO test 
 PTRACE_SET_DEBUGREG, RO test 
 PTRACE_SET_DEBUGREG, RW test 
 PTRACE_SET_DEBUGREG, Kernel Access Userspace test 
 PPC_PTRACE_SETHWDEBUG, MODE_EXACT, WO test 
 PPC_PTRACE_SETHWDEBUG, MODE_EXACT, RO test 
 PPC_PTRACE_SETHWDEBUG, MODE_EXACT, RW test 
 PPC_PTRACE_SETHWDEBUG, MODE_EXACT, Kernel Access Userspace test 
 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW ALIGNED, WO test 
 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW ALIGNED, RO test 
 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW ALIGNED, RW test 
 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW UNALIGNED, WO test 
 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW UNALIGNED, RO test 
 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW UNALIGNED, RW test 
 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW UNALIGNED, DAR OUTSIDE, RW test 
 PPC_PTRACE_SETHWDEBUG. DAWR_MAX_LEN. RW test 
 PPC_PTRACE_SETHWDEBUG 2, MODE_RANGE, DW ALIGNED, WO test 
 PPC_PTRACE_SETHWDEBUG 2, MODE_RANGE, DW UNALIGNED, RO test 
 PPC_PTRACE_SETHWDEBUG 2, MODE_RANGE, DAWR Overlap, WO test 
 PPC_PTRACE_SETHWDEBUG 2, MODE_RANGE, DAWR Overlap, RO test 
 Wait for the child to SIGTRAP 
		
		  For ptrace registered watchpoint, signal is generated
		  before executing loadstore. Singlestep the instruction
		  and then continue the test.
 PTRACE_SET_DEBUGREG, WO test
 PTRACE_SET_DEBUGREG, RO test 
 PTRACE_SET_DEBUGREG, RW test 
 PTRACE_SET_DEBUGREG, Kernel Access Userspace test 
 hardcoded in kernel 
 PPC_PTRACE_SETHWDEBUG, MODE_EXACT, WO test 
 PPC_PTRACE_SETHWDEBUG, MODE_EXACT, RO test 
 PPC_PTRACE_SETHWDEBUG, MODE_EXACT, RW test 
 hardcoded in kernel 
 PPC_PTRACE_SETHWDEBUG, MODE_EXACT, Kernel Access Userspace test 
 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW ALIGNED, WO test 
 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW ALIGNED, RO test 
 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW ALIGNED, RW test 
 PPC_PTRACE_SETHWDEBUG 2, MODE_RANGE, DW ALIGNED, WO test 
 PPC_PTRACE_SETHWDEBUG 2, MODE_RANGE, DW UNALIGNED, RO test 
 PPC_PTRACE_SETHWDEBUG 2, MODE_RANGE, DAWR Overlap, WO test 
 PPC_PTRACE_SETHWDEBUG 2, MODE_RANGE, DAWR Overlap, RO test 
 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW UNALIGNED, WO test 
 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW UNALIGNED, RO test 
 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW UNALIGNED, RW test 
 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW UNALIGNED, DAR OUTSIDE, RW test 
 PPC_PTRACE_SETHWDEBUG, DAWR_MAX_LEN, RW test 
 Set the breakpoints and check the child successfully trigger them 
 Let the child exit first. 
	
	  Testcases exits immediately with -1 on any failure. If
	  it has reached here, it means all tests were successful.
 SPDX-License-Identifier: GPL-2.0-or-later
  Ptrace test for TAR, PPR, DSCR registers in the TM context
  Copyright (C) 2015 Anshuman Khandual, IBM Corporation.
 TAR_1 
 DSCR_1 
 PPR_1
 TAR_2 
 DSCR_2 
 PPR_2 
 Transaction abort handler 
 TM failed, analyse 
 SPDX-License-Identifier: GPL-2.0+
  Ptrace test for Memory Protection Key registers
  Copyright (C) 2015 Anshuman Khandual, IBM Corporation.
  Copyright (C) 2018 IBM Corporation.
 5 MB should be enough 
 Information shared between the parent and the child. 
 AMR value the parent expects to read in the core file. 
 IAMR value the parent expects to read in the core file. 
 UAMOR value the parent expects to read in the core file. 
 When the child crashed. 
 Wait until parent fills out the initial register values. 
 Get some pkeys so that we can change their bits in the AMR. 
	
	  We won't use pkey3. This tests whether the kernel restores the UAMOR
	  permissions after a key is freed.
 Crash. 
 Shouldn't get here. 
 Return file size if filename exists and pass sanity check, or zero if not. 
 Make sure we're not using a stale core file. 
	
	  e_phnum is at most 65535 so calculating the size of the
	  program header cannot overflow.
 Sanity check the program header table location. 
 Find the PT_NOTE segment. 
 Find the NT_PPC_PKEY note. 
	
	  Get the initial values for AMR, IAMR and UAMOR and communicate them
	  to the child.
 Wake up child so that it can set itself up. 
 Construct array of core file names to try. 
 Check whether we can predict the name of the core file. 
 SPDX-License-Identifier: GPL-2.0-or-later
  Ptrace test for VMXVSX registers in the TM context
  Copyright (C) 2015 Anshuman Khandual, IBM Corporation.
 SPDX-License-Identifier: GPL-2.0+
 Overlapping address range 
 Non-overlapping address range 
 --> parent (SIGUSR1) 
	 Test:
	  if (new per thread event by ptrace)
	 	if (existing cpu event by perf)
	 		if (addr range overlaps)
	 			fail;
	 Test:
	  if (new per thread event by ptrace)
	 	if (existing cpu event by perf)
	 		if (addr range does not overlaps)
	 			allow;
	 Test:
	  if (new per thread event by ptrace)
	 	if (existing thread event by perf on the same thread)
	 		if (addr range overlaps)
	 			fail;
	 Test:
	  if (new per thread event by ptrace)
	 	if (existing thread event by perf on the same thread)
	 		if (addr range does not overlaps)
	 			fail;
	 Test:
	  if (new per thread event by ptrace)
	 	if (existing thread event by perf on the different thread)
	 		allow;
 Temporary Child 
	 Test:
	  if (new per thread kernel event by perf)
	 	if (existing thread event by ptrace on the same thread)
	 		allow;
	  -- OR --
	  if (new per cpu kernel event by perf)
	 	if (existing thread event by ptrace)
	 		allow;
	 Test:
	  if (new per thread event by perf)
	 	if (existing thread event by ptrace on the same thread)
	 		if (addr range overlaps)
	 			fail;
	 Test:
	  if (new per thread event by perf)
	 	if (existing thread event by ptrace on the same thread)
	 		if (addr range does not overlaps)
	 			allow;
	 Test:
	  if (new per thread event by perf)
	 	if (existing thread event by ptrace on the other thread)
	 		allow;
 Temporary Child 
	 Test:
	  if (new per cpu event by perf)
	 	if (existing thread event by ptrace on the same thread)
	 		if (addr range overlaps)
	 			fail;
	 Test:
	  if (new per cpu event by perf)
	 	if (existing thread event by ptrace on the same thread)
	 		if (addr range does not overlap)
	 			allow;
	 Test:
	  if (new per thread and per cpu event by perf)
	 	if (existing thread event by ptrace on the same thread)
	 		if (addr range overlaps)
	 			fail;
	 Test:
	  if (new per thread and per cpu event by perf)
	 	if (existing thread event by ptrace on the same thread)
	 		if (addr range does not overlap)
	 			allow;
	 Test:
	  if (new per thread and per cpu event by perf)
	 	if (existing thread event by ptrace on the other thread)
	 		allow;
 Temporary Child 
 parent 
 <-- child (SIGUSR1) 
 SPDX-License-Identifier: GPL-2.0-or-later
  Ptrace test for GPRFPR registers in TM Suspend context
  Copyright (C) 2015 Anshuman Khandual, IBM Corporation.
 Tracer and Tracee Shared Data 
 Transaction abort handler 
 SPDX-License-Identifier: GPL-2.0-or-later
  Ptrace test TM SPR registers
  Copyright (C) 2015 Anshuman Khandual, IBM Corporation.
 Tracee and tracer shared data 
 TM failover handler should follow "tbegin.;" 
 $ = TFHAR - 12 
 There are 2 32bit instructions before tbegin. 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2020 IBM Corp.
  Author: Bulent Abali <abali@us.ibm.com>
	 Save power and let other threads use the hw. top may show
	  100% but only because OS doesn't know we slowed the this
	  hw thread while polling. We're letting other threads have
	  higher throughput on the core.
		 usleep(0) takes around 29000 ticks ~60 us.
		  300000 is spinning for about 600 us then
		  start sleeping.
 Fault address from signal handler 
 hw has updated csb and output buffer 
 Check CSB flags. 
 spin for few ticks 
 sleep 
 CC Table 6-8 
  Fault in pages prior to NX job submission.  wr=1 may be required to
  touch writeable pages.  System zero pages do not fault-in the page as
  intended.  Typically set wr=1 for NX target pages and set wr=0 for NX
  source pages.
 When buf_sz is small or buf tail is in another page 
 SPDX-License-Identifier: GPL-2.0-or-later
 P9 gunzip sample code for demonstrating the P9 NX hardware
  interface.  Not intended for productive uses or for performance or
  compression ratio measurements.  Note also that devcryptogzip,
  VAS and skiboot support are required
  Copyright 2020 IBM Corp.
  Author: Bulent Abali <abali@us.ibm.com>
  https:github.comlibnxzpower-gzip for zlib api and other utils
  Definitions of acronyms used here.  See
  P9 NX Gzip Accelerator User's Manual for details:
  https:github.comlibnxzpower-gzipblobdevelopdocpower_nx_gzip_um.pdf
  adlercrc: 32 bit checksums appended to stream tail
  ce:       completion extension
  cpb:      coprocessor parameter block (metadata)
  crb:      coprocessor request block (command)
  csb:      coprocessor status block (status)
  dht:      dynamic huffman table
  dde:      data descriptor element (address, length)
  ddl:      list of ddes
  dhfh:    dynamic and fixed huffman types
  fc:       coprocessor function code
  histlen:  historydictionary length
  history:  sliding window of up to 32KB of data
  lzcount:  Deflate LZ symbol counts
  rembytecnt: remaining byte count
  sfbt:     source final block type; last block's type during decomp
  spbc:     source processed byte count
  subc:     source unprocessed bit count
  tebc:     target ending bit count; valid bits in the last byte
  tpbc:     target processed byte count
  vas:      virtual accelerator switch; the user mode interface
 For aligned_alloc()
 For endian.h
 fifo queue management 
 amount of free bytes in the first and last parts 
 amount of used bytes in the first and last parts 
 first and last free parts start here 
 first and last used parts start here 
  Adds an (address, len) pair to the list of ddes (ddl) and updates
  the base dde.  ddl[0] is the only dde in a direct dde which
  contains a single (addr,len) pair.  For more pairs, ddl[0] becomes
  the indirect (base) dde that points to a list of direct ddes.
  See Section 6.4 of the NX-gzip user manual for DDE description.
  Addr=NULL, len=0 clears the ddl[0].  Returns the total number of
  bytes in ddl.  Caller is responsible for allocting the array of
  nx_dde_t ddl.  If N addresses are required in the scatter-gather
  list, the ddl array must have N+1 entries minimum.
 Number of ddes in the dde list ; == 0 when it is a direct dde 
 First dde is unused; make it a direct dde 
		 Converting direct to indirect dde
		  ddl[0] becomes head dde of ddl
		  copy direct to indirect first.
 Add the new dde next 
 Ddl head points to 2 direct ddes 
 Pointer to the first direct dde 
 Append a dde to an existing indirect ddl 
 byte sum of all dde 
  Touch specified number of pages represented in number bytes
  beginning from the first buffer in a dde list.
  Do not touch the pages past buf_sz-th byte's page.
  Set buf_sz = 0 to touch all pages described by the ddep.
 Direct dde 
 Indirect dde 
 First address of the list 
 Touching fewer pages than encoded in the ddebc 
  Src and dst buffers are supplied in scatter gather lists.
  NX function code and other parameters supplied in cmdp.
 Status, output byte count in tpbc 
 NX reports input bytes in spbc; cleared 
 Clear output 
 Submit the crb, the job descriptor, to the accelerator. 
 Queuing, file ops, byte counting 
 1000 max 
 nx hardware 
 when using mmap'ed files 
 Make a new file name to write to.  Ignoring '.gz' 
 Decode the gzip header 
 ID1 
 ID2 
 CM 
 FLG 
	 Read 6 bytes; ignoring the MTIME, XFL, OS fields in this
	  sample code.
 FNAME 
 FHCRC 
	 Allocate one page larger to prevent page faults due to NX
	  overfetching.
	  Either do this (char)(uintptr_t)aligned_alloc or use
	  -std=c11 flag to make the int-to-pointer warning go away.
 Leave unused space due to history rounding rules 
 Read from .gz file 
	 We read in to fifo_in in two steps: first: read in to from
	  cur_in to the end of the buffer.  last: if free space wrapped
	  around, read from fifo_in offset 0 to offset cur_in.
 Reset fifo head to reduce unnecessary wrap arounds 
 Free space total is reduced by a gap 
 Free space may wrap around as first and last 
 Start offsets of the free memory 
 Reduce read_sz because of the line_sz gap 
 Read in to offset cur_in + used_in 
 Either EOF or error; exit the read loop 
 If free space wrapped around 
 Reduce read_sz because of the line_sz gap 
 Increase used space 
 Decrease free space 
 Either EOF or error; exit the read loop 
	 At this point we have used_in bytes in fifo_in with the
	  data head starting at cur_in and possibly wrapping around.
 Write decompressed data to output file 
	 If fifo_out has data waiting, write it out to the file to
	  make free target space for the accelerator used bytes in
	  the first and last parts of fifo_out.
 Move head of the fifo 
 If more data available in the last part 
 Keep it here for later 
 NX decompresses input data 
 Addresslen lists 
 FC, CRC, HistLen, Table 6-6 
		 Resuming a partially decompressed input.
		  The key to resume is supplying the 32KB
		  dictionary (history) to NX, which is basically
		  the last 32KB of output produced.
 Round up the history size to quadword.  Section 2.10 
 bytes 
 Chain in the history buffer to the DDE list 
 Up to 32KB history wraps around fifo_out 
 First decompress job 
 Writing 0 clears out subc as well 
		 Assuming 10% compression ratio initially; use the
		  most recently measured compression ratio as a
		  heuristic to estimate the input and output
		  sizes.  If we give too much input, the target buffer
		  overflows and NX cycles are wasted, and then we
		  must retry with smaller input size.  1000 is 100%.
	
	  NX source buffers
	
	  NX target buffers
 Reduce output free space amount not to overwrite the history 
	 Target buffer size is used to limit the source data size
	  based on previous measurements of compression ratio.
 source_sz includes history 
	 Estimating how much source is needed to 34 fill a
	  target_max size target buffer.  If we overshoot, then NX
	  must repeat the job with smaller input and we waste
	  bandwidth.  If we undershoot then we use more NX calls than
	  necessary.
		 Target might be small, therefore limiting the
		  source data.
		 Source file might be small, therefore limiting target
		  touch pages to a smaller value to save processor cycles.
	 Some NX condition codes require submitting the NX job again.
	  Kernel doesn't handle NX page faults. Expects user code to
	  touch pages.
 Fault in pages 
 Send job to NX 
		 We touched the pages ahead of time.  In the most common case
		  we shouldn't be here.  But may be some pages were paged out.
		  Kernel should have placed the faulting address to fsaddr.
 Try once with exact number of pages 
			 If still faulting try fewer input pages
			  assuming memory outage
		 Not an error in the most common case; it just says
		  there is trailing data that we must examine.
		 
		  CC=3 CE(1)=0 CE(0)=1 indicates partial completion
		  Fig.6-7 and Table 6-8.
			 Check CPB for more information
			  spbc and tpbc are valid
 Table 6-4 
 Table 6-4 
 not an error 
 History length error when CE(1)=1 CE(0)=0. 
		 Target buffer not large enough; retry smaller input
		  data; give at least 1 byte.  SPBCTPBC are not valid.
		 This should not happen for gzip formatted data;
		  we need trailing crc and isize
	 Table 6-4: Source Final Block Type (SFBT) describes the
	  last processed deflate block and clues the software how to
	  resume the next job.  SUBC indicates how many input bits NX
	  consumed but did not process.  SPBC indicates how many
	  bytes of source were given to the accelerator including
	  history bytes.
 Deflate final EOB received 
 Calculating the checksum start position. 
		 Resume decompression cases are below. Basically
		  indicates where NX has suspended and how to resume
		  the input stream.
 Within a literal block; use rembytecount 
 Within a literal block; use rembytecount; bfinal=1 
 Supply the partially processed source byte again 
		 SUBC LS 3bits: number of bits in the first source byte need
		  to be processed.
		  000 means all 8 bits;  Table 6-3
		  Clear subc, histlen, sfbt, rembytecnt, dhtlen
 Within a FH block; 
 Within a FH block; bfinal=1 
 Clear subc, histlen, sfbt, rembytecnt, dhtlen 
 Within a DH block; 
 Within a DH block; bfinal=1 
 Clear subc, histlen, sfbt, rembytecnt, dhtlen 
 Round up to a qword 
 Copy dht from cpb.out to cpb.in 
 Within a block header; bfinal=0; 
		      Also given if source data exactly ends (SUBC=0) with
		       EOB code with BFINAL=0.  Means the next byte will
		       contain a block header.
 within a block header with BFINAL=1. 
 Clear subc, histlen, sfbt, rembytecnt, dhtlen 
 Engine did not process any data 
 Adjust the source and target buffer offsets and lengths  
 Delete input data from fifo_in 
 Add output data to fifo_out 
	 Deflate history is 32KB max.  No need to supply more
	  than 32KB on a resume.
	 To estimate expected expansion in the next NX job; 500 means 50%.
	  Deflate best case is around 1 to 1000.
 More data to write out 
			 Need at least 8 more bytes containing gzip crc
			  and isize.
 Compare checksums and exit 
 SPDX-License-Identifier: GPL-2.0-or-later
 P9 gzip sample code for demonstrating the P9 NX hardware interface.
  Not intended for productive uses or for performance or compression
  ratio measurements.  For simplicity of demonstration, this sample
  code compresses in to fixed Huffman blocks only (Deflate btype=1)
  and has very simple memory management.  Dynamic Huffman blocks
  (Deflate btype=2) are more involved as detailed in the user guide.
  Note also that devcryptogzip, VAS and skiboot support are
  required.
  Copyright 2020 IBM Corp.
  https:github.comlibnxzpower-gzip for zlib api and other utils
  Author: Bulent Abali <abali@us.ibm.com>
  Definitions of acronyms used here. See
  P9 NX Gzip Accelerator User's Manual for details:
  https:github.comlibnxzpower-gzipblobdevelopdocpower_nx_gzip_um.pdf
  adlercrc: 32 bit checksums appended to stream tail
  ce:       completion extension
  cpb:      coprocessor parameter block (metadata)
  crb:      coprocessor request block (command)
  csb:      coprocessor status block (status)
  dht:      dynamic huffman table
  dde:      data descriptor element (address, length)
  ddl:      list of ddes
  dhfh:    dynamic and fixed huffman types
  fc:       coprocessor function code
  histlen:  historydictionary length
  history:  sliding window of up to 32KB of data
  lzcount:  Deflate LZ symbol counts
  rembytecnt: remaining byte count
  sfbt:     source final block type; last block's type during decomp
  spbc:     source processed byte count
  subc:     source unprocessed bit count
  tebc:     target ending bit count; valid bits in the last byte
  tpbc:     target processed byte count
  vas:      virtual accelerator switch; the user mode interface
 For aligned_alloc()
 For endian.h
  LZ counts returned in the user supplied nx_gzip_crb_cpb_t structure.
 clear 
 resuming with no history 
	 Section 6.6 programming notes; spbc may be in two different
	  places depending on FC.
 Figure 6-3 6-4; CSB location 
 Source direct dde (scatter-gather list) 
 Target direct dde (scatter-gather list) 
 Submit the crb, the job descriptor, to the accelerator 
  Prepares a blank no filename no timestamp gzip header and returns
  the number of bytes written to buf.
  Gzip specification at https:tools.ietf.orghtmlrfc1952
 ID1 
 ID2 
 CM  
 FLG 
 MTIME 
 MTIME 
 MTIME 
 MTIME 
 XFL 4=fastest 
 OS UNIX 
 Caller must free the allocated buffer return nonzero on error. 
 Returns nonzero on error 
  Z_SYNC_FLUSH as described in zlib.h.
  Returns number of appended bytes
 Last byte is partially full 
 BFINAL and BTYPE written 
 Zero length block 
  Final deflate block bit.  This call assumes the block
  beginning is byte aligned.
 Generous output buffer for headertrailer 
	
	  On PowerVM, the hypervisor defines the maximum request buffer
	  size is defined and this value is available via sysfs.
 sysfs entry is not available on PowerNV 
 Compress piecemeal in smallish chunks 
 Write the gzip header to the stream 
 Init the CRB, the coprocessor request block 
 Initial gzip crc32 
 Submit chunk size source data per job 
 Supply large target in case data expands 
 Page faults are handled by the user code 
		 Fault-in pages; an improved code wouldn't touch so
		  many pages but would try to estimate the
		  compression ratio and adjust both the src and dst
		  touch amounts.
 Page faults are handled by the user code 
 Reset for the next chunk 
		 Two possible locations for spbc depending on the function
		  code.
 Target byte count 
 Target ending bit count 
 More chunks to go 
			 Round up to the next byte with a flush
			  block; do not set the BFINAqL bit.
 Done 
			 Set the BFINAL bit of the last block per Deflate
			  specification.
 Resuming crc32 for the next chunk 
 Append crc32 and ISIZE to the end 
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2018 IBM Corporation.
 mtspr 3,RS to check for move to DSCR below 
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2018 IBM Corporation.
 The PMU event we use only works on Power7 or later
 disable L1 prefetching
	
	  We expect to see l1d miss for each cacheline access when entry_flush
	  is set. Allow a small variation on this.
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2018-2019 IBM Corporation.
 We could scale all the events by runningenabled but we're lazy
 As long as the PMU is uncontended they should all run
 Works with FAIL_IF()
 Make sure it's NULL terminated
 Trim the trailing newline
 Order matters
 P8 + P9
 P8 + P9
 P9 only
 P9 only
 The PMU events we use only work on Power8 or later
 Count pattern cache too
 These should all not affect userspace branch prediction
			
			  Such a mismatch may be caused by a guest system
			  reporting as vulnerable when the host is mitigated.
			  Return skip code to avoid detecting this as an error.
			  We are not vulnerable and reporting otherwise, so
			  missing such a mismatch is safe.
 This seems to affect userspace branch prediction a bit?
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2018 IBM Corporation.
 The PMU event we use only works on Power7 or later
 disable L1 prefetching
	
	  We expect to see l1d miss for each cacheline access when rfi_flush
	  is set. Allow a small variation on this.
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2018 IBM Corporation.
  Copyright 2020 Canonical Ltd.
 The PMU event we use only works on Power7 or later
 disable L1 prefetching
	
	  We expect to see l1d miss for each cacheline access when entry_flush
	  is set. Allow a small variation on this.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2017, Michael Ellerman, IBM Corp.
 If we found none we're probably on a system where they don't exist 
 But if we found any, we expect to find them all 
 SPDX-License-Identifier: GPL-2.0
  The associativity domain numbers are returned from the hypervisor as a
  stream of mixed 16-bit and 32-bit fields. The stream is terminated by the
  special value of "all ones" (aka. 0xffff) and its size may not exceed 48
  bytes.
     --- 16-bit fields -->
   _________________________
   |  0  |  1  |  2  |  3  |   be_packed[0]
   ------+-----+-----+------
   _________________________
   |  4  |  5  |  6  |  7  |   be_packed[1]
   -------------------------
             ...
   _________________________
   | 20  | 21  | 22  | 23  |   be_packed[5]
   -------------------------
  Convert to the sequence they would appear in the ibm,associativity property.
 Let's fix the values returned by plpar_hcall9() 
			
			  Let's concatenate the 16 bits of this field to the
			  15 lower bits of the previous field
 This is the list terminator 
 Data is in the lower 15 bits of this field 
			
			  Data is in the lower 15 bits of this field
			  concatenated with the next 16 bit field
 The first cell contains the length of the property 
 NOTE: This file is included by a selftest and built in userspace. 
 SPDX-License-Identifier: GPL-2.0
		 Parsing the next 16-bit value out of the next 64-bit input
		  value.
 Parse at most 6 x 64-bit input values 
		 Parsing the next 32-bit value out of the next 64-bit input
		  value.
 Parse at most 6 x 64-bit input values 
		 Parse a 32-bit value split accross two consecutives 64-bit
		  input values.
		 The lower bits in 0x0001ffff don't get mixed up with the
		  0xffff terminator.
		 The following input doesn't follow the specification.
abort();
#define MAX_LEN 512
 printf("from=%p to=%p len=%ld\n", q+dst, q+src, len);
 SPDX-License-Identifier: GPL-2.0
 Fill with sequential bytes 
 SPDX-License-Identifier: GPL-2.0-or-later
  Userspace test harness for load_unaligned_zeropad. Creates two
  pages and uses mprotect to prevent access to the second page and
  a SEGV handler that walks the exception tables and runs the fixup
  routine.
  The results are compared against a normal load that is that is
  performed while access to the second page is enabled via mprotect.
  Copyright (C) 2014 Anton Blanchard <anton@au.ibm.com>, IBM
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015, Cyril Bur, IBM Corp.
  This test attempts to see if the FPU registers are correctly reported in a
  signal context. Each worker just spins checking its FPU registers, at some
  point a signal will interrupt it and C code will check the signal context
  ensuring it is also the same.
 Number of times each thread should receive the signal 
  Factor by which to multiply number of online CPUs for total number of
  worker threads
 Only the non volatiles were loaded up 
		
		  Harness will say the fail was here, look at why signal_fpu
		  returned
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015, Cyril Bur, IBM Corp.
  This test attempts to see if the FPU registers change across preemption.
  Two things should be noted here a) The check_fpu function in asm only checks
  the non volatile registers as it is reused from the syscall test b) There is
  no way to be sure preemption happened so this test just uses many threads
  and a long wait. As such, a successful test doesn't mean much but a failure
  is bad.
 Time to wait for workers to get preempted (seconds) 
  Factor by which to multiply number of online CPUs for total number of
  worker threads
 Test failed if it ever returns 
 Not really necessary but nice to wait for every thread to start 
	
	  Working are checking this value every loop. In preempt_fpu 'cmpwi r5,0; bne 2b'.
	  r5 will have loaded the value of running.
		
		  Harness will say the fail was here, look at why preempt_fpu
		  returned
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright IBM Corp. 2020
  This test attempts to cause a FP denormal exception on POWER8 CPUs. Unfortunately
  if the denormal handler is not configured or working properly, this can cause a bad
  crash in kernel mode when the kernel tries to save FP registers when the process
  exits.
 try to induce lfs <denormal> ; stfd 
 random denormal 
 renormalised value 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015, Cyril Bur, IBM Corp.
  This test attempts to see if the VMX registers change across preemption.
  Two things should be noted here a) The check_vmx function in asm only checks
  the non volatile registers as it is reused from the syscall test b) There is
  no way to be sure preemption happened so this test just uses many threads
  and a long wait. As such, a successful test doesn't mean much but a failure
  is bad.
 Time to wait for workers to get preempted (seconds) 
  Factor by which to multiply number of online CPUs for total number of
  worker threads
 Test fails if it ever returns 
 vcmpequd used in vmx_asm.S is v2.07
 Not really nessesary but nice to wait for every thread to start 
	
	  Working are checking this value every loop. In preempt_vmx 'cmpwi r5,0; bne 2b'.
	  r5 will have loaded the value of running.
		
		  Harness will say the fail was here, look at why preempt_vmx
		  returned
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015, Cyril Bur, IBM Corp.
  This test attempts to see if the VSX registers change across preemption.
  There is no way to be sure preemption happened so this test just
  uses many threads and a long wait. As such, a successful test
  doesn't mean much but a failure is bad.
 Time to wait for workers to get preempted (seconds) 
  Factor by which to multiply number of online CPUs for total number of
  worker threads
  Ensure there is twice the number of non-volatile VMX regs!
  check_vmx() is going to use the other half as space to put the live
  registers before calling vsx_memcmp()
 Don't want zero because it hides kernel problems 
 Not really nessesary but nice to wait for every thread to start 
	
	  Working are checking this value every loop. In preempt_vsx 'cmpwi r5,0; bne 2b'.
	  r5 will have loaded the value of running.
		
		  Harness will say the fail was here, look at why preempt_vsx
		  returned
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015, Cyril Bur, IBM Corp.
  This test attempts to see if the VMX registers change across a syscall (fork).
 test_vmx will fork() 
	
	  Setup an environment with much context switching
 vcmpequd used in vmx_asm.S is v2.07
 Can't FAIL_IF(pid2 == -1); because we've already forked 
		
		  Couldn't fork, ensure child_ret is set and is a fail
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015, Cyril Bur, IBM Corp.
  This test attempts to see if the VMX registers are correctly reported in a
  signal context. Each worker just spins checking its VMX registers, at some
  point a signal will interrupt it and C code will check the signal context
  ensuring it is also the same.
 Number of times each thread should receive the signal 
  Factor by which to multiply number of online CPUs for total number of
  worker threads
 Only the non volatiles were loaded up 
			
			  Shouldn't printf() in a signal handler, however, this is a
			  test and we've detected failure. Understanding what failed
			  is paramount. All that happens after this is tests exit with
			  failure.
 vcmpequd used in vmx_asm.S is v2.07
		
		  Harness will say the fail was here, look at why signal_vmx
		  returned
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015, Cyril Bur, IBM Corp.
  This test attempts to see if the FPU registers change across a syscall (fork).
 test_fpu will fork() 
	
	  Setup an environment with much context switching
 Can't FAIL_IF(pid2 == -1); because already forked once 
		
		  Couldn't fork, ensure test is a fail
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2015, Anton Blanchard, IBM Corp.
 SPDX-License-Identifier: GPL-2.0+
  Part of fork context switch microbenchmark.
  Copyright 2018, Anton Blanchard, IBM Corp.
 SPDX-License-Identifier: GPL-2.0-or-later
  Test null syscall performance
  Copyright (C) 2009-2015 Anton Blanchard, IBM
  Use a timer instead of busy looping on clock_gettime() so we don't
  pollute profiles with glibc and VDSO hits.
  This only works with recent kernels where cpufreq modifies
  proccpuinfo dynamically.
 Try to get out of low powerlow frequency mode 
 Find fastest clock frequency 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2016, Anton Blanchard, Michael Ellerman, IBM Corp.
 SPDX-License-Identifier: GPL-2.0+
  Context switch microbenchmark.
  Copyright 2018, Anton Blanchard, IBM Corp.
 Create a new process group so we can signal everyone for exit 
 SPDX-License-Identifier: GPL-2.0-or-later
  Context switch microbenchmark.
  Copyright (C) 2015 Anton Blanchard <anton@au.ibm.com>, IBM
  Note: LTO (Link Time Optimisation) doesn't play well with this function
  attribute. Be very careful enabling LTO for this test.
 Create a new process group so we can signal everyone for exit 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2016, Anton Blanchard, Michael Ellerman, IBM Corp.
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2005-2020 IBM Corporation.
  Includes code from librtas (https:github.comibm-power-utilitieslibrtas)
 Unexpected IO Error 
 No Firmware Implementation of Function 
 Pointer to return values in args[]. 
 allocate enough for two string, a slash and trailing NULL 
 We don't care if the call doesn't exist
 Test a legitimate harmless call
 Expected: call succeeds
 Test a prohibited call
 Expected: call returns -EINVAL
 Get RMO
 Test a permitted call, user-supplied size, buffer inside RMO
 Expected: call succeeds
 Test a permitted call, user-supplied size, buffer start outside RMO
 Expected: call returns -EINVAL
 Test a permitted call, user-supplied size, buffer end outside RMO
 Expected: call returns -EINVAL
 Test a permitted call, fixed size, buffer end outside RMO
 Expected: call returns -EINVAL
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015, Michael Ellerman, IBM Corp.
  This test simply tests that certain syscalls are implemented. It doesn't
  actually exercise their logic in any way.
	
	  If we ran no tests then it means none of the syscall numbers were
	  defined, possibly because we were built against old headers. But it
	  means we didn't really test anything, so instead of passing mark it
	  as a skip to give the user a clue.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2021, Google LLC.
  Tests for adjusting the system counter from userspace
 __x86_64__ 
 SPDX-License-Identifier: GPL-2.0
  KVM dirty page logging test
  Copyright (C) 2018, Red Hat, Inc.
 for program_invocation_name 
 The memory slot index to track dirty pages 
 Default guest test virtual memory offset 
 How many pages to dirty for each guest loop 
 How many host loops to run (one KVM_GET_DIRTY_LOG for each loop) 
 Interval for each host loop (ms) 
 Dirty bitmaps are always little endian, so we need to swap on big endian 
  GuestHost shared variables. Ensure addr_gva2hva() andor
  sync_global_tofrom_guest() are used when accessing from
  the host. READWRITE_ONCE() should also be used with anything
  that may change.
  Guest physical memory offset of the testing memory slot.
  This will be set to the topmost valid physical address minus
  the test memory size.
  Guest virtual memory offset of the testing memory slot.
  Must not conflict with identity mapped test code.
  Continuously write to the first 8 bytes of a random pages within
  the testing memory region.
	
	  On s390x, all pages of a 1M segment are initially marked as dirty
	  when a page of the segment is written to for the very first time.
	  To compensate this specialty in this test, we need to touch all
	  pages during the first iteration.
 Tell the host that we need more random numbers 
 Host variables 
 Points to the test VM memory region on which we track dirty logs 
 For statistics only 
 Whether dirty ring reset is requested, or finished 
  This is only set by main thread, and only cleared by vcpu thread.  It is
  used to request vcpu thread to stop at the next GUEST_SYNC, since GUEST_SYNC
  is the only place that we'll guarantee both "dirty bit" and "dirty data"
  will match.  E.g., SIG_IPI won't guarantee that if the vcpu is interrupted
  after setting dirty bit but before the data is written.
  This is updated by the vcpu thread to tell the host whether it's a
  ring-full event.  It should only be read until a sem_wait() of
  sem_vcpu_stop and before vcpu continues to run.
  This is only used for verifying the dirty pages.  Dirty ring has a very
  tricky case when the ring just got full, kvm will do userspace exit due to
  ring full.  When that happens, the very last PFN is set but actually the
  data is not changed (the guest WRITE is not really applied yet), because
  we found that the dirty ring is full, refused to continue the vcpu, and
  recorded the dirty gfn with the old contents.
  For this specific case, it's safe to skip checking this pfn for this
  bit, because it's a redundant bit, and when the write happens later the bit
  will be set again.  We use this variable to always keep track of the latest
  dirty gfn we've collected, so that if a mismatch of data found later in the
  verifying process, we let it pass.
 Only use KVM_GET_DIRTY_LOG for logging 
 Use both KVM_[GET|CLEAR]_DIRTY_LOG for logging 
 Use dirty ring for logging 
 Run all supported modes 
 Mode of logging to test.  Default is to run all supported modes 
 Logging mode for current run 
  In our test we do signal tricks, let's use a better version of
  sem_wait to avoid signal interrupts
 Should only be called after a GUEST_SYNC 
 It means main thread is sleeping waiting 
	
	  Switch to dirty ring mode after VM creation but before any
	  of the vcpu creation.
pr_info("fetch 0x%x page %llu\n", fetch_index, cur->offset);
 This makes sure that hardware PML cache flushed 
 We only have one vcpu 
		
		  This is not a ring-full event, it's safe to allow
		  vcpu to continue
 Only have one vcpu 
 Cleared pages should be the same as collected 
 A ucall-sync or ring-full event is allowed 
 We should allow this to continue 
 Update the flag first before pause 
 Kick another round of vcpu just to make sure it will quit 
 Return true if this mode is supported, otherwise false 
 Hook when the vm creation is done (before vcpu creation) 
 Hook to collect the dirty pages into the bitmap provided 
 Hook to call when after each vcpu run 
  We use this bitmap to track some pages that should have its dirty
  bit set in the _next_ iteration.  For example, if we detected the
  page value changed to current iteration but at the same time the
  page bit is cleared in the latest bitmap, then the system must
  report that write in the next get dirty log call.
	
	  SIG_IPI is unblocked atomically while in KVM_RUN.  It causes the
	  ioctl to return with -EINTR, but it is still pending and we need
	  to accept it with the sigwait.
 Clear any existing kick signals 
 Let the guest dirty the random pages 
 If this is a special page that we were tracking... 
			
			  If the bit is set, the value written onto
			  the corresponding page should be either the
			  previous iteration number or the current one.
					
					  Short answer: this case is special
					  only for dirty ring test where the
					  page is the last page before a kvm
					  dirty ring full in iteration N-2.
					 
					  Long answer: Assuming ring size R,
					  one possible condition is:
					 
					       main thr       vcpu thr
					       --------       --------
					     iter=1
					                    write 1 to page 0~(R-1)
					                    full, vmexit
					     collect 0~(R-1)
					     kick vcpu
					                    write 1 to (R-1)~(2R-2)
					                    full, vmexit
					     iter=2
					     collect (R-1)~(2R-2)
					     kick vcpu
					                    write 1 to (2R-2)
					                    (NOTE!!! "1" cached in cpu reg)
					                    write 2 to (2R-1)~(3R-3)
					                    full, vmexit
					     iter=3
					     collect (2R-2)~(3R-3)
					     (here if we read value on page
					      "2R-2" is 1, while iter=3!!!)
					 
					  This however can only happen once per iteration.
					
					  Please refer to comments in
					  dirty_ring_last_page.
			
			  If cleared, the value written can be any
			  value smaller or equals to the iteration
			  number.  Note that the value can be exactly
			  (iteration-1) if that write can happen
			  like this:
			 
			  (1) increase loop count to "iteration-1"
			  (2) write to page P happens (with value
			      "iteration-1")
			  (3) get dirty log for "iteration-1"; we'll
			      see that page P bit is set (dirtied),
			      and not set the bit in host_bmap_track
			  (4) increase loop count to "iteration"
			      (which is current iteration)
			  (5) get dirty log for current iteration,
			      we'll see that page P is cleared, with
			      value "iteration-1".
				
				  This page is _just_ modified; it
				  should report its dirtyness in the
				  next run
 1G 
	
	  We reserve page table for 2 times of extra dirty mem which
	  will definitely cover the original (1G+) test range.  Here
	  we do the calculation with 4K page size which is the
	  smallest so the page number will be enough for all archs
	  (e.g., 64K page size guest will need even less memory for
	  page tables).
	
	  A little more than 1G of guest page sized pages.  Cover the
	  case where the size is not aligned to 64 pages.
 Align to 1M (segment size) 
 Add an extra memory slot for testing dirty logging 
 Do mapping for the dirty track memory slot 
 Cache the HVA pointer of the region 
 Export the shared variables to the guest 
 Start the iterations 
 Give the vcpu thread some time to dirty some pages 
		
		  See vcpu_sync_stop_requested definition for details on why
		  we need to stop vcpu when verify data.
		
		  NOTE: for dirty ring, it's possible that we didn't stop at
		  GUEST_SYNC but instead we stopped because ring is full;
		  that's okay too because ring full means we're only missing
		  the flush of the last page, and since we handle the last
		  page specially verification will succeed anyway.
 Tell the vcpu thread to quit 
 Ensure that vCPU threads start with SIG_IPI blocked.  
 Run each log mode 
 SPDX-License-Identifier: GPL-2.0
  access_tracking_perf_test
  Copyright (C) 2021, Google, Inc.
  This test measures the performance effects of KVM's access tracking.
  Access tracking is driven by the MMU notifiers test_young, clear_young, and
  clear_flush_young. These notifiers do not have a direct userspace API,
  however the clear_young notifier can be triggered by marking a pages as idle
  in syskernelmmpage_idlebitmap. This test leverages that mechanism to
  enable access tracking on guest memory.
  To measure performance this test runs a VM with a configurable number of
  vCPUs that each touch every page in disjoint regions of memory. Performance
  is measured in the time it takes all vCPUs to finish touching their
  predefined region.
  Note that a deterministic correctness test of access tracking is not possible
  by using page_idle as it exists today. This is for a few reasons:
  1. page_idle only issues clear_young notifiers, which lack a TLB flush. This
     means subsequent guest accesses are not guaranteed to see page table
     updates made by KVM until some time in the future.
  2. page_idle only operates on LRU pages. Newly allocated pages are not
     immediately allocated to LRU lists. Instead they are held in a "pagevec",
     which is drained to LRU lists some time in the future. There is no
     userspace API to force this drain to occur.
  These limitations are worked around in this test by using a large enough
  region of memory for each vCPU such that the number of translations cached in
  the TLB and the number of pages held in pagevecs are a small fraction of the
  overall workload. And if either of those conditions are not true this test
  will fail rather than silently passing.
 Global variable used to synchronize all of the vCPU threads. 
 Defines what vCPU threads should do during a given iteration. 
 Run the vCPU to access all its memory. 
 Mark the vCPU's memory idle in page_idle. 
 Set to true when vCPU threads should exit. 
 The iteration that was last completed by each vCPU. 
 Whether to overlap the regions of memory vCPUs access. 
 The backing source for the region of memory. 
 The amount of memory to allocate for each vCPU. 
 The number of vCPUs to create in the VM. 
 If vCPUs are using an overlapping region, let vCPU 0 mark it idle. 
	
	  Assumption: Less than 1% of pages are going to be swapped out from
	  under us during this test.
	
	  Test that at least 90% of memory has been marked idle (the rest might
	  not be marked idle because the pages have not yet made it to an LRU
	  list or the translations are still cached in the TLB). 90% is
	  arbitrary; high enough that we ensure most memory access went through
	  access tracking but low enough as to not make the test too brittle
	  over time and across architectures.
 The type of memory accesses to perform in the VM. 
 Kick off the vCPUs by incrementing iteration. 
 Wait for all vCPUs to finish the iteration. 
	
	  Even though this parallelizes the work across vCPUs, this is still a
	  very slow operation because page_idle forces the test to mark one pfn
	  at a time and the clear_young notifier serializes on the KVM MMU
	  lock.
 As a control, read and write to the populated memory first. 
 Repeat on memory that has been marked as idle. 
 Set done to signal the vCPU threads to exit 
 SPDX-License-Identifier: GPL-2.0
  KVM demand paging test
  Adapted from dirty_log_test.c
  Copyright (C) 2018, Red Hat, Inc.
  Copyright (C) 2019, Google, Inc.
 for pipe2 
 Let the guest access its memory 
 In order to get minor faults, prefault via the alias. 
 Cache the host addresses of the region 
			
			  Set up user fault fd to handle demand paging
			  requests.
 Tell the user fault fd handler threads to quit 
 __NR_userfaultfd 
 __NR_userfaultfd 
 SPDX-License-Identifier: GPL-2.0
  KVM dirty page logging performance test
  Based on dirty_log_test.c
  Copyright (C) 2018, Red Hat, Inc.
  Copyright (C) 2020, Google, Inc.
 How many host loops to run by default (one KVM_GET_DIRTY_LOG for each loop)
 Host variables 
 Start the iterations 
 Allow the vCPUs to populate memory 
 Enable dirty logging 
		
		  Incrementing the iteration number will start the vCPUs
		  dirtying memory again.
 Disable dirty logging 
 Tell the vcpu thread to quit 
 SPDX-License-Identifier: GPL-2.0
  KVM memslot modification stress test
  Adapted from demand_paging_test.c
  Copyright (C) 2018, Red Hat, Inc.
  Copyright (C) 2020, Google, Inc.
 for program_invocation_name 
 Let the guest access its memory until a stop signal is received 
	
	  Add the dummy memslot just below the perf_test_util memslot, which is
	  at the top of the guest physical address space.
 SPDX-License-Identifier: GPL-2.0-only
 for program_invocation_short_name 
  Use an arbitrary, bogus signature for configuring rseq, this test does not
  actually enter an rseq critical section.
  Any bug related to task migration is likely to be timing-dependent; perform
  a large number of migrations to reduce the odds of a false negative.
	
	  Advance to the next CPU, skipping those that weren't in the original
	  affinity set.  Sadly, there is no CPU_SET_FOR_EACH, and cpu_set_t's
	  data storage is considered as opaque.  Note, if this task is pinned
	  to a small set of discontigous CPUs, e.g. 2 and 1023, this loop will
	  burn a lot cycles and the test will take longer than normal to
	  complete.
		
		  Bump the sequence count twice to allow the reader to detect
		  that a migration may have occurred in between rseq and sched
		  CPU ID reads.  An odd sequence count indicates a migration
		  is in-progress, while a completely different count indicates
		  a migration occurred since the count was last read.
		
		  Ensure the odd count is visible while sched_getcpu() isn't
		  stable, i.e. while changing affinity is in-progress.
		
		  Wait 1-10us before proceeding to the next iteration and more
		  specifically, before bumping seq_cnt again.  A delay is
		  needed on three fronts:
		 
		   1. To allow sched_setaffinity() to prompt migration before
		      ioctl(KVM_RUN) enters the guest so that TIF_NOTIFY_RESUME
		      (or TIF_NEED_RESCHED, which indirectly leads to handling
		      NOTIFY_RESUME) is handled in KVM context.
		 
		      If NOTIFY_RESUMENEED_RESCHED is set after KVM enters
		      the guest, the guest will trigger a IOMMIO exit all the
		      way to userspace and the TIF flags will be handled by
		      the generic "exit to userspace" logic, not by KVM.  The
		      exit to userspace is necessary to give the test a chance
		      to check the rseq CPU ID (see #2).
		 
		      Alternatively, guest_code() could include an instruction
		      to trigger an exit that is handled by KVM, but any such
		      exit requires architecture specific code.
		 
		   2. To let ioctl(KVM_RUN) make its way back to the test
		      before the next round of migration.  The test's check on
		      the rseq CPU ID must wait for migration to complete in
		      order to avoid false positive, thus any kernel rseq bug
		      will be missed if the next migration starts before the
		      check completes.
		 
		   3. To ensure the read-side makes efficient forward progress,
		      e.g. if sched_getcpu() involves a syscall.  Stalling the
		      read-side means the test will spend more time waiting for
		      sched_getcpu() to stabilize and less time trying to hit
		      the timing-dependent bug.
		 
		  Because any bug in this area is likely to be timing-dependent,
		  run with a range of delays at 1us intervals from 1us to 10us
		  as a best effort to avoid tuning the test to the point where
		  it can hit _only_ the original bug and not detect future
		  regressions.
		 
		  The original bug can reproduce with a delay up to ~500us on
		  x86-64, but starts to require more iterations to reproduce
		  as the delay creeps above ~10us, and the average runtime of
		  each iteration obviously increases as well.  Cap the delay
		  at 10us to keep test runtime reasonable while minimizing
		  potential coverage loss.
		 
		  The lower bound for reproducing the bug is likely below 1us,
		  e.g. failures occur on x86-64 with nanosleep(0), but at that
		  point the overhead of the syscall likely dominates the delay.
		  Use usleep() for simplicity and to avoid unnecessary kernel
		  dependencies.
	
	  CPU_SET doesn't provide a FOR_EACH helper, get the minmax CPU that
	  this task is affined to in order to reduce the time spent querying
	  unusable CPUs, e.g. if this task is pinned to a small percentage of
	  total CPUs.
 Tell stdout not to buffer its content 
	
	  Create and run a dummy VM that immediately exits to userspace via
	  GUEST_SYNC, while concurrently migrating the process by setting its
	  CPU affinity.
		
		  Verify rseq's CPU matches sched's CPU.  Ensure migration
		  doesn't occur between sched_getcpu() and reading the rseq
		  cpu_id by rereading both if the sequence count changes, or
		  if the count is odd (migration in-progress).
			
			  Drop bit 0 to force a mismatch if the count is odd,
			  i.e. if a migration is in-progress.
			
			  Ensure reading sched_getcpu() and rseq.cpu_id
			  complete in a single "no migration" window, i.e. are
			  not reordered across the seq_cnt reads.
	
	  Sanity check that the test was able to enter the guest a reasonable
	  number of times, e.g. didn't get stalled too oftenlong waiting for
	  sched_getcpu() to stabilize.  A 2:1 migration:KVM_RUN ratio is a
	  fairly conservative ratio on x86-64, which can do _more_ KVM_RUNs
	  than migrations given the 1us+ delay in the migration task.
 SPDX-License-Identifier: GPL-2.0
  KVM page table test
  Copyright (C) 2021, Huawei, Inc.
  Make sure that THP has been enabled or enough HUGETLB pages with specific
  page size have been pre-allocated on your system, if you are planning to
  use hugepages to back the guest memory for testing.
 for program_invocation_name 
 Default size(1GB) of the memory for testing 
 Default guest test virtual memory offset 
 Different guest memory accessing stages 
  Guest variables. Use addr_gva2hva() if these variables need
  to be changed in host.
 Host variables 
 Whether the test stage is updated, or completed 
  Guest physical memory offset of the testing memory slot.
  This will be set to the topmost valid physical address minus
  the test memory size.
  Guest virtual memory offset of the testing memory slot.
  Must not conflict with identity mapped test code.
 Make sure vCPU args data structure is not corrupt 
		
		  All vCPU threads will be started in this stage,
		  where guest code of each vCPU will do nothing.
		
		  Before dirty logging, vCPUs concurrently access the first
		  8 bytes of each page (host pagelarge page) within the same
		  memory region with different accessing types (readwrite).
		  Then KVM will create normal page mappings or huge block
		  mappings for them.
		
		  During dirty logging, KVM will only update attributes of the
		  normal page mappings from RO to RW if memory backing src type
		  is anonymous. In other cases, KVM will split the huge block
		  mappings into normal page mappings if memory backing src type
		  is THP or HUGETLB.
				
				  Write to the first host page in each large
				  page region, and triger break of large pages.
				
				  Access the middle host pages in each large
				  page region. Since dirty logging is enabled,
				  this will create new mappings at the smallest
				  granularity.
		
		  After dirty logging is stopped, vCPUs concurrently read
		  from every single host page. Then KVM will coalesce the
		  split page mappings back to block mappings. And a TLB
		  conflict abort could occur here if TLB entries of the
		  page mappings are not fully invalidated.
		
		  Here we can know the execution time of every
		  single vcpu running in different test stages.
 Align up the test memory size 
 Create a VM with enough guest pages 
 Align down GPA of the testing memslot 
 Set up the shared data structure test_args 
 Add an extra memory slot with specified backing src type 
 Do mapping(GVA->GPA) for the testing memory slot 
 Cache the HVA pointer of the region 
 Export shared structure test_args to guest 
 Wake up all the vcpus to run new test stage 
 Wait for all the vcpus to complete new test stage 
 Create VM with vCPUs and make some pre-initialization 
 Test the stage of KVM creating mappings 
 Test the stage of KVM updating mappings 
 Test the stage of KVM adjusting mappings 
 Tell the vcpu thread to quit 
 SPDX-License-Identifier: GPL-2.0
  A memslot-related performance benchmark.
  Copyright (C) 2021 Oracle andor its affiliates.
  Basic guest setup  host vCPU thread code lifted from set_memory_region_test.
  32 MiB is max size that gets well over 100 iterations on 509 slots.
  Considering that each slot needs to have at least one page up to
  8194 slots in use can then be tested (although with slightly
  limited resolution).
  128 MiB is min size that fills 32k slots with at least one page in each
  while at the same time gets 100+ iterations in such test
 2 MiB chunk size like a typical huge page 
  For the move active test the middle of the test area is placed on
  a memslot boundary: half lies in the memslot being moved, half in
  other memslot(s).
  When running this test with 32k memslots (32764, really) each memslot
  contains 4 pages.
  The last one additionally contains the remaining 21 pages of memory,
  for the total size of 25 pages.
  Hence, the maximum size here is 50 pages.
  Technically, we need also for the atomic bool to be address-free, which
  is recommended, but not strictly required, by C11 for lockless
  implementations.
  However, in practice both GCC and Clang fulfill this requirement on
  all KVM-supported platforms.
 Ensure the guest thread is spun up. 
  noinline so we can easily see how much time the host spends waiting
  for the guest.
  For the same reason use alarm() instead of polling clock_gettime()
  to implement a wait timeout.
		
		  No host sync here since the MMIO exits are so expensive
		  that the host would spend most of its time waiting for
		  the guest and so instead of measuring memslot move
		  performance we would measure the performance and
		  likelihood of MMIO exits
		
		  We can afford to access (map) just a small number of pages
		  per host sync as otherwise the host will spend
		  a significant amount of its time waiting for the guest
		  (instead of doing unmap operations), so this will
		  effectively turn this test into a map performance test.
		 
		  Just access a single page to be on the safe side.
	
	  Unmap the second half of the test area while guest writes to (maps)
	  the first half.
	
	  Wait for the guest to finish writing the first half of the test
	  area, verify the written value on the first and the last page of
	  this area and then unmap it.
	  Meanwhile, the guest is writing to (mapping) the second half of
	  the test area.
	
	  Wait for the guest to finish writing the second half of the test
	  area and verify the written value on the first and the last page
	  of this area.
	  The area will be unmapped at the beginning of the next loop
	  iteration.
	  Meanwhile, the guest is writing to (mapping) the first half of
	  the test area.
	
	  Wait for the guest to finish mapping page(s) in the first half
	  of the test area, verify the written value and then perform unmap
	  of this area.
	  Meanwhile, the guest is writing to (mapping) page(s) in the second
	  half of the test area.
 Likewise, but for the opposite host  guest areas 
	
	  Only rank the slot setup time for tests using the whole test memory
	  area so they are comparable
 Tell stdout not to buffer its content 
 SPDX-License-Identifier: GPL-2.0
 for program_invocation_short_name 
  s390x needs at least 1MB alignment, and the x86_64 MOVEDELETE tests need a
  2MB sized and aligned region so that the initial region corresponds to
  exactly one large page.
  Somewhat arbitrary location and slot, intended to not overlap anything.
	
	  Loop until the guest is done.  Re-enter the guest on all MMIO exits,
	  which will occur if the guest attempts to access a memslot after it
	  has been deleted or while it is being moved .
 Wait for the vCPU thread to reenter the guest. 
	
	  Allocate and map two pages so that the GPA accessed by guest_code()
	  stays valid across the memslot move.
 Ditto for the host mapping so that both pages can be zeroed. 
 Ensure the guest thread is spun up. 
	
	  Spin until the memory region starts getting moved to a
	  misaligned address.
	  Every region move may or may not trigger MMIO, as the
	  window where the memslot is invalid is usually quite small.
 Spin until the misaligning memory region move completes. 
 Spin until the memory region starts to get re-aligned. 
 Spin until the re-aligning memory region move completes. 
	
	  Shift the region's base GPA.  The guest should not see "2" as the
	  hva->gpa translation is misaligned, i.e. the guest is accessing a
	  different host pfn.
	
	  The guest _might_ see an invalid memslot and trigger MMIO, but it's
	  a tiny window.  Spin and defer the sync until the memslot is
	  restored and guest behavior is once again deterministic.
	
	  Note, value in memory needs to be changed before restoring the
	  memslot, else the guest could race the update and see "2".
 Restore the original base, the guest should see "1". 
 Defered sync from when the memslot was misaligned (above). 
 Spin until the memory region is deleted. 
 Spin until the memory region is recreated. 
 Spin until the memory region is deleted. 
 Spin indefinitely (until the code memslot is deleted). 
 Delete the memory region, the guest should not die. 
 Recreate the memory region.  The guest should see "0". 
 Delete the region again so that there's only one memslot left. 
	
	  Delete the primary memslot.  This should cause an emulation error or
	  shutdown due to the page tables getting nuked.
	
	  On AMD, after KVM_EXIT_SHUTDOWN the VMCB has been reinitialized already,
	  so the instruction pointer would point to the reset vector.
 __x86_64__ 
  Test it can be added memory slots up to KVM_CAP_NR_MEMSLOTS, then any
  tentative to add further slots should fail.
 On s390x, the host address must be aligned to 1M (due to PGSTEs) 
 Check it can be added memory slots up to the maximum allowed 
 Check it cannot be added memory slots beyond the limit 
 Tell stdout not to buffer its content 
	
	  FIXME: the zero-memslot test fails on aarch64 and s390x because
	  KVM_RUN fails with ENOEXEC or EFAULT.
 SPDX-License-Identifier: GPL-2.0
  stealstolen time test
  Copyright (C) 2020, Red Hat, Inc.
 steal_time must have 64-byte alignment 
 ST_GPA_BASE is identity mapped 
 PV_TIME_ST must have 64-byte alignment 
 ST_GPA_BASE is identity mapped 
 Set CPU affinity so we can force preemption of the VCPU 
 Create a one VCPU guest and an identity mapped memslot for the steal time structure 
 Add the rest of the VCPUs 
 Run test on each VCPU 
 First VCPU run initializes steal-time 
 Second VCPU run, expect guest stolen time to be <= run_delay 
 Steal time from the VCPU. The steal time thread has the same CPU affinity as the VCPUs. 
 Run VCPU again to confirm stolen time is consistent with run_delay 
 SPDX-License-Identifier: GPL-2.0-only
  kvm_binary_stats_test
  Copyright (C) 2021, Google LLC.
  Test the fd-based interface for KVM statistics.
 for program_invocation_short_name 
 Read kvm stats header 
 Read kvm stats id string 
 Check id string, that should start with "kvm" 
 Sanity check for other fields in header 
 Check overlap 
 Allocate memory for stats descriptors 
 Read kvm stats descriptors 
 Sanity check for fields in descriptors 
 Check type,unit,base boundaries 
		 Check exponent for stats unit
		  Exponent for counter should be greater than or equal to 0
		  Exponent for unit bytes should be greater than or equal to 0
		  Exponent for unit seconds should be less than or equal to 0
		  Exponent for unit clock cycles should be greater than or
		  equal to 0
 Check name string 
 Check size field, which should not be zero 
 Check bucket_size field 
 Check overlap 
 Check validity of all stats data size 
 Check stats offset 
 Allocate memory for stats data 
 Read kvm stats data as a bulk 
 Read kvm stats data one by one 
 Get fd for VM stats 
 Get fd for VCPU stats 
  Usage: kvm_bin_form_stats [#vm] [#vcpu]
  The first parameter #vm set the number of VMs being created.
  The second parameter #vcpu set the number of VCPUs being created.
  By default, DEFAULT_NUM_VM VM and DEFAULT_NUM_VCPU VCPU for the VM would be
  created for testing.
 Get the number of VMs and VCPUs that would be created for testing. 
 Check the extension for binary stats 
 Create VMs and VCPUs 
 Check stats read for every VM and VCPU 
 SPDX-License-Identifier: GPL-2.0-only
  kvm_create_max_vcpus
  Copyright (C) 2019, Google LLC.
  Test for KVM_CAP_MAX_VCPUS and KVM_CAP_MAX_VCPU_ID.
 for program_invocation_short_name 
 This asserts that the vCPU was created. 
	
	  Upstream KVM prior to 4.8 does not support KVM_CAP_MAX_VCPU_ID.
	  Userspace is supposed to use KVM_CAP_MAX_VCPUS as the maximum ID
	  in this case.
 SPDX-License-Identifier: GPL-2.0-only
  This test is intended to reproduce a crash that happens when
  kvm_arch_hardware_disable is called and it attempts to unregister the user
  return notifiers.
 Arguments for the pthreads 
 Some busy work 
 Should not be reached 
	
	  Wait for the child to post to the semaphore, but wake up periodically
	  to check if the child exited prematurely.
 Child is still running, keep waiting. 
		
		  Child is no longer running, which is not expected.
		 
		  If it exited with a non-zero status, we explicitly forward
		  the child's status in case it exited with KSFT_SKIP.
 This function always exits 
 SPDX-License-Identifier: GPL-2.0-only
  arch_timer.c - Tests the aarch64 timer IRQ functionality
  The test validates both the virtual and physical timer IRQs using
  CVAL and TVAL registers. This consitutes the four stages in the test.
  The guest's main thread configures the timer interrupt for a stage
  and waits for it to fire, with a timeout equal to the timer period.
  It asserts that the timeout doesn't exceed the timer period.
  On the other hand, upon receipt of an interrupt, the guest's interrupt
  handler validates the interrupt by checking if the architectural state
  is in compliance with the specifications.
  The test provides command-line options to configure the timer's
  period (-p), number of vCPUs (-n), and iterations per stage (-i).
  To stress-test the timer stack even more, an option to migrate the
  vCPUs across pCPUs (-m), at a particular rate, is also provided.
  Copyright (c) 2021, Google LLC.
 Shared variables between host and guest 
 Make sure we are dealing with the correct timer IRQ 
 Basic 'timer condition met' check 
 Setup the next interrupt 
 Setup a timeout for the interrupt to arrive 
 Currently, any exit from guest is an indication of completion 
 Randomly find an available pCPU to place a vCPU on 
 Allow the error where the vCPU thread is already finished 
 Spawn a thread to control the vCPU migrations 
 Timer initid should be same for all the vCPUs, so query only vCPU-0 
 Make all the test's cmdline args visible to the guest 
 Tell stdout not to buffer its content 
 SPDX-License-Identifier: GPL-2.0
  Check for KVM_GET_REG_LIST regressions.
  Copyright (C) 2020, Red Hat, Inc.
  When attempting to migrate from a host with an older kernel to a host
  with a newer kernel we allow the newer kernel on the destination to
  list new registers with get-reg-list. We assume they'll be unused, at
  least until the guest reboots, and so they're relatively harmless.
  However, if the destination host with the newer kernel is missing
  registers which the source host with the older kernel has, then that's
  a regression in get-reg-list. This test checks for that regression by
  checking the current list against a blessed list. We should never have
  missing registers, but if new ones appear then they can probably be
  added to the blessed list. A completely new blessed list can be created
  by running the test with the --list command line argument.
  Note, the blessed list should be created from the oldest possible
  kernel. We can't go older than v4.15, though, because that's the first
  release to expose the ID system registers in KVM_GET_REG_LIST, see
  commit 93390c0a1b20 ("arm64: KVM: Hide unsupported AArch64 CPU features
  from guests"). Also, one must use the --core-reg-fixup command line
  option when running on an older kernel that doesn't include df205b5c6328
  ("KVM: arm64: Filter out invalid core register IDs in KVM_GET_REG_LIST")
	
	  DEMUX register presence depends on the host's CLIDR_EL1.
	  This means there's no set of them that we can bless.
	
	  core_off is the offset into struct kvm_regs
  Older kernels listed each 32-bit word of CORE registers separately.
  For 64 and 128-bit registers we need to ignore the extra words. We
  also need to fixup the sizes, because the older kernels stated all
  registers were 64-bit, even when they weren't.
			
			  These offsets are pointing at padding.
			  We need to ignore them too.
	
	  We only test that we can get the register and then write back the
	  same value. Some registers may allow other values to be written
	  back, but others only allow some bits to be changed, and at least
	  for ID registers set will fail if the value does not exactly match
	  what was returned by get. If registers that allow other values to
	  be written need to have the other values tested, then we should
	  create a new set of tests for those in a new independent test
	  executable.
 rejects_set registers are rejected after KVM_ARM_VCPU_FINALIZE 
		
		  We only want to print the register list of a single config.
  The current blessed list was primed with the output of kernel version
  v4.15 with --core-reg-fixup and then later updated with new registers.
  The blessed list is up to date with kernel version v5.13-rc3
 CNTV_CTL_EL0 
 CNTV_CVAL_EL0 
 MIDR_EL1 
 REVIDR_EL1 
 CLIDR_EL1 
 AIDR_EL1 
 CTR_EL0 
 MDCCINT_EL1 
 MDSCR_EL1 
 DBGVCR32_EL2 
 MPIDR_EL1 
 ID_PFR0_EL1 
 ID_PFR1_EL1 
 ID_DFR0_EL1 
 ID_AFR0_EL1 
 ID_MMFR0_EL1 
 ID_MMFR1_EL1 
 ID_MMFR2_EL1 
 ID_MMFR3_EL1 
 ID_ISAR0_EL1 
 ID_ISAR1_EL1 
 ID_ISAR2_EL1 
 ID_ISAR3_EL1 
 ID_ISAR4_EL1 
 ID_ISAR5_EL1 
 ID_MMFR4_EL1 
 ID_ISAR6_EL1 
 MVFR0_EL1 
 MVFR1_EL1 
 MVFR2_EL1 
 ID_PFR2_EL1 
 ID_DFR1_EL1 
 ID_MMFR5_EL1 
 ID_AA64PFR0_EL1 
 ID_AA64PFR1_EL1 
 ID_AA64ZFR0_EL1 
 ID_AA64DFR0_EL1 
 ID_AA64DFR1_EL1 
 ID_AA64AFR0_EL1 
 ID_AA64AFR1_EL1 
 ID_AA64ISAR0_EL1 
 ID_AA64ISAR1_EL1 
 ID_AA64MMFR0_EL1 
 ID_AA64MMFR1_EL1 
 ID_AA64MMFR2_EL1 
 SCTLR_EL1 
 ACTLR_EL1 
 CPACR_EL1 
 TTBR0_EL1 
 TTBR1_EL1 
 TCR_EL1 
 AFSR0_EL1 
 AFSR1_EL1 
 ESR_EL1 
 FAR_EL1 
 PAR_EL1 
 MAIR_EL1 
 AMAIR_EL1 
 VBAR_EL1 
 DISR_EL1 
 CONTEXTIDR_EL1 
 TPIDR_EL1 
 CNTKCTL_EL1 
 CSSELR_EL1 
 TPIDR_EL0 
 TPIDRRO_EL0 
 DACR32_EL2 
 IFSR32_EL2 
 FPEXC32_EL2 
 PMINTENSET_EL1 
 PMINTENCLR_EL1 
 PMCR_EL0 
 PMCNTENSET_EL0 
 PMCNTENCLR_EL0 
 PMOVSCLR_EL0 
 PMSWINC_EL0 
 PMSELR_EL0 
 PMCCNTR_EL0 
 PMUSERENR_EL0 
 PMOVSSET_EL0 
 PMCCFILTR_EL0 
 ZCR_EL1 
 SPDX-License-Identifier: GPL-2.0-only
  psci_cpu_on_test - Test that the observable state of a vCPU targeted by the
  CPU_ON PSCI call matches what the caller requested.
  Copyright (c) 2021 Google LLC.
  This is a regression test for a race between KVM servicing the PSCI call and
  userspace reading the vCPUs registers.
	
	  make sure the target is already off when executing the test.
 SPDX-License-Identifier: GPL-2.0
 This test only uses the first bp and wp slot. 
 Software-breakpoint 
 Hardware-breakpoint 
 Hardware-breakpoint + svc 
 Hardware-breakpoint + software-breakpoint 
 Watchpoint 
 Single-step 
 SPDX-License-Identifier: GPL-2.0
  vgic init sequence tests
  Copyright (C) 2020, Red Hat, Inc.
 helper to access a redistributor register 
 dummy guest code 
 we don't want to assert on run execution, hence that helper 
  Helper routine that performs KVM device tests in general. Eventually the
  ARM_VGIC (GICv2 or GICv3) device gets created with an overlapping
  DISTREDIST (or DISTCPUIF for GICv2). Assumption is 4 vcpus are going to be
  used hence the overlap. In the case of GICv3, A RDIST region is set at @0x0
  and a DIST region is set @0x70000. The GICv2 case sets a CPUIF @0x0 and a
  DIST region @0x1000.
 CPU interface in GICv2
 Check existing groupattributes 
 check non existing attribute 
 misaligned DIST and REDIST address settings 
 out of range address 
 Space for half a rdist (a rdist is: 2  rdist.alignment). 
 set REDIST base address @0x0
 Attempt to create a second legacy redistributor region 
 Attempt to mix legacy and new redistributor regions 
	
	  Set overlapping DIST  REDIST, cannot be detected here. Will be detected
	  on first vcpu run instead.
 Test the new REDIST region API 
 The last redist is above the pa range. 
	
	  Now there are 2 redist regions:
	  region 0 @ 0x200000 2 redists
	  region 1 @ 0x240000 1 redist
	  Attempt to read their characteristics
  VGIC KVM device is created and initialized before the secondary CPUs
  get created
 Add the rest of the VCPUs 
 All the VCPUs are created before the VGIC KVM device gets initialized 
 step2 
 step 3 
 The 2 first rdists should be put there (vcpu 0 and 3) 
  Test GICR_TYPER last bit with new redist regions
  rdist regions #1 and #2 are contiguous
  rdist region #0 @0x100000 2 rdist capacity
      rdists: 0, 3 (Last)
  rdist region #1 @0x240000 2 rdist capacity
      rdists:  5, 4 (Last)
  rdist region #2 @0x200000 2 rdist capacity
      rdists: 1, 2
 Test last bit with legacy region 
 Uses the legacy REDIST region API. 
 Set space for 3 redists, we have 1 vcpu, so this succeeds. 
 Add the rest of the VCPUs 
 Attempt to run a vcpu without enough redist space. 
 This one succeeds setting the ITS base 
  Returns 0 if it's possible to create GIC device of a given type (V2 or V3).
 try to create a non existing KVM device 
 trial mode 
 try to create the other gic_dev_type 
 SPDX-License-Identifier: GPL-2.0-only
  toolstestingselftestskvmlibelf.c
  Copyright (C) 2018, Google LLC.
 Open the ELF file. 
	 Read in and validate ELF Identification Record.
	  The ELF Identification record is the first 16 (EI_NIDENT) bytes
	  of the ELF header, which is at the beginning of the ELF file.
	  For now it is only safe to read the first EI_NIDENT bytes.  Once
	  read and validated, the value of e_ehsize can be used to determine
	  the real size of the ELF header.
	 Read in the ELF header.
	  With the ELF Identification portion of the ELF header
	  validated, especially that the value at EI_VERSION is
	  as expected, it is now safe to read the entire ELF header.
 VM ELF Load
  Input Args:
    filename - Path to ELF file
  Output Args: None
  InputOutput Args:
    vm - Pointer to opaque type that describes the VM.
  Return: None, TEST_ASSERT failures for all error conditions
  Loads the program image of the ELF file specified by filename,
  into the virtual address space of the VM pointed to by vm.  On entry
  the VM needs to not be using any of the virtual address space used
  by the image and it needs to have sufficient available physical pages, to
  back the virtual pages used to load the image.
 Open the ELF file. 
 Read in the ELF header. 
	 For each program header.
	  The following ELF header members specify the location
	  and size of the program headers:
	 
	    e_phoff - File offset to start of program headers
	    e_phentsize - Size of each program header
	    e_phnum - Number of program header entries
 Seek to the beginning of the program header. 
 Read in the program header. 
 Skip if this header doesn't describe a loadable segment. 
 Allocate memory for this segment within the VM. 
		 TODO(lhuemill): Set permissions of each memory segment
		  based on the least-significant 3 bits of phdr.p_flags.
		 Load portion of initial state that is contained within
		  the ELF file.
 SPDX-License-Identifier: GPL-2.0-only
  toolstestingselftestskvmlibassert.c
  Copyright (C) 2018, Google LLC.
 for getline(3) and strchrnul(3)
 Dumps the current stack trace to stderr. 
	
	  Build and run this command:
	 
	 	addr2line -s -e proc$PPIDexe -fpai {backtrace addresses} | \
	 		grep -v test_dump_stack | cat -n 1>&2
	 
	  Note that the spacing is different and there's no newline.
 N bytes per addr  2 digits per byte + 1 space per addr: 
 Null terminator: 
	
	  Skip the first 3 frames: backtrace, test_dump_stack, and
	  test_assert. We hope that backtrace isn't inlined and the other two
	  we've declared noinline.
 SPDX-License-Identifier: GPL-2.0-only
  toolstestingselftestskvmlibio.c
  Copyright (C) 2018, Google LLC.
 Test Write
  A wrapper for write(2), that automatically handles the following
  special conditions:
    + Interrupted system call (EINTR)
    + Write of less than requested amount
    + Non-block return (EAGAIN)
  For each of the above, an additional write is performed to automatically
  continue writing the requested data.
  There are also many cases where write(2) can return an unexpected
  error (e.g. EIO).  Such errors cause a TEST_ASSERT failure.
  Note, for function signature compatibility with write(2), this function
  returns the number of bytes written, but that value will always be equal
  to the number of requested bytes.  All other conditions in this and
  future enhancements to this function either automatically issue another
  write(2) or cause a TEST_ASSERT failure.
  Args:
   fd    - Opened file descriptor to file to be written.
   count - Number of bytes to write.
  Output:
   buf   - Starting address of data to be written.
  Return:
   On success, number of bytes written.
   On failure, a TEST_ASSERT failure is caused.
	 Note: Count of zero is allowed (see "RETURN VALUE" portion of
	  write(2) manpage for details.
 Test Read
  A wrapper for read(2), that automatically handles the following
  special conditions:
    + Interrupted system call (EINTR)
    + Read of less than requested amount
    + Non-block return (EAGAIN)
  For each of the above, an additional read is performed to automatically
  continue reading the requested data.
  There are also many cases where read(2) can return an unexpected
  error (e.g. EIO).  Such errors cause a TEST_ASSERT failure.  Note,
  it is expected that the file opened by fd at the current file position
  contains at least the number of requested bytes to be read.  A TEST_ASSERT
  failure is produced if an End-Of-File condition occurs, before all the
  data is read.  It is the callers responsibility to assure that sufficient
  data exists.
  Note, for function signature compatibility with read(2), this function
  returns the number of bytes read, but that value will always be equal
  to the number of requested bytes.  All other conditions in this and
  future enhancements to this function either automatically issue another
  read(2) or cause a TEST_ASSERT failure.
  Args:
   fd    - Opened file descriptor to file to be read.
   count - Number of bytes to read.
  Output:
   buf   - Starting address of where to write the bytes read.
  Return:
   On success, number of bytes read.
   On failure, a TEST_ASSERT failure is caused.
	 Note: Count of zero is allowed (see "If count is zero" portion of
	  read(2) manpage for details.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020, Red Hat, Inc.
 Starting with z13 we have 47bits of physical address 
 SPDX-License-Identifier: GPL-2.0-only
  Sparse bit array
  Copyright (C) 2018, Google LLC.
  Copyright (C) 2018, Red Hat, Inc. (code style cleanup and fuzzing driver)
  This library provides functions to support a memory efficient bit array,
  with an index size of 2^64.  A sparsebit array is allocated through
  the use sparsebit_alloc() and free'd via sparsebit_free(),
  such as in the following:
    struct sparsebit s;
    s = sparsebit_alloc();
    sparsebit_free(&s);
  The struct sparsebit type resolves down to a struct sparsebit.
  Note that, sparsebit_free() takes a pointer to the sparsebit
  structure.  This is so that sparsebit_free() is able to poison
  the pointer (e.g. set it to NULL) to the struct sparsebit before
  returning to the caller.
  Between the return of sparsebit_alloc() and the call of
  sparsebit_free(), there are multiple query and modifying operations
  that can be performed on the allocated sparsebit array.  All of
  these operations take as a parameter the value returned from
  sparsebit_alloc() and most also take a bit index.  Frequently
  used routines include:
   ---- Query Operations
   sparsebit_is_set(s, idx)
   sparsebit_is_clear(s, idx)
   sparsebit_any_set(s)
   sparsebit_first_set(s)
   sparsebit_next_set(s, prev_idx)
   ---- Modifying Operations
   sparsebit_set(s, idx)
   sparsebit_clear(s, idx)
   sparsebit_set_num(s, idx, num);
   sparsebit_clear_num(s, idx, num);
  A common operation, is to itterate over all the bits set in a test
  sparsebit array.  This can be done via code with the following structure:
    sparsebit_idx_t idx;
    if (sparsebit_any_set(s)) {
      idx = sparsebit_first_set(s);
      do {
        ...
        idx = sparsebit_next_set(s, idx);
      } while (idx != 0);
    }
  The index of the first bit set needs to be obtained via
  sparsebit_first_set(), because sparsebit_next_set(), needs
  the index of the previously set.  The sparsebit_idx_t type is
  unsigned, so there is no previous index before 0 that is available.
  Also, the call to sparsebit_first_set() is not made unless there
  is at least 1 bit in the array set.  This is because sparsebit_first_set()
  aborts if sparsebit_first_set() is called with no bits set.
  It is the callers responsibility to assure that the
  sparsebit array has at least a single bit set before calling
  sparsebit_first_set().
  ==== Implementation Overview ====
  For the most part the internal implementation of sparsebit is
  opaque to the caller.  One important implementation detail that the
  caller may need to be aware of is the spatial complexity of the
  implementation.  This implementation of a sparsebit array is not
  only sparse, in that it uses memory proportional to the number of bits
  set.  It is also efficient in memory usage when most of the bits are
  set.
  At a high-level the state of the bit settings are maintained through
  the use of a binary-search tree, where each node contains at least
  the following members:
    typedef uint64_t sparsebit_idx_t;
    typedef uint64_t sparsebit_num_t;
    sparsebit_idx_t idx;
    uint32_t mask;
    sparsebit_num_t num_after;
  The idx member contains the bit index of the first bit described by this
  node, while the mask member stores the setting of the first 32-bits.
  The setting of the bit at idx + n, where 0 <= n < 32, is located in the
  mask member at 1 << n.
  Nodes are sorted by idx and the bits described by two nodes will never
  overlap. The idx member is always aligned to the mask size, i.e. a
  multiple of 32.
  Beyond a typical implementation, the nodes in this implementation also
  contains a member named num_after.  The num_after member holds the
  number of bits immediately after the mask bits that are contiguously set.
  The use of the num_after member allows this implementation to efficiently
  represent cases where most bits are set.  For example, the case of all
  but the last two bits set, is represented by the following two nodes:
    node 0 - idx: 0x0 mask: 0xffffffff num_after: 0xffffffffffffffc0
    node 1 - idx: 0xffffffffffffffe0 mask: 0x3fffffff num_after: 0
  ==== Invariants ====
  This implementation usses the following invariants:
    + Node are only used to represent bits that are set.
      Nodes with a mask of 0 and num_after of 0 are not allowed.
    + Sum of bits set in all the nodes is equal to the value of
      the struct sparsebit_pvt num_set member.
    + The setting of at least one bit is always described in a nodes
      mask (mask >= 1).
    + A node with all mask bits set only occurs when the last bit
      described by the previous node is not equal to this nodes
      starting index - 1.  All such occurences of this condition are
      avoided by moving the setting of the nodes mask bits into
      the previous nodes num_after setting.
    + Node starting index is evenly divisible by the number of bits
      within a nodes mask member.
    + Nodes never represent a range of bits that wrap around the
      highest supported index.
       (idx + MASK_BITS + num_after - 1) <= ((sparsebit_idx_t) 0) - 1)
      As a consequence of the above, the num_after member of a node
      will always be <=:
        maximum_index - nodes_starting_index - number_of_mask_bits
    + Nodes within the binary search tree are sorted based on each
      nodes starting index.
    + The range of bits described by any two nodes do not overlap.  The
      range of bits described by a single node is:
        start: node->idx
        end (inclusive): node->idx + MASK_BITS + node->num_after - 1;
  Note, at times these invariants are temporarily violated for a
  specific portion of the code.  For example, when setting a mask
  bit, there is a small delay between when the mask bit is set and the
  value in the struct sparsebit_pvt num_set member is updated.  Other
  temporary violations occur when node_split() is called with a specified
  index and assures that a node where its mask represents the bit
  at the specified index exists.  At times to do this node_split()
  must split an existing node into two nodes or create a node that
  has no bits set.  Such temporary violations must be corrected before
  returning to the caller.  These corrections are typically performed
  by the local function node_reduce().
 Does not include indent amount 
 index of least-significant bit in mask 
 num contiguously set after mask 
	
	  Points to root node of the binary search
	  tree.  Equal to NULL when no bits are set in
	  the entire sparsebit array.
	
	  A redundant count of the total number of bits set.  Used for
	  diagnostic purposes and to change the time complexity of
	  sparsebit_num_set() from O(n) to O(1).
	  Note: Due to overflow, a value of 0 means none or all set.
 Returns the number of set bits described by the settings
  of the node pointed to by nodep.
 Returns a pointer to the node that describes the
  lowest bit index.
 Returns a pointer to the node that describes the
  lowest bit index > the index of the node pointed to by np.
  Returns NULL if no node with a higher index exists.
	
	  If current node has a right child, next node is the left-most
	  of the right child.
	
	  No right child.  Go up until node is left child of a parent.
	  That parent is then the next node.
 Searches for and returns a pointer to the node that describes the
  highest index < the index of the node pointed to by np.
  Returns NULL if no node with a lower index exists.
	
	  If current node has a left child, next node is the right-most
	  of the left child.
	
	  No left child.  Go up until node is right child of a parent.
	  That parent is then the next node.
 Allocates space to hold a copy of the node sub-tree pointed to by
  subtree and duplicates the bit settings to the newly allocated nodes.
  Returns the newly allocated copy of subtree.
 Duplicate the node at the root of the subtree 
 As needed, recursively duplicate the left and right subtrees 
 Searches for and returns a pointer to the node that describes the setting
  of the bit given by idx.  A node describes the setting of a bit if its
  index is within the bits described by the mask bits or the number of
  contiguous bits set after the mask.  Returns NULL if there is no such node.
 Find the node that describes the setting of the bit at idx 
 Entry Requirements:
    + A node that describes the setting of idx is not already present.
  Adds a new node to describe the setting of the bit at the index given
  by idx.  Returns a pointer to the newly added node.
  TODO(lhuemill): Degenerate cases causes the tree to get unbalanced.
 Allocate and initialize the new node. 
 If no nodes, set it up as the root node. 
	
	  Find the parent where the new node should be attached
	  and add the node there.
	
	  Does num_after bits of previous node overlap with the mask
	  of the new node?  If so set the bits in the new nodes mask
	  and reduce the previous nodes num_after.
 Returns whether all the bits in the sparsebit array are set.  
	
	  If any nodes there must be at least one bit set.  Only case
	  where a bit is set and total num set is 0, is when all bits
	  are set.
 Clears all bits described by the node pointed to by nodep, then
  removes the node.
 Have both left and right child 
		
		  Move left children to the leftmost leaf node
		  of the right child.
 Left only child 
 Right only child 
 Leaf Node 
 Splits the node containing the bit at idx so that there is a node
  that starts at the specified index.  If no such node exists, a new
  node at the specified index is created.  Returns the new node.
  idx must start of a mask boundary.
	
	  Is there a node that describes the setting of idx?
	  If not, add it.
	
	  All done if the starting index of the node is where the
	  split should occur.
	
	  Split point not at start of mask, so it must be part of
	  bits described by num_after.
	
	  Calculate offset within num_after for where the split is
	  to occur.
	
	  Add a new node to describe the bits starting at
	  the split point.
 Move bits after the split point into the new node 
 Iteratively reduces the node pointed to by nodep and its adjacent
  nodes into a more compact form.  For example, a node with a mask with
  all bits set adjacent to a previous node, will get combined into a
  single node with an increased num_after setting.
  After each reduction, a further check is made to see if additional
  reductions are possible with the new previous and next nodes.  Note,
  a search for a reduction is only done across the nodes nearest nodep
  and those that became part of a reduction.  Reductions beyond nodep
  and the adjacent nodes that are reduced are not discovered.  It is the
  responsibility of the caller to pass a nodep that is within one node
  of each possible reduction.
  This function does not fix the temporary violation of all invariants.
  For example it does not fix the case where the bit settings described
  by two or more nodes overlap.  Such a violation introduces the potential
  complication of a bit setting for a specific index having different settings
  in different nodes.  This would then introduce the further complication
  of which node has the correct setting of the bit and thus such conditions
  are not allowed.
  This function is designed to fix invariant violations that are introduced
  by node_split() and by changes to the nodes mask or num_after members.
  For example, when setting a bit within a nodes mask, the function that
  sets the bit doesn't have to worry about whether the setting of that
  bit caused the mask to have leading only or trailing only bits set.
  Instead, the function can call node_reduce(), with nodep equal to the
  node address that it set a mask bit in, and node_reduce() will notice
  the cases of leading or trailing only bits and that there is an
  adjacent node that the bit settings could be merged into.
  This implementation specifically detects and corrects violation of the
  following invariants:
    + Node are only used to represent bits that are set.
      Nodes with a mask of 0 and num_after of 0 are not allowed.
    + The setting of at least one bit is always described in a nodes
      mask (mask >= 1).
    + A node with all mask bits set only occurs when the last bit
      described by the previous node is not equal to this nodes
      starting index - 1.  All such occurences of this condition are
      avoided by moving the setting of the nodes mask bits into
      the previous nodes num_after setting.
 1) Potential reductions within the current node. 
 Nodes with all bits cleared may be removed. 
			
			  About to remove the node pointed to by
			  nodep, which normally would cause a problem
			  for the next pass through the reduction loop,
			  because the node at the starting point no longer
			  exists.  This potential problem is handled
			  by first remembering the location of the next
			  or previous nodes.  Doesn't matter which, because
			  once the node at nodep is removed, there will be
			  no other nodes between prev and next.
			 
			  Note, the checks performed on nodep against both
			  both prev and next both check for an adjacent
			  node that can be reduced into a single node.  As
			  such, after removing the node at nodep, doesn't
			  matter whether the nodep for the next pass
			  through the loop is equal to the previous pass
			  prev or next node.  Either way, on the next pass
			  the one not selected will become either the
			  prev or next node.
		
		  When the mask is 0, can reduce the amount of num_after
		  bits by moving the initial num_after bits into the mask.
		
		  2) Potential reductions between the current and
		  previous nodes.
 Nodes with no bits set can be removed. 
			
			  All mask bits set and previous node has
			  adjacent index.
			
			  Is node adjacent to previous node and the node
			  contains a single contiguous range of bits
			  starting from the beginning of the mask?
				
				  How many contiguous bits are there?
				  Is equal to the total number of set
				  bits, due to an earlier check that
				  there is a single contiguous range of
				  set bits.
				
				  For predictable performance, handle special
				  case where all mask bits are set and there
				  is a non-zero num_after setting.  This code
				  is functionally correct without the following
				  conditionalized statements, but without them
				  the value of num_after is only reduced by
				  the number of mask bits per pass.  There are
				  cases where num_after can be close to 2^64.
				  Without this code it could take nearly
				  (2^64)  32 passes to perform the full
				  reduction.
		
		  3) Potential reductions between the current and
		  next nodes.
 Nodes with no bits set can be removed. 
			
			  Is next node index adjacent to current node
			  and has a mask with all bits set?
 Returns whether the bit at the index given by idx, within the
  sparsebit array is set or not.
 Find the node that describes the setting of the bit at idx 
 Bit is set if it is any of the bits described by num_after 
 Is the corresponding mask bit set 
 Within the sparsebit array pointed to by s, sets the bit
  at the index given by idx.
 Skip bits that are already set 
	
	  Get a node where the bit at idx is described by the mask.
	  The node_split will also create a node, if there isn't
	  already a node that describes the setting of bit.
 Set the bit within the nodes mask 
 Within the sparsebit array pointed to by s, clears the bit
  at the index given by idx.
 Skip bits that are already cleared 
 Is there a node that describes the setting of this bit? 
	
	  If a num_after bit, split the node, so that the bit is
	  part of a node mask.
	
	  After node_split above, bit at idx should be within the mask.
	  Clear that bit.
 Recursively dumps to the FILE stream given by stream the contents
  of the sub-tree of nodes pointed to by nodep.  Each line of output
  is prefixed by the number of spaces given by indent.  On each
  recursion, the indent amount is increased by 2.  This causes nodes
  at each level deeper into the binary search tree to be displayed
  with a greater indent.
 Dump contents of node 
 If present, dump contents of left child nodes 
 If present, dump contents of right child nodes 
 Dumps to the FILE stream specified by stream, the implementation dependent
  internal state of s.  Each line of output is prefixed with the number
  of spaces given by indent.  The output is completely implementation
  dependent and subject to change.  Output from this function should only
  be used for diagnostic purposes.  For example, this function can be
  used by test cases after they detect an unexpected condition, as a means
  to capture diagnostic information.
 Dump the contents of s 
 Allocates and returns a new sparsebit array. The initial state
  of the newly allocated sparsebit array has all bits cleared.
 Allocate top level structure. 
 Frees the implementation dependent data for the sparsebit array
  pointed to by s and poisons the pointer to that data.
 Makes a copy of the sparsebit array given by s, to the sparsebit
  array given by d.  Note, d must have already been allocated via
  sparsebit_alloc().  It can though already have bits set, which
  if different from src will be cleared.
 First clear any bits already set in the destination 
 Returns whether num consecutive bits starting at idx are all set.  
 With num > 0, the first bit must be set. 
 Find the next cleared bit 
	
	  If no cleared bits beyond idx, then there are at least num
	  set bits. idx + num doesn't wrap.  Otherwise check if
	  there are enough set bits between idx and the next cleared bit.
 Returns whether the bit at the index given by idx.  
 Returns whether num consecutive bits starting at idx are all cleared.  
 With num > 0, the first bit must be cleared. 
 Find the next set bit 
	
	  If no set bits beyond idx, then there are at least num
	  cleared bits. idx + num doesn't wrap.  Otherwise check if
	  there are enough cleared bits between idx and the next set bit.
 Returns the total number of bits set.  Note: 0 is also returned for
  the case of all bits set.  This is because with all bits set, there
  is 1 additional bit set beyond what can be represented in the return
  value.  Use sparsebit_any_set(), instead of sparsebit_num_set() > 0,
  to determine if the sparsebit array has any bits set.
 Returns whether any bit is set in the sparsebit array.  
	
	  Nodes only describe set bits.  If any nodes then there
	  is at least 1 bit set.
	
	  Every node should have a non-zero mask.  For now will
	  just assure that the root node has a non-zero mask,
	  which is a quick check that at least 1 bit is set.
 Returns whether all the bits in the sparsebit array are cleared.  
 Returns whether all the bits in the sparsebit array are set.  
 Returns the index of the first set bit.  Abort if no bits are set.
 Validate at least 1 bit is set 
 Returns the index of the first cleared bit.  Abort if
  no bits are cleared.
 Validate at least 1 bit is cleared. 
 If no nodes or first node index > 0 then lowest cleared is 0 
 Does the mask in the first node contain any cleared bits. 
	
	  All mask bits set in first node.  If there isn't a second node
	  then the first cleared bit is the first bit after the bits
	  described by the first node.
		
		  No second node.  First cleared bit is first bit beyond
		  bits described by first node.
	
	  There is a second node.
	  If it is not adjacent to the first node, then there is a gap
	  of cleared bits between the nodes, and the first cleared bit
	  is the first bit within the gap.
	
	  Second node is adjacent to the first node.
	  Because it is adjacent, its mask should be non-zero.  If all
	  its mask bits are set, then with it being adjacent, it should
	  have had the mask bits moved into the num_after setting of the
	  previous node.
 Returns index of next bit set within s after the index given by prev.
  Returns 0 if there are no bits after prev that are set.
 A bit after the highest index can't be set. 
	
	  Find the leftmost 'candidate' overlapping or to the right
	  of lowest_possible.
 True iff lowest_possible is within candidate 
	
	  Find node that describes setting of bit at lowest_possible.
	  If such a node doesn't exist, find the node with the lowest
	  starting index that is > lowest_possible.
 Does the candidate node describe the setting of lowest_possible? 
		
		  Candidate doesn't describe setting of bit at lowest_possible.
		  Candidate points to the first node with a starting index
		  > lowest_possible.
	
	  Candidate describes setting of bit at lowest_possible.
	  Note: although the node describes the setting of the bit
	  at lowest_possible, its possible that its setting and the
	  setting of all latter bits described by this node are 0.
	  For now, just handle the cases where this node describes
	  a bit at or after an index of lowest_possible that is set.
	
	  Although candidate node describes setting of bit at
	  the index of lowest_possible, all bits at that index and
	  latter that are described by candidate are cleared.  With
	  this, the next bit is the first bit in the next node, if
	  such a node exists.  If a next node doesn't exist, then
	  there is no next set bit.
 Returns index of next bit cleared within s after the index given by prev.
  Returns 0 if there are no bits after prev that are cleared.
 A bit after the highest index can't be set. 
	
	  Does a node describing the setting of lowest_possible exist?
	  If not, the bit at lowest_possible is cleared.
 Does a mask bit in node 1 describe the next cleared bit. 
	
	  Next cleared bit is not described by node 1.  If there
	  isn't a next node, then next cleared bit is described
	  by bit after the bits described by the first node.
	
	  There is a second node.
	  If it is not adjacent to the first node, then there is a gap
	  of cleared bits between the nodes, and the next cleared bit
	  is the first bit within the gap.
	
	  Second node is adjacent to the first node.
	  Because it is adjacent, its mask should be non-zero.  If all
	  its mask bits are set, then with it being adjacent, it should
	  have had the mask bits moved into the num_after setting of the
	  previous node.
 Starting with the index 1 greater than the index given by start, finds
  and returns the index of the first sequence of num consecutively set
  bits.  Returns a value of 0 of no such sequence exists.
		
		  Does the sequence of bits starting at idx consist of
		  num set bits?
		
		  Sequence of set bits at idx isn't large enough.
		  Skip this entire sequence of set bits.
 Starting with the index 1 greater than the index given by start, finds
  and returns the index of the first sequence of num consecutively cleared
  bits.  Returns a value of 0 of no such sequence exists.
		
		  Does the sequence of bits starting at idx consist of
		  num cleared bits?
		
		  Sequence of cleared bits at idx isn't large enough.
		  Skip this entire sequence of cleared bits.
 Sets the bits  in the inclusive range idx through idx + num - 1.  
	
	  Leading - bits before first mask boundary.
	 
	  TODO(lhuemill): With some effort it may be possible to
	    replace the following loop with a sequential sequence
	    of statements.  High level sequence would be:
	 
	      1. Use node_split() to force node that describes setting
	         of idx to be within the mask portion of a node.
	      2. Form mask of bits to be set.
	      3. Determine number of mask bits already set in the node
	         and store in a local variable named num_already_set.
	      4. Set the appropriate mask bits within the node.
	      5. Increment struct sparsebit_pvt num_set member
	         by the number of bits that were actually set.
	         Exclude from the counts bits that were already set.
	      6. Before returning to the caller, use node_reduce() to
	         handle the multiple corner cases that this method
	         introduces.
 Middle - bits spanning one or more entire mask 
		
		  As needed, split just after end of middle bits.
		  No split needed if end of middle bits is at highest
		  supported bit index.
 Delete nodes that only describe bits within the middle. 
 As needed set each of the mask bits 
 Trailing - bits at and beyond last mask boundary 
 Clears the bits  in the inclusive range idx through idx + num - 1.  
 Leading - bits before first mask boundary 
 Middle - bits spanning one or more entire mask 
		
		  As needed, split just after end of middle bits.
		  No split needed if end of middle bits is at highest
		  supported bit index.
 Delete nodes that only describe bits within the middle. 
 As needed clear each of the mask bits 
 Clear any bits described by num_after 
		
		  Delete the node that describes the beginning of
		  the middle bits and perform any allowed reductions
		  with the nodes prev or next of nodep.
 Trailing - bits at and beyond last mask boundary 
 Sets the bit at the index given by idx.  
 Clears the bit at the index given by idx.  
 Sets the bits in the entire addressable range of the sparsebit array.  
 Clears the bits in the entire addressable range of the sparsebit array.  
 Determine the printf format string 
	
	  When stream is NULL, just determine the size of what would
	  have been printed, else print the range.
 Dumps to the FILE stream given by stream, the bit settings
  of s.  Each line of output is prefixed with the number of
  spaces given by indent.  The length of each line is implementation
  dependent and does not depend on the indent amount.  The following
  is an example output of a sparsebit array that has bits:
    0x5, 0x8, 0xa:0xe, 0x12
  This corresponds to a sparsebit whose bits 5, 8, 10, 11, 12, 13, 14, 18
  are set.  Note that a ':', instead of a '-' is used to specify a range of
  contiguous bits.  This is done because '-' is used to specify command-line
  options, and sometimes ranges are specified as command-line arguments.
 Display initial indent 
 For each node 
 For each group of bits in the mask 
				
				  How much room will it take to display
				  this range.
				
				  If there is not enough room, display
				  a newline plus the indent of the next
				  line.
 Display the range 
		
		  If num_after and most significant-bit of mask is not
		  set, then still need to display a range for the bits
		  described by num_after.
			
			  How much room will it take to display
			  this range.
			
			  If there is not enough room, display
			  a newline plus the indent of the next
			  line.
 Display the range 
 Validates the internal state of the sparsebit array given by
  s.  On error, diagnostic information is printed to stderr and
  abort is called.
 For each node 
		
		  Increase total bits set by the number of bits set
		  in this node.
		
		  Arbitrary choice as to whether a mask of 0 is allowed
		  or not.  For diagnostic purposes it is beneficial to
		  have only one valid means to represent a set of bits.
		  To support this an arbitrary choice has been made
		  to not allow a mask of zero.
		
		  Validate num_after is not greater than the max index
		  - the number of mask bits.  The num_after member
		  uses 0-based indexing and thus has no value that
		  represents all bits set.  This limitation is handled
		  by requiring a non-zero mask.  With a non-zero mask,
		  MASK_BITS worth of bits are described by the mask,
		  which makes the largest needed num_after equal to:
		 
		     (~(sparsebit_num_t) 0) - MASK_BITS + 1
 Validate node index is divisible by the mask size 
		
		  Validate bits described by node don't wrap beyond the
		  highest supported index.
 Check parent pointers. 
			
			  Is index of previous node before index of
			  current node?
			
			  Nodes occur in asscending order, based on each
			  nodes starting index.
			
			  When the node has all mask bits set, it shouldn't
			  be adjacent to the last bit described by the
			  previous node.
		
		  Is sum of bits set in each node equal to the count
		  of total bits set.
 A simple but effective fuzzing driver.  Look for bugs with the help
  of some invariants and of a trivial representation of sparsebit.
  Just use 512 bytes of devzero and devurandom as inputs, and let
  afl-fuzz do the magic. :)
 SPDX-License-Identifier: GPL-2.0-only
  toolstestingselftestskvmlibtest_util.c
  Copyright (C) 2020, Google LLC.
  Parses "[0-9]+[kmgt]?".
			
			  No MAP_HUGETLB, we use MFD_HUGETLB instead. Since
			  we're using "file backed" memory, we need to specify
			  this when the FD is created, not when the area is
			  mapped.
 Return MIN_RUN_DELAY_NS upon failure just to be safe 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020, Google LLC.
  Guest virtual memory offset of the testing memory slot.
  Must not conflict with identity mapped test code.
 The id of the vCPU. 
 The pthread backing the vCPU. 
 Set to true once the vCPU thread is up and running. 
 The vCPU threads involved in this test. 
 The function run by each vCPU thread, as provided by the test. 
 Set to true once all vCPU threads are up and running. 
  Continuously write to the first 8 bytes of each page in the
  specified region.
 Make sure vCPU args data structure is not corrupt. 
 By default vCPUs will write to memory. 
	
	  Snapshot the non-huge page size.  This is used by the guest code to
	  accessdirty pages at the logging granularity.
	
	  Pass guest_num_pages to populate the page tables for test memory.
	  The memory is also added to memslot 0, but that's a benign side
	  effect as KVM allows aliasing HVAs in meslots.
	
	  If there should be more memory in the guest test region than there
	  can be pages in the guest, it will definitely cause problems.
 Align to 1M (segment size) 
 Add extra memory slots for testing 
 Do mapping for the demand paging memory slot 
 Export the shared variables to the guest. 
	
	  Wait for all vCPU threads to be up and running before calling the test-
	  provided vCPU thread function. This prevents thread creation (which
	  requires taking the mmap_sem in write mode) from interfering with the
	  guest faulting in its memory.
 SPDX-License-Identifier: GPL-2.0-only
  toolstestingselftestskvmlibkvm_util.c
  Copyright (C) 2018, Google LLC.
 for program_invocation_name 
  Open KVM_DEV_PATH if available, otherwise exit the entire program.
  Input Args:
    flags - The flags to pass when opening KVM_DEV_PATH.
  Return:
    The opened file descriptor of devkvm.
  Capability
  Input Args:
    cap - Capability
  Output Args: None
  Return:
    On success, the Value corresponding to the capability (KVM_CAP_)
    specified by the value of cap.  On failure a TEST_ASSERT failure
    is produced.
  Looks up and returns the value corresponding to the capability
  (KVM_CAP_) given by cap.
 VM Enable Capability
  Input Args:
    vm - Virtual Machine
    cap - Capability
  Output Args: None
  Return: On success, 0. On failure a TEST_ASSERT failure is produced.
  Enables a capability (KVM_CAP_) on the VM.
 VCPU Enable Capability
  Input Args:
    vm - Virtual Machine
    vcpu_id - VCPU
    cap - Capability
  Output Args: None
  Return: On success, 0. On failure a TEST_ASSERT failure is produced.
  Enables a capability (KVM_CAP_) on the VCPU.
  VM Create
  Input Args:
    mode - VM Mode (e.g. VM_MODE_P52V48_4K)
    phy_pages - Physical memory pages
    perm - permission
  Output Args: None
  Return:
    Pointer to opaque structure that describes the created VM.
  Creates a VM with the mode specified by mode (e.g. VM_MODE_P52V48_4K).
  When phy_pages is non-zero, a memory region of phy_pages physical pages
  is created and mapped starting at guest physical address 0.  The file
  descriptor to control the created VM is created with the permissions
  given by perm (e.g. O_RDWR).
 Setup mode specific traits. 
		
		  Ignore KVM support for 5-level paging (vm->va_bits == 57),
		  it doesn't take effect unless a CR4.LA57 is set, which it
		  isn't for this VM_MODE.
 Limit to VA-bit canonical virtual addresses. 
 Limit physical addresses to PA-bits. 
 Allocate and setup memory for guest. 
  VM Create with customized parameters
  Input Args:
    mode - VM Mode (e.g. VM_MODE_P52V48_4K)
    nr_vcpus - VCPU count
    slot0_mem_pages - Slot0 physical memory size
    extra_mem_pages - Non-slot0 physical memory total size
    num_percpu_pages - Per-cpu physical memory pages
    guest_code - Guest entry point
    vcpuids - VCPU IDs
  Output Args: None
  Return:
    Pointer to opaque structure that describes the created VM.
  Creates a VM with the mode specified by mode (e.g. VM_MODE_P52V48_4K),
  with customized slot0 memory size, at least 512 pages currently.
  extra_mem_pages is only used to calculate the maximum page table size,
  no real memory allocation for non-slot0 memory in this function.
 Force slot0 memory size not small than DEFAULT_GUEST_PHY_PAGES 
	 The maximum page table size for a memory region will be when the
	  smallest pages are used. Considering each page contains x page
	  table descriptors, the total extra size for page tables (for extra
	  N pages) will be: Nx+Nx^2+Nx^3+... which is definitely smaller
	  than Nx2.
  VM Restart
  Input Args:
    vm - VM that has been released before
    perm - permission
  Output Args: None
  Reopens the file descriptors associated to the VM and reinstates the
  global state, such as the irqchip and the memory regions that are mapped
  into the guest.
  Userspace Memory Region Find
  Input Args:
    vm - Virtual Machine
    start - Starting VM physical address
    end - Ending VM physical address, inclusive.
  Output Args: None
  Return:
    Pointer to overlapping region, NULL if no such region.
  Searches for a region with any physical memory that overlaps with
  any portion of the guest physical addresses from start to end
  inclusive.  If multiple overlapping regions exist, a pointer to any
  of the regions is returned.  Null is returned only when no overlapping
  region exists.
  KVM Userspace Memory Region Find
  Input Args:
    vm - Virtual Machine
    start - Starting VM physical address
    end - Ending VM physical address, inclusive.
  Output Args: None
  Return:
    Pointer to overlapping region, NULL if no such region.
  Public interface to userspace_mem_region_find. Allows tests to look up
  the memslot datastructure for a given range of guest physical memory.
  VCPU Find
  Input Args:
    vm - Virtual Machine
    vcpuid - VCPU ID
  Output Args: None
  Return:
    Pointer to VCPU structure
  Locates a vcpu structure that describes the VCPU specified by vcpuid and
  returns a pointer to it.  Returns NULL if the VM doesn't contain a VCPU
  for the specified vcpuid.
  VM VCPU Remove
  Input Args:
    vcpu - VCPU to remove
  Output Args: None
  Return: None, TEST_ASSERT failures for all error conditions
  Removes a vCPU from a VM and frees its resources.
  Destroys and frees the VM pointed to by vmp.
 Free userspace_mem_regions. 
 Free sparsebit arrays. 
 Free the structure describing the VM. 
  Memory Compare, host virtual to guest virtual
  Input Args:
    hva - Starting host virtual address
    vm - Virtual Machine
    gva - Starting guest virtual address
    len - number of bytes to compare
  Output Args: None
  InputOutput Args: None
  Return:
    Returns 0 if the bytes starting at hva for a length of len
    are equal the guest virtual bytes starting at gva.  Returns
    a value < 0, if bytes at hva are less than those at gva.
    Otherwise a value > 0 is returned.
  Compares the bytes starting at the host virtual address hva, for
  a length of len, to the guest bytes starting at the guest virtual
  address given by gva.
	
	  Compare a batch of bytes until either a match is found
	  or all the bytes have been compared.
		
		  Determine host address for guest virtual address
		  at offset.
		
		  Determine amount to compare on this pass.
		  Don't allow the comparsion to cross a page boundary.
		
		  Perform the comparison.  If there is a difference
		  return that result to the caller, otherwise need
		  to continue on looking for a mismatch.
	
	  No mismatch found.  Let the caller know the two memory
	  areas are equal.
  VM Userspace Memory Region Add
  Input Args:
    vm - Virtual Machine
    src_type - Storage source for this region.
               NULL to use anonymous memory.
    guest_paddr - Starting guest physical address
    slot - KVM region slot
    npages - Number of physical pages
    flags - KVM memory region flags (e.g. KVM_MEM_LOG_DIRTY_PAGES)
  Output Args: None
  Return: None
  Allocates a memory area of the number of pages specified by npages
  and maps it to the VM specified by vm, at a starting physical address
  given by guest_paddr.  The region is created with a KVM region slot
  given by slot, which must be unique and < KVM_MEM_SLOTS_NUM.  The
  region is created with the flags given by flags.
	
	  Confirm a mem region with an overlapping address doesn't
	  already exist.
 Confirm no region with the requested slot already exists. 
 Allocate and initialize new mem region structure. 
 On s390x, the host address must be aligned to 1M (due to PGSTEs) 
	
	  When using THP mmap is not guaranteed to returned a hugepage aligned
	  address so we have to pad the mmap. Padding is not needed for HugeTLB
	  because mmap will always return an address aligned to the HugeTLB
	  page size.
 Add enough memory to align up if necessary 
 Align host address 
 As needed perform madvise 
 Add to quick lookup data structures 
 If shared memory, create an alias. 
 Align host alias address 
  Memslot to region
  Input Args:
    vm - Virtual Machine
    memslot - KVM memory slot ID
  Output Args: None
  Return:
    Pointer to memory region structure that describe memory region
    using kvm memory slot ID given by memslot.  TEST_ASSERT failure
    on error (e.g. currently no memory region using memslot as a KVM
    memory slot ID).
  VM Memory Region Flags Set
  Input Args:
    vm - Virtual Machine
    flags - Starting guest physical address
  Output Args: None
  Return: None
  Sets the flags of the memory region specified by the value of slot,
  to the values given by flags.
  VM Memory Region Move
  Input Args:
    vm - Virtual Machine
    slot - Slot of the memory region to move
    new_gpa - Starting guest physical address
  Output Args: None
  Return: None
  Change the gpa of a memory region.
  VM Memory Region Delete
  Input Args:
    vm - Virtual Machine
    slot - Slot of the memory region to delete
  Output Args: None
  Return: None
  Delete a memory region.
  VCPU mmap Size
  Input Args: None
  Output Args: None
  Return:
    Size of VCPU state
  Returns the size of the structure pointed to by the return value
  of vcpu_state().
  VM VCPU Add
  Input Args:
    vm - Virtual Machine
    vcpuid - VCPU ID
  Output Args: None
  Return: None
  Adds a virtual CPU to the VM specified by vm with the ID given by vcpuid.
  No additional VCPU setup is done.
 Confirm a vcpu with the specified id doesn't already exist. 
 Allocate and initialize new vcpu structure. 
 Add to linked-list of VCPUs. 
  VM Virtual Address Unused Gap
  Input Args:
    vm - Virtual Machine
    sz - Size (bytes)
    vaddr_min - Minimum Virtual Address
  Output Args: None
  Return:
    Lowest virtual address at or below vaddr_min, with at least
    sz unused bytes.  TEST_ASSERT failure if no area of at least
    size sz is available.
  Within the VM specified by vm, locates the lowest starting virtual
  address >= vaddr_min, that has at least sz unallocated bytes.  A
  TEST_ASSERT failure occurs for invalid input or no area of at least
  sz unallocated bytes >= vaddr_min is available.
 Determine lowest permitted virtual page index. 
 Loop over section with enough valid virtual page indexes. 
		
		  Are there enough unused virtual pages available at
		  the currently proposed starting virtual page index.
		  If not, adjust proposed starting index to next
		  possible.
		
		  If needed, adjust proposed starting virtual address,
		  to next range of valid virtual addresses.
 NOT REACHED 
  VM Virtual Address Allocate
  Input Args:
    vm - Virtual Machine
    sz - Size in bytes
    vaddr_min - Minimum starting virtual address
    data_memslot - Memory region slot for data pages
    pgd_memslot - Memory region slot for new virtual translation tables
  Output Args: None
  Return:
    Starting guest virtual address
  Allocates at least sz bytes within the virtual address space of the vm
  given by vm.  The allocated bytes are mapped to a virtual address >=
  the address given by vaddr_min.  Note that each allocation uses a
  a unique set of pages, with the minimum real allocation being at least
  a page.
	
	  Find an unused range of virtual page addresses of at least
	  pages in length.
 Map the virtual pages. 
  VM Virtual Address Allocate Pages
  Input Args:
    vm - Virtual Machine
  Output Args: None
  Return:
    Starting guest virtual address
  Allocates at least N system pages worth of bytes within the virtual address
  space of the vm.
  VM Virtual Address Allocate Page
  Input Args:
    vm - Virtual Machine
  Output Args: None
  Return:
    Starting guest virtual address
  Allocates at least one system page worth of bytes within the virtual address
  space of the vm.
  Map a range of VM virtual address to the VM's physical address
  Input Args:
    vm - Virtual Machine
    vaddr - Virtuall address to map
    paddr - VM Physical Address
    npages - The number of pages to map
    pgd_memslot - Memory region slot for new virtual translation tables
  Output Args: None
  Return: None
  Within the VM given by @vm, creates a virtual translation for
  @npages starting at @vaddr to the page range starting at @paddr.
  Address VM Physical to Host Virtual
  Input Args:
    vm - Virtual Machine
    gpa - VM physical address
  Output Args: None
  Return:
    Equivalent host virtual address
  Locates the memory region containing the VM physical address given
  by gpa, within the VM given by vm.  When found, the host virtual
  address providing the memory to the vm physical address is returned.
  A TEST_ASSERT failure occurs if no region containing gpa exists.
  Address Host Virtual to VM Physical
  Input Args:
    vm - Virtual Machine
    hva - Host virtual address
  Output Args: None
  Return:
    Equivalent VM physical address
  Locates the memory region containing the host virtual address given
  by hva, within the VM given by vm.  When found, the equivalent
  VM physical address is returned. A TEST_ASSERT failure occurs if no
  region containing hva exists.
  Address VM physical to Host Virtual alias.
  Input Args:
    vm - Virtual Machine
    gpa - VM physical address
  Output Args: None
  Return:
    Equivalent address within the host virtual alias area, or NULL
    (without failing the test) if the guest memory is not shared (so
    no alias exists).
  When vm_create() and related functions are called with a shared memory
  src_type, we also create a writable, shared alias mapping of the
  underlying guest memory. This allows the host to manipulate guest memory
  without mapping that memory in the guest's address space. And, for
  userfaultfd-based demand paging, we can do so without triggering userfaults.
  VM Create IRQ Chip
  Input Args:
    vm - Virtual Machine
  Output Args: None
  Return: None
  Creates an interrupt controller chip for the VM specified by vm.
  VM VCPU State
  Input Args:
    vm - Virtual Machine
    vcpuid - VCPU ID
  Output Args: None
  Return:
    Pointer to structure that describes the state of the VCPU.
  Locates and returns a pointer to a structure that describes the
  state of the VCPU with the given vcpuid.
  VM VCPU Run
  Input Args:
    vm - Virtual Machine
    vcpuid - VCPU ID
  Output Args: None
  Return: None
  Switch to executing the code for the VCPU given by vcpuid, within the VM
  given by vm.
  VM VCPU Set MP State
  Input Args:
    vm - Virtual Machine
    vcpuid - VCPU ID
    mp_state - mp_state to be set
  Output Args: None
  Return: None
  Sets the MP state of the VCPU given by vcpuid, to the state given
  by mp_state.
  VM VCPU Get Reg List
  Input Args:
    vm - Virtual Machine
    vcpuid - VCPU ID
  Output Args:
    None
  Return:
    A pointer to an allocated struct kvm_reg_list
  Get the list of guest registers which are supported for
  KVM_GET_ONE_REGKVM_SET_ONE_REG calls
  VM VCPU Regs Get
  Input Args:
    vm - Virtual Machine
    vcpuid - VCPU ID
  Output Args:
    regs - current state of VCPU regs
  Return: None
  Obtains the current register state for the VCPU specified by vcpuid
  and stores it at the location given by regs.
  VM VCPU Regs Set
  Input Args:
    vm - Virtual Machine
    vcpuid - VCPU ID
    regs - Values to set VCPU regs to
  Output Args: None
  Return: None
  Sets the regs of the VCPU specified by vcpuid to the values
  given by regs.
  VM VCPU System Regs Get
  Input Args:
    vm - Virtual Machine
    vcpuid - VCPU ID
  Output Args:
    sregs - current state of VCPU system regs
  Return: None
  Obtains the current system register state for the VCPU specified by
  vcpuid and stores it at the location given by sregs.
  VM VCPU System Regs Set
  Input Args:
    vm - Virtual Machine
    vcpuid - VCPU ID
    sregs - Values to set VCPU system regs to
  Output Args: None
  Return: None
  Sets the system regs of the VCPU specified by vcpuid to the values
  given by sregs.
  VCPU Ioctl
  Input Args:
    vm - Virtual Machine
    vcpuid - VCPU ID
    cmd - Ioctl number
    arg - Argument to pass to the ioctl
  Return: None
  Issues an arbitrary ioctl on a VCPU fd.
  VM Ioctl
  Input Args:
    vm - Virtual Machine
    cmd - Ioctl number
    arg - Argument to pass to the ioctl
  Return: None
  Issues an arbitrary ioctl on a VM fd.
  KVM system ioctl
  Input Args:
    vm - Virtual Machine
    cmd - Ioctl number
    arg - Argument to pass to the ioctl
  Return: None
  Issues an arbitrary ioctl on a KVM fd.
  Device Ioctl
  VM Dump
  Input Args:
    vm - Virtual Machine
    indent - Left margin indent amount
  Output Args:
    stream - Output FILE stream
  Return: None
  Dumps the current state of the VM given by vm, to the FILE stream
  given by stream.
 Known KVM exit reasons 
  Exit Reason String
  Input Args:
    exit_reason - Exit reason
  Output Args: None
  Return:
    Constant string pointer describing the exit reason.
  Locates and returns a constant string that describes the KVM exit
  reason given by exit_reason.  If no such string is found, a constant
  string of "Unknown" is returned.
  Physical Contiguous Page Allocator
  Input Args:
    vm - Virtual Machine
    num - number of pages
    paddr_min - Physical address minimum
    memslot - Memory region to allocate page from
  Output Args: None
  Return:
    Starting physical address
  Within the VM specified by vm, locates a range of available physical
  pages at or above paddr_min. If found, the pages are marked as in use
  and their base address is returned. A TEST_ASSERT failure occurs if
  not enough pages are available at or above paddr_min.
 Arbitrary minimum physical address used for virtual translation tables. 
  Address Guest Virtual to Host Virtual
  Input Args:
    vm - Virtual Machine
    gva - VM virtual address
  Output Args: None
  Return:
    Equivalent host virtual address
  Is Unrestricted Guest
  Input Args:
    vm - Virtual Machine
  Output Args: None
  Return: True if the unrestricted guest is set to 'Y', otherwise return false.
  Check if the unrestricted guest flag is enabled.
 Ensure that the KVM vendor-specific module is loaded. 
 SPDX-License-Identifier: GPL-2.0
  ucall support. A ucall is a "hypercall to userspace".
  Copyright (C) 2018, Red Hat, Inc.
	
	  Find an address within the allowed physical and virtual address
	  spaces, that does _not_ have a KVM memory region associated with
	  it. Identity mapping an address like this allows the guest to
	  access it, but as KVM doesn't know what to do with it, it
	  will assume it's something userspace handles and exit with
	  KVM_EXIT_MMIO. Well, at least that's how it works for AArch64.
	  Here we start with a guess that the addresses around 58th
	  of the allowed space are unmapped and then work both down and
	  up from there in 116th allowed space sized steps.
	 
	  Note, we need to use VA-bits - 1 when calculating the allowed
	  virtual address space for an identity mapping because the upper
	  half of the virtual address space is the two's complement of the
	  lower and won't match physical addresses.
 SPDX-License-Identifier: GPL-2.0
  ARM64 Spinlock support
 SPDX-License-Identifier: GPL-2.0
  ARM Generic Interrupt Controller (GIC) v3 support
 1s 
 1s 
 We should not be reaching here 
 We care about 'cpu' only for SGIs or PPIs 
 1s 
 Wait until the processor is 'active' 
 Align all the redistributors sequentially 
	
	  Mark all the SGI and PPI interrupts as non-secure Group-1.
	  Also, deactivate and disable them.
 Set a default priority for all the SGIs and PPIs 
 Enable the GIC system register (ICC_) access 
 Set a default priority threshold 
 Enable non-secure Group-1 interrupts 
 Disable the distributor until we set things up 
	
	  Mark all the SPI interrupts as non-secure Group-1.
	  Also, deactivate and disable them.
 Set a default priority for all the SPIs 
 Wait for the settings to sync-in 
 Finally, enable the distributor globally with ARE 
	
	  Initialize only the distributor for now.
	  The redistributor and CPU interfaces are initialized
	  later for every PE.
 SPDX-License-Identifier: GPL-2.0
  AArch64 code
  Copyright (C) 2018, Red Hat, Inc.
 fall through 
 fall through 
 Access Flag ;
 NORMAL (See DEFAULT_MAIR_EL1) 
 fall through 
 fall through 
	
	  Enable FPASIMD to avoid trapping when accessing Q0-Q15
	  registers, which the variable argument list macros do.
 TG0 = 64KB 
 IPS = 52 bits 
 TG0 = 4KB 
 IPS = 48 bits 
 TG0 = 64KB 
 IPS = 48 bits 
 TG0 = 4KB 
 IPS = 40 bits 
 TG0 = 64KB 
 IPS = 40 bits 
 M | C | I ;
 TCR_EL1 |= IRGN0:WBWA | ORGN0:WBWA | SH0:Inner-Shareable ;
 T0SZ ;
 valid_ec  {
 SPDX-License-Identifier: GPL-2.0
  ARM Generic Interrupt Controller (GIC) v3 host support
  vGIC-v3 default host setup
  Input args:
 	vm - KVM VM
 	nr_vcpus - Number of vCPUs supported by this VM
 	gicd_base_gpa - Guest Physical Address of the Distributor region
 	gicr_base_gpa - Guest Physical Address of the Redistributor region
  Output args: None
  Return: GIC file-descriptor or negative error code upon failure
  The function creates a vGIC-v3 device and maps the distributor and
  redistributor regions of the guest. Since it depends on the number of
  vCPUs for the VM, it must be called after all the vCPUs have been created.
	
	  Make sure that the caller is infact calling this
	  function after all the vCPUs are added.
 Distributor setup 
 Redistributor setup 
 SPDX-License-Identifier: GPL-2.0
  ARM Generic Interrupt Controller (GIC) support
 Distributor initialization is needed only once per VM 
 Make sure that the initialized data is visible to all the vCPUs 
 SPDX-License-Identifier: GPL-2.0
  ucall support. A ucall is a "hypercall to userspace".
  Copyright (C) 2018, Red Hat, Inc.
 SPDX-License-Identifier: GPL-2.0-only
  toolstestingselftestskvmlibx86_64processor.c
  Copyright (C) 2021, Google LLC.
 Per SDM: to enable xAPIC when in x2APIC must first disable APIC 
	
	  Per SDM: reset value of spurious interrupt vector register has the
	  APIC software enabled bit=0. It must be enabled in addition to the
	  enable bit in the MSR.
 SPDX-License-Identifier: GPL-2.0-only
  toolstestingselftestskvmlibx86_64svm.c
  Helpers used for nested SVM testing
  Largely inspired from KVM unit test svm.c
  Copyright (C) 2020, Red Hat, Inc.
 Allocate memory regions for nested SVM tests.
  Input Args:
    vm - The VM to allocate guest-virtual addresses in.
  Output Args:
    p_svm_gva - The guest virtual address for the struct svm_test_data.
  Return:
    Pointer to structure with the addresses of the SVM areas.
  Avoid using memset to clear the vmcb, since libc may not be
  available in L1 (and, even if it is, features that libc memset may
  want to use, like AVX, may not be enabled).
  saverestore 64-bit general registers except rax, rip, rsp
  which are directly handed through the VMCB guest processor state
  selftests do not use interrupts so we dropped clgisticlistgi
  for now. registers involved in LOADSAVE_GPR_C are eventually
  unmodified so they do not need to be in the clobber list.
 rflags
 rax
 rflags
 rax
  Open SEV_DEV_PATH if available, otherwise exit the entire program.
  Return:
    The opened file descriptor of devsev.
 SPDX-License-Identifier: GPL-2.0-only
  toolstestingselftestskvmlibx86_64processor.c
  Copyright (C) 2018, Google LLC.
 Virtual translation table structure declarations 
  Segment Dump
  Input Args:
    stream  - Output FILE stream
    segment - KVM segment
    indent  - Left margin indent amount
  Output Args: None
  Return: None
  Dumps the state of the KVM segment given by @segment, to the FILE stream
  given by @stream.
  dtable Dump
  Input Args:
    stream - Output FILE stream
    dtable - KVM dtable
    indent - Left margin indent amount
  Output Args: None
  Return: None
  Dumps the state of the KVM dtable given by @dtable, to the FILE stream
  given by @stream.
 If needed, create page map l4 table. 
		
		  Entry already present.  Assert that the caller doesn't want
		  a hugepage at this level, and that there isn't a hugepage at
		  this level.
	
	  Allocate upper level page tables, if not already present.  Return
	  early if a hugepage was created.
 Fill in page table entry. 
 Set the bottom 52 bits. 
 Clear the bottom bits of the reserved mask. 
	
	  SDM vol 3, fig 4-11 "Formats of CR3 and Paging-Structure Entries
	  with 4-Level Paging and 5-Level Paging".
	  If IA32_EFER.NXE = 0 and the P flag of a paging-structure entry is 1,
	  the XD flag (bit 63) is reserved.
	
	  Based on the mode check above there are 48 bits in the vaddr, so
	  shift 16 to sign extend the last bit (bit-47),
  Set Unusable Segment
  Input Args: None
  Output Args:
    segp - Pointer to segment register
  Return: None
  Sets the segment register pointed to by @segp to an unusable state.
  Set Long Mode Flat Kernel Code Segment
  Input Args:
    vm - VM whose GDT is being filled, or NULL to only write segp
    selector - selector value
  Output Args:
    segp - Pointer to KVM segment
  Return: None
  Sets up the KVM segment pointed to by @segp, to be a code segment
  with the selector value given by @selector.
 kTypeCodeData 
	segp->type = 0x08 | 0x01 | 0x02;  kFlagCode | kFlagCodeAccessed
					   | kFlagCodeReadable
  Set Long Mode Flat Kernel Data Segment
  Input Args:
    vm - VM whose GDT is being filled, or NULL to only write segp
    selector - selector value
  Output Args:
    segp - Pointer to KVM segment
  Return: None
  Sets up the KVM segment pointed to by @segp, to be a data segment
  with the selector value given by @selector.
 kTypeCodeData 
	segp->type = 0x00 | 0x01 | 0x02;  kFlagData | kFlagDataAccessed
					   | kFlagDataWritable
 Set mode specific system register values. 
 Create VCPU 
 Setup guest general purpose registers 
 Setup the MP state 
  Allocate an instance of struct kvm_cpuid2
  Input Args: None
  Output Args: None
  Return: A pointer to the allocated struct. The caller is responsible
  for freeing this struct.
  Since kvm_cpuid2 uses a 0-length array to allow a the size of the
  array to be decided at allocation time, allocation is slightly
  complicated. This function uses a reasonable default length for
  the array and performs the appropriate allocation.
  KVM Supported CPUID Get
  Input Args: None
  Output Args:
  Return: The supported KVM CPUID
  Get the guest CPUID supported by KVM.
  KVM Get MSR
  Input Args:
    msr_index - Index of MSR
  Output Args: None
  Return: On success, value of the MSR. On failure a TEST_ASSERT is produced.
  Get value of MSR for VCPU.
  VM VCPU CPUID Set
  Input Args:
    vm - Virtual Machine
    vcpuid - VCPU id
  Output Args: None
  Return: KVM CPUID (KVM_GET_CPUID2)
  Set the VCPU's CPUID.
  Locate a cpuid entry.
  Input Args:
    function: The function of the cpuid entry to find.
    index: The index of the cpuid entry.
  Output Args: None
  Return: A pointer to the cpuid entry. Never returns NULL.
  VM VCPU CPUID Set
  Input Args:
    vm - Virtual Machine
    vcpuid - VCPU id
    cpuid - The CPUID values to set.
  Output Args: None
  Return: void
  Set the VCPU's CPUID.
  VCPU Get MSR
  Input Args:
    vm - Virtual Machine
    vcpuid - VCPU ID
    msr_index - Index of MSR
  Output Args: None
  Return: On success, value of the MSR. On failure a TEST_ASSERT is produced.
  Get value of MSR for VCPU.
  _VCPU Set MSR
  Input Args:
    vm - Virtual Machine
    vcpuid - VCPU ID
    msr_index - Index of MSR
    msr_value - New value of MSR
  Output Args: None
  Return: The result of KVM_SET_MSRS.
  Sets the value of an MSR for the given VCPU.
  VCPU Set MSR
  Input Args:
    vm - Virtual Machine
    vcpuid - VCPU ID
    msr_index - Index of MSR
    msr_value - New value of MSR
  Output Args: None
  Return: On success, nothing. On failure a TEST_ASSERT is produced.
  Set value of MSR for VCPU.
	
	  When KVM exits to userspace with KVM_EXIT_IO, KVM guarantees
	  guest state is consistent only after userspace re-enters the
	  kernel with KVM_RUN.  Complete IO prior to migrating state
	  to a new VM.
 output  "=a"(eax), "=b"(ebx),
 input  "0"(leaf), "2"(0));
 SDM 4.1.4 
 Handlers have the same address in both address spaces.
 Need to skip KVM CPUID leaves 0x400000xx 
 SPDX-License-Identifier: GPL-2.0-only
  toolstestingselftestskvmlibx86_64vmx.c
  Copyright (C) 2018, Google LLC.
 KVM should return supported EVMCS version range 
 Allocate memory regions for nested VMX tests.
  Input Args:
    vm - The VM to allocate guest-virtual addresses in.
  Output Args:
    p_vmx_gva - The guest virtual address for the struct vmx_pages.
  Return:
    Pointer to structure with the addresses of the VMX areas.
 Setup of a region of guest memory for the vmxon region. 
 Setup of a region of guest memory for a vmcs. 
 Setup of a region of guest memory for the MSR bitmap. 
 Setup of a region of guest memory for the shadow VMCS. 
 Setup of a region of guest memory for the VMREAD and VMWRITE bitmaps. 
 Setup of a region of guest memory for the VP Assist page. 
 Setup of a region of guest memory for the enlightened VMCS. 
	
	  Ensure bits in CR0 and CR4 are valid in VMX operation:
	  - Bit X is 1 in _FIXED0: bit X is fixed to 1 in CRx.
	  - Bit X is 0 in _FIXED1: bit X is fixed to 0 in CRx.
 Enable VMX operation 
	
	  Configure IA32_FEATURE_CONTROL MSR to allow VMXON:
	   Bit 0: Lock bit. If clear, VMXON causes a #GP.
	   Bit 2: Enables VMXON outside of SMX operation. If clear, VMXON
	     outside of SMX causes a #GP.
 Enter VMX root operation. 
 Load a VMCS. 
 Setup shadow VMCS, do not load it yet. 
  Initialize the control fields to the most basic settings possible.
 + 1 
 Never match 
 64-bit host 
 64-bit guest 
  Initialize the host state fields based on the current host state, with
  the exception of HOST_RSP and HOST_RIP, which should be set by vmlaunch
  or vmresume.
  Initialize the guest state fields essentially as a clone of
  the host state fields. Some host state fields have fixed
  values, and we set the corresponding guest state fields accordingly.
 Allocate page directory pointer table if not present. 
 Allocate page directory table if not present. 
 Allocate page table if not present. 
 Fill in page table entry. 
	
	  For now mark these as accessed and dirty because the only
	  testcase we have needs that.  Can be reconsidered later.
  Map a range of EPT guest physical addresses to the VM's physical address
  Input Args:
    vm - Virtual Machine
    nested_paddr - Nested guest physical address to map
    paddr - VM Physical Address
    size - The size of the range to map
    eptp_memslot - Memory region slot for new virtual translation tables
  Output Args: None
  Return: None
  Within the VM given by vm, creates a nested guest translation for the
  page range starting at nested_paddr to the page range starting at paddr.
 Prepare an identity extended page table that maps all the
  physical pages in VM.
 SPDX-License-Identifier: GPL-2.0
  ucall support. A ucall is a "hypercall to userspace".
  Copyright (C) 2019 Red Hat, Inc.
 Exit via DIAGNOSE 0x501 (normally used for breakpoints) 
 0x83 means DIAGNOSE 
 SPDX-License-Identifier: GPL-2.0-or-later
  Test handler for the s390x DIAGNOSE 0x0318 instruction.
  Copyright (C) 2020, IBM
  The DIAGNOSE 0x0318 instruction call must be handled via userspace. As such,
  we create an ad-hoc VM here to handle the instruction then extract the
  necessary data. It is up to the caller to decide what to do with that data.
	
	  If KVM does not support diag318, then return 0 to
	  ensure tests do not break.
	
	  If a test has previously requested the diag318 info,
	  then don't bother spinning up a temporary VM again.
 SPDX-License-Identifier: GPL-2.0-only
  KVM selftest s390x library code - CPU-related functions (page tables...)
  Copyright (C) 2019, Red Hat, Inc.
  Allocate 4 pages for a regionsegment table (ri < 4), or one page for
  a page table (ri == 4). Returns a suitable regionsegment table entry
  which points to the freshly allocated pages.
 Walk through region and segment tables 
 Fill in page table entry 
 page index 
 page index 
 Setup guest registers 
 Enable floating point regs 
 Primary region table 
 DAT enabled + 64 bit mode 
 SPDX-License-Identifier: GPL-2.0-only
  vmx_apic_access_test
  Copyright (C) 2020, Google LLC.
  This work is licensed under the terms of the GNU GPL, version 2.
  The first subtest simply checks to see that an L2 guest can be
  launched with a valid APIC-access address that is backed by a
  page of L1 physical memory.
  The second subtest sets the APIC-access address to a (valid) L1
  physical address that is not backed by memory. KVM can't handle
  this situation, so resuming L2 should result in a KVM exit for
  internal error (emulation). This is not an architectural
  requirement. It is just a shortcoming of KVM. The internal error
  is unfortunate, but it's better than what used to happen!
 The virtual machine object. 
 Exit to L1 
 Prepare the VMCS for L2 execution. 
 Try to launch L2 with the memory-backed APIC-access address. 
 Try to resume L2 with the unbacked APIC-access address. 
 NOT REACHED 
 SPDX-License-Identifier: GPL-2.0-only
  svm_vmcall_test
  Copyright (C) 2020, Red Hat, Inc.
  Nested SVM testing: VMCALL
 Prepare for L2 execution. 
 NOT REACHED 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018, Red Hat, Inc.
  Tests for SMM.
 for program_invocation_short_name 
  This is compiled as normal 64-bit code, however, SMI handler is executed
  in real-address mode. To stay simple we're limiting ourselves to a mode
  independent subset of asm here.
  SMI handler always report back fixed stage SMRAM_STAGE.
 mov $SMRAM_STAGE, %al 
 in $SYNC_PORT, %al 
 rsm 
 Stages 8-11 are eaten by SMM (SMRAM_STAGE reported instead) 
 Create VM 
		
		  Enter SMM during L2 execution and check that we correctly
		  return from it. Do not perform saverestore while in SMM yet.
		
		  Perform saverestore while the guest is in SMM triggered
		  during L2 execution.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2021, Google LLC.
  Tests for adjusting the KVM clock from userspace
 SPDX-License-Identifier: GPL-2.0-only
  vmx_nested_tsc_scaling_test
  Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  This test case verifies that nested TSC scaling behaves as expected when
  both L1 and L2 are scaled using different ratios. For this test we scale
  L1 down and scale L2 up.
 L2 is scaled up (from L1's perspective) by this factor 
  This function checks whether the "actual" TSC frequency of a guest matches
  its expected frequency. In order to account for delays in taking the TSC
  measurements, a difference of 1% between the actual and the expected value
  is tolerated.
	
	  Reading the TSC twice with about a second's difference should give
	  us an approximation of the TSC frequency from the guest's
	  perspective. Now, this won't be completely accurate, but it should
	  be good enough for the purposes of this test.
 exit to L1 
 check that L1's frequency looks alright before launching L2 
 prepare the VMCS for L2 execution 
 enable TSC offsetting and TSC scaling for L2 
 launch L2 
 check that L1's frequency still looks good 
	
	  We set L1's scale factor to be a random number from 2 to 10.
	  Ideally we would do the same for L2's factor but that one is
	  referenced by both main() and l1_guest_code() and using a global
	  variable does not work.
 scale down L1's TSC frequency 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2021, Red Hat Inc.
  Generic tests for KVM CPUID setget ioctls
 CPUIDs known to differ 
	
	  These entries depend on the vCPU's XCR0 register and IA32_XSS MSR,
	  which are not controlled for by this test.
 SPDX-License-Identifier: GPL-2.0-only
  xen_vmcall_test
  Copyright  2020 Amazon.com, Inc. or its affiliates.
  Userspace hypercall testing
 First a direct invocation of 'vmcall' 
 Fill in the Xen hypercall page 
 Set Hyper-V Guest OS ID 
 Hyper-V hypercall page 
 Invoke a Xen hypercall 
 Invoke a Hyper-V hypercall 
 code 
 ingpa (badly aligned) 
 Map a region for the hypercall pages 
 NOT REACHED 
 SPDX-License-Identifier: GPL-2.0-only
  KVM_SET_SREGS tests
  Copyright (C) 2018, Google LLC.
  This is a regression test for the bug fixed by the following commit:
  d3802286fa0f ("kvm: x86: Disallow illegal IA32_APIC_BASE MSR values")
  That bug allowed a user-mode program that called the KVM_SET_SREGS
  ioctl to put a VCPU's local APIC into an invalid state.
 for program_invocation_short_name 
 Skip the sub-test, the feature is supported. 
 Sanity check that KVM didn't change anything. 
 Tell stdout not to buffer its content 
	
	  Create a dummy VM, specifically to avoid doing KVM_SET_CPUID2, and
	  use it to verify all supported CR4 bits can be set prior to defining
	  the vCPU model, i.e. without doing KVM_SET_CPUID2.
 Verify all unsupported features are rejected by KVM. 
 Create a "real" VM and verify APIC_BASE can be set. 
 SPDX-License-Identifier: GPL-2.0
  KVM guest debug register tests
  Copyright (C) 2020, Red Hat, Inc.
 For testing data access debug BP 
 Create a pending interrupt on current vCPU 
	
	  Software BP tests.
	 
	  NOTE: sw_bp need to be before the cmd here, because int3 is an
	  exception rather than a normal trap for KVM_SET_GUEST_DEBUG (we
	  capture it using the vcpu exception bitmap).
 Hardware instruction BP test 
 Hardware data BP test 
	
	  Single step test, covers 2 basic instructions and 2 emulated
	 
	  Enable interrupts during the single stepping to see that
	  pending interrupt we raised is not handled due to KVM_GUESTDBG_BLOCKIRQ
 DR6.BD test 
 Instruction lengths starting at ss_start 
 sti
 xor 
 cpuid 
 mov 
 rdmsr 
 cli 
 Test software BPs - int3 
 Test instruction HW BP over DR[0-3] 
 Skip "nop" 
 Test data access HW BP over DR[0-3] 
 Rollback the 4-bytes "mov" 
 Skip the 4-bytes "mov" 
 Test single step 
 Finally test global disable 
 Disable all debug controls, run to the end 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2020, Google LLC.
  Tests for KVM paravirtual feature disablement
  KVM paravirtual msrs to test. Expect a #GP if any of these msrs are read or
  written, as the KVM_CPUID_FEATURES leaf is cleared.
  KVM hypercalls to test. Expect -KVM_ENOSYS when called, as the corresponding
  features have been cleared in KVM_CPUID_FEATURES.
 SPDX-License-Identifier: GPL-2.0-only
 Initial migration from the src to the first dst. 
 Migrate the guest back to the original VM. 
 es=  false);
 es=  false);
 es=  true);
 es=  false);
 es=  true);
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2021, Red Hat, Inc.
  Tests for Hyper-V clocksources
 Simplified mul_u64_u64_shr() 
 First, check MSR-based clocksource 
 HV_X64_MSR_TIME_REF_COUNT is in 100ns 
 1% tolerance 
 Compare TSC page clocksource with HV_X64_MSR_TIME_REF_COUNT 
 10 ms tolerance 
 Set Guest OS id to enable Hyper-V emulation 
 Set up TSC page is disabled state, check that it's clean 
 Set up TSC page is enabled state 
 Call KVM_SET_CLOCK from userspace, check that TSC page was updated 
 Sanity check TSC page timestamp, it should be close to 0 
	
	  Enable Re-enlightenment and check that TSC page stays constant across
	  KVM_SET_CLOCK.
	
	  Disable re-enlightenment and TSC page, check that KVM doesn't update
	  it anymore.
 First, check MSR-based clocksource 
 HV_X64_MSR_TIME_REF_COUNT is in 100ns 
 1% tolerance 
 NOT REACHED 
 Keep in sync with guest_main() 
 Reset kvmclock triggering TSC page update 
 SPDX-License-Identifier: GPL-2.0
  Tests for MSR_IA32_TSC and MSR_IA32_TSC_ADJUST.
  Copyright (C) 2020, Red Hat, Inc.
 Guest: writes to MSR_IA32_TSC affect both MSRs.  
 Guest: writes to MSR_IA32_TSC_ADJUST affect both MSRs.  
 Host: setting the TSC offset.  
	
	  Guest: writes to MSR_IA32_TSC_ADJUST do not destroy the
	  host-side offset and affect both MSRs.
	
	  Guest: writes to MSR_IA32_TSC affect both MSRs, so the host-side
	  offset is now visible in MSR_IA32_TSC_ADJUST.
 Guest: writes to MSR_IA32_TSC affect both MSRs.  
 Guest: writes to MSR_IA32_TSC_ADJUST affect both MSRs.  
	
	  Host: writes to MSR_IA32_TSC set the host-side offset
	  and therefore do not change MSR_IA32_TSC_ADJUST.
 Host: writes to MSR_IA32_TSC_ADJUST do not modify the TSC.  
 Restore previous value.  
	
	  Guest: writes to MSR_IA32_TSC_ADJUST do not destroy the
	  host-side offset and affect both MSRs.
	
	  Guest: writes to MSR_IA32_TSC affect both MSRs, so the host-side
	  offset is now visible in MSR_IA32_TSC_ADJUST.
 SPDX-License-Identifier: GPL-2.0
  Test for x86 KVM_CAP_MSR_PLATFORM_INFO
  Copyright (C) 2018, Google LLC.
  This work is licensed under the terms of the GNU GPL, version 2.
  Verifies expected behavior of controlling guest access to
  MSR_PLATFORM_INFO.
 for program_invocation_short_name 
 Tell stdout not to buffer its content 
 SPDX-License-Identifier: GPL-2.0-only
  svm_vmcall_test
  Copyright  2021 Amazon.com, Inc. or its affiliates.
  Xen shared_info  pvclock testing
 32 bytes 
 sizeof(vcpu_info_t) == 64 
 64 bytes (x86) 
 Trigger an interrupt injection 
 Test having the host set runstates manually 
 Test runstate time adjust 
 Test runstate time set 
 sched_yield() should result in some 'runnable' time 
 Map a region for the shared_info page 
 NOT REACHED 
 Yield until scheduler delay exceeds target 
	
	  Just a really basic check that things are being put in the
	  right place. The actual calculations are much the same for
	  Xen as they are for the KVM variants, so no need to check.
		
		  Fetch runstate and check sanity. Strictly speaking in the
		  general case we might not expect the numbers to be identical
		  but in this case we know we aren't running the vCPU any more.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018, Red Hat, Inc.
  Tests for Enlightened VMCS, including nested guest state.
 for program_invocation_short_name 
 VMLAUNCH 
 Forced exit to L1 upon restore 
 Done, exit to L1 and never come back.  
	
	  NMI forces L2->L1 exit, resuming L2 and hope that EVMCS is
	  up-to-date (RIP points where it should and not at the beginning
	  of l2_guest_code(). GUEST_SYNC(9) checkes that.
 Try enlightened vmptrld with an incorrect GPA 
 Restore state in a new VM.  
 Create VM 
 NOT REACHED 
 UCALL_SYNC is handled here.  
 Force immediate L2->L1 exit before resuming 
		
		  Do KVM_GET_NESTED_STATEKVM_SET_NESTED_STATE for a freshly
		  restored VM (before the first KVM_RUN) to check that
		  KVM_STATE_NESTED_EVMCS is not lost.
 SPDX-License-Identifier: GPL-2.0-only
  Test for x86 KVM_CAP_SYNC_REGS
  Copyright (C) 2018, Google LLC.
  Verifies expected behavior of x86 KVM_CAP_SYNC_REGS functionality,
  including requesting an invalid register set, updates tofrom values
  in kvm_run.s.regs when kvm_valid_regs and kvm_dirty_regs are toggled.
 for program_invocation_short_name 
  ucall is embedded here to protect against compiler reshuffling registers
  before calling a function. In this test we only need to get KVM_EXIT_IO
  vmexit and preserve RBX, no additional information is needed.
 Tell stdout not to buffer its content 
 Create VM 
 Request reading invalid register set from VCPU. 
 Request setting invalid register set into VCPU. 
 Request and verify all valid register sets. 
 TODO: BUILD TIME CHECK: TEST_ASSERT(KVM_SYNC_X86_NUM_FIELDS != 3); 
 Set and verify various register values. 
 TODO run->s.regs.events.XYZ = ABC; 
	 Clear kvm_dirty_regs bits, verify new s.regs values are
	  overwritten with existing guest values.
	 Clear kvm_valid_regs bits and kvm_dirty_bits.
	  Verify s.regs values are not overwritten with existing guest values
	  and that guest values are not overwritten with kvm_sync_regs values.
	 Clear kvm_valid_regs bits. Verify s.regs values are not overwritten
	  with existing guest values but that guest values are overwritten
	  with kvm_sync_regs values.
 SPDX-License-Identifier: GPL-2.0
  Test that KVM_SET_BOOT_CPU_ID works as intended
  Copyright (C) 2020, Red Hat, Inc.
 for program_invocation_name 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019, Google LLC.
  Tests for the IA32_XSS MSR.
 for program_invocation_short_name 
 Create VM 
	
	  At present, KVM only supports a guest IA32_XSS value of 0. Verify
	  that trying to set the guest IA32_XSS to an unsupported value fails.
	  Also, in the future when a non-zero value succeeds check that
	  IA32_XSS is in the KVM_GET_MSR_INDEX_LIST.
 SPDX-License-Identifier: GPL-2.0
  xapic_ipi_test
  Copyright (C) 2020, Google LLC.
  This work is licensed under the terms of the GNU GPL, version 2.
  Test that when the APIC is in xAPIC mode, a vCPU can send an IPI to wake
  another vCPU that is halted when KVM's backing page for the APIC access
  address has been moved by mm.
  The test starts two vCPUs: one that sends IPIs and one that continually
  executes HLT. The sender checks that the halter has woken from the HLT and
  has reentered HLT before sending the next IPI. While the vCPUs are running,
  the host continually calls migrate_pages to move all of the process' pages
  amongst the available numa nodes on the machine.
  Migration is a command line option. When used on non-numa machines will 
  exit with error. Test is still usefull on non-numa for testing IPIs.
 for program_invocation_short_name 
 Default running time for the test 
 Default delay between migrate_pages calls (microseconds) 
  Vector for IPI from sender vCPU to halting vCPU.
  Value is arbitrary and was chosen for the alternating bit pattern. Any
  value should work.
  Incremented in the IPI handler. Provides evidence to the sender that the IPI
  arrived at the destination
 Data struct shared between host main thread and vCPUs 
	
	   Record local version register as a cross-check that APIC access
	   worked. Value should match what KVM reports (APIC_VERSION in
	   archx86kvmlapic.c). If test is failing, check that values match
	   to determine whether APIC access exits are working.
 host address of ipis_rcvd global 
	
	  Loop forever HLTing and recording halts & wakes. Disable interrupts
	  each time around to minimize window between signaling the pending
	  halt to the sender vCPU and executing the halt. No need to disable on
	  first run as this vCPU executes first and the host waits for it to
	  signal going into first halt before starting the sender vCPU. Record
	  TPR and PPR for diagnostic purposes in case the test fails.
  Runs on halter vCPU when IPI arrives. Write an arbitrary non-zero value to
  enable diagnosing errant writes to the APIC access address backing page in
  case of test failure.
	
	  Init interrupt command register for sending IPIs
	 
	  Delivery mode=fixed, per SDM:
	    "Delivers the interrupt specified in the vector field to the target
	     processor."
	 
	  Destination mode=physical i.e. specify target by its local APIC
	  ID. This vCPU assumes that the halter vCPU has already started and
	  set data->halter_apic_id.
		
		  Send IPI to halter vCPU.
		  First IPI can be sent unconditionally because halter vCPU
		  starts earlier.
		
		  Wait up to ~1 sec for halter to indicate that it has:
		  1. Received the IPI
		  2. Woken up from the halt
		  3. Gone back into halt
		  Current CPUs typically run at 2.x Ghz which is ~2
		  billion ticks per second.
 Get set of first 64 numa nodes available 
	 Init array of masks containing a single-bit in each, one for each
	  available node. migrate_pages called below requires specifying nodes
	  as bit masks.
		
		  migrate_pages with PID=0 will migrate all pages of this
		  process between the nodes specified as bitmasks. The page
		  backing the APIC access address belongs to this process
		  because it is allocated by KVM in the context of the
		  KVM_CREATE_VCPU ioctl. If that assumption ever changes this
		  test may break or give a false positive signal.
 Start halter vCPU thread and wait for it to execute first HLT. 
	
	  Cancel threads and wait for them to stop.
 SPDX-License-Identifier: GPL-2.0-only
  KVM_GETSET_ tests
  Copyright (C) 2018, Red Hat, Inc.
  Tests for vCPU state saverestore, including nested guest state.
 for program_invocation_short_name 
 Exit to L1 
 Done, exit to L1 and never come back.  
 Prepare for L2 execution. 
 Exit to L1 
 L1 has now set up a shadow VMCS for us.  
 Done, exit to L1 and never come back.  
 Check that the launched state is preserved.  
 Create VM 
 NOT REACHED 
 UCALL_SYNC is handled here.  
 Restore state in a new VM.  
 SPDX-License-Identifier: GPL-2.0
  VMX-pmu related msrs test
  Copyright (C) 2021 Intel Corporation
  Test to check the effect of various CPUID settings
  on the MSR_IA32_PERF_CAPABILITIES MSR, and check that
  whatever we write with KVM_SET_MSR is _not_ modified
  in the guest and test it can be retrieved with KVM_GET_MSR.
  Test to check that invalid LBR formats are rejected.
 for program_invocation_short_name 
 Create VM 
 testcase 1, set capabilities when we have PDCM bit 
 check capabilities can be retrieved with KVM_GET_MSR 
 check whatever we write with KVM_SET_MSR is _not_ modified 
 testcase 2, check valid LBR formats are accepted 
 testcase 3, check invalid LBR format is rejected 
 testcase 4, set capabilities when we don't have PDCM bit 
 testcase 5, set capabilities when we don't have PMU version bits 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2021, Red Hat, Inc.
  Tests for Hyper-V features enablement
			
			  Only available when Hyper-V identification is set
			
			  HV_X64_MSR_GUEST_OS_ID has to be written first to make
			  HV_X64_MSR_HYPERCALL available.
 Read only 
 Read only 
 Read only 
			
			  Remains unavailable even with KVM_CAP_HYPERV_SYNIC2
			  capability enabled and guest visible CPUID bit unset.
 Direct mode test 
 Read only 
 Can only write '0' 
 END 
 Nothing in 'sparse banks' -> success 
 XMM fast hypercall 
 END 
 Test MSRs 
 Test hypercalls 
 Hypercall inputoutput 
 SPDX-License-Identifier: GPL-2.0-only
  vmx_set_nested_state_test
  Copyright (C) 2019, Google LLC.
  This test verifies the integrity of calling the ioctl KVM_SET_NESTED_STATE.
  Mirror of VMCS12_REVISION in archx86kvmvmxvmcs12.h. If that value
  changes this should be updated.
 Set revision_id in vmcs12 to vmcs12_revision. 
 Add a page for VMCS12. 
 The format must be set to 0. 0 for VMX, 1 for SVM. 
	
	  We cannot virtualize anything if the guest does not have VMX
	  enabled.
	
	  We cannot virtualize anything if the guest does not have VMX
	  enabled.  We expect KVM_SET_NESTED_STATE to return 0 if vmxon_pa
	  is set to -1ull, but the flags must be zero.
 Enable VMX in the guest CPUID. 
	
	  Setting vmxon_pa == -1ull and vmcs_pa == -1ull exits early without
	  setting the nested state but flags other than eVMCS must be clear.
	  The eVMCS flag can be set if the enlightened VMCS capability has
	  been enabled.
 It is invalid to have vmxon_pa == -1ull and SMM flags non-zero. 
 Invalid flags are rejected. 
 It is invalid to have vmxon_pa == -1ull and vmcs_pa != -1ull. 
 It is invalid to have vmxon_pa set to a non-page aligned address. 
	
	  It is invalid to have KVM_STATE_NESTED_SMM_GUEST_MODE and
	  KVM_STATE_NESTED_GUEST_MODE set together.
	
	  It is invalid to have any of the SMM flags set besides:
	 	KVM_STATE_NESTED_SMM_GUEST_MODE
	 	KVM_STATE_NESTED_SMM_VMXON
 Outside SMM, SMM flags must be zero. 
	
	  Size must be large enough to fit kvm_nested_state and vmcs12
	  if VMCS12 physical address is set
	
	  KVM_SET_NESTED_STATE succeeds with invalid VMCS
	  contents but L2 not running.
 Invalid flags are rejected, even if no VMCS loaded. 
 vmxon_pa cannot be the same address as vmcs_pa. 
	
	  Test that if we leave nesting the state reflects that when we get
	  it again.
	
	  AMD currently does not implement set_nested_state, so for now we
	  just early out.
	
	  First run tests with VMX disabled to check error handling.
 Passing a NULL kvm_nested_state causes a EFAULT. 
 'size' cannot be smaller than sizeof(kvm_nested_state). 
	
	  Setting the flags 0xf fails the flags check.  The only flags that
	  can be used are:
	      KVM_STATE_NESTED_GUEST_MODE
	      KVM_STATE_NESTED_RUN_PENDING
	      KVM_STATE_NESTED_EVMCS
	
	  If KVM_STATE_NESTED_RUN_PENDING is set then
	  KVM_STATE_NESTED_GUEST_MODE has to be set as well.
 SPDX-License-Identifier: GPL-2.0
 PFEC == RSVD | PRESENT (read, kernel). 
 Create VM 
 Map 1gb page without a backing memlot. 
 Guest access to the 1gb page should trigger MMIO. 
	
	  Effect the CPUID change for the guest and re-enter the guest.  Its
	  access should now #PF due to the PAGE_SIZE bit being reserved or
	  the resulting GPA being invalid.  Note, kvm_get_supported_cpuid()
	  returns the struct that contains the entry being modified.  Eww.
	
	  Add a dummy memslot to coerce KVM into bumping the MMIO generation.
	  KVM does not "officially" support mucking with CPUID after KVM_RUN,
	  and will incorrectly reuse MMIO SPTEs.  Don't delete the memslot!
	  KVM x86 zaps all shadow pages on memslot deletion.
 Set up a #PF handler to eat the RSVD #PF and signal all done! 
	
	  Restore the happy CPUID value for the next test.  Yes, changes are
	  indeed persistent across VM destruction.
	
	  All tests are opt-in because TDP doesn't play nice with reserved #PF
	  in the GVA->GPA translation.  The hardware page walker doesn't let
	  software change GBPAGES or MAXPHYADDR, and KVM doesn't manually walk
	  the GVA on fault for performance reasons.
 SPDX-License-Identifier: GPL-2.0
  Test for x86 KVM_CAP_HYPERV_CPUID
  Copyright (C) 2018, Red Hat, Inc.
  This work is licensed under the terms of the GNU GPL, version 2.
 for program_invocation_short_name 
 0x4000000A 
		
		  If needed for debug:
		  fprintf(stdout,
		 	"CPUID%lx EAX=0x%lx EBX=0x%lx ECX=0x%lx EDX=0x%lx\n",
		 	entry->function, entry->eax, entry->ebx, entry->ecx,
		 	entry->edx);
 Tell stdout not to buffer its content 
 Test vCPU ioctl version 
 Test system ioctl version 
 SPDX-License-Identifier: GPL-2.0-only
  VMX-preemption timer test
  Copyright (C) 2020, Google, LLC.
  Test to ensure the VM-Enter after migration doesn't
  incorrectly restarts the timer with the full timer
  value instead of partially decayed timer value
 for program_invocation_short_name 
	
	  Wait until the 1st threshold has passed
	
	  Force L2 through Save and Restore cycle
	
	  Now wait for the preemption timer to fire and
	  exit to L1
	
	  Check for Preemption timer support
	
	  Turn on PIN control and resume the guest
	
	  Ensure exit from L2 happens after L2 goes through
	  save and restore
	
	  Ensure the exit from L2 is due to preemption timer expiry
	
	  Sync with the host and pass the l1|l2 pt_expiry_finish times and
	  tsc deadlines so that host can verify they are as expected
	
	  AMD currently does not implement any VMX features, so for now we
	  just early out.
 Create VM 
 NOT REACHED 
 UCALL_SYNC is handled here.  
		
		  If this stage 2 then we should verify the vmx pt expiry
		  is as expected.
		  From L1's perspective verify Preemption timer hasn't
		  expired too early.
		  From L2's perspective verify Preemption timer hasn't
		  expired too late.
 Restore state in a new VM.  
 SPDX-License-Identifier: GPL-2.0
  Test that KVM_GET_MSR_INDEX_LIST and
  KVM_GET_MSR_FEATURE_INDEX_LIST work as intended
  Copyright (C) 2020, Red Hat, Inc.
 SPDX-License-Identifier: GPL-2.0
  CR4 and CPUID sync test
  Copyright 2018, Red Hat, Inc. andor its affiliates.
  Author:
    Wei Huang <wei@redhat.com>
 turn on CR4.OSXSAVE 
 verify CR4.OSXSAVE == CPUID.OSXSAVE 
 notify hypervisor to change CR4 
 check again 
 Tell stdout not to buffer its content 
 Create VM 
 emulate hypervisor clearing CR4.OSXSAVE 
 SPDX-License-Identifier: GPL-2.0-only
  vmx_tsc_adjust_test
  Copyright (C) 2018, Google LLC.
  IA32_TSC_ADJUST test
  According to the SDM, "if an execution of WRMSR to the
  IA32_TIME_STAMP_COUNTER MSR adds (or subtracts) value X from the TSC,
  the logical processor also adds (or subtracts) value X from the
  IA32_TSC_ADJUST MSR.
  Note that when L1 doesn't intercept writes to IA32_TSC, a
  WRMSR(IA32_TSC) from L2 sets L1's TSC value, not L2's perceived TSC
  value.
  This test verifies that this unusual case is handled correctly.
 The virtual machine object. 
 Exit to L1 
 Prepare the VMCS for L2 execution. 
 Jump into L2.  First, test failure to load guest CR3.  
 Allocate VMX pages and shared descriptors (vmx_pages). 
 NOT REACHED 
  mmio_warning_test
  Copyright (C) 2019, Google LLC.
  This work is licensed under the terms of the GNU GPL, version 2.
  Test that we don't get a kernel warning when we call KVM_RUN after a
  triple fault occurs.  To get the triple fault to occur we call KVM_RUN
  on a VCPU that hasn't been properly setup.
 SPDX-License-Identifier: GPL-2.0
  KVM dirty page logging test
  Copyright (C) 2018, Red Hat, Inc.
 for program_invocation_name 
 The memory slot index to track dirty pages 
 L1 guest test virtual memory offset 
 L2 guest test virtual memory offset 
 Exit to L1 and never come back.  
 Create VM 
 Add an extra memory slot for testing dirty logging 
	
	  Add an identity map for GVA range [0xc0000000, 0xc0002000).  This
	  affects both L1 and L2.  However...
	
	  ... pages in the L2 GPA range [0xc0001000, 0xc0003000) will map to
	  0xc0000000.
	 
	  Note that prepare_eptp should be called only L1's GPA map is done,
	  meaning after the last call to virt_map.
 NOT REACHED 
			
			  The nested guest wrote at offset 0x1000 in the memslot, but the
			  dirty bitmap must be filled in according to L1 GPA, not L2.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020, Google LLC.
  Tests for exiting into userspace on registered MSRs
 for program_invocation_short_name 
 Forced emulation prefix, used to invoke the emulator unconditionally. 
 Test an MSR the kernel knows about. 
 Test an MSR the kernel doesn't know about. 
 Test a fabricated MSR that no one knows about. 
  Note: Force test_rdmsr() to not be inlined to prevent the labels,
  rdmsr_start and rdmsr_end, from being defined multiple times.
  Note: Force test_wrmsr() to not be inlined to prevent the labels,
  wrmsr_start and wrmsr_end, from being defined multiple times.
  Note: Force test_em_rdmsr() to not be inlined to prevent the labels,
  rdmsr_start and rdmsr_end, from being defined multiple times.
  Note: Force test_em_wrmsr() to not be inlined to prevent the labels,
  wrmsr_start and wrmsr_end, from being defined multiple times.
	
	  Test userspace intercepting rdmsr  wrmsr for MSR_IA32_XSS.
	 
	  A GP is thrown if anything other than 0 is written to
	  MSR_IA32_XSS.
	
	  Test userspace intercepting rdmsr  wrmsr for MSR_IA32_FLUSH_CMD.
	 
	  A GP is thrown if MSR_IA32_FLUSH_CMD is read
	  from or if a value other than 1 is written to it.
	
	  Test userspace intercepting rdmsr  wrmsr for MSR_NON_EXISTENT.
	 
	  Test that a fabricated MSR can pass through the kernel
	  and be handled in userspace.
	
	  Test to see if the instruction emulator is available (ie: the module
	  parameter 'kvm.force_emulation_prefix=1' is set).  This instruction
	  will #UD if it isn't available.
 Let userspace know we aren't done. 
		
		  Now run the same tests with the instruction emulator.
 This goes into the in-kernel emulation 
 This goes into user space emulation 
 If trapped == true, this goes into user space emulation 
 This goes into the in-kernel emulation 
 Invalid MSR, should always be handled by user space exit 
	
	  Disable msr filtering, so that the kernel
	  handles everything in the next round
 Let userspace know to switch the filter 
 Create VM 
 Process guest code userspace exits. 
 Process emulated rdmsr and wrmsr instructions. 
 Confirm the guest completed without issues. 
 ignore 
 Create VM 
 Create VM 
 Tell stdout not to buffer its content 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020, Google LLC.
  Tests for KVM_CAP_EXIT_ON_EMULATION_FAILURE capability.
 for program_invocation_short_name 
  Accessors to get RM, REG, and Mod bits described in the SDM vol 2,
  figure 2-2 "Table Interpretation of ModRM Byte (C8H)".
 Ensure we are dealing with a simple 2-byte flds instruction. 
 Ensure there is no SIB byte. 
 Ensure there is no displacement byte. 
			
			  If is_flds() succeeded then the instruction bytes
			  contained an flds instruction that is 2-bytes in
			  length (ie: no prefix, no SIB, no displacement).
 Tell stdout not to buffer its content 
 SPDX-License-Identifier: GPL-2.0-only
  svm_int_ctl_test
  Copyright (C) 2021, Red Hat, Inc.
  Nested SVM testing: test simultaneous use of V_IRQ from L1 and L0.
	 This code raises interrupt INTR_IRQ_NUMBER in the L1's LAPIC,
	  and since L1 didn't enable virtual interrupt masking,
	  L2 should receive it and not L1.
	 
	  L2 also has virtual interrupt 'VINTR_IRQ_NUMBER' pending in V_IRQ
	  so it should also receive it after the following 'sti'.
 Prepare for L2 execution. 
 No virtual interrupt masking 
 No intercepts for real and virtual interrupts 
 Make a virtual interrupt VINTR_IRQ_NUMBER pending 
 NOT REACHED 
 SPDX-License-Identifier: GPL-2.0-only
  vmx_close_while_nested
  Copyright (C) 2019, Red Hat, Inc.
  Verify that nothing bad happens if a KVM user exits with open
  file descriptors while executing a nested guest.
 The virtual machine object. 
 Exit to L0 
 Prepare the VMCS for L2 execution. 
 Allocate VMX pages and shared descriptors (vmx_pages). 
 NOT REACHED 
 SPDX-License-Identifier: GPL-2.0-or-later
  Test for s390x CPU resets
  Copyright (C) 2020, IBM
 set several CRs to "safe" value 
 enable guarded storage 
 monitor mask = 1 
 PER START 
 PER END 
 Dirty registers 
 Round toward 0 
 set fpc to !=0 
 now clobber some general purpose regs 
 now clobber a floating point reg 
 now clobber an access reg 
 We embed diag 501 here to control register content 
 no clobber list as this should not return 
	
	  irqs contains the number of retrieved interrupts. Any interrupt
	  (notably, the emergency call interrupt we have injected) should
	  be cleared by the resets, so this should be 0.
 sync regs 
 KVM_GET_SREGS 
 sync regs 
 kvm_run 
 Inject IRQ 
 Create VM 
 must clears 
 must not clears 
 must clears 
 must not clears 
 must clears 
 Tell stdout not to buffer its content 
 SPDX-License-Identifier: GPL-2.0-only
  Test for s390x KVM_CAP_SYNC_REGS
  Based on the same test for x86:
  Copyright (C) 2018, Google LLC.
  Adaptions for s390x:
  Copyright (C) 2019, Red Hat, Inc.
  Test expected behavior of the KVM_CAP_SYNC_REGS functionality.
 for program_invocation_short_name 
	
	  We embed diag 501 here instead of doing a ucall to avoid that
	  the compiler has messed with r11 at the time of the ucall.
 Tell stdout not to buffer its content 
 Create VM 
 Request reading invalid register set from VCPU. 
 Request setting invalid register set into VCPU. 
 Request and verify all valid register sets. 
 Set and verify various register values 
	 Clear kvm_dirty_regs bits, verify new s.regs values are
	  overwritten with existing guest values.
 SPDX-License-Identifier: GPL-2.0-or-later
  Test for s390x KVM_S390_MEM_OP
  Copyright (C) 2019, Red Hat, Inc.
 Tell stdout not to buffer its content 
 Create VM 
 Set the first array 
 Let the guest code copy the first array to the second 
 Get the second array 
 Check error conditions - first bad size: 
 Zero size: 
 Bad flags: 
 Bad operation: 
 Bad guest address: 
 Bad host address: 
 Bad access register: 
 Enable AR mode 
 To sync new state to SIE block 
 Disable AR mode 
 Run to sync new state 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 Not a problem if it fails.
 Wait for any grace periods. 
 SPDX-License-Identifier: GPL-2.0-or-later
    Copyright  International Business Machines  Corp., 2009
  DESCRIPTION
       1. Block a thread using FUTEX_WAIT
       2. Attempt to use FUTEX_CMP_REQUEUE_PI on the futex from 1.
       3. The kernel must detect the mismatch and return -EINVAL.
  AUTHOR
       Darren Hart <dvhart@linux.intel.com>
  HISTORY
       2009-Nov-9: Initial version by Darren Hart <dvhart@linux.intel.com>
 Allow the child to block in the kernel. 
	
	  The kernel should detect the waiter did not setup the
	  q->requeue_pi_key and return -EINVAL. If it does not,
	  it likely gave the lock to the child, which is now hung
	  in the kernel.
			
			  The kernel correctly detected the mismatched
			  requeue_pi target and aborted. Wake the child with
			  FUTEX_WAKE.
 If the kernel crashes, we shouldn't return at all. 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright Collabora Ltd., 2021
  futex cmp requeue test by Andr Almeida <andrealmeid@collabora.com>
 Testing a private futex 
 Testing an anon page shared memory 
 Testing a file backed shared memory 
 Freeing resources 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright FUJITSU LIMITED 2010
  Copyright KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
  DESCRIPTION
       Internally, Futex has two handling mode, anon and file. The private file
       mapping is special. At first it behave as file, but after write anything
       it behave as anon. This test is intent to test such case.
  AUTHOR
       KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
  HISTORY
       2010-Jan-6: Initial version by KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
 SPDX-License-Identifier: GPL-2.0-or-later
  futex_waitv() test by Andr Almeida <andrealmeid@collabora.com>
  Copyright 2021 Collabora Ltd.
 setting absolute timeout for futex2 
 Private waitv 
 Shared waitv 
 Testing a waiter without FUTEX_32 flag 
 Testing a waiter with an unaligned address 
 Testing a NULL address for waiters.uaddr 
 Testing a NULL address for waiters 
 Testing an invalid clockid 
 SPDX-License-Identifier: GPL-2.0-or-later
    Copyright  International Business Machines  Corp., 2006-2008
  DESCRIPTION
       This test exercises the futex_wait_requeue_pi() signal handling both
       before and after the requeue. The first should be restarted by the
       kernel. The latter should return EWOULDBLOCK to the waiter.
  AUTHORS
       Darren Hart <dvhart@linux.intel.com>
  HISTORY
       2008-May-5: Initial version by Darren Hart <dvhart@linux.intel.com>
		
		  signal the waiter before requeue, waiter should automatically
		  restart futex_wait_requeue_pi() in the kernel. Wait for the
		  waiter to block on f1 again.
		
		  If res is non-zero, we either requeued the waiter or hit an
		  error, break out and handle it. If it is zero, then the
		  signal may have hit before the the waiter was blocked on f1.
		  Try again.
	
	  Signal the waiter after requeue, waiter should return from
	  futex_wait_requeue_pi() with EWOULDBLOCK. Join the thread here so the
	  futex_unlock_pi() can't happen before the signal wakeup is detected
	  in the kernel.
 SPDX-License-Identifier: GPL-2.0-or-later
    Copyright  International Business Machines  Corp., 2009
  DESCRIPTION
       Block on a futex and wait for timeout.
  AUTHOR
       Darren Hart <dvhart@linux.intel.com>
  HISTORY
       2009-Nov-6: Initial version by Darren Hart <dvhart@linux.intel.com>
       2021-Apr-26: More test cases by Andr Almeida <andrealmeid@collabora.com>
 100us default timeout 
  Get a PI lock and hold it forever, so the main thread lock_pi will block
  and we can test the timeout
 Blocks forever 
  Check if the function returned the expected error
  Calculate absolute timeout and correct overflow
 initialize relative timeout 
 FUTEX_WAIT_BITSET with CLOCK_REALTIME 
 FUTEX_WAIT_BITSET with CLOCK_MONOTONIC 
 FUTEX_WAIT_REQUEUE_PI with CLOCK_REALTIME 
 FUTEX_WAIT_REQUEUE_PI with CLOCK_MONOTONIC 
	
	  FUTEX_LOCK_PI with CLOCK_REALTIME
	  Due to historical reasons, FUTEX_LOCK_PI supports only realtime
	  clock, but requires the caller to not set CLOCK_REALTIME flag.
	 
	  If you call FUTEX_LOCK_PI with a monotonic clock, it'll be
	  interpreted as a realtime clock, and (unless you mess your machine's
	  time or your time machine) the monotonic clock value is always
	  smaller than realtime and the syscall will timeout immediately.
 Test operations that don't support FUTEX_CLOCK_REALTIME 
 futex_waitv with CLOCK_MONOTONIC 
 futex_waitv with CLOCK_REALTIME 
 SPDX-License-Identifier: GPL-2.0-or-later
    Copyright  International Business Machines  Corp., 2006-2008
  DESCRIPTION
       This test excercises the futex syscall op codes needed for requeuing
       priority inheritance aware POSIX condition variables and mutexes.
  AUTHORS
       Sripathi Kodi <sripathik@in.ibm.com>
       Darren Hart <dvhart@linux.intel.com>
  HISTORY
       2008-Jan-13: Initial version by Sripathi Kodi <sripathik@in.ibm.com>
       2009-Nov-6: futex test adaptation by Darren Hart <dvhart@linux.intel.com>
 Test option defaults 
	 Each thread sleeps for a different amount of time
	  This is to avoid races, because we don't lock the
 cond_signal 
 we have to loop at least THREAD_MAX times 
 Wait for threads to finish 
 Store the first error or failure encountered in waiter_ret 
	
	  FIXME: unit_test is obsolete now that we parse options and the
	  various style of runs are done by run.sh - simplify the code and move
	  unit_test into main()
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright Collabora Ltd., 2021
  futex cmp requeue test by Andr Almeida <andrealmeid@collabora.com>
	
	  Requeue a waiter from f1 to f2, and wake f2.
	
	  Create 10 waiters at f1. At futex_requeue, wake 3 and requeue 7.
	  At futex_wake, wake INT_MAX (should be exactly 7).
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright FUJITSU LIMITED 2010
  Copyright KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
  DESCRIPTION
       Wait on uninitialized heap. It shold be zero and FUTEX_WAIT should
       return immediately. This test is intent to test zero page handling in
       futex.
  AUTHOR
       KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
  HISTORY
       2010-Jan-6: Initial version by KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
 SPDX-License-Identifier: GPL-2.0-or-later
    Copyright  International Business Machines  Corp., 2009
  DESCRIPTION
       Test if FUTEX_WAIT op returns -EWOULDBLOCK if the futex value differs
       from the expected one.
  AUTHOR
       Gowrishankar <gowrishankar.m@in.ibm.com>
  HISTORY
       2009-Nov-14: Initial version by Gowrishankar <gowrishankar.m@in.ibm.com>
 SPDX-License-Identifier: GPL-2.0 
  Check if the cgroup is frozen by looking at the cgroup.events::frozen value.
		
		  Check the cgroup.events::frozen value.
  Freeze the given cgroup.
  Attach a task to the given cgroup and wait for a cgroup frozen event.
  All transient events (e.g. populated) are ignored.
  Freeze the given cgroup and wait for the inotify signal.
  If there are no events in 10 seconds, treat this as an error.
  Then check that the cgroup is in the desired state.
  A simple process running in a sleep loop until being
  re-parented.
  A simple test for the cgroup freezer: populated the cgroup with 100
  running processes and freeze it. Then unfreeze it. Then it kills all
  processes and destroys the cgroup.
  The test creates the following hierarchy:
        A
       \ \
    B  E  I K
   \  |
  C  D F
       |
       G
       |
       H
  with a process in C, H and 3 processes in K.
  Then it tries to freeze and unfreeze the whole tree.
	
	  Wait until all child processes will enter
	  corresponding cgroups.
	
	  Freeze B.
	
	  Freeze F.
	
	  Freeze G.
	
	  Check that A and E are not frozen.
	
	  Freeze A. Check that A, B and E are frozen.
	
	  Unfreeze B, F and G
	
	  Check that C and H are still frozen.
	
	  Unfreeze A. Check that A, C and K are not frozen.
  A fork bomb emulator.
  The test runs a fork bomb in a cgroup and tries to freeze it.
  Then it kills all processes and checks that cgroup isn't populated
  anymore.
  The test creates a cgroups and freezes it. Then it creates a child cgroup
  and populates it with a task. After that it checks that the child cgroup
  is frozen and the parent cgroup remains frozen too.
  The test creates two nested cgroups, freezes the parent
  and removes the child. Then it checks that the parent cgroup
  remains frozen and it's possible to create a new child
  without unfreezing. The new child is frozen too.
  The test creates two cgroups: A and B, runs a process in A
  and performs several migrations:
  1) A (running) -> B (frozen)
  2) B (frozen) -> A (running)
  3) A (frozen) -> B (frozen)
  On each step it checks the actual state of both cgroups.
	
	  Migrate from A (running) to B (frozen)
	
	  Migrate from B (frozen) to A (running)
	
	  Migrate from A (frozen) to B (frozen)
  The test checks that ptrace works with a tracing process in a frozen cgroup.
	
	  Cgroup has to remain frozen, however the test task
	  is in traced state.
  Check if the process is stopped.
  Test that it's possible to freeze a cgroup with a stopped process.
  Test that it's possible to freeze a cgroup with a ptraced process.
	
	  cg_check_frozen(cgroup, true) will fail here,
	  because the task in in the TRACEd state.
  Test that it's possible to freeze a cgroup with a process,
  which called vfork() and is waiting for a child.
 SPDX-License-Identifier: GPL-2.0 
 Handle the case of comparing against empty string 
	
	  Example:
	  cgroup sysfscgroup cgroup2 rw,seclabel,noexec,relatime 0 0
 If cgroup.kill exists use it. 
	
	  Verify that this is a genuine test failure:
	  ENOSYS -> clone3() not available
	  E2BIG  -> CLONE_INTO_CGROUP not available
 Genuine test failure. 
	
	  We don't care whether this fails. We only care whether the initial
	  clone succeeded.
 SPDX-License-Identifier: GPL-2.0 
  This test creates two nested cgroups with and without enabling
  the memory controller.
 Create two nested cgroups with the memory controller enabled 
 Create two nested cgroups without enabling memory controller 
  This test create a memory cgroup, allocates
  some anonymous memory and some pagecache
  and check memory.current and some memory.stat values.
  Wait until processes are killed asynchronously by the OOM killer
  If we exceed a timeout, fail.
  First, this test creates the following hierarchy:
  A       memory.min = 50M,  memory.max = 200M
  AB     memory.min = 50M,  memory.current = 50M
  ABC   memory.min = 75M,  memory.current = 50M
  ABD   memory.min = 25M,  memory.current = 50M
  ABE   memory.min = 500M, memory.current = 0
  ABF   memory.min = 0,    memory.current = 50M
  Usages are pagecache, but the test keeps a running
  process in every leaf cgroup.
  Then it creates AG and creates a significant
  memory pressure in it.
  AB    memory.current ~= 50M
  ABC  memory.current ~= 33M
  ABD  memory.current ~= 17M
  ABE  memory.current ~= 0
  After that it tries to allocate more than there is
  unprotected memory in A available, and checks
  checks that memory.min protects pagecache even
  in this case.
  First, this test creates the following hierarchy:
  A       memory.low = 50M,  memory.max = 200M
  AB     memory.low = 50M,  memory.current = 50M
  ABC   memory.low = 75M,  memory.current = 50M
  ABD   memory.low = 25M,  memory.current = 50M
  ABE   memory.low = 500M, memory.current = 0
  ABF   memory.low = 0,    memory.current = 50M
  Usages are pagecache.
  Then it creates AG an creates a significant
  memory pressure in it.
  Then it checks actual memory usages and expects that:
  AB    memory.current ~= 50M
  AB   memory.current ~= 33M
  ABD  memory.current ~= 17M
  ABE  memory.current ~= 0
  After that it tries to allocate more than there is
  unprotected memory in A available,
  and checks low and oom events in memory.events.
  This test checks that memory.high limits the amount of
  memory which can be consumed by either anonymous memory
  or pagecache.
  This test checks that memory.max limits the amount of
  memory which can be consumed by either anonymous memory
  or pagecache.
 Should be killed by OOM killer 
  This test checks that memory.swap.max limits the amount of
  anonymous memory which can be swapped out.
 Should be killed by OOM killer 
  This test disables swapping and tries to allocate anonymous memory
  up to OOM. Then it checks for oom and oom_kill events in
  memory.events.
 nice round number 
  This test checks socket memory accounting.
  The test forks a TCP server listens on a random port between 1000
  and 61000. Once it gets a client connection, it starts writing to
  its socket.
  The TCP client interleaves reads from the socket with check whether
  memory.current and memory.stat.sock are similar.
  This test disables swapping and tries to allocate anonymous memory
  up to OOM with memory.group.oom set. Then it checks that all
  processes in the leaf (but not the parent) were killed.
  This test disables swapping and tries to allocate anonymous memory
  up to OOM with memory.group.oom set. Then it checks that all
  processes in the parent and leaf were killed.
  This test disables swapping and tries to allocate anonymous memory
  up to OOM with memory.group.oom set. Then it checks that all
  processes were killed except those set with OOM_SCORE_ADJ_MIN
	
	  Check that memory controller is available:
	  memory is listed in cgroup.controllers
 SPDX-License-Identifier: GPL-2.0 
  Kill the given cgroup and wait for the inotify signal.
  If there are no events in 10 seconds, treat this as an error.
  Then check that the cgroup is in the desired state.
  A simple process running in a sleep loop until being
  re-parented.
  The test creates the following hierarchy:
        A
       \ \
    B  E  I K
   \  |
  C  D F
       |
       G
       |
       H
  with a process in C, H and 3 processes in K.
  Then it tries to kill the whole tree.
	
	  Wait until all child processes will enter
	  corresponding cgroups.
	
	  Kill A and check that we get an empty notification.
  The test runs a fork bomb in a cgroup and tries to kill it.
 SPDX-License-Identifier: GPL-2.0 
  Create a child process that allocates and touches 100MB, then waits to be
  killed. Wait until the child is attached to the cgroup, kill all processes
  in that cgroup and wait until "cgroup.procs" is empty. At this point try to
  destroy the empty cgroup. The test helps detect race conditions between
  dying processes leaving the cgroup and cgroup destruction path.
 wait for the child to enter cgroup 
 wait for cgroup to be empty 
  A(0) - B(0) - C(1)
         \ D(0)
  A, B and C's "populated" fields would be 1 while D's 0.
  test that after the one process in C is moved to root,
  A,B and C's "populated" fields would flip to "0" and file
  modified events will be generated on the
  "cgroup.events" files of both cgroups.
 Test that we can directly clone into a new cgroup. 
 Remove cgroup. 
  A (domain threaded) - B (threaded) - C (domain)
  test that C can't be used until it is turned into a
  threaded cgroup.  "cgroup.type" file will report "domain (invalid)" in
  these cases. Operations which fail due to invalid topology use
  EOPNOTSUPP as the errno.
  Test that when a child becomes threaded
  the parent type becomes domain threaded.
  Test that there's no internal process constrain on threaded cgroups.
  You can add threadsprocesses on a parent with a controller enabled.
  Test that you can't enable a controller on a child if it's not enabled
  on the parent.
  Test that you can't disable a controller on a parent
  if it's enabled in a child.
  Test internal process constraint.
  You can't add a pid to a domain parent if a controller is enabled.
  Test threadgroup migration.
  All threads of a process are migrated together.
  Test single thread migration.
  Threaded cgroups allow successful migration of a thread.
 SPDX-License-Identifier: GPL-2.0
  Memory cgroup charging is performed using percpu batches 32 pages
  big (look at MEMCG_CHARGE_BATCH), whereas memory.stat is exact. So
  the maximum discrepancy between charge and vmstat entries is number
  of cpus multiplied by 32 pages.
  This test allocates 100000 of negative dentries with long names.
  Then it checks that "slab" in memory.stat is larger than 1M.
  Then it sets memory.high to 1M and checks that at least 12
  of slab memory has been reclaimed.
  The test creates and destroys a large number of cgroups. In each cgroup it
  allocates some slab memory (mostly negative dentries) using 2  NR_CPUS
  threads. Then it checks the sanity of numbers on the parent level:
  the total size of the cgroups should be roughly equal to
  anon + file + slab + kernel_stack.
  The test reads the entire prockpagecgroup. If the operation went
  successfully (and the kernel didn't panic), the test is treated as passed.
  The test spawns a process, which spawns 1000 threads. Then it checks
  that memory.stat's kernel_stack is at least 1000 pages large.
  This test sequentionally creates 30 child cgroups, allocates some
  kernel memory in each of them, and deletes them. Then it checks
  that the number of dying cgroups on the parent level is 0.
		
		  Reclaiming cgroups might take some time,
		  let's wait a bit and repeat.
  This test creates a sub-tree with 1000 memory cgroups.
  Then it checks that the memory.current on the parent level
  is greater than 0 and approximates matches the percpu value
  from memory.stat.
	
	  Check that memory controller is available:
	  memory is listed in cgroup.controllers
  Copyright (c) 2019 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 Test that open(O_TMPFILE), linkat() doesn't screw accounting. 
 Our heroes: 1 root inode, 1 O_TMPFILE inode, 1 permanent inode. 
 SPDX-License-Identifier: GPL-2.0
 should fail (offset not page aligned) 
 should fail (size not multiple of page) 
 should fail (not memfd) 
 stdin 
 should work 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2011 Red Hat, Inc., Frederic Weisbecker <fweisbec@redhat.com>
  Selftests for breakpoints (and more generally the do_debug() path) in x86.
 Breakpoint access modes 
  Ensures the child and parent are always "talking" about
  the same test sequence. (ie: that we haven't forgotten
  to call check_trapped() somewhere).
 Dummy variables to test readwrite accesses 
 Dummy functions to test execution accesses 
	
	  If we haven't trapped, wake up the parent
	  so that it notices the failure.
  Do the rwx accesses to trigger the breakpoints. And run
  the usual traps.
 Wake up father so that it sets up the first test 
 Test instruction breakpoints 
 Test write watchpoints 
 Test readwrite watchpoints (on read accesses) 
 Icebp trap 
 Int 3 trap 
 Wait for the child to SIGTRAP 
 Set the breakpoints and check the child successfully trigger them 
 Instruction breakpoints 
 Write watchpoint 
 Read-Write watchpoint 
 Icebp traps 
 Int 3 traps 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2016 Google, Inc.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2016 Google, Inc.
  Original Code by Pavel Labath <labath@google.com>
  Code modified by Pratyush Anand <panand@redhat.com>
  for testing different byte select for each access size.
 Write 
 SPDX-License-Identifier: GPL-2.0
 mmap and write a simple pattern 
 Allocate and fill a bunch of buffers 
 mmap and fill with simple pattern 
 close them all 
 Allocate and validate all buffers are zeroed 
 mmap and validate everything is zero 
 close them all 
 Test the ioctl version compatibility w a smaller structure then expected 
 Test the ioctl version compatibility w a larger structure then expected 
 SPDX-License-Identifier: GPL-2.0
  Tests for prctl(PR_GET_TSC, ...)  prctl(PR_SET_TSC, ...)
  Tests if the control register is updated correctly
  when set with prctl()
  Warning: this test will cause a very high load for a few seconds
 Getset the process' ability to use the timestamp counter instruction 
 allow the use of the timestamp counter 
 throw a SIGSEGV instead of reading the TSC 
 snippet from wikipedia :-) 
 We cannot use "=A", since this would use %rax on x86_64 
 SPDX-License-Identifier: GPL-2.0
  Tests for prctl(PR_GET_TSC, ...)  prctl(PR_SET_TSC, ...)
  Tests if the control register is updated correctly
  at context switches
  Warning: this test will cause a very high load for a few seconds
 Getset the process' ability to use the timestamp counter instruction 
 allow the use of the timestamp counter 
 throw a SIGSEGV instead of reading the TSC 
 We cannot use "=A", since this would use %rax on x86_64 
 SPDX-License-Identifier: GPL-2.0
  Tests for prctl(PR_GET_TSC, ...)  prctl(PR_SET_TSC, ...)
  Basic test to test behaviour of PR_GET_TSC and PR_SET_TSC
 Getset the process' ability to use the timestamp counter instruction 
 allow the use of the timestamp counter 
 throw a SIGSEGV instead of reading the TSC 
 We cannot use "=A", since this would use %rax on x86_64 
  Strictly speaking, this is not a test. But it can report during test
  runs so relative performace can be measured.
 Equal to, or within 1% or 2 digits 
 Avoid using "sysctl" which may not be installed. 
 Native call 
 One filter resulting in a bitmap 
 Second filter resulting in a bitmap 
 Third filter, can no longer be converted to bitmap 
 Fourth filter, can not be converted to bitmap because of filter 3 
 Estimations 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012 The Chromium OS Authors. All rights reserved.
  Test code for seccomp bpf.
  glibc 2.26 and later have SIGSYS in siginfo_t. Before that,
  we need to use the kernel's siginfo.h file and trick glibc
  into accepting it.
 Attempt to de-conflict with the selftests tree. 
 kill the process 
 kill the thread 
 disallow and force a SIGSYS 
 returns an errno 
 pass to a tracer or disallow 
 allow 
 allow after logging 
 Input: which filter 
 Output: filter's flags 
 Flags for seccomp notification fd ioctl. 
 On success, the return value is the remote process's added fd number 
 valid flags for seccomp_notif_addfd 
 Specify remote fd 
 Addfd and return it, atomically 
 Have TH_LOG report actual location filecmp() is used. 
 Note! This doesn't test no new privs behavior 
 Tests kernel support by checking for a copy_from_user() fault on NULL. 
 Succeeds with CAP_SYS_ADMIN, fails without 
 TODO(wad) check caps not euid 
 Too many filter instructions in a single filter. 
 One less is okay, though. 
 Too many total filter instructions. 
 getppid() should succeed and be logged (no check for logging) 
 return code >= 0x80000000 is unused. 
 getpid() should never return. 
 Only both with lower 32-bit for now. 
 times() should never return. 
 Only both with lower 32-bit for now. 
 mmap2() should never return. 
 The test failed, so clean up the resources. 
 This is a thread task to die via seccomp filter violation. 
 Prepare a thread that will kill itself or both of us. 
 Kill only when calling __NR_prctl. 
	
	  Add the KILL_THREAD rule again to make sure that the KILL_PROCESS
	  flag cannot be downgraded by a new filter.
 Start a thread that will exit immediately. 
 Start a thread that will die immediately. 
	
	  If we get here, only the spawned thread died. Let the parent know
	  the whole process didn't die (i.e. this thread, the spawner,
	  stayed running).
 If only the thread was killed, we'll see exit 42. 
 If the entire process was killed, we'll see SIGSYS. 
 If the entire process was killed, we'll see SIGSYS. 
 TODO(wad) add 64-bit versus 32-bit arg tests. 
 Make sure basic errno values are correctly passed through a filter. 
 Make sure an errno of zero is correctly handled by the arch code. 
 "errno" of 0 is ok. 
  The SECCOMP_RET_DATA mask is 16 bits wide, but errno is smaller.
  This tests that the errno value gets capped correctly, fixed by
  580c57f10768 ("seccomp: cap SECCOMP_RET_ERRNO data to MAX_ERRNO").
  Filters are processed in reverse order: last applied is executed first.
  Since only the SECCOMP_RET_ACTION mask is tested for return values, the
  SECCOMP_RET_DATA mask results will follow the most recently applied
  matching filter return (and not the lowest or highest value).
 Ensure that SIGSYS overrides SIG_IGN 
	 Expect the registers to be rolled back. (nr = error) may vary
 Silence gcc warning about volatile. 
 calling user insn 
 triggering system call number 
 AUDIT_ARCH_ of syscall 
 Make sure arch is non-zero. 
 Should work just fine. 
 Should work just fine. 
 getpid() should never return. 
 Should work just fine. 
 getpid() should never return. 
 Should work just fine. 
 getpid() should never return. 
 Should work just fine. 
 getpid() should never return. 
 Should work just fine. 
 Should work just fine. 
 Should work just fine. 
 No ptracer 
 Should work just fine. 
 No ptracer 
 Should work just fine. 
 Should also work just fine 
 Should work just fine. 
 Should also work just fine 
 Catch the Ubuntu 12.04 value error. 
 Allow external shutdown. 
 Wait for attach stop 
 Unblock the tracee 
 Run until we're shut down. Must assert to stop execution. 
 Child is dead. Time to go. 
 Check if this is a seccomp event. 
 Directly report the status of our test harness results. 
 Common tracer setupteardown functions. 
 Setup a pipe for clean synchronization. 
 Fork a child which we'll promote to tracer 
		
		  Extract the exit code from the other process and
		  adopt it for ourselves in case its asserts failed.
 "poke" tracer arguments and function. 
 If this fails, don't try to recover. 
	
	  Poke in the message.
	  Registers are not touched to try to keep this relatively arch
	  agnostic.
 Set up tracer args. 
 Launch tracer. 
								\
			  scv 0 system call uses -ve result	\
			  for error, so no need to adjust.	\
								\
			  A syscall error is signaled by the	\
			  CR0 SO bit and the code is stored as	\
			  a positive value.			\
  On xtensa syscall return value is in the register
  a2 of the current window which is not fixed.
  Most architectures can change the syscall by just updating the
  associated register. This is the default if not defined above.
  Most architectures can change the syscall return value by just
  writing to the SYSCALL_RET register. This is the default if not
  defined above. If an architecture cannot set the return value
  (for example when the syscall and return value register is
  shared), report it with TH_LOG() in an arch-specific definition
  of SYSCALL_RET_SET() above, and leave SYSCALL_RET undefined.
 When the syscall return can't be changed, stub out the tests for it. 
  Some architectures (e.g. powerpc) can only set syscall
  return values on syscall exit during ptrace.
  Use PTRACE_GETREGS and PTRACE_SETREGS when available. This is useful for
  architectures without HAVE_ARCH_TRACEHOOK (e.g. User-mode Linux).
 Architecture-specific syscall fetching routine. 
 Architecture-specific syscall changing routine. 
 Do not getset registers if we have nothing to do. 
 Flush any register changes made. 
 Change only syscall number. 
 Change syscall return value (and set syscall number to -1). 
 Make sure we got the right message. 
 Validate and take action on expected syscalls. 
 change getpid to getppid. 
 skip gettid with valid return code. 
 skip openat with error. 
 do nothing (allow getppid) 
	
	  The traditional way to tell PTRACE_SYSCALL entryexit
	  is by counting.
 Make sure we got an appropriate message. 
	
	  Some architectures only support setting return values during
	  syscall exit under ptrace, and on exit the syscall number may
	  no longer be available. Therefore, save the initial sycall
	  number here, so it can be examined during both entry and exit
	  phases.
	
	  Depending on the architecture's syscall setting abilities, we
	  pick which things to set during this phase (entry or exit).
 Now handle the actual rewriting cases. 
 Never change syscall return for this case. 
 Unhandled, do nothing. 
	
	  All of the SECCOMP_RET_TRACE behaviors can be tested with either
	  SECCOMP_RET_TRACE+PTRACE_CONT or plain ptrace()+PTRACE_SYSCALL.
	  This indicates if we should use SECCOMP_RET_TRACE (false), or
	  ptrace (true).
 Prepare some testable syscall results. 
 Launch tracer. 
	
	  There should be no difference between an "internal" skip
	  and userspace asking for syscall "-1".
 And no difference for "still not valid but not -1". 
 getppid works as expected (no changes). 
 getpid has been redirected to getppid as expected. 
 Tracer should skip the open syscall, resulting in ESRCH. 
 Tracer skips the gettid syscall and store altered return value. 
 Install additional "errno on getppid" filter. 
 Tracer will redirect getpid to getppid, and we should see EPERM. 
 Install additional "death on getppid" filter. 
 Tracer will redirect getpid to getppid, and we should die. 
 Reject insane operation. 
 Reject strict with flags or pointer. 
 Reject insane args for filter. 
 Make sure neither entry point will switch to strict. 
  Test detection of known and unknown filter flags. Userspace needs to be able
  to check if a filter flag is supported by the current kernel and a good way
  of doing that is by attempting to enter filter mode, with the flag bit in
  question set, and a NULL pointer for the _args_ parameter. EFAULT indicates
  that the flag is valid and EINVAL indicates that the flag is invalid.
 Test detection of individual known-good filter flags 
 Make sure the flag is a single bit! 
	
	  Test detection of all known-good filter flags combined. But
	  for the exclusive flags we need to mask them out and try them
	  individually for the "all flags" testing.
 Test detection of an unknown filter flags, without exclusives. 
	
	  Test detection of an unknown filter flag that may simply need to be
	  added to this test
  To avoid joining joined threads (which is not allowed by Bionic),
  make sure we both successfully join and clear the tid to skip a
  later join attempt during fixture teardown. Any remaining threads
  will be directly killed during teardown.
		
		  If a thread is still running, it may be stuck, so hit
		  it over the head really hard.
 Just re-apply the root prog to fork the tree 
 Return outside of started so parent notices failures. 
 Check prctl failure detection by requesting sib 0 diverge. 
 Signal the threads to clean up
 Ensure diverging sibling failed to call prctl. 
 Tell the siblings to test the policy 
 Ensure they are both killed and don't exit cleanly. 
 start siblings before any prctl() operations 
 Tell the siblings to test no policy 
 Ensure they are both upset about lacking nnp. 
 start siblings before any prctl() operations 
 Tell the siblings to test the policy 
 Ensure they are both killed and don't exit cleanly. 
 Wake the threads 
 Ensure they are both unkilled. 
 Wake the threads 
 Ensure they are both unkilled. 
	
	  Sibling 0 will have its own seccomp policy
	  and Sibling 1 will not be under seccomp at
	  all. Sibling 1 will enter seccomp and 0
	  will cause failure.
	 Increment the other siblings num_waits so we can clean up
	  the one we just saw.
 Signal the thread to clean up
 Poll for actual task death. pthread_join doesn't guarantee it. 
 Switch to the remaining sibling 
	 If remaining sibling didn't have a chance to wake up during
	  the first broadcast, manually reduce the num_waits now.
 Poll for actual task death. pthread_join doesn't guarantee it. 
 just us chickens 
 Make sure restarted syscalls are seen directly as "restart_syscall". 
 Allow __NR_write for easy logging. 
 The nanosleep jump target. 
 The restart_syscall jump target. 
 Child uses EXPECT not ASSERT to deliver status correctly. 
 Attach parent as tracer and stop. 
 Start nanosleep to be interrupted. 
 Read final sync from parent. 
 Directly report the status of our test harness results. 
 Attach to child, setup options, and release. 
 Wait for nanosleep() to start. 
 Might as well check siginfo for sanity while we're here. 
 Verify signal delivery came from child (seccomp-triggered). 
 Interrupt nanosleep with SIGSTOP (which we'll need to handle). 
	
	  There is no siginfo on SIGSTOP any more, so we can't verify
	  signal delivery came from parent now (getpid() == info.si_pid).
	  https:lkml.kernel.orgrCAGXu5jJaZAOzP1qFz66tYrtbuywqb+UN2SOA1VLHpCCOiYvYeg@mail.gmail.com
	  At least verify the SIGSTOP via PTRACE_GETSIGINFO.
 Restart nanosleep with SIGCONT, which triggers restart_syscall. 
 Wait for restart_syscall() to start. 
	
	  FIXME:
	  - native ARM registers do NOT expose true syscall.
	  - compat ARM registers on ARM64 DO expose true syscall.
 Write again to end test. 
 Verify that the FILTER_FLAG_LOG flag isn't accepted in strict mode 
 Verify that a simple, permissive filter can be added with no flags 
 See if the same filter can be added with the FILTER_FLAG_LOG flag 
 Ensure that the kill filter works with the FILTER_FLAG_LOG flag 
 getpid() should never return. 
 Check that an unknown action is handled properly (EOPNOTSUPP) 
 Only real root can get metadata. 
 one with log, one without 
 Past here must not use ASSERT or child process is never killed. 
 Check that we get -ENOSYS with no listener attached 
 Add some no-op filters for grins. 
 Check that the basic notification machinery works 
 Installing a second listener in the chain should EBUSY 
 Test that we can't pass garbage to the kernel. 
 check that we make sure flags == 0 
 these were exclusive 
 but now they're not 
	
	  Check that nothing bad happens when we kill the task in the middle
	  of a syscall.
		
		  ERESTARTSYS behavior is a bit hard to test, because we need
		  to rely on a signal that has not yet been handled. Let's at
		  least check that the error code gets propagated through, and
		  hope that it doesn't break when there is actually a signal :)
	
	  Make sure the signal really is delivered, which means we're not
	  stuck in the user notification code any more and the notification
	  should be dead.
 -ERESTARTSYS 
	
	  Check that we get an ENOSYS when the listener is closed.
  Check that a pid in a child namespace still shows up as valid in ours.
  Check that a pid in a sibling (i.e. unrelated) namespace shows up as 0, i.e.
  invalid.
 Create the sibling ns, and sibling in it. 
		
		  The pid should be 0, i.e. the task is in some namespace that
		  we can't "see".
 Do a bad recv() 
 We should still be able to receive this notification, though. 
	
	  Verify that setting SECCOMP_USER_NOTIF_FLAG_CONTINUE enforces other
	  args be set to 0.
	
	  The seccomp filter has become unused so we should be notified once
	  the kernel gets around to cleaning up task struct.
	
	  The seccomp filter has become unused so we should be notified once
	  the kernel gets around to cleaning up task struct.
 100 ms 
 There may be arbitrary already-open fds at test start. 
 fd: 4 
 Check that the basic notification machinery works 
 fds will be added and this value is expected 
 Atomic addfd+send is received here. Check it is a valid fd 
 Verify bad newfd_flags cannot be set 
 Verify bad flags cannot be set 
 Verify that remote_fd cannot be set without setting flags 
 Verify small size cannot be set 
 Verify we can't send bits filled in unknown buffer area 
 Verify we can set an arbitrary remote fd 
 Verify we can set an arbitrary remote fd with large size 
 Verify we can set a specific remote fd 
 Resume syscall 
	
	  This sets the ID of the ADD FD to the last request plus 1. The
	  notification ID increments 1 per notification.
 This spins until the underlying notification is generated 
 Verify we can do an atomic addfd and send 
	
	  Child has earlier "low" fds and now 42, so we expect the next
	  lowest available fd to be assigned here.
	
	  This sets the ID of the ADD FD to the last request plus 1. The
	  notification ID increments 1 per notification.
 This spins until the underlying notification is generated 
 Wait for child to finish. 
 Check that the basic notification machinery works 
 Should probably spot check procsysfsfile-nr 
 Wait for child to finish. 
  TODO:
  - expand NNP testing
  - better arch-specific TRACE and TRAP handlers.
  - endianness checking when appropriate
  - 64-bit arg prodding
  - arch value testing (x86 modes especially)
  - verify that FILTER_FLAG_LOG filters generate log messages
  - verify that RET_LOG generates log messages
 SPDX-License-Identifier: GPL-2.0
  main() pid is used to avoid duplicate test counts 
	
	  TODO: If we're already root, we could skip creating the userns.
 Re-enable effective caps
 no short writes on tmpfs 
 don't print this message for mpid 
 Make sure that i starts out clear 
 We should not be able to add ambient caps yet. 
 The remaining tests need real privilege 
 Find our path 
 SPDX-License-Identifier: GPL-2.0
	
	  Be careful just in case a setgid or setcapped copy of this
	  helper gets out.
 SPDX-License-Identifier: GPL-2.0-or-later
  Author: Alexey Gladkov <gladkov.alexey@gmail.com>
	
	  This rlimit is not a problem for root because it can be exceeded.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2020 Collabora Ltd.
  Test code for syscall user dispatch
 Bad Linux syscall number 
 Bad Linux syscall number 
 Test Summary:
  - dispatch_trigger_sigsys: Verify if PR_SET_SYSCALL_USER_DISPATCH is
    able to trigger SIGSYS on a syscall.
  - bad_selector: Test that a bad selector value triggers SIGSYS with
    si_errno EINVAL.
  - bad_prctl_param: Test that the API correctly rejects invalid
    parameters on prctl
  - dispatch_and_return: Test that a syscall is selectively dispatched
    to userspace depending on the value of selector.
  - disable_dispatch: Test that the PR_SYS_DISPATCH_OFF correctly
    disables the dispatcher
  - direct_dispatch_range: Test that a syscall within the allowed range
    can bypass the dispatcher.
 Invalid op 
 PR_SYS_DISPATCH_OFF 
 offset != 0 
 len != 0 
 sel != NULL 
 Valid parameter 
 PR_SYS_DISPATCH_ON 
 Dispatcher region is bad (offset > 0 && len == 0) 
 Invalid selector 
	
	  Dispatcher range overflows unsigned long
	
	  Allowed range overflows usigned long
  Use global selector for handle_sigsys tests, to avoid passing
  selector to signal handler
 In preparation for sigreturn. 
 Make sure selector is good prior to prctl. 
 MAGIC_SYSCALL_1 doesn't exist. 
 MAGIC_SYSCALL_1 should be emulated. 
 Make sure selector is good prior to prctl. 
	 Even though it is ready to catch SIGSYS, the signal is
	  supposed to be uncatchable.
 MAGIC_SYSCALL_1 doesn't exist. 
 Shouldn't have any effect... 
	
	  Instead of calculating libc addresses; allow the entire
	  memory map and lock the selector.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2020 Collabora Ltd.
  Benchmark and test syscall user dispatch
 Bad Linux syscall number 
 Bad Linux syscall number 
  To test returning from a sigsys with selector blocked, the test
  requires some per-architecture support (i.e. knowledge about the
  signal trampoline address).  On i386, we know it is on the vdso, and
  a small trampoline is open-coded for x86_64.  Other architectures
  that have a trampoline in the vdso will support TEST_BLOCKED_RETURN
  out of the box, but don't enable them until they support syscall user
  dispatch.
 printf and friends are not signal-safe. 
 Landing pad within dispatcher area 
 SPDX-License-Identifier: GPL-2.0
 o32 
 n32 
 n64 
 create a couple of gaps 
 test that the kernel caps and still closes all fds 
 create a couple of gaps 
 test that the kernel caps and still closes all fds 
 Ensure the FD_CLOEXEC bit is set also with a resource limit in place.  
 Set close-on-exec for two ranges: [0-50] and [75-100].  
 Test a common pattern.  
 Ensure the FD_CLOEXEC bit is set also with a resource limit in place.  
 Set close-on-exec for two ranges: [0-50] and [75-100].  
 Test a common pattern.  
  Regression test for syzbot+96cfd2b22b3213646a93@syzkaller.appspotmail.com
 Create a huge gap in the fd table. 
		
			  We now have a private file descriptor table and all
			  our open fds should still be open but made
			  close-on-exec.
		
			  Duplicating the file descriptor must remove the
			  FD_CLOEXEC flag.
	
	  We had a shared file descriptor table before along with requesting
	  close-on-exec so the original fds must not be close-on-exec.
  Regression test for syzbot+96cfd2b22b3213646a93@syzkaller.appspotmail.com
	
	  Create a huge gap in the fd table. When we now call
	  CLOSE_RANGE_UNSHARE with a shared fd table and and with ~0U as upper
	  bound the kernel will only copy up to fd1 file descriptors into the
	  new fd table. If the kernel is buggy and doesn't handle
	  CLOSE_RANGE_CLOEXEC correctly it will not have copied all file
	  descriptors and we will oops!
	 
	  On a buggy kernel this should immediately oops. But let's loop just
	  to be sure.
			
			  We now have a private file descriptor table and all
			  our open fds should still be open but made
			  close-on-exec.
			
			  Duplicating the file descriptor must remove the
			  FD_CLOEXEC flag.
	
	  We created a private file descriptor table before along with
	  requesting close-on-exec so the original fds must not be
	  close-on-exec.
 SPDX-License-Identifier: GPL-2.0
  Example of using hugepage memory in a user application using the mmap
  system call with MAP_HUGETLB flag.  Before running this program make
  sure the administrator has allocated enough default sized huge pages
  to cover the 256 MB allocation.
  For ia64 architecture, Linux kernel reserves Region number 4 for hugepages.
  That means the addresses starting with 0x800000... will need to be
  specified.  Specifying a fixed address is not required on ppc64, i386
  or x86_64.
 arch specific 
 Only ia64 requires this 
 munmap() length of MAP_HUGETLB memory must be hugepage aligned 
  Stress test for transparent huge pages, memory compaction and migration.
  Authors: Konstantin Khlebnikov <koct9i@gmail.com>
  This is free and unencumbered software released into the public domain.
 drop pmd 
 allocate transparent huge page 
 split transhuge page, keep last page 
 SPDX-License-Identifier: GPL-2.0
  A test of splitting PMD THPs and PTE-mapped THPs from a specified virtual
  address range in a process via <debugfs>split_huge_pages interface.
	
	  Fetch the AnonHugePages: in the same block and check the number of
	  hugepages.
 split all THPs 
 remap the first pagesize of first THP 
 remap the Nth pagesize of Nth THP 
 smap does not show THPs after mremap, use kpageflags instead 
 split all remapped THPs 
 smap does not show THPs after mremap, use kpageflags instead 
 write something to the file, so a file-backed THP can be allocated 
 split the file-backed THP 
 SPDX-License-Identifier: GPL-2.0
  Tests Memory Protection Keys (see Documentationcore-apiprotection-keys.rst)
  There are examples in here of:
    how to set protection keys on memory
    how to setclear bits in pkey registers (the rights register)
    how to handle SEGV_PKUERR signals and extract pkey-relevant
     information from the siginfo
  Things to add:
 	make sure KSM and KSM COW breaking works
 	prefault pages in at malloc, or not
 	protect MPX bounds tables with protection keys?
 	make sure VMA splittingmerging is working correctly
 	OOMs can destroy mm->mmap (see exit_mmap()), so make sure it is immune to pkeys
 	look for pkey "leaks" where it is still set on a VMA but "freed" back to the kernel
 	do a plain mprotect() to a mprotect_pkey() area and make sure the pkey sticks
  Compile like this:
 	gcc      -o protection_keys    -O2 -g -std=gnu99 -pthread -Wall protection_keys.c -lrt -ldl -lm
 	gcc -m32 -o protection_keys_32 -O2 -g -std=gnu99 -pthread -Wall protection_keys.c -lrt -ldl -lm
	
	  these need to be raw because they are called under
	  pkey_assert()
  This attempts to have roughly a page of instructions followed by a few
  instructions that do a write, and another page of instructions.  That
  way, we are pretty sure that the write is in the second page of
  instructions and has at least a page of padding behind it.
  That lets us be sure to madvise() away the write instruction, which
  will then fault, which makes sure that the fault code handles
  execute-only memory properly.
 This way, both 4K and 64K alignment are maintained 
 Assume this happens in the second page of instructions: 
 pad out by another page: 
 make sure that 'rights' only contains the bits we expect: 
 modify bits accordingly in old pkey_reg and assign it 
 pkey_reg and flags have the same format 
 Failed address bound checks: 
 arch 
 arch 
 arch 
	
	  32-bit has some extra padding so that userspace can tell whether
	  the XSTATE header is present in addition to the "legacy" FPU
	  state.  We just assume that it is here.
 i386 
	
	  If we got a PKEY fault, we HAVE to have at least one bit set in
	  here.
 arch 
	
	  need __read_pkey_reg() version so we do not do shadow_pkey_reg
	  checking
 arch 
 arch 
 restore access and let the faulting instruction continue 
 arch 
 #PF is mapped to sigsegv 
sigset_t - signals to block while in the handler 
 get the old signal mask. 
 call sa_sigaction, not sa_handler
 void()(), obsolete 
 in the child 
	
	  pkey_alloc() sets PKEY register, so we need to reflect it in
	  shadow_pkey_reg:
 clear both the bits: 
		
		  move the new state in from init_val
		  (remember, we cheated and init_val == pkey_reg format)
 for shadow checking: 
  I had a bug where pkey bits could be set by mprotect() but
  not cleared.  This ensures we get lots of random bit sets
  and clears on the vma and pte pkey bits.
 allocate every possible key and make a note of which ones we got 
 select a random one out of the allocated ones 
 now zero it out so we don't free it next 
 go through the allocated ones that we did not want and free them 
 find a free record 
 every record is full 
		
		  realloc() does not initialize memory, so zero it from
		  the first new record all the way to the end.
	
	  Guarantee we can fit at least one huge page in the resulting
	  allocation by allocating space for 2:
	
	  Now go make sure that we got the pages and that they
	  are PMD-level pages. Someone might have made PUD-level
	  pages the default.
 -1 to guarantee leaving the trailing \0 
 can not do direct with the pkey_mprotect() API:
	malloc_pkey_mmap_direct,
	malloc_pkey_mmap_dax,
 try again if the malloc_type we tried is unsupported 
	 For exec-only memory, we do not know the pkey in
	 advance, so skip this check.
 arch 
	
	  The signal handler shold have cleared out PKEY register to let the
	  test program continue.  We now have to restore it.
 arch 
 arch 
	
	  Keep GCC from optimizing this away somehow
	
	  This is a bit of a hack.  But mprotect() requires
	  huge-page-aligned sizes when operating on hugetlbfs.
	  So, make sure that we use something that's a multiple
	  of a huge page when we can.
 allocate every possible key and make sure key-0 never got allocated 
 free all the allocated keys 
 attach key-0 in various modes 
 Assumes that all pkeys other than 'pkey' are unallocated 
 Note: 0 is the default pkey, so don't mess with it 
 Assumes that all pkeys other than 'pkey' are unallocated 
 pass a known-invalid pkey in: 
 in the child 
 Assumes that all pkeys other than 'pkey' are unallocated 
 for shadow checking 
			
			  Ensure the number of successes never
			  exceeds the number of keys supported
			  in the hardware.
		
		  Make sure that allocation state is properly
		  preserved across fork().
	
	  On x86:
	  There are 16 pkeys supported in hardware.  Three are
	  allocated by the time we get here:
	    1. The default key (0)
	    2. One possibly consumed by an execute-only mapping.
	    3. One allocated by the test code and passed in via
	       'pkey' to this function.
	  Ensure that we can allocate at least another 13 (16-3).
	 
	  On powerpc:
	  There are either 5, 28, 29 or 32 pkeys supported in
	  hardware depending on the page size (4K or 64K) and
	  platform (powernv or powervm). Four are allocated by
	  the time we get here. These include pkey-0, pkey-1,
	  exec-only pkey and the one allocated by the test code.
	  Ensure that we can allocate the remaining.
 for shadow checking 
 arch 
	
	  All keys should be allocated and set to allow reads and
	  writes, so the register should be all 0.  If not, just
	  skip the test.
	
	  Just allocate an absurd about of memory rather than
	  doing the XSAVE size enumeration dance.
 These __builtins require compiling with -mxsave 
 XSAVE to build a valid buffer: 
 Clear XSTATE_BV[PKRU]: 
 XRSTOR will likely get PKRU back to the init state: 
  This is mostly useless on ppc for now.  But it will not
  hurt anything and should give some better coverage as
  a long-running test that continually checks the pkey
  register.
	
	  Loop for a bit, hoping to get exercise the kernel
	  context switch code.
 for shadow checking 
  pkey 0 is special.  It is allocated by default, so you do not
  have to call pkey_alloc() to use it first.  Make sure that it
  is usable.
	
	  This is a bit of a hack.  But mprotect() requires
	  huge-page-aligned sizes when operating on hugetlbfs.
	  So, make sure that we use something that's a multiple
	  of a huge page when we can.
 Use pkey 0 
 Make sure that we can set it back to the original pkey. 
	
	  This is the "control" for our little expermient.  Make sure
	  we can always access it when ptracing.
	
	  Fork a child which is an exact copy of this process, of course.
	  That means we can do all of our tests via ptrace() and then plain
	  memory access and ensure they work differently.
	 Write access, untested for now:
	ret = ptrace(PTRACE_POKEDATA, child_pid, peek_at, data);
	pkey_assert(ret != -1);
	dprintf1("poke at %p: %ld\n", peek_at, ret);
	
	  Try to access the pkey-protected "ptr" via ptrace:
 expect it to work, without an error: 
 Now access from the current task, and expect an exception: 
	
	  Try to access the NON-pkey-protected "plain_ptr" via ptrace:
 expect it to work, without an error: 
 Now access from the current task, and expect NO exception: 
 lots_o_noops_around_write should be page-aligned already 
 Point 'p1' at the second page of the function: 
	
	  Try to ensure we fault this in on next touch to ensure
	  we get an instruction fault as opposed to a data one
	
	  Make sure this is an instruction fault
 Use a normal mprotect(), not mprotect_pkey(): 
	
	  Reset the shadow, assuming that the above mprotect()
	  correctly changed PKRU, but to an unknown value since
	  the actual alllocated pkey is unknown.
 Make sure this is an instruction fault 
	
	  Put the memory back to non-PROT_EXEC.  Should clear the
	  exec-only pkey off the VMA and allow it to be readable
	  again.  Go to PROT_NONE first to check for a kernel bug
	  that did not clear the pkey when doing PROT_NONE.
 SPDX-License-Identifier: GPL-2.0
  hugepage-shm:
  Example of using huge page memory in a user application using Sys V shared
  memory system calls.  In this example the app is requesting 256MB of
  memory that is backed by huge pages.  The application uses the flag
  SHM_HUGETLB in the shmget system call to inform the kernel that it is
  requesting huge pages.
  For the ia64 architecture, the Linux kernel reserves Region number 4 for
  huge pages.  That means that if one requires a fixed address, a huge page
  aligned address starting with 0x800000... will be required.  If a fixed
  address is not required, the kernel will select an address in the proper
  range.
  Other architectures, such as ppc64, i386 or x86_64 are not so constrained.
  Note: The default shared memory limit is quite low on many kernels,
  you may need to increase it via:
  echo 268435456 > procsyskernelshmmax
  This will increase the maximum size per shared memory segment to 256MB.
  The other limit that you will hit eventually is shmall which is the
  total amount of shared memory in pages. To set it to 16GB on a system
  with a 4kB pagesize do:
  echo 4194304 > procsyskernelshmall
 Only ia64 requires this 
 SPDX-License-Identifier: GPL-2.0
  Test that MAP_FIXED_NOREPLACE works.
  Copyright 2018, Jann Horn <jannh@google.com>
  Copyright 2018, Michael Ellerman, IBM Corporation.
 Check we can map all the areas we need below
	
	  Exact same mapping again:
	    base |  free  | new
	      +1 | mapped | new
	      +2 | mapped | new
	      +3 | mapped | new
	      +4 |  free  | new
	
	  Second mapping contained within first:
	 
	    base |  free  |
	      +1 | mapped |
	      +2 | mapped | new
	      +3 | mapped |
	      +4 |  free  |
	
	  Overlap end of existing mapping:
	    base |  free  |
	      +1 | mapped |
	      +2 | mapped |
	      +3 | mapped | new
	      +4 |  free  | new
	
	  Overlap start of existing mapping:
	    base |  free  | new
	      +1 | mapped | new
	      +2 | mapped |
	      +3 | mapped |
	      +4 |  free  |
	
	  Adjacent to start of existing mapping:
	    base |  free  | new
	      +1 | mapped |
	      +2 | mapped |
	      +3 | mapped |
	      +4 |  free  |
	
	  Adjacent to end of existing mapping:
	    base |  free  |
	      +1 | mapped |
	      +2 | mapped |
	      +3 | mapped |
	      +4 |  free  |  new
 SPDX-License-Identifier: GPL-2.0
  It tests the mlockmlock2() when they are invoked
  on randomly memory region.
 drop capabilities including CAP_IPC_LOCK 
  Get the MMUPageSize of the memory region including input
  address from proc file.
  return value: on error case, 0 will be returned.
  Otherwise the page size(in bytes) is returned.
 found the MMUPageSize of this section 
  Test mlockmlock2() on provided memory chunk.
  It expects the mlockmlock2() to be successful (within rlimit)
  With allocated memory chunk [p, p + alloc_size), this
  test will choose startlen randomly to perform mlockmlock2
  [start, start +  len] memory range. The range is within range
  of the allocated chunk.
  The memory region size alloc_size is within the rlimit.
  So we always expect a success of mlockmlock2.
  VmLck is assumed to be 0 before this test.
     return value: 0 - success
     else: failure
		
		  - choose mlockmlock2 randomly
		  - choose lock_size randomly but lock_size < alloc_size
		  - choose start_offset randomly but p+start_offset+lock_size
		    < p+alloc_size
	
	  Check VmLck left by the tests.
  We expect the mlockmlock2() to be fail (outof limitation)
  With allocated memory chunk [p, p + alloc_size), this
  test will randomly choose startlen and perform mlockmlock2
  on [start, start+len] range.
  The memory region size alloc_size is above the rlimit.
  And the len to be locked is higher than rlimit.
  So we always expect a failure of mlockmlock2.
  No locked page number should be increased as a side effect.
     return value: 0 - success
     else: failure
 SPDX-License-Identifier: GPL-2.0-only
  Authors: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
  Authors: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
  This will work with 16M and 2M hugepage size
  >= 128TB is the hint addr value we used to select
  large address space.
		
		  If stack is moved, we could possibly allocate
		  this at the requested address.
		
		  We should never allocate at the requested address or above it
		  The len cross the 128TB boundary. Without MAP_FIXED
		  we will always search in the lower address space.
		
		  Exact mapping at 128TB, the area is free we should get that
		  even without MAP_FIXED.
			
			  Do a dereference of the address returned so that we catch
			  bugs in page fault handling
 SPDX-License-Identifier: GPL-2.0
  hugepage-mmap:
  Example of using huge page memory in a user application using the mmap
  system call.  Before running this application, make sure that the
  administrator has mounted the hugetlbfs filesystem (on some directory
  like mnt) using the command mount -t hugetlbfs nodev mnt. In this
  example, the app is requesting memory of size 256MB that is backed by
  huge pages.
  For the ia64 architecture, the Linux kernel reserves Region number 4 for
  huge pages.  That means that if one requires a fixed address, a huge page
  aligned address starting with 0x800000... will be required.  If a fixed
  address is not required, the kernel will select an address in the proper
  range.
  Other architectures, such as ppc64, i386 or x86_64 are not so constrained.
 Only ia64 requires this 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018 Dmitry Safonov, Arista Networks
  MAP_POPULATE | MAP_PRIVATE should COW VMA pages.
 Probably unnecessary, but let it be. 
 SPDX-License-Identifier: GPL-2.0
  HMM stands for Heterogeneous Memory Management, it is a helper layer inside
  the linux kernel to help device drivers mirror a process address space in
  the device. This allows the device to use the same address space which
  makes communication and data exchange a lot easier.
  This framework's sole purpose is to exercise various code paths inside
  the kernel to make sure that HMM performs as expected and to flush out any
  bugs.
  This is a private UAPI to the kernel test module so it isn't exported
  in the usual includeuapi... directory.
 Simulate a device reading system memory. 
  Create a temporary file that will be deleted on close.
  Return a random unsigned number.
  Simple NULL test of device openclose.
  Read private anonymous memory.
	
	  Initialize buffer in system memory but leave the first two pages
	  zero (pte_none and pfn_zero).
 Set buffer permission to read-only. 
 Populate the CPU page table with a special zero page. 
 Simulate a device reading system memory. 
 Check what the device read. 
  Read private anonymous memory which has been protected with
  mprotect() PROT_NONE.
 Initialize buffer in system memory. 
 Initialize mirror buffer so we can verify it isn't written. 
 Protect buffer from reading. 
 Simulate a device reading system memory. 
 Allow CPU to read the buffer so we can check it. 
 Check what the device read. 
  Write private anonymous memory.
 Initialize data that the device will write to buffer->ptr. 
 Simulate a device writing system memory. 
 Check what the device wrote. 
  Write private anonymous memory which has been protected with
  mprotect() PROT_READ.
 Simulate a device reading a zero page of memory. 
 Initialize data that the device will write to buffer->ptr. 
 Simulate a device writing system memory. 
 Check what the device wrote. 
 Now allow writing and see that the zero page is replaced. 
 Simulate a device writing system memory. 
 Check what the device wrote. 
  Check that a device writing an anonymous private mapping
  will copy-on-write if a child process inherits the mapping.
 Initialize buffer->ptr so we can tell if it is written. 
 Initialize data that the device will write to buffer->ptr. 
 Check that the parent's buffer did not change. 
 Check that we see the parent's values. 
 The child process needs its own mirror to its own mm. 
 Simulate a device writing system memory. 
 Check what the device wrote. 
  Check that a device writing an anonymous shared mapping
  will not copy-on-write if a child process inherits the mapping.
 Initialize buffer->ptr so we can tell if it is written. 
 Initialize data that the device will write to buffer->ptr. 
 Check that the parent's buffer did change. 
 Check that we see the parent's values. 
 The child process needs its own mirror to its own mm. 
 Simulate a device writing system memory. 
 Check what the device wrote. 
  Write private anonymous huge page.
 Initialize data that the device will write to buffer->ptr. 
 Simulate a device writing system memory. 
 Check what the device wrote. 
  Write huge TLBFS page.
 Skip test if we can't allocate a hugetlbfs page. 
 Initialize data that the device will write to buffer->ptr. 
 Simulate a device writing system memory. 
 Check what the device wrote. 
 LOCAL_CONFIG_HAVE_LIBHUGETLBFS 
  Read mmap'ed file memory.
 Write initial contents of the file. 
 Simulate a device reading system memory. 
 Check what the device read. 
  Write mmap'ed file memory.
 Initialize data that the device will write to buffer->ptr. 
 Simulate a device writing system memory. 
 Check what the device wrote. 
 Check that the device also wrote the file. 
  Migrate anonymous memory to device private memory.
 Initialize buffer in system memory. 
 Migrate memory to device. 
 Check what the device read. 
  Migrate anonymous memory to device private memory and fault some of it back
  to system memory, then try migrating the resulting mix of system and device
  private memory to the device.
 Initialize buffer in system memory. 
 Migrate memory to device. 
 Check what the device read. 
 Fault half the pages back to system memory and check them. 
 Migrate memory to the device again. 
 Check what the device read. 
  Migrate anonymous shared memory to device private memory.
 Migrate memory to device. 
  Try to migrate various memory types to device private memory.
 Reserve a range of addresses. 
 Migrating a protected area should be an error. 
 Punch a hole after the first page address. 
 We expect an error if the vma doesn't cover the range. 
 Page 2 will be a read-only zero page. 
 Page 3 will be read-only. 
 Page 4-5 will be read-write. 
 Now try to migrate pages 2-5 to device 1. 
 Page 5 won't be migrated to device 0 because it's on device 1. 
  Migrate anonymous memory to device private memory and fault it back to system
  memory multiple times.
 Initialize buffer in system memory. 
 Migrate memory to device. 
 Check what the device read. 
 Fault pages back to system memory and check them. 
  Read anonymous memory multiple times.
 Initialize buffer in system memory. 
 Simulate a device reading system memory. 
 Check what the device read. 
 Delay for a bit and then unmap buffer while it is being read. 
  Try reading anonymous memory while it is being unmapped.
 Initialize buffer in system memory. 
 Simulate a device reading system memory. 
 Check what the device read. 
  Test memory snapshot without faulting in pages accessed by the device.
 Reserve a range of addresses. 
 Punch a hole after the first page address. 
 Page 2 will be read-only zero page. 
 Page 3 will be read-only. 
 Page 4-6 will be read-write. 
 Page 5 will be migrated to device 0. 
 Page 6 will be migrated to device 1. 
 Simulate a device snapshotting CPU pagetables. 
 Check what the device saw. 
  Test the hmm_range_fault() HMM_PFN_PMD flag for large pages that
  should be mapped by a large page table entry.
 Skip test if we can't allocate a hugetlbfs page. 
 Initialize the pages the device will snapshot in buffer->ptr. 
 Simulate a device snapshotting CPU pagetables. 
 Check what the device saw. 
 Make the region read-only. 
 Simulate a device snapshotting CPU pagetables. 
 Check what the device saw. 
 LOCAL_CONFIG_HAVE_LIBHUGETLBFS 
  Test two devices reading the same memory (double mapped).
 Reserve a range of addresses. 
 Initialize buffer in system memory. 
 Make region read-only. 
 Simulate device 0 reading system memory. 
 Check what the device read. 
 Simulate device 1 reading system memory. 
 Check what the device read. 
 Punch a hole after the first page address. 
  Basic check of exclusive faulting.
 Initialize buffer in system memory. 
 Map memory exclusively for device access. 
 Check what the device read. 
 Fault pages back to system memory and check them. 
 Check atomic access revoked 
 Initialize buffer in system memory. 
 Map memory exclusively for device access. 
 Check what the device read. 
 Simulate a device writing system memory. 
  Check copy-on-write works.
 Initialize buffer in system memory. 
 Map memory exclusively for device access. 
 Fault pages back to system memory and check them. 
 SPDX-License-Identifier: GPL-2.0-only
  MADV_POPULATE_READ and MADV_POPULATE_WRITE tests
  Copyright 2021, Red Hat, Inc.
  Author(s): David Hildenbrand <david@redhat.com>
  For now, we're using 2 MiB of private anonymous memory for all tests.
 Present or swapped. 
 Hole in the middle 
 Hole at end 
 Hole at beginning 
 Clear any softdirty bits. 
 Populating READ should set softdirty. 
 Populating WRITE should set softdirty. 
 SPDX-License-Identifier: GPL-2.0
  A test for the patch "Allow compaction of unevictable pages".
  With this patch we should be able to allocate at least 14
  of RAM in huge pages. Without the patch much less is
  allocated.
	 We want to test with 80% of available memory. Else, OOM killer comes
 Start with the initial condition of 0 huge pages
	 Request a large number of huge pages. The Kernel will allocate
	 We should have been able to request at least 13 rd of the memory in
		 Write something (in this case the address of the map) to
		  ensure that KSM can't merge the mapped pages
 SPDX-License-Identifier: GPL-2.0
  hugepage-mremap:
  Example of remapping huge page memory in a user application using the
  mremap system call.  Code assumes a hugetlbfs filesystem is mounted
  at '.huge'.  The code will use 10MB worth of huge pages.
 Definition of O_ constants 
 Definition of SYS_ constants 
 userfaultfd file descriptor 
 Create and enable userfaultfd object. 
	 Create a private anonymous mapping. The memory will be
	  demand-zero paged--that is, not yet allocated. When we
	  actually touch the memory, it will be allocated via
	  the userfaultfd.
	 Register the memory range of the mapping we just created for
	  handling by the userfaultfd object. In mode, we request to track
	  missing pages (i.e., pages that have not yet been faulted in).
 mmap to a PUD aligned address to hopefully trigger pmd sharing. 
 mmap again to a dummy address to hopefully trigger pmd sharing. 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2020 Google LLC
 4MB 
 Verify the entire region 
 1KB -> not page aligned 
  Returns the start address of the mapping on success, else returns
  NULL on failure.
	
	  Check that the address is aligned to the specified alignment.
	  Addresses which have alignments that are multiples of that
	  specified are not considered valid. For instance, 1GB address is
	  2MB-aligned, however it will not be considered valid for a
	  requested alignment of 2MB. This is done to reduce coincidental
	  alignment in the tests.
 Returns the time taken for the remap on success else returns -1. 
 Set byte pattern 
 Mask to zero out lower bits of address for alignment 
 Offset of destination address from the end of the source region 
 See comment in get_source_mapping() 
 Verify byte pattern after remapping 
  Since the destination address is specified using MREMAP_FIXED, subsequent
  mremap will unmap any previous mapping at the address range specified by
  dest_addr and region_size. This significantly affects the remap time of
  subsequent tests. So we clean up mappings after each test.
		
		  Comparing mremap time is only applicable if entire region
		  was faulted in.
 Expected mremap failures 
 Src addr PTE aligned 
 Src addr 1MB aligned 
 Src addr PMD aligned 
 Src addr PUD aligned 
	
	  mremap 1GB region - Page table level aligned time
	  comparison.
 SPDX-License-Identifier: GPL-2.0-only
  Stress userfaultfd syscall.
   Copyright (C) 2015  Red Hat, Inc.
  This test allocates two virtual areas and bounces the physical
  memory across the two virtual areas (from area_src to area_dst)
  using userfaultfd.
  There are three threads running per CPU:
  1) one per-CPU thread takes a per-page pthread_mutex in a random
     page of the area_dst (while the physical page may still be in
     area_src), and increments a per-page counter in the same page,
     and checks its value against a verification region.
  2) another per-CPU thread handles the userfaults generated by
     thread 1 above. userfaultfd blocking reads or poll() modes are
     exercised interleaved.
  3) one last per-CPU thread transfers the memory in the background
     at maximum bandwidth (if not already transferred by thread
     2). Each cpu thread takes cares of transferring a portion of the
     area.
  When all threads of type 3 completed the transfer, one bounce is
  complete. area_src and area_dst are then swapped. All threads are
  respawned and so the bounce is immediately restarted in the
  opposite direction.
  per-CPU threads 1 by triggering userfaults inside
  pthread_mutex_lock will also verify the atomicity of the memory
  transfer (UFFDIO_COPY).
 exercise the test_uffdio__eexist every ALARM_INTERVAL_SECS 
 Whether to test uffd write-protection 
 Whether to test uffd minor faults 
 Userfaultfd test statistics 
 pthread_mutex_t starts at page offset 0 
  count is placed in the page after pthread_mutex_t naturally aligned
  to avoid non alignment faults on non-x86 archs.
	
	  We can't zap just the pagetable with hugetlbfs because
	  MADV_DONTEED won't work. So exercise -EEXIST on a alias
	  mapping where the pagetables are not established initially,
	  this way we'll exercise the -EEXEC at the fs level.
		
		  In the transition between 255 to 256, powerpc will
		  read out of order in my_bcmp and see both bytes as
		  zero, so leave a placeholder below always non-zero
		  after the count, to avoid my_bcmp to trigger false
		  positives.
	
	  After initialization of area_src, we must explicitly release pages
	  for area_dst to make sure it's fully empty.  Otherwise we could have
	  some area_dst pages be errornously initialized with zero pages,
	  hence we could hit memory corruption later in the test.
	 
	  One example is when THP is globally enabled, above allocate_area()
	  calls could have the two areas merged into a single VMA (as they
	  will have the same VMA flags so they're mergeable).  When we
	  initialize the area_src above, it's possible that some part of
	  area_dst could have been faulted in via one huge THP that will be
	  shared between area_src and area_dst.  It could cause some of the
	  area_dst won't be trapped by missing userfaults.
	 
	  This release_pages() will guarantee even if that happened, we'll
	  proactively split the thp and drop any accidentally initialized
	  pages within area_dst.
 Write protection page faults 
 Undo write-protect, do wakeup after that 
	
	  Error handling within the kernel for continue is subtly different
	  from copy or zeropage, so it may be a source of bugs. Trigger an
	  error (-EEXIST) on purpose, to verify doing so doesn't cause a BUG.
 uninitialized warning 
 real retval in ufdio_copy.copy 
 real retval in ufdio_copy.copy 
 Write protect page faults 
		
		  Minor page faults
		 
		  To prove we can modify the original range for testing
		  purposes, we're going to bit flip this range before
		  continuing.
		 
		  Note that this requires all minor page fault tests operate on
		  area_dst (non-UFFD-registered) and area_dst_alias
		  (UFFD-registered).
 Missing page faults 
 from here cancellation is ok 
 Copy the first half of the pages 
	
	  If we need to test uffd-wp, set it up now.  Then we'll have
	  at least the first half of the pages mapped already which
	  can be write-protected for testing
	
	  Continue the 2nd half of the page copying, handling write
	  protection faults if any
	
	  Be strict and immediately zap area_src, the whole area has
	  been transferred already by the background treads. The
	  area_src could then be faulted in in a racy way by still
	  running uffdio_threads reading zeropages after we zapped
	  area_src (but they're guaranteed to get -EEXIST from
	  UFFDIO_COPY without writing zero pages into area_dst
	  because the background threads already completed).
  For non-cooperative userfaultfd test we fork() a process that will
  generate pagefaults, will mremap the area monitored by the
  userfaultfd and at last this process will release the monitored
  area.
  For the anonymous and shared memory the area is divided into two
  parts, the first part is accessed before mremap, and the second
  part is accessed after mremap. Since hugetlbfs does not support
  mremap, the entire monitored area is accessed in a single pass for
  HUGETLB_TEST.
  The release of the pages currently generates event for shmem and
  anonymous memory (UFFD_EVENT_REMOVE), hence it is not checked
  for hugetlb.
  For signal test(UFFD_FEATURE_SIGBUS), signal_test = 1, we register
  monitored area, generate pagefaults and test that signal is delivered.
  Use UFFDIO_COPY to allocate missing page and retry. For signal_test = 2
  test robustness use case - we release monitored area, fork a process
  that will generate pagefaults and verify signal is generated.
  This also tests UFFD_FEATURE_EVENT_FORK event along with the signal
  feature. Using monitor thread, verify no userfault events are generated.
 This is a MISSING request 
 This is a WP request 
		
		  Trigger write protection if there is by writing
		  the same value back.
 Reset area_src since we just clobbered it 
		
		  Trigger write protection if there is by writing
		  the same value back.
 real retval in ufdio_zeropage.zeropage 
 exercise UFFDIO_ZEROPAGE 
	
	  After registering with UFFD, populate the non-UFFD-registered side of
	  the shared mapping. This should not trigger any UFFD minor faults.
	
	  Read each of the pages back using the UFFD-registered mapping. We
	  expect that the first time we touch a page, it will result in a minor
	  fault. uffd_poll_thread will resolve the fault by bit-flipping the
	  page's contents, and then issuing a CONTINUE ioctl.
 This macro let __LINE__ works in err() 
 Open the pagemap fd of the child itself 
		
		  After fork() uffd-wp bit should be gone as long as we're
		  without UFFD_FEATURE_EVENT_FORK
 Succeed 
 Pagemap tests uffd-wp only 
 Not enough memory to test this page size 
 Flush so it doesn't flush twice in parentchild later 
 This is a thp test 
 This is normal page test; force no thp 
 Touch the page 
 Make sure uffd-wp bit dropped when fork 
 Exclusive required or PAGEOUT won't work 
 Uffd-wp should persist even swapped out 
 Make sure uffd-wp bit dropped when fork 
 Unprotect; this tests swap pte modifications 
 Fault in the page from disk 
 register 
		
		  The madvise done previously isn't enough: some
		  uffd_thread could have read userfaults (one of
		  those already resolved by the background thread)
		  and it may be in the process of calling
		  UFFDIO_COPY. UFFDIO_COPY will read the zapped
		  area_src and it would map a zero page in it (of
		  course such a UFFDIO_COPY is perfectly safe as it'd
		  return -EEXIST). The problem comes at the next
		  bounce though: that racing UFFDIO_COPY would
		  generate zeropages in the area_src, so invalidating
		  the previous MADV_DONTNEED. Without this additional
		  MADV_DONTNEED those zeropages leftovers in the
		  area_src would lead to -EEXIST failure during the
		  next bounce, effectively leaving a zeropage in the
		  area_dst.
		 
		  Try to comment this out madvise to see the memory
		  corruption being caught pretty quick.
		 
		  khugepaged is also inhibited to collapse THP after
		  MADV_DONTNEED only after the UFFDIO_REGISTER, so it's
		  required to MADV_DONTNEED here.
 bounce pass 
 Clear all the write protections if there is any 
 unregister 
 verification 
 prepare next bounce 
		
		  shmemhugetlb won't be able to run since they have different
		  behavior on fork() (file-backed memory normally drops ptes
		  directly when fork), meanwhile the pagemap test will verify
		  pgtable entry of fork()ed child.
		
		  Hard-code for x86_64 for now for 2M THP, as x86_64 is
		  currently the only one that supports uffd-wp
  Copied from mlock2-tests.c
 Only enable write-protect test for anonymous test 
 Minor faults require shared hugetlb; only enable here. 
	
	  Whether we can test certain features depends not just on test type,
	  but also on whether or not this particular kernel supports the
	  feature.
 __NR_userfaultfd 
 __NR_userfaultfd 
 SPDX-License-Identifier: GPL-2.0
  This program reserves and uses hugetlb memory, supporting a bunch of
  scenarios needed by the charged_reserved_hugetlb.sh test.
 Global definitions. 
 Global variables. 
  Show usage and exit.
 Parse command-line arguments. 
 Signal to caller that we're done. 
 Hold memory until external kill signal is delivered. 
 SPDX-License-Identifier: GPL-2.0
  Tests for mremap w MREMAP_DONTUNMAP.
  Copyright 2020, Brian Geffon <bgeffon@google.com>
 Try a simple operation for to "test" for kernel support this prevents
 reporting tests as failed when it's run on an older kernel.
 This simple remap should only fail if MREMAP_DONTUNMAP isn't
 supported.
 This helper will just validate that an entire mapping contains the expected
 byte.
 Compare each page checking that it contains our expected byte.
 this test validates that MREMAP_DONTUNMAP moves the pagetables while leaving
 the source mapping mapped.
 Try to just move the whole mapping anywhere (not fixed).
 Validate that the pages have been moved, we know they were moved if
 the dest_mapping contains a's.
 This test validates that MREMAP_DONTUNMAP on a shared mapping works as expected.
 Try to just move the whole mapping anywhere (not fixed).
 Old kernel which doesn't support MREMAP_DONTUNMAP on shmem.
 Validate that the pages have been moved, we know they were moved if
 the dest_mapping contains a's.
 Because the region is backed by shmem, we will actually see the same
 memory at the source location still.
 This test validates MREMAP_DONTUNMAP will move page tables to a specific
 destination using MREMAP_FIXED, also while validating that the source
 remains intact.
 Since we want to guarantee that we can remap to a point, we will
 create a mapping up front.
 The dest mapping will have been unmap by mremap so we expect the Xs
 to be gone and replaced with a's.
 And the source mapping will have had its ptes dropped.
 This test validates that we can MREMAP_DONTUNMAP for a portion of an
 existing mapping.
	
	   source mapping:
	   --------------
	   | aaaaaaaaaa |
	   --------------
	   to become:
	   --------------
	   | aaaaa00000 |
	   --------------
	   With the destination mapping containing 5 pages of As.
	   ---------
	   | aaaaa |
	   ---------
 We will grab the last 5 pages of the source and move them.
 We expect the first 5 pages of the source to contain a's and the
 final 5 pages to contain zeros.
 Finally we expect the destination to have 5 pages worth of a's.
 This test validates that we can remap over only a portion of a mapping.
	
	   source mapping:
	   ---------
	   |aaaaa|
	   ---------
	   dest mapping initially:
	   -----------
	   |XXXXXXXXXX|
	   ------------
	   Source to become:
	   ---------
	   |00000|
	   ---------
	   With the destination mapping containing 5 pages of As.
	   ------------
	   |aaaaaXXXXX|
	   ------------
 We will grab the last 5 pages of the source and move them.
 Finally we expect the destination to have 5 pages worth of a's.
 Finally the last 5 pages shouldn't have been touched.
 test for kernel support for MREMAP_DONTUNMAP skipping the test if
 not.
 Keep a page sized buffer around for when we need it.
 SPDX-License-Identifier: GPL-2.0
  Copyright IBM Corporation, 2021
  Author: Mike Rapoport <rppt@linux.ibm.com>
 drop capabilities including CAP_IPC_LOCK 
 __NR_memfd_secret 
 __NR_memfd_secret 
 Just the flags we need, copied from mm.h: 
 check pte is writable 
 mark page accessed 
 Serialize prints 
 Only report timing information on the _BENCHMARK commands: 
			
			  Dump page 0 (index 1). May be overridden later, by
			  user's non-option arguments.
			 
			  .which_pages is zero-based, so that zero can mean "do
			  nothing".
 works only with DUMP_USER_PAGES_TEST 
 strtol, so you can pass flags in hex form 
 fault pages in gup, do not fault in userland 
		
		  For example:
		 
		    .gup_test -c 0 1 0x1001
		 
		  ...to dump pages 0, 1, and 4097
			
			  Do the 1-based indexing here, so that the user can
			  use normal 0-based indexing on the command line.
	
	  FOLL_TOUCH, in gup_test, is used as an eitheror case: either
	  fault pages in from the kernel via FOLL_TOUCH, or fault them
	  in here, from user space. This allows comparison of performance
	  between those two cases.
 SPDX-License-Identifier: GPL-2.0
 Since merging occurs only after 2 scans, make sure to get at least 2 full scans 
	
	  Since there must be at least 2 pages for merging and 1 page can be
	  shared with the limited number of pages (max_page_sharing), sometimes
	  there are 'leftover' pages that cannot be merged. For example, if there
	  are 11 pages and max_page_sharing = 10, then only 10 pages will be
	  merged and the 11th page won't be affected. As a result, when the number
	  of duplicate pages is divided by max_page_sharing and the remainder is 1,
	  pages_shared and pages_sharing values will be equal between dupl_page_count
	  and dupl_page_count - 1.
 fill pages with the same data and merge them 
 verify that the right number of pages are merged 
 fill pages with the same data and merge them 
 change 1 byte in each of the 2 pages -- KSM must automatically unmerge them 
 get at least 1 scan, so KSM can detect that the pages were modified 
 check that unmerging was successful and 0 pages are currently merged 
 fill pages with zero and try to merge them 
	 verify that the right number of pages are merged:
	 1) if use_zero_pages is set to 1, empty pages are merged
	    with the kernel zero page instead of with each other;
	 2) if use_zero_pages is set to 0, empty pages are not treated specially
	    and merged as usual.
 allocate 2 pages in 2 different NUMA nodes and fill them with the same data 
 try to merge the pages 
	 verify that the right number of pages are merged:
	 1) if merge_across_nodes was enabled, 2 duplicate pages will be merged;
	 2) if merge_across_nodes = 0, there must be 0 merged pages, since there is
	    only 1 unique page in each node and they can't be shared.
 drop pmd 
 allocate transparent huge page 
 page_count must be less than 2page_size 
 Create 2000 pairs of duplicate pages 
 SPDX-License-Identifier: GPL-2.0
 Test selecting other page sizes for mmapshmget.
   Before running this huge pages for each huge page size must have been
   reserved.
   For large pages beyond MAX_ORDER (like 1GB on x86) boot options must be used.
   Also shmmax must be increased.
   And you need to run as root to work around some weird permissions in shm.
   And nothing using huge pages should run in parallel.
   When the program aborts you may need to clean up the shm segments with
   ipcrm -m by hand, like this
   sudo ipcs | awk '$1 == "0x00000000" {print $2}' | xargs -n1 sudo ipcrm -m
 segment will use huge TLB pages 
 printf(fmt)
 SPDX-License-Identifier: GPL-2.0
 only one page is faulted in 
 Now unlock and recheck attributes 
 Now unlock and recheck attributes 
	
	  Before we unlock a portion, we need to that all three pages are in
	  the same VMA.  If they are not we abort this test (Note that this is
	  not a failure)
 All three VMAs should be different 
 Now unlock the first and third page and check the VMAs again 
 Now all three VMAs should be the same 
	
	  Fetch the AnonHugePages: in the same block and check whether it got
	  the expected number of hugeepages next.
	
	  Fetch the Swap: in the same block and check whether it got
	  the expected number of hugeepages next.
 3 seconds 
 Sanity check 
 Wait until the second full_scan completed 
 Do not touch settings on child exit 
 Do not touch settings on child exit 
 Do not touch settings on child exit 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2017, Anshuman Khandual, IBM Corp.
  Works on architectures which support 128TB virtual
  address range and beyond.
  Maximum address range mapped with a single mmap()
  call is little bit more than 16GB. Hence 16GB is
  chosen as the single chunk size for address space
  mapping.
 16GB 
  Address space till 128TB is mapped without any hint
  and is enabled by default. Address space beyond 128TB
  till 512TB is obtained by passing hint address as the
  first argument into mmap() system call.
  The process heap address space is divided into two
  different areas one below 128TB and one above 128TB
  till it reaches 512TB. One with size 128TB and the
  other being 384TB.
  On Arm64 the address space is 256TB and no high mappings
  are supported so far.
 Number of 16GB chunks for 128TB 
 First address beyond 128TB 
 First address beyond 256TB 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Need to mount securityfs
 Code executed by child 
 Give parent 1 second to write map file
 Code executed by parent 
 Code executed by child 
 Code executed by parent 
 First test to make sure we can write userns mappings from a user
 that doesn't have any restrictions (as long as it has CAP_SETUID);
 Take away all but setid caps
 Need PR_SET_DUMPABLE flag set so we can write proc[pid]uid_map
 from non-root parent process.
 Now take away all caps
 NOTE: this test doesn't clean up users that were created in
 etcpasswd or flush policies that were added to the LSM.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2021 Samsung Electrnoics
  Bongsu Jeon <bongsu.jeon@samsung.com>
  Test code for nci
 SPDX-License-Identifier: GPL-2.0
 o32 
 n32 
 n64 
 o32 
 n32 
 n64 
 Apply to the entire subtree 
 do not follow symlinks 
 Attempt to de-conflict with the selftests tree. 
	
	  We're holding a fd open for writing so this needs to fail somewhere
	  in the middle and the mount options need to be unchanged.
	
	  We're holding a fd open to a mount somwhere in the middle so this
	  needs to fail somewhere in the middle. After this the mount options
	  need to be unchanged.
 All writers are gone so this should succeed. 
 Try to change mount options from multiple threads. 
  Validate that negative fd values are rejected.
  Validate that excessively large fd values are rejected.
  Validate that closed fd values are rejected.
  Validate that the initial user namespace is rejected.
  Validate that an attached mount in our mount namespace can be idmapped.
  (The kernel enforces that the mount's mount namespace and the caller's mount
   namespace match.)
  Validate that idmapping a mount is rejected if the mount's mount namespace
  and our mount namespace don't match.
  (The kernel enforces that the mount's mount namespace and the caller's mount
   namespace match.)
  Validate that an attached mount in our mount namespace can be idmapped.
 Changing mount properties on a detached mount. 
  Validate that a detached mount not in our mount namespace can be idmapped.
 Changing mount properties on a detached mount. 
  Validate that currently changing the idmapping of an idmapped mount fails.
 Change idmapping on a detached mount that is already idmapped. 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2016-20 Intel Corporation. 
	
	  Pages must be added before mapping VMAs because their permissions
	  cap the VMA permissions.
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2016-20 Intel Corporation. 
 SECINFO flags 
 sanity check 
 BE -> LE 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2016-20 Intel Corporation. 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2016-20 Intel Corporation. 
	
	  An enclave consumer only must do this.
 Get vDSO base address 
   sync  sw_sync abstraction
   Copyright 2015-2016 Collabora Ltd.
   Based on the implementation from the Android Open Source Project,
   Copyright 2012 Google, Inc
   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the "Software"),
   to deal in the Software without restriction, including without limitation
   the rights to use, copy, modify, merge, publish, distribute, sublicense,
   andor sell copies of the Software, and to permit persons to whom the
   Software is furnished to do so, subject to the following conditions:
   The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   OTHER DEALINGS IN THE SOFTWARE.
 SW_SYNC ioctls 
 Same code! 
   sync test runner
   Copyright 2015-2016 Collabora Ltd.
   Based on the implementation from the Android Open Source Project,
   Copyright 2012 Google, Inc
   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the "Software"),
   to deal in the Software without restriction, including without limitation
   the rights to use, copy, modify, merge, publish, distribute, sublicense,
   andor sell copies of the Software, and to permit persons to whom the
   Software is furnished to do so, subject to the following conditions:
   The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   OTHER DEALINGS IN THE SOFTWARE.
 need this return to keep gcc happy 
   sync stress test: producerconsumer
   Copyright 2015-2016 Collabora Ltd.
   Based on the implementation from the Android Open Source Project,
   Copyright 2012 Google, Inc
   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the "Software"),
   to deal in the Software without restriction, including without limitation
   the rights to use, copy, modify, merge, publish, distribute, sublicense,
   andor sell copies of the Software, and to permit persons to whom the
   Software is furnished to do so, subject to the following conditions:
   The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   OTHER DEALINGS IN THE SOFTWARE.
 IMPORTANT NOTE: if you see this test failing on your system, it may be
  due to a shortage of file descriptors. Please ensure your system has
  a sensible limit for this test to finish correctly.
 Returns 1 on error, 0 on success 
		
		  Wait for the consumer to finish. Use alternate
		  means of waiting on the fence
		
		  Every producer increments the counter, the consumer
		  checks and erases it
		
		  Make sure we see an increment from every producer thread.
		  Vary the means by which we wait.
 Release the producer threads 
 Consumer thread runs here 
   sync fence merge tests
   Copyright 2015-2016 Collabora Ltd.
   Based on the implementation from the Android Open Source Project,
   Copyright 2012 Google, Inc
   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the "Software"),
   to deal in the Software without restriction, including without limitation
   the rights to use, copy, modify, merge, publish, distribute, sublicense,
   andor sell copies of the Software, and to permit persons to whom the
   Software is furnished to do so, subject to the following conditions:
   The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   OTHER DEALINGS IN THE SOFTWARE.
   sync fence wait tests
   Copyright 2015-2016 Collabora Ltd.
   Based on the implementation from the Android Open Source Project,
   Copyright 2012 Google, Inc
   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the "Software"),
   to deal in the Software without restriction, including without limitation
   the rights to use, copy, modify, merge, publish, distribute, sublicense,
   andor sell copies of the Software, and to permit persons to whom the
   Software is furnished to do so, subject to the following conditions:
   The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   OTHER DEALINGS IN THE SOFTWARE.
 Confirm fence isn't signaled 
 confirm you can successfully wait 
   sync stress test: parallelism
   Copyright 2015-2016 Collabora Ltd.
   Based on the implementation from the Android Open Source Project,
   Copyright 2012 Google, Inc
   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the "Software"),
   to deal in the Software without restriction, including without limitation
   the rights to use, copy, modify, merge, publish, distribute, sublicense,
   andor sell copies of the Software, and to permit persons to whom the
   Software is furnished to do so, subject to the following conditions:
   The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   OTHER DEALINGS IN THE SOFTWARE.
 Wait on the prior thread to complete 
		
		  Confirm the previous thread's writes are visible
		  and then increment
 Kick off the other thread 
	
	  Use a single timeline to synchronize two threads
	  hammmering on the same counter.
 make sure the threads did not trample on one another 
   sync allocation tests
   Copyright 2015-2016 Collabora Ltd.
   Based on the implementation from the Android Open Source Project,
   Copyright 2012 Google, Inc
   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the "Software"),
   to deal in the Software without restriction, including without limitation
   the rights to use, copy, modify, merge, publish, distribute, sublicense,
   andor sell copies of the Software, and to permit persons to whom the
   Software is furnished to do so, subject to the following conditions:
   The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   OTHER DEALINGS IN THE SOFTWARE.
   sync stress test: merging
   Copyright 2015-2016 Collabora Ltd.
   Based on the implementation from the Android Open Source Project,
   Copyright 2012 Google, Inc
   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the "Software"),
   to deal in the Software without restriction, including without limitation
   the rights to use, copy, modify, merge, publish, distribute, sublicense,
   andor sell copies of the Software, and to permit persons to whom the
   Software is furnished to do so, subject to the following conditions:
   The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   OTHER DEALINGS IN THE SOFTWARE.
	
	  Randomly create sync_points out of a fixed set of timelines,
	  and merge them together
 Generate sync_point. 
 Keep track of the latest sync_point in each timeline. 
 Merge 
 Confirm our map matches the fence. 
 Trigger the merged fence 
 Increment the timeline to the last sync_point 
 Check that the fence is triggered. 
   sync fence tests with one timeline
   Copyright 2015-2016 Collabora Ltd.
   Based on the implementation from the Android Open Source Project,
   Copyright 2012 Google, Inc
   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the "Software"),
   to deal in the Software without restriction, including without limitation
   the rights to use, copy, modify, merge, publish, distribute, sublicense,
   andor sell copies of the Software, and to permit persons to whom the
   Software is furnished to do so, subject to the following conditions:
   The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   OTHER DEALINGS IN THE SOFTWARE.
 Wait on fence until timeout 
 Advance timeline from 0 -> 1 
 Wait on fence until timeout 
 Signal the fence 
 Wait successfully 
 Go even further, and confirm wait still succeeds 
 create fence a,b,c and then merge them all into fence d 
 confirm all fences have one active point (even d) 
 confirm that d is not signaled until the max of a,b,c 
  Copyright (c) 2019 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  Fork and exec tiny 1 page executable which precisely controls its VM.
  Test proc$PIDmaps
  Test proc$PIDsmaps
  Test proc$PIDsmaps_rollup
  Test proc$PIDstatm
  FIXME require CONFIG_TMPFS which can be disabled
  FIXME test other values from "smaps"
  FIXME support other archs
 Casually unmap stack, vDSO and everything else. 
 munmap 
 Ping parent. 
 write(0, &c, 1); 
 xor edi, edi 
 lea rsi, [rip] 
 mov edx, 1 
 1: pause(); 
 jmp 1b 
 Avoid ETXTBSY on exec. 
  vsyscall page can't be unmapped, probe it with memory load.
 Hide "segfault at ffffffffff600000" messages. 
 Reserve fd 0 for 1-byte pipe ping from child. 
 Generate "head -n1 proc$PIDmaps" 
 Test proc$PIDmaps 
 Test proc$PIDsmaps 
 Test proc$PIDsmaps_rollup 
 Test proc$PIDstatm 
 ->total_vm 
 rss 
 file rss 
 ELF executable segments 
 ->data_vm + ->stack_vm 
  Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 Test readlink procselfmap_files... 
  Copyright  2020 Alexey Gladkov <gladkov.alexey@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 Test procfd lookup.
 lstat(2) has more "coverage" in case non-symlink pops up somehow. 
 leading junk 
 trailing junk 
 Wipe fdtable. 
 Now fdtable is clean. 
 Clean again! 
 Default RLIMIT_NOFILE-1 
  Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 Test that procself gives correct TGID.
  Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 Test that values in procuptime increment monotonically
 while shifting across CPUs.
 find out "nr_cpu_ids" 
 CPU might not exist, ignore error 
  Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 Test
 1) read and lseek on every file in proc
 2) readlink of every symlink in proc
 3) recursively (1) + (2) for every directory in proc
 4) write to procclear_refs and proctaskclear_refs
task
 5) write to procsysrq-trigger
 read from prockmsg can block 
 struct proc_ops::proc_lseek is mandatory if file is seekable. 
 Ensure proc is proc. 
  Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 Test that procloadavg correctly reports last pid in pid namespace. 
 pid 1 
 pid 2 
  Copyright  2020 Alexey Gladkov <gladkov.alexey@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 Test that values in procuptime increment monotonically.
  Copyright  2019 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  Test that setns(CLONE_NEWNET) points to new procnet content even
  if old one is in dcache.
  FIXME procnetunix is under CONFIG_UNIX which can be disabled.
 Check for priviledges and syscall availability straight away. 
 Distinguisher between two otherwise empty net namespaces. 
 Reliably pin dentry into dcache. 
  Copyright  2019 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  Test that setns(CLONE_NEWIPC) points to new procsysvipc content even
  if old one is in dcache.
 Check for priviledges and syscall availability straight away. 
 Distinguisher between two otherwise empty IPC namespaces. 
 Reliably pin dentry into dcache. 
  Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 Test that proc$KERNEL_THREADfd is empty.
  Test for kernel threadness atomically with openat().
  Return proc$PIDfd descriptor if process is kernel thread.
  Return -1 if a process is userspace process.
	
	  Believe it or not, struct task_struct::flags is directly exposed
	  to userspace!
 Search backwards: ->comm can contain whitespace and ')'. 
	
	  In theory this will loop indefinitely if kernel threads are exiled
	  from proc.
	 
	  Start with kthreadd.
 EACCES if run as non-root. 
  Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 Do direct system call as libc can wrap anything. 
  Copyright (c) 2021 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  Test that "mount -t proc -o subset=pid" hides everything but pids,
  procself and procthread-self.
  Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 Test that open(procfd) opens the same file.
#undef NDEBUG
#include <assert.h>
#include <stdio.h>
#include <systypes.h>
#include <sysstat.h>
#include <fcntl.h>
#include <unistd.h>
int main(void)
{
	int fd0, fd1, fd2;
	struct stat st0, st1, st2;
	char buf[64];
	int rv;
	fd0 = open("", O_DIRECTORY|O_RDONLY);
	assert(fd0 >= 0);
	snprintf(buf, sizeof(buf), "procselffd%u", fd0);
	fd1 = open(buf, O_RDONLY);
	assert(fd1 >= 0);
	snprintf(buf, sizeof(buf), "procthread-selffd%u", fd0);
	fd2 = open(buf, O_RDONLY);
	assert(fd2 >= 0);
	rv = fstat(fd0, &st0);
	assert(rv == 0);
	rv = fstat(fd1, &st1);
	assert(rv == 0);
	rv = fstat(fd2, &st2);
	assert(rv == 0);
	assert(st0.st_dev == st1.st_dev);
	assert(st0.st_ino == st1.st_ino);
	assert(st0.st_dev == st2.st_dev);
	assert(st0.st_ino == st2.st_ino);
	return 0;
}
  Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 Test that procthread-self gives correct TGIDPID.
 main thread 
 side thread 
  Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  Copyright (c) 2021 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 Test that proctask never contains "0".
 child 
 parent 
  Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 Test readlink procselfmap_files... with minimum address. 
	
	  va_max must be enough bigger than vm.mmap_min_addr, which is
	  64KB32KB by default. (depends on CONFIG_LSM_MMAP_MIN_ADDR)
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 2020 Bernd Edlinger <bernd.edlinger@hotmail.de>
  All rights reserved.
  Check whether proc$pidmem can be accessed without causing deadlocks
  when de_thread is blocked with ->cred_guard_mutex held.
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 2018 Dmitry V. Levin <ldv@altlinux.org>
  All rights reserved.
  Check whether PTRACE_GET_SYSCALL_INFO semantics implemented in the kernel
  matches userspace expectations.
 a sequence of architecture-agnostic syscalls 
 get the pid before PTRACE_TRACEME 
 cannot happen 
 unreachable 
 chdir 
 gettid 
 invalid PTRACE_SYSCALL_INFO_ op 
 cannot happen 
 the tracee is no more 
 the tracee is no more 
 cannot happen 
 entering chdir 
 entering gettid 
 entering exit_group 
 exiting chdir 
 exiting gettid 
 SPDX-License-Identifier: GPL-2.0
	
	  Allocate two contiguous pages. The first one is for read-write,
	  another is for read-only.
 Unsupported flags 
 A part of the buffer is read-only 
 Read-only buffer 
 Send signals in process-wide and per-thread queues 
 Dump signals one by one
 Dump all signals for one call 
	
	  Dump signal from the process-wide queue.
	  The number of signals is not multible to the buffer size
 SPDX-License-Identifier: GPL-2.0-or-later
  Author: Aleksa Sarai <cyphar@cyphar.com>
  Copyright (C) 2018-2019 SUSE LLC.
  Construct a test directory with the following structure:
  root
  |-- procexe -> procselfexe
  |-- procroot -> procselfroot
  |-- root
  |-- mnt [mountpoint]
  |   |-- self -> ..mnt
  |   `-- absself -> mnt
  |-- etc
  |   `-- passwd
  |-- creatlink -> newfile3
  |-- reletc -> etc
  |-- relsym -> etcpasswd
  |-- absetc -> etc
  |-- abssym -> etcpasswd
  |-- abscheeky -> cheeky
  `-- cheeky
      |-- absself -> 
      |-- self -> ....root
      |-- garbageself -> ....root
      |-- passwd -> ..cheeky..cheeky..etc..etcpasswd
      |-- abspasswd -> ..cheeky..cheeky..etc..etcpasswd
      |-- dotdotlink -> ............................etcpasswd
      `-- garbagelink -> ............................etcpasswd
 Unshare and make tmp a new directory. 
 Make the top-level directory. 
 A sub-directory which is actually used for tests. 
 There is no mountat(2), so use chdir. 
 RESOLVE_BENEATH 
 Attempts to cross dirfd should be blocked. 
 Only relative paths that stay inside dirfd should work. 
 Tricky paths should fail. 
 RESOLVE_IN_ROOT 
 All attempts to cross the dirfd will be scoped-to-root. 
 O_CREAT should handle trailing symlinks correctly. 
 RESOLVE_NO_XDEV 
 Crossing down into a mountpoint is disallowed. 
 Crossing up out of a mountpoint is disallowed. 
 Jumping to "" is ok, but later components cannot cross. 
 Magic-links are blocked since they can switch vfsmounts. 
 Except magic-link jumps inside the same vfsmount. 
 RESOLVE_NO_MAGICLINKS 
 Regular symlinks should work. 
 Magic-links should not work. 
 RESOLVE_NO_SYMLINKS 
 Normal paths should work. 
 Regular symlinks are blocked. 
 Trailing symlinks with NO_FOLLOW. 
 Auto-set O_PATH. 
 NOTE: We should be checking for CAP_SYS_ADMIN here... 
 SPDX-License-Identifier: GPL-2.0-or-later
  Author: Aleksa Sarai <cyphar@cyphar.com>
  Copyright (C) 2018-2019 SUSE LLC.
 Check openat2(2) support. 
 SPDX-License-Identifier: GPL-2.0-or-later
  Author: Aleksa Sarai <cyphar@cyphar.com>
  Copyright (C) 2018-2019 SUSE LLC.
  O_LARGEFILE is set to 0 by glibc.
  XXX: This is wrong on {mips, parisc, powerpc, sparc}.
 Normal struct. 
 Bigger struct, with zeroed out end. 
 TODO: Once expanded, check zero-padding. 
 Smaller than version-0 struct. 
 Bigger struct, with non-zero trailing bytes. 
				
				  Explicitly misalign the structure copying it with the given
				  (mis)alignment offset. The other data is set to be non-zero to
				  make sure that non-zero bytes outside the struct aren't checked
				 
				  This is effectively to check that is_zeroed_user() works.
 O_TMPFILE is incompatible with O_PATH and O_CREAT. 
 O_PATH only permits certain other flags to be set ... 
 ... and others are absolutely not permitted. 
 ->mode must only be set with O_{CREAT,TMPFILE}. 
 ->mode must only contain 0777 bits. 
 ->resolve flags must not conflict. 
 ->resolve must only contain RESOLVE_ flags. 
 currently unknown upper 32 bit rejected. 
 O_CLOEXEC isn't shown in F_GETFL. 
 O_CREAT is hidden from F_GETFL. 
 SPDX-License-Identifier: GPL-2.0-or-later
  Author: Aleksa Sarai <cyphar@cyphar.com>
  Copyright (C) 2018-2019 SUSE LLC.
 Construct a test directory with the following structure:
  root
  |-- a
  |   `-- c
  `-- b
 Make the top-level directory. 
 Swap @dirfd@a and @dirfd@b constantly. Parent must kill this process. 
 If the parent (the test process) dies, kill ourselves too. 
 Swap @a and @b. 
 escaped outside and got ENOENT... 
 unexpected error 
 we got an unexpected fd 
 Should be killed anyway, but might as well make sure. 
 SPDX-License-Identifier: GPL-2.0
 Multi-threaded 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  Test for remove_on_exec.
  Copyright (C) 2021, Google LLC.
 We need the latest siginfo from the kernel repo. 
		
		  Children normally retain their inherited event on exec; with
		  remove_on_exec, we'll remove their event, but the parent and
		  any other non-exec'd children will keep their events.
 Initialize sigtrap handler. 
 Initialize perf event. 
 Verify event propagates to fork'd child. 
 Child enables event. 
  Verify that event does _not_ propagate to fork+exec'd child; event enabled
  after fork+exec.
	
	  Non-exec child, to ensure exec does not affect inherited events of
	  other children.
 Block until parent enables event. 
 Child is running. 
 Wait for exec'd child to start spinning. 
 Now we can enable the event, knowing the child is doing work. 
 If the event propagated to the exec'd child, it will exit normally... 
 ... give time for event to trigger (in case of bug). 
 Should still be running. 
 Verify removal from child did not affect this task's event. 
 Should not hang! 
 Nor should it have affected the first child. 
  Verify that event does _not_ propagate to fork+exec'd child; event enabled
  before fork+exec.
	
	  The child may exit abnormally at any time if the event propagated and
	  a SIGTRAP is sent before the handler was set up.
 ... give time for event to trigger (in case of bug). 
 Should still be running. 
 Verify removal from child did not affect this task's event. 
 Should not hang! 
 Some forked with event disabled, rest with enabled. 
 ... give time for event to trigger (in case of bug). 
 All children should still be running. 
 Verify event is still alive. 
 For exec'd child. 
 Set up sigtrap handler in case we erroneously receive a trap. 
 Signal parent that we're starting to spin. 
 Should hang here until killed. 
 SPDX-License-Identifier: GPL-2.0
  Test for perf events with SIGTRAP across all threads.
  Copyright (C) 2021, Google LLC.
 We need the latest siginfo from the kernel repo. 
 Data shared between test body, threads, and signal handler. 
 Which threads still want a signal. 
 Sanity check number of signals received. 
 Variable to set breakpoint on. 
 First observed siginfo_t. 
 Unique value to check si_perf_data is correctly set from perf_event_attr::sig_data. 
 Children inherit events ... 
 ... but only cloned with CLONE_THREAD. 
 Required by sigtrap. 
 Request synchronous SIGTRAP on event. 
	
	  The data in siginfo_t we're interested in should all be the same
	  across threads.
 read 
 idempotent write 
 Initialize sigtrap handler. 
 Initialize perf event. 
 Spawn threads inheriting perf event. 
 Check enabled for parent. 
 Test that modification propagates to all inherited events. 
 Check enabled for parent. 
 Stress test event + signal handling. 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 splice(2) file to stdout. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2019 ARM Limited 
  The following handle_signal_ helpers are used by main default_handler
  and are meant to return true when signal is handled successfully:
  when false is returned instead, it means that the signal was somehow
  unexpected in that context and it was NOT handled; default_handler will
  take care of such unexpected situations.
 Mangling PC to avoid loops on original SIGILL 
 ->run was asserted NON-NULL in test_setup() already 
	
	  it's a bug in the test code when this assert fail:
	  if sig_trig was defined, it must have been used before getting here.
	
	  fake_sigreturn tests, which have sanity_enabled=1, set, at the very
	  last time, the token field to the SP address used to place the fake
	  sigframe: so token==0 means we never made it to the end,
	  segfaulting well-before, and the test is possibly broken.
	
	  Trying to narrow down the SEGV to the ones generated by Kernel itself
	  via arm64_notify_segfault(). This is a best-effort check anyway, and
	  the si_code check may need to change if this aspect of the kernel
	  ABI changes.
	
	  Some tests can lead to SEGV loops: in such a case we want to
	  terminate immediately exiting straight away; some others are not
	  supposed to outlive the signal handler code, due to the content of
	  the fake sigframe which caused the signal itself.
 Mangling PC to avoid loops on original BRK instr 
 uncatchable signals naturally skipped ... 
	
	  RT Signals default disposition is Term but they cannot be
	  generated by the Kernel in response to our tests; so just catch
	  them all and report them as UNEXPECTED signals.
 just in case...unblock explicitly all we need 
 just in case 
		
		  Checking for CPU required features using both the
		  auxval and the arm64 MRS Emulation to read sysregs.
 Perform test specific additional initialization 
 assert core invariants symptom of a rotten testcase 
 Default result is FAIL if test setup fails 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 ARM Limited
  Generic test wrapper for arm64 signal tests.
  Each test provides its own tde struct tdescr descriptor to link with
  this wrapper. Framework provides common helpers.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 ARM Limited
  Try to mangle the ucontext from inside a signal handler, toggling
  the execution state bit: this attempt must be spotted by Kernel and
  the test case is expected to be terminated via SEGV.
 This config should trigger a SIGSEGV by Kernel 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2021 ARM Limited
  Attempt to change the SVE vector length in a signal hander, this is not
  supported and is expected to segfault.
	
	  Enumerate up to SVE_VQ_MAX vector lengths
 Skip missing VLs 
 We need at least two VLs 
 Get a signal context with a SVE frame in it 
 No changes are supported; init left us at minimum VL so go to max 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 ARM Limited
  Try to mangle the ucontext from inside a signal handler, mangling the
  DAIF bits in an illegal manner: this attempt must be spotted by Kernel
  and the test case is expected to be terminated via SEGV.
	
	  This config should trigger a SIGSEGV by Kernel when it checks
	  the sigframe consistency in valid_user_regs() routine.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2021 ARM Limited
  Check that the SVE vector length reported in signal contexts is the
  expected one.
 Get a signal context which should have a SVE frame in it 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2021 ARM Limited
  Verify that the SVE register context in signal frames is set up as
  expected.
	
	  Enumerate up to SVE_VQ_MAX vector lengths
 Skip missing VLs 
 We need at least one VL 
 RDVL x16, #1 so we should have SVE regs; real data is TODO 
	
	  Get a signal context which should have a SVE frame and registers
	  in it.
 The actual size validation is done in get_current_context() 
		
		  TODO: the signal test helpers can't currently cope
		  with signal frames bigger than struct sigcontext,
		  skip VLs that will trigger that.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 ARM Limited
  Place a fake sigframe on the stack including a bad record overflowing
  the __reserved space: on sigreturn Kernel must spot this attempt and
  the test case is expected to be terminated via SEGV.
 just to fill the ucontext_t with something real 
 at least HDR_SZ + bad sized esr_context needed 
	
	  Use an esr_context to build a fake header with a
	  size greater then the free __reserved area minus HDR_SZ;
	  using ESR_MAGIC here since it is not checked for size nor
	  is limited to one instance.
	 
	  At first inject an additional normal esr_context
 and terminate properly 
	
	  now mess with fake esr_context size: leaving less space than
	  needed while keeping size value 16-aligned
	 
	  It must trigger a SEGV from Kernel on:
	 
	 	resv_sz - offset < sizeof(head)
 at first set the maximum good 16-aligned size 
 plus a bit more of 16-aligned sized stuff 
 and terminate properly 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 ARM Limited
  Try to mangle the ucontext from inside a signal handler, toggling
  the mode bit to escalate exception level: this attempt must be spotted
  by Kernel and the test case is expected to be termninated via SEGV.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 ARM Limited
  Try to mangle the ucontext from inside a signal handler, toggling
  the mode bit to escalate exception level: this attempt must be spotted
  by Kernel and the test case is expected to be termninated via SEGV.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 ARM Limited
  Place a fake sigframe on the stack including a BAD Unknown magic
  record: on sigreturn Kernel must spot this attempt and the test
  case is expected to be terminated via SEGV.
 just to fill the ucontext_t with something real 
 need at least 2HDR_SZ space: KSFT_BAD_MAGIC + terminator. 
	
	  use a well known NON existent bad magic...something
	  we should pretty sure won't be ever defined in Kernel
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2019 ARM Limited 
 Size will be rounded up to a multiple of 16 bytes 
 Either a bare sve_context or a sve_context followed by regs data 
 Walk till the end terminator verifying __reserved contents 
 Size is validated in validate_sve_context() 
			
			  This is a BAD magic header defined
			  artificially by a testcase and surely
			  unknown to the Kernel parse_user_sigframe().
			  It MUST cause a Kernel induced SEGV
			
			  A still unknown Magic: potentially freshly added
			  to the Kernel code and still unknown to the
			  tests.
  This function walks through the records inside the provided reserved area
  trying to find enough space to fit @need_sz bytes: if not enough space is
  available and an extra_context record is present, it throws away the
  extra_context record.
  It returns a pointer to a new header where it is possible to start storing
  our need_sz bytes.
  @shead: points to the start of reserved area
  @need_sz: needed bytes
  @resv_sz: reserved area size in bytes
  @offset: if not null, this will be filled with the offset of the return
 	    head pointer from @shead
  @return: pointer to a new head where to start storing need_sz bytes, or
 	    NULL if space could not be made available.
 not found a terminator...no need to update offset if any 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 ARM Limited
  Place a fake sigframe on the stack including a badly sized terminator
  record: on sigreturn Kernel must spot this attempt and the test case
  is expected to be terminated via SEGV.
 just to fill the ucontext_t with something real 
 at least HDR_SZ for the badly sized terminator. 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 ARM Limited
  Place a fake sigframe on the stack at a misaligned SP: on sigreturn
  Kernel must spot this attempt and the test case is expected to be
  terminated via SEGV.
 just to fill the ucontext_t with something real 
 Forcing sigframe on misaligned SP (16 + 3) 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 ARM Limited
  Try to mangle the ucontext from inside a signal handler, toggling
  the mode bit to escalate exception level: this attempt must be spotted
  by Kernel and the test case is expected to be termninated via SEGV.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 ARM Limited
  Try to mangle the ucontext from inside a signal handler, toggling
  the mode bit to escalate exception level: this attempt must be spotted
  by Kernel and the test case is expected to be termninated via SEGV.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 ARM Limited
  Place a fake sigframe on the stack including an additional FPSIMD
  record: on sigreturn Kernel must spot this attempt and the test
  case is expected to be terminated via SEGV.
 just to fill the ucontext_t with something real 
 Add a spurious fpsimd_context 
 and terminate 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 ARM Limited
  Place a fake sigframe on the stack missing the mandatory FPSIMD
  record: on sigreturn Kernel must spot this attempt and the test
  case is expected to be terminated via SEGV.
 just to fill the ucontext_t with something real 
 Just overwrite fpsmid_context 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 ARM Limited
  Try to mangle the ucontext from inside a signal handler, toggling
  the mode bit to escalate exception level: this attempt must be spotted
  by Kernel and the test case is expected to be termninated via SEGV.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 ARM Limited
  Try to mangle the ucontext from inside a signal handler, toggling
  the mode bit to escalate exception level: this attempt must be spotted
  by Kernel and the test case is expected to be termninated via SEGV.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2020 ARM Limited
 Check the validity of the tagged pointer 
 Proceed further for nonzero tags 
 Check the validity outside the range 
 Try to catch a excluded tag by a number of tries. 
 Check tag value 
 Try to catch a excluded tag by a number of tries. 
 Check tag value 
 Try to catch a excluded tag by a number of tries. 
		
		  Here tag byte can be between 0x0 to 0xF (full allowed range)
		  so no need to match so just verify if it is writable.
 Try to catch a excluded tag by a number of tries. 
 Here all tags exluded so tag value generated should be 0 
 Check the write validity of the untagged pointer 
 Register SIGSEGV handler 
 Set test plan 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2020 ARM Limited
 Compare the context for precise error 
 Adjust the pc by 4 
 Adjust the pc by 4 
 Initialize the file for mappable size 
 Initialize the file for mappable size 
 Enable address tagging ABI, mte error reporting mode and tag inclusion mask. 
 Get current mte mode 
 Disable PSTATE.TCO 
 Create a file in the tmpfs filesystem 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2020 ARM Limited
 page size - 1 0,  page size + 1  0
 Only mte enabled memory will allow tag insertion 
 Only mte enabled memory will allow tag insertion 
 Try to clear PROT_MTE property and verify it by tag checking 
 Try to clear PROT_MTE property and verify it by tag checking 
 Register signal handlers 
 Set test plan 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2020 ARM Limited
 Insert same data in all the pages 
 Tagged pages should not merge 
 Register signal handlers 
 Set test plan 
 Enable KSM 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2020 ARM Limited
 page size - 1 0,  page size + 1  0
 Do copy on write 
 Wait for child process to terminate 
 Only mte enabled memory will allow tag insertion 
 Register SIGSEGV handler 
 Set test plan 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2020 ARM Limited
 Copy from file into buffer with valid tag 
 Verify same pattern is read 
 Tag the next half of memory with different value 
 Copy from file into buffer with invalid tag 
	
	  Accessing user memory in kernel with invalid tag should fail in sync
	  mode without fault but may not fail in async mode as per the
	  implemented MTE userspace support in Arm64 kernel.
 Register signal handlers 
 Set test plan 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2020 ARM Limited
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2020 ARM Limited
 page size - 1 0,  page size + 1  0
 Set some value in tagged memory 
 Check the buffer whether it is filled. 
 Set some value in tagged memory and make the buffer underflow 
 Check whether the buffer is filled 
 There were no fault so the underflow area should be filled 
 Imprecise fault should occur otherwise return error 
			
			  The imprecise fault is checked after the write to the buffer,
			  so the underflow area before the fault should be filled.
 Precise fault should occur otherwise return error 
 Underflow area should not be filled 
 Set some value in tagged memory and make the buffer underflow 
 Check whether the buffer is filled 
 There were no fault so the overflow area should be filled 
 Imprecise fault should occur otherwise return error 
			
			  The imprecise fault is checked after the write to the buffer,
			  so the overflow area should be filled before the fault.
 Precise fault should occur otherwise return error 
 Underflow area should not be filled 
 Set some value in memory and copy
 Check the buffer whether it is filled. 
 check initial tags for anonymous mmap 
 check initial tags for file mmap 
 Register SIGSEGV handler 
 Set test plan 
 Buffer by byte tests 
 Check buffer underflow with underflow size as 16 
 Check buffer underflow with underflow size as page size 
 Check buffer overflow with overflow size as 16 
 Buffer by block tests 
 Initial tags are supposed to be 0 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2015-2020 ARM Limited.
  Original author: Dave Martin <Dave.Martin@arm.com>
	
	  Enumerate up to SVE_VQ_MAX vector lengths
 Print out the vector lengths in ascending order: 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2015-2019 ARM Limited.
  Original author: Dave Martin <Dave.Martin@arm.com>
 vector length 
 command 
 same as sh(1) command-not-executable error 
 same as sh(1) builtin incorrect-usage 
 same as sh(1) builtin incorrect-usage 
 same as sh(1) not-found error 
 same as sh(1) not-executable error 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2015-2021 ARM Limited.
  Original author: Dave Martin <Dave.Martin@arm.com>
 <linuxelf.h> and <sysauxv.h> don't like each other, so: 
 Validate setting and getting the inherit flag 
 First set the flag 
	
	  Read back the new register state and verify that we have
	  set the flags we expected.
 Now clear 
 Validate attempting to set the specfied VL via ptrace 
 Check if the VL is supported in this process 
 If the VL is not supported then a supported VL will be returned 
 Set the VL by doing a set with no register payload 
	
	  Read back the new register state and verify that we have the
	  same VL that we got from prctl() on ourselves.
 Access the FPSIMD registers via the SVE regset 
 New process should start with FPSIMD registers only 
 Try to set a known FPSIMD state via PT_REGS_SVE 
 Verify via the FPSIMD regset 
 Validate attempting to set SVE data and read SVE data 
 Set up some data and write it out 
 TODO: Generate a valid FFR pattern 
 Read the data back 
 We might read more data if there's extensions we don't know 
 Validate attempting to set SVE data and read SVE data 
 Set up some data and write it out 
 Read the data back 
		
		  Z regs are stored endianness invariant, this won't
		  work for big endian
 Attach to the child 
		
		  This should never happen but it's hard to flag in
		  the framework.
 bust group-stop 
 FPSIMD via SVE regset 
 prctl() flags 
 Step through every possible VQ 
 First, try to set this vector length 
 If the VL is supported validate data setget 
 SPDX-License-Identifier: GPL-2.0-only
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2021 ARM Limited.
  Original author: Mark Brown <broonie@kernel.org>
 Start a new process and return the vector length it sees 
 Child: put vector length on the pipe 
		
		  Replace stdout with the pipe, errors to stderr from
		  here as kselftest prints to stdout.
 exec() a new binary which puts the VL on stdout 
 Parent; wait for the exit status from the child & verify it 
  Verify that we can read the default VL via proc, checking that it
  is set in a freshly spawned child.
 Is this the actual default seen by new processes? 
 Verify that we can write a minimum value and have it take effect 
 What was the new value? 
 Did it take effect in a new process? 
 Verify that we can write a maximum value and have it take effect 
 -1 is accepted by the proc interface as the maximum VL 
 What was the new value? 
 Did it take effect in a new process? 
 Can we read back a VL from prctl? 
 Mask out any flags 
 Is that what we can read back directly? 
 Does the prctl let us set the VL we already have? 
 Can we set a new VL for this process? 
 Try to set the minimum VL 
 Try to set the maximum VL 
 The _INHERIT flag should not be present when we read the VL 
 If we didn't request it a new VL shouldn't affect the child 
 Ensure the default VL is different 
 Check that the child has the default we just set 
 If we didn't request it a new VL shouldn't affect the child 
 The _INHERIT flag should be present when we read the VL 
 Ensure the default VL is different 
 Check that the child inherited our VL 
 _ONEXEC takes effect only in the child process 
 Set a known value for the default and our current VL 
 Set a different value for the child to have on exec 
 Our current VL should stay the same 
 Check that the child inherited our VL 
 For each VQ verify that setting via prctl() does the right thing 
 Attempt to set the VL 
 Check that we actually have the reported new VL 
 Was that the VL we asked for? 
 Should round up to the minimum VL if below it 
 Should round down to maximum VL if above it 
 Otherwise we should've rounded down 
	
	  The defaultminmax tests must be first and in this order
	  to provide data for other tests.
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2020 ARM Limited
	 don't try to execute illegal (unimplemented) instructions) caller
	  should have checked this and keep worker simple
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2020 ARM Limited
 output is encoded in the upper 32 bits 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2020 ARM Limited
  The kernel sets TBID by default. So bits 55 and above should remain
  untouched no matter what.
  The VA space size is 48 bits. Bigger is opt-in.
 data key instructions are not in NOP space. This prevents a SIGILL  \
 generic key instructions are not in NOP space. This prevents a SIGILL  \
	
	  pin this process and all its children to a single CPU, so it can also
	  guarantee a context switch with its child
 child
	
	  wait for the worker to finish, so that read() reads all data
	  will also context switch with worker so that this function can be used
	  for context switch tests
 check that a corrupted PAC results in SIGSEGV or SIGILL 
  There are no separate pac and aut controls so checking only the pac
  instructions is sufficient
 generic and data key instructions are not in NOP space. This prevents a SIGILL 
	
	  In Linux the PAC field can be up to 7 bits wide. Even if keys are
	  different, there is about 5% chance for PACs to collide with
	  different addresses. This chance rapidly increases with fewer bits
	  allocated for the PAC (e.g. wider address). A comparison of the keys
	  directly will be more reliable.
	  All signed values need to be different at least once out of n
	  attempts to be certain that the keys are different
  fork() does not change keys. Only exec() does so call a worker program.
  Its only job is to sign a value and report back the resutls
 generic and data key instructions are not in NOP space. This prevents a SIGILL 
 will context switch with a process with different keys at least once 
 will context switch with a process with different keys at least once 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019  Arm Limited
  Original author: Dave Martin <Dave.Martin@arm.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019,2021  Arm Limited
  Original author: Dave Martin <Dave.Martin@arm.com>
 zap BTYPE so that resuming the faulting code will work 
 Branch Target exceptions should only happen in BTI binaries: 
 Gross hack for finding AT_HWCAP2 from the initial process stack: 
 start of environment 
 step over environment 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019  Arm Limited
  Original author: Dave Martin <Dave.Martin@arm.com>
 SPDX-License-Identifier: GPL-2.0
 ignore libudev messages 
 ignore uevents we didn't trigger 
 If logging is enabled dump the received uevent. 
 Check whether we have been orphaned. 
 Make sure that we go away when our parent dies. 
	 Trigger 10 uevents to account for the case where the kernel might
	  drop some.
	 Wait for 2 seconds before considering this failed. This should be
	  plenty of time for the kernel to deliver the uevent even under heavy
	  load.
 success 
 error 
	
	  Setup:
	  - Open uevent listening socket in initial network namespace owned by
	    initial user namespace.
	  - Trigger uevent in initial network namespace owned by initial user
	    namespace.
	  Expected Result:
	  - uevent listening socket receives uevent
	
	  Setup:
	  - Open uevent listening socket in non-initial network namespace
	    owned by initial user namespace.
	  - Trigger uevent in initial network namespace owned by initial user
	    namespace.
	  Expected Result:
	  - uevent listening socket receives uevent
	
	  Setup:
	  - unshare user namespace
	  - Open uevent listening socket in initial network namespace
	    owned by initial user namespace.
	  - Trigger uevent in initial network namespace owned by initial user
	    namespace.
	  Expected Result:
	  - uevent listening socket receives uevent
	
	  Setup:
	  - Open uevent listening socket in non-initial network namespace
	    owned by non-initial user namespace.
	  - Trigger uevent in initial network namespace owned by initial user
	    namespace.
	  Expected Result:
	  - uevent listening socket receives no uevent
	
	  Setup:
	  - Open uevent listening socket in initial network namespace
	    owned by initial user namespace.
	  - unshare network namespace
	  - Trigger uevent in initial network namespace owned by initial user
	    namespace.
	  Expected Result:
	  - uevent listening socket receives uevent
	
	  Setup:
	  - Open uevent listening socket in initial network namespace
	    owned by initial user namespace.
	  - unshare user namespace
	  - Trigger uevent in initial network namespace owned by initial user
	    namespace.
	  Expected Result:
	  - uevent listening socket receives uevent
	
	  Setup:
	  - Open uevent listening socket in initial network namespace
	    owned by initial user namespace.
	  - unshare user namespace
	  - unshare network namespace
	  - Trigger uevent in initial network namespace owned by initial user
	    namespace.
	  Expected Result:
	  - uevent listening socket receives uevent
 SPDX-License-Identifier: GPL-2.0-only
  entry_from_vm86.c - tests kernel entries from vm86 mode
  Copyright (c) 2014-2015 Andrew Lutomirski
  This exercises a few paths that need to special-case vm86 mode.
 addressing via displacements 
 addressing via registers 
 register operands, only for smsw 
 Returns false if the test was skipped. 
 Initialize variables with arbitrary values 
 UMIP -- exit with INT3 unless kernel emulation did not trap #GP 
 Results from displacement-only addressing 
 Results from register-indirect addressing 
 Results when using register operands 
 Use the end of the page as our stack. 
 Looks like RPL = 0 
 #BR -- should deliver SIG??? 
	
	  SYSENTER -- should cause #GP or #UD depending on CPU.
	  Expected return type -1 means that we shouldn't validate
	  the vm86 return value.  This will avoid problems on non-SEP
	  CPUs.
	
	  SYSCALL would be a disaster in VM86 mode.  Fortunately,
	  there is no kernel that both enables SYSCALL and sets
	  EFER.SCE, so it's #UD on all systems.  But vm86 is
	  buggy (or has a "feature"), so the SIGILL will actually
	  be delivered.
 STI with VIP set 
 POPF with VIP set but IF clear: should not trap 
 POPF with VIP set and IF set: should trap 
 POPF with VIP clear and IF set: should not trap 
 INT3 -- should cause #BP 
 INT80 -- should exit with "INTx 0x80" 
 UMIP -- should exit with INTx 0x80 unless UMIP was not disabled 
 Execute a null pointer 
 Make sure nothing explodes if we fork. 
 SPDX-License-Identifier: GPL-2.0-only
  syscall_arg_fault.c - tests faults 32-bit fast syscall stack args
  Copyright (c) 2015 Andrew Lutomirski
	
	  KVM has some bugs that can cause us to stop making progress.
	  detect them and complain, but don't infinite loop or fail the
	  test.
 The trap was on SYSCALL or SYSENTER 
 one of the ud2 instructions faulted 
 Our sigaltstack scratch space. 
	
	  The actual exception can vary.  On Atom CPUs, we get #SS
	  instead of #PF when the vDSO fails to access the stack when
	  ESP is too close to 2^32, and #SS causes SIGBUS.
	
	  Exercise another nasty special case.  The 32-bit SYSCALL
	  and SYSENTER instructions (even in compat mode) each
	  clobber one register.  A Linux system call has a syscall
	  number and six arguments, and the user stack pointer
	  needs to live in some register on return.  That means
	  that we need eight registers, but SYSCALL and SYSENTER
	  only preserve seven registers.  As a result, one argument
	  ends up on the stack.  The stack is user memory, which
	  means that the kernel can fail to read it.
	 
	  The 32-bit fast system calls don't have a defined ABI:
	  we're supposed to invoke them through the vDSO.  So we'll
	  fudge it: we set all regs to invalid pointer values and
	  invoke the entry instruction.  The return will fail no
	  matter what, and we completely lose our program state,
	  but we can fix it up with a signal handler.
 make sure we recover cleanly 
 make sure we recover cleanly 
 SPDX-License-Identifier: GPL-2.0-only
  sigreturn.c - tests for x86 sigreturn(2) and exit-to-userspace
  Copyright (c) 2014-2015 Andrew Lutomirski
  This is a series of tests that exercises the sigreturn(2) syscall and
  the IRET  SYSRET paths in the kernel.
  For now, this focuses on the effects of unusual CS and SS values,
  and it has a bunch of tests to make sure that ESPRSP is restored
  properly.
  The basic idea behind these tests is to raise(SIGUSR1) to create a
  sigcontext frame, plug in the values to be tested, and then return,
  which implicitly invokes sigreturn(2) and programs the user context
  as desired.
  For tests for which we expect sigreturn and the subsequent return to
  user mode to succeed, we return to a short trampoline that generates
  SIGTRAP so that the meat of the tests can be ordinary C code in a
  SIGTRAP handler.
  The inner workings of each test is documented below.
  Do not run on outdated, unpatched kernels at risk of nasty crashes.
 Pull in AR_xyz defines. 
  Copied from asmucontext.h, as asmucontext.h conflicts badly with the glibc
  headers.
  UC_SIGCONTEXT_SS will be set when delivering 64-bit or x32 signals on
  kernels that save SS in the sigcontext.  All kernels that set
  UC_SIGCONTEXT_SS will correctly restore at least the low 32 bits of esp
  regardless of SS (i.e. they implement espfix).
  Kernels that set UC_SIGCONTEXT_SS will also set UC_STRICT_RESTORE_SS
  when delivering a signal that came from 64-bit code.
  Sigreturn restores SS as follows:
  if (saved SS is valid || UC_STRICT_RESTORE_SS is set ||
      saved CS is not 64-bit)
          new SS = saved SS  (will fail IRET and signal if invalid)
  else
          new SS = a flat 32-bit data segment
  In principle, this test can run on Linux emulation layers (e.g.
  Illumos "LX branded zones").  Solaris-based kernels reserve LDT
  entries 0-5 for their own internal purposes, so start our LDT
  allocations above that reservation.  (The tests don't pass on LX
  branded zones, but at least this lets them run.)
 An aligned stack accessible through some of our segments. 
  An aligned int3 instruction used as a trampoline.  Some of the tests
  want to fish out their ss values, so this trampoline copies ss to eax
  before the int3.
  At startup, we prepapre:
  - ldt_nonexistent_sel: An LDT entry that doesn't exist (all-zero
    descriptor or out of bounds).
  - code16_sel: A 16-bit LDT code segment pointing to int3.
  - data16_sel: A 16-bit LDT data segment pointing to stack16.
  - npcode32_sel: A 32-bit not-present LDT code segment pointing to int3.
  - npdata32_sel: A 32-bit not-present LDT data segment pointing to stack16.
  - gdt_data16_idx: A 16-bit GDT data segment pointing to stack16.
  - gdt_npdata32_idx: A 32-bit not-present GDT data segment pointing to
    stack16.
  For no particularly good reason, xyz_sel is a selector value with the
  RPL and LDT bits filled in, whereas xyz_idx is just an index into the
  descriptor table.  These variables will be zero if their respective
  segments could not be allocated.
 Code, not conforming 
 Data, grow-up 
 Code, not conforming 
 Data, grow-up 
 Data, grow-up 
		
		  This probably indicates vulnerability to CVE-2014-8133.
		  Merely getting here isn't definitive, though, and we'll
		  diagnose the problem for real later on.
 Data, grow-up 
		
		  As a hardening measure, newer kernels don't allow this.
 State used by our signal handlers. 
 Instructions for the SIGUSR1 handler. 
 Abstractions for some 32-bit vs 64-bit differences. 
  Checks a given selector for its code bitness or returns -1 if it's not
  a usable code segment selector.
 Not code. 
 Unknown bitness. 
  Checks a given selector for its code bitness or returns -1 if it's not
  a usable code segment selector.
 Number of errors in the current test case. 
		
		  This happens on Linux 4.1.  The rest will fail, too, so
		  return now to reduce the noise.
 UC_STRICT_RESTORE_SS is set iff we came from 64-bit mode. 
		
		  DOSEMU was written before 64-bit sigcontext had SS, and
		  it tries to figure out the signal source SS by looking at
		  the physical register.  Make sure that keeps working.
  SIGUSR1 handler.  Sets CS and SS as requested and points IP to the
  int3 trampoline.  Sets SP to a large known value so that we can see
  whether the value round-trips back to user mode correctly.
	
	  Make sure the kernel doesn't inadvertently use DS or ES-relative
	  accesses in a region where user DS or ES is loaded.
	 
	  Skip this for 64-bit builds because long mode doesn't care about
	  DS and ES and skipping it increases test coverage a little bit,
	  since 64-bit kernels can still run the 32-bit build.
 The asm code does this. 
  Called after a successful sigreturn (via int3) or from a failed
  sigreturn (directly by kernel).  Restores our state so that the
  original raise(SIGUSR1) returns.
 Sanity check failure. 
			
			  DOSEMU transitions from 32-bit to 64-bit mode by
			  adjusting sigcontext, and it requires that this work
			  even if the saved SS is bogus.
 Tests recovery if !UC_STRICT_RESTORE_SS 
 We can't do the rest. 
 Return.  The kernel should recover without sending another signal. 
 Finds a usable code segment of the requested bitness. 
	
	  Check that each register had an acceptable value when the
	  int3 trampoline was invoked.
 don't care 
			
			  If we were using a 16-bit stack segment, then
			  the kernel is a bit stuck: IRET only restores
			  the low 16 bits of ESPRSP if SS is 16-bit.
			  The kernel uses a hack to restore bits 31:16,
			  but that hack doesn't help with bits 63:32.
			  On Intel CPUs, bits 63:32 end up zeroed, and, on
			  AMD CPUs, they leak the high bits of the kernel
			  espfix64 stack pointer.  There's very little that
			  the kernel can do about it.
			 
			  Similarly, if we are returning to a 32-bit context,
			  the CPU will often lose the high 32 bits of RSP.
 Sanity check on the kernel 
 X86_TRAP_IRET 
		
		  This also implicitly tests UC_STRICT_RESTORE_SS:
		  We check that these signals set UC_STRICT_RESTORE_SS and,
		  if UC_STRICT_RESTORE_SS doesn't cause strict behavior,
		  then we won't get SIGSEGV.
 Our sigaltstack scratch space. 
 Easy cases: return to a 32-bit SS in each possible CS bitness. 
	
	  Test easy espfix cases: return to a 16-bit LDT SS in each possible
	  CS bitness.  NB: with a long mode CS, the SS bitness is irrelevant.
	 
	  This catches the original missing-espfix-on-64-bit-kernels issue
	  as well as CVE-2014-8134.
		
		  For performance reasons, Linux skips espfix if SS points
		  to the GDT.  If we were able to allocate a 16-bit SS in
		  the GDT, see if it leaks parts of the kernel stack pointer.
		 
		  This tests for CVE-2014-8133.
 Nasty ABI case: check SS corruption handling. 
	
	  We're done testing valid sigreturn cases.  Now we test states
	  for which sigreturn itself will succeed but the subsequent
	  entry to user mode will fail.
	 
	  Depending on the failure mode and the kernel bitness, these
	  entry failures can generate SIGSEGV, SIGBUS, or SIGILL.
 32-bit kernels do this 
 Easy failures: invalid SS, resulting in #GP(0) 
 These fail because SS isn't a data segment, resulting in #GP(SS) 
 Try to return to a not-present code segment, triggering #NP(SS). 
	
	  Try to return to a not-present but otherwise valid data segment.
	  This will cause IRET to fail with #SS on the espfix stack.  This
	  exercises CVE-2014-9322.
	 
	  Note that, if espfix is enabled, 64-bit Linux will lose track
	  of the actual cause of failure and report #GP(0) instead.
	  This would be very difficult for Linux to avoid, because
	  espfix64 causes IRET failures to be promoted to #DF, so the
	  original exception frame is never pushed onto the stack.
	
	  Try to return to a not-present but otherwise valid data
	  segment without invoking espfix.  Newer kernels don't allow
	  this to happen in the first place.  On older kernels, though,
	  this can trigger CVE-2014-9322.
 SPDX-License-Identifier: GPL-2.0
  iopl.c - Test case for a Linux on Xen 64-bit bug
  Copyright (c) 2015 Andrew Lutomirski
 X86_FLAGS_IF 
 X86_FLAGS_IF 
  Returns whether it managed to disable interrupts.
 Probe for iopl support.  Note that iopl(0) works even as nonroot. 
 Make sure that CLISTI are blocked even with IOPL level 3 
 Establish an IO bitmap to test the restore 
 Restore our original state prior to starting the fork test. 
	
	  Verify that IOPL emulation is disabled and the IO bitmap still
	  works.
 Drop the IO bitmap 
 Test the capability checks. 
 Trivial program to check that compilation with certain flags is working. 
 SPDX-License-Identifier: GPL-2.0 
  mov_ss_trap.c: Exercise the bizarre side effects of a watchpoint on MOV SS
  This does MOV SS from a watchpointed address followed by various
  types of kernel entries.  A MOV SS that hits a watchpoint will queue
  up a #DB trap but will not actually deliver that trap.  The trap
  will be delivered after the next instruction instead.  The CPU's logic
  seems to be:
   - Any fault: drop the pending #DB trap.
   - INT $N, INT3, INTO, SYSCALL, SYSENTER: enter the kernel and then
     deliver #DB.
   - ICEBP: enter the kernel but do not deliver the watchpoint trap
   - breakpoint: only one #DB is delivered (phew!)
  There are plenty of ways for a kernel to handle this incorrectly.  This
  test tries to exercise all the cases.
  This should mostly cover CVE-2018-1087 and CVE-2018-8897.
 G0 
 RW0 = read or write 
 LEN0 = 2 bytes 
 G1, RW1 = insn 
 Some emulators (e.g. QEMU TCG) don't emulate ICEBP. 
	
	  INT $1: if #DB has DPL=3 and there isn't special handling,
	  then the kernel will die.
	
	  In principle, we should test 32-bit SYSCALL as well, but
	  the calling convention is so unpredictable that it's
	  not obviously worth the effort.
		
		  Toggle the high bit of RSP to make it noncanonical to
		  strengthen this test on non-SMAP systems.
	
	  Invoking SYSENTER directly breaks all the rules.  Just handle
	  the SIGSEGV.
 Clear EBP first to make sure we segfault cleanly. 
 We're unreachable here.  SYSENTER forgets RIP. 
 compat getpid 
 SPDX-License-Identifier: GPL-2.0
  ldt_gdt.c - Test cases for LDT and GDT access
  Copyright (c) 2015 Andrew Lutomirski
 Points to an array of 1024 ints, each holding its own index. 
 Use to delete GDT entry 
 The SDM says "bits 19:16 are undefined".  Thanks. 
	
	  NB: Different Linux versions do different things with the
	  accessed bit in set_thread_area().
 No point testing set_thread_area in a 64-bit build 
 Should work in the GDT, too. 
 Code, not conforming 
 Test entry_number too high. 
 Test deletion and actions mistakeable for deletion. 
  0: thread is idle
  1: thread armed
  2: thread should clear LDT entry 0
  3: thread should exit
 should never fail 
 clear LDT entry 0 
 If ftx == 2, set it to zero.  If ftx == 100, quit. 
  The UAPI header calls this 'struct sigaction', which conflicts with
  glibc.  Sigh.
 the real type is nasty 
		
		  glibc has a nasty bug: it sometimes writes garbage to
		  sa_restorer.  This interacts quite badly with anything
		  that fiddles with SS because it can trigger legacy
		  stack switching.  Patch it up.  See:
		 
		  https:sourceware.orgbugzillashow_bug.cgi?id=21269
 64-bit glibc works fine. 
 True 32-bit kernels send SIGILL instead of SIGSEGV on IRET faults. 
 Make sure the thread is ready after the last test. 
 Data 
 Arm the thread. 
 Go! 
		
		  On success, modify_ldt will segfault us synchronously,
		  and we'll escape via siglongjmp.
 Kill the thread. 
	
	  Older kernel versions did inherit the LDT on exec() which is
	  wrong because exec() starts from a clean state.
 Code, not conforming 
 exec failed 
 Data, grow-up
 64-bit only system -- we can't use set_thread_area 
 Test DS 
 Should invalidate ds 
 Test ES 
 Should invalidate es 
 Test FS 
 Should invalidate fs 
 Restore FSBASE for glibc 
 Test GS 
 Should invalidate gs 
 Restore GSBASE for glibc 
 SPDX-License-Identifier: GPL-2.0-only
  Trivial program to check that we have a valid 64-bit build environment.
  Copyright (c) 2015 Andy Lutomirski
 SPDX-License-Identifier: GPL-2.0-only
  check_initial_reg_state.c - check that execve sets the correct state
  Copyright (c) 2014-2016 Andrew Lutomirski
 SPDX-License-Identifier: GPL-2.0
 Test truncation to zero (round-to-nearest would give 1 here) 
	 SIGILL triggers on 32-bit kernels wo fisttp emulation
	  when run with "no387 nofxsr". Other signals are caught
	  just in case.
 SPDX-License-Identifier: GPL-2.0-only
  vdso_restorer.c - tests vDSO-based signal restore
  Copyright (c) 2015 Andrew Lutomirski
  This makes sure that sa_restorer == NULL keeps working on 32-bit
  configurations.  Modern glibc doesn't use it under any circumstances,
  so it's easy to overlook breakage.
  64-bit userspace has never supported sa_restorer == NULL, so this is
  32-bit only.
 Open-code this -- the headers are too messy to easily use them. 
 request kernel-provided restorer 
 SPDX-License-Identifier: GPL-2.0
	 SIGILL triggers on 32-bit kernels wo fcomi emulation
	  when run with "no387 nofxsr". Other signals are caught
	  just in case.
 If fcmovCC() returns 1.0, the move wasn't done 
 SPDX-License-Identifier: GPL-2.0
 Bitness-agnostic defines for user_regs_struct fields. 
  Helper to invoke int80 with controlled regs and capture the final regs.
  Nasty helper to invoke AT_SYSINFO (i.e. __kernel_vsyscall) with
  controlled regs and capture the final regs.  This is so nasty that it
  crashes my copy of gdb :)
 gettid 
 kill 
 Wait for SIGSTOP. 
	
	  This does exactly what it appears to do if syscall is int80 or
	  SYSCALL64.  For SYSCALL32 or SYSENTER, though, this is highly
	  magical.  It needs to work so that ptrace and syscall restart
	  work as expected.
 Wait for SIGSTOP. 
 We should be stopped at pause(2) entry. 
 Interrupt it. 
 Advance.  We should be stopped at exit. 
 Poke the regs back in.  This must not break anything. 
 Catch the (ignored) SIGUSR1. 
 The next event should be pause(2) again. 
 We should be stopped at pause(2) entry. 
 Kill it. 
 SPDX-License-Identifier: GPL-2.0-only
  sigreturn.c - tests that x86 avoids Intel SYSRET pitfalls
  Copyright (c) 2014-2016 Andrew Lutomirski
 State used by our signal handlers. 
 Set IP and CX to match so that SYSRET can happen. 
 R11 and EFLAGS should already match. 
	
	  When the kernel returns from a slow-path syscall, it will
	  detect whether SYSRET is appropriate.  If it incorrectly
	  thinks that SYSRET is appropriate when RIP is noncanonical,
	  it'll crash on Intel CPUs.
 One extra test to check that we didn't screw up the mremap logic. 
 These are the interesting cases. 
 SPDX-License-Identifier: GPL-2.0-only
  sysret_ss_attrs.c - test that syscalls return valid hidden SS attributes
  Copyright (c) 2015 Andrew Lutomirski
  On AMD CPUs, SYSRET can return with a valid SS descriptor with with
  the hidden attributes set to an unusable state.  Make sure the kernel
  doesn't let this happen.
	
	  Do our best to cause sleeps on this CPU to exit the kernel and
	  re-enter with SS = 0.
	
	  Start a busy-looping thread on the same CPU we're on.
	  For simplicity, just stick everything to CPU 0.  This will
	  fail in some containers, but that's probably okay.
		
		  Go to sleep and return using sysret (if we're 64-bit
		  or we're 32-bit on AMD on a 64-bit kernel).  On AMD CPUs,
		  SYSRET doesn't fix up the cached SS descriptor, so the
		  kernel needs some kind of workaround to make sure that we
		  end the system call with a valid stack segment.  This
		  can be a confusing failure because the SS selector
		  is the same regardless.
		
		  On 32-bit, just doing a syscall through glibc is enough
		  to cause a crash if our cached SS descriptor is invalid.
		  On 64-bit, it's not, so try extra hard.
 SPDX-License-Identifier: GPL-2.0-only
  32-bit syscall ABI conformance test.
  Copyright (c) 2015 Denys Vlasenko
  Can be built statically:
  gcc -Os -Wall -static -m32 test_syscall_vdso.c thunks_32.S
 register did not change 
			
			  Non-INT80 syscall entrypoints are allowed to clobber R8+ regs:
			  either clear them to 0, or for R11, load EFLAGS.
			
			  INT80 syscall entrypoint can be used by
			  64-bit programs too, unlike SYSCALLSYSENTER.
			  Therefore it must preserve R12+
			  (they are callee-saved registers in 64-bit C ABI).
			 
			  Starting in Linux 4.17 (and any kernel that
			  backports the change), R8..11 are preserved.
			  Historically (and probably unintentionally), they
			  were clobbered or zeroed.
 bytes 
 Carry Flag 
 Bit 1 - always on 
 Parity Flag 
 Auxiliary carry Flag 
 Zero Flag 
 Sign Flag 
 Trap Flag 
 Interrupt Flag 
 Direction Flag 
 Overflow Flag 
 IO Privilege Level (2 bits) 
 IO Privilege Level (2 bits) 
 Nested Task 
 Resume Flag 
 Virtual Mode 
 Alignment CheckAccess Control 
 Virtual Interrupt Flag 
 Virtual Interrupt Pending 
 CPUID detection 
print_regs64();
 Try 6-arg syscall: pselect. It should return quickly 
 PSELECT 
 ebx  arg1 
 ecx  arg2 
 edx  arg3 
 esi  arg4 
 edi  arg5 
 %ebp arg6 
 set almost all flags 
 except TF, IOPL, NT, RF, VM, AC, VIF, VIP 
 Check that registers are not clobbered 
 ebx  arg1 
 ecx  arg2 
 edx  arg3 
 esi  arg4 
 edi  arg5 
 %ebp arg6 
print_regs64();
	
	  On paravirt kernels, flags are not preserved across syscalls.
	  Thus, we do not consider it a bug if some are changed.
	  We just show ones which do.
 child 
 parent 
 paranoia 
		
		  Note: we do not inject sig = WSTOPSIG(status).
		  We probably should, but careful: do not inject SIGTRAP
		  generated by syscall entryexit stops.
		  That kills the child.
sig);
	 This only works for non-static builds:
	  syscall_addr = dlsym(dlopen("linux-gate.so.1", RTLD_NOW), "__kernel_vsyscall");
 SPDX-License-Identifier: GPL-2.0-only
  unwind_vdso.c - tests unwind info for AT_SYSINFO in the vDSO
  Copyright (c) 2014-2015 Andrew Lutomirski
  This tests __kernel_vsyscall's unwind info.
 We need getauxval(). 
 trap source 
 -1 until we hit the trap source 
 Not there yet 
 Here we are. 
 Find the return address. 
 Not there yet 
 Force symbol binding without TF set. 
		
		  The most likely cause of this is that you're on Debian or
		  a Debian-based distro, you're missing libc6-i686, and you're
		  affected by libc19006 (https:sourceware.orgPR19006).
 New enough libc 
 SPDX-License-Identifier: GPL-2.0-only
  32-bit test to check vDSO mremap.
  Copyright (c) 2016 Dmitry Safonov
  Suggested-by: Andrew Lutomirski
  Can be built statically:
  gcc -Os -Wall -static -m32 test_mremap_vdso.c
 Searching for memory location where to remap 
 Retry with larger 
 Simpler than parsing ELF header 
 Glibc is likely to explode now - exit with raw syscall 
 __x86_64__ 
 SPDX-License-Identifier: GPL-2.0-only
  Trivial program to check that we have a valid 32-bit build environment.
  Copyright (c) 2015 Andy Lutomirski
 SPDX-License-Identifier: GPL-2.0
  ioperm.c - Test case for ioperm(2)
  Copyright (c) 2015 Andrew Lutomirski
	
	  Probe for ioperm support.  Note that clearing ioperm bits
	  works even as nonroot.
 Make sure that fork() preserves ioperm. 
 Verify that the child dropping 0x80 did not affect the parent 
 Test the capability checks. 
 SPDX-License-Identifier: GPL-2.0
 err() exits and will not return 
	
	  CPUID.1:ECX.XSAVE[bit 26] enumerates general
	  support for the XSAVE feature set, including
	  XGETBV.
	
	  EBX enumerates the size (in bytes) required by the XSAVE
	  instruction for an XSAVE area containing all the user state
	  components corresponding to bits currently set in XCR0.
	 
	  Stash that off so it can be used to allocate buffers later.
	
	  eax: XTILEDATA state component size
	  ebx: XTILEDATA state component offset in user buffer
 The helpers for managing XSAVE buffer and tile states: 
 XSAVE buffer should be 64B-aligned. 
 XSTATE_BV is at the beginning of the header: 
 XSTATE_BV is at the beginning of the header: 
	
	  Ensure that 'data' is never 0.  This ensures that
	  the registers are never in their initial configuration
	  and thus never tracked as being in the init state.
 See 'struct _fpx_sw_bytes' at sigcontext.h 
 N.B. The struct's field name varies so read from the offset. 
 Work around printf() being unsafe in signals: 
  Signal handler for when AMX is used but
  permission has not been obtained.
 Reset the signal message buffer: 
	
	  Without permission, the signal XSAVE buffer should not
	  have room for AMX register state (aka. xtiledata).
	  Check that the size does not overlap with where xtiledata
	  will reside.
	 
	  This also implies that no state components PAST
	  XTILEDATA (features >=19) can be present in the buffer.
	
	  Without permission, the XTILEDATA feature
	  bit should not be set.
 Skip the faulting XRSTOR 
 Return true if XRSTOR is successful; otherwise, false. 
 Print any messages produced by the signal code: 
	
	  Reset the buffer to make sure any future printing
	  only outputs new messages:
  Use XRSTOR to populate the XTILEDATA registers with
  random data.
  Return true if successful; otherwise, false.
 Return XTILEDATA to its initial configuration. 
 arch_prctl() and sigaltstack() test 
	
	  getauxval() itself can return 0 for failure or
	  success.  But, in this case, AT_MINSIGSTKSZ
	  will always return a >=0 value if implemented.
	  Just check for 0.
	
	  Try setup_altstack() with a size which can not fit
	  XTILEDATA.  ARCH_REQ_XCOMP_PERM should fail.
	
	  Try setup_altstack() with a size derived from
	  AT_MINSIGSTKSZ.  It should be more than large enough
	  and thus ARCH_REQ_XCOMP_PERM should succeed.
	
	  Try to coerce setup_altstack() to again accept a
	  too-small altstack.  This ensures that big-enough
	  sigaltstacks can not shrink to a too-small value
	  once XTILEDATA permission is established.
 fork() failed 
 fork() succeeded.  Now in the parent. 
 fork() succeeded.  Now in the child . 
	
	  The permission request should fail without an
	  XTILEDATA-compatible signal stack
	
	  Set up an XTILEDATA-compatible signal stack and
	  also obtain permission to populate XTILEDATA.
 Ensure that XTILEDATA can be populated. 
 fork() failed 
 fork() succeeded.  Now in the (grand)child. 
		
		  Ensure that the grandchild inherited
		  permission and a compatible sigaltstack:
 fork() succeeded.  Now in the parent. 
  Save current register state and compare it to @xbuf1.'
  Returns false if @xbuf1 matches the registers.
  Returns true  if @xbuf1 differs from the registers.
 tiledata inheritance test 
 fork() failed 
 fork() succeeded.  Now in the parent. 
 fork() succeeded.  Now in the child. 
 fork() failed 
 fork() succeeded.  Still in the first child. 
 fork() succeeded.  Now in the (grand)child. 
	
	  TILEDATA registers are not preserved across fork().
	  Ensure that their value has changed:
 Context switching test 
	
	  Load random data into 'xbuf' and then restore
	  it to the tile registers themselves.
		
		  Ensure the register values have not
		  diverged from those recorded in 'xbuf'.
 Load new, random values into xbuf and registers 
		
		  The last thread's last unlock will be for
		  thread 0's mutex.  However, thread 0 will
		  have already exited the loop and the mutex
		  will already be unlocked.
		 
		  Because this is not an ERRORCHECK mutex,
		  that inconsistency will be silently ignored.
	
	  Return this thread's finfo, which is
	  a unique value for this thread.
		
		  Thread 'i' will wait on this mutex to
		  be unlocked.  Lock it immediately after
		  initialization:
 Affinitize to one CPU to force context switches 
	
	  This thread wakes up thread 0
	  Thread 0 will wake up 1
	  Thread 1 will wake up 2
	  ...
	  the last thread will wake up 0
	 
	  ... this will repeat for the configured
	  number of iterations.
 Wait for all the threads to finish: 
 Check hardware availability at first 
 Request permission for the following tests 
 SPDX-License-Identifier: GPL-2.0-only
  fsgsbase_restore.c, test ptrace vs fsgsbase
  Copyright (c) 2020 Andy Lutomirski
  This test case simulates a tracer redirecting tracee execution to
  a function and then restoring tracee state using PTRACE_GETREGS and
  PTRACE_SETREGS.  This is similar to what gdb does when doing
  'p func()'.  The catch is that this test has the called function
  modify a segment register.  This makes sure that ptrace correctly
  restores segment state when using PTRACE_SETREGS.
  This is not part of fsgsbase.c, because that test is 64-bit only.
 Data, grow-up 
 No modify_ldt for us (configured out, perhaps) 
 32-bit set_thread_area 
	
	  The tracer will redirect execution here.  This is meant to
	  work like gdb's 'p func()' feature.  The tricky bit is that
	  we modify a segment register in order to make sure that ptrace
	  can correctly restore segment registers.
	
	  Write a nonzero selector with base zero to the segment register.
	  Using a null selector would defeat the test on AMD pre-Zen2
	  CPUs, as such CPUs don't clear the base when loading a null
	  selector.
 Should not get here. 
 Wait for SIGSTOP. 
 Don't clobber the redzone. 
 Wait for SIGSTOP. 
 Wait for SIGSTOP. 
 SPDX-License-Identifier: GPL-2.0-only
  single_step_syscall.c - single-steps various x86 syscalls
  Copyright (c) 2014-2015 Andrew Lutomirski
  This is a very simple series of tests that makes system calls with
  the TF flag set.  This exercises some nasty kernel code in the
  SYSENTER case: SYSENTER does not clear TF, so SYSENTER with TF set
  immediately issues #DB from CPL 0.  This requires special handling in
  the kernel.
 Force a syscall 
	
	  This test is particularly interesting if fast syscalls use
	  SYSENTER: it triggers a nasty design flaw in SYSENTER.
	  Specifically, SYSENTER does not clear TF, so either SYSENTER
	  or the next instruction traps at CPL0.  (Of course, Intel
	  mostly forgot to document exactly what happens here.)  So we
	  get a CPL0 fault with usergs (on 64-bit kernels) and possibly
	  no stack.  The only sane way the kernel can possibly handle
	  it is to clear TF on return from the #DB handler, but this
	  happens way too early to set TF in the saved pt_regs, so the
	  kernel has to do something clever to avoid losing track of
	  the TF bit.
	 
	  Needless to say, we've had bugs in this area.
 Force symbol binding without TF set. 
 Now make sure that another fast syscall doesn't set TF again. 
	
	  And do a forced SYSENTER to make sure that this works even if
	  fast syscalls don't use SYSENTER.
	 
	  Invoking SYSENTER directly breaks all the rules.  Just handle
	  the SIGSEGV.
 Clear EBP first to make sure we segfault cleanly. 
 We're unreachable here.  SYSENTER forgets RIP. 
 Now make sure that another fast syscall doesn't set TF again. 
 SPDX-License-Identifier: GPL-2.0-only
  Corrupt the XSTATE header in a signal frame
  Based on analysis and a test case from Thomas Gleixner.
 Is CR4.OSXSAVE enabled ? 
 Wreck the first reserved bytes in the header 
	
	  Enforce that the child runs on the same CPU
	  which in turn forces a schedule.
	
	  We could try to confirm that extended state is still preserved
	  when we schedule.  For now, the only indication of failure is
	  a warning in the kernel logs.
 SPDX-License-Identifier: GPL-2.0 
 max length of lines in procselfmaps - anything longer is skipped here 
 vsyscalls and vDSO 
 getcpu() was never wired up in the 32-bit vDSO. 
 sscanf() is safe here as strlen(name) >= strlen(line) 
 syscalls 
 We already tested this adequately. 
 INSTR 
  Debuggers expect ptrace() to be able to peek at the vsyscall page.
  Use process_vm_readv() as a proxy for ptrace() to test this.  We
  want it to work in the vsyscall=emulate case and to fail in the
  vsyscall=xonly case.
  It's worth noting that this ABI is a bit nutty.  write(2) can't
  read from the vsyscall page on any kernel version or mode.  The
  fact that ptrace() ever worked was a nice courtesy of old kernels,
  but the code to support it is fairly gross.
		
		  We expect process_vm_readv() to work if and only if the
		  vsyscall page is readable.
	
	  If vsyscalls are emulated, we expect a single trap in the
	  vsyscall page -- the call instruction will trap with RIP
	  pointing to the entry point before emulation takes over.
	  In native mode, we expect two traps, since whatever code
	  the vsyscall page contains will be more than just a ret
	  instruction.
 SPDX-License-Identifier: GPL-2.0-only
 sigaltstack()-enforced minimum stack 
 SPDX-License-Identifier: GPL-2.0-only
  fsgsbase.c, an fsgsbase test
  Copyright (c) 2014-2016 Andy Lutomirski
 Crash cleanly. 
 Skip the faulting mov 
	
	  Unless we have FSGSBASE, there's no direct way to do this from
	  user mode.  We can get at it indirectly using signals, though.
 Use a constant-length instruction here. 
	
	  If that didn't segfault, try the other end of the address space.
	  Unless we get really unlucky and run into the vsyscall page, this
	  is guaranteed to segfault.
  ARCH_SET_FSGS(0) may or may not program a selector of zero.  HARD_ZERO
  means to force the selector to zero to improve test coverage.
	
	  Sets GS != 0 and GSBASE != 0 but arranges for the kernel to think
	  that GSBASE == 0 (i.e. thread.gsbase == 0).
 Step 1: tell the kernel that we have GSBASE == 0. 
 Step 2: change GSBASE without telling the kernel. 
 Data, grow-up 
 No modify_ldt for us (configured out, perhaps) 
 32-bit set_thread_area 
			
			  On AMD chips, this causes GSBASE != 0, GS == 0, and
			  thread.gsbase == 0.
		
		  Signal delivery is quite likely to change a selector
		  of 1, 2, or 3 back to 0 due to IRET being defective.
		
		  IRET is misdesigned and will squash selectors 1, 2, or 3
		  to zero.  Don't fail the test just because this happened.
 Read the initial base.  It should be 1. 
 Poke an LDT selector into GS. 
 And read the base. 
		
		  In a non-FSGSBASE system, the nonzero selector will load
		  GSBASE (again). But what is tested here is whether the
		  selector value is changed or not by the GSBASE write in
		  a ptracer.
			
			  On older kernels, poking a nonzero value into the
			  base would zero the selector.  On newer kernels,
			  this behavior has changed -- poking the base
			  changes only the base and, if FSGSBASE is not
			  available, this may have no effect once the tracee
			  is resumed.
 Do these tests before we have an LDT. 
 Probe FSGSBASE 
 Set up for multithreading. 
 should never fail 
 Kill the thread. 
 SPDX-License-Identifier: GPL-2.0
 sNaN is s|111 1111 1|1xx xxxx xxxx xxxx xxxx xxxx 
 qNaN is s|111 1111 1|0xx xxxx xxxx xxxx xxxx xxxx (some x must be nonzero) 
 sNaN80 is s|111 1111 1111 1111 |10xx xx...xx (some x must be nonzero) 
 fld of a qnan raised FE_INVALID, clear it
 fld of a qnan raised FE_INVALID, clear it
	"	flds	snan""\n"	
	"	fstpt	snan1""\n"	
	"	fnclex""\n"		
 fldt never raise FE_INVALID
	printf("snan:%x snan1:%04x %04x %04x %04x %04x\n", snan, snan1[4], snan1[3], snan1[2], snan1[1], snan1[0]);
 fld of a qnan raised FE_INVALID, clear it
 fld of a qnan raised FE_INVALID, clear it
	 SIGILL triggers on 32-bit kernels wo fcomi emulation
	  when run with "no387 nofxsr". Other signals are caught
	  just in case.
 SPDX-License-Identifier: GPL-2.0 
  syscall_numbering.c - test calling the x86-64 kernel with various
  valid and invalid system call numbers.
  Copyright (c) 2018 Andrew Lutomirski
 Common system call numbers 
 x64-only system call numbers 
 x32-only system call numbers (without X32_BIT) 
 File descriptor for devnull 
 x32 supported on this kernel? 
  Shared memory block between tracer and test
 Total error count 
 Message indentation level 
 In probe_syscall() 
 Sentinel for ptrace-modified return value 
  Directly invokes the given syscall with nullfd as the first argument
  and the rest zero. Avoids involving glibc wrappers in case they ever
  end up intercepting some system calls for some reason, or modify
  the system call number itself.
	
	  We pass in an extra copy of the extended system call number
	  in %rbx, so we can examine it from the ptrace handler without
	  worrying about it being possibly modified. This is to test
	  the validity of struct user regs.orig_rax a.k.a.
	  struct pt_regs.orig_ax.
	
	  Improve readability by stripping the x32 bit, but round
	  toward zero so we don't display -1 as -1073741825.
  Anyone diagnosing a failure will want to know whether the kernel
  supports x32. Tell them. This can also be used to conditionalize
  tests based on existence or nonexistence of x32.
	
	  Syscalls 512-547 are "x32" syscalls.  They are
	  intended to be called with the x32 (0x40000000) bit
	  set.  Calling them without the x32 bit set is
	  nonsense and should not work.
	
	  The MSB is supposed to be ignored, so we loop over a few
	  to test that out.
 Do this on entry only 
 For these, don't even getregs 
 Just read, no writeback 
 Write back the same register state verbatim 
 Thread exited? 
 Wait for the child process to terminate 
 wait some more ;
 Launch the test thread; this thread continues as the tracer thread 
	
	  It is quite likely to get a segfault on a failure, so make
	  sure the message gets out by setting stdout to nonbuffered.
	
	  Harmless file descriptor to work on...
	
	  Set up a block of shared memory...
 SPDX-License-Identifier: GPL-2.0-only
  syscall_nt.c - checks syscalls with NT set
  Copyright (c) 2014-2015 Andrew Lutomirski
  Some obscure user-space code requires the ability to make system calls
  with FLAGS.NT set.  Make sure it works.
	
	  Now try it again with TF set -- TF forces returns via IRET in all
	  cases except non-ptregs-using 64-bit full fast path syscalls.
	
	  Now try DF.  This is evil and it's plausible that we will crash
	  glibc, but glibc would have to do something rather surprising
	  for this to happen.
 SPDX-License-Identifier: LGPL-2.1
 A simple percpu spinlock.  Returns the cpu lock was acquired on. 
 Retry if comparison fails or rseq aborts. 
	
	  Acquire semantic when taking lock after control dependency.
	  Matches rseq_smp_store_release().
	
	  Release lock, with release semantic. Matches
	  rseq_smp_acquire__after_ctrl_dep().
  A simple test which implements a sharded counter using a per-cpu
  lock.  Obviously real applications might prefer to simply use a
  per-cpu increment; however, this is reasonable for a test and the
  lock can be extended to synchronize more complicated operations.
 Load list->c[cpu].head with single-copy atomicity. 
 Retry if comparison fails or rseq aborts. 
  Unlike a traditional lock-less linked list; the availability of a
  rseq primitive allows us to implement pop without concerns over
  ABA-type races.
 Retry if rseq aborts. 
  __percpu_list_pop is not safe against concurrent accesses. Should
  only be used on lists that are not concurrently modified.
 encourage shuffling 
 Simultaneous modification to a per-cpu linked list from many threads.  
 Generate list entries for every usable cpu. 
	
	  All entries should now be accounted for (unless some external
	  actor is interfering with our allowed affinity while this
	  test is running).
 SPDX-License-Identifier: LGPL-2.1
  rseq.c
  Copyright (C) 2016 Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
  This library is free software; you can redistribute it andor
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; only
  version 2.1 of the License.
  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  Lesser General Public License for more details.
  Shared with other libraries. This library may take rseq ownership if it is
  still 0 when executing the library constructor. Set to 1 by library
  constructor when handling rseq. Set to 0 in destructor if handling rseq.
 Whether this library have ownership of rseq registration. 
 Check whether rseq is handled by another library. 
 SPDX-License-Identifier: LGPL-2.1
  Basic test coverage for critical regions and rseq_current_cpu().
 SPDX-License-Identifier: LGPL-2.1
 BENCHMARK 
 A simple percpu spinlock. Grabs lock on current cpu. 
 Retry if comparison fails or rseq aborts. 
	
	  Acquire semantic when taking lock after control dependency.
	  Matches rseq_smp_store_release().
	
	  Release lock, with release semantic. Matches
	  rseq_smp_acquire__after_ctrl_dep().
  A simple test which implements a sharded counter using a per-cpu
  lock.  Obviously real applications might prefer to simply use a
  per-cpu increment; however, this is reasonable for a test and the
  lock can be extended to synchronize more complicated operations.
 Load list->c[cpu].head with single-copy atomicity. 
 Retry if comparison fails or rseq aborts. 
  Unlike a traditional lock-less linked list; the availability of a
  rseq primitive allows us to implement pop without concerns over
  ABA-type races.
 Retry if rseq aborts. 
  __percpu_list_pop is not safe against concurrent accesses. Should
  only be used on lists that are not concurrently modified.
 encourage shuffling 
 Simultaneous modification to a per-cpu linked list from many threads.  
 Generate list entries for every usable cpu. 
	
	  All entries should now be accounted for (unless some external
	  actor is interfering with our allowed affinity while this
	  test is running).
 Retry if comparison fails or rseq aborts. 
 Load offset with single-copy atomicity. 
 Retry if comparison fails or rseq aborts. 
  __percpu_buffer_pop is not safe against concurrent accesses. Should
  only be used on buffers that are not concurrently modified.
 encourage shuffling 
 Should increase buffer size. 
 Simultaneous modification to a per-cpu buffer from many threads.  
 Generate list entries for every usable cpu. 
 Worse-case is every item in same CPU. 
			
			  We could theoretically put the word-sized
			  "data" directly in the buffer. However, we
			  want to model objects that would not fit
			  within a single word, so allocate an object
			  for each node.
	
	  All entries should now be accounted for (unless some external
	  actor is interfering with our allowed affinity while this
	  test is running).
 Load offset with single-copy atomicity. 
 copylen must be <= 4kB. 
 Retry if comparison fails or rseq aborts. 
 Load offset with single-copy atomicity. 
 copylen must be <= 4kB. 
 Retry if comparison fails or rseq aborts. 
  __percpu_memcpy_buffer_pop is not safe against concurrent accesses. Should
  only be used on buffers that are not concurrently modified.
 encourage shuffling 
 Should increase buffer size. 
 Simultaneous modification to a per-cpu buffer from many threads.  
 Generate list entries for every usable cpu. 
 Worse-case is every item in same CPU. 
			
			  We could theoretically put the word-sized
			  "data" directly in the buffer. However, we
			  want to model objects that would not fit
			  within a single word, so allocate an object
			  for each node.
	
	  All entries should now be accounted for (unless some external
	  actor is interfering with our allowed affinity while this
	  test is running).
 Test MEMBARRIER_CMD_PRIVATE_RESTART_RSEQ_ON_CPU membarrier command. 
 Worker threads modify data in their "active" percpu lists. 
 Wait for initialization. 
  The manager thread swaps per-cpu lists that worker threads see,
  and validates that there are no unexpected modifications.
 Init lists. 
 list_a is "active". 
		
		  As list_b is "inactive", we should never see changes
		  to list_b.
 Make list_b "active". 
 missing CPU ) {
		
		  Cpu A should now only modify list_b, so the values
		  in list_a should be stable.
		
		  As list_a is "inactive", we should never see changes
		  to list_a.
 Make list_a "active". 
 missing CPU) {
 Remember a value from list_b. 
 RSEQ_ARCH_HAS_OFFSET_DEREF_ADDV 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018 Davide Caratti, Red Hat inc.
  This program is free software; you can redistribute it andor
  modify it under the terms of version 2 of the GNU General Public
  License as published by the Free Software Foundation.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014 Sony Mobile Communications Inc.
  Selftest for runtime system size
  Prints the amount of RAM that the currently running system is using.
  This program tries to be as small as possible itself, to
  avoid perturbing the system memory utilization with its
  own execution.  It also attempts to have as few dependencies
  on kernel features as possible.
  It should be statically linked, with startup libs avoided.  It uses
  no library calls except the syscall() function for the following 3
  syscalls:
    sysinfo(), write(), and _exit()
  For output, it avoids printf (which in some C libraries
  has large external dependencies) by  implementing it's own
  number output and print routines, and using __builtin_strlen()
  The test may crash if any of the above syscalls fails because in some
  libc implementations (e.g. the GNU C Library) errno is saved in
  thread-local storage, which does not get initialized due to avoiding
  startup libs.
 put digits in buffer from back to front 
 this program has no main(), as startup libraries are not used 
 ignore cache complexities for now 
 SPDX-License-Identifier: GPL-2.0-only
  Use the core scheduling prctl() to test core scheduling cookies control.
  Copyright (c) 2021 Oracle andor its affiliates.
  Author: Chris Hyser <chris.hyser@oracle.com>
  This library is free software; you can redistribute it andor modify it
  under the terms of version 2.1 of the GNU Lesser General Public License as
  published by the Free Software Foundation.
  This library is distributed in the hope that it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  for more details.
  You should have received a copy of the GNU Lesser General Public License
  along with this library; if not, see <http:www.gnu.orglicenses>.
 create unique core_sched cookie 
 push core_sched cookie to pid 
 pull core_sched cookie to pid 
 put into separate process group 
 get a random process pid 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-or-later
 SPDX-License-Identifier: GPL-2.0
 Send some data through with ULP but no keys 
 MSG_PEEK can only peek into the current record. 
	 Non-MSG_PEEK will advance strparser (and therefore record)
	  however.
	 MSG_MORE will hold current record open, so later MSG_PEEK
	  will see everything.
 Test timing out 
 Set timeout to inf. secs 
 Send 20 bytes 
 Poll with inf. timeout 
 Now the remaining 5 bytes of record data are in TLS ULP 
 parent 
 child 
	 Ensure nonblocking behavior by imposing a small send
	  buffer.
 parent 
 child 
 Only allow multiples for simplicity 
 prep a file to send 
 spawn children 
 parent waits for all children 
 Split threads for reading and writing 
 test sending non-record types. 
 Should fail because we didn't provide a control message 
 Recv the message again without MSG_PEEK 
 TLS ULP not supported 
 SPDX-License-Identifier: GPL-2.0
  Test key rotation for TFO.
  New keys are 'rotated' in two steps:
  1) Add new key as the 'backup' key 'behind' the primary key
  2) Make new key the primary by swapping the backup and primary keys
  The rotation is done in stages using multiple sockets bound
  to the same port via SO_REUSEPORT. This simulates key rotation
  behind say a load balancer. We verify that across the rotation
  there are no cases in which a cookie is not accepted by verifying
  that TcpExtTCPFastOpenPassiveFail remains 0.
		 clang does not recognize error() above as terminating
		  the program, so it complains that saddr, sz are
		  not initialized when this code path is taken. Silence it.
		 clang does not recognize error() above as terminating
		  the program, so it complains that saddr, daddr, sz are
		  not initialized when this code path is taken. Silence it.
 first set new key as backups 
 swap the keys 
 SPDX-License-Identifier: GPL-2.0
 no events and more time to wait, do poll again 
 Flush all outstanding bytes for the tcp receive queue 
 MSG_TRUNC flushes up to len bytes 
 client detached 
 verify contents 
 Flush all outstanding datagrams. Verify first few bytes of each. 
 MSG_TRUNC will make return value full datagram length 
  Test for the regression introduced by
  b9470c27607b ("inet: kill smallest_size and smallest_port")
  If we open an ipv4 socket on a port with reuseaddr we shouldn't reset the tb
  when we open the ipv6 conterpart, which is what was happening previously.
 SPDX-License-Identifier: GPL-2.0
  ipsec.c - Check xfrm on veth inside a net-ns.
  Copyright (c) 2018 Dmitry Safonov
 xxx.xxx.xxx.xxx is longest + \0 
 16 mask divided by 30 subnets 
 10.0.0.0 
 192.168.0.0 
 30 mask for one veth connection 
  ksft_cnt is static in kselftest, so isn't shared with children.
  We have to send a test result back to parent and count there.
  results_fd is a pipe with test feedback from children.
  Running the test inside a new parent net namespace to bother less
  about cleanup on error-path.
 NLMSG_ALIGNTO == RTA_ALIGNTO, nlmsg_len already aligned 
 unsigned key_len; 
 Make sure that writeread is atomic to a pipe 
 EOF 
 EOF 
 The other end sends ip to ping 
 TODO: use setmap instead 
 Verify desc 
 Fill selector. 
 Fill id 
 Note: zero-spi cannot be deleted 
 Fill lifteme_cfg 
 XXX: check xfrm algo, see xfrm_state_pack_algo(). 
	
	  Add dump filter by source address as there may be other tunnels
	  in this netns (if tests run in parallel).
 0xffffffff mask see addr_match() 
 Check dumps for XFRM_MSG_GETSA 
 Fill selector. 
 Fill lifteme_cfg 
 Fill tmpl 
 Note: zero-spi cannot be deleted 
 Fill id 
 Note: zero-spi cannot be deleted 
 Fill selector. 
 Restore the default 
	
	  At this moment xfrm uses nlmsg_parse_deprecated(), which
	  implies NL_VALIDATE_LIBERAL - ignoring attributes with
	  (type > maxtype). nla_parse_depricated_strict() would enforce
	  it. Or even stricter nla_parse().
	  Right now it's not expected to fail, but to be ignored.
 UDP pinging without xfrm 
 UDP pinging with xfrm tunnel 
 xfrm delete 
 Check that seq sock is ready, just for sure. 
 EOF 
 UDP pinging without xfrm 
 in parent - selftest 
 child 
 No compression backend realization 
 not implemented 
  Some structures in xfrm uapi header differ in size between
  64-bit and 32-bit ABI:
              32-bit UABI               |            64-bit UABI
   -------------------------------------|-------------------------------------
    sizeof(xfrm_usersa_info)     = 220  |  sizeof(xfrm_usersa_info)     = 224
    sizeof(xfrm_userpolicy_info) = 164  |  sizeof(xfrm_userpolicy_info) = 168
    sizeof(xfrm_userspi_info)    = 228  |  sizeof(xfrm_userspi_info)    = 232
    sizeof(xfrm_user_acquire)    = 276  |  sizeof(xfrm_user_acquire)    = 280
    sizeof(xfrm_user_expire)     = 224  |  sizeof(xfrm_user_expire)     = 232
    sizeof(xfrm_user_polexpire)  = 168  |  sizeof(xfrm_user_polexpire)  = 176
  Check the affected by the UABI difference structures.
  Also, check translation for xfrm_set_spdinfo: it has it's own attributes
  which needs to be correctly copied, but not translated.
 EOF 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2018 Google Inc.
  Author: Eric Dumazet (edumazet@google.com)
  Reference program demonstrating tcp mmap() usage,
  and SO_RCVLOWAT hints for receiver.
  Note : NIC with header split is needed to use mmap() on TCP :
  Each incoming frame must be a multiple of PAGE_SIZE bytes of TCP payload.
  How to use on loopback interface :
   ifconfig lo mtu 61512  # 154096 + 40 (ipv6 header) + 32 (TCP with TS option header)
   tcp_mmap -s -z &
   tcp_mmap -H ::1 -z
   Or leave default lo mtu, but use -M option to set TCP_MAXSEG option to (4096 + 12)
       (4096 : page size on x86, 12: TCP TS option length)
   tcp_mmap -s -z -M $((4096+12)) &
   tcp_mmap -H ::1 -z -M $((4096+12))
  Note: -z option on sender uses MSG_ZEROCOPY, which forces a copy when packets go through loopback interface.
        We might use sendfile() instead, but really this test program is about mmap(), for receivers ;)
  $ .tcp_mmap -s &                                 # Without mmap()
  $ for i in {1..4}; do .tcp_mmap -H ::1 -z ; done
  received 32768 MB (0 % mmap'ed) in 14.1157 s, 19.4732 Gbit
    cpu usage user:0.057 sys:7.815, 240.234 usec per MB, 65531 c-switches
  received 32768 MB (0 % mmap'ed) in 14.6833 s, 18.7204 Gbit
   cpu usage user:0.043 sys:8.103, 248.596 usec per MB, 65524 c-switches
  received 32768 MB (0 % mmap'ed) in 11.143 s, 24.6682 Gbit
    cpu usage user:0.044 sys:6.576, 202.026 usec per MB, 65519 c-switches
  received 32768 MB (0 % mmap'ed) in 14.9056 s, 18.4413 Gbit
    cpu usage user:0.036 sys:8.193, 251.129 usec per MB, 65530 c-switches
  $ kill %1   # kill tcp_mmap server
  $ .tcp_mmap -s -z &                              # With mmap()
  $ for i in {1..4}; do .tcp_mmap -H ::1 -z ; done
  received 32768 MB (99.9939 % mmap'ed) in 6.73792 s, 40.7956 Gbit
    cpu usage user:0.045 sys:2.827, 87.6465 usec per MB, 65532 c-switches
  received 32768 MB (99.9939 % mmap'ed) in 7.26732 s, 37.8238 Gbit
    cpu usage user:0.037 sys:3.087, 95.3369 usec per MB, 65532 c-switches
  received 32768 MB (99.9939 % mmap'ed) in 7.61661 s, 36.0893 Gbit
    cpu usage user:0.046 sys:3.559, 110.016 usec per MB, 65529 c-switches
  received 32768 MB (99.9939 % mmap'ed) in 7.43764 s, 36.9577 Gbit
    cpu usage user:0.035 sys:3.467, 106.873 usec per MB, 65530 c-switches
 Default: autotuning.  Can be set with -r <integer> option 
 Default: autotuning.  Can be set with -w <integer> option 
 zero copy option. (MSG_ZEROCOPY for sender, mmap() for receiver 
 hash received data (simple xor) (-h option) 
 -k option: receiver shall keep all received file in memory (no munmap() calls) 
 Attempt to use huge pages if possible. 
				 It is more efficient to unmap the pages right now,
				  instead of doing this in next TCP_ZEROCOPY_RECEIVE.
 Each thread should reserve a big enough vma to avoid
  spinlock collisions in ptl locks.
  This size is 2MB on x86_64, and is exported in procmeminfo.
 server : listen for incoming connections 
		 if really procmeminfo is not helping,
		  we use the default x86_64 hugepagesize.
 Note : we just want to fill the pipe with 0 bytes 
 SPDX-License-Identifier: GPL-2.0
 Test IPV6_FLOWINFO cmsg on send and recv 
 uapiglibc weirdness may leave this undefined 
 do not pass IPV6_ADDR_ANY or IPV6_ADDR_MAPPED 
 SPDX-License-Identifier: GPL-2.0
 test sending up to max mtu + 1 
 position check field exactly one byte beyond end of packet 
 BPF filter accepts only this length, vlan changes MAC 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2013 Red Hat, Inc.
  Author: Daniel Borkmann <dborkman@redhat.com>
          Chetan Loke <loke.chetan@gmail.com> (TPACKET_V3 usage example)
  A basic test of packet socket's TPACKET_V1TPACKET_V2TPACKET_V3 behavior.
  Control:
    Test the setup of the TPACKET socket with different patterns that are
    known to fail (TODO) resp. succeed (OK).
  Datapath:
    Open a pair of packet sockets and send resp. receive an a priori known
    packet pattern accross the sockets and check if it was received resp.
    sent correctly. Fanout in combination with RX_RING is currently not
    tested here.
    The test currently runs for
    - TPACKET_V1: RX_RING, TX_RING
    - TPACKET_V2: RX_RING, TX_RING
    - TPACKET_V3: RX_RING
	 Lets create some broken crap, that still passes
	  our BPF filter.
	 TPACKET_V{1,2} sets up the ring->rd related variables based
	  on frames (e.g., rd_num is tp_frame_nr) whereas V3 sets these
	  up based on blocks (e.g, rd_num is  tp_block_nr)
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2018 Google Inc.
  Author: Soheil Hassas Yeganeh (soheil@google.com)
  Simple example on how to use TCP_INQ and TCP_CM_INQ.
		 TCP_INQ can overestimate in-queue by one byte if we send
		  the FIN packet. Sleep for 1 second, so that the client
		  likely invoked recvmsg().
 SPDX-License-Identifier: GPL-2.0
 Got a TX timestamp from error queue 
 range of IDs acknowledged 
 cold cache when writing buffer 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Test IPV6_FLOWINFO_MGR 
 uapiglibc weirdness may leave this undefined 
 from netipv6ip6_flowlabel.c 
 do not pass IPV6_ADDR_ANY or IPV6_ADDR_MAPPED 
 SPDX-License-Identifier: GPL-2.0
  Test functionality of BPF filters with SO_REUSEPORT. Same test as
  in reuseport_bpf_cpu, only as one socket per NUMA node.
 R0 = bpf_get_numa_node_id() 
 return R0 
 Forward iterate 
 Reverse iterate 
 SPDX-License-Identifier: GPL-2.0
  Test functionality of BPF filters with SO_REUSEPORT.  This program creates
  an SO_REUSEPORT receiver group containing one socket per CPU core. It then
  creates a BPF program that will select a socket from this group based
  on the core id that receives the packet.  The sending code artificially
  moves itself to run on different core ids and sends one message from
  each core.  Since these packets are delivered over loopback, they should
  arrive on the same core that sent them.  The receiving code then ensures
  that the packet was received on the socket for the corresponding core id.
  This entire process is done for several different core id permutations
  and for each IPv4IPv6 and TCPUDP combination.
 A = raw_smp_processor_id() 
 return A 
 Forward iterate 
 Reverse iterate 
 Even cores 
 Odd cores 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014 Google Inc.
  Author: willemb@google.com (Willem de Bruijn)
  Test software tx timestamping, including
  - SCHED, SND and ACK timestamps
  - RAW, UDP and TCP
  - IPv4 and IPv6
  - various packet sizes (to test GSO and TSO)
  Consult the command line arguments for help on running
  the various testcases.
  This test requires a dummy TCP server.
  A simple `nc6 [-u] -l -p $DESTPORT` will do
 command line parameters 
	 compare key for each subsequent request
	  must only test for one type, the first one requested
 TODO: convert to check_and_print payload once API is stable 
 overprovision];
 checksum ip(v6) addresses + udp header + payload 
 set for udp csum calc 
 kernel writes saddr, csum, len 
 kernel does not write saddr in case of ipv6 
 spoof 
		 special case, only rawv6_sendmsg:
		  pass proto in sin6_port if not connected
		  also see ANK comment in netipv4raw.c
 reset expected key on each new socket 
 wait for all errors to be queued, else ACKs arrive OOO 
	 leave fd open, will be closed on process exit.
	  this enables connect() to succeed and avoids icmp replies
 SPDX-License-Identifier: GPL-2.0
 Toeplitz test
  1. Read packets and their rx_hash using PF_PACKETTPACKET_V3
  2. Compute the rx_hash in software based on the packet contents
  3. Compare the two
  Optionally, either '-C $rx_irq_cpu_list' or '-r $rps_bitmap' may be given.
  If '-C $rx_irq_cpu_list' is given, also
  4. Identify the cpu on which the packet arrived with PACKET_FANOUT_CPU
  5. Compute the rxqueue that RSS would select based on this rx_hash
  6. Using the $rx_irq_cpu_list map, identify the arriving cpu based on rxq irq
  7. Compare the cpus from 4 and 6
  Else if '-r $rps_bitmap' is given, also
  4. Identify the cpu on which the packet arrived with PACKET_FANOUT_CPU
  5. Compute the cpu that RPS should select based on rx_hash and $rps_bitmap
  6. Compare the cpus from 4 and 5
 hex encoded: AA:BB:CC:...:ZZ 
 real constraint is PACKET_FANOUT_MAX 
 must be a power of 2 
 configuration options (cmdline arguments) 
 global vars 
 stats 
 tpacket ring 
 map from rxq to cpu 
 Compare computed cpu with arrival cpu from packet_fanout_cpu 
 Compare computed rxhash with rxhash received from tpacket_v3 
 A single TPACKET_V3 block can hold multiple frames 
 simple test: sleep once unconditionally and then process all rings 
 filter on transport protocol and destination port 
 same for udp 
 drop everything: used temporarily during setup 
	 block packets until all rings are added to the fanout group:
	  else packets can arrive during setup and get misclassified
 must come after bind: verifies all programs in group match 
		 on failure, retry using old API if that is sufficient:
		  it has a hard limit of 256 sockets, so only try if
		  (a) only testing rxhash, not RSS or (b) <= 256 cpus.
		  in this API, the third argument is left implicit.
 setup inet(6) socket to blackhole the test traffic, if arg '-s' 
 accept packets once all rings in the fanout group are up 
 skip ','
 SPDX-License-Identifier: GPL-2.0
  This testsuite provides conformance testing for GRO coalescing.
  Test cases:
  1.data
   Data packets of the same size and same header setup with correct
   sequence numbers coalesce. The one exception being the last data
   packet coalesced: it can be smaller than the rest and coalesced
   as long as it is in the same flow.
  2.ack
   Pure ACK does not coalesce.
  3.flags
   Specific test cases: no packets with PSH, SYN, URG, RST set will
   be coalesced.
  4.tcp
   Packets with incorrect checksum, non-consecutive seqno and
   different TCP header options shouldn't coalesce. Nit: given that
   some extension headers have paddings, such as timestamp, headers
   that are padding differently would not be coalesced.
  5.ip:
   Packets with different (ECN, TTL, TOS) header, ip options or
   ip fragments (ipv6) shouldn't coalesce.
  6.large:
   Packets larger than GRO_MAX_SIZE packets shouldn't coalesce.
  MSS is defined as 4096 - header because if it is too small
  (i.e. 1500 MTU - header), it will result in many packets,
  increasing the "large" test case's flakiness. This is because
  due to time sensitivity in the coalescing window, the receiver
  may not coalesce all of the packets.
  Note the timing issue applies to all of the test cases, so some
  flakiness is to be expected.
 DF = 1, MF = 0 
 send one extra flag, not first and not last pkt 
 Test for data of same length, smaller than previous
  and of different lengths
 If incoming segments make tracked segment length exceed
  legal IP datagram length, do not coalesce
 Pure acks and dup acks don't coalesce 
 TCP with options is always a permutation of {TS, NOP, NOP}.
  Implement different orders to verify coalescing stops.
 two NOP opts ,
 Packets with invalid checksum don't coalesce. 
 Packets with non-consecutive sequence number don't coalesce.
  Packet with different timestamp option or different timestamps
   don't coalesce.
 Packet with different tcp options don't coalesce. 
 IPv4 options shouldn't coalesce 
  IPv4 fragments shouldn't coalesce 
	 Once fragmented, packet would retain the total_len.
	  Tcp header is prepared as if rest of data is in follow-up frags,
	  but follow up frags aren't actually sent.
 DF = 1, MF = 1
 IPv4 packets with different ttl don't coalesce.
 Packets with different tos don't coalesce.
 Packets with different ECN don't coalesce.
 ECN set to 10
 ECN set to 10
 IPv6 fragments and packets with extensions don't coalesce.
		 Min ethernet frame payload is 46(ETH_ZLEN - ETH_HLEN) by RFC 802.3.
		  Ipv4tcp packets without at least 6 bytes of data will be padded.
		  Packet sockets are protocol agnostic, and will not trim the padding.
			 Modified packets may be received out of order.
			  Sleep function added to enforce test boundaries
			  so that fin pkts are not received prior to other pkts.
		 20 is the difference between min iphdr size
		  and min ipv6hdr size. Like MAX_HDR_SIZE,
		  MAX_PAYLOAD is defined with the larger header of the two.
			 GRO doesn't check for ipv6 hop limit when flushing.
			  Hence no corresponding test to the ipv4 case.
 last segment sent individually, doesn't start new segment 
 Loopback device does not support hw timestamps. 
 for IPv4 header 
 setsockopt for SO_TIMESTAMPING is asynchronous 
 SPDX-License-Identifier: GPL-2.0
 Test program for SIOC{G,S}HWTSTAMP
  Copyright 2013 Solarflare Communications
  Author: Ben Hutchings
 SPDX-License-Identifier: GPL-2.0+
  Author: Justin Iurman (justin.iurman@uliege.be)
  IOAM tester for IPv6, see ioam6.sh for details on each test case.
  Be careful if you modify structs below - everything MUST be kept synchronized
  with configurations inside ioam6.sh and always reflect the same.
 default value 
 default value 
 default value 
 default value 
 default value 
	
	  OUTPUT 
	
	  INPUT 
	
	  GLOBAL 
 SPDX-License-Identifier: GPL-2.0
 IPv6 fragment header lenth. 
 Max UDP payload length. 
 IPv4 MF flag. 
 IPv6 MF flag. 
 Receive a UDP packet. Validate it matches udp_payload. 
 OK 
 This is the last fragment. 
 This is the last fragment. 
	 Send the UDP datagram using raw IP fragments: the 0th fragment
	  has the UDP header; other fragments are pieces of udp_payload
	  split in chunks of frag_len size.
	 
	  Odd fragments (1st, 3rd, 5th, etc.) are sent out first, then
	  even fragments (0th, 2nd, etc.) are sent out.
 Version. 
 Occasionally test in-order fragments. 
 Occasionally test IPv4 "runs" (see netipv4ip_fragment.c) 
 Odd fragments. 
 IPv4 ignores duplicates, so randomly send a duplicate. 
		 Send an extra random fragment.
		 
		  Duplicates and some fragments completely inside
		  previously sent fragments are droppedignored. So
		  random offset and frag_len can result in a dropped
		  fragment instead of a dropped queuepacket. Thus we
		  hard-code offset and frag_len.
 not enough payload for random offset and frag_len. 
 sendto() returns EINVAL if offset + frag_len is too small. 
 In IPv6 if !!(frag_len % 8), the fragment is dropped. 
 Event fragments. 
 IPv4 ignores duplicates, so randomly send a duplicate. 
	 Frag queue timeout is set to one second in the calling script;
	  socket timeout should be just a bit longer to avoid tests interfering
	  with each other.
 Initialize the payload. 
 Open sockets. 
 Fail fast. 
			 With overlaps, one sendreceive pair below takes
			  at least one second (== timeout) to run, so there
			  is not enough test time to run a nested loop:
			  the full overlap test takes 20-30 seconds.
			 Without overlaps, each packet reassembly (== one
			  sendreceive pair below) takes very little time to
			  run, so we can easily afford more thourough testing
			  with a nested loop: the full non-overlap test takes
			  less than one second).
 Cleanup. 
 !ipv6 );
 ipv6 );
 Print the seed to trackreproduce potential failures. 
 SPDX-License-Identifier: GPL-2.0-only
  Check if we can fully utilize 4-tuples for connect().
  Rules to bind sockets to the same port when all ephemeral ports are
  exhausted.
    1. if there are TCP_LISTEN sockets on the port, fail to bind.
    2. if there are sockets without SO_REUSEADDR, fail to bind.
    3. if SO_REUSEADDR is disabled, fail to bind.
    4. if SO_REUSEADDR is enabled and SO_REUSEPORT is disabled,
         succeed to bind.
    5. if SO_REUSEADDR and SO_REUSEPORT are enabled and
         there is no socket having the both options and the same EUID,
         succeed to bind.
    6. fail to bind.
  Author: Kuniyuki Iwashima <kuniyu@amazon.co.jp>
 SPDX-License-Identifier: GPL-2.0
 dynamically allocate unused port 
 SPDX-License-Identifier: GPL-2.0
  Verify that consecutive sends over packet tx_ring are mirrored
  with their original content intact.
 SPDX-License-Identifier: GPL-2.0
  Test the SO_TXTIME API
  Takes a stream of { payload, delivery time }[], to be sent across two
  processes. Start this program on two separate network namespaces or
  connected hosts, one instance in transmit mode and the other in receive
  mode using the '-r' option. Receiver will compare arrival timestamps to
  the expected stream. Sender will read transmit timestamps from the error
  queue. The streams can differ due to out-of-order delivery and drops.
 encode one timed transmission (of a 1B payload) 
 only pass non-zero on first call 
 parse delay 
 parse character 
 Evaluate MSG_ZEROCOPY
  Send traffic between two processes over one of the supported
  protocols and modes:
  PF_INETPF_INET6
  - SOCK_STREAM
  - SOCK_DGRAM
  - SOCK_DGRAM with UDP_CORK
  - SOCK_RAW
  - SOCK_RAW with IP_HDRINCL
  PF_PACKET
  - SOCK_DGRAM
  - SOCK_RAW
  PF_RDS
  - SOCK_SEQPACKET
  Start this program on two connected hosts, one in send mode and
  the other with option '-r' to put it in receiver mode.
  If zerocopy mode ('-z') is enabled, the sender will verify that
  the kernel queues completions on the error queue for all zerocopy
  transfers.
 default: pin to last cpu 
 split up the packet. for non-multiple, make first buffer longer 
		 in mixed-frags mode, alternate zerocopy and copy frags
		  start with non-zerocopy, to ensure attach later works
	 Detect notification gaps. These should not happen often, if at all.
	  Gaps can occur due to drops, reordering and retransmissions.
 Read all outstanding messages on the errqueue 
 Wait for all remaining completions on the errqueue 
 sock_raw passes ll header as data 
 both sock_raw and sock_dgram expect name 
 packet and raw sockets with hdrincl must pass network header 
	 If tx over PF_PACKET, rx over PF_INET(6)SOCK_RAW,
	  to recv the only copy of the packet, not a clone
 Flush all outstanding bytes for the tcp receive queue 
 MSG_TRUNC flushes up to len bytes 
 Flush all outstanding datagrams. Verify first few bytes of each. 
 MSG_TRUNC will return full datagram length 
 raw ipv4 return with header, raw ipv6 without 
 max tcp options ;
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2013 Google Inc.
  Author: Willem de Bruijn (willemb@google.com)
  A basic test of packet socket fanout behavior.
  Control:
  - create fanout fails as expected with illegal flag combinations
  - join   fanout fails as expected with diverging types or flags
  Datapath:
    Open a pair of packet sockets and a pair of INET sockets, send a known
    number of packets across the two INET sockets and count the number of
    packets enqueued onto the two packet sockets.
    The test currently runs for
    - PACKET_FANOUT_HASH
    - PACKET_FANOUT_HASH with PACKET_FANOUT_FLAG_ROLLOVER
    - PACKET_FANOUT_LB
    - PACKET_FANOUT_CPU
    - PACKET_FANOUT_ROLLOVER
    - PACKET_FANOUT_CBPF
    - PACKET_FANOUT_EBPF
  Todo:
  - functionality: PACKET_FANOUT_FLAG_DEFRAG
 for sched_setaffinity 
 for __NR_bpf 
 Open a socket in a given fanout mode.
 ldb [80] 
 ret A 
 Test illegal mode + flag combination 
 Test illegal group with different modes or flags 
 Test illegal max_num_members values 
 expected failure on greater than PACKET_FANOUT_MAX 
 expected failure on joining group with different max_num_members 
 success on joining group with same max_num_members 
 success on joining group with max_num_members unspecified 
 Test creating a unique fanout group ids 
 Send data, but not enough to overflow a queue 
 Send more data, overflow the queue 
 TODO: ensure consistent order between expect1 and expect2 
 PACKET_FANOUT_MAX 
 find a set of ports that do not collide onto the same socket 
 TODO: test that choice alternates with previous 
  Test functionality of BPF filters for SO_REUSEPORT.  The tests below will use
  a BPF program (both classic and extended) to read the first word from an
  incoming packet (expected to be in network byte-order), calculate a modulus
  of that number, and then dispatch the packet to the Nth socket using the
  result.  These tests are run for each supported address family and protocol.
  Additionally, a few edge cases in the implementation are tested.
 BPF_MOV64_REG(BPF_REG_6, BPF_REG_1) 
 BPF_LD_ABS(BPF_W, 0) R0 = (uint32_t)skb[0] 
 BPF_ALU64_IMM(BPF_MOD, BPF_REG_0, mod) 
 BPF_EXIT_INSN() 
 A = (uint32_t)skb[0] 
 A = A % mod 
 return A 
 bit 1: client side; bit-2 server side 
	 NOTE: UDP socket lookups traverse a different code path when there
	  are > 10 sockets in a group.  Run the bpf test through both paths.
 TCP fastopen is required for the TCP tests 
 SPDX-License-Identifier: GPL-2.0
  It is possible to use SO_REUSEPORT to open multiple sockets bound to
  equivalent local addresses using AF_INET and AF_INET6 at the same time.  If
  the AF_INET6 socket has IPV6_V6ONLY set, it's clear which socket should
  receive a given incoming packet.  However, when it is not set, incoming v4
  packets should prefer the AF_INET socket(s).  This behavior was defined with
  the original SO_REUSEPORT implementation, but broke with
  e32ea7e74727 ("soreuseport: fast reuseport UDP socket selection")
  This test creates these mixed AF_INETAF_INET6 sockets and asserts the
  AF_INET preference for v4 packets.
	 NOTE: UDP socket lookups traverse a different code path when there
	  are > 10 sockets in a group.
 SPDX-License-Identifier: GPL-2.0-only
  This program demonstrates how the various time stamping features in
  the Linux kernel work. It emulates the behavior of a PTP
  implementation in stand-alone master mode by sending PTPv1 Sync
  multicasts once every second. It looks for similar packets, but
  beyond that doesn't actually implement PTP.
  Outgoing packets are time stamped with SO_TIMESTAMPING with or
  without hardware support.
  Incoming packets are time stamped with SO_TIMESTAMPING with or
  without hardware support, SIOCGSTAMP[NS] (per-socket time stamp) and
  SO_TIMESTAMP[NS].
  Copyright (C) 2009 Intel Corporation.
  Author: Patrick Ohly <patrick.ohly@intel.com>
 fake uuid 
 fake uuid 
 fake uuid 
 skip deprecated HW transformed 
 bind to PTP port 
 PTP event port );
 set multicast group for outgoing packets 
 alternate PTP domain 1 
 join multicast group, loop our own packet 
 set socket options for time stamping 
 request IP_PKTINFO for debugging purposes 
 verify socket options 
 send packets forever every five seconds 
 continue waiting for timeout or data 
 write one packet 
 SPDX-License-Identifier: GPL-2.0
 send() buffer size, may exceed mss 
 send() call is expected to fail 
 mss after applying gso 
 recv(): number of calls of full mss 
 recv(): size of last non-mss dgram, if any 
 no GSO: send a single byte 
 no GSO: send a single MSS 
 no GSO: send a single MSS + 1B: fail 
 send a single MSS: will fall back to no GSO 
 send a single MSS + 1B 
 send exactly 2 MSS 
 send 2 MSS + 1B 
 send MAX segs 
 send MAX bytes 
 send MAX + 1: fail 
 send a single 1B MSS: will fall back to no GSO 
 send 2 1B segments 
 send 2B + 2B + 1B segments 
 send max number of min sized segments 
 send max number + 1 of min sized segments: fail 
 EOL 
 no GSO: send a single byte 
 no GSO: send a single MSS 
 no GSO: send a single MSS + 1B: fail 
 send a single MSS: will fall back to no GSO 
 send a single MSS + 1B 
 send exactly 2 MSS 
 send 2 MSS + 1B 
 send MAX segs 
 send MAX bytes 
 send MAX + 1: fail 
 send a single 1B MSS: will fall back to no GSO 
 send 2 1B segments 
 send 2B + 2B + 1B segments 
 send max number of min sized segments 
 send max number + 1 of min sized segments: fail 
 EOL 
 very wordy version of system("ip route add dev lo mtu 1500 127.0.0.332") 
if_nametoindex("lo");
 MTU is a subtype in a metrics type 
 now fill MTU subtype. Note that it fits within above rta_len 
 If MSG_MORE, send 1 byte followed by remainder 
 Recv all full MSS datagrams 
 Recv the non-full last datagram, if tlen was not a multiple of mss 
 Verify received all data 
 if a specific test is given, then skip all others 
 Have tests fail quickly instead of hang 
 Do not fragment these datagrams: only succeed if GSO works 
 use connected addr );
 SPDX-License-Identifier: GPL-2.0
 Test that sockets listening on a specific address are preferred
  over sockets listening on addr_any.
		 clang does not recognize error() above as terminating
		  the program, so it complains that saddr, sz are
		  not initialized when this code path is taken. Silence it.
		 clang does not recognize error() above as terminating
		  the program, so it complains that saddr, daddr, sz are
		  not initialized when this code path is taken. Silence it.
	 Below we test that a socket listening on a specific address
	  is always selected in preference over a socket listening
	  on addr_any. Bugs where this is not the case often result
	  in sockets created first or last to get picked. So below
	  we make sure that there are always addr_any sockets created
	  before and after a specific socket is created.
 SPDX-License-Identifier: GPL-2.0
	 0    = valid file descriptor
	  -foo = error foo
	 If non-zero, accept EAFNOSUPPORT to handle the case
	  of the protocol not being configured into the kernel.
 SPDX-License-Identifier: GPL-2.0
 nettest - used for functional tests of networking APIs
  Copyright (c) 2013-2019 David Ahern <dsahern@gmail.com>. All rights reserved.
 local address 
 remote address 
 remote scope; v6 send only 
 multicast group 
 DGRAM, STREAM, RAW 
 AF_INETAF_INET6 
 prefix for MD5 password 
 0: default, -1: force off, +1: force on 
 expected addresses and device index for connection 
 local address 
 remote address 
 ESP in UDP encap test 
 ENOENT is harmless. Returned when a password is cleared 
	 entire string should be consumed by conversion
	  and value should be between min and max
 avoid PKTINFO conflicts with bindtodev 
				 kernel is allowing scope_id to be set to VRF
				  index for LLA. for sends to global address
				  reset scope id
 client sends first message 
 Not in both_mode, so there's no process to signal 
 ipc_fd = -1 if no parent process to signal 
 to tell log_msg in case we are in both_mode 
	 when running in both mode, address validation applies
	  solely to client side
	 do the client-side function here in the parent process,
	  waiting to be told when to continue
 process inputs 
	
	  process input args
 SPDX-License-Identifier: GPL-2.0
 check messages from kernel 
 do a netlink command and, if max > 0, fetch the reply  
 Beware: the NLMSG_NEXT macro updates the 'rem' argument 
 addr data 
 family 
 flags 
 do not support flag list yet 
 the only argument is the address id (nonzero) 
 zero id with the IP address 
 build a dummy addr with only the ID set 
 addr data 
 family 
 bump unknown flags, if any 
 the only argument is the address id 
 build a dummy addr with only the ID set 
 limit 
 limit 
 do not expect a reply 
 addr data 
 family 
 flags 
 do not support flag list yet 
 SPDX-License-Identifier: GPL-2.0
 size of this structure in userspace 
 must be 0, set by kernel 
 must be 0, set by kernel 
 size of one element in data[] 
 success 
 success 
 0 size_subflow_data 
 bogus olen 
 must be unchanged 
 size_kernel not 0 
 num_subflows not 0 
 forward compat check: larger struct mptcp_subflow_data on 'old' kernel 
 olen must be truncated to real data size filled by kernel: 
 no truncation, kernel should have filled 1 byte of optname payload in buf[1]: 
 wait and repeat, might be that tx is still ongoing 
 un-block server 
 sequence advances due to FIN 
 wait for hangup 
 wait until server bound a socket 
 SPDX-License-Identifier: GPL-2.0
 success 
 success 
 let the join handshake complete, before going on 
				 no more data to receive:
				  peer has closed its write side
 and nothing more to send 
 Else, still have data to transmit 
 We have no more data to send. 
 ... and peer also closed already 
				 ... but we still receive.
				  Close our write side, ev. give some time
				  for address notification andor checking
				  the current status
 leave some time for late joinannounce 
		 show the runtime only if this end shutdown(wr) before receiving the EOF,
		  (that is, if this end got the longer runtime)
 listener is ready. 
 silence compiler warning 
 silence compiler warning 
 silence compiler warning 
 SPDX-License-Identifier: GPL-2.0-or-later
 Test 1: Test for SIGURG and OOB 
 Test 2: Test for OOB being overwitten 
 Test 3: Test for SIOCATMARK 
 Test 4: Test for 1byte OOB msg 
	 Test 1:
	  veriyf that SIGURG is
	  delivered and 63 bytes are
	  read and oob is '@'
	 Test 2:
	  Verify that the first OOB is over written by
	  the 2nd one and the first OOB is returned as
	  part of the read, and sigurg is received.
	 Test 3:
	  verify that 2nd oob over writes
	  the first one and read breaks at
	  oob boundary returning 127 bytes
	  and sigurg is received and atmark
	  is set.
	  oob is '%' and second read returns
	  64 bytes.
	 Test 4:
	  verify that a single byte
	  oob message is delivered.
	  set non blocking mode and
	  check proper error is
	  returned and sigurg is
	  received and correct
	  oob is read.
 Inline Testing 
	 Test 1 -- Inline:
	  Check that SIGURG is
	  delivered and 63 bytes are
	  read and oob is '@'
	 Test 2 -- Inline:
	  Verify that the first OOB is over written by
	  the 2nd one and read breaks correctly on
	  2nd OOB boundary with the first OOB returned as
	  part of the read, and sigurg is delivered and
	  siocatmark returns true.
	  next read returns one byte, the oob byte
	  and siocatmark returns false.
	 Test 3 -- Inline:
	  verify that 2nd oob over writes
	  the first one and read breaks at
	  oob boundary returning 127 bytes
	  and sigurg is received and siocatmark
	  is true after the read.
	  subsequent read returns 65 bytes
	  because of oob which should be '%'.
	 Test 4 -- Inline:
	  verify that a single
	  byte oob message is delivered
	  and read returns one byte, the oob
	  byte and sigurg is received
 SPDX-License-Identifier: GPL-2.0
  Based on Christian Brauner's clone3() example.
  These tests are assuming to be running in the host's
  PID namespace.
 capabilities related code based on selftestsbpftest_verifier.c 
 Drop all capabilities 
 40 -> CAP_CHECKPOINT_RESTORE 
 Find the current active PID 
 After the child has finished, its PID should be free. 
 This would fail without CAP_CHECKPOINT_RESTORE 
 This should work as we have CAP_CHECKPOINT_RESTORE as non-root 
 SPDX-License-Identifier: GPL-2.0 
	
	  Check that CLONE_CLEAR_SIGHAND and CLONE_SIGHAND are mutually
	  exclusive.
 Register signal handler for SIGUSR1 
 Register signal handler for SIGUSR2 
 Check that CLONE_CLEAR_SIGHAND works. 
 SPDX-License-Identifier: GPL-2.0
  Based on Christian Brauner's clone3() example.
  These tests are assuming to be running in the host's
  PID namespace.
 Signal the parent that the child is ready 
 Try invalid settings 
	
	  This can actually work if this test running in a MAX_PID_NS_LEVEL - 1
	  nested PID namespace.
	
	  This can actually work if this test running in a MAX_PID_NS_LEVEL - 1
	  nested PID namespace.
 Try with an invalid PID 
 Claim that the set_tid array actually contains 2 elements. 
 Try it in a new PID namespace 
 Try with a valid PID (1) this should return -EEXIST. 
 Try it in a new PID namespace 
 pid_max should fail everywhere 
		
		  All remaining tests require root. Tell the framework
		  that all those tests are skipped as non-root.
 Find the current active PID 
 After the child has finished, its PID should be free. 
 This should fail as there is no PID 1 in that namespace 
	
	  Creating a process with PID 1 in the newly created most nested
	  PID namespace and PID 'pid' in the parent PID namespace. This
	  needs to work.
 This should fail as there is no PID 1 in that namespace 
 Let's create a PID 1 
		
		  This and the next test cases check that all pid-s are
		  released on error paths.
 This should fail as there is invalid PID at level '1'. 
		
		  This should fail as there are not enough active PID
		  namespaces. Again assuming this is running in the host's
		  PID namespace. Not yet nested.
		
		  This should work and from the parent we should see
		  something like 'NSpid:	pid	42	1'.
 Verify that all generated PIDs are as expected. 
 Tell the clone3()'d child to finish. 
 SPDX-License-Identifier: GPL-2.0
 Based on Christian Brauner's clone3() example 
 Just a simple clone3() should return 0.
 Do a clone3() in a new PID NS.
 Do a clone3() with CLONE_ARGS_SIZE_VER0. 
 Do a clone3() with CLONE_ARGS_SIZE_VER0 - 8 
 Do a clone3() with sizeof(struct clone_args) + 8 
 Do a clone3() with exit_signal having highest 32 bits non-zero 
 Do a clone3() with negative 32-bit exit_signal 
 Do a clone3() with exit_signal not fitting into CSIGNAL mask 
 Do a clone3() with NSIG < exit_signal < CSIG 
 Do a clone3() with > page size 
 Do a clone3() with CLONE_ARGS_SIZE_VER0 in a new PID NS. 
 Do a clone3() with CLONE_ARGS_SIZE_VER0 - 8 in a new PID NS 
 Do a clone3() with sizeof(struct clone_args) + 8 in a new PID NS 
 Do a clone3() with > page size in a new PID NS 
 SPDX-License-Identifier: GPL-2.0-or-later
  PTP 1588 clock support - User space test program
  Copyright (C) 2010 OMICRON electronics GmbH
 For PPC64, to get LL64 types 
 clock_adjtime is not available in GLIBC < 2.14 
 sigh, uClibc ... 
	
	  The 'freq' field in the 'struct timex' is in parts per
	  million, but with a 16 bit binary fractional field.
	  Instead of calculating either one of
	 
	     scaled_ppm = (ppb  1000) << 16  [1]
	     scaled_ppm = (ppb << 16)  1000  [2]
	 
	  we simply use double precision math, in order to avoid the
	  truncation in [1] and the possible overflow in [2].
 Disable the feature again. 
 SPDX-License-Identifier: GPL-2.0
 Wait when the thread will call clock_nanosleep(). 
 The maximum timeout is about 5 seconds. 
 Try to interrupt clock_nanosleep(). 
 Check whether clock_nanosleep() has been interrupted or not. 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Check that a child process is in the new timens. 
 Check for proper vvar offsets after execve. 
 SPDX-License-Identifier: GPL-2.0
 100ms
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  Test shouldn't be run for a day, so add 10 days to child
  time and check parent's time to be in the same day.
 SPDX-License-Identifier: GPL-2.0
  Test shouldn't be run for a day, so add 10 days to child
  time and check parent's time to be in the same day.
	
	  off_id is -1 if a clock has own offset, or it contains an index
	  which contains a right offset of this clock.
 Let's play nice and put it closer to original 
 Offsets have to be set before tasks enter the namespace. 
  This application is Copyright 2012 Red Hat, Inc.
 	Doug Ledford <dledford@redhat.com>
  mq_perf_tests is free software: you can redistribute it andor modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, version 3.
  mq_perf_tests is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  For the full text of the license, see <http:www.gnu.orglicenses>.
  mq_perf_tests.c
    Tests various types of message queue workloads, concentrating on those
    situations that invole large message sizes, large message queue depths,
    or both, and reports back useful metrics about kernel message queue
    performance.
 In case we get called by multiple threads or from an sighandler 
		
		  Be silent if this fails, if we cleaned up already it's
		  expected to fail
  open_queue - open the global queue for testing
  @attr - An attr struct specifying the desired queue traits
  @result - An attr struct that lists the actual traits the queue has
  This open is not allowed to fail, failure will result in an orderly
  shutdown of the program.  The global queue_path is used to set what
  queue to open, the queue descriptor is saved in the global queue
  variable.
  Tests to perform (all done with MSG_SIZE messages):
  1) Time to addremove message with 0 messages on queue
  1a) with constant prio
  2) Time to addremove message when queue close to capacity:
  2a) with constant prio
  2b) with increasing prio
  2c) with decreasing prio
  2d) with random prio
  3) Test limits of priorities honored (double check _SC_MQ_PRIO_MAX)
			 Double check that they didn't give us the same CPU
			
			  Although we can create a msg queue with a
			  non-absolute path name, unlink will fail.  So,
			  if the name doesn't start with a , add one
			  when we save it.
 Load up the current system values for everything we can 
 Tell the user our initial state 
  This application is Copyright 2012 Red Hat, Inc.
 	Doug Ledford <dledford@redhat.com>
  mq_open_tests is free software: you can redistribute it andor modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, version 3.
  mq_open_tests is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  For the full text of the license, see <http:www.gnu.orglicenses>.
  mq_open_tests.c
    Tests the various situations that should either succeed or fail to
    open a posix message queue and then reports whether or not they
    did as they were supposed to.
 In case we get called recursively by a set() call below 
		
		  Be silent if this fails, if we cleaned up already it's
		  expected to fail
  test_queue - Test opening a queue, shutdown if we fail.  This should
  only be called in situations that should never fail.  We clean up
  after ourselves and return the queue attributes in result.
  Same as test_queue above, but failure is not fatal.
  Returns:
  0 - Failed to create a queue
  1 - Created a queue, attributes in result
	
	  Although we can create a msg queue with a non-absolute path name,
	  unlink will fail.  So, if the name doesn't start with a , add one
	  when we save it.
 Find out what files there are for us to make tweaks in 
 Load up the current system values for everything we can 
 Tell the user our initial state 
		
		  While we are here, go ahead and test that the kernel
		  properly follows the default settings
 In case max was the same as the default 
	
	  Test #2 - open with an attr struct that exceeds rlimit
 SPDX-License-Identifier: GPL-2.0 
 Attempt to de-conflict with the selftests tree. 
	
	  Callers need to see ECHILD with non-blocking pidfds when no child
	  processes exists.
 pidfd_open() doesn't support PIDFD_NONBLOCK. 
 pidfd_open() doesn't support PIDFD_NONBLOCK. 
	
	  Callers need to see EAGAINEWOULDBLOCK with non-blocking pidfd when
	  child processes exist but none have exited.
	
	  Callers need to continue seeing 0 with non-blocking pidfd and
	  WNOHANG raised explicitly when child processes exist but none have
	  exited.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Child process just sleeps for a min and exits 
 Parent kills the child and waits for its death 
 Setup 3 sec alarm - plenty of time 
 Send SIGKILL to the child 
 Wait for the death notification 
 Check for error conditions 
 Wait for child to prevent zombies 
 SPDX-License-Identifier: GPL-2.0
  UNKNOWN_FD is an fd number that should never exist in the child, as it is
  used to check the negative case.
	
	  Ensure we don't leave around a bunch of orphaned children if our
	  tests fail.
	
	  The fixture setup is completed at this point. The tests will run.
	 
	  This blocking recv enables the parent to message the child.
	  Either we will read 'P' off of the sk, indicating that we need
	  to disable ptrace, or we will read a 0, indicating that the other
	  side has closed the sk. This occurs during fixture teardown time,
	  indicating that the child should exit.
	
	  remote_fd is the number of the FD which we are trying to retrieve
	  from the child.
 pid points to the child which we are fetching FDs from 
 pidfd is the pidfd of the child 
	
	  sk is our side of the socketpair used to communicate with the child.
	  When it is closed, the child will exit.
	
	  Wait for the child to complete setup. It'll send the remote memfd's
	  number when ready.
	
	  Turn into nobody if we're root, to avoid CAP_SYS_PTRACE
	 
	  The tests should run in their own process, so even this test fails,
	  it shouldn't result in subsequent tests failing.
 SPDX-License-Identifier: GPL-2.0 
 seconds 
  Straightforward test to see whether pidfd_send_signal() works is to send
  a signal to ourself.
  Maximum number of cycles we allow. This is equivalent to PID_MAX_DEFAULT.
  If users set a higher limit or we have cycled PIDFD_MAX_DEFAULT number of
  times then we skip the test to not go into an infinite loop or block for a
  long time.
 pid 1 in new pid namespace 
 grab pid PID_RECYCLE 
		
		  We want to be as predictable as we can so if we haven't been
		  able to grab pid PID_RECYCLE skip the test.
 skip test 
			
			  Stop the child so we can inspect whether we have
			  recycled pid PID_RECYCLE.
			
			  We have recycled the pid. Try to signal it. This
			  needs to fail since this is a different process than
			  the one the pidfd refers to.
 let the process move on 
 fallthrough 
 not reached 
			
			  If the user set a custom pid_max limit we could be
			  in the millions.
			  Skip the test in this case.
 failed to recycle pid 
 PIDFD_ERROR :
	
	  Exec in the non-leader thread will destroy the leader immediately.
	  If the wait in the parent returns too soon, the test fails.
	
	  glibc exit calls exit_group syscall, so explicity call exit only
	  so that only the group leader exits, leaving the threads alone.
		
		  This sleep tests for the case where if the child exits, and is in
		  EXIT_ZOMBIE, but the thread group leader is non-empty, then the poll
		  doesn't prematurely return even though there are active threads
 SPDX-License-Identifier: GPL-2.0
 Create task that exits right away. 
 Create tasks that will be stopped. 
 processes are in the same namespace 
 processes are in different namespaces 
 Test that we can't pass garbage to the kernel. 
 Test that we can't attach to a task that has already exited. 
 Verify that we haven't changed any namespaces. 
 Verify that we have changed to the correct namespaces. 
 Verify that we have changed to the correct namespaces. 
 Verify that we have changed to the correct namespaces. 
 No use logging pid_for_children. 
	
	  Can't setns to a user namespace outside of our hierarchy since we
	  don't have caps in there and didn't create it. That means that under
	  no circumstances should we be able to setns to any of the other
	  ones since they aren't owned by our user namespace.
 SPDX-License-Identifier: GPL-2.0
 will be: not ok %d # error %s test: %s 
 will be: not ok %d # SKIP %s test: %s 
 In case of error we bail out and terminate the test program 
 if we got no fd for the sibling, we are done 
	 verify that we can not resolve the pidfd for a process
	  in a sibling pid namespace, i.e. a pid namespace it is
	  not in our or a descended namespace
 Create a new child in a new pid and mount namespace 
	 Pass the pidfd representing the first child to the
	  second child, which will be in a sibling pid namespace,
	  which means that the fdinfo NSpid entry for the pidfd
	  should only contain '0'.
	 The children will have pid 1 in the new pid namespace,
	  so the line must be 'NSPid:\t<pid>\t1'.
	 wait for the process, check the exit status and set
	  'err' accordingly, if it is not already set.
 Create a new child in a new pid and mount namespace 
  Regression test for:
  35f71bc0a09a ("fork: report pid reservation failure properly")
  b26ebfe12f34 ("pid: Fix error return value in some cases")
 SPDX-License-Identifier: GPL-2.0
 An example of output and arguments 
 This one should fail 
 This one should return same fd 
 Compare with self 
 Compare epoll target 
 SPDX-License-Identifier: GPL-2.0
 needed to get the defines 
#include <fcntl.h>	 in glibc 2.2 this has the needed
	 we will now be notified if any of the files
 SPDX-License-Identifier: GPL-2.0
	
	  grantpt() makes assumptions about devpts so ignore it. It's also
	  not really needed.
 SPDX-License-Identifier: GPL-2.0
           t0
            | (ew)
           e0
            | (lt)
           s0
           t0
            | (ew)
           e0
            | (et)
           s0
            t0
             | (ew)
            e0
      (lt)   \ (lt)
         s0    s2
            t0
             | (ew)
            e0
      (et)   \ (et)
         s0    s2
           t0
            | (p)
           e0
            | (lt)
           s0
           t0
            | (p)
           e0
            | (et)
           s0
            t0
             | (p)
            e0
      (lt)   \ (lt)
         s0    s2
            t0
             | (p)
            e0
      (et)   \ (et)
         s0    s2
         t0    t1
      (ew) \   (ew)
            e0
             | (lt)
            s0
         t0    t1
      (ew) \   (ew)
            e0
             | (et)
            s0
         t0    t1
      (ew) \   (ew)
            e0
      (lt)   \ (lt)
         s0    s2
         t0    t1
      (ew) \   (ew)
            e0
      (et)   \ (et)
         s0    s2
         t0    t1
      (ew) \   (p)
            e0
             | (lt)
            s0
         t0    t1
      (ew) \   (p)
            e0
             | (et)
            s0
         t0    t1
      (ew) \   (p)
            e0
      (lt)   \ (lt)
         s0    s2
         t0    t1
      (ew) \   (p)
            e0
      (et)   \ (et)
         s0    s2
           t0
            | (ew)
           e0
            | (lt)
           e1
            | (lt)
           s0
           t0
            | (ew)
           e0
            | (lt)
           e1
            | (et)
           s0
            t0
             | (ew)
            e0
             | (et)
            e1
             | (lt)
            s0
            t0
             | (ew)
            e0
             | (et)
            e1
             | (et)
            s0
           t0
            | (p)
           e0
            | (lt)
           e1
            | (lt)
           s0
           t0
            | (p)
           e0
            | (lt)
           e1
            | (et)
           s0
           t0
            | (p)
           e0
            | (et)
           e1
            | (lt)
           s0
           t0
            | (p)
           e0
            | (et)
           e1
            | (et)
           s0
         t0    t1
      (ew) \   (ew)
            e0
             | (lt)
            e1
             | (lt)
            s0
         t0    t1
      (ew) \   (ew)
            e0
             | (lt)
            e1
             | (et)
            s0
         t0    t1
      (ew) \   (ew)
            e0
             | (et)
            e1
             | (lt)
            s0
         t0    t1
      (ew) \   (ew)
            e0
             | (et)
            e1
             | (et)
            s0
         t0    t1
      (ew) \   (p)
            e0
             | (lt)
            e1
             | (lt)
            s0
         t0    t1
      (ew) \   (p)
            e0
             | (lt)
            e1
             | (et)
            s0
         t0    t1
      (ew) \   (p)
            e0
             | (et)
            e1
             | (lt)
            s0
         t0    t1
      (ew) \   (p)
            e0
             | (et)
            e1
             | (et)
            s0
         t0   t1
     (ew) |    | (ew)
          |   e0
           \   (lt)
            e1
             | (lt)
            s0
         t0   t1
     (ew) |    | (ew)
          |   e0
           \   (lt)
            e1
             | (et)
            s0
         t0   t1
     (ew) |    | (ew)
          |   e0
           \   (et)
            e1
             | (lt)
            s0
         t0   t1
     (ew) |    | (ew)
          |   e0
           \   (et)
            e1
             | (et)
            s0
         t0   t1
      (p) |    | (ew)
          |   e0
           \   (lt)
            e1
             | (lt)
            s0
         t0   t1
      (p) |    | (ew)
          |   e0
           \   (lt)
            e1
             | (et)
            s0
         t0   t1
      (p) |    | (ew)
          |   e0
           \   (et)
            e1
             | (lt)
            s0
         t0   t1
      (p) |    | (ew)
          |   e0
           \   (et)
            e1
             | (et)
            s0
         t0   t1
     (ew) |    | (p)
          |   e0
           \   (lt)
            e1
             | (lt)
            s0
         t0   t1
     (ew) |    | (p)
          |   e0
           \   (lt)
            e1
             | (et)
            s0
         t0   t1
     (ew) |    | (p)
          |   e0
           \   (et)
            e1
             | (lt)
            s0
         t0   t1
     (ew) |    | (p)
          |   e0
           \   (et)
            e1
             | (et)
            s0
         t0   t1
      (p) |    | (p)
          |   e0
           \   (lt)
            e1
             | (lt)
            s0
         t0   t1
      (p) |    | (p)
          |   e0
           \   (lt)
            e1
             | (et)
            s0
         t0   t1
      (p) |    | (p)
          |   e0
           \   (et)
            e1
             | (lt)
            s0
         t0   t1
      (p) |    | (p)
          |   e0
           \   (et)
            e1
             | (et)
            s0
            t0
             | (ew)
            e0
      (lt)   \ (lt)
         e1    e2
     (lt) |     | (lt)
         s0    s2
            t0
             | (ew)
            e0
      (et)   \ (et)
         e1    e2
     (lt) |     | (lt)
         s0    s2
            t0
             | (p)
            e0
      (lt)   \ (lt)
         e1    e2
     (lt) |     | (lt)
         s0    s2
            t0
             | (p)
            e0
      (et)   \ (et)
         e1    e2
     (lt) |     | (lt)
         s0    s2
         t0    t1
      (ew) \   (ew)
            e0
      (lt)   \ (lt)
         e1    e2
     (lt) |     | (lt)
         s0    s2
         t0    t1
      (ew) \   (ew)
            e0
      (et)   \ (et)
         e1    e2
     (lt) |     | (lt)
         s0    s2
         t0    t1
      (ew) \   (p)
            e0
      (lt)   \ (lt)
         e1    e2
     (lt) |     | (lt)
         s0    s2
         t0    t1
      (ew) \   (p)
            e0
      (et)   \ (et)
         e1    e2
     (lt) |     | (lt)
         s0    s2
         t0    t1
       (p) \   (p)
            e0
      (lt)   \ (lt)
         e1    e2
     (lt) |     | (lt)
         s0    s2
         t0    t1
       (p) \   (p)
            e0
      (et)   \ (et)
         e1    e2
     (lt) |     | (lt)
         s0    s2
         t0
       (p) \
            e0
      (et) 
         e0
  Based on https:bugzilla.kernel.orgshow_bug.cgi?id=205933
 Block SIGUSR1 
 Prepare empty mask for epoll_pwait() 
 Mark we are ready 
 Start when all are ready 
 Account this waiter 
 We expect only signal delivery on stop 
 Since we are on ET mode, thus each thread gets its own fd. 
 Create event fds 
 Create waiter threads 
 Wait for all to be ready 
 Steady, go 
 Wait all have gone to kernel 
 1ms should be enough to schedule away 
 Quickly signal all handles at once 
 Busy loop for 1s and wait for all waiters to wake up 
 Stop waiters 
	
	  If epoll returned the eventfd, write on the eventfd to wake up the
	  blocking poller.
	
	  We are testing a race.  Repeat the test case 1000 times to make it
	  more likely to fail in case of a bug.
		
		  Start 3 threads:
		  Thread 1 sleeps for 10.9ms and writes to the evenfd.
		  Thread 2 calls epoll with a timeout of 11ms.
		  Thread 3 calls epoll with a timeout of -1.
		 
		  The eventfd write by Thread 1 should either wakeup Thread 2
		  or Thread 3.  If it wakes up Thread 2, Thread 2 writes on the
		  eventfd to wake up Thread 3.
		 
		  If no events are missed, all three threads should eventually
		  be joinable.
 Equivalent to basic test epoll1, but exercising epoll_pwait2. 
 Epoll_pwait2 basic timeout test. 
         t0    t1
      (ew) \   (ew)
            e0
             | (lt)
            s0
	
	  main will act as the emitter once both waiter threads are
	  blocked and expects to both be awoken upon the ready event.
 SPDX-License-Identifier: GPL-2.0
 success: binderfs mounted 
 success: binder device allocation 
 success: binder transaction with binderfs binder device 
 success: binder device removal 
 success: binder-control device removal failed as expected 
 success: binder feature files found 
  Regression test:
  2669b8b0c798 ("binder: prevent UAF for binderfs devices")
  f0fe2c0f050d ("binder: prevent UAF for binderfs devices II")
  211b64e4b5b6 ("binderfs: use refcount for binder control devices too")
 SPDX-License-Identifier: GPL-2.0
 Attempt to de-conflict with the selftests tree. 
 SPDX-License-Identifier: GPL-2.0
  selftest for sparc64's privileged ADI driver
  Author: Tom Hromatka <tom.hromatka@oracle.com>
 bit mask of enabled bits to print 
			 Given a line like this:
			  d0400000-10ffaffff : System RAM
			  replace the "-" with a space
 somewhat arbitrarily chosen address 
 somewhat arbitrarily chosen address 
 somewhat arbitrarily chosen address 
 somewhat arbitrarily chosen address 
 seek to the current offset.  this should return EINVAL 
 somewhat arbitrarily chosen address 
 somewhat arbitrarily chosen address 
 somewhat arbitrarily chosen address 
	 it's impossible to get here, but the compiler throws a warning
	  about control reaching the end of non-void function.  bah.
 SPDX-License-Identifier: GPL-2.0
  video_device_test - Video Device Test
  Copyright (c) 2016 Shuah Khan <shuahkh@osg.samsung.com>
  Copyright (c) 2016 Samsung Electronics Co., Ltd.
  This file adds a test for Video Device. This test should not be included
  in the Kselftest run. This test should be run when hardware and driver
  that makes use of V4L2 API is present.
  This test opens user specified Video Device and calls video ioctls in a
  loop once every 10 seconds.
  Usage:
 	sudo .video_device_test -d devvideoX
 	While test is running, remove the device or unbind the driver and
 	ensure there are no use after free errors and other Oops in the
 	dmesg.
 	When possible, enable KaSan kernel config option for use-after-free
 	error detection.
 Process arguments 
 Generate random number of interations 
 Open Video device and keep it open 
 SPDX-License-Identifier: GPL-2.0
  media_device_open.c - Media Controller Device Open Test
  Copyright (c) 2016 Shuah Khan <shuahkh@osg.samsung.com>
  Copyright (c) 2016 Samsung Electronics Co., Ltd.
  This file adds a test for Media Controller API.
  This test should be run as root and should not be
  included in the Kselftest run. This test should be
  run when hardware and driver that makes use Media
  Controller API are present in the system.
  This test opens user specified Media Device and calls
  MEDIA_IOC_DEVICE_INFO ioctl, closes the file, and exits.
  Usage:
 	sudo .media_device_open -d devmediaX
 	Run this test is a loop and run bindunbind on the driver.
 Process arguments 
 Open Media device and keep it open 
 SPDX-License-Identifier: GPL-2.0
  media_device_test.c - Media Controller Device ioctl loop Test
  Copyright (c) 2016 Shuah Khan <shuahkh@osg.samsung.com>
  Copyright (c) 2016 Samsung Electronics Co., Ltd.
  This file adds a test for Media Controller API.
  This test should be run as root and should not be
  included in the Kselftest run. This test should be
  run when hardware and driver that makes use Media
  Controller API are present in the system.
  This test opens user specified Media Device and calls
  MEDIA_IOC_DEVICE_INFO ioctl in a loop once every 10
  seconds.
  Usage:
 	sudo .media_device_test -d devmediaX
 	While test is running, remove the device and
 	ensure there are no use after free errors and
 	other Oops in the dmesg. Enable KaSan kernel
 	config option for use-after-free error detection.
 Process arguments 
 Generate random number of interations 
 Open Media device and keep it open 
 SPDX-License-Identifier: GPL-2.0-only
  Exercise devmem mmap cases that have been troublesome in the past
  (c) Copyright 2007 Hewlett-Packard Development Company, L.P.
 	Bjorn Helgaas <bjorn.helgaas@hp.com>
	if (fnmatch("procbuspci", path, 0) == 0) {
		rc = ioctl(fd, PCIIOC_MMAP_IS_MEM);
		if (rc == -1)
			perror("PCIIOC_MMAP_IS_MEM ioctl");
	}
	addr = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_SHARED, fd, offset);
	if (addr == MAP_FAILED)
		return 1;
	if (touch) {
		c = (int ) addr;
		while (c < (int ) (addr + length))
			sum += c++;
	}
	rc = munmap(addr, length);
	if (rc == -1) {
		perror("munmap");
		return -1;
	}
	close(fd);
	return 0;
}
static int scan_tree(char path, char file, off_t offset, size_t length, int touch)
{
	struct dirent namelist;
	char name, path2;
	int i, n, r, rc = 0, result = 0;
	struct stat buf;
	n = scandir(path, &namelist, 0, alphasort);
	if (n < 0) {
		perror("scandir");
		return -1;
	}
	for (i = 0; i < n; i++) {
		name = namelist[i]->d_name;
		if (fnmatch(".", name, 0) == 0)
			goto skip;
		if (fnmatch("..", name, 0) == 0)
			goto skip;
		path2 = malloc(strlen(path) + strlen(name) + 3);
		strcpy(path2, path);
		strcat(path2, "");
		strcat(path2, name);
		if (fnmatch(file, name, 0) == 0) {
			rc = map_mem(path2, offset, length, touch);
			if (rc == 0)
				fprintf(stderr, "PASS: %s 0x%lx-0x%lx is %s\n", path2, offset, offset + length, touch ? "readable" : "mappable");
			else if (rc > 0)
				fprintf(stderr, "PASS: %s 0x%lx-0x%lx not mappable\n", path2, offset, offset + length);
			else {
				fprintf(stderr, "FAIL: %s 0x%lx-0x%lx not accessible\n", path2, offset, offset + length);
				return rc;
			}
		} else {
			r = lstat(path2, &buf);
			if (r == 0 && S_ISDIR(buf.st_mode)) {
				rc = scan_tree(path2, file, offset, length, touch);
				if (rc < 0)
					return rc;
			}
		}
		result |= rc;
		free(path2);
skip:
		free(namelist[i]);
	}
	free(namelist);
	return result;
}
char buf[1024];
static int read_rom(char path)
{
	int fd, rc;
	size_t size = 0;
	fd = open(path, O_RDWR);
	if (fd == -1) {
		perror(path);
		return -1;
	}
	rc = write(fd, "1", 2);
	if (rc <= 0) {
		close(fd);
		perror("write");
		return -1;
	}
	do {
		rc = read(fd, buf, sizeof(buf));
		if (rc > 0)
			size += rc;
	} while (rc > 0);
	close(fd);
	return size;
}
static int scan_rom(char path, char file)
{
	struct dirent namelist;
	char name, path2;
	int i, n, r, rc = 0, result = 0;
	struct stat buf;
	n = scandir(path, &namelist, 0, alphasort);
	if (n < 0) {
		perror("scandir");
		return -1;
	}
	for (i = 0; i < n; i++) {
		name = namelist[i]->d_name;
		if (fnmatch(".", name, 0) == 0)
			goto skip;
		if (fnmatch("..", name, 0) == 0)
			goto skip;
		path2 = malloc(strlen(path) + strlen(name) + 3);
		strcpy(path2, path);
		strcat(path2, "");
		strcat(path2, name);
		if (fnmatch(file, name, 0) == 0) {
			rc = read_rom(path2);
			 
			if (rc > 0)
				fprintf(stderr, "PASS: %s read %d bytes\n", path2, rc);
			else {
				fprintf(stderr, "PASS: %s not readable\n", path2);
				return rc;
			}
		} else {
			r = lstat(path2, &buf);
			if (r == 0 && S_ISDIR(buf.st_mode)) {
				rc = scan_rom(path2, file);
				if (rc < 0)
					return rc;
			}
		}
		result |= rc;
		free(path2);
skip:
		free(namelist[i]);
	}
	free(namelist);
	return result;
}
int main(void)
{
	int rc;
	if (map_mem("devmem", 0, 0xA0000, 1) == 0)
		fprintf(stderr, "PASS: devmem 0x0-0xa0000 is readable\n");
	else
		fprintf(stderr, "FAIL: devmem 0x0-0xa0000 not accessible\n");
	 
	if (map_mem("devmem", 0xA0000, 0x20000, 0) == 0)
		fprintf(stderr, "PASS: devmem 0xa0000-0xc0000 is mappable\n");
	else
		fprintf(stderr, "FAIL: devmem 0xa0000-0xc0000 not accessible\n");
	if (map_mem("devmem", 0xC0000, 0x40000, 1) == 0)
		fprintf(stderr, "PASS: devmem 0xc0000-0x100000 is readable\n");
	else
		fprintf(stderr, "FAIL: devmem 0xc0000-0x100000 not accessible\n");
	 
	rc = map_mem("devmem", 0, 10241024, 0);
	if (rc == 0)
		fprintf(stderr, "PASS: devmem 0x0-0x100000 is mappable\n");
	else if (rc > 0)
		fprintf(stderr, "PASS: devmem 0x0-0x100000 not mappable\n");
	else
		fprintf(stderr, "FAIL: devmem 0x0-0x100000 not accessible\n");
	scan_tree("sysclasspci_bus", "legacy_mem", 0, 0xA0000, 1);
	scan_tree("sysclasspci_bus", "legacy_mem", 0xA0000, 0x20000, 0);
	scan_tree("sysclasspci_bus", "legacy_mem", 0xC0000, 0x40000, 1);
	scan_tree("sysclasspci_bus", "legacy_mem", 0, 10241024, 0);
	scan_rom("sysdevices", "rom");
	scan_tree("procbuspci", "??.?", 0, 0xA0000, 1);
	scan_tree("procbuspci", "??.?", 0xA0000, 0x20000, 0);
	scan_tree("procbuspci", "??.?", 0xC0000, 0x40000, 1);
	scan_tree("procbuspci", "??.?", 0, 10241024, 0);
	return rc;
}
 SPDX-License-Identifier: GPL-2.0
  Stas Sergeev <stsp@users.sourceforge.net>
  test sigaltstack(SS_ONSTACK | SS_AUTODISARM)
  If that succeeds, then swapcontext() can be used inside sighandler safely.
 put some data on stack. other sighandler will try to overwrite it 
 dont run valgrind on this 
 try to find the data stored by previous sighandler 
 corrupt the data 
 tell other sighandler that his data is corrupted 
 Make sure more than the required minimum. 
			
			  If test cases for the !SS_AUTODISARM variant were
			  added, we could still run them.  We don't have any
			  test cases like that yet, so just exit and report
			  success.
 SPDX-License-Identifier: GPL-2.0
 create a test variable 
 SPDX-License-Identifier: GPL-2.0
	 attributes: EFI_VARIABLE_NON_VOLATILE |
	 		EFI_VARIABLE_BOOTSERVICE_ACCESS |
	 		EFI_VARIABLE_RUNTIME_ACCESS
 create a test variable 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-or-later
 Real Time Clock Driver Test
 	by: Benjamin Gaignard (benjamin.gaignard@linaro.org)
  To build
 	gcc rtctest_setdate.c -o rtctest_setdate
 FALLTHROUGH 
 Write the new date in RTC 
 Read back 
 SPDX-License-Identifier: GPL-2.0
  Real Time Clock Driver Test Program
  Copyright (c) 2018 Alexandre Belloni <alexandre.belloni@bootlin.com>
 Read the RTC timedate 
 Turn on update interrupts 
 This read will block 
 Turn on update interrupts 
 The select will wait until an RTC interrupt happens. 
 This read won't block 
 Enable alarm interrupts 
 Disable alarm interrupts 
 Enable alarm interrupts 
 Disable alarm interrupts 
 FALLTHROUGH 
 SPDX-License-Identifier: GPL-2.0+
  kselftest suite for mincore().
  Copyright (C) 2020 Collabora, Ltd.
 Default test file size: 4MB 
  Tests the user interface. This test triggers most of the documented
  error conditions in mincore().
 Query a 0 byte sized range 
 Addresses in the specified range are invalid or unmapped 
 <addr> argument is not page-aligned 
 <length> argument is too large 
 <vec> argument points to an illegal address 
  Test mincore() behavior on a private anonymous page mapping.
  Check that the page is not loaded into memory right after the mapping
  but after accessing it (on-demand allocation).
  Then free the page and check that it's not memory-resident.
 Map one page and check it's not memory-resident 
 Touch the page and check again. It should now be in memory 
	
	  It shouldn't be memory-resident after unlocking it and
	  marking it as unneeded.
  Check mincore() behavior on huge pages.
  This test will be skipped if the mapping fails (ie. if there are no
  huge pages available).
  Make sure the system has at least one free huge page, check
  "HugePages_Free" in procmeminfo.
  Increment syskernelmmhugepageshugepages-2048kBnr_hugepages if
  needed.
  Test mincore() behavior on a file-backed page.
  No pages should be loaded into memory right after the mapping. Then,
  accessing any address in the mapping range should load the page
  containing the address and a number of subsequent pages (readahead).
  The actual readahead settings depend on the test environment, so we
  can't make a lot of assumptions about that. This test covers the most
  general cases.
	
	  Map the whole file, the pages shouldn't be fetched yet.
	
	  Touch a page in the middle of the mapping. We expect the next
	  few pages (the readahead window) to be populated too.
	
	  End of the readahead window. The rest of the pages shouldn't
	  be in memory.
  Test mincore() behavior on a page backed by a tmpfs file.  This test
  performs the same steps as the previous one. However, we don't expect
  any readahead in this case.
	
	  Map the whole file, the pages shouldn't be fetched yet.
	
	  Touch a page in the middle of the mapping. We expect only
	  that page to be fetched into memory.
