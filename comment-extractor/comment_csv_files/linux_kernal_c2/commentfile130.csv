 SPDX-License-Identifier: GPL-2.0+
  V4L2 Capture IC Preprocess Subdev for Freescale i.MX56 SOC
  This subdevice handles capture of video frames from the CSI or VDIC,
  which are routed directly to the Image Converter preprocess tasks,
  for resizing, colorspace conversion, and rotation.
  Copyright (c) 2012-2017 Mentor Graphics Inc.
  MinMax supported width and heights.
  We allow planar output, so we have to align width at the source pad
  by 16 pixels to meet IDMAC alignment requirements for possible planar
  output.
  TODO: move this into pad format negotiation, if capture device
  has not requested a planar format, we should allow 8 pixel
  alignment at the source pad.
 multiple of 8 pixels 
 multiple of 2 lines 
 multiple of 2 pixels 
 multiple of 2 lines 
 multiple of 2 
 the video device at output pad 
 lock to protect all members below 
 IPU units we require 
 active vb2 buffers to send to video dev sink 
 ipu double buffer index: 0-1 
 the sink for the captured frames 
 the source subdev 
 controls 
 degrees 
 derived from rotation, hflip, vflip controls 
 protect eof_irq handler 
 frame sequence counter 
 waiting for last EOF at stream off 
 NFB4EOF encountered during streaming 
 swap topbottom lines when interweaving 
 get next queued buffer 
 select new IPU buf 
 toggle IPU double-buffer index 
 bump the EOF timeout timer 
	
	  this is not an unrecoverable error, just mark
	  the next captured frame with vb2 error flag.
  EOF timeout timer function.
  EOF timeout timer function. This is an unrecoverable condition
  without a stream restart.
 signal a fatal error to capture device 
 return any remaining active frames with return_status 
	
	  If the field type at capture interface is interlaced, and
	  the output IDMAC pad is sequential, enable interweave at
	  the IDMAC output channel.
 recalc stride using swapped width 
 start interweave scan at 1st top line (2nd line) 
	
	  Skip writing U and V components to odd rows in the output
	  channels for planar 4:2:0 (but not when enabling IDMAC
	  interweaving, they are incompatible).
 init the IC-PRP-->MEM IDMAC channel 
 init the MEM-->IC-PRP ROT IDMAC channel 
 init the destination IC-PRP ROT-->MEM IDMAC channel 
 now link IC-PRP-->MEM to MEM-->IC-PRP ROT 
 enable the IC 
 set buffers ready 
 enable the channels 
 and finally enable the IC PRP task 
 init the IC PRP-->MEM IDMAC channel 
 set buffers ready 
 enable the channels 
 enable the IC task 
 init EOF completion waitq 
 start upstream 
 start the EOF timeout timer 
 mark next EOF interrupt as the last before stream off 
	
	  and then wait for interrupt handler to mark completion.
 stop upstream 
 cancel the EOF timeout timer 
  Applies IC resizer and IDMAC alignment restrictions to output
  rectangle given the input rectangle, and depending on given
  rotation mode.
  The IC resizer cannot downsize more than 4:1. Note also that
  for 90 or 270 rotation, _both_ output width and height must
  be aligned by W_ALIGN_SRC, because the intermediate rotation
  buffer swaps output widthheight, and the final output buffer
  does not.
  Returns true if the output rectangle was modified.
  V4L2 subdev operations.
 propagate colorimetry from sink 
 propagate a default format to source pad 
 this is the source pad 
 the remote must be the device node 
 can't change rotation mid-streaming 
	
	  enabledisable streaming only if stream_count is
	  going from 0 to 1  1 to 0.
 No limits on valid frame intervals 
 set a default mbus format  
 init default frame interval 
 SPDX-License-Identifier: GPL-2.0
  V4L2 Media Controller Driver for Freescale common i.MX567 SOC
  Copyright (c) 2019 Linaro Ltd
  Copyright (c) 2016 Mentor Graphics Inc.
 async subdev bound notifier 
  Create the missing media links from the CSI-2 receiver.
  Called after all async subdevs have bound.
 skip if not a CSI or a CSI mux 
  adds given video device to given imx-media source pad vdev list.
  Continues upstream from the pad entity's sink pads.
 skip this entity if not a v4l2_subdev 
		
		  shouldn't happen, but no reason to fail driver load,
		  just skip this entity.
 just return if we've been here before 
 attach this vdev to this pad 
 move upstream from this entity's sink pads 
  For every subdevice, allocate an array of list_head's, one list_head
  for each pad, to hold the list of video devices reachable from that
  pad.
 attach to the subdev's host private pointer 
 form the vdev lists in all imx-media source pads 
 async subdev complete notifier 
  adds controls to a video device from an entity subdevice.
  Continues upstream from the entity's sink pads.
 move upstream 
 don't bother if source is not a subdev 
 nothing to do if source sd has no pad vdev list 
	
	  Before disabling a link, reset controls for all video
	  devices reachable from this link.
	 
	  After enabling a link, refresh controls for all video
	  devices reachable from this link.
 no subdevs? just bail 
 prepare the async subdev notifier and register it 
 SPDX-License-Identifier: GPL-2.0+
  V4L2 Deinterlacer Subdev for Freescale i.MX56 SOC
  Copyright (c) 2017 Mentor Graphics Inc.
  This subdev implements two different video pipelines:
  CSI -> VDIC
  In this pipeline, the CSI sends a single interlaced field F(n-1)
  directly to the VDIC (and optionally the following field F(n)
  can be sent to memory via IDMAC channel 13). This pipeline only works
  in VDIC's high motion mode, which only requires a single field for
  processing. The other motion modes (low and medium) require three
  fields, so this pipeline does not work in those modes. Also, it is
  not clear how this pipeline can deal with the various field orders
  (sequential BTTB, interlaced BTTB).
  MEM -> CH8,9,10 -> VDIC
  In this pipeline, previous field F(n-1), current field F(n), and next
  field F(n+1) are transferred to the VDIC via IDMAC channels 8,9,10.
  These memory buffers can come from a video output or mem2mem device.
  All motion modes are supported by this pipeline.
  The "direct" CSI->VDIC pipeline requires no DMA, but it can only be
  used in high motion mode.
  MinMax supported width and heights.
 multiple of 16 pixels 
 multiple of 2 lines 
 multiple of 2 
 lock to protect all members below 
 IPU units we require 
 F(n-1) transfer channel 
 F(n) transfer channel 
 F(n+1) transfer channel 
 pipeline operations 
 current and previous input buffers indirect path 
	
	  translated field type, input line stride, and field size
	  for indirect path
 the source (a video device or subdev) 
 the sink that will receive the progressive out buffers 
 the video device at IDMAC input pad 
 using direct CSI->VDIC->IC pipeline 
 motion select control 
  This function is currently unused, but will be called when the
  outputmem2mem device at the IDMAC input pad sends us a new
  buffer. It kicks off the IDMAC read channels to bring in the
  buffer fields from memory and begin the conversions.
 current input buffer is now previous 
		
		  can't get here, priv->fieldtype can only be one of
		  the above. This is to quiet smatch errors.
 one field to VDIC channels 
 set VDIC to receive from CSI for direct path 
 12 full image size 
 init the vdi-in channels 
 enable the channels 
 disable channels 
	
	  init the VDIC.
	 
	  note we don't give infmt->code to ipu_vdi_setup(). The VDIC
	  only supports 4:2:2 or 4:2:0, and this subdev will only
	  negotiate 4:2:2 at its sink pads.
  V4L2 subdev operations.
 can't change motion control mid-streaming 
	
	  enabledisable streaming only if stream_count is
	  going from 0 to 1  1 to 0.
 startstop upstream 
 output is always progressive! 
 input must be interlaced! Choose SEQ_TB if not 
 propagate format to source pad 
 this is a sink pad 
 direct pad must connect to a CSI 
 record which input pad is now active 
 No limits on valid input frame intervals 
 Reset output interval 
		
		  frame rate at output pad is double input
		  rate when using direct CSI->VDIC pipeline.
		 
		  TODO: implement VDIC frame skipping
 set a default mbus format  
 init default frame interval 
 SPDX-License-Identifier: GPL-2.0
  Freescale i.MX7 SoC series MIPI-CSI V3.3 receiver driver
  Copyright (C) 2019 Linaro Ltd
  Copyright (C) 2015-2016 Freescale Semiconductor, Inc. All Rights Reserved.
  Copyright (C) 2011 - 2013 Samsung Electronics Co., Ltd.
 Register map definition 
 CSIS common control 
 CSIS clock control 
 CSIS Interrupt mask 
 CSIS Interrupt source 
 D-PHY status control 
 D-PHY common control 
 D-PHY Master and Slave Control register Low 
 D-PHY Master and Slave Control register High 
 D-PHY Slave Control register Low 
 D-PHY Slave Control register High 
 ISP Configuration register 
 i.MX8M[MNP] only 
 ISP Image Resolution register 
 ISP SYNC register 
 ISP shadow registers 
 Debug control register 
 Non-image packet data buffers 
 MIPI CSI-2 Data Types 
 Errors 
 Non-image data receive events 
 Frame startend 
 Protect csis_fmt, format_mbus and state 
 Protect events 
 -----------------------------------------------------------------------------
  Format helpers
 YUV formats. 
 RAW (Bayer and greyscale) formats. 
 -----------------------------------------------------------------------------
  Hardware configuration
 Called with the state.lock mutex held 
 Color format 
 Pixel resolution 
 Calculate the line rate from the pixel rate. 
	
	  The HSSETTLE counter value is document in a table, but can also
	  easily be calculated. Hardcode the CLKSETTLE value to 0 for now
	  (which is documented as corresponding to CSI-2 v0.87 to v1.00) until
	  we figure out how to compute it correctly.
 Update the shadow register. 
 Set clock rate 
 Update the eventerror counters 
 -----------------------------------------------------------------------------
  PHY regulator and reset
 Get MIPI PHY reset and regulator. 
 -----------------------------------------------------------------------------
  Debug
 -----------------------------------------------------------------------------
  V4L2 subdev operations
	
	  When called from mipi_csis_subdev_init() to initialize the active
	  configuration, cfg is NULL, which indicates there's no source pad
	  configuration to set.
	
	  The CSIS can't transcode in any way, the source format is identical
	  to the sink format.
	
	  The CSIS can't transcode in any way, the source format can't be
	  modified.
	
	  Validate the media bus code and clamp and align the size.
	 
	  The total number of bits per line must be a multiple of 8. We thus
	  need to align the width for formats that are not multiples of 8
	  bits.
 1, 3, 5, 7 
 Propagate the format from sink to source. 
 Store the CSIS format descriptor for active formats. 
 -----------------------------------------------------------------------------
  Media entity operations
 We only care about the link to the source. 
 -----------------------------------------------------------------------------
  Async subdev notifier
 -----------------------------------------------------------------------------
  Suspendresume
 -----------------------------------------------------------------------------
  Proberemove & platform driver
 Parse DT properties. 
 Acquire resources. 
 Reset PHY and enable the clocks. 
 Now that the hardware is initialized, request the interrupt. 
 Initialize and register the subdev. 
 Initialize debugfs. 
 Enable runtime PM. 
 sentinel  },
 SPDX-License-Identifier: GPL-2.0+
  V4L2 Image Converter Subdev for Freescale i.MX56 SOC
  Copyright (c) 2014-2016 Mentor Graphics Inc.
 get our IC task id 
 SPDX-License-Identifier: GPL-2.0
  V4L2 Capture CSI Subdev for Freescale i.MX6ULL  i.MX7 SOC
  Copyright (c) 2019 Linaro Ltd
 csi control reg 1 
 control reg 2 
 control reg 3 
 csi status reg 
 csi image parameter reg 
 csi control reg 18 
 lock to protect members below 
 lock to protect irq handler when stop streaming 
 active vb2 buffers to send to video dev sink 
 -----------------------------------------------------------------------------
  Hardware Configuration
 return any remaining active frames with return_status 
 mark next EOF interrupt as the last before stream off 
	
	  and then wait for interrupt handler to mark completion.
		
		  CSI-2 sources are supposed to use the 1X16 formats, but not
		  all of them comply. Support both variants.
 Clear the Rx FIFO and reflash the DMA controller. 
 Clear and enable the interrupts. 
 Enable the RxFIFO DMA and the CSI. 
 -----------------------------------------------------------------------------
  Interrupt Handling
 get next queued buffer 
		
		  For both FB1 and FB2 interrupter bits set case,
		  CSI DMA is work in one of FB1 and FB2 buffer,
		  but software can not know the state.
		  Skip it to avoid base address updated
		  when csi work in field0 and field1 will write to
		  new base address.
 -----------------------------------------------------------------------------
  V4L2 Subdev Operations
 propagate format to source pads 
	
	  Validate the source link, and record whether the source uses the
	  parallel input or the CSI-2 receiver.
 The input is the CSI-2 receiver. 
 The input is the mux, check its input. 
		
		  The input is an external entity, it must use the parallel
		  bus.
 Validate the sink link, ensure the pixel format is supported. 
 set a default mbus format  
 init default frame interval 
 -----------------------------------------------------------------------------
  Media Entity Operations
 -----------------------------------------------------------------------------
  Probe & Remove
	
	  If the subdev is a video mux, it must be one of the CSI
	  muxes. Mark it as such via its group id.
 OK if asd already exists 
 install interrupt handler 
 add media device 
 SPDX-License-Identifier: GPL-2.0+
  MIPI CSI-2 Receiver Subdev for Freescale i.MX6 SOC.
  Copyright (c) 2012-2017 Mentor Graphics Inc.
  there must be 5 pads: 1 input pad from sensor, and
  the 4 virtual channel output pads
  The default maximum bit-rate per lane in Mbps, if the
  source subdev does not provide V4L2_CID_LINK_FREQ.
 what is this? 
 lock to protect all members below 
 Register offsets 
  i.MX CSI2IPU Gasket registers follow. The CSI2IPU gasket is
  not part of the MIPI CSI-2 core, but its registers fall in the
  same register map range.
  The required sequence of MIPI CSI-2 startup as specified in the i.MX6
  reference manual is as follows:
  1. Deassert presetn signal (global reset).
         It's not clear what this "global reset" signal is (maybe APB
         global reset), but in any case this step would be probably
         be carried out during driver load in csi2_probe().
  2. Configure MIPI Camera Sensor to put all Tx lanes in LP-11 state.
         This must be carried out by the MIPI sensor's s_power(ON) subdev
         op.
  3. D-PHY initialization.
  4. CSI2 Controller programming (Set N_LANES, deassert PHY_SHUTDOWNZ,
     deassert PHY_RSTZ, deassert CSI2_RESETN).
  5. Read the PHY status register (PHY_STATE) to confirm that all data and
     clock lanes of the D-PHY are in LP-11 state.
  6. Configure the MIPI Camera Sensor to start transmitting a clock on the
     D-PHY clock lane.
  7. CSI2 Controller programming - Read the PHY status register (PHY_STATE)
     to confirm that the D-PHY is receiving a clock on the D-PHY clock lane.
  All steps 3 through 7 are carried out by csi2_s_stream(ON) here. Step
  6 is accomplished by calling the source subdev's s_stream(ON) between
  steps 5 and 7.
 Clear PHY test interface 
 Raise test interface strobe signal 
 Configure address write on falling edge and lower strobe signal 
 Configure data write on rising edge and raise strobe signal 
 Clear strobe signal 
  This table is based on the table documented at
  https:community.nxp.comdocsDOC-94312. It assumes
  a 27MHz D-PHY pll reference clock.
  Waits for ultra-low-power state on D-PHY clock lane. This is currently
  unused and may not be needed at all, but keep around just in case.
 wait for ULP on clock lane 
 wait until no errors on bus 
 Waits for low-power LP-11 state on data and clock lanes. 
 Wait for active clock on the clock lane. 
 Setup the i.MX CSI2IPU Gasket 
 setup the gasket 
 Step 3 
 Step 4 
 Step 5 
 Step 6 
 Step 7 
 stop upstream 
  V4L2 subdev operations.
	
	  enabledisable streaming only if stream_count is
	  going from 0 to 1  1 to 0.
 Output pads mirror active input pad, no limits on input pads 
 set a default mbus format  
 sentinel  }
 SPDX-License-Identifier: GPL-2.0+
  TI OMAP4 ISS V4L2 Driver - CSI PHY module
  Copyright (C) 2012 Texas Instruments, Inc.
  Author: Sergio Aguirre <sergio.a.aguirre@gmail.com>
  csi2_if_enable - Enable CSI2 Receiver interface.
  @enable: enable flag
  csi2_recv_config - CSI2 receiver module configuration.
  @currctrl: iss_csi2_ctrl_cfg structure
	
	  Set MFlag assertion boundaries to:
	  Low: 48 of FIFO size
	  High: 68 of FIFO size
 Generation of 16x64-bit bursts (Recommended) 
 Do Non-Posted writes (Recommended) 
	
	  Enforce Little endian for all formats, including:
	  YUV4:2:2 8-bit and YUV4:2:0 Legacy
 To set the format on the CSI2 requires a mapping function that takes
  the following inputs:
  - 3 different formats (at this time)
  - 2 destinations (mem, vp+mem) (vp only handled separately)
  - 2 decompression options (on, off)
  Output should be CSI2 frame format code
  Array indices as follows: [format][dest][decompr]
  Not all combinations are valid. 0 means invalid.
 RAW10 formats 
 Output to memory 
 No DPCM decompression 
 DPCM decompression 
 Output to both 
 No DPCM decompression 
 DPCM decompression 
 RAW10 DPCM8 formats 
 Output to memory 
 No DPCM decompression 
 DPCM decompression 
 Output to both 
 No DPCM decompression 
 DPCM decompression 
 RAW8 formats 
 Output to memory 
 No DPCM decompression 
 DPCM decompression 
 Output to both 
 No DPCM decompression 
 DPCM decompression 
 YUV422 formats 
 Output to memory 
 No DPCM decompression 
 DPCM decompression 
 Output to both 
 No DPCM decompression 
 DPCM decompression 
  csi2_ctx_map_format - Map CSI2 sink media bus format to CSI2 format ID
  @csi2: ISS CSI2 device
  Returns CSI2 physical format id
 Neither output enabled is a valid combination 
	 If we need to skip frames at the beginning of the stream disable the
	  video port to avoid sending the skipped frames to the IPIPEIF.
  csi2_set_outaddr - Set memory address to save output image
  @csi2: Pointer to ISS CSI2a device.
  @addr: 32-bit memory address aligned on 32 byte boundary.
  Sets the memory address where the output will be saved.
  Returns 0 if successful, or -EINVAL if the address is not in the 32 byte
  boundary.
  is_usr_def_mapping - Checks whether USER_DEF_MAPPING should
 			be enabled by CSI2.
  @format_id: mapped format id
  csi2_ctx_enable - Enable specified CSI2 context
  @ctxnum: Context number, valid between 0 and 7 values.
  @enable: enable
  csi2_ctx_config - CSI2 context configuration.
  @ctx: context configuration
 Set up CSI2_CTx_CTRL1 
 Set up CSI2_CTx_CTRL2 
 Set up CSI2_CTx_CTRL3 
 Set up CSI2_CTx_DAT_OFST 
  csi2_timing_config - CSI2 timing configuration.
  @timing: csi2_timing_cfg structure
  csi2_irq_ctx_set - Enables CSI2 Context IRQs.
  @enable: Enabledisable CSI2 Context interrupts
  csi2_irq_complexio1_set - Enables CSI2 ComplexIO IRQs.
  @enable: Enabledisable CSI2 ComplexIO #1 interrupts
  csi2_irq_status_set - Enables CSI2 Status IRQs.
  @enable: Enabledisable CSI2 Status interrupts
  omap4iss_csi2_reset - Resets the CSI2 module.
  Must be called with the phy lock held.
  Returns 0 if successful, or -EBUSY if power command didn't respond.
	
	  CSI2 fields that can be updated while the context has
	  been enabled or the interface has been enabled are not
	  updated dynamically currently. So we do not allow to
	  reconfigure if either has been enabled
	
	  The CSI2 receiver can't do any format conversion except DPCM
	  decompression, so every set_format call configures both pads
	  and enables DPCM decompression as a special case:
	
	  Enable end of frame and end of line signals generation for
	  context 0. These signals are generated from CSI2 receiver to
	  qualify the last pixel of a frame and the last pixel of a line.
	  Without enabling the signals CSI2 receiver writes data to memory
	  beyond buffer size andor data line offset is not handled correctly.
 Set configuration (timings, format and links) 
  csi2_print_status - Prints CSI2 debug information.
 -----------------------------------------------------------------------------
  Interrupt handling
  csi2_isr_buffer - Does buffer handling at end-of-frame
  when writing to memory.
	
	  Let video queue operation restart engine if there is an underrun
	  condition.
 Propagate frame number 
			 A zero value means that the counter isn't implemented
			  by the source. Increment the frame number in software
			  in that case.
			 Extend the 16 bit frame number to 32 bits by
			  computing the delta between two consecutive CSI2
			  frame numbers and adding it to the software frame
			  number. The hardware counter starts at 1 and wraps
			  from 0xffff to 1 without going through 0, so subtract
			  1 when the counter wraps.
	 Skip interrupts until we reach the frame skip count. The CSI2 will be
	  automatically disabled, as the frame skip count has been programmed
	  in the CSI2_CTx_CTRL1::COUNT field, so re-enable it.
	 
	  It would have been nice to rely on the FRAME_NUMBER interrupt instead
	  but it turned out that the interrupt is only generated when the CSI2
	  writes to memory (the CSI2_CTx_CTRL1::COUNT field is decreased
	  correctly and reaches 0 when data is forwarded to the video port only
	  but no interrupt arrives). Maybe a CSI2 hardware bug.
  omap4iss_csi2_isr - CSI2 interrupt handling.
 Failure Cases 
 Successful cases 
 -----------------------------------------------------------------------------
  ISS video operations
  csi2_queue - Queues the first buffer when using memory output
  @video: The video node
  @buffer: buffer to queue
	
	  If streaming was enabled before there was a buffer queued
	  or underrun happened in the ISR, the hardware was not enabled
	  and DMA queue flag ISS_VIDEO_DMAQUEUE_UNDERRUN is still set.
	  Enable it now.
 Enable  disable context 0 and IRQs 
 -----------------------------------------------------------------------------
  V4L2 subdev operations
 Clamp the width and height to valid range (1-8191). 
 If not found, use SGRBG10 as default 
		 Source format same as sink format, except for DPCM
		  compression.
		
		  Only Allow DPCM decompression, and check that the
		  pattern is preserved
 RGB, non-interlaced 
  csi2_enum_mbus_code - Handle pixel format enumeration
  @sd     : pointer to v4l2 subdev structure
  @cfg    : V4L2 subdev pad config
  @code   : pointer to v4l2_subdev_mbus_code_enum structure
  return -EINVAL or zero on success
 Passthrough sink pad code 
 Uncompressed code 
  csi2_get_format - Handle get format by pads subdev method
  @sd : pointer to v4l2 subdev structure
  @cfg: V4L2 subdev pad config
  @fmt: pointer to v4l2 subdev format structure
  return -EINVAL or zero on success
  csi2_set_format - Handle set format by pads subdev method
  @sd : pointer to v4l2 subdev structure
  @cfg: V4L2 subdev pad config
  @fmt: pointer to v4l2 subdev format structure
  return -EINVAL or zero on success
 Propagate the format from sink to source 
  csi2_init_formats - Initialize formats on all pads
  @sd: ISS CSI2 V4L2 subdevice
  @fh: V4L2 subdev file handle
  Initialize all pad formats with default values. If fh is not NULL, try
  formats are initialized on the file handle. Otherwise active formats are
  initialized on the device.
  csi2_set_stream - EnableDisable streaming on the CSI2 module
  @sd: ISS CSI2 V4L2 subdevice
  @enable: ISS pipeline stream state
  Return 0 on success or a negative error code otherwise.
		
		  When outputting to memory with no buffer available, let the
		  buffer queue handler start the hardware. A DMA queue flag
		  ISS_VIDEO_DMAQUEUE_QUEUED will be set as soon as there is
		  a buffer available.
 Enable context 0 and IRQs 
 subdev video operations 
 subdev pad operations 
 subdev operations 
 subdev internal operations 
 -----------------------------------------------------------------------------
  Media entity operations
  csi2_link_setup - Setup CSI2 connections.
  @entity : Pointer to media entity structure
  @local  : Pointer to local pad array
  @remote : Pointer to remote pad array
  @flags  : Link flags
  return -EINVAL or zero on success
 FIXME: this is actually a hack! 
	
	  The ISS core doesn't support pipelines with multiple video outputs.
	  Revisit this when it will be implemented, and return -EBUSY for now.
 Link from camera to CSI2 is fixed... 
 media operations 
 Register the subdev and video nodes. 
 -----------------------------------------------------------------------------
  ISS CSI2 initialisation and cleanup
  csi2_init_entities - Initialize subdev and media entity.
  @csi2: Pointer to csi2 structure.
  return -ENOMEM or zero on success
 group ID for iss subdevs 
 Video device node 
  omap4iss_csi2_init - Routine for module driver init
  omap4iss_csi2_create_links() - CSI2 pads links creation
  @iss: Pointer to ISS device
  return negative error code or zero on success
 Connect the CSI2a subdev to the video node. 
 Connect the CSI2b subdev to the video node. 
  omap4iss_csi2_cleanup - Routine for module driver cleanup
 SPDX-License-Identifier: GPL-2.0+
  TI OMAP4 ISS V4L2 Driver - ISP IPIPEIF module
  Copyright (C) 2012 Texas Instruments, Inc.
  Author: Sergio Aguirre <sergio.a.aguirre@gmail.com>
  ipipeif_print_status - Print current IPIPEIF Module register values.
  @ipipeif: Pointer to ISS ISP IPIPEIF device.
  Also prints other debug information stored in the IPIPEIF module.
  ipipeif_enable - EnableDisable IPIPEIF.
  @enable: enable flag
 -----------------------------------------------------------------------------
  Format- and pipeline-related configuration helpers
  ipipeif_set_outaddr - Set memory address to save output image
  @ipipeif: Pointer to ISP IPIPEIF device.
  @addr: 32-bit memory address aligned on 32 byte boundary.
  Sets the memory address where the output will be saved.
 Save address split in Base Address H & L 
 IPIPEIF_PAD_SINK 
 IPIPEIF with YUV422 input from ISIF 
 Select ISIFIPIPEIF input format 
 Set RAW Bayer pattern 
 Generate ISIF0 on the last line of the image 
 IPIPEIF_PAD_SOURCE_ISIF_SF 
 IPIPEIF_PAD_SOURCE_VP 
 Do nothing? 
 -----------------------------------------------------------------------------
  Interrupt handling
	 The ISIF generates VD0 interrupts even when writes are disabled.
	  deal with it anyway). Disabling the ISIF when no buffer is available
	  is thus not be enough, we need to handle the situation explicitly.
  omap4iss_ipipeif_isr - Configure ipipeif during interframe time.
  @ipipeif: Pointer to ISP IPIPEIF device.
  @events: IPIPEIF events
 -----------------------------------------------------------------------------
  ISP video operations
	
	  If streaming was enabled before there was a buffer queued
	  or underrun happened in the ISR, the hardware was not enabled
	  and DMA queue flag ISS_VIDEO_DMAQUEUE_UNDERRUN is still set.
	  Enable it now.
 -----------------------------------------------------------------------------
  V4L2 subdev operations
  ipipeif_set_stream - EnableDisable streaming on the IPIPEIF module
  @sd: ISP IPIPEIF V4L2 subdevice
  @enable: Enabledisable stream
		
		  When outputting to memory with no buffer available, let the
		  buffer queue handler start the hardware. A DMA queue flag
		  ISS_VIDEO_DMAQUEUE_QUEUED will be set as soon as there is
		  a buffer available.
  ipipeif_try_format - Try video format on a pad
  @ipipeif: ISS IPIPEIF device
  @cfg: V4L2 subdev pad config
  @pad: Pad number
  @fmt: Format
		 TODO: If the IPIPEIF output formatter pad is connected
		  directly to the resizer, only YUV formats can be used.
 If not found, use SGRBG10 as default 
 Clamp the input size. 
		 The data formatter truncates the number of horizontal output
		  pixels to a multiple of 16. To avoid clipping data, allow
		  callers to request an output size bigger than the input size
		  up to the nearest multiple of 16.
	 Data is written to memory unpacked, each 10-bit or 12-bit pixel is
	  stored on 2 bytes.
  ipipeif_enum_mbus_code - Handle pixel format enumeration
  @sd     : pointer to v4l2 subdev structure
  @cfg    : V4L2 subdev pad config
  @code   : pointer to v4l2_subdev_mbus_code_enum structure
  return -EINVAL or zero on success
 No format conversion inside IPIPEIF 
  ipipeif_get_format - Retrieve the video format on a pad
  @sd : ISP IPIPEIF V4L2 subdevice
  @cfg: V4L2 subdev pad config
  @fmt: Format
  Return 0 on success or -EINVAL if the pad is invalid or doesn't correspond
  to the format type.
  ipipeif_set_format - Set the video format on a pad
  @sd : ISP IPIPEIF V4L2 subdevice
  @cfg: V4L2 subdev pad config
  @fmt: Format
  Return 0 on success or -EINVAL if the pad is invalid or doesn't correspond
  to the format type.
 Propagate the format from sink to source 
 Check if the two ends match 
  ipipeif_init_formats - Initialize formats on all pads
  @sd: ISP IPIPEIF V4L2 subdevice
  @fh: V4L2 subdev file handle
  Initialize all pad formats with default values. If fh is not NULL, try
  formats are initialized on the file handle. Otherwise active formats are
  initialized on the device.
 V4L2 subdev video operations 
 V4L2 subdev pad operations 
 V4L2 subdev operations 
 V4L2 subdev internal operations 
 -----------------------------------------------------------------------------
  Media entity operations
  ipipeif_link_setup - Setup IPIPEIF connections
  @entity: IPIPEIF media entity
  @local: Pad at the local end of the link
  @remote: Pad at the remote end of the link
  @flags: Link flags
  return -EINVAL or zero on success
 FIXME: this is actually a hack! 
 Read from the sensor CSI2a or CSI2b. 
 Write to memory 
 Send to IPIPERESIZER 
 media operations 
  ipipeif_init_entities - Initialize V4L2 subdev and media entity
  @ipipeif: ISS ISP IPIPEIF module
  Return 0 on success and a negative error code on failure.
 group ID for iss subdevs 
 Register the subdev and video node. 
 -----------------------------------------------------------------------------
  ISP IPIPEIF initialisation and cleanup
  omap4iss_ipipeif_init - IPIPEIF module initialization.
  @iss: Device pointer specific to the OMAP4 ISS.
  TODO: Get the initialisation values from platform data.
  Return 0 on success or a negative error code otherwise.
  omap4iss_ipipeif_create_links() - IPIPEIF pads links creation
  @iss: Pointer to ISS device
  return negative error code or zero on success
 Connect the IPIPEIF subdev to the video node. 
  omap4iss_ipipeif_cleanup - IPIPEIF module cleanup.
  @iss: Device pointer specific to the OMAP4 ISS.
 SPDX-License-Identifier: GPL-2.0+
  TI OMAP4 ISS V4L2 Driver
  Copyright (C) 2012, Texas Instruments
  Author: Sergio Aguirre <sergio.a.aguirre@gmail.com>
  omap4iss_flush - Post pending L3 bus writes by doing a register readback
  @iss: OMAP4 ISS device
  In order to force posting of pending writes, we need to write and
  readback the same register, in this case the revision register.
  See this link for reference:
    https:www.mail-archive.comlinux-omap@vger.kernel.orgmsg08149.html
  iss_isp_enable_interrupts - Enable ISS ISP interrupts.
  @iss: OMAP4 ISS device
 Enable ISP interrupts 
  iss_isp_disable_interrupts - Disable ISS interrupts.
  @iss: OMAP4 ISS device
  iss_enable_interrupts - Enable ISS interrupts.
  @iss: OMAP4 ISS device
 Enable HL interrupts 
  iss_disable_interrupts - Disable ISS interrupts.
  @iss: OMAP4 ISS device
  Configure the bridge. Valid inputs are
  IPIPEIF_INPUT_CSI2A: CSI2a receiver
  IPIPEIF_INPUT_CSI2B: CSI2b receiver
  The bridge and lane shifter are configured according to the selected input
  and the ISP platform data.
  iss_isr - Interrupt Service Routine for ISS module.
  @irq: Not used currently.
  @_iss: Pointer to the OMAP4 ISS device
  Handles the corresponding callback if plugged in.
  Returns IRQ_HANDLED when IRQ was correctly handled, or IRQ_NONE when the
  IRQ wasn't handled.
 -----------------------------------------------------------------------------
  Pipeline stream management
  iss_pipeline_disable - Disable streaming on a pipeline
  @pipe: ISS pipeline
  @until: entity at which to stop pipeline walk
  Walk the entities chain starting at the pipeline output video node and stop
  all modules in the chain. Wait synchronously for the modules to be stopped if
  necessary.
  If the until argument isn't NULL, stop the pipeline walk when reaching the
  until entity. This is used to disable a partially started pipeline due to a
  subdev start error.
			 If the entity failed to stopped, assume it has
			  crashed. Mark it as such, the ISS will be reset when
			  applications will release it.
  iss_pipeline_enable - Enable streaming on a pipeline
  @pipe: ISS pipeline
  @mode: Stream mode (single shot or continuous)
  Walk the entities chain starting at the pipeline output video node and start
  all modules in the chain in the given mode.
  Return 0 if successful, or the return value of the failed video::s_stream
  operation otherwise.
	 If one of the entities in the pipeline has crashed it will not work
	  properly. Refuse to start streaming in that case. This check must be
	  performed before the loop below to avoid starting entities if the
	  pipeline won't start anyway (those entities would then likely fail to
	  stop, making the problem worse).
  omap4iss_pipeline_set_stream - Enabledisable streaming on a pipeline
  @pipe: ISS pipeline
  @state: Stream state (stopped, single shot or continuous)
  Set the pipeline to the given stream state. Pipelines can be started in
  single-shot or continuous mode.
  Return 0 if successful, or the return value of the failed video::s_stream
  operation otherwise. The pipeline state is not updated when the operation
  fails, except when stopping the pipeline.
  omap4iss_pipeline_cancel_stream - Cancel stream on a pipeline
  @pipe: ISS pipeline
  Cancelling a stream mark all buffers on all video nodes in the pipeline as
  erroneous and makes sure no new buffer can be queued. This function is called
  when a fatal error that prevents any further operation on the pipeline
  occurs.
  iss_pipeline_is_last - Verify if entity has an enabled link to the output
 			  video node
  @me: ISS module's media entity
  Returns 1 if the entity has an enabled link to the output video node or 0
  otherwise. It's true only while pipeline can have no more than one output
  node.
 Fist, ensure that the ISP is IDLE (no transactions happening) 
 Now finally, do the reset 
  iss_module_sync_idle - Helper to sync module with its idle state
  @me: ISS submodule's media entity
  @wait: ISS submodule's wait queue for streamoffinterrupt synchronization
  @stopping: flag which tells module wants to stop
  This function checks if ISS submodule needs to wait for next interrupt. If
  yes, makes the caller to sleep while waiting for such event.
	
	  atomic_set() doesn't include memory barrier on ARM platform for SMP
	  scenario. We'll call it here to avoid race conditions.
	
	  If module is the last one, it's writing to memory. In this case,
	  it's necessary to check if the module is already paused due to
	  DMA queue underrun or if it has to wait for next interrupt to be
	  idle.
	  If it isn't the last one, the function won't sleep but stopping
	  will still be set to warn next submodule caller's interrupt the
	  module wants to be idle.
  omap4iss_module_sync_is_stopped - Helper to verify if module was stopping
  @wait: ISS submodule's wait queue for streamoffinterrupt synchronization
  @stopping: flag which tells module wants to stop
  This function checks if ISS submodule was stopping. In case of yes, it
  notices the caller by setting stopping to 0 and waking up the wait queue.
  Returns 1 if it was stopping or 0 otherwise.
 --------------------------------------------------------------------------
  Clock management
 Wait for HW assertion 
  iss_enable_clocks - Enable ISS clocks
  @iss: OMAP4 ISS device
  Return 0 if successful, or clk_enable return value if any of tthem fails.
  iss_disable_clocks - Disable ISS clocks
  @iss: OMAP4 ISS device
  omap4iss_get - Acquire the ISS resource.
  Initializes the clocks for the first acquire.
  Increment the reference count on the ISS. If the first reference is taken,
  enable clocks and power-up all submodules.
  Return a pointer to the ISS device structure, or NULL if an error occurred.
  omap4iss_put - Release the ISS
  Decrement the reference count on the ISS. If the last reference is released,
  power-down all submodules, disable clocks and free temporary buffers.
		 Reset the ISS if an entity has failed to stop. This is the
		  only way to recover from such conditions, although it would
		  be worth investigating whether resetting the ISP only can't
		  fix the problem in some cases.
  iss_register_subdev_group - Register a group of subdevices
  @iss: OMAP4 ISS device
  @board_info: I2C subdevs board information array
  Register all I2C subdevices in the board_info array. The array must be
  terminated by a NULL entry, and the first entry must be the sensor.
  Return a pointer to the sensor media entity if it has been successfully
  registered, or NULL otherwise.
 Register internal entities 
 Register external entities 
		 Connect the sensor to the correct interface module.
		  CSI2a receiver through CSIPHY1, or
		  CSI2b receiver through CSIPHY2
  iss_create_links() - Pads links creation for the subdevices
  @iss : Pointer to ISS device
  return negative error code or zero on success
 Connect the submodules. 
	
	  TODO: When implementing DT support switch to syscon regmap lookup by
	  phandle.
 Clocks 
 Configure BTE BW_LIMITER field to max recommended value (1 GB) 
 Perform ISP reset 
 Interrupt 
 Entities 
 SPDX-License-Identifier: GPL-2.0+
  TI OMAP4 ISS V4L2 Driver - ISP RESIZER module
  Copyright (C) 2012 Texas Instruments, Inc.
  Author: Sergio Aguirre <sergio.a.aguirre@gmail.com>
  resizer_print_status - Print current RESIZER Module register values.
  @resizer: Pointer to ISS ISP RESIZER device.
  Also prints other debug information stored in the RESIZER module.
  resizer_enable - EnableDisable RESIZER.
  @enable: enable flag
 TODO: Enable RSZB 
 -----------------------------------------------------------------------------
  Format- and pipeline-related configuration helpers
  resizer_set_outaddr - Set memory address to save output image
  @resizer: Pointer to ISP RESIZER device.
  @addr: 32-bit memory address aligned on 32 byte boundary.
  Sets the memory address where the output will be saved.
 Save address split in Base Address H & L 
 SAD = BAD 
 Program UV buffer address... Hardcoded to be contiguous! 
 Ensure Y_BAD_L[6:0] = C_BAD_L[6:0]
 Save address split in Base Address H & L 
 SAD = BAD 
	 Disable pass-through more. Despite its name, the BYPASS bit controls
	  pass-through mode, not bypass mode.
 Select RSZ input 
 RSZ ignores WEN signal from IPIPEIPIPEIF 
 Set Resizer in free-running mode 
 Init Resizer A 
 Set size related things now 
 Buffer output settings 
 UYVY -> NV12 conversion 
 UV Buffer output settings 
 -----------------------------------------------------------------------------
  Interrupt handling
	 The whole resizer needs to be stopped. Disabling RZA only produces
	  input FIFO overflows, most probably when the next frame is received.
  omap4iss_resizer_isr - Configure resizer during interframe time.
  @resizer: Pointer to ISP RESIZER device.
  @events: RESIZER events
 -----------------------------------------------------------------------------
  ISS video operations
	
	  If streaming was enabled before there was a buffer queued
	  or underrun happened in the ISR, the hardware was not enabled
	  and DMA queue flag ISS_VIDEO_DMAQUEUE_UNDERRUN is still set.
	  Enable it now.
 -----------------------------------------------------------------------------
  V4L2 subdev operations
  resizer_set_stream - EnableDisable streaming on the RESIZER module
  @sd: ISP RESIZER V4L2 subdevice
  @enable: Enabledisable stream
 FIXME: Enable RSZB also 
		
		  When outputting to memory with no buffer available, let the
		  buffer queue handler start the hardware. A DMA queue flag
		  ISS_VIDEO_DMAQUEUE_QUEUED will be set as soon as there is
		  a buffer available.
  resizer_try_format - Try video format on a pad
  @resizer: ISS RESIZER device
  @cfg: V4L2 subdev pad config
  @pad: Pad number
  @fmt: Format
 If not found, use UYVY as default 
 Clamp the input size. 
		 The data formatter truncates the number of horizontal output
		  pixels to a multiple of 16. To avoid clipping data, allow
		  callers to request an output size bigger than the input size
		  up to the nearest multiple of 16.
  resizer_enum_mbus_code - Handle pixel format enumeration
  @sd     : pointer to v4l2 subdev structure
  @cfg: V4L2 subdev pad config
  @code   : pointer to v4l2_subdev_mbus_code_enum structure
  return -EINVAL or zero on success
  resizer_get_format - Retrieve the video format on a pad
  @sd : ISP RESIZER V4L2 subdevice
  @cfg: V4L2 subdev pad config
  @fmt: Format
  Return 0 on success or -EINVAL if the pad is invalid or doesn't correspond
  to the format type.
  resizer_set_format - Set the video format on a pad
  @sd : ISP RESIZER V4L2 subdevice
  @cfg: V4L2 subdev pad config
  @fmt: Format
  Return 0 on success or -EINVAL if the pad is invalid or doesn't correspond
  to the format type.
 Propagate the format from sink to source 
 Check if the two ends match 
  resizer_init_formats - Initialize formats on all pads
  @sd: ISP RESIZER V4L2 subdevice
  @fh: V4L2 subdev file handle
  Initialize all pad formats with default values. If fh is not NULL, try
  formats are initialized on the file handle. Otherwise active formats are
  initialized on the device.
 V4L2 subdev video operations 
 V4L2 subdev pad operations 
 V4L2 subdev operations 
 V4L2 subdev internal operations 
 -----------------------------------------------------------------------------
  Media entity operations
  resizer_link_setup - Setup RESIZER connections
  @entity: RESIZER media entity
  @local: Pad at the local end of the link
  @remote: Pad at the remote end of the link
  @flags: Link flags
  return -EINVAL or zero on success
 FIXME: this is actually a hack! 
 Read from IPIPE or IPIPEIF. 
 Write to memory 
 media operations 
  resizer_init_entities - Initialize V4L2 subdev and media entity
  @resizer: ISS ISP RESIZER module
  Return 0 on success and a negative error code on failure.
 group ID for iss subdevs 
 Register the subdev and video node. 
 -----------------------------------------------------------------------------
  ISP RESIZER initialisation and cleanup
  omap4iss_resizer_init - RESIZER module initialization.
  @iss: Device pointer specific to the OMAP4 ISS.
  TODO: Get the initialisation values from platform data.
  Return 0 on success or a negative error code otherwise.
  omap4iss_resizer_create_links() - RESIZER pads links creation
  @iss: Pointer to ISS device
  return negative error code or zero on success
 Connect the RESIZER subdev to the video node. 
  omap4iss_resizer_cleanup - RESIZER module cleanup.
  @iss: Device pointer specific to the OMAP4 ISS.
 SPDX-License-Identifier: GPL-2.0+
  TI OMAP4 ISS V4L2 Driver - Generic video node
  Copyright (C) 2012 Texas Instruments, Inc.
  Author: Sergio Aguirre <sergio.a.aguirre@gmail.com>
 -----------------------------------------------------------------------------
  Helper functions
  iss_video_mbus_to_pix - Convert v4l2_mbus_framefmt to v4l2_pix_format
  @video: ISS video instance
  @mbus: v4l2_mbus_framefmt format (input)
  @pix: v4l2_pix_format format (output)
  Fill the output pix structure with information from the input mbus format.
  The bytesperline and sizeimage fields are computed from the requested bytes
  per line value in the pix format and information from the video instance.
  Return the number of padding bytes at end of line.
	
	  Skip the last format in the loop so that it will be selected if no
	  match is found.
	
	  Clamp the requested bytes per line value. If the maximum bytes per
	  line value is zero, the module doesn't support user configurable line
	  sizes. Override the requested value with the minimum in that case.
 FIXME: Special case for NV12! We should make this nicer... 
	
	  Skip the last format in the loop so that it will be selected if no
	  match is found.
 Return a pointer to the ISS video instance at the far end of the pipeline. 
 -----------------------------------------------------------------------------
  Video queue operations
 Revisit multi-planar support for NV12 
	
	  Mark the buffer is faulty and give it back to the queue immediately
	  if the video node has registered an error. vb2 will perform the same
	  check when preparing the buffer, but that is inherently racy, so we
	  need to handle the race condition with an authoritative check here.
  omap4iss_video_buffer_next - Complete the current buffer and return the next
  @video: ISS video object
  Remove the current video buffer from the DMA queue and fill its timestamp,
  field count and state fields before waking up its completion handler.
  For capture video nodes, the buffer state is set to VB2_BUF_STATE_DONE if no
  error has been flagged in the pipeline, or to VB2_BUF_STATE_ERROR otherwise.
  The DMA queue is expected to contain at least one buffer.
  Return a pointer to the next buffer in the DMA queue, or NULL if the queue is
  empty.
	
	  Do frame number propagation only if this is the output video node.
	  Frame number either comes from the CSI receivers or it gets
	  incremented here if H3A is not active.
	  Note: There is no guarantee that the output buffer will finish
	  first, so the input number might lag behind by 1 in some cases.
  omap4iss_video_cancel_stream - Cancel stream on a video node
  @video: ISS video object
  Cancelling a stream mark all buffers on the video node as erroneous and makes
  sure no new buffer can be queued.
 -----------------------------------------------------------------------------
  V4L2 ioctls
	
	  Fill the bytesperline and sizeimage fields by converting to media bus
	  format and back to pixel format.
	
	  Try the get selection operation first and fallback to get format if
	  not implemented.
  Stream management
  Every ISS pipeline has a single input and a single output. The input can be
  either a sensor or a video node. The output is always a video node.
  As every pipeline has an output video node, the ISS video objects at the
  pipeline output stores the pipeline state. It tracks the streaming state of
  both the input and output, as well as the availability of buffers.
  In sensor-to-memory mode, frames are always available at the pipeline input.
  Starting the sensor usually requires I2C transfers and must be done in
  interruptible context. The pipeline is started and stopped synchronously
  to the stream onoff commands. All modules in the pipeline will get their
  subdev set stream handler called. The module at the end of the pipeline must
  delay starting the hardware until buffers are available at its output.
  In memory-to-memory mode, startingstopping the stream requires
  synchronization between the input and output. ISS modules can't be stopped
  in the middle of a frame, and at least some of the modules seem to become
  busy as soon as they're started, even if they don't receive a frame start
  event. For that reason frames need to be processed in single-shot mode. The
  driver needs to wait until a frame is completely processed and written to
  memory before restarting the pipeline for the next frame. Pipelined
  processing might be possible but requires more testing.
  Stream start must be delayed until buffers are available at both the input
  and output. The pipeline must be started in the videobuf queue callback with
  the buffers queue spinlock held. The modules subdev set stream operation must
  not sleep.
	
	  Start streaming on the pipeline. No link touching an entity in the
	  pipeline can be activated or deactivated once streaming is started.
	
	  Verify that the currently configured format matches the output of
	  the connected subdev.
	
	  Find the ISS video node connected at the far end of the pipeline and
	  update the pipeline.
	
	  Set the maximum time per frame as the value requested by userspace.
	  This is a soft limit that can be overridden if the hardware doesn't
	  support the request limit.
	
	  In sensor-to-memory mode, the stream can be started synchronously
	  to the stream on command. In memory-to-memory mode, it will be
	  started when buffers are queued on both the input and output.
 Update the pipeline state. 
 Stop the stream. 
 -----------------------------------------------------------------------------
  V4L2 file operations
 If this is the first user, initialise the pipeline. 
 Disable streaming and free the buffers queue resources. 
 Release the videobuf2 queue 
 -----------------------------------------------------------------------------
  ISS video core
 Initialize the video device. 
 SPDX-License-Identifier: GPL-2.0+
  TI OMAP4 ISS V4L2 Driver - ISP IPIPE module
  Copyright (C) 2012 Texas Instruments, Inc.
  Author: Sergio Aguirre <sergio.a.aguirre@gmail.com>
  ipipe_print_status - Print current IPIPE Module register values.
  @ipipe: Pointer to ISS ISP IPIPE device.
  Also prints other debug information stored in the IPIPE module.
  ipipe_enable - EnableDisable IPIPE.
  @enable: enable flag
 -----------------------------------------------------------------------------
  Format- and pipeline-related configuration helpers
 IPIPE_PAD_SINK 
 NOTE: Currently just supporting pipeline IN: RGB, OUT: YUV422 
 Enable YUV444 -> YUV422 conversion 
 Ignore ipipeif_wrt signal, and operate on-the-fly.  
 HACK: Values tuned for Ducati SW (OV) 
 IPIPE_PAD_SOURCE_VP 
 Do nothing? 
 -----------------------------------------------------------------------------
  V4L2 subdev operations
  ipipe_set_stream - EnableDisable streaming on the IPIPE module
  @sd: ISP IPIPE V4L2 subdevice
  @enable: Enabledisable stream
 Enable clk_arm_g0 
 Enable clk_pix_g[3:0] 
  ipipe_try_format - Try video format on a pad
  @ipipe: ISS IPIPE device
  @cfg: V4L2 subdev pad config
  @pad: Pad number
  @fmt: Format
 If not found, use SGRBG10 as default 
 Clamp the input size. 
  ipipe_enum_mbus_code - Handle pixel format enumeration
  @sd     : pointer to v4l2 subdev structure
  @cfg    : V4L2 subdev pad config
  @code   : pointer to v4l2_subdev_mbus_code_enum structure
  return -EINVAL or zero on success
 FIXME: Forced format conversion inside IPIPE ? 
  ipipe_get_format - Retrieve the video format on a pad
  @sd : ISP IPIPE V4L2 subdevice
  @cfg: V4L2 subdev pad config
  @fmt: Format
  Return 0 on success or -EINVAL if the pad is invalid or doesn't correspond
  to the format type.
  ipipe_set_format - Set the video format on a pad
  @sd : ISP IPIPE V4L2 subdevice
  @cfg: V4L2 subdev pad config
  @fmt: Format
  Return 0 on success or -EINVAL if the pad is invalid or doesn't correspond
  to the format type.
 Propagate the format from sink to source 
 Check if the two ends match 
  ipipe_init_formats - Initialize formats on all pads
  @sd: ISP IPIPE V4L2 subdevice
  @fh: V4L2 subdev file handle
  Initialize all pad formats with default values. If fh is not NULL, try
  formats are initialized on the file handle. Otherwise active formats are
  initialized on the device.
 V4L2 subdev video operations 
 V4L2 subdev pad operations 
 V4L2 subdev operations 
 V4L2 subdev internal operations 
 -----------------------------------------------------------------------------
  Media entity operations
  ipipe_link_setup - Setup IPIPE connections
  @entity: IPIPE media entity
  @local: Pad at the local end of the link
  @remote: Pad at the remote end of the link
  @flags: Link flags
  return -EINVAL or zero on success
 Read from IPIPEIF. 
 Send to RESIZER 
 media operations 
  ipipe_init_entities - Initialize V4L2 subdev and media entity
  @ipipe: ISS ISP IPIPE module
  Return 0 on success and a negative error code on failure.
 group ID for iss subdevs 
 Register the subdev and video node. 
 -----------------------------------------------------------------------------
  ISP IPIPE initialisation and cleanup
  omap4iss_ipipe_init - IPIPE module initialization.
  @iss: Device pointer specific to the OMAP4 ISS.
  TODO: Get the initialisation values from platform data.
  Return 0 on success or a negative error code otherwise.
  omap4iss_ipipe_cleanup - IPIPE module cleanup.
  @iss: Device pointer specific to the OMAP4 ISS.
 SPDX-License-Identifier: GPL-2.0+
  TI OMAP4 ISS V4L2 Driver - CSI PHY module
  Copyright (C) 2012 Texas Instruments, Inc.
  Author: Sergio Aguirre <sergio.a.aguirre@gmail.com>
  csiphy_lanes_config - Configuration of CSIPHY lanes.
  Updates HW configuration.
  Called with phy->mutex taken.
  csiphy_set_power
  @power: Power state to be set.
  Returns 0 if successful, or -EBUSY if the retry count is exceeded.
  csiphy_dphy_config - Configure CSI2 D-PHY parameters.
  Called with phy->mutex taken.
 Set up REGISTER0 
 Set up REGISTER1 
  TCLK values are OK at their reset values
	
	  SCM.CONTROL_CAMERA_RX
	  - bit [31] : CSIPHY2 lane 2 enable (4460+ only)
	  - bit [30:29] : CSIPHY2 per-lane enable (1 to 0)
	  - bit [28:24] : CSIPHY1 per-lane enable (4 to 0)
	  - bit [21] : CSIPHY2 CTRLCLK enable
	  - bit [20:19] : CSIPHY2 config: 00 d-phy, 0110 ccp2
	  - bit [18] : CSIPHY1 CTRLCLK enable
	  - bit [17:16] : CSIPHY1 config: 00 d-phy, 0110 ccp2
	
	  TODO: When implementing DT support specify the CONTROL_CAMERA_RX
	  register offset in the syscon property instead of hardcoding it.
 NOTE: Leave CSIPHY1 config to 0x0: D-PHY mode 
 Enable all lanes for now 
 Enable CTRLCLK 
 NOTE: Leave CSIPHY2 config to 0x0: D-PHY mode 
 Enable all lanes for now 
 Enable CTRLCLK 
 Reset used lane count 
 Clock and data lanes verification 
	
	  THS_TERM: Programmed value = ceil(12.5 nsDDRClk period) - 1.
	  THS_SETTLE: Programmed value = ceil(90 nsDDRClk period) + 3.
  omap4iss_csiphy_init - Initialize the CSI PHY frontends
 SPDX-License-Identifier: GPL-2.0
  Rockchip Video Decoder H264 backend
  Copyright (C) 2019 Collabora, Ltd.
 	Boris Brezillon <boris.brezillon@collabora.com>
  Copyright (C) 2016 Rockchip Electronics Co., Ltd.
 	Jeffy Chen <jeffy.chen@rock-chips.com>
 Size with u32 units. 
 Data structure describing auxiliary buffer format. 
  Constant CABAC table.
  Built from the tables described in section '9.3.1.1 Initialisation process
  for context variables' of the H264 spec.
 Table 9-12 – Values of variables m and n for ctxIdx from 0 to 10 
 Table 9-13 – Values of variables m and n for ctxIdx from 11 to 23 
 Table 9-14 – Values of variables m and n for ctxIdx from 24 to 39 
 Table 9-15 – Values of variables m and n for ctxIdx from 40 to 53 
 Table 9-16 – Values of variables m and n for ctxIdx from 54 to 59 
 Table 9-17 – Values of variables m and n for ctxIdx from 60 to 69 
 Table 9-18 – Values of variables m and n for ctxIdx from 70 to 104 
 Table 9-19 – Values of variables m and n for ctxIdx from 105 to 165 
 Table 9-20 – Values of variables m and n for ctxIdx from 166 to 226 
 Table 9-21 – Values of variables m and n for ctxIdx from 227 to 275 
 Table 9-22 – Values of variables m and n for ctxIdx from 277 to 337 
 Table 9-23 – Values of variables m and n for ctxIdx from 338 to 398 
 Values of variables m and n for ctxIdx from 399 to 463 (not documented) 
	
	  HW read the SPSPPS information from PPS packet index by PPS id.
	  offset from the base can be calculated by PPS_id  32 (size per PPS
	  packet unit). so the driver copy SPSPPS information to the exact PPS
	  packet unit for HW accessing.
 write sps 
 write pps 
 To be on the safe side, program the scaling matrix address 
	
	  Assign an invalid pic_num if DPB entry at that position is inactive.
	  If we assign 0 in that position hardware will treat that as a real
	  reference picture with pic_num 0, triggering output picture
	  corruption.
  dpb poc related registers table
	
	  If a DPB entry is unused or invalid, address of current destination
	  buffer is returned.
 config rlc base address 
 config cabac table 
 config output base address 
 config ref pic address & poc 
	
	  Since support frame mode only
	  top_field_order_cnt is the same as bottom_field_order_cnt
 config hw pps address 
 config hw rps address 
 Build the PB{0,1} ref lists. 
 Start decoding! 
 SPDX-License-Identifier: GPL-2.0
  Rockchip Video Decoder driver
  Copyright (C) 2019 Collabora, Ltd.
  Based on rkvdec driver by Google LLC. (Tomasz Figa <tfiga@chromium.org>)
  Based on s5p-mfc driver by Samsung Electronics Co., Ltd.
  Copyright (C) 2011 Samsung Electronics Co., Ltd.
		
		  TODO: The hardware supports 10-bit and 4:2:2 profiles,
		  but it's currently broken in the driver.
		  Reject them for now, until it's fixed.
 Only 4:0:0 and 4:2:0 are supported 
 Luma and chroma bit depth mismatch 
 Only 8-bit is supported 
	
	  The codec context should point to a coded format desc, if the format
	  on the coded end has not been set yet, it should point to the
	  default value.
 Always apply the frmsize constraint of the coded end. 
 All coded formats are considered single planar for now. 
 Change not allowed if queue is busy 
	
	  In order to support dynamic resolution change, the decoder admits
	  a resolution change, as long as the pixelformat remains. Can't be
	  done if streaming.
	
	  Since format change on the OUTPUT queue will reset the CAPTURE
	  queue, we can't allow doing so when the CAPTURE queue has buffers
	  allocated.
	
	  Current decoded format might have become invalid with newly
	  selected codec, so reset it to default just to be safe and
	  keep internal driver state sane. User is mandated to set
	  the decoded format again after we return, so we don't need
	  anything smarter.
	 
	  Note that this will propagates any size changes to the decoded format.
 Propagate colorspace information to capture. 
	
	  Buffer's bytesused must be written by driver for CAPTURE buffers.
	  (for OUTPUT buffers, if userspace passes 0 bytesused, v4l2-core sets
	  it to buffer length).
 Apply request(s) controls if needed. 
	
	  Driver does mostly sequential access, so sacrifice TLB efficiency
	  for faster allocation. Also, no CPU access on the source queue,
	  so no kernel mapping needed.
 sentinel  }
	
	  Bump ACLK to max. possible freq. (500 MHz) to improve performance
	  When 4k video playback.
 SPDX-License-Identifier: GPL-2.0
 0 for AC3
len=6+((pes[4]<<8)|pes[5]);
 SPDX-License-Identifier: GPL-2.0
 for memcpy() 
 SPDX-License-Identifier: GPL-2.0-or-later
    Driver for Spase SP8870 demodulator
    Copyright (C) 1999 Juergen Peitz
  This driver needs external firmware. Please use the command
  "<kerneldir>scriptsget_dvb_firmware alps_tdlb7" to
  downloadextract it, and then copy it to usrlibhotplugfirmware
  or libfirmware (depending on configuration of firmware hotplug).
 demodulator private data 
 firmware size for sp8870 
 starting point for firmware in file 'Sc_main.mc' 
 system controller stop
 instruction RAM register hiword
 instruction RAM MWR
 do firmware upload
 write register 0xCF0A
 microcontroller STOP
 microcontroller START
 not documented but if we don't read 0x0D01 out here
 we don't get a correct data valid signal
 use specified parameters 
 enable autoprobing 
 enable TS output and interface pins
 system controller stop
 set tuner parameters
 sample rate correction bit [23..17]
 sample rate correction bit [16..0]
 integer carrier offset
 fractional carrier offset
 filter for 678 Mhz channel
 scan order: 2k first = 0x0000, 8k first = 0x0001
 read status reg in order to clear pending irqs
 system controller start
 request the firmware, this will block until someone uploads it 
 enable TS output and interface pins 
 system controller stop
 ADC mode
 Reed Solomon parity bytes passed to output
 MPEG clock is suppressed if no valid data
 bit 0x010: enable data valid signal 
 number of trials to recover from lockup 
 maximum checks for data valid signal 
 only for debugging: counter for detected lockups 
 only for debugging: counter for channel switches 
	
	    The firmware of the sp8870 sometimes locks up after setting frontend parameters.
	    We try to detect this by checking the data valid signal.
	    If it is not set after MAXCHECKS we try to recover the lockup by setting
	    the frontend parameters again.
			valid = ((sp8870_readreg(i2c, 0x0200) & 4) == 0);
 tristate TS output and disable interface pins
 allocate memory for the internal state 
 setup the state 
 check if the demod is there 
 create dvb_frontend 
 SPDX-License-Identifier: GPL-2.0-or-later
  av7110_ca.c: CA and CI stuff
  Copyright (C) 1999-2002 Ralph  Metzler
                        & Marcus Metzler for convergence integrated media GmbH
  originally based on code by:
  Copyright (C) 1998,1999 Christian Theiss <mistert@rz.fh-augsburg.de>
  the project's page is at https:linuxtv.org
av7110->ci_stat=data[1];
  CI link layer file ops
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for the remote control of SAA7146 based AV7110 cards
  Copyright (C) 1999-2003 Holger Waechtler <holger@convergence.de>
  Copyright (C) 2003-2007 Oliver Endriss <o.endriss@gmx.de>
  Copyright (C) 2019 Sean Young <sean@mess.org>
 internal only 
 interrupt handler 
 RC5: 5 bits device address, 6 bits command 
 RCMM: 32 bits scancode 
			
			  extended RC5: 5 bits device address, 7 bits command
			 
			  Extended RC5 uses only one start bit. The second
			  start bit is re-assigned bit 6 of the command bit.
MODULE_AUTHOR("Holger Waechtler <holger@convergence.de>, Oliver Endriss <o.endriss@gmx.de>");
MODULE_LICENSE("GPL");
 SPDX-License-Identifier: GPL-2.0-or-later
  av7110_hw.c: av7110 low level hardware access and firmware interface
  Copyright (C) 1999-2002 Ralph  Metzler
                        & Marcus Metzler for convergence integrated media GmbH
  originally based on code by:
  Copyright (C) 1998,1999 Christian Theiss <mistert@rz.fh-augsburg.de>
  the project's page is at https:linuxtv.org
 for debugging ARM communication: 
#define COM_DEBUG
  Max transfer size done by av7110_fw_cmd()
  The maximum size passed to this function is 6 bytes. The buffer also
  uses two additional ones for type and size. So, 8 bytes is enough.
  DEBI functions
 This DEBI code is based on the Stradis driver
 immediate transfer 
 block transfer 
 av7110 ARM core boot stuff 
 Disable DEBI and GPIO irq 
 the firmware needs some time to initialize 
  0  
 we cannot write av7110 DRAM directly, so load a bootloader into
 Disable DEBI and GPIO irq 
 enable DEBI 
 test DEBI 
 FIXME: Why does Nexus CA require 2x iwdebi for first init? 
 boot 
saa7146_setgpio(dev, DEBI_DONE_LINE, SAA7146_GPIO_INPUT);
saa7146_setgpio(dev, 3, SAA7146_GPIO_INPUT);
 the firmware needs some time to initialize 
ARM_ClearIrq(av7110);
  DEBI command polling
 not supported by old firmware 
 new firmware 
	dprintk(4, "%p\n", av7110);
 non-immediate COMMAND type 
	dprintk(4, "%p\n", av7110);
	dprintk(4, "%p\n", av7110);
  0  
  Firmware commands
 get version of the firmware ROM, RTSL, video ucode and ARM application  
 print firmware capabilities 
 Luma=0.299R+0.587G+0.114B 0..65535 
 Cr 0..4095 
 Cb 0..4095 
 possible if syscall is repeated by -ERESTARTSYS and if firmware cannot abort 
		 just continue. This should work for all fw versions
		  if bnum==1 && !brest && LoadBitmap was successful
 CONFIG_DVB_AV7110_OSD 
 SPDX-License-Identifier: GPL-2.0-or-later
  av7110_av.c: audio and video MPEG decoder stuff
  Copyright (C) 1999-2002 Ralph  Metzler
                        & Marcus Metzler for convergence integrated media GmbH
  originally based on code by:
  Copyright (C) 1998,1999 Christian Theiss <mistert@rz.fh-augsburg.de>
  the project's page is at https:linuxtv.org
 MPEG-2 (ISO 13818  H.222.0) stream types 
pts_dts flags
flags
 adaptation flags
 adaptation extension flags
 video PES do not have a length in TS
printk("buffer empty - avail %d blen %u dlen %d\n", len, blen, dlen);
 loudspeaker 
 headphonesr 
 loudspeaker 
  IO buffer management and control
	p->counter = 0;
  Video MPEG decoder events
FIXME: timestamp?
  DVB device file operations
 if not playing: may play if asked for 
 if not playing: may play if asked for 
 search in buf for instances of 00 00 01 b5 1? 
	 setting n always > 1, fixes problems when playing stillframes
 FIXME: nonblock? 
 unused, make sure to use atomic time for y2038 if it ever gets used 
 in frames per 1000sec 
 unknownoddevenprogressive 
note: arg is ignored by firmware
  empty event queue 
  driver registration
 arbitrary 
 SPDX-License-Identifier: GPL-2.0-or-later
  av7110_v4l.c: av7110 video4linux interface for DVB and Siemens DVB-C analog module
  Copyright (C) 1999-2002 Ralph  Metzler
                        & Marcus Metzler for convergence integrated media GmbH
  originally based on code by:
  Copyright (C) 1998,1999 Christian Theiss <mistert@rz.fh-augsburg.de>
  the project's page is at https:linuxtv.org
 ignored 
	 magic number: 614. tuning with the frequency given by v4l2
 side effect: video_status is now 0, video_fh is NULL 
 loudspeaker source
 headphone source
 SCART 1 source
 FM matrix, mono
 loudspeaker + headphone
 SCART 1 volume
 TDA9819 pin9(STD)
 TDA9819 pin30(VIF)
 loudspeaker source
 headphone source
 SCART 1 source
 FM matrix, mono
 loudspeaker + headphone
 SCART 1 volume
 TDA9819 pin9(STD)
 TDA9819 pin30(VIF)
 hmm, this does not do anything!? 
 48.25 MHZ  62.5 kHz = 772, see fi1216mk2-specs, page 2 
 855.25 MHz  62.5 kHz = 13684 
 FIXME: add the real signal strength here 
 FIXME: standard  stereo detection is still broken 
 stereo 
 bilingual 
 mono 
 stereo 
 bilingual 
 mono 
 mono 
 case V4L2_TUNER_MODE_MONO: 
 mono 
 fast mute 
 tune in desired frequency 
 start stereo detection 
 loudspeaker + headphone 
 SCART 1 volume 
 WSS controlled by firmware 
 WSS controlled by userspace 
  INITIALIZATION
 the probing above resets the msp...
 loudspeaker + headphone
 loudspeaker source
 headphone source
 loudspeaker volume
 SCART 1 source
 SCART 1 volume
 prescale SCART
 FujitsuSiemens DVB-Cable 
 HauppaugeTT DVB-C premium 
 HauppaugeTT DVB-C premium 
 setup for DVB by default 
 TDA9819 pin9(STD)
 TDA9819 pin30(VIF)
 init the saa7113 
 setup msp for analog sound: BG Dual-FM 
 AD_CV
 FIR1
 FIR1
 FIR1
 FIR1
 FIR1
 FIR1
 FIR2
 FIR2
 FIR2
 FIR2
 FIR2
 FIR2
 FIR2
 FIR2
 FIR2
 MODE_REG
 DCO1_LO 5.74MHz
 DCO1_HI
 DCO2_LO 5.5MHz
 DCO2_HI
 LOAD_REG 12
 set dd1 stream a & b 
	 special case DVB-C: these cards have an analog tuner
	   plus need some special handling, so we have separate
 FIXME: these values are experimental values that look better than the
 SPDX-License-Identifier: GPL-2.0-or-later
  budget-patch.c: driver for Budget Patch,
  hardware modification of DVB-S cards enabling full TS
  Written by Emard <emard@softhome.net>
  Original idea by Roberto Deza <rdeza@unav.es>
  Special thanks to Holger Waechtler, Michael Hunold, Marian Durkovic
  and Metzlerbros
  the project's page is at https:linuxtv.org
MAKE_BUDGET_INFO(satel,"TT-BudgetPatch SATELCO PCI", BUDGET_TT_HW_DISEQC);
        MAKE_EXTENSION_PCI(satel, 0x13c2, 0x1013),
 those lines are for budget-patch to be tried
 on a true budget card and observe the
 behaviour of VSYNC generated by rps1.
 this code was shamelessly copypasted from budget.c
 Diseqc functions only for TT Budget card 
 taken from the Skyvision DVB driver by
 shamelessly copypasted from budget.c 
 NOTE: since we're using a prescaler of 2, we set the
 divisor frequency to 62.5kHz and divide by 125 above
 HauppaugeTT WinTV DVB-S rev1.X
 SATELCO Multimedia PCI
 try the ALPS BSRV2 first of all
 try the ALPS BSRU6 now
 Try the grundig 29504-451
 written by Emard 
 initialize registers. Better to have it like this
 than leaving something unconfigured
 port B VSYNC at rising edge
 have this in budget-core too!
 VBI
 debi config
 saa7146_write(dev, DEBI_CONFIG, MASK_30|MASK_28|MASK_18);
 zero all HPS registers
 r68
 r6c
 r70
 r60
 r64
 r74
 r78
 Set HPS prescaler for port B input
 BRS control
 a
 b
 HPS_CTRL1
 HPS_CTRL2
 DEBI
 Disable RPS1 and RPS0
 RPS1 timeout disable
 code for autodetection
 will wait for VBI_B event (vertical blank at port B)
 and will reset GPIO3 after VBI_B is detected.
 (GPIO3 should be raised high by CPU to
 test if GPIO3 will generate vertical blank signal
 in budget patch GPIO3 is connected to VSYNC_B
 issue RPS1 interrupt to increment counter
 at least a NOP is neede between two interrupts
 interrupt again
 set event counter 1 source as RPS1 interrupt (0x03)          (rE4 p53)
 use 0x03 to track RPS1 interrupts - increase by 1 every gpio3 is toggled
 use 0x15 to track VPE  interrupts - increase by 1 every vpeirq() is called
 set event counter 1 threshold to maximum allowed value        (rEC p55)
 Fix VSYNC level
 Set RPS1 Address register to point to RPS code               (r108 p42)
 Enable RPS1,                                                 (rFC p33)
 Disable RPS1
      OLD (Original design by Roberto Deza):
      This code will setup the SAA7146_RPS1 to generate a square
      wave on GPIO3, changing when a field (TS_HEIGHT2 "lines" of
      TS_WIDTH packets) has been acquired on SAA7146_D1B video port;
      then, this GPIO3 output which is connected to the D1B_VSYNC
      input, will trigger the acquisition of the alternate field
      and so on.
      Currently, the TT_budget  WinTV_Nova cards have two ICs
      (74HCT4040, LVC74) for the generation of this VSYNC signal,
      which seems that can be done perfectly without this :-)).
      New design (By Emard)
      this rps1 code will copy internal HS event to GPIO3 pin.
      GPIO3 is in budget-patch hardware connected to port B VSYNC
      HS is an internal event of 7146, accessible with RPS
      and temporarily raised high every n lines
      (n in defined in the RPS_THRESH1 counter threshold)
      I think HS is raised high on the beginning of the n-th line
      and remains high until this n-th line that triggered
      it is completely received. When the reception of n-th line
      ends, HS is lowered.
      To transmit data over DMA, 7146 needs changing state at
      port B VSYNC pin. Any changing of port B VSYNC will
      cause some DMA data transfer, with more or less packets loss.
      It depends on the phase and frequency of VSYNC and
      the way of 7146 is instructed to trigger on port B (defined
      in DD1_INIT register, 3rd nibble from the right valid
      numbers are 0-7, see datasheet)
      The correct triggering can minimize packet loss,
      dvbtraffic should give this stable bandwidths:
        22k transponder = 33814 kbits
      27.5k transponder = 38045 kbits
      by experiment it is found that the best results
      (stable bandwidths and almost no packet loss)
      are obtained using DD1_INIT triggering number 2
      (Va at rising edge of VS Fa = HS x VS-failing forced toggle)
      and a VSYNC phase that occurs in the middle of DMA transfer
      (about byte 188512=96256 in the DMA window).
      Phase of HS is still not clear to me how to control,
      It just happens to be so. It can be seen if one enables
      RPS_IRQ and print Event Counter 1 in vpeirq(). Every
      time RPS_INTERRUPT is called, the Event Counter 1 will
      increment. That's how the 7146 is programmed to do event
      counting in this budget-patch.c
      I think HPS setting has something to do with the phase
      of HS but I can't be 100% sure in that.
      hardware debug note: a working budget card (including budget patch)
      with vpeirq() interrupt setup in mode "0x90" (every 64K) will
      generate 3 interrupts per 25-Hz DMA frame of 2188512 bytes
      and that means 325=75 Hz of interrupt frequency, as seen by
      watch cat procinterrupts
      If this frequency is 3x lower (and data received in the DMA
      buffer don't start with 0x47, but in the middle of packets,
      whose lengths appear to be like 188 292 188 104 etc.
      this means VSYNC line is not connected in the hardware.
      (check soldering pcb and pins)
      The same behaviour of missing VSYNC can be duplicated on budget
      cards, by setting DD1_INIT trigger mode 7 in 3rd nibble.
 Setup RPS1 "program" (p35)
 Wait Source Line Counter Threshold                           (p36)
 Set GPIO3=1                                                  (p42)
 issue RPS1 interrupt
 Wait reset Source Line Counter Threshold                     (p36)
 Set GPIO3=0                                                  (p42)
 issue RPS1 interrupt
 Jump to begin of RPS program                                 (p37)
 Fix VSYNC level
 Set RPS1 Address register to point to RPS code               (r108 p42)
 Set Source Line Counter Threshold, using BRS                 (rCC p43)
 It generates HS event every TS_HEIGHT lines
 this is related to TS_WIDTH set in register
 NUM_LINE_BYTE3 in budget-core.c. If NUM_LINE_BYTE
 low 16 bits are set to TS_WIDTH bytes (TS_WIDTH=2188
,then RPS_THRESH1
 should be set to trigger every TS_HEIGHT (512) lines.
 saa7146_write(dev, RPS_THRESH0, ((TS_HEIGHT2)<<16) |MASK_28| (TS_HEIGHT2) |MASK_12 );
 Enable RPS1                                                  (rFC p33)
 SPDX-License-Identifier: GPL-2.0-or-later
  driver for the SAA7146 based AV110 cards (like the Fujitsu-Siemens DVB)
  av7110.c: initialization and demux stuff
  Copyright (C) 1999-2002 Ralph  Metzler
                        & Marcus Metzler for convergence integrated media GmbH
  originally based on code by:
  Copyright (C) 1998,1999 Christian Theiss <mistert@rz.fh-augsburg.de>
  the project's page is at https:linuxtv.org
 set internal volume control to maximum 
 handle different card types 
 remaining inits according to card and frontend type 
 SPDIF on
		
		  some special handling for the Siemens DVB-C cards...
 done. 
 switch DVB SCART on
 RGB on, SCART pin 16
saa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO); 
 SPDIF on
 card-specific recovery 
 got signal or told to quit
  IRQ handling
#define DEBUG_TIMING
 for good measure 
 we want a real DEBI DMA 
 irq from av7110 firmware writing the mailbox register in the DPRAM 
 we shouldn't get any irq while a debi xfer is running 
 maybe we should try resetting the debi? 
 see what the av7110 wants 
 CONFIG_DVB_AV7110_OSD 
  hardware filter functions
	u16 mode = 0x0320;
teletext
 keep going, stop as many filters as possible 
 full_ts mod 
 full_ts mod 
 pointer casting paranoia... 
  SEC device file operations
 simplified code from budget-core.c 
 DMA3 off 
 VPE 
 VPE 
 DMA3 on 
 have a clean section start 
 nearest lower position divisible by 188 
 Ensure streamed PCI data is synced to CPU 
 track rps1 activity 
 no wraparound, dump olddma..newdma 
 wraparound, dump olddma..buflen and 0..newdma 
		 initialize software demux1 without its own frontend
		  demux1 hardware is connected to frontend0 of demux0
  I2C client commands
  INITIALIZATION
 check for firmware magic 
 check dpram file 
 check root file 
 request the av7110 firmware, this will block until someone uploads it 
linuxtv.orgdownloaddvbfirmware\n");
 check if the firmware is available 
 NOTE: since we're using a prescaler of 2, we set the
 divisor frequency to 62.5kHz and divide by 125 above
 wait for PLL lock
 call the real implementation 
 FujitsuSiemens DVB-Cable (ves1820Philips CD1516(??))
 HauppaugeTT WinTV DVB-S rev1.X
 HauppaugeTT WinTV Nexus-S Rev 2.X
 HauppaugeTT WinTV DVB-S rev1.3SE
 try the ALPS BSRV2 first of all
 try the ALPS BSRU6 now
 Try the grundig 29504-451
 Try DVB-C cards 
 Siemens DVB-C (full-length card) VES1820Philips CD1516 
 Hauppauge DVB-C 2.1 VES1820ALPS TDBE2 
 HauppaugeTT Nexus-T premium rev1.X
 try ALPS TDLB7 first, then Grundig 29504-401
 HauppaugeTT DVB-T
 Grundig 29504-401
 HauppaugeTT DVB-C premium rev2.X
 Galaxis DVB-S rev1.3
 ALPS BSRV2 
 Fujitsu-Siemens DVB-S rev 1.6 
 Grundig 29504-451 
 HauppaugeTT Nexus-CA rev1.X
 set TDA9819 into DVB mode 
 TDA9819 pin9(STD)
 TDA9819 pin30(VIF)
 tuner on this needs a slower i2c bus speed 
 HauppaugeTT Nexus-S rev 2.3 
 ALPS BSBE1 
 FIXME: propagate the failure code from the lower layers 
 Budgetpatch note:
  Original hardware design by Roberto Deza:
  There is a DVB_Wiki at
  https:linuxtv.org
  New software triggering design by Emard that works on
  original Roberto Deza's hardware:
  rps1 code for budgetpatch will copy internal HS event to GPIO3 pin.
  GPIO3 is in budget-patch hardware connectd to port B VSYNC
  HS is an internal event of 7146, accessible with RPS
  and temporarily raised high every n lines
  (n in defined in the RPS_THRESH1 counter threshold)
  I think HS is raised high on the beginning of the n-th line
  and remains high until this n-th line that triggered
  it is completely received. When the reception of n-th line
  ends, HS is lowered.
  To transmit data over DMA, 7146 needs changing state at
  port B VSYNC pin. Any changing of port B VSYNC will
  cause some DMA data transfer, with more or less packets loss.
  It depends on the phase and frequency of VSYNC and
  the way of 7146 is instructed to trigger on port B (defined
  in DD1_INIT register, 3rd nibble from the right valid
  numbers are 0-7, see datasheet)
  The correct triggering can minimize packet loss,
  dvbtraffic should give this stable bandwidths:
    22k transponder = 33814 kbits
  27.5k transponder = 38045 kbits
  by experiment it is found that the best results
  (stable bandwidths and almost no packet loss)
  are obtained using DD1_INIT triggering number 2
  (Va at rising edge of VS Fa = HS x VS-failing forced toggle)
  and a VSYNC phase that occurs in the middle of DMA transfer
  (about byte 188512=96256 in the DMA window).
  Phase of HS is still not clear to me how to control,
  It just happens to be so. It can be seen if one enables
  RPS_IRQ and print Event Counter 1 in vpeirq(). Every
  time RPS_INTERRUPT is called, the Event Counter 1 will
  increment. That's how the 7146 is programmed to do event
  counting in this budget-patch.c
  I think HPS setting has something to do with the phase
  of HS but I can't be 100% sure in that.
  hardware debug note: a working budget card (including budget patch)
  with vpeirq() interrupt setup in mode "0x90" (every 64K) will
  generate 3 interrupts per 25-Hz DMA frame of 2188512 bytes
  and that means 325=75 Hz of interrupt frequency, as seen by
  watch cat procinterrupts
  If this frequency is 3x lower (and data received in the DMA
  buffer don't start with 0x47, but in the middle of packets,
  whose lengths appear to be like 188 292 188 104 etc.
  this means VSYNC line is not connected in the hardware.
  (check soldering pcb and pins)
  The same behaviour of missing VSYNC can be duplicated on budget
  cards, by setting DD1_INIT trigger mode 7 in 3rd nibble.
	 Set RPS_IRQ to 1 to track rps1 activity.
	  Enabling this won't send any interrupt to PC CPU.
		 autodetect the presence of budget patch
		  this only works if saa7146 has been recently
		  reset with with MASK_31 to MC1
		 
		  will wait for VBI_B event (vertical blank at port B)
		  and will reset GPIO3 after VBI_B is detected.
		  (GPIO3 should be raised high by CPU to
		  test if GPIO3 will generate vertical blank signal
		  in budget patch GPIO3 is connected to VSYNC_B
 RESET SAA7146 
 autodetection success seems to be time-dependend after reset 
 Fix VSYNC level 
 set vsync_b triggering 
 port B VSYNC at rising edge 
 VBI
 BRS control
 a
 b
 HPS_CTRL1
 HPS_CTRL2
 DEBI
 start writing RPS1 code from beginning 
 Disable RPS1 
 RPS1 timeout disable 
 issue RPS1 interrupt to increment counter 
 Jump to begin of RPS program as safety measure               (p37) 
		 set event counter 1 source as RPS1 interrupt (0x03)          (rE4 p53)
		  use 0x03 to track RPS1 interrupts - increase by 1 every gpio3 is toggled
		  use 0x15 to track VPE  interrupts - increase by 1 every vpeirq() is called
 set event counter 1 threshold to maximum allowed value        (rEC p55) 
 Set RPS1 Address register to point to RPS code               (r108 p42) 
 Enable RPS1,                                                 (rFC p33) 
 now send VSYNC_B to rps1 by rising GPIO3 
		 if rps1 responded by lowering the GPIO3,
		  then we have budgetpatch hardware
 Disable RPS1 
 prepare the av7110 device struct 
	 the Siemens DVB needs this if you want to have the i2c chips
 275 kHz 
 full-ts mod? 
 check for full-ts flag in eeprom 
 dma3 
 set dd1 stream a & b 
 upload all 
		 set event counter 1 source as RPS1 interrupt (0x03)          (rE4 p53)
		  use 0x03 to track RPS1 interrupts - increase by 1 every gpio3 is toggled
		  use 0x15 to track VPE  interrupts - increase by 1 every vpeirq() is called
 set event counter 1 threshold to maximum allowed value        (rEC p55) 
 Setup BUDGETPATCH MAIN RPS1 "program" (p35) 
 Wait Source Line Counter Threshold                           (p36) 
 Set GPIO3=1                                                  (p42) 
 issue RPS1 interrupt 
 Wait reset Source Line Counter Threshold                     (p36) 
 Set GPIO3=0                                                  (p42) 
 issue RPS1 interrupt 
 Jump to begin of RPS program                                 (p37) 
 Fix VSYNC level 
 Set RPS1 Address register to point to RPS code               (r108 p42) 
		 Set Source Line Counter Threshold, using BRS                 (rCC p43)
		  It generates HS event every TS_HEIGHT lines
		  this is related to TS_WIDTH set in register
		  NUM_LINE_BYTE3. If NUM_LINE_BYTE low 16 bits
		  are set to TS_WIDTH bytes (TS_WIDTH=2188),
		  then RPS_THRESH1 should be set to trigger
		  every TS_HEIGHT (512) lines.
 Enable RPS1                                                  (rFC p33) 
 end of budgetpatch register initialization 
 set dd1 stream a & b 
 upload all 
 locks for data transfers fromto AV7110 
 default OSD window 
 TV standard 
 ARM "watchdog" 
 allocate and init buffers 
 init BMP buffer 
 load firmware into AV7110 cards 
 set initial volume in mixer struct 
	 special case DVB-C: these cards have an analog tuner
	   plus need some special handling, so we have separate
 Nothing to do. Rejoice. 
 Disable RPS1 
 VSYNC LOW (inactive) 
 DMA3 off 
print_time("av7110_irq");
	 Note: Don't try to handle the DEBI error irq (MASK_18), in
	  intel mode the timeout is asserted all the time...
printk("av7110_irq: DEBI\n");
		 Note 1: The DEBI irq is level triggered: We must enable it
		  only after we started a DMA xfer, and disable it here
		  immediately, or it will be signalled all the time while
		  DEBI is idle.
		  Note 2: You would think that an irq which is masked is
		  not signalled by the hardware. Not so for the SAA7146:
		  An irq is signalled as long as the corresponding bit
		  in the ISR is set, and disabling irqs just prevents the
		  hardware from setting the ISR bit. This means a) that we
		  must clear the ISR after disabling the irq (which is why
		  we must do it here even though saa7146_core did it already),
		  and b) that if we were to disable an edge triggered irq
		  (like the gpio irqs sadly are) temporarily we would likely
		  loose some. This sucks :-(
printk("av7110_irq: GPIO\n");
 Technisat SkyStar1
 TTHauppauge WinTV Nexus-CA v????
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 2012 - 2015 UNISYS CORPORATION
  All rights reserved.
 The Send and Receive Buffers of the IO Queue may both be full 
 GUIDS for HBA channel type supported by this driver 
	 Note that the only channel type we expect to be reported by the
	  bus driver is the VISOR_VHBA channel.
 The Data being tracked 
 Type of pointer that is being stored 
 Each scsi_host has a host_data area that contains this struct. 
	 Tracks the requests that have been forwarded to
	  the IOVM and haven't returned yet
 Start search for next pending free slot here 
 lock to protect data in devdata 
	
	  allows us to pass int handles back-and-forth between us and
	  iovm, instead of raw pointers
  add_scsipending_entry - Save off io command that is pending in
 			   Service Partition
  @devdata: Pointer to devdata
  @cmdtype: Specifies the type of command pending
  @new:     The command to be saved
  Saves off the io command that is being handled by the Service
  Partition so that it can be handled when it completes. If new is
  NULL it is assumed the entry refers only to the cmdrsp.
  Return: Insert_location where entry was added on success,
 	   -EBUSY if it can't
 wants to send cmdrsp 
  del_scsipending_ent - Removes an entry from the pending array
  @devdata: Device holding the pending array
  @del:     Entry to remove
  Removes the entry pointed at by del and returns it.
  Return: The scsipending entry pointed to on success, NULL on failure
  get_scsipending_cmdrsp - Return the cmdrsp stored in a pending entry
  @ddata: Device holding the pending array
  @ent:   Entry that stores the cmdrsp
  Each scsipending entry has a cmdrsp in it. The cmdrsp is only valid
  if the "sent" field is not NULL.
  Return: A pointer to the cmdrsp, NULL on failure
  setup_scsitaskmgmt_handles - Stash the necessary handles so that the
 				completion processing logic for a taskmgmt
 				cmd will be able to find who to wake up
 				and where to stash the result
  @xa:       The data object maintaining the pointer<-->int mappings
  @cmdrsp:   Response from the IOVM
  @event:    The event handle to associate with an id
  @result:   The location to place the result of the event handle into
 specify the event that has to be triggered when this cmd is complete 
  cleanup_scsitaskmgmt_handles - Forget handles created by
 				  setup_scsitaskmgmt_handles()
  @xa: The data object maintaining the pointer<-->int mappings
  @cmdrsp:   Response from the IOVM
  forward_taskmgmt_command - Send taskmegmt command to the Service
 			      Partition
  @tasktype: Type of taskmgmt command
  @scsidev:  Scsidev that issued command
  Create a cmdrsp packet and send it to the Service Partition
  that will service this request.
  Return: Int representing whether command was queued successfully or not
 issue TASK_MGMT_ABORT_TASK 
 save destination 
	 It can take the Service Partition up to 35 seconds to complete
	  an IO in some cases, so wait 45 seconds and error out
  visorhba_abort_handler - Send TASK_MGMT_ABORT_TASK
  @scsicmd: The scsicmd that needs aborted
  Return: SUCCESS if inserted, FAILED otherwise
 issue TASK_MGMT_ABORT_TASK 
  visorhba_device_reset_handler - Send TASK_MGMT_LUN_RESET
  @scsicmd: The scsicmd that needs aborted
  Return: SUCCESS if inserted, FAILED otherwise
 issue TASK_MGMT_LUN_RESET 
  visorhba_bus_reset_handler - Send TASK_MGMT_TARGET_RESET for each
 				target on the bus
  @scsicmd: The scsicmd that needs aborted
  Return: SUCCESS if inserted, FAILED otherwise
  visorhba_host_reset_handler - Not supported
  @scsicmd: The scsicmd that needs to be aborted
  Return: Not supported, return SUCCESS
 issue TASK_MGMT_TARGET_RESET for each target on each bus for host 
  visorhba_get_info - Get information about SCSI device
  @shp: Scsi host that is requesting information
  Return: String with visorhba information
 Return version string 
  dma_data_dir_linux_to_spar - convert dma_data_direction value to
 				Unisys-specific equivalent
  @d: dma direction value to convert
  Returns the Unisys-specific dma direction value corresponding to @d
  visorhba_queue_command_lck - Queues command to the Service Partition
  @scsicmd:		Command to be queued
  @vsiorhba_cmnd_done: Done command to call when scsicmd is returned
  Queues to scsicmd to the ServicePartition after converting it to a
  uiscmdrsp structure.
  Return: 0 if successfully queued to the Service Partition, otherwise
 	   error code
	 save the pending insertion location. Deletion from pending
	  will return the scsicmd pointer for completion
 save destination 
 save datadir 
 keep track of the max buffer length so far. 
 convert buffer to phys information  
 buffer is scatterlist - copy it out 
 queue must be full and we aren't going to wait 
  visorhba_slave_alloc - Called when new disk is discovered
  @scsidev: New disk
  Create a new visordisk_info structure and add it to our
  list of vdisks.
  Return: 0 on success, -ENOMEM on failure.
	 this is called by the midlayer before scan for new devices --
	  LLD can alloc any struct & do init if needed.
 already allocated return success 
 even though we errored, treat as success 
  visorhba_slave_destroy - Disk is going away, clean up resources.
  @scsidev: Scsi device to destroy
	 midlevel calls this after device has been quiesced and
	  before it is to be deleted.
  info_debugfs_show - Debugfs interface to dump visorhba states
  @seq: The sequence file to write information to
  @v:   Unused, but needed for use with seq file single_open invocation
  Presents a file in the debugfs tree named: visorhbavbus<x>:dev<y>info.
  Return: SUCCESS
  complete_taskmgmt_command - Complete task management
  @idrtable: The data object maintaining the pointer<-->int mappings
  @cmdrsp:   Response from the IOVM
  @result:   The result of the task management command
  Service Partition returned the result of the task management
  command. Wake up anyone waiting for it.
	 copy the result of the taskmgmt and
	  wake up the error handler that is waiting for this
  visorhba_serverdown_complete - Called when we are done cleaning up
 				  from serverdown
  @devdata: Visorhba instance on which to complete serverdown
  Called when we are done cleanning up from serverdown, stop processing
  queue, fail pending IOs.
	 Stop using the IOVM response queue (queue should be drained
	  by the end)
 Fail commands that weren't completed 
  visorhba_serverdown - Got notified that the IOVM is down
  @devdata: Visorhba that is being serviced by downed IOVM
  Something happened to the IOVM, return immediately and
  schedule cleanup work.
  Return: 0 on success, -EINVAL on failure
  do_scsi_linuxstat - Scsi command returned linuxstat
  @cmdrsp:  Response from IOVM
  @scsicmd: Command issued
  Don't log errors for disk-not-present inquiries.
 Do not log errors for disk-not-present inquiries 
 Okay see what our error_count is here.... 
  do_scsi_nolinuxstat - Scsi command didn't have linuxstat
  @cmdrsp:  Response from IOVM
  @scsicmd: Command issued
  Handle response when no linuxstat was returned.
		 Linux scsi code wants a device at Lun 0
		  to issue report luns, but we don't want
		  a disk there so we'll present a processor
		  there.
  complete_scsi_command - Complete a scsi command
  @uiscmdrsp: Response from Service Partition
  @scsicmd:   The scsi command
  Response was returned by the Service Partition. Finish it and send
  completion to the scsi midlayer.
 take what we need out of cmdrsp and complete the scsicmd 
  drain_queue - Pull responses out of iochannel
  @cmdrsp:  Response from the IOSP
  @devdata: Device that owns this iochannel
  Pulls responses out of the iochannel and process the responses.
 queue empty 
			 scsicmd location is returned by the
			  deletion
 complete the orig cmd 
 cmdrsp is now available for re-use 
  This is used only when this driver is active as an hba driver in the
  client guest partition.  It is called periodically so we can obtain
  and process the command respond from the IO Service Partition periodically.
  visorhba_pause - Function to handle visorbus pause messages
  @dev:	   Device that is pausing
  @complete_func: Function to call when finished
  Something has happened to the IO Service Partition that is
  handling this device. Quiet this device and reset commands
  so that the Service Partition can be corrected.
  Return: SUCCESS
  visorhba_resume - Function called when the IO Service Partition is back
  @dev:	   Device that is pausing
  @complete_func: Function to call when finished
  Yay! The IO Service Partition is back, the channel has been wiped
  so lets re-establish connection and start processing responses.
  Return: 0 on success, -EINVAL on failure
  visorhba_probe - Device has been discovered; do acquire
  @dev: visor_device that was discovered
  A new HBA was discovered; do the initial connections of it.
  Return: 0 on success, otherwise error code
  visorhba_remove - Remove a visorhba device
  @dev: Device to remove
  Removes the visorhba device.
 This is used to tell the visorbus driver which types of visor devices
  we support, and what functions to call when a visor device that we support
  is attached or removed.
  visorhba_init - Driver init routine
  Initialize the visorhba driver and register it with visorbus
  to handle s-Par virtual host bus adapter.
  Return: 0 on success, error code otherwise
  visorhba_exit - Driver exit routine
  Unregister driver from the bus and free up memory.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2012 - 2015 UNISYS CORPORATION
  All rights reserved.
 This driver lives in a spar partition, and registers to ethernet io
  channels from the visorbus driver. It creates netdev devices and
  forwards transmit to the IO channel and accepts rcvs from the IO
  Partition via the IO channel.
 MAX_BUF = 64 lines x 32 MAXVNIC x 80 characters
          = 163840 bytes
 GUIDS for director channel type supported by this driver.  
 {8cd5994d-c58e-11da-95a9-00e08161165f} 
	 Note that the only channel type we expect to be reported by the
	  bus driver is the VISOR_VNIC channel.
 FIXME XXX: This next line of code must be fixed and removed before
  acceptance into the 'normal' part of the kernel.  It is only here as a place
  holder to get module autoloading functionality working for visorbus.  Code
  must be added to scriptsmodefile2alias.c, etc., to get this working
  properly.
 struct visornic_devdata
  @enabled:                        0 disabled 1 enabled to receive.
  @enab_dis_acked:                 NET_RCV_ENABLEDISABLE acked by IOPART.
  @struct dev:
  @struct netdev:
  @struct net_stats:
  @interrupt_rcvd:
  @rsp_queue:
  @struct rcvbuf:
  @incarnation_id:                 incarnation_id lets IOPART know about
                                   re-birth.
  @old_flags:                      flags as they were prior to
                                   set_multicast_list.
  @usage:                          count of users.
  @num_rcv_bufs:                   number of rcv buffers the vnic will post.
  @num_rcv_bufs_could_not_alloc:
  @num_rcvbuf_in_iovm:
  @alloc_failed_in_if_needed_cnt:
  @alloc_failed_in_repost_rtn_cnt:
  @max_outstanding_net_xmits:      absolute max number of outstanding xmits
                                   - should never hit this.
  @upper_threshold_net_xmits:      high water mark for calling
                                   netif_stop_queue().
  @lower_threshold_net_xmits:      high water mark for calling
                                   netif_wake_queue().
  @struct xmitbufhead:             xmitbufhead - head of the xmit buffer list
                                   sent to the IOPART end.
  @server_down_complete_func:
  @struct timeout_reset:
  @struct cmdrsp_rcv:             cmdrsp_rcv is used for postingunposting rcv
                                   buffers.
  @struct xmit_cmdrsp:            xmit_cmdrsp - issues NET_XMIT - only one
                                   active xmit at a time.
  @server_down:                    IOPART is down.
  @server_change_state:            Processing SERVER_CHANGESTATE msg.
  @going_away:                     device is being torn down.
  @struct eth_debugfs_dir:
  @interrupts_rcvd:
  @interrupts_notme:
  @interrupts_disabled:
  @busy_cnt:
  @priv_lock:                      spinlock to access devdata structures.
  @flow_control_upper_hits:
  @flow_control_lower_hits:
  @n_rcv0:                         # rcvs of 0 buffers.
  @n_rcv1:                         # rcvs of 1 buffers.
  @n_rcv2:                         # rcvs of 2 buffers.
  @n_rcvx:                         # rcvs of >2 buffers.
  @found_repost_rcvbuf_cnt:        # repost_rcvbuf_cnt.
  @repost_found_skb_cnt:           # of found the skb.
  @n_repost_deficit:               # of lost rcv buffers.
  @bad_rcv_buf:                    # of unknown rcv skb not freed.
  @n_rcv_packets_not_accepted:     # bogs rcv packets.
  @queuefullmsg_logged:
  @struct chstat:
  @struct napi:
  @struct cmdrsp:
 spinlock to access devdata structures. 
 flow control counter 
 debug counters 
 Returns next non-zero index on success or 0 on failure (i.e. out of room). 
 The input entry spans only one page - add as is. 
 This entry spans multiple pages. 
 visor_copy_fragsinfo_from_skb - copy fragment list in the SKB to a phys_info
 				   array that the IOPART understands
  @skb:	  Skbuff that we are pulling the frags from.
  @firstfraglen: Length of first fragment in skb.
  @frags_max:	  Max len of frags array.
  @frags:	  Frags array filled in on output.
  Return: Positive integer indicating number of entries filled in frags on
          success, negative integer on error.
	 Compute the number of fragments this skb has, and if its more than
	  frag array can hold, linearize the skb
		 can take smallest of firstfraglen (what's left) OR
		  bytes left in the page
			 add_physinfo_entries only returns
			  zero if the frags array is out of room
			  That should never happen because we
			  fail above, if count+numfrags > frags_max.
	 Don't want to break ABI here by having a debugfs
	  file that no longer exists or is writable, so
	  lets just make this a vestigual function
 visornic_serverdown_complete - pause device following IOPART going down
  @devdata: Device managed by IOPART.
  The IO partition has gone down, and we need to do some cleanup for when it
  comes back. Treat the IO partition as the link being down.
 Stop polling for interrupts 
 visornic_serverdown - Command has notified us that IOPART is down
  @devdata:	   Device managed by IOPART.
  @complete_func: Function to call when finished.
  Schedule the work needed to handle the server down request. Make sure we
  haven't already handled the server change state event.
  Return: 0 if we scheduled the work, negative integer on error.
 alloc_rcv_buf - alloc rcv buffer to be given to the IO Partition
  @netdev: Network adapter the rcv bufs are attached too.
  Create an sk_buff (rcv_buf) that will be passed to the IO Partition
  so that it can write rcv data into our memory space.
  Return: Pointer to sk_buff.
	 NOTE: the first fragment in each rcv buffer is pointed to by
	  rcvskb->data. For now all rcv buffers will be RCVPOST_BUF_SIZE
	  in length, so the first frag is large enough to hold 1514.
	 current value of mtu doesn't come into play here; large
	  packets will just end up using multiple rcv buffers all of
	  same size.
 alloc_skb already zeroes it out for clarification. 
 post_skb - post a skb to the IO Partition
  @cmdrsp:  Cmdrsp packet to be send to the IO Partition.
  @devdata: visornic_devdata to post the skb to.
  @skb:     Skb to give to the IO partition.
  Return: 0 on success, negative integer on error.
 send_enbdis - Send NET_RCV_ENBDIS to IO Partition
  @netdev:  Netdevice we are enablingdisabling, used as context return value.
  @state:   Enable = 1disable = 0.
  @devdata: Visornic device we are enablingdisabling.
  Send the enabledisable message to the IO Partition.
  Return: 0 on success, negative integer on error.
 visornic_disable_with_timeout - disable network adapter
  @netdev:  netdevice to disable.
  @timeout: Timeout to wait for disable.
  Disable the network adapter and inform the IO Partition that we are disabled.
  Reclaim memory from rcv bufs.
  Return: 0 on success, negative integer on failure of IO Partition responding.
 send a msg telling the other end we are stopping incoming pkts 
 must wait for ack 
	 send disable and wait for ack -- don't hold lock when sending
	  disable because if the queue is full, insert might sleep.
	  If an error occurs, don't wait for the timeout.
	 wait for ack to arrive before we try to free rcv buffers
	  NOTE: the other end automatically unposts the rcv buffers
	  when it gets a disable.
	 Wait for usage to go to 1 (no other users) before freeing
	  rcv buffers
 we've set enabled to 0, so we can give up the lock. 
 stop the transmit queue so nothing more can be transmitted 
	 Free rcv buffers - other end has automatically unposed them on
	  disable
 init_rcv_bufs - initialize receive buffs and send them to the IO Partition
  @netdev:  struct netdevice.
  @devdata: visornic_devdata.
  Allocate rcv buffers and post them to the IO Partition.
  Return: 0 on success, negative integer on failure.
	 allocate fixed number of receive buffers to post to uisnic
	  post receive buffers after we've allocated a required amount
 if we failed to allocate one let us stop 
 couldn't even allocate one -- bail out 
	 Ensure we can alloc 23rd of the requested number of buffers.
	  23 is an arbitrary choice; used also in ndis init.c
 free receive buffers we did alloc and then bail out 
	 post receive buffers to receive incoming input - without holding
	  lock - we've not enabled nor started the queue so there shouldn't
	  be any rcv or xmit activity
		 Error handling -
		  If we posted at least one skb, we should return success,
		  but need to free the resources that we have not successfully
		  posted.
 visornic_enable_with_timeout	- send enable to IO Partition
  @netdev:  struct net_device.
  @timeout: Time to wait for the ACK from the enable.
  Sends enable to IOVM and inits, and posts receive buffers to IOVM. Timeout is
  defined in msecs (timeout of 0 specifies infinite wait).
  Return: 0 on success, negative integer on failure.
	 NOTE: the other end automatically unposts the rcv buffers when it
	  gets a disable.
	 now we're ready, let's send an ENB to uisnic but until we get
	  an ACK back from uisnic, we'll drop the packets
	 send enable and wait for ack -- don't hold lock when sending enable
	  because if the queue is full, insert might sleep. If an error
	  occurs error out.
 visornic_timeout_reset - handle xmit timeout resets
  @work: Work item that scheduled the work.
  Transmit timeouts are typically handled by resetting the device for our
  virtual NIC; we will send a disable and enable to the IOVM. If it doesn't
  respond, we will trigger a serverdown.
 visornic_open - enable the visornic device and mark the queue started
  @netdev: netdevice to start.
  Enable the device and start the transmit queue.
  Return: 0 on success.
 visornic_close - disables the visornic device and stops the queues
  @netdev: netdevice to stop.
  Disable the device and stop the transmit queue.
  Return 0 on success.
 devdata_xmits_outstanding - compute outstanding xmits
  @devdata: visornic_devdata for device
  Return: Long integer representing the number of outstanding xmits.
 vnic_hit_high_watermark
  @devdata:	    Indicates visornic device we are checking.
  @high_watermark: Max num of unacked xmits we will tolerate before we will
 		    start throttling.
  Return: True iff the number of unacked xmits sent to the IO Partition is >=
 	   high_watermark. False otherwise.
 vnic_hit_low_watermark
  @devdata:	   Indicates visornic device we are checking.
  @low_watermark: We will wait until the num of unacked xmits drops to this
 		   value or lower before we start transmitting again.
  Return: True iff the number of unacked xmits sent to the IO Partition is <=
 	   low_watermark.
 visornic_xmit - send a packet to the IO Partition
  @skb:    Packet to be sent.
  @netdev: Net device the packet is being sent from.
  Convert the skb to a cmdrsp so the IO Partition can understand it, and send
  the XMIT command to the IO Partition for processing. This function is
  protected from concurrent calls by a spinlock xmit_lock in the net_device
  struct. As soon as the function returns, it can be called again.
  Return: NETDEV_TX_OK.
	 sk_buff struct is used to host network data throughout all the
	  linux network subsystems
	 skb->len is the FULL length of data (including fragmentary portion)
	  skb->data_len is the length of the fragment portion in frags
	  skb->len - skb->data_len is size of the 1st fragment in skb->data
	  calculate the length of the first fragment that skb->data is
	  pointing to
 pad the packet out to minimum size 
 clear cmdrsp 
 save the pointer to skb -- we'll need it for completion 
 extra NET_XMITs queued over to IOVM - need to wait 
 save off the length of the entire data packet 
	 copy ethernet header from first frag into ocmdrsp
	  - everything else will be pass in frags & DMA'ed
	 copy frags info - from skb->data we need to only provide access
	  beyond eth header
 Track the skbs that have been sent to the IOVM for XMIT 
 update xmt stats 
 check if we have hit the high watermark for netif_stop_queue() 
 extra NET_XMITs queued over to IOVM - need to wait 
 stop queue - call netif_wake_queue() after lower threshold 
 skb will be freed when we get back NET_XMIT_DONE 
 visornic_get_stats - returns net_stats of the visornic device
  @netdev: netdevice.
  Return: Pointer to the net_device_stats struct for the device.
 visornic_change_mtu - changes mtu of device
  @netdev: netdevice.
  @new_mtu: Value of new mtu.
  The device's MTU cannot be changed by system; it must be changed via a
  CONTROLVM message. All vnics and pnics in a switch have to have the same MTU
  for everything to work. Currently not supported.
  Return: -EINVAL.
 visornic_set_multi - set visornic device flags
  @netdev: netdevice.
  The only flag we currently support is IFF_PROMISC.
 visornic_xmit_timeout - request to timeout the xmit
  @netdev: netdevice.
  Queue the work and return. Make sure we have not already been informed that
  the IO Partition is gone; if so, we will have already timed-out the xmits.
 Ensure that a ServerDown message hasn't been received 
 repost_return - repost rcv bufs that have come back
  @cmdrsp: IO channel command struct to post.
  @devdata: Visornic devdata for the device.
  @skb: Socket buffer.
  @netdev: netdevice.
  Repost rcv buffers that have been returned to us when we are finished
  with them.
  Return: 0 for success, negative integer on error.
 visornic_rx - handle receive packets coming back from IO Partition
  @cmdrsp: Receive packet returned from IO Partition.
  Got a receive packet back from the IO Partition; handle it and send it up
  the stack.
  Return: 1 iff an skb was received, otherwise 0.
	 post new rcv buf to the other end using the cmdrsp we have at hand
	  post it without holding lock - but we'll use the signal lock to
	  synchronize the queue insert the cmdrsp that contains the net.rcv
	  is the one we are using to repost, so copy the info we need from it.
	 set length to how much was ACTUALLY received -
	  NOTE: rcv_done_len includes actual length of data rcvd
	  including ethhdr
 update rcv stats - call it with priv_lock held 
 test enabled while holding lock 
		 don't process it unless we're in enable mode and until
		  we've gotten an ACK saying the other end got our RCV enable
	 when skb was allocated, skb->dev, skb->data, skb->len and
	  skb->data_len were setup. AND, data has already put into the
	  skb (both first frag and in frags pages)
	  NOTE: firstfragslen is the amount of data in skb->data and that
	  which is not in nr_frags or frag_list. This is now simply
	  RCVPOST_BUF_SIZE. bump tail to show how much data is in
	  firstfrag & set data_len to show rest see if we have to chain
	  frag_list.
 do PRECAUTIONARY check 
 length rcvd is greater than firstfrag in this skb rcv buf  
 amount in skb->data 
 amount that will be in frag_list 
		 data fits in this skb - no chaining - do
		  PRECAUTIONARY check
 should be 1 
 nothing rcvd in frag_list 
	 amount we bumped tail by in the head skb
	  it is used to calculate the size of each chained skb below
	  it is also used to index into bufline to continue the copy
	  (for chansocktwopc)
	  if necessary chain the rcv skbs together.
	  NOTE: index 0 has the same as cmdrsp->net.rcv.skb; we need to
	  chain the rest to that one.
	  - do PRECAUTIONARY check
 chain the various rcv buffers into the skb's frag_list. 
 Note: off was initialized above  
 start of list- set head 
			 should we set skb->len and skb->data_len for each
			  buffer being chained??? can't hurt!
 assert skb->len == off 
	 set up packet's protocol type using ethernet header - this
	  sets up skb->pkt_type & it also PULLS out the eth header
 accept all packets 
 accept all broadcast packets 
				 only accept multicast packets that we can
				  find in our multicast address list
 accept pkt, dest matches a multicast addr 
 accept packet, h_dest must match vnic  mac address 
 something is not right 
 drop packet - don't forward it up to OS 
	 netif_rx returns various values, but "in practice most drivers
	  ignore the return value
	 whether the packet got dropped or handled, the skb is freed by
	  kernel code, so we shouldn't free it. but we should repost a
	  new rcv buffer.
 devdata_initialize - initialize devdata structure
  @devdata: visornic_devdata structure to initialize.
  @dev:     visorbus_device it belongs to.
  Setup initial values for the visornic, based on channel and default values.
  Return: A pointer to the devdata structure.
 devdata_release - free up references in devdata
  @devdata: Struct to clean up.
 DebugFS code 
 for each vnic channel dump out channel specific data 
 Only consider netdevs that are visornic, and are open 
		 str_pos += scnprintf(vbuf + str_pos, len - str_pos,
		 		     " inner_loop_limit_reached_cnt = %lu\n",
		 		     devdata->inner_loop_limit_reached_cnt);
 send_rcv_posts_if_needed - send receive buffers to the IO Partition.
  @devdata: Visornic device.
 don't do this until vnic is marked ready 
	 this code is trying to prevent getting stuck here forever,
	  but still retry it if you cant allocate them all this time.
 drain_resp_queue - drains and ignores all messages from the resp queue
  @cmdrsp:  IO channel command response message.
  @devdata: Visornic device to drain.
 service_resp_queue - drain the response queue
  @cmdrsp:  IO channel command response message.
  @devdata: Visornic device to drain.
  @rx_work_done:
  @budget:
  Drain the response queue of any responses from the IO Partition. Process the
  responses as we get them.
		 TODO: CLIENT ACQUIRE -- Don't really need this at the
		  moment
 queue empty 
 process incoming packet 
 only call queue wake if we stopped it 
 ASSERT netdev == vnicinfo->netdev; 
				 check if we have crossed the lower watermark
				  for netif_wake_queue()
					 enough NET_XMITs completed
					  so can restart netif queue
 Inform Linux that the link is up 
 cmdrsp is now available for reuse  
 If there aren't any more packets to receive stop the poll 
 visornic_channel_interrupt	- checks the status of the response queue
  Main function of the vnic_incoming thread. Periodically check the response
  queue and drain it if needed.
 visornic_probe - probe function for visornic devices
  @dev: The visor device discovered.
  Called when visorbus discovers a visornic device on its bus. It creates a new
  visornic ethernet adapter.
  Return: 0 on success, or negative integer on error.
 Get MAC address from channel and read it into the device. 
 don't trust messages laying around in the channel 
 not yet 
 Setup rcv bufs 
	 set the net_xmit outstanding threshold
	  always leave two slots open but you should have 3 at a minimum
	  note that max_outstanding_net_xmits must be > 0
 create a cmdrsp we can use to post and unpost rcv buffers 
set the default mtu 
 TODO: Setup Interrupt information 
 Let's start our threads to get responses 
	 Note: Interrupts have to be enable before the while
	  loop below because the napi routine is responsible for
	  setting enab_dis_acked
 create debugsysfs directories 
 host_side_disappeared - IO Partition is gone
  @devdata: Device object.
  IO partition servicing this device is gone; do cleanup.
 indicate device destroyed 
 visornic_remove - called when visornic dev goes away
  @dev: Visornic device that is being removed.
  Called when DEVICE_DESTROY gets called to remove device.
 going_away prevents new items being added to the workqueues 
 this will call visornic_close() 
 visornic_pause - called when IO Part disappears
  @dev:	   Visornic device that is being serviced.
  @complete_func: Call when finished.
  Called when the IO Partition has gone down. Need to free up resources and
  wait for IO partition to come back. Mark link as down and don't attempt any
  DMA. When we have freed memory, call the complete_func so that Command knows
  we are done. If we don't call complete_func, the IO Partition will never
  come back.
  Return: 0 on success.
 visornic_resume - called when IO Partition has recovered
  @dev:	   Visornic device that is being serviced.
  @compelte_func: Call when finished.
  Called when the IO partition has recovered. Re-establish connection to the IO
  Partition and set the link up. Okay to do DMA again.
  Returns 0 for success, negative integer on error.
	 Must transition channel to ATTACHED state BEFORE
	  we can start using the device again.
	  TODO: State transitions
 This is used to tell the visorbus driver which types of visor devices
  we support, and what functions to call when a visor device that we support
  is attached or removed.
 visornic_init - init function
  Init function for the visornic driver. Do initial driver setup and wait
  for devices.
  Return: 0 on success, negative integer on error.
 visornic_cleanup - driver exit routine
  Unregister driver from the bus and free up memory.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2011 - 2015 UNISYS CORPORATION
  All rights reserved.
  This driver lives in a generic guest Linux partition, and registers to
  receive keyboard and mouse channels from the visorbus driver.  It reads
  inputs from such channels, and delivers it to the Linux OS in the
  standard way the Linux expects for input drivers.
 These defines identify mouse and keyboard activity which is specified by the
  firmware to the host using the cmsimpleinput protocol.  @ingroup coretypes
 only motion; arg1=x, arg2=y 
 arg1: 1=left,2=center,3=right 
 arg1: wheel rotation away fromtoward user 
 arg1: scancode, as follows: If arg1 <= 0xff, it's a 1-byte scancode and arg1
 	 is that scancode. If arg1 > 0xff, it's a 2-byte scanecode, with the 1st
 	 byte in the low 8 bits, and the 2nd byte in the high 8 bits.
 	 E.g., the right ALT key would appear as x'38e0'.
 arg1: scancode (in same format as inputaction_keyDown); MUST refer to one of
 	 the locking keys, like capslock, numlock, or scrolllock.
  arg2: 1 iff locking key should be in the LOCKED position (e.g., light is ON)
 Keyboard channel {c73416d0-b0b8-44af-b304-9d2ae99f1b3d} 
 Mouse channel {addf07d4-94a9-46e2-81c3-61abcdbdbd87} 
 header of keyboardmouse channels 
  This is the private data that we store for each device. A pointer to this
  struct is maintained via dev_get_drvdata()  dev_set_drvdata() for each
  struct device.
 lock for dev 
 size of following array 
 for keyboard devices: visorkbd_keycode[] + visorkbd_ext_keycode[] 
  Borrowed from driversinputkeyboardatakbd.c
  This maps 1-byte scancodes to keycodes.
 American layout 
 enables UK backslash+pipe key and FR lessthan+greaterthan key 
  This maps the <xx> in extended scancodes of the form "0xE0 <xx>" into
  keycodes.
 0x00 
 0x10 
 0x18 
 0x20 
 0x28 
 0x30 
 AltGr , 0, 0, 0, 0, 0, 0, 0,		    
 0x40 
 0x48 
 0x50 
 0x58 
 0x60 
 0x70 
	
	  If we're not paused, really enable interrupts. Regardless of whether
	  we are paused, set a flag indicating interrupts should be enabled so
	  when we resume, interrupts will really be enabled.
	
	  If we're not paused, really disable interrupts. Regardless of
	  whether we are paused, set a flag indicating interrupts should be
	  disabled so when we resume we will not re-enable them.
  setup_client_keyboard() initializes and returns a Linux input node that we
  can use to deliver keyboard inputs to Linux.  We of course do this when we
  see keyboard inputs coming in on a keyboard channel.
 sizeof(unsigned char) 
 pre input_register! 
 pre input_register! 
 allocate room for devdata->keycode_table, filled in below 
	
	  visorinput_open() can be called as soon as input_register_device()
	  happens, and that will enable channel interrupts.  Setting paused
	  prevents us from getting into visorinput_channel_interrupt() prior
	  to the device structure being totally initialized.
	
	  This is an input device in a client guest partition, so we need to
	  create whatever input nodes are necessary to deliver our inputs to
	  the guest OS.
 No other input devices supported 
	
	  Device struct is completely set up now, with the exception of
	  visorinput_dev being registered. We need to unlock before we
	  register the device, because this can cause an on-stack call of
	  visorinput_open(), which would deadlock if we had the lock.
	
	  Establish calls to visorinput_channel_interrupt() if that is the
	  desired state that we've kept track of in interrupts_enabled while
	  the device was being created.
	
	  due to above, at this time no thread of execution will be in
	  visorinput_channel_interrupt()
  Make it so the current locking state of the locking key indicated by
  <keycode> is as indicated by <desired_state> (1=locked, 0=unlocked).
  <scancode> is either a 1-byte scancode, or an extended 16-bit scancode with
  0xE0 in the low byte and the extended scancode value in the next higher byte.
  This is used only when this driver is active as an input driver in the
  client guest partition.  It is called periodically so we can obtain inputs
  from the channel, and deliver them to the guest OS.
 Unsupported input action 
	
	  due to above, at this time no thread of execution will be in
	  visorinput_channel_interrupt()
	
	  Re-establish calls to visorinput_channel_interrupt() if that is the
	  desired state that we've kept track of in interrupts_enabled while
	  the device was paused.
 GUIDS for all channel types supported by this driver. 
 SPDX-License-Identifier: GPL-2.0
  Broadcom BM2835 V4L2 driver
  Copyright © 2013 Raspberry Pi (Trading) Ltd.
  Authors: Vincent Sanders @ Collabora
           Dave Stevenson @ Broadcom
 		(now dave.stevenson@raspberrypi.org)
           Simon Mellor @ Broadcom
           Luke Diamand @ Broadcom
 camera instance counter 
 global device data array 
 timeperframe: minmax and default 
 Container for MMAL and VB2 buffers
 video formats 
 ------------------------------------------------------------------
 	Videobuf queue operations
  ------------------------------------------------------------------
 refuse queue setup if port is not configured 
 Handle CREATE_BUFS situation - nplanes != 0 
 Handle REQBUFS situation 
	
	  videobuf2-vmalloc allocator is context-less so no need to set
	  alloc_ctxs array.
 error in transfer 
 there was a buffer with the error so return it 
 stream ended 
			 empty buffer whilst capturing - expected to be an
			  EOS, so grab another frame
			 stopping streaming.
			  return buffer, and signal frame completion
 signal frame completion 
 ensure a format has actually been set 
init_completion(&dev->capture.frame_cmplt); 
 enable frame capture 
 reset sequence number 
	 if the preview is not already running, wait for a few frames for AGC
	  to settle down.
 enable the connection from camera to encoder (if applicable) 
 Get VC timestamp at this point in time 
 Flag to indicate just to rely on kernel timestamps 
 enable the camera port 
 capture the first frame 
 abort streaming and wait for last buffer 
 ensure a format has actually been set 
 stop capturing frames 
 disable the connection from camera to encoder 
 wait for all buffers to be returned 
 ------------------------------------------------------------------
 	IOCTL operations
  ------------------------------------------------------------------
 overlay ioctl 
 already in requested state 
 disconnect preview ports and disable component 
 set preview port format and connect it to output 
	 The video overlay must stay within the framebuffer and can't be
	  positioned independently.
 input ioctls 
 only a single camera input 
 capture ioctls 
			
			  24bpp is a pain as we can't use simple masking.
			  Min stride is width aligned to 16, times 24bpp.
			
			  GPU isn't removing padding, so stride is aligned to
			  32
	 Image buffer has to be padded to allow for alignment, even though
	  we sometimes then remove that padding before delivering the buffer.
 Preview and encode ports need to match on resolution 
		 Need to disable the overlay before we can update
		  the resolution
 configure buffering 
 ensure capture is not going to be tried 
 Set any encoding specific parameters 
 Could set EXIF parameters here 
 configure buffering 
 Disconnect any previous connection 
 format dependent port setup 
 Make a further decision on port based on resolution 
 ensure capture is not going to be tried 
 configure buffering 
 select port for capture 
 todo: Need to convert the vchiqmmal error into a v4l2 error. 
 try the format to set valid parameters 
 if a capture is running refuse to set format 
	 If the format is unsupported v4l2 says we should switch to
	  a supported one and not return an error.
 timeperframe is arbitrary and continuous 
 regarding width & height - we support any within range 
 fill in stepwise (step=1.0 is required by V4L2 spec) 
 tpf: {, 0} resets timing; clip to [min, max]
 overlay 
 inputs 
 capture 
 buffer management 
 ------------------------------------------------------------------
 	Driver initfinalise
  ------------------------------------------------------------------
 V4L2 ioctl handler 
 Returns the number of cameras, and also the max resolution supported
  by those cameras.
 create a camera_info component 
 Unusual failure - let's guess one camera. 
 MMAL instance and component init 
 get the camera component ready 
	 There was an error in the firmware that meant the camera component
	  produced BGR instead of RGB.
	  This is now fixed, but in order to support the old firmwares, we
	  have to check.
 Found BGR24 first - old firmware. 
				 Found RGB24 first
				  new firmware, so use RGB24.
 Rely on fps_range 
 Rely on fps_range 
 Rely on fps_range 
 get the preview component ready 
 get the image encoder component ready 
 get the video encoder component ready 
 video device needs to be able to access instance data 
 v4l2 core mutex used to protect all fops and v4l2 ioctls. 
 setup device defaults 
 JPEG 
 v4l device registration 
 setup v4l controls 
 mmal init 
 initialize queue 
 initialise video devices 
		 Really want to call vidioc_s_fmt_vid_cap with the default
		  format, but currently the APIs don't join up.
 SPDX-License-Identifier: GPL-2.0
  Broadcom BM2835 V4L2 driver
  Copyright © 2013 Raspberry Pi (Trading) Ltd.
  Authors: Vincent Sanders @ Collabora
           Dave Stevenson @ Broadcom
 		(now dave.stevenson@raspberrypi.org)
           Simon Mellor @ Broadcom
           Luke Diamand @ Broadcom
 The supported V4L2_CID_AUTO_EXPOSURE_BIAS values are from -4.0 to +4.0.
  MMAL values are in 16th increments so the MMAL range is -24 to +24.
  V4L2 docs say value "is expressed in terms of EV, drivers should interpret
  the values as 0.001 EV units, where the value 1000 stands for +1 EV."
  V4L2 is limited to a max of 32 values in a menu, so count in 13rds from
  -4 to +4
 Supported ISO values (1000)
  ISOO = auto ISO
 special cluster entry 
 v4l2 control identifier 
	 control minimum value or
	  mask for MMAL_CONTROL_TYPE_STD_MENU
 maximum value of control 
 default value of control 
 step size of the control 
 integer menu array 
 mmal parameter id 
 V4L2_SCENE_MODE_NONE automatically added 
 control handlers
 Convert from index to 16ths 
		 V4L2 is in 100usec increments.
		  MMAL is 1usec.
	 exposure_dynamic_framerate (V4L2_CID_EXPOSURE_AUTO_PRIORITY) should
	  always apply irrespective of scene mode.
	
	  Older firmware versions (pre July 2019) have a bug in handling
	  MMAL_PARAMETER_VIDEO_BIT_RATE that result in the call
	  returning -MMAL_MSG_STATUS_EINVAL. So ignore errors from this call.
 Should never get here 
 Should never get here 
 Restore all user selections 
 Set up scene mode 
 Set all the values 
 Units of 100usecs 
 Dummy MMAL ID as it gets mapped into FPS range 
 mask is computed at runtime 
 Variable FPS. Define min FPS as 1fps. 
 Fixed FPS - set min and max to be the same 
				 Special handling to work out the mask
				  value based on the scene_configs array
				  at runtime. Reduces the chance of
				  mismatches.
 skip this entry when constructing controls 
 SPDX-License-Identifier: GPL-2.0
  Broadcom BM2835 V4L2 driver
  Copyright © 2013 Raspberry Pi (Trading) Ltd.
  Authors: Vincent Sanders @ Collabora
           Dave Stevenson @ Broadcom
 		(now dave.stevenson@raspberrypi.org)
           Simon Mellor @ Broadcom
           Luke Diamand @ Broadcom
  V4L2 driver MMAL vchiq interface code
  maximum number of components supported.
  This matches the maximum permitted by default on the VPU
  Timeout for synchronous msg responses in seconds.
  Helpful to increase this if stopping in the VPU debugger.
#define FULL_MSG_DUMP 1
 normal message context 
	 Index in the context_map idr so that we can find the
	  mmal_msg_context again when servicing the VCHI reply.
 work struct for buffer_cb callback 
 work struct for deferred callback 
 mmal instance 
 mmal port 
 actual buffer used to store bulk reply 
 amount of buffer used 
 MMAL buffer flags 
 Presentation and Decode timestamps 
 context status 
 bulk data 
 message handle to release 
 pointer to received message 
 received message length 
 completion upon reply 
 synchronous response 
 ensure serialised access to service 
 vmalloc page to receive scratch bulk xfers into 
 protect accesses to context_map 
 ordered workqueue to process all bulk operations 
 handle for a vchiq instance 
 todo: should this be allocated from a pool to avoid kzalloc 
	 Create an ID that will be passed along with our message so
	  that when we service the VCHI reply, we can look up what
	  message is being replied to.
 deals with receipt of event to host message 
 workqueue scheduled callback
  we do this because it is important we do not call any other vchiq
  sync calls from witin the message delivery thread
 workqueue scheduled callback to handle receiving buffers
  VCHI will allow up to 4 bulk receives to be scheduled before blocking.
  If we block in the service_callback context then we can't process the
  VCHI_CALLBACK_BULK_RECEIVED message that would otherwise allow the blocked
  vchiq_bulk_receive() call to complete.
 Dummy receive to ensure the buffers remain in order 
 queue the bulk submission 
				  Actual receive needs to be a multiple
				   of 4 bytes
 enqueue a bulk receive for a given message context 
		 todo: this is a serious error, we should never have
		  committed a buffer_to_host operation to the mmal
		  port without the buffer to back it up (underflow
		  handling) and there is no obvious way to deal with
		  this - how is the mmal servie going to react when
		  we fail to do the xfer and reschedule a buffer when
		  it arrives? perhaps a starved flag to indicate a
		  waiting bulk receive?
 ensure we do not overrun the available buffer 
		 todo: is this the correct response, what happens to
		  the rest of the message data?
 store length 
 data in message, memcpy from packet into output buffer 
 queue the buffer availability with MMAL_MSG_TYPE_BUFFER_FROM_HOST 
 get context 
 store bulk message context for when data arrives 
 initialise work structure ready to schedule callback 
 prep the buffer from host message 
 just to make debug clearer 
 drvbuf is our private data passed back 
 buffer header 
 nothing used yet 
 no offset 
 no flags 
 clear buffer type specific data 
 no payload in message 
 deals with receipt of buffer to host message 
 message reception had an error 
 empty buffer 
				return;	 successful bulk submission, bulk
					  completion will trigger callback
 do callback with empty buffer - not EOS though 
 data is not in message, queue a bulk receive 
			return;	 successful bulk submission, bulk
				  completion will trigger callback
 failed to submit buffer, this will end badly 
 data payload within message 
 signal error 
 schedule the port callback 
 schedule the port callback 
 incoming event service callback 
 handling is different for buffer messages 
 messages dependent on header context to complete 
 fill in context values 
			 todo: should this check (completion_done()
			  == 1) for no one waiting? or do we need a
			  flag to tell us the completion has been
			  interrupted so we can free the message and
			  its context. This probably also solves the
			  message arriving after interruption todo
			  below
 complete message so caller knows it happened 
		 TODO: consider if this requires action if received when
		  driver is not explicitly closing the service
 payload size must not cause message to exceed max size 
 todo: what happens if the message arrives after aborting 
 todo do readonly fields need setting at all? 
 only three writable fields in a port 
 elementary stream format setup 
 got an unexpected message type in reply 
 return operation status 
 use port info get message to retrieve port information 
 port info time 
 got an unexpected message type in reply 
 return operation status 
 copy the values out of the message 
	 port type and index cached to use on port info set because
	  it does not use a port handle
 stream format 
 elementary stream format 
 create component on vc 
 build component create message 
 got an unexpected message type in reply 
 a valid component response received 
 destroys a component on vc 
 got an unexpected message type in reply 
 enable a component on vc 
 got an unexpected message type in reply 
 disable a component on vc 
 got an unexpected message type in reply 
 get version of mmal implementation 
 got an unexpected message type in reply 
 do a port action with a port as a parameter 
 got an unexpected message type in reply 
 do a port action with handles as parameters 
 got an unexpected message type in reply 
 got an unexpected message type in reply 
 got an unexpected message type in reply 
	 port_parameter_get_reply.size includes the header,
	  whilst value_size doesn't.
		 Copy only as much as we have space for
		  but report true size of parameter
 Always report the size of the returned parameter to the caller 
 disables a port and drains buffers from it 
		
		  Drain all queued buffers on port. This should only
		  apply to buffers that have been queued before the port
		  has been enabled. If the port has been enabled and buffers
		  passed, then the buffers should have been removed from this
		  list, and we should get the relevant callbacks via VCHIQ
		  to release the buffers.
 enable a port 
 send buffer headers to videocore 
 ------------------------------------------------------------------
  Exported API
 ------------------------------------------------------------------
 read what has actually been set 
 enable a port
  enables a port and queues buffers for satisfying callbacks if we
  provide a callback handler
 already enabled - noop 
 ports will be connected in a tunneled manner so data buffers
  are not handled by client.
 disconnect ports if connected 
		 do not need to disable the destination port as they
		  are connected and it is done automatically
 do not make new connection 
 copy src port format to dst 
 set new format 
 read what has actually been set 
 connect two ports together 
 Port is disabled. Queue for when it is enabled. 
 Initialise a mmal component and its ports
 port index 
 todo is this correct error? 
	 We need a handle to reference back to our component structure.
	  Use the array index in instance->component rather than rolling
	  another IDR.
 ports info needs gathering 
  cause a mmal component to be destroyed
  cause a mmal component to be enabled
  cause a mmal component to be enabled
	 compile time checks to ensure structure size as they are
	  directly (de)serialised from memory.
 ensure the header structure has packed to the correct size 
 ensure message structure does not exceed maximum length 
 mmal port struct is correct size 
 create a vchi instance 
 SPDX-License-Identifier: GPL-2.0
 Copyright 2011 Broadcom Corporation.  All rights reserved. 
 hardware definition 
 open callback 
 Initialise alsa_stream 
 clear spdif status, as we are not in spdif mode 
 minimum 16 bytes alignment (for vchiq bulk transfers) 
 position update is in 10ms order 
	
	  Do not free up alsa_stream here, it will be freed up by
	  runtime->private_free callback we registered in _open above
	 notify the vchiq that it should enter spdif passthrough mode by
	  setting channels=0 (see
	  https:github.comraspberrypilinuxissues528)
 trigger callback 
 pointer callback 
	 Give userspace better delay reporting by interpolating between GPU
	  notifications, assuming audio speed is close enough to the clock
	  used for ktime
 operators 
 create a pcm device 
 SPDX-License-Identifier: GPL-2.0
 Copyright 2011 Broadcom Corporation.  All rights reserved. 
 Open the VCHI service connections 
 Finished with the service for now 
 Close all VCHI service connections 
 Initialize and create a VCHI connection 
 Close the VCHI connection - it will also free vchi_ctx->instance 
 Allocate memory for this instance 
 bulk transfer 
 resend ctls - alsa_stream may not have been open when first send 
 FIXME: this doesn't seem working as expected for "draining" 
 Stop the audio service 
 Send the message to the videocore 
 SPDX-License-Identifier: GPL-2.0
 Copyright 2011 Broadcom Corporation.  All rights reserved. 
 volume maximum and minimum in terms of 0.01dB 
 originally -10240 
 change ctls for all substreams 
 2303 
	
	  bcm2835 supports only consumer mode and sets all other format flags
	  automatically. So the only thing left is signalling non-audio content
 SPDX-License-Identifier: GPL-2.0
 Copyright 2011 Broadcom Corporation.  All rights reserved. 
 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
  Copyright (c) 2014 Raspberry Pi (Trading) Ltd. All rights reserved.
  Copyright (c) 2010-2012 Broadcom. All rights reserved.
 Global 'vchiq' debugfs and clients entry used by all instances 
 Log category debugfs entries 
 add an instance (process) to the debugfs entries 
 create an entry under <debugfs>vchiqlog for each log category 
 remove all the debugfs entries 
 CONFIG_DEBUG_FS 
 CONFIG_DEBUG_FS 
 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
 Copyright (c) 2010-2012 Broadcom. All rights reserved. 
 Function to initialize our lock 
  This function is used to defer initialization until the vchiq stack is
  initialized. If the stack is already initialized, then the callback will
  be made immediately, otherwise it will be deferred until
  vchiq_call_connected_callbacks is called.
 We're already connected. Call the callback immediately. 
  This function is called by the vchiq stack once it has been connected to
  the videocore and clients can start to use the stack.
 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
  Copyright (c) 2014 Raspberry Pi (Trading) Ltd. All rights reserved.
  Copyright (c) 2010-2012 Broadcom. All rights reserved.
 Override the default prefix, which would be vchiq_arm (from the filename) 
 Run time control of log level, based on KERN_XXX level. 
 Keepalive-related data 
	
	  Global use count for videocore.
	  This is equal to the sum of the use counts for all services.  When
	  this hits zero the videocore suspend procedure will be initiated.
	
	  Use count to track requests from videocore peer.
	  This use count is not associated with a service, so needs to be
	  tracked separately with the state.
	
	  Flag to indicate that the first vchiq connect has made it through.
	  This means that both sides should be fully ready, and we should
	  be able to suspend after this point.
 This value is the size of the L2 cache lines as understood by the
  VPU firmware, which determines the required alignment of the
  offsetssizes in pagelists.
  Modern VPU firmware looks for a DT "cache-line-size" property in
  the VCHIQ node and will overwrite it with the actual L2 cache size,
  which the kernel must then respect.  That property was rejected
  upstream, so we have to use the VPU firmware's compatibility value
  of 32.
 Read (and clear) the doorbell 
 Was the doorbell rung? 
 There is a potential problem with partial cache lines (pages?)
  at the ends of the block when reading. If the CPU accessed anything in
  the same line (page?) then it may have pulled old data into the cache,
  obscuring the new data underneath. We can solve this by transferring the
  partial cache lines separately, and allowing the ARM to copy into the
  cached area.
	 Allocate enough storage to hold the page pointers and the page
	  list
 Populate the fields of the pagelistinfo structure 
 do not try and release vmalloc pages 
 This is probably due to the process being killed 
 release user pages 
	
	  Initialize the scatterlist so that the magic cookie
	   is filled if debugging is enabled
 Now set the pages for each scatterlist 
 Combine adjacent blocks for performance 
		 Note: addrs is the address + page_count - 1
		  The firmware expects blocks after the first to be page-
		  aligned and a multiple of the page size
 Partial cache lines (fragments) require special measures 
	
	  NOTE: dma_unmap_sg must be called before the
	  cpu can touch any of the datapages.
 Deal with any partial cache lines (fragments) 
 Need to mark all the pages dirty. 
	
	  VCHI messages between the CPU and firmware use
	  32-bit bus addresses.
 Allocate space for the channels in coherent memory 
 Send the base address of the slots to VideoCore 
 data barrier operation 
 trigger vc interrupt 
	
	  Store the pagelistinfo address in remote_data,
	  which isn't used by the slave.
	
	  VideoCore may not be ready due to boot up timing.
	  It may never be ready if kernel and firmware are mismatched,so don't
	  block forever.
 Remove all services 
		
		  vchiq__bulk_transfer() may return VCHIQ_RETRY, so we need
		  to implement a retry mechanism since this function is
		  supposed to block until queued
		
		  vchiq__bulk_transfer() may return VCHIQ_RETRY, so we need
		  to implement a retry mechanism since this function is
		  supposed to block until queued
 This thread has an outstanding bulk transfer. 
 FIXME: why compare a dma address to a pointer? 
				
				  This is not a retry of the previous one.
				  Cancel the signal when the transfer completes.
 Cancel the signal when the transfer completes. 
 Out of space - wait for the client 
 N.B. service_userdata is updated while processing AWAIT_COMPLETION 
		
		  Take an extra reference, to be held until
		  this CLOSED notification is delivered.
	
	  A write barrier is needed here to ensure that the entire completion
	  record is written out before the insert point.
	
	  How do we ensure the callback goes to the right client?
	  The service_user data points to a user_service record
	  containing the original callback and the user state structure, which
	  contains a circular buffer for completion records.
			
			  If there is no MESSAGE_AVAILABLE in the completion
			  queue, add one
		
		  If there is a thread waiting in DEQUEUE_MESSAGE, or if
		  there is a MESSAGE_AVAILABLE in the completion queue then
		  bypass the completion queue.
	
	  If the terminating NUL is included in the length, then it
	  marks the end of a line and should be replaced with a
	  carriage return.
	
	  There is no list of instances, so instead scan all services,
	  marking those that have been dumped.
  Autosuspend related functionality
		
		  read and clear counters.  Do release_count then use_count to
		  prevent getting more releases than uses
		
		  Call userelease service the requisite number of times.
		  Process use before release so use counts don't go negative
 Send the use notify to videocore 
 Don't use BUG_ON - don't allow user thread to crash kernel 
	
	  If there's more than 64 services, only dump ones with
	  non-zero counts
	
	  Simply exit on error since the function handles cleanup in
	  cases of failure.
 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
 Copyright (c) 2010-2012 Broadcom. All rights reserved. 
 -                                 
 -                                 
 + (srcport, -), fourcc, client_id 
 + (srcport, dstport)              
 + (srcport, dstport)              
 + (srcport, dstport)              
 + (srcport, dstport), data, size  
 + (srcport, dstport), data, size  
 + (srcport, dstport), actual      
 + (srcport, dstport), actual      
 -                                 
 -                                 
 -                                 
 -                                 
 -                                 
 Ensure the fields are wide enough 
 we require this for consistency between endpoints 
 Run time control of log level, based on KERN_XXX level. 
 Synchronise with other threads. 
		
		  If we're pausing then the slot_mutex is held until resume
		  by the slot handler.  Therefore don't try to acquire this
		  mutex if we're the slot handler and in the pause sent state.
		  We don't need to in this case anyway.
 Unblock any sending thread. 
	
	  Don't clear the 'fired' flag because it may already have been set
	  by the other side.
  All the event waiting routines in VCHIQ used a custom semaphore
  implementation that filtered most signals. This achieved a behaviour similar
  to the "killable" family of functions. While cleaning up this code all the
  routines where switched to the "interruptible" family of functions, as the
  former was deemed unjustified and the use "killable" set all VCHIQ's
  threads in D state.
  Round up message sizes so that any space at the end of a slot is always big
  enough for a header. This relies on header size being a power of two, which
  has been verified earlier by a static assertion.
 Allow room for the header 
 Round up 
 Called by the slot handler thread 
 Called by the slot handler thread 
 ... and ensure the slot handler runs. 
  Called from queue_message, by the slot handler and application threads,
  with slot_mutex held
 Fill the remaining space with padding 
 If necessary, get the next slot. 
 If there is no free slot... 
 ...wait for one. 
 But first, flush through the last slot. 
 No space available 
		
		  Signal the service that it
		  has dropped below its quota
 Set the found bit for this service 
			
			  Signal the service in case
			  it has dropped below its quota
 Called by the recycle thread. 
	
	  Find slots which have been freed by the other side, and return them
	  to the available queue.
	
	  Use a memory barrier to ensure that any state that may have been
	  modified by another thread is not masked by stale prefetched
	  values.
		
		  Beware of the address dependency - data is calculated
		  using an index written by the other side.
 Initialise the bitmask for services which have used this slot 
		
		  Don't allow the slot to be reused until we are no
		  longer interested in it.
 Called by the slot handler and application threads 
 The service has been closed 
		
		  Ensure this service doesn't use more than its quota of
		  messages or slots
		
		  Ensure data messages don't use more than their quota of
		  slots
 Pass the signal on to other waiters 
 The service has been closed 
		
		  In the event of a failure, return the mutex to the
		  state it was in
		
		  If this transmission can't fit in the last slot used by any
		  service, the data_use_count must be increased.
		
		  If this isn't the same slot last used by this service,
		  the service's slot_use_count must be increased.
			
			  It is assumed for now that this code path
			  only happens from calls inside this file.
			 
			  External callers are through the vchiq_queue_message
			  path which always sets the type to be VCHIQ_MSG_DATA
			 
			  At first glance this appears to be correct but
			  more review is needed.
 Make sure the new header is visible to the peer. 
 Make the new tx_pos visible to the peer. 
 Called by the slot handler and application threads 
 Rewrite the message header to prevent a double release 
 Add to the freed queue 
		
		  A read barrier is necessary here to prevent speculative
		  fetches of remote->slot_queue_recycle from overtaking the
		  mutex.
		
		  A write barrier is necessary, but remote_event_signal
		  contains one.
 Called by the slot handler - don't hold the bulk mutex 
		
		  Only generate callbacks for non-dummy bulk
		  requests, and non-terminated services
			
			  Make it look like a client, because
			  it must be removed and not left in
			  the LISTENING state.
 Called by the slot handler thread 
 Called with the bulk_mutex held 
 fabricate a matching dummy bulk 
 fabricate a matching dummy bulk 
 A matching service exists 
 Version mismatch 
 Acknowledge the OPEN 
 The service is now open 
 Success - the message has been dealt with 
 No available service, or an invalid request - send a CLOSE 
  parse_message() - parses a single message from the rx slot
  @state:  vchiq state struct
  @header: message header
  Context: Process context
  Return:
   >= 0     - size of the parsed message payload (without header)
   -EINVAL  - fatal error occurred, bail out is required
			
			  This could be a CLOSE from a client which
			  hadn't yet received the OPENACK - look for
			  the connected service
 There should be no data 
		
		  We should never receive a bulk request from the
		  other side since we're not setup to perform as the
		  master.
 If initiated, signal the application thread 
 Send a PAUSE in response 
 At this point slot_mutex is held 
 Release the slot mutex 
 Called by the slot handler thread 
			
			  Initialise use_count to one, and increment
			  release_count at the end of the slot to avoid
			  releasing the slot prematurely.
		
		  Perform some housekeeping when the end of the slot is
		  reached.
 Remove the extra reference count. 
  handle_poll() - handle service polling and other rare conditions
  @state:  vchiq state struct
  Context: Process context
  Return:
   0        - poll handled successful
   -EAGAIN  - retry later
 Poll the services as requested 
 Retry later 
			
			  This should really be impossible,
			  since the PAUSE should have flushed
			  through outstanding messages.
 Called by the slot handler thread 
			
			  Handle service polling and other rare conditions here
			  out of the mainline code
 Called by the recycle thread 
 Called by the sync thread 
 Ensure there is enough memory to run an absolutely minimum system 
	
	  initialize shared state pointers
	
	  initialize events and mutexes
 At start-of-day, the slot is empty and available 
	
	  bring up slot handler thread
 Indicate readiness to the other side 
 Called from application thread when a client or server service is created. 
	
	  Although it is perfectly possible to use a spinlock
	  to protect the creation of services, it is overkill as it
	  disables interrupts while the array is searched.
	  The only danger is of another thread trying to create a
	  service - service deletion is safe.
	  Therefore it is preferable to use state->mutex which,
	  although slower to claim, doesn't block interrupts while
	  it is held.
 Prepare to use a previously unused service 
				
				  There is another server using this
				  fourcc which doesn't match.
 Bring this service online 
 Don't unlock the service - leave it with a ref_count of 1. 
 Wait for the ACKNAK 
 Release any claimed messages aimed at this service 
			
			  This buffer is still being read from - stop
			  at the current read position
 Abort any outstanding bulk transfers 
 Complete the close process 
			
			  cater for cases where close is forced and the
			  client may not close all it's handles
 Called by the slot handler 
 The open was rejected - tell the user 
 Shutdown mid-open - let the other side know 
 Change the state while the mutex is still held 
 Change the state while the mutex is still held 
 This happens when a process is killed mid-close 
 Force into LISTENING mode 
 Called from the application process upon process death 
 Mark the service for removal by the slot handler 
 Called from the slot handler 
 Release the initial lock 
 Find all services registered to this client and enable them. 
 Find all services registered to this client and remove them. 
 Unregister the service 
 Mark the service for termination by the slot handler 
 Unregister the service 
		
		  Make it look like a client, because it must be removed and
		  not left in the LISTENING state.
 Mark the service for removal by the slot handler 
  This function may be called by kernel threads or user threads.
  User threads may receive VCHIQ_RETRY to indicate that a signal has been
  received and the call should be retried after being returned to user
  context.
  When called in blocking mode, the userdata field points to a bulk_waiter
  structure.
	
	  The slot mutex must be held when the service is being closed, so
	  claim it here to ensure that isn't happening
		
		  vchiq_queue_message() may return VCHIQ_RETRY, so we need to
		  implement a retry mechanism since this function is supposed
		  to block until queued
				
				  Signal the service that it may have
				  dropped below its quota
				
				  Signal the service that it may have
				  dropped below its quota
Don't include the lock just taken
 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
  Copyright (c) 2014 Raspberry Pi (Trading) Ltd. All rights reserved.
  Copyright (c) 2010-2012 Broadcom. All rights reserved.
 Allow the underlying service to be culled 
 Wake the user-thread blocked in close_ or remove_service 
 Copy to user space if msgbuf is not NULL 
 Cancel the signal when the transfer completes. 
 read a user pointer value from an array pointers in user space 
		
		  A read memory barrier is needed to stop
		  prefetch of a stale completion record
 This must be a VCHIQ-style service 
 Stall here for lack of a buffer for the message. 
 Get the pointer from user space 
 Copy the message to user space 
 Now it has been copied, the message can be released. 
 The completion must point to the msgbuf. 
		
		  FIXME: address space mismatch, does bulk_userdata
		  actually point to user or kernel memory?
		
		  Ensure that the above copy has completed
		  before advancing the remove pointer.
 Remove all services 
 Wake the completion thread and ask it to exit 
		
		  close_pending is false on first entry, and when the
		  wait in vchiq_close_service has been interrupted.
		
		  close_pending is true once the underlying service
		  has been closed until the client library calls the
		  CLOSE_DELIVERED ioctl, signalling close_event.
 Copy elements into kernel space 
 Increment for non-trivial changes 
 Update for incompatible changes 
 OUT 
 INOUT 
 Ensure videocore is awake to allow termination. 
 Wake the completion thread and ask it to exit 
 Wake the slot handler if the completion queue is full. 
 Mark all services for termination... 
 Wake the slot handler if the msg queue is full. 
 ...and wait for them to die 
 Release any closed services 
 Wake any blocked user-thread 
 Release the PEER service count. 
 	vchiq_register_chrdev - Register the char driver for vchiq
 				and create the necessary class and
 				device files in userspace.
 	@parent		The parent of the char device.
 	Returns 0 on success else returns the error code.
 	vchiq_deregister_chrdev	- Deregister and cleanup the vchiq char
 				  driver and device files
 SPDX-License-Identifier: GPL-2.0
  rtl8712_recv.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
init recv_buf
free skb by driver
	TODO:
	  Offset 0
Offset 4
Offset 8
Offset 12
 valid 
 correct 
 incorrect 
 correct 
 incorrect 
 invalid 
Offset 16
Offset 20
phy_info
perform defrag
		the first fragment number must be 0
		 free the whole queue
check the fragment sequence  (2nd ~n fragment frame) 
			 the fragment number must increase  (after decache)
			  release the defrag_q & prframe
		 copy the 2nd~n fragment frame's payload to the first fragment
		  get the 2nd~last fragment frame's payload
		 append  to first fragment frame's tail (if privacy frame,
		  pull the ICV)
 free the defrag_q queue and return the prframe 
 check if need to defrag, if needed queue the frame to defrag_q 
 need to define struct of wlan header frame ctrl 
isn't a fragment frame
		 0~(n-1) fragment frame
		  enqueue to defraf_g
the first fragment
free current defrag_q 
 Then enqueue the 0~(n-1) fragment to the defrag_q 
			 can't find this ta's defrag_queue, so free this
			  recv_frame
		 the last fragment frame
		  enqueue the last fragment
call recvframe_defrag to defrag
			 can't find this ta's defrag_queue, so free this
			   recv_frame
 after defrag we must check tkip mic code 
 Offset 12 denote 2 mac address 
==m==>change the length order
 move the data point to data content 
 Allocate new skb for releasing to upper layer 
 convert hdr + possible LLC headers into Ethernet header 
			 remove RFC1042 or Bridge-Tunnel encapsulation and
			  replace EtherType
 Leave Ethernet header part of hdr and full payload 
 Indicate the packets to upper layer 
8 bytes alignment
 Rx Reorder initialize condition.
 Drop out the packet which SeqNum is smaller than WinStart 
	
	  Sliding window manipulation. Conditions includes:
	  1. Incoming SeqNum is equal to WinStart =>Window shift 1
	  2. Incoming SeqNum is larger than the WinEnd => Window shift N
 Handling some condition for forced indicate case.
	 Prepare indication list and indication.
	  Check if there is any packet need indicate.
indicate this recv_frame
 indicate this recv_frame 
 Update local variables. 
 s1. 
s2. check if winstart_b(indicate_seq) needs to be updated
s3. Insert all packet into Reorder Queue to maintain its ordering.
	s4.
	  Indication process.
	  After Packet dropping and Sliding Window shifting as above, we can
	  now just indicate the packets with the SeqNum smaller than latest
	  WinStart and buffer other packets.
	 
	  For Rx Reorder condition:
	  1. All packets with SeqNum smaller than WinStart => Indicate
	  2. All packets with SeqNum larger than or equal to
	  WinStart => Buffer it.
BGN Mode
 including perform A-MPDU Rx Ordering Buffer Control
BG mode
 indicate this recv_frame 
	
	  -33dB~0dB to 0%~99%
 in dBm.
 Translate to dBm (x=0.5y-95).
 Record it for next packet processing
 CCK Driver info Structure is not the same as OFDM packet.
		 (1)Hardware does not provide RSSI for CCK
		  (2)PWDB, Average PWDB calculated by hardware
		  (for rate adaptive)
			 Modify the RF RNA gain value to -40, -20,
			  -2, 14 by Jenyu's suggestion
			  Note: different RF with the different
			  RNA gain.
 CCK gain is smaller than OFDMMCS gain,
 so we add gain diff by experiences, the val is 6 
 modify the offset to make the same gain index with OFDM.
		
		  (3) Get Signal Quality (EVM)
 (1)Get RSSI for HT rate 
 Translate DBM to percentage. 
		 (2)PWDB, Average PWDB calculated by hardware (for
		  rate adaptive)
 (3)EVM of HT rate 
 both spatial stream make sense 
 only spatial stream 1 makes sense 
dbm
	 UI BSS List signal strength(in percentage), make it good looking,
	  from 0~100. It is assigned to the BSS List in
	  GetValueFromBeaconOrProbeRsp().
		
		  1. Record the general EVM to the sliding window.
 <1> Showed on UI for user, in percentage. 
 free this recv_frame 
 check the frame crtl field and decache 
 free this recv_frame 
	 Test throughput with Netgear 3700 (No security) with Chariot 3T3R
	  pairs. The packet count will be a big number so that the containing
	  packet will effect the Rx reordering.
		 In this case, it means the MAX_RECVBUF_SZ is too small to
		  get the data from 8712u.
 more fragment bit 
 ragmentation number 
 uint 2^3 = 8 bytes 
 Qos data, wireless lan header length is 26 
can't access the precvbuf
		 for first fragment packet, driver need allocate 1536 +
		  drvinfo_sz + RXDESC_SIZE to defrag packet.
1658+6=1664, 1664 is 128 alignment.
		 2 is for IP header 4 bytes alignment in QoS packet case.
		  4 is for skb->data 4 bytes alignment.
		 because the endian issue, driver avoid reference to the
		  rxstat after calling update_recvframe_attrib_from_recvstat();
 SPDX-License-Identifier: GPL-2.0
  rtl871x_io.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
  The purpose of rtl871x_io.c
  a. provides the API
  b. provides the protocol engine
  c. provides the software interface between caller and the hardware interface
  For r8712u, both syncasync operations are provided.
  Only sync readwrite_mem operations are provided.
 SPDX-License-Identifier: GPL-2.0
  usb_halinit.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
 switch to 80M clock 
 enable VSPS12 LDO Macro block 
 Enable AFE Macro Block's Bandgap 
 enable LDOA15 block 
 Enable VSPS12_SW Macro Block 
 Enable AFE Macro Block's Mbias 
 isolate PCIe Analog 1.2V to PCIe 3.3V and PCIE Digital 
 attach AFE PLL to MACTOPBBPCIe Digital 
 enable AFE clock 
 Enable AFE PLL Macro Block 
 release isolation AFE PLL & MD 
 enable MAC clock 
 enable Core digital and enable IOREG RW 
 enable REG_EN 
 switch the control path 
 reduce EndPoint & init it 
 consideration of power consumption - init 
 Initialization for power on sequence, 
		 Enable AFE Macro Block's Bandgap and Enable AFE Macro
		  Block's Mbias
 Enable LDOA15 block 
 Enable Switch Regulator Block 
 Engineer Packet CP test Enable 
 Enable AFE clock 
 Enable AFE PLL Macro Block 
 Attach AFE PLL to MACTOPBBPCIe Digital 
 Switch to 40M clock 
 SSC Disable 
 Enable MAC clock 
 Revised POS, 
 Enable Core digital and enable IOREG RW 
 Enable REG_EN 
 Switch the control path to FW 
 Fix the RX FIFO issue(usb error), 
 For power save, used this in the bit file after 970621 
		 Initialization for power on sequence,
		  E-Fuse leakage prevention sequence
		 Set control path switch to HW control and reset Digital Core,
		  CPU Core and MAC IO to solve FW download fail when system
		  from resume sate.
 Revised POS, 
		 Enable AFE Macro Block's Bandgap and Enable AFE Macro
		  Block's Mbias
Bandgap
 Enable PLL Power (LDOA15V) 
 Enable LDOV12D block 
 Engineer Packet CP test Enable 
 Support 64k IMEM 
 Enable AFE clock 
 Enable AFE PLL Macro Block 
		 Some sample will download fw failure. The clock will be
		  stable with 500 us delay after reset the PLL
		  TODO: When usleep is added to kernel, change next 3
		  udelay(500) to usleep(500)
 Attach AFE PLL to MACTOPBBPCIe Digital 
 Switch to 40M clock 
		 CPU Clock and 80M Clock SSC Disable to overcome FW download
		  fail timing issue.
 Enable MAC clock 
 Revised POS, 
 Enable Core digital and enable IOREG RW 
 Enable REG_EN 
 Switch the control path to FW 
 Fix the RX FIFO issue(usb error), 970410 
 For power save, used this in the bit file after 970621 
 Revised for 8051 ROM code wrong operation. 
		 To make sure that TxDMA can ready to download FW.
		  We should reset TxDMA if IMEM RPT was not ready.
 PlatformStallExecution(5); 
 Delay 1ms 
 PlatformStallExecution(2); 
 Reset TxDMA 
 mapping rx fifo address 
 issue Rx irp to receive data 
 SPDX-License-Identifier: GPL-2.0
  rtl871x_mp_ioctl.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
0ffset :0x800~0xfff
0ffset :0x800~0xfff
 1T2R  path_a path_b 
This function initializes the DUT to the MP test mode
 3 1. initialize a new struct wlan_bssid_ex 
round up to multiple of 4 bytes.
init mp_start_test status
append txdesc
 3 2. create a new psta for mp driver 
 clear psta in the cur_network, if any 
 3 3. join pseudo AdHoc 
 Set to LINKED STATE for MP TRX Testing 
This function change the DUT from the MP test mode into normal mode 
 3 1. disconnect pseudo AdHoc 
 3 2. clear psta used in mp test mode. 
 3 3. return to normal state (default:station mode) 
 WIFI_STATION_STATE;
flush the cur_network
 1 for loopback
 Link in ad hoc network, 0x1025004C 
 RCR : disable all pkt, 0x10250048 
 RCR disable Check BSSID, 0x1025004a 
 disable RX filter map , mgt frames will put in RX FIFO 0 
boot from EFUSE
baseband register
0ffset :0x800~0xfff
baseband register
init workparam
------------------------------------------------------------------------
----------------------------------------------------------------------
 SET_OID 
4
4
RCR = 0x10250048
--------------------------------------------------------------------------
Linux
-------------------------------------------------------------------------
CALL  the power_down function
-------------------------------------------------------------------------- 
 SPDX-License-Identifier: GPL-2.0
  rtl871x_ioctl_linux.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
 pairwise key 
 set mic key 
 group key idx is 1 or 2 
 parsing WPAWPA2 IE 
 parsing WPS IE 
 AP MAC address 
 Add the ESSID 
 parsing HT_CAP_IE 
 Add the protocol name 
 Add mode 
 Add frequencychannel 
  check legal index 
 Add encryption capability 
Add basic and extended rates 
 Bit rate given in 500 kbs units 
 Check if we added any event 
 Add quality statistics 
 we only update signal_level (signal strength) that is rssi. 
 signal strength 
 signal quality 
 noise level 
 how to translate rssi to ?% 
 for large key indices, set the default (0) 
			 don't update "psecuritypriv->PrivacyAlgrthm" and
			  "psecuritypriv->PrivacyKeyIndex=keyid", but can
			  r8712_set_key to fwcam
 802_1x 
 sta mode 
 group key 
 set wps_ie 
 parsing HT_CAP_IE 
 If setting by frequency, convert to a channel 
 Setting by channel number 
 Yes ! We can set it !!! 
 	There are the BSSID information in the bssid.sa_data array.
 	If cmd is IW_PMKSA_FLUSH, it means the wpa_supplicant wants to clear
 	all the PMKID information. If cmd is IW_PMKSA_ADD, it means the
 	wpa_supplicant wants to add a PMKIDBSSID to driver.
 	If cmd is IW_PMKSA_REMOVE, it means the wpa_supplicant wants to
 	remove a PMKIDBSSID from driver.
 overwrite PMKID 
				 BSSID is matched, the same AP => rewrite
				  with new PMKID.
 Find a new entry 
				 BSSID is matched, the same AP => Remove
				  this PMKID information and reset it.
 no auto select 
	 Let's try to keep this struct in the same order as in
	  linuxincludewireless.h
	 TODO: See what values we can set, and remove the ones we can't
	  set, or fill them with some default data.
 ~5 Mbs real (802.11b) 
 TODO: 8711 sensitivity ? 
 signal level threshold range 
 percent values between 0 and 100. 
 Updated all three 
 > 8% missed beacons is 'bad' 
 TODO: Find real 'good' to 'bad' threshold value for RSSI 
 Updated all three 
 Include only legal frequencies for some countries 
Return received signal strength indicator in -db for 
 current AP 
<ssid> Rssi xx 
static u8 xxxx; 
(xxxx=xxxx+10) 
pcur_network->network.Rssi 
Return link speed in MBPS 
LinkSpeed xx 
Return mac address of the station 
 Macaddr = xx:xx:xx:xx:xx:xx 
Set scan type to active 
OK if successful 
Set scan type to passive 
OK if successful 
Set scan type to passive 
OK if successful 
u32 enableDrvCtrl 
u32 tryPktCnt 
u32 tryPktInterval 
u32 firstStageTO 
Set scan type to passive 
OK if successfu 
u32 enableDrvCtrl 
u32 tryPktCnt 
u32 tryPktInterval 
u32 firstStageTO 
 set bssid flow
  s1. set_802_11_infrastructure_mode()
  s2. set_802_11_authentication_mode()
  s3. set_802_11_encryption_mode()
  s4. set_802_11_bssid()
  This function intends to handle the Set AP command, which specifies the
  MAC# of a preferred Access Point.
  Currently, the request comes via Wireless Extensions' SIOCSIWAP ioctl.
  For this operation to succeed, there is no need for the interface to be up.
  This function intends to handle the Set Scan command.
  Currently, the request comes via Wireless Extensions' SIOCSIWSCAN ioctl.
  For this operation to succeed, the interface is brought Up beforehand.
 set ssid flow
  s1. set_802_11_infrastructure_mode()
  s2. set_802_11_authenticaion_mode()
  s3. set_802_11_encryption_mode()
  s4. set_802_11_ssid()
  This function intends to handle the Set ESSID command.
  Currently, the request comes via the Wireless Extensions' SIOCSIWESSID ioctl.
  For this operation to succeed, there is no need for the interface to be Up.
 no auto select 
 MCS15 
 default MCS7 
 Mbps2 
 no auto select 
 no auto select 
 no auto select 
 open system 
 set authentication mode 
 open system 
 shared system 
 open system 
		if (keyindex_provided == 1) {  set key_id only, no given
					        KeyMaterial(erq->length==0).
 transmit key 
 no auto select 
		
		   ??? does not use these parameters
 wpa_supplicant is enabling tkip countermeasure. 
 wpa_supplicant is disabling tkip countermeasure. 
		 HACK:
		 
		  wpa_supplicant calls set_wpa_enabled when the driver
		  is loaded and unloaded, regardless of if WPA is being
		  used.  No other calls are made which can be used to
		  determine if encryption will be used or not prior to
		  association being expected.  If encryption is not being
		  used, drop_unencrypted is set to false, else true -- we
		  can use this to determine if the CAP_PRIVACY_ON bit should
		  be set.
			 it means init value, or using wep,
			  ndisencryptstatus =
			 	Ndis802_11Encryption1Enabled,
			  then it needn't reset it;
 todo:check status, BytesNeeded, etc. 
 query info 
 BSSID match, then check if supporting wpawpa2 
 WPS Start 
 WPS Stop because of wps success 
 WPS Stop because of wps fail 
 802.1x 
 WPA 
 WPA_PSK 
 WPA2 
 WPA2_PSK 
		 HACK:
		 
		  wpa_supplicant calls set_wpa_enabled when the driver
		  is loaded and unloaded, regardless of if WPA is being
		  used.  No other calls are made which can be used to
		  determine if encryption will be used or not prior to
		  association being expected.  If encryption is not being
		  used, drop_unencrypted is set to false, else true -- we
		  can use this to determine if the CAP_PRIVACY_ON bit should
		  be set.
 added for WPA2 mixed mode 
 based on "driver_ipw" and for hostapd 
 SIOCSIWCOMMIT 
 SIOCGIWNAME 
 SIOCSIWNWID 
 SIOCGIWNWID 
 SIOCSIWFREQ 
 SIOCGIWFREQ 
 SIOCSIWMODE 
 SIOCGIWMODE 
 SIOCSIWSENS 
 SIOCGIWSENS 
 SIOCSIWRANGE 
 SIOCGIWRANGE 
 SIOCSIWPRIV 
 SIOCGIWPRIV 
 SIOCSIWSTATS 
 SIOCGIWSTATS 
 SIOCSIWSPY 
 SIOCGIWSPY 
 SIOCGIWTHRSPY 
 SIOCWIWTHRSPY 
 SIOCSIWAP 
 SIOCGIWAP 
	r871x_wx_set_mlme,		 request MLME operation;
					   uses struct iw_mlme
 SIOCGIWAPLIST -- deprecated 
 SIOCSIWSCAN 
 SIOCGIWSCAN 
 SIOCSIWESSID 
 SIOCGIWESSID 
 SIOCSIWNICKN 
 SIOCGIWNICKN 
 -- hole -- 
 -- hole -- 
 SIOCSIWRATE 
 SIOCGIWRATE 
 SIOCSIWRTS 
 SIOCGIWRTS 
 SIOCSIWFRAG 
 SIOCGIWFRAG 
 SIOCSIWTXPOW 
 SIOCGIWTXPOW 
 SIOCSIWRETRY 
 SIOCGIWRETRY 
 SIOCSIWENCODE 
 SIOCGIWENCODE 
 SIOCSIWPOWER 
 SIOCGIWPOWER 
---hole---
---hole---
 SIOCSIWGENIE 
 SIOCGIWGENIE 
 SIOCSIWAUTH 
 SIOCGIWAUTH 
 SIOCSIWENCODEEXT 
 SIOCGIWENCODEEXT 
 SIOCSIWPMKSA 
---hole---
for MM DTV platform
 show percentage, we need transfer dbm to original value. 
 SPDX-License-Identifier: GPL-2.0
  rtl871x_pwrctrl.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
	case PS_STATE_S2: only for USB normal powersave mode use,
			   temp mark some code.
 if driver is in active state, we dont need set smart_ps.
  Caller:ISR handler...
  This will be called when CPWM interrupt is up.
  using to update cpwn of drv; and drv will make a decision to up or
  down pwr level
 clear RPWM to ensure driver and fw back to initial state. 
  Caller: r8712_cmd_thread
  Check if the fw_pwrstate is okay for issuing cmd.
  If not (cpwm should be is less than P2 state), then the sub-routine
  will raise the cpwm to be greater than or equal to P2.
  Calling Context: Passive
  Return Value:
  0:	    r8712_cmd_thread can issue cmds to firmware afterwards.
  -EINVAL: r8712_cmd_thread can not do anything.
  Caller: ISR
  If ISR's txdone,
  No more pkts for TX,
  Then driver shall call this fun. to power down firmware again.
 SPDX-License-Identifier: GPL-2.0
  mlme_linux.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>.
  Larry Finger <Larry.Finger@lwfinger.net>
	if (adapter->securitypriv.AuthAlgrthm == 2) { 802.1x
 We have to backup the PMK information for WiFi PMK Caching
		 
		memcpy(&backupPMKIDList[0],
		       &adapter->securitypriv.PMKIDList[0],
		       sizeof(struct RT_PMKID_LIST)  NUM_PMKID_CACHE);
		backupPMKIDIndex = adapter->securitypriv.PMKIDIndex;
		backupTKIPCountermeasure =
			adapter->securitypriv.btkip_countermeasure;
		memset((unsigned char )&adapter->securitypriv, 0,
		       sizeof(struct security_priv));
		timer_setup(&adapter->securitypriv.tkip_timer,
			    r8712_use_tkipkey_handler, 0);
 Restore the PMK information to securitypriv structure
		 
		memcpy(&adapter->securitypriv.PMKIDList[0],
		       &backupPMKIDList[0],
		       sizeof(struct RT_PMKID_LIST)  NUM_PMKID_CACHE);
		adapter->securitypriv.PMKIDIndex = backupPMKIDIndex;
		adapter->securitypriv.btkip_countermeasure =
					 backupTKIPCountermeasure;
	} else { reset values in securitypriv
		struct security_priv sec_priv = &adapter->securitypriv;
		sec_priv->AuthAlgrthm = 0; open system
		sec_priv->PrivacyAlgrthm = _NO_PRIVACY_;
		sec_priv->PrivacyKeyIndex = 0;
		sec_priv->XGrpPrivacy = _NO_PRIVACY_;
		sec_priv->XGrpKeyid = 1;
		sec_priv->ndisauthtype = Ndis802_11AuthModeOpen;
		sec_priv->ndisencryptstatus = Ndis802_11WEPDisabled;
		sec_priv->wps_phase = false;
	}
}
void r8712_report_sec_ie(struct _adapter adapter, u8 authmode, u8 sec_ie)
{
	uint len;
	u8 buff, p, i;
	union iwreq_data wrqu;
	buff = NULL;
	if (authmode == _WPA_IE_ID_) {
		buff = kzalloc(IW_CUSTOM_MAX, GFP_ATOMIC);
		if (!buff)
			return;
		p = buff;
		p += sprintf(p, "ASSOCINFO(ReqIEs=");
		len = sec_ie[1] + 2;
		len =  (len < IW_CUSTOM_MAX) ? len : IW_CUSTOM_MAX;
		for (i = 0; i < len; i++)
			p += sprintf(p, "%02x", sec_ie[i]);
		p += sprintf(p, ")");
		memset(&wrqu, 0, sizeof(wrqu));
		wrqu.data.length = p - buff;
		wrqu.data.length = (wrqu.data.length < IW_CUSTOM_MAX) ?
				   wrqu.data.length : IW_CUSTOM_MAX;
		wireless_send_event(adapter->pnetdev, IWEVCUSTOM, &wrqu, buff);
		kfree(buff);
	}
}
 SPDX-License-Identifier: GPL-2.0
  rtl8712_cmd.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>.
  Larry Finger <Larry.Finger@lwfinger.net>
		 Here we only set bPbcPressed to true
		  After trigger PBC, the variable will be set to false
		 0 is the default value and it means the application monitors
		  the HW PBC doesn't provide its pid to driver.
 query rx phy status from fw.
  Adhoc mode: beacon.
  Infrastructure mode: beacon , data.
 Wait FW complete IO Cmd 
 time out 
 check mlme, hw, phy, or dynamic algorithm status. 
  invoke cmd->callback function 
  invoke cmd->callback function 
		 Before set JoinBss_CMD to FW, driver must ensure FW is in
		  PS_MODE_ACTIVE. Directly write rpwm to radio on and assign
		  new pwr_mode to Driver, instead of use workitem to change
		  state.
 if returning pcmd_r == NULL, pcmd must be free. 
 set 
 query 
 if pcmd != NULL, cmd will be handled by fw 
 32 bytes for TX Desc - 8 offset 
 8 bytes alignment 
 Append 8 bytes 
 free all cmd_obj resources 
 checking event sequence... 
 checking if event code is valid 
 checking if event size match the event parm size 
 update evt_seq 
 move to event content, 8 bytes alignment 
 SPDX-License-Identifier: GPL-2.0
  xmit_linux.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
 get UserPriority from IP hdr
UserPriority = (ntohs(ip_hdr.tos) >> 5) & 0x3 ;
		 "When priority processing of data frames is supported,
		  a STA's SME should send EAPOL-Key frames at the highest
		  priority."
dump xmitframe directly or drop xframe
 SPDX-License-Identifier: GPL-2.0
  rtl871x_security.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
 =====WEP related===== 
 preload shift register, per CRC-32 spec 
 transmit complement, per CRC-32 spec 
  Need to consider the fragment situation
 exclude ICV 
,wepkey
start to encrypt each fragment
 exclude ICV 
 start to decrypt recvframe 
 decrypt payload include icv 
 calculate icv and compare the icv 
 3 =====TKIP related===== 
 Convert from Byte[] to Us4Byte32 in a portable way 
 Convert from Us4Byte32 to Byte[] in a portable way 
 Reset the state to the empty message. 
 Set the key 
 and reset the message 
 Append the byte to our word-sized buffer 
 Process the word if it is full. 
 Clear the buffer 
 This is simple 
 Append the minimum padding 
 and then zeroes until the length is a multiple of 4 
 The appendByte function has already computed the result. 
 Reset to the empty message. 
 Michael MIC pseudo header: DA, SA, 3 x 0, Priority 
 ToDS==1 
 DA 
 From Ds==1 
 ToDS==0 
 DA 
 From Ds==1 
 macros for extractioncreation of unsigned charunsigned short values  
 select the Nth 16-bit word of the temporal key unsigned char array TK[]   
 S-box lookup: 16 bits --> 16 bits 
 fixed algorithm "parameters" 
 this needs to be "big enough"     
  48-bit transmitter address       
 128-bit temporal key              
  80-bit Phase1 key                
 128-bit RC4KEY (104 bits unknown) 
 2-unsigned char by 2-unsigned char subset of the full AES S-box table 
 Sbox for hash (can be in ROM) 
 second half is unsigned char-reversed version of first! 
  Routine: Phase 1 -- generate P1K, given TA, TK, IV32
  Inputs:
      tk[]      = temporal key                         [128 bits]
      ta[]      = transmitter's MAC address            [ 48 bits]
      iv32      = upper 32 bits of IV                  [ 32 bits]
  Output:
      p1k[]     = Phase 1 key                          [ 80 bits]
  Note:
      This function only needs to be called every 216 packets,
      although in theory it could be called every packet.
 Initialize the 80 bits of P1K[] from IV32 and TA[0..5]     
 use TA[] as little-endian 
 Now compute an unbalanced Feistel cipher with 80-bit block 
 size on the 80-bit block P1K[], using the 128-bit key TK[] 
 Each add is mod 216 
 avoid "slide attacks" 
  Routine: Phase 2 -- generate RC4KEY, given TK, P1K, IV16
  Inputs:
      tk[]      = Temporal key                         [128 bits]
      p1k[]     = Phase 1 output key                   [ 80 bits]
      iv16      = low 16 bits of IV counter            [ 16 bits]
  Output:
      rc4key[]  = the key used to encrypt the packet   [128 bits]
  Note:
      The value {TA,IV32,IV16} for Phase1Phase2 must be unique
      across all packets using the same key TK value. Then, for a
      given value of TK[], this TKIP48 construction guarantees that
      the final RC4KEY value is unique across all packets.
  Suggested implementation optimization: if PPK[] is "overlaid"
      appropriately on RC4KEY[], there is no need for the final
      for loop below that copies the PPK[] result into RC4KEY[].
 temporary key for mixing    
 Note: all adds in the PPK[] equations below are mod 216 
 first, copy P1K to PPK 
 next,  add in IV16 
 Bijective non-linear mixing of the 96 bits of PPK[0..5] 
 Mix key in each "round" 
 Total # S-box lookups == 6  
 Final sweep: bijective, "linear". Rotates kill LSB correlations   
 Use all of TK[] in Phase2   
 Note: At this point, for a given key TK[0..15], the 96-bit output 
 value PPK[0..5] is guaranteed to be unique, as a function   
 of the 96-bit "input" value   {TA,IV32,IV16}. That is, P1K  
 is now a keyed permutation of {TA,IV32,IV16}. 
 Set RC4KEY[0..3], which includes "cleartext" portion of RC4 key   
 RC4KEY[0..2] is the WEP IV  
 Help avoid weak (FMS) keys  
 Copy 96 bits of PPK[0..5] to RC4KEY[4..15]  (little-endian) 
The hlen isn't include the IV
  exclude ICV 
 4 start to encrypt each fragment 
 4 the last fragment 
 The hlen doesn't include the IV 
 exclude ICV 
 4 start to decrypt recvframe 
 4 decrypt payload include icv 
 3 =====AES related===== 
 SBOX Table 
 aes128k128d()                        
 Performs a 128 bit AES encrypt with  
 128 bit data.                        
 Swap halves 
 Rotate left 8 bits 
 logical shift left 1 bit 
 Rotate right 8 bits 
 1 - 9 
 construct_mic_iv()                           
 Builds the MIC IV from header fields and PN  
 QoS_TC           
 mute bits 7-4    
 mic_iv[8:13] = PN[5:0] 
 construct_mic_header1()                      
 Builds the first MIC header block from       
 header fields.                               
 Mute CF poll & CF ack bits 
 Mute retry, more data and pwr mgt bits 
 A1 
 A2 
 construct_mic_header2()                      
 Builds the last MIC header block from        
 header fields.                               
 A3 
 mpdu[23]; 
 A4 
 mute bits 15 - 4 
 A4 
 construct_mic_header2()                      
 Builds the last MIC header block from        
 header fields.                               
 flag 
 Ctr 
 bitwise_xor()                    
 A 128 bit, bitwise exclusive or  
 Intermediate Buffers 
 Find start of payload 
 Calculate MIC 
 Add on the final payload block if it needs padding 
 Insert MIC into payload 
 If short final block, then pad it,
 encrypt and copy unpadded part back 
 Encrypt the MIC 
 exclude ICV 
 Intermediate Buffers 
 4 start to encrypt each fragment 
 Intermediate Buffers 
 start to decrypt the payload 
(plen including llc, payload and mic) 
 now, decrypt pframe with hdrlen offset and plen long 
 8 is for extiv 
 If short final block, pad it,
 encrypt it and copy the unpadded part back   
 start to calculate the mic 
 Find start of payload 
 Calculate MIC 
 Add on the final payload block if it needs padding 
 Insert MIC into payload 
 If short final block, pad it,
 encrypt and copy unpadded part back 
 Encrypt the MIC 
 compare the mic 
 exclude ICV 
 Intermediate Buffers 
 4 start to encrypt each fragment 
 SPDX-License-Identifier: GPL-2.0
  rtl871x_recv.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
 Datagram Delivery Protocol 
  caller : defrag; recvframe_chk_defrag in recv_thread  (passive)
  pframequeue: defrag_queue : will be accessed in recv_thread  (passive)
  using spin_lock to protect
 calculate mic code 
icv_len included the mic code
 mic checked ok 
 decrypt and set the ivlen,icvlen of the recv_frame 
###set the security information in the recv_frame 
 get ether_type 
			 blocked
			  only accept EAPOL frame
free this frame
			 allowed
			  check decryption status, and decrypt the
			  frame if needed
 check is the EAPOL frame or not (Rekey) 
 check Rekey 
 filter packets that SA is myself or multicast or broadcast 
		 For Station mode, sa and bssid should always be BSSID,
		  and DA is my mac-address
			 For AP mode, if DA == MCAST, then BSSID should
			  be also MCAST
 not mc-frame 
			 For AP mode, if DA is non-MCAST, then it must be
			  BSSID, and bssid == BSSID
 get ap_info 
 if NULL-frame, drop packet 
		 drop QoS-SubType Data, including QoS NULL,
		  excluding QoS-Data
 filter packets that SA is myself or multicast or broadcast 
 da should be for me 
 check BSSID 
		 For AP mode, if DA is non-MCAST, then it must be BSSID,
		  and bssid == BSSID
		  For AP mode, RA=BSSID, TX=STA(SRC_ADDR), A3=DST_ADDR
 parsing QC field 
HT-CTRL 11n
 decache, drop duplicate recv packets 
shall check frame subtype, to  from ds, da, bssid 
then call check if rx seqfrag. duplicated.
add version chk
bit(7)~bit(2)
remove the wlanhdr and add the eth_hdr
point to frame_ctrl field
 convert hdr + possible LLC headers into Ethernet header 
		 remove RFC1042 or Bridge-Tunnel encapsulation and
		  replace EtherType
 Leave Ethernet header part of hdr and full payload 
 append rx status for mp test packets 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>.
  Larry Finger <Larry.Finger@lwfinger.net>
 firmware available - start netdev 
 todo: check if needs endian conversion 
 0:off 1:on 2:auto 
 1:RTSCTS 2:CTS to self 
 default enable turbo_mode 
 define the size of boot loader 
 define the size of FW in IMEM 
 define the size of FW in SRAM 
 define the size of DMEM variable 
 check signature 
 check fw_priv_sze & sizeof(struct fw_priv) 
 check fw_sz & image_fw_sz 
 for compare usage 
 max = 49152; 
 FW file size 
 firmware check ok 
 Download FirmWare 
 1. determine IMEM code size and Load IMEM Code Section 
49152) {
 2.Download EMEM code size and Load EMEM Code Section 
 max=48k 
 3.Enable CPU 
 4.polling IMEM Ready 
 5.Download DMEM code size and Load EMEM Code Section 
 polling dmem code done 
		if (tmp8 & BIT(4))  When boot from EEPROM,
				     & FW need more time to read EEPROM
 boot from EFUSE 
 r8712 firmware download 
	r8712_write32(padapter, RCR, (val32 | BIT(26)));  Enable RX TCP
							   Checksum offload
 Append PHY status 
 for usb rx aggregation 
 page = 128bytes 
 enable usb rx aggregation 
	r8712_write8(padapter, 0x102500D9, 1);  TH=1 => means that invalidate
						  usb rx aggregation
 1.7ms4 
 Fix the RX FIFO issue(USB error) 
 Turn off BB 
 Turn off MAC	
 Switch Control Path 
 Enable Loader Data Keep 
	r8712_write8(padapter, SYS_ISO_CTRL, 0xF9);  Isolation signals from
						      CORE, PLL
 Enable EFUSE 1.2V 
 Disable AFE PLL. 
 Disable A15V 
 Disable E-Fuse 1.2V 
 Disable LDO12(for CE) 
 Disable AFE BG&MB 
 Option for Disable 1.6V LDO.	
 Disable 1.6V LDO 
 Set SW PFM 
 SPDX-License-Identifier: GPL-2.0
  rtl871x_mlme.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
 Maybe someday we should rename this variable to "active_mode"(Jeff)
 1: active, 0: passive. 
 allocate DMA-ableNon-Page memory for cmd_buf and rsp_buf 
 return the wlan_network with the matching addr
  Shall be called under atomic context...
  to avoid possible racing condition...
in ad-hoc mode bit1 must set to 1 
 <1> Showed on UI for user, in percentage. 
 Caller must hold pmlmepriv->lock first 
	 If we didn't find a match, then get a new network slot to initialize
	  with this beacon's information
 If there are no more slots, expire the oldest 
 Otherwise just pull from the free list 
 update scan_time 
		 we have an entry and we are going to update it. But
		  this entry may be already expired. In this case we
		  do the same as we found a new net and call the new_net
		  handler
select the desired network based on the capability of the (i)bss.
  check items:		(1) security
 			(2) network_type
 			(3) WMM
 			(4) HT
 			(5) others
 TODO: Perry : For Power Management 
 endian_convert 
 update IBSS_network 's timestamp 
 lock pmlmepriv->lock when you accessing network_q 
 r8712_free_assoc_resources: the caller has to lock pmlmepriv->lock
  r8712_indicate_connect: the caller has to lock pmlmepriv->lock
  r8712_ind_disconnect: the caller has to lock pmlmepriv->lock
Notes:
 pnetwork : returns from r8712_joinbss_event_callback
 ptarget_wlan: found from scanned_queue
 if join_res > 0, for (fw_state==WIFI_STATION_STATE), we check if
   "ptarget_sta" & "ptarget_wlan" exist.
 if join_res > 0, for (fw_state==WIFI_ADHOC_STATE), we only check
  if "ptarget_wlan" exist.
 if join_res > 0, update "cur_network->network" from
  "pnetwork->network" if (ptarget_wlan !=NULL).
 endian_convert 
s1. find ptarget_wlan
s2. find ptarget_sta & update ptarget_sta
update ptarget_sta {
s3. update cur_network & indicate connect
update fw_state will clr _FW_UNDER_LINKING
TODO: update HT_Capability
indicate connect
 to do: 
		the sta have been in sta_info_queue => do nothing
		 (between drv has received this event before and
		  fw have not yet to set key to CAM_ENTRY)
 to do : init sta_info variable 
 psta->aid = (uint)pstassoc->cam_id; 
 a sta + bcmc_stainfo (not Ibss_stainfo) 
a sta + bcmc_stainfo (not Ibss_stainfo) 
re-create ibss
	When the Netgear 3500 AP is with WPA2PSK-AES mode, it will send
 	 the ADDBA req frame with start seq control = 0 to wifi client after
 	 the WPA handshake and the seqence number of following data packet
 	will be 0. In this case, the Rx reorder sequence is not longer than 0
 	 and the WiFi client will drop the data with seq number 0.
 	So, the 8712 firmware has to inform driver with receiving the
 	 ADDBA-Req frame so that the driver can reset the
 	sequence value of Rx reorder control.
		 set the indicate_seq to 0xffff so that the rx reorder
		  can store any following data packet.
 scan fail, so clear to_join flag 
r8712_indicate_connect again
				 if the ssid is the same, select the bss
				  which has the max rssi
 802.1X 
 WEP 
 adjust IEs for r8712_joinbss_cmd in WMM 
 after the fixed IE 
WMM element ID and OUI
 to the next IE element 
  Ported from 8185: IsInPreAuthKeyList().
  Search by BSSID,
  Return Value:
 	-1		:if there is no pre-auth key in the  table
 	>=0		:if there is pre-auth key, and   return the entry id
 Could not find. 
		;  There is one Pre-Authentication Key for the
		    specific BSSID.
Search required WPA or WPA2 IE and copy to sec_ie[] 
get next
restruct WPA IE or WPA2 IE in sec_ie[] 
			 parsing SSN IE to select required encryption
			  algorithm, and set the bcmc encryption algorithm
check wpa_oui tag
IE Ver error
					 get bcmc encryption type (group
					  key type)
none
WEP_40
TKIP
AESCCMP
WEP_104
check the unicast encryption type
else the uncst_oui is match
mixed mode, unicast_enc_type > 1
					select the uncst_oui and remove
					  the other uncst_oui
remove the other unicast suit
			 parsing RSN IE to select required encryption
			  algorithm, and set the bcmc encryption algorithm
IE Ver error
get bcmc encryption type
WEP_40
TKIP
AESWRAP
WEP_104
one
check the unicast encryption type
else the uncst_oui is match
mixed mode, unicast_enc_type > 1
					select the uncst_oui and remove the
					  other uncst_oui
remove the other unicast suit
copy fixed ie
copy RSN or SSN
the Pre-Authentication bit should be zero
copy fixed ie only
PMKID count = 0x0100
PMKID length = 2+16
 adhoc no 802.1x 
 TODO 
	 1. Supported rates
	  2. IE
the function is at passive_level
	 todo: if you want to do something ioreghw setting before join_bss,
	  please add code here
reset to disabled
reset it
 validate  usb rx aggregation 
TH = 48 pages, 6k
 invalidate  usb rx aggregation 
 TH=1 => means that invalidate usb rx aggregation 
the function is >= passive_level
 the function is > passive_level (in critical_section) 
 maybe needs check if ap supports rx ampdu. 
check Max Rx A-MPDU Size
 max_ampdu_sz (kbytes); 
	 for A-MPDU Rx reordering buffer control for bmc_sta & sta_info
	  if A-MPDU Rx is enabled, resetting rx_ordering_ctrl
	  wstart_b(indicate_seq) to default value=0xffff
	  todo: check if AP can send A-MPDU packets
 SPDX-License-Identifier: GPL-2.0
  rtl8712_io.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>.
  Larry Finger <Larry.Finger@lwfinger.net>
 SPDX-License-Identifier: GPL-2.0
  usb_intf.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
 RTL8188SU 
 Realtek 
 Abocom 
 ASUS 
 11n mode disable 
 Belkin 
 ISY IWL - Belkin clone 
 Corega 
 D-Link 
 11n mode disable 
 Edimax 
 EnGenius 
 Hawking 
 Hercules 
 Logitec 
 PCI 
 Sitecom 
 11n mode disable 
 Sweex 
 Thinkware 
 Toshiba 
 - 
 RTL8191SU 
 Realtek 
 Amigo 
 ASUSEKB 
 11n mode disable 
 ASUSEKBLenovo 
 11n mode disable 
 11n mode disable 
 ASUSMedia BOX 
 Belkin 
 D-Link 
 Edimax 
 EnGenius 
 Guillemot 
 Hawking 
 Mediao 
 PCI 
 Sitecom 
 Skyworth 
 - 
 11n mode disable 
 11n mode disable 
 RTL8192SU 
 Realtek 
 Belkin 
 Corega 
 Edimax 
 NEC 
disable_hw_interrupt
		device still exists, so driver can do io operation
		  TODO:
 cancel in irp 
 cancel out irp 
 TODO:cancel other irps 
s1.
s3.
s4.
s5.
s6.
  drv_init() - a device potentially for us
  notes: drv_init() is called when the bus driver has located a card for us
  to support. We accept the new device by returning 0.
	 In this probe function, O.S. will provide the usb interface pointer
	  to driver. We have to increase the reference count of the usb device
	  structure by using the usb_get_dev function.
 step 1. 
 step 2. 
	 step 3.
	  initialize the dvobj_priv
 step 4. 
 step 5. read efuseeeprom data and get mac_addr 
CR9346
 To check system boot selection.
 To check autoload success or not.
			 The following operations prevent Efuse leakage by
			  turning on 2.5V.
			 Retrieve Chip version.
			  Recognize IC version by Reg0x4 BIT15.
				 Use the mac address stored in the Efuse
				  offset = 0x12 for usb in efuse
 Led mode 
			 Make sure the user did not select a multicast
			  address by setting bit 1 of first octet.
 step 6. Load the firmware asynchronously 
 rmmod module & unplug(SurpriseRemoved) will call r871xu_dev_remove()
  => how to recognize both
 never exit with a firmware callback pending 
 will call netdev_close() 
 Stop driver mlme relation timer 
	 decrease the reference count of the usb device structure
	  when disconnect
	 If we didn't unplug usb dongle and removeinsert module, driver
	  fails on sitesurvey for the first time when device is up.
	  Reset usb port for sitesurvey fail issue.
 SPDX-License-Identifier: GPL-2.0
  rtl871x_eeprom.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
CF+ and SDIO
 USB 
	 Erase this particular word.  Write the erase opcode and register
	  number in that order. The opcode is 3bits in length; reg is 6
	  bits long.
	 write the new word to the EEPROM
	  send the write opcode the EEPORM
 select which word in the EEPROM that we are writing to. 
 write the data to the selected EEPROM word. 
ReadEEprom
 select EEPROM, reset bits, set _EECS 
	 write the read opcode and register number in that order
	  The opcode is 3bits in length, reg is 6 bits long
 Now read the data (16 bits) in from the selected EEPROM word 
 SPDX-License-Identifier: GPL-2.0
  rtl8712_led.c
  Copyright(c) 2007 - 2010  Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
===========================================================================
 	Constant.
 ===========================================================================
  Default LED behavior.
===========================================================================
  LED object.
 ===========================================================================
	LED_SCAN_BLINK = 6,  LED is blinking during scanning period,
			      the # of times to blink is depend on time
			      for scanning.
 LED is blinking during no link state. 
	LED_BLINK_StartToBlink = 8, Customized for Sercomm Printer
				     Server case
 LED is blinkg during WPS communication 
for ALPHA 
for BELKIN 
===========================================================================
 	Prototype of protected function.
 ===========================================================================
===========================================================================
  LED_819xUsb routines.
 ===========================================================================
 	Description:
 		Initialize an LED_871x object.
 	Description:
 		DeInitialize an LED_871x object.
	 We should reset bLedBlinkInProgress if we cancel
	  the LedControlTimer,
 	Description:
 		Turn on LED according to LedPin specified.
 SW control led0 on.
 SW control led1 on.
 	Description:
 		Turn off LED according to LedPin specified.
 Set to software control.
 Set to software control.
===========================================================================
  Interface to manipulate LED objects.
 ===========================================================================
 	Description:
 		Initialize all LED_871x objects.
	Description:
 		DeInitialize all LED_819xUsb objects.
	Description:
 		Implementation of LED blinking behavior.
 		It toggle off LED and schedule corresponding timer if necessary.
 Change LED according to BlinkingLedState specified. 
 Determine if we shall change LED state again. 
 Assign LED state to toggle. 
 Schedule a timer to toggle LED state. 
 Change LED according to BlinkingLedState specified. 
 WPS success 
 Change LED according to BlinkingLedState specified. 
 Change LED according to BlinkingLedState specified. 
WPS success
 Change LED according to BlinkingLedState specified. 
WPS authentication fail
WPS session overlap 
 Change LED according to BlinkingLedState specified. 
 Change LED according to BlinkingLedState specified. 
	Description:
 		Callback function of LED BlinkTimer,
 		it just schedules to corresponding BlinkWorkItem.
	 This fixed the crash problem on Fedora 12 when trying to do the
	  insmod;ifconfig up;rmmod commands.
	Description:
 		Callback function of LED BlinkWorkItem.
 		We dispatch actual LED blink action according to LedStrategy.
============================================================================
  Default LED behavior.
 ============================================================================
 	Description:
 		Implement each led action for SW_LED_MODE0.
 		This is default strategy.
 dummy branch 
wait until xinpin finish 
 dummy branch 
wait until xinpin finish
 dummy branch 
 wait until xinpin finish 
LED1 settings
wait until xinpin finish
WPS connect success
WPS authentication fail
LED1 settings
WPS session overlap
LED1 settings
 solid blue 
 dummy branch 
solid blue
wait until xinpin finish
	Description:
 		Dispatch LED action according to pHalData->LedStrategy.
 SPDX-License-Identifier: GPL-2.0
  recv_linux.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>.
  Larry Finger <Larry.Finger@lwfinger.net>
init os related resource in struct recv_priv
alloc os related resource in union recv_frame
alloc os related resource in struct recv_buf
free os related resource in struct recv_buf
	recvframe->u.hdr.pkt = NULL;  pointers to NULL before
				       r8712_free_recvframe()
enqueue back to free_recv_queue
 SPDX-License-Identifier: GPL-2.0
  rtl871x_xmit.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
	
	 Please insert all the queue initialization using _init_queue below
	
	  Please allocate memory with sz = (struct xmit_frame)  NR_XMITFRAME,
	  and initialize free_xmit_frame below.
	  Please also apply  free_txobj to link_up all the xmit_frames...
	
	  init xmit hw_txqueue
per AC pending irp
init xmit_buf
	
	  If driver xmit ARP packet, driver can set ps mode to initial
	  setting. It stands for getting DHCP or fix IP.
firstly, filter packet not belongs to mp
		 for mp storing the txcmd per packet,
		  according to the info of txcmd to update pattrib
get MP_TXDESC_SIZE bytes txcmd per packet
 r8712_xmitframe_coalesce() overwrite this!
		 The following is for DHCP and ARP packet, we use cck1M to
		  tx these packets and let LPS awake some time
		  to prevent DHCP protocol fail
MINIMUM_DHCP_PACKET_SIZE)
 IP header
					 68 : UDP BOOTP client
					  67 : UDP BOOTP server
					  Use low rate to send DHCP packet.
 get sta_info
 drop the pkt 
 if we cannot get psta => drrp the pkt 
 get ether_hdr_len 
	 if in MP_STATE, update pkt_attrib from mp_txcmd, and overwrite
	  some settings above.
encode mic code
start to calculate the mic code
 start to calculate the mic code 
 ToDS==1 
DA
 From Ds==1 
 ToDS==0 
 DA 
 From Ds==1 
			 add mic code  and add the mic code length in
			  last_txcmdsz
 to_ds = 1, fr_ds = 0; 
 to_ds = 0, fr_ds = 1; 
 TODO: fill HT Control Field 
 Update Seq Num will be handled by fw 
  This sub-routine will perform all the following:
  1. remove 802.3 header.
  2. create wlan_header, based on the info in pxmitframe
  3. append sta's ivext-iv
  4. append LLC
  5. move frag chunk from pframe to pxmitframe->mem
  6. apply sw-encrypt, if necessary.
 truncate TXDESC_SIZE bytes txcmd if at mp mode for 871x 
 take care -  update_txdesc overwrite this 
 adding icv, if necessary...
  Calling context:
  1. OS_TXENTRY
  2. RXENTRY (rx_thread or RX_ISRRX_CallBack)
  If we turn on USE_RXTHREAD, then, no need for critical section.
  Otherwise, we must use _enter_exit critical to protect free_xmit_queue...
  Must be very very cautious...
	
	  Please remember to use all the osdep_service api,
	  and lockunlock or _enter_exit critical to protect
	  pfree_xmit_queue
  Will enqueue pxmitframe to the proper queue, and indicate it
  to xx_pending list.....
 pxmitbuf attach to pxmitframe 
 urb and irp connection 
 buffer addr assoc 
 pxmitframe attach to pxmitbuf 
  tx_action == 0 == no frames to transmit
  tx_action > 0 ==> we have frames to transmit
  tx_action < 0 ==> we have frames to transmit, but TXFF is not even enough
 						 to transmit 1 frame.
enqueue packet
dump packet directly
 SPDX-License-Identifier: GPL-2.0
  rtl8712_xmit.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
RTL8712_EP_LO;
RTL8712_EP_HI;
RTL8712_EP_LO;
entry indx: 0->vo, 1->vi, 2->be, 3->bk.
Remove sta node when there are no pending packets.
				 must be done after sta_plist->next
				  and before break
 Fill up TxCmd Descriptor according as USB FW Tx Aaggregation info.
 dw0 
 dw1 
 Fill up Cmd Header for USB FW Tx Aggregation.
 dw0 
 802.3->802.11 converter 
 free skb struct 
padding zero 
 Add the new mpdu's length 
 linux complete context doesn't need to protect 
 buffer addr assoc 
RTL8712_DMA_H2CCMD 
 buffer addr assoc 
 use 1st xmitframe as media 
 urb length in cmd_dw1 
32 bytes for TX Desc + 8 bytes pending
default = 32 bytes for TX Desc
 offset 0 
 32 bytes for TX Desc + 8 bytes pending 
 default = 32 bytes for TX Desc 
 offset 4 
 dirty workaround, need to check if it is aggr cmd. 
Non-QoS
SEC_TYPE
KEY_ID when WEP is used;
offset 8
offset 12
		 fw will increase the seqnum by itself, driver pass the
		  correct priority to fw.
		  fw will check the correct priority for increasing the
		  seqnum per tid. about usb using 4-endpoint, qsel points out
		  the correct mapping between AC&Endpoint,
		  the purpose is that correct mapping lets the MAC release
		  the AC Queue list correctly.
Not EAP & ARP type data packet
BGN Mode
			 EAP data packet and ARP packet.
			  Use the 1M data rate to send the EAPARP packet.
			  This will maybe make the handshake smooth.
driver uses data rate
1M
 mp tx packets 
 offset 8 
 offset 16 
 offset 20 
 reset to zero; 
 offset 4 
 CAM_ID(MAC_ID), default=5; 
 Non-QoS 
 offset 8 
 offset 12 
		 fw will increase the seqnum by itself, driver pass the
		  correct priority to fw.
		  fw will check the correct priority for increasing the seqnum
		  per tid. about usb using 4-endpoint, qsel points out the
		  correct mapping between AC&Endpoint,
		  the purpose is that correct mapping let the MAC releases
		  the AC Queue list correctly.
 offset 16 
gtest
 offset 20 
 gtest 1M 
 offset 4 
 offset 4 
offset 8
offset 12
offset 16
gtest
offset 20
gtest
 1st frame dequeued 
 need to remember the 1st frame 
		 1. dequeue 2nd frame
		  2. aggr if 2nd xframe is dequeued, else dump directly
			 always return ndis_packet after
			  r8712_xmitframe_coalesce
 pxmitframe == NULL && p2ndxmitframe == NULL 
 SPDX-License-Identifier: GPL-2.0
  rtl871x_cmd.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
  Caller and the r8712_cmd_thread can protect cmd_q by spin_lock.
  No irqsave is necessary.
 allocate DMA-ableNon-Page memory for cmd_buf and rsp_buf 
 allocate DMA-ableNon-Page memory for cmd_buf and rsp_buf 
  Calling Context:
  r8712_enqueue_cmd can only be called between kernel thread,
  since only spin_lock is used.
  ISRCall-Back functions can't call this sub-function.
 notes: translate IELength & Length after assign to cmdsz; 
 for hidden ap to set fw_state here 
	
	  If the driver wants to use the bssid to create the connection.
	  If not, we copy the connecting AP's MAC address to it so that
	  the driver just has the bssid information for PMKIDList searching.
 WMM IE in beacon 
 no WMM IE in beacon 
		
		  For WEP mode, we will use the bg mode to do the connection
		  to avoid some IOT issues, especially for Realtek 8192u
		  SoftAP.
 restructure_ht_ie 
 get cmdsz before endian conversion 
 wlan_network endian conversion 
 for sta_mode 
 endian_convert 
		
		  we will set _FW_LINKED when there is one more sat to
		  join us (stassoc_event_callback)
CAM_ID(CAM_ENTRY)
 SPDX-License-Identifier: GPL-2.0
  usb_ops_linux.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
 HI Queue 
 in 
 in 
 in 
 in 
 translate DMA FIFO addr to pipehandle 
 SUCCESS 
 Try to use skb from the free queue 
 skb is reused 
 translate DMA FIFO addr to pipehandle 
 not to consider tx fragment 
 translate DMA FIFO addr to pipehandle 
 context is xmit_frame 
	 For mstar platform, mstar suggests the address for USB IO
	  should be 16 bytes alignment. Trying to fix it here.
 read_in 
 write_out 
 Success this control transfer. 
			 For Control read transfer, we have to copy the read
			  data from pIo_buf to pdata.
 SPDX-License-Identifier: GPL-2.0
  os_intfs.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>.
  Larry Finger <Larry.Finger@lwfinger.net>
 module param defaults 
for enable tx_ampdu
 The video_mode variable is for video mode.
 It may be specify when inserting module with video_mode=1 parameter.
 enable video mode
Ndis802_11Infrastructure; infra, ad-hoc, auto
ad-hoc support requirement
long, short, auto
active, passive
 default is set to disable the wmm.
 1T2R
 mac address to use instead of the one stored in Efuse 
 if wifi_test = 1, driver will disable the turbo mode and pass it to
  firmware private.
UAPSD
 1 second timeout 
 Initial the PID value used for HW PBC.
Below is to terminate r8712_cmd_thread & event_thread...
xmit_priv
 mlme_priv 
 Maybe someday we should rename this variable to "active_mode"(Jeff)
 1: active, 0: passive. 
ht_priv
set to disabled
security_priv
pwrctrl_priv
registry_priv
misc.
	   bit 8:
	    1 -> enable video mode to 96B AP
	    0 -> disable video mode to 96B AP
	    bit 9:
	    1 -> enable 40MHz mode
	    0 -> disable 40MHz mode
	    bit 10:
	    1 -> enable STBC
	    0 -> disable STBC
 enable bit8, bit10
		 if the driver supports the 40M bandwidth,
		  we can enable the bit 9.
  This function intends to handle the activation of an interface
  i.e. when it is brought UpActive from a Down state.
 Use the mac address stored in the Efuse 
			 We have to inform fw to use user-supplied MAC
			  address.
			
			  The "myid" function will get the wifi mac address
			  from eeprompriv structure instead of netdev
			  structure. So, we have to overwrite the mac_addr
			  stored in the eeprompriv structure. In this case,
			  the real mac address won't be used anymore. So that,
			  the eeprompriv.mac_addr should store the mac which
			  users specify.
 start driver mlme relation timer 
  This function intends to handle the shutdown of an interface
  i.e. when it is brought Down from an UpActive state.
 Close LED
s1.
s2.
s2-1.  issue disassoc_cmd to fw
s2-2.  indicate disconnect to os
s2-3.
s2-4.
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
  Special for bb and rf reg readwrite
 offset : 0X800~0XFFF 
 4 byte access 
 4 byte access 
 offset : 0X800~0XFFF 
 4 byte access 
 4 byte access 
 offset : 0x00 ~ 0xFF 
  SetChannel
  Description
 	Use H2C command to change channel,
 	not only modify rf register, but also other setting need to be done.
 3 1.Set MAC register : BWOPMODE  bit2:1 20MhzBW 
 3 2.Set PHY related register 
 20 MHz channel
		 Use PHY_REG.txt default value. Do not need to change.
		  Correct the tx power for CCK rate in 40M.
		  It is set in Tx descriptor for 8192x series
 40 MHz channel
		 Use PHY_REG.txt default value. Do not need to change.
		  Correct the tx power for CCK rate in 40M.
		  Set Control channel to upper or lower. These settings are
		  required only for 40MHz
 3 3.Set RF related register 
------------------------------Define structure----------------------------
 From SD3 Willis suggestion !!! Set RF A=TX and B as standby
 Power save 
 Power save 
 For 8192S 
 Disable Power save 
OFDM Tx
OFDM Tx
 A 
 default: A 
 option: A 
 B 
 default: B 
 option: B 
 AB 
 default:A 
 option:B 
OFDM Rx
OFDM Rx
CCK TxRx
 0x24: RF Reg[6:5] 
 0x24: RF Reg[4:0] 
 Start Single Carrier. 
 1. if OFDM block on? 
set OFDM block on
 2. set CCK test mode off, set to CCK normal mode 
 3. turn on scramble setting 
 4. Turn On Single Carrier Tx and off the other test modes. 
 Stop Single Carrier.
 Turn off all test modes.
BB Reset
 Start Single Tone.
 PAD all on.
 Stop Single Tone.
 PAD all on.
 Start Carrier Suppression.
 1. if CCK block on? 
set CCK block on
 Turn Off All Test Mode 
transmit mode
turn off scramble setting
Set CCK Tx Test Rate
Set FTxRate to 1Mbps
 Stop Carrier Suppression. 
normal mode
turn on scramble setting
BB Reset
 1. if CCK block on? 
set CCK block on
 Turn Off All Test Mode 
Set CCK Tx Test Rate
transmit mode
turn on scramble setting
normal mode
turn on scramble setting
BB Reset
 mpt_StartCckContTx 
 1. if OFDM block on? 
set OFDM block on
 2. set CCK test mode off, set to CCK normal mode
 3. turn on scramble setting 
 4. Turn On Continue Tx and turn off the other test modes.
BB Reset
 mpt_StartOfdmContTx 
 ADC turn off [bit24-21] adc port0 ~ port1 
 ADC turn on [bit24-21] adc port0 ~ port1 
select
 set counter to zero
selection
Read packet count
 SPDX-License-Identifier: GPL-2.0
  rtl871x_ioctl_set.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
 wifi, printable ascii code must be supported 
 adhoc mode will start with an empty queue, but skip checking 
		 when set_ssidset_bssid for do_join(), but scanning queue
		  is empty we try to issue sitesurvey firstly
			 submit r8712_createbss_cmd to change to an
			  ADHOC_MASTER pmlmepriv->lock has been
			  acquired by caller...
 can't associate ; reset under-linking 
			 when set_ssidset_bssid for do_join(), but
			  there are no desired bss in scanning queue
			  we try to issue sitesurvey first
				 driver is in
				  WIFI_ADHOC_MASTER_STATE
					 if in WIFI_ADHOC_MASTER_STATE or
					   WIFI_ADHOC_STATE, create bss or
					  rejoin again
					 driver is in
					  WIFI_ADHOC_MASTER_STATE
			 will clr Linked_state before this function,
			  we must have checked whether issue dis-assoc_cmd or
			  not
		 clear WIFI_STATION_STATE; WIFI_AP_STATE; WIFI_ADHOC_STATE;
		  WIFI_ADHOC_MASTER_STATE
 Scan or linking is in progress, do nothing. 
 802.1x 
 SPDX-License-Identifier: GPL-2.0
  ieee80211.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>.
  Larry Finger <Larry.Finger@lwfinger.net>
-----------------------------------------------------------
  for adhoc-master to generate ie and provide supported-rate to fw
 -----------------------------------------------------------
 r8712_set_ie will update frame length 
 ---------------------------------------------------------------------------
  index: the information element id index, limit is the limit for search
  ---------------------------------------------------------------------------
timestamp will be inserted by hardware
beacon interval : 2bytes
capability info
SSID
supported rates
DS parameter set
IBSS Parameter Set
check if oui matches...
check version...
 No WPA IE - fail silently 
group_cipher
pairwise_cipher
 No RSN IE - fail silently 
group_cipher
pairwise_cipher
Search required WPA or WPA2 IE and copy to sec_ie[ ]
get next 
get next
get next
 goto next 
 SPDX-License-Identifier: GPL-2.0
  rtl871x_sta_mgt.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
 this function is used to free the memory of lock || sema for all stainfos 
 be done before free sta_hash_lock 
 For the SMC router, the sequence number of first packet of WPS handshake
  will be 0. In this case, this packet will be dropped by recv_decache function
  if we use the 0x00 as the default value for tid_rxseq variable. So, we
  initialize the tid_rxseq variable as the 0xffff.
 for A-MPDU Rx reordering buffer control 
 using pstapriv->sta_hash_lock to protect 
 re-init sta_info; 20061114 
	 for A-MPDU Rx reordering buffer control,
	  cancel reordering_ctrl_timer
 insert into free_sta_queue; 20061114 
 free all stainfo which in sta_hash[all] 
 any station allocated can be searched by hash list 
 if found the matched address 
 SPDX-License-Identifier: GPL-2.0
  usb_ops.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
 read_in 
 read_in 
 read_in 
 write_out 
 write_out 
 write_out 
 SPDX-License-Identifier: GPL-2.0
  rtl871x_ioctl_rtl.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>
  Larry Finger <Larry.Finger@lwfinger.net>
 WIRELESS_MODE_B 
 WIRELESS_MODE_G 
 WIRELESS_MODE_A 
 QUERY_OID 
 QUERY_OID 
 init workparam 
		 RegOffsetValue	- The offset of RF register to read.
		  RegDataWidth	- The data width of RF register to read.
		  RegDataValue	- The value to read.
		  RegOffsetValue = ((unsigned long )InformationBuffer);
		  RegDataWidth = ((unsigned long )InformationBuffer+1);
		  RegDataValue =  ((unsigned long )InformationBuffer+2);
	 nStatus==0	CheckingStatus
	  nStatus==1	Associated
	  nStatus==2	AdHocMode
	  nStatus==3	NotAssociated
 SPDX-License-Identifier: GPL-2.0
  rtl8712_efuse.c
  Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192SU
  Modifications for inclusion into the Linux staging tree are
  Copyright(c) 2010 Larry Finger. All rights reserved.
  Contact information:
  WLAN FAE <wlanfae@realtek.com>.
  Larry Finger <Larry.Finger@lwfinger.net>
 reserve 3 bytes for HW stop read 
0x1FD;
		 -----------------e-fuse pwr & clk reg ctrl ---------------
		  Enable LDOE25 Macro Block
 for some platform , need some delay time 
 Change Efuse Clock for write action to 40MHZ 
 for some platform , need some delay time 
		 -----------------e-fuse pwr & clk reg ctrl -----------------
		  Disable LDOE25 Macro Block
 Change Efuse Clock for write action to 500K 
  Before write E-Fuse, this function must be called.
 -----------------e-fuse reg ctrl --------------------------------- 
 address 
 read cmd 
 wait for complete 
 -----------------e-fuse reg ctrl -------------------------------- 
 address 
 data 
 write cmd 
 wait for complete 
 -----------------e-fuse reg ctrl --------------------------------- 
 address 
 read cmd 
 data 
 write cmd 
 read one byte to check if E-Fuse is empty 
 0 : write enable 
 read next header 
 retrieve original data 
 fill original data 
 additional check 
 write again 
 write again 
 check if E-Fuse Clock Enable and E-Fuse Clock is 40M 
target_word_cnts + pg header(1 byte)
 current size is also the last addr
hdr
 check if what we read is what we write 
 continue to blind write 
 continue to blind write 
 write header ok OR can't check header(creep) 
 go to next address 
 fail 
 write header fail 
 nothing damaged. 
 call rescue procedure 
 rescue fail 
 fail 
 otherwise, take another risk... 
 -----------------e-fuse one byte read  write ---------------------
 pktdata index 
 data index 
 check if E-Fuse Clock Enable and E-Fuse Clock is 40M 
 pktdata index 
 newdata index 
 data index 
  odd start 
 SPDX-License-Identifier: GPL-2.0+
  VMEbus User access driver
  Author: Martyn Welch <martyn.welch@ge.com>
  Copyright 2008 GE Intelligent Platforms Embedded Systems, Inc.
  Based on work by:
    Tom Armistead and Ajit Prem
      Copyright 2004 Motorola Inc.
 Currently Documentationadmin-guidedevices.rst defines the
  following for VME:
  221 char	VME bus
 		  0 = devbusvmem0		First master image
 		  1 = devbusvmem1		Second master image
 		  2 = devbusvmem2		Third master image
 		  3 = devbusvmem3		Fourth master image
 		  4 = devbusvmes0		First slave image
 		  5 = devbusvmes1		Second slave image
 		  6 = devbusvmes2		Third slave image
 		  7 = devbusvmes3		Fourth slave image
 		  8 = devbusvmectl		Control
 		It is expected that all VME bus drivers will use the
 		same interface.  For interface documentation see
 		http:www.vmelinux.org.
  However the VME driver at http:www.vmelinux.org is rather old and doesn't
  even support the tsi148 chipset (which has 8 master and 8 slave windows).
  We'll run with this for now as far as possible, however it probably makes
  sense to get rid of the old mappings and just do everything dynamically.
  So for now, we'll restrict the driver to providing 4 masters and 4 slaves as
  defined above and try to support at least some of the interface from
  http:www.vmelinux.org as an alternative the driver can be written
  providing a saner interface later.
  The vmelinux.org driver never supported slave images, the devices reserved
  for slaves were repurposed to support all 8 master images on the UniverseII!
  We shall support 4 masters and 4 slaves with this driver.
 VME Major Device Number 
 Number of dev entries 
 Size of one slave image buffer 
  Structure to handle image related parameters.
 Buffer address in kernel space 
 Buffer address in PCI address space 
 Buffer size 
 Mutex for locking image 
 Sysfs device 
 VME resource 
 Number of current mmap's 
 Character device 
 Sysfs class 
 Pointer to user device 
 XXX Do we really want this helper - we can use vme__get ? 
 Ensure we are starting at a valid location 
 Ensure not reading past end of the image 
 Ensure we are starting at a valid location 
 Ensure not reading past end of the image 
  The ioctls provided by the old VME access method (the one at vmelinux.org)
  are most certainly wrong as the effectively push the registers layout
  through to user space. Given that the VME core can handle multiple bridges,
  with different register layouts this is most certainly not the way to go.
  We aren't using the structures defined in the Motorola driver either - these
  are also quite low level, however we should use the definitions that have
  already been defined.
			 XXX	We do not want to push aspace, cycle and width
			 	to userspace as they are
			 XXX	We do not want to push aspace, cycle and width
			 	to userspace as they are
			 XXX	We do not want to push aspace, cycle and width
			 	to userspace as they are
			 XXX	We do not want to push aspace, cycle and width
			 	to userspace as they are
  In this simple access driver, the old behaviour is being preserved as much
  as practical. We will therefore reserve the buffers and request the images
  here so that we don't have to do it later.
 Save pointer to the bridge device 
 Initialise descriptors 
 Assign major and minor numbers for the driver 
 Register the driver as a char device 
 Request slave resources and allocate buffers (128kB wide) 
 XXX Need to properly request attributes 
		 For ca91cx42 bridge there are only two slave windows
		  supporting A16 addressing, so we request A24 supported
		  by all windows.
	
	  Request master resources allocate page sized buffers for small
	  reads and writes
 XXX Need to properly request attributes 
 Create sysfs entries - on udev systems this creates the dev files 
 Add sysfs Entries 
 Ensure counter set correctly to unalloc all master windows 
	
	  Ensure counter set correctly to unalloc all slave windows and buffers
 Remove sysfs Entries 
 Unregister device driver 
 Unregister the major and minor device numbers 
	 Let's start by supporting one bus, we can support more than one
	  in future revisions if that ever becomes necessary.
	
	  Here we just register the maximum number of devices we can and
	  leave vme_user_match() to allow only 1 to go through to probe().
	  This way, if we later want to allow multiple user access devices,
	  we just change the code in vme_user_match().
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose: Provide functions to setup NIC operation mode
  Functions:
       vnt_set_rspinf - Set RSPINF
       vnt_update_ifs - Update slotTime,SIFS,DIFS, and EIFS
       vnt_update_top_rates - Update BasicTopRate
       vnt_add_basic_rate - Add to BasicRateSet
       vnt_ofdm_min_rate - Check if any OFDM rate is in BasicRateSet
       vnt_get_tsf_offset - Calculate TSFOffset
       vnt_get_current_tsf - Read Current NIC TSF counter
       vnt_get_next_tbtt - Calculate Next Beacon TSF counter
       vnt_reset_next_tbtt - Set NIC Beacon time
       vnt_update_next_tbtt - Sync. NIC Beacon time
       vnt_radio_power_off - Turn Off NIC Radio Power
       vnt_radio_power_on - Turn On NIC Radio Power
  Revision History:
       06-10-2003 Bryan YC Fan:  Re-write codes to support VT3253 spec.
       08-26-2003 Kyle Hsu:      Modify the definition type of dwIoBase.
       09-01-2003 Bryan YC Fan:  Add vnt_update_ifs().
 const u16 cw_rxbcntsf_off[MAX_RATE] =
    {17, 34, 96, 192, 34, 23, 17, 11, 8, 5, 4, 3};
 clear NAV 
 Set Channel[7] = 0 to tell HW channel is changing now. 
 RSPINF_b_1 to RSPINF_b_11 
 RSPINF_a_6 to RSPINF_a_72 
  Description: Calculate TSF offset of two TSF input
               Get TSF Offset from RxBCN's TSF and local TSF
  Parameters:
   In:
       rx_rate	- rx rate.
       tsf1	- Rx BCN's TSF
       tsf2	- Local TSF
   Out:
       none
  Return Value: TSF Offset value
  Description: Read NIC TSF counter
               Get local TSF counter
  Parameters:
   In:
 	priv		- The adapter to be read
   Out:
 	current_tsf	- Current TSF counter
  Return Value: true if success; otherwise false
  Description: Clear NIC TSF counter
               Clear local TSF counter
  Parameters:
   In:
       priv	- The adapter to be read
  Return Value: true if success; otherwise false
  Description: Read NIC TSF counter
               Get NEXTTBTT from adjusted TSF and Beacon Interval
  Parameters:
   In:
       tsf		- Current TSF counter
       beacon_interval - Beacon Interval
   Out:
       tsf		- Current TSF counter
  Return Value: TSF value of next Beacon
	 Next TBTT =
	 	((local_current_TSF  beacon_interval) + 1)  beacon_interval
  Description: Turn off Radio power
  Parameters:
   In:
       priv         - The adapter to be turned off
   Out:
       none
  Return Value: true if success; otherwise false
  Description: Turn on Radio power
  Parameters:
   In:
       priv         - The adapter to be turned on
   Out:
       none
  Return Value: true if success; otherwise false
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose:  MAC routines
  Author: Tevin Chen
  Date: May 21, 1996
  Functions:
  Revision History:
 swap over swap[0] and swap[1] to get correct write order 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose: Implement functions for 802.11i Key management
  Author: Jerry Chen
  Date: May 29, 2003
  Functions:
  Revision History:
 default key last entry 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose: Implement functions to access baseband
  Author: Jerry Chen
  Date: Jun. 5, 2002
  Functions:
 	vnt_get_frame_time	- Calculate data frame transmitting time
 	vnt_get_phy_field	- Calculate PhyLength, PhyService and Phy
 				  Signal parameter for baseband Tx
 	vnt_vt3184_init		- VIA VT3184 baseband chip init code
  Revision History:
 0x0f 
 0x1f 
 0x2f 
 0x3f 
 0x0f 
 0x1f 
 0x2f 
 0x3f 
 0x4f 
 0x5f 
 0x6f 
 0x7f 
 0x8f 
 0x9f 
 0xaf 
 0xbf 
 0xcf 
 0xdf 
 0xef 
 0xff 
 {{RobertYu:20060515, new BB setting for VT3226D0 
 0x0f 
 0x1f 
 0x2f 
 0x3f 
 0x4f 
 0x5f 
 0x6f 
 0x7f 
 0x8f 
 0x9f 
 0xaf 
 0xbf 
 0xcf 
 0xdf 
 0xef 
 0xff 
 Max sensitivity 
 Max sensitivity 
 Max sensitivity 
  Description: Set Antenna mode
  Parameters:
   In:
 	priv		- Device Structure
 	antenna_mode	- Antenna Mode
   Out:
       none
  Return Value: none
  Description: Set Antenna mode
  Parameters:
   In:
       pDevice          - Device Structure
       byAntennaMode    - Antenna Mode
   Out:
       none
  Return Value: none
 Fix VT3226 DFC system timing issue 
 Fix for TX USB resets from vendors driver 
  Description: Set ShortSlotTime mode
  Parameters:
   In:
 	priv	- Device Structure
   Out:
       none
  Return Value: none
 patch for 3253B0 Baseband with Cardbus module 
 1101 1111 
 0010 0000 
  Description: vnt_set_deep_sleep
  Parameters:
   In:
 	priv	- Device Structure
   Out:
       none
  Return Value: none
 CR12 
 CR13 
 CR12 
 CR13 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose: Handles 802.11 power management functions
  Author: Lyndon Chen
  Date: July 17, 2002
  Functions:
       vnt_enable_power_saving - Enable Power Saving Mode
       PSvDiasblePowerSaving - Disable Power Saving Mode
       vnt_next_tbtt_wakeup - Decide if we need to wake up at next Beacon
  Revision History:
  Routine Description:
  Enable hw power saving functions
  Return Value:
     None.
 set period of power up before TBTT 
 set AID 
	 Warren:06-18-2004,the sequence must follow
	  PSEN->AUTOSLEEP->GO2DOZE
 enable power saving hw function 
 Set AutoSleep 
	 Warren:MUST turn on this once before turn on AUTOSLEEP ,or the
	  AUTOSLEEP doesn't work
 always listen beacon 
 disable power saving hw function 
 clear AutoSleep 
 set always listen beacon 
  Routine Description:
  Check if Next TBTT must wake up
  Return Value:
     None.
 Turn on wake up to listen next beacon 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose: Handle USB control endpoint
  Author: Warren Hsu
  Date: Mar. 29, 2005
  Functions:
 	vnt_control_out - Write variable length bytes to MEMBBMACEEPROM
 	vnt_control_in - Read variable length bytes from MEMBBMACEEPROM
 	vnt_control_out_u8 - Write one byte to MEMBBMACEEPROM
 	vnt_control_in_u8 - Read one byte from MEMBBMACEEPROM
  Revision History:
       04-05-2004 Jerry Chen: Initial release
       11-24-2004 Warren Hsu: Add ControlvWriteByte,ControlvReadByte,
                              ControlvMaskByte
 ms 
 [31:16]RcvByteCount ( not include 4-byte Status ) 
 Frame Size error drop this packet.
 real Frame Size = USBframe_size -4WbkStatus - 4RxStatus 
 -8TSF - 4RSR - 4SQ3 - ?Padding 
 if SQ3 the range is 24~27, if no SQ3 the range is 20~23 
Fix hardware bug => PLCP_Length error 
 rx_rate  5 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose: handle WMAC802.3802.11 rx & tx functions
  Author: Lyndon Chen
  Date: May 20, 2003
  Functions:
       vnt_generate_tx_parameter - Generate tx dma required parameter.
       vnt_get_rsvtime- get frame reserved time
       vnt_fill_cts_head- fulfill CTS ctl header
  Revision History:
 Long Preamble 
 Short Preamble 
 RATE_1M  
 RATE_2M  
 RATE_5M  
 RATE_11M 
 RATE_6M  
 RATE_9M  
 RATE_12M 
 RATE_18M 
 RATE_24M 
 RATE_36M 
 RATE_48M 
 RATE_54M 
 Get Length, Service, and Signal fields of Phy for Tx 
 Get SignalField,ServiceField,Length 
 Get Duration and TimeStamp 
 Get SignalField,ServiceField,Length 
 Get Duration and TimeStampOff 
 Get SignalField,ServiceField,Length 
 Get CTSDuration_ba 
Get CTS Frame body
 returns true if mic_hdr is needed 
 strip header and icv len from payload 
 Get rrv_time header 
Set fifo controls 
 Get SignalField,ServiceField,Length 
 Get TimeStampOff 
 Get SignalField,ServiceField,Length 
 Get TimeStampOff 
 Get Duration 
 time stamp always 0 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose: rf function code
  Author: Jerry Chen
  Date: Feb. 19, 2004
  Functions:
 	vnt_rf_write_embedded	- Embedded write RF register via MAC
  Revision History:
 	RF_VT3226: RobertYu:20051111, VT3226C0 and before
 	RF_VT3226D0: RobertYu:20051228
 	RF_VT3342A0: RobertYu:20060609
 channel 15 Tf = 4915MHz 
 channel = 15, Tf = 4915MHz 
 channel = 15 Tf = 4915MHz 
 11bg mode 
 channel = 15 Tf = 4915MHz 
 channel = 15 Tf = 4915MHz 
 RF_AL2230, RF_AL2230S init table, channel table 0 and 1 
 RF_AIROHA7230 init table, channel table 0 and 1 
 RF_VT3226 init table, channel table 0 and 1 
 RF_VT3226D0 init table, channel table 0 and 1 
 RF_VT3342A0 init table, channel table 0 and 1 
 RF_AIROHA7230 init table 2 and channel table 2 
  Description: Write to IFRF, by embedded programming
 Set Tx power by power level and rate 
		
		  0x080F1B00 for 3 wire control TxGain(D10)
		  and 0x31 as TX Gain value
 Set Tx power by channel number type 
 set channel number to array number 
 remove 14 channels to array size 
 Convert rssi to dbm 
 Init Table 
 Channel Table 0 
 Channel Table 1 
 Init Table 2 
 Channel Table 2 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose: driver entry for initial, open, close, tx and rx.
  Author: Lyndon Chen
  Date: Dec 8, 2005
  Functions:
    vt6656_probe - module initial (insmod) driver entry
    vnt_free_tx_bufs - free tx buffer function
    vnt_init_registers- initial MAC & BBP & RF internal registers.
  Revision History:
  define module options
 version information 
 BasebandType[] baseband type selected
  0: indicate 802.11a type
  1: indicate 802.11b type
  2: indicate 802.11g type
  Static vars definitions
 Set number of TX buffers 
 Set number of RX buffers 
 branch to loader for download new firmware 
  initialization of MAC & BBP registers
 issue card_init command to device 
 local ID for AES functions 
 do MACbSoftwareReset in MACvInitialize 
 target to IF pin while programming to RF chip 
 load power table 
	
	  original zonetype is USA, but custom zonetype is Europe,
	  then need to recover 12, 13, 14 channels with 11 channel
 same as RFbMA2829SelectChannel 
 load OFDM A power table 
 if not set default is both 
 Set initial antenna mode 
 default Auto Mode 
 get RFType 
 load vt3266 calibration parameters in EEPROM 
				 CR255, enable TXRX IQ and
				  DC compensation mode
 CR251, TX IQ Imbalance Calibration 
 CR252, TX DC-Offset Calibration 
 CR253, RX IQ Imbalance Calibration 
				 CR255, turn off
				  BB Calibration compensation
 get permanent network address 
 if exist SW network address, use it 
 deallocate URBs 
 deallocate skb 
 allocate URBs 
 submit rx urb 
 bInterval is set to 1 
 clear all keys 
 LED blink on TX 
 LED slow blink 
 Set max sensitivity
 CONFIG_PM 
 CONFIG_PM 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose: Handles the management command interface functions
  Author: Lyndon Chen
  Date: May 8, 2003
  Functions:
 	vnt_cmd_complete - Command Complete function
 	vnt_schedule_command - Push Command and wait Command Scheduler to do
 	vnt_cmd_timer_wait- Call back timer
  Revision History:
 Command Queue Empty 
 If fail all ends TODO retry 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose: Channel number mapping
  Author: Lucas Lin
  Date: Dec 24, 2004
  Revision History:
 	01-18-2005	RobertYu:	remove the for loop searching in
 					ChannelValid, change ChannelRuleTab
 					to lookup-type, reorder table items.
 SPDX-License-Identifier: GPL-2.0+
  abstraction of the spi interface of HopeRf rf69 radio module
  Copyright (C) 2016 Wolf-Entwicklungen
 	Marcus Wolf <linux@wolf-entwicklungen.de>
 enable prosa debug info 
 enable print of values on reg access 
 enable print of values on fifo access 
 in Hz 
 in byte 
-------------------------------------------------------------------------
		
		  should never happen, since we already checked,
		  that module is connected. Therefore no error
		  handling, just an optional error message...
		
		  should never happen, since we already checked,
		  that module is connected. Therefore no error
		  handling, just an optional error message...
-------------------------------------------------------------------------
-------------------------------------------------------------------------
	
	  we are using packet mode, so this check is not really needed
	  but waiting for mode ready is necessary when going from sleep
	  because the FIFO may not be immediately available from previous mode
	  while (_mode == RF69_MODE_SLEEP && (READ_REG(REG_IRQFLAGS1) &
		  RF_IRQFLAGS1_MODEREADY) == 0x00);  Wait for ModeReady
 check input value
 8388608 = 2^23;
 calculate reg settings
 transmit to RF 69
 to improve precision of calculation
 TODO: Dependency to bitrate
 calculat f step
  524288 = 2^19
 calculate register settings
 check msb
 write to chip
 to improve precision of calculation
 calculat f step
  524288 = 2^19
 check input value
 calculate reg settings
 write to chip
 check register pa_level
 check high power mode
 check input value
 write value
 check value for mantisse and exponent
 read old value
 "delete" mantisse and exponent = just keep the DCC setting
 add new mantisse
 add new exponent
 write back
 read reg
 delete old value
 add new value
 write back
 	case fifo_not_empty:
 		return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_NOT_EMPTY);
 no value check needed - u8 exactly matches register size 
 no value check needed - u16 exactly matches register size 
 calculate reg settings 
 transmit to chip 
 check input value
 write value
 check input value 
 write value 
	
	  access the fifo to activate new threshold
	  retval (mis-) used as buffer here
-------------------------------------------------------------------------
 prepare a bidirectional transfer 
 SPDX-License-Identifier: GPL-2.0+
  userspace interface for pi433 radio module
  Pi433 is a 433MHz radio module for the Raspberry Pi.
  It is based on the HopeRf Module RFM69CW. Therefore inside of this
  driver, you'll find an abstraction of the rf69 chip.
  If needed, this driver could be extended, to also support other
  devices, basing on HopeRfs rf69.
  The driver can also be extended, to support other modules of
  HopeRf with a similar interace - e. g. RFM69HCW, RFM12, RFM95, ...
  Copyright (C) 2016 Wolf-Entwicklungen
 	Marcus Wolf <linux@wolf-entwicklungen.de>
32	
 min: FIFO_SIZE! 
 65536 = 2^16  
 Protect idr accesses 
 mainly for udev to create devpi433 
  tx config is instance specific
  so with each open a new tx config struct is needed
  rx config is device specific
  so we have just one rx config, ebedded in device struct
 device handling related values 
 irq related values 
 tx related values 
 serialize userspace writers 
 rx related values 
 fifo wait queue 
 flags 
-------------------------------------------------------------------------
 GPIO interrupt handlers 
-------------------------------------------------------------------------
 receiver config 
 packet config 
 enable 
 lengths 
 values 
 packet format enable 
-------------------------------------------------------------------------
 return without action, if no pending read request 
 setup for receiving 
 setup rssi irq 
 setup fifo level interrupt 
 set module to receiving mode 
-------------------------------------------------------------------------
 wait for any tx to finish 
 wait was interrupted 
 prepare status vars 
 setup radio module to listen for something "in the air" 
 now check RSSI, if low wait for getting high (RSSI interrupt) 
 allow tx to interrupt us while waiting for high RSSI 
 wait for RSSI level to become high 
 wait was interrupted 
 cross check for ongoing tx 
 configure payload ready irq 
 fixed or unlimited length? 
 length byte enabled? 
 wait was interrupted 
 address byte enabled? 
 wait was interrupted 
 get payload 
 wait was interrupted 
 need to drop bytes or acquire? 
 access the fifo 
 read failed 
 adjust status vars 
 rx done, wait was interrupted or error occurred 
 wait for fifo to be populated or for request to terminate
		
		  get data from fifo in the following order:
		  - tx_cfg
		  - size of message
		  - message
 use fixed message length, if requested 
 increase size, if len byte is requested 
 increase size, if adr byte is requested 
 prime buffer 
 add length byte, if requested 
			
			  according to spec, length byte itself must be
			  excluded from the length calculation
 add adr byte, if requested 
 finally get message data from fifo 
		
		  if rx is active, we need to interrupt the waiting for
		  incoming telegrams, to be able to send something.
		  We are only allowed, if currently no reception takes
		  place otherwise we need to  wait for the incoming telegram
		  to finish
		
		  prevent race conditions
		  irq will be reenabled after tx config is set
 clear fifo, set fifo threshold, set payload length 
 this clears the fifo 
			
			  rx is currently waiting for a telegram;
			  we need to set the radio module to standby
 configure the rf chip 
 enable fifo level interrupt 
 enable packet sent interrupt 
 was disabled by rx active check 
 enable transmission 
 transfer this msg (and repetitions) to chip fifo 
 msg to big for fifo - take a part 
 msg fits into fifo - take all 
 reset for next repetition 
 we are done. Wait for packet to get sent 
 STOP_TRANSMISSION 
 everything sent? 
-------------------------------------------------------------------------
 check, whether internal buffer is big enough for requested size 
 just one read request at a time 
 start receiving 
 will block until something was received
 release rx 
 if read was successful copy to user space
	
	  check, whether internal buffer (tx thread) is big enough
	  for requested size
	
	  write the following sequence into fifo:
	  - tx_cfg
	  - size of message
	  - message
 start transfer 
 Check type and command number 
 during pendig read request, change of config not allowed 
-------------------------------------------------------------------------
 setup instance data
 TODO: fill instance->tx_cfg;
 instance data as context 
-------------------------------------------------------------------------
 "construct" name and get the gpio descriptor 
GPIOD_IN);
 release already allocated gpios 
 configure the pin 
 configure irq 
 flags 
 check if gpiod is valid 
-------------------------------------------------------------------------
	
	  REVISIT switch to aio primitives, so that userspace
	  gets more complete API coverage.  It'll simplify things
	  too, except for the locking.
-------------------------------------------------------------------------
 setup spi parameters 
	
	  spi->max_speed_hz = 10000000;
	  1MHz already set by device tree overlay
 Ping the chip by reading the version register 
 Allocate driver data 
 Initialize the driver data 
 init rx buffer 
 init wait queues 
 init fifo 
 init mutexes and locks 
 setup GPIO (including irq_handler) for the different DIOs 
 setup the radio module 
 determ minor number 
 create device 
 start tx thread 
 create cdev 
 spi setup 
 free GPIOs 
 make sure ops on existing fds can abort cleanly 
	
	  NOTE:  suspendresume methods are not necessary here.
	  We don't do anything except pass the requests tofrom
	  the underlying controller.  The refrigerator handles
	  most issues; the controller driver handles the rest.
-------------------------------------------------------------------------
	
	  If MAX_MSG_SIZE is smaller then FIFO_SIZE, the driver won't
	  work stable - risk of buffer overflow
	
	  Claim device numbers.  Then register a class
	  that will key udevmdev to addremove dev nodes.  Last, register
	  Last, register the driver which manages those device numbers.
 SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
  Copyright (c) 2003-2012 Broadcom Corporation
  All Rights Reserved
  fmn.h - For FMN credit configuration and registering fmn_handler.
  FMN is communication mechanism that allows processing agents within
  XLRXLS to communicate each other.
  The readlwritel implementation byteswaps on XLRXLS, so
  we need to use __raw_ IO to read the NAE registers
  because they are in the big-endian MMIO area on the SoC.
 skb->data is cache aligned 
 16 byte IP header align 
 Fill rx ring 
  Ethtool operation
  Net operations
 schedule a link state check 
 Setup the speed from PHY to internal reg
 FB to 6th bucket 
 End of packet descriptor 
 No Free back 
 Length of data 
 Free back id 
 Set len to 0 
 32bit address 
 set mac station address 
  Gmac init
  Configure the 6 FIFO's that are used by the network accelarator to
  communicate with the rest of the XLx device. 4 of the FIFO's are for
  packets from NA --> cpu (called Class FIFO's) and 2 are for feeding
  the NA with free descriptors.
  Configure PDE to Round-Robin distribution of packets to the
  available cpu
 Each core has 8 buckets(station) 
  Setup the Message ring credits, bucket size and other
  common configuration
 Setting non-core MsgBktSize(0x321 - 0x325) 
	
	  Setting non-core Credit counter register
	  Distributing Gmac's credit to CPU's
 one bucket is assumed for each cpu 
 for each cpu, mark the 4+threadid bucket 
configure the 128  9 Translation table to send to available buckets
		
		  On use_bkt set the b0, b1 are used, else
		  the 4 classes are used, here implemented
		  a logic to distribute the packets to the
		  buckets equally or based on the class
 Mark it as ETHERNET type 
 Use 7bit CRChash for flow classification with 127 as CRC polynomial
 configure the parser : L2 Type is configured in the bootloader 
 extract IP: src, dest protocol 
 Configure to extract SRC port and Dest port for TCP and UDP pkts 
 100ms timeout
 Write the data which starts the write cycle 
 poll for the read cycle to complete 
 100ms timeout
 setup the phy reg to be used 
 Issue the read command 
 poll for the read cycle to complete 
 clear the read cycle 
 Read the data 
  XLR ports are RGMII. XLS ports are SGMII mostly except the port0,
  which can be configured either SGMII or RGMII, considered SGMII
  by default, if board setup to RGMII the port_type need to set
  accordingly.Serdes and PCS layer need to configured for SGMII
 program  GPIO values for serdes init parameters 
 enable autoneg - more magic 
 Set interface to Byte mode 
 Set interface to Nibble mode 
 Set SGMII speed in Interface control reg 
 Attach MAC to PHY 
 Scan only the enabled address 
 setting clock divisor to 54 
 Setup MAC_CONFIG reg if (xls & rgmii) 
 Rx Tx enable 
 Setup tx control reg 
 Setup rx control reg 
 Setup MAC_CONFIG reg 
 Rx Tx disable
 Setup tx control reg 
 Setup rx control reg 
  Initialization of gmac
 Enable Full-duplex1000MbpsCRC 
 speed 2.5Mhz 
 Setup Interrupt mask reg 
 Clear all stats 
	
	  Allocate our adapter data structure and attach it to the device.
	
	  XLR and XLS have 1 and 2 NAE controller respectively
	  Each controller has 4 gmac ports, mapping each controller
	  under one parent device, 4 gmac ports under one device.
 Setup Mac address and Rx mode 
 Configure PDE to Round-Robin pkt distribution 
 Call init with respect to port 
 SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
  Copyright (c) 2003-2012 Broadcom Corporation
  All Rights Reserved
 Linux Net 
 Passing GPIO base for serdes init. Only needed on sgmii ports 
 first block RGMII or XAUI, use RGMII 
 second block is XAUI, not supported yet 
 default XLS config, all ports SGMII 
 assume all GMACs for now 
 SPDX-License-Identifier: GPL-2.0+
   GDMA4740 DMAC support
 for RT305X gdma registers 
 for MT7621 gdma registers 
 wait dma transfer complete 
 restore to init value 
 verify chan is already stopped 
		
		  TODO: memcpy function have bugs. sometime it will copy
		  more 8 bytes data when using dmatest verify.
 make sure next_sg is update 
 verify chan is already stopped 
 make sure next_sg is update 
 clean done bits 
 start only have work to do 
		
		  We never update edesc->residue in the cyclic case, so we
		  can tell the remaining room to the end of the circular
		  buffer.
 record last chan to round robin all chans 
		
		  on mt7621. when verify with dmatest with all
		  channel is enable. we need to limit only two
		  channel is working at the same time. otherwise the
		  data will have problem.
 all chans round robin 
 all chans round robin 
 init hardware 
 SPDX-License-Identifier: GPL-2.0
  Xilinx 'Clocking Wizard' driver
   Copyright (C) 2013 - 2014 Xilinx
   Sören Brinkmann <soren.brinkmann@xilinx.com>
 Get the mask from width 
 Extract divider instance from clock hardware instance 
  struct clk_wzrd - Clock wizard private data structure
  @clk_data:		Clock data
  @nb:			Notifier block
  @base:		Memory base
  @clk_in1:		Handle to input clock 'clk_in1'
  @axi_clk:		Handle to input clock 's_axi_aclk'
  @clks_internal:	Internal clocks
  @clkout:		Output clocks
  @speed_grade:	Speed grade of the device
  @suspended:		Flag indicating power state of the device
  struct clk_wzrd_divider - clock divider specific to clk_wzrd
  @hw:		handle between common and hardware-specific interfaces
  @base:	base address of register containing the divider
  @offset:	offset address of register containing the divider
  @shift:	shift to the divider bit field
  @width:	width of the divider bit field
  @flags:	clk_wzrd divider flags
  @table:	array of valuedivider pairs, last entry should have div = 0
  @lock:	register lock
 divider lock 
 maximum frequencies for inputoutput clocks per speed grade 
 spin lock variable for clk_wzrd 
 Cap the value to max 
 Set divisor and clear phase offset 
 Check status register 
 Initiate reconfiguration 
 Check status register 
	
	  since we don't change parent rate we just round rate to closest
	  achievable
 Set divisor and clear phase offset 
 Check status register 
 Initiate reconfiguration 
 Check status register 
 should never happen 
 register div 
 register div per output 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  0x2C[23:18] = 0x2C[17:12] = CrystalCap 
 4 Support ability 
 4 No link or more than one entry 
 3 1. CFO Tracking 
 4 1.1 No new packet 
 4 1.2 Calculate CFO 
 4 1.3 Avoid abnormal large CFO 
 4 1.4 Dynamic Xtal threshold 
 4 1.5 BT case: Disable CFO tracking 
 4 1.6 Big jump 
 4 1.7 Adjust Crystal Cap. 
 3 2. Dynamic ATC switch 
		
		  3 Update CFO report for path-A & path-B
		  Only paht-A and path-B have CFO tail and short CFO
 3 Update packet counter 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
  Global variables, these are static variables 
  local function proto type if needed 
  local function start with halbtc8723b1ant_ 
  normal mode 
  normal mode 
  retry limit =8 
  normal mode 
  AMPDU timw = 0x38  32us 
  normal mode 
  disable cck 12 
  disable cck 125.5, ofdm 69121824, mcs 01234 
	Rx Aggregation related setting 
  decide BT control aggregation buf size or not 
  aggregation buf size, only work when BT control Rx aggregation size. 
  real update aggregation setting 
  trigger 
 to avoid 0x76e[3] = 1 (WLAN_Act control by PTA) during IPS 
 if (! (pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x76e) & 0x8)) 
  reset counter 
 reset counter 
  work around for HS mode. 
  check if Sco only 
  check if A2dp only 
  check if Pan only 
  check if Hid only 
  opCode, 0x6 = Retry_Penalty 
 normal rate except MCS765, OFDM544836 
 MCS7 or OFDM54 
 MCS6 or OFDM48 
 MCS5 or OFDM36 
 function enable 
  [31:16]=fw ver, [15:0]=fw sub ver 
 WiFi TRx Mask on 
 BT TRx Mask on 
 Use H2C to set GNT_BT to HIGH 
  set grant_bt to high 
 set wlan_act control by PTA 
 BT select s0s1 is controlled by WiFi 
 Use H2C to set GNT_BT to HIGH 
  set grant_bt to high 
 set wlan_act to always low 
 BT select s0s1 is controlled by BT 
 BT select s0s1 is controlled by WiFi 
  0x4c[24:23]= 00, Set Antenna control by BT_RFE_CTRL	BT Vendor 0xac = 0xf002 
 Use H2C to set GNT_BT to LOW 
  BT calibration check 
  set grant_bt to PTA 
 set wlan_act control by PTA 
  0x4c[23]= 0, 0x4c[24]= 1  Antenna control by WLBT 
  fixed internal switch S1->WiFi, S0->BT 
 tell firmware "no antenna inverse" 
 ext switch type 
 tell firmware "antenna inverse" 
 ext switch type 
  ext switch setting 
  0x4c[23]= 1, 0x4c[24]= 0  Antenna control by 0x64 
 Fix Ext switch Main->S1, Aux->S0 
 tell firmware "no antenna inverse" 
 internal switch type 
 tell firmware "antenna inverse" 
 internal switch type 
  internal switch setting 
 u32 fwVer = 0; 
 only for A2DP-only case 12911 
 no null-pkt 
  no tx-pause at BT-slot 
  0x778 = d1 toggle 
 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) 
  SoftAP only with no sta associated, BT disable , TDMA mode for power saving 
 here softap mode screen off will cost 70-80mA for phone 
  disable PS tdma 
 PTA Control 
 Software control, Antenna at BT side 
 Software control, Antenna at WiFi side 
  update pre state 
 halbtc8723b1ant_SwMechanism(pBtCoexist, false); 
 halbtc8723b1ant_SwMechanism(pBtCoexist, false); 
 halbtc8723b1ant_SwMechanism(pBtCoexist, false); 
 halbtc8723b1ant_SwMechanism(pBtCoexist, false); 
 halbtc8723b1ant_SwMechanism(pBtCoexist, false); 
 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration 
 acquire the BT TRx retry count from BT_Info byte2 
  no retry in the last 2-second duration 
  if 連續 n 個2秒 retry count為0, 則調寬WiFi duration 
  <=3 retry in the last 2-second duration 
  if 連續 2 個2秒 retry count< 3, 則調窄WiFi duration 
  避免一直在兩個level中來回 
 m 最大值 = 20 ' 最大120秒 recheck是否調整 WiFi duration. 
 retry count > 3, 只要1次 retry count > 3, 則調窄WiFi duration 
  避免一直在兩個level中來回 
 m 最大值 = 20 ' 最大120秒 recheck是否調整 WiFi duration. 
  recover to previous adjust type 
  already under LPS state 
  keep state under LPS, do nothing. 
  will leave LPS state, turn off psTdma first 
  NO PS state 
  will enter LPS state, turn off psTdma first 
  keep state under NO PS state, do nothing. 
  recover to original 32k low power setting 
  when coex force to enter LPS, do not enter 32k low power. 
  power save must executed before psTdma. 
	Software Coex Mechanism start 
	Non-Software Coex Mechanism start 
  SCOHIDA2DP busy 
  tdma and coex table 
 HID 
 HID 
 A2DP 
 HID+A2DP 
 PAN(OPP, FTP), HID+PAN(OPP, FTP) 
 A2DP+PAN(OPP, FTP), HID+A2DP+PAN(OPP, FTP) 
 BT no-profile busy (0x9) 
  power save state 
  tdma and coex table 
  tdma and coex table 
 Bryant Add 
  tdma and coex table 
  tdma and coex table 
 Bryant Add 
  tdma and coex table 
  power save state 
 A2DP 
 busy 
 no force LPS, no PS-TDMA, use pure TDMA 
  tdma and coex table 
 halbtc8723b1ant_ActionSco(pBtCoexist); 
 halbtc8723b1ant_ActionHid(pBtCoexist); 
 halbtc8723b1ant_ActionA2dp(pBtCoexist); 
 halbtc8723b1ant_ActionA2dpPanHs(pBtCoexist); 
 halbtc8723b1ant_ActionPanEdr(pBtCoexist); 
 halbtc8723b1ant_ActionPanHs(pBtCoexist); 
 halbtc8723b1ant_ActionPanEdrA2dp(pBtCoexist); 
 halbtc8723b1ant_ActionPanEdrHid(pBtCoexist); 
 halbtc8723b1ant_ActionHidA2dpPanEdr(pBtCoexist); 
 halbtc8723b1ant_ActionHidA2dp(pBtCoexist); 
 just print debug message 
 just print debug message 
  wifi LPSBusy 
  force to reset coex mechanism 
  sw all off 
 halbtc8723b1ant_PsTdma(pBtCoexist, FORCE_EXEC, false, 8); 
 enable TBTT nterrupt 
  0x790[5:0]= 0x5 
  Enable counter statistics 
 Antenna config 
  PTA parameter 
  work around function start with wa_halbtc8723b1ant_ 
  extern function start with EXhalbtc8723b1ant_ 
  enable BB, REG_SYS_FUNC_EN such that we can write 0x948 correctly. 
  set GRAN_BT = 1 
  set WLAN_ACT = 0 
  S0 or S1 setting and Local register setting(By the setting fw can get ant number, S0S1, ... info) 
  Local setting bit define 
	BIT0: "0" for no antenna inverse; "1" for antenna inverse 
	BIT1: "0" for internal switch; "1" for external switch 
	BIT2: "0" for one antenna; "1" for two antenna 
  NOTE: here default all internal switch and 1-antenna ==> BIT1 = 0 and BIT2 = 0 
  fixed at S0 for USB interface 
  antenna inverse 
  for PCIE and SDIO interface, we check efuse 0xc3[6] 
  set to S1 
  set to S0 
  antenna inverse 
 Force antenna setup for no scan result issue 
  non-connected scan 
  wifi is connected 
  non-connected scan 
 pCoexDm->nArpCnt = 0; 
  non-connected scan 
 Set CCK TxRx high Pri except 11b mode 
 CCK Tx 
 CCK Rx 
 CCK Tx 
 CCK Rx 
 CCK Tx 
 CCK Rx 
  only 2.4G we need to inform bt the chnl mask 
 H2C_Parameter[0] = 0x1; 
  if APR PKT > 10 after connect, do not go to ActionWifiConnectedSpecialPacket(pBtCoexist) 
 pCoexSta->btInfoC2h[rspSource][3]2+10; 
 BT into is responded by BT FW and BT RF REG 0x3C != 0x15 => Need to switch BT TRx Mask 
  Here we need to resend some wifi info to BT 
  because bt is reset and loss of the info. 
  BT already NOT ignore Wlan active, do nothing here. 
  check BIT2 first ==> check if bt is under inquiry or page scan 
  set link exist status 
  connection exists 
 mask profile bit for connect-ilde identification (for CSR case: A2DP idle --> 0x41) 
  connection exists but no busy 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2013 Realtek Corporation. All rights reserved.
  8051 enable 
  8051 reset 
  MCU firmware download disable. 
  (Default) Phase #1 : PCI muse use 4-byte write to download FW 
  Phase #2 : Use 8-byte, if Phase#1 use big size to write FW. 
  Phase #3 : Use 1-byte, the remnant of FW image. 
 	printk("====>%s %d\n", __func__, __LINE__); 
 3 Phase #1 
 3 Phase #2 
 3 Phase #3 
  Since we need dynamic decide method of dwonload fw, so we call this function to get chip version. 
  We can remove _ReadChipVersion from ReadpadapterInfo8192C later. 
  Reset 8051(WLMCU) IO wrapper 
  0x1c[8] = 0 
  Suggested by Isaac@SD1 and Gimmy@SD1, coding by Lucas@20130624 
  Enable 8051 IO wrapper 
  0x1c[8] = 1 
 polling CheckSum report 
  polling for FW ready 
  after 88C Fw v33.1 
 0x1cf = 0x20. Inform 8051 to reset. 2009.12.25. tynli_test 
 force firmware reset 
 	Description: 
 		Download 8192C firmware code. 
 1. write 0xA3[:2:0] = 3b'010 
 2. read power_state = 0xA0[1:0] 
  To Check Fw header. Added by tynli. 2009.12.04. 
  Shift 32 bytes for FW header 
  Suggested by Filen. If 8051 is running in RAM code, driver should inform Fw to reset by itself, 
  or it will cause download Fw fail. 2010.02.01. by tynli. 
 8051 RAM code 
 reset FWDL chksum 
  Init Fw LPS related. 
 Init H2C cmd. 
  Init H2C counter. by tynli. 2009.12.09. 
 pHalData->H2CQueueHead = 0; 
 pHalData->H2CQueueTail = 0; 
 pHalData->H2CStopInsertQueue = false; 
 				Efuse related code 
 	The following is for compile ok 
 	That should be merged with the original in the future 
  For RTL8723 only. 
  Efuse access protection for RTL8723 
  enable BT power cut 
  0x6A[14] = 1 
  Attention!! Between 0x6A[14] and 0x6A[15] setting need 100us delay 
  So don't write 0x6A[14]= 1 and 0x6A[15]= 0 together! 
  disable BT output isolation 
  0x6A[15] = 0 
  enable BT output isolation 
  0x6A[15] = 1 
  Attention!! Between 0x6A[14] and 0x6A[15] setting need 100us delay 
  So don't write 0x6A[14]= 1 and 0x6A[15]= 0 together! 
  disable BT power cut 
  0x6A[14] = 1 
  To avoid cannot access efuse regsiters after disableenable several times during DTM test. 
  Suggested by SD1 IsaacHsu. 2013.07.08, added by tynli. 
  SDIO local register is suspend 
  check 0x86[1:0]= 10'2h, wait power state to leave suspend 
  Reset: 0x0000h[28], default valid 
  Clock: Gated(0x0008h[5]) 8M(0x0008h[1]) clock from ANA, default valid 
  Enable LDO 2.5V before readwrite action 
 rtw_write8(padapter, REG_EFUSE_ACCESS, EFUSE_ACCESS_ON); 
  Disable LDO 2.5V after readwrite action 
  Do NOT excess total size of EFuse table. Added by Roger, 2008.11.10. 
  0xff will be efuse default value instead of 0x00. 
  switch bank back to bank 0 for later BT and wifi use. 
  Check PG header for section num. 
 extended header 
  Get word enable value from PG header 
  Check word enable condition in the section 
  Copy from Efuse map to output pointer memory!!! 
  Calculate Efuse utilization 
  Do NOT excess total size of EFuse table. Added by Roger, 2008.11.10. 
  0xff will be efuse default value instead of 0x00. 
  8723b Max bake 0~2 
  Check PG header for section num. 
 extended header 
  Check word enable condition in the section 
  switch bank back to bank 0 for later BT and wifi use. 
  Copy from Efuse map to output pointer memory!!! 
  Calculate Efuse utilization. 
  for debug 
  for debug 
  switch bank back to bank 0 for later BT and wifi use. 
  try again! 
  try again form address 0 
  report max size to prevent write efuse 
 bank = EFUSE_MAX_BANK; 
  only when bank is switched we have to reset the efuse_addr. 
 bank = EFUSE_MAX_BANK; 
 				hoffset = ((hoffset & 0xE0) >> 5) | ((efuse_data & 0xF0) >> 1); 
 read next header 
 extended header 
 read next header 
  Check if we need to check next bank efuse 
  don't need to check next bank. 
  <Roger_TODO> Efuse has been pre-programmed dummy 5Bytes at the end of Efuse by CP. 
  Skip dummy parts to prevent unexpected data read from Efuse. 
  By pass right now. 2009.02.19. 
  Check word enable condition in the section 
  if same header is found but no data followed 
  write some part of data followed by the header. 
  Here to write partial data 
  if write fail on some words, write these bad words again 
  write fail, return 
  partial write ok, update the target packet for later use 
  this word has been written 
  disable the word 
  read from next header 
  not used header, 0xff 
  to write ext_header 
 offset PG fail 
 YJ, TODO, move read chip type here 
  IC version (CUT) 
  For regulator mode. by tynli. 2011.01.14 
  ROM code version. 
  For multi-function consideration. Added by Roger, 2010.10.06. 
  port0 and port1 
  Enable prot0 beacon function for PSTDMA 
  TODO: Remove these magic number 
  ms 
  Firmware will control REG_DRVERLYINT when power saving is enable, 
  so don't set this register on STA mode. 
  5ms 
  2ms 
  Suggested by designer timchen. Change beacon AIFS to the largest number 
  beacause test chip does not contension before sending beacon. by tynli. 2009.11.03 
 enable single pkt ampdu 
 for VHT packet length 11K 
  ARFB table 9 for 11ac 5G 2SS 
  ARFB table 10 for 11ac 5G 1SS 
  2010.06.23. Added by tynli. 
 reset TSF, enable update TSF, correcting TSF On Beacon 
 REG_BCN_INTERVAL 
 REG_BCNDMATIM 
 REG_ATIMWND 
 REG_TBTT_PROHIBIT 
 REG_DRVERLYINT 
 REG_BCN_MAX_ERR 
 REG_BCNTCFG (0x510) 
 REG_DUAL_TSF_RST 
 REG_BCN_CTRL (0x550) 
  ATIM window 
  Beacon interval (in unit of TU). 
  Reset TSF Timer to zero, added by Roger. 2008.06.24 
  NOTE: Fix test chip's bug (about contention windows's randomness) 
 CAM_SIZE 
 set correct initial date rate for each mac_id 
  Efuse related function 
  Let 8051 take control antenna setting 
  DPDT_SEL_EN, 0x4C[23] 
  init default value 
  init dm default value 
 for IQK 
 	pdmpriv->binitialized = false; 
 	pdmpriv->prv_traffic_idx = 3; 
 	pdmpriv->initialize = 0; 
  init Efuse variables 
  6: EEPROM used is 93C46, 4: boot from E-Fuse. 
  LLT RWInit function 
  autoload OK. 
  Read EFUSE real map to shadow. 
 autoload fail 
 	struct hal_com_data	pHalData = GET_HAL_DATA(padapter); 
  Checl 0x8129 again for making sure autoload status!! 
 2.4G default value 
 YJ, move, 120316 
 2 2.4G default value 
 4bit sign number to 8 bit sign number 
 4bit sign number to 8 bit sign number 
 4bit sign number to 8 bit sign number 
 4bit sign number to 8 bit sign number 
 4bit sign number to 8 bit sign number 
 4bit sign number to 8 bit sign number 
  20101019 MH Add Regulator recognize for CU. 
 bit0~2 
 bit0~2 
  EFUSE_0xC3[6] == 0, S1(Main)-RF_PATH_A; 
  EFUSE_0xC3[6] == 1, S0(Aux)-RF_PATH_B 
 memcpy(pEEPROM->adjuseVoltageVal, &hwinfo[EEPROM_Voltage_ADDR_8723B], 1); 
 what value should 8812 set? 
  ThermalMeter from EEPROM 
  BB_RF Gain Offset from EEPROM 
 if (pTcb->bBTTxPacket) 
 	BWSettingOfDesc = 0; 
  Clear first 
  checksume is always calculated by first 32 bytes, 
  and it doesn't depend on TX DESC length. 
  Thomas, Lucas@SD4, 20130515 
  SEC_TYPE 
  ENABLE HW RTS 
  RTS Rate =24M 
  Set RTS BW 
  CAM_ID(MAC_ID) 
  Non EAP & ARP & DHCP type data packet 
  AGG EN 
  AGG BK 
  modify data rate by iwpriv 
  EAP data packet and ARP packet. 
  Use the 1M data rate to send the EAPARP packet. 
  This will maybe make the handshake smooth. 
  AGG BK 
  driver uses rate 
  DATA_SHORT 
  CAM_ID(MAC_ID) 
  Rate ID 
  driver uses rate, 1M 
  retry limit enable 
  CCX-TXRPT ack for xmit mgmt frames. 
  CAM_ID(MAC_ID) 
  Rate ID 
  driver uses rate 
	 2009.11.05. tynli_test. Suggested by SD4 Filen for FW LPS.
	  (1) The sequence number of each non-Qos frame  broadcast 
	  multicast  mgnt frame should be controlled by Hw because Fw
	  will also send null data which we cannot control when Fw LPS
	  enable.
	  --> default enable non-Qos data sequense number. 2010.06.23.
	  by tynli.
	  (2) Enable HW SEQ control for beacon packet, because we use
	  Hw beacon.
	  (3) Use HW Qos SEQ to control the seq num of Ext port non-Qos
	  packets.
	  2010.06.23. Added by tynli.
  Hw set sequence number 
  HWSEQ_EN 
 Description:
  Parameters:
 	pxmitframe	xmitframe
 	pbuf		where to fill tx desc
  Description: In normal chip, we should send some packet to Hw which will be used by Fw 
 			in FW LPS mode. The function is to fill the Tx descriptor of this packets, then 
 			Fw can tell Hw to send these packet derectly. 
  Added by tynli. 2009.10.15. 
 type1:pspoll, type2:null 
  Clear all status 
 bFirstSeg; 
 bLastSeg; 
  Offset = 32 
  Buffer size + command header 
  Fixed queue of Mgnt queue 
  Set NAVUSEHDR to prevent Ps-poll AId filed to be changed to error vlaue by Hw. 
  Hw set sequence number 
  use data rate which is set by Sw 
  Encrypt the data frame if under security mode excepct null data. Suggested by CCW. 
  USB interface drop packet if the checksum of descriptor isn't correct. 
  Using this checksum can let hardware recovery from packet bulk out error (e.g. Cancel URC, Bulk out error.). 
  disable Port0 TSF update 
  set net_type 
  disable atim wnd 
 rtw_write8(padapter, REG_BCN_CTRL, 0x18); 
 Set RCR 
 CBSSID_DATA must set to 0, reject ICV_ERR packet 
 enable to rx data frame 
 enable to rx ps-poll 
 Beacon Control related register for first time 
  2ms 
 rtw_write8(padapter, REG_BCN_MAX_ERR, 0xFF); 
  10ms 
  +32767 (~32ms) 
 reset TSF 
 enable BCN0 Function for if1 
 don't enable update TSF0 for if1 (due to TSF update when beaconprobe rsp are received) 
 SW_BCN_SEL - Port0 
 rtw_write8(Adapter, REG_DWBCN1_CTRL_8192E+2, rtw_read8(Adapter, REG_DWBCN1_CTRL_8192E+2) & ~BIT4); 
  select BCN on port 0 
  dis BCN1 ATIM  WND if if2 is station 
  Always enable port0 beacon function for PSTDMA 
 us 
  disable related TSF function 
  enable related TSF function 
  Set RCR to not to receive data frame when NO LINK state 
 rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR) & ~RCR_ADF); 
  reject all data frames 
  reset TSF 
  disable update TSF 
  config RCR to receive different BSSID & not to receive data frame 
  under sitesurvey 
  disable update TSF 
  Save original RRSR setting. 
  sitesurvey done 
  enable to rx data frame 
  enable update TSF 
  Restore original RRSR setting. 
  prepare to join 
 enable to rx data frame.Accept all data frame 
 rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF); 
  RCR_ADF 
  Ad-hoc Mode 
 joinbss_event call back when join res < 0 
 sta add event call back 
 enable update TSF 
	else if (seq_no != padapter->xmitpriv.seq_no) {
		rtw_ack_tx_done(&padapter->xmitpriv, RTW_SCTX_DONE_CCX_PKT_FAIL);
	}
 			CCX_FwC2HTxRpt(padapter, QueueID, pC2hEvent->payload); 
 			C2HExtRaRptHandler(padapter, pC2hEvent->payload, C2hEvent.CmdLen); 
  Clear event to notify FW we have read the command. 
  Note: 
 	If this field isn't clear, the FW won't update the next command message. 
 	rtw_write8(padapter, REG_C2HEVT_CLEAR, C2H_EVT_HOST_CLOSE); 
 			CCX_FwC2HTxRpt(padapter, QueueID, tmpBuf); 
 			C2HExtRaRptHandler(padapter, tmpBuf, C2hEvent.CmdLen); 
 c2h_handler_8723b(padapter,&C2hEvent); 
 apply force and allow mask 
 IOT consideration 
 if peer is cisco and didn't use ofdm rate, we enable 6M ack 
  Set RRSR rate table. 
  prepare to join 
  joinbss_event callback when join res < 0 
  sta add event callback 
 				rtw_btcoex_MediaStatusNotify(padapter, RT_MEDIA_CONNECT); 
 SIFS_Timer = 0x0a0a0808; 
 RESP_SIFS for CCK 
  SIFS_T2T_CCK (0x08) 
 SIFS_R2T_CCK(0x08) 
 RESP_SIFS for OFDM 
 SIFS_T2T_OFDM (0x0a) 
 SIFS_R2T_OFDM(0x0a) 
  Joseph marked out for Netgear 3500 TKIP channel 7 issue.(Temporarily) 
 regTmp = (pHalData->nCur40MhzPrimeSC)<<5; 
  filled id in CAM config 2 byte 
 ulContent |= CAM_VALID; 
  polling bit, and No Write enable, and address 
  write content 0 is equall to mark invalid 
 mdelay(40); 
 mdelay(40); 
  BE 
  VI 
  VO 
  Forece leave RF low power mode for 1T1R to prevent conficting setting in Fw power 
  saving sequence. 2010.06.07. Added by tynli. Suggested by SD3 yschang. 
 if (psmode != PS_MODE_ACTIVE)	{ 
 	rtl8723b_set_lowpwr_lps_cmd(padapter, true); 
  else { 
 	rtl8723b_set_lowpwr_lps_cmd(padapter, false); 
 restore rx gain 
  pause tx 
  keep sn 
 RX DMA stop 
  RQPN Load 0 
  BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2, write 1 to clear, Clear by sw 
  SW_BCN_SEL - Port0 
  Input is MACID 
  macid is between 0~31 
  Input is MACID 
  macid is between 0~31 
  BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2 
  When we halt NIC, we should check if FW LPS is leave. 
  If it is in HWSW Radio OFF or IPS state, we do not check Fw LPS Leave, 
  because Fw is unload. 
 Description:
 	Change default setting of specified variable.
 Description:
 	Query setting of specified variable.
  Stanley@BB.SD3 suggests 16K can get stable performance 
  The experiment was done on SDIO interface 
  coding by Lucas@20130730 
 info 1
 info 1
 info 2
 rate mask 1
 rate mask 2
  support macid sleep 
  stop xmit_buf_thread 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  _GLNA 
  _GPA 
  _ALNA 
  _APA 
  _BT 
  Value Defined Check =============== 
 QFN Type [15:12] and Cut Version [27:24] need to do value check 
  Bit Defined Check ================ 
  We don't care [31:28] and [23:20] 
  BoardType is DONTCARE 
 GLNA 
 GPA 
 ALNA 
 APA 
  BoardType of each RF path is matched 
                           MAC_REG.TXT
  This (offset, data) pair doesn't care the condition. 
  This line is the beginning of branch. 
  ELSE, ENDIF 
  Condition isn't matched. Discard the following (offset, data) pairs. 
  prevent from for-loop += 2 
  Configure matched pairs and skip to end of if-else. 
  Keeps reading until ENDIF. 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
UNKNOWN, REALTEK_90, ALTEK_92SE	BROADCOM, LINK	ATHEROS,
 CISCO, MERU, MARVELL, 92U_AP, SELF_AP
UNKNOWN, REALTEK_90, REALTEK_92SE, BROADCOM, RALINK, ATHEROS,
 CISCO, MERU, MARVELL, 92U_AP, SELF_AP(DownLinkTx)
UNKNOWN, REALTEK_90, REALTEK_92SE, BROADCOM, RALINK, ATHEROS,
 CISCO, MERU, MARVELL, 92U_AP, SELF_AP(UpLinkRx)
  ODM_InitEdcaTurbo 
	  In HW integration first stage, we provide 4 different handles to
	   operate at the same time. In stage23, we need to prove universal
	   interface and merge all HW dynamic mechanism.
  odm_CheckEdcaTurbo 
 invalid value 
  Check if the status needs to be changed. 
 traffic, TX or RX 
  Uplink TP is present. 
  Balance TP is present. 
  Downlink TP is present. 
  Balance TP is present. 
 92D txop can't be set to 0x3e for cisco1250 
  Set DL EDCA for Atheros peer to 0x3ea42b. 
  Turn Off EDCA turbo here. 
  Restore original EDCA according to the declaration of AP. 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
 yield(); 
 if (n > 1) 
 	++priv->pshare->nr_out_of_txoqt_space; 
  translate fifo addr to queue index 
  check if hardware tx fifo page is enough 
  Total number of page is NOT available, so update current FIFO status 
 rtw_free_xmitframe(pxmitpriv, pframe); 
 pxmitbuf->priv_data = NULL; 
  Description
 Transmit xmitbuf to hardware tx fifo
  Return
 _SUCCESS	ok
 _FAIL		something error
 	dump secondary adapter xmitbuf 
  Description:
 Aggregation packets and send to hardware
  Return:
 0	Success
 -1	Hardware resource(TX FIFO) not ready
 -2	Software resource(xmitbuf) not ready
  0(VO), 1(VI), 2(BE), 3(BK) 
 because stop_sta_xmit may delete sta_plist at any time 
 so we should add lock here, or while loop can not exit 
  check xmit_buf size enough or not 
 pxmitbuf->priv_data will be NULL, and will crash here 
 can not yield under lock 
 yield(); 
  ok to send, remove frame from queue 
  coalesce the xmitframe to xmitbuf 
  Todo: error handler 
 if (k != 1) 
 	((struct xmit_frame)pxmitbuf->priv_data)->pg_num += pxmitframe->pg_num; 
  round to 8 bytes alignment 
  dump xmit_buf to hw tx fifo 
  Description
 Transmit xmitframe from queue
  Return
 _SUCCESS	ok
 _FAIL		something error
  dequeue frame and write to hardware 
 here sleep 1ms will cause big TP loss of TX 
 from 50+ to 40+ 
  128 is tx page size 
 dump beacon directly 
  Description:
 Handle xmitframe(packet) come from rtw_xmit()
  Return:
 true	dump packet directly ok
 false	enqueue, temporary can't transmit packets to hardware
  Return
 _SUCCESS	start thread ok
 _FAIL		start thread fail
  Insert tmplist to end of queue, and delete phead 
  then tmplist become head of queue. 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  Module:	rtl8192c_rf6052.c	(Source C File)
  Note:	Provide RF 6052 series relative API.
  Function:
  Export:
  Abbrev:
  History:
  Data			Who		Remark
  09252008	MHC		Create initial version.
  11052008	MHC		Add API for tw power setting.
---------------------------Define Local Constant---------------------------
---------------------------Define Local Constant---------------------------
------------------------Define global variable-----------------------------
------------------------Define global variable-----------------------------
------------------------Define local variable------------------------------
  20081120 MH For Debug only, RF 
------------------------Define local variable------------------------------
-----------------------------------------------------------------------------
  Function:    PHY_RF6052SetBandwidth()
  Overview:    This function is called by SetBWModeCallback8190Pci() only
  Input:       struct adapter 			Adapter
 		WIRELESS_BANDWIDTH_E	Bandwidth	20M or 40M
  Output:      NONE
  Return:      NONE
  Note:		For RF type 0222D
 20M or 40M 
 3----------------------------------------------------------------- 
 3 <2> Initialize RF 
 3----------------------------------------------------------------- 
 for (eRFPath = RF_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++) 
----Store original RFENV control type----
----Set RF_ENV enable----
 PlatformStallExecution(1); 
----Set RF_ENV output high----
 PlatformStallExecution(1); 
 Set bit number of Address and Data for RF register 
  Set 1 to 4 bits for 8255 
 PlatformStallExecution(1); 
  Set 0 to 12  bits for 8255 
 PlatformStallExecution(1); 
----Initialize RF fom connfiguration file----
----Restore RFENV control type----
 3 ----------------------------------------------------------------- 
 3 Configuration of Tx Power Tracking 
 3 ----------------------------------------------------------------- 
  Initialize general global value 
  Config BB and RF 
 End of HalRf6052.c 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
  Description: 
  This file is for 92CE92CU dynamic mechanism only 
  Global var 
  functions 
  Init Value 
 	ODM_CMNINFO_BINHCT_TEST only for MP Team 
  Pointer reference 
 ODM_CMNINFO_MAC_PHY_MODE pHalData->MacPhyMode92D 
 	ODM_CmnInfoHook(pDM_Odm, ODM_CMNINFO_MAC_PHY_MODE,&(pDM_Odm->u8_temp)); 
  Calculate TxRx statistics. 
 ODM 
 ODM_CmnInfoUpdate(&pHalData->odmpriv , ODM_CMNINFO_RSSI_MIN, pdmpriv->MinUndecoratedPWDBForDM); 
 update IGI 
 set rssi to fw 
 ODM_DMWatchdog(&pHalData->odmpriv); 
 Do DIG by RSSI In LPS-32K 
 1 Find MIN-RSSI 
 if (pDM_DigTable->CurIGValue != pDM_Odm->RSSI_Min) 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  MACRO definition for pRFCalibrateInfo->TxIQC_8723B[0] 
  RF_PATH_B 
  MACRO definition for pRFCalibrateInfo->TxIQC_8723B[1] 
  RF_PATH_A 
---------------------------Define Local Constant---------------------------
 In the case that we fail to read TxPowerTrack.txt, we use the table for
  88E as the default table.
 3 ============================================================ 
 3 Tx Power Tracking 
 3 ============================================================ 
 new element A = element D x X 
 consider minus 
 new element C = element D x Y 
 if (RFPath == RF_PATH_A) 
			 write new elements A, C, D to regC80 and regC94,
			  element B is always 0
			 write new elements A, C, D to regC88 and regC9C,
			  element B is always 0
-----------------------------------------------------------------------------
  Function:	odm_TxPwrTrackSetPwr88E()
  Overview:	88E change all channel tx power according to flag.
 			OFDM & CCK are all different.
  Input:		NONE
  Output:		NONE
  Return:		NONE
  Revised History:
 When		Who	Remark
 04232012	MHC	Create Version 0.
 0dB 
 2dB 
 auto rate 
 force rate 
 2 CCK 
 2dB 
 2 OFDM 
 3dB 
 2dB 
 2 HT 
 QPSKBPSK 
 4dB 
 16QAM 
 3dB 
 64QAM 
 2dB 
 Default OFDM index = 30 
  Adjust BB swing by OFDM IQ matrix 
 BBSwing higher then Limit 
 If TxAGC has changed, reset TxAGC again 
  Lowest CCK Index = 0 
 If TxAGC has changed, reset TxAGC again 
  This method is not supported. 
 1 7. IQK 
 bit0 = 1 => Tx OK, bit1 = 1 => Rx OK 
, regEA4;
  Save RF Path 
 leave IQK mode 
 	enable path A PA in TXIQK mode 
 	disable path B PA in TXIQK mode 
 	PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH_A, 0xed, bRFRegOffsetMask, 0x00020); 
 	PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH_A, 0x43, bRFRegOffsetMask, 0x40ec1); 
 1 Tx IQK 
 IQK setting 
 path-A IQK setting 
 	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_A, bMaskDWord, 0x8214010a); 
 LO calibration setting 
 enter IQK mode 
 Ant switch 
  wifi switch to S1 
  wifi switch to S0 
 GNT_BT = 0 
 One shot, path A LOK & IQK 
  delay x ms 
 PlatformStallExecution(IQK_DELAY_TIME_8723B1000); 
 restore Ant Path 
 GNT_BT = 1 
 leave IQK mode 
  Check failed 
 Allen 20131125 
 if Tx not OK, ignore Rx 
 bit0 = 1 => Tx OK, bit1 = 1 => Rx OK 
  Save RF Path 
 leave IQK mode 
 1 Get TXIMR setting 
 modify RXIQK mode table 
 LNA2 off, PA on for Dcut 
 	PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH_A, RF_WE_LUT, 0x80000, 0x0); 
 IQK setting 
 path-A IQK setting 
 	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_A, bMaskDWord, 0x82160c1f); 
 LO calibration setting 
 enter IQK mode 
 Ant switch 
  wifi switch to S1 
  wifi switch to S0 
 GNT_BT = 0 
 One shot, path A LOK & IQK 
  delay x ms 
 PlatformStallExecution(IQK_DELAY_TIME_8723B1000); 
 restore Ant Path 
 GNT_BT = 1 
 leave IQK mode 
  Check failed 
 Allen 20131125 
 if Tx not OK, ignore Rx 
 modify RXIQK mode table 
 LAN2 on, PA off for Dcut 
 	PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH_A, RF_WE_LUT, 0x80000, 0x0); 
 PA, PAD setting 
 IQK setting 
 path-A IQK setting 
 	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_PI_A, bMaskDWord, 0x281604c2); 
 LO calibration setting 
 enter IQK mode 
 Ant switch 
  wifi switch to S1 
  wifi switch to S0 
 GNT_BT = 0 
 One shot, path A LOK & IQK 
  delay x ms 
 PlatformStallExecution(IQK_DELAY_TIME_8723B1000); 
 restore Ant Path 
 GNT_BT = 1 
 leave IQK mode 
  Check failed 
 	PAPAD controlled by 0x0 
 leave IQK mode 
 Allen 20131125 
 if Tx is OK, check whether Rx is OK 
 bit0 = 1 => Tx OK, bit1 = 1 => Rx OK 
, regEC4, regECC, Path_SEL_BB;
  Save RF Path 
 leave IQK mode 
 	in TXIQK mode 
 	PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH_A, RF_WE_LUT, 0x80000, 0x1); 
 	PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x20000); 
 	PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x0003f); 
 	PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xc7f87); 
 	enable path B PA in TXIQK mode 
 1 Tx IQK 
 IQK setting 
 path-A IQK setting 
 	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_A, bMaskDWord, 0x82140114); 
 LO calibration setting 
 enter IQK mode 
 switch to path B 
 	PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH_A, 0xb0, bRFRegOffsetMask, 0xeffe0); 
 GNT_BT = 0 
 One shot, path B LOK & IQK 
  delay x ms 
 PlatformStallExecution(IQK_DELAY_TIME_88E1000); 
 restore Ant Path 
 GNT_BT = 1 
 leave IQK mode 
  Check failed 
 Allen 20131125 
 bit0 = 1 => Tx OK, bit1 = 1 => Rx OK 
  Save RF Path 
 leave IQK mode 
 switch to path B 
 modify RXIQK mode table 
 open PA S1 & SMIXER 
 IQK setting 
 path-B IQK setting 
 	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_A, bMaskDWord, 0x82160c1f); 
 LO calibration setting 
 enter IQK mode 
 switch to path B 
 	PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH_A, 0xb0, bRFRegOffsetMask, 0xeffe0); 
 GNT_BT = 0 
 One shot, path B TXIQK @ RXIQK 
  delay x ms 
 PlatformStallExecution(IQK_DELAY_TIME_88E1000); 
 restore Ant Path 
 GNT_BT = 1 
 leave IQK mode 
  Check failed 
 Allen 20131125 
 if Tx not OK, ignore Rx 
 modify RXIQK mode table 
 20121009, Kordan> RF Mode = 3 
 	PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH_A, RF_WE_LUT, 0x80000, 0x0); 
 open PA S1 & close SMIXER 
 PA, PAD setting 
 	PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH_A, 0xdf, bRFRegOffsetMask, 0xf80); 
 	PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH_A, 0x56, bRFRegOffsetMask, 0x51000); 
 IQK setting 
 path-B IQK setting 
 	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_PI_A, bMaskDWord, 0x281604c2); 
 LO calibration setting 
 enter IQK mode 
 switch to path B 
 	PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH_A, 0xb0, bRFRegOffsetMask, 0xeffe0); 
 GNT_BT = 0 
 One shot, path B LOK & IQK 
  delay x ms 
 PlatformStallExecution(IQK_DELAY_TIME_88E1000); 
 restore Ant Path 
 GNT_BT = 1 
 leave IQK mode 
  Check failed 
 	PAPAD controlled by 0x0 
 leave IQK mode 
 	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, 0xffffff00, 0x00000000); 
 	PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH_B, 0xdf, bRFRegOffsetMask, 0x180); 
 Allen 20131125 
 if Tx is OK, check whether Rx is OK 
 2 Tx IQC 
  <20130226, Kordan> Saving RxIQC, otherwise not initialized. 
 			pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xC14][VAL] = PHY_QueryBBReg(pDM_Odm->Adapter, rOFDM0_XARxIQImbalance, bMaskDWord); 
 2 Rx IQC 
 do Tx only 
 2 Tx IQC 
 		pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC9C][KEY] = rOFDM0_XDTxAFE; 
 		pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC9C][VAL] = PHY_QueryBBReg(pDM_Odm->Adapter, rOFDM0_XDTxAFE, bMaskDWord); 
 			pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xC14][VAL] = PHY_QueryBBReg(pDM_Odm->Adapter, rOFDM0_XARxIQImbalance, bMaskDWord); 
 2 Rx IQC 
 		PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_AGCRSSITable, 0x0000F000, reg); 
  20110726 MH Add an API for testing IQK fail case. 
  MP Already declare in odm.c 
 S1: RFpath = 0, S0:RFpath = 1 
 S0 TX IQC 
 S0 RX IQC 
 S1 TX IQC 
 S1 RX IQC 
 for path A and path B 
 path A TX OK 
 path A RX OK 
 path B TX OK 
 path B RX OK 
 since 92C & 92D have the different define in IQK_BB_REG 
  Note: IQ calibration must be performed after loading 
 		PHY_REG.txt , and radio_a, radio_b.txt 
 u32 bbvalue; 
  Save ADDA parameters, turn Path A ADDA on 
 no serial mode 
 save RF path for 8723B 
 	Path_SEL_BB = PHY_QueryBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord); 
 	Path_SEL_RF = PHY_QueryRFReg(pDM_Odm->Adapter, RF_PATH_A, 0xb0, 0xfffff); 
 MAC settings 
 BB setting 
 PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_RFMOD, BIT24, 0x00); 
 	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_XAB_RFInterfaceSW, BIT10, 0x01); 
 	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_XAB_RFInterfaceSW, BIT26, 0x01); 
 	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_XA_RFInterfaceOE, BIT10, 0x00); 
 	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_XB_RFInterfaceOE, BIT10, 0x00); 
 RX IQ calibration setting for 8723B D cut large current issue when leaving IPS 
 path A TX IQK 
 		if (PathAOK == 0x03) { 
  Path A Tx IQK Success 
 path A RXIQK 
 				result[t][0] = (PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16; 
 				result[t][1] = (PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16; 
 path B IQK 
 path B TX IQK 
  Path B Tx IQK Success 
 path B RX IQK 
 				result[t][0] = (PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16; 
 				result[t][1] = (PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16; 
 Allen end 
 Back to BB mode, load original value 
  Reload ADDA power saving parameters 
  Reload MAC parameters 
 Reload RF path 
 		PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord, Path_SEL_BB); 
 		PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH_A, 0xb0, 0xfffff, Path_SEL_RF); 
 Allen initial gain 0xc50 
  Restore RX initial gain 
 load 0xe30 IQC default value 
 Check continuous TX and Packet TX 
 Deal with contisuous TX case 
 disable all continuous TX 
  Deal with Packet TX case 
  block all queues 
 1. Read original RF mode 
 Path-A 
 Path-B 
 2. Set RF mode = standby mode 
 Path-A 
 Path-B 
 3. Read RF reg18 
 4. Set LC calibration begin	bit15 
  LDO ON 
  LDO OFF 
  Channel 10 LC calibration issue for 8723bs with 26M xtal 
 Restore original situation 
 Deal with contisuous TX case 
 Path-A 
 Path-B 
  Deal with Packet TX case 
 IQK version:V2.5    20140123 
 IQK is controlled by Is2ant, RF path 
 false:1ant, true:2-ant 
 0:S1, 1:S0 
 last is final result 
 	u32 		Path_SEL_BB = 0; 
  20120213<Kordan> Turn on when continuous Tx to pass lab testing. (required by Edlu) 
  Restore TX IQK 
  Restore RX IQK 
 save default GNT_BT 
  Save RF Path 
 	Path_SEL_BB = PHY_QueryBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord); 
 	Path_SEL_RF = PHY_QueryRFReg(pDM_Odm->Adapter, RF_PATH_A, 0xb0, 0xfffff); 
 set GNT_BT = 0, pause BT traffic 
 	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, BIT12, 0x0); 
 	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, BIT11, 0x1); 
 X default value 
 Y default value 
 To Fix BSOD when final_candidate is 0xff 
 by sherry 20120321 
 restore GNT_BT 
  Restore RF Path 
 	PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord, Path_SEL_BB); 
 	PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH_A, 0xb0, 0xfffff, Path_SEL_RF); 
 Resotr RX mode table parameter 
 set GNT_BT = HW control 
 	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, BIT12, 0x0); 
 	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, BIT11, 0x0); 
 S1 
 S0 
  20120213<Kordan> Turn on when continuous Tx to pass lab testing. (required by Edlu) 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
  Description:
 Call power on sequence to enable card
  Return:
 _SUCCESS	enable success
 _FAIL		enable fail
  RSV_CTRL 0x1C[7:0] = 0x00 
  unlock ISOCLKPower control register 
 	u8 bMacPwrCtrlOn; 
  all of these MUST be configured before power on 
  only cmd52 can be used before power on(card enable) 
  Radio-Off Pin Trigger 
  Enable falling edge triggering interrupt 
  Enable power down and GPIO interrupt 
  Enable HW power down and RF on 
  Enable CMD53 RW Operation 
 	bMacPwrCtrlOn = true; 
 	rtw_hal_set_hwreg(padapter, HW_VAR_APFM_ON_MAC, &bMacPwrCtrlOn); 
  Enable MAC DMAWMACSCHEDULESEC block 
  external switch to S1 
  0x38[11] = 0x1 
  0x4c[23] = 0x1 
  0x64[0] = 0 
  Switch the control of EESK, EECS to RFC for DPDT or Antenna switch 
  BIT_EEPRPAD_RFE_CTRL_EN 
  DPDT_SEL_EN, 1 for SW control 
  BIT_SW_DPDT_SEL_DATA, DPDT_SEL default configuration 
 Tx Page FIFO threshold 
  NOTE: This step shall be proceed before writing REG_RQPN. 
  TX DMA 
 u16 txdmactrl; 
 for WMM 
 for WMM , CONFIG_OUT_EP_WIFI_MODE 
  typical setting 
  for WMM 
  RX Page Boundary 
  Tx page size is always 128. 
  TODO: use the other function to set network type 
 	value32 = (value32 & ~MASK_NETTYPE) | _NETTYPE(NT_LINK_AD_HOC); 
  Accept all multicast address 
  Accept all data frames 
  2010.09.08 hpfan 
  Since ADF is removed from RCR, ps-poll will not be indicate to driver, 
  RxFilterMap should mask ps-poll to gurantee AP mode can rx ps-poll. 
  Accept all management frames 
  Response Rate Set 
  CF-END Threshold 
 m_spIoBase->rtw_write8(REG_CFEND_TH, 0x1); 
  SIFS (used in NAV) 
  Retry Limit 
  Set Spec SIFS (used in NAV) 
  Set SIFS for CCK 
  Set SIFS for OFDM 
  TXOP 
  Set ACK timeout 
 0:1, 1:2, 2:3, 3:4 
 0:1K, 1:512Byte, 2:256Byte... 
 RxAggLowThresh = 41K 
  Tx aggregation setting 
 	sdio_AggSettingTxUpdate(padapter); 
  Rx aggregation setting 
  2011210 MH Add for USB agg mode dynamic switch. 
 1 This part need to modified according to the rate set we filtered!! 
  Set RRSR, RATR, and REG_BWOPMODE registers 
  It support CCK rate by default. 
  CCK rate will be filtered out only when associated AP does not support it. 
 for MacOSX compiler warning. 
  HISR - turn all off 
  HIMR - turn all off 
  Initialize and enable SDIO Host Interrupt. 
  Initialize system Host Interrupt. 
 YJ, TODO 
  20100809 MH Add for power down check. 
EEPROM_RF_OPT3_92C, (u32 )&tmpvalue);
  20100825 MH INF priority > PDN Efuse value. 
  HalDetectPwrDownMode 
 for polling cpwm 
 ser rpwm 
 do polling cpwm 
  Disable Interrupt first. 
 	rtw_hal_disable_interrupt(padapter); 
 	SIC_Init(padapter); 
  20100809 MH We need to check if we need to turnon or off RF after detecting 
  HW GPIO pin. Before PHY_RFConfig8192C. 
  Set RF type for BBRF configuration 
  Save target channel 
  <Roger_Notes> Current Channel will be updated again later. 
 d. Initialize BB related configurations. 
  If RF is on, we need to init RF. Otherwise, skip the procedure. 
  We need to follow SU method to change the RF cfg.txt. Default disable RF TXRX mode. 
 if (pHalData->eRFPowerState == eRfOn) 
  Joseph Note: Keep RfRegChnlVal for later use. 
 if (!pHalData->bMACFuncEnable) { 
  init LLT after tx buffer boundary is defined 
  Get Rx PHY status in order to report RSSI and others. 
 YJ, TODO 
  CCA 
  hpfan_todo: 2nd CCA related 
  unit: 256us. 256ms 
  unit: 256us. 256ms 
  Record original value for template. This is arough data, we can only use the data 
  for power adjust. The value can not be adjustde according to different power!!! 
 	pHalData->OriginalCckTxPwrIdx = pHalData->CurrentCckTxPwrIdx; 
 	pHalData->OriginalOfdm24GTxPwrIdx = pHalData->CurrentOfdm24GTxPwrIdx; 
  Disable BAR, suggested by Scott 
  2010.04.09 add by hpfan 
  HW SEQ CTRL 
  set 0x0 to 0xFF by tynli. Default enable HW SEQ NUM. 
  Configure SDIO TxRx Control to enable Rx DMA timer masking. 
  2010.02.24. 
  Update current Tx FIFO page status. 
  Enable MACTXENMACRXEN block 
 ack for xmit mgmt frames. 
 	pHalData->PreRpwmVal = SdioLocalCmd52Read1Byte(padapter, SDIO_REG_HRPWM1) & 0x80; 
 Inform WiFi FW that it is the beginning of IQK 
 Inform WiFi FW that it is the finish of IQK 
  Init BT hw config. 
  Description: 
 	RTL8723e card disable power sequence v003 which suggested by Scott. 
  First created by tynli. 2011.01.28. 
  Run LPS WL RFOFF flow 
 	==== Reset digital sequence   ====== 
 8051 RAM code 
  Reset MCU 0x2[10]= 0. Suggested by Filen. 2011.01.26. by tynli. 
  0x2[10], FEN_CPUEN 
  MCUFWDL 0x80[1:0]= 0 
  reset MCU ready status 
  Reset MCU IO Wrapper, added by Roger, 2011.08.30 
 	==== Reset digital sequence end ====== 
  Disable CMD53 RW 
 poll 0x1cc to make sure H2C command already finished by FW; MAC_0x1cc = 0 means H2C done by FW. 
 H2C done, enter 32k 
 ser rpwm to enter 32k 
  interface related variable 
 	Description: 
 		We should set Efuse cell selection to WiFi cell in default. 
 	Assumption: 
 		PASSIVE_LEVEL 
 	Added by Roger, 2010.11.23. 
 		sMacAddr[5] = (u8)GetRandomNumber(1, 254); 
 Read Permanent MAC address 
  This part read and parse the eepromefuse content 
  Read Bluetooth co-exist and initialize 
  To check system boot selection. 
 	pHalData->EEType = IS_BOOT_FROM_EEPROM(Adapter) ? EEPROM_93C46 : EEPROM_BOOT_EFUSE; 
 	Description: 
 		Read HW adapter information by E-Fuse or EEPROM according CR9346 reported. 
 	Assumption: 
 		PASSIVE_LEVEL (SDIO interface) 
  before access eFuse, make sure card enable has been called 
  for BT, Switch Ant control to BT 
 for the power consumption issue,  wifi ko module is loaded during booting, but wifi GUI is off 
  Read EEPROM size before call any EEPROM function 
  If variable not handled here,
  some variables will be processed in SetHwReg8723B()
  rpwm value only use BIT0(clock bit) , BIT6(Ack bit), and BIT7(Toggle bit) 
  BIT0 value - 1: 32k, 0:40MHz. 
  BIT6 value - 1: report cpwm value after success set, 0:do not report. 
  BIT7 value - Toggle bit change. 
  If variable not handled here,
  some variables will be processed in GetHwReg8723B()
 3. read dword 0x88               driver read fw ps state 
 	Description: 
 		Query setting of specified variable. 
  Stanley@BB.SD3 suggests 16K can get stable performance 
  coding by Lucas@20130730 
 	Description: 
 		Change default setting of specified variable. 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
 if (padapter->isprimary) 
 if (padapter->isprimary) 
  Description:
 Use hardware(efuse), driver parameter(registry) and default channel plan
 to decide which one should be used.
  Parameters:
 padapter			pointer of adapter
 hw_channel_plan		channel plan from HW (efuseeeprom)
 					BIT[7] software configure mode; 0:Enable, 1:disable
 					BIT[6:0] Channel Plan
 sw_channel_plan		channel plan from SW (registrymodule param)
 def_channel_plan	channel plan used when HWSW both invalid
 AutoLoadFail		efuse autoload fail or not
  Return:
 Final channel plan decision
 VO 
 VI 
 BE 
 BK 
 BCN 
 MGT 
 HIGH 
 TXCMD 
 WMM 
 	BK,	BE,	VI,	VO,	BCN,	CMD, MGT, HIGH, HCCA 
   0,		1,	0,	1,	0,	0,	0,	0,		0	}; 
 0:ep_0 num, 1:ep_1 num 
 VO 
 VI 
 BE 
 BK 
 BCN 
 MGT 
 HIGH 
 TXCMD 
 typical setting 
 BK,	BE,	VI,	VO,	BCN,	CMD, MGT, HIGH, HCCA 
   1,		1,	0,	0,	0,	0,	0,	0,		0	}; 
 0:ep_0 num, 1:ep_1 num 
 VO 
 VI 
 BE 
 BK 
 BCN 
 MGT 
 HIGH 
 TXCMD 
 for WMM 
 	BK,	BE,	VI,	VO,	BCN,	CMD, MGT, HIGH, HCCA 
   1,		2,	1,	0,	0,	0,	0,	0,		0	}; 
 0:H, 1:N, 2:L 
 VO 
 VI 
 BE 
 BK 
 BCN 
 MGT 
 HIGH 
 TXCMD 
 typical setting 
 	BK,	BE,	VI,	VO,	BCN,	CMD, MGT, HIGH, HCCA 
   2,		2,	1,	0,	0,	0,	0,	0,		0	}; 
 0:H, 1:N, 2:L 
 VO 
 VI 
 BE 
 BK 
 BCN 
 MGT 
 HIGH 
 TXCMD 
 C2H event format:
 Field	 TRIGGER		CONTENT	   CMD_SEQ	CMD_LEN		 CMD_ID
 BITS	 [127:120]	[119:16]      [15:8]		  [7:4]		   [3:0]
 C2H event format:
 Field    TRIGGER    CMD_LEN    CONTENT    CMD_SEQ    CMD_ID
 BITS    [127:120]   [119:112]    [111:16]	     [15:8]         [7:0]
 Not ready 
 Not a valid value 
 Read the content 
	
	 Clear event to notify FW we have read the command.
	 If this field isn't clear, the FW won't update the next command message.
 bg mode ra_bitmap 
 n mode ra_bitmap 
   1R 
 Enable default key related setting 
 Disable default key related setting 
 save dm flag 
 restore dm flag 
		
		 input is already a mask to clear function
		 don't invert it again! George, Lucas@20130513
 TODO - Is something needed here? 
 TODO - Is something needed here? 
 disable all dynamic func 
 disable DIG 
 disable High power 
 disable tx power tracking 
 disable BT coexistence 
 disable antenna diversity 
 turn on all dynamic func 
 _irqL irqL; 
 spin_lock_bh(&pHalData->odm_stainfo_lock); 
 spin_unlock_bh(&pHalData->odm_stainfo_lock); 
 	Description: 
 		Return true if chTmp is represent for hex digit and 
 		false otherwise. 
 	Description: 
 		Translate a character to hex digit. 
 	Description: 
 		Parse hex number from the string pucStr. 
  Check input parameter. 
  Initialize output. 
  Skip leading space. 
  Skip leading '0x' or '0X'. 
  Check if szScan is now pointer to a character for hex digit, 
  if not, it means this is not a valid hex number. 
  Parse each digit. 
  Initialize output. 
  Skip leading space. 
  Parse each digit. 
 	Description: 
". 
  <20121004, Kordan> For example,
   ParseQualifiedString(inString, 0, outString, '[', ']') gets "Kordan" from
   a string "Hello [Kordan]".
   If RightQualifier does not exist, it will hang in the while loop
  find ']' 
 switch counter to RX fifo 
 printk("8723b or 8192e , MAC_667 set 0xf0\n"); 
 todo: other chips 
 rtw_write8(adapter, REG_RXERR_RPT+3, rtw_read8(adapter, REG_RXERR_RPT+3)|0xa0); 
 keep org value 
 keep org value 
 res &= 0xfff87fff; 
 res |= (padapter->eeprompriv.EEPROMRFGainVal & 0x0f)<< 15; 
 rtw_hal_write_rfreg(padapter, RF_PATH_A, REG_RF_BB_GAIN_OFFSET, RF_GAIN_OFFSET_MASK, res); 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
 RT_CID_819x_FUNAI_TV 
 Reg818 = PHY_QueryBBReg(padapter, 0x818, bMaskDWord); 
 Reg874[20:18]=3'b010 
 RegC70[3]= 1'b0 
 Reg85C[31:24]= 0x63 
 Reg874[15:14]=2'b10 
 RegA75[7:4]= 0x3 
 Reg818[28]= 1'b0 
 Reg818[28]= 1'b1 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2013 Realtek Corporation. All rights reserved.
 		Global variables 
 		Debug related function 
  recover the LPS state to the original 
   Constraint:
    1. this function will request pwrctrl->lock
  unit: ms 
  !LPS_RPWM_WAIT_MS 
  !LPS_RPWM_WAIT_MS 
   Constraint:
    1. this function will request pwrctrl->lock
  leave 32k low power. 
  original 32k low power behavior. 
  return value: 
  [31:16]=> connected port number 
  [15:0]=> port connected bit define 
		 Use the value of the new variable GLBtcWiFiInScanState to judge whether WiFi is in scan state or not, since the originally used flag
 			pU1Tmp = BTC_DMSP; 
 			pU1Tmp = BTC_DMDP; 
 			pU1Tmp = BTC_MP_UNKNOWN; 
 1Ant =========== 
  set some u8 type variables. 
  set some u8 type variables. 
  the following are some action which will be triggered 
 1Ant =========== 
  set some u8 type variables. 
  the following are some action which will be triggered 
 		IO related function 
 Set OperVer 
 Set ReqNum 
 Set OpCode to BT_LO_OP_WRITE_REG_VALUE 
 Set WriteRegValue 
 Set OperVer 
 Set ReqNum 
 Set OpCode of BT_LO_OP_WRITE_REG_ADDR 
 Set WriteRegAddr 
 To be implemented. Always return 0 temporarily 
 		Extern functions called by other module 
  set default antenna position to main  port 
 pBtCoexist->statistics.cntBind++; 
 Power on setting function is only added in 8723B currently 
  All notify is called in cmd thread, don't need to leave low power again 
 	halbtcoutsrc_LeaveLowPower(pBtCoexist); 
 	halbtcoutsrc_NormalLowPower(pBtCoexist); 
  All notify is called in cmd thread, don't need to leave low power again 
 	halbtcoutsrc_LeaveLowPower(pBtCoexist); 
 	halbtcoutsrc_NormalLowPower(pBtCoexist); 
  All notify is called in cmd thread, don't need to leave low power again 
 	halbtcoutsrc_LeaveLowPower(pBtCoexist); 
 	halbtcoutsrc_NormalLowPower(pBtCoexist); 
  All notify is called in cmd thread, don't need to leave low power again 
 	halbtcoutsrc_LeaveLowPower(pBtCoexist); 
 	halbtcoutsrc_NormalLowPower(pBtCoexist); 
  All notify is called in cmd thread, don't need to leave low power again 
 	halbtcoutsrc_LeaveLowPower(pBtCoexist); 
 	halbtcoutsrc_NormalLowPower(pBtCoexist); 
  All notify is called in cmd thread, don't need to leave low power again 
 	halbtcoutsrc_LeaveLowPower(pBtCoexist); 
 	halbtcoutsrc_NormalLowPower(pBtCoexist); 
  currently only 1ant we have to do the notification, 
  once pnp is notified to sleep state, we have to leave LPS that we can sleep normally. 
  Periodical should be called in cmd thread, 
  don't need to leave low power again 
 	halbtcoutsrc_LeaveLowPower(pBtCoexist); 
 	halbtcoutsrc_NormalLowPower(pBtCoexist); 
 GLBtCoexist.boardInfo.btdmAntPos = BTC_ANTENNA_AT_MAIN_PORT; 
 GLBtCoexist.boardInfo.btdmAntPos = BTC_ANTENNA_AT_MAIN_PORT; 
  Currently used by 8723b only, S0 or S1 
  Description:
 Run BT-Coexist mechanism or not
  Dewcription:
 Check is co-exist mechanism enabled or not
  Return:
 true	Enable BT co-exist mechanism
 false	Disable BT co-exist mechanism
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
  update rx report to recv_frame attribute 
  Normal rx packet 
  update rx report to recv_frame attribute 
  Notice:
 Before calling this function,
 precvframe->u.hdr.rx_data should be ready!
 unsigned long		irqL; 
 rtl8723b_query_rx_phy_status(precvframe, pphy_status); 
 spin_lock_bh(&p_hal_data->odm_stainfo_lock); 
 spin_unlock_bh(&p_hal_data->odm_stainfo_lock); 
  The case of can't allocate recvframe should be temporary, 
  schedule again and hope recvframe is available next time. 
  fix Hardware RX data error, drop whole recv_buffer 
 rx desc parsing 
 	Modified by Albert 20101213 
 	For 8 bytes IP header alignment. 
 	Qos data, wireless lan header length is 26 
  for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet. 
  modify alloc_sz for recvive crc error packet by thomas 2011-06-02 
 	6 is for IP header 8 bytes alignment in QoS packet case. 
 	8 is for skb->data 4 bytes alignment. 
 force pkt_copy->data at 8-byte alignment address 
 force ip_hdr at 8-byte alignment address according to shift_sz. 
 recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE); 
  move to drv info position 
  update drv info 
 rtl8723s_update_bassn(padapter, pdrvinfo); 
 Normal rx packet 
  Initialize recv private variable for hardware dependent
  1. recv buf
  2. recv tasklet
 3 1. init recv buffer 
  init each recv buffer 
 3 2. init tasklet 
  Free recv private variable of hardware dependent
  1. recv buf
  2. recv tasklet
 3 1. kill tasklet 
 3 2. free all recv buffers 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
 _irqL irql; 
 spin_lock_bh(&pHalData->SdioTxFIFOFreePageLock); 
 spin_unlock_bh(&pHalData->SdioTxFIFOFreePageLock); 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
  Description: 
	The following mapping is for SDIO host local register space. 
  Creadted by Roger, 2011.01.31. 
  4 bytes alignment 
  4 bytes alignment 
  4 bytes alignment 
  Description:
 Read from RX FIFO
 Round read size to block size,
 and make sure data transfer will be done in one command.
  Parameters:
 intfhdl	a pointer of intf_hdl
 addr		port ID
 cnt			size to read
 rmem		address to put data
  Return:
 _SUCCESS(1)		Success
 _FAIL(0)		Fail
  Description:
 Write to TX FIFO
 Align write size block size,
 and make sure data could be written in one command.
  Parameters:
 intfhdl	a pointer of intf_hdl
 addr		port ID
 cnt			size to write
 wmem		data pointer to write
  Return:
 _SUCCESS(1)		Success
 _FAIL(0)		Fail
  Todo: align address to 4 bytes.
  Todo: align address to 4 bytes.
  Todo: align address to 4 bytes.
  decide how many bytes need to be read 
	Description: 
		Initialize SDIO Host Interrupt Mask configuration variables for future use. 
	Assumption: 
		Using SDIO Local register ONLY for configuration. 
	Created by Roger, 2011.02.11. 
	Description: 
		Initialize System Host Interrupt Mask configuration variables for future use. 
	Created by Roger, 2011.08.03. 
	Description: 
		Enalbe SDIO Host Interrupt Mask configuration on SDIO local domain. 
	Assumption: 
		1. Using SDIO Local register ONLY for configuration. 
		2. PASSIVE LEVEL 
	Created by Roger, 2011.02.11. 
  Update current system IMR settings 
  <Roger_Notes> There are some C2H CMDs have been sent before system interrupt is enabled, e.g., C2H, CPWM. 
  So we need to clear all C2H events that FW has notified, otherwise FW won't schedule any commands anymore. 
  2011.10.19. 
	Description: 
		Disable SDIO Host IMR configuration to mask unnecessary interrupt service. 
	Assumption: 
		Using SDIO Local register ONLY for configuration. 
	Created by Roger, 2011.02.11. 
	Description: 
		Using 0x100 to check the power status of FW. 
	Assumption: 
		Using SDIO Local register ONLY for configuration. 
	Created by Isaac, 2013.09.10. 
  Patch for some SDIO Host 4 bytes issue 
  ex. RK3188 
 3 1. alloc recvbuf 
 3 2. alloc skb 
 3 3. read data from rxfifo 
 3 4. init recvbuf 
 3 1. enqueue recvbuf 
 3 2. schedule tasklet 
 Handle CCX report here 
 Error handling for malloc fail 
  clear HISR 
	Description: 
		Query SDIO Local register to query current the number of Free TxPacketBuffer page. 
	Assumption: 
		1. Running at PASSIVE_LEVEL 
		2. RT_TX_SPINLOCK is NOT acquired. 
	Created by Roger, 2011.01.28. 
	Description: 
		Query SDIO Local register to get the current number of TX OQT Free Space. 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
This file includes all kinds of Power Action event for RTL8723B
and corresponding hardware configurtions which are released from HW SD.
Major Change History:
	When       Who               What
	---------- ---------------   -------------------------------
	2011-08-08 Roger            Create.
 drivers should parse below arrays and do the corresponding actions 
 3 Power on  Array 
 3Radio off GPIO Array 
 3Card Disable Array 
 3 Card Enable Array 
 3Suspend Array 
 3 Resume Array 
 3HWPDN Array 
 3 Enter LPS 
 FW behavior 
 3 Leave LPS 
 FW behavior 
 3 Enter SW LPS 
 SW behavior 
 3 Leave SW LPS 
 SW behavior 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
 if (pRfd->Status.bPacketToSelf || pRfd->Status.bPacketBeacon) 
  Process_UI_RSSI_8192C 
  Process_UiLinkQuality8192S 
  Check RSSI 
  Check PWDB. 
 process_PWDB(padapter, precvframe); 
 UpdateRxSignalStatistics8192C(Adapter, pRfd); 
  Check EVM 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
 free HAL Data 
  cancel dm  timer 
  [IMPORTANT] This function would be run in interrupt context.
 pframe = (u8 )(pmgntframe->buf_addr) + TXDESC_OFFSET; 
 pwlanhdr = (struct rtw_ieee80211_hdr )pframe; 
 memcpy(pmgntframe->attrib.ra, pwlanhdr->addr1, ETH_ALEN); 
 pmgntframe->attrib.bswenc = true; 
Start specifical interface thread		
Start specifical interface thread		
 this function caller is in interrupt context 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
 include "Mp_Precomp.h" 
  <20121113, Kordan> This function should be called when TxAGC changed. 
  Otherwise the previous compensation is gone, because we record the 
  delta of temperature between two TxPowerTracking watch dogs. 
  NOTE: If Tx BB swing or Tx scaling is varified during run-time, still 
        need to call this function. 
  Initial Mix mode power tracking 
 Initial at Modify Tx Scaling Mode 
 Initial at Modify Tx Scaling Mode 
  OFDM BB Swing should be less than +3.0dB, which is required by Arthur 
  GetRightChnlPlaceforIQK(pHalData->CurrentChannel) 
 4 1. The following TWO tables decide the final index of OFDMCCK swing table. 
 4 2. Initialization (7 steps in total) 
 cosa add for debug 
 0x42: RF Reg[15:10] 88E 
 4 3. Initialize ThermalValues of RFCalibrateInfo 
 4 4. Calculate average thermal meter 
 Average times =  c.AverageThermalNum 
 Calculate Average ThermalValue after average enough times 
 4 5. Calculate delta, delta_LCK 
 delta" here is used to determine whether thermal value changes or not. 
 4 6. If necessary, do LCK. 
  Delta temperature is equal to or larger than 20 centigrade. 
 3 7. If necessary, move the index of swing table to adjust Tx power. 
 delta" here is used to record the absolute value of difference. 
 4 7.1 The Final Power Index = BaseIndex + PowerIndexOffset 
  Record delta swing for mix mode power tracking 
  Record delta swing for mix mode power tracking 
  Record delta swing for mix mode power tracking 
  Record delta swing for mix mode power tracking 
  If Thermal value changes but lookup table value still the same 
  Power Index Diff between 2 times Power Tracking 
 4 7.1 Handle boundary conditions of index. 
 else if (pDM_Odm->RFCalibrateInfo.CCK_index < 0) 
 pDM_Odm->RFCalibrateInfo.CCK_index = 0; 
 Print Swing base & current 
 4 7.2 Configure the Swing Table to adjust Tx Power. 
  Always true after Tx Power is adjusted by power tracking. 
  20120423 MH According to Luke's suggestion, we can not write BB digital 
  to increase TX power. Otherwise, EVM will be bad. 
  20120425 MH Add for tx power tracking to set tx power in tx agc for 88E. 
  Record last time Power Tracking result as base. 
 Record last Power Tracking Thermal Value 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  This function is for inband noise test utility only 
  To obtain the inband noise level(dbm), do the following. 
  1. disable DIG and Power Saving 
  2. Set initial gain = 0x1a 
  3. Stop updating idle time pwer report (for driver read) 
 - 0x80c[25] 
  Step 1. Disable DIG && Set initial gain. 
  Step 2. Disable all power save for read registers 
 dcmd_DebugControlPowerSave(padapter, PSDisable); 
  Step 3. Get noise power level 
 Stop updating idle time pwer report (for driver read) 
 Read Noise Floor Report 
 PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XAAGCCore1, bMaskByte0, TestInitialGain); 
 if (max_rf_path == 2) 
 PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XBAGCCore1, bMaskByte0, TestInitialGain); 
 update idle time pwer report per 5us 
 mdelay(10); 
 msleep(10); 
 printk("####### valid_done:%d #############\n", valid_done); 
 printk("%s PATH_%d - sum = %d, valid_cnt = %d\n", __func__, rf_path, noise_data.sum[rf_path], noise_data.valid_cnt[rf_path]); 
  Step 4. Recover the Dig 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  Add 1us delay between BBRF register setting. 
 For disableenable test in high temperature, the B6 value will fail to fill. Suggestion by BB Stanley, 2013.06.25. 
 Do LCK againg 
  RF_Content: radioa_txt 
  Add 1us delay between BBRF register setting. 
  Add 1us delay between BBRF register setting. 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  _GLNA 
  _GPA 
  _ALNA 
  _APA 
  _BT 
  Value Defined Check =============== 
 QFN Type [15:12] and Cut Version [27:24] need to do value check 
  Bit Defined Check ================ 
  We don't care [31:28] and [23:20] 
  BoardType is DONTCARE 
 GLNA 
 GPA 
 ALNA 
 APA 
  BoardType of each RF path is matched 
                           AGC_TAB.TXT
  This (offset, data) pair doesn't care the condition. 
  This line is the beginning of branch. 
  ELSE, ENDIF 
				  Condition isn't matched.
				   Discard the following (offset, data) pairs.
  prevent from for-loop += 2 
  Configure matched pairs and skip to end of if-else. 
  Keeps reading until ENDIF. 
                           PHY_REG.TXT
  This (offset, data) pair doesn't care the condition. 
  This line is the beginning of branch. 
  ELSE, ENDIF 
				  Condition isn't matched.
				   Discard the following (offset, data) pairs.
  prevent from for-loop += 2 
  Configure matched pairs and skip to end of if-else. 
  Keeps reading until ENDIF. 
                           PHY_REG_PG.TXT
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  phy_CalculateBitShift - Get shifted position of the BitMask.
  @BitMask: Bitmask.
  Return:	Return the shift bit position of the mask
  PHY_QueryBBReg_8723B - Read "specific bits" from BB register.
  @Adapter:
  @RegAddr:	The target address to be readback
  @BitMask:	The target bit position in the target address
 				to be readback
  Return:	The readback register value
  .. Note::	This function is equal to "GetRegSetting" in PHY programming
 			guide
  PHY_SetBBReg_8723B - Write "Specific bits" to BB register (page 8~).
  @Adapter:
  @RegAddr:	The target address to be modified
  @BitMask:	The target bit position in the target address
 				to be modified
  @Data:		The new register value in the target bit position
 				of the target address
  .. Note::	This function is equal to "PutRegSetting" in PHY programming
 			guide
 u16 BBWaitCounter	= 0; 
 if not "double word" write 
  2. RF register RW API 
  Make sure RF register offset is correct 
 T65 RF 
 T65 RF 
  Read from BBreg8b8, 12 bits for 8190, 20bits for T65 RF 
 Read from BBreg8a0, 12 bits for 8190, 20 bits for T65 RF 
  phy_RFSerialWrite_8723B - Write data to RF register (page 8~).
  @Adapter:
  @eRFPath:	Radio path of ABCD
  @Offset:	The target address to be read
  @Data:	The new register Data in the target bit position
 			of the target to be read
  .. Note::	Threre are three types of serial operations:
 		1. Software serial write
 		2. Hardware LSSI-Low Speed Serial Interface
 		3. Hardware HSSI-High speed
 		serial write. Driver need to implement (1) and (2).
 		This function is equal to the combination of RF_ReadReg() and  RFLSSIRead()
  .. Note::		  For RF8256 only
 		 The total count of RTL8256(Zebra4) register is around 36 bit it only employs
 		 4-bit RF address. RTL8256 uses "register mode control bit" (Reg00[12], Reg00[10])
 		 to access register address bigger than 0xf. See "Appendix-4 in PHY Configuration
 		 programming guide" for more details.
 		 Thus, we define a sub-finction for RTL8526 register address conversion
 	       ===========================================================
 		 Register Mode		RegCTL[1]		RegCTL[0]		Note
 							(Reg00[12])		(Reg00[10])
 	       ===========================================================
 		 Reg_Mode0				0				x			Reg 0 ~15(0x0 ~ 0xf)
 	       ------------------------------------------------------------------
 		 Reg_Mode1				1				0			Reg 16 ~30(0x1 ~ 0xf)
 	       ------------------------------------------------------------------
 		 Reg_Mode2				1				1			Reg 31 ~ 45(0x1 ~ 0xf)
 	       ------------------------------------------------------------------
 20080902	MH	Add 92S RF definition
  Switch page for 8256 RF IC 
  Put write addr in [5:0]  and write data in [31:16] 
  T65 RF 
  Write Operation 
  PHY_QueryRFReg_8723B - Query "Specific bits" to RF register (page 8~).
  @Adapter:
  @eRFPath:	Radio path of ABCD
  @RegAddr:	The target address to be read
  @BitMask:	The target bit position in the target address
 				to be read
  Return:	Readback value
  .. Note::	This function is equal to "GetRFRegSetting" in PHY
 			programming guide
  PHY_SetRFReg_8723B - Write "Specific bits" to RF register (page 8~).
  @Adapter:
  @eRFPath:	Radio path of ABCD
  @RegAddr:	The target address to be modified
  @BitMask:	The target bit position in the target address
 				to be modified
  @Data:	The new register Data in the target bit position
 								of the target address
  .. Note::	This function is equal to "PutRFRegSetting" in PHY
 			programming guide.
  RF data is 12 bits only 
  3. Initial MACBBRF config by reading MACBBRF txt. 
-----------------------------------------------------------------------------
  PHY_MACConfig8192C - Condig MAC by header file or parameter file.
  Revised History:
   When		Who		Remark
   08122008	MHC		Create Version 0.
 ---------------------------------------------------------------------------
  phy_InitBBRFRegisterDefinition - Initialize Register definition offset for
 									Radio Path ABCD
  @Adapter:
  .. Note::		The initialization value is constant and it should never be changes
  RF Interface Sowrtware Control 
  16 LSBs if read 32-bit from 0x870 
  16 MSBs if read 32-bit from 0x870 (16-bit for 0x872) 
  RF Interface Output (and Enable) 
  16 LSBs if read 32-bit from 0x860 
  16 LSBs if read 32-bit from 0x864 
  RF Interface (Output and)  Enable 
  16 MSBs if read 32-bit from 0x860 (16-bit for 0x862) 
  16 MSBs if read 32-bit from 0x864 (16-bit for 0x866) 
 LSSI Parameter 
 wire control parameter2 
 wire control parameter2 
  Tranceiver Readback LSSIHSPI mode 
  Read Tx Power Limit File 
  1. Read PHY_REG.TXT BB INIT!! 
  If EEPROM or EFUSE autoload OK, We must config by PHY_REG_PG.txt 
  2. Read BB AGC table Initialization 
  Enable BB and RF 
  Others use Antenna S1 
  Config BB and AGC 
  0x2C[23:18] = 0x2C[17:12] = CrystalCap 
  RF config 
    Description:
        The low-level interface to set TxAGC , called by both MP and Normal Driver.
                                                                                     <20120830, Kordan>
  antenna diversity Enable 
  antenna diversity disable 
  BIT 7 = 0, BIT 8 = 0 
  BIT 7 = 1, BIT 8 = 0 
 3 Set Reg668 Reg440 BW 
 3 Set Reg483 
 3 
 3<2>Set PHY related register 
 3 
 20 MHz channel
 40 MHz channel
  Set Control channel to upper or lower. These settings are required only for 40MHz 
 3<3>Set RF related register 
 static bool		bInitialzed = false; 
 check is swchnl or setbw 
 skip change for channel or bandwidth is the same 
 Switch workitem or set timer to do switch channel or setbandwidth operation 
  20M or 40M 
  Upper, Lower, or Don't care 
  Call after initialization 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  CCK 
  OFDM 
  HT MCS0~7 
   This function must be called if the value in the PHY_REG_PG.txt(or header)
   is exact dBm values
  OFDM-1T 
  BW20-1S, BW20-2S 
  BW40-1S, BW40-2S 
  workaround for wrong index combination to obtain tx power limit, 
  OFDM only exists in BW 20M 
  CCK table will only be given in BW 20M 
  HT on 80M will reference to HT on 40M 
  HT 1T 
  OFDM 
  CCK 
 Realtek Reserve 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  Global var 
  0, +6.0dB 
  1, +5.5dB 
  2, +5.0dB 
  3, +4.5dB 
  4, +4.0dB 
  5, +3.5dB 
  6, +3.0dB 
  7, +2.5dB 
  8, +2.0dB 
  9, +1.5dB 
  10, +1.0dB 
  11, +0.5dB 
  12, +0dB 
  13, -0.5dB 
  14, -1.0dB 
  15, -1.5dB 
  16, -2.0dB 
  17, -2.5dB 
  18, -3.0dB 
  19, -3.5dB 
  20, -4.0dB 
  21, -4.5dB 
  22, -5.0dB 
  23, -5.5dB 
  24, -6.0dB 
  25, -6.5dB 
  26, -7.0dB 
  27. -7.5dB 
  28, -8.0dB 
  29, -8.5dB 
  30, -9.0dB 
  31, -9.5dB 
  32, -10.0dB 
  33, -10.5dB 
  34, -11.0dB 
  35, -11.5dB 
  36, -12.0dB 
  0, +0dB 
  1, -0.5dB 
  2, -1.0dB 
  3, -1.5dB 
  4, -2.0dB 
  5, -2.5dB 
  6, -3.0dB 
  7, -3.5dB 
  8, -4.0dB 
  9, -4.5dB 
  10, -5.0dB 
  11, -5.5dB 
  12, -6.0dB <== default 
  13, -6.5dB 
  14, -7.0dB 
  15, -7.5dB 
  16, -8.0dB 
  17, -8.5dB 
  18, -9.0dB 
  19, -9.5dB 
  20, -10.0dB 
  21, -10.5dB 
  22, -11.0dB 
  23, -11.5dB 
  24, -12.0dB 
  25, -12.5dB 
  26, -13.0dB 
  27, -13.5dB 
  28, -14.0dB 
  29, -14.5dB 
  30, -15.0dB 
  31, -15.5dB 
  32, -16.0dB 
  0, +0dB 
  1, -0.5dB 
  2, -1.0dB 
  3, -1.5dB 
  4, -2.0dB 
  5, -2.5dB 
  6, -3.0dB 
  7, -3.5dB 
  8, -4.0dB 
  9, -4.5dB 
  10, -5.0dB 
  11, -5.5dB 
  12, -6.0dB  <== default 
  13, -6.5dB 
  14, -7.0dB 
  15, -7.5dB 
  16, -8.0dB 
  17, -8.5dB 
  18, -9.0dB 
  19, -9.5dB 
  20, -10.0dB 
  21, -10.5dB 
  22, -11.0dB 
  23, -11.5dB 
  24, -12.0dB 
  25, -12.5dB 
  26, -13.0dB 
  27, -13.5dB 
  28, -14.0dB 
  29, -14.5dB 
  30, -15.0dB 
  31, -15.5dB 
  32, -16.0dB 
  0,  -15.0dB 
  1,  -14.5dB 
  2,  -14.0dB 
  3,  -13.5dB 
  4,  -13.0dB 
  5,  -12.5dB 
  6,  -12.0dB 
  7,  -11.5dB 
  8,  -11.0dB 
  9,  -10.5dB 
  10, -10.0dB 
  11, -9.5dB 
  12, -9.0dB 
  13, -8.5dB 
  14, -8.0dB 
  15, -7.5dB 
  16, -7.0dB 
  17, -6.5dB 
  18, -6.0dB 
  19, -5.5dB 
  20, -5.0dB 
  21, -4.5dB 
  22, -4.0dB 
  23, -3.5dB 
  24, -3.0dB 
  25, -2.5dB 
  26, -2.0dB 
  27, -1.5dB 
  28, -1.0dB 
  29, -0.5dB 
  30, +0dB 
  31, +0.5dB 
  32, +1.0dB 
  33, +1.5dB 
  34, +2.0dB 
  35, +2.5dB 
  36, +3.0dB 
  37, +3.5dB 
  38, +4.0dB 
  39, +4.5dB 
  40, +5.0dB 
  41, +5.5dB 
  42, +6.0dB 
   0, -16.0dB 
   1, -15.5dB 
   2, -15.0dB 
   3, -14.5dB 
   4, -14.0dB 
   5, -13.5dB 
   6, -13.0dB 
   7, -12.5dB 
   8, -12.0dB 
   9, -11.5dB 
  10, -11.0dB 
  11, -10.5dB 
  12, -10.0dB 
  13, -9.5dB 
  14, -9.0dB 
  15, -8.5dB 
  16, -8.0dB 
  17, -7.5dB 
  18, -7.0dB 
  19, -6.5dB 
  20, -6.0dB 
  21, -5.5dB 
  22, -5.0dB 
  23, -4.5dB 
  24, -4.0dB 
  25, -3.5dB 
  26, -3.0dB 
  27, -2.5dB 
  28, -2.0dB 
  29, -1.5dB 
  30, -1.0dB 
  31, -0.5dB 
  32, +0dB 
   0, -16.0dB 
   1, -15.5dB 
   2, -15.0dB 
   3, -14.5dB 
   4, -14.0dB 
   5, -13.5dB 
   6, -13.0dB 
   7, -12.5dB 
   8, -12.0dB 
   9, -11.5dB 
  10, -11.0dB 
  11, -10.5dB 
  12, -10.0dB 
  13, -9.5dB 
  14, -9.0dB 
  15, -8.5dB 
  16, -8.0dB 
  17, -7.5dB 
  18, -7.0dB 
  19, -6.5dB 
  20, -6.0dB 
  21, -5.5dB 
  22, -5.0dB 
  23, -4.5dB 
  24, -4.0dB 
  25, -3.5dB 
  26, -3.0dB 
  27, -2.5dB 
  28, -2.0dB 
  29, -1.5dB 
  30, -1.0dB 
  31, -0.5dB 
  32, +0dB 
  0,  -12.0dB 
  1,  -11.5dB 
  2,  -11.0dB 
  3,  -10.5dB 
  4,  -10.0dB 
  5,  -9.5dB 
  6,  -9.0dB 
  7,  -8.5dB 
  8,  -8.0dB 
  9,  -7.5dB 
  10, -7.0dB 
  11, -6.5dB 
  12, -6.0dB 
  13, -5.5dB 
  14, -5.0dB 
  15, -4.5dB 
  16, -4.0dB 
  17, -3.5dB 
  18, -3.0dB 
  19, -2.5dB 
  20, -2.0dB 
  21, -1.5dB 
  22, -1.0dB 
  23, -0.5dB 
  24, +0  dB 
  25, +0.5dB 
  26, +1.0dB 
  27, +1.5dB 
  28, +2.0dB 
  29, +2.5dB 
  30, +3.0dB 
  31, +3.5dB 
  32, +4.0dB 
  33, +4.5dB 
  34, +5.0dB 
  35, +5.5dB 
  36, +6.0dB 
 Remove Edca by Yu Chen 
 3 ============================================================ 
 3 RATR MASK 
 3 ============================================================ 
 3 ============================================================ 
 3 Rate Adaptive 
 3 ============================================================ 
 11M or 5.5M enable 
 if (psta->mac_id == 1) 
 printk("RSSI:%d, RSSI_LEVEL:%d\n", pstat->rssi_stat.UndecoratedSmoothedPWDB, pstat->rssi_level); 
-----------------------------------------------------------------------------
 Function:	odm_RefreshRateAdaptiveMask()
 Overview:	Update rate table mask according to rssi
 Input:		NONE
 Output:		NONE
 Return:		NONE
 Revised History:
When		Who		Remark
05272009	hpfan	Create Version 0.
 --------------------------------------------------------------------------
  Return Value: bool 
  - true: RATRState is changed. 
  Threshold Adjustment: 
  when RSSI state trends to go up one or two levels, make sure RSSI is high enough. 
  Here GoUpGap is added to solve the boundary's level alternation issue. 
  Decide RATRState by RSSI. 
 printk("==>%s, RATRState:0x%02x , RSSI:%d\n", __func__, RATRState, RSSI); 
 3 ============================================================ 
 3 RSSI Monitor 
 3 ============================================================ 
 1 1.Determine the minimum RSSI 
 0~15]:MACID, [16~31]:PWDB_rssi 
 if (check_fwstate(&Adapter->mlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == true) 
 if (psta->mac_id == 1) 
 printk("%s ==> sta_cnt(%d)\n", __func__, sta_cnt); 
  Report every sta's RSSI to FW 
  If associated entry is found 
  If associated entry is found 
 get pdmpriv->MinUndecoratedPWDBForDM 
 ODM_CmnInfoUpdate(&pHalData->odmpriv , ODM_CMNINFO_RSSI_MIN, pdmpriv->MinUndecoratedPWDBForDM); 
  odm_RSSIMonitorCheck 
 3 ============================================================ 
 3 SW Antenna Diversity 
 3 ============================================================ 
 3 ============================================================ 
 3 Tx Power Tracking 
 3 ============================================================ 
 pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = true; 
  The index of "0 dB" in SwingTable. 
 at least delay 1 sec 
 3 Export Interface 
  20110921 MH Add to describe different team necessary resource allocate?? 
  20110920 MH This is the entry pointer for all team to execute HW out source DM. 
  You can not add any dummy function here, be care, you can only use DM structure 
  to perform any new ODM_DM. 
 For CE Platform(SPRD or Tablet) 
 8723A or 8189ES platform 
 NeilChen--2012--08--24-- 
 Fix Leave LPS issue 
  in LPS mode 
 (pDM_Odm->SupportICType & (ODM_RTL8723A))|| 
 (pDM_Odm->SupportICType & (ODM_RTL8188E) &&(&&(((pDM_Odm->SupportInterface  == ODM_ITRF_SDIO))) 
 odm_EdcaTurboCheck(pDM_Odm); 
 2010.05.30 LukeLee: For CE platform, files in IC subfolders may not be included to be compiled, 
  so compile flags must be left here to prevent from compile errors 
  Init .. Fixed HW value. Only init time. 
  This section is used for init value 
  Fixed ODM value. 
 To remove the compiler warning, must add an empty default statement to handle the other values. 
 do nothing 
  Hook call by reference pointer. 
  Dynamic call by reference pointer. 
 case ODM_CMNINFO_RTSTA_AID: 
 pDM_Odm->pAidMap =  (u8 )pValue; 
 break; 
 case ODM_CMNINFO_BT_COEXIST: 
 pDM_Odm->BTCoexist = (bool )pValue; 
 case ODM_CMNINFO_STA_STATUS: 
 pDM_Odm->pODM_StaInfo[] = (PSTA_INFO_T)pValue; 
 break; 
 case ODM_CMNINFO_PHY_STATUS: 
 pDM_Odm->pPhyInfo = (ODM_PHY_INFO )pValue; 
 break; 
 case ODM_CMNINFO_MAC_STATUS: 
 pDM_Odm->pMacInfo = (struct odm_mac_status_info )pValue; 
 break; 
 To remove the compiler warning, must add an empty default statement to handle the other values. 
 do nothing 
  Hook call by reference pointer. 
  Dynamic call by reference pointer. 
 To remove the compiler warning, must add an empty default statement to handle the other values. 
 do nothing 
  Update BandCHannel.. The values are dynamic but non-per-packet. 
  This init variable may be changed in run time. 
  The following is for BT HS mode and BT coexist mechanism. 
	case	ODM_CMNINFO_OP_MODE:
		pDM_Odm->OPMode = (u8)Value;
		break;
	case	ODM_CMNINFO_WM_MODE:
		pDM_Odm->WirelessMode = (u8)Value;
		break;
	case	ODM_CMNINFO_SEC_CHNL_OFFSET:
		pDM_Odm->SecChOffset = (u8)Value;
		break;
	case	ODM_CMNINFO_SEC_MODE:
		pDM_Odm->Security = (u8)Value;
		break;
	case	ODM_CMNINFO_BW:
		pDM_Odm->BandWidth = (u8)Value;
		break;
	case	ODM_CMNINFO_CHNL:
		pDM_Odm->Channel = (u8)Value;
		break;
 do nothing 
 3 ============================================================ 
 3 DIG 
 3 ============================================================ 
-----------------------------------------------------------------------------
  Function:	odm_DIGInit()
  Overview:	Set DIG scheme init value.
  Input:		NONE
  Output:		NONE
  Return:		NONE
  Revised History:
 When		Who		Remark
 ---------------------------------------------------------------------------
 Remove DIG by yuchen 
 Remove DIG and FA check by Yu Chen 
 3 ============================================================ 
 3 BB Power Save 
 3 ============================================================ 
 Remove BB power saving by Yuchen 
 3 ============================================================ 
 3 Dynamic Tx Power 
 3 ============================================================ 
 Remove BY YuChen 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  -33dB~0dB to 0%~99% 
 46  53 73 95 201301231630 
  46 53 77 99 201301241630 
 rx_pwr_all = -53+(2(31-VGA_idx)); 
		
		  (1)Hardware does not provide RSSI for CCK
		  (2)PWDB, Average PWDB calculated by
		     hardware (for rate adaptive)
		
		  2011.11.28 LukeLee: 88E use different LNA & VGA gain table
		  The RSSI formula should be modified according to the gain table
  (3) Get Signal Quality (EVM) 
 if (pPktinfo->bPacketMatchBSSID) 
 is OFDM rate 
		
		  (1)Get RSSI for HT rate
  20080130 MH we will judge RF RX path now. 
 else 
 continue; 
 Translate DBM to percentage. 
 Get Rx snr value in DB 
		
		  (2)PWDB, Average PWDB calculated by hardware (for rate adaptive)
		
		  (3)EVM of HT rate
		 
		  Only spatial stream 1 makes sense
		 
		  Do not use shift operation like "rx_evmX >>= 1"
		  because the compiler of free build environment
		  fill most significant bit to "zero" when doing
		  shifting operation which may change a negative
		  value to positive one, then the dbm value (which
		  is supposed to be negative) is not correct
		  anymore.
 dbm 
  Fill value in RFD, Get the first spatial stream only 
	
	  UI BSS List signal strength(in percentage), make it good
	  looking, from 0~100.
	  It is assigned to the BSS List in GetValueFromBeaconOrProbeRsp().
 Statistic for antennapath diversity------------------ 
 Smart Antenna Debug Message------------------ 
 ofdm rate 
 1 Process OFDM RSSI 
  initialize 
 1 Process CCK RSSI 
  initialize 
 if (pEntry) 
 2011.07.28 LukeLee: modified to prevent unstable CCK RSSI 
  Endianness before calling this API 
  If you want to add a new IC, Please follow below template and generate a new one. 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
 PHY parameters initialize for n series 
 0x894[31:16]= 0x2710	Time duration for NHM unit: 4us, 0x2710 =40ms 
 rtw_write16(pDM_Odm->Adapter, ODM_REG_NHM_TIMER_11N+2, 0x4e20);	0x894[31:16]= 0x4e20	Time duration for NHM unit: 4us, 0x4e20 =80ms 
 0x890[31:16]= 0xffff	th_9, th_10 
 rtw_write32(pDM_Odm->Adapter, ODM_REG_NHM_TH3_TO_TH0_11N, 0xffffff5c);	0x898 = 0xffffff5c		th_3, th_2, th_1, th_0 
 0x898 = 0xffffff52		th_3, th_2, th_1, th_0 
 0x89c = 0xffffffff		th_7, th_6, th_5, th_4 
 0xe28[7:0]= 0xff		th_8 
 0x890[9:8]=3			enable CCX 
 0xc0c[7]= 1			max power among all RX ants 
  Get NHM report 
  Reset NHM counter 
 u8 test_status; 
 struct false_ALARM_STATISTICS pFalseAlmCnt = &pDM_Odm->FalseAlmCnt; 
 Tx > 4Rx possible for adaptivity test 
 Enable EDCCA since it is possible running Adaptivity testing 
 test_status = 1; 
 test_status = 5; 
 test_status = 3; 
  TX<RX 
 test_status = 2; 
 test_status = 5; 
 test_status = 4; 
  find H2L, L2H lower bound 
  -7 
  stop counting if EDCCA is asserted 
 CHANNEL_WIDTH_20 
 Search pwdB lower bound 
  Band4 doesn't need adaptivity 
 replace lower bound to prevent EDCCA always equal  
 1 Check initial gain by upper bound 
 1 Set IGI value 
 1 Pause DIG 
 2 Disable DIG 
 2 Backup IGI value 
 2 Write new IGI value 
 1 Resume DIG 
 2 Write backup IGI value 
 2 Enable DIG 
 SupportAbility 
 SupportAbility 
 ScanInProcess 
 add by Neil Chen to avoid PSD is processing 
 To Initialize pDM_Odm->bDMInitialGainEnable == false to avoid DIG error 
 To Initi BT30 IGI 
  Common parameters 
 1 Update status 
 1 Boundary Decision 
 2 For WIN\CE 
 1 Adjust boundary by RSSI 
 2 Modify DIG upper bound 
 4 Modify DIG upper bound for 92E, 8723A\B, 8821 & 8812 BT 
 2 Modify DIG lower bound 
 if (pDM_Odm->bOneEntryOnly) 
 1 Force Lower Bound for AntDiv 
 1 Modify DIG lower bound, deal with abnormal case 
 2 Abnormal false alarm case 
 2 Abnormal lower bound case 
 1 False alarm threshold decision 
 1 Adjust initial gain by false alarm 
 1 Check initial gain by upperlower bound 
 1 Force upper bound and lower bound for adaptivity 
 1 Update status 
 ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue); 
  BT is not using 
 ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue); 
 0x1E or 0x1C 
  Using FW PS mode to make IGI 
 Adjust by  FA in LPS MODE 
 Lower bound checking 
 RSSI Lower bound check 
 Upper and Lower Bound checking 
 ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue); 
 3 ============================================================ 
 3 FASLE ALARM CHECK 
 3 ============================================================ 
 hold ofdm counter 
 hold page C counter 
 hold page D counter 
 hold cck counter 
  For NIC 
 if (pDM_DigTable->ForbiddenIGI < pDM_DigTable->CurIGValue) 
 pDM_DigTable->ForbiddenIGI = pDM_DigTable->CurIGValue; 
 DM_DIG_MIN) 
 DM_DIG_MIN; 
 DM_DIG_MIN; 
 3 ============================================================ 
 3 CCK Packet Detect Threshold 
 3 ============================================================ 
 modify by Guo.Mingzhi 2012-01-03 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
 defines 
  Global variables, these are static variables 
  local function start with halbtc8723b2ant_ 
 	Rx Aggregation related setting 
  decide BT control aggregation buf size or not 
  aggregation buf size, only work when BT control Rx aggregation size. 
  real update aggregation setting 
  trigger 
  work around for HS mode. 
  check if Sco only 
  check if A2dp only 
  check if Pan only 
  check if Hid only 
  There are several type of dacswing 
  0x18 0x10 0xc 0x8 0x4 0x6 
 Shrink RF Rx LPF corner 
 Resume RF Rx LPF corner 
  After initialized, we can use pCoexDm->btRf0x1eBackup 
  opCode, 0x6 = Retry_Penalty 
 normal rate except MCS765, OFDM544836 
 MCS7 or OFDM54 
 MCS6 or OFDM48 
 MCS5 or OFDM36 
 return; 
 BB AGC Gain Table 
 RF Gain 
  set rssiAdjustVal for wifi module. 
  function enable 
  [31:16]=fw ver, [15:0]=fw sub ver 
 Use H2C to set GNT_BT to LOW 
 WiFi TRx Mask off 
 BT TRx Mask off 
 tell firmware "no antenna inverse" 
 tell firmware "antenna inverse" 
 ext switch type 
 int switch type 
  ext switch setting 
  0x4c[23]= 0, 0x4c[24]= 1  Antenna control by WLBT 
  fixed internal switch S1->WiFi, S0->BT 
  ext switch main at wifi 
  ext switch aux at wifi 
  internal switch 
  0x4c[23]= 0, 0x4c[24]= 1  Antenna control by WLBT 
 fixed external switch S1->Main, S0->Aux 
  fixed internal switch S1->WiFi, S0->BT 
  fixed internal switch S0->WiFi, S1->BT 
  disable PS tdma 
  update pre state 
  fw all off 
  sw all off 
  hw all off 
 pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0); 
  force to reset coex mechanism 
 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration 
 acquire the BT TRx retry count from BT_Info byte2 
  no retry in the last 2-second duration 
  if 連續 n 個2秒 retry count為0, 則調寬WiFi duration 
  <=3 retry in the last 2-second duration 
  if 連續 2 個2秒 retry count< 3, 則調窄WiFi duration 
  避免一直在兩個level中來回 
 m 最大值 = 20 ' 最大120秒 recheck是否調整 WiFi duration. 
 retry count > 3, 只要1次 retry count > 3, 則調窄WiFi duration 
  避免一直在兩個level中來回 
 m 最大值 = 20 ' 最大120秒 recheck是否調整 WiFi duration. 
  if current PsTdma not match with the recorded one (when scan, dhcp...), 
  then we have to adjust it back to the previous record one. 
  SCO only or SCO+PAN(HS) 
 for SCO quality at 11bg mode 
 for SCO quality & wifi performance balance at 11n mode 
 for voice quality 
  sw mechanism 
 for HID at 11bg mode 
 for HID quality & wifi performance balance at 11n mode 
  sw mechanism 
 A2DP only  PAN(EDR) only A2DP+PAN(HS) 
  define the office environment 
  sw mechanism 
  sw mechanism 
  sw mechanism 
  sw mechanism 
 PAN(HS) only 
 PAN(EDR)+A2DP 
  sw mechanism 
  sw mechanism 
  HID+A2DP+PAN(EDR) 
  sw mechanism 
 btRssiState = halbtc8723b2ant_BtRssiState(2, 29, 0); 
  only 802.11N mode we have to dec bt power to 4 degree 
  need to check ap Number of Not 
  sw mechanism 
  set wlan_act to low 
 WiFi goto standby while GNT_BT 0-->1 
 Use H2C to set GNT_BT to HIGH 
 BT select s0s1 is controlled by BT 
 BT select s0s1 is controlled by WiFi 
  backup rf 0x1e value 
  0x790[5:0]= 0x5 
 Antenna config 
  PTA parameter 
  Enable counter statistics 
 0x76e[3] = 1, WLAN_Act control by PTA 
  work around function start with wa_halbtc8723b2ant_ 
  extern function start with EXhalbtc8723b2ant_ 
 Set BIT2 by default since it's 2ant case 
  enable BB, REG_SYS_FUNC_EN such that we can write 0x948 correctly. 
  set GRAN_BT = 1 
  set WLAN_ACT = 0 
  S0 or S1 setting and Local register setting(By the setting fw can get ant number, S0S1, ... info) 
  Local setting bit define 
 	BIT0: "0" for no antenna inverse; "1" for antenna inverse 
 	BIT1: "0" for internal switch; "1" for external switch 
 	BIT2: "0" for one antenna; "1" for two antenna 
  NOTE: here default all internal switch and 1-antenna ==> BIT1 = 0 and BIT2 = 0 
  fixed at S0 for USB interface 
  antenna inverse 
  for PCIE and SDIO interface, we check efuse 0xc3[6] 
  set to S1 
  set to S0 
  antenna inverse 
  only 2.4G we need to inform bt the chnl mask 
 [3:0] 
 BT into is responded by BT FW and BT RF REG 0x3C != 0x01 => Need to switch BT TRx Mask 
  Here we need to resend some wifi info to BT 
  because bt is reset and loss of the info. 
  BT already NOT ignore Wlan active, do nothing here. 
  check BIT2 first ==> check if bt is under inquiry or page scan 
  set link exist status 
  connection exists 
  connection exists but no busy 
 BT goto standby while GNT_BT 1-->0 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  _GLNA 
  _GPA 
  _ALNA 
  _APA 
  _BT 
  Value Defined Check =============== 
 QFN Type [15:12] and Cut Version [27:24] need to do value check 
  Bit Defined Check ================ 
  We don't care [31:28] and [23:20] 
  BoardType is DONTCARE 
 GLNA 
 GPA 
 ALNA 
 APA 
  BoardType of each RF path is matched 
                           RadioA.TXT
  This (offset, data) pair doesn't care the condition. 
  This line is the beginning of branch. 
  ELSE, ENDIF 
				  Condition isn't matched.
				   Discard the following (offset, data) pairs.
  prevent from for-loop += 2 
  Configure matched pairs and skip to end of if-else. 
  Keeps reading until ENDIF. 
                           TxPowerTrack_SDIO.TXT
                           TXPWR_LMT.TXT
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
 H2C Msg format :
| 31 - 8		|7-5	| 4 - 0	|
| h2c_msg	|Class	|CMD_ID	|
| 31-0						|
| Ext msg					|
 pay attention to if  race condition happened in  H2C cmd setting. 
 			(u8 )(&h2c_cmd) |= BIT(7); 
pmlmeext->mgnt_seq);
 pmlmeext->mgnt_seq++; 
 timestamp will be inserted by hardware 
  beacon interval: 2 bytes 
  capability info: 2 bytes 
 below for ad-hoc mode 
  SSID 
  supported rates... 
  DS parameter set 
  IBSS Parameter Set... 
 ATIMWindow = cur->configuration.ATIMWindow; 
 todo: ERP IE 
  EXTERNDED SUPPORTED RATE 
 todo:HT for adhoc 
  Frame control. 
  AID. 
  BSSID. 
  TA. 
  To check if reserved page content is destroyed by beacon because beacon
  is too large.
 2010.06.23. Added by tynli. 
 DTIM = (awake_intvl - 1) 
 DTIM =2 
  Keep awake interval to 1 to prevent from 
  decreasing coex performance 
  AllON(0x0C), RFON(0x04), RFOFF(0x00) 
  AllON(0x0C), RFON(0x04), RFOFF(0x00) 
 byte 6 for adaptive_early_32k 
 0:3] = DrvBcnEarly  (ms) , [4:7] = DrvBcnTimeOut  (ms) 
  20% for DrvBcnEarly, 80% for DrvBcnTimeOut 
 reset adaptive_early_32k cnt 
 offload to FW if fw version > v15.10
		pmlmeext->DrvBcnEarly = 0;
		pmlmeext->DrvBcnTimeOut =7;
		if ((pmlmeext->DrvBcnEarly!= 0Xff) && (pmlmeext->DrvBcnTimeOut!= 0xff))
			u1H2CPwrModeParm[H2C_PWRMODE_LEN-1] = BIT(0) | ((pmlmeext->DrvBcnEarly<<1)&0x0E) |((pmlmeext->DrvBcnTimeOut<<4)&0xf0) ;
 10  100  awakeinterval (ms) 
 ms wait broadcast data timer 
 ms Keep awake when tx 
  Description: Fill the reserved packets that FW will use to RSVD page.
  Now we just send 4 types packet to rsvd page.
  (1)Beacon, (2)Ps-poll, (3)Null data, (4)ProbeRsp.
  Input:
  bDLFinished - false: At the first time we will send all the packets as
  a large packet to Hw, so we need to set the packet length to total length.
  true: At the second time, we should send the first packet (default:beacon)
  to Hw again and set the length in descriptor to the real beacon length.
 2009.10.15 by tynli. 
 3 (1) beacon 
  When we count the first page size, we need to reserve description size for the RSVD 
  packet, it will be filled in front of the packet in TXPKTBUF. 
 If we don't add 1 more page, the WOWLAN function has a problem. Baron thinks it's a bug of firmware 
 3 (2) ps-poll 
 3 (3) null data 
 3 (5) Qos null data 
 3 (6) BT Qos null data 
  update attribute 
  We should set AID, correct TSF, HW seq enable before set JoinBssReport to Fw in 8892C. 
  Suggested by filen. Added by tynli. 
  set REG_CR bit 8 
  ENSWBCN 
  Disable Hw protection for a time which revserd for Hw sending beacon. 
  Fix download reserved page packet fail that access collision with the protection time. 
  2010.05.11. Added by tynli. 
  Set FWHW_TXQ_CTRL 0x422[6]= 0 to tell Hw the packet is not a real beacon frame. 
  To tell Hw the packet is not a real beacon frame. 
  Clear beacon valid check bit. 
  download rsvd page. 
 mdelay(10); 
  check rsvd page download OK. 
  2010.05.11. Added by tynli. 
  To make sure that if there exists an adapter which would like to send beacon. 
  If exists, the origianl value of 0x422[6] will be 1, we should check this to 
  prevent from setting 0x422[6] to 0 after download reserved page, or it will cause 
  the beacon cannot be sent by HW. 
  2010.06.23. Added by tynli. 
  Clear CR[8] or beacon packet will not be send to TxBuf anymore. 
  ~ENSWBCN 
 arg[0] = macid 
 arg[1] = raid 
 arg[2] = shortGIrate 
 arg[3] = init_rate 
 3 (1) beacon 
  When we count the first page size, we need to reserve description size for the RSVD 
  packet, it will be filled in front of the packet in TXPKTBUF. 
 If we don't add 1 more page, the WOWLAN function has a problem. Baron thinks it's a bug of firmware 
  Jump to lastest page 
 3 (6) BT Qos null data 
  update attribute 
  We should set AID, correct TSF, HW seq enable before set JoinBssReport to Fw in 8892C. 
  Suggested by filen. Added by tynli. 
  set REG_CR bit 8 
  ENSWBCN 
  Disable Hw protection for a time which revserd for Hw sending beacon. 
  Fix download reserved page packet fail that access collision with the protection time. 
  2010.05.11. Added by tynli. 
  Set FWHW_TXQ_CTRL 0x422[6]= 0 to tell Hw the packet is not a real beacon frame. 
  To tell Hw the packet is not a real beacon frame. 
  Clear beacon valid check bit. 
 			mdelay(10); 
  check rsvd page download OK. 
  2010.05.11. Added by tynli. 
  To make sure that if there exists an adapter which would like to send beacon. 
  If exists, the origianl value of 0x422[6] will be 1, we should check this to 
  prevent from setting 0x422[6] to 0 after download reserved page, or it will cause 
  the beacon cannot be sent by HW. 
  2010.06.23. Added by tynli. 
  Clear CR[8] or beacon packet will not be send to TxBuf anymore. 
  ~ENSWBCN 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
++
Copyright (c) Realtek Semiconductor Corp. All rights reserved.
Module Name:
	HalPwrSeqCmd.c
Abstract:
	Implement HW Power sequence configuration CMD handling routine for Realtek devices.
Major Change History:
	When       Who               What
	---------- ---------------   -------------------------------
	2011-10-26 Lucas            Modify to be compatible with SD4-CE driver.
	2011-07-07 Roger            Create.
  Description: 
  This routine deal with the Power Configuration CMDs parsing for RTL8723RTL8188E Series IC. 
  Assumption: 
  We should follow specific format which was released from HW SD. 
  2011.07.07, added by Roger. 
  polling autoload done. 
 2 Only Handle the command whose FAB, CUT, and Interface are matched 
  <Roger_Notes> We should deal with interface specific address mapping for some interfaces, e.g., SDIO interface 
  2011.07.07. 
  Read Back SDIO Local value 
  Write Back SDIO Local value 
  Read the value from system register 
  Write the value back to system register 
  When this command is parsed, end the process 
 Add Array Index 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
 for (i = 0; i<MAX_RX_NUMBLKS; i++) 
 _rtw_init_queue(&psta_recvpriv->blk_strms[i]); 
 precvpriv->precv_frame_buf = precvpriv->pallocated_frame_buf + RXFRAME_ALIGN_SZ - 
 ((SIZE_PTR) (precvpriv->pallocated_frame_buf) &(RXFRAME_ALIGN_SZ-1)); 
 ms 
 INIT_LIST_HEAD(&(precvframe->u.hdr.list)); 
 _spinlock(&pfree_recv_queue->lock); 
 spin_unlock(&pfree_recv_queue->lock); 
signed int	rtw_enqueue_recvframe(union recv_frame precvframe, struct __queue queue)
{
	return rtw_free_recvframe(precvframe, queue);
}
caller : defrag ; recvframe_chk_defrag in recv_thread  (passive)
pframequeue: defrag_queue : will be accessed in recv_thread  (passive)
using spinlock to protect
 u8 iv, rxdata_key_idx = 0; 
 calculate mic code 
 mickey =&psecuritypriv->dot118021XGrprxmickey.skey[0]; 
 iv = precvframe->u.hdr.rx_data+prxattrib->hdrlen; 
 rxdata_key_idx =(((iv[3])>>6)&0x3) ; 
 psecuritypriv->dot118021XGrpKeyid, pmlmeinfo->key_index, rxdata_key_idx); 
 icv_len included the mic code 
 care the length of the data 
  double check key_index for some timing issue , 
  cannot compare with psecuritypriv->dot118021XGrpKeyid also cause timing issue 
 mic checked ok 
 decrypt and set the ivlen, icvlen of the recv_frame 
 set the security information in the recv_frame 
 for Funia BD's WPA issue 
 blocked 
 only accept EAPOL frame 
 get ether_type 
 free this frame 
 allowed 
 check decryption status, and decrypt the frame if needed 
 check is the EAPOL frame or not (Rekey) 
 if (ether_type == eapol_type) { 
 check Rekey 
 prtnframe =precv_frame; 
 else { 
 if (bretry) 
 psta->state |= WIFI_SLEEP_STATE; 
 pstapriv->sta_dz_bitmap |= BIT(psta->aid); 
 psta->state ^= WIFI_SLEEP_STATE; 
 pstapriv->sta_dz_bitmap &= ~BIT(psta->aid); 
 process received triggered frame 
 issue one qos null frame with More data bit = 0 and the EOSP bit set (= 1) 
  filter packets that SA is myself or multicast or broadcast 
  For Station mode, sa and bssid should always be BSSID, and DA is my mac-address 
  For AP mode, if DA == MCAST, then BSSID should be also MCAST 
  not mc-frame 
  For AP mode, if DA is non-MCAST, then it must be BSSID, and bssid == BSSID 
  get ap_info 
  filter packets that SA is myself or multicast or broadcast 
  da should be for me 
  check BSSID 
  get ap_info 
 No data, will not indicate to upper layer, temporily count it here 
  get sta_info 
 Special case 
  get sta_info 
 for AP multicast issue , modify by yiwei 
 For AP mode, RA =BSSID, TX =STA(SRC_ADDR), A3 =DST_ADDR 
 No data, will not indicate to upper layer, temporily count it here 
 uint len = precv_frame->u.hdr.len; 
 receive the frames that ra(a1) is my address 
 for rx pkt statistics 
 only handle ps-poll 
 update BCN for TIM IE 
 update_BCNTIM(padapter); 
 issue nulldata with More data bit = 0 to indicate we have no buffered packets 
 update BCN for TIM IE 
 update_BCNTIM(padapter); 
 perform defrag 
 the first fragment number must be 0 
 free the whole queue 
 check the fragment sequence  (2nd ~n fragment frame) 
 the fragment number must be increasing  (after decache) 
 release the defrag_q & prframe 
 copy the 2nd~n fragment frame's payload to the first fragment 
 get the 2nd~last fragment frame's payload 
 append  to first fragment frame's tail (if privacy frame, pull the ICV) 
 memcpy 
 free the defrag_q queue and return the prframe 
 check if need to defrag, if needed queue the frame to defrag_q 
 need to define struct of wlan header frame ctrl 
 isn't a fragment frame 
 0~(n-1) fragment frame 
 enqueue to defraf_g 
 the first fragment 
 free current defrag_q 
 Then enqueue the 0~(n-1) fragment into the defrag_q 
 spin_lock(&pdefrag_q->lock); 
 spin_unlock(&pdefrag_q->lock); 
 can't find this ta's defrag_queue, so free this recv_frame 
 the last fragment frame 
 enqueue the last fragment 
 spin_lock(&pdefrag_q->lock); 
 spin_unlock(&pdefrag_q->lock); 
 call recvframe_defrag to defrag 
 can't find this ta's defrag_queue, so free this recv_frame 
 after defrag we must check tkip mic code 
 struct mlme_priv pmlmepriv = &adapter->mlmepriv; 
 for rx pkt statistics 
 psta->rssi = prxcmd->rssi; 
 psta->signal_quality = prxcmd->sq; 
 parsing QC field 
 HT-CTRL 11n 
  decache, drop duplicate recv packets 
 bit(7)~bit(2) 
 only support station mode 
 unicast management frame decrypt 
 set iv and icv length 
 actual management data frame body 
 save actual management data frame body 
 overwrite the iv field 
 remove the iv and icv length 
 verify BIP MME IE of broadcastmulticast de-authdisassoc packet 
 issue sa query request 
 802.11w protect 
 according 802.11-2012 standard, these five types are not robust types 
 issue sa query request 
 shall check frame subtype, to  from ds, da, bssid 
 then call check if rx seqfrag. duplicated. 
 add version chk 
 bit(7)~bit(2) 
 mgnt 
  only data frame return _SUCCESS 
 ctrl 
  only data frame return _SUCCESS 
 data 
  dump eapol 
  get ether_type 
 remove the wlanhdr and add the eth_hdr 
  point to frame_ctrl field 
 convert hdr + possible LLC headers into Ethernet header 
 eth_type = (psnap_type[0] << 8) | psnap_type[1]; 
 eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) || 
 remove RFC1042 or Bridge-Tunnel encapsulation and replace EtherType 
 Leave Ethernet header part of hdr and full payload 
 pattrib->ether_type 
  append rx status for mp test packets 
 Offset 12 denote 2 mac address 
 move the data point to data content 
 Indicate the packets to upper layer 
 free this recv_frame 
  4096; 
  Rx Reorder initialize condition. 
  Drop out the packet which SeqNum is smaller than WinStart 
  Sliding window manipulation. Conditions includes: 
  1. Incoming SeqNum is equal to WinStart =>Window shift 1 
  2. Incoming SeqNum is larger than the WinEnd => Window shift N 
  boundary situation, when seq_num cross 0xFFF 
 spin_lock_irqsave(&ppending_recvframe_queue->lock, irql); 
 spin_lock(&ppending_recvframe_queue->lock); 
 Duplicate entry is found!! Do not insert current entry. 
 spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql); 
 spin_lock_irqsave(&ppending_recvframe_queue->lock, irql); 
 spin_lock(&ppending_recvframe_queue->lock); 
 spin_unlock(&ppending_recvframe_queue->lock); 
 spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql); 
 u8 index = 0; 
 spin_lock_irqsave(&ppending_recvframe_queue->lock, irql); 
 spin_lock(&ppending_recvframe_queue->lock); 
  Handling some condition for forced indicate case. 
  spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql); 
 spin_unlock(&ppending_recvframe_queue->lock); 
  Prepare indication list and indication. 
  Check if there is any packet need indicate. 
 Set this as a lock to make sure that only one thread is indicating packet. 
 pTS->RxIndicateState = RXTS_INDICATE_PROCESSING; 
  Indicate packets 
 indicate this recv_frame 
 indicate this recv_frame 
 error condition; 
 Update local variables. 
 spin_unlock(&ppending_recvframe_queue->lock); 
 spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql); 
 s1. 
 indicate this recv_frame 
 temp filter -> means didn't support A-MSDUs in a A-MPDU 
 s2. check if winstart_b(indicate_seq) needs to been updated 
 s3. Insert all packet into Reorder Queue to maintain its ordering. 
 spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql); 
 return _FAIL; 
 s4. 
  Indication process. 
  After Packet dropping and Sliding Window shifting as above, we can now just indicate the packets 
  with the SeqNum smaller than latest WinStart and buffer other packets. 
  For Rx Reorder condition: 
  1. All packets with SeqNum smaller than WinStart => Indicate 
  2. All packets with SeqNum larger than or equal to WinStart => Buffer it. 
 recv_indicatepkts_in_order(padapter, preorder_ctrl, true); 
 struct recv_priv precvpriv = &padapter->recvpriv; 
 struct rx_pkt_attrib pattrib = &prframe->u.hdr.attrib; 
 BGN Mode 
 prframe->u.hdr.preorder_ctrl = &precvpriv->recvreorder_ctrl[pattrib->priority]; 
  including perform A-MPDU Rx Ordering Buffer Control 
 BG mode 
 indicate this recv_frame 
 check the frame crtl field and decache 
 free this recv_frame 
 free this recv_frame 
 check if need to handle uc_swdec_pending_queue
 check if need to enqueue into uc_swdec_pending_queue
 to prevent from recvframe starvation, get recvframe from uc_swdec_pending_queue to free_recvframe_cnt  
  this value is based on converging_constant = 5000 and sampling_interval = 1000 
 update the user specific value, signal_strength_dbg, to signal_strength, rssi 
  update_req is clear, means we got rx 
  after avg_vals are acquired, we can re-stat the signal values 
  update_req is clear, means we got rx 
  after avg_vals are acquired, we can re-stat the signal values 
 update value of signal_strength, rssi, signal_qual 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
  syn ips_mode with request 
 consider buddy, if exist 
  ATTENTION:
 rtw_ps_processor() doesn't handle LPS.
 system suspend or autosuspend 
 from tx 
  2 sec == watch dog timer 
  from rx path 
2) {
 rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_LEAVE, 1); 
  Description:
 This function MUST be called under power lock protect
  Parameters
 padapter
 pslv			power state level, only could be PS_STATE_S0 ~ PS_STATE_S4
  only when from PS_STATE S0S1 to S2 and higher needs ACK 
  No LPS 32K, No Ack 
  polling cpwm 
 if (pwrpriv->pwr_mode == PS_MODE_ACTIVE) 
  Return:
 0:	Leave OK
 -1:	Timeout
 -2:	Other error
 	Description: 
 		Enter the leisure power save mode. 
 Skip lps enter request if number of assocated adapters is not 1 
 Skip lps enter request for adapter not port0 
  Idle for a while if we connect to AP a while ago. 
   4 Sec 
 	Description: 
 		Leave the leisure power save mode. 
 connect 
  Description: Leave all power save mode: LPS, FwLPS, IPS if needed. 
  Move code to function by tynli. 2010.03.26. 
 connect 
  Caller:ISR handler...
  This will be called when CPWM interrupt is up.
  using to update cpwn of drv; and drv willl make a decision to up or down pwr level
  This function is a timer handler, can't do any IO in it.
  Description:
 Check if the fw_pwrstate is okay for IO.
 If not (cpwm is less than S2), then the sub-routine
 will raise the cpwm to be greater than or equal to S2.
 Calling Context: Passive
 Constraint:
 	1. this function will request pwrctrl->lock
  Return Value:
 _SUCCESS	hardware is ready for IO
 _FAIL		can't IO right now
  Description:
 If task is done, call this func. to power down firmware again.
 Constraint:
 	1. this function will request pwrctrl->lock
  Return Value:
 none
  Caller: rtw_xmit_thread
  Check if the fw_pwrstate is okay for xmit.
  If not (cpwm is less than S3), then the sub-routine
  will raise the cpwm to be greater than or equal to S3.
  Calling Context: Passive
  Return Value:
  _SUCCESS	rtw_xmit_thread can write fifotxcmd afterwards.
  _FAIL		rtw_xmit_thread can not do anything.
  Caller: rtw_cmd_thread
  Check if the fw_pwrstate is okay for issuing cmd.
  If not (cpwm should be is less than S2), then the sub-routine
  will raise the cpwm to be greater than or equal to S2.
  Calling Context: Passive
  Return Value:
 _SUCCESS	rtw_cmd_thread can issue cmds to firmware afterwards.
 _FAIL		rtw_cmd_thread can not do anything.
  Caller: ISR
  If ISR's txdone,
  No more pkts for TX,
  Then driver shall call this fun. to power down firmware again.
  Caller: ISR
  If all commands have been done,
  and no more command to do,
  then driver shall call this fun. to power down firmware again.
  PS_MODE_MIN; 
 rtw_pwr_wakeup - Wake the NIC up from: 1)IPS. 2)USB autosuspend
 @adapter: pointer to struct adapter structure
 @ips_deffer_ms: the ms will prevent from falling into IPS after wakeup
 Return _SUCCESS or _FAIL
 for LPS 
 IPS still bound with primary adapter 
 System suspend is not allowed to wakeup 
 block??? 
 I think this should be check in IPS, LPS, autosuspend functions... 
 TODO: the following checking need to be merged... 
  ATTENTION:
 This function will request pwrctrl LOCK!
  ATTENTION:
 This function will request pwrctrl LOCK!
  ATTENTION:
 Before calling this function pwrctrl lock should be occupied already,
 otherwise it may return incorrect value.
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  Must sync with rtw_wdev_alloc() 
  wdev->iftype = NL80211_IFTYPE_STATION 
  1: active, 0: pasive. Maybe someday we should rename this varable to "active_mode" (Jeff) 
 allocate DMA-ableNon-Page memory for cmd_buf and rsp_buf 
struct	wlan_network _rtw_dequeue_network(struct __queue queue)
{
	_irqL irqL;
	struct wlan_network pnetwork;
	spin_lock_bh(&queue->lock);
	if (list_empty(&queue->queue))
		pnetwork = NULL;
	else
	{
		pnetwork = container_of(get_next(&queue->queue), struct wlan_network, list);
		list_del_init(&(pnetwork->list));
	}
	spin_unlock_bh(&queue->lock);
	return pnetwork;
}
 	_irqL irqL; 
  unit:msec 
 spin_lock_irqsave(&free_queue->lock, irqL); 
 spin_unlock_irqrestore(&free_queue->lock, irqL); 
	return the wlan_network with the matching addr
	Shall be called under atomic context... to avoid possible racing condition...
 spin_lock_bh(&scanned_queue->lock); 
 spin_unlock_bh(&scanned_queue->lock); 
 in ad-hoc mode bit1 must set to 1 
 p[0]; 
 p[1]; 
 p[2]; 
static struct	wlan_network rtw_dequeue_network(struct __queue queue)
{
	struct wlan_network pnetwork;
	pnetwork = _rtw_dequeue_network(queue);
	return pnetwork;
}
	return the wlan_network with the matching addr
	Shall be called under atomic context... to avoid possible racing condition...
 	(src->configuration.ds_config == dst->configuration.ds_config) && 
 The rule below is 15 for sample value, 45 for history value 
 Take the recvpriv's value for the connected AP
 the rssi value here is undecorated, and will be used for antenna diversity 
 from the right channel 
 from the right channel 
 bss info not receiving from the right channel, use the original RX signal infos 
 if (pmlmepriv->cur_network.network.ie_length<= pnetwork->ie_length) 
Caller must hold pmlmepriv->lock first.
 TODO: don't select network in the same ess as oldest if it's new enough
	 If we didn't find a match, then get a new network slot to initialize
 if (phead == plist) { 
 If there are no more slots, expire the oldest 
 list_del_init(&oldest->list); 
  variable initialize 
 bss info not receiving from the right channel 
 Otherwise just pull from the free list 
  will update scan_time 
 bss info not receiving from the right channel 
		 we have an entry and we are going to update it. But this entry may
		  be already expired. In this case we do the same as we found a new
		  net and call the new_net handler
 target.reserved[0]== 1, means that scanned network is a bcn frame. 
  probe resp(3) > beacon(1) > probe req(2) 
 struct __queue	queue	= &(pmlmepriv->scanned_queue); 
 spin_lock_bh(&queue->lock); 
 spin_unlock_bh(&queue->lock); 
 select the desired network based on the capability of the (i)bss. 
  check items: (1) security 
 			   (2) network_type 
 			   (3) WMM 
 			   (4) HT 
                      (5) others 
 u8 wps_ie[512]; 
 for  correct flow of 8021X  to do.... 
 TODO: Perry : For Power Management 
  update IBSS_network 's timestamp 
  lock pmlmepriv->lock when you accessing network_q 
 pmlmepriv->fw_state ^= _FW_UNDER_SURVEY;because don't set assoc_timer 
 there is no need to wait for join 
rtw_free_assoc_resources: the caller has to lock pmlmepriv->lock
rtw_indicate_connect: the caller has to lock pmlmepriv->lock
rtw_indicate_disconnect: the caller has to lock pmlmepriv->lock
 set ips_deny_time to avoid enter IPS before LPS leave 
 update ptarget_sta 
 update station supportRate 
 sta mode 
 security related 
 	Commented by Albert 20120721 
 	When doing the WPS, the wps_ie_len won't equal to 0 
 	And the Wi-Fi driver shouldn't allow the data packet to be transmitted. 
 for A-MPDU Rx reordering buffer control for bmc_sta & sta_info 
 if A-MPDU Rx is enabled, resetting  rx_ordering_ctrl wstart_b(indicate_seq) to default value = 0xffff 
 todo: check if AP can send A-MPDU packets 
 preorder_ctrl = &precvpriv->recvreorder_ctrl[i]; 
 max_ampdu_sz;ex. 32(kbytes) -> wsize_b =32 
 preorder_ctrl = &precvpriv->recvreorder_ctrl[i]; 
 max_ampdu_sz;ex. 32(kbytes) -> wsize_b =32 
 pnetwork : returns from rtw_joinbss_event_callback 
 ptarget_wlan: found from scanned_queue 
  why not use ptarget_wlan?? 
  some ies in pnetwork is wrong, so we should use ptarget_wlan ies 
 the ptarget_wlan->network.rssi is raw data, we use ptarget_wlan->network.phy_info.signal_strength instead (has scaled) 
 update fw_state will clr _FW_UNDER_LINKING here indirectly 
 Notes: the function could be > passive_level (the same context as Rx tasklet) 
 pnetwork : returns from rtw_joinbss_event_callback 
 ptarget_wlan: found from scanned_queue 
 if join_res > 0, for (fw_state ==WIFI_STATION_STATE), we check if  "ptarget_sta" & "ptarget_wlan" exist. 
 if join_res > 0, for (fw_state ==WIFI_ADHOC_STATE), we only check if "ptarget_wlan" exist. 
 if join_res > 0, update "cur_network->network" from "pnetwork->network" if (ptarget_wlan != NULL). 
 define REJOIN 
 s1. find ptarget_wlan 
 s2. update cur_network 
 s3. find ptarget_sta & update ptarget_sta after update cur_network only for station mode 
 s4. indicate connect 
 s5. Cancel assoc_timer 
 rtw_free_assoc_resources(adapter, 1); 
 if join_res < 0 (join fails), then try again 
 extend time of assoc_timer 
 there is no need to wait for join 
 rtw_free_assoc_resources(adapter, 1); 
 FOR STA, AP , AD-HOC mode 
   MACID|OPMODE:1 connect 
 report to upper layer 
 for AD-HOC mode 
 the sta have been in sta_info_queue => do nothing 
 between drv has received this event before and  fw have not yet to set key to CAM_ENTRY) 
 to do : init sta_info variable 
 psta->aid = (uint)pstassoc->cam_id; 
 for ad-hoc mode 
  a sta + bcmc_stainfo (not Ibss_stainfo) 
   MACID|OPMODE:0 means disconnect 
 for STA, AP, ADHOC mode, report disconnect stauts to FW 
 if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) 
 this stadel_event is caused by roaming, decrease to_roam 
  remove the network entry in scanned_queue 
 a sta + bcmc_stainfo (not Ibss_stainfo) 
 rtw_indicate_disconnect(adapter);removed@20091105 
 free old ibss network 
 pwlan = rtw_find_network(&pmlmepriv->scanned_queue, pstadel->macaddr); 
 re-create ibss 
 _rtw_join_timeout_handler - Timeoutfailure handler for CMD JoinBss
 @adapter: pointer to struct adapter structure
 join timeout caused by roaming 
 try another 
 indicate disconnect for the case that join_timeout and check_fwstate != FW_LINKED 
 rtw_scan_timeout_handler - TimeoutFailure handler for CMD SiteSurvey
 @adapter: pointer to struct adapter structure
 disable auto scan when connect to 11AC AP 
 disabled 
 rtw_lps_ctrl_wk_cmd(adapter, LPS_CTRL_ENTER, 1); 
 call rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_LEAVE, 1) in traffic_status_watchdog() 
 auto site survey 
 Select a new roaming candidate from the original @param candidate and @param competitor
 @return true: candidate is updated
 @return false: candidate is not updated
 got specific addr to roam 
 Select a new join candidate from the original @param candidate and @param competitor
 @return true: candidate is updated
 @return false: candidate is not updated
 check bssid, if needed 
 check ssid, if needed 
Calling context:
The caller of the sub-routine will be in critical section...
The caller must hold the following spinlock
pmlmepriv->lock
  check for situation of  _FW_LINKED 
 try again 
 0~3 
 try again 
 adjust ies for rtw_joinbss_cmd in WMM 
 after the fixed IE 
 WMM element ID and OUI 
  to the next IE element 
  Ported from 8185: IsInPreAuthKeyList(). (Renamed from SecIsInPreAuthKeyList(), 2006-10-13.) 
  Added by Annie, 2006-05-07. 
  Search by BSSID, 
  Return Value: 
 		-1		:if there is no pre-auth key in the  table 
 		>= 0		:if there is pre-auth key, and   return the entry id 
 continue; 
  Could not find. 
  There is one Pre-Authentication Key for the specific BSSID. 
  Check the RSN IE length 
  If the RSN IE length <= 20, the RSN IE didn't include the PMKID information 
  0-11th element in the array are the fixed IE 
  12th element in the array is the IE 
  13th element in the array is the IE length 
  The RSN IE didn't include the PMK ID, append the PMK information 
 PMKID count = 0x0100 
 PMKID length = 2+16 
 copy fixed ie only 
 copy RSN or SSN 
		 debug for CONFIG_IEEE80211W
		{
			int jj;
			printk("supplicant_ie_length =%d &&&&&&&&&&&&&&&&&&&\n", psecuritypriv->supplicant_ie[1]+2);
			for (jj = 0; jj < psecuritypriv->supplicant_ie[1]+2; jj++)
				printk(" %02x ", psecuritypriv->supplicant_ie[jj]);
			printk("\n");
 struct	xmit_priv pxmitpriv = &adapter->xmitpriv; 
  adhoc no 802.1x 
  TODO 
  1. Supported rates 
  2. IE 
 rtw_set_supported_rate(pdev_network->supported_rates, pregistrypriv->wireless_mode) ;  will be called in rtw_generate_ie 
 notes: translate ie_length & length after assign the length to cmdsz in createbss_cmd(); 
 pdev_network->ie_length = cpu_to_le32(sz); 
 the function is at passive_level 
 todo: if you want to do something ioreghw setting before join_bss, please add code here 
 reset to disabled 
  TH = 1 => means that invalidate usb rx aggregation 
  TH = 0 => means that validate usb rx aggregation, use init value. 
  LDPC support 
  STBC 
  Beamforming setting 
 the function is >= passive_level 
 Get HT BW 
 TDLS: TODO 2040 issue 
 TDLS: TODO 40? 
 to disable 40M Hz support while gd_bw_40MHz_en = 0 
 todo: disable SM power save mode 
 enable for 2.4GHz 
 fill default supported_mcs_set 
 update default supported_mcs_set 
 RX STBC One spatial stream 
 rtw_hal_get_def_var(padapter, HW_VAR_MAX_RX_AMPDU_FACTOR, &max_rx_ampdu_factor); 
 the function is > passive_level (in critical_section) 
 struct sta_info bmc_sta, psta; 
 struct recv_reorder_ctrl preorder_ctrl; 
 struct recv_priv precvpriv = &padapter->recvpriv; 
 struct wlan_network pcur_network = &(pmlmepriv->cur_network);; 
 maybe needs check if ap supports rx ampdu. 
 check Max Rx A-MPDU Size 
  max_ampdu_sz (kbytes); 
 todo: 
 update cur_bwmode & cur_ch_offset 
 update the MCS set 
 update the MCS rates 
 switch to the 40M Hz mode according to the AP 
 pmlmeext->cur_bwmode = CHANNEL_WIDTH_40; 
  Config SM Power Save setting 
  Config current HT Protection mode. 
 if (bmcst || (padapter->mlmepriv.LinkDetectInfo.bTxBusyTraffic == false)) 
 Station mode 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2013 Realtek Corporation. All rights reserved.
  ================================================== 
  Below Functions are called by BT-Coex 
  ================================================== 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
 INIT_LIST_HEAD(&psta->asoc_list); 
 INIT_LIST_HEAD(&psta->sleep_list); 
 INIT_LIST_HEAD(&psta->wakeup_list); 
 _rtw_init_queue(&pstapriv->asoc_q); 
  32 = 6 sec 
  32 = 6 sec 
  this function is used to free the memory of lock || sema for all stainfos 
 be done before free sta_hash_lock 
delete all reordering_ctrl_timer		
===============================
 struct	sta_info rtw_alloc_stainfo(_queue pfree_sta_queue, unsigned char hwaddr) 
 spin_lock_bh(&(pfree_sta_queue->lock)); 
 spin_unlock_bh(&(pfree_sta_queue->lock)); 
 spin_unlock_bh(&(pfree_sta_queue->lock)); 
 spin_lock_bh(&(pstapriv->sta_hash_lock)); 
 spin_unlock_bh(&(pstapriv->sta_hash_lock)); 
  Commented by Albert 20090813 
  For the SMC router, the sequence number of first packet of WPS handshake will be 0. 
  In this case, this packet will be dropped by recv_decache function if we use the 0x00 as the default value for tid_rxseq variable. 
  So, we initialize the tid_rxseq variable as the 0xffff. 
 for A-MPDU Rx reordering buffer control 
 preorder_ctrl->wsize_b = (NR_RECVBUFF-2); 
 64; 
 init for DM 
 init for the sequence number of received management frame 
 alloc mac id for non-bcmc station, 
 list_del_init(&psta->sleep_list); 
 list_del_init(&psta->wakeup_list); 
 vo 
 vi 
 be 
 bk 
  re-init sta_info; 20061114 will be init in alloc_stainfo 
 _rtw_init_sta_xmit_priv(&psta->sta_xmitpriv); 
 _rtw_init_sta_recv_priv(&psta->sta_recvpriv); 
 for A-MPDU Rx reordering buffer control, cancel reordering_ctrl_timer 
 release mac id for non-bcmc station, 
	spin_lock_bh(&pstapriv->asoc_list_lock);
	list_del_init(&psta->asoc_list);
	spin_unlock_bh(&pstapriv->asoc_list_lock);
 spin_lock_bh(&(pfree_sta_queue->lock)); 
 spin_unlock_bh(&(pfree_sta_queue->lock)); 
  free all stainfo which in sta_hash[all] 
 any station allocated can be searched by hash list 
  if found the matched address 
 struct __queue	pstapending = &padapter->xmitpriv.bm_pending; 
  default broadcast & multicast use macid 1 
 accept unless in deny list 
 deny unless in accept list 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
	
	  Please insert all the queue initializaiton using _rtw_init_queue below
	
	  Please allocate memory with the sz = (struct xmit_frame)  NR_XMITFRAME,
	  and initialize free_xmit_frame below.
	  Please also apply  free_txobj to link_up all the xmit_frames...
 init xmit_buf 
 Tx buf allocation may fail sometimes, so sleep and retry. 
 init xframe_ext queue,  the same count as extbuf  
  Init xmit extension buff 
 free xframe_ext queue,  the same count as extbuf  
  free xmit extension buff 
 struct sta_info psta = pattrib->psta; 
 no frag 
  (1) RTS_Threshold is compared to the MPDU, not MSDU. 
  (2) If there are more than one frag in  this MSDU, only the first frag uses protection frame. 
 Other fragments are protected by previous fragment. 
 So we only need to check the length of first fragment. 
 IOT action 
 check ERP protection 
 check HT op mode 
 check rts 
 to do list: check MIMO power save condition. 
 check AMPDU aggregation for TXOP 
 for debug : force driver control vrtl_carrier_sense. 
 qos_en, ht_en, init rate, , bw, ch_offset, sgi 
 driver control AMPDU Density for peer sta's rx 
 For WPS 1.0 WEP, driver should not encrypt EAPOL Packet for WPS handshake. 
  get UserPriority from IP hdr 
  The following is for DHCP and ARP packet, we use cck1M to tx these packets and let LPS awake some time 
  to prevent DHCP protocol fail 
 MINIMUM_DHCP_PACKET_SIZE) { 
  IP header 
  68 : UDP BOOTP client 
  67 : UDP BOOTP server 
 for parsing ICMP pakcets 
  protocol type in ip header 0x1 is ICMP 
  If EAPOL , ARP , OR DHCP packet, driver must be in active mode. 
  get sta_info 
  if we cannot get psta => drop the pkt 
  if we cannot get psta => drop the pkt 
 TODO:_lock 
 TODO:_unlock 
  get ether_hdr_len 
 pattrib->ether_type == 0x8100) ? (14 + 4): 14; vlan tag 
 pattrib->priority = 5; force to used VI queue, for testing 
 encode mic code 
 start to calculate the mic code 
 start to calculate the mic code 
 ToDS == 1 
 DA 
 From Ds == 1 
 ToDS == 0 
 DA 
 From Ds == 1 
 add mic code  and add the mic code length in last_txcmdsz 
 to_ds = 1, fr_ds = 0; 
  1.Data transfer to AP 
  2.Arp pkt will relayed by AP 
 to_ds = 0, fr_ds = 1; 
 TODO: fill HT Control Field 
 Update Seq Num will be handled by fw 
 check if enable ampdu 
 re-check if enable ampdu by BA_starting_seqctrl 
 check BA_starting_seqctrl 
 AGG BK 
 AGG EN 
 AGG EN 
  Calculate wlan 802.11 packet MAX size from pkt_attrib
  This function doesn't consider fragment case
  WLAN Header and IV 
  LLC 
  MIC 
  ICV 
  This sub-routine will perform all the following:
  1. remove 802.3 header.
  2. create wlan_header, based on the info in pxmitframe
  3. append sta's ivext-iv
  4. append LLC
  5. move frag chunk from pframe to pxmitframe->mem
  6. apply sw-encrypt, if necessary.
 2346-4 = 2342 
 adding icv, if necessary... 
  don't do fragment to broadcastmulticast packets 
 broadcast or multicast management pkt use BIP, unicast management pkt use CCMP encryption 
 bit(7)~bit(2) 
 only support station mode 
 IGTK key is not install, it may not support 802.11w 
 station mode doesn't need TX BIP, just ready the code 
 other types doesn't need the BIP 
 octent 0 and 1 is key index , BIP keyid is 4 or 5, LSB only need octent 0 
 copy packet number 
 increase the packet number 
 add MME IE with MIC all zero, MME string doesn't include element id and length 
  total frame length - header length 
 conscruct AAD, copy frame control field 
 conscruct AAD, copy address 1 to address 3 
 copy management fram body 
 calculate mic 
 copy right BIP mic value, total is 128bits, we use the 0~63 bits 
 unicast mgmt frame TX 
 start to encrypt mgmt frame 
 according 802.11-2012 standard, these five types are not robust types 
 before encrypt dump the management packet content 
 bakeup original management packet 
 move to data portion 
 802.11w unicast management packet must be _AES_ 
 it's MIC of AES 
 set AES IV header 
 insert iv header into management frame 
 copy mgmt data portion after CCMP header 
 move pframe to end of mgmt pkt 
 add 8 bytes CCMP IV header to length 
 add 8 bytes MIC 
 set final tx command size 
 set protected bit must be beofre SW encrypt 
 software encrypt 
 Logical Link Control(LLC) SubNetwork Attachment Point(SNAP) header
  IEEE LLCSNAP header contains 8 octets
  First 3 octets comprise the LLC portion
  SNAP portion, 5 octets, is divided into two fields:
 Organizationally Unique Identifier(OUI), 3 octets,
 type, defined by that organization, 2 octets.
 default value setting 
  Calling context:
  1. OS_TXENTRY
  2. RXENTRY (rx_thread or RX_ISRRX_CallBack)
  If we turn on USE_RXTHREAD, then, no need for critical section.
  Otherwise, we must use _enter_exit critical to protect free_xmit_queue...
  Must be very, very cautious...
 _queue pfree_xmit_queue) 
	
	 	Please remember to use all the osdep_service api,
	 	and lockunlock or _enter_exit critical to protect
	 	pfree_xmit_queue
  Will enqueue pxmitframe to the proper queue,
  and indicate it to xx_pending list.....
 BCMC in PS (HIQ) 
  The main transmit(tx) entry
  Return
 1	enqueue
 0	success, hardware will handle this xmit frame(packet)
 <0	fail
 pre_xmitframe 
 HIQ 
 if anyone sta is in ps mode 
 pattrib->qsel = 0x11;HIQ 
 update BCN for TIM IE 
 for BCMC Frames 
 for BCMC Frames 
 for BCMC Frames 
 no any sta in ps mode 
 timeout, do something?? 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  for adhoc-master to generate ie and provide supported-rate to fw 
  last element must be zero!! 
  could be pure B, pure G, or BG 
  rtw_set_ie will update frame length 
 frame length 
----------------------------------------------------------------------------
index: the information element id index, limit is the limit for search
  rtw_get_ie_ex - Search specific IE from a series of IEs
  @in_ie: Address of IEs to search
  @in_len: Length limit from in_ie
  @eid: Element ID to match
  @oui: OUI to match
  @oui_len: OUI length
  @ie: If not NULL and the specific IE is found, the IE will be copied to the buf starting from the specific IE
  @ielen: If not NULL and the specific IE is found, will set to the length of the entire IE
  Returns: The address of the specific IE found, or NULL
 goto next 
  rtw_ies_remove_ie - Find matching IEs and remove
  @ies: Address of IEs to search
  @ies_len: Pointer of length of ies, will update to new length
  @offset: The offset to start search
  @eid: Element ID to match
  @oui: OUI to match
  @oui_len: OUI length
  Returns: _SUCCESS: ies is updated, _FAIL: not updated
 timestamp will be inserted by hardware 
 beacon interval : 2bytes 
 BCN_INTERVAL; 
 capability info 
 SSID 
 supported rates 
 ie = rtw_set_ie(ie, WLAN_EID_EXT_SUPP_RATES, (rateLen - 8), (pdev_network->supported_rates + 8), &sz); 
 DS parameter set 
 IBSS Parameter Set 
 HT Cap. 
 todo: 
 pdev_network->ie_length =  sz; update ie_length 
 return _SUCCESS; 
 check if oui matches... 
 check version... 
 No WPA IE - fail silently 
 group_cipher 
 pairwise_cipher 
 count = le16_to_cpu((u16)pos); 
 No RSN IE - fail silently 
 group_cipher 
 pairwise_cipher 
 count = le16_to_cpu((u16)pos); 
 ifdef CONFIG_WAPI_SUPPORT 
 if (authmode == WLAN_EID_BSS_AC_ACCESS_DELAY) 
 get next 
 get next 
 endif 
 Search required WPA or WPA2 IE and copy to sec_ie[ ] 
 get next 
 get next 
 get next 
  rtw_get_wps_ie - Search WPS IE from a series of IEs
  @in_ie: Address of IEs to search
  @in_len: Length limit from in_ie
  @wps_ie: If not NULL and WPS IE is found, WPS IE will be copied to the buf starting from wps_ie
  @wps_ielen: If not NULL and WPS IE is found, will set to the length of the entire WPS IE
  Returns: The address of the WPS IE found, or NULL
 goto next 
  rtw_get_wps_attr - Search a specific WPS attribute from a given WPS IE
  @wps_ie: Address of WPS IE to search
  @wps_ielen: Length limit from wps_ie
  @target_attr_id: The attribute ID of WPS attribute to search
  @buf_attr: If not NULL and the WPS attribute is found, WPS attribute will be copied to the buf starting from buf_attr
  @len_attr: If not NULL and the WPS attribute is found, will set to the length of the entire WPS attribute
  Returns: the address of the specific WPS attribute found, or NULL
  6 = 1(Element ID) + 1(Length) + 4(WPS OUI) 
 goto first attr 
  4 = 2(Attribute ID) + 2(Length) 
 goto next 
  rtw_get_wps_attr_content - Search a specific WPS attribute content from a given WPS IE
  @wps_ie: Address of WPS IE to search
  @wps_ielen: Length limit from wps_ie
  @target_attr_id: The attribute ID of WPS attribute to search
  @buf_content: If not NULL and the WPS attribute is found, WPS attribute content will be copied to the buf starting from buf_content
  @len_content: If not NULL and the WPS attribute is found, will set to the length of the WPS attribute content
  Returns: the address of the specific WPS attribute content found, or NULL
	 first 3 bytes in vendor specific information element are the IEEE
	  OUI of the vendor. The following byte is used a vendor specific
		 MicrosoftWi-Fi information elements are further typed and
			 Microsoft OUI (00:50:F2) with OUI Type 1:
 this is a Wi-Fi WME info. element 
 Wi-Fi Protected Setup (WPS) IE 
  rtw_ieee802_11_parse_elems - Parse information elements in management frames
  @start: Pointer to the start of IEs
  @len: Length of IE buffer in octets
  @elems: Data structure for parsed elements
  @show_errors: Whether to show parsing errors in debug log
  Returns: Parsing result
 Users specify the mac address 
 Use the mac address stored in the Efuse 
 u8 wpa_ie[255], rsn_ie[255]; 
 get bwmode and ch_offset 
 parsing HT_CAP_IE 
 parsing HT_INFO_IE 
 show MCS rate, unit: 100Kbps 
 vendor-specific 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  UNII 
 HiperLAN2 
 Japan MMAC 
  Japan 
 Japan, means J08 
 Japan, means J12 
 Japan, means J16 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
	----------------------------------------------------------
					below 2 are reserved
OUI definitions for the vendor specific IE
ChannelPlan definitions
  0x00, RT_CHANNEL_DOMAIN_2G_WORLD , Passive scan CH 12, 13 
  0x01, RT_CHANNEL_DOMAIN_2G_ETSI1 
  0x02, RT_CHANNEL_DOMAIN_2G_FCC1 
  0x03, RT_CHANNEL_DOMAIN_2G_MIKK1 
  0x04, RT_CHANNEL_DOMAIN_2G_ETSI2 
  0x05, RT_CHANNEL_DOMAIN_2G_GLOBAL , Passive scan CH 12, 13, 14 
  0x06, RT_CHANNEL_DOMAIN_2G_NULL 
  0x00 ~ 0x1F , Old Define ===== 
 0x00, RT_CHANNEL_DOMAIN_FCC 
 0x01, RT_CHANNEL_DOMAIN_IC 
 0x02, RT_CHANNEL_DOMAIN_ETSI 
 0x03, RT_CHANNEL_DOMAIN_SPAIN 
 0x04, RT_CHANNEL_DOMAIN_FRANCE 
 0x05, RT_CHANNEL_DOMAIN_MKK 
 0x06, RT_CHANNEL_DOMAIN_MKK1 
 0x07, RT_CHANNEL_DOMAIN_ISRAEL 
 0x08, RT_CHANNEL_DOMAIN_TELEC 
 0x09, RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN 
 0x0A, RT_CHANNEL_DOMAIN_WORLD_WIDE_13 
 0x0B, RT_CHANNEL_DOMAIN_TAIWAN 
 0x0C, RT_CHANNEL_DOMAIN_CHINA 
 0x0D, RT_CHANNEL_DOMAIN_SINGAPORE_INDIA_MEXICO 
 0x0E, RT_CHANNEL_DOMAIN_KOREA 
 0x0F, RT_CHANNEL_DOMAIN_TURKEY 
 0x10, RT_CHANNEL_DOMAIN_JAPAN 
 0x11, RT_CHANNEL_DOMAIN_FCC_NO_DFS 
 0x12, RT_CHANNEL_DOMAIN_JAPAN_NO_DFS 
 0x13, RT_CHANNEL_DOMAIN_WORLD_WIDE_5G 
 0x14, RT_CHANNEL_DOMAIN_TAIWAN_NO_DFS 
 0x15, RT_CHANNEL_DOMAIN_ETSI_NO_DFS 
 0x16, RT_CHANNEL_DOMAIN_KOREA_NO_DFS 
 0x17, RT_CHANNEL_DOMAIN_JAPAN_NO_DFS 
 0x18, RT_CHANNEL_DOMAIN_PAKISTAN_NO_DFS 
 0x19, RT_CHANNEL_DOMAIN_TAIWAN2_NO_DFS 
 0x1A, 
 0x1B, 
 0x1C, 
 0x1D, 
 0x1E, 
 0x1F, RT_CHANNEL_DOMAIN_WORLD_WIDE_ONLY_5G 
  0x20 ~ 0x7F , New Define ===== 
 0x20, RT_CHANNEL_DOMAIN_WORLD_NULL 
 0x21, RT_CHANNEL_DOMAIN_ETSI1_NULL 
 0x22, RT_CHANNEL_DOMAIN_FCC1_NULL 
 0x23, RT_CHANNEL_DOMAIN_MKK1_NULL 
 0x24, RT_CHANNEL_DOMAIN_ETSI2_NULL 
 0x25, RT_CHANNEL_DOMAIN_FCC1_FCC1 
 0x26, RT_CHANNEL_DOMAIN_WORLD_ETSI1 
 0x27, RT_CHANNEL_DOMAIN_MKK1_MKK1 
 0x28, RT_CHANNEL_DOMAIN_WORLD_KCC1 
 0x29, RT_CHANNEL_DOMAIN_WORLD_FCC2 
 0x2A, 
 0x2B, 
 0x2C, 
 0x2D, 
 0x2E, 
 0x2F, 
 0x30, RT_CHANNEL_DOMAIN_WORLD_FCC3 
 0x31, RT_CHANNEL_DOMAIN_WORLD_FCC4 
 0x32, RT_CHANNEL_DOMAIN_WORLD_FCC5 
 0x33, RT_CHANNEL_DOMAIN_WORLD_FCC6 
 0x34, RT_CHANNEL_DOMAIN_FCC1_FCC7 
 0x35, RT_CHANNEL_DOMAIN_WORLD_ETSI2 
 0x36, RT_CHANNEL_DOMAIN_WORLD_ETSI3 
 0x37, RT_CHANNEL_DOMAIN_MKK1_MKK2 
 0x38, RT_CHANNEL_DOMAIN_MKK1_MKK3 
 0x39, RT_CHANNEL_DOMAIN_FCC1_NCC1 
 0x3A, 
 0x3B, 
 0x3C, 
 0x3D, 
 0x3E, 
 0x3F, 
 0x40, RT_CHANNEL_DOMAIN_FCC1_NCC2 
 0x41, RT_CHANNEL_DOMAIN_GLOBAL_NULL 
 0x42, RT_CHANNEL_DOMAIN_ETSI1_ETSI4 
 0x43, RT_CHANNEL_DOMAIN_FCC1_FCC2 
 0x44, RT_CHANNEL_DOMAIN_FCC1_NCC3 
 0x45, RT_CHANNEL_DOMAIN_WORLD_ETSI5 
 0x46, RT_CHANNEL_DOMAIN_FCC1_FCC8 
 0x47, RT_CHANNEL_DOMAIN_WORLD_ETSI6 
 0x48, RT_CHANNEL_DOMAIN_WORLD_ETSI7 
 0x49, RT_CHANNEL_DOMAIN_WORLD_ETSI8 
 0x50, RT_CHANNEL_DOMAIN_WORLD_ETSI9 
 0x51, RT_CHANNEL_DOMAIN_WORLD_ETSI10 
 0x52, RT_CHANNEL_DOMAIN_WORLD_ETSI11 
 0x53, RT_CHANNEL_DOMAIN_FCC1_NCC4 
 0x54, RT_CHANNEL_DOMAIN_WORLD_ETSI12 
 0x55, RT_CHANNEL_DOMAIN_FCC1_FCC9 
 0x56, RT_CHANNEL_DOMAIN_WORLD_ETSI13 
 0x57, RT_CHANNEL_DOMAIN_FCC1_FCC10 
 use the combination for max channel numbers 
 Search the @param ch in given @param ch_set
  @ch_set: the given channel set
  @ch: the given channel number
  return the index of channel_num in channel_set, -1 if not found
Following are the initialization functions for WiFi MLME
 reset to zero when disconnect at client mode 
 Channel 1~11 is active, and 12~14 is passive 
  channel 12~13, passive scan 
 fill_fwpriv(padapter, &(pmlmeext->fwpriv)); 
 del_timer_sync(&pmlmeext->ADDBA_timer); 
 receive the frames that ra(a1) is my address or ra(a1) is bc address. 
 receive the frames that ra(a1) is my address or ra(a1) is bc address. 
 drop the duplicate management frame 
 if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) 
Following are the callback functions for each subtype of the management frames
 check (wildcard) SSID 
 Invalid value 0x2D is detected in Extended Supported Rates (ESR) IE. Try to fix the IE length to avoid failed Beacon parsing. 
 we should update current network before auth, or some IE is wrong 
 check the vendor of the assoc AP 
 update TSF Value 
 reset for adaptive_early_32k 
 start auth 
 update WMM, ERP in the beacon 
 todo: the timer is used instead of the number of the beacon received 
 update WMM, ERP in the beacon 
 todo: the timer is used instead of the number of the beacon received 
 allocate a new CAM entry for IBSS station 
 get supported rate 
 update TSF Value 
 report sta add event 
  rx a shared-key auth but shared not enabled 
  rx a open-system auth but shared-key is enabled 
  allocate a new one 
 pstat->flags = 0; 
 pstat->capability = 0; 
 TODO: STA re_auth within expire_to 
 TODO: STA re_auth and auth timeout 
  shared system or auto authentication 
 prepare for the challenging txt... 
  challenging txt is correct... 
  Now, we are going to issue_auth... 
 check A1 matches or not 
  pmlmeinfo->auth_algo == dot11AuthAlgrthm_Auto) 
 pmlmeinfo->reauth_count = 0; 
  legendary shared system 
  open system 
  this is also illegal 
 pmlmeinfo->state &= ~(WIFI_FW_AUTH_STATE); 
  WIFI_REASSOCREQ 
 capab_info = le16_to_cpu((unsigned short )(pframe + WLAN_HDR_A3_LEN)); 
  check if this stat has been successfully authenticatedassocated 
 now parse all ieee802_11 ie to point to elems 
  now we should check all the fields... 
  checking SSID 
  broadcast ssid, however it is not allowed in assocreq 
  check if ssid match 
  check if the supported rate is ok 
  use our own rate set as statoin used 
 memcpy(supportRate, AP_BSSRATE, AP_BSSRATE_LEN); 
 supportRateNum = AP_BSSRATE_LEN; 
 todo: mask supportRate between AP & STA -> move to update raid 
 get_matched_rate(pmlmeext, supportRate, &supportRateNum, 0); 
 update station supportRate 
 check RSNWPAWPS 
 psk,  todo:802.1x 
 psk,  todo:802.1x 
 wpabuf_free(sta->wps_ie); 
 sta->wps_ie = wpabuf_alloc_copy(elems.wps_ie + 4, 
 				elems.wps_ie_len - 4); 
  AP support WPARSN, and sta is going to do WPS, but AP is not ready 
  that the selected registrar of AP is _FLASE 
  check if there is WMM IE & support WWM-PS 
 save HT capabilities in the sta object 
 status = WLAN_STATUS_CIPHER_SUITE_REJECTED; 
 goto OnAssocReqFail; 
 TODO: identify_proprietary_vendor_ie(); 
  Realtek proprietary IE 
  identify if this is Broadcom sta 
  identify if this is ralink sta 
  Customer proprietary IE 
 get a unique AID 
 if (pstat->aid > NUM_STA) { 
  now the station is qualified to join our BSS... 
 1 bss_cap_update & sta_info_update 
 2 issue assoc rsp before notify station join event. 
 3-(1) report sta add event 
 struct wlan_bssid_ex			cur_network = &(pmlmeinfo->network); 
 check A1 matches or not 
 status 
 get capabilities 
 set slot time 
 AID 
 following are moved to join event callback function 
 to handle HT, WMM, rate adaptive, update MAC reg 
 for not to handle the synchronous IO in the tasklet 
 WMM 
 HT caps 
 HT info 
 Update Basic Rate Table for spec, 2010-12-28 , by thomas 
 check A3 
 rtw_free_stainfo(padapter, psta); 
 	Commented by Albert 20130604 
 	Before sending the auth frame to start the STAGC mode connection with APGO, 
 	we will send the deauth first. 
 	However, the Win8.1 with BRCM Wi-Fi will send the deauth with reason code 6 to us after receieving our deauth. 
 	Added the following code to avoid this case. 
  TODO: 802.11r 
 check A3 
 rtw_free_stainfo(padapter, psta); 
 check RA matches or not 
 for if1, staap mode 
  representing Block Ack 
 ADDBA request 
 process_addba_req(padapter, (u8 )&(pmlmeinfo->ADDBA_req), GetAddr3Ptr(pframe)); 
 reject ADDBA Req 
 ADDBA response 
 successful 
 DELBA 
 todo: how to notify the host while receiving DELETE BA 
 check RA matches or not 
 check RA matches or not 
 SA Query req 
 SA Query rsp 
Following are some TX functions for WiFi MLME
 memset((u8 )(pattrib), 0, sizeof(struct pkt_attrib)); 
   500ms 
 update attribute 
pmlmeext->mgnt_seq);
 pmlmeext->mgnt_seq++; 
 below for ad-hoc mode 
 timestamp will be inserted by hardware 
  beacon interval: 2 bytes 
  capability info: 2 bytes 
  SSID 
  supported rates... 
  DS parameter set 
 if ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) 
  IBSS Parameter Set... 
 ATIMWindow = cur->configuration.ATIMWindow; 
 ERP IE 
  EXTERNDED SUPPORTED RATE 
 todo:HT for adhoc 
 update attribute 
 inerset & update wps_probe_resp_ie 
 to get ie data len 
 retrieve SSID IE from cur_network->ssid 
 timestamp will be inserted by hardware 
  beacon interval: 2 bytes 
  capability info: 2 bytes 
 below for ad-hoc mode 
  SSID 
  supported rates... 
  DS parameter set 
  IBSS Parameter Set... 
 ATIMWindow = cur->configuration.ATIMWindow; 
 ERP IE 
  EXTERNDED SUPPORTED RATE 
 todo:HT for adhoc 
 update attribute 
 	unicast probe request frame 
 	broadcast probe request frame 
 add wps_ie for wps2.0 
  if psta == NULL, indicate we are station(client) now... 
 update attribute 
  for AP mode 
  setting auth algo number 
  setting auth seq number 
  setting status code... 
  added challenging text... 
  setting auth algo number 
  0:OPEN System, 1:Shared key 
 setting IV for auth seq #3 
  setting auth seq number 
  setting status code... 
  then checking to see if sending challenging text... 
 update attribute 
 capability 
 FILL HT CAP INFO IE 
 p = hostapd_eid_ht_capabilities_info(hapd, p); 
 FILL HT ADD INFO IE 
 p = hostapd_eid_ht_operation(hapd, p); 
 FILL WMM IE 
 add WPS IE ie for wps 2.0 
 update attribute 
 caps 
 listen interval 
 todo: listen interval for power saving 
 SSID 
 supported rate & extended supported rate 
  Check if the AP's supported rates are also supported by STA. 
  for JAPAN, channel 14 can only uses B Mode(CCK) 
 for (i = 0; i < sta_bssrate_len; i++) { 
  Check if the AP's supported rates are also supported by STA. 
  Avoid the proprietary data rate (22Mbps) of Handlink WSG-4000 AP 
  the rate is supported by STA 
 don't connect to AP if no joint supported rate 
 vendor specific IE, such as WPA, WMM, WPS 
					 Commented by Kurt 20110629
					  In some older APs, WPS handshake
					  would be fail if we append vendor
					  extensions information to AP
 when wait_ack is true, this function should be called at process context 
 update attribute 
  [IMPORTANT] Don't call this function in interrupt context
  When wait_ms > 0, this function should be called at process context
  da == NULL for station mode
 da == NULL, assume it's null data for sta to ap
  [IMPORTANT] This function run in interrupt context
  The null data packet would be sent without power bit,
  and not guarantee success.
 da == NULL, assume it's null data for sta to ap
 when wait_ack is true, this function should be called at process context 
 update attribute 
 when wait_ms >0 , this function should be called at process context 
 da == NULL for station mode 
 da == NULL, assume it's null data for sta to ap
 update attribute 
 update attribute 
 SA Query req 
 send sa query request to AP, AP should reply sa query response in 1 second 
 SA Query rsp 
 update attribute 
 memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN); 
 ADDBA req 
  A-MSDU NOT Supported 
  immediate Block Ack 
  TID 
  max buffer size is 8 MSDU 
 immediate ack & 64 buffer size 
  5ms 
 if ((psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.mac_address)) != NULL) 
 ADDBA rsp 
 64 buffer size 
 32 buffer size 
 16 buffer size 
 8 buffer size 
 64 buffer size 
  max buffer size is 8 MSDU 
 disabled 
 enabled 
 auto 
 DELBA 
 update attribute 
 20 MHz BSS Width Request 
 non-HT 
 SET_BSS_INTOLERANT_ELE_REG_CLASS(InfoContent, i); 
 channel number 
 SET_BSS_INTOLERANT_ELE_CHANNEL(InfoContent+k, j); 
 struct recv_reorder_ctrl preorder_ctrl; 
  recipient 
  originator 
Following are some utility functions for WiFi MLME
 PAUSE 4-AC Queue when site_survey 
 rtw_hal_get_hwreg(padapter, HW_VAR_TXPAUSE, (u8 )(&val8)); 
 val8 |= 0x0f; 
 rtw_hal_set_hwreg(padapter, HW_VAR_TXPAUSE, (u8 )(&val8)); 
 obey the channel plan setting... 
 IOT issue, When wifi_spec is not set, send one probe req without WPS IE. 
 IOT issue, When wifi_spec is not set, send one probe req without WPS IE. 
 	channel number is 0 or this channel is not valid. 
 switch back to the original channel 
 SelectChannel(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset); 
 flush 4-AC Queue after site_survey 
 val8 = 0; 
 rtw_hal_set_hwreg(padapter, HW_VAR_TXPAUSE, (u8 )(&val8)); 
 config MSR 
 restore RX GAIN 
 turn on dynamic functions 
 Switch_DM_Func(padapter, DYNAMIC_ALL_FUNC_ENABLE, true); 
 survey done 
 collect bss info from Beacon and Probe requestresponse frames. 
  FIXME : more type 
 below is to copy the information element 
 get the signal strength 
  in dBM.raw data 
 in percentage 
 in percentage 
  checking SSID 
 checking rate info... 
  Checking for ds_config 
  In 5G, some ap do not have DSSET IE 
  checking HT info for channel 
  use current channel 
 2040 BSS Coexistence check 
  mark bss info receiving from nearby channel as signal_quality 101 
 update wireless mode 
 update capability 
 adhoc master 
 switch channel 
 SelectChannel(padapter, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE); 
 set msr to WIFI_FW_ADHOC_STATE 
 issue beacon 
 update bcmc sta_info 
 update wireless mode 
 update capability 
  Because of AP's not receiving deauth before 
  AP may: 1)not response auth or 2)deauth us after link is complete 
  issue deauth before issuing auth to deal with the situation 
 	Commented by Albert 20120721 
 	For the Win8 P2P connection, it will be hard to have a successful connection if this Wi-Fi doesn't connect to it. 
 To avoid connecting to AP fail during resume process, change retry count from 5 to 1 
 here wait for receiving the beacon to start auth 
 and enable a timer 
 adhoc client 
 check A3 
  Adjust channel plan by AP Country IE 
  first channel number 
  number of channel 
  2.4 GHz 
  5 GHz 
 					chplan_new[k].ScanType = chplan_sta[i].ScanType; 
  change AP not support channel to Passive scan 
 				chplan_new[k].ScanType = chplan_sta[i].ScanType; 
  add channel AP supported 
  keep original STA 2.4G channel plan 
  skip AP 2.4G channel plan 
  If channel is used by AP, set channel scan type to active 
Following are the functions to report events
 u8 pframe = precv_frame->u.hdr.rx_data; 
 uint len = precv_frame->u.hdr.len; 
Following are the event callback functions
 for staadhoc mode 
 ERP 
 HT 
 reset 
 reset 
 QoS 
 set_opmode_cmd(padapter, infra_client_with_mlme); 
	 For safety, prevent from keeping macid sleep.
	  If we can sure all power mode enterleave are paired,
	  this check can be removed.
	  Lucas@20131113
 wakeup macid after disconnect. 
 set MSR to no link state -> infra. mode 
 switch to the 20M Hz mode after disconnect 
 pmlmepriv->LinkDetectInfo.TrafficBusyState = false; 
 update bcmc sta_info 
 turn on dynamic functions 
  update IOT-related issue 
 BCN interval 
 update capability 
 WMM, Update EDCA param 
 HT 
 Set cur_channel&cur_bwmode&cur_ch_offset 
 only for infra. mode 
 set per sta rate after updating HT cap. 
		 wakeup macid after join bss successfully to ensure
  correcting TSF 
 set_link_timer(pmlmeext, DISCONNECT_TO); 
 currently only adhoc mode will go here 
 adhoc master or sta_count>1 
 nothing to do 
 adhoc client 
 update TSF Value 
 update_TSF(pmlmeext, pframe, len); 
  correcting TSF 
 start beacon 
 update adhoc sta_info 
  ToDo: HT for Ad-hoc 
 rate radaptive 
Following are the functions for the timer handlers
 skip bcmc sta 
   tx info ============ 
 linked infrastructure client mode 
  16 sec 
  Marked by Kurt 20130715 
  For WiDi 3.5 and latered on, they don't ask WiDi sink to do roaming, so we could not check rx limit that strictly. 
  todo: To check why we under miracast session, rx_chk would be false 
 end of if ((psta = rtw_get_stainfo(pstapriv, passoc_res->network.mac_address)) != NULL) 
 linked IBSS mode 
 for each assoc list entry to check the rx pkt counter 
  indicate disconnect caused by no rx 
 set_link_timer(pmlmeext, DISCONNECT_TO); 
 issue rtw_sitesurvey_cmd 
 reset 
 static unsigned int		rx_pkt = 0; 
 static u64				tx_cnt = 0; 
 struct xmit_priv 	pxmitpriv = &(padapter->xmitpriv); 
 struct sta_priv 	pstapriv = &padapter->stapriv; 
 re-auth timer 
 if (pmlmeinfo->auth_algo != dot11AuthAlgrthm_Auto) 
 else 
 	pmlmeinfo->auth_algo = dot11AuthAlgrthm_Shared; 
 	pmlmeinfo->reauth_count = 0; 
 re-assoc timer 
 disconnect 
 start_ap_mode(padapter); 
  clear state 
 set to	STATION_STATE 
 Set_MSR(padapter, type); 
  Do this after port switch to 
  prevent from downloading rsvd page to wrong port 
 connect 
 u32 initialgain; 
 below is for ad-hoc master 
 disable dynamic functions, such as high power, DIG 
 config the initial gain under linking, need to write the BB registers 
 initialgain = 0x1E; 
 rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 )(&initialgain)); 
 cancel link timer 
 clear CAM 
 Check pbuf->ie_length 
 u32 initialgain; 
 u32 acparm; 
 check already connecting to AP or not 
 clear CAM 
 set MSR to nolink -> infra. mode 
 Set_MSR(padapter, _HW_STATE_NOLINK_); 
 pmlmeinfo->assoc_AP_vendor = HT_IOT_PEER_MAX; 
 Check pbuf->ie_length 
 Check AP vendor to move rtw_joinbss_cmd() 
 pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pnetwork->ies, pnetwork->ie_length); 
 sizeof(struct ndis_802_11_fix_ie) 
 Get WMM IE. 
 Get HT Cap IE. 
 Get HT Info IE. 
 spec case only for cisco's ap because cisco's ap issue assoc rsp using mcs rate @40MHz or @20MHz 
 switch to the 40M Hz mode according to the AP 
 check channel, bandwidth, offset and switch 
 disable dynamic functions, such as high power, DIG 
 Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, false); 
 config the initial gain under linking, need to write the BB registers 
 initialgain = 0x1E; 
 rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 )(&initialgain)); 
 cancel link timer 
 Stop BCN 
 clear first 
 acquire channels from in 
 if out is empty, use channel_set as default 
 issue null data if associating to the AP 
 delay 50ms to protect nulldata(1). 
 disable dynamic functions, such as high power, DIG 
		 config the initial gain under scanning, need to write the BB
		  registers
 set MSR to no link state 
 under site survey 
 main tx key for wep. 
 not default key, searched by A2 
 allow multicast packets to driver 
 pmlmeinfo->ADDBA_retry_count = 0; 
 pmlmeinfo->candidate_tid_bitmap |= (0x1 << pparm->tid); 
 psta->htpriv.candidate_tid_bitmap |= BIT(pparm->tid); 
 _set_timer(&pmlmeext->ADDBA_timer, ADDBA_TO); 
0
8
9
10
15
20
  checking if event code is valid 
  checking if event size match the event parm size 
 for BCMC Frames 
  10ms, ATIM(HIQ) Windows 
 HIQ 
 check hi queue and bmc_sleepq 
 tx bcmc frames after update TIM 
 Find union about ch, bw, ch_offset of all linkedlinking interfaces 
  TDLS_ESTABLISHED	: write RCR DATA BIT 
  TDLS_CS_OFF		: go back to the channel linked with AP, terminating channel switch procedure 
  TDLS_INIT_CH_SEN	: init channel sensing, receive all data and mgnt frame 
  TDLS_DONE_CH_SEN: channel sensing and report candidate channel 
  TDLS_OFF_CH		: first time set channel to off channel 
  TDLS_BASE_CH		: go back tp the channel linked with AP when set base channel as target channel 
  TDLS_P_OFF_CH	: periodically go to off channel 
  TDLS_P_BASE_CH	: periodically go back to base channel 
  TDLS_RS_RCR		: restore RCR 
  TDLS_TEAR_STA	: free tdls sta 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
 define WAIT_FOR_BCN_TO_MIN	(3000) 
  1M, 2M, 5.5M, 11M, 6M, 12M, 24M are mandatory. 
 DBG_CH_SWITCH 
 DBG_CH_SWITCH 
 saved channel info 
 set Channel 
 saved channelbw info 
  set center channel 
 get key from cam 
 APAd-hoc mode group key: static alloction to default key by key ID 
 bypass STA mode group key setting before connected(ex:WEP) because bssid is not ready 
 Fix issue that pairwise and group key have same key id. Pairwise key first, group key can overwirte group only(ex: rekey) 
 clear default key related key search setting 
 struct registry_priv pregpriv = &padapter->registrypriv; 
 entry indx: 0->vo, 1->vi, 2->be, 3->bk. 
 compare CW and AIFS 
 compare TXOP 
 AIFS = AIFSN  slot time + SIFS - r2t phy delay 
 acm_mask |= (ACM? BIT(0):0); 
 update HT info also 
 set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode); 
 update ap's stainfo 
  bwmode 
 Commented by Albert 20100712 
 Got the endian issue here. 
 modify from  fw by Thomas 20101117 
 update the MCS set 
 update the MCS rates 
  Config STBC setting 
  Config LDPC Coding Capability 
  Config STBC setting 
 struct registry_priv  pregpriv = &padapter->registrypriv; 
 set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode); 
 handle A-MPDU parameter field 
	
		AMPDU_para [1:0]:Max AMPDU Len => 0:8k , 1:16k, 2:32k, 3:64k
		AMPDU_para [4:2]:Min MPDU Start Spacing
 0:off 1:on 2:auto 
 off 
 on 
 1:RTSCTS 2:CTS to self 
 auto 
 u8 wpa_ie[255], rsn_ie[255]; 
 below is to copy the information element 
 check bw and channel offset 
 parsing HT_CAP_IE 
 parsing HT_INFO_IE 
 bcn_info_update 
 to do : need to check that whether modify related register of BB or not 
 goto _mismatch; 
 Checking for channel 
 In 5G, some ap do not have DSSET IE checking HT info for channel 
 we don't find channel IE, so don't check it 
 checking SSID 
 not hidden ssid 
 check encryption info 
 to update WMM parameter set while receiving beacon 
 WMM 
 HT info 
 HT_info_handler(padapter, pIE); 
 rate adaptive 
 if (pIE->data[5] & RT_HT_CAP_USE_LONG_PREAMBLE) 
 bssDesc->BssHT.RT2RT_HT_Mode |= RT_HT_CAP_USE_LONG_PREAMBLE; 
 bssDesc->BssHT.RT2RT_HT_Mode |= RT_HT_CAP_USE_92SE; 
 disable high power 
 rtw_write16(padapter, 0x4cc, 0xffff); 
 rtw_write16(padapter, 0x546, 0x01c0); 
 disable high power 
  Check preamble mode, 2005.01.06, by rcnjko. 
  Mark to update preamble value forever, 2008.03.18 by lanhsin 
 if (pMgntInfo->RegPreambleMode == PREAMBLE_AUTO) 
  Short Preamble 
  PREAMBLE_LONG or PREAMBLE_AUTO 
  Long Preamble 
  PREAMBLE_SHORT or PREAMBLE_AUTO 
 Filen: See 802.11-2007 p.91 
 Filen: See 802.11-2007 p.90 
 && (!(pMgntInfo->pHTInfo->RT2RT_HT_Mode & RT_HT_CAP_USE_LONG_PREAMBLE)) )
  Short Slot Time 
  Long Slot Time 
 B Mode 
 0x0808 -> for CCK, 0x0a0a -> for OFDM 
 change this value if having IOT issues. 
  Only B, BG, and BGN AP could use CCK rate 
 delay = (timestamp mod 1024100)1000 (unit: ms) 
 delay_ms = do_div(tsf, (pmlmeinfo->bcn_interval1024))1000; 
 pmlmeext->bcn_delay_ratio[8] = (pmlmeext->bcn_delay_cnt[8]  100) pmlmeext->bcn_cnt; 
 pmlmeext->bcn_delay_ratio[delay_ms] = (pmlmeext->bcn_delay_cnt[delay_ms]  100) pmlmeext->bcn_cnt; 
	for (i = 0; i<9; i++)
	{
			pmlmeext->bcn_delay_cnt[i] , i, pmlmeext->bcn_delay_ratio[i]);
	}
 dump for  adaptive_early_32k 
 reset adaptive_early_32k cnt 
 For 8188E RA 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
0
5
10
14
15
18
20
25
30
35
40
45
46
50
51
54
55
56
57
58
59
60
61
62
63
0
10
14
18
20
30
40
 46 
50
55
56
57
58
59
60
61
62
63
  Caller and the rtw_cmd_thread can protect cmd_q by spin_lock.
  No irqsave is necessary.
 allocate DMA-ableNon-Page memory for cmd_buf and rsp_buf 
 allocate DMA-ableNon-Page memory for cmd_buf and rsp_buf 
  Calling Context:
  rtw_enqueue_cmd can only be called between kernel thread,
  since only spin_lock is used.
  ISRCall-Back functions can't call this sub-function.
 spin_lock_bh(&queue->lock); 
 spin_unlock_bh(&queue->lock); 
 spin_lock_bh(&(queue->lock)); 
 spin_unlock_bh(&(queue->lock)); 
 set to true to allow enqueuing cmd when hw_init_completed is false 
 com_thread not running 
 free parmbuf in cmd_obj 
 free rsp in cmd_obj 
 free cmd_obj 
 call callback function for post-processed 
 todo: !!! fill rsp_buf to pcmd->rsp if (pcmd->rsp!= NULL) 
 need consider that free cmd_obj in rtw_cmd_callback 
  free all cmd_obj resources 
  rtw_sitesurvey_cmd(~)
 	### NOTE:#### (!!!!)
 	MUST TAKE CARE THAT BEFORE CALLING THIS FUNC, YOU SHOULD HAVE LOCKED pmlmepriv->lock
 psurveyPara->bsslimit = 48; 
 prepare ssid list 
 prepare channel list 
 rtw_free_cmd_obj(pcmd); 
 no need to enqueue, do the cmd hdl directly and free cmd parameter 
 need enqueue, prepare cmd_obj and enqueue 
 for ies is fix buf size 
 for hidden ap to set fw_state here 
  Added by Albert 20090218 
  If the driver wants to use the bssid to create the connection. 
  If not,  we have to copy the connecting AP's MAC address to it so that 
  the driver just has the bssid information for PMKIDList searching. 
 There is WMM IE in this corresp. beacon 
 There is no WMM IE in this corresp. beacon 
 	Added by Albert 20100623 
 	For the WEP mode, we will use the bg mode to do the connection to avoid some IOT issue. 
 	Especially for Realtek 8192u SoftAP. 
 rtw_restructure_ht_ie 
 get cmdsz before endian conversion 
 GEN_CMD_CODE(_JoinBss) 
 for sta_mode 
 prepare cmd parameter 
 need enqueue, prepare cmd_obj and enqueue 
 no need to enqueue, do the cmd hdl directly and free cmd parameter 
 jeff: set this because at least sw key is ready 
 rtw_enqueue_cmd(pcmdpriv, ph2c); 
 add for CONFIG_IEEE80211W, none 11w can use it 
 rtw_enqueue_cmd(pcmdpriv, ph2c); 
 rtw_enqueue_cmd(pcmdpriv, ph2c); 
 only  primary padapter does this cmd 
 rtw_enqueue_cmd(pcmdpriv, ph2c); 
  check if allow software config 
 check input parameter 
 prepare cmd parameter 
 need enqueue, prepare cmd_obj and enqueue 
 no need to enqueue, do the cmd hdl directly and free cmd parameter 
 do something based on res... 
  Tx 
  Rx 
  Calculate throughput in last interval 
  Determine if our traffic is busy now 
&& !MgntInitAdapterInProgress(pMgntInfo)) {
  if we raise bBusyTraffic in last watchdog, using lower threshold. 
  Higher TxRx data. 
  check traffic for  powersaving. 
TrafficTransitionLevel)
  LeisurePS only work in infra mode. 
 for debug purpose 
 if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING|_FW_UNDER_SURVEY) ==false) 
 check_hw_pbc(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->type); 
  BT-Coexist 
 always call rtw_ps_processor() at last one. 
  connect 
 connect 
  Reset LPS Setting 
 disconnect 
 struct pwrctrl_priv pwrctrlpriv = adapter_to_pwrctl(padapter); 
 if (!pwrctrlpriv->bLeisurePs) 
 	return res; 
 re check again 
 transform BT-FW btinfo to WiFI-FW C2H format and notify 
 dont call RW in this function, beucase SDIO interrupt have claim host 
 or deadlock will happen and cause special-systemserver-died in android 
 This C2H event is read, clear it 
 This C2H event is not read, read & clear now 
 Special pointer to trigger c2h_evt_clear only 
 Handle CCX report here 
 Enqueue into cmd_thread for others 
 only  primary padapter go to this cmd, but execute dynamic_chk_wk_hdl() for two interfaces 
 add for CONFIG_IEEE80211W, none 11w can use it 
 TODO: cancel timer and do timeout handler directly... 
 need to make timeout handlerOS independent 
  free cmd 
  free cmd 
 TODO: cancel timer and do timeout handler directly... 
 need to make timeout handlerOS independent 
 pwlan->fixed = true; 
 list_add_tail(&(pwlan->list), &pmlmepriv->scanned_queue.queue); 
  copy pdev_network information to	pmlmepriv->cur_network 
  reset ds_config 
 tgt_network->network.configuration.ds_config = (u32)rtw_ch2freq(pnetwork->configuration.ds_config); 
  we will set _FW_LINKED when there is one more sat to join us (rtw_stassoc_event_callback) 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
 Define global variables 
  E-Fuse Control. 
-----------------------------------------------------------------------------
  Function:	Efuse_PowerSwitch
  Overview:	When we want to enable write operation, we should change to
 			pwr on state. When we stop write, we should switch to 500k mode
 			and disable LDO 2.5V.
  Input:       NONE
  Output:      NONE
  Return:      NONE
  Revised History:
  When			Who		Remark
  11172008	MHC		Create Version 0.
-----------------------------------------------------------------------------
  Function:	Efuse_GetCurrentSize
  Overview:	Get current efuse size!!!
  Input:       NONE
  Output:      NONE
  Return:      NONE
  Revised History:
  When			Who		Remark
  11162008	MHC		Create Version 0.
  11162008 MH Add description. Get current efuse area enabled word!!. 
  0 : write enable 
 	Description: 
 		1. Execute E-Fuse read byte operation according as map offset and 
 		    save to E-Fuse table. 
 		2. Referred from SD1 Richard. 
 	Assumption: 
 		1. Boot from E-Fuse and successfully auto-load. 
 		2. PASSIVE_LEVEL (USB interface) 
 	Created by Roger, 2008.10.21. 
 	20081212 MH	1. Reorganize code flow and reserve bytes. and add description. 
 					2. Add efuse utilization collect. 
 	20081222 MH	Read Efuse must check if we write section 1 data again!!! Sec1 
 					write addr must be after sec5. 
-----------------------------------------------------------------------------
  Function:	EFUSE_Read1Byte
  Overview:	Copy from WMAC fot EFUSE read 1 byte.
  Input:       NONE
  Output:      NONE
  Return:      NONE
  Revised History:
  When			Who		Remark
  09232008	MHC		Copy from WMAC.
 E-fuse 512Byte 
 Write E-fuse Register address bit0~7 
 Write E-fuse Register address bit8~9 
 Write 0x30[31]= 0 
 Wait Write-ready (0x30[31]= 1) 
 EFUSE_Read1Byte 
  11162008 MH Read one byte from real Efuse. 
  <20130121, Kordan> For SMIC EFUSE specificatoin. 
 0x34[11]: SW force PGMEN input of efuse to high. (for the bank selected by 0x34[9:8]) 
 PHY_SetMacReg(padapter, 0x34, BIT11, 0); 
  -----------------e-fuse reg ctrl --------------------------------- 
 address 
 rtw_write8(padapter, EFUSE_CTRL+3,  0x72); read cmd 
 Write bit 32 0 
  11162008 MH Write one byte to reald Efuse. 
  -----------------e-fuse reg ctrl --------------------------------- 
 address 
  <20130227, Kordan> 8192E MP chip A-cut had better not set 0x34[11] until B-Cut. 
  <20130121, Kordan> For SMIC EFUSE specificatoin. 
 0x34[11]: SW force PGMEN input of efuse to high. (for the bank selected by 0x34[9:8]) 
 PHY_SetMacReg(padapter, 0x34, BIT11, 1); 
  disable Efuse program enable 
-----------------------------------------------------------------------------
  Function:	efuse_WordEnableDataRead
  Overview:	Read allowed word in current efuse section data.
  Input:       NONE
  Output:      NONE
  Return:      NONE
  Revised History:
  When			Who		Remark
  11162008	MHC		Create Version 0.
  11212008	MHC		Fix Write bug when we only enable late word.
-----------------------------------------------------------------------------
  Function:	Efuse_ReadAllMap
  Overview:	Read All Efuse content
  Input:       NONE
  Output:      NONE
  Return:      NONE
  Revised History:
  When			Who		Remark
  11112008	MHC		Create Version 0.
-----------------------------------------------------------------------------
  Function:	efuse_ShadowRead1Byte
 		efuse_ShadowRead2Byte
 		efuse_ShadowRead4Byte
  Overview:	Read from efuse init map by onetwofour bytes !!!!!
  Input:       NONE
  Output:      NONE
  Return:      NONE
  Revised History:
  When			Who		Remark
  11122008	MHC		Create Version 0.
  EFUSE_ShadowRead1Byte 
 Read Two Bytes 
  EFUSE_ShadowRead2Byte 
 Read Four Bytes 
  efuse_ShadowRead4Byte 
-----------------------------------------------------------------------------
  Function:	EFUSE_ShadowMapUpdate
  Overview:	Transfer current EFUSE content to shadow init and modify map.
  Input:       NONE
  Output:      NONE
  Return:      NONE
  Revised History:
  When			Who		Remark
  11132008	MHC		Create Version 0.
 PlatformMoveMemory((void )&pHalData->EfuseMap[EFUSE_MODIFY_MAP][0], 
 void )&pHalData->EfuseMap[EFUSE_INIT_MAP][0], mapLen); 
  EFUSE_ShadowMapUpdate 
-----------------------------------------------------------------------------
  Function:	EFUSE_ShadowRead
  Overview:	Read from efuse init map !!!!!
  Input:       NONE
  Output:      NONE
  Return:      NONE
  Revised History:
  When			Who		Remark
  11122008	MHC		Create Version 0.
 EFUSE_ShadowRead
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
 for ACL 
 pmlmeext->bstart_bss = false; 
 stop_ap_mode(padapter); 
 free_assoc_sta_resources 
 free bcmc sta_info 
 update TIM IE 
 append TIM IE from dst_ie offset 
 calculate head_len 
 get ssid_ie len 
  get supported rates len 
 DS Parameter Set IE, len =3 
 append TIM IE from offset 
 DTIM count 
 DTIM period 
 for bcmc frames 
 bitmap ctrl 
 copy remainder IE 
 check auth_queue 
 check asoc_queue 
 to check if alive by another methods 
 if station is at ps mode. 
 to update bcn with tim_bitmap for this station 
 TODO: Aging mechanism to digest frames in sleep_q to 
 avoid running out of xmitframe 
 switch to correct channel of current network  before issue keep-alive frames 
 issue null data to check sta alive
 back to the original operation channel 
 default set to 0 
 psta->mac_id = psta->aid+4; 
 mac_id = 1 for bcmc stainfo 
!!! remove it, because it has been set before this. 
 prepare for add_RATid 
  error handling 
 ap mode 
 if (pHalData->fw_ractrl == true) 
 notes: 
 AID: 1~MAX for sta and 0 for bcmc in apadhoc mode 
 MAC_ID = AID+1 for sta in apadhoc mode 
 MAC_ID = 1 for bcmc for staapadhoc 
 MAC_ID = 0 for bssid for staapadhoc 
 CAM_ID = 0~3 for default key, cmd_id =macid + 3, macid =aid+1; 
 set intf_tag to if1 
 psta->intf_tag = 0; 
 psta->mac_id = psta->aid+4; 
alloc macid when call rtw_alloc_stainfo(), 
 release macid when call rtw_free_stainfo() 
 ap mode 
 update sta's cap 
 ERP 
 HT related cap 
 check if sta supports rx ampdu 
  bwmode 
 check if sta support s Short GI 20M 
 check if sta support s Short GI 40M 
 according to psta->bw_mode 
  B0 Config LDPC Coding Capability 
  B7 B8 B9 Config STBC setting 
 Rx AMPDU 
  recipient 
 TX AMPDU 
 originator 
 reset 
 reset 
 todo: init other variables 
 add ratid 
move to ap_sta_info_defer_update() 
 HT related cap 
 check if sta supports rx ampdu 
 phtpriv_ap->ampdu_enable = phtpriv_ap->ampdu_enable; 
 check if sta support s Short GI 20M 
 check if sta support s Short GI 40M 
 reset 
 reset 
	 handle A-MPDU parameter field
	 
	 	AMPDU_para [1:0]:Max AMPDU Len => 0:8k , 1:16k, 2:32k, 3:64k
	 	AMPDU_para [4:2]:Min MPDU Start Spacing
  Config SM Power Save setting 
  Config current HT Protection mode. 
 pmlmeinfo->HT_protection = pmlmeinfo->HT_info.infos[1] & 0x3; 
 check if there is wps ie, 
 if there is wpsie in beacon, the hostapd will update beacon twice when stating hostapd, 
 and at first time the security ie (RSNWPA IE) will not include in beacon. 
 todo: update wmm, ht cap 
 pmlmeinfo->WMM_enable; 
 pmlmeinfo->HT_enable; 
 pmlmeinfo->HT_info_enable = true; 
 pmlmeinfo->HT_caps_enable = true; 
 setting only at  first time 
 WEP Key will be set before this function, do not clear CAM. 
 clear CAM 
 set MSR to AP_Mode 
 Set BSSID REG 
 Set EDCA param reg 
  VO 
  VI 
 BE 
  BK 
 Set Security 
 Beacon Control related register 
 setting only at  first time 
 u32 initialgain; 
 initialgain = 0x1e; 
 disable dynamic functions, such as high power, DIG 
 Save_DM_Func_Flag(padapter); 
 Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, false); 
 turn on all dynamic functions 
 rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 )(&initialgain)); 
 set channel, bwmode 
 switch to the 40M Hz mode 
 pmlmeext->cur_bwmode = CHANNEL_WIDTH_40; 
 pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER; 
 pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER; 
 pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE; 
 let pnetwork_mlmeext == pnetwork_mlme. 
 update cur_wireless_mode 
 update RRSR after set channel and bandwidth 
 update capability after cur_wireless_mode updated 
 issue beacon frame 
 update bcmc sta_info 
 pmlmeext->bstart_bss = true; 
 beacon interval 
 ie + 8;	8: TimeStamp, 2: Beacon Interval 2:Capability 
 pbss_network->configuration.beacon_period = le16_to_cpu((unsigned short)p); 
 capability 
 cap = (unsigned short )rtw_get_capability_from_ie(ie); 
 cap = le16_to_cpu(cap); 
 SSID 
 channel 
  get supported rates 
 get ext_supported rates 
 parsing ERP_IE 
 update privacysecurity 
 wpa2 
 psk,  todo:802.1x 
 wpa 
 psk,  todo:802.1x 
 wmm 
 QoS Info, support U-APSD 
 disable all ACM bits since the WMM admission 
 control is not supported 
 BE 
 BK 
 VI 
 VO 
 parsing HT_CAP_IE 
 set  Max Rx AMPDU size  to 64K 
 parsing HT_INFO_IE 
 todo: 
 ht_cap = false; 
 ht_cap 
 issue beacon to start bss network 
 start_bss_network(padapter, (u8 )pbss_network); 
 alloc sta_info for ap itself 
  update AP's sta info 
 Aries, add, fix bug of flush_cam_entry at STOP AP mode , 0724 
 for check if already set beacon 
 update bcmc sta_info 
 update_bmc_sta(padapter); 
 Baddr is used for clearing acl_list 
 parsing ERP_IE 
 to get ie data len 
 update ie_length 
 struct mlme_ext_info pmlmeinfo; 
 pmlmeinfo = &(pmlmeext->mlmext_info); 
 8: TimeStamp, 2: Beacon Interval 2:Capability 
send_beacon must execute on TSR level 
  op_mode
  Set to 0 (HT pure) under the following conditions
 	  - all STAs in the BSS are 2040 MHz HT in 2040 MHz BSS or
 	  - all STAs in the BSS are 20 MHz HT in 20 MHz BSS
  Set to 1 (HT non-member protection) if there may be non-HT STAs
 	  in both the primary and the secondary channel
  Set to 2 if only HT STAs are associated in BSS,
 	  however and at least one 20 MHz HT STA is associated
  Set to 3 (HT mixed mode) when one or more non-HT STAs are associated
 	  (currently non-GF HT station is considered as non-HT STA also)
	 Note: currently we switch to the MIXED op mode if HT non-greenfield
	  station is associated. Probably it's a theoretical case, since
	  it looks like all known HT STAs support greenfield.
 update associated stations cap. 
 check asoc_queue 
 called > TSR LEVEL for USB or SDIO Interface
 update associated stations cap. 
 tear down Rx AMPDU 
  recipient 
 tear down TX AMPDU 
 originator 
 reset 
 reset 
 report_del_sta_event(padapter, psta->hwaddr, reason); 
 clear cam entry  key 
 free sta asoc_queue 
 spin_unlock_bh(&pstapriv->asoc_list_lock); 
 spin_lock_bh(&pstapriv->asoc_list_lock); 
 called > TSR LEVEL for USB or SDIO Interface
 update wmm cap. 
 update 802.11n ht cap. 
 called >= TSR LEVEL for USB or SDIO Interface
 add ratid 
 DM_RATR_STA_INIT 
 restore hw setting from sw data structures 
 restore group key, WEP keys is restored in ips_leave() 
 pairwise key 
 per sta pairwise key and settings 
 init_mlme_ap_info(padapter); 
 for ACL 
 reset and init security priv , this can refine with rtw_reset_securitypriv 
 for ACL 
 free_assoc_sta_resources 
 disconnect 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
The purpose of rtw_io.c
a. provides the API
b. provides the protocol engine
c. provides the software interface between caller and the hardware interface
Compiler Flag Option:
1. CONFIG_SDIO_HCI:
    a. USE_SYNC_IRP:  Only sync operations are provided.
    b. USE_ASYNC_IRP:Both syncasync operations are provided.
jackson@realtek.com.tw
 struct	io_queue	pio_queue = (struct io_queue )adapter->pio_queue; 
 struct	io_queue	pio_queue = (struct io_queue )adapter->pio_queue; 
 struct	io_queue	pio_queue = (struct io_queue )adapter->pio_queue; 
 struct	io_queue	pio_queue = (struct io_queue )adapter->pio_queue; 
 struct	io_queue	pio_queue = (struct io_queue )adapter->pio_queue; 
 struct	io_queue	pio_queue = (struct io_queue )adapter->pio_queue; 
 Increase and check if the continual_io_error of this @param dvobjprive is larger than MAX_CONTINUAL_IO_ERR
 @return true:
 @return false:
 Set the continual_io_error of this @param dvobjprive to 0
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
 when set_ssidset_bssid for rtw_do_join(), but scanning queue is empty 
 we try to issue sitesurvey firstly 
  submit site_survey_cmd 
  submit createbss_cmd to change to a ADHOC_MASTER 
 pmlmepriv->lock has been acquired by caller... 
  can't associate ; reset under-linking 
 when set_ssidset_bssid for rtw_do_join(), but there are no desired bss in scanning queue 
 we try to issue sitesurvey firstly 
 if in WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE, create bss or rejoin again 
 it means driver is in WIFI_ADHOC_MASTER_STATE, we needn't create bss again. 
 change to other mode from Ndis802_11APMode 
 will clr Linked_state; before this function, we must have checked whether issue dis-assoc_cmd or not 
 rtw_indicate_connect(padapter); 
 SecClearAllKeys(adapter); 
 modify for CONFIG_IEEE80211W, none 11w can use it 
  Scan or linking is in progress, do nothing. 
 rtw_get_cur_max_rate -
 @adapter: pointer to struct adapter structure
 Return 0 or 100Kbps
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
 WEP related ===== 
	Need to consider the fragment  situation
  exclude ICV 
 wepkey 
 start to encrypt each fragment 
 the last fragment 
  exclude ICV 
 start to decrypt recvframe 
 keyindex =(iv[3]&0x3); 
 memcpy(&wepkey[3], &psecuritypriv->dot11DefKey[psecuritypriv->dot11PrivacyKeyIndex].skey[0], keylength); 
 decrypt payload include icv 
 calculate icv and compare the icv 
 3		=====TKIP related ===== 
  Convert from Byte[] to Us3232 in a portable way 
  Convert from Us3232 to Byte[] in a portable way 
  Reset the state to the empty message. 
  Set the key 
  and reset the message 
  Append the byte to our word-sized buffer 
  Process the word if it is full. 
  Clear the buffer 
  This is simple 
  Append the minimum padding 
  and then zeroes until the length is a multiple of 4 
  The appendByte function has already computed the result. 
  Reset to the empty message. 
 Michael MIC pseudo header: DA, SA, 3 x 0, Priority 
 ToDS == 1 
 DA 
 From Ds == 1 
 ToDS == 0 
 DA 
 From Ds == 1 
 macros for extractioncreation of unsigned charunsigned short values  
 select the Nth 16-bit word of the temporal key unsigned char array TK[]   
 S-box lookup: 16 bits --> 16 bits 
 fixed algorithm "parameters" 
 this needs to be "big enough"     
 2-unsigned char by 2-unsigned char subset of the full AES S-box table 
 Sbox for hash (can be in ROM)     
 second half of table is unsigned char-reversed version of first! 
 Routine: Phase 1 -- generate P1K, given TA, TK, IV32
 Inputs:
     tk[]      = temporal key                         [128 bits]
     ta[]      = transmitter's MAC address            [ 48 bits]
     iv32      = upper 32 bits of IV                  [ 32 bits]
 Output:
     p1k[]     = Phase 1 key                          [ 80 bits]
 Note:
     This function only needs to be called every 216 packets,
     although in theory it could be called every packet.
 Initialize the 80 bits of P1K[] from IV32 and TA[0..5]     
 use TA[] as little-endian 
 Now compute an unbalanced Feistel cipher with 80-bit block 
 size on the 80-bit block P1K[], using the 128-bit key TK[] 
 Each add operation here is mod 216 
 avoid "slide attacks" 
 Routine: Phase 2 -- generate RC4KEY, given TK, P1K, IV16
 Inputs:
     tk[]      = Temporal key                         [128 bits]
     p1k[]     = Phase 1 output key                   [ 80 bits]
     iv16      = low 16 bits of IV counter            [ 16 bits]
 Output:
     rc4key[]  = the key used to encrypt the packet   [128 bits]
 Note:
     The value {TA, IV32, IV16} for Phase1Phase2 must be unique
     across all packets using the same key TK value. Then, for a
     given value of TK[], this TKIP48 construction guarantees that
     the final RC4KEY value is unique across all packets.
 Suggested implementation optimization: if PPK[] is "overlaid"
     appropriately on RC4KEY[], there is no need for the final
     for loop below that copies the PPK[] result into RC4KEY[].
 temporary key for mixing    
 Note: all adds in the PPK[] equations below are mod 216         
 first, copy P1K to PPK      
 next,  add in IV16          
 Bijective non-linear mixing of the 96 bits of PPK[0..5]           
 Mix key in each "round"     
 Total # S-box lookups == 6  
 Final sweep: bijective, "linear". Rotates kill LSB correlations   
 Use all of TK[] in Phase2   
 Note: At this point, for a given key TK[0..15], the 96-bit output 
       value PPK[0..5] is guaranteed to be unique, as a function   
       of the 96-bit "input" value   {TA, IV32, IV16}. That is, P1K  
       is now a keyed permutation of {TA, IV32, IV16}.               
 Set RC4KEY[0..3], which includes "cleartext" portion of RC4 key   
 RC4KEY[0..2] is the WEP IV  
 Help avoid weak (FMS) keys  
 Copy 96 bits of PPK[0..5] to RC4KEY[4..15]  (little-endian)       
 The hlen isn't include the IV 
  exclude ICV 
 4 start to encrypt each fragment 
 4 the last fragment 
 The hlen isn't include the IV 
  exclude ICV 
 4 start to decrypt recvframe 
 4 decrypt payload include icv 
 3			=====AES related ===== 
 Function Prototypes 
  add for CONFIG_IEEE80211W, none 11w also can use 
 for CONFIG_IEEE80211W, none 11w also can use 
 for CONFIG_IEEE80211W, none 11w also can use 
 aes128k128d()                        
 Performs a 128 bit AES encrypt with  
 128 bit data.                        
 construct_mic_iv()                           
 Builds the MIC IV from header fields and PN  
 Baron think the function is construct CCM    
 nonce                                        
 add for CONFIG_IEEE80211W, none 11w also can use 
 QoS_TC           
 mute bits 7-4    
 802.11w management frame should set management bit(4) 
 mic_iv[2:7] = A2[0:5] = mpdu[10:15] 
 mic_iv[8:13] = PN[0:5] 
 mic_iv[8:13] = PN[5:0] 
 construct_mic_header1()                      
 Builds the first MIC header block from       
 header fields.                               
 Build AAD SC, A1, A2                           
 for CONFIG_IEEE80211W, none 11w also can use 
 802.11w management frame don't AND subtype bits 4, 5, 6 of frame control field 
 Mute CF poll & CF ack bits 
 Mute retry, more data and pwr mgt bits 
 A1 
 A2 
 construct_mic_header2()                      
 Builds the last MIC header block from        
 header fields.                               
 A3 
 mpdu[23]; 
 A4 
 mute bits 15 - 4 
 A4 
 construct_mic_header2()                      
 Builds the last MIC header block from        
 header fields.                               
 Baron think the function is construct CCM    
 nonce                                        
 for CONFIG_IEEE80211W, none 11w also can use 
 flag 
 QoC_Control 
 802.11w management frame should set management bit(4) 
 ctr_preload[2:7] = A2[0:5] = mpdu[10:15] 
 ctr_preload[8:13] = PN[0:5] 
 ctr_preload[8:13] = PN[5:0] 
 Ctr 
 bitwise_xor()                    
 A 128 bit, bitwise exclusive or  
 Intermediate Buffers 
  add for CONFIG_IEEE80211W, none 11w also can use 
 message, 
  add for CONFIG_IEEE80211W, none 11w also can use 
 message 
  add for CONFIG_IEEE80211W, none 11w also can use 
 message, 
 Find start of payload 
 Calculate MIC 
 Add on the final payload block if it needs padding 
 Insert MIC into payload 
 message, 
  add for CONFIG_IEEE80211W, none 11w also can use 
 If there is a short final block, then pad it,
 encrypt it and copy the unpadded part back   
 message, 
  add for CONFIG_IEEE80211W, none 11w also can use 
 Encrypt the MIC 
 message, 
  add for CONFIG_IEEE80211W, none 11w also can use 
  exclude ICV 
static
 unsigned char message[MAX_MSG_SIZE]; 
 Intermediate Buffers 
  payload,iv 
 4 start to encrypt each fragment 
 4 the last fragment 
 Intermediate Buffers 
 start to decrypt the payload 
 plen including LLC, payload_length and mic) 
 only for data packet . add for CONFIG_IEEE80211W, none 11w also can use 
  now, decrypt pframe with hdrlen offset and plen long 
  8 is for extiv 
  add for CONFIG_IEEE80211W, none 11w also can use 
 If there is a short final block, then pad it,
 encrypt it and copy the unpadded part back   
  add for CONFIG_IEEE80211W, none 11w also can use 
 start to calculate the mic 
 8 is for ext iv len 
  add for CONFIG_IEEE80211W, none 11w also can use 
  add for CONFIG_IEEE80211W, none 11w also can use 
 Find start of payload 
 Calculate MIC 
 Add on the final payload block if it needs padding 
 Insert MIC into payload 
  add for CONFIG_IEEE80211W, none 11w also can use 
 If there is a short final block, then pad it,
 encrypt it and copy the unpadded part back   
  add for CONFIG_IEEE80211W, none 11w also can use 
 Encrypt the MIC 
  add for CONFIG_IEEE80211W, none 11w also can use 
 compare the mic 
  exclude ICV 
static
 unsigned char message[MAX_MSG_SIZE]; 
 Intermediate Buffers 
  payload,iv 
 4 start to encrypt each fragment 
 PKT start 
 mapping to wlan header 
 save the frame body + MME 
 find MME IE pointer 
 Baron 
 save packet number 
 BIP packet number should bigger than previous BIP packet 
 copy key index 
 clear the MIC field of MME to zero 
 conscruct AAD, copy frame control field 
 conscruct AAD, copy address 1 to address 3 
 MIC field should be last 8 bytes of packet (packet without FCS) 
  omac1_aes_128_vector - One-Key CBC MAC (OMAC1) hash with AES-128
  @key: 128-bit key for the hash operation
  @num_elem: Number of elements in the data vector
  @addr: Pointers to the data areas
  @len: Lengths of the data blocks
  @mac: Buffer for MAC (128 bits, i.e., 16 bytes)
  Returns: 0 on success, -1 on failure
  This is a mode for using block cipher (AES in this case) for authentication.
  OMAC1 was standardized with the name CMAC by NIST in a Special Publication
  (SP) 800-38B.
  omac1_aes_128 - One-Key CBC MAC (OMAC1) hash with AES-128 (aka AES-CMAC)
  @key: 128-bit key for the hash operation
  @data: Data buffer for which a MAC is determined
  @data_len: Length of data buffer in bytes
  @mac: Buffer for MAC (128 bits, i.e., 16 bytes)
  Returns: 0 on success, -1 on failure
  This is a mode for using block cipher (AES in this case) for authentication.
  OMAC1 was standardized with the name CMAC by NIST in a Special Publication
  (SP) 800-38B.
 Restore HW wep key setting according to key_mask 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2013 Realtek Corporation. All rights reserved.
 BIT0 "ODM_COMP_DIG",
 BIT1 "ODM_COMP_RA_MASK",
 BIT2 "ODM_COMP_DYNAMIC_TXPWR",
 BIT3 "ODM_COMP_FA_CNT",
 BIT4 "ODM_COMP_RSSI_MONITOR",
 BIT5 "ODM_COMP_CCK_PD",
 BIT6 "ODM_COMP_ANT_DIV",
 BIT7 "ODM_COMP_PWR_SAVE",
 BIT8 "ODM_COMP_PWR_TRAIN",
 BIT9 "ODM_COMP_RATE_ADAPTIVE",
 BIT10 "ODM_COMP_PATH_DIV",
 BIT11 "ODM_COMP_PSD",
 BIT12 "ODM_COMP_DYNAMIC_PRICCA",
 BIT13 "ODM_COMP_RXHP",
 BIT14 "ODM_COMP_MP",
 BIT15 "ODM_COMP_DYNAMIC_ATC",
 BIT16 "ODM_COMP_EDCA_TURBO",
 BIT17 "ODM_COMP_EARLY_MODE",
 BIT18 NULL,
 BIT19 NULL,
 BIT20 NULL,
 BIT21 NULL,
 BIT22 NULL,
 BIT23 NULL,
 BIT24 "ODM_COMP_TX_PWR_TRACK",
 BIT25 "ODM_COMP_RX_GAIN_TRACK",
 BIT26 "ODM_COMP_CALIBRATION",
 BIT27 NULL,
 BIT28 NULL,
 BIT29 NULL,
 BIT30 "ODM_COMP_COMMON",
 BIT31 "ODM_COMP_INIT",
 BIT0 "ODM_BB_DIG",
 BIT1 "ODM_BB_RA_MASK",
 BIT2 "ODM_BB_DYNAMIC_TXPWR",
 BIT3 "ODM_BB_FA_CNT",
 BIT4 "ODM_BB_RSSI_MONITOR",
 BIT5 "ODM_BB_CCK_PD",
 BIT6 "ODM_BB_ANT_DIV",
 BIT7 "ODM_BB_PWR_SAVE",
 BIT8 "ODM_BB_PWR_TRAIN",
 BIT9 "ODM_BB_RATE_ADAPTIVE",
 BIT10 "ODM_BB_PATH_DIV",
 BIT11 "ODM_BB_PSD",
 BIT12 "ODM_BB_RXHP",
 BIT13 "ODM_BB_ADAPTIVITY",
 BIT14 "ODM_BB_DYNAMIC_ATC",
 BIT15 NULL,
 BIT16 "ODM_MAC_EDCA_TURBO",
 BIT17 "ODM_MAC_EARLY_MODE",
 BIT18 NULL,
 BIT19 NULL,
 BIT20 NULL,
 BIT21 NULL,
 BIT22 NULL,
 BIT23 NULL,
 BIT24 "ODM_RF_TX_PWR_TRACK",
 BIT25 "ODM_RF_RX_GAIN_TRACK",
 BIT26 "ODM_RF_CALIBRATION",
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
 ms 
 if wowlan is not supported, kernel generate a disconnect at each suspend
  cf: netwirelesssysfs.c, so register a stub wowlan.
  Moreover wowlan has to be enabled via a the nl80211_set_wowlan callback.
  (from user space, e.g. iw phy0 wowlan enable)
 spt_band.ht_cap 
 copy AP 
 not supported 
 struct ieee80211_supported_band band; 
 To reduce PBC Overlap rate 
 spin_lock_bh(&pwdev_priv->scan_req_lock); 
  it means under processing WPS 
 clear sr 
 spin_unlock_bh(&pwdev_priv->scan_req_lock); 
 We've set wiphy's signal_type as CFG80211_SIGNAL_TYPE_MBM: signal strength in mBm (100dBm) 
 dbm 
 dbm 
pmlmeext->mgnt_seq);
 pmlmeext->mgnt_seq++; 
  WIFI_BEACON 
	Check the given bss is valid by kernel API cfg80211_get_bss()
	@padapter : the given adapter
	return true if bss is valid,  false for not found.
 notify cfg80211 that device joined an IBSS 
GFP_KERNEL);
 ret = -EINVAL; 
 wep default key has not been set, so use this key index as default key. 
 group key 
 group key 
 DEBUG_ERR("set key length :param->u.crypt.key_len =%d\n", param->u.crypt.key_len); 
 set mic key 
 rx will use bmc_sta's dot118021XPrivacy 
  psk802_1x 
 pairwise key 
 DEBUG_ERR("set key length :param->u.crypt.key_len =%d\n", param->u.crypt.key_len); 
 set mic key 
 group key??? 
 DEBUG_ERR("set key length :param->u.crypt.key_len =%d\n", param->u.crypt.key_len); 
 set mic key 
 rx will use bmc_sta's dot118021XPrivacy 
 wep default key has not been set, so use this key index as default key. 
  802_1x 
 sta mode 
 Jeff: don't disable ieee8021x_blocked while clearing key 
 pairwise key 
 set mic key 
 DEBUG_ERR(("\nset key length :param->u.crypt.key_len =%d\n", param->u.crypt.key_len)); 
 _set_timer(&padapter->securitypriv.tkip_timer, 50); 
 group key 
 save the IGTK key, length 16 bytes 
						
						for (no = 0;no<16;no++)
							printk(" %02x ", padapter->securitypriv.dot11wBIPKey[param->u.crypt.idx].skey[no]);
 DEBUG_ERR(("Set OID_802_11_ADD_KEY: bcmc stainfo is null\n")); 
 Jeff: don't disable ieee8021x_blocked while clearing key 
 adhoc mode 
 todo: remove key 
 remove = 1; 
 for wpawpa2 group key 
 for wpawpa2 pairwise key 
 clear the flag of wep default key set. 
 set wep default key 
 set the flag to represent that wep default key has been set 
 for infra.P2PClient mode 
 for Ad-HocAP mode 
 TODO: should acquire station info... 
 avoid WARN_ON(request != wiphy_to_dev(request->wiphy)->scan_req); 
notify_channel,
WLAN_CAPABILITY_ESS,
WLAN_CAPABILITY_ESS);
 report network only if the current channel set contains the channel to which this network belongs 
 ev =translate_scan(padapter, a, pnetwork, ev, stop); 
 endif 
 parsing request ssids, n_ssids 
 parsing channels, n_channels 
 return -ENOTSUPP; 
 if (psecuritypriv->dot11PrivacyAlgrthm >= _AES_) 
	psecuritypriv->ndisauthtype = Ndis802_11AuthModeWPA2PSK; 
 auth_type = UMAC_AUTH_TYPE_8021X; 
 Treat this as normal case, but need to clear WIFI_UNDER_WPS 
 handle wps_ie 
 TKIP and AES disallow multicast packets until installing group key 
 WPS open need to enable multicast 
  check_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS) == true) 
 open system 
 open system 
 For WEP Shared auth 
 rtw_set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus); 
 overwrite PMKID 
			
			  BSSID is matched, the same AP => Remove this PMKID information
			  and reset it.
  WIFI_REASSOCREQ 
 Skip the ratio tap header 
 Check if the QoS bit is set 
		 Check if this ia a Wireless Distribution System (WDS) frame
		  which has 4 MAC addresses
		 Skip the 802.11 header, QoS (if any) and SNAP, but leave spaces for
		  for two MAC addresses
 Use the real net device to transmit the packet 
 only for action frames 
 u8 category, action, OUI_Subtype, dialogToken = 0; 
 unsigned char frame_body; 
 starting alloc mgmt frame to dump it 
 update attribute 
 update seq number 
  wdev 
  24 =beacon header len. 
 check wps ie if inclued 
 pbss_network->ies will not include p2p_ie, wfd ie 
 clear CAM 
 check asoc_queue 
 check asoc_queue 
 starting alloc mgmt frame to dump it 
 ret = -ENOMEM; 
 update attribute 
 update seq number 
 cookie generation 
 indicate ack before issue frame to avoid racing with rsp frame 
 Mbps 
 Mbps 
	
	 Maximum length of AMPDU that the STA can receive.
	 Length = 2 ^ (13 + max_ampdu_length_exp) - 1 (octets)
Minimum MPDU start spacing , 
	
	 hw->wiphy->bands[NL80211_BAND_2GHZ]
	 base on ant_num
	 rx_mask: RX mask
	 if rx_ant = 1 rx_mask[0]= 0xff;==>MCS0-MCS7
	 if rx_ant =2 rx_mask[1]= 0xff;==>MCS8-MCS15
	 if rx_ant >=3 rx_mask[2]= 0xff;
	 if BW_40 rx_mask[4]= 0x01;
	 highest supported RX rate
 copy mac_addr to wiphy 
 if (padapter->registrypriv.wireless_mode & WIRELESS_11G) 
 wiphy 
 init regulary domain 
  wdev 
  will be init in rtw_hal_init() 
  Must sync with _rtw_init_mlme_priv() 
  pmlmepriv->fw_state = WIFI_STATION_STATE 
 init pwdev_priv 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
 padapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled; 
 don't update "psecuritypriv->dot11PrivacyAlgrthm" and 
 psecuritypriv->dot11PrivacyKeyIndex =keyid", but can rtw_set_key to fwcam 
  802_1x 
 sta mode 
 DEBUG_ERR(("Set wpa_set_encryption: Obtain Sta_info fail\n")); 
 Jeff: don't disable ieee8021x_blocked while clearing key 
 pairwise key 
 set mic key 
 DEBUG_ERR(("\nset key length :param->u.crypt.key_len =%d\n", param->u.crypt.key_len)); 
 _set_timer(&padapter->securitypriv.tkip_timer, 50); 
 group key 
 only TKIP group key need to install this 
 printk("BIP key_len =%d , index =%d @@@@@@@@@@@@@@@@@@\n", param->u.crypt.key_len, param->u.crypt.idx); 
 save the IGTK key, length 16 bytes 
						printk("IGTK key below:\n");
						for (no = 0;no<16;no++)
							printk(" %02x ", padapter->securitypriv.dot11wBIPKey[param->u.crypt.idx].skey[no]);
 DEBUG_ERR(("Set OID_802_11_ADD_KEY: bcmc stainfo is null\n")); 
 Jeff: don't disable ieee8021x_blocked while clearing key 
 adhoc mode 
 set wps_ie 
 goto next 
 TKIP and AES disallow multicast packets until installing group key 
 WPS open need to enable multicast 
  check_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS) == true) 
 802.1x 
 ret = ieee80211_wpa_enable(ieee, value); 
 WPA 
 WPA_PSK 
 WPA2 
 WPA2_PSK 
 ieee->tkip_countermeasures =value; 
		 HACK:
		 
		  wpa_supplicant calls set_wpa_enabled when the driver
		  is loaded and unloaded, regardless of if WPA is being
		  used.  No other calls are made which can be used to
		  determine if encryption will be used or not prior to
		  association being expected.  If encryption is not being
		  used, drop_unencrypted is set to false, else true -- we
		  can use this to determine if the CAP_PRIVACY_ON bit should
		  be set.
 ieee->privacy_invoked =value; 
 ieee->ieee802_1x =value; 
  added for WPA2 mixed mode 
		
		spin_lock_irqsave(&ieee->wpax_suitlist_lock, flags);
		ieee->wpax_type_set = 1;
		ieee->wpax_type_notify = value;
		spin_unlock_irqrestore(&ieee->wpax_suitlist_lock, flags);
 down(&ieee->wx_sem); 
 ret = wpa_set_wpa_ie(dev, param, p->length); 
 up(&ieee->wx_sem); 
 sizeof(struct ieee_param) = 64 bytes; 
 if (param_len !=  (u32) ((u8 ) param->u.crypt.key - (u8 ) param) + param->u.crypt.key_len) 
 ret = -EINVAL; 
 todo:clear default encryption keys 
 don't update "psecuritypriv->dot11PrivacyAlgrthm" and 
 psecuritypriv->dot11PrivacyKeyIndex =keyid", but can rtw_set_key to cam 
  group key 
 DEBUG_ERR("set key length :param->u.crypt.key_len =%d\n", param->u.crypt.key_len); 
 set mic key 
 rx will use bmc_sta's dot118021XPrivacy 
  psk802_1x 
 DEBUG_ERR("set key length :param->u.crypt.key_len =%d\n", param->u.crypt.key_len); 
 set mic key 
 group key??? 
 DEBUG_ERR("set key length :param->u.crypt.key_len =%d\n", param->u.crypt.key_len); 
 set mic key 
 rx will use bmc_sta's dot118021XPrivacy 
  12 = param header, 2:no packed 
 _irqL irqL; 
 struct list_head	phead, plist; 
 struct sta_info psta = NULL; 
 struct sta_priv pstapriv = &padapter->stapriv; 
 clear CAM 
	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
	if (psta)
	{
		rtw_free_stainfo(padapter,  psta);
		psta = NULL;
	}
 psta = rtw_alloc_stainfo(pstapriv, param->sta_addr); 
 aid = 1~2007 
 check wmm cap. 
 chec 802.11n ht cap. 
		nonerp_set : BIT(0)
		no_short_slot_time_set : BIT(1)
		no_short_preamble_set : BIT(2)
		no_ht_gf_set : BIT(3)
		no_ht_set : BIT(4)
		ht_20mhz_set : BIT(5)
  12 = param header, 2:no packed 
  12 = param header, 2:no packed 
  12 = param header, 2:no packed 
  12 = param header, 2:no packed 
	
	 this function is expect to call in master mode, which allows no power saving
	 so, we just check hw_init_completed
  copy from netwirelesswext.c end 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  add for CONFIG_IEEE80211W, none 11w also can use 
 802.1x 
  Added by Albert 20090218 
  We have to backup the PMK information for WiFi PMK Caching test item. 
  Backup the btkip_countermeasure information. 
  When the countermeasure is trigger, the driver have to disconnect with AP for 60 seconds. 
 reset RX BIP packet number 
  Added by Albert 20090218 
  Restore the PMK information to securitypriv structure for the following connection. 
 reset values in securitypriv 
 if (adapter->mlmepriv.fw_state & WIFI_STATION_STATE) 
 open system 
  add for CONFIG_IEEE80211W, none 11w also can use 
 struct rt_pmkid_list   backupPMKIDList[ NUM_PMKID_CACHE ]; 
  Do it first for tx broadcast pkt after disconnection issue! 
 modify for CONFIG_IEEE80211W, none 11w also can use the same command 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
 No free space for Tx, tx_worker is too slow 
 free sta asoc_queue 
 avoid come from STA1 and send back STA1 
 dev_kfree_skb_any(skb); 
  Caller shall tx this multicast frame via normal way. 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
 end: all zeroes 				},
 3 1. init SDIO bus 
 alloc memory for HAL DATA 
  hal dep 
  hal dep 
 3 1. init network device data 
 3 3. init driver special setting, interface, OS and hardware relative 
 4 3.1 set hardware operation functions 
 3 5. initialize Chip version 
 3 6. read efuseeeprom data 
 3 7. init driver common data 
 3 8. get WLan MAC address 
  set mac addr 
  drv_init() - a device potentially for us
  notes: drv_init() is called when the bus driver has located a card for us to support.
         We accept the new device by returning 0.
 dev_alloc_name && register_netdev 
 test surprise remove 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
 free skb by driver 
 alloc os related resource in union recv_frame 
 free os related resource in union recv_frame 
 free skb by driver 
 free os related resource in struct recv_buf 
		
		  remove RFC1042 or Bridge-Tunnel encapsulation and replace
		  EtherType
 Leave Ethernet header part of hdr and full payload 
 Indicate the packets to upper layer 
 skb->ip_summed = CHECKSUM_NONE; 
  to APself 
 pointers to NULL before rtw_free_recvframe() 
 enqueue back to free_recv_queue 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
  Return:
 0		Success
 others	Fail
  Return:
 0		Success
 others	Fail
  Return:
 0		Success
 others	Fail
  Return:
 0		Success
 others	Fail
  Use CMD53 to read data from SDIO device.
  This function MUST be called after sdio_claim_host() or
  in SDIO ISR(host had been claimed).
  Parameters:
 psdio	pointer of SDIO_DATA
 addr	address to read
 cnt		amount to read
 pdata	pointer to put data, this should be a "DMA:able scratch buffer"!
  Return:
 0		Success
 others	Fail
  Use CMD53 to read data from SDIO device.
  Parameters:
 psdio	pointer of SDIO_DATA
 addr	address to read
 cnt		amount to read
 pdata	pointer to put data, this should be a "DMA:able scratch buffer"!
  Return:
 0		Success
 others	Fail
  Use CMD53 to write data to SDIO device.
  This function MUST be called after sdio_claim_host() or
  in SDIO ISR(host had been claimed).
  Parameters:
 psdio	pointer of SDIO_DATA
 addr	address to write
 cnt		amount to write
 pdata	data pointer, this should be a "DMA:able scratch buffer"!
  Return:
 0		Success
 others	Fail
	size = sdio_align_size(func, cnt); 
  Use CMD53 to write data to SDIO device.
  Parameters:
   psdio	pointer of SDIO_DATA
   addr	address to write
   cnt		amount to write
   pdata	data pointer, this should be a "DMA:able scratch buffer"!
  Return:
   0		Success
   others	Fail
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2009-2010  Realtek Corporation.
  REG_RULE(freq start, freq end, bandwidth, max gain, eirp, reg_flags)
  Only these channels all allow active
  scan on all world regulatory domains
 2G chan 01 - chan 11 
  We enable active scan on these a case
  by case basis by regulatory domain
 2G chan 12 - chan 13, PASSIV SCAN 
 NL80211_BAND_2GHZ 
 not supported 
 all channels disable 
 channels apply by channel plans. 
 Hard code flags 
 Hard code flags 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
 module param defaults 
 RTL8712_AIR_TRX; 
 Ndis802_11Infrastructure;infra, ad-hoc, auto 
 struct ndis_802_11_ssid	ssid; 
 ad-hoc support requirement 
 long, short, auto 
 active, passive 
 int smart_ps = 1; 
 USB_RX_AGG_DMA = 1, USB_RX_AGG_USB =2 
 int qos_enable = 0; 
  0:By SW 1:By HW. 
  default is set to enable the wmm. 
  0: 20 MHz, 1: 40 MHz
  2.4G use bit 0 ~ 3
  0x01 means enable 2.4G 40MHz
 for enable tx_ampdu ,0: disable, 0x1:enable (but wifi_spec should be 0), 0x2: force enable (don't care wifi_spec) 
  0: disable, 1:enable 2.4g 
  0: disabled, 1:enabled, 2:auto . There is an IOT issu with DLINK DIR-629 when the flag turn on 
  Short GI support Bit Map 
  BIT0 - 20MHz, 0: non-support, 1: support 
  BIT1 - 40MHz, 0: non-support, 1: support 
  BIT2 - 80MHz, 0: non-support, 1: support 
  BIT3 - 160MHz, 0: non-support, 1: support 
  BIT0: Enable VHT LDPC Rx, BIT1: Enable VHT LDPC Tx, BIT4: Enable HT LDPC Rx, BIT5: Enable HT LDPC Tx 
  BIT0: Enable VHT STBC Rx, BIT1: Enable VHT STBC Tx, BIT4: Enable HT STBC Rx, BIT5: Enable HT STBC Tx 
  BIT0: Enable VHT Beamformer, BIT1: Enable VHT Beamformee, BIT4: Enable HT Beamformer, BIT5: Enable HT Beamformee 
 Use 2 path Tx to transmit MCS0~7 and legacy mode 
  <0: undefined, >0: Antenna number 
  0:OFF , 1:ON, 2:decide by Efuse config 
 0:decide by efuse  1: for 88EE, 1Tx and 1RxCG are diversity.(2 Ant with SPDT), 2:  for 88EE, 1Tx and 2Rx are diversity.(2 Ant, Tx and RxCG are both on aux port, RxCS is on main port), 3: for 88EE, 1Tx and 1RxCG are fixed.(1Ant, Tx and RxCG are both on aux port) 
 0: disable, 1:enable 
  temp mac address if users want to use instead of the mac address in Efuse 
 registry_par->hci = (u8)hci; 
 registry_par->qos_enable = (u8)rtw_qos_enable; 
 UAPSD 
 addr->sa_data[4], addr->sa_data[5]); 
 eth_hw_addr_set(pnetdev, addr->sa_data); 
 padapter->bset_hwaddr = true; 
 pxmitpriv->tx_pkts++; 
 precvpriv->rx_pkts++; 
  AC to queue mapping
  AC_VO -> queue 0
  AC_VI -> queue 1
  AC_BE -> queue 2
  AC_BK -> queue 3
 Given a data frame determine the 802.1p1d tag to use. 
	 skb->priority values from 256->263 are magic values to
	  directly indicate a specific 802.1d priority.  This is used
	  to allow 802.1d priority to be passed directly in from VLAN
	  tags, etc.
 rtw_netif_stop_queue(pnetdev); 
 pnetdev->init = NULL; 
 pnetdev->tx_timeout = NULL; 
 3 second timeout 
 step 2. 
 will call netdev_close() 
 wait for cmd_thread to run 
  Below is to termindate tx_thread... 
 xmit_priv 
 pxmitpriv->rts_thresh = pregistrypriv->rts_thresh; 
 recv_priv 
 mlme_priv 
 qos_priv 
 pmlmepriv->qospriv.qos_option = pregistrypriv->wmm_enable; 
 ht_priv 
 set to disabled 
 security_priv 
 rtw_get_encrypt_decrypt_from_registrypriv(padapter); 
 open system 
 registry_priv 
 hal_priv 
 misc. 
 for debug purpose 
 macid = 1 for bcmc stainfo 
 hal_priv 
 pmlmepriv->LinkDetectInfo.TrafficBusyState = false; 
 mlmeextpriv 
  add for CONFIG_IEEE80211W, none 11w also can use 
  We don't need to memset padapter->XXX to zero, because adapter is allocated by vzalloc(). 
 memset((unsigned char )&padapter->securitypriv, 0, sizeof (struct security_priv)); 
 cancel dm timer 
 free_io_queue(padapter); 
 will free bcmc_stainfo here 
 kfree((void )padapter); 
 free the old_pnetdev 
  clear pbuddystruct adapter to avoid access wrong pointer. 
 alloc netdev name 
 Tell the network stack we exist 
 struct pwrctrl_priv pwrpriv = adapter_to_pwrctl(padapter); 
 padapter->bup = true; 
 rtw_pwr_wakeup(padapter); 
if (!padapter->hw_init_completed)
	{
		padapter->bDriverStopped = true;
		rtw_dev_unload(padapter);
	}
 s1. 
 s2. 
 s2-2.  indicate disconnect to os 
 s2-3. 
 s2-4. 
 check the status of IPS 
 check HW status and SW state 
 amy modify 20120221 for power seq is different between driver open and ips 
 s2-2.  indicate disconnect to os 
 s2-3. 
 s2-4. 
 sdio_deinit(adapter_to_dvobj(padapter)); 
  wait for the latest FW to remove this condition. 
  interface init 
 if (sdio_init(adapter_to_dvobj(padapter)) != _SUCCESS) 
 if (sdio_alloc_irq(adapter_to_dvobj(padapter)) != _SUCCESS) 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
 Translate the OS dependent @param error_code to OS independent RTW_STATUS_CODE
 @return: one of RTW_STATUS_CODE
 free the old_pnetdev 
 duplicate src 
 replace buf with dup 
 free ori 
  rtw_cbuf_full - test if cbuf is full
  @cbuf: pointer of struct rtw_cbuf
  Returns: true if cbuf is full
  rtw_cbuf_empty - test if cbuf is empty
  @cbuf: pointer of struct rtw_cbuf
  Returns: true if cbuf is empty
  rtw_cbuf_push - push a pointer into cbuf
  @cbuf: pointer of struct rtw_cbuf
  @buf: pointer to push in
  Lock free operation, be careful of the use scheme
  Returns: true push success
  rtw_cbuf_pop - pop a pointer from cbuf
  @cbuf: pointer of struct rtw_cbuf
  Lock free operation, be careful of the use scheme
  Returns: pointer popped out
  rtw_cbuf_alloc - allocate a rtw_cbuf with given size and do initialization
  @size: size of pointer
  Returns: pointer of srtuct rtw_cbuf, NULL for allocation failure
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
 MAC Setting 
 Reg4C[25]=1, Reg4C[23]=1 for pin output 
 Pin Settings 
 Reg870[8]=1'b0, Reg870[9]=1'b0	antsel antselb by HW 
 Reg864[10]=1'b0	antsel2 by HW 
 Regb2c[22]=1'b0	disable CSCG switch 
 Regb2c[31]=1'b1	output at CG only 
 OFDM Settings 
 CCK Settings 
 Fix CCK PHY status report issue 
 CCK complete HW AntDiv within 64 samples 
 antenna mapping table 
 MAC Setting 
 Reg4C[25]=1, Reg4C[23]=1 for pin output 
 Pin Settings 
 Reg870[8]=1'b0, Reg870[9]=1'b0		antsel antselb by HW 
 Reg864[10]=1'b0	antsel2 by HW 
 Regb2c[22]=1'b0	disable CSCG switch 
 Regb2c[31]=1'b1	output at CG only 
 OFDM Settings 
 CCK Settings 
 Fix CCK PHY status report issue 
 CCK complete HW AntDiv within 64 samples 
 Tx Settings 
 Reg80c[21]=1'b0		from TX Reg 
 antenna mapping table 
 testchip 
 Reg858[10:8]=3'b001 
 Reg858[13:11]=3'b010 
 MPchip 
 Reg914=3'b010, Reg915=3'b001 
 MAC Setting 
 Reg4C[25]=1, Reg4C[23]=1 for pin output 
 Reg7B4[16]=1 enable antenna training, Reg7B4[17]=1 enable A2 match 
 Match MAC ADDR 
 Reg870[8]=1'b0, Reg870[9]=1'b0		antsel antselb by HW 
 Reg864[10]=1'b0	antsel2 by HW 
 Regb2c[22]=1'b0	disable CSCG switch 
 Regb2c[31]=1'b1	output at CG only 
 antenna mapping table 
 testchip 
 Reg858[10:8]=3'b001 
 Reg858[13:11]=3'b010 
 MPchip 
 testchip 
 Reg858[10:8]=3'b000 
 Reg858[13:11]=3'b001 
 Reg878[0],Reg858[14:15])=3'b010 
 Reg878[3:1]=3b'011 
 Reg878[6:4]=3b'100 
 Reg878[9:7]=3b'101 
 Reg878[12:10]=3b'110 
 Reg878[15:13]=3b'111 
 MPchip 
 Default Ant Setting when no fast training 
 Reg80c[21]=1'b1		from TX Info 
 Default RX 
 Optional RX 
 Enter Traing state 
 Reg864[2:0]=3'd6	ant combination=reg864[2:0]+1 
 RegC50[7]=1'b1		enable HW AntDiv 
 Default RX 
 Optional RX 
 Default TX 
 Resp Tx 
 Default RX 
 Optional RX 
 2 Caculate RSSI per Antenna 
 2 Select MaxRSSI for DIG 
 2 Select RX Idle Antenna 
 2 Select TRX Antenna 
 2 Set RX Idle Antenna 
 RegC50[7]=1'b1		enable HW AntDiv 
 Enable CCK AntDiv 
 Reg80c[21]=1'b0		from TX Reg 
 Because HW AntDiv is disabled before Link, we enable HW AntDiv after link 
 RegC50[7]=1'b1		enable HW AntDiv 
 Enable CCK AntDiv 
 Reg80c[21]=1'b1		from TX Info 
 3============================================================ 
 3 Dynamic Primary CCA 
 3============================================================ 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
 init recv_buf 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
                           RadioA_1T.TXT
  This (offset, data) pair meets the condition. 
  This line is the start line of branch. 
  Discard the following (offset, data) pairs. 
  prevent from for-loop += 2 
  Configure matched pairs and skip to end of if-else. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) Realtek Semiconductor Corp.
Module Name:
	RateAdaptive.c
Abstract:
	Implement Rate Adaptive functions for common operations.
Major Change History:
	When       Who               What
	---------- ---------------   -------------------------------
	2011-08-12 Page            Create.
  Rate adaptive parameters 
 92 , idx = 0 
 86 , idx = 1 
 81 , idx = 2 
 75 , idx = 3 
 71	, idx = 4 
 66	, idx = 5 
 62	, idx = 6 
 59	, idx = 7 
 53 , idx = 8 
 50	, idx = 9 
 47	, idx = 0x0a 
 43	, idx = 0x0b 
 40 , idx = 0x0c 
 37 , idx = 0x0d 
 32 , idx = 0x0e 
 26 , idx = 0x0f 
 20	, idx = 0x10 
 17 , idx = 0x11 
 15	, idx = 0x12 
 12	, idx = 0x13 
 9 , idx = 0x14 
 6 , idx = 0x15 
 3, idx = 0x16 
  wilson modify 
  SS>TH 
  0329 R01 
  SS<TH 
  SS>TH 
  200ms-1200ms 
  End Rate adaptive parameters 
  back to default timing 
 200ms 
  increase the timing 
  decrease the timing 
 u32 pool_retry; 
  STA used and data packet exits 
  Start RA decision 
 TODO by page 
  rate up 
 YJ, add, 120120 
  Wilson 20111026 
  Highest rate 
  Lowest rate 
 invalid value 
 MCS7 
 Active is not used at present. by page, 110819 
  Active when this STA is use 
  Need to fill into HW_PWR_STATUS 
  Power training try state 
  RAstage == 6 
  Stage_RA counter 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
  Normal chip with one IN and one OUT doesn't have interrupt IN EP. 
  All config other than above support one Bulk IN and one Interrupt IN. 
 512 bytes 
 64 bytes 
  only 4 bits 
  USB_RX_AGG_DMA; 
 unit : 512b 
 uint :128 b 0x0A;	10 = MAX_RX_DMA_BUFFER_SIZE2haldata->UsbBulkOutSize 
 6, absolute time = 34ms(2^6) 
  HW Power on sequence 
  Enable MAC DMAWMACSCHEDULESEC block 
  Set CR bit10 to enable 32k calibration. Suggested by SD1 Gimmy. Added by tynli. 2011.08.31. 
 suggseted by zhouzhou, by page, 20111230 
  Enable MAC DMAWMACSCHEDULESEC block 
  for SDIO - Set CR bit10 to enable 32k calibration. Suggested by SD1 Gimmy. Added by tynli. 2011.08.31. 
  Shall USB interface init this? 
 HISR write one to clear 
  HIMR - 
  REG_USB_SPECIAL_OPTION - BIT(4) 
  0; Use interrupt endpoint to upload interrupt pkt 
  1; Use bulk endpoint to upload interrupt pkt, 
  NOTE: This step shall be proceed before writting REG_RQPN. 
  TX DMA 
 Just follow MP Team,??? Georgia 0328 
 reserve 7 page for LPS 
  RX Page Boundary 
 for WMM ,CONFIG_OUT_EP_WIFI_MODE 
  typical setting 
  for WMM 
  TODO: use the other function to set network type 
  Tx page size is always 128. 
  some REG_RCR will be modified later by phy_ConfigMACWithHeaderFile() 
  Accept all multicast address 
  Response Rate Set 
  CF-END Threshold 
  SIFS (used in NAV) 
  Retry Limit 
  Set Spec SIFS (used in NAV) 
  Set SIFS for CCK 
  Set SIFS for OFDM 
  TXOP 
  Set ACK timeout 
-----------------------------------------------------------------------------
  Function:	usb_AggSettingTxUpdate()
  Overview:	Separate TXRX parameters update independent for TP detection and
 			dynamic TXRX aggreagtion parameters update.
  Input:			struct adapter 
  OutputReturn:	NONE
  Revised History:
 	When		Who		Remark
 	12102010	MHC		Separate to smaller function.
  usb_AggSettingTxUpdate 
-----------------------------------------------------------------------------
  Function:	usb_AggSettingRxUpdate()
  Overview:	Separate TXRX parameters update independent for TP detection and
 			dynamic TXRX aggreagtion parameters update.
  Input:			struct adapter 
  OutputReturn:	NONE
  Revised History:
 	When		Who		Remark
 	12102010	MHC		Separate to smaller function.
 0x280[12:8] 
  TODO: 
  usb_AggSettingRxUpdate 
  Tx aggregation setting 
  Rx aggregation setting 
  2011210 MH Add for USB agg mode dynamic switch. 
  TODO: Remove these magic number 
  ms 
  5ms 
  2ms 
  Suggested by designer timchen. Change beacon AIFS to the largest number 
  beacause test chip does not contension before sending beacon. by tynli. 2009.11.03 
  Set CCK and OFDM Block "ON" 
  Save target channel 
 default set to 6 
  20100809 MH We need to check if we need to turnon or off RF after detecting 
  HW GPIO pin. Before PHY_RFConfig8192C. 
  20100826 MH If Efuse does not support sective suspend then disable the function. 
  for WMM 
 d. Initialize BB related configurations. 
  Get Rx PHY status in order to report RSSI and others. 
 set mac_address 
 set msr 
 todo 
  Init CR MACTXEN, MACRXEN after setting RxFF boundary REG_TRXFF_BNDY to patch 
  Hw bug which Hw initials RxFF boundary size to a value which is larger than the real Rx buffer size in 88E. 
  Enable MACTXENMACRXEN block 
 Enable TX Report 
 Enable Tx Report Timer 
 Set MAX RPT MACID 
 FOR sta mode ,0: bcmc ,1:AP 
 Tx RPT Timer. Unit: 32us 
  unit: 256us. 256ms 
  unit: 256us. 256ms 
 Keep RfRegChnlVal for later use. 
  20101217 MH We need to set TX power according to EFUSE content at first. 
  Move by Neo for USB SS to below setp 
 _RfPowerSave(Adapter); 
  Disable BAR, suggested by Scott 
  2010.04.09 add by hpfan 
  HW SEQ CTRL 
 set 0x0 to 0xFF by tynli. Default enable HW SEQ NUM. 
 Nav limit , suggest by scott 
  20100811 MH Merge from 8192SE for Minicard init. We need to confirm current radio status 
  and then decide to enable RF or not.!!!??? For Selective suspend mode. We may not 
  call initstruct adapter. May cause some problem?? 
  Fix the bug that HwSw radio off before S3S4, the RF off action will not be executed 
  in MgntActSet_RF_State() after wake up, because the value of haldata->eRFPowerState 
  is the same as eRfOff, we should change it to eRfOn after we config RF parameters. 
  Added by tynli. 2010.03.30. 
  enable Tx report. 
  Suggested by SD1 pisa. Added by tynli. 2011.10.21. 
 Pretx_en, for WEPTKIP SEC 
 tynli_test_tx_report. 
 enable tx DMA to drop the redundate data of packet 
  20100826 MH Merge from 8192CE. 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_PABIAS); 
	_InitPABias(Adapter); 
 ack for xmit mgmt frames. 
 here call with bRegSSPwrLvl 1, bRegSSPwrLvl 2 needs to be verified 
 phy_SsPwrSwitch92CU(adapt, rf_on, 1); 
 here call with bRegSSPwrLvl 1, bRegSSPwrLvl 2 needs to be verified 
 phy_SsPwrSwitch92CU(adapt, rf_off, 1); 
 Stop Tx Report Timer. 0x4EC[Bit1]=b'0 
  stop rx 
  Run LPS WL RFOFF flow 
  2. 0x1F[7:0] = 0		turn off RF 
 8051 RAM code 
  Reset MCU 0x2[10]=0. 
  0x2[10], FEN_CPUEN 
  reset MCU ready status 
 YJ,add,111212 
 Disable 32k 
  Card disable power action flow 
  Reset MCU IO Wrapper 
 YJ,test add, 111207. For Power Consumption. 
 Reg0x46 
 Reg0x43 
 set LNA ,TRSW,EX_PA Pin to output mode 
 issue Rx irp to receive data 
	EEPROMEFUSE Content Parsing 
  Support Open-drain arrangement for controlling the LED. 
  VID, PID 
  Customer ID, 0x00 and 0xff are reserved for Realtek. 
  Customer ID, 0x00 and 0xff are reserved for Realtek. 
 Read Permanent MAC address 
 parse the eepromefuse content 
 check system boot selection 
 rf_chip -> _InitRFType() 
  Read EEPROM size before call any EEPROM function 
  2010.03.01. Marked by tynli. No need to call workitem beacause we record the value 
  which should be read from register to a global variable. 
  2010.03.01. Marked by tynli. No need to call workitem beacause we record the value 
  which should be read from register to a global variable. 
 todo: CheckFwRsvdPageContent(Adapter);  2010.06.23. Added by tynli. 
  disable Port0 TSF update 
  set net_type 
 disable atim wnd 
 Set RCR 
 CBSSID_DATA must set to 0,reject ICV_ERR packet 
 enable to rx data frame 
 enable to rx ps-poll 
 Beacon Control related register for first time 
  2ms 
  10ms 
  +32767 (~32ms) 
 reset TSF 
 BIT(3) - If set 0, hw will clr bcnq when tx becon okfail or port 0 
 enable BCN0 Function for if1 
 don't enable update TSF0 for if1 (due to TSF update when beaconprobe rsp are received) 
 dis BCN1 ATIM  WND if if2 is station 
  2007.01.16, by Emily 
  Select RRSR (in Legacy-OFDM and CCK) 
  For 8190, we select only 24M, 12M, 6M, 11M, 5.5M, 2M, and 1M from the Basic rate. 
  We do not use other rates. 
 2011.03.30 add by Luke Lee 
 CCK 2M ACK should be disabled for some BCM and Atheros AP IOT 
 because CCK 2M has poor TXEVM 
 CCK 5.5M & 11M ACK should be enabled for better performance 
  default enable 1M ACK rate 
  Set RRSR rate table. 
  Set RTS initial rate 
  Ziv - Check 
 us 
 disable related TSF function 
 enable related TSF function 
 Set RCR to not to receive data frame when NO LINK state 
 reject all data frames 
 reset TSF 
 disable update TSF 
 under sitesurvey 
 config RCR to receive different BSSID & not to receive data frame 
 reject all data frame 
 disable update TSF 
 sitesurvey done 
 enable to rx data frame 
 enable update TSF 
 enable update TSF 
  RCR_ADF 
  prepare to join 
 enable to rx data frame.Accept all data frame 
  RCR_ADF 
  Ad-hoc Mode 
 joinbss_event call back when join res < 0 
 sta add event call back 
 enable update TSF 
  <Roger_EXP> Temporary removed, 2008.06.20. 
 RESP_SIFS for CCK 
  SIFS_T2T_CCK (0x08) 
 SIFS_R2T_CCK(0x08) 
 RESP_SIFS for OFDM 
 SIFS_T2T_OFDM (0x0a) 
 SIFS_R2T_OFDM(0x0a) 
  Joseph marked out for Netgear 3500 TKIP channel 7 issue.(Temporarily) 
  filled id in CAM config 2 byte 
  polling bit, and No Write enable, and address 
  write content 0 is equall to mark invalid 
 delay_ms(40); 
 delay_ms(40); 
  0xb972a841; 
  Forece leave RF low power mode for 1T1R to prevent conficting setting in Fw power 
  saving sequence. 2010.06.07. Added by tynli. Suggested by SD3 yschang. 
 restore rx gain 
 switch antenna to Optimum_antenna 
  To set EFUE total used bytes, added by Roger, 2008.12.22. 
 pause tx 
 keep sn 
 RX DMA stop 
 RQPN Load 0 
 BCN_VALID, BIT(16) of REG_TDECTRL = BIT(0) of REG_TDECTRL+2, write 1 to clear, Clear by sw 
 BCN_VALID, BIT(16) of REG_TDECTRL = BIT(0) of REG_TDECTRL+2 
 When we halt NIC, we should check if FW LPS is leave. 
  If it is in HWSW Radio OFF or IPS state, we do not check Fw LPS Leave, 
  because Fw is unload. 
  To get EFUE total used bytes, added by Roger, 2008.12.22. 
 Query setting of specified variable. 
 Change default setting of specified variable. 
 disable all dynamic func 
 disable DIG 
 disable High power 
 disable tx power tracking 
 disable antenna diversity 
 turn on all dynamic func 
 CAM_SIZE 
  for infra mode 
 for broadcastmulticast 
 for each sta in IBSS 
 todo: support HT in IBSS 
 MACID 
 to do ,for 8188E-SMIC 
 set ra_id 
 reset TSF, enable update TSF, correcting TSF On Beacon 
 BCN interval 
  2ms 
  NOTE: Fix test chip's bug (about contention windows's randomness) 
 init default value 
 init dm default value 
 for IQK 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
 Enable initial offload 
 disable initial offload 
  0. Refresh efuse init map as all oxFF. 
  1. Read the first byte to check if efuse is empty!!! 
  2. Read real efuse content. Filter PG header and every section data. 
  Check PG header for section num. 
 extended header 
  Get word enable value from PG header 
  Check word enable condition in the section 
  Read next PG header 
  3. Collect 16 sections and 4 word unit into Efuse map. 
  4. Copy from Efuse map to output pointer memory!!! 
  5. Calculate Efuse utilization. 
 beacon head, where FW store len(2-byte) and efuse physical map. 
 buffer to store efuse physical map 
 for efuse content: the max byte to read. will update to byte read 
 if not valid 
 8-bytes addressing 
 data from EEPROM needs to be in LE 
			 Although lenc is only used in a debug statement,
			  do not remove it as the rtw_read16() call consumes
			  2 bytes from the EEPROM source.
 restore BCN_HEAD 
  MCU firmware download enable. 
  8051 reset 
  MCU firmware download disable. 
  Reserved for fw extension. 
  (Default) Phase #1 : PCI muse use 4-byte write to download FW 
  Phase #2 : Use 8-byte, if Phase#1 use big size to write FW. 
  Phase #3 : Use 1-byte, the remnant of FW image. 
 3 Phase #1 
 3 Phase #2 
 3 Phase #3 
  Since we need dynamic decide method of dwonload fw, so we call this function to get chip version. 
  We can remove _ReadChipVersion from ReadpadapterInfo8192C later. 
  polling CheckSum report 
  polling for FW ready 
  To Check Fw header. Added by tynli. 2009.12.04. 
  Shift 32 bytes for FW header 
  Suggested by Filen. If 8051 is running in RAM code, driver should inform Fw to reset by itself, 
  or it will cause download Fw fail. 2010.02.01. by tynli. 
 8051 RAM code 
 reset the FWDL chksum 
  Init Fw LPS related. 
  Init H2C counter. by tynli. 2009.12.09. 
			Efuse related code 
  1.2V Power: From VDDON with Power Cut(0x0000h[15]), defualt valid 
  Reset: 0x0000h[28], default valid 
  Clock: Gated(0x0008h[5]) 8M(0x0008h[1]) clock from ANA, default valid 
  Enable LDO 2.5V before readwrite action 
  Disable LDO 2.5V after readwrite action 
  Do NOT excess total size of EFuse table. Added by Roger, 2008.11.10. 
  total E-Fuse table is 512bytes 
  0. Refresh efuse init map as all oxFF. 
  1. Read the first byte to check if efuse is empty!!! 
  2. Read real efuse content. Filter PG header and every section data. 
  Check PG header for section num. 
 extended header 
  Get word enable value from PG header 
  Check word enable condition in the section 
  Read next PG header 
  3. Collect 16 sections and 4 word unit into Efuse map. 
  4. Copy from Efuse map to output pointer memory!!! 
  5. Calculate Efuse utilization. 
 Do not support BT 
 extended header 
 read next header 
  <Roger_TODO> Efuse has been pre-programmed dummy 5Bytes at the end of Efuse by CP. 
  Skip dummy parts to prevent unexpected data read from Efuse. 
  By pass right now. 2009.02.19. 
   Header Read ------------- 
 read next header 
 read next header 
   Data section Read ------------- 
 check if data exist 
  write fail 
 to write ext_header 
 word_en PG fail 
 offset PG fail 
 wrong extended header 
  write ok 
 reorganize other pg packet 
  default all words are disabled 
  check if the same words are enabled both target and current PG packet 
  enable word 0 
  enable word 1 
  enable word 2 
  enable word 3 
  if same header is found but no data followed 
  write some part of data followed by the header. 
  Here to write partial data 
  if write fail on some words, write these bad words again 
  write fail, return 
  partial write ok, update the target packet for later use 
  this word has been written 
  disable the word 
  read from next header 
  not used header, 0xff 
 Change to check TYPE_EFUSE_MAP_LEN , because 8188E raw 256, logic map over 256. 
  IC version (CUT) 
  ROM code version. 
  6: EEPROM used is 93C46, 4: boot from E-Fuse. 
  LLT RWInit function 
 polling 
  176, 22k 
  end of list 
  Make the other pages as ring buffer 
  This ring buffer is used as beacon buffer if we config this MAC as two MAC transfer. 
  Otherwise used as local loopback buffer. 
  Let last entry point to the start entry of ring buffer 
  autoload OK. 
  Read EFUSE real map to shadow. 
 autoload fail 
 update to default value 0xFF 
  Check 0x8129 again for making sure autoload status!! 
 2.4G default value 
 2.4G default value 
 4bit sign number to 8 bit sign number 
 4bit sign number to 8 bit sign number 
 4bit sign number to 8 bit sign number 
 4bit sign number to 8 bit sign number 
 4bit sign number to 8 bit sign number 
 4bit sign number to 8 bit sign number 
  Channel 1-2 
  Channel 3-5 
  Channel 6-8 
  Channel 9-11 
  Channel 12-13 
  Channel 14 
 hw power down mode selection , 0:rf-off  1:power down 
  decide hw if support remote wakeup function 
  if hw supported, 8051 (SIE) will generate WeakUP signal(D+D- toggle) when autoresume 
  20101019 MH Add Regulator recognize for CU. 
 bit0~2 
 bit0~2 
  Antenna Diversity setting. 
  2:By EFUSE 
  0:OFF , 1:ON, 2:By EFUSE 
 If TRxAntDivType is AUTO in advanced setting, use EFUSE value instead. 
  For 88EE, 1Tx and 1RxCG are fixed.(1Ant, Tx and RxCG are both on aux port) 
  0xC1[3] is ignored. 
  ThermalMeter from EEPROM 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
 H2C Msg format :
 0x1DF - 0x1D0
| 31 - 8	| 7-5	 4 - 0	|
| h2c_msg	|Class_ID CMD_ID	|
 Extend 0x1FF - 0x1F0
|31 - 0	  |
|ext_msg|
 pay attention to if  race condition happened in  H2C cmd setting. 
 Write Ext command 
  Write command 
 bitmap[0:27] = tx_rate_bitmap 
 bitmap[28:31]= Rate Adaptive id 
 arg[0:4] = macid 
 arg[5] = Short GI 
  0:Min, 1:Max, 2:User define 
  AllON(0x0C), RFON(0x04), RFOFF(0x00) 
  AllON(0x0C), RFON(0x04), RFOFF(0x00) 
pmlmeext->mgnt_seq);
 timestamp will be inserted by hardware 
  beacon interval: 2 bytes 
  capability info: 2 bytes 
 below for ad-hoc mode 
  SSID 
  supported rates... 
  DS parameter set 
  IBSS Parameter Set... 
 todo: ERP IE 
  EXTERNDED SUPPORTED RATE 
 todo:HT for adhoc 
  Frame control. 
  AID. 
  BSSID. 
  TA. 
  To check if reserved page content is destroyed by beacon because beacon is too large. 
  2010.06.23. Added by tynli. 
  Description: Fill the reserved packets that FW will use to RSVD page. 
			Now we just send 4 types packet to rsvd page. 
			(1)Beacon, (2)Ps-poll, (3)Null data, (4)ProbeRsp. 
	Input: 
	    bDLFinished - false: At the first time we will send all the packets as a large packet to Hw, 
						so we need to set the packet length to total length. 
			      true: At the second time, we should send the first packet (default:beacon) 
						to Hw again and set the length in descriptor to the real beacon length. 
  2009.10.15 by tynli. 
 3 (1) beacon  2 pages 
  When we count the first page size, we need to reserve description size for the RSVD 
  packet, it will be filled in front of the packet in TXPKTBUF. 
  To reserved 2 pages for beacon buffer. 2010.06.24. 
 3 (2) ps-poll 1 page 
 3 (3) null data  1 page 
 3 (4) probe response  1page 
 3 (5) Qos null data 
  update attribute 
  We should set AID, correct TSF, HW seq enable before set JoinBssReport to Fw in 8892C. 
  Suggested by filen. Added by tynli. 
  Do not set TSF again here or vWiFi beacon DMA INT will not work. 
 Set REG_CR bit 8. DMA beacon by SW. 
  Disable Hw protection for a time which revserd for Hw sending beacon. 
  Fix download reserved page packet fail that access collision with the protection time. 
  2010.05.11. Added by tynli. 
  Set FWHW_TXQ_CTRL 0x422[6]=0 to tell Hw the packet is not a real beacon frame. 
  Clear beacon valid check bit. 
  download rsvd page. 
 mdelay(10); 
  check rsvd page download OK. 
  We just can send the reserved page twice during the time that Tx thread is stopped (e.g. pnpsetpower) 
  because we need to free the Tx BCN Desc which is used by the first reserved page packet. 
  At run time, we cannot get the Tx Desc until it is released in TxHandleInterrupt() so we will return 
  the beacon TCB in the following code. 2011.11.23. by tynli. 
  Enable Bcn 
  To make sure that if there exists an adapter which would like to send beacon. 
  If exists, the origianl value of 0x422[6] will be 1, we should check this to 
  prevent from setting 0x422[6] to 0 after download reserved page, or it will cause 
  the beacon cannot be sent by HW. 
  2010.06.23. Added by tynli. 
  Update RSVD page location H2C to Fw. 
  Do not enable HW DMA BCN or it will cause Pcie interface hang by timing issue. 2011.11.24. by tynli. 
  Clear CR[8] or beacon packet will not be send to TxBuf anymore. 
  update CTWindow value. 
  hw only support 2 set of NoA 
  To control the register setting for which NOA 
  config P2P NoA Descriptor Register 
  rst p2p circuit 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
  This file is for 92CE92CU dynamic mechanism only 
  Initialize GPIO setting registers 
  functions 
  Init Value 
 Station mode 
  Add new function to reset the state of antenna diversity before link. 
  Compare RSSI for deciding antenna 
 select optimum_antenna for before linked =>For antenna diversity 
 keep org parameter 
  Add new function to reset the state of antenna diversity before link. 
  Condition that does not need to use antenna diversity. 
 switch channel 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
  Module:	rtl8192c_rf6052.c	( Source C File)
  Note:	Provide RF 6052 series relative API.
  Function:
  Export:
  Abbrev:
  History:
  Data			Who		Remark
  09252008	MHC		Create initial version.
  11052008	MHC		Add API for tw power setting.
-----------------------------------------------------------------------------
  Function:    PHY_RF6052SetBandwidth()
  Overview:    This function is called by SetBWModeCallback8190Pci() only
  Input:       struct adapter Adapter
 			WIRELESS_BANDWIDTH_E	Bandwidth	20M or 40M
  Output:      NONE
  Return:      NONE
  Note:		For RF type 0222D
-----------------------------------------------------------------------------
  Function:	PHY_RF6052SetCckTxPower
  Overview:
  Input:       NONE
  Output:      NONE
  Return:      NONE
  Revised History:
  When			Who		Remark
  11052008	MHC		Simulate 8192series..
 FOR CE ,must disable turbo scan 
 disable turbo scan 
  20101018 MH For external PA module. We need to limit power index to be less than 0x20. 
  Increase TX power 
  Decrease TX power 
  rf-A cck tx power 
  rf-B cck tx power 
 PHY_RF6052SetCckTxPower 
  powerbase0 for OFDM rates 
  powerbase1 for HT MCS rates 
 Check HT20 to HT40 diff 
  Index 0 & 1= legacy OFDM, 2-5=HT_MCS rate 
  Realtek better performance 
  increase power diff defined by Realtek for large power 
  Realtek regulatory 
  increase power diff defined by Realtek for regulatory 
  Channel 1-2 
  Channel 3-5 
  Channel 6-8 
  Channel 9-11 
  Channel 12-13 
  Channel 14 
  Better regulatory 
  don't increase any power diff 
  Customer defined power diff. 
  increase power diff defined by customer. 
  201005115 Joseph: Set Tx Power diff for Tx power training mechanism. 
-----------------------------------------------------------------------------
  Function:	PHY_RF6052SetOFDMTxPower
  Overview:	For legacy and HY OFDM, we must read EEPROM TX power index for
 			different channel and read original value in TX power register area from
 			0xe00. We increase offset and original value to be correct tx pwr.
  Input:       NONE
  Output:      NONE
  Return:      NONE
  Revised History:
  When			Who		Remark
  11052008	MHC		Simulate 8192 series method.
  01062009	MHC		1. Prevent Path B tx power overflow or underflow dure to
 						AB pwr difference or legacyHT pwr diff.
 						2. We concern with path B legacyHT OFDM difference.
  01222009	MHC		Support new EPRO format from SD3.
  20120423 MH According to power tracking value, we need to revise OFDM tx power. 
  This is ued to fix unstable power tracking mode. 
 Initialize RF 
----Store original RFENV control type----
----Set RF_ENV enable----
 PlatformStallExecution(1); 
----Set RF_ENV output high----
 PlatformStallExecution(1); 
 Set bit number of Address and Data for RF register 
  Set 1 to 4 bits for 8255 
 PlatformStallExecution(1); 
  Set 0 to 12  bits for 8255 
 PlatformStallExecution(1); 
----Initialize RF fom connfiguration file----
----Restore RFENV control type----;
  Config BB and RF 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
 return the final channel plan decision 
  CCK and OFDM non-HT rates 
 VO 
 VI 
 BE 
 BK 
 BCN 
 MGT 
 HIGH 
 TXCMD 
 WMM 
 BK, BE, VI, VO, BCN,	CMD, MGT, HIGH, HCCA 
  0,  1,  0,  1,   0,   0,   0,    0,    0}; 
 0:H, 1:L 
 VO 
 VI 
 BE 
 BK 
 BCN 
 MGT 
 HIGH 
 TXCMD 
 typical setting 
 BK, BE, VI, VO, BCN,	CMD, MGT, HIGH, HCCA 
  1,	1,  0,  0,   0,   0,   0,    0,    0}; 
 0:H, 1:L 
 VO 
 VI 
 BE 
 BK 
 BCN 
 MGT 
 HIGH 
 TXCMD 
 for WMM 
 BK, BE, VI, VO, BCN,	CMD, MGT, HIGH, HCCA 
  1,	2,  1,  0,   0,   0,   0,    0,    0}; 
 0:H, 1:N, 2:L 
 VO 
 VI 
 BE 
 BK 
 BCN 
 MGT 
 HIGH 
 TXCMD 
 typical setting 
 BK, BE, VI, VO, BCN,	CMD, MGT, HIGH, HCCA 
  2,  2,  1,  0,   0,   0,   0,    0,    0}; 
 0:H, 1:N, 2:L 
 VO 
 VI 
 BE 
 BK 
 BCN 
 MGT 
 HIGH 
 TXCMD 
 C2H event format:
 Field	 TRIGGER		CONTENT	   CMD_SEQ	CMD_LEN		 CMD_ID
 BITS	 [127:120]	[119:16]      [15:8]		  [7:4]		   [3:0]
 Not ready 
 Not a valid value 
 Read the content 
	
	 Clear event to notify FW we have read the command.
	 If this field isn't clear, the FW won't update the next
	 command message.
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
  LED object. 
  LED_819xUsb routines. 
	Description: 
		Turn on LED according to LedPin specified. 
  SW control led0 on. 
  SW control led1 on. 
	Description: 
		Turn off LED according to LedPin specified. 
 0x4E 
  Open-drain arrangement for controlling the LED) 
  Set to software control. 
  Set to software control. 
  Interface to manipulate LED objects. 
  Default LED behavior. 
	Description: 
		Initialize all LED_871x objects. 
	Description: 
		DeInitialize all LED_819xUsb objects. 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
  Add 1us delay between BBRF register setting. 
  RF_Content: radioa_txt 
  Add 1us delay between BBRF register setting. 
  Add 1us delay between BBRF register setting. 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
---------------------------Define Local Constant---------------------------
 Channel switch:The size of command tables for switch channel
---------------------------Define Local Constant---------------------------
------------------------Define global variable-----------------------------
------------------------Define local variable------------------------------
--------------------Define export function prototype-----------------------
  Please refer to header file 
--------------------Define export function prototype-----------------------
----------------------------Function Body----------------------------------
  1. BB register RW API 
 Function:	phy_CalculateBitShift
 OverView:	Get shifted position of the BitMask
 Input:
			u32		BitMask,
 Output:	none
 Return:		u32		Return the shift bit bit position of the mask
 Function:	PHY_QueryBBReg
 OverView:	Read "sepcific bits" from BB register
 Input:
			struct adapter Adapter,
			u32			RegAddr,	The target address to be readback
			u32			BitMask		The target bit position in the target address
								to be readback
 Output:	None
 Return:		u32			Data		The readback register value
 Note:		This function is equal to "GetRegSetting" in PHY programming guide
 Function:	PHY_SetBBReg
 OverView:	Write "Specific bits" to BB register (page 8~)
 Input:
			struct adapter Adapter,
			u32			RegAddr,	The target address to be modified
			u32			BitMask		The target bit position in the target address
									to be modified
			u32			Data		The new register value in the target bit position
									of the target address
 Output:	None
 Return:		None
 Note:		This function is equal to "PutRegSetting" in PHY programming guide
 if not "double word" write 
  2. RF register RW API 
 Function:	phy_RFSerialRead
 OverView:	Read regster from RF chips
 Input:
			struct adapter Adapter,
			enum rf_radio_path eRFPath,	Radio path of ABCD
			u32			Offset,		The target address to be read
 Output:	None
 Return:		u32			reback value
 Note:		Threre are three types of serial operations:
			1. Software serial write
			2. Hardware LSSI-Low Speed Serial Interface
			3. Hardware HSSI-High speed
			serial write. Driver need to implement (1) and (2).
			This function is equal to the combination of RF_ReadReg() and  RFLSSIRead()
  Make sure RF register offset is correct 
  Switch page for 8256 RF IC 
  For 92S LSSI Read RFLSSIRead 
  For RF AB write 0x82482c(does not work in the future) 
  We must use 0x824 for RF A and B to execute read trigger 
 T65 RF 
  PlatformStallExecution(10); 
 PlatformStallExecution(100); 
 PlatformStallExecution(10); 
  Read from BBreg8b8, 12 bits for 8190, 20bits for T65 RF 
 Read from BBreg8a0, 12 bits for 8190, 20 bits for T65 RF 
 Function:	phy_RFSerialWrite
 OverView:	Write data to RF register (page 8~)
 Input:
			struct adapter Adapter,
			enum rf_radio_path eRFPath,	Radio path of ABCD
			u32			Offset,		The target address to be read
			u32			Data		The new register Data in the target bit position
									of the target to be read
 Output:	None
 Return:		None
 Note:		Threre are three types of serial operations:
			1. Software serial write
			2. Hardware LSSI-Low Speed Serial Interface
			3. Hardware HSSI-High speed
			serial write. Driver need to implement (1) and (2).
			This function is equal to the combination of RF_ReadReg() and  RFLSSIRead()
  Note:		  For RF8256 only
 			 The total count of RTL8256(Zebra4) register is around 36 bit it only employs
 			 4-bit RF address. RTL8256 uses "register mode control bit" (Reg00[12], Reg00[10])
 			 to access register address bigger than 0xf. See "Appendix-4 in PHY Configuration
 			 programming guide" for more details.
 			 Thus, we define a sub-finction for RTL8526 register address conversion
 		       ===========================================================
 			 Register Mode		RegCTL[1]		RegCTL[0]		Note
 								(Reg00[12])		(Reg00[10])
 		       ===========================================================
 			 Reg_Mode0				0				x			Reg 0 ~15(0x0 ~ 0xf)
 		       ------------------------------------------------------------------
 			 Reg_Mode1				1				0			Reg 16 ~30(0x1 ~ 0xf)
 		       ------------------------------------------------------------------
 			 Reg_Mode2				1				1			Reg 31 ~ 45(0x1 ~ 0xf)
 		       ------------------------------------------------------------------
 	20080902	MH	Add 92S RF definition
  20090617 MH We can not execute IO for power save or other accident mode. 
  Switch page for 8256 RF IC 
  Put write addr in [5:0]  and write data in [31:16] 
  T65 RF 
  Write Operation 
 Function:	PHY_QueryRFReg
 OverView:	Query "Specific bits" to RF register (page 8~)
 Input:
			struct adapter Adapter,
			enum rf_radio_path eRFPath,	Radio path of ABCD
			u32			RegAddr,	The target address to be read
			u32			BitMask		The target bit position in the target address
									to be read
 Output:	None
 Return:		u32			Readback value
 Note:		This function is equal to "GetRFRegSetting" in PHY programming guide
 Function:	PHY_SetRFReg
 OverView:	Write "Specific bits" to RF register (page 8~)
 Input:
			struct adapter Adapter,
			enum rf_radio_path eRFPath,	Radio path of ABCD
			u32			RegAddr,	The target address to be modified
			u32			BitMask		The target bit position in the target address
									to be modified
			u32			Data		The new register Data in the target bit position
									of the target address
 Output:	None
 Return:		None
 Note:		This function is equal to "PutRFRegSetting" in PHY programming guide
  RF data is 12 bits only 
  3. Initial MACBBRF config by reading MACBBRF txt. 
-----------------------------------------------------------------------------
  Function:    PHY_MACConfig8192C
  Overview:	Condig MAC by header file or parameter file.
  Input:       NONE
  Output:      NONE
  Return:      NONE
  Revised History:
   When		Who		Remark
   08122008	MHC		Create Version 0.
  Config MAC 
  2010.07.13 AMPDU aggregation number B 
 Function:	phy_InitBBRFRegisterDefinition
 OverView:	Initialize Register definition offset for Radio Path ABCD
 Input:
			struct adapter Adapter,
 Output:	None
 Return:		None
 Note:		The initialization value is constant and it should never be changes
  RF Interface Sowrtware Control 
  16 LSBs if read 32-bit from 0x870 
  16 MSBs if read 32-bit from 0x870 (16-bit for 0x872) 
  16 LSBs if read 32-bit from 0x874 
  16 MSBs if read 32-bit from 0x874 (16-bit for 0x876) 
  RF Interface Readback Value 
  16 LSBs if read 32-bit from 0x8E0 
  16 MSBs if read 32-bit from 0x8E0 (16-bit for 0x8E2) 
  16 LSBs if read 32-bit from 0x8E4 
  16 MSBs if read 32-bit from 0x8E4 (16-bit for 0x8E6) 
  RF Interface Output (and Enable) 
  16 LSBs if read 32-bit from 0x860 
  16 LSBs if read 32-bit from 0x864 
  RF Interface (Output and)  Enable 
  16 MSBs if read 32-bit from 0x860 (16-bit for 0x862) 
  16 MSBs if read 32-bit from 0x864 (16-bit for 0x866) 
 Addr of LSSI. Wirte RF register by driver 
 LSSI Parameter 
  RF parameter 
 BB Band Select 
  Tx AGC Gain Stage (same for all path. Should we remove this?) 
 Tx gain stage 
 Tx gain stage 
 Tx gain stage 
 Tx gain stage 
  Tranceiver A~D HSSI Parameter-1 
 wire control parameter1 
 wire control parameter1 
  Tranceiver A~D HSSI Parameter-2 
 wire control parameter2 
 wire control parameter2 
  RF switch Control 
 TRAnt switch control 
  AGC control 1 
  AGC control 2 
  RX AFE control 1 
  RX AFE control 1 
  Tx AFE control 1 
  Tx AFE control 2 
  Tranceiver LSSI Readback SI mode 
  Tranceiver LSSI Readback PI mode 
  1. Read PHY_REG.TXT BB INIT!! 
  We will separate as 88C  92C according to chip version 
  2. If EEPROM or EFUSE autoload OK, We must config by PHY_REG_PG.txt 
  3. BB AGC table Initialization 
  Enable BB and RF 
  20090923 Joseph: Advised by Steven and Jenyu. Power sequence before init RF. 
  Config BB and AGC 
  write 0x24[16:11] = 0x24[22:17] = CrystalCap 
  RF config 
  1. CCK 
 2. OFDM 
  1. BW20 
 2. BW40 
  1. CCK 
 2. OFDM 
  1. BW20 
 2. BW40 
  1. CCK 
 2. OFDM 
  1. BW20 
 2. BW40 
  1. CCK 
 2. OFDM 
  1. BW20 
 2. BW40 
-----------------------------------------------------------------------------
  Function:    SetTxPowerLevel8190()
  Overview:    This function is export to "HalCommon" moudule
 			We must consider RF path later!!!!!!!
  Input:       struct adapter Adapter
 			u8		channel
  Output:      NONE
  Return:      NONE
 	20081104	MHC		We remove EEPROM_93C56.
 						We need to move CCX relative code to independet file.
 	20090121	MHC		Support new EEPROM format from SD3 requirement.
  [0]:RF-A, [1]:RF-B 
-----------------------------------------------------------------------------
  Function:    PHY_SetBWModeCallback8192C()
  Overview:    Timer callback function for SetSetBWMode
  Input:		PRT_TIMER		pTimer
  Output:      NONE
  Return:      NONE
  Note:		(1) We do not take j mode into consideration now
 			(2) Will two workitem of "switch channel" and "switch channel bandwidth" run
 			     concurrently?
  There is no 40MHz mode in RF_8225. 
 3 
 3<1>Set MAC register 
 3 
  20070207 Mark by Emily because we have not verify whether this register works 
  20070207 Mark by Emily because we have not verify whether this register works 
 3  
 3 <2>Set PHY related register 
 3 
 20 MHz channel
 40 MHz channel
  Set Control channel to upper or lower. These settings are required only for 40MHz 
 Skip over setting of J-mode in BB register here. Default value is "None J mode". Emily 20070315 
 3<3>Set RF related register 
  Please implement this function in Hal8190PciPhy8256.c 
 -----------------------------------------------------------------------------
  Function:   SetBWMode8190Pci()
  Overview:  This function is export to "HalCommon" moudule
  Input:		struct adapter Adapter
 			enum ht_channel_width Bandwidth	20M or 40M
  Output:      NONE
  Return:      NONE
  Note:		We do not take j mode into consideration now
  20M or 40M 
  Upper, Lower, or Don't care 
 s1. pre common command - CmdID_SetTxPowerLevel 
 s2. RF dependent command - CmdID_RF_WriteReg, param1=RF_CHNLBW, param2=channel 
  Call after initialization 
 return immediately if it is peudo-phy 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
    drivers should parse below arrays and do the corresponding actions
 3 Power on  Array 
 3Radio off Array 
 3Card Disable Array 
 3 Card Enable Array 
 3Suspend Array 
 3 Resume Array 
 3HWPDN Array 
 3 Enter LPS 
 FW behavior 
 3 Leave LPS 
 FW behavior 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2012 Realtek Corporation. 
 todo: based on rssi_level
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
  ODM IO Relative API. 
  ODM Memory relative API. 
  ODM Timer relative API. 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
 total xmit irp = 4 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
---------------------------Define Local Constant---------------------------
  20100425 MH Define the max tx power tracking tx agc power. 
---------------------------Define Local Constant---------------------------
 3============================================================ 
 3 Tx Power Tracking 
 3============================================================ 
-----------------------------------------------------------------------------
  Function:	ODM_TxPwrTrackAdjust88E()
  Overview:	88E we can not write 0xc80c94c4c 0xa2x. Instead of write TX agc.
 				No matter OFDM & CCK use the same method.
  Input:		NONE
  Output:		NONE
  Return:		NONE
  Revised History:
 	When		Who		Remark
 	04232012	MHC		Create Version 0.
 	04232012	MHC		Adjust TX agc directly not throughput BB digital.
  0 = OFDM, 1 = CCK 
  1 = +(increase) 2 = -(decrease) 
  Tx tracking CCKOFDM BB swing index adjust 
  Tx power tracking BB swing table. 
  The base index = 12. +((12-n)2)dB 13~?? = decrease tx pwr by -((n-12)2)dB 
  For OFDM afjust 
  For CCK adjust. 
  20120425 MH According to EdLuke.Lees estimate for EVM the max tx power tracking 
  need to be less than 6 power index for 88E. 
  ODM_TxPwrTrackAdjust88E 
-----------------------------------------------------------------------------
  Function:	odm_TxPwrTrackSetPwr88E()
  Overview:	88E change all channel tx power accordign to flag.
 				OFDM & CCK are all different.
  Input:		NONE
  Output:		NONE
  Return:		NONE
  Revised History:
 	When		Who		Remark
 	04232012	MHC		Create Version 0.
  odm_TxPwrTrackSetPwr88E 
 091212 chiyokolin 
 OFDM BB Swing should be less than +3.0dB, which is required by Arthur 
 2.4G, decrease power 
  For lower temperature, 20120220 updated on 20120220. 
 2.4G, increase power 
 2.4G, decrease power 
 2.4G,, increase power 
  20120425 MH Add for tx power tracking to set tx power in tx agc for 88E. 
 cosa add for debug 
  <Kordan> RFCalibrateInfo.RegA24 will be initialized when ODM HW configuring, but MP configures with para files. 
 0x42: RF Reg[15:10] 88E 
 Query OFDM path A default setting 
 find the index 
 Query OFDM path B default setting 
 find the index 
 Query CCK default setting From 0xa24 
 calculate average thermal meter 
  Delta temperature is equal to or larger than 20 centigrade. 
 calculate new OFDM  CCK offset 
 2 temporarily remove bNOPG 
 Config by SwingTable 
 Adujst OFDM Ant_A according to IQK result 
  Revse TX power table. 
 new element C = element D x Y 
  20120423 MH According to Luke's suggestion, we can not write BB digital 
  to increase TX power. Otherwise, EVM will be bad. 
 new element A = element D x X 
 consider minus 
 new element C = element D x Y 
 wtite new elements A, C, D to regC88 and regC9C, element B is always 0 
  Delta temperature is equal to or larger than 20 centigrade. 
 update thermal meter value 
 1 7.	IQK 
 ms 
 bit0 = 1 => Tx OK, bit1 = 1 => Rx OK 
 1 Tx IQK 
 path-A IQK setting 
 LO calibration setting 
 One shot, path A LOK & IQK 
  delay x ms 
 PlatformStallExecution(IQK_DELAY_TIME_88E1000); 
  Check failed 
 bit0 = 1 => Tx OK, bit1 = 1 => Rx OK 
 1 Get TXIMR setting 
 modify RXIQK mode table 
 PA,PAD off 
 IQK setting 
 path-A IQK setting 
 LO calibration setting 
 One shot, path A LOK & IQK 
  delay x ms 
  Check failed 
 if Tx not OK, ignore Rx 
 1 RX IQK 
 modify RXIQK mode table 
 IQK setting 
 path-A IQK setting 
 LO calibration setting 
 One shot, path A LOK & IQK 
  delay x ms 
 PlatformStallExecution(IQK_DELAY_TIME_88E1000); 
  Check failed 
 reload RF 0xdf 
 if Tx is OK, check whether Rx is OK 
 bit0 = 1 => Tx OK, bit1 = 1 => Rx OK 
 One shot, path B LOK & IQK 
  delay x ms 
  Check failed 
 for path A and path B 
 path A TX OK 
 path A RX OK 
 path B TX OK 
 path B RX OK 
 since 92C & 92D have the different define in IQK_BB_REG 
  Note: IQ calibration must be performed after loading 
 		PHY_REG.txt , and radio_a, radio_b.txt 
  Save ADDA parameters, turn Path A ADDA on 
  Switch BB to PI mode to do IQ Calibration. 
 BB setting 
 MAC settings 
 Page B init 
 AP or IQK 
  IQ calibration setting 
  Turn Path B ADDA on 
 Tx IQK OK 
 Back to BB mode, load original value 
  Switch back BB to SI mode after finish IQ Calibration. 
  Reload ADDA power saving parameters 
  Reload MAC parameters 
  Restore RX initial gain 
 load 0xe30 IQC default value 
 Check continuous TX and Packet TX 
 Deal with contisuous TX case 
 disable all continuous TX 
  Deal with Packet TX case 
  block all queues 
 1. Read original RF mode 
 Path-A 
 Path-B 
 2. Set RF mode = standby mode 
 Path-A 
 Path-B 
 3. Read RF reg18 
 4. Set LC calibration begin	bit15 
 Restore original situation 
 Deal with continuous TX case 
 Path-A 
 Path-B 
  Deal with Packet TX case 
 last is final result 
  20120213<Kordan> Turn on when continuous Tx to pass lab testing. (required by Edlu) 
 X default value 
 Y default value 
 To Fix BSOD when final_candidate is 0xff 
 by sherry 20120321 
  20120213<Kordan> Turn on when continuous Tx to pass lab testing. (required by Edlu) 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
  (32 bytes  2 bytes per XOR) => 16 times 
 Clear first 
  Description: In normal chip, we should send some packet to Hw which will be used by Fw 
			in FW LPS mode. The function is to fill the Tx descriptor of this packets, then 
			Fw can tell Hw to send these packet derectly. 
  Clear all status 
 offset 0 
 own, bFirstSeg, bLastSeg; 
 32 bytes for TX Desc 
  Buffer size + command header 
 offset 4 
  Fixed queue of Mgnt queue 
 Set NAVUSEHDR to prevent Ps-poll AId filed to be changed to error vlaue by Hw. 
  Hw set sequence number 
 set bit3 to 1. Suugested by TimChen. 2009.12.29. 
  BT NULL 
 offset 16 
 driver uses rate 
  USB interface drop packet if the checksum of descriptor isn't correct. 
  Using this checksum can let hardware recovery from packet bulk out error (e.g. Cancel URC, Bulk out error.). 
 SEC_TYPE : 0:NO_ENC,1:WEP40TKIP,2:WAPI,3:AES 
  Set RTS BW 
 4 offset 0 
 update TXPKTSIZE 
 32 bytes for TX Desc 
  pkt_offset, unit:8 bytes padding 
 driver uses rate 
 rate control always by driver 
 offset 4 
 AGG EN 
 AGG BK 
 offset 8 
 offset 12 
 offset 16 , offset 20 
 QoS 
 offset 20 
 Non EAP & ARP & DHCP type data packet 
 RTS Rate=24M 
 DATARTS  Rate FB LMT 
 SGI 
  EAP data packet and ARP packet and DHCP. 
  Use the 1M data rate to send the EAPARP packet. 
  This will maybe make the handshake smooth. 
 AGG BK 
  DATA_SHORT 
 offset 4 
 offset 8 
 CCX-TXRPT ack for xmit mgmt frames. 
 offset 12 
 offset 20 
 retry limit enable 
 retry limit = 6 
 retry limit = 12 
 offset 4 
 CAM_ID(MAC_ID) 
 raid 
 offset 8 
 offset 12 
 offset 20 
  2009.11.05. tynli_test. Suggested by SD4 Filen for FW LPS. 
  (1) The sequence number of each non-Qos frame  broadcast  multicast  
  mgnt frame should be controlled by Hw because Fw will also send null data 
  which we cannot control when Fw LPS enable. 
  --> default enable non-Qos data sequense number. 2010.06.23. by tynli. 
  (2) Enable HW SEQ control for beacon packet, because we use Hw beacon. 
  (3) Use HW Qos SEQ to control the seq num of Ext port non-Qos packets. 
  2010.06.23. Added by tynli. 
  Hw set sequence number 
  Hw set sequence number 
 for non-agg data frame or  management frame 
 no frag 
 pull txdesc head 
  no consider fragement 
  aggregate variable 
  next pkt address 
  last pkt tail 
  packet length, except TXDESC_SIZE and PKT_OFFSET 
  dump frame variable 
  check xmitbuffer is ok 
 3 1. pick up first frame 
  no more xmit frame, release xmit buffer 
  alloc xmitframe should assign to 1. 
  first frame of aggregation, reserve offset 
  always return ndis_packet after rtw_xmitframe_coalesce 
 3 2. aggregate same priority and same DA(AP or STA) frames 
  check pkt amount in one bulk 
  round to next bulksize 
  dequeue same priority packet from station tx queue 
  not first frame of aggregation 
  not first frame of aggregation, no need to reserve offset 
  always return ndis_packet after rtw_xmitframe_coalesce 
  (len - TXDESC_SIZE) == pxmitframe->attrib.last_txcmdsz 
  don't need xmitframe any more 
  handle pointer and stop condition 
 end while (aggregate same priority and same DA(AP or STA) frames) 
 3 3. update first frame txdesc 
  remove pkt_offset 
 3 4. write xmit buffer to USB FIFO 
 3 5. update statisitc 
  Return
 	true	dump packet directly
 	false	enqueue packet
  Trick, make the statistics correct 
  Return
 	true	dump packet directly ok
 	false	temporary can't transmit packets to hardware
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
  include files 
 avoid to warn in FreeBSD ==> To DO modify 
  UL			DL 
 0:unknown AP 
  1:realtek AP 
  2:unknown AP => realtek_92SE 
  3:broadcom AP 
  4:ralink AP 
  5:atheros AP 
  6:cisco AP 
  8:marvell AP 
  10:unknown AP=> 92U AP 
  11:airgocap AP 
  Global var 
  0, +6.0dB 
  1, +5.5dB 
  2, +5.0dB 
  3, +4.5dB 
  4, +4.0dB 
  5, +3.5dB 
  6, +3.0dB 
  7, +2.5dB 
  8, +2.0dB 
  9, +1.5dB 
  10, +1.0dB 
  11, +0.5dB 
  12, +0dB 
  13, -0.5dB 
  14, -1.0dB 
  15, -1.5dB 
  16, -2.0dB 
  17, -2.5dB 
  18, -3.0dB 
  19, -3.5dB 
  20, -4.0dB 
  21, -4.5dB 
  22, -5.0dB 
  23, -5.5dB 
  24, -6.0dB 
  25, -6.5dB 
  26, -7.0dB 
  27. -7.5dB 
  28, -8.0dB 
  29, -8.5dB 
  30, -9.0dB 
  31, -9.5dB 
  32, -10.0dB 
  33, -10.5dB 
  34, -11.0dB 
  35, -11.5dB 
  36, -12.0dB 
  37, -12.5dB 
  38, -13.0dB 
  39, -13.5dB 
  40, -14.0dB 
  41, -14.5dB 
  42, -15.0dB 
  0, +0dB 
  1, -0.5dB 
  2, -1.0dB 
  3, -1.5dB 
  4, -2.0dB 
  5, -2.5dB 
  6, -3.0dB 
  7, -3.5dB 
  8, -4.0dB 
  9, -4.5dB 
  10, -5.0dB 
  11, -5.5dB 
  12, -6.0dB 
  13, -6.5dB 
  14, -7.0dB 
  15, -7.5dB 
  16, -8.0dB 
  17, -8.5dB 
  18, -9.0dB 
  19, -9.5dB 
  20, -10.0dB 
  21, -10.5dB 
  22, -11.0dB 
  23, -11.5dB 
  24, -12.0dB 
  25, -12.5dB 
  26, -13.0dB 
  27, -13.5dB 
  28, -14.0dB 
  29, -14.5dB 
  30, -15.0dB 
  31, -15.5dB 
  32, -16.0dB 
  0, +0dB 
  1, -0.5dB 
  2, -1.0dB 
  3, -1.5dB 
  4, -2.0dB 
  5, -2.5dB 
  6, -3.0dB 
  7, -3.5dB 
  8, -4.0dB 
  9, -4.5dB 
  10, -5.0dB 
  11, -5.5dB 
  12, -6.0dB 
  13, -6.5dB 
  14, -7.0dB 
  15, -7.5dB 
  16, -8.0dB 
  17, -8.5dB 
  18, -9.0dB 
  19, -9.5dB 
  20, -10.0dB 
  21, -10.5dB 
  22, -11.0dB 
  23, -11.5dB 
  24, -12.0dB 
  25, -12.5dB 
  26, -13.0dB 
  27, -13.5dB 
  28, -14.0dB 
  29, -14.5dB 
  30, -15.0dB 
  31, -15.5dB 
  32, -16.0dB 
 3 Export Interface 
  20110921 MH Add to describe different team necessary resource allocate?? 
 2012.05.03 Luke: For all IC series 
  Gary 
  20110920 MH This is the entry pointer for all team to execute HW out source DM. 
  You can not add any dummy function here, be care, you can only use DM structure 
  to perform any new ODM_DM. 
 2012.05.03 Luke: For all IC series 
  Init .. Fixed HW value. Only init time. 
  This section is used for init value 
  Fixed ODM value. 
 To remove the compiler warning, must add an empty default statement to handle the other values. 
 do nothing 
  Tx power tracking BB swing table. 
  The base index = 12. +((12-n)2)dB 13~?? = decrease tx pwr by -((n-12)2)dB 
  Set defalut value as index 12. 
  Hook call by reference pointer. 
  Dynamic call by reference pointer. 
 To remove the compiler warning, must add an empty default statement to handle the other values. 
 do nothing 
  Update BandCHannel.. The values are dynamic but non-per-packet. 
  This init variable may be changed in run time. 
 To Initialize pDM_Odm->bDMInitialGainEnable == false to avoid DIG error 
 add by Neil Chen to avoid PSD is processing 
 1 Boundary Decision 
 2 8723A Series, offset need to be 10 
 2 Modify DIG upper bound 
 2 Modify DIG lower bound 
 1 Lower Bound for 88E AntDiv 
 1 Modify DIG lower bound, deal with abnormally large false alarm 
 3600=2hr 
 Recovery mechanism for IGI lower bound 
 DM_DIG_MIN) 
 DM_DIG_MIN; 
 DM_DIG_MIN; 
 1 Adjust initial gain by false alarm 
 pDM_DigTable->CurIGValue = pDM_DigTable->PreIGValue+2; 
 pDM_DigTable->CurIGValue = pDM_DigTable->PreIGValue+1; 
 pDM_DigTable->CurIGValue =pDM_DigTable->PreIGValue-1; 
 2012.03.30 LukeLee: enable DIG before link but with very high thresholds 
 pDM_DigTable->CurIGValue = pDM_DigTable->PreIGValue+2; 
 pDM_DigTable->CurIGValue = pDM_DigTable->PreIGValue+1; 
 pDM_DigTable->CurIGValue =pDM_DigTable->PreIGValue-1; 
 1 Check initial gain by upperlower bound 
 2 High power RSSI threshold 
 ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue); 
 3============================================================ 
 3 FASLE ALARM CHECK 
 3============================================================ 
 hold ofdm counter 
 hold page C counter 
 hold page D counter 
 hold cck counter 
 3============================================================ 
 3 CCK Packet Detect Threshold 
 3============================================================ 
 modify by Guo.Mingzhi 2012-01-03 
 3============================================================ 
 3 BB Power Save 
 3============================================================ 
 Reg874[20:18]=3'b010 
 RegC70[3]=1'b0 
 Reg85C[31:24]=0x63 
 Reg874[15:14]=2'b10 
 RegA75[7:4]=0x3 
 Reg818[28]=1'b0 
 Reg818[28]=1'b1 
 3============================================================ 
 3 RATR MASK 
 3============================================================ 
 3============================================================ 
 3 Rate Adaptive 
 3============================================================ 
 11M or 5.5M enable 
 case WIRELESS_11_24N: 
-----------------------------------------------------------------------------
  Function:	odm_RefreshRateAdaptiveMask()
  Overview:	Update rate table mask according to rssi
  Input:		NONE
  Output:		NONE
  Return:		NONE
  Revised History:
 	When		Who		Remark
 	05272009	hpfan	Create Version 0.
  Return Value: bool 
  - true: RATRState is changed. 
  Threshold Adjustment: 
  when RSSI state trends to go up one or two levels, make sure RSSI is high enough. 
  Here GoUpGap is added to solve the boundary's level alternation issue. 
  Decide RATRState by RSSI. 
 3============================================================ 
 3 RSSI Monitor 
 3============================================================ 
 1 1.Determine the minimum RSSI 
 0~15]:MACID, [16~31]:PWDB_rssi 
  Report every sta's RSSI to FW 
  If associated entry is found 
  If associated entry is found 
 3============================================================ 
 3 Tx Power Tracking 
 3============================================================ 
 at least delay 1 sec 
 EDCA Turbo 
  ODM_InitEdcaTurbo 
  Check if the status needs to be changed. 
 traffic, TX or RX 
  Uplink TP is present. 
  Balance TP is present. 
  Downlink TP is present. 
  Balance TP is present. 
  Turn Off EDCA turbo here. 
  Restore original EDCA according to the declaration of AP. 
  Set variables for next time. 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
  -33dB~0dB to 0%~99% 
  (1)Hardware does not provide RSSI for CCK 
  (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive) 
 2011.11.28 LukeLee: 88E use different LNA & VGA gain table 
 The RSSI formula should be modified according to the gain table 
 In 88E, cck_highpwr is always set to 1 
 VGA_idx = 27~2 
 VGA_idx = 2~0 
 VGA_idx = 7~5 
 VGA_idx = 7~4 
 VGA_idx = 7~0 
 VGA_idx = 5~0 
  (3) Get Signal Quality (EVM) 
 is OFDM rate 
  (1)Get RSSI for HT rate 
  20080130 MH we will judge RF RX path now. 
 Translate DBM to percentage. 
 Get Rx snr value in DB 
  (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive) 
  (3)EVM of HT rate 
 both spatial stream make sense 
 only spatial stream 1 makes sense 
  Do not use shift operation like "rx_evmX >>= 1" because the compilor of free build environment 
  fill most significant bit to "zero" when doing shifting operation which may change a negative 
  value to positive one, then the dbm value (which is supposed to be negative)  is not correct anymore. 
 dbm 
  Fill value in RFD, Get the first spatial stream only 
 UI BSS List signal strength(in percentage), make it good looking, from 0~100. 
 It is assigned to the BSS List in GetValueFromBeaconOrProbeRsp(). 
 PWDB_ALL; 
 For 88E HW Antenna Diversity 
 Smart Antenna Debug Message------------------  
 Smart Antenna Debug Message------------------ 
 ofdm rate 
 1 Process OFDM RSSI 
  initialize 
 1 Process CCK RSSI 
  initialize 
 2011.07.28 LukeLee: modified to prevent unstable CCK RSSI 
  Endianness before calling this API 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
                           AGC_TAB_1T.TXT
  This (offset, data) pair meets the condition. 
  This line is the start line of branch. 
  Discard the following (offset, data) pairs. 
  prevent from for-loop += 2 
  Configure matched pairs and skip to end of if-else. 
                           PHY_REG_1T.TXT
  This (offset, data) pair meets the condition. 
  This line is the start line of branch. 
  Discard the following (offset, data) pairs. 
  prevent from for-loop += 2 
  Configure matched pairs and skip to end of if-else. 
                           PHY_REG_PG.TXT
  this line is a line of pure_body 
  this line is the start of branch 
  don't need the hw_body 
  skip the pair of expression 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
                           MAC_REG.TXT
  This (offset, data) pair meets the condition. 
  This line is the start line of branch. 
  Discard the following (offset, data) pairs. 
  prevent from for-loop += 2 
  Configure matched pairs and skip to end of if-else. 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
  Process_UI_RSSI_8192C 
  Check RSSI 
  Check EVM 
 u8)prxreport->crc32; 
  update rx report to recv_frame attribute 
 prxreport->rpt_sel; 
 Normal rx packet 
 u16)prxreport->pktlen; 
 u8)(prxreport->drvinfosize << 3); 
 u8)prxreport->physt; 
 u8)(prxreport->swdec ? 0 : 1); 
 u8)prxreport->security; 
 u8)prxreport->qos; 
 u8)prxreport->tid; 
 u8)prxreport->amsdu; 
 u16)prxreport->seq; 
 u8)prxreport->frag; 
 u8)prxreport->mf; 
 u8)prxreport->md; 
 u8)prxreport->rxmcs; 
 u8)prxreport->rxht; 
 u8)prxreport->icverr; 
 CCX 
  TX RPT 
 Rx length[9:0] 
  Get TX report MAC ID valid. 
  USB HISR RPT 
 u16)prxreport->pktlen; 
  Notice:
 	Before calling this function,
 	precvframe->rx_data should be ready!
 to do Ad-hoc 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
		
		  device or controller has been disabled due to
		  some problem that could not be worked around,
		  device or bus doesn’t exist, endpoint does not
		  exist or is not enabled.
		
		  device or controller has been disabled due to
		  some problem that could not be worked around,
		  device or bus doesn’t exist, endpoint does not
		  exist or is not enabled.
  HISR 
  C2H Event 
 can't access the precvbuf for new arch. 
	Modified by Albert 20101213 
	For 8 bytes IP header alignment. 
	Qos data, wireless lan header length is 26 
  for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet. 
  modify alloc_sz for recvive crc error packet by thomas 2011-06-02 
	6 is for IP header 8 bytes alignment in QoS packet case. 
	8 is for skb->data 4 bytes alignment. 
 force pkt_copy->data at 8-byte alignment address 
 force ip_hdr at 8-byte alignment address according to shift_sz. 
 Normal rx packet 
 enqueue recvframe to txrtp queue 
 CCX-TXRPT ack for xmit mgmt frames. 
 SUCCESS 
 re-assign for linux based on skb 
 reuse skb 
 translate DMA FIFO addr to pipehandle 
 context is precvbuf 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
++
Module Name:
	HalPwrSeqCmd.c
Abstract:
	Implement HW Power sequence configuration CMD handling routine for Realtek devices.
Major Change History:
	When       Who               What
	---------- ---------------   -------------------------------
	2011-10-26 Lucas            Modify to be compatible with SD4-CE driver.
	2011-07-07 Roger            Create.
	Description: 
		This routine deals with the Power Configuration CMDs parsing
 		for RTL8723RTL8188E Series IC.
 	Assumption:
 		We should follow specific format which was released from HW SD.
  polling autoload done. 
 2 Only Handle the command whose FAB, CUT, and Interface are matched 
  Read the value from system register 
  Write the value back to system register 
  When this command is parsed, end the process 
 Add Array Index 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2012 Realtek Corporation. 
 Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) 
 ms 
 free skb by driver 
caller : defrag ; recvframe_chk_defrag in recv_thread  (passive)
pframequeue: defrag_queue : will be accessed in recv_thread  (passive)
using spinlock to protect
 calculate mic code 
 icv_len included the mic code 
 care the length of the data 
  double check key_index for some timing issue , 
  cannot compare with psecuritypriv->dot118021XGrpKeyid also cause timing issue 
 mic checked ok 
 decrypt and set the ivlen, icvlen of the recv_frame 
 set the security information in the recv_frame 
 for Funia BD's WPA issue 
 blocked 
 only accept EAPOL frame 
 get ether_type 
 free this frame 
 allowed 
 check decryption status, and decrypt the frame if needed 
 if (bretry) 
 process received triggered frame 
 issue one qos null frame with More data bit = 0 and the EOSP bit set (= 1) 
  filter packets that SA is myself or multicast or broadcast 
  For Station mode, sa and bssid should always be BSSID, and DA is my mac-address 
  For AP mode, if DA == MCAST, then BSSID should be also MCAST 
  not mc-frame 
  For AP mode, if DA is non-MCAST, then it must be BSSID, and bssid == BSSID 
  get ap_info 
  filter packets that SA is myself or multicast or broadcast 
  da should be for me 
  check BSSID 
  get ap_info 
 if ((GetFrameSubType(ptr) & WIFI_QOS_DATA_TYPE) == WIFI_QOS_DATA_TYPE) { 
 No data, will not indicate to upper layer, temporily count it here 
  get sta_info 
 Special case 
  get sta_info 
 For AP mode, RA = BSSID, TX = STA(SRC_ADDR), A3 = DST_ADDR 
 No data, will not indicate to upper layer, temporily count it here 
 uint len = precv_frame->len; 
 receive the frames that ra(a1) is my address 
 only handle ps-poll 
 for rx pkt statistics 
 upate BCN for TIM IE 
 update_BCNTIM(padapter); 
 issue nulldata with More data bit = 0 to indicate we have no buffered packets 
 upate BCN for TIM IE 
 update_BCNTIM(padapter); 
 for rx pkt statistics 
 psta->rssi = prxcmd->rssi; 
 psta->signal_quality = prxcmd->sq; 
 parsing QC field 
 HT-CTRL 11n 
  decache, drop duplicate recv packets 
 shall check frame subtype, to  from ds, da, bssid 
 then call check if rx seqfrag. duplicated. 
 add version chk 
 bit(7)~bit(2) 
 Dump rx packets 
 dump all rx packets 
 mgnt 
  only data frame return _SUCCESS 
 ctrl 
  only data frame return _SUCCESS 
 data 
 remove the wlanhdr and add the eth_hdr 
  point to frame_ctrl field 
 convert hdr + possible LLC headers into Ethernet header 
 remove RFC1042 or Bridge-Tunnel encapsulation and replace EtherType 
 Leave Ethernet header part of hdr and full payload 
 pattrib->ether_type 
  append rx status for mp test packets 
 perform defrag 
 the first fragment number must be 0 
 free the whole queue 
 check the fragment sequence  (2nd ~n fragment frame) 
 the fragment number must be increasing  (after decache) 
 release the defrag_q & prframe 
 copy the 2nd~n fragment frame's payload to the first fragment 
 get the 2nd~last fragment frame's payload 
 append  to first fragment frame's tail (if privacy frame, pull the ICV) 
 memcpy 
 free the defrag_q queue and return the prframe 
 check if need to defrag, if needed queue the frame to defrag_q 
 need to define struct of wlan header frame ctrl 
 isn't a fragment frame 
 0~(n-1) fragment frame 
 enqueue to defraf_g 
 the first fragment 
 free current defrag_q 
 Then enqueue the 0~(n-1) fragment into the defrag_q 
 can't find this ta's defrag_queue, so free this recv_frame 
 the last fragment frame 
 enqueue the last fragment 
 call recvframe_defrag to defrag 
 can't find this ta's defrag_queue, so free this recv_frame 
 after defrag we must check tkip mic code 
 Offset 12 denote 2 mac address 
 move the data point to data content 
 Allocate new skb for releasing to upper layer 
 convert hdr + possible LLC headers into Ethernet header 
 remove RFC1042 or Bridge-Tunnel encapsulation and replace EtherType 
 Leave Ethernet header part of hdr and full payload 
 Indicate the packets to upper layer 
  Insert NAT2.5 RX here! 
 free this recv_frame 
  4096; 
  Rx Reorder initialize condition. 
  Drop out the packet which SeqNum is smaller than WinStart 
  Sliding window manipulation. Conditions includes: 
  1. Incoming SeqNum is equal to WinStart =>Window shift 1 
  2. Incoming SeqNum is larger than the WinEnd => Window shift N 
  Handling some condition for forced indicate case. 
  Prepare indication list and indication. 
  Check if there is any packet need indicate. 
 Set this as a lock to make sure that only one thread is indicating packet. 
 indicate this recv_frame 
 indicate this recv_frame 
 error condition; 
 Update local variables. 
 s1. 
 indicate this recv_frame 
 temp filter -> means didn't support A-MSDUs in a A-MPDU 
 s2. check if winstart_b(indicate_seq) needs to been updated 
 s3. Insert all packet into Reorder Queue to maintain its ordering. 
 s4. 
  Indication process. 
  After Packet dropping and Sliding Window shifting as above, we can now just indicate the packets 
  with the SeqNum smaller than latest WinStart and buffer other packets. 
  For Rx Reorder condition: 
  1. All packets with SeqNum smaller than WinStart => Indicate 
  2. All packets with SeqNum larger than or equal to WinStart => Buffer it. 
 recv_indicatepkts_in_order(padapter, preorder_ctrl, true); 
 struct recv_priv precvpriv = &padapter->recvpriv; 
 struct rx_pkt_attrib pattrib = &prframe->attrib; 
 BGN Mode 
 prframe->preorder_ctrl = &precvpriv->recvreorder_ctrl[pattrib->priority]; 
  including perform A-MPDU Rx Ordering Buffer Control 
 BG mode 
 indicate this recv_frame 
 check the frame crtl field and decache 
 free this recv_frame 
  DATA FRAME 
 free this recv_frame 
 check if need to handle uc_swdec_pending_queue
 check if need to enqueue into uc_swdec_pending_queue
				 to prevent from recvframe starvation,
				  get recvframe from uc_swdec_pending_queue to
  this value is based on converging_constant = 5000 and sampling_interval = 1000 
 update the user specific value, signal_strength_dbg, to signal_strength, rssi 
  update_req is clear, means we got rx 
  after avg_vals are accquired, we can re-stat the signal values 
  update_req is clear, means we got rx 
  after avg_vals are accquired, we can re-stat the signal values 
 update value of signal_strength, rssi, signal_qual 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2012 Realtek Corporation. 
  syn ips_mode with request 
 consider buddy, if exist 
 if (pwrpriv->pwr_mode == PS_MODE_ACTIVE) 
  Set CTWindow after LPS 
  Return:
 	0:	Leave OK
 	-1:	Timeout
 	-2:	Other error
	Description: 
		Enter the leisure power save mode. 
  Idle for a while if we connect to AP a while ago. 
   4 Sec 
 For Tenda W311R IOT issue 
	Description: 
		Leave the leisure power save mode. 
  Description: Leave all power save mode: LPS, FwLPS, IPS if needed. 
  Move code to function by tynli. 2010.03.26. 
 connect 
  PS_MODE_MIN; 
 rtw_pwr_wakeup - Wake the NIC up from: 1)IPS. 2)USB autosuspend
 @adapter: pointer to struct adapter structure
 @ips_deffer_ms: the ms wiil prevent from falling into IPS after wakeup
 Return _SUCCESS or _FAIL
 System suspend is not allowed to wakeup 
 block??? 
 I think this should be check in IPS, LPS, autosuspend functions... 
 TODO: the following checking need to be merged... 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. i
  waiting time for pppoe server in sec 
-----------------------------------------------------------------
  How database records network address:
	   0    1    2    3    4    5    6    7    8    9   10
	|----|----|----|----|----|----|----|----|----|----|----|
  IPv4  |type|                             |      IP addr      |
  IPX   |type|      Net addr     |          Node addr          |
  IPX   |type|      Net addr     |Sckt addr|
  Apple |type| Network |node|
  PPPoE |type|   SID   |           AC MAC            |
 Find a tag in pppoe frame and return the pointer 
  prevent un-alignment access 
  have a room for new tag 
  Caller must spin_lock already! 
  Caller must spin_lock already! 
 	NAT2.5 interface
---------------------------------------------------
                 Handle IP frame                   
---------------------------------------------------
 some multicast with source IP is all zero, maybe other case is illegal 
 in class A, B, C, host address is all zero or all one is illegal 
 record source IP address and , source mac address into db 
---------------------------------------------------
                 Handle ARP frame                  
---------------------------------------------------
  skb_copy for all ARP frame 
  change to ARP sender mac address to wlan STA address 
---------------------------------------------------
                Handle PPPoE frame                 
---------------------------------------------------
  Discovery phase according to tag 
  if SID existed, copy old value and delete it 
  insert the magic_code+client mac in relay tag 
 Add relay tag 
  not add relay tag 
  session phase 
---------------------------------------------------
                 Handle EAP frame                  
---------------------------------------------------
---------------------------------------------------
         Handle C-Media proprietary frame          
---------------------------------------------------
------------------------------------------------
         Handle IPV6 frame			  
------------------------------------------------
 312 - cookie 
  IP 
  UDP 
  DHCP request 
  match magic word 
  if not broadcast 
  or BROADCAST flag 
  recalculate checksum 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
  We don't need to memset padapter->XXX to zero, because adapter is allocated by vzalloc(). 
  1: active, 0: pasive. Maybe someday we should rename this varable to "active_mode" (Jeff) 
 allocate DMA-ableNon-Page memory for cmd_buf and rsp_buf 
 _queue free_queue) 
  unit:sec 
	return the wlan_network with the matching addr
	Shall be calle under atomic context... to avoid possible racing condition...
 in ad-hoc mode bit1 must set to 1 
 p[0]; 
 p[1]; 
 p[2]; 
 struct	mlme_priv pmlmepriv) 
  (pmlmepriv); 
	return the wlan_network with the matching addr
	Shall be calle under atomic context... to avoid possible racing condition...
 this will update src.Rssi, need consider again 
 The rule below is 15 for sample value, 45 for history value 
 Take the recvpriv's value for the connected AP
 the rssi value here is undecorated, and will be used for antenna diversity 
 from the right channel 
(src->Rssi+dst->Rssi4)5;
		if (sq_smp != 101) {  from the right channel 
((u32)(src->PhyInfo.SignalStrength)+(u32)(dst->PhyInfo.SignalStrength)4)5;
((u32)(src->PhyInfo.SignalQuality)+(u32)(dst->PhyInfo.SignalQuality)4)5;
(src->Rssi+dst->Rssi4)5;
		} else {
			 bss info not receiving from the right channel, use the original RX signal infos 
			ss_final = dst->PhyInfo.SignalStrength;
			sq_final = dst->PhyInfo.SignalQuality;
			rssi_final = dst->Rssi;
		}
Caller must hold pmlmepriv->lock first.
	 If we didn't find a match, then get a new network slot to initialize
 If there are no more slots, expire the oldest 
  variable initialize 
 bss info not receiving from the right channel 
 Otherwise just pull from the free list 
  will update scan_time 
 bss info not receiving from the right channel 
		 we have an entry and we are going to update it. But this entry may
		  be already expired. In this case we do the same as we found a new
		  net and call the new_net handler
 target.Reserved[0]== 1, means that scanned network is a bcn frame. 
 probe resp(3) > beacon(1) > probe req(2) 
 select the desired network based on the capability of the (i)bss. 
  check items:	(1) security 
 			(2) network_type 
 			(3) WMM 
			(4) HT 
			(5) others 
 u8 wps_ie[512]; 
 for  correct flow of 8021X  to do.... 
  update IBSS_network 's timestamp 
  lock pmlmepriv->lock when you accessing network_q 
 there is no need to wait for join 
rtw_free_assoc_resources: the caller has to lock pmlmepriv->lock
rtw_indicate_connect: the caller has to lock pmlmepriv->lock
rtw_indicate_disconnect: the caller has to lock pmlmepriv->lock
 update ptarget_sta 
 sta mode 
 security related 
 	Commented by Albert 20120721 
 	When doing the WPS, the wps_ie_len won't equal to 0 
 	And the Wi-Fi driver shouldn't allow the data packet to be tramsmitted. 
 for A-MPDU Rx reordering buffer control for bmc_sta & sta_info 
 if A-MPDU Rx is enabled, resetting  rx_ordering_ctrl wstart_b(indicate_seq) to default value = 0xffff 
 todo: check if AP can send A-MPDU packets 
 preorder_ctrl = &precvpriv->recvreorder_ctrl[i]; 
 max_ampdu_sz; ex. 32(kbytes) -> wsize_b = 32 
 preorder_ctrl = &precvpriv->recvreorder_ctrl[i]; 
 max_ampdu_sz; ex. 32(kbytes) -> wsize_b = 32 
 misc. 
 pnetwork: returns from rtw_joinbss_event_callback 
 ptarget_wlan: found from scanned_queue 
  why not use ptarget_wlan?? 
  some IEs in pnetwork is wrong, so we should use ptarget_wlan IEs 
 the ptarget_wlan->network.Rssi is raw data, we use ptarget_wlan->network.PhyInfo.SignalStrength instead (has scaled) 
 update fw_state will clr _FW_UNDER_LINKING here indirectly 
 Notes: the function could be > passive_level (the same context as Rx tasklet) 
 pnetwork: returns from rtw_joinbss_event_callback 
 ptarget_wlan: found from scanned_queue 
 if join_res > 0, for (fw_state == WIFI_STATION_STATE), we check if  "ptarget_sta" & "ptarget_wlan" exist. 
 if join_res > 0, for (fw_state == WIFI_ADHOC_STATE), we only check if "ptarget_wlan" exist. 
 if join_res > 0, update "cur_network->network" from "pnetwork->network" if (ptarget_wlan != NULL). 
 s1. find ptarget_wlan 
 s2. update cur_network 
 s3. find ptarget_sta & update ptarget_sta after update cur_network only for station mode 
 s4. indicate connect 
 s5. Cancle assoc_timer 
 if join_res < 0 (join fails), then try again 
 adhoc  id =  31~2 
 FOR AP , AD-HOC mode 
 MACID|OPMODE:1 connect 
 for AD-HOC mode 
 the sta have been in sta_info_queue => do nothing 
 between drv has received this event before and  fw have not yet to set key to CAM_ENTRY) 
 to do: init sta_info variable 
 for ad-hoc mode 
  a sta + bcmc_stainfo (not Ibss_stainfo) 
   MACID|OPMODE:0 means disconnect 
 for STA, AP, ADHOC mode, report disconnect stauts to FW 
 don't roam 
 this stadel_event is caused by roaming, decrease to_roaming 
 don't roam 
  remove the network entry in scanned_queue 
 a sta + bcmc_stainfo (not Ibss_stainfo) 
 free old ibss network 
 re-create ibss 
 _rtw_join_timeout_handler - Timeoutfaliure handler for CMD JoinBss
 @adapter: pointer to struct adapter structure
 join timeout caused by roaming 
 try another 
 rtw_scan_timeout_handler - TimeoutFaliure handler for CMD SiteSurvey
 @adapter: pointer to struct adapter structure
 auto site survey per 60sec 
  302 sec = 60sec 
 auto site survey 
  expire NAT2.5 entry 
  due to rtw_dynamic_check_timer_handlder() is called every 2 seconds 
 Select a new join candidate from the original @param candidate and @param competitor
 @return true: candidate is updated
 @return false: candidate is not updated
 check bssid, if needed 
 check ssid, if needed 
Calling context:
The caller of the sub-routine will be in critical section...
The caller must hold the following spinlock
pmlmepriv->lock
  check for situation of  _FW_LINKED 
 try again 
 try again 
 0~3 
 adjust IEs for rtw_joinbss_cmd in WMM 
 after the fixed IE 
 WMM element ID and OUI 
 Append WMM IE to the last index of out_ie 
  to the next IE element 
  Ported from 8185: IsInPreAuthKeyList(). (Renamed from SecIsInPreAuthKeyList(), 2006-10-13.) 
  Added by Annie, 2006-05-07. 
  Search by BSSID, 
  Return Value: 
 		-1		:if there is no pre-auth key in the  table 
 		>= 0		:if there is pre-auth key, and   return the entry id 
 continue; 
  Could not find. 
  There is one Pre-Authentication Key for the specific BSSID. 
  Check the RSN IE length 
  If the RSN IE length <= 20, the RSN IE didn't include the PMKID information 
  0-11th element in the array are the fixed IE 
  12th element in the array is the IE 
  13th element in the array is the IE length 
  The RSN IE didn't include the PMK ID, append the PMK information 
 PMKID count = 0x0100 
 PMKID length = 2+16 
 copy fixed ie only 
 copy RSN or SSN 
  adhoc no 802.1x 
  TODO 
  1. Supported rates 
  2. IE 
 notes: translate IELength & Length after assign the Length to cmdsz in createbss_cmd(); 
 pdev_network->IELength = cpu_to_le32(sz); 
 the function is at passive_level 
 todo: if you want to do something ioreghw setting before join_bss, please add code here 
 reset to disabled 
  TH = 1 => means that invalidate usb rx aggregation 
  TH = 0 => means that validate usb rx aggregation, use init value. 
 the function is >= passive_level 
		
		AMPDU_para [1:0]:Max AMPDU Len => 0:8k , 1:16k, 2:32k, 3:64k
		AMPDU_para [4:2]:Min MPDU Start Spacing
 the function is > passive_level (in critical_section) 
 maybe needs check if ap supports rx ampdu. 
 check Max Rx A-MPDU Size 
  max_ampdu_sz (kbytes); 
 update cur_bwmode & cur_ch_offset 
 update the MCS rates 
 switch to the 40M Hz mode according to the AP 
  Config SM Power Save setting 
  Config current HT Protection mode. 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
  32 = 6 sec 
  32 = 6 sec 
	delete all reordering_ctrl_timer		
===============================
  Commented by Albert 20090813 
  For the SMC router, the sequence number of first packet of WPS handshake will be 0. 
  In this case, this packet will be dropped by recv_decache function if we use the 0x00 as the default value for tid_rxseq variable. 
  So, we initialize the tid_rxseq variable as the 0xffff. 
 for A-MPDU Rx reordering buffer control 
 64; 
 init for DM 
 init for the sequence number of received management frame 
  using pstapriv->sta_hash_lock to protect 
  re-init sta_info; 20061114 
 for A-MPDU Rx reordering buffer control, cancel reordering_ctrl_timer 
  free all stainfo which in sta_hash[all] 
 any station allocated can be searched by hash list 
  if found the matched address 
  default broadcast & multicast use macid 1 
 accept unless in deny list 
 deny unless in accept list 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2012 Realtek Corporation. 
  We don't need to memset padapter->XXX to zero, because adapter is allocated by vzalloc(). 
	
	Please insert all the queue initializaiton using rtw_init_queue below
	
	Please allocate memory with the sz = (struct xmit_frame)  NR_XMITFRAME,
	and initialize free_xmit_frame below.
	Please also apply  free_txobj to link_up all the xmit_frames...
 pxmitpriv->pxmit_frame_buf = pxmitpriv->pallocated_frame_buf + 4 - 
 						((size_t) (pxmitpriv->pallocated_frame_buf) &3); 
 init xmit_buf 
 pxmitpriv->pxmitbuf = pxmitpriv->pallocated_xmitbuf + 4 - 
 						((size_t) (pxmitpriv->pallocated_xmitbuf) &3); 
 Tx buf allocation may fail sometimes, so sleep and retry. 
  Init xmit extension buff 
 per AC pending irp 
 no frag 
  (1) RTS_Threshold is compared to the MPDU, not MSDU. 
  (2) If there are more than one frag in  this MSDU, only the first frag uses protection frame. 
 		Other fragments are protected by previous fragment. 
 		So we only need to check the length of first fragment. 
 IOT action 
 check ERP protection 
 check HT op mode 
 check rts 
 to do list: check MIMO power save condition. 
 check AMPDU aggregation for TXOP 
	if (psta->rtsen)
		pattrib->vcs_mode = RTS_CTS;
	else if (psta->cts2self)
		pattrib->vcs_mode = CTS_TO_SELF;
	else
 qos_en, ht_en, init rate, , bw, ch_offset, sgi 
  get user_prio from IP hdr 
 		user_prio = (ntohs(ip_hdr.tos) >> 5) & 0x3; 
  "When priority processing of data frames is supported, 
  a STA's SME should send EAPOL-Key frames at the highest priority." 
  The following is for DHCP and ARP packet, we use cck1M to tx these packets and let LPS awake some time 
  to prevent DHCP protocol fail 
 MINIMUM_DHCP_PACKET_SIZE) { 
  IP header 
  68 : UDP BOOTP client 
  67 : UDP BOOTP server 
  Use low rate to send DHCP packet. 
  If EAPOL , ARP , OR DHCP packet, driver must be in active mode. 
  get sta_info 
  if we cannot get psta => drrp the pkt 
 DBG_88E("%s ==> mac_id(%d)\n", __func__, pattrib->mac_id); 
  if we cannot get psta => drop the pkt 
  get ether_hdr_len 
 pattrib->ether_type == 0x8100) ? (14 + 4): 14; vlan tag 
 if (psecuritypriv->dot11PrivacyAlgrthm == _TKIP_PRIVACY_) 
 encode mic code 
 start to calculate the mic code 
 msleep(10); 
 start to calculate the mic code 
 ToDS == 1 
 DA 
 From Ds == 1 
 ToDS == 0 
 DA 
 From Ds == 1 
 add mic code  and add the mic code length in last_txcmdsz 
 to_ds = 1, fr_ds = 0; 
 Data transfer to AP 
 to_ds = 0, fr_ds = 1; 
 TODO: fill HT Control Field 
 Update Seq Num will be handled by fw 
 check if enable ampdu 
 re-check if enable ampdu by BA_starting_seqctrl 
 check BA_starting_seqctrl 
 AGG BK 
 AGG EN 
 AGG EN 
This sub-routine will perform all the following:
1. remove 802.3 header.
2. create wlan_header, based on the info in pxmitframe
3. append sta's ivext-iv
4. append LLC
5. move frag chunk from pframe to pxmitframe->mem
6. apply sw-encrypt, if necessary.
 2346-4 = 2342 
 adding icv, if necessary... 
  don't do fragment to broadcatmulticast packets 
 Logical Link Control(LLC) SubNetwork Attachment Point(SNAP) header
  IEEE LLCSNAP header contains 8 octets
  First 3 octets comprise the LLC portion
  SNAP portion, 5 octets, is divided into two fields:
 	Organizationally Unique Identifier(OUI), 3 octets,
 	type, defined by that organization, 2 octets.
 pxmitbuf->ext_tag = true; 
 DBG_88E("+rtw_alloc_xmitbuf\n"); 
Calling context:
1. OS_TXENTRY
2. RXENTRY (rx_thread or RX_ISRRX_CallBack)
If we turn on USE_RXTHREAD, then, no need for critical section.
Otherwise, we must use _enter_exit critical to protect free_xmit_queue...
Must be very very cautious...
 _queue pfree_xmit_queue) 
	
		Please remember to use all the osdep_service api,
		and lockunlock or _enter_exit critical to protect
		pfree_xmit_queue
 default value setting 
 pxframe->attrib.psta = NULL; 
 default use pkt_offset to fill tx desc 
 		pxmitframe->pkt = NULL; 
 Remove sta node when there are no pending packets. 
 must be done after get_next and before break 
  Will enqueue pxmitframe to the proper queue,
  and indicate it to xx_pending list.....
  check if SA is equal to our MAC 
 BCMC in PS (HIQ) 
  The main transmit(tx) entry
  Return
 	1	enqueue
 	0	success, hardware will handle this xmit frame(packet)
 	<0	fail
 HIQ 
 if any one sta is in ps mode 
 tx bcmc packets after upate bcn 
 upate BCN for TIM IE 
 for BCMC Frames 
 for BCMC Frames 
 for BCMC Frames 
 no any sta in ps mode 
 upate BCN for TIM IE 
 timeout, do something?? 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
  for adhoc-master to generate ie and provide supported-rate to fw 
  last element must be zero!! 
  could be pure B, pure G, or BG 
  rtw_set_ie will update frame length 
 frame length 
----------------------------------------------------------------------------
index: the information element id index, limit is the limit for search
 timestamp will be inserted by hardware 
 beacon interval : 2bytes 
 BCN_INTERVAL; 
 capability info 
 SSID 
 supported rates 
 ie = rtw_set_ie(ie, _EXT_SUPPORTEDRATES_IE_, (rateLen - 8), (pdev_network->SupportedRates + 8), &sz); 
 DS parameter set 
 IBSS Parameter Set 
 check if oui matches... 
 check version... 
 No WPA IE - fail silently 
 group_cipher 
 pairwise_cipher 
 No RSN IE - fail silently 
 group_cipher 
 pairwise_cipher 
 Search required WPA or WPA2 IE and copy to sec_ie[] 
 get next 
 get next 
 get next 
  rtw_get_wps_ie - Search WPS IE from a series of IEs
  @in_ie: Address of IEs to search
  @in_len: Length limit from in_ie
  @wps_ie: If not NULL and WPS IE is found, WPS IE will be copied to the buf starting from wps_ie
  @wps_ielen: If not NULL and WPS IE is found, will set to the length of the entire WPS IE
  Returns: The address of the WPS IE found, or NULL
 goto next 
  rtw_get_wps_attr - Search a specific WPS attribute from a given WPS IE
  @wps_ie: Address of WPS IE to search
  @wps_ielen: Length limit from wps_ie
  @target_attr_id: The attribute ID of WPS attribute to search
  @buf_attr: If not NULL and the WPS attribute is found, WPS attribute will be copied to the buf starting from buf_attr
  @len_attr: If not NULL and the WPS attribute is found, will set to the length of the entire WPS attribute
  Returns: the address of the specific WPS attribute found, or NULL
  6 = 1(Element ID) + 1(Length) + 4(WPS OUI) 
 goto first attr 
  4 = 2(Attribute ID) + 2(Length) 
 goto next 
  rtw_get_wps_attr_content - Search a specific WPS attribute content from a given WPS IE
  @wps_ie: Address of WPS IE to search
  @wps_ielen: Length limit from wps_ie
  @target_attr_id: The attribute ID of WPS attribute to search
  @buf_content: If not NULL and the WPS attribute is found, WPS attribute content will be copied to the buf starting from buf_content
  @len_content: If not NULL and the WPS attribute is found, will set to the length of the WPS attribute content
  Returns: the address of the specific WPS attribute content found, or NULL
	 first 3 bytes in vendor specific information element are the IEEE
	  OUI of the vendor. The following byte is used a vendor specific
		 MicrosoftWi-Fi information elements are further typed and
			 Microsoft OUI (00:50:F2) with OUI Type 1:
 this is a Wi-Fi WME info. element 
 Wi-Fi Protected Setup (WPS) IE 
  ieee802_11_parse_elems - Parse information elements in management frames
  @start: Pointer to the start of IEs
  @len: Length of IE buffer in octets
  @elems: Data structure for parsed elements
  @show_errors: Whether to show parsing errors in debug log
  Returns: Parsing result
 Users specify the mac address 
 Use the mac address stored in the Efuse 
  rtw_get_p2p_ie - Search P2P IE from a series of IEs
  @in_ie: Address of IEs to search
  @in_len: Length limit from in_ie
  @p2p_ie: If not NULL and P2P IE is found, P2P IE will be copied to the buf starting from p2p_ie
  @p2p_ielen: If not NULL and P2P IE is found, will set to the length of the entire P2P IE
  Returns: The address of the P2P IE found, or NULL
 goto next 
  rtw_get_p2p_attr - Search a specific P2P attribute from a given P2P IE
  @p2p_ie: Address of P2P IE to search
  @p2p_ielen: Length limit from p2p_ie
  @target_attr_id: The attribute ID of P2P attribute to search
  @buf_attr: If not NULL and the P2P attribute is found, P2P attribute will be copied to the buf starting from buf_attr
  @len_attr: If not NULL and the P2P attribute is found, will set to the length of the entire P2P attribute
  Returns: the address of the specific WPS attribute found, or NULL
  6 = 1(Element ID) + 1(Length) + 3 (OUI) + 1(OUI Type) 
 goto first attr 
  3 = 1(Attribute ID) + 2(Length) 
 goto next 
  rtw_get_p2p_attr_content - Search a specific P2P attribute content from a given P2P IE
  @p2p_ie: Address of P2P IE to search
  @p2p_ielen: Length limit from p2p_ie
  @target_attr_id: The attribute ID of P2P attribute to search
  @buf_content: If not NULL and the P2P attribute is found, P2P attribute content will be copied to the buf starting from buf_content
  @len_content: If not NULL and the P2P attribute is found, will set to the length of the P2P attribute content
  Returns: the address of the specific P2P attribute content found, or NULL
 u16)(pbuf + 1) = cpu_to_le16(attr_len); 
 get bwmode and ch_offset 
 parsing HT_CAP_IE 
 parsing HT_INFO_IE 
 show MCS rate, unit: 100Kbps 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
  UNII 
 HiperLAN2 
 Japan MMAC 
  Japan 
 Japan, means J08 
 Japan, means J12 
 Japan, means J16 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2012 Realtek Corporation. 
	----------------------------------------------------------
					below 2 are reserved
OUI definitions for the vendor specific IE
MCS rate definitions
ChannelPlan definitions
  0x00, RT_CHANNEL_DOMAIN_2G_WORLD , Passive scan CH 12, 13 
  0x01, RT_CHANNEL_DOMAIN_2G_ETSI1 
  0x02, RT_CHANNEL_DOMAIN_2G_FCC1 
  0x03, RT_CHANNEL_DOMAIN_2G_MIKK1 
  0x04, RT_CHANNEL_DOMAIN_2G_ETSI2 
  0x05, RT_CHANNEL_DOMAIN_2G_NULL 
  0x00 ~ 0x1F , Old Define ===== 
 0x00, RT_CHANNEL_DOMAIN_FCC 
 0x01, RT_CHANNEL_DOMAIN_IC 
 0x02, RT_CHANNEL_DOMAIN_ETSI 
 0x03, RT_CHANNEL_DOMAIN_SPAIN 
 0x04, RT_CHANNEL_DOMAIN_FRANCE 
 0x05, RT_CHANNEL_DOMAIN_MKK 
 0x06, RT_CHANNEL_DOMAIN_MKK1 
 0x07, RT_CHANNEL_DOMAIN_ISRAEL 
 0x08, RT_CHANNEL_DOMAIN_TELEC 
 0x09, RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN 
 0x0A, RT_CHANNEL_DOMAIN_WORLD_WIDE_13 
 0x0B, RT_CHANNEL_DOMAIN_TAIWAN 
 0x0C, RT_CHANNEL_DOMAIN_CHINA 
 0x0D, RT_CHANNEL_DOMAIN_SINGAPORE_INDIA_MEXICO 
 0x0E, RT_CHANNEL_DOMAIN_KOREA 
 0x0F, RT_CHANNEL_DOMAIN_TURKEY 
 0x10, RT_CHANNEL_DOMAIN_JAPAN 
 0x11, RT_CHANNEL_DOMAIN_FCC_NO_DFS 
 0x12, RT_CHANNEL_DOMAIN_JAPAN_NO_DFS 
 0x14, RT_CHANNEL_DOMAIN_TAIWAN_NO_DFS 
 0x15, RT_CHANNEL_DOMAIN_ETSI_NO_DFS 
 0x16, RT_CHANNEL_DOMAIN_KOREA_NO_DFS 
 0x17, RT_CHANNEL_DOMAIN_JAPAN_NO_DFS 
 0x18, RT_CHANNEL_DOMAIN_PAKISTAN_NO_DFS 
 0x19, RT_CHANNEL_DOMAIN_TAIWAN2_NO_DFS 
 0x1A, 
 0x1B, 
 0x1C, 
 0x1D, 
 0x1E, 
  0x20 ~ 0x7F , New Define ===== 
 0x20, RT_CHANNEL_DOMAIN_WORLD_NULL 
 0x21, RT_CHANNEL_DOMAIN_ETSI1_NULL 
 0x22, RT_CHANNEL_DOMAIN_FCC1_NULL 
 0x23, RT_CHANNEL_DOMAIN_MKK1_NULL 
 0x24, RT_CHANNEL_DOMAIN_ETSI2_NULL 
 0x25, RT_CHANNEL_DOMAIN_FCC1_FCC1 
 0x26, RT_CHANNEL_DOMAIN_WORLD_ETSI1 
 0x27, RT_CHANNEL_DOMAIN_MKK1_MKK1 
 0x28, RT_CHANNEL_DOMAIN_WORLD_KCC1 
 0x29, RT_CHANNEL_DOMAIN_WORLD_FCC2 
 0x2A, 
 0x2B, 
 0x2C, 
 0x2D, 
 0x2E, 
 0x2F, 
 0x30, RT_CHANNEL_DOMAIN_WORLD_FCC3 
 0x31, RT_CHANNEL_DOMAIN_WORLD_FCC4 
 0x32, RT_CHANNEL_DOMAIN_WORLD_FCC5 
 0x33, RT_CHANNEL_DOMAIN_WORLD_FCC6 
 0x34, RT_CHANNEL_DOMAIN_FCC1_FCC7 
 0x35, RT_CHANNEL_DOMAIN_WORLD_ETSI2 
 0x36, RT_CHANNEL_DOMAIN_WORLD_ETSI3 
 0x37, RT_CHANNEL_DOMAIN_MKK1_MKK2 
 0x38, RT_CHANNEL_DOMAIN_MKK1_MKK3 
 0x39, RT_CHANNEL_DOMAIN_FCC1_NCC1 
 0x3A, 
 0x3B, 
 0x3C, 
 0x3D, 
 0x3E, 
 0x3F, 
 0x40, RT_CHANNEL_DOMAIN_FCC1_NCC2 
 0x41, RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN_2G 
 use the conbination for max channel numbers 
  Search the @param channel_num in given @param channel_set
  @ch_set: the given channel set
  @ch: the given channel number
  return the index of channel_num in channel_set, -1 if not found
Following are the initialization functions for WiFi MLME
 reset to zero when disconnect at client mode 
 Channel 1~11 is active, and 12~14 is passive 
  channel 12~13, passive scan 
 _cancel_timer_ex(&pmlmeext->ADDBA_timer); 
 receive the frames that ra(a1) is my address or ra(a1) is bc address. 
 receive the frames that ra(a1) is my address or ra(a1) is bc address. 
 drop the duplicate management frame 
	do nothing if the device name is empty 
Following are the callback functions for each subtype of the management frames
	mcs_rate = 0 -> CCK 1M rate 
	mcs_rate = 1 -> CCK 2M rate 
	mcs_rate = 2 -> CCK 5.5M rate 
	mcs_rate = 3 -> CCK 11M rate 
	In the P2P mode, the driver should not support the CCK rate 
	Commented by Kurt 20121016 
	IOT issue: Google Nexus7 use 1M rate to send p2p_probe_req after GO nego completed and Nexus7 is client 
  FIXME 
 check (wildcard) SSID 
 we should update current network before auth, or some IE is wrong 
 check the vendor of the assoc AP 
 update TSF Value 
 start auth 
 update WMM, ERP in the beacon 
 todo: the timer is used instead of the number of the beacon received 
 update WMM, ERP in the beacon 
 todo: the timer is used instead of the number of the beacon received 
 allocate a new CAM entry for IBSS station 
 get supported rate 
 update TSF Value 
 report sta add event 
  rx a shared-key auth but shared not enabled 
  rx a open-system auth but shared-key is enabled 
  allocate a new one 
 TODO: STA re_auth and auth timeout 
  shared system or auto authentication 
 prepare for the challenging txt... 
 checking for challenging txt... 
  challenging txt is correct... 
  Now, we are going to issue_auth... 
 check A1 matches or not 
  pmlmeinfo->auth_algo == dot11AuthAlgrthm_Auto) 
  legendary shared system 
  open system 
  this is also illegal 
  WIFI_REASSOCREQ 
  check if this stat has been successfully authenticatedassocated 
 now parse all ieee802_11 ie to point to elems 
  now we should check all the fields... 
  checking SSID 
  broadcast ssid, however it is not allowed in assocreq 
  check if ssid match 
  check if the supported rate is ok 
  use our own rate set as statoin used 
 memcpy(supportRate, AP_BSSRATE, AP_BSSRATE_LEN); 
 supportRateNum = AP_BSSRATE_LEN; 
 todo: mask supportRate between AP & STA -> move to update raid 
 get_matched_rate(pmlmeext, supportRate, &supportRateNum, 0); 
 update station supportRate 
 check RSNWPAWPS 
 psk,  todo:802.1x 
 psk,  todo:802.1x 
 wpabuf_free(sta->wps_ie); 
 sta->wps_ie = wpabuf_alloc_copy(elems.wps_ie + 4, 
				elems.wps_ie_len - 4); 
  AP support WPARSN, and sta is going to do WPS, but AP is not ready 
  that the selected registrar of AP is _FLASE 
  check if there is WMM IE & support WWM-PS 
 save HT capabilities in the sta object 
 status = WLAN_STATUS_CIPHER_REJECTED_PER_POLICY; 
 goto OnAssocReqFail; 
 TODO: identify_proprietary_vendor_ie(); 
  Realtek proprietary IE 
  identify if this is Broadcom sta 
  identify if this is ralink sta 
  Customer proprietary IE 
 get a unique AID 
 if (pstat->aid > NUM_STA) { 
  now the station is qualified to join our BSS... 
 1 bss_cap_update & sta_info_update 
 issue assoc rsp before notify station join event. 
 2 - report to upper layer 
 3-(1) report sta add event 
 struct wlan_bssid_ex cur_network = &(pmlmeinfo->network); 
 check A1 matches or not 
 status 
 get capabilities 
 set slot time 
 AID 
 following are moved to join event callback function 
 to handle HT, WMM, rate adaptive, update MAC reg 
 for not to handle the synchronous IO in the tasklet 
 WMM 
 HT caps 
 HT info 
 Update Basic Rate Table for spec, 2010-12-28 , by thomas 
 check A3 
		 Before sending the auth frame to start the STAGC mode connection with APGO,
		 	we will send the deauth first.
		 	However, the Win8.1 with BRCM Wi-Fi will send the deauth with reason code 6 to us after receieving our deauth.
		 	Added the following code to avoid this case.
 TODO: 802.11r
 check A3 
 check RA matches or not 
 for if1, staap mode 
  representing Block Ack 
 ADDBA request 
 reject ADDBA Req 
 ADDBA response 
 successful 
 DELBA 
 todo: how to notify the host while receiving DELETE BA 
 update attribute 
	Initialize the dialog value 
	WPS Section 
	WPS OUI 
	WPS version 
	Type: 
	Length: 
	Value: 
	Version 1.0 
	Device Password ID 
	Type: 
	Length: 
	Value: 
	P2P IE Section. 
	P2P OUI 
	WFA P2P v1.0 
	Commented by Albert 20110306 
	According to the P2P Specification, the group negoitation request frame should contain 9 P2P attributes 
	1. P2P Capability 
	2. Group Owner Intent 
	3. Configuration Timeout 
	4. Listen Channel 
	5. Extended Listen Timing 
	6. Intended P2P Interface Address 
	7. Channel List 
	8. P2P Device Info 
	9. Operating Channel 
	P2P Capability 
	Type: 
	Length: 
	Value: 
	Device Capability Bitmap, 1 byte 
	Group Capability Bitmap, 1 byte 
	Group Owner Intent 
	Type: 
	Length: 
	Value: 
	Todo the tie breaker bit. 
	Configuration Timeout 
	Type: 
	Length: 
	Value: 
	2 seconds needed to be the P2P GO 
	2 seconds needed to be the P2P Client 
	Listen Channel 
	Type: 
	Length: 
	Value: 
	Country String 
	The third byte should be set to 0x04. 
	Described in the "Operating Channel Attribute" section. 
	Operating Class 
	Copy from SD7 
	Channel Number 
	listening channel number 
	Extended Listen Timing ATTR 
	Type: 
	Length: 
	Value: 
	Availability Period 
	Availability Interval 
	Intended P2P Interface Address 
	Type: 
	Length: 
	Value: 
	Channel List 
	Type: 
  Length: 
  Country String(3) 
  + (Operating Class (1) + Number of Channels(1))  Operation Classes (?) 
  + number of channels in all classes 
	Value: 
	Country String 
	The third byte should be set to 0x04. 
	Described in the "Operating Channel Attribute" section. 
	Channel Entry List 
	Operating Class 
	Number of Channels 
	Channel List 
	Device Info 
	Type: 
	Length: 
	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) 
	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) 
	Value: 
	P2P Device Address 
	Config Method 
	This field should be big endian. Noted by P2P specification. 
	Primary Device Type 
	Category ID 
	OUI 
	Sub Category ID 
	Number of Secondary Device Types 
	No Secondary Device Type List 
	Device Name 
	Type: 
	Length: 
	Value: 
	Operating Channel 
	Type: 
	Length: 
	Value: 
	Country String 
	The third byte should be set to 0x04. 
	Described in the "Operating Channel Attribute" section. 
	Operating Class 
	Channel Number 
	operating channel number 
 update attribute 
	The Dialog Token of provisioning discovery request frame. 
	Commented by Albert 20110328 
	Try to get the device password ID from the WPS IE of group negotiation request frame 
	WiFi Direct test plan 5.1.15 
	WPS Section 
	WPS OUI 
	WPS version 
	Type: 
	Length: 
	Value: 
	Version 1.0 
	Device Password ID 
	Type: 
	Length: 
	Value: 
	Commented by Kurt 20120113 
	If some device wants to do p2p handshake without sending prov_disc_req 
	We have to get peer_req_cm from here. 
	P2P IE Section. 
	P2P OUI 
	WFA P2P v1.0 
	Commented by Albert 20100908 
	According to the P2P Specification, the group negoitation response frame should contain 9 P2P attributes 
	1. Status 
	2. P2P Capability 
	3. Group Owner Intent 
	4. Configuration Timeout 
	5. Operating Channel 
	6. Intended P2P Interface Address 
	7. Channel List 
	8. Device Info 
	9. Group ID	(Only GO) 
	ToDo: 
	P2P Status 
	Type: 
	Length: 
	Value: 
	P2P Capability 
	Type: 
	Length: 
	Value: 
	Device Capability Bitmap, 1 byte 
	Commented by Albert 20110308 
	According to the P2P specification 
	if the sending device will be client, the P2P Capability should be reserved of group negotiation response frame 
	Be group owner or meet the error case 
	Group Capability Bitmap, 1 byte 
	Group Owner Intent 
	Type: 
	Length: 
	Value: 
	Peer's tie breaker bit is 1, our tie breaker bit should be 0 
	Peer's tie breaker bit is 0, our tie breaker bit should be 1 
	Configuration Timeout 
	Type: 
	Length: 
	Value: 
	2 seconds needed to be the P2P GO 
	2 seconds needed to be the P2P Client 
	Operating Channel 
	Type: 
	Length: 
	Value: 
	Country String 
	The third byte should be set to 0x04. 
	Described in the "Operating Channel Attribute" section. 
	Operating Class 
	Channel Number 
	operating channel number 
	Intended P2P Interface Address 
	Type: 
	Length: 
	Value: 
	Channel List 
	Type: 
  Country String(3) 
  + (Operating Class (1) + Number of Channels(1))  Operation Classes (?) 
  + number of channels in all classes 
	Value: 
	Country String 
	The third byte should be set to 0x04. 
	Described in the "Operating Channel Attribute" section. 
	Channel Entry List 
	Operating Class 
	Number of Channels 
	Channel List 
	Device Info 
	Type: 
	Length: 
	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) 
	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) 
	Value: 
	P2P Device Address 
	Config Method 
	This field should be big endian. Noted by P2P specification. 
	Primary Device Type 
	Category ID 
	OUI 
	Sub Category ID 
	Number of Secondary Device Types 
	No Secondary Device Type List 
	Device Name 
	Type: 
	Length: 
	Value: 
	Group ID Attribute 
	Type: 
	Length: 
	Value: 
	p2P Device Address 
	SSID 
 update attribute 
	P2P IE Section. 
	P2P OUI 
	WFA P2P v1.0 
	Commented by Albert 20110306 
	According to the P2P Specification, the group negoitation request frame should contain 5 P2P attributes 
	1. Status 
	2. P2P Capability 
	3. Operating Channel 
	4. Channel List 
	5. Group ID	(if this WiFi is GO) 
	P2P Status 
	Type: 
	Length: 
	Value: 
	P2P Capability 
	Type: 
	Length: 
	Value: 
	Device Capability Bitmap, 1 byte 
	Group Capability Bitmap, 1 byte 
	Operating Channel 
	Type: 
	Length: 
	Value: 
	Country String 
	The third byte should be set to 0x04. 
	Described in the "Operating Channel Attribute" section. 
	Operating Class 
	Operating Class 
	Channel Number 
	Use the listen channel as the operating channel 
	Channel List 
	Type: 
	Length: 
	Value: 
	Group ID Attribute 
	Type: 
	Length: 
	Value: 
	p2P Device Address 
	SSID 
 update attribute 
	P2P IE Section. 
	P2P OUI 
	WFA P2P v1.0 
	Commented by Albert 20101011 
	According to the P2P Specification, the P2P Invitation request frame should contain 7 P2P attributes 
	1. Configuration Timeout 
	2. Invitation Flags 
	3. Operating Channel	(Only GO) 
	4. P2P Group BSSID	(Should be included if I am the GO) 
	5. Channel List 
	6. P2P Group ID 
	7. P2P Device Info 
	Configuration Timeout 
	Type: 
	Length: 
	Value: 
	2 seconds needed to be the P2P GO 
	2 seconds needed to be the P2P Client 
	Invitation Flags 
	Type: 
	Length: 
	Value: 
	Operating Channel 
	Type: 
	Length: 
	Value: 
	Country String 
	The third byte should be set to 0x04. 
	Described in the "Operating Channel Attribute" section. 
	Operating Class 
	Channel Number 
	operating channel number 
	P2P Group BSSID 
	Type: 
	Length: 
	Value: 
	P2P Device Address for GO 
	Channel List 
	Type: 
	Length: 
  Country String(3) 
  + (Operating Class (1) + Number of Channels(1))  Operation Classes (?) 
  + number of channels in all classes 
	Value: 
	Country String 
	The third byte should be set to 0x04. 
	Described in the "Operating Channel Attribute" section. 
	Channel Entry List 
	Operating Class 
	Number of Channels 
	Channel List 
	P2P Group ID 
	Type: 
	Length: 
	Value: 
	P2P Device Address for GO 
	SSID 
	Device Info 
	Type: 
	Length: 
	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) 
	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) 
	Value: 
	P2P Device Address 
	Config Method 
	This field should be big endian. Noted by P2P specification. 
	Primary Device Type 
	Category ID 
	OUI 
	Sub Category ID 
	Number of Secondary Device Types 
	No Secondary Device Type List 
	Device Name 
	Type: 
	Length: 
	Value: 
 update attribute 
	P2P IE Section. 
	P2P OUI 
	WFA P2P v1.0 
	Commented by Albert 20101005 
	According to the P2P Specification, the P2P Invitation response frame should contain 5 P2P attributes 
	1. Status 
	2. Configuration Timeout 
	3. Operating Channel	(Only GO) 
	4. P2P Group BSSID	(Only GO) 
	5. Channel List 
	P2P Status 
	Type: 
	Length: 
	Value: 
	When status code is P2P_STATUS_FAIL_INFO_UNAVAILABLE. 
	Sent the event receiving the P2P Invitation Req frame to DMP UI. 
	DMP had to compare the MAC address to find out the profile. 
	So, the WiFi driver will send the P2P_STATUS_FAIL_INFO_UNAVAILABLE to NB. 
	If the UI found the corresponding profile, the WiFi driver sends the P2P Invitation Req 
	to NB to rebuild the persistent group. 
	Configuration Timeout 
	Type: 
	Length: 
	Value: 
	2 seconds needed to be the P2P GO 
	2 seconds needed to be the P2P Client 
	The P2P Invitation request frame asks this Wi-Fi device to be the P2P GO 
	In this case, the P2P Invitation response frame should carry the two more P2P attributes. 
	First one is operating channel attribute. 
	Second one is P2P Group BSSID attribute. 
	Operating Channel 
	Type: 
	Length: 
	Value: 
	Country String 
	The third byte should be set to 0x04. 
	Described in the "Operating Channel Attribute" section. 
	Operating Class 
	Copy from SD7 
	Channel Number 
	operating channel number 
	P2P Group BSSID 
	Type: 
	Length: 
	Value: 
	P2P Device Address for GO 
	Channel List 
	Type: 
	Length: 
  Country String(3) 
  + (Operating Class (1) + Number of Channels(1))  Operation Classes (?) 
  + number of channels in all classes 
	Value: 
	Country String 
	The third byte should be set to 0x04. 
	Described in the "Operating Channel Attribute" section. 
	Channel Entry List 
	Operating Class 
	Number of Channels 
	Channel List 
 update attribute 
	WPS OUI 
	WPS version 
	Type: 
	Length: 
	Value: 
	Version 1.0 
	Config Method 
	Type: 
	Length: 
	Value: 
 update attribute 
	Use the device address for BSSID field. 
 timestamp will be inserted by hardware 
  beacon interval: 2 bytes 
	capability info: 2 bytes 
	ESS and IBSS bits must be 0 (defined in the 3.1.2.1.1 of WiFi Direct Spec) 
  SSID 
  supported rates... 
	Use the OFDM rate in the P2P probe response frame. (6(B), 9(B), 12, 18, 24, 36, 48, 54) 
  DS parameter set 
	Todo: WPS IE 
	Noted by Albert 20100907 
	According to the WPS specification, all the WPS attribute is presented by Big Endian. 
	WPS OUI 
	WPS version 
	Type: 
	Length: 
	Value: 
	Version 1.0 
	WiFi Simple Config State 
	Type: 
	Length: 
	Value: 
	Not Configured. 
	Response Type 
	Type: 
	Length: 
	Value: 
	UUID-E 
	Type: 
	Length: 
	Value: 
	Manufacturer 
	Type: 
	Length: 
	Value: 
	Model Name 
	Type: 
	Length: 
	Value: 
	Model Number 
	Type: 
	Length: 
	Value: 
	character 1 
	Serial Number 
	Type: 
	Length: 
	Value: 
	Primary Device Type 
	Type: 
	Length: 
	Value: 
	Category ID 
	OUI 
	Sub Category ID 
	Device Name 
	Type: 
	Length: 
	Value: 
	Config Method 
	Type: 
	Length: 
	Value: 
 update attribute 
	This two flags will be set when this is only the P2P client mode. 
	broadcast probe request frame 
	Use the OFDM rate in the P2P probe request frame. (6(B), 9(B), 12(B), 24(B), 36, 48, 54) 
	WPS IE 
	Noted by Albert 20110221 
	According to the WPS specification, all the WPS attribute is presented by Big Endian. 
	WPS OUI 
	WPS version 
	Type: 
	Length: 
	Value: 
	Version 1.0 
	UUID-E 
	Type: 
	Length: 
	Value: 
	Config Method 
	Type: 
	Length: 
	Value: 
	Device Name 
	Type: 
	Length: 
	Value: 
	Primary Device Type 
	Type: 
	Length: 
	Value: 
	Category ID 
	OUI 
	Sub Category ID 
	Device Password ID 
	Type: 
	Length: 
	Value: 
	Registrar-specified 
	P2P OUI 
	WFA P2P v1.0 
	Commented by Albert 20110221 
	According to the P2P Specification, the probe request frame should contain 5 P2P attributes 
	1. P2P Capability 
	2. P2P Device ID if this probe request wants to find the specific P2P device 
	3. Listen Channel 
	4. Extended Listen Timing 
	5. Operating Channel if this WiFi is working as the group owner now 
	P2P Capability 
	Type: 
	Length: 
	Value: 
	Device Capability Bitmap, 1 byte 
	Group Capability Bitmap, 1 byte 
	Listen Channel 
	Type: 
	Length: 
	Value: 
	Country String 
	The third byte should be set to 0x04. 
	Described in the "Operating Channel Attribute" section. 
	Operating Class 
	Copy from SD7 
	Channel Number 
	listen channel 
	Extended Listen Timing 
	Type: 
	Length: 
	Value: 
	Availability Period 
	Availability Interval 
	Operating Channel (if this WiFi is working as the group owner now) 
	Type: 
	Length: 
	Value: 
	Country String 
	The third byte should be set to 0x04. 
	Described in the "Operating Channel Attribute" section. 
	Operating Class 
	Copy from SD7 
	Channel Number 
	operating channel number 
 WPS IE 
	Do nothing if the driver doesn't enable the P2P function. 
 OUI Subtype 
	Commented by Albert 20110526 
	In this case, this means the previous nego fail doesn't be reset yet. 
	Restore the previous p2p state 
	Commented by Kurt 20110902 
 Add if statement to avoid receiving duplicate prov disc req. such that pre_p2p_state would be covered. 
	Commented by Kurt 20120113 
	Get peer_dev_addr here if peer doesn't issue prov_disc frame. 
	Commented by Albert 20110718 
	No matter negotiating or negotiation failure, the driver should set up the restore P2P state timer. 
	Commented by Albert 20110425 
	The restore timer is enabled when issuing the nego request frame of rtw_p2p_connect function. 
	Reset the dialog token for group negotiation frames. 
	Added by Albert 20101005 
	Received the P2P Invite Request frame. 
	Parse the necessary information from the P2P Invitation Request frame. 
	For example: The MAC address of sending this P2P Invitation Request frame. 
	Commented by Albert 20120510 
	Copy to the pwdinfo->p2p_peer_interface_addr. 
	So that the WFD UI (or Sigma) can get the peer interface address by using the following command. 
	#> iwpriv wlan0 p2p_get peer_ifa 
	After having the peer interface address, the sigma can find the correct conf file for wpa_supplicant. 
	Re-invoke the persistent group. 
	The p2p device sending this p2p invitation request wants this Wi-Fi device to be the persistent GO. 
	The p2p device sending this p2p invitation request wants to be the persistent GO. 
	The operating channel is acceptable for this device. 
	The operating channel isn't supported by this device. 
	Commented by Albert 20121130 
	Intel will use the different P2P IE to store the operating channel information 
	Workaround for Intel WiDi 3.5 
	Received the invitation to join a P2P group. 
	In this case, the GO can't be myself. 
	The p2p device sending this p2p invitation request wants to join an existing P2P group 
	Commented by Albert 20120628 
	In this case, this Wi-Fi device should use the iwpriv command to get the peer device address. 
	The peer device address should be the destination address for the provisioning discovery request. 
	Then, this Wi-Fi device should use the iwpriv command to get the peer interface address. 
	The peer interface address should be the address for WPS mac address 
 20110902 Kurt 
 Add the following statement to avoid receiving duplicate prov disc req. such that pre_p2p_state would be covered. 
	Commented by Albert 20110707 
	Should we check the pwdinfo->tx_prov_disc_info.bsent flag here?? 
	Commented by Albert 20110426 
	The restore timer is enabled when issuing the provisioing request frame in rtw_p2p_prov_disc function. 
 check RA matches or not 
 check RA matches or not 
 for if1, staap mode 
Following are some TX fuctions for WiFi MLME
 b mode 
 ag mode 
   500ms 
 update attribute 
pmlmeext->mgnt_seq);
 pmlmeext->mgnt_seq++; 
  for P2P : Primary Device Type & Device Name 
 now pframe is end of wsc ie, insert Primary Device Type & Device Name 
	Primary Device Type 
	Type: 
	Length: 
	Value: 
	Category ID 
	OUI 
	Sub Category ID 
	Device Name 
	Type: 
	Length: 
	Value: 
 update wsc ie length 
 pframe move to end 
 copy remainder_ie to pframe 
 below for ad-hoc mode 
 timestamp will be inserted by hardware 
  beacon interval: 2 bytes 
  capability info: 2 bytes 
  SSID 
  supported rates... 
  DS parameter set 
  IBSS Parameter Set... 
 ERP IE 
  EXTERNDED SUPPORTED RATE 
 todo:HT for adhoc 
 DBG_88E("issue bcn_sz=%d\n", pattrib->last_txcmdsz); 
 update attribute 
 inerset & update wps_probe_resp_ie 
 to get ie data len 
 timestamp will be inserted by hardware 
  beacon interval: 2 bytes 
  capability info: 2 bytes 
 below for ad-hoc mode 
  SSID 
  supported rates... 
  DS parameter set 
  IBSS Parameter Set... 
 ATIMWindow = cur->Configuration.ATIMWindow; 
 ERP IE 
  EXTERNDED SUPPORTED RATE 
 todo:HT for adhoc 
 update attribute 
	unicast probe request frame 
	broadcast probe request frame 
 add wps_ie for wps2.0 
  if psta == NULL, indiate we are station(client) now... 
 update attribute 
  for AP mode 
  setting auth algo number 
  setting auth seq number 
  setting status code... 
  added challenging text... 
  setting auth algo number 
  0:OPEN System, 1:Shared key 
 setting IV for auth seq #3 
  setting auth seq number 
  setting status code... 
  then checking to see if sending challenging text... 
 update attribute 
 capability 
 FILL HT CAP INFO IE 
 FILL HT ADD INFO IE 
 FILL WMM IE 
 add WPS IE ie for wps 2.0 
 update attribute 
 caps 
 listen interval 
 todo: listen interval for power saving 
 SSID 
 supported rate & extended supported rate 
  Check if the AP's supported rates are also supported by STA. 
  for JAPAN, channel 14 can only uses B Mode(CCK) 
  Check if the AP's supported rates are also supported by STA. 
  Avoid the proprietary data rate (22Mbps) of Handlink WSG-4000 AP 
  the rate is not supported by STA 
  the rate is supported by STA 
 don't connect to AP if no joint supported rate 
 RSN 
 HT caps 
 to disable 40M Hz support while gd_bw_40MHz_en = 0 
 todo: disable SM power save mode 
 RX STBC One spatial stream 
 enable for 2.45 GHz 
 enable for 2.4GHz 
 RX STBC two spatial stream 
 vendor specific IE, such as WPA, WMM, WPS 
 Commented by Kurt 20110629 
 In some older APs, WPS handshake 
 would be fail if we append vender extensions informations to AP 
	Should add the P2P IE in the association request frame. 
	P2P OUI 
	WFA P2P v1.0 
	Commented by Albert 20101109 
	According to the P2P Specification, the association request frame should contain 3 P2P attributes 
	1. P2P Capability 
	2. Extended Listen Timing 
	3. Device Info 
	Commented by Albert 20110516 
	4. P2P Interface 
	P2P Capability 
	Type: 
	Length: 
	Value: 
	Device Capability Bitmap, 1 byte 
	Group Capability Bitmap, 1 byte 
	Extended Listen Timing 
	Type: 
	Length: 
	Value: 
	Availability Period 
	Availability Interval 
	Device Info 
	Type: 
	Length: 
	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) 
	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) 
	Value: 
	P2P Device Address 
	Config Method 
	This field should be big endian. Noted by P2P specification. 
	Primary Device Type 
	Category ID 
	OUI 
	Sub Category ID 
	Number of Secondary Device Types 
	No Secondary Device Type List 
	Device Name 
	Type: 
	Length: 
	Value: 
	P2P Interface 
	Type: 
	Length: 
	Value: 
	P2P Device Address 
	P2P Interface Address Count 
	P2P Interface Address List 
 when wait_ack is ture, this function shoule be called at process context 
 update attribute 
 when wait_ms > 0 , this function shoule be called at process context 
 da == NULL for station mode 
 da == NULL, assum it's null data for sta to ap
 when wait_ack is ture, this function shoule be called at process context 
 update attribute 
 when wait_ms > 0 , this function shoule be called at process context 
 da == NULL for station mode 
 da == NULL, assum it's null data for sta to ap
 update attribute 
 update attribute 
 memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN); 
 ADDBA req 
 immediate ack & 64 buffer size 
  5ms 
 ADDBA rsp 
 64 buffer size 
 32 buffer size 
 16 buffer size 
 8 buffer size 
 64 buffer size 
 disabled 
 enabled 
 DELBA 
 Requested from peer STA as it does not want to use the mechanism 
 update attribute 
 20 MHz BSS Width Request 
 non-HT 
 SET_BSS_INTOLERANT_ELE_REG_CLASS(InfoContent, i); 
 channel number 
 SET_BSS_INTOLERANT_ELE_CHANNEL(InfoContent+k, j); 
 struct recv_reorder_ctrl preorder_ctrl; 
  recipient 
  originator 
Following are some utitity fuctions for WiFi MLME
	Commented by Albert 20110603 
	The driver is in the find phase, it should go through the social channel. 
 obey the channel plan setting... 
 todo: to issue two probe req??? 
 msleep(SURVEY_TO>>1); 
 todo: to issue two probe req??? 
 msleep(SURVEY_TO>>1); 
	channel number is 0 or this channel is not valid. 
	Set the find_phase_state_exchange_cnt to P2P_FINDPHASE_EX_CNT. 
	This will let the following flow to run the scanning end. 
	Set the P2P State to the listen state of find phase and set the current channel to the listen channel 
 restore RX GAIN 
 turn on dynamic functions 
 Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, true); 
  20100721:Interrupt scan operation here. 
  For SW antenna diversity before link, it needs to switch to another antenna and scan again. 
  It compares the scan result and select beter one to do connection. 
 switch back to the original channel 
 config MSR 
 restore RX GAIN 
 turn on dynamic functions 
 Switch_DM_Func(padapter, DYNAMIC_ALL_FUNC_ENABLE, true); 
 survey done 
 collect bss info from Beacon and Probe requestresponse frames. 
  FIXME : more type 
 below is to copy the information element 
 get the signal strength 
  in dBM.raw data 
 in percentage 
 in percentage 
  checking SSID 
 checking rate info... 
 todo: 
  Checking for DSConfig 
  In 5G, some ap do not have DSSET IE 
  checking HT info for channel 
  use current channel 
 2040 BSS Coexistence check 
  mark bss info receiving from nearby channel as SignalQuality 101 
 update wireless mode 
 udpate capability 
 adhoc master 
 switch channel 
 SelectChannel(padapter, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE); 
 set msr to WIFI_FW_ADHOC_STATE 
 issue beacon 
 update bcmc sta_info 
 update wireless mode 
 udpate capability 
 switch channel 
 here wait for receiving the beacon to start auth 
 and enable a timer 
 adhoc client 
 switch channel 
  Because of AP's not receiving deauth before 
  AP may: 1)not response auth or 2)deauth us after link is complete 
  issue deauth before issuing auth to deal with the situation 
	Commented by Albert 20120721 
	For the Win8 P2P connection, it will be hard to have a successful connection if this Wi-Fi doesn't connect to it. 
 check A3 
  Adjust channel plan by AP Country IE 
  first channel number 
  number of channel 
  change AP not support channel to Passive scan 
  add channel AP supported 
  keep original STA 2.4G channel plan 
  skip AP 2.4G channel plan 
  keep original STA 5G channel plan 
  If channel is used by AP, set channel scan type to active 
Following are the functions to report events
 u8 pframe = precv_frame->rx_data; 
 uint len = precv_frame->len; 
Following are the event callback functions
 for staadhoc mode 
 ERP 
 HT 
 reset 
 reset 
 QoS 
 restore to initial setting. 
 for bcmc 
 turn on dynamic functions 
  update IOT-releated issue 
 BCN interval 
 udpate capability 
 WMM, Update EDCA param 
 HT 
 only for infra. mode 
 set per sta rate after updating HT cap. 
   MACID|OPMODE: 1 means connect 
  correcting TSF 
 adhoc master or sta_count>1 
 nothing to do 
 adhoc client 
  correcting TSF 
 start beacon 
 rate radaptive 
 update adhoc sta_info 
 restore to initial setting. 
 switch to the 20M Hz mode after disconnect 
 SelectChannel(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset); 
 set MSR to no link state -> infra. mode 
Following are the functions for the timer handlers
 linked infrastructure client mode 
 switch to correct channel of current network  before issue keep-alive frames 
 if tx acked and p2p disabled, set rx_chk _SUCCESS to reset retry count 
 back to the original operation channel 
 end of if ((psta = rtw_get_stainfo(pstapriv, passoc_res->network.MacAddress)) != NULL) 
 linked IBSS mode 
 for each assoc list entry to check the rx pkt counter 
  indicate disconnect caused by no rx 
 issue rtw_sitesurvey_cmd 
 reset 
 re-auth timer 
 re-assoc timer 
  clear state 
 set to	STATION_STATE 
 u32	initialgain; 
 todo: 
 below is for ad-hoc master 
 disable dynamic functions, such as high power, DIG 
 cancel link timer 
 clear CAM 
 Check pbuf->IELength 
 check already connecting to AP or not 
 clear CAM 
 set MSR to nolink -> infra. mode 
 Check pbuf->IELength 
 Check AP vendor to move rtw_joinbss_cmd() 
 Get WMM IE. 
 Get HT Cap IE. 
 Get HT Info IE. 
 spec case only for cisco's ap because cisco's ap issue assoc rsp using mcs rate @40MHz or @20MHz 
 switch to the 40M Hz mode according to the AP 
 disable dynamic functions, such as high power, DIG 
 config the initial gain under linking, need to write the BB registers 
 cancel link timer 
 restore to initial setting. 
 Stop BCN 
 set MSR to no link state -> infra. mode 
 switch to the 20M Hz mode after disconnect 
 clear out first 
 acquire channels from in 
 if out is empty, use channel_set as default 
 for first time sitesurvey_cmd 
 issue null data if associating to the AP 
 delay 50ms to protect nulldata(1). 
 disable dynamic functions, such as high power, DIG 
 config the initial gain under scanning, need to write the BB registers 
 set MSR to no link state 
 under site survey 
 main tx key for wep. 
 write cam 
 cam_entry 
 cam_entry: 
 0~3 for default key 
 for concurrent mode (ap+sta): 
 default key is disable, using sw encryptdecrypt 
 cam_entry = 4 for sta mode (macid = 0) 
 cam_entry(macid+3) = 5 ~ N for ap mode (aid = 1~N, macid = 2 ~N) 
 for concurrent mode (sta+sta): 
 default key is disable, using sw encryptdecrypt 
 cam_entry = 4 mapping to macid = 0 
 cam_entry = 5 mapping to macid = 2 
  clear cam entry  {
 0~3 for default key, cmd_id = macid + 3, macid = aid+1; 
 below for sta mode 
  clear cam entry 
  checking if event code is valid 
  checking if event size match the event parm size 
 tx bcmc frames after update TIM 
 for BCMC Frames 
  10ms, ATIM(HIQ) Windows 
 HIQ 
  TDLS_WRCR		: write RCR DATA BIT 
  TDLS_SD_PTI		: issue peer traffic indication 
  TDLS_CS_OFF		: go back to the channel linked with AP, terminating channel switch procedure 
  TDLS_INIT_CH_SEN	: init channel sensing, receive all data and mgnt frame 
  TDLS_DONE_CH_SEN: channel sensing and report candidate channel 
  TDLS_OFF_CH		: first time set channel to off channel 
  TDLS_BASE_CH		: go back tp the channel linked with AP when set base channel as target channel 
  TDLS_P_OFF_CH	: periodically go to off channel 
  TDLS_P_BASE_CH	: periodically go back to base channel 
  TDLS_RS_RCR		: restore RCR 
  TDLS_CKALV_PH1	: check alive timer phase1 
  TDLS_CKALV_PH2	: check alive timer phase2 
  TDLS_FREE_STA	: free tdls sta 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2012 Realtek Corporation. 
 define WAIT_FOR_BCN_TO_M	(3000) 
  1M, 2M, 5.5M, 11M, 6M, 12M, 24M are mandatory. 
 saved channel info 
 saved bw info 
 SelectChannel(padapter, channel); 
 switch to the proper channel 
 SelectChannel(padapter, channel + 2); 
 SelectChannel(padapter, channel - 2); 
 set Channel 
 saved channelbw info 
  set center channel 
 struct registry_priv	pregpriv = &padapter->registrypriv; 
 AIFS = AIFSN  slot time + SIFS - r2t phy delay 
 entry indx: 0->vo, 1->vi, 2->be, 3->bk. 
 compare CW and AIFS 
 compare TXOP 
 update HT info also 
 set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode); 
 update ap's stainfo 
  bwmode 
 	Got the endian issue here. 
 modify from  fw by Thomas 20101117 
 update the MCS rates 
 struct registry_priv	 pregpriv = &padapter->registrypriv; 
 handle A-MPDU parameter field 
	
		AMPDU_para [1:0]:Max AMPDU Len => 0:8k , 1:16k, 2:32k, 3:64k
		AMPDU_para [4:2]:Min MPDU Start Spacing
 0:off 1:on 2:auto 
 off 
 on 
 1:RTSCTS 2:CTS to self 
 auto 
 u8 wpa_ie[255], rsn_ie[255]; 
 below is to copy the information element 
 check bw and channel offset 
 parsing HT_CAP_IE 
 parsing HT_INFO_IE 
 bcn_info_update 
 to do : need to check that whether modify related register of BB or not 
 goto _mismatch; 
 Checking for channel 
 In 5G, some ap do not have DSSET IE checking HT info for channel 
 we don't find channel IE, so don't check it 
 checking SSID 
 not hidden ssid 
 check encryption info 
 HT info 
 HT_info_handler(padapter, pIE); 
 rate adaptive 
  Update RRSR and Rate for USERATE 
 	Added by Albert 20110322 
 	In the P2P mode, the driver should not support the b mode. 
 	So, the Tx packet shouldn't use the CCK rate 
 disable high power 
 rtw_write16(padapter, 0x4cc, 0xffff); 
 rtw_write16(padapter, 0x546, 0x01c0); 
 disable high power 
  Check preamble mode, 2005.01.06, by rcnjko. 
  Mark to update preamble value forever, 2008.03.18 by lanhsin 
  Short Preamble 
  PREAMBLE_LONG or PREAMBLE_AUTO 
  Long Preamble 
  PREAMBLE_SHORT or PREAMBLE_AUTO 
 Filen: See 802.11-2007 p.91 
 Filen: See 802.11-2007 p.90 
  Short Slot Time 
  Long Slot Time 
 B Mode 
 0x0808 -> for CCK, 0x0a0a -> for OFDM 
 change this value if having IOT issues. 
  Only B, BG, and BGN AP could use CCK rate 
  clear global value 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
 look up sta asoc_queue 
 P2P device address 
 P2P interface address 
 u16)(pcur) = cpu_to_be16(psta->config_methods); 
 u16)(pcur) = cpu_to_be16(WPS_ATTR_DEVICE_NAME); 
 u16)(pcur) = cpu_to_be16(psta->dev_name_len); 
 pstart += tmplen; 
 P2P action frame 
 update attribute 
 Build P2P action frame header 
 there is no IE in this P2P action frame 
 update attribute 
 Build P2P public action frame header 
 Build P2P IE 
	P2P OUI 
	WFA P2P v1.0 
  P2P_ATTR_STATUS 
	The Dialog Token of provisioning discovery request frame. 
 update attribute 
	WPS OUI 
	Config Method 
	Type: 
	Length: 
	Value: 
 P2P action frame 
 update attribute 
 Build P2P action frame header 
 Add P2P IE header 
	P2P OUI 
	WFA P2P v1.0 
 Add Status attribute in P2P IE 
 Add NoA attribute in P2P IE 
 index 
 CTWindow and OppPS Parameters 
 todo: Notice of Absence Descriptor(s) 
	P2P OUI 
	WFA P2P v1.0 
	According to the P2P Specification, the beacon frame should contain 3 P2P attributes 
	1. P2P Capability 
	2. P2P Device ID 
	3. Notice of Absence (NOA) 
	P2P Capability ATTR 
	Type: 
	Length: 
	Value: 
	Device Capability Bitmap, 1 byte 
	Be able to participate in additional P2P Groups and 
	support the P2P Invitation Procedure 
	Group Capability Bitmap, 1 byte 
  P2P Device ID ATTR 
  Notice of Absence ATTR 
	Type: 
	Length: 
	Value: 
	P2P OUI 
	WFA P2P v1.0 
	Commented by Albert 20100907 
	According to the P2P Specification, the probe response frame should contain 5 P2P attributes 
	1. P2P Capability 
	2. Extended Listen Timing 
	3. Notice of Absence (NOA)	(Only GO needs this) 
	4. Device Info 
	5. Group Info	(Only GO need this) 
	P2P Capability ATTR 
	Type: 
	Length: 
 u16) (p2pie + p2pielen) = cpu_to_le16(0x0002); 
	Value: 
	Device Capability Bitmap, 1 byte 
	Group Capability Bitmap, 1 byte 
	Group Capability Bitmap, 1 byte 
	Extended Listen Timing ATTR 
	Type: 
	Length: 
 u16) (p2pie + p2pielen) = cpu_to_le16(0x0004); 
	Value: 
	Availability Period 
 u16) (p2pie + p2pielen) = cpu_to_le16(0xFFFF); 
	Availability Interval 
 u16) (p2pie + p2pielen) = cpu_to_le16(0xFFFF); 
  Notice of Absence ATTR 
	Type: 
	Length: 
	Value: 
	Device Info ATTR 
	Type: 
	Length: 
	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) 
	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) 
 u16) (p2pie + p2pielen) = cpu_to_le16(21 + pwdinfo->device_name_len); 
	Value: 
	P2P Device Address 
	Config Method 
	This field should be big endian. Noted by P2P specification. 
 u16) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->supported_wps_cm); 
	Primary Device Type 
	Category ID 
 u16) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA); 
	OUI 
 u32) (p2pie + p2pielen) = cpu_to_be32(WPSOUI); 
	Sub Category ID 
 u16) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER); 
	Number of Secondary Device Types 
	No Secondary Device Type List 
	Device Name 
	Type: 
 u16) (p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME); 
	Length: 
 u16) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len); 
	Value: 
  Group Info ATTR 
	Type: 
	Length: 
	Value: 
	P2P OUI 
	WFA P2P v1.0 
	Commented by Albert 20110301 
	According to the P2P Specification, the provision discovery request frame should contain 3 P2P attributes 
	1. P2P Capability 
	2. Device Info 
	3. Group ID (When joining an operating P2P Group) 
	P2P Capability ATTR 
	Type: 
	Length: 
 u16) (p2pie + p2pielen) = cpu_to_le16(0x0002); 
	Value: 
	Device Capability Bitmap, 1 byte 
	Group Capability Bitmap, 1 byte 
	Device Info ATTR 
	Type: 
	Length: 
	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) 
	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) 
 u16) (p2pie + p2pielen) = cpu_to_le16(21 + pwdinfo->device_name_len); 
	Value: 
	P2P Device Address 
	Config Method 
	This field should be big endian. Noted by P2P specification. 
 u16) (p2pie + p2pielen) = cpu_to_be16(WPS_CONFIG_METHOD_PBC); 
 u16) (p2pie + p2pielen) = cpu_to_be16(WPS_CONFIG_METHOD_DISPLAY); 
	Primary Device Type 
	Category ID 
 u16) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA); 
	OUI 
 u32) (p2pie + p2pielen) = cpu_to_be32(WPSOUI); 
	Sub Category ID 
 u16) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER); 
	Number of Secondary Device Types 
	No Secondary Device Type List 
	Device Name 
	Type: 
 u16) (p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME); 
	Length: 
 u16) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len); 
	Value: 
	Added by Albert 20110519 
	In this case, the pdev_raddr is the device address of the group owner. 
	P2P Group ID ATTR 
	Type: 
	Length: 
 u16) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN + ussidlen); 
	Value: 
	P2P OUI 
	WFA P2P v1.0 
  According to the P2P Specification, the Association response frame should contain 2 P2P attributes 
	1. Status 
	2. Extended Listen Timing (optional) 
	Status ATTR 
  Extended Listen Timing ATTR 
	Type: 
	Length: 
	Value: 
	There is no OFDM rate included in SupportedRates IE of this probe request frame 
	The driver should response this probe request. 
	rate_cnt > 4 means the SupportRates IE contains the OFDM rate because the count of CCK rates are 4. 
	We should proceed the following check for this probe request. 
	Added comments by Albert 20100906 
	There are several items we should check here. 
	1. This probe request frame must contain the P2P IE. (Done) 
	2. This probe request frame must contain the wildcard SSID. (Done) 
	3. Wildcard BSSID. (Todo) 
	4. Destination Address. (Done in mgt_dispatcher function) 
	5. Requested Device Type in WSC IE. (Todo) 
	6. Device ID attribute in P2P IE. (Todo) 
	Just last 1 byte is valid for ssid len of the probe request 
 todo: 
 Check Requested Device Type attributes in WSC IE. 
 Check Device ID attribute in P2P IE 
 non -p2p device 
  WIFI_REASSOCREQ 
 Check P2P Capability ATTR 
 Check Extended Listen Timing ATTR 
 Check P2P Device Info ATTR 
 P2P Device Address 
 Config Methods 
 Get the next P2P IE 
 look up sta asoc_queue 
 issue GO Discoverability Request 
 issue Device Discoverability Response 
	Commented by Kurt 20120113 
	If some device wants to do p2p handshake without sending prov_disc_req 
	We have to get peer_req_cm from here. 
	include both intent and tie breaker values. 
	Try to match the tie breaker value 
	Store the group id information. 
						
						 	Change our operating channel as peer's for compatibility.
  Take first channel of ch_list_inclusioned as operating channel 
 Get the next P2P IE 
	Be able to know which one is the P2P GO and which one is P2P client. 
	Found the P2P IE. 
	Do nothing. 
	Try to get the peer's interface address 
	Try to get the peer's intent and tie breaker value. 
	include both intent and tie breaker values. 
	Try to match the tie breaker value 
	Store the group id information. 
	Try to get the operation channel information 
	Try to get the channel list information 
							
							 	Change our operating channel as peer's for compatibility.
  Take first channel of ch_list_inclusioned as operating channel 
	Try to get the group id information if peer is GO 
 Get the next P2P IE 
	Found the P2P IE. 
	Commented by Albert 20100911 
	Todo: Need to handle the case which both Intents are the same. 
	Have to compare the Tie Breaker 
	Try to get the group id information 
 Get the next P2P IE 
 todo: check NoA attribute 
	In the P2P client mode, the driver should not switch back to its listen channel 
	because this P2P client should stay at the operating channel of P2P GO. 
  NoA length should be n(13) + 2 
  Get Notice of Absence IE. 
  if index change, driver should reconfigure related setting. 
  NoA length should be n(13) + 2 
 memcpy(&wifidirect_info->noa_count[noa_num], &noa_attr[noa_offset], 1); 
  driver should wait LPS for entering CTWindow 
  find target, just break. 
 Get the next P2P IE 
  Pre action for p2p state 
	Reset the operation channel information 
	Reset the operation channel information 
	the provision discovery request frame is trigger to send or not 
 issue_probereq_p2p(adapter, NULL); 
 _set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT); 
init device&interface address 
	1, 6, 11 are the social channel defined in the WiFi Direct specification. 
	channel 0 for scanning ending in site survey function. 
	Use the channel 11 as the listen channel 
	Use the OFDM rate in the P2P probe response frame. (6(B), 9(B), 12, 18, 24, 36, 48, 54) 
	6(B) 
	9(B) 
	12 
	18 
	24 
	36 
	48 
	54 
	Token used for P2P invitation request frame. 
	Used to indicate the scan end in site survey function 
	Used to indicate the scan end in site survey function 
 leave IPSAutosuspend 
	Added by Albert 20110322 
	In the P2P mode, the driver should not support the b mode. 
	So, the Tx packet shouldn't use the CCK rate 
 Enable P2P function 
 Disable P2P function 
 Restore to initial setting. 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2012 Realtek Corporation. 
Caller and the rtw_cmd_thread can protect cmd_q by spin_lock.
No irqsave is necessary.
 sema_init(&(pcmdpriv->cmd_done_sema), 0); 
 allocate DMA-ableNon-Page memory for cmd_buf and rsp_buf 
 allocate DMA-ableNon-Page memory for cmd_buf and rsp_buf 
Calling Context:
rtw_enqueue_cmd can only be called between kernel thread,
since only spin_lock is used.
ISRCall-Back functions can't call this sub-function.
 set to true to allow enqueuing cmd when hw_init_completed is false 
 com_thread not running 
 free parmbuf in cmd_obj 
 free rsp in cmd_obj 
 free cmd_obj 
 _RND4 
 call callback function for post-processed 
 todo: !!! fill rsp_buf to pcmd->rsp if (pcmd->rsp!= NULL) 
 need conider that free cmd_obj in rtw_cmd_callback 
  free all cmd_obj resources 
 DBG_88E("%s: leaving... drop cmdcode:%u\n", __func__, pcmd->cmdcode); 
rtw_sitesurvey_cmd(~)
	### NOTE:#### (!!!!)
	MUST TAKE CARE THAT BEFORE CALLING THIS FUNC, YOU SHOULD HAVE LOCKED pmlmepriv->lock
 psurveyPara->bsslimit = 48; 
 prepare ssid list 
 prepare channel list 
  302 sec = 60sec 
 for IEs is fix buf size 
 for hidden ap to set fw_state here 
  Added by Albert 20090218 
  If the the driver wants to use the bssid to create the connection. 
  If not,  we have to copy the connecting AP's MAC address to it so that 
  the driver just has the bssid information for PMKIDList searching. 
 There is WMM IE in this corresp. beacon 
 There is no WMM IE in this corresp. beacon 
 	Added by Albert 20100623 
 	For the WEP mode, we will use the bg mode to do the connection to avoid some IOT issue. 
 	Especially for Realtek 8192u SoftAP. 
 rtw_restructure_ht_ie 
 get cmdsz before endian conversion 
 GEN_CMD_CODE(_JoinBss) 
 for sta_mode 
 prepare cmd parameter 
 need enqueue, prepare cmd_obj and enqueue 
 no need to enqueue, do the cmd hdl directly and free cmd parameter 
 jeff: set this because at least sw key is ready 
 DBG_88E("rtw_addbareq_cmd, tid =%d\n", tid); 
 rtw_enqueue_cmd(pcmdpriv, ph2c); 
 rtw_enqueue_cmd(pcmdpriv, ph2c); 
 check input parameter 
 prepare cmd parameter 
 need enqueue, prepare cmd_obj and enqueue 
 no need to enqueue, do the cmd hdl directly and free cmd parameter 
 do something based on res... 
  Determine if our traffic is busy now 
  Higher TxRx data. 
  check traffic for  powersaving. 
  LeisurePS only work in infra mode. 
 connect 
 connect 
  Reset LPS Setting 
 disconnect 
 DBG_88E("LPS_CTRL_SPECIAL_PACKET\n"); 
 struct pwrctrl_priv pwrctrlpriv = &padapter->pwrctrlpriv; 
 if (!pwrctrlpriv->bLeisurePs) 
 	return res; 
 	As the command tppe. 
 	Must be NULL here 
 while ((rtw_read32(padapter, 0x414)&0x00ffff00)!= 0) 
 while ((rtw_read32(padapter, 0x414)&0x0000ff00)!= 0) 
 re check again 
 This C2H event is read, clear it 
 This C2H event is not read, read & clear now 
 Special pointer to trigger c2h_evt_clear only 
 Enqueue into cmd_thread for others 
 	Commented by Albert 20110701 
 	I used the type_size as the type command 
 TODO: cancel timer and do timeout handler directly... 
 need to make timeout handlerOS independent 
  free cmd 
 clear bridge database 
  free cmd 
 TODO: cancel timer and do timeout handler directly... 
 need to make timeout handlerOS independent 
  we will set _FW_LINKED when there is one more sat to join us (rtw_stassoc_event_callback) 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2012 Realtek Corporation. 
  Current LED state. 
  true if LED is ON, false if LED is OFF. 
  true if it is blinking, false o.w.. 
  Number of times to toggle led state for blinking. 
  Next state for blinking, either RTW_LED_ON or RTW_LED_OFF are. 
  Change LED according to BlinkingLedState specified. 
 WPS success 
 wait until xinpin finish 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
------------------------Define local variable------------------------------
------------------------Define local variable------------------------------
  E-Fuse Control. 
  11162008 MH Add description. Get current efuse area enabled word!!. 
  0 : write enable 
 	Description: 
 		Execute E-Fuse read byte operation. 
 		Referred from SD1 Richard. 
 	Assumption: 
 		1. Boot from E-Fuse and successfully auto-load. 
 		2. PASSIVE_LEVEL (USB interface) 
 	Created by Roger, 2008.10.21. 
 Write Address 
 Write bit 32 0 
 Check bit 32 read-ready 
  20100205 Joseph: Add delay suggested by SD1 Victor. 
  This fix the problem that Efuse read error in high temperature condition. 
  Designer says that there shall be some delay after ready bit is set, or the 
  result will always stay on last data we read. 
  11162008 MH Read one byte from real Efuse. 
  -----------------e-fuse reg ctrl --------------------------------- 
 address 
 read cmd 
  11162008 MH Write one byte to reald Efuse. 
  -----------------e-fuse reg ctrl --------------------------------- 
 address 
 data 
 write cmd 
-----------------------------------------------------------------------------
  Function:	efuse_WordEnableDataRead
  Overview:	Read allowed word in current efuse section data.
  Input:       NONE
  Output:      NONE
  Return:      NONE
  Revised History:
  When			Who		Remark
  11162008	MHC		Create Version 0.
  11212008	MHC		Fix Write bug when we only enable late word.
-----------------------------------------------------------------------------
  Function:	Efuse_ReadAllMap
  Overview:	Read All Efuse content
  Input:       NONE
  Output:      NONE
  Return:      NONE
  Revised History:
  When			Who		Remark
  11112008	MHC		Create Version 0.
-----------------------------------------------------------------------------
  Function:	EFUSE_ShadowMapUpdate
  Overview:	Transfer current EFUSE content to shadow init and modify map.
  Input:       NONE
  Output:      NONE
  Return:      NONE
  Revised History:
  When			Who		Remark
  11132008	MHC		Create Version 0.
  EFUSE_ShadowMapUpdate 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2012 Realtek Corporation. 
 for ACL 
 free_assoc_sta_resources 
 free bcmc sta_info 
 update TIM IE 
 append TIM IE from dst_ie offset 
 calculate head_len 
  get supported rates len 
 DS Parameter Set IE, len = 3 
 append TIM IE from offset 
 DTIM count 
 DTIM period 
 for bcmc frames 
 bitmap ctrl 
 copy remainder IE 
 check auth_queue 
 check asoc_queue 
 to check if alive by another methods if station is at ps mode. 
 to update bcn with tim_bitmap for this station 
 TODO: Aging mechanism to digest frames in sleep_q to avoid running out of xmitframe 
 switch to correct channel of current network  before issue keep-alive frames 
 issue null data to check sta alive
 back to the original operation channel 
 bg mode ra_bitmap 
 n mode ra_bitmap 
  2R 
   1R 
 max short GI rate 
 support entry 2~31 
 bitmap[0:27] = tx_rate_bitmap 
 bitmap[28:31]= Rate Adaptive id 
 arg[0:4] = macid 
 arg[5] = Short GI 
 set ra_id, init_rate 
 default set to 0 
 prepare for add_RATid 
 bg mode ra_bitmap 
 force to b mode 
 ap mode 
 bitmap[0:27] = tx_rate_bitmap 
 bitmap[28:31]= Rate Adaptive id 
 arg[0:4] = macid 
 arg[5] = Short GI 
 set ra_id, init_rate 
 notes: 
 AID: 1~MAX for sta and 0 for bcmc in apadhoc mode 
 MAC_ID = AID+1 for sta in apadhoc mode 
 MAC_ID = 1 for bcmc for staapadhoc 
 MAC_ID = 0 for bssid for staapadhoc 
 CAM_ID = 0~3 for default key, cmd_id = macid + 3, macid = aid+1; 
 ap mode 
 update sta's cap 
 ERP 
 HT related cap 
 check if sta supports rx ampdu 
 check if sta support s Short GI 
  bwmode 
 Rx AMPDU 
  recipient 
 TX AMPDU 
 originator 
 reset 
 reset 
 todo: init other variables 
 parsing ERP_IE 
 to get ie data len 
 update IELength 
 8: TimeStamp, 2: Beacon Interval 2:Capability 
op_mode
Set to 0 (HT pure) under the following conditions
	- all STAs in the BSS are 2040 MHz HT in 2040 MHz BSS or
	- all STAs in the BSS are 20 MHz HT in 20 MHz BSS
Set to 1 (HT non-member protection) if there may be non-HT STAs
	in both the primary and the secondary channel
Set to 2 if only HT STAs are associated in BSS,
	however and at least one 20 MHz HT STA is associated
Set to 3 (HT mixed mode) when one or more non-HT STAs are associated
	(currently non-GF HT station is considered as non-HT STA also)
	 Note: currently we switch to the MIXED op mode if HT non-greenfield
	  station is associated. Probably it's a theoretical case, since
	  it looks like all known HT STAs support greenfield.
 update associcated stations cap. 
 check asoc_queue 
 called > TSR LEVEL for USB or SDIO Interface
 update associcated stations cap. 
 update associcated stations cap. 
 tear down Rx AMPDU 
  recipient 
 tear down TX AMPDU 
  originator 
 reset 
 reset 
 clear cam entry  key 
 free sta asoc_queue 
 called > TSR LEVEL for USB or SDIO Interface
 update wmm cap. 
 update 802.11n ht cap. 
 for ACL 
 reset and init security priv , this can refine with rtw_reset_securitypriv 
 for ACL 
 free_assoc_sta_resources 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2012 Realtek Corporation. 
 when set_ssidset_bssid for rtw_do_join(), but scanning queue is empty 
 we try to issue sitesurvey firstly 
  submit site_survey_cmd 
  submit createbss_cmd to change to a ADHOC_MASTER 
 pmlmepriv->lock has been acquired by caller... 
  can't associate ; reset under-linking 
 when set_ssidset_bssid for rtw_do_join(), but there are no desired bss in scanning queue 
 we try to issue sitesurvey firstly 
 it means driver is in WIFI_ADHOC_MASTER_STATE, we needn't create bss again. 
 should we add something here...? 
 if in WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE, create bss or rejoin again 
 it means driver is in WIFI_ADHOC_MASTER_STATE, we needn't create bss again. 
 DBG_88E("change mode, old_mode =%d, new_mode =%d, fw_state = 0x%x\n", pold_state, networktype, get_fwstate(pmlmepriv)); 
 change to other mode from Ndis802_11APMode 
 will clr Linked_state; before this function, we must have chked whether  issue dis-assoc_cmd or not 
  Scan or linking is in progress, do nothing. 
 rtw_get_cur_max_rate -
 @adapter: pointer to struct adapter structure
 Return 0 or 100Kbps
 cur_bwmod is updated by beacon, pmlmeinfo is updated by association response 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
 WEP related ===== 
	Need to consider the fragment  situation
  exclude ICV 
 wepkey 
 start to encrypt each fragment 
 the last fragment 
  exclude ICV 
 start to decrypt recvframe 
 decrypt payload include icv 
 3		===== TKIP related ===== 
  Convert from Byte[] to Us3232 in a portable way 
  Convert from Us3232 to Byte[] in a portable way 
  Reset the state to the empty message. 
  Set the key 
  and reset the message 
  Append the byte to our word-sized buffer 
  Process the word if it is full. 
  Clear the buffer 
  This is simple 
  Append the minimum padding 
  and then zeroes until the length is a multiple of 4 
  The appendByte function has already computed the result. 
  Reset to the empty message. 
 Michael MIC pseudo header: DA, SA, 3 x 0, Priority 
 ToDS == 1 
 DA 
 From Ds == 1 
 ToDS == 0 
 DA 
 From Ds == 1 
 macros for extractioncreation of unsigned charunsigned short values  
 select the Nth 16-bit word of the temporal key unsigned char array TK[]   
 S-box lookup: 16 bits --> 16 bits 
 fixed algorithm "parameters" 
 this needs to be "big enough"     
  48-bit transmitter address       
 128-bit temporal key	      
  80-bit Phase1 key		
 128-bit RC4KEY (104 bits unknown) 
 2-unsigned char by 2-unsigned char subset of the full AES S-box table 
 Sbox for hash (can be in ROM)     
 second half of table is unsigned char-reversed version of first! 
 Routine: Phase 1 -- generate P1K, given TA, TK, IV32
 Inputs:
     tk[]      = temporal key			 [128 bits]
     ta[]      = transmitter's MAC address	    [ 48 bits]
     iv32      = upper 32 bits of IV		  [ 32 bits]
 Output:
     p1k[]     = Phase 1 key			  [ 80 bits]
 Note:
     This function only needs to be called every 216 packets,
     although in theory it could be called every packet.
 Initialize the 80 bits of P1K[] from IV32 and TA[0..5]     
 use TA[] as little-endian 
 Now compute an unbalanced Feistel cipher with 80-bit block 
 size on the 80-bit block P1K[], using the 128-bit key TK[] 
 Each add operation here is mod 216 
 avoid "slide attacks" 
 Routine: Phase 2 -- generate RC4KEY, given TK, P1K, IV16
 Inputs:
     tk[]      = Temporal key			 [128 bits]
     p1k[]     = Phase 1 output key		   [ 80 bits]
     iv16      = low 16 bits of IV counter	    [ 16 bits]
 Output:
     rc4key[]  = the key used to encrypt the packet   [128 bits]
 Note:
     The value {TA, IV32, IV16} for Phase1Phase2 must be unique
     across all packets using the same key TK value. Then, for a
     given value of TK[], this TKIP48 construction guarantees that
     the final RC4KEY value is unique across all packets.
 Suggested implementation optimization: if PPK[] is "overlaid"
     appropriately on RC4KEY[], there is no need for the final
     for loop below that copies the PPK[] result into RC4KEY[].
 temporary key for mixing    
 Note: all adds in the PPK[] equations below are mod 216	 
 first, copy P1K to PPK      
 next,  add in IV16	  
 Bijective non-linear mixing of the 96 bits of PPK[0..5]	   
 Mix key in each "round"     
 Total # S-box lookups == 6  
 Final sweep: bijective, "linear". Rotates kill LSB correlations   
 Use all of TK[] in Phase2   
 Note: At this point, for a given key TK[0..15], the 96-bit output 
       value PPK[0..5] is guaranteed to be unique, as a function   
       of the 96-bit "input" value   {TA, IV32, IV16}. That is, P1K  
       is now a keyed permutation of {TA, IV32, IV16}.	       
 Set RC4KEY[0..3], which includes "cleartext" portion of RC4 key   
 RC4KEY[0..2] is the WEP IV  
 Help avoid weak (FMS) keys  
 Copy 96 bits of PPK[0..5] to RC4KEY[4..15]  (little-endian)       
 The hlen isn't include the IV 
  exclude ICV 
 4 start to encrypt each fragment 
 4 the last fragment 
 The hlen isn't include the IV 
  exclude ICV 
 4 start to decrypt recvframe 
 4 decrypt payload include icv 
 3			===== AES related ===== 
 SBOX Table 
 Function Prototypes 
 aes128k128d()			
 Performs a 128 bit AES encrypt with  
 128 bit data.			
 Swap halves 
 Rotate left 8 bits 
 logical shift left 1 bit 
 Rotate right 8 bits 
 1 - 9 
 construct_mic_iv()			   
 Builds the MIC IV from header fields and PN  
 QoS_TC	   
 mute bits 7-4    
 mic_iv[2:7] = A2[0:5] = mpdu[10:15] 
 mic_iv[8:13] = PN[5:0] 
 construct_mic_header1()		      
 Builds the first MIC header block from       
 header fields.			       
 Mute CF poll & CF ack bits 
 Mute retry, more data and pwr mgt bits 
 A1 
 A2 
 construct_mic_header2()		      
 Builds the last MIC header block from	
 header fields.			       
 A3 
 mpdu[23]; 
 A4 
 mute bits 15 - 4 
 A4 
 construct_mic_header2()		      
 Builds the last MIC header block from	
 header fields.			       
 flag 
 QoC_Control 
 ctr_preload[2:7] = A2[0:5] = mpdu[10:15] 
 ctr_preload[8:13] = PN[5:0] 
 Ctr 
 bitwise_xor()		    
 A 128 bit, bitwise exclusive or  
 Intermediate Buffers 
 Find start of payload 
 Calculate MIC 
 bitwise_xor(aes_out, &message[payload_index], chain_buffer); 
 Add on the final payload block if it needs padding 
 padded_buffer[j] = message[payload_index++]; 
 Insert MIC into payload 
 message[payload_index+j] = mic[j]; 
 If there is a short final block, then pad it,
 encrypt it and copy the unpadded part back   
 Encrypt the MIC 
  exclude ICV 
static
	unsigned char	message[MAX_MSG_SIZE]; 
 Intermediate Buffers 
  payload,iv 
	uint	offset = 0; 
 4 start to encrypt each fragment 
 4 the last fragment 
 Intermediate Buffers 
	uint	offset = 0; 
 start to decrypt the payload 
 plen including llc, payload_length and mic) 
  now, decrypt pframe with hdrlen offset and plen long 
  8 is for extiv 
 If there is a short final block, then pad it,
 encrypt it and copy the unpadded part back   
 start to calculate the mic 
 8 is for ext iv len 
 Find start of payload 
 Calculate MIC 
 Add on the final payload block if it needs padding 
 Insert MIC into payload 
 If there is a short final block, then pad it,
 encrypt it and copy the unpadded part back   
 Encrypt the MIC 
 compare the mic 
  exclude ICV 
 Intermediate Buffers 
  payload,iv 
 4 start to encrypt each fragment 
 in concurrent we should use sw descrypt in group key, so we remove this message 
 AES tables
 for 128-bit blocks, Rijndael never uses more than 10 rcon values 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
 Beacon 
 check if the io_buf can accommodate new cmds 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2012 Realtek Corporation. 
  combo scan 
	User is doing the P2P device discovery 
	The prefix of SSID should be "DIRECT-" and the IE should contains the P2P IE. 
	If not, the driver should ignore this AP and go to the next AP. 
	Verifying the SSID 
  Probe Request 
	Verifying the P2P IE 
  Beacon or Probe Respones 
	Verifying the P2P IE 
  AP MAC address  
 Add the ESSID 
 parsing HT_CAP_IE 
 Add the protocol name 
 Add mode 
 Add frequencychannel 
 Add encryption capability 
Add basic and extended rates 
 MCS15 
 MCS7 
 default MCS7 
 Mbps2; 
 parsing WPAWPA2 IE 
 parsing WPS IE 
 goto next 
 Add quality statistics 
  signal quality 
  noise level 
  802_1x 
 sta mode 
 pairwise key 
 set mic key 
 group key 
 Jeff: don't disable ieee8021x_blocked while clearing key 
 dump 
 set wps_ie 
 goto next 
 parsing HT_CAP_IE 
 wrqu->freq.m = ieee80211_wlan_frequencies[pcur_bss->Configuration.DSConfig-1]  100000; 
 overwrite PMKID 
  BSSID is matched, the same AP => rewrite with new PMKID. 
  Find a new entry 
  BSSID is matched, the same AP => Remove this PMKID information and reset it. 
 no auto select 
	 Let's try to keep this struct in the same order as in
	  linuxincludewireless.h
	 TODO: See what values we can set, and remove the ones we can't
	  set, or fill them with some default data.
 ~5 Mbs real (802.11b) 
 signal level threshold range 
 percent values between 0 and 100. 
 Updated all three 
 > 8% missed beacons is 'bad' 
 TODO: Find real 'good' to 'bad' threshol value for RSSI 
 -78 dBm 
 Updated all three 
  Include only legal frequencies for some countries 
  The following code will proivde the security capability to network manager. 
  If the driver doesn't provide this capability to network manager, 
  the WPAWPA2 routers can't be chosen in the network manager. 
#define IW_SCAN_CAPA_NONE		0x00
#define IW_SCAN_CAPA_ESSID		0x01
#define IW_SCAN_CAPA_BSSID		0x02
#define IW_SCAN_CAPA_CHANNEL		0x04
#define IW_SCAN_CAPA_MODE		0x08
#define IW_SCAN_CAPA_RATE		0x10
#define IW_SCAN_CAPA_TYPE		0x20
#define IW_SCAN_CAPA_TIME		0x40
 set bssid flow 
 s1. rtw_set_802_11_infrastructure_mode() 
 s2. rtw_set_802_11_authentication_mode() 
 s3. set_802_11_encryption_mode() 
 s4. rtw_set_802_11_bssid() 
 set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus); 
  When Busy Traffic, driver do not site survey. So driver return success. 
  wpa_supplicant will not issue SIOCSIWSCAN cmd again after scan timeout. 
  modify by thomas 2011-02-22. 
	For the DMP WiFi Display project, the driver won't to scan because 
	the pmlmepriv->scan_interval is always equal to 3. 
	So, the wpa_supplicant won't find out the WPS SoftAP. 
  stop parsing 
 it has still some scan parameter to parse, we only do this now... 
	P2P is enabled 
	P2P is disabled 
 report network only if the current channel set contains the channel to which this network belongs 
 set ssid flow 
 s1. rtw_set_802_11_infrastructure_mode() 
 s2. set_802_11_authenticaion_mode() 
 s3. set_802_11_encryption_mode() 
 s4. rtw_set_802_11_ssid() 
 no auto select 
 no auto select 
 wrqu->rts.disabled = (wrqu->rts.value == DEFAULT_RTS_THRESHOLD); 
 no auto select 
 no auto select 
 open system 
 set authentication mode 
 Ndis802_11EncryptionDisabled; 
 Ndis802_11EncryptionDisabled; 
 open system 
  set key_id only, no given KeyMaterial(erq->length == 0). 
 no auto select 
		
		   ??? does not use these parameters
  wpa_supplicant is enabling the tkip countermeasure. 
  wpa_supplicant is disabling the tkip countermeasure. 
		 HACK:
		 
		  wpa_supplicant calls set_wpa_enabled when the driver
		  is loaded and unloaded, regardless of if WPA is being
		  used.  No other calls are made which can be used to
		  determine if encryption will be used or not prior to
		  association being expected.  If encryption is not being
		  used, drop_unencrypted is set to false, else true -- we
		  can use this to determine if the CAP_PRIVACY_ON bit should
		  be set.
 it means init value, or using wep, ndisencryptstatus = Ndis802_11Encryption1Enabled, 
  then it needn't reset it; 
 open system 
		
		   It's the starting point of a link layer connection using wpa_supplicant
 todo: remove key 
 remove = 1; 
	 cliW: WEP does not have group key
	  just not checking GROUP key setting
 dump debug info here 
	
	  IMPORTANT!!
	  Only when wireless private ioctl is at odd order,
	  "extra" would be copied to user space.
 	For all data larger than 16 octets, we need to use a
 	pointer to memory allocated in user space.
 BSSID match, then check if supporting wpawpa2 
  WPS Start 
  WPS Stop because of wps success 
  WPS Stop because of wps fail 
 set channelbandwidth 
	Stay at the listen state and wait for discovery. 
	Listen channel number 
	Commented by Albert 20110524 
	This function is used to set the operating channel if the driver will become the group owner 
	Operating channel number 
	Comment by Albert 20101013 
	Input data format: 
	Ex:  0 
	Ex:  1XX:XX:XX:XX:XX:XXYYSSID 
	0 => Reflush the profile record list. 
	1 => Add the profile list 
	XX:XX:XX:XX:XX:XX => peer's MAC Address (ex: 00:E0:4C:00:00:01) 
	YY => SSID Length 
	SSID => SSID for persistence group 
	The upper application should pass the SSID to driver by using this rtw_p2p_profilefound function. 
	Remove all the profile information of wifidirect_info structure. 
	Add this profile information into pwdinfo->profileinfo 
	Ex:  1XX:XX:XX:XX:XX:XXYYSSID 
	Commented by Albert 20101012 
	Because of the output size limitation, I had removed the "Role" information. 
	About the "Role" information, we will use the new private IOCTL to get the "Role" information. 
	Commented by Albert 20110520 
	This function will return the config method description 
	This config method description will show us which config method the remote P2P device is intended to use 
	by sending the provisioning discovery request frame. 
 6 is the string "wpsCM =", 17 is the MAC addr, we have to clear it at wrqu->data.pointer 
	Commented by Albert 20110727 
	The input data is the MAC address which the application wants to know its WPS config method. 
	After knowing its WPS config method, the application can decide the config method for provisioning discovery. 
	Format: iwpriv wlanx p2p_get_wpsCM 00:E0:4C:00:00:05 
  The mac address is matched. 
  +10 is for the str "go_devadd =", we have to clear it at wrqu->data.pointer 
	Commented by Albert 20121209 
	The input data is the GO's interface address which the application wants to know its device address. 
	Format: iwpriv wlanx p2p_get2 go_devadd = 00:E0:4C:00:00:05 
	Commented by Albert 20110518 
	Match the device address located in the P2P IE 
	This is for the case that the P2P device address is not the same as the P2P interface address. 
	The P2P Device ID attribute is included in the Beacon frame. 
	The P2P Device Info attribute is included in the probe response frame. 
	Handle the P2P Device ID attribute of Beacon first 
	Handle the P2P Device Info attribute of probe response 
 Get the next P2P IE 
  +9 is for the str "dev_type =", we have to clear it at wrqu->data.pointer 
	Commented by Albert 20121209 
	The input data is the MAC address which the application wants to know its device type. 
	Such user interface could know the device type. 
	Format: iwpriv wlanx p2p_get2 dev_type = 00:E0:4C:00:00:05 
	The mac address is matched. 
  +5 is for the str "devN =", we have to clear it at wrqu->data.pointer 
	Commented by Albert 20121225 
	The input data is the MAC address which the application wants to know its device name. 
	Such user interface could show peer device's device name instead of ssid. 
	Format: iwpriv wlanx p2p_get2 devN = 00:E0:4C:00:00:05 
	The mac address is matched. 
  +8 is for the str "InvProc =", we have to clear it at wrqu->data.pointer 
	Commented by Ouden 20121226 
	The application wants to know P2P initiation procedure is supported or not. 
	Format: iwpriv wlanx p2p_get2 InvProc = 00:E0:4C:00:00:05 
	Commented by Albert 20121226 
	Match the device address located in the P2P IE 
	This is for the case that the P2P device address is not the same as the P2P interface address. 
	Handle the P2P capability attribute 
 Get the next P2P IE 
	Commented by Albert 20110304 
	The input data contains two informations. 
	1. First information is the MAC address which wants to formate with 
	2. Second information is the WPS PINCode or "pbc" string for push button method 
	Format: 00:E0:4C:00:00:05 
	Format: 00:E0:4C:00:00:05 
	Restore to the listen state if the current p2p state is not nego OK 
	The input data contains two informations. 
	1. First information is the P2P device address which you want to send to. 
	2. Second information is the group id which combines with GO's mac address, space and GO's ssid. 
	Command line sample: iwpriv wlan0 p2p_set invite ="00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy" 
	Format: 00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy 
	Reset the content of struct tx_invite_req_info 
	Commented by Albert 20110518 
	Match the device address located in the P2P IE 
	This is for the case that the P2P device address is not the same as the P2P interface address. 
	The P2P Device ID attribute is included in the Beacon frame. 
	The P2P Device Info attribute is included in the probe response frame. 
	Handle the P2P Device ID attribute of Beacon first 
	Handle the P2P Device Info attribute of probe response 
	Store the GO's bssid 
	Store the GO's ssid 
	The input data is 0 or 1 
	0: disable persistent group functionality 
	1: enable persistent group founctionality 
	Disable the persistent group function. 
	Enable the persistent group function. 
	The input data contains two informations. 
	1. First information is the MAC address which wants to issue the provisioning discovery request frame. 
	2. Second information is the WPS configuration method which wants to discovery 
	Format: 00:E0:4C:00:00:05_display 
	Format: 00:E0:4C:00:00:05_keypad 
	Format: 00:E0:4C:00:00:05_pbc 
	Format: 00:E0:4C:00:00:05_label 
	Reset the content of struct tx_provdisc_req_info excluded the wps_config_method_request. 
	Commented by Albert 20110518 
	Match the device address located in the P2P IE 
	This is for the case that the P2P device address is not the same as the P2P interface address. 
	The P2P Device ID attribute is included in the Beacon frame. 
	The P2P Device Info attribute is included in the probe response frame. 
	Handle the P2P Device ID attribute of Beacon first 
	Handle the P2P Device Info attribute of probe response 
 Get the next P2P IE 
	This function is used to inform the driver the user had specified the pin code value or pbc 
	to application. 
	Added by Albert 20110328 
	if the input data is P2P_NO_WPSINFO -> reset the wpsinfo 
	if the input data is P2P_GOT_WPSINFO_PEER_DISPLAY_PIN -> the utility just input the PIN code got from the peer P2P device. 
	if the input data is P2P_GOT_WPSINFO_SELF_DISPLAY_PIN -> the utility just got the PIN code from itself. 
	if the input data is P2P_GOT_WPSINFO_PBC -> the utility just determine to use the PBC 
	Commented by Albert 20110323 
	The wrqu->data.length will include the null character 
	So, we will decrease 7 + 1 
	Commented by Albert 20110524 
	The wrqu->data.length will include the null character 
	So, we will decrease (10 + 1) 
	Commented by Albert 20110524 
	The wrqu->data.length will include the null character 
	So, we will decrease (6 + 1) 
	Get the P2P device address when receiving the provision discovery request frame. 
	Get the P2P device address when receiving the P2P Invitation request frame. 
  free network queue for Android's timming issue 
  close led 
  the interface is being "disabled", we can do deeper IPS 
 read_reg 
 write_reg 
 read_bb 
 write_bb 
 read_rf 
 write_rf 
 normal mode, 
 dbg mode 
 IOL test 
 LLT table initialization test 
 blink LED test 
 continuous write byte test 
 continuous write word test 
 continuous write dword test 
			
			 dbg 0x79000000 [value], set RESP_TXAGC to + value, value:0~15
			 dbg 0x79010000 [value], set RESP_TXAGC to - value, value:0~15
 dump rxtx packet 
  driver version display 
 set rx_stbc 
  0: disable, bit(0):enable 2.4g, bit(1):enable 5g, 0x3: enable both 2.4g and 5g 
 default is set to enable 2.4GHZ for IOT issue with bufflao's AP at 5GHZ 
 set ampdu_enable 
  0: disable, 0x1:enable (but wifi_spec should be 0), 0x2: force enable (don't care wifi_spec) 
 get wifi_spec 
 registers dump, 0 for mac reg, 1 for bb reg, 2 for rf reg 
 turn onoff dynamic funcs 
						extra_arg = 0  - disable all dynamic func
						extra_arg = 1  - disable DIG
						extra_arg = 2  - disable tx power tracking
						extra_arg = 3  - turn on all dynamic func
 added for wps2.0 @20110524 
 set 
 get 
 0x00 
 0x01 
 0x02 
 0x03 
  for MM DTV platform 
 0x04 
 0x05 
 0x06 
 0x07 
 0x08 
 0x09 
  Set Channel depend on the country code 
 0x0A 
 0x0B 
 0x0C 
 0x0D 
 0x0E 
 0x0F 
 0x10 
 0x11 
 0x12 
 0x13 
 0x14 
 0x15 
 0x16 
 0x17 
 0x18 
 0x19 
 0x1A 
 0x1B 
  0x1C is reserved for hostapd 
  0x1D 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. i
 802.1x 
  We have to backup the PMK information for WiFi PMK Caching test item. 
  Backup the btkip_countermeasure information. 
  When the countermeasure is trigger, the driver have to disconnect with AP for 60 seconds. 
  Restore the PMK information to securitypriv structure for the following connection. 
 reset values in securitypriv 
 open system 
  Do it first for tx broadcast pkt after disconnection issue! 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2012 Realtek Corporation. 
 No free space for Tx, tx_worker is too slow 
 free sta asoc_queue 
 avoid   come from STA1 and send back STA1 
  Caller shall tx this multicast frame via normal way. 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
 DID_USB_v916_20130116 
=== Realtek demoboard ===
 8188EUS 
 8188ETV 
 8188FU 
=== Customer ID ===
 8188EUS 
 Abocom - Abocom 
 Sitecom N150 v2 
 DLink DWA-125 REV D1 
 Dlink DWA-123 REV D1 
 DLink GO-USB-N150 REV B1 
 D-Link DWA-121 rev B1 
 Elecom WDC-150SU2M 
 TP-Link TL-WN722N v2 
 TP-Link TL-WN727N v5.21 
 MERCUSYS MW150US v2 
 ASUS USB-N10 Nano B1 
 Edimax EW-7811Un V2 
 Terminating entry 
 3 misc 
 Modify condition for 92DU DMDP 2010.11.18, by Thomas 
				 If we didn't unplug usb dongle and
				  removeinsert module, driver fails
				  on sitesurvey for the first time when
				  device is up . Reset usb port for sitesurvey
 cancel in irp 
 cancel out irp 
 todo:cancel other irps 
 s3. 
 s4. 
 s5. 
 s1. 
 s2. 
 s2-2.  indicate disconnect to os 
 s2-3. 
 s2-4. 
  drv_init() - a device potentially for us
  notes: drv_init() is called when the bus driver has located
  a card for us to support.
         We accept the new device by returning 0.
 step 2. allocate HalData 
 step init_io_priv 
 step read_chip_version 
 step usb endpoint mapping 
 step read efuseeeprom data and get mac_addr 
 step 5. 
	 2012-07-11 Move here to prevent the 8723AS-VAU BT auto
  alloc dev name after read efuse. 
 step 6. Tell the network stack we exist 
 will call netdev_close() 
 Initialize dvobj_priv 
  dev_remove() - our device is being removed
 rmmod module & unplug(SurpriseRemoved) will call r871xu_dev_remove() => how to recognize both 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
 init os related resource in struct recv_priv 
 alloc os related resource in struct recv_frame 
 free os related resource in struct recv_frame 
 alloc os related resource in struct recv_buf 
 free os related resource in struct recv_buf 
  pointers to NULL before rtw_free_recvframe() 
 enqueue back to free_recv_queue 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2012 Realtek Corporation. 
 translate DMA FIFO addr to pipehandle 
  pxmitbuf->pbuf 
 context is pxmitbuf 
    We add the URB_ZERO_PACKET flag to urb so that the host will send the zero packet automatically. 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2011 Realtek Corporation. 
 0:Disable, 1:Enable, 
 module param defaults 
 RTL8712_AIR_TRX; 
 Ndis802_11Infrastructure; infra, ad-hoc, auto 
 ad-hoc support requirement 
 long, short, auto 
 active, passive 
  0:By SW 1:By HW. 
  default is set to enable the wmm. 
  0 :disable, bit(0): enable 2.4g, bit(1): enable 5g 
 for enable tx_ampdu 
  0: disable, bit(0):enable 2.4g, bit(1):enable 5g, default is set to enable 2.4GHZ for IOT issue with bufflao's AP at 5GHZ 
  0: disabled, 1:enabled, 2:auto 
 Use 2 path Tx to transmit MCS0~7 and legacy mode 
 auto 
  0:Reject AP's Add BA req, 1:Accept AP's Add BA req. 
  0:OFF , 1:ON, 2:decide by Efuse config 
 0:decide by efuse  1: for 88EE, 1Tx and 1RxCG are diversity.(2 Ant with SPDT), 2:  for 88EE, 1Tx and 2Rx are diversity.(2 Ant, Tx and RxCG are both on aux port, RxCS is on main port), 3: for 88EE, 1Tx and 1RxCG are fixed.(1Ant, Tx and RxCG are both on aux port) 
 0:disable, 1:enable, 2: by EFUSE config 
 HW power  ping detect 0:disable , 1:enable 
  temp mac address if users want to use instead of the mac address in Efuse 
  0:Disable, 1:enable, 2:by usb speed 
 UAPSD 
 0:disable, 1:enable, 2:by EFUSE config 
 0:disable, 1:enable 
 pxmitpriv->tx_pkts++; 
 precvpriv->rx_pkts++; 
  AC to queue mapping
  AC_VO -> queue 0
  AC_VI -> queue 1
  AC_BE -> queue 2
  AC_BK -> queue 3
 Given a data frame determine the 802.1p1d tag to use. 
	 skb->priority values from 256->263 are magic values to
	  directly indicate a specific 802.1d priority.  This is used
	  to allow 802.1d priority to be passed directly in from VLAN
	  tags, etc.
 3 second timeout 
 step 2. 
 wait for rtw_cmd_thread() to start running 
 Below is to termindate rtw_cmd_thread & event_thread... 
 wait for rtw_cmd_thread() to stop running 
 xmit_priv 
 mlme_priv 
  302 sec = 60sec 
 ht_priv 
 set to disabled 
 security_priv 
 open system 
 registry_priv 
 hal_priv 
 misc. 
 hal_priv 
  302 sec = 60sec 
 mlmeextpriv 
  cancel sw led timer 
 we can call rtw_p2p_enable here, but: 
  1. rtw_p2p_enable may have IO operation 
  2. rtw_p2p_enable is bundled with wext interface 
 will free bcmc_stainfo here 
 free the old_pnetdev 
  clear pbuddystruct adapter to avoid access wrong pointer. 
 s5. 
 s1. 
 s2. 
 s2-2.  indicate disconnect to os 
 s2-3. 
 s2-4. 
  Close LED 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2007 - 2012 Realtek Corporation. 
 Translate the OS dependent @param error_code to OS independent RTW_STATUS_CODE
 @return: one of RTW_STATUS_CODE
For the following list_xxx operations,
caller must guarantee the atomic context.
Otherwise, there will be racing condition.
Caller must check if the list is empty before calling rtw_list_delete
  the input parameter start use the same unit as jiffies 
 free the old_pnetdev 
 duplicate src 
 replace buf with dup 
 free ori 
  rtw_cbuf_empty - test if cbuf is empty
  @cbuf: pointer of struct rtw_cbuf
  Returns: true if cbuf is empty
  rtw_cbuf_pop - pop a pointer from cbuf
  @cbuf: pointer of struct rtw_cbuf
  Lock free operation, be careful of the use scheme
  Returns: pointer popped out
  rtw_cbuf_alloc - allocate a rtw_cbuf with given size and do initialization
  @size: size of pointer
  Returns: pointer of srtuct rtw_cbuf, NULL for allocation failure
 SPDX-License-Identifier: GPL-2.0+
  DMA-able FIFO implementation
  Copyright (C) 2012 Peter Hurley <peter@hurleysoftware.com>
  private helper fn to determine if check is in open interval (lo,hi)
  dma_fifo_init: initialize the fifo to a valid but inoperative state
  @fifo: address of in-place "struct dma_fifo" object
  dma_fifo_alloc - initialize and allocate dma_fifo
  @fifo: address of in-place "struct dma_fifo" object
  @size: 'apparent' size, in bytes, of fifo
  @align: dma alignment to maintain (should be at least cpu cache alignment),
          must be power of 2
  @tx_limit: maximum # of bytes transmissible per dma (rounded down to
             multiple of alignment, but at least align size)
  @open_limit: maximum # of outstanding dma transactions allowed
  @gfp_mask: get_free_pages mask, passed to kmalloc()
  The 'apparent' size will be rounded up to next greater aligned size.
  Returns 0 if no error, otherwise an error code
  dma_fifo_free - frees the fifo
  @fifo: address of in-place "struct dma_fifo" to free
  Also reinits the fifo to a valid but inoperative state. This
  allows the fifo to be reused with a different target requiring
  different fifo parameters.
  dma_fifo_reset - dumps the fifo contents and reinits for reuse
  @fifo: address of in-place "struct dma_fifo" to reset
  dma_fifo_in - copies data into the fifo
  @fifo: address of in-place "struct dma_fifo" to write to
  @src: buffer to copy from
  @n: # of bytes to copy
  Returns the # of bytes actually copied, which can be less than requested if
  the fifo becomes full. If < 0, return is error code.
  dma_fifo_out_pend - gets addresslen of next avail read and marks as pended
  @fifo: address of in-place "struct dma_fifo" to read from
  @pended: address of structure to fill with read addresslen
           The datalen fields will be NULL0 if no dma is pended.
  Returns the # of used bytes remaining in fifo (ie, if > 0, more data
  remains in the fifo that was not pended). If < 0, return is error code.
  dma_fifo_out_complete - marks pended dma as completed
  @fifo: address of in-place "struct dma_fifo" which was read from
  @complete: address of structure for previously pended dma to mark completed
 Only update the fifo in the original pended order 
 SPDX-License-Identifier: GPL-2.0+
  FireWire Serial driver
  Copyright (C) 2012 Peter Hurley <peter@hurleysoftware.com>
 same id used in card root directory   
 must be unique within LINUX_VENDOR_ID 
 configurable options 
 # of std ttys to create per fw_card    
 - doubles as loopback port index       
 try to VIRT_CABLE to every peer        
 create a loopback device for each card 
  Threshold below which the tty is woken for writing
  - should be equal to WAKEUP_CHARS in driversttyn_tty.c because
    even if the writer is woken, n_tty_poll() won't set EPOLLOUT until
    our fifo is below this level
  fwserial_list: list of every fw_serial created for each fw_card
  See discussion in fwserial_probe.
  port_table: array of tty ports allocated to each fw_card
  tty ports are allocated during probe when an fw_serial is first
  created for a given fw_card. Ports are allocated in a contiguous block,
  each block consisting of 'num_ports' ports.
 total # of tty ports created per fw_card 
 slab used as pool for struct fwtty_transactions 
 for each stat, print sum of 0 to 2^k, then individually 
  Returns the max receive packet size for the given node
  Devices which are OHCI v1.0 v1.1 v1.2-draft or RFC 2734 compliant
  are required by specification to support max_rec of 8 (512 bytes) or more.
 see IEEE 1394-2008 table 8-8 
  fwtty_update_port_status - decodes & dispatches line status changes
  Note: in loopback, the port->lock is being held. Only use functions that
  don't attempt to reclaim the port->lock.
 simulated LSRMSR status from remote 
 run emit_breaks one last time (if pending) 
  __fwtty_port_line_status - generate 'line status' for indicated port
  This function returns a remote 'MSR' state based on the local 'MCR' state,
  as if a null modem cable was attached. The actual status is a mangling
  of TIOCM_ bits suitable for sending to a peer's status_addr.
  Note: caller must be holding port lock
 TODO: add module param to tie RNG to DTR as well 
 emulate BRK as add'l line status 
  __fwtty_write_port_status - send the port line status to peer
  Note: caller must be holding the port lock.
  fwtty_write_port_status - same as above but locked by port lock
  fwtty_do_hangup - wait for ldisc to deliver all pending rx; only then hangup
  When the remote has finished tx, and all in-flight rx has been received and
  pushed to the flip buffer, the remote may close its device. This will
  drop DTR on the remote which will drop carrier here. Typically, the tty is
  hung up when carrier is dropped or lost.
  However, there is a race between the hang up and the line discipline
  delivering its data to the reader. A hangup will cause the ldisc to flush
  (ie., clear) the read buffer and flip buffer. Because of firewire's
  relatively high throughput, the ldisc frequently lags well behind the driver,
  resulting in lost data (which has already been received and written to
  the flip buffer) when the remote closes its end.
  Unfortunately, since the flip buffer offers no direct method for determining
  if it holds data, ensuring the ldisc has delivered all data is problematic.
 FIXME: drop this workaround when __tty_hangup waits for ldisc completion 
 generate breaks at the line rate (but at least 1) 
 disregard break status; breaks are generated by emit_breaks work 
 TODO: don't drop SAK and Magic SysRq here 
		 throttle the sender if remaining flip buffer space has
		  reached high watermark to avoid losing data which may be
		  in-flight. Since the AR request context is 32k, that much
		  data may have _already_ been acked.
  fwtty_port_handler - bus address handler for port readswrites
  This handler is responsible for handling inbound readwrite dma from remotes.
 Only accept rx from the peer virtual-cabled to this port 
  fwtty_tx_complete - callback for tx dma
  @data: ignored, has no meaning for write txns
  @length: ignored, has no meaning for write txns
  The writer must be woken here if the fifo has been emptied because it
  may have slept if chars_in_buffer was != 0
 TODO: implement retries 
 try to write as many dma transactions out as possible 
		
		  Stop tx if the 'last view' of the fifo is empty or if
		  this is the writer and there's not enough data to bother
 wakeup the writer 
 Don't change carrier state if this is a console 
  fwtty_port_carrier_raised: required tty_port operation
  This port operation is polled after a tty has been opened and is waiting for
  carrier detect -- see driversttytty_port:tty_port_block_til_ready().
 compute bit count of 2 frames 
 turn off echo and newline xlat if loopback 
 if console, don't change carrier state 
  fwtty_port_shutdown
  Note: the tty port core ensures this is not the console and
  manages TTY_IO_ERROR properly
 TODO: cancel outstanding transactions 
	
	  Ignore throttling (but not unthrottling).
	  It only makes sense to throttle when data will no longer be
	  accepted by the tty flip buffer. For example, it is
	  possible for received data to overflow the tty buffer long
	  before the line discipline ever has a chance to throttle the driver.
	  Additionally, the driver may have already completed the IO
	  but the tty buffer is still emptying, so the line discipline is
	  throttling and unthrottling nothing.
  fwtty_break_ctl - startstop sending breaks
  Signals the remote to start or stop generating simulated breaks.
  First, stop dequeueing from the fifo and wait for writerdrain to leave tx
  before signalling the break line status. This guarantees any pending rx will
  be queued to the line discipline before break is simulated on the remote.
  Conversely, turning off break_ctl requires signalling the line status change,
  then enabling tx.
 TODO: simulate loopback if TIOCM_LOOP set 
 | FWSC_RSP_OK 
 reconfigure tx_fifo optimally for this peer 
  fwserial_claim_port - attempt to claim port @ index for peer
  Returns ptr to claimed port or error code (as ERR_PTR())
  Can sleep - must be called from process context
 must guarantee that previous port releases have completed 
  fwserial_find_port - find avail port and claim for peer
  Returns ptr to claimed port or NULL if none avail
  Can sleep - must be called from process context
 must guarantee that previous port releases have completed 
 TODO: implement optional GUID-to-specific port # matching 
 find an unattached port (but not the loopback port, if present) 
 claim port 
 drop carrier (and all other line status) 
 reset dma fifo max transmission size back to S100 
  fwserial_connect_peer - initiate virtual cable with peer
  Returns 0 if VIRT_CABLE_PLUG request was successfully sent,
  otherwise error code.  Must be called from process context.
 only initiate VIRT_CABLE_PLUG if peer is currently not attached 
  fwserial_close_port -
  HUP the tty (if the tty exists) and unregister the tty device.
  Only used by the unit driver upon unit removal to disconnect and
  cleanup all attached ports
  The port reference is put by fwtty_cleanup (if a reference was
  ever taken).
  fwserial_lookup - finds first fw_serial associated with card
  @card: fw_card to match
  NB: caller must be holding fwserial_list_mutex
  __fwserial_lookup_rcu - finds first fw_serial associated with card
  @card: fw_card to match
  NB: caller must be inside rcu_read_lock() section
  __fwserial_peer_by_node_id - finds a peer matching the given generation + id
  If a matching peer could not be found for the specified generationnode id,
  this could be because:
  a) the generation has changed and one of the nodes hasn't updated yet
  b) the remote node has created its remote unit device before this
     local node has created its corresponding remote unit device
  In either case, the remote node should retry
  Note: caller must be in rcu_read_lock() section
		
		  Something is very wrong - there should be a matching
		  fw_serial structure for every fw_card. Maybe the remote node
		  has created its remote unit device before this driver has
		  been probed for any unit devices...
  fwserial_add_peer - add a newly probed 'serial' unit device as a 'peer'
  @serial: aggregate representing the specific fw_card to add the peer to
  @unit: 'peer' to create and add to peer_list of serial
  Adds a 'peer' (ie, a local or remote 'serial' unit device) to the list of
  peers for a specific fw_card. Optionally, auto-attach this peer to an
  available tty port. This function is called either directly or indirectly
  as a result of a 'serial' unit device being created & probed.
  Note: this function is serialized with fwserial_remove_peer() by the
  fwserial_list_mutex held in fwserial_probe().
  A 1:1 correspondence between an fw_unit and an fwtty_peer is maintained
  via the dev_set_drvdata() for the device of the fw_unit.
 retrieve the mgmt bus addr from the unit directory 
		
		  No mgmt address effectively disables VIRT_CABLE_PLUG -
		  this peer will not be able to attach to a remote
 associate peer with specific fw_card 
 identify the local unit & virt cable to loopback port 
 auto-attach to remote units only (if policy allows) 
  fwserial_remove_peer - remove a 'serial' unit device as a 'peer'
  Remove a 'peer' from its list of peers. This function is only
  called by fwserial_remove() on bus removal of the unit device.
  Note: this function is serialized with fwserial_add_peer() by the
  fwserial_list_mutex held in fwserial_remove().
 if this unit is the local unit, clear link 
 cancel the request timeout timer (if running) 
  fwserial_create - init everything to create TTYs for a specific fw_card
  @unit: fw_unit for first 'serial' unit device probed for this fw_card
  This function inits the aggregate structure (an fw_serial instance)
  used to manage the TTY ports registered by a specific fw_card. Also, the
  unit device is added as the first 'peer'.
  This unit device may represent a local unit device (as specified by the
  config ROM unit directory) or it may represent a remote unit device
  (as specified by the reading of the remote node's config ROM).
  Returns 0 to indicate "ownership" of the unit device, or a negative errno
  value to indicate which error.
 get unique bus addr region for port's status & recv fifo 
		
		  XXX: use custom memory region above cpu physical memory addrs
		  this will ease porting to 64-bit firewire adapters
 preserve i for error cleanup 
 preserve j for error cleanup 
 fall-through to error processing 
  fwserial_probe: bus probe function for firewire 'serial' unit devices
  A 'serial' unit device is created and probed as a result of:
  - declaring a ieee1394 bus id table for 'devices' matching a fabricated
    'serial' unit specifier id
  - adding a unit directory to the config ROM(s) for a 'serial' unit
  The firewire core registers unit devices by enumerating unit directories
  of a node's config ROM after reading the config ROM when a new node is
  added to the bus topology after a bus reset.
  The practical implications of this are:
  - this probe is called for both local and remote nodes that have a 'serial'
    unit directory in their config ROM (that matches the specifiers in
    fwserial_id_table).
  - no specific order is enforced for local vs. remote unit devices
  This unit driver copes with the lack of specific order in the same way the
  firewire net driver does -- each probe, for either a local or remote unit
  device, is treated as a 'peer' (has a struct fwtty_peer instance) and the
  first peer created for a given fw_card (tracked by the global fwserial_list)
  creates the underlying TTYs (aggregated in a fw_serial instance).
  NB: an early attempt to differentiate local & remote unit devices by creating
      peers only for remote units and fw_serial instances (with their
      associated TTY devices) only for local units was discarded. Managing
      the peer lifetimes on device removal proved too complicated.
  fwserial_probefwserial_remove are effectively serialized by the
  fwserial_list_mutex. This is necessary because the addition of the first peer
  for a given fw_card will trigger the creation of the fw_serial for that
  fw_card, which must not simultaneously contend with the removal of the
  last peer for a given fw_card triggering the destruction of the same
  fw_serial for the same fw_card.
  fwserial_remove: bus removal function for firewire 'serial' unit devices
  The corresponding 'peer' for this unit device is removed from the list of
  peers for the associated fw_serial (which has a 1:1 correspondence with a
  specific fw_card). If this is the last peer being removed, then trigger
  the destruction of the underlying TTYs.
 unlink from the fwserial_list here 
  fwserial_update: bus update function for 'firewire' serial unit devices
  Updates the new node_id and bus generation for this peer. Note that locking
  is unnecessary; but careful memory barrier usage is important to enforce the
  load and store order of generation & node_id.
  The fw-core orders the write of node_id before generation in the parent
  fw_device to ensure that a stale node_id cannot be used with a current
  bus generation. So the generation value must be read before the node_id.
  In turn, this orders the write of node_id before generation in the peer to
  also ensure a stale node_id cannot be used with a current bus generation.
 XXX: config ROM definitons could be improved with semi-automated offset
  and length calculation
   type = text            
   enc = ASCII, lang EN   
 'Linux TTY'              
  The management address is in the unit space region but above other known
  address users (to keep wild writes from causing havoc)
  fwserial_handle_plug_req - handle VIRT_CABLE_PLUG request work
  @work: ptr to peer->work
  Attempts to complete the VIRT_CABLE_PLUG handshake sequence for this peer.
  This checks for a collided request-- ie, that a VIRT_CABLE_PLUG request was
  already sent to this peer. If so, the collision is resolved by comparing
  guid values; the loser sends the plug response.
  Note: if an error prevents a response, don't do anything -- the
  remote will timeout its request.
 don't release claimed port 
 We lost - hijack the already-claimed port and send ok 
 We lost - send unplug rsp 
		
		  This should never happen - it would mean that the
		  remote unit that just wrote this transaction was
		  already removed from the bus -- and the removal was
		  processed before we rec'd this transaction
  fwserial_mgmt_handler: bus address handler for mgmt requests
  This handler is responsible for handling virtual cable requests from remotes
  for all cards.
 XXX: placeholder for a "firewire" debugfs node 
 num_ttysnum_ports must not be set above the static alloc avail 
	
	  Ideally, this address handler would be registered per local node
	  (rather than the same handler for all local nodes). However,
	  since the firewire core requires the config rom descriptor before
	  the local unit device(s) are created, a single management handler
	  must suffice for all local serial units.
 SPDX-License-Identifier: GPL-2.0
  AD7746 capacitive sensor driver supporting AD7745, AD7746 and AD7747
  Copyright 2011 Analog Devices Inc.
  AD7746 Register Definition
 Status Register Bit Designations (AD7746_REG_STATUS) 
 Capacitive Channel Setup Register Bit Designations (AD7746_REG_CAP_SETUP) 
 AD7746 only 
 VoltageTemperature Setup Register Bit Designations (AD7746_REG_VT_SETUP) 
 Excitation Setup Register Bit Designations (AD7746_REG_EXC_SETUP) 
 Config Register Bit Designations (AD7746_REG_CFG) 
 CAPDAC Register Bit Designations (AD7746_REG_CAPDACx) 
 protect sensor state 
	
	  Capacitive channel digital filter setup;
	  conversion timeupdate rate setup per channel
 Values are Update Rate (Hz), Conversion Time (ms) + 1
 21pF 
		
		  CAPDAC Scale = 21pF_typ  127
		  CIN Scale = 8.192pF  2^24
		  Offset Scale = CAPDAC Scale  CIN Scale = 338646
 Now read the actual register 
			
			  temperature in milli degrees Celsius
			  T = ((val  2048) - 4096)  1000
 supply_raw
 1 + gain_val  2^16 
 8.192pf  2^24 
 1170mV  2^23 
 this is only used for device removal purposes 
 SPDX-License-Identifier: GPL-2.0+
  API bus driver for ADT731678 ADT751679 digital temperature
  sensor, ADC and DAC
  Copyright 2010 Analog Devices Inc.
  adt7316 register access by SPI
  device probe and remove
 don't exceed max specified SPI CLK frequency 
 switch from default I2C protocol to SPI protocol 
 SPDX-License-Identifier: GPL-2.0+
  ADT7316 digital temperature sensor driver supporting ADT731678 ADT751679
  Copyright 2010 Analog Devices Inc.
  ADT7316 registers definition
  ADT7316 config1
  ADT7316 config2
  ADT7316 config3
  ADT7316 DAC config
  ADT7316 LDAC config
  ADT7316 INT_MASK2
  ADT7316 value masks
  Chip ID
  struct adt7316_chip_info - chip specific information
 0x2f 
 DAC config 
 LDAC config 
 8, 10, 12 
 chip id 
  Logic interrupt mask for user application to enable
  interrupts.
  struct adt7316_chip_info - chip specific information
 ADT7316_DA_EN_MODE_LDAC 
 ex_temp and ain 
 convert supplement to positive value 
  Show mask of enabled interrupts in Hex.
  Set 1 to the mask in Hex to enabled interrupts.
 enable vdd int 
 disable vdd int 
 mask in reg is opposite, set 1 to disable 
 mask in reg is opposite, set 1 to disable 
 NASTY duplication to be fixed 
  device probe and remove
 this is only used for device removal purposes 
 SPDX-License-Identifier: GPL-2.0+
  I2C bus driver for ADT731678 ADT751679 digital temperature
  sensor, ADC and DAC
  Copyright 2010 Analog Devices Inc.
  adt7316 register access by I2C
  device probe and remove
 SPDX-License-Identifier: GPL-2.0+
  ADIS16240 Programmable Impact Sensor and Recorder driver
  Copyright 2010 Analog Devices Inc.
 ms 
 Flash memory write count 
 Output, power supply 
 Output, x-axis accelerometer 
 Output, y-axis accelerometer 
 Output, z-axis accelerometer 
 Output, auxiliary ADC input 
 Output, temperature 
 Output, x-axis acceleration peak 
 Output, y-axis acceleration peak 
 Output, z-axis acceleration peak 
 Output, sum-of-squares acceleration peak 
 Output, Capture Buffer 1, X and Y acceleration 
 Output, Capture Buffer 2, Z acceleration 
 Diagnostic, error flags 
 Diagnostic, event counter 
 Diagnostic, check sum value from firmware test 
 Calibration, x-axis acceleration offset adjustment 
 Calibration, y-axis acceleration offset adjustment 
 Calibration, z-axis acceleration offset adjustment 
 Clock, hour and minute 
 Clock, month and day 
 Clock, year 
 Wake-up setting, hour and minute 
 Wake-up setting, month and day 
 Alarm 1 amplitude threshold 
 Alarm 2 amplitude threshold 
 Alarm control 
 Capture, external trigger control 
 Capture, address pointer 
 Capture, configuration and control 
 General-purpose digital inputoutput control 
 Miscellaneous control 
 Internal sample period (rate) control 
 System command 
 MSC_CTRL 
 Enables sum-of-squares output (XYZPEAK_OUT) 
 Enables peak tracking output (XPEAK_OUT, YPEAK_OUT, and ZPEAK_OUT) 
 Self-test enable: 1 = apply electrostatic force, 0 = disabled 
 Data-ready enable: 1 = enabled, 0 = disabled 
 Data-ready polarity: 1 = active high, 0 = active low 
 Data-ready line selection: 1 = DIO2, 0 = DIO1 
 DIAG_STAT 
 Alarm 2 status: 1 = alarm active, 0 = alarm inactive 
 Alarm 1 status: 1 = alarm active, 0 = alarm inactive 
 Capture buffer full: 1 = capture buffer is full 
 Flash test, checksum flag: 1 = mismatch, 0 = match 
 Power-on, self-test flag: 1 = failure, 0 = pass 
 Power-on self-test: 1 = in-progress, 0 = complete 
 SPI communications failure 
 Flash update failure 
 Power supply above 3.625 V 
 Power supply below 2.225 V 
 GLOB_CMD 
 At the moment triggers are only used for ring buffer
  filling. This may change!
 4.88 mV 
 0.244 C 
 51.4 mg 
 51.4 mg 
 25 C = 0x133 
 setup the industrialio driver allocated elements 
 this is only used for removal purposes 
 Get the device into a sane initial state 
 SPDX-License-Identifier: GPL-2.0+
  ADIS16203 Programmable 360 Degrees Inclinometer
  Copyright 2010 Analog Devices Inc.
 ms 
 Flash memory write count 
 Output, power supply 
 Output, auxiliary ADC input 
 Output, temperature 
 Output, x-axis inclination 
 Output, y-axis inclination 
 Incline null calibration 
 Alarm 1 amplitude threshold 
 Alarm 2 amplitude threshold 
 Alarm 1, sample period 
 Alarm 2, sample period 
 Alarm control 
 Auxiliary DAC data 
 General-purpose digital inputoutput control 
 Miscellaneous control 
 Internal sample period (rate) control 
 Operation, filter configuration 
 Operation, sleep mode control 
 Diagnostics, system status register 
 Operation, system command register 
 MSC_CTRL 
 Self-test at power-on: 1 = disabled, 0 = enabled 
 Reverses rotation of both inclination outputs 
 Self-test enable 
 Data-ready enable: 1 = enabled, 0 = disabled 
 Data-ready polarity: 1 = active high, 0 = active low 
 Data-ready line selection: 1 = DIO1, 0 = DIO0 
 DIAG_STAT 
 Alarm 2 status: 1 = alarm active, 0 = alarm inactive 
 Alarm 1 status: 1 = alarm active, 0 = alarm inactive 
 Self-test diagnostic error flag 
 SPI communications failure 
 Flash update failure 
 Power supply above 3.625 V 
 Power supply below 2.975 V 
 GLOB_CMD 
 currently only one writable parameter which keeps this simple 
 1.22 mV 
 0.61 mV 
 -0.47 C 
 0.025 degree 
 25 C = 1278 
 Fixme: Not what it appears to be - see data sheet 
 setup the industrialio driver allocated elements 
 this is only used for removal purposes 
 Get the device into a sane initial state 
 SPDX-License-Identifier: GPL-2.0
  AD5933 AD5934 Impedance Converter, Network Analyzer
  Copyright 2011 Analog Devices Inc.
 AD5933AD5934 Registers 
 RW, 1 byte 
 RW, 1 byte 
 RW, 3 bytes 
 RW, 3 bytes 
 RW, 2 bytes, 9 bit 
 RW, 2 bytes 
 R, 1 byte 
 R, 2 bytes
 R, 2 bytes
 R, 2 bytes
 AD5933_REG_CONTROL_HB Bits 
 AD5933_REG_CONTROL_LB Bits 
 AD5933_REG_STATUS Bits 
 I2C Block Commands 
 Device Specs 
 Protect sensor state 
 Ring Channels 
  handles: AD5933_REG_FREQ_START and AD5933_REG_FREQ_INC
 2x, 4x handling, see datasheet 
  note:
  ideally we would handle the scale attributes via the iio_info
  (read|write)_raw methods, however this part is a untypical since we
  don't create dedicated sysfs channel attributes for out0 and in0.
	
	  AD5933_CTRL_INIT_START_FREQ:
	  High Q complex circuits require a long time to reach steady state.
	  To facilitate the measurement of such impedances, this mode allows
	  the user full control of the settling time requirement before
	  entering start frequency sweep mode where the impedance measurement
	  takes place. In this mode the impedance is excited with the
	  programmed start frequency (ad5933_ring_preenable),
	  but no measurement takes place.
 start sweep 
 no data available - try again later 
		
		  last sample received - power down do
		  nothing until the ring enable is toggled
 we just received a valid datum, move on to the next 
 SPDX-License-Identifier: GPL-2.0+
  ADE7854586878 Polyphase Multifunction Energy Metering IC Driver (SPI Bus)
  Copyright 2010 Analog Devices Inc.
 SPDX-License-Identifier: GPL-2.0+
  ADE7854586878 Polyphase Multifunction Energy Metering IC Driver (I2C Bus)
  Copyright 2010 Analog Devices Inc.
 SPDX-License-Identifier: GPL-2.0+
  ADE7854586878 Polyphase Multifunction Energy Metering IC Driver
  Copyright 2010 Analog Devices Inc.
 Software Chip Reset 
		irqen |= BIT(17);  1: interrupt enabled when all periodical
				    (at 8 kHz rate) DSP computations finish.
 Disable IRQ 
 setup the industrialio driver allocated elements 
 Get the device into a sane initial state 
 SPDX-License-Identifier: GPL-2.0
  ad2s1210.c support for the ADI Resolver to Digital Converters: AD2S1210
  Copyright (c) 2010-2010 Analog Devices Inc.
 write 1 bytes (address or data) to the chip 
 read value from one of the registers 
 read the fault register since last sample 
 delay (2  tck + 20) nano seconds 
 delay (6  tck + 20) nano seconds 
 delay (2  tck + 20) nano seconds 
 SPDX-License-Identifier: GPL-2.0
  AD7280A Lithium Ion Battery Monitoring System
  Copyright 2011 Analog Devices Inc.
 Registers 
 D11 to D0, Read only 
 D11 to D0, Read only 
 D11 to D0, Read only 
 D11 to D0, Read only 
 D11 to D0, Read only 
 D11 to D0, Read only 
 D11 to D0, Read only 
 D11 to D0, Read only 
 D11 to D0, Read only 
 D11 to D0, Read only 
 D11 to D0, Read only 
 D11 to D0, Read only 
 D11 to D0, Read only 
 D15 to D8, Readwrite 
 D7 to D0, Readwrite 
 D7 to D0, Readwrite 
 D7 to D0, Readwrite 
 D7 to D0, Readwrite 
 D7 to D0, Readwrite 
 D7 to D0, Readwrite 
 D7 to D0, Readwrite 
 D7 to D0, Readwrite 
 D7 to D0, Readwrite 
 D7 to D0, Readwrite 
 D7 to D0, Readwrite 
 D7 to D0, Readwrite 
 D7 to D0, Readwrite 
 D7 to D0, Readwrite 
 D7 to D0, Readwrite 
 D7 to D0, Readwrite 
 Bits and Masks 
 < 1MHz 
 5-bit device address is sent LSB first 
 During a read a valid write is mandatory.
  So writing to the highest available address (Address 0x1F)
  and setting the address all parts bit to 0 is recommended
  So the TXVAL is AD7280A_DEVADDR_ALL + CRC
  AD7280 CRC
  P(x) = x^8 + x^5 + x^3 + x^2 + x^1 + x^0 = 0b100101111 => 0x2F
 protect sensor state 
 After initiating a conversion sequence we need to wait until the
  conversion is done. The delay is typically in the range of 15..30 us
  however depending an the number of devices in the daisy chain and the
  number of averages taken, conversion delays and acquisition time options
  it may take up to 250us, in this case we better sleep instead of busy
  wait.
 turns off the read operation on all parts 
 turns on the read operation on the addressed part 
 Set register address on the part to be read from 
 only sum cell voltages 
 LSB 15.68mV 
 LSB 19.6mV 
 Note: No need to fix checkpatch warning that reads:
 	CHECK: spaces preferred around that '-' (ctx:VxV)
  The function argument is stringified and doesn't need a fix
	
	  Total Conversion Time = ((tACQ + tCONV) 
	 			   (Number of Conversions per Part)) −
	 			   tACQ + ((N - 1)  tDELAY)
	 
	  Readback Delay = Total Conversion Time + tWAIT
 Convert to usecs 
 Add tWAIT 
 SPDX-License-Identifier: GPL-2.0+
  AD7816 digital temperature sensor driver supporting AD781678
  Copyright 2010 Analog Devices Inc.
  AD7816 config masks
  AD7816 temperature masks
  struct ad7816_chip_info - chip specific information
 0 always be temperature 
  ad7816 data access by SPI
 operating mode 2 
 operating mode 1 
  temperature bound events
  device probe and remove
 this is only used for device removal purposes 
 Only low trigger is supported in ad781678 
 SPDX-License-Identifier: GPL-2.0
  AD9832 SPI DDS driver
  Copyright 2011 Analog Devices Inc.
 Registers 
 Command Control Bits 
  struct ad9832_state - driver instance specific data
  @spi:		spi_device
  @avdd:		supply regulator for the analog section
  @dvdd:		supply regulator for the digital section
  @mclk:		external master clock
  @ctrl_fp:		cached frequencyphase control word
  @ctrl_ss:		cached syncselsrc control word
  @ctrl_src:		cached sleepresetclr word
  @xfer:		default spi transfer
  @msg:		default spi message
  @freq_xfer:		tuning word spi transfer
  @freq_msg:		tuning word spi message
  @phase_xfer:		tuning word spi transfer
  @phase_msg:		tuning word spi message
  @lock:		protect sensor state
  @data:		spi transmit buffer
  @phase_data:		tuning word spi transmit buffer
  @freq_data:		tuning word spi transmit buffer
 protect sensor state 
	
	  DMA (thus cache coherency maintenance) requires the
	  transfer buffers to live in their own cache lines.
  see dds.h for further information
 1Hz 
 2PI2^12 rad
 Setup default messages 
 SPDX-License-Identifier: GPL-2.0
  AD9833AD9834AD9837AD9838 SPI DDS driver
  Copyright 2010-2011 Analog Devices Inc.
 Registers 
 Command Control Bits 
  struct ad9834_state - driver instance specific data
  @spi:		spi_device
  @mclk:		external master clock
  @control:		cached control word
  @devid:		device id
  @xfer:		default spi transfer
  @msg:		default spi message
  @freq_xfer:		tuning word spi transfer
  @freq_msg:		tuning word spi message
  @lock:		protect sensor state
  @data:		spi transmit buffer
  @freq_data:		tuning word spi transmit buffer
 protect sensor state 
	
	  DMA (thus cache coherency maintenance) requires the
	  transfer buffers to live in their own cache lines.
  ad9834_supported_device_ids:
 AD9843 reserved mode 
 AD9843 reserved mode 
  see dds.h for further information
 1Hz 
 2PI2^12 rad
 Setup default messages 
 SPDX-License-Identifier: GPL-2.0
  #ifdef __BIG_ENDIAN
  ssize_t lynxfb_ops_write(struct fb_info info, const char __user buf,
  size_t count, loff_t ppos);
  ssize_t lynxfb_ops_read(struct fb_info info, char __user buf,
  size_t count, loff_t ppos);
  #endif
 common var for all device 
	1024x600-60 VESA	[1.71:1] 
	1024x600-70 VESA 
	1024x600-75 VESA 
	1024x600-85 VESA 
	720x480	
	1280x720		[1.78:1]	
	1280x768@60 
	1360 x 768	[1.77083:1]	
	1368 x 768      [1.78:1]	
	1440 x 900		[16:10]	
	1440x960		[15:10]	
	1920x1080	[16:9]	
 no hardware cursor supported under version 2.6.10, kernel bug 
 get the 16bit color of kernel means 
	
	  each time 2d function begin to work,below three variable always need
	  be set, seems we can put them together in some place
	
	  If not use spin_lock, system will die if user load driver
	  and immediately unload driver frequently (dual)
	  since they fb_count could change during the lifetime of
	  this lock, we are holding it for all cases.
	
	  each time 2d function begin to work,below three variable always need
	  be set, seems we can put them together in some place
	
	  If not use spin_lock, system will die if user load driver
	  and immediately unload driver frequently (dual)
	  since they fb_count could change during the lifetime of
	  this lock, we are holding it for all cases.
	
	  each time 2d function begin to work,below three variable always need
	  be set, seems we can put them together in some place
 TODO: Implement hardware acceleration for image->depth > 1 
	
	  If not use spin_lock, system will die if user load driver
	  and immediately unload driver frequently (dual)
	  since they fb_count could change during the lifetime of
	  this lock, we are holding it for all cases.
 fix structure is not so FIX ... 
	
	  var->red,green,blue,transp are need to be set by driver
	  and these data should be set before setcolreg routine
FB_ACCELF_TEXT;
 1 means do suspend 
 1 means do suspend 
 FB_ACCELF_TEXT; 
 check if current fb's video memory big enough to hold the onscreen
 defaulty crtc->channel go with par->index 
 setup crtc and output member 
 chip specific phase 
 not consider of padding stuffs for o_screen,need fix 
			 not consider of padding stuffs for o_screen,
			  need fix
 cursor 
 set index 
	
	  set current cursor variable and proc pointer,
	  must be set after crtc member initialized
 set info->fbops, must be set before fb_find_mode 
 use 2d acceleration 
break;
 some member of info->var had been set by fb_find_mode 
 set par 
 set info 
 set info->fix 
	
	  according to mmap experiment from user space application,
	  fix->mmio_len should not larger than virtual size
	  (xres_virtual x yres_virtual x ByPP)
	  Below line maybe buggy when user mmap fb dev node and write
	  data into the bound over virtual size
 set var 
	chip specific g_option configuration routine 
 defaultly turn g_hwcursor on for both view 
 SM750LE only have one crt channel 
 sm750le do not have complex attributes 
 enable device 
		
		  hook deInit and 2d routines, notes that below hw_xxx
		  routine can work on most of lynx chips
		  if some chip need specific function,
		  please hook it in smXXX_set_drv routine
 call chip specific setup routine  
 call chip specific mmap routine 
 call chipInit routine 
 allocate frame buffer info structures according to g_dualview 
	
	  Notes:
	  char  strsep(char s,const char  ct);
	  @s: the string to be searched
	  @ct :the characters to search for
	 
	  strsep() updates @options to pointer after the first found token
	  it also returns the pointer ahead the token.
 options that mean for any lynx chips are configured here 
 misc g_settings are transport to chip specific routines 
 SPDX-License-Identifier: GPL-2.0
 setup 2d engine registers 
 dpr1c 
 DE_STRETCH bpp format need be initialized in setMode routine 
 disable clipping and transparent 
 dpr2c 
 dpr30 
 dpr24 
 dpr0c 
  set2dformat only be called from setmode functions
  but if you need dual framebuffer driver,need call set2dformat
  every time you use 2d function
 fmt=0,1,2 for 8,16,32,bpp on sm718750502 
		
		  int time wait and always busy,seems hardware
		  got something error
 dpr40 
 dpr10 
 dpr44 
 DPR14 
 dpr4 
 dpr8 
 dpr0xc 
  sm750_hw_copyarea
  @accel: Acceleration device data
  @sBase: Address of source: offset in frame buffer
  @sPitch: Pitch value of source surface in BYTE
  @sx: Starting x coordinate of source surface
  @sy: Starting y coordinate of source surface
  @dBase: Address of destination: offset in frame buffer
  @dPitch: Pitch value of destination surface in BYTE
  @Bpp: Color depth of destination surface
  @dx: Starting x coordinate of destination surface
  @dy: Starting y coordinate of destination surface
  @width: width of rectangle in pixel value
  @height: height of rectangle in pixel value
  @rop2: ROP value
 Direction of ROP2 operation: 1 = Left to Right, (-1) = Right to Left 
 If source and destination are the same surface, need to check for overlay cases 
 Determine direction of operation 
			  +----------+
			   |S         |
			   |   +----------+
			   |   |      |   |
			   |   |      |   |
			   +---|------+   |
			 	|         D|
			 	+----------+
			  +----------+
			   |D         |
			   |   +----------+
			   |   |      |   |
			   |   |      |   |
			   +---|------+   |
			 	|         S|
			 	+----------+
 sy == dy 
				 +------+---+------+
				  |S     |   |     D|
				  |      |   |      |
				  |      |   |      |
				  |      |   |      |
				  +------+---+------+
 sx > dx 
				 +------+---+------+
				  |D     |   |     S|
				  |      |   |      |
				  |      |   |      |
				  |      |   |      |
				  +------+---+------+
	
	  Note:
	  DE_FOREGROUND and DE_BACKGROUND are don't care.
	  DE_COLOR_COMPARE and DE_COLOR_COMPARE_MAKS
	  are set by set deSetTransparency().
	
	  2D Source Base.
	  It is an address offset (128 bit aligned)
	  from the beginning of frame buffer.
 dpr40 
	
	  2D Destination Base.
	  It is an address offset (128 bit aligned)
	  from the beginning of frame buffer.
 dpr44 
	
	  Program pitch (distance between the 1st points of two adjacent lines).
	  Note that input pitch is BYTE value, but the 2D Pitch register uses
	  pixel values. Need Byte to pixel conversion.
 dpr10 
	
	  Screen Window width in Pixels.
	  2D engine uses this value to calculate the linear address in frame buffer
	  for a given point.
 dpr3c 
 dpr0 
 dpr04 
 dpr08 
 dpr0c 
  sm750_hw_imageblit
  @accel: Acceleration device data
  @pSrcbuf: pointer to start of source buffer in system memory
  @srcDelta: Pitch value (in bytes) of the source buffer, +ive means top down
 	      and -ive mean button up
  @startBit: Mono data can start at any bit in a byte, this value should be
 	      0 to 7
  @dBase: Address of destination: offset in frame buffer
  @dPitch: Pitch value of destination surface in BYTE
  @bytePerPixel: Color depth of destination surface
  @dx: Starting x coordinate of destination surface
  @dy: Starting y coordinate of destination surface
  @width: width of rectangle in pixel value
  @height: height of rectangle in pixel value
  @fColor: Foreground color (corresponding to a 1 in the monochrome data
  @bColor: Background color (corresponding to a 0 in the monochrome data
  @rop2: ROP value
 Just make sure the start bit is within legal range 
	
	  2D Source Base.
	  Use 0 for HOST Blt.
	 2D Destination Base.
	  It is an address offset (128 bit aligned)
	  from the beginning of frame buffer.
	
	  Program pitch (distance between the 1st points of two adjacent
	  lines). Note that input pitch is BYTE value, but the 2D Pitch
	  register uses pixel values. Need Byte to pixel conversion.
 dpr10 
	
	  Screen Window width in Pixels.
	  2D engine uses this value to calculate the linear address
	  in frame buffer for a given point.
	 
	   Note: For 2D Source in Host Write, only X_K1_MONO field is needed,
	   and Y_K2 field is not used.
	   For mono bitmap, use startBit for X_K1.
 dpr00 
 dpr04 
 dpr08 
 Write MONO data (line by line) to 2D Engine data port 
 For each line, send the data in chunks of 4 bytes 
 SPDX-License-Identifier: GPL-2.0
 state != 0 means turn on both timing & plane en_bit 
		
		  Timing should be enabled first before enabling the
		  plane because changing at the same time does not
		  guarantee that the plane will also enabled or
		  disabled.
		
		  Somehow the register value on the plane is not set
		  until a few delay. Need to write and read it a
		  couple times
		
		  When turning off, there is no rule on the
		  programming sequence since whenever the clock is
		  off, then it does not matter whether the plane is
		  enabled or disabled.  Note: Modifying the plane bit
		  will take effect on the next vertical sync. Need to
		  find out if it is necessary to wait for 1 vsync
		  before modifying the timing enable bit.
	
	  Do not wait when the Primary PLL is off or display control is
	  already off. This will prevent the software to wait forever.
 Wait for end of vsync. 
 Wait for start of vsync. 
 disp should be 1 to open sequence 
 set panel path controller select 
 set crt path controller select 
se blank off 
 set primary timing and plane en_bit 
 set secondary timing and plane en_bit
 set  panel sequence 
 SPDX-License-Identifier: GPL-2.0
 SM750 and SM750LE are different in their revision ID only. 
  This function set up the main chip clock.
  Input: Frequency to be set.
 Cheok_0509: For SM750LE, the chip clock is fixed. Nothing to set. 
		
		  Set up PLL structure to hold the value to be set in clocks.
 Defined in CLOCK.H 
		
		  Call sm750_calc_pll_value() to fill the other fields
		  of the PLL structure. Sometimes, the chip cannot set
		  up the exact clock required by the User.
		  Return value of sm750_calc_pll_value gives the actual
		  possible clock.
 Master Clock Control: MXCLK_PLL 
	
	  Cheok_0509: For SM750LE, the memory clock is fixed.
	  Nothing to set.
		
		  Set the frequency to the maximum frequency
		  that the DDR Memory can take which is 336MHz.
 Calculate the divisor 
 Set the corresponding divisor in the register. 
  This function set up the master clock (MCLK).
  Input: Frequency to be set.
  NOTE:
       The maximum frequency the engine can run is 168MHz.
	
	  Cheok_0509: For SM750LE, the memory clock is fixed.
	  Nothing to set.
		
		  Set the frequency to the maximum frequency
		  that the SM750 engine can run, which is about 190 MHz.
 Calculate the divisor 
 Set the corresponding divisor in the register. 
 sm750le only use 64 mb memory
 for 750,always use power mode0
 get frame buffer size from GPIO 
 8  Mega byte 
 16 Mega byte 
 32 Mega byte 
 64 Mega byte 
 Enable display power gate & LOCALMEM power gate
 set panel pll and graphic mode via mmio_88 
 set graphic mode via IO method 
 Set the Main Chip Clock 
 Set up memory clock. 
 Set up master clock 
	
	  Reset the memory controller.
	  If the memory controller is not reset in SM750,
	  the system might hang when sw accesses the memory.
	  The memory should be resetted after changing the MXCLK.
 Disable Overlay, if a former application left it on 
 Disable video alpha, if a former application left it on 
 Disable alpha plane, if a former application left it on 
 Disable DMA Channel, if a former application left it on 
 Disable DMA Power, if a former application left it on 
 We can add more initialization as needed. 
  monk liu @ 462011:
 	re-write the calculatePLL function of ddk750.
 	the original version function does not use
 	some mathematics tricks and shortcut
 	when it doing the calculation of the best N,M,D combination
 	I think this version gives a little upgrade in speed
  750 pll clock formular:
  Request Clock = (Input Clock  M )(N  X)
  Input Clock = 14318181 hz
  X = 2 power D
  D ={0,1,2,3,4,5,6}
  M = {1,...,255}
  N = {2,...,15}
	
	  as sm750 register definition,
	  N located in 2,15 and M located in 1,255
		
		  SM750LE don't have
		  programmable PLL and MN values to work on.
		  Just return the requested clock.
	
	  for MXCLK register,
	  no POD provided, so need be treated differently
		
		  RN will not exceed maximum long
		  if @request <= 285 MHZ (for 32bit cpu)
 rem always small than 14318181 
 round step 
	
	  Note that all PLL's have the same format. Here, we just use
	  Panel PLL parameter to work out the bit fields in the
	  register. On returning a 32 bit number, the value can be
	  applied to any PLL in the calling function.
 SPDX-License-Identifier: GPL-2.0
 cursor control for voyager and 718750
 hw_cursor_xxx works for voyager,718 and 750 
  in byte
 in byte	
 in byte 
 2 stands for forecolor and 1 for backcolor 
 assume pitch is 1,2,4,8,...
 need a return 
  in byte
 in byte	
 in byte 
 assume pitch is 1,2,4,8,...
 need a return 
 SPDX-License-Identifier: GPL-2.0
  SM50x can operate in one of three modes: 0, 1 or Sleep.
  On hardware reset, power mode 0 is default.
 Set up other fields in Power Control Register 
 Program new power mode. 
  This function enabledisable the 2D engine.
 Enable DMA Gate 
  This function enabledisable the GPIO Engine
 Enable GPIO Gate 
  This function enabledisable the I2C Engine
 Enable I2C Gate 
 SPDX-License-Identifier: GPL-2.0
  This global variable contains all the supported driver and its corresponding
  function API. Please set the function pointer to NULL whenever the function
  is not supported.
 error 
 SPDX-License-Identifier: GPL-2.0
	
	  reserve the vidreg space of smi adaptor
	  if you do this, you need to add release region code
	  in lynxfb_remove, or memory will not be mapped again
	  successfully
 now map mmio and vidmem 
	
	  don't use pdev_resource[x].end - resource[x].start to
	  calculate the resource size, it's only the maximum available
	  size but not the actual size, using
	  @ddk750_get_vm_size function can be safe.
 reserve the vidmem space of smi adaptor 
 for sm718, open pci burst 
 does user need CRT? 
 shut off dpms 
 turn on dpms 
		
		  for 750LE, no DVI chip initialization
		  makes Monitor no signal
		 
		  Set up GPIO for software I2C to program DVI chip in the
		  Xilinx SP605 board, in order to have video signal.
		
		  Customer may NOT use CH7301 DVI chip, which has to be
		  initialized differently.
			
			  The following register values for CH7301 are from
			  Chrontel app note and our experiment.
 init 2d engine 
 just open DISPLAY_CONTROL_750LE register bit 3:0 
 set the controller's mode for @crtc charged with @var and @fix parameters 
 set 2d engine pixel format according to mode bpp 
 set timing 
 choose pll 
 set pitch, offset, width, start address, etc... 
		
		  crtc->channel is not equal to par->index on numeric,
		  be aware of that
 set pixel format 
 not implemented now 
		
		  crtc->channel is not equal to par->index on numeric,
		  be aware of that
 SET PIXEL FORMAT 
 engine reset 
 call 2d init 
 timeout error 
 timeout error 
 check params 
 SPDX-License-Identifier: GPL-2.0
          Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
   swi2c.c --- SM750SM718 DDK
   This file contains the source code for I2C using software
   implementation.
  I2C Software Master Driver:
  ===========================
  Each i2c cycle is split into 4 sections. Each of these section marks
  a point in time where the SCL or SDA may be changed.
  1 Cycle == |  Section I. |  Section 2. |  Section 3. |  Section 4. |
             +-------------+-------------+-------------+-------------+
             | SCL set LOW |SCL no change| SCL set HIGH|SCL no change|
                                           ____________ _____________
  SCL == XXXX _____________ ____________ 
  I.e. the SCL may only be changed in section 1. and section 3. while
  the SDA may only be changed in section 2. and section 4. The table
  below gives the changes for these 2 lines in the varios sections.
  Section changes Table:
  ======================
  blank = no change, L = set bit LOW, H = set bit HIGH
                                 | 1.| 2.| 3.| 4.|
                  ---------------+---+---+---+---+
                  Tx Start   SDA |   | H |   | L |
                             SCL | L |   | H |   |
                  ---------------+---+---+---+---+
                  Tx Stop    SDA |   | L |   | H |
                             SCL | L |   | H |   |
                  ---------------+---+---+---+---+
                  Tx bit H   SDA |   | H |   |   |
                             SCL | L |   | H |   |
                  ---------------+---+---+---+---+
                  Tx bit L   SDA |   | L |   |   |
                             SCL | L |   | H |   |
                  ---------------+---+---+---+---+
 GPIO pins used for this I2C. It ranges from 0 to 63. 
   Below is the variable declaration for the GPIO pin register usage
   for the i2c Clock and i2c Data.
   Note:
       Notice that the GPIO usage for the i2c clock and i2c Data are
       separated. This is to make this code flexible enough when
       two separate GPIO pins for the clock and data are located
       in two different GPIO register set (worst case).
 i2c Clock GPIO Register usage 
 i2c Data GPIO Register usage 
   This function puts a delay between command
	 find a bug:
	  peekIO method works well before suspendresume
	  but after suspend, peekIO(0x3ce,0x61) & 0x10
	  always be non-zero,which makes the while loop
	  never finish.
	  use non-ultimate for loop below is safe
     Change wait algorithm to use PCI bus clock,
      it's more reliable than counter loop ..
      write 0x61 to 0x3ce and read from 0x3cf
   This function setreset the SCL GPIO pin
   Parameters:
       value    - Bit value to set to the SCL or SDA (0 = low, 1 = high)
   Notes:
       When setting SCL to high, just set the GPIO as input where the pull up
       resistor will pull the signal up. Do not use software to pull up the
       signal because the i2c will fail when other device try to drive the
       signal due to SM50x will drive the signal to always high.
 High 
		
		  Set direction as input. This will automatically
		  pull the signal up.
 Low 
 Set the signal down 
 Set direction as output 
   This function setreset the SDA GPIO pin
   Parameters:
       value    - Bit value to set to the SCL or SDA (0 = low, 1 = high)
   Notes:
       When setting SCL to high, just set the GPIO as input where the pull up
       resistor will pull the signal up. Do not use software to pull up the
       signal because the i2c will fail when other device try to drive the
       signal due to SM50x will drive the signal to always high.
 High 
		
		  Set direction as input. This will automatically
		  pull the signal up.
 Low 
 Set the signal down 
 Set direction as output 
   This function read the data from the SDA GPIO pin
   Return Value:
       The SDA data bit sent by the Slave
 Make sure that the direction is input (High) 
 Now read the SDA line 
   This function sends ACK signal
 Single byte read is ok without it. 
   This function sends the start command to the slave device
 Start I2C 
   This function sends the stop command to the slave device
 Stop the I2C 
   This function writes one byte to the slave device
   Parameters:
       data    - Data to be write to the slave device
   Return Value:
        0   - Success
       -1   - Fail to write byte
 Sending the data bit by bit 
 Set SCL to low 
 Send data bit 
 Toggle clk line to one 
 Shift byte to be sent 
 Set the SCL Low and SDA High (prepare to get input) 
 Set the SCL High for ack 
 Read SDA, until SDA==0 
 Set the SCL Low and SDA High 
   This function reads one byte from the slave device
   Parameters:
       ack    - Flag to indicate either to send the acknowledge
             message to the slave device or not
   Return Value:
       One byte data read from the Slave device
 Set the SCL to Low and SDA to High (Input) 
 Set the SCL High 
 Read data bits from SDA 
 Set the SCL Low and SDA High 
  This function initializes GPIO port for SW I2C communication.
  Parameters:
       clk_gpio      - The GPIO pin to be used as i2c SCL
       data_gpio     - The GPIO pin to be used as i2c SDA
  Return Value:
       -1   - Fail to initialize the i2c
        0   - Success
 Initialize the GPIO pin for the i2c Clock Register 
 Initialize the Clock GPIO Offset 
 Initialize the GPIO pin for the i2c Data Register 
 Initialize the Data GPIO Offset 
 Note that SM750LE don't have GPIO MUX and power is always on 
 Clear the i2c lines. 
  This function initializes the i2c attributes and bus
  Parameters:
       clk_gpio      - The GPIO pin to be used as i2c SCL
       data_gpio     - The GPIO pin to be used as i2c SDA
  Return Value:
       -1   - Fail to initialize the i2c
        0   - Success
	
	  Return 0 if the GPIO pins to be used is out of range. The
	  range is only from [0..63]
 Initialize the GPIO pin for the i2c Clock Register 
 Initialize the Clock GPIO Offset 
 Initialize the GPIO pin for the i2c Data Register 
 Initialize the Data GPIO Offset 
 Enable the GPIO pins for the i2c Clock and Data (GPIO MUX) 
 Enable GPIO power 
 Clear the i2c lines. 
   This function reads the slave device's register
   Parameters:
       addr   - i2c Slave device address which register
                         to be read from
       reg    - Slave device's register to be read
   Return Value:
       Register value
 Send the Start signal 
 Send the device address 
 Send the register index 
 Get the bus again and get the data from the device read address 
 Stop swI2C and release the bus 
   This function writes a value to the slave device's register
   Parameters:
       addr            - i2c Slave device address which register
                         to be written
       reg             - Slave device's register to be written
       data            - Data to be written to the register
   Result:
           0   - Success
          -1   - Fail
 Send the Start signal 
	 Send the device address and read the data. All should return success
	  in order for the writing processed to be successful
 Stop i2c and release the bus 
 SPDX-License-Identifier: GPL-2.0
 I2C Address of each SII164 chip 
 Define this definition to use hardware i2c. 
 SII164 Vendor and Device ID 
 Name of the DVI Controller chip 
   sii164GetVendorID
       This function gets the vendor ID of the DVI controller chip.
   Output:
       Vendor ID
   sii164GetDeviceID
       This function gets the device ID of the DVI controller chip.
   Output:
       Device ID
   DVI.C will handle all SiI164 chip stuffs and try its best to make code
   minimal and useful
   sii164InitChip
       This function initialize and detect the DVI controller chip.
   Input:
       edge_select           - Edge Select:
                                0 = Input data is falling edge latched (falling
                                    edge latched first in dual edge mode)
                                1 = Input data is rising edge latched (rising
                                    edge latched first in dual edge mode)
       bus_select            - Input Bus Select:
                                0 = Input data bus is 12-bits wide
                                1 = Input data bus is 24-bits wide
       dual_edge_clk_select  - Dual Edge Clock Select
                                0 = Input data is single edge latched
                                1 = Input data is dual edge latched
       hsync_enable          - Horizontal Sync Enable:
                                0 = HSYNC input is transmitted as fixed LOW
                                1 = HSYNC input is transmitted as is
       vsync_enable          - Vertical Sync Enable:
                                0 = VSYNC input is transmitted as fixed LOW
                                1 = VSYNC input is transmitted as is
       deskew_enable         - De-skewing Enable:
                                0 = De-skew disabled
                                1 = De-skew enabled
       deskew_setting        - De-skewing Setting (increment of 260psec)
                                0 = 1 step --> minimum setup  maximum hold
                                1 = 2 step
                                2 = 3 step
                                3 = 4 step
                                4 = 5 step
                                5 = 6 step
                                6 = 7 step
                                7 = 8 step --> maximum setup  minimum hold
       continuous_sync_enable- SYNC Continuous:
                                0 = Disable
                                1 = Enable
       pll_filter_enable     - PLL Filter Enable
                                0 = Disable PLL Filter
                                1 = Enable PLL Filter
       pll_filter_value      - PLL Filter characteristics:
                                0~7 (recommended value is 4)
   Output:
       0   - Success
      -1   - Fail.
 Initialize the i2c bus 
 Use fast mode. 
 Check if SII164 Chip exists 
		
		   Initialize SII164 controller chip.
 Select the edge 
 Select bus wide 
 Select DualSingle Edge Clock 
 Select HSync Enable 
 Select VSync Enable 
		
		  De-skew enabled with default 111b value.
		  This fixes some artifacts problem in some mode on board 2.2.
		  Somehow this fix does not affect board 2.1.
 EnableDisable Continuous Sync. 
 EnableDisable PLL Filter 
 Set the PLL Filter value 
 Recover from Power Down and enable output. 
 Return -1 if initialization fails. 
 below sii164 function is not necessary 
   sii164ResetChip
       This function resets the DVI Controller Chip.
 Power down 
  sii164GetChipString
       This function returns a char string name of the current DVI Controller
       chip.
       It's convenient for application need to display the chip name.
   sii164SetPower
       This function sets the power configuration of the DVI Controller Chip.
   Input:
       powerUp - Flag to set the power down or up
 Power up the chip 
 Power down the chip 
   sii164SelectHotPlugDetectionMode
       This function selects the mode of the hot plug detection.
   sii164EnableHotPlugDetection
       This function enables the Hot Plug detection.
   enableHotPlug   - Enable (=1)  disable (=0) Hot Plug detection
	 Depending on each DVI controller, need to enable the hot plug based
	  on each individual chip design.
   sii164IsConnected
       Check if the DVI Monitor is connected.
   Output:
       0   - Not Connected
       1   - Connected
   sii164CheckInterrupt
       Checks if interrupt has occurred.
   Output:
       0   - No interrupt
       1   - Interrupt occurs
   sii164ClearInterrupt
       Clear the hot plug interrupt.
 Clear the MDI interrupt 
 SPDX-License-Identifier: GPL-2.0
  SM750LE only:
  This function takes care extra registers and bit fields required to set
  up a mode in SM750LE
  Explanation about Display Control register:
  HW only supports 7 predefined pixel clocks, and clock select is
  in bit 29:27 of Display Control register.
	
	  SM750LE has to set up the top-left and bottom-right
	  registers as well.
	  Note that normal SM750SM718 only use those two register for
	  auto-centering mode.
	
	  Assume common fields in dispControl have been properly set before
	  calling this function.
	  This function only sets the extra fields in dispControl.
 Clear bit 29:27 of display control register 
 Set bit 29:27 of display control register for the right clock 
 Note that SM750LE only need to supported 7 resolutions. 
 default to VGA clock 
 Set bit 25:24 of display controller 
 Set bit 14 of display controller 
 only timing related registers will be  programed 
 programe secondary pixel clock 
		
		  May a hardware bug or just my test chip (not confirmed).
		  PANEL_DISPLAY_CTRL register seems requiring few writes
		  before a value can be successfully written in.
		  Added some masks to mask out the reserved bits.
		  Note: This problem happens by design. The hardware will wait
		        for the next vertical sync to turn onoff the plane.
 set graphic mode via IO method 
 SPDX-License-Identifier: GPL-2.0
 Enable GPIO 30 & 31 as IIC clock & data 
	
	  Enable Hardware I2C power.
	  TODO: Check if we need to enable GPIO power?
 Enable the I2C Controller and set the bus speed mode 
 Disable I2C controller 
 Disable I2C Power 
 Set GPIO 30 & 31 back as GPIO pins 
 Wait until the transfer is completed. 
   This function writes data to the i2c slave device registers.
   Parameters:
       addr            - i2c Slave device address
       length          - Total number of bytes to be written to the device
       buf             - The buffer that contains the data to be written to the
                      i2c device.
   Return Value:
       Total number of bytes those are actually written.
 Set the Device Address 
	
	  Write data.
	  Note:
	       Only 16 byte can be accessed per i2c start instruction.
		
		  Reset I2C by writing 0 to I2C_RESET register to
		  clear the previous status.
 Set the number of bytes to be written 
 Move the data to the I2C data register 
 Start the I2C 
 Wait until the transfer is completed. 
 Subtract length 
 Total byte written 
   This function reads data from the slave device and stores them
   in the given buffer
   Parameters:
       addr            - i2c Slave device address
       length          - Total number of bytes to be read
       buf             - Pointer to a buffer to be filled with the data read
                      from the slave device. It has to be the same size as the
                      length to make sure that it can keep all the data read.
   Return Value:
       Total number of actual bytes read from the slave device
 Set the Device Address 
	
	  Read data and save them to the buffer.
	  Note:
	       Only 16 byte can be accessed per i2c start instruction.
		
		  Reset I2C by writing 0 to I2C_RESET register to
		  clear all the status.
 Set the number of bytes to be read 
 Start the I2C 
 Wait until transaction done. 
 Save the data to the given buffer 
 Subtract length by 16 
 Number of bytes read. 
   This function reads the slave device's register
   Parameters:
       deviceAddress   - i2c Slave device address which register
                         to be read from
       registerIndex   - Slave device's register to be read
   Return Value:
       Register value
   This function writes a value to the slave device's register
   Parameters:
       deviceAddress   - i2c Slave device address which register
                         to be written
       registerIndex   - Slave device's register to be written
       data            - Data to be written to the register
   Result:
           0   - Success
          -1   - Fail
 SPDX-License-Identifier: GPL-2.0
  Staging board support for Armadillo 800 eva.
  Enable not-yet-DT-capable devices here.
  Based on board-armadillo800eva.c
  Copyright (C) 2012 Renesas Solutions Corp.
  Copyright (C) 2012 Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
 SPDX-License-Identifier: GPL-2.0
 Staging board support for KZM9D. Enable not-yet-DT-capable devices here. 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2014 Magnus Damm
  Copyright (C) 2015 Glider bvba
 DT node available 
 Nothing found 
 Initialization similar to device_pm_init_common() 
 SPDX-License-Identifier: GPL-2.0
  Xilinx AXIS FIFO: interface to the Xilinx AXI-Stream FIFO IP core
  Copyright (C) 2018 Jacob Feder
  Authors:  Jacob Feder <jacobsfeder@gmail.com>
  See Xilinx PG080 document for IP details
 ----------------------------
            includes
  ----------------------------
 ----------------------------
        driver parameters
  ----------------------------
 read buffer length in words 
 write buffer length in words 
 ----------------------------
      IP register offsets
  ----------------------------
 Interrupt Status 
 Interrupt Enable 
 Transmit Reset 
 Transmit Vacancy 
 Transmit Data 
 Transmit Length 
 Receive Reset 
 Receive Occupancy 
 Receive Data 
 Receive Length 
 Local Link Reset 
 Transmit Destination 
 Receive Destination 
 ----------------------------
      reset register masks
  ----------------------------
 receive reset value 
 Transmit reset value 
 Local Link reset value 
 ----------------------------
        interrupt masks
  ----------------------------
 Receive under-read 
 Receive over-read 
 Receive underrun (empty) 
 Transmit overrun 
 Transmit complete 
 Receive complete 
 Transmit length mismatch 
 Transmit reset complete 
 Receive reset complete 
 Tx FIFO Programmable Full 
 Tx FIFO Programmable Empty 
 Rx FIFO Programmable Full 
 Rx FIFO Programmable Empty 
 All the ints 
 Error status ints 
 Receive Error status ints 
 Transmit Error status ints 
 ----------------------------
            globals
  ----------------------------
 ms to wait before read() times out 
 ms to wait before write() times out 
 ----------------------------
  module command-line arguments
  ----------------------------
 ----------------------------
             types
  ----------------------------
 interrupt 
 kernel space memory 
 max words in the receive fifo 
 max words in the transmit fifo 
 whether the IP has the rx fifo enabled 
 whether the IP has the tx fifo enabled 
 wait queue for asynchronos read 
 lock for reading 
 wait queue for asynchronos write 
 lock for writing 
 write file flags 
 read file flags 
 device created from the device tree 
 ----------------------------
          sysfs entries
  ----------------------------
 ----------------------------
         implementation
  ----------------------------
  axis_fifo_read() - Read a packet from AXIS-FIFO character device.
  @f: Open file.
  @buf: User space buffer to read to.
  @len: User space buffer length.
  @off: Buffer offset.
  As defined by the device's documentation, we need to check the device's
  occupancy before reading the length register and then the data. All these
  operations must be executed atomically, in order and one after the other
  without missing any.
  Returns the number of bytes read from the device or negative error code
 	on failure.
		
		  Device opened in non-blocking mode. Try to lock it and then
		  check if any packet is available.
		 opened in blocking mode
		  wait for a packet available interrupt (or timeout)
		  if nothing is currently available
		 this probably can't happen unless IP
		  registers were previously mishandled
	 read data into an intermediate buffer, copying the contents
	  to userspace when the buffer is full
  axis_fifo_write() - Write buffer to AXIS-FIFO character device.
  @f: Open file.
  @buf: User space buffer to write to the device.
  @len: User space buffer length.
  @off: Buffer offset.
  As defined by the device's documentation, we need to write to the device's
  data buffer then to the device's packet length register atomically. Also,
  we need to lock before checking if the device has available space to avoid
  any concurrency issue.
  Returns the number of bytes written to the device or negative error code
 	on failure.
		
		  Device opened in non-blocking mode. Try to lock it and then
		  check if there is any room to write the given buffer.
 opened in blocking mode 
		 wait for an interrupt (or timeout) if there isn't
		  currently enough room in the fifo
	 write data from an intermediate buffer into the fifo IP, refilling
	  the buffer with userspace data as needed
 write packet size to fifo 
 packet received 
 wake the reader process if it is waiting 
 clear interrupt 
 packet sent 
 wake the writer process if it is waiting 
 transmit fifo programmable full 
 transmit fifo programmable empty 
 receive fifo programmable full 
 receive fifo programmable empty 
 transmit reset complete interrupt 
 receive reset complete interrupt 
 receive fifo under-read error interrupt 
 receive over-read error interrupt 
 receive underrun error interrupt 
 transmit overrun error interrupt 
 transmit length mismatch error interrupt 
 unknown interrupt type 
 read named property from the device tree 
 IP sets TDFV to fifo depth - 4 so we will do the same 
 interrupt resources 
 IO mem resources 
 OS device (from device tree) 
 error return value 
	 ----------------------------
	      init wrapper device
	  ----------------------------
 allocate device wrapper memory 
	 ----------------------------
	    init device memory space
	  ----------------------------
 get iospace for the device 
 request physical memory 
 create unique device name 
	 ----------------------------
	           init IP
	  ----------------------------
	 ----------------------------
	     init device interrupts
	  ----------------------------
 get IRQ resource 
 request IRQ 
	 ----------------------------
	       init char device
	  ----------------------------
 create character device 
 SPDX-License-Identifier: GPL-2.0
  nvec_ps2: mouse driver for a NVIDIA compliant embedded controller
  Copyright (C) 2011 The AC100 Kernel Team <ac100@lists.launchpad.net>
  Authors:  Pierre-Hugues Husson <phhusson@free.fr>
            Ilya Petrov <ilya.muromec@gmail.com>
            Marc Dietrich <marvin24@gmx.de>
 !ack 
 disable mouse 
 send cancel autoreceive 
 start streaming 
 enable mouse 
 SPDX-License-Identifier: GPL-2.0
  nvec_power: power supply driver for a NVIDIA compliant embedded controller
  Copyright (C) 2011 The AC100 Kernel Team <ac100@lists.launchpad.net>
  Authors:  Ilya Petrov <ilya.muromec@gmail.com>
            Marc Dietrich <marvin24@gmx.de>
 payload 
		
		  This differs a little from the spec fill in more if you find
		  some.
 AC status via sys req 
	
	  Select a battery request function via round robin doing it all at
	  once seems to overload the power supply.
 SPDX-License-Identifier: GPL-2.0
  nvec_kbd: keyboard driver for a NVIDIA compliant embedded controller
  Copyright (C) 2011 The AC100 Kernel Team <ac100@lists.launchpad.net>
  Authors:  Pierre-Hugues Husson <phhusson@free.fr>
            Marc Dietrich <marvin24@gmx.de>
 should be BIT(0) only, firmware bug? 
 power onoff button 
 Enable keyboard 
 configures wake on special keys 
 enable wake key reporting 
 Disable caps lock LED 
 SPDX-License-Identifier: GPL-2.0
  NVEC: NVIDIA compliant embedded controller interface
  Copyright (C) 2011 The AC100 Kernel Team <ac100@lists.lauchpad.net>
  Authors:  Pierre-Hugues Husson <phhusson@free.fr>
            Ilya Petrov <ilya.muromec@gmail.com>
            Marc Dietrich <marvin24@gmx.de>
            Julian Andres Klode <jak@jak-linux.org>
  enum nvec_msg_category - Message categories for nvec_msg_alloc()
  @NVEC_MSG_RX: The message is an incoming message (from EC)
  @NVEC_MSG_TX: The message is an outgoing message (to EC)
  nvec_register_notifier - Register a notifier with nvec
  @nvec: A &struct nvec_chip
  @nb: The notifier block to register
  @events: Unused
  Registers a notifier with @nvec. The notifier will be added to an atomic
  notifier chain that is called for all received messages except those that
  correspond to a request initiated by nvec_write_sync().
  nvec_unregister_notifier - Unregister a notifier with nvec
  @nvec: A &struct nvec_chip
  @nb: The notifier block to unregister
  Unregisters a notifier with @nvec. The notifier will be removed from the
  atomic notifier chain.
  nvec_status_notifier - The final notifier
  Prints a message about control events not handled in the notifier
  chain.
  nvec_msg_alloc:
  @nvec: A &struct nvec_chip
  @category: Pool category, see &enum nvec_msg_category
  Allocate a single &struct nvec_msg object from the message pool of
  @nvec. The result shall be passed to nvec_msg_free() if no longer
  used.
  Outgoing messages are placed in the upper 75% of the pool, keeping the
  lower 25% available for RX buffers only. The reason is to prevent a
  situation where all buffers are full and a message is thus endlessly
  retried because the response could never be processed.
  nvec_msg_free:
  @nvec: A &struct nvec_chip
  @msg:  A message (must be allocated by nvec_msg_alloc() and belong to @nvec)
  Free the given message
  nvec_msg_is_event - Return %true if @msg is an event
  @msg: A message
  nvec_msg_size - Get the size of a message
  @msg: The message to get the size for
  This only works for received messages, not for outgoing messages.
 for variable size, payload size in byte 1 + count (1) + cmd (1) 
  nvec_gpio_set_value - Set the GPIO value
  @nvec: A &struct nvec_chip
  @value: The value to write (0 or 1)
  Like gpio_set_value(), but generating debugging information
  nvec_write_async - Asynchronously write a message to NVEC
  @nvec: An nvec_chip instance
  @data: The message data, starting with the request type
  @size: The size of @data
  Queue a single message to be transferred to the embedded controller
  and return immediately.
  Returns: 0 on success, a negative error code on failure. If a failure
  occurred, the nvec driver may print an error.
  nvec_write_sync - Write a message to nvec and read the response
  @nvec: An &struct nvec_chip
  @data: The data to write
  @size: The size of @data
  @msg:  The response message received
  This is similar to nvec_write_async(), but waits for the
  request to be answered before returning. This function
  uses a mutex and can thus not be called from e.g.
  interrupt handlers.
  Returns: 0 on success, a negative error code on failure.
  The response message is returned in @msg. Shall be freed
  with nvec_msg_free() once no longer used.
  nvec_toggle_global_events - enables or disables global event reporting
  @nvec: nvec handle
  @state: true for enable, false for disable
  This switches onoff global event reports by the embedded controller.
  nvec_event_mask - fill the command string with event bitfield
  @ev: points to event command string
  @mask: bit to insert into the event mask
  Configure event command expects a 32 bit bitfield which describes
  which events to enable. The bitfield has the following structure
  (from highest byte to lowest):
 	system state bits 7-0
 	system state bits 15-8
 	oem system state bits 7-0
 	oem system state bits 15-8
  nvec_request_master - Process outgoing messages
  @work: A &struct work_struct (the tx_worker member of &struct nvec_chip)
  Processes all outgoing requests by sending the request and awaiting the
  response, then continuing with the next request. Once a request has a
  matching response, it will be freed and removed from the list.
  parse_msg - Print some information and call the notifiers on an RX message
  @nvec: A &struct nvec_chip
  @msg: A message received by @nvec
  Paarse some pieces of the message and then call the chain of notifiers
  registered via nvec_register_notifier.
  nvec_dispatch - Process messages received from the EC
  @work: A &struct work_struct (the tx_worker member of &struct nvec_chip)
  Process messages previously received from the EC and put into the RX
  queue of the &struct nvec_chip instance associated with @work.
  nvec_tx_completed - Complete the current transfer
  @nvec: A &struct nvec_chip
  This is called when we have received an END_TRANS on a TX transfer.
 We got an END_TRANS, let's skip this, maybe there's an event 
  nvec_rx_completed - Complete the current transfer
  @nvec: A &struct nvec_chip
  This is called when we have received an END_TRANS on a RX transfer.
 Battery quirk - Often incomplete, and likes to crash 
	
	  Add the received data to the work list and move the ring buffer
	  pointer to the next entry.
  nvec_invalid_flags - Send an error message about invalid flags and jump
  @nvec: The nvec device
  @status: The status flags
  @reset: Whether we shall jump to state 0.
  nvec_tx_set - Set the message to transfer (nvec->tx)
  @nvec: A &struct nvec_chip
  Gets the first entry from the tx_data list of @nvec and sets the
  tx member to it. If the tx_data list is empty, this uses the
  tx_scratch message to send a no operation message.
  nvec_interrupt - Interrupt handler
  @irq: The IRQ
  @dev: The nvec device
  Interrupt handler that fills our RX buffers and empties our TX
  buffers. This uses a finite state machine with ridiculous amounts
  of error checking, in order to be fairly reliable.
 Filter out some errors 
 The EC did not request a read, so it send us something, read it 
 Verify that its a transfer start, the rest later 
 command byte 
 Should not happen in a normal world 
 first byte after command 
 EC does a block read, we transmit data 
 EC does some write, we read the data 
 If we are told that a new transfer starts, verify it 
 Send data if requested, but not on end of transmission 
 If we have send the first byte 
	
	  TODO: A correct fix needs to be found for this.
	 
	  We experience less incomplete messages with this delay than without
	  it, but we don't know why. Help is appreciated.
 enable event reporting 
 Get Firmware Version 
 unmute speakers? 
 enable lid switch event 
 enable power button event 
 FIXME: needs check whether nvec is responsible for power off 
 keep these sync or you'll break suspend 
 Match table for of_platform binding 
 SPDX-License-Identifier: GPL-2.0
  nvec_paz00: OEM specific driver for Compal PAZ00 based devices
  Copyright (C) 2011 The AC100 Kernel Team <ac100@lists.launchpad.net>
  Authors:  Ilya Petrov <ilya.muromec@gmail.com>
 to expose the default value to userspace 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the ILI9486 LCD Controller
  Copyright (C) 2014 Noralf Tronnes
 this init sequence matches PiScreen 
 Interface Mode Control 
 Interface Pixel Format 
 Power Control 3 
 VCOM Control 1 
 PGAMCTRL(Positive Gamma Control) 
 NGAMCTRL(Negative Gamma Control) 
 Digital Gamma Control 1 
 end marker 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the SH1106 OLED Controller
  Based on the SSD1306 driver by Noralf Tronnes
  Copyright (C) 2017 Heiner Kallweit
 Init sequence based on the Adafruit SSD1306 Arduino library 
 Set Display OFF 
 Set Display Clock Divide Ratio Oscillator Frequency 
 Set Multiplex Ratio 
 Set Display Offset 
 Set Display Start Line 
 Set Segment Re-map 
 column address 127 is mapped to SEG0 
 Set COM Output Scan Direction 
 remapped mode. Scan from COM[N-1] to COM0 
 Set COM Pins Hardware Configuration 
 A[4]=1b, Alternative COM pin configuration 
 A[4]=1b, Alternative COM pin configuration 
 A[4]=0b, Sequential COM pin configuration 
 Set Pre-charge Period 
 Set VCOMH Deselect Level 
 Set Display ON 
 Gamma is used to control Contrast 
 apply mask 
 Set Contrast Control for BANK0 
 offset refers to vmem with 2 bytes element size 
 set page and set column to 2 because of vidmem width 132 
 Write data 
 keep DC low for all command bytes to transfer 
 set default contrast to 0xcd = 80% 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the UC1701 LCD Controller
  The display is monochrome and the video memory is RGB565.
  Any pixel value except 0 turns the pixel on.
  Copyright (C) 2014 Juergen Holzmann
 1: Display onoff 
 2: display start line set 
 3: Page address set (lower 4 bits select one of the pages) 
 4: column address 
 8: select orientation 
 9: inverted display 
 10: show memory content or switch all pixels on 
 11: lcd bias set 
 14: Reset Controller 
 15: output mode select (turns display upside-down) 
 16: power control set 
 17: voltage regulator resistor ratio set 
 18: Volume mode set 
 22: NOP command 
 25: advanced program control 
 25: advanced program control2 
 column offset for normal orientation 
 column offset for bottom view orientation 
 softreset of LCD 
 set startpoint 
 select orientation BOTTOMVIEW 
 output mode select (turns display upside-down) 
 Normal Pixel mode 
 positive display 
 bias 19 
 power control mode: all features on 
 set voltage regulator RR 
 volume mode set 
 advanced program control 
 enable display 
 goto address 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the SSD1306 OLED Controller
  Copyright (C) 2013 Noralf Tronnes
  write_reg() caveat:
  This doesn't work because DC has to be LOW for both values:
  write_reg(par, val1, val2);
  Do it like this:
  write_reg(par, val1);
  write_reg(par, val2);
 Init sequence taken from the Adafruit SSD1306 Arduino library 
 Set Display OFF 
 Set Display Clock Divide Ratio Oscillator Frequency 
 Set Multiplex Ratio 
 Set Display Offset 
 Set Display Start Line 
 Charge Pump Setting 
 A[2] = 1b, Enable charge pump during display on 
 Set Memory Addressing Mode 
 Vertical addressing mode  
 Set Segment Re-map 
 column address 127 is mapped to SEG0 
 Set COM Output Scan Direction 
 remapped mode. Scan from COM[N-1] to COM0 
 Set COM Pins Hardware Configuration 
 A[4]=1b, Alternative COM pin configuration 
 A[4]=1b, Alternative COM pin configuration 
 A[4]=0b, Sequential COM pin configuration 
 Set Pre-charge Period 
 Set VCOMH Deselect Level 
 according to the datasheet, this value is out of bounds 
 Entire Display ON 
 Resume to RAM content display. Output follows RAM content 
	 Set Normal Display
	  0 in RAM: OFF in display panel
	  1 in RAM: ON in display panel
 Set Display ON 
 Set Column Address 
 Set Page Address 
 Set Lower Column Start Address for Page Addressing Mode 
 Set Higher Column Start Address for Page Addressing Mode 
 Set Display Start Line 
 Gamma is used to control Contrast 
 apply mask 
 Set Contrast Control for BANK0 
 Write data 
 SPDX-License-Identifier: GPL-2.0
 module uses onboard GPIO for panel power 
 Command Lock 
 Command Lock 
 Display Off 
 Front Clock Div 
 Set Mux Ratio 
 Set Column Address 
 Set Row Address 
 Set Display Start Line 
 Set Display Offset 
 Set GPIO 
 Set Function Selection 
 Set Phase Length 
 Set Segment Low Voltage 
 Set Precharge Voltage 
 Set VComH Voltage 
 Set Contrast 
 Set Master Contrast 
 Set Second Precharge Period 
 Set Display Mode Reset 
 Set Sleep Mode Display On 
 don't risk messing up register A0h 
 Set Colour Depth 
  Grayscale Lookup Table
  GS1 - GS63
  The driver Gamma curve contains the relative values between the entries
  in the Lookup table.
  From datasheet:
  8.8 Gray Scale Decoder
 	there are total 180 Gamma Settings (Setting 0 to Setting 180)
 	available for the Gray Scale table.
 	The gray scale is defined in incremental way, with reference
 	to the length of previous table entry:
 		Setting of GS1 has to be >= 0
 		Setting of GS2 has to be > Setting of GS1 +1
 		Setting of GS3 has to be > Setting of GS2 +1
 		:
 		Setting of GS63 has to be > Setting of GS62 +1
 Onboard backlight connected to GPIO0 on SSD1351, GPIO1 unused 
 SPDX-License-Identifier: GPL-2.0
  FB driver for the NHD-1.69-160128UGC3 (Newhaven Display International, Inc.)
  using the SEPS525 (Syncoam) LCD Controller
  Copyright (C) 2016 Analog Devices Inc.
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 SEPS525_DISPLAYMODE_SET 
 FBTFT doesn't really use it today 
 Init sequence taken from: Arduino Library for the Adafruit 2.2" display 
 Disable Oscillator Power Down 
 Set Normal Driving Current 
 Set EXPORT1 Pin at Internal Clock 
 Set Clock as 120 FramesSec 
 Set Reference Voltage Controlled by External Resister 
 precharge time R G B 
 precharge current R G B (uA) 
 driving current R G B (uA) 
 Set Color Sequence 
 Set MCU Interface Mode 
 Set Memory Write Mode 
 1128 Duty (0x0F~0x7F) 
 Set Mapping RAM Display Start Line (0x00~0x7F) 
 Display On (0x000x01) 
 Set All Internal Register Value as Normal Mode 
 Set RGB Interface Polarity as Active Low 
 Set Window Xs,Ys Xe,Ye
 start position X,Y 
 Memory Access Control  
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2013 Noralf Tronnes
  This driver is inspired by:
    st7735fb.c, Copyright (C) 2011, Matt Porter
    broadsheetfb.c, Copyright (C) 2008, Jaya Kumar
 Assume backlight is off, get polarity from current state of pin 
 Activate chip 
 Sanity checks 
 special case, needed ? 
 Mark display linesarea as dirty 
 Schedule deferred_io to update display (no-op if already on queue)
 set display line markers as clean 
 Mark display lines as dirty 
 TODO: only mark changed area update all for now 
 from pxafb.c 
  fbtft_framebuffer_alloc - creates a new frame buffer info structure
  @display: pointer to structure describing the display
  @dev: pointer to the device for this fb, this can be NULL
  @pdata: platform data for the display in use
  Creates a new frame buffer info structure.
  Also creates and populates the following structures:
    info->fbops
    info->fbdefio
    info->pseudo_palette
    par->fbtftops
    par->txbuf
  Returns the new structure, or NULL if an error occurred.
 sanity check 
 defaults 
 override driver values? 
 RGB565 
 Transmit buffer 
 add in case startbyte is used 
 need buffer for byteswapping 
 default fbtft operations 
 use driver provided functions 
  fbtft_framebuffer_release - frees up all memory used by the framebuffer
  @info: frame buffer info structure
 	fbtft_register_framebuffer - registers a tft frame buffer device
 	@fb_info: frame buffer info structure
   Sets SPI driverdata if needed
   Requests needed gpios.
   Initializes display
   Updates display.
 	Registers a frame buffer device @fb_info.
 	Returns negative errno on error, or zero for success.
 sanity checks 
 update the entire display 
 Turn on backlight if available 
 	fbtft_unregister_framebuffer - releases a tft frame buffer device
 	@fb_info: frame buffer info structure
   Frees SPI driverdata if needed
   Frees gpios.
 	Unregisters frame buffer device.
  fbtft_init_display_from_property() - Device Tree init_display() function
  @par: Driver data
  Return: 0 if successful, negative if error
 make debug message 
  fbtft_init_display() - Generic init_display() function
  @par: Driver data
  Uses par->init_sequence to do the initialization
  Return: 0 if successful, negative if error
 sanity check 
 make sure stop marker exists 
 done 
 make debug message 
 Write 
  fbtft_verify_gpios() - Generic verify_gpios() function
  @par: Driver data
  Uses @spi, @pdev and @buswidth to determine which GPIOs is needed
  Return: 0 if successful, negative if error
 returns 0 if the property is not present 
  fbtft_probe_common() - Generic device probe() helper function
  @display: Display properties
  @sdev: SPI device
  @pdev: Platform device
  Allocates, initializes and registers a framebuffer
  Either @sdev or @pdev should be NULL
  Return: 0 if successful, negative if error
 write register functions 
 write_vmem() functions 
 GPIO write() functions 
 9-bit SPI setup 
 allocate buffer with room for dc bits 
 make sure we still use the driver provided functions 
 use init_sequence if provided 
 use platform_data provided functions above all 
  fbtft_remove_common() - Generic device remove() helper function
  @dev: Device
  @info: Framebuffer
  Unregisters and releases the framebuffer
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the HX8353D LCD Controller
  Copyright (c) 2014 Petr Olivka
  Copyright (c) 2013 Noralf Tronnes
 SETEXTC 
 RADJ 
 VCOM 
 PWR 
 COLMOD 
 MEM ACCESS 
 SLPOUT - Sleep out & booster on 
 DISPON - Display On 
 RGBSET 
 column address 
 Row address 
 memory write 
	
	  madctl - memory data access control
	    rgbbgr:
	    1. mode selection pin srgb
	 	rgb hw pin for color filter setting: 0=rgb, 1=bgr
	    2. madctl rgb bit
	 	rgb-bgr order color filter panel: 0=rgb, 1=bgr
 gamma string format: 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the SSD1289 LCD Controller
  Copyright (C) 2013 Noralf Tronnes
  Init sequence taken from ITDB02_Graph16.cpp - (C)2010-2011 Henning Karlsen
 R4Eh - Set GDDRAM X address counter 
 R4Fh - Set GDDRAM Y address counter 
 R22h - RAM data write 
 don't risk messing up register 11h 
  Gamma string format:
  VRP0 VRP1 PRP0 PRP1 PKP0 PKP1 PKP2 PKP3 PKP4 PKP5
  VRN0 VRN1 PRN0 PRN1 PKN0 PKN1 PKN2 PKN3 PKN4 PKN5
 apply mask 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the ILI9481 LCD Controller
  Copyright (c) 2014 Petr Olivka
  Copyright (c) 2013 Noralf Tronnes
 SLP_OUT - Sleep out 
 Power setting 
 VCOM 
 Power setting for norm. mode 
 Panel driving setting 
 Frame rate & inv. 
 Pixel format 
 Gamma 
 DISP_ON 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the ST7789V LCD Controller
  Copyright (C) 2015 Dennis Menschel
  enum st7789v_command - ST7789V display controller commands
  @PORCTRL: porch setting
  @GCTRL: gate control
  @VCOMS: VCOM setting
  @VDVVRHEN: VDV and VRH command enable
  @VRHS: VRH set
  @VDVS: VDV set
  @VCMOFSET: VCOM offset set
  @PWCTRL1: power control 1
  @PVGAMCTRL: positive voltage gamma control
  @NVGAMCTRL: negative voltage gamma control
  The command names are the same as those found in the datasheet to ease
  looking up their semantics and usage.
  Note that the ST7789V display controller offers quite a few more commands
  which have been omitted from this list as they are not used at the moment.
  Furthermore, commands that are compliant with the MIPI DCS have been left
  out as well to avoid duplicate entries.
 bitmask for RGBBGR order 
 bitmask for pagecolumn order 
 bitmask for column address order 
 bitmask for page address order 
 60Hz for 16.6ms, configured as 216.6ms 
 completion for panel TE line 
 Linux IRQ for LCD TE line 
  init_tearing_effect_line() - init tearing effect line.
  @par: FBTFT parameter object.
  Return: 0 on success, or a negative error code otherwise.
 if te is NULL, indicating no configuration, directly return success 
 GPIO is locked as an IRQ, we may drop the reference 
 The effective state is high and lasts no more than 1000 microseconds 
  init_display() - initialize the display controller
  @par: FBTFT parameter object
  Most of the commands in this init function set their parameters to the
  same default values which are already in place after the display has been
  powered up. (The main exception to this rule is the pixel format which
  would default to 18 instead of 16 bit per pixel.)
  Nonetheless, this sequence can be used as a template for concrete
  displays which usually need some adjustments.
  Return: 0 on success, < 0 if error occurred.
 turn off sleep mode 
 set pixel format to RGB-565 
	
	  VGH = 13.26V
	  VGL = -10.43V
	
	  VDV and VRH register values come from command write
	  (instead of NVM)
	
	  VAP =  4.1V + (VCOM + VCOM offset + 0.5  VDV)
	  VAN = -4.1V + (VCOM + VCOM offset + 0.5  VDV)
 VDV = 0V 
 VCOM = 0.9V 
 VCOM offset = 0V 
	
	  AVDD = 6.8V
	  AVCL = -4.8V
	  VDS = 2.3V
 TE line output is off by default when powering on 
  write_vmem() - write data to display.
  @par: FBTFT parameter object.
  @offset: offset from screen_buffer.
  @len: the length of data to be writte.
  Return: 0 on success, or a negative error code otherwise.
  set_var() - apply LCD properties like rotation and BGR mode
  @par: FBTFT parameter object
  Return: 0 on success, < 0 if error occurred.
  set_gamma() - set gamma curves
  @par: FBTFT parameter object
  @curves: gamma curves
  Before the gamma curves are applied, they are preprocessed with a bitmask
  to ensure syntactically correct input for the display controller.
  This implies that the curves input parameter might be changed by this
  function and that illegal gamma values are auto-corrected and not
  reported as errors.
  Return: 0 on success, < 0 if error occurred.
 curve index offset 
	
	  Bitmasks for gamma curve command parameters.
	  The masks are the same for both positive and negative voltage
	  gamma curves.
 V63[3:0], V0[3:0]
 V1[5:0] 
 V2[5:0] 
 V4[4:0] 
 V6[4:0] 
 J0[1:0], V13[3:0] 
 V20[6:0] 
 V36[2:0], V27[2:0] 
 V43[6:0] 
 J1[1:0], V50[3:0] 
 V57[4:0] 
 V59[4:0] 
 V61[5:0] 
 V62[5:0] 
  blank() - blank the display
  @par: FBTFT parameter object
  @on: whether to enable or disable blanking the display
  Return: 0 on success, < 0 if error occurred.
 SPDX-License-Identifier: GPL-2.0+
  FB driver for Two KS0108 LCD controllers in AGM1264K-FL display
  Copyright (C) 2014 ololoshka2871
 Uncomment text line to use negative image on display 
#define NEGATIVE
 because 2 x ks0108 in one display 
 diffusing error (Floyd-Steinberg) 
 display on 
 set x to 0 
 set page to 0 
 set start line to 0 
 Check if all necessary GPIOS defined 
 left ks0108 E pin 
 left ks0108 controller pin 
 right ks0108 controller pin 
 if write (rw = 0) e(1->0) perform write 
 if read (rw = 1) e(0->1) set data on D0-7
 This function oses to enter commands
  first byte - destination controller 0 or 1
  following - commands
 select chip 
 cs1 
 cs0 
 RS->0 (command mode) 
 save display writing zone 
 diffusion matrix row 
 diffusion matrix column 
 skip pixels out of zone 
 pixel itself 
 buffer to convert RGB565 -> grayscale16 -> Dithered image 1bpp 
 converting to grayscale16 
 gamma-correction by table 
 Image Dithering 
 what color close? 
 white 
 black 
 1 string = 2 pages 
 left half of display 
			 select left side (sc0)
			  set addr
 write bitmap 
 RS->1 (data mode) 
 right half of display 
			 select right side (sc1)
			  set addr
 write bitmap 
 RS->1 (data mode) 
 set write mode 
 set data bus 
 set E 
 unset E - write 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the SSD1325 OLED Controller
  write_reg() caveat:
     This doesn't work because DC has to be LOW for both values:
       write_reg(par, val1, val2);
     Do it like this:
       write_reg(par, val1);
       write_reg(par, val2);
 Init sequence taken from the Adafruit SSD1306 Arduino library 
  Grayscale Lookup Table
  GS1 - GS15
  The "Gamma curve" contains the relative values between the entries
  in the Lookup table.
  0 = Setting of GS1 < Setting of GS2 < Setting of GS3.....<
  Setting of GS14 < Setting of GS15
 Write data 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the Watterott LCD Controller
  Copyright (C) 2013 Noralf Tronnes
 Set command header. pos: x, y, w, h 
 Set command header. pos: x, y, w, h 
 enable SPI interface by having CS and MOSI low during reset 
	
	  Set CS active inverse polarity: just setting SPI_CS_HIGH does not
	  work with GPIO based chip selects that are logically active high
	  but inverted inside the GPIO library, so enforce inverted
	  semantics.
 make sure mode is set 
 not used on this controller 
 this controller rotates clock wise 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the uPD161704 LCD Controller
  Copyright (C) 2014 Seong-Woo Kim
  Based on fb_ili9325.c by Noralf Tronnes
  Based on ili9325.c by Jeroen Domburg
  Init code from UTFT library by Henning Karlsen
 Initialization sequence from Lib_UTFT 
 register reset 
 Soft reset 
 oscillator start 
Oscillator 0: stop, 1: operation 
 y-setting 
 amplitude setting 
 amplitude setting 
 amplitude setting 
 amplitude setting 
 circuit setting 1 
 circuit setting 2 
 adjustment V10 positive polarity 
 adjustment V9 negative polarity 
 adjustment V34 positive polarity 
 adjustment V31 negative polarity 
 adjustment V61 negative polarity 
 adjustment V61 negative polarity 
 Basical clock for 1 line (BASECOUNT[7:0]) number specified 
 Power supply setting 
 DCDC output setting 
 DCDC frequency setting 
 DCDC rising setting 
 Regulator voltage setting 
 Regulator current setting 
 VCOM output setting 
 VCOM amplitude setting 
 VCOMM cencter setting 
 DCDC operation setting 
 windows setting 
 Minimum X address 
 Maximum X address 
 Minimum Y address 
 Maximum Y address 
 LCD display area setting 
 [LCDSIZE]  X MIN. size set 
 [LCDSIZE]  Y MIN. size set 
 [LCDSIZE]  X MAX. size set 
 [LCDSIZE]  Y MAX. size set 
 Gate scan setting 
 n line inversion line number 
 Line inversionframe inversioninterlace setting 
 Gate scan operation setting register 
 Color mode 
GS = 0: 260-k color (64 gray scale), GS = 1: 8 color (2 gray scale) 
 RAM control register 
Window access 00:Normal, 10:Window 
 Display setting register 2 
 display setting 
 display on 
 R20h = Horizontal GRAM Start Address 
 R21h = Vertical GRAM Start Address 
 Write Data to GRAM 
 AM: GRAM update direction 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the HX8357D LCD Controller
  Copyright (C) 2015 Adafruit Industries
  Based on the HX8347D FB driver
  Copyright (C) 2013 Christian Vogelgsang
  Based on driver code found here: https:github.comwatterottr61505u-Adapter
 Reset things like Gamma 
 setextc 
 setRGB which also enables SDO 
 -1.52V 
 Normal mode 70Hz, Idle mode 55 Hz 
 Set Panel - BGR, Gate direction swapped 
 Not deep standby 
 BT 
 VSPR 
 VSNR 
 AP 
 FS 
 OPON normal 
 OPON idle 
 STBA 
 STBA 
 STBA 
 GEN 
 NW 0x02 
 RTN 
 DIV 
 DUM 
 DUM 
 GDON 
 GDOFF 
 16 bit 
 TE off 
 tear line 
 Exit Sleep 
 display on 
 XSTART 
 XEND 
 YSTART 
 YEND 
 Memory Access Control 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the ILI9163 LCD Controller
  Copyright (C) 2015 Kozhevnikov Anatoly
  Based on ili9325.c by Noralf Tronnes and
  .S.U.M.O.T.O.Y. by Max MC Costa (https:github.comsumotoyTFT_ILI9163C).
 ILI9163C commands 
 Frame Rate Control 
	(In normal modeFull colors) 
 Frame Rate Control (In Idle mode8-colors) 
 Frame Rate Control 
	(In Partial modefull colors) 
 Display Inversion Control 
 RGB Interface Blanking Porch setting 
 Display Function set 5 
 Source Driver Direction Control 
 Gate Driver Direction Control  
 Power_Control1 
 Power_Control2 
 Power_Control3 
 Power_Control4 
 Power_Control5 
 VCOM_Control 1 
 VCOM_Control 2 
 VCOM Offset Control 
 Positive Gamma Correction Setting 
 Negative Gamma Correction Setting 
 GAM_R_SEL 
  This display:
  http:www.ebay.comitmReplace-Nokia-5110-LCD-1-44-Red-Serial-128X128-SPI-
  Color-TFT-LCD-Display-Module-271422122271
  This particular display has a design error! The controller has 3 pins to
  configure to constrain the memory and resolution to a fixed dimension (in
  that case 128x128) but they leaved those pins configured for 128x160 so
  there was several pixel memory addressing problems.
  I solved by setup several parameters that dinamically fix the resolution as
  needit so below the parameters for this display. If you have a strain or a
  correct display (can happen with chinese) you can copy those parameters and
  create setup for different displays.
see note 2 - this is the red version 
see note 2 - this is the black version 
 software reset 
 exit sleep 
 default gamma curve 3 
 Enable Gamma adj 
 Frame Rate Control (In normal modeFull colors) 
 display inversion  
 Set VRH1[4:0] & VC[2:0] for VCI1 & GVDD 
 Set BT[2:0] for AVDD & VCL & VGH & VGL  
 Set VMH[6:0] & VML[6:0] for VOMH & VCOML 
 display ON 
 Memory Write 
 Fix incorrect setting 
  7) MY:  1(bottom to top),	0(top to bottom)    Row Address Order
  6) MX:  1(R to L),		0(L to R)	    Column Address Order
  5) MV:  1(Exchanged),	0(normal)	    RowColumn exchange
  4) ML:  1(bottom to top),	0(top to bottom)    Vertical Refresh Order
  3) RGB: 1(BGR),		0(RGB)		    Color Space
  2) MH:  1(R to L),		0(L to R)	    Horizontal Refresh Order
  1)
  0)
 	MY, MX, MV, ML,RGB, MH, D1, D0
 	0 | 0 | 0 | 0 | 1 | 0 | 0 | 0	normal
 	1 | 0 | 0 | 0 | 1 | 0 | 0 | 0	Y-Mirror
 	0 | 1 | 0 | 0 | 1 | 0 | 0 | 0	X-Mirror
 	1 | 1 | 0 | 0 | 1 | 0 | 0 | 0	X-Y-Mirror
 	0 | 0 | 1 | 0 | 1 | 0 | 0 | 0	X-Y Exchange
 	1 | 0 | 1 | 0 | 1 | 0 | 0 | 0	X-Y Exchange, Y-Mirror
 	0 | 1 | 1 | 0 | 1 | 0 | 0 | 0	XY exchange
 	1 | 1 | 1 | 0 | 1 | 0 | 0 | 0
 Avoid compiler warning 
 Colorspcae 
 Write Data to GRAM mode 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the ILI9341 LCD display controller
  This display uses 9-bit SPI: DataCommand bit + 8 data bits
  For platforms that doesn't support 9-bit, the driver is capable
  of emulating this using 8-bit transfer.
  This is done by transferring eight 9-bit words in 9 bytes.
  Copyright (C) 2013 Christian Vogelgsang
  Based on adafruit22fb.c by Noralf Tronnes
 startup sequence for MI0283QT-9A 
 --------------------------------------------------------- 
 ------------power control-------------------------------- 
 ------------VCOM --------- 
 ------------memory access control------------------------ 
 16bit pixel 
 ------------frame rate----------------------------------- 
 ------------Gamma---------------------------------------- 
 write_reg(par, 0xF2, 0x08);  
 ------------display-------------------------------------- 
 entry mode set 
 MY row address order 
 MX column address order 
 MV row  column exchange 
 ML vertical refresh order 
 MH horizontal refresh order 
 RGB-BGR Order 
  Gamma string format:
   Positive: Par1 Par2 [...] Par15
   Negative: Par1 Par2 [...] Par15
 SPDX-License-Identifier: GPL-2.0
  fbtft_write_spi_emulate_9() - write SPI emulating 9-bit
  @par: Driver data
  @buf: Buffer to write
  @len: Length of buffer (must be divisible by 8)
  When 9-bit SPI is not available, this function can be used to emulate that.
  par->extra must hold a transformation buffer used for transfer.
  Optimized use of gpiolib is twice as fast as no optimization
  only one driver can use the optimized version at a time
 Start writing by pulling down WR 
 Set data 
 used as delay 
 Pullup WR 
 Start writing by pulling down WR 
 Set data 
 used as delay 
 Pullup WR 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the S6D02A1 LCD Controller
  Based on fb_st7735r.c by Noralf Tronnes
  Init code from UTFT library by Henning Karlsen
 power setting sequence 
 initializing sequence 
 gamma setting - possible values 0x01, 0x02, 0x04, 0x08 
 end marker 
	
	  Memory data access control (0x36h)
	  RGBBGR:
	 	1. Mode selection pin SRGB
	 		RGB HW pin for color filter setting: 0=RGB, 1=BGR
	 	2. MADCTL RGB bit
	 		RGB-BGR ORDER color filter panel: 0=RGB, 1=BGR
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the TLS8204 LCD Controller
  The display is monochrome and the video memory is RGB565.
  Any pixel value except 0 turns the pixel on.
  Copyright (C) 2013 Noralf Tronnes
  Copyright (C) 2014 Michael Hope (adapted for the TLS8204)
 gamma is used to control contrast in this driver 
 Enter extended command mode 
	write_reg(par, 0x21);	 5:1  1
				  2:0  PD - Powerdown control: chip is active
				  1:0  V  - Entry mode: horizontal addressing
				  0:1  H  - Extended instruction set control:
				 	     extended
 H=1 Bias system 
				 4:1  1
				  3:0  0
				  2:x  BS2 - Bias System
				  1:x  BS1
				  0:x  BS0
 Set the address of the first display line. 
 Enter H=0 standard command mode 
 H=0 Display control 
				 3:1  1
				  2:1  D - DE: 10=normal mode
				  1:0  0
				  0:0  E
 H=0 Set X address of RAM 
	write_reg(par, 0x80);	 7:1  1
				  6-0: X[6:0] - 0x00
 H=0 Set Y address of RAM 
	write_reg(par, 0x40);	 7:0  0
				  6:1  1
				  2-0: Y[2:0] - 0x0
		 The display is 102x68 but the LCD is 84x48.
		  Set the write pointer at the start of each row.
 Write the row 
 apply mask 
 turn on extended instruction set 
 turn off extended instruction set 
 SPDX-License-Identifier: GPL-2.0
 replace optional separators 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the ILI9320 LCD Controller
  Copyright (C) 2013 Noralf Tronnes
 Initialization sequence from ILI9320 Application Notes 
  Start Initial Sequence  
 Set the Vcore voltage and this setting is must. 
 Start internal OSC. 
 set SS and SM bit 
 set 1 line inversion 
 Resize register 
 set the back and front porch 
 set non-display area refresh cycle 
 FMARK function 
 RGB interface setting 
 Frame marker Position 
 RGB interface polarity 
 Power On sequence  
 SAP, BT[3:0], AP, DSTB, SLP, STB 
 DC1[2:0], DC0[2:0], VC[2:0] 
 VREG1OUT voltage 
 VDV[4:0] for VCOM amplitude 
 Dis-charge capacitor power voltage 
 SAP, BT[3:0], AP, DSTB, SLP, STB 
 R11h=0x0031 at VCI=3.3V DC1[2:0], DC0[2:0], VC[2:0] 
 R12h=0x0138 at VCI=3.3V VREG1OUT voltage 
 R13h=0x1800 at VCI=3.3V VDV[4:0] for VCOM amplitude 
 R29h=0x0008 at VCI=3.3V VCM[4:0] for VCOMH 
 GRAM horizontal Address 
 GRAM Vertical Address 
 ------------------ Set GRAM area --------------- 
 Horizontal GRAM Start Address 
 Horizontal GRAM End Address 
 Vertical GRAM Start Address 
 Vertical GRAM End Address 
 Gate Scan Line 
 NDL,VLE, REV 
 set scrolling line 
 -------------- Partial Display Control --------- 
 -------------- Panel Control ------------------- 
 262K color and display ON 
 R20h = Horizontal GRAM Start Address 
 R21h = Vertical GRAM Start Address 
 Write Data to GRAM 
  Gamma string format:
   VRP0 VRP1 RP0 RP1 KP0 KP1 KP2 KP3 KP4 KP5
   VRN0 VRN1 RN0 RN1 KN0 KN1 KN2 KN3 KN4 KN5
 apply mask 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the ST7735R LCD Controller
  Copyright (C) 2013 Noralf Tronnes
 delay 
 delay 
	 FRMCTR1 - frame rate control: normal mode
	  frame rate = fosc  (1 x 2 + 40)  (LINE + 2C + 2D)
	 FRMCTR2 - frame rate control: idle mode
	  frame rate = fosc  (1 x 2 + 40)  (LINE + 2C + 2D)
	 FRMCTR3 - frame rate control - partial mode
	  dot inversion mode, line inversion mode
	 INVCTR - display inversion control
	  no inversion
	 PWCTR1 - Power Control
	  -4.6V, AUTO mode
	 PWCTR2 - Power Control
	  VGH25 = 2.4C VGSEL = -10 VGH = 3  AVDD
	 PWCTR3 - Power Control
	  Opamp current small, Boost frequency
	 PWCTR4 - Power Control
	  BCLK2, Opamp current small & Medium low
 PWCTR5 - Power Control 
 VMCTR1 - Power Control 
 delay 
 delay 
 end marker 
	 MADCTL - Memory data access control
	  RGBBGR:
	  1. Mode selection pin SRGB
	     RGB HW pin for color filter setting: 0=RGB, 1=BGR
	  2. MADCTL RGB bit
	     RGB-BGR ORDER color filter panel: 0=RGB, 1=BGR
  Gamma string format:
  VRF0P VOS0P PK0P PK1P PK2P PK3P PK4P PK5P PK6P PK7P PK8P PK9P SELV0P SELV1P SELV62P SELV63P
  VRF0N VOS0N PK0N PK1N PK2N PK3N PK4N PK5N PK6N PK7N PK8N PK9N SELV0N SELV1N SELV62N SELV63N
 apply mask 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the S6D1121 LCD Controller
  Copyright (C) 2013 Roman Rolinsky
  Based on fb_ili9325.c by Noralf Tronnes
  Based on ili9325.c by Jeroen Domburg
  Init code from UTFT library by Henning Karlsen
 Initialization sequence from Lib_UTFT 
 Write Data to GRAM 
 R20h = Horizontal GRAM Start Address 
 R21h = Vertical GRAM Start Address 
 Write Data to GRAM 
 AM: GRAM update direction 
  Gamma string format:
  PKP0 PKP1 PKP2 PKP3 PKP4 PKP5 PKP6 PKP7 PKP8 PKP9 PKP10 PKP11 VRP0 VRP1
  PKN0 PKN1 PKN2 PKN3 PKN4 PKN5 PKN6 PKN7 PRN8 PRN9 PRN10 PRN11 VRN0 VRN1
 apply mask 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the HX8340BN LCD Controller
  This display uses 9-bit SPI: DataCommand bit + 8 data bits
  For platforms that doesn't support 9-bit, the driver is capable
  of emulating this using 8-bit transfer.
  This is done by transferring eight 9-bit words in 9 bytes.
  Copyright (C) 2013 Noralf Tronnes
 BTL221722-276L startup sequence, from datasheet 
	
	  SETEXTCOM: Set extended command set (C1h)
	  This command is used to set extended command set access enable.
	  Enable: After command (C1h), must write: ffh,83h,40h
	
	  Sleep out
	  This command turns off sleep mode.
	  In this mode the DCDC converter is enabled, Internal oscillator
	  is started, and panel scanning is started.
 Undoc'd register? 
	
	  SETOSC: Set Internal Oscillator (B0h)
	  This command is used to set internal oscillator related settings
	 	OSC_EN: Enable internal oscillator
	 	Internal oscillator frequency: 125% x 2.52MHz
 Drive ability setting 
	
	  SETPWCTR5: Set Power Control 5(B5h)
	  This command is used to set VCOM Low and VCOM High Voltage
	  VCOMH 0110101 :  3.925
	  VCOML 0100000 : -1.700
	  45h=69  VCOMH: "VMH" + 5d   VCOML: "VMH" + 5d
	
	  SETPWCTR4: Set Power Control 4(B4h)
	 	VRH[4:0]:	Specify the VREG1 voltage adjusting.
	 			VREG1 voltage is for gamma voltage setting.
	 	BT[2:0]:	Switch the output factor of step-up circuit 2
	 			for VGH and VGL voltage generation.
	
	  Interface Pixel Format (3Ah)
	  This command is used to define the format of RGB picture data,
	  which is to be transfer via the system and RGB interface.
	  RGB interface: 16 BitPixel
	
	  Display on (29h)
	  This command is used to recover from DISPLAY OFF mode.
	  Output from the Frame Memory is enabled.
 MADCTL - Memory data access control 
 RGBBGR can be set with HW pin SRGB and MADCTL BGR bit 
  Gamma Curve selection, GC (only GC0 can be customized):
    0 = 2.2, 1 = 1.8, 2 = 2.5, 3 = 1.0
  Gamma string format:
    OP0 OP1 CP0 CP1 CP2 CP3 CP4 MP0 MP1 MP2 MP3 MP4 MP5 CGM0 CGM1
    ON0 ON1 CN0 CN1 CN2 CN3 CN4 MN0 MN1 MN2 MN3 MN4 MN5 XXXX  GC
 apply mask 
 Gamma Set (26h) 
 only GC0 can be customized 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the uPD161704 LCD Controller
  Copyright (C) 2014 Seong-Woo Kim
  Based on fb_ili9325.c by Noralf Tronnes
  Based on ili9325.c by Jeroen Domburg
  Init code from UTFT library by Henning Karlsen
 Initialization sequence from Lib_UTFT 
 oscillator start 
oscillator 0: stop, 1: operation 
 Power settings 
 power supply setup 
 Display control 
 LTPS control settings 
 Gray scale settings 
 RAM access settings 
 First screen drive position (1) 
 First screen drive position (2) 
 R200h = Horizontal GRAM Start Address 
 R201h = Vertical GRAM Start Address 
 Write Data to GRAM 
 AM: GRAM update direction 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the UltraChip UC1611 LCD controller
  The display is 4-bit grayscale (16 shades) 240x160.
  Copyright (C) 2015 Henri Chain
  LCD voltage is a combination of ratio, gain, pot and temp
  V_LCD = V_BIAS  ratio
  V_LCD = (C_V0 + C_PM × pot)  (1 + (T - 25)  temp)
  C_V0 and C_PM depend on ratio and gain
  T is ambient temperature
 BR -> actual ratio: 0-3 -> 5, 10, 11, 13 
 TC -> % compensation per deg C: 0-3 -> -.05, -.10, -.015, -.20 
 PC[1:0] -> LCD capacitance: 0-3 -> <20nF, 20-28 nF, 29-40 nF, 40-56 nF 
 PC[3:2] -> V_LCD: 0, 1, 3 -> ext., int. with ratio = 5, int. standard 
	
	  Set CS active inverse polarity: just setting SPI_CS_HIGH does not
	  work with GPIO based chip selects that are logically active high
	  but inverted inside the GPIO library, so enforce inverted
	  semantics.
 Reset controller 
 Set bias ratio 
 Set bias gain and potentiometer 
 Set temperature compensation 
 Set panel loading 
 Set pump control 
 Set inverse display 
 Set 4-bit grayscale mode 
 Set Display enable 
 Set column address 
 Set page address (divide xs by 2) (not used by driver) 
 Set column address (not used by driver) 
 Set page address (divide ys by 2) 
 par->info->fix.visual = FB_VISUAL_PSEUDOCOLOR; 
 Set RAM address control 
 Increment positively 
 Increment page first 
 Wrap around (default) 
 Set LCD mapping 
 Mirror Y OFF 
 Mirror X OFF 
 MS nibble last (default) 
 Set RAM address control 
 Increment positively 
 Increment column first 
 Wrap around (default) 
 Set LCD mapping 
 Mirror Y ON 
 Mirror X OFF 
 MS nibble last (default) 
 Set RAM address control 
 Increment positively 
 Increment page first 
 Wrap around (default) 
 Set LCD mapping 
 Mirror Y ON 
 Mirror X ON 
 MS nibble last (default) 
 Set RAM address control 
 Increment positively 
 Increment column first 
 Wrap around (default) 
 Set LCD mapping 
 Mirror Y OFF 
 Mirror X ON 
 MS nibble last (default) 
 Must be even because pages are two lines 
 Write data 
 Must be even because pages are two lines 
 Write data 
 SPDX-License-Identifier: GPL-2.0
 Display Off 
 Set Column Address Mapping, COM Scan Direction and Colour Depth 
 RGB colour 
 Set Display Start Line 
 Set Display Offset 
 NORMALDISPLAY 
 Set multiplex 
 Set master 
 write_reg(par, 0xb0, 0x0b);  Set power mode 
 Precharge 
 Clock div 
 Precharge A 
 Precharge B 
 Precharge C 
 Precharge level 
 vcomh 
 Master current 
 Contrast A 
 Contrast B 
 Contrast C 
 Set Sleep Mode Display On 
  Grayscale Lookup Table
  GS1 - GS63
  The driver Gamma curve contains the relative values between the entries
  in the Lookup table.
  From datasheet:
  8.8 Gray Scale Decoder
  there are total 180 Gamma Settings (Setting 0 to Setting 180)
  available for the Gray Scale table.
  The gray scale is defined in incremental way, with reference
  to the length of previous table entry:
  Setting of GS1 has to be >= 0
  Setting of GS2 has to be > Setting of GS1 +1
  Setting of GS3 has to be > Setting of GS2 +1
  :
  Setting of GS63 has to be > Setting of GS62 +1
 SPDX-License-Identifier: GPL-2.0+
  Custom FB driver for tinylcd.com display
  Copyright (C) 2013 Noralf Tronnes
 SPDX-License-Identifier: GPL-2.0
    void (write_reg)(struct fbtft_par par, int len, ...);
		 we're emulating 9-bit, pad start of buffer with no-ops
		  (assuming here that zero is a no-op)
 dc=1 
    int (write_vmem)(struct fbtft_par par);
 16 bit pixel over 8-bit databus 
 non buffered write 
 buffered write 
 16 bit pixel over 9-bit SPI bus: dc + high byte, dc + low byte 
 16 bit pixel over 16-bit databus 
 no need for buffered write with 16-bit bus 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the ILI9325 LCD Controller
  Copyright (C) 2013 Noralf Tronnes
  Based on ili9325.c by Jeroen Domburg
 VGL=Vci4 , VGH=Vci4 
 Vci1=Vci0.80 
 VREG1OUT=Vci1.85 
 VCOMH amplitude=VREG1OUT0.98 
 VCOMH=VREG1OUT0.735 
  Verify that this configuration is within the Voltage limits
  Display module configuration: Vcc = IOVcc = Vci = 3.3V
  Voltages
  ----------
  Vci                                =   3.3
  Vci1           =  Vci  0.80       =   2.64
  DDVDH          =  Vci1  2         =   5.28
  VCL            = -Vci1             =  -2.64
  VREG1OUT       =  Vci  1.85       =   4.88
  VCOMH          =  VREG1OUT  0.735 =   3.59
  VCOM amplitude =  VREG1OUT  0.98  =   4.79
  VGH            =  Vci  4          =  13.2
  VGL            = -Vci  4          = -13.2
  Limits
  --------
  Power supplies
  1.65 < IOVcc < 3.30   =>  1.65 < 3.3 < 3.30
  2.40 < Vcc   < 3.30   =>  2.40 < 3.3 < 3.30
  2.50 < Vci   < 3.30   =>  2.50 < 3.3 < 3.30
  SourceVCOM power supply voltage
   4.50 < DDVDH < 6.0   =>  4.50 <  5.28 <  6.0
  -3.0  < VCL   < -2.0  =>  -3.0 < -2.64 < -2.0
  VCI - VCL < 6.0       =>  5.94 < 6.0
  Gate driver output voltage
   10  < VGH   < 20     =>   10 <  13.2  < 20
  -15  < VGL   < -5     =>  -15 < -13.2  < -5
  VGH - VGL < 32        =>   26.4 < 32
  VCOM driver output voltage
  VCOMH - VCOML < 6.0   =>  4.79 < 6.0
 Initialization sequence from ILI9325 Application Notes 
 ----------- Start Initial Sequence ----------- 
 Set internal timing 
 Set internal timing 
 Set internal timing 
 set SS and SM bit 
 set 1 line inversion 
 Resize register 
 set the back porch and front porch 
 set non-display area refresh cycle 
 FMARK function 
 RGB interface setting 
 Frame marker Position 
 RGB interface polarity 
 ----------- Power On sequence ----------- 
 SAP, BT[3:0], AP, DSTB, SLP, STB 
 DC1[2:0], DC0[2:0], VC[2:0] 
 VREG1OUT voltage 
 VDV[4:0] for VCOM amplitude 
 Dis-charge capacitor power voltage 
 SAP, BT[3:0], AP, DSTB, SLP, STB 
 DC1[2:0], DC0[2:0], VC[2:0] 
 Delay 50ms 
 Internal reference voltage= Vci; 
 Delay 50ms 
 Set VDV[4:0] for VCOM amplitude 
 Set VCM[5:0] for VCOMH 
 Set Frame Rate 
 Delay 50ms 
 GRAM horizontal Address 
 GRAM Vertical Address 
------------------ Set GRAM area --------------- 
 Horizontal GRAM Start Address 
 Horizontal GRAM End Address 
 Vertical GRAM Start Address 
 Vertical GRAM Start Address 
 Gate Scan Line 
 NDL,VLE, REV 
 set scrolling line 
-------------- Partial Display Control --------- 
-------------- Panel Control ------------------- 
 262K color and display ON 
 R20h = Horizontal GRAM Start Address 
 R21h = Vertical GRAM Start Address 
 Write Data to GRAM 
 AM: GRAM update direction 
  Gamma string format:
   VRP0 VRP1 RP0 RP1 KP0 KP1 KP2 KP3 KP4 KP5
   VRN0 VRN1 RN0 RN1 KN0 KN1 KN2 KN3 KN4 KN5
 apply mask 
 SPDX-License-Identifier: GPL-2.0+
  FBTFT driver for the RA8875 LCD Controller
  Copyright by Pf@nne & NOTRO
 PLL clock frequency 
 color deep  MCU Interface 
 pixel clock period  
 horizontal settings 
 vertical settings 
 PLL clock frequency  
 color deep  MCU Interface 
 pixel clock period  
 horizontal settings 
 vertical settings 
 PLL clock frequency 
 color deep  MCU Interface 
 pixel clock period 
 horizontal settings 
 vertical settings 
 PLL clock frequency 
 color deep  MCU Interface 
 pixel clock period 
 horizontal settings 
 vertical settings 
 PWM clock 
 Display ON 
 Set_Active_Window 
 Set_Memory_Write_Cursor 
 slow down spi-speed for writing registers 
 restore user spi-speed 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the HX8347D LCD Controller
  Copyright (C) 2013 Christian Vogelgsang
  Based on driver code found here: https:github.comwatterottr61505u-Adapter
 driving ability 
 power voltage 
 VCOM offset 
 for flicker adjust 
 power on 
 start osc 
 wakeup 
 color selection 
 65k 
panel characteristic 
display on 
 MY row address order 
 MX column address order 
 MV row  column exchange 
 ML vertical refresh order 
 RGB-BGR Order 
  Gamma string format:
    VRP0 VRP1 VRP2 VRP3 VRP4 VRP5 PRP0 PRP1 PKP0 PKP1 PKP2 PKP3 PKP4 CGM
    VRN0 VRN1 VRN2 VRN3 VRN4 VRN5 PRN0 PRN1 PKN0 PKN1 PKN2 PKN3 PKN4 CGM
 apply mask 
 skip if all values are zero 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the SSD1305 OLED Controller
  based on SSD1306 driver by Noralf Tronnes
  write_reg() caveat:
     This doesn't work because DC has to be LOW for both values:
       write_reg(par, val1, val2);
     Do it like this:
       write_reg(par, val1);
       write_reg(par, val2);
 Init sequence taken from the Adafruit SSD1306 Arduino library 
 Set Display OFF 
 Set Display Clock Divide Ratio Oscillator Frequency 
 Set Multiplex Ratio 
 Set Display Offset 
 Set Display Start Line 
 Charge Pump Setting 
 A[2] = 1b, Enable charge pump during display on 
 Set Memory Addressing Mode 
 Vertical addressing mode  
	
	  Set Segment Re-map
	  column address 127 is mapped to SEG0
	
	  Set COM Output Scan Direction
	  remapped mode. Scan from COM[N-1] to COM0
 Set COM Pins Hardware Configuration 
 A[4]=1b, Alternative COM pin configuration 
 A[4]=0b, Sequential COM pin configuration 
 Set Pre-charge Period 
	
	  Entire Display ON
	  Resume to RAM content display. Output follows RAM content
	
	  Set Normal Display
	   0 in RAM: OFF in display panel
	   1 in RAM: ON in display panel
 Set Display ON 
 Set Lower Column Start Address for Page Addressing Mode 
 Set Higher Column Start Address for Page Addressing Mode 
 Set Display Start Line 
 Gamma is used to control Contrast 
 Set Contrast Control for BANK0 
 Write data 
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the ILI9340 LCD Controller
  Copyright (C) 2013 Noralf Tronnes
 Init sequence taken from: Arduino Library for the Adafruit 2.2" display 
 Power Control 1 
 Power Control 2 
 VCOM Control 1 
 VCOM Control 2 
 COLMOD: Pixel Format Set 
 16 bitspixel 
 Frame Rate Control 
 Division ratio = fosc, Frame Rate = 79Hz 
 Display Function Control 
 Gamma Function Disable 
 Gamma curve selection 
 Positive Gamma Correction 
 Negative Gamma Correction 
 Memory Access Control  
 SPDX-License-Identifier: GPL-2.0+
  FB driver for the PCD8544 LCD Controller
  The display is monochrome and the video memory is RGB565.
  Any pixel value except 0 turns the pixel on.
  Copyright (C) 2013 Noralf Tronnes
 gamma controls the contrast in this driver 
	 Function set
	 
	  5:1  1
	  2:0  PD - Powerdown control: chip is active
	  1:0  V  - Entry mode: horizontal addressing
	  0:1  H  - Extended instruction set control: extended
	 H=1 Temperature control
	 
	  2:1  1
	  1:x  TC1 - Temperature Coefficient: 0x10
	  0:x  TC0
	 H=1 Bias system
	 
	  4:1  1
	  3:0  0
	  2:x  BS2 - Bias System
	  1:x  BS1
	  0:x  BS0
	 Function set
	 
	  5:1  1
	  2:0  PD - Powerdown control: chip is active
	  1:1  V  - Entry mode: vertical addressing
	  0:0  H  - Extended instruction set control: basic
	 H=0 Display control
	 
	  3:1  1
	  2:1  D  - DE: 10=normal mode
	  1:0  0
	  0:0  E
	 H=0 Set X address of RAM
	 
	  7:1  1
	  6-0: X[6:0] - 0x00
	 H=0 Set Y address of RAM
	 
	  7:0  0
	  6:1  1
	  2-0: Y[2:0] - 0x0
 Write data 
 apply mask 
 turn on extended instruction set 
 turn off extended instruction set 
 SPDX-License-Identifier: GPL-2.0
  This file is based on code from OCTEON SDK by Cavium Networks.
  Copyright (c) 2003-2007 Cavium Networks
 FIXME: Need autoneg logic 
 SPDX-License-Identifier: GPL-2.0
  This file is based on code from OCTEON SDK by Cavium Networks.
  Copyright (c) 2003-2007 Cavium Networks
  cvm_oct_ioctl - IOCTL support for PHY control
  @dev:    Device to change
  @rq:     the request
  @cmd:    the command
  Returns Zero on success
	
	  The polling task need to know about link status changes.
  cvm_oct_phy_setup_device - setup the PHY
  @dev:    Device to setup
  Returns Zero on success, negative on failure
	 If there is no phy, assume a direct MAC connection and that
	  the link is up.
 SPDX-License-Identifier: GPL-2.0
  This file is based on code from OCTEON SDK by Cavium Networks.
  Copyright (c) 2003-2010 Cavium Networks
 CONFIG_XFRM 
  You can define GET_SKBUFF_QOS() to override how the skbuff output
  function determines which output queue is used. The default
  implementation always uses the base queue for the port. If, for
  example, you wanted to use the skb->priority field, define
  GET_SKBUFF_QOS as: #define GET_SKBUFF_QOS(skb) ((skb)->priority)
 Maximum number of SKBs to try to free per xmit packet. 
 Drain any pending packets in the free list 
 Do the actual freeing outside of the lock. 
  cvm_oct_xmit - transmit a packet
  @skb:    Packet to send
  @dev:    Device info structure
  Returns Always returns NETDEV_TX_OK
	
	  Prefetch the private data structure.  It is larger than the
	  one cache line.
	
	  The check on CVMX_PKO_QUEUES_PER_PORT_ is designed to
	  completely remove "qos" in the event neither interface
	  supports multiple queues per port.
 Save scratch in case userspace is using it 
		
		  Fetch and increment the number of packets to be
		  freed.
	
	  We have space for 6 segment pointers, If there will be more
	  than that, we must linearize.
				
				  Get the number of skbuffs in use
				  by the hardware
				
				  Get the number of skbuffs in use
				  by the hardware
	
	  The CN3XXX series of parts has an errata (GMX-401) which
	  causes the GMX block to hang if a collision occurs towards
	  the end of a <68 byte packet. As a workaround for this, we
	  pad packets to be 68 bytes whenever we are in half duplex
	  mode. We don't handle the case of having a small packet but
	  no room to add the padding.  The kernel should always give
	  us at least a cache line
 We only need to pad packet in half duplex mode 
 Build the PKO command 
 Don't pollute L2 with the outgoing packet 
 Build the PKO buffer pointer 
	
	  See if we can put this skb in the FPA pool. Any strange
	  behavior from the Linux networking stack will most likely
	  be caused by a bug in the following code. If some field is
	  in use by the network stack and gets carried over when a
	  buffer is reused, bad things may happen.  If in doubt and
	  you dont need the absolute best performance, disable the
	  define REUSE_SKBUFFS_WITHOUT_FREE. The reuse of buffers has
	  shown a 25% increase in performance under some loads.
 TX buffer beginning can't meet FPA alignment constraints 
 TX buffer isn't large enough for the FPA 
 TX buffer sharing data with someone else 
 TX buffer has been cloned 
 TX buffer header has been cloned 
 TX buffer has a destructor 
 TX buffer has fragments 
 TX buffer truesize has been changed 
	
	  We can use this buffer in the FPA.  We don't need the FAU
	  update anymore
	
	  The skbuff will be reused without ever being freed. We must
	  cleanup a bunch of core things.
 CONFIG_NET_SCHED 
 REUSE_SKBUFFS_WITHOUT_FREE 
 Check if we can use the hardware checksumming 
 Use hardware checksum calc 
 Get the number of skbuffs in use by the hardware 
 Get the number of skbuffs in use by the hardware 
	
	  If we're sending faster than the receive can free them then
	  don't do the HW free.
 Drop this packet if we have too many already queued to the HW 
 Drop the lock when notifying the core.  
 If not using normal queueing.  
 Send the packet to the output queue 
 Do the actual freeing outside of the lock. 
 Restore the scratch area 
		
		  Schedule the cleanup tasklet every 1024 packets for
		  the pathological case of high traffic on one port
		  delaying clean up of packets on a different port
		  that is blocked waiting for the cleanup.
  cvm_oct_xmit_pow - transmit a packet to the POW
  @skb:    Packet to send
  @dev:    Device info structure
  Returns Always returns zero
 Get a work queue entry 
 Get a packet buffer 
	
	  Calculate where we need to copy the data to. We need to
	  leave 8 bytes for a next pointer (unused). We also need to
	  include any configure skip. Then we need to align the IP
	  packet src and dest into the same 64bit word. The below
	  calculation may add a little extra, but that doesn't
	  hurt.
	
	  We have to copy the packet since whoever processes this
	  packet will free it to a hardware pool. We can't use the
	  trick of counting outstanding packets like in
	  cvm_oct_xmit.
	
	  Fill in some of the work queue fields. We may need to add
	  more if the software at the other end needs them.
 FIXME 
 Default to zero. Sets of zero later are commented out 
 FIXME 
 FIXME 
 FIXME 
 FIXME 
 FIXME 
 We only support IPv4 right now 
 Hardware would set to zero 
 No error, packet is internal 
 Assume Linux is sending a good packet 
 This is an IP packet 
 No error, packet is internal 
 No error, packet is internal 
		
		  When copying the data, include 4 bytes of the
		  ethernet header to align the same way hardware
		  does.
 FIXME 
 FIXME 
 FIXME 
 Hardware would set to zero 
 IP was done up above 
 No error, packet is internal 
 No error, packet is internal 
 Submit the packet to the POW 
  cvm_oct_tx_shutdown_dev - free all skb that are currently queued for TX.
  @dev:    Device being shutdown
 Disable the interrupt.  
 Do the work in the tasklet.  
 Disable the interrupt.  
 Register an IRQ handler to receive CIU_TIMX(1) interrupts 
 Free the interrupt handler 
 SPDX-License-Identifier: GPL-2.0
  This file is based on code from OCTEON SDK by Cavium Networks.
  Copyright (c) 2003-2010 Cavium Networks
  cvm_oct_fill_hw_skbuff - fill the supplied hardware pool with skbuffs
  @pool:     Pool to allocate an skbuff for
  @size:     Size of the buffer needed for the pool
  @elements: Number of buffers to allocate
  Returns the actual number of buffers allocated.
  cvm_oct_free_hw_skbuff- free hardware pool skbuffs
  @pool:     Pool to allocate an skbuff for
  @size:     Size of the buffer needed for the pool
  @elements: Number of buffers to allocate
  cvm_oct_fill_hw_memory - fill a hardware pool with memory.
  @pool:     Pool to populate
  @size:     Size of each buffer in the pool
  @elements: Number of buffers to allocate
  Returns the actual number of buffers allocated.
		
		  FPA memory must be 128 byte aligned.  Since we are
		  aligning we need to save the original pointer so we
		  can feed it to kfree when the memory is returned to
		  the kernel.
		 
		  We allocate an extra 256 bytes to allow for
		  alignment and space for the original pointer saved
		  just before the block.
  cvm_oct_free_hw_memory - Free memory allocated by cvm_oct_fill_hw_memory
  @pool:     FPA pool to free
  @size:     Size of each buffer in the pool
  @elements: Number of buffers that should be in the pool
 SPDX-License-Identifier: GPL-2.0
  This file is based on code from OCTEON SDK by Cavium Networks.
  Copyright (c) 2003-2007 Cavium Networks
 Check and see if this interrupt was caused by the GMX block 
 19 - SPX1_INT_REG & STX1_INT_REG 
 18 - SPX0_INT_REG & STX0_INT_REG 
		
		  The SPI4000 TWSI interface is very slow. In order
		  not to bring the system to a crawl, we only poll a
		  single port every second. This means negotiation
		  speed changes take up to 10 seconds, but at least
		  we don't waste absurd amounts of time waiting for
		  TWSI.
			
			  This function does nothing if it is called on an
			  interface without a SPI4000.
			
			  Normal ordering increments. By decrementing
			  we only match once per iteration.
 SPDX-License-Identifier: GPL-2.0
  This file is based on code from OCTEON SDK by Cavium Networks.
  Copyright (c) 2003-2007 Cavium Networks
 Mask indicating which receive groups are in use. 
  cvm_oct_poll_queue_stopping - flag to indicate polling should stop.
  Set to one right before cvm_oct_poll_queue is destroyed.
  Array of every ethernet device owned by this driver indexed by
  the ipd input port number.
	
	  FPA 0 may have been drained, try to refill it if we need
	  more than num_packet_buffers  2, otherwise normal receive
	  processing will refill it.  If it were drained, no packets
	  could be received so cvm_oct_napi_poll would never be
	  invoked to do the refill.
 Setup the FPA 
  cvm_oct_free_work- Free a work queue entry
  @work_queue_entry: Work queue entry to free
  Returns Zero on success, Negative on failure.
  cvm_oct_common_get_stats - get the low level ethernet statistics
  @dev:    Device to get the statistics from
  Returns Pointer to the statistics
 The simulator doesn't support statistics 
  cvm_oct_common_change_mtu - change the link MTU
  @dev:     Device to change
  @new_mtu: The new MTU
  Returns Zero on success
 Add ethernet header and FCS, and VLAN if configured. 
 Signal errors on packets larger than the MTU 
			
			  Set the hardware to truncate packets larger
			  than the MTU and smaller the 64 bytes.
		
		  Set the hardware to truncate packets larger than
		  the MTU. The jabber register must be set to a
		  multiple of 8 bytes, so round up.
  cvm_oct_common_set_multicast_list - set the multicast list
  @dev:    Device to work on
 Allow broadcast MAC addresses 
 Force accept multicast packets 
 Force reject multicast packets 
			
			  Reject matches if promisc. Since CAM is
			  shut off, should accept everything.
 Filter packets based on the CAM 
  cvm_oct_common_set_mac_address - set the hardware MAC address for a device
  @dev:    The device in question.
  @addr:   Socket address.
  Returns Zero on success
  cvm_oct_common_init - per network device initialization
  @dev:    Device to initialize
  Returns Zero on success
	
	  Force the interface to use the POW send if always_use_pow
	  was specified or it is in the pow send list.
 We do our own locking, Linux doesn't need to 
	
	  Zero out stats for port so we won't mistakenly show
	  counters from the bootloader.
	 By default, both RXTX delay is enabled in
	  __cvmx_helper_rgmii_enable().
 Change the input group for all ports before input is enabled 
				 We support only 16 groups at the moment, so
				  always disable the two additional "hidden"
				  tag_mask bits on CN68XX.
	
	  Initialize the FAU used for counting packet buffers that
	  need to be freed.
 Initialize the FAU used for counting tx SKBs that need to be freed 
 Initialize the device private structure. 
 Initialize the device private structure. 
 These types don't support ports to IPDPKO 
	
	  150 uS: about 10 1500-byte packets at 1GE.
 Free the ethernet devices 
 Free the HW pools 
 SPDX-License-Identifier: GPL-2.0
  This file is based on code from OCTEON SDK by Cavium Networks.
  Copyright (c) 2003-2007 Cavium Networks
 Set preamble checking. 
 Set FCS stripping. 
 Clear any error bits. 
	
	  Take the global register lock since we are going to
	  touch registers that affect more than one port.
		
		  Read the GMXX_RXX_INT_REG[PCTERR] bit and see if we are
		  getting preamble errors.
			
			  We are getting preamble errors at 10Mbps. Most
			  likely the PHY is giving us packets with misaligned
			  preambles. In order to get these packets we need to
			  disable preamble checking and do it in software.
		
		  Since the 10Mbps preamble workaround is allowed we need to
		  enable preamble checking, FCS stripping, and clear error
		  bits on every speed change. If errors occur during 10Mbps
		  operation the above code will change this stuff
 Tell core. 
		
		  In phydev mode, we need still periodic polling for the
		  preamble error checking, and we also need to call this
		  function on every link state change.
		 
		  Only true RGMII ports need to be polled. In GMII mode, port
		  0 is really a RGMII port.
 SPDX-License-Identifier: GPL-2.0
  This file is based on code from OCTEON SDK by Cavium Networks.
  Copyright (c) 2003-2010 Cavium Networks
 CONFIG_XFRM 
  cvm_oct_do_interrupt - interrupt handler.
  @irq: Interrupt number.
  @napi_id: Cookie to identify the NAPI instance.
  The interrupt occurs whenever the POW has packets in our group.
 Disable the IRQ and start napi_poll. 
  cvm_oct_check_rcv_error - process receive errors
  @work: Work queue entry pointing to the packet.
  Returns Non-zero if the packet can be dropped, zero otherwise.
		
		  Ignore length errors on min size packets. Some
		  equipment incorrectly pads packets to 64+4FCS
		  instead of 60+4FCS.  Note these packets still get
		  counted as frame errors.
		
		  We received a packet with either an alignment error
		  or a FCS error. This may be signalling that we are
		  running 10Mbps with GMXX_RXX_FRM_CTL[PRE_CHK]
		  off. If this is the case we need to parse the
		  packet to determine if we can remove a non spec
		  preamble and generate a correct packet.
 Port received 0xd5 preamble 
 Port received 0xd preamble 
		
		  Octeon Errata PKI-100: The segment size is wrong.
		 
		  Until it is fixed, calculate the segment size based on
		  the packet pool buffer size.
		  When it is fixed, the following line should be replaced
		  with this one:
		  int segment_size = segment_ptr.s.size;
 Don't copy more than what is left in the packet 
 Copy the data into the packet 
 Prefetch cvm_oct_device since we know we need it soon 
 Save scratch in case userspace is using it 
 Only allow work for our group (and preserve priorities) 
 Flush 
 Immediately throw away all packets with receive errors 
		
		  We can only use the zero copy path if skbuffs are
		  in the FPA pool and the packet fits in a single
		  buffer.
			
			  We have to copy the packet. First allocate
			  an skbuff for it.
			
			  Check if we've received a packet that was
			  entirely stored in the work entry.
					
					  The beginning of the packet
					  moves for IP packets.
 No packet buffers to free 
			
			  Only accept packets for devices that are
			  currently up.
 Increment RX stats for virtual ports 
				
				  Drop any packet received for a device that
				  isn't up.
			
			  Drop any packet received for a device that
			  doesn't exist.
		
		  Check to see if the skbuff and work share the same
		  packet buffer.
			
			  This buffer needs to be replaced, increment
			  the number of buffers we need to free by
			  one.
 Restore the original POW group mask 
 Flush 
 Restore the scratch area 
  cvm_oct_napi_poll - the NAPI poll function.
  @napi: The NAPI instance.
  @budget: Maximum number of packets to receive.
  Returns the number of packets processed.
 No more work 
  cvm_oct_poll_controller - poll for receive packets
  device.
  @dev:    Device to poll. Unused
 Register an IRQ handler to receive POW interrupts 
 Enable POW interrupt when our port has at least one packet 
		 Schedule NAPI now. This will indirectly enable the
		  interrupt.
 Disable POW interrupt 
 Free the interrupt handler 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Linux device driver for RTL8192U
  Based on the r8187 driver, which is:
  Copyright 2004-2005 Andrea Merello <andrea.merello@gmail.com>, et al.
  Contact Information:
  Jerry chuang <wlanfae@realtek.com>
 RTL8225 Radio frontend 
 Card EEPROM 
 FIXME: check if 2.6.7 is ok 
 set here to open your trace code. 
 always open err flags on 
 Realtek 
 Corega 
 Belkin 
 Sitecom 
 EnGenius 
 Dlink 
 Zinwell 
 LG 
 default use hw. set 0 to use software security 
 Driver name   
 PCI_ID table  
 probe fn      
 remove fn     
 PM suspend fn 
 PM resume fn  
 FCC 
 IC 
 ETSI 
 Spain. Change to ETSI. 
 France. Change to ETSI. 
 MKK 
 MKK1 
 Israel. 
 For 11a , TELEC 
 MIC 
 For Global Domain. 1-11:active scan, 12-14 passive scan. 
 actually 8225 & 8256 rf chips only support B,G,24N mode 
 Clear old channel map 
 Set new channel map 
		 this flag enabled to follow 11d country IE setting,
		  otherwise, it shall follow global domain settings.
	 In static WEP, OID_ADD_KEY or OID_ADD_WEP are set before STA
	  associate to AP. However, ResetKey is called on
	  OID_802_11_INFRASTRUCTURE_MODE and MlmeAssociateRequest. In this
	  condition, Cam can not be reset because upper layer will not set
	  this static key again.
 as 92U has extend page from 4 to 16, so modify functions below. 
 u8 read_phy_cck(struct net_device dev, u8 adr); 
 u8 read_phy_ofdm(struct net_device dev, u8 adr); 
 this might still called in what was the PHY rtl8185rtl8192 common code
  plans are to possibility turn it again in one common code...
    -----------------------------PROCFS STUFF-------------------------
   -----------------------------MISC STUFF-------------------------
	 do not change in link_state != WLAN_LINK_ASSOCIATED.
	  msr must be updated if the state is ASSOCIATING.
	  this is intentional and make sense for ad-hoc and
	  master (see the create BSSIBSS func)
 this hack should avoid frame TX during channel setting
 need to implement rf set channel here 
 nomal packet rx procedure 
 denote rx normal packet queue 
 command packet rx procedure 
 denote rx cmd packet queue 
 The prototype of rx_isr has changed since one version of Linux Kernel 
 TODO check rx queue length and refill somewhere 
 FIXME !! 
 FIXME !! 
 this function TX data frames when the ieee80211 stack requires this.
  It checks also if we need to stop the ieee tx queue, eventually do it
 shall not be referred by command packet 
 This is a rough attempt to TX a frame
  This is called by the ieee 80211 stack to TX management frames.
  If the ring is full packet are dropped (for data frame the queue
  is stopped before this can happen).
 TODO 
 free skb and tx_urb 
	
	  Handle HW Beacon:
	  We had transfer our beacon frame to host controller at this moment.
	 
	 
	  Caution:
	  Handling the wait queue of command packets.
	  For Tx command packets, we must not do TCB fragment because it is
	  not handled right now. We must cut the packets to match the size of
	  TX_CMD_PKT before we send it.
 Handle MPDU in wait queue. 
 Don't send data frame during scanning.
 avoid further processing AMSDU 
 short slot time 
 long slot time 
 TODO: BcnIFS may required to be changed on ASIC 
 temporary hw beacon is not used any more.
  open it when necessary
 Tx descriptor ought to be set according to the skb->cb 
	---------------------------------------------------------------------
	  Fill up USB_OUT_CONTEXT.
	 ---------------------------------------------------------------------
  Mapping SoftwareHardware descriptor queue id to "Queue Select Field"
  in TxFwInfo data structure
  2006.10.30 by Emily
  \param QUEUEID       Software Queue
 default set to 
 TODO: mark other queue selection until we verify it is OK 
 TODO: Remove Assertions 
 HT rate since here 
  The tx procedure is just as following,
  skb->cb will contain all the following information,
  priority, morefrag, rate, &dev.
	 we are locked here so the two atomic_read and inc are executed
	  without interleaves
	  !!! For debug purpose
 Fill Tx firmware info 
 DWORD 0 
 AMPDU enabled 
 DWORD 1 
 DWORD 1 
 Protection mode related 
 Set Bandwidth and sub-channel settings. 
 use duplicated mode 
 Fill Tx descriptor 
 DWORD 0 
DWORD 1
	 Fill fields that are required to be initialized in
	  all of the descriptors
 DWORD 0 
 DWORD 2 
 To submit bulk urb 
		 We need to send 0 byte packet whenever
		  512N bytes64N(HIGN SPEEDNORMAL SPEED) bytes packet has
		  been transmitted. Otherwise, it will be halt to wait for
		  another packet.
		 Add this as in pure N mode, wep encryption will use software
		  way, but there is no chance to set this as wep will not set
		  group key in wext.
update timing params
 aifs 
 flags 
 tx_op_limit 
  background support to run QoS activate functionality
	 It better set slot time at first
	 
	  For we just support bg mode at present, let the slot time at
	  920 selection
	 
	  update the ac parameter to related registers
 Mode GA: slotTimeTimer = 9; Mode B: 20 
 handle and manage frame from beacon and probe response 
  handling the beaconing responses. if we get different QoS setting
  off the network from the associated setting, adjust the QoS
  setting
 update qos parameter for current network 
	 we use connecting AP's capability instead of only security config
	  on our driver to distinguish whether it should use N mode or G mode
 simply judge  
 wep encryption, no N mode setting 
 parse pairwise key type 
	 We do not consider set support rate for ABG mode, only
	  HT MCS rate is set here.
 init priv variables here. only non_zero value should be initialized here. 
 set to channel 1 
 SET AUTO 
 11 mbps 
 for silent reset 
 we don't use FW readwrite RF until stable firmware is available. 
 Max DMA Burst Size per Tx DMA Burst, 7: reserved. 
 Short retry limit 
 Long retry limit 
		 FALSE: HW provides PLCP length and LENGEXT
		  TRUE: SW provides them
 accept managementdata 
 accept control frame for SW AP needs PS-poll 
 accept BCMCUC 
 Max DMA Burst Size per Rx DMA Burst, 7: unlimited. 
 Rx FIFO Threshold, 7: No Rx threshold. 
 rx related queue 
 Tx related queue 
 init lock here 
 init tasklet and wait_queue here. only 2.6 above kernel is considered 
 whether need I consider BIT(5?) 
 used to swap endian. as ntohl & htonl are not necessary
  to swap endian, so use this instead.
 first read EEPROM ID out; 
 set channelplan from eeprom 
 should I set IDR0 here? 
 default 1T2R 
 read Tx power gain offset of legacy OFDM to HT rate 
 read ThermalMeter from EEPROM 
 for tx power track 
 read antenna tx power offset of BCD to A from EEPROM 
 Read CrystalCap from EEPROM 
 get per-channel Tx power level 
 old eeprom definition 
 endif EEPROM_Def_Ver == 1 
 update HAL variables 
 Antenna B gain offset to antenna A, bit0~3 
 Antenna C gain offset to antenna A, bit4~7 
 CrystalCap, bit12~15 
		 ThermalMeter, bit0~3 for RFIC1, bit4~7 for RFIC2
		  92U does not enable TX power tracking.
 end if VersionID == VERSION_819XU_A 
 for dlink led 
	 We can only know RF type in the function. So we have to init
	  DIG RATR table again.
 function:  This function actually only set RRSR, RATR and BW_OPMODE registers
 	     not to do all the hw config as its name says
    input:  net_device dev
   output:  none
   return:  none
   notice:  This part need to modified according to the rate set we filtered
 Set RRSR, RATR, and BW_OPMODE registers 
		 It support CCK rate by default. CCK rate will be filtered
		  out only when associated AP does not support it.
 Set Retry Limit here 
 Set Contention Window here 
 Set Tx AGC 
 Set Tx Antenna including Feedback control 
 Set Auto Rate fallback control 
 InitializeAdapter and PhyCfg 
 for ASIC power on sequence 
 config CPUReset Register 
 Firmware Reset or not? 
 do nothing here? 
 config BB. 
 Loopback mode or not 
 after reset cpu, we need wait for a seconds to write in register. 
 add for new bitfile:usb suspend reset pin set to 1. Do we need? 
 Set Hardware 
 turn on TxRx 
 set IDR0 here 
 set RCR 
 Initialize Number of Reserved Pages in Firmware Queue 
 Set AckTimeout 
 TODO: (it value is only for FPGA version). need to be changed!! 
 Beacon related 
 Firmware download 
 config RF. 
 We can force firmware to do RF-RW 
--set CCK and OFDM Block "ON"--
 if D or C cut 
 this configures registers for beacon tx and enables it via
  rtl8192_beacon_tx_enable(). rtl8192_beacon_tx_disable() might
  be used to stop beacon transmission
    -------------------------------NET STUFF---------------------------
 	<Assumption: RT_TX_SPINLOCK is acquired.>
 	First added: 2006.11.19 by emily
 Decide such threshold according to current power save mode 
	 If rssi is small, we should check rx for long time because of bad rx.
	  or maybe it will continuous silent reset every 2 seconds.
 high rssi, check rx stuck right now. 
  This function is called by Checkforhang to check whether we should
  ask OS to reset driver
  Note:NIC with USB interface sholud not call this function because we
  cannot scan descriptor to judge whether there is tx stuck.
  Note: This function may be required to be rewrite for Vista OS.
  <<<Assumption: Tx spinlock has been acquired >>>
  8185 and 8185b does not implement this function.
		 If driver is in the status of firmware download failure,
		  driver skips RF initialization and RF is in turned off
		  state. Driver should check whether Rx stuck and do silent
		  reset. And if driver is in firmware download failure status,
		  driver should initialize RF in the following silent reset
		  procedure
		 
		  Driver should not check RX stuck in IBSS mode because it is
		  required to set Check BSSID in order to send beacon,
		  however, if check BSSID is set, STA cannot hear any packet
		  at all.
 This function is used to fix TxRx stop bug temporarily.
  This function will do "system reset" to NIC when Tx or Rx is stuck.
  The method checking TxRx stuck of this function is supported by FW,
  which reports Tx and Rx counter to register 0x128 and 0x130.
 If we need to check CCK stop, please uncomment this line. 
 bStuck = Adapter->HalFunc.CheckHWStopHandler(Adapter); 
 Set the variable for reset. 
 For test --> force write UFWP. 
 to get busy traffic condition 
 for AP roaming 
 check if reset the driver 
 This is control by OID set in Pomelo 
 FIXME 
 Tx related queue release 
	 as cancel_delayed_work will del work->timer, so if work is not
	  defined as struct delayed_work, it will corrupt
 FIXME FIXME 
 based on ipw2200 driver 
 parse here for HW security 
					 We fill both index entry and 4th
					  entry for pairwise key as in IPW
					  interface, adhoc will only get here,
					  so we need index entry for its
					  default key serching!
 KeyIndex 
 KeyType 
 MacAddr 
 DefaultKey 
 KeyContent 
  Function:     UpdateRxPktTimeStamp
  Overview:     Record the TSF time stamp when receiving a packet
  Input:
        PADAPTER        Adapter
        PRT_RFD         pRfd,
  Output:
        PRT_RFD         pRfd
                                (pRfd->Status.TimeStampHigh is updated)
                                (pRfd->Status.TimeStampLow is updated)
  Return:
                None
 0-100 index. 
 in dBm. 
 Translate to dBm (x=0.5y-95). 
 We can not declare RSSIEVM total value of sliding window to
  be a local static. Otherwise, it may increase when we return from S3S4. The
  value will be kept in memory or disk. Declare the value in the adaptor
  and it will be reinitialized when returned from S3S4.
 to record the sequence number 
 Check whether we should take the previous packet into accounting 
 if previous packet is not aggregated packet 
 <1> Showed on UI for user, in dbm 
 If the previous packet does not match the criteria, neglect it 
	 only rtl8190 supported
	  rtl8190_process_cck_rxpathsel(priv,pprevious_stats);
 Check RSSI 
 record the general signal strength to the sliding window. 
	 <2> Showed on UI for engineering
	  hardware does not provide rssi information for each rf path in CCK
 Check PWDB. 
 record the beacon pwdb to the sliding window. 
 initialize 
 Check EVM 
 record the general EVM to the sliding window. 
 <1> Showed on UI for user, in percentage. 
			 Showed on UI for user in Windows Vista,
			  for Link quality.
 <2> Showed on UI for engineering 
 2 spatial stream 
 initialize 
-----------------------------------------------------------------------------
  Function:	rtl819x_query_rxpwrpercentage()
  Overview:
  Input:		char		antpower
  Output:		NONE
  Return:		0-100 percentage
 ---------------------------------------------------------------------------
 QueryRxPwrPercentage 
 We want good-looking for signal strengthquality 
 Step 1. Scale mapping. 
 Record it for next packet processing 
 Move pointer to the 16th bytes. Phy status start address. 
 Initial the cck and ofdm buffer pointer 
 (1)Hardware does not provide RSSI for CCK 
		 (2)PWDB, Average PWDB calculated by hardware
		  (for rate adaptive)
 (3) Get Signal Quality (EVM) 
 (1)Get RSSI for HT rate 
 We will judge RF RX path now. 
 Get Rx snr value in DB 
 Translate DBM to percentage. 
 Record Signal Strength for next packet 
		 (2)PWDB, Average PWDB calculated by hardware
		  (for rate adaptive)
 (3)EVM of HT rate 
 both spatial stream make sense 
 only spatial stream 1 makes sense 
			 Do not use shift operation like "rx_evmX >>= 1"
			  because the compiler of free build environment will
			  set the most significant bit to "zero" when doing
			  shifting operation which may change a negative value
			  to positive one, then the dbm value (which is
			  supposed to be negative) is not correct anymore.
 dbm 
				 Fill value in RFD, Get the first spatial
				  stream only
 record rx statistics for debug 
 40M channel 
 20M channel 
	 UI BSS List signal strength(in percentage), make it good looking,
	  from 0~100. It is assigned to the BSS List in
	  GetValueFromBeaconOrProbeRsp().
 We can judge RX path number now. 
 QueryRxPhyStatus8190Pci 
	 TODO: We must only check packet for current MAC address.
	  Not finish
 Get Signal Quality for only RX data queue (but not command queue) 
 Get MAC frame start address. 
 Check if the received packet is acceptable. 
	 Process PHY information for previous packet (RSSIPWDBEVM)
	  Because phy information is contained in the last packet of AMPDU
	  only, so driver should process phy information of previous packet
  Function:	UpdateReceivedRateHistogramStatistics
  Overview:	Record the received data rate
  Input:
 	struct net_device dev
 	struct ieee80211_rx_stats stats
  Output:
 			(priv->stats.ReceivedRateHistogram[] is updated)
  Return:
 		None
 0: Total, 1:OK, 2:CRC, 3:ICV 
 1: short preambleGI, 0: long preambleGI 
 short 
 long 
 CCK rate 
 Legacy OFDM rate 
 11n High throughput rate 
 total 
 Get Rx Descriptor Information 
 RTL8190 set this bit to indicate that Hw does not decrypt packet 
 Get Driver Info 
	 TODO: Need to verify it on FGPA platform
	  Driver info are written to the RxBuffer following rx desc
 unit: 0.5M 
 TODO 
				 Abnormal Case: Receive CRC OK packet with Rx
				  descriptor indicating non supported rate.
				  Special Error Handling here
 Set 1M rate by default 
 Rx A-MPDU 
 Get Total offset of MPDU Frame Body 
 20 is for ps-poll 
 first packet should not contain Rx aggregation header 
 TODO 
 hardware related info 
 Process the MPDU received 
sCrcLng);
 TODO 
 TODO 
 unicast packet 
 Get shifted bytes of Starting address of 802.11 header. 
 about HCT 
 for adding ps function in future 
	 When RF is off, we should not count the packet for hwsw synchronize
	  reason, ie. there may be a duration while sw switch is changed and
	  hw switch is being changed.
 We have to release RFD and return if rx pkt is cmd pkt. 
 Get Rx Descriptor Information 
 TODO 
 prfd->queue_id = 1; 
 Process the command packet received. 
 Nomal packet pipe 
 Command packet pipe 
 should never get here! 
     ---------------------------- USB_STUFF---------------------------
 detach all the work and timer structure declared or inititialize
  in r8192U_init function.
	 add HWSec active enable here.
	  default using hwsec. when peer AP is in N mode only and
	  pairwise_key_type is none_aes(which HT_IOT_ACT_PURE_N_MODE indicates
	  it), use software security. when peer AP is in b,g,n mode mixed and
	  pairwise_key_type is none_aes, use g mode hw security.
 add hwsec_support flag to totol control hw_sec onoff 
 MAC|Config 
 MAC 
 Key Material 
     ------------------- module init  exit stubs ----------------
 SPDX-License-Identifier: GPL-2.0
  This file contains wireless extension handlers.
  This is part of rtl8180 OpenSource driver.
  Copyright (C) Andrea Merello 2004-2005  <andrea.merello@gmail.com>
  Parts of this driver are based on the GPL part
  of the official realtek driver.
  Parts of this driver are based on the rtl8180 driver skeleton
  from Patric Schenke & Andres Salomon.
  Parts of this driver are based on the Intel Pro Wireless 2100 GPL driver.
  We want to thank the Authors of those projects and the Ndiswrapper
  project Authors.
 Informative stuff (to choose between different interface) 
 To give an idea... 
	 In theory this value should be the maximum benchmarked
	  TCPIP throughput, because with most of these devices the
	  bit rate is meaningless (overhead an co) to estimate how
	  fast the connection will go and pick the fastest one.
	  I suggest people to play with Netperf or any benchmark...
 NWID (or domain id) 
 Minimal NWID we are able to set 
 Maximal NWID we are able to set 
 Old Frequency (backward compat - moved lower ) 
 Scan capabilities 
	 Let's try to keep this struct in the same order as in
	  linuxincludewireless.h
	 TODO: See what values we can set, and remove the ones we can't
	  set, or fill them with some default data.
 ~5 Mbs real (802.11b) 
 TODO: Not used in 802.11b? 
 range->min_nwid; 	
 TODO: Not used in 802.11b? 
 range->max_nwid; 	
 Old Frequency (backward compat - moved lower ) 
 range->old_num_channels; 
 range->old_num_frequency; 
 range->old_freq[6];  
 signal level threshold range 
 TODO: Find real max RSSI and stick here 
 Updated all three 
 > 8% missed beacons is 'bad' 
 TODO: Find real 'good' to 'bad' threshold value for RSSI 
 Updated all three 
 range->retry_capa; 	
 range->retry_flags; 	
 range->r_time_flags; 	
 range->min_retry; 		
 range->max_retry; 		
 range->min_r_time; 	
 range->max_r_time; 	
 Include only legal frequencies for some countries 
 FIXME: do we need to set anything for channels 
 we don't use ? 
 no auto select 
 struct sockaddr temp = (struct sockaddr )awrq; 
 sometimes, the length is zero while we do not type key value 
 EntryNo 
 KeyIndex 
 KeyType 
 DefaultKey 
 KeyContent 
 EntryNo 
 KeyIndex 
 KeyType 
 DefaultKey 
 KeyContent 
	 FIXME !
	  We might try to write directly the TX config register
	  or to restart just the (R)TX process.
	  I'm unsure if whole reset is really needed
 can't be disabled 
 we have not this support for this radio 
 we have not this support for this radio 
 hw security need to reorganized. 
 none is not allowed to use hwsec WB 2008.07.01 
 as IW_ENCODE_ALG_CCMP is defined to be 3 and KEY_TYPE_CCMP is defined to 4; 
 we only get 16 bytes key.why? WB 2008.7.1 
 EntryNao 
 KeyIndex 
 KeyType 
 MacAddr 
 DefaultKey 
 KeyContent 
 EntryNo 
 KeyIndex 
 KeyType 
 MacAddr 
 DefaultKey 
 KeyContent 
 pairwise key 
 EntryNo 
 KeyIndex 
 KeyType 
 MacAddr 
 DefaultKey 
 KeyContent 
 SIOCSIWCOMMIT 
 SIOCGIWNAME 
 SIOCSIWNWID 
 SIOCGIWNWID 
 SIOCSIWFREQ 
 SIOCGIWFREQ 
 SIOCSIWMODE 
 SIOCGIWMODE 
 SIOCSIWSENS 
 SIOCGIWSENS 
 SIOCSIWRANGE 
 SIOCGIWRANGE 
 SIOCSIWPRIV 
 SIOCGIWPRIV 
 SIOCSIWSTATS 
 SIOCGIWSTATS 
 SIOCSIWSPY 
 SIOCGIWSPY 
 SIOCGIWTHRSPY 
 SIOCWIWTHRSPY 
 SIOCSIWAP 
 SIOCGIWAP 
 MLME-- 
 SIOCGIWAPLIST -- deprecated 
 SIOCSIWSCAN 
 SIOCGIWSCAN 
 SIOCSIWESSID 
 SIOCGIWESSID 
 SIOCSIWNICKN 
 SIOCGIWNICKN 
 -- hole -- 
 -- hole -- 
 SIOCSIWRATE 
 SIOCGIWRATE 
 SIOCSIWRTS 
 SIOCGIWRTS 
 SIOCSIWFRAG 
 SIOCGIWFRAG 
 SIOCSIWTXPOW 
 SIOCGIWTXPOW 
 SIOCSIWRETRY 
 SIOCGIWRETRY 
 SIOCSIWENCODE 
 SIOCGIWENCODE 
 SIOCSIWPOWER 
 SIOCGIWPOWER 
---hole---
---hole---
 NULL, 		
 SIOCSIWGENIE 
 NULL, 			
 r8192_wx_get_auth,   SIOCSIWAUTH 
 SIOCSIWENCODEEXT 
 NULL, 			 SIOCSIWENCODEEXT 
 NULL, 			
 SIOCSIWPMKSA 
---hole---
 SPDX-License-Identifier: GPL-2.0
  Procedure:    Init boot codefirmware codedata session
  Description: This routine will initialize firmware. If any error occurs during the initialization
 		process, the routine shall terminate immediately and return fail.
 		NIC driver should call NdisOpenFile only from MiniportInitialize.
  Arguments:   The pointer of the adapter
  Returns:
         NDIS_STATUS_FAILURE - the following initialization process should be terminated
         NDIS_STATUS_SUCCESS - if firmware initialization process success
  segment the img and use the ptr and length to remember info on each segment
 Fragmentation might be required 
		 Allocate skb buffer to contain firmware info and tx descriptor info
		  add 4 to avoid packet appending overflow.
		
		  Transform from little endian to big endian
		  and pending  zero
  Procedure:	Check whether main code is download OK. If OK, turn on CPU
  Description:	CPU register locates in different page against general register.
 	    Switch to CPU register in the begin and switch back before return
  Arguments:   The pointer of the adapter
  Returns:
         NDIS_STATUS_FAILURE - the following initialization process should
 				be terminated
         NDIS_STATUS_SUCCESS - if firmware initialization process success
 Check whether put code OK 
 Turn On CPU 
 Check whether CPU boot OK 
 Check Firmware Ready 
 it is called by reset 
 TODO: system reset 
 it is called by Initialize 
	
	  Download boot, main, and data image for System reset.
	  Download data image for firmware reset
		
		  Open image file, and map file to continuous memory if open file success.
		  or read image file from array. Default load from IMG file
 we only need to download data.img here 
 Download image file 
		 The firmware download process is just as following,
		  1. that is each packet will be segmented and inserted to the wait queue.
		  2. each packet segment will be put in the skb_buff packet.
		  3. each skb_buff packet data content will already include the firmware info
		    and Tx descriptor info
			 Download boot
			  initialize command descriptor.
			  will set polling bit when firmware code is also configured
 mdelay(1000); 
			
			  To initialize IMEM, CPU move code  from 0x80000080,
			  hence, we send 0x80 byte packet
 Download firmware code. Wait until Boot Ready and Turn on CPU 
 Check Put Code OK and Turn On CPU 
 download initial data code 
 wait until data code is initialized ready.
 SPDX-License-Identifier: GPL-2.0
Created on  2008 716,  5:31
 SPDX-License-Identifier: GPL-2.0
  This is part of the rtl8192 driver
  This files contains programming code for the rtl8256
  radio frontend.
  Many thanks to Realtek Corp. for their great support!
  Forward declaration of local functions
--------------------------------------------------------------------------
  Overview:	set RF band width (20M or 40M)
  Input:       struct net_device	dev
 		WIRELESS_BANDWIDTH_E	Bandwidth	20M or 40M
  Output:      NONE
  Return:      NONE
  Note:	8226 support both 20M  and 40 MHz
 --------------------------------------------------------------------------
	 for(eRFPath = RF90_PATH_A; eRFPath <pHalData->NumTotalRFPath;
	   eRFPath++)
 8256 D-cut, E-cut, xiong: consider it later! 
 phy para:1ba 
 8256 D-cut, E-cut, xiong: consider it later! 
 phy para:3ba 
 I need to set priv->chan whenever current channel changes 
--------------------------------------------------------------------------
  Overview:    Interface to config 8256
  Input:       struct net_device	dev
  Output:      NONE
  Return:      NONE
 --------------------------------------------------------------------------
	 Initialize general global value
	 
	  TODO: Extend RF_PATH_C and RF_PATH_D in the future
 Config BB and RF 
--------------------------------------------------------------------------
  Overview:    Interface to config 8256
  Input:       struct net_device	dev
  Output:      NONE
  Return:      NONE
 --------------------------------------------------------------------------
 Initialize RF 
		 Joseph test for shorten RF config
		  pHalData->RfReg0Value[eRFPath] =  rtl8192_phy_QueryRFReg(dev, (enum rf90_radio_path_e)eRFPath, rGlobalCtrl, bMaskDWord);
		  ----Store original RFENV control type
----Set RF_ENV enable----
----Set RF_ENV output high----
 Set bit number of Address and Data for RF register 
 Set 0 to 4 bits for Z-serial and set 1 to 6 bits for 8258 
 Set 0 to 12 bits for Z-serial and 8258, and set 1 to 14 bits for ??? 
		 Check RF block (for FPGA platform only)----
		  TODO: this function should be removed on ASIC , Emily 2007.2.2
----Initialize RF fom connfiguration file----
----Restore RFENV control type----
 Joseph TxPower for 8192 testing 
 OFDM rates 
 MCS rates 
 Max power index = 0x24 
 for tx power track 
			Add by Jacken 20080306
			 Emily, 20080613. Set low tx power for both MCS and legacy OFDM
 SPDX-License-Identifier: GPL-2.0
   This files contains card eeprom (93c46 or 93c56) programming routines,
   memory is addressed by 16 bits words.
   This is part of rtl8180 OpenSource driver.
   Copyright (C) Andrea Merello 2004  <andrea.merello@gmail.com>
   Parts of this driver are based on the GPL part of the
   official realtek driver.
   Parts of this driver are based on the rtl8180 driver skeleton
   from Patric Schenke & Andres Salomon.
   Parts of this driver are based on the Intel Pro Wireless 2100 GPL driver.
   We want to thank the Authors of those projects and the Ndiswrapper
   project Authors.
 enable EPROM 
 disable EPROM 
 enable EPROM programming 
	
	  keep chip pin D to low state while reading.
	  I'm unsure if it is necessary, but anyway shouldn't hurt
		 eeprom needs a clk cycle between writing opcode&adr
		  and reading data. (eeprom outs a dummy 0)
 disable EPROM programming 
 SPDX-License-Identifier: GPL-2.0
   (c) Copyright 2008, RealTEK Technologies Inc. All Rights Reserved.
   Module:	r819xusb_cmdpkt.c
 		(RTL8190 TXRX command packet handler Source C File)
   Note:	The module is responsible for handling TX and RX command packet.
 		1. TX : Send set and query configuration command packet.
 		2. RX : Receive tx feedback, beacon state, query configuration
 			command packet.
   Function:
   Export:
   Abbrev:
   History:
 	Date		Who		Remark
 	05062008	amy		Create initial version porting from
 					windows driver.
	 Get TCB and local buffer from common pool.
	  (It is shared by CmdQ, MgntQ, and USB coalesce DataQ)
	 When RF is off, we should not count the packet for hwsw synchronize
	  reason, ie. there may be a duration while sw switch is changed and
	  hw switch is being changed.
	 We can not know the packet length and transmit type:
	  broadcast or uni or multicast. So the relative statistics
	  must be collected in tx feedback info.
 We can not make sure broadcastmulticast or unicast mode. 
 We can not make sure broadcastmulticast or unicast mode. 
-----------------------------------------------------------------------------
  Function:    cmpk_handle_tx_feedback()
  Overview:	The function is responsible for extract the message inside TX
 		feedbck message from firmware. It will contain dedicated info in
 		ws-06-0063-rtl8190-command-packet-specification.
 		Please refer to chapter "TX Feedback Element".
               We have to read 20 bytes in the command packet.
  Input:       struct net_device	dev
               u8			pmsg	- Msg Ptr of the command packet.
  Output:      NONE
  Return:      NONE
  Revised History:
   When		Who	Remark
   05082008		amy	Create Version 0 porting from windows code.
 ---------------------------------------------------------------------------
 1. Extract TX feedback info from RFD to temp structure buffer. 
	 It seems that FW use big endian(MIPS) and DRV use little endian in
	  windows OS. So we have to read the content byte by byte or transfer
	  endian type before copy the message copy.
 Use pointer to transfer structure memory. 
 2. Use tx feedback info to count TX statistics. 
 Comment previous method for TX statistic function. 
 Collect info TX feedback packet to fill TCB. 
	 We can not know the packet length and transmit type: broadcast or uni
	  or multicast.
 87B have to SW beacon for DTM encryption_cmn. 
 HW Beacon 
-----------------------------------------------------------------------------
  Function:    cmpk_handle_interrupt_status()
  Overview:    The function is responsible for extract the message from
 		firmware. It will contain dedicated info in
 		ws-07-0063-v06-rtl819x-command-packet-specification-070315.doc.
 		Please refer to chapter "Interrupt Status Element".
  Input:       struct net_device dev
               u8 pmsg		- Message Pointer of the command packet.
  Output:      NONE
  Return:      NONE
  Revised History:
   When		Who	Remark
   05122008		amy	Add this for rtl8192 porting from windows code.
 ---------------------------------------------------------------------------
 1. Extract TX feedback info from RFD to temp structure buffer. 
	 It seems that FW use big endian(MIPS) and DRV use little endian in
	  windows OS. So we have to read the content byte by byte or transfer
	  endian type before copy the message copy.
 Statistics of beacon for ad-hoc mode. 
 2 maybe need endian transform? 
 Other information in interrupt status we need? 
-----------------------------------------------------------------------------
  Function:	cmpk_count_tx_status()
  Overview:	Count aggregated tx status from firmwar of one type rx command
 		packet element id = RX_TX_STATUS.
  Input:	NONE
  Output:	NONE
  Return:	NONE
  Revised History:
 	When		Who	Remark
 	05122008	amy	Create Version 0 porting from windows code.
 ---------------------------------------------------------------------------
	 When RF is off, we should not count the packet for hwsw synchronize
	  reason, ie. there may be a duration while sw switch is changed and
	  hw switch is being changed.
-----------------------------------------------------------------------------
  Function:	cmpk_handle_tx_status()
  Overview:	Firmware add a new tx feedback status to reduce rx command
 		packet buffer operation load.
  Input:		NONE
  Output:		NONE
  Return:		NONE
  Revised History:
 	When		Who	Remark
 	05122008	amy	Create Version 0 porting from windows code.
 ---------------------------------------------------------------------------
 2. Use tx feedback info to count TX statistics. 
-----------------------------------------------------------------------------
  Function:	cmpk_handle_tx_rate_history()
  Overview:	Firmware add a new tx rate history
  Input:		NONE
  Output:		NONE
  Return:		NONE
  Revised History:
 	When		Who	Remark
 	05122008	amy	Create Version 0 porting from windows code.
 ---------------------------------------------------------------------------
	 When RF is off, we should not count the packet for hwsw synchronize
	  reason, ie. there may be a duration while sw switch is changed and
	  hw switch is being changed.
	 Do endian transfer to word alignment(16 bits) for windows system.
	  You must do different endian transfer for linux and MAC OS
 Collect CCK rate packet num 
 Collect OFDM rate packet num 
-----------------------------------------------------------------------------
  Function:    cmpk_message_handle_rx()
  Overview:    In the function, we will capture different RX command packet
 		info. Every RX command packet element has different message
 		length and meaning in content. We only support three type of RX
 		command packet now. Please refer to document
 		ws-06-0063-rtl8190-command-packet-specification.
  Input:       NONE
  Output:      NONE
  Return:      NONE
  Revised History:
   When		Who	Remark
   05062008		amy	Create Version 0 porting from windows code.
 ---------------------------------------------------------------------------
	 0. Check inpt arguments. It is a command queue message or
	  pointer is null.
 This is not a command packet. 
 1. Read received command packet message length from RFD. 
 2. Read virtual address from RFD. 
 3. Read command packet element id and length. 
	 4. Check every received command packet content according to different
	     element type. Because FW may aggregate RX command packet to
	     minimize transmit time between DRV and FW.
	 Add a counter to prevent the lock in the loop from being held too
	  long
 We support aggregation of different cmd in the same packet 
			 You must at lease add a switch case element here,
			  Otherwise, we will jump to default case.
 This is a command packet. 
 This is a command packet. 
 SPDX-License-Identifier: GPL-2.0
 2412 1  
 2417 2  
 2422 3  
 2427 4  
 2432 5  
 2437 6  
 2442 7  
 2447 8  
 2452 9  
 2457 10 
 2462 11 
 2467 12 
 2472 13 
 2484    
  function:  This function checks different RF type to execute legal judgement.
             If RF Path is illegal, we will return false.
  input:     net_device	 dev
             u32		 e_rfpath
  output:    none
  return:    0(illegal, false), 1(legal, true)
  function:  This function sets specific bits to BB register
  input:     net_device dev
             u32        reg_addr   target addr to be modified
             u32        bitmask    taget bit pos to be modified
             u32        data       value to be write
  output:    none
  return:    none
  notice:
  function:  This function reads specific bits from BB register
  input:     net_device	dev
             u32		reg_addr   target addr to be readback
             u32		bitmask    taget bit pos to be readback
  output:    none
  return:    u32		data       the readback register value
  notice:
  function:  This function reads register from RF chip
  input:     net_device        dev
             rf90_radio_path_e e_rfpath    radio path of ABCD
             u32               offset     target address to be read
  output:    none
  return:    u32               readback value
  notice:    There are three types of serial operations:
             (1) Software serial write.
             (2)Hardware LSSI-Low Speed Serial Interface.
             (3)Hardware HSSI-High speed serial write.
             Driver here need to implement (1) and (2)
             ---need more spec for this information.
 Make sure RF register offset is correct 
 Switch page for 8256 RF IC 
 Switch to Reg_Mode2 for Reg 31-45 
 Modify offset 
 Switch to Reg_Mode1 for Reg16-30 
 Put desired read addr to LSSI control Register 
 Issue a posedge trigger 
 TODO: we should not delay such a long time. Ask for help from SD3 
 Switch back to Reg_Mode0 
  function:  This function writes data to RF register
  input:     net_device        dev
             rf90_radio_path_e e_rfpath  radio path of ABCD
             u32               offset   target address to be written
             u32               data	 the new register data to be written
  output:    none
  return:    none
  notice:    For RF8256 only.
  ===========================================================================
  Reg Mode	RegCTL[1]	RegCTL[0]		Note
 		(Reg00[12])	(Reg00[10])
  ===========================================================================
  Reg_Mode0	0		x			Reg 0 ~ 15(0x0 ~ 0xf)
  ---------------------------------------------------------------------------
  Reg_Mode1	1		0			Reg 16 ~ 30(0x1 ~ 0xf)
  ---------------------------------------------------------------------------
  Reg_Mode2	1		1			Reg 31 ~ 45(0x1 ~ 0xf)
  ---------------------------------------------------------------------------
 Put write addr in [5:0] and write data in [31:16] 
 Write operation 
 Switch back to Reg_Mode0 
  function:  This function set specific bits to RF register
  input:     net_device        dev
             rf90_radio_path_e e_rfpath  radio path of ABCD
             u32               reg_addr target addr to be modified
             u32               bitmask  taget bit pos to be modified
             u32               data     value to be written
  output:    none
  return:    none
  notice:
 RF data is 12 bits only 
 RF data is 12 bits only 
  function:  This function reads specific bits from RF register
  input:     net_device        dev
             u32               reg_addr target addr to be readback
             u32               bitmask  taget bit pos to be readback
  output:    none
  return:    u32               data     the readback register value
  notice:
  function:  We support firmware to execute RF-RW.
  input:     net_device        dev
             rf90_radio_path_e e_rfpath
             u32               offset
  output:    none
  return:    u32
  notice:
	 Firmware RF Write control.
	  We can not execute the scheme in the initial step.
	  Otherwise, RF-RW will waste much time.
	  This is only for site survey.
 1. Read operation need not insert data. bit 0-11 
 2. Write RF register address. bit 12-19 
 3. Write RF path.  bit 20-21 
 4. Set RF read indicator. bit 22=0 
 5. Trigger Fw to operate the command. bit 31 
 6. We can not execute read operation if bit 31 is 1. 
		 If FW can not finish RF-RW for more than ?? times.
		  We must reset FW.
 7. Execute read operation. 
 8. Check if firmware send back RF content. 
		 If FW can not finish RF-RW for more than ?? times.
		  We must reset FW.
  function:  We support firmware to execute RF-RW.
  input:     net_device        dev
             rf90_radio_path_e e_rfpath
             u32               offset
             u32               data
  output:    none
  return:    none
  notice:
	 Firmware RF Write control.
	  We can not execute the scheme in the initial step.
	  Otherwise, RF-RW will waste much time.
	  This is only for site survey.
 1. Set driver write bit and 12 bit data. bit 0-11 
 2. Write RF register address. bit 12-19 
 3. Write RF path.  bit 20-21 
 4. Set RF write indicator. bit 22=1 
 5. Trigger Fw to operate the command. bit 31=1 
 6. Write operation. We can not write if bit 31 is 1. 
		 If FW can not finish RF-RW for more than ?? times.
		  We must reset FW.
	 7. No matter check bit. We always force the write.
	  Because FW will not accept the command.
	 According to test, we must delay 20us to wait firmware
	  to finish RF write operation.
 We support delay in firmware side now. 
  function:  This function reads BB parameters from header file we generate,
             and do register readwrite
  input:     net_device	dev
  output:    none
  return:    none
  notice:    BB parameters may change all the time, so please make
             sure it has been synced with the newest.
  function:  This function does dirty work
  input:     net_device	dev
             u8                ConfigType
  output:    none
  return:    none
  notice:    BB parameters may change all the time, so please make
             sure it has been synced with the newest.
  function:  This function initializes Register definition offset for
             Radio Path ABCD
  input:     net_device	dev
  output:    none
  return:    none
  notice:    Initialization value here is constant and it should never
             be changed
 RF Interface Software Control 
 16 LSBs if read 32-bit from 0x870 
 16 MSBs if read 32-bit from 0x870 (16-bit for 0x872) 
 16 LSBs if read 32-bit from 0x874 
 16 MSBs if read 32-bit from 0x874 (16-bit for 0x876) 
 RF Interface Readback Value 
 16 LSBs if read 32-bit from 0x8E0 
 16 MSBs if read 32-bit from 0x8E0 (16-bit for 0x8E2) 
 16 LSBs if read 32-bit from 0x8E4 
 16 MSBs if read 32-bit from 0x8E4 (16-bit for 0x8E6) 
 RF Interface Output (and Enable) 
 16 LSBs if read 32-bit from 0x860 
 16 LSBs if read 32-bit from 0x864 
 16 LSBs if read 32-bit from 0x868 
 16 LSBs if read 32-bit from 0x86C 
 RF Interface (Output and) Enable 
 16 MSBs if read 32-bit from 0x860 (16-bit for 0x862) 
 16 MSBs if read 32-bit from 0x864 (16-bit for 0x866) 
 16 MSBs if read 32-bit from 0x86A (16-bit for 0x86A) 
 16 MSBs if read 32-bit from 0x86C (16-bit for 0x86E) 
 Addr of LSSI. Write RF register by driver 
 RF parameter 
 BB Band Select 
 Tx AGC Gain Stage (same for all path. Should we remove this?) 
 Tranceiver A~D HSSI Parameter-1 
 wire control parameter1 
 Tranceiver A~D HSSI Parameter-2 
 wire control parameter2 
 RF Switch Control 
 TRAnt switch control 
 AGC control 1 
 AGC control 2 
 RX AFE control 1 
 RX AFE control 1 
 Tx AFE control 1 
 Tx AFE control 2 
 Tranceiver LSSI Readback 
  function:  This function is to write register and then readback to make
             sure whether BB and RF is OK
  input:     net_device        dev
             hw90_block_e      CheckBlock
             rf90_radio_path_e e_rfpath  only used when checkblock is
                                        HW90_BLOCK_RF
  output:    none
  return:    return whether BB and RF is ok (0:OK, 1:Fail)
  notice:    This function may be removed in the ASIC
 Initialize register address offset to be checked 
 Write data to register and readback 
			 TODO: we should not delay for such a long time.
			  Ask SD3
 Check whether readback data is correct 
  function:  This function initializes BB&RF
  input:     net_device	dev
  output:    none
  return:    none
  notice:    Initialization value may change all the time, so please make
             sure it has been synced with the newest.
	
	  <1> Initialize BaseBand
 --set BB Global Reset-- 
 ---set BB reset Active--- 
 ----Ckeck FPGAPHY0 and PHY1 board is OK---- 
 TODO: this function should be removed on ASIC 
 don't care RF path 
 ---- Set CCK and OFDM Block "OFF"---- 
 ----BB Register Initilazation---- 
 ==m==>Set PHY REG From Header<==m== 
 ----Set BB reset de-Active---- 
 ----BB AGC table Initialization---- 
 ==m==>Set PHY REG From Header<==m== 
 ----Enable XSTAL ---- 
 Antenna gain offset from BCD to A 
 XSTALLCap 
	 Check if the CCK HighPower is turned ON.
	  This is used to calculate PWDB.
  function:  This function initializes BB&RF
  input:     net_device	dev
  output:    none
  return:    none
  notice:    Initialization value may change all the time, so please make
             sure it has been synced with the newest.
	 config BB&RF. As hardCode based initialization has not been well
	  implemented, so use file first.
	  FIXME: should implement it for hardcode?
  function:  This function obtains the initialization value of Tx power Level
             offset
  input:     net_device	dev
  output:    none
  return:    none
 Read rx initial gain 
 Read framesync 
 Read SIFS (save the value read fome MACPHY_REG.txt) 
  function:  This function sets the initialization value of Tx power Level
             offset
  input:     net_device        dev
             u8                channel
  output:    none
  return:    none
 need further implement 
  function:  This function checks Rf chip to do RF config
  input:     net_device	dev
  output:    none
  return:    only 8256 is supported
  function:  This function updates Initial gain
  input:     net_device	dev
  output:    none
  return:    As Windows has not implemented this, wait for complement
  function:  This function read RF parameters from general head file,
             and do RF 3-wire
  input:     net_device	dev
             rf90_radio_path_e e_rfpath
  output:    none
  return:    return code show if RF configuration is successful(0:pass, 1:fail)
  notice:    Delay may be required for RF configuration
  function:  This function sets Tx Power of the channel
  input:     net_device        dev
             u8                channel
  output:    none
  return:    none
  notice:
  function:  This function sets RF state on or off
  input:     net_device         dev
             RT_RF_POWER_STATE  eRFPowerState  Power State to set
  output:    none
  return:    none
  notice:
 RF-A, RF-B 
 enable RF-Chip AB - 0x860[4] 
 analog to digital on - 0x88c[9:8] 
 digital to analog on - 0x880[4:3] 
 rx antenna on - 0xc04[1:0] 
 rx antenna on - 0xd04[1:0] 
 analog to digital part2 on - 0x880[6:5] 
 RF-A, RF-B 
 disable RF-Chip AB - 0x860[4] 
 analog to digital off, for power save 
 0x88c[11:8] 
 digital to analog off, for power save - 0x880[4:3] 
 rx antenna off - 0xc04[3:0] 
 rx antenna off - 0xd04[3:0] 
 analog to digital part2 off, for power save 
 0x880[6:5] 
  function:  This function sets command table variable (struct sw_chnl_cmd).
  input:     sw_chnl_cmd      CmdTable    table to be set
             u32            CmdTableIdx  variable index in table to be set
             u32            CmdTableSz   table size
             switch_chan_cmd_id    CmdID        command ID to set
             u32            Para1
             u32            Para2
             u32            msDelay
  output:
  return:    true if finished, false otherwise
  notice:
  function:  This function sets channel step by step
  input:     net_device        dev
             u8                channel
             u8                stage   3 stages
             u8                step
             u32               delay   whether need to delay
  output:    store new stage, step and delay for next step
             (combine with function above)
  return:    true if finished, false otherwise
  notice:    Wait for simpler function to replace it
		 return true to tell upper caller function this channel
		  setting is finished! Or it will in while loop.
 FIXME: need to check whether channel is legal or not here 
 <1> Fill up pre common command. 
 <2> Fill up post common command. 
 <3> Fill up RF dependent command. 
 TEST!! This is not the table for 8256!! 
 consider it later! 
  function:  This function does actually set channel work
  input:     net_device        dev
             u8                channel
  output:    none
  return:    none
  notice:    We should not call this function directly
  function:  Callback routine of the work item for switch channel.
  input:     net_device	dev
  output:    none
  return:    none
  function:  This function scheduled actual work item to set channel
  input:     net_device        dev
             u8                channel   channel to set
  output:    none
  return:    return code show if workitem is scheduled (1:pass, 0:fail)
  notice:    Delay may be required for RF configuration
 -------------------------------------------- 
 -------------------------------------------- 
  function:  Callback routine of the work item for set bandwidth mode.
  input:     net_device	 dev
  output:    none
  return:    none
  notice:    I doubt whether SetBWModeInProgress flag is necessary as we can
             test whether current work in the queue or not.do I?
 <1> Set MAC register 
 We have not verify whether this register works 
 We have not verify whether this register works 
 <2> Set PHY related register 
 Correct the tx power for CCK rate in 20M. 
	 Skip over setting of J-mode in BB register here.
	  Default value is "None J mode".
 <3> Set RF related register 
  function:  This function schedules bandwidth switch work.
  input:     struct net_deviceq   dev
             HT_CHANNEL_WIDTH     bandwidth  20M or 40M
             HT_EXTCHNL_OFFSET    offset     Upper, Lower, or Don't care
  output:    none
  return:    none
  notice:    I doubt whether SetBWModeInProgress flag is necessary as we can
 	      test whether current work in the queue or not.do I?
 FW DIG OFF 
 Bit0 ~ Bit6 
 FW DIG OFF 
 FW DIG ON 
 SPDX-License-Identifier: GPL-2.0
++
Copyright-c Realtek Semiconductor Corp. All rights reserved.
Module Name:
	r8192U_dm.c
Abstract:
	HW dynamic mechanism.
Major Change History:
	When		Who				What
	----------	--------------- -------------------------------
	2008-05-14	amy                     create version 0 porting from windows code.
---------------------------Define Local Constant---------------------------
 Indicate different AP vendor for IOT issue. 
---------------------------Define Local Constant---------------------------
------------------------Define global variable-----------------------------
 Debug variable ? 
 Store current software write register content for MAC PHY. 
 For Dynamic Rx Path Selection by Signal Strength 
 DM --> Rate Adaptive 
 DM --> Bandwidth switch 
 DM --> TX power control 
static	void	dm_initialize_txpower_tracking(struct net_device dev);
static	void	dm_txpower_reset_recovery(struct net_device dev);
 DM --> Dynamic Init Gain by RSSI 
 DM --> EDCA turbo mode control 
static	void	dm_gpio_change_rf(struct net_device dev);
 DM --> Check PBC 
 DM --> Check current RX RF path state 
 DM --> Fsync for broadcom ap 
 Added by vivi, 20080522 
---------------------Define local function prototype-----------------------
---------------------Define of Tx Power Control For NearFar Range --------   
 DM --> For rate adaptive and DIG, we must send RSSI to firmware 
---------------------------Define function prototype------------------------
 ================================================================================
 	HW Dynamic mechanism interface.
  ================================================================================
 	Description:
 		Prepare SW resource for HW dynamic mechanism.
 	Assumption:
 		This function is only invoked at driver initialization once.
 Undecorated Smoothed Signal Strength, it can utilized to dynamic mechanism. 
 Initial TX Power Control for nearfar range , add by amy 20080515, porting from windows code. 
dm_initialize_txpower_tracking(dev);
 InitHalDm 
	if (pHalData->bForcedUsbRxAggr) {
		if (pHalData->ForcedUsbRxAggrInfo == 0) {
			if (pHalData->bCurrentRxAggrEnable) {
				Adapter->HalFunc.HalUsbRxAggrHandler(Adapter, FALSE);
			}
		} else {
			if (!pHalData->bCurrentRxAggrEnable || (pHalData->ForcedUsbRxAggrInfo != pHalData->LastUsbRxAggrInfoSetting)) {
				Adapter->HalFunc.HalUsbRxAggrHandler(Adapter, TRUE);
			}
		}
		return;
	}
			 If usb rx firmware aggregation is enabled,
			  when anyone of three threshold conditions above is reached,
			  firmware will send aggregated packet to driver.
 dm_CheckEdcaTurbo 
struct r8192_priv priv = ieee80211_priv(dev);
static u8	previous_bssid[6] ={0};
Add by amy 20080515 ,porting from windows code.
 Add by amy 2008-05-15 porting from windows code. 
 HalDmWatchDog 
 Decide Rate Adaptive Set according to distance (signal strength)
 	01112008	MHC		Modify input arguments and RATR table level.
 	01162008	MHC		RF_Type is assigned in ReadAdapterInfo(). We must call
 						the function after making sure RF_Type.
		 071008 MH Modify for RA smooth scheme.
		  20080111 MH Modify 2T RATR table for different RSSI. 080515 porting by amy from windows code.
 cosa add for test 
 cosa add for test 
 InitRateAdaptive 
-----------------------------------------------------------------------------
  Function:	dm_check_rate_adaptive()
  Overview:
  Input:		NONE
  Output:		NONE
  Return:		NONE
  Revised History:
 	When		Who		Remark
 	052608	amy	Create version 0 porting from windows code.
 this variable is set by ioctl. 
 TODO: Only 11n mode is implemented currently, 
RT_TRACE(COMP_RATE, "dm_CheckRateAdaptive(): \t");
 Check whether Short GI is enabled 
 cosa add for test 
		 20071008 MH We support RA smooth scheme now. When it is the first
		  time to link with AP. We will not change upperlower threshold. If
		  STA stay in high or low level, we must change two different threshold
		  to prevent jumping frequently.
DbgPrint("[DM] THresh HL=%d%d\n\r", RATR.HighRSSIThreshForRA, RATR.LowRSSIThreshForRA);
DbgPrint("[DM] RSSI=%d STA=HIGH\n\r", pHalData->UndecoratedSmoothedPWDB);
DbgPrint("[DM] RSSI=%d STA=Middle\n\r", pHalData->UndecoratedSmoothedPWDB);
DbgPrint("[DM] RSSI=%d STA=LOW\n\r", pHalData->UndecoratedSmoothedPWDB);
 cosa add for test 
pHalData->UndecoratedSmoothedPWDB = 19;
DbgPrint("TestRSSI = %d, set RATR to 0x%x\n", pHalData->UndecoratedSmoothedPWDB, pRA->TestRSSIRATR);
				else
DbgPrint("TestRSSI Recover to 0x%x\n", targetRATR);
		 2008.04.01
		  For RTL819X, if pairwisekey = weptkip, we support only MCS0~7.
 Check whether updating of RATR0 is required 
 dm_CheckRateAdaptive 
 dm_init_bandwidth_autoswitch 
 If send packets in 40 Mhz in 2040 
 in force send packets in 20 Mhz in 2040 
 dm_BandwidthAutoSwitch 
 OFDM default at 0db, index=6. 
 0, +6db 
 1, +5db 
 2, +4db 
 3, +3db 
 4, +2db 
 5, +1db 
 6, +0db ===> default, upper for higher temperature, lower for low temperature 
 7, -1db 
 8, -2db 
 9, -3db 
 10, -4db 
 11, -5db 
 12, -6db 
 13, -7db 
 14, -8db 
 15, -9db 
 16, -10db 
 17, -11db 
 18, -12db 
 0, +0db ===> CCK40M default 
 1, -1db 
 2, -2db 
 3, -3db 
 4, -4db 
 5, -5db 
 6, -6db ===> CCK20M default 
 7, -7db 
 8, -8db 
 9, -9db 
 10, -10db 
 11, -11db 
 0, +0db  ===> CCK40M default 
 1, -1db 
 2, -2db 
 3, -3db 
 4, -4db 
 5, -5db 
 6, -6db  ===> CCK20M default 
 7, -7db 
 8, -8db 
 9, -9db 
 10, -10db 
 11, -11db 
RT_STATUS				rtStatus = RT_STATUS_SUCCESS;
 fill tx_cmd 
DbgPrint("hi, vivi, strange\n");
 check if the report value is right 
if (abs(Avg_TSSI_Meas_from_driver - TSSI_13dBm) <= E_FOR_TX_POWER_TRACK)
 For MacOS-compatible 
 Query OFDM default setting 
 find the index 
 Query CCK default setting From 0xa22 
pHalData->TXPowercount = 0;
	 ==========================
	  this is only for test, should be masked
	  ==========================
 read and filter out unreasonable value 
 0x12: RF Reg[10:7] 
 if over 12, TP will be bad when high temperature 
 We use fixed value by Bryant's suggestion 
 We use fixed value by Bryant's suggestion 
 Get current RF-A temperature index 
 lower temperature 
 higher temperature 
 max to +6dB 
	DbgPrint("%ddb, tmpOFDMindex = %d, tmpCCK20Mindex = %d, tmpCCK40Mindex = %d",
		((u1Byte)tmpRegA - pHalData->ThermalMeter[0]),
 40M 
DbgPrint("Update CCK Swing, CCK_index = %d\n", pHalData->CCK_index);
 Initial the Tx BB index and mapping value 
	 ccktxbb_valuearray[0] is 0xA22 [1] is 0xA24 ...[7] is 0xA29
	  This Table is for CH1~CH13
	 ccktxbb_valuearray[0] is 0xA22 [1] is 0xA24 ...[7] is 0xA29
	  This Table is for CH14
	 Tx Power tracking by Thermal Meter requires Firmware RW 3-wire. This mechanism
	  can be enabled only when Firmware RW 3-wire is enabled. Otherwise, frequent rw
	  3-wire by driver causes RF to go into a wrong state.
 dm_InitializeTXPowerTracking 
DbgPrint("dm_CheckTXPowerTracking()\n");
		 Attention!! You have to write all 12bits of data to RF, or it may cause RF to crash
		  actually write reg0x02 bit1=0, then bit1=1.
		  DbgPrint("Trigger ThermalMeter, write RF reg0x2 = 0x4d to 0x4f\n");
DbgPrint("Schedule TxPowerTrackingWorkItem\n");
static u32 tx_power_track_counter = 0;
 dm_CheckTXPowerTracking 
 Write 0xa22 0xa23 
 Write 0xa22 0xa23 
 Write 0xa24 ~ 0xa27 
 Write 0xa28  0xa29 
 Write 0xa24 ~ 0xa27 
 Write 0xa28  0xa29 
 Write 0xa22 0xa23 
 Write 0xa24 ~ 0xa27 
 Write 0xa28  0xa29 
priv->CCKTxPowerAdjustCntNotCh14++;	cosa add for debug.
 Write 0xa22 0xa23 
 Write 0xa24 ~ 0xa27 
 Write 0xa28  0xa29 
  dm_CCKTxPowerAdjust 
 dm_TXPowerResetRecovery 
 Restore previous state for rate adaptive 
 TODO: Only 11n mode is implemented currently, 
 20071115 MH Copy from 8190PCI. 
 1T2R, Spatial Stream 2 should be disabled 
DbgPrint("HW_VAR_TATR_0 from 0x%x ==> 0x%x\n", ((pu4Byte)(val))[0], ratr_value);
DbgPrint("set HW_VAR_TATR_0 = 0x%x\n", ratr_value);
cosa PlatformEFIOWrite4Byte(Adapter, RATR0, ((pu4Byte)(val))[0]);
 Restore TX Power Tracking Index 
 Restore BB Initial Gain 
 DM_RestoreDynamicMechanismState 
 Bit0~ Bit6 
 Disable Initial Gain 
PHY_SetBBReg(Adapter, UFWP, bMaskLWord, 0x800);
 Only clear byte 1 and rewrite. 
 Enable Initial Gain 
PHY_SetBBReg(Adapter, UFWP, bMaskLWord, 0x100);
 Only clear byte 1 and rewrite. 
 dm_BBInitialGainRestore 
 Bit0~ Bit6 
PHY_SetBBReg(Adapter, UFWP, bMaskLWord, 0x800);
 Only clear byte 1 and rewrite. 
 dm_BBInitialGainBakcup 
-----------------------------------------------------------------------------
  Function:	dm_dig_init()
  Overview:	Set DIG scheme init value.
  Input:		NONE
  Output:		NONE
  Return:		NONE
  Revised History:
 	When		Who		Remark
 	05152008	amy		Create Version 0 porting from windows code.
 20071005 MH Disable DIG scheme now. Not tested. 
 20071004 MH Define init gain threshold. 
 for new dig debug rssi value 
 dm_dig_init 
-----------------------------------------------------------------------------
  Function:	dm_ctrl_initgain_byrssi()
  Overview:	Driver must monitor RSSI and notify firmware to change initial
 				gain according to different threshold. BB team provide the
 				suggested solution.
  Input:			struct net_device dev
  Output:		NONE
  Return:		NONE
  Revised History:
 	When		Who		Remark
 	05272008	amy		Create Version 0 porting from windows code.
 ; 
DbgPrint("Dig by Sw Rssi\n");
 if switched algorithm, we have to disable FW Dig. 
 execute several times to make sure the FW Dig is disabled 
 FW DIG Off 
 Only clear byte 1 and rewrite. 
 fw dig off. 
	DbgPrint("DM_DigTable.PreConnectState = %d, DM_DigTable.CurConnectState = %d\n",
DbgPrint("DM_DigTable.Rssi_val = %d\n", DM_DigTable.Rssi_val);
 dm_CtrlInitGainByRssi 
 Fw DIG On. 
 Only clear byte 1 and rewrite.
 For smooth, we can not change DIG state. 
DbgPrint("Dig by Fw False Alarm\n");
if (DM_DigTable.Dig_State == DM_STA_DIG_OFF)
	DbgPrint("DIG Check\n\r RSSI=%d LOW=%d HIGH=%d STATE=%d",
	pHalData->UndecoratedSmoothedPWDB, DM_DigTable.RssiLowThresh,
	 1. When RSSI decrease, We have to judge if it is smaller than a threshold
	  and then execute the step below.
		 20080205 MH When we execute silent reset, the DIG PHY parameters
		  will be reset to init value. We must prevent the condition.
 If DIG is off, DIG high power state must reset. 
  1.1 DIG Off. 
  Only clear byte 1 and rewrite. 
  1.2 Set initial gain. 
  1.3 Lower PD_TH for OFDM. 
			 20080111 MH 40MHZ 9092 register are not the same.
			  20080205 MH SD3-Jerry 92U92E PD_TH are the same.
			else if (priv->card_8192 == HARDWARE_TYPE_RTL8190P)
				write_nic_byte(pAdapter, rOFDM0_RxDetector1, 0x40);
			else if (pAdapter->HardwareType == HARDWARE_TYPE_RTL8192E)
			else
				PlatformEFIOWrite1Byte(pAdapter, rOFDM0_RxDetector1, 0x40);
 1.4 Lower CS ratio for CCK. 
 1.5 Higher EDCCA. 
PlatformEFIOWrite4Byte(pAdapter, rOFDM0_ECCAThreshold, 0x325);
	 2. When RSSI increase, We have to judge if it is larger than a threshold
	  and then execute the step below.
DbgPrint("DIG ON\n\r");
		 2.1 Set initial gain.
		  20080226 MH SD3-Jerry suggest to prevent dirty environment.
 2.2 Higher PD_TH for OFDM. 
			 20080111 MH 40MHZ 9092 register are not the same.
			  20080205 MH SD3-Jerry 92U92E PD_TH are the same.
			
			else if (priv->card_8192 == HARDWARE_TYPE_RTL8190P)
				write_nic_byte(dev, rOFDM0_RxDetector1, 0x42);
			else if (pAdapter->HardwareType == HARDWARE_TYPE_RTL8192E)
			else
				PlatformEFIOWrite1Byte(pAdapter, rOFDM0_RxDetector1, 0x42);
 2.3 Higher CS ratio for CCK. 
		 2.4 Lower EDCCA.
		  20080111 MH 9092 series are the same.
PlatformEFIOWrite4Byte(pAdapter, rOFDM0_ECCAThreshold, 0x346);
 2.5 DIG On. 
  Only clear byte 1 and rewrite. 
 dm_CtrlInitGainByRssi 
-----------------------------------------------------------------------------
  Function:	dm_ctrl_initgain_byrssi_highpwr()
  Overview:
  Input:		NONE
  Output:		NONE
  Return:		NONE
  Revised History:
 	When		Who		Remark
 	05282008	amy		Create Version 0 porting from windows code.
  For smooth, we can not change high power DIG state in the range. 
	 3. When RSSI >75% or <70%, it is a high power issue. We have to judge if
	     it is larger than a threshold and then execute the step below.
	 
	  20080205 MH SD3-Jerry Modify PD_TH for high power issue.
 3.1 Higher PD_TH for OFDM for high power state. 
			else if (priv->card_8192 == HARDWARE_TYPE_RTL8190P)
				write_nic_byte(dev, rOFDM0_RxDetector1, 0x41);
  3.2 Recover PD_TH for OFDM for normal power region. 
				else if (priv->card_8192 == HARDWARE_TYPE_RTL8190P)
					write_nic_byte(dev, rOFDM0_RxDetector1, 0x42);
 dm_CtrlInitGainByRssiHighPwr 
 current state is disconnected 
  disconnected -> connected or connected -> disconnected 
DbgPrint("DM_DigTable.CurIGValue = 0x%x, DM_DigTable.PreIGValue = 0x%x\n", DM_DigTable.CurIGValue, DM_DigTable.PreIGValue);
 if silent reset happened, we should rewrite the values back 
DbgPrint("Write initial gain = 0x%x\n", initial_gain);
  Set initial gain. 
 disconnected -> connected or connected -> disconnected 
  if silent reset happened, we should rewrite the values back 
DbgPrint("Write PD_TH state = %d\n", DM_DigTable.CurPD_THState);
  Lower PD_TH for OFDM. 
					 20080111 MH 40MHZ 9092 register are not the same.
					  20080205 MH SD3-Jerry 92U92E PD_TH are the same.
					else if (priv->card_8192 == HARDWARE_TYPE_RTL8190P)
						write_nic_byte(dev, rOFDM0_RxDetector1, 0x40);
 Higher PD_TH for OFDM. 
					 20080111 MH 40MHZ 9092 register are not the same.
					  20080205 MH SD3-Jerry 92U92E PD_TH are the same.
					else if (priv->card_8192 == HARDWARE_TYPE_RTL8190P)
						write_nic_byte(dev, rOFDM0_RxDetector1, 0x42);
 Higher PD_TH for OFDM for high power state. 
					else if (priv->card_8192 == HARDWARE_TYPE_RTL8190P)
						write_nic_byte(dev, rOFDM0_RxDetector1, 0x41);
 disconnected -> connected or connected -> disconnected 
 if silent reset happened, we should rewrite the values back 
DbgPrint("Write CS_ratio state = %d\n", DM_DigTable.CurCS_ratioState);
  Lower CS ratio for CCK. 
  Higher CS ratio for CCK. 
 dm_init_edca_turbo 
PSTA_QOS			pStaQos = pMgntInfo->pStaQos;
 Keep past TxRx packet count for RT-to-RT EDCA turbo. 
	 Do not be Turbo if it's under WiFi config and Qos Enabled, because the EDCA parameters
	  should follow the settings from QAP. By Bruce, 2007-12-07.
 We do not turn on EDCA turbo mode for some AP that has IOT issue 
printk("========>%s():bis_any_nonbepkts is %d\n", __func__, priv->bis_any_nonbepkts);
 Check the status for current condition. 
 For RT-AP, we needs to turn it on when Rx>Tx 
printk("%s():curRxOkCnt > 4curTxOkCnt\n");
printk("%s():curRxOkCnt < 4curTxOkCnt\n");
		 Turn Off EDCA turbo here.
		  Restore original EDCA according to the declaration of AP.
  For Each time updating EDCA parameter, reset EDCA turbo mode status. 
			 Check ACM bit.
			  If it is set, immediately set ACM control bit to downgrading AC for passing WMM testplan. Annie, 2005-12-13.
  TODO:  Modified this part and try to set acm control in only 1 IO processing!! 
  acm bit is 1. 
 ACM bit is 0. 
 Set variables for next time. 
 dm_CheckEdcaTurbo 
	 1. Uplink
	  2. Linksys350Linksys300N
	  3. <50 disable, >55 enable
 downlink, disable CTS to self 
DbgPrint("dm_CTSToSelf() ==> CTS to self disabled -- downlink\n");
 uplink 
-----------------------------------------------------------------------------
  Function:	dm_check_pbc_gpio()
  Overview:	Check if PBC button is pressed.
  Input:		NONE
  Output:		NONE
  Return:		NONE
  Revised History:
 	When		Who		Remark
 	05282008	amy	Create Version 0 porting from windows code.
		 Here we only set bPbcPressed to TRUE
		  After trigger PBC, the variable will be set to FALSE
-----------------------------------------------------------------------------
  Function:	DM_RFPathCheckWorkItemCallBack()
  Overview:	Check if Current RF RX path is enabled
  Input:		NONE
  Output:		NONE
  Return:		NONE
  Revised History:
 	When		Who		Remark
 	01302008	MHC		Create Version 0.
bool bactually_set = false;
	 20080130 MH After discussing with SD3 Jerry, 0xc040xd04 register will
	  always be the same. We only read 0xc04 now.
 Check Bit 0-3, it means if RF A-D is enabled. 
 DM_RFPathCheckWorkItemCallBack 
 RF-C 
 RF-D 
 pure B mode, fixed cck version2 
DbgPrint("Pure B mode, use cck rx version2\n");
 decide maxsecmin rssi index 
 find first enabled rf path and the rssi values 
 initialize, set all rssi index to the same one 
 we pick up the max index first, and let sec and min to be the same one 
 let sec and min point to the different index 
 let sec and min point to the different index 
 This case we don't need to set any index 
 This case we don't need to set any index 
 let sec and min point to the different index 
 This case we don't need to set any index 
 decide maxsecmin cck pwdb index 
 find first enabled rf path and the rssi values 
 initialize, set all rssi index to the same one 
 we pick up the max index first, and let sec and min to be the same one 
 let sec and min point to the different index 
 let sec and min point to the different index 
 otherwise we don't need to set any index 
  This case we don't need to set any index 
  let sec and min point to the different index 
 otherwise we don't need to set any index 
	 Set CCK Rx path
	  reg0xA07[3:2]=cck default rx path, reg0xa07[1:0]=cck optional rx path.
 record the enabled rssi threshold 
 disable the BB Rx path, OFDM 
 0xc04[3:0] 
 0xd04[3:0] 
 disabled rf 
 enable the BB Rx path 
DbgPrint("RF-%d is enabled.\n", 0x1<<i);
 0xc04[3:0] 
 0xd04[3:0] 
-----------------------------------------------------------------------------
  Function:	dm_check_rx_path_selection()
  Overview:	Call a workitem to check current RXRF path and Rx Path selection by RSSI.
  Input:		NONE
  Output:		NONE
  Return:		NONE
  Revised History:
 	When		Who		Remark
 	05282008	amy		Create Version 0 porting from windows code.
 dm_CheckRxRFPath 
 current default 0xc38 monitor on 
 Count rate 54, MCS [7], [12, 13, 14, 15] 
 Continue count 
 Continue count over 
 Stop the continued count 
 If Count diff <= FsyncRateCountThreshold 
 if we never receive those mcs rate and rssi > 30 % then switch fsyn 
 Let Register return to default value; 
 Let Register return to default value; 
 Initial rate record to zero, start to record. 
 Initialize continue diff count to zero, start to record. 
u32			framesyncC34;
 For broadcom AP we write different default value 
DbgPrint("Fsync is idle, rssi>=40, write 0xc38 = 0x%x\n", pHalData->framesync);
DbgPrint("Fsync is idle, not connected, write 0xc38 = 0x%x\n", pHalData->framesync);
 After silent reset, the reg_c38_State will be returned to default value 
DbgPrint("reg_c38_State = 0 for silent reset.\n");
DbgPrint("framesync no monitor, write 0xc38 = 0x%x\n", pHalData->framesync);
-----------------------------------------------------------------------------
  Function:	dm_shadow_init()
  Overview:	Store all NIC MACBB register content.
  Input:		NONE
  Output:		NONE
  Return:		NONE
  Revised History:
 	When		Who		Remark
 	05292008	amy		Create Version 0 porting from windows code.
 ---------------------------------------------------------------------------
DbgPrint("P-%dO-%02x=%02x\r\n", page, offset, DM_Shadow[page][offset]);
 dm_shadow_init 
---------------------------Define function prototype------------------------
-----------------------------------------------------------------------------
  Function:	DM_DynamicTxPower()
  Overview:	Detect Signal strength to control TX Registry
			Tx Power Control For NearFar Range
  Input:		NONE
  Output:		NONE
  Return:		NONE
  Revised History:
 	When		Who		Remark
 	03062008	Jacken	Create Version 0.
 ---------------------------------------------------------------------------
 Initial TX Power Control for nearfar range , add by amy 20080515, porting from windows code. 
 Default to enable Tx Power Control 
printk("priv->ieee80211->current_network.unknown_cap_exist is %d , priv->ieee80211->current_network.broadcom_cap_exist is %d\n", priv->ieee80211->current_network.unknown_cap_exist, priv->ieee80211->current_network.broadcom_cap_exist);
printk("=======>%s(): txhipower_threshold is %d, txlowpower_threshold is %d\n", __func__, txhipower_threshold, txlowpower_threshold);
 high power state check 
 low power state check 
pHalData->bTXPowerCtrlforNearFarRange = !pHalData->bTXPowerCtrlforNearFarRange;
pHalData->bStartTxCtrlByTPCNFR = FALSE;    Clear th flag of Set TX Power from Sitesurvey
 dm_dynamic_txpower 
 added by vivi, for read tx rate and retrycount 
 for 11n tx rate 
priv->stats.CurrentShowTxate = read_nic_byte(dev, CURRENT_TX_RATE_REG);
printk("=============>tx_rate_reg:%x\n", ieee->softmac_stats.CurrentShowTxate);
 for initial tx rate 
priv->stats.last_packet_rate = read_nic_byte(dev, INITIAL_TX_RATE_REG);
 for tx tx retry count 
priv->stats.txretrycount = read_nic_dword(dev, TX_RETRY_COUNT_REG);
	 If we test chariot, we should stop the TX command ?
	  Because 92E will always silent reset when we send tx command. We use register
	  0x1e0(byte) to notify driver.
---------------------------Define function prototype------------------------
 SPDX-License-Identifier: GPL-2.0
  Host AP crypt: host-based WEP encryption implementation for Host AP driver
  Copyright (c) 2002-2004, Jouni Malinen <jkmaline@cc.hut.fi>
 start WEP IV from a random value 
 Perform WEP encryption on given skb that has at least 4 bytes of headroom
  for IV and 4 bytes of tailroom for ICV. Both IV and ICV will be transmitted,
  so the payload length increases with 8 bytes.
  WEP frame payload: IV + TX key idx, RC4(data), ICV = RC4(CRC32(data))
	 Fluhrer, Mantin, and Shamir have reported weaknesses in the key
	  scheduling algorithm of RC4. At least IVs (KeyByte + 3, 0xff, N)
	  can be used to speedup attacks, so avoid using them.
 Prepend 24-bit IV to RC4 key and TX frame 
 Copy rest of the WEP key (the secret part) 
 Append little-endian CRC32 and encrypt it to produce ICV 
 Perform WEP decryption on given buffer. Buffer includes whole WEP part of
  the frame: IV (4 bytes), encrypted payload (including SNAP header),
  ICV (4 bytes). len includes both IV and ICV.
  Returns 0 if frame was decrypted successfully and ICV was correct and -1 on
  failure. If frame is OK, IV and ICV will be removed.
 Copy rest of the WEP key (the secret part) 
 Apply RC4 to data and compute CRC32 over decrypted data 
 ICV mismatch - drop frame 
 Remove IV and ICV 
 IV 
 ICV 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2004 Intel Corporation. All rights reserved.
  Portions of this file are based on the WEP enablement code provided by the
  Host AP project hostap-drivers v0.1.3
  Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
  <jkmaline@cc.hut.fi>
  Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
  Contact Information:
  James P. Ketrenos <ipw2100-admin@linux.intel.com>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
 First entry MUST be the AP MAC address 
 Remaining entries will be displayed in the order we provide them 
 Add the ESSID 
	if (network->flags & NETWORK_EMPTY_ESSID) {
 Add the protocol name 
 Add mode 
 Add frequencychannel 
	iwe.u.freq.m = ieee80211_frequency(network->channel, network->mode);
 Add encryption capability 
 Add basic and extended rates 
 add N rate here  {
 Add quality statistics 
 TODO: Fix these values... 
	printk("WPA IE\n");
	 Add EXTRA: Age to display seconds since last beaconprobe response
	char stop = ev + IW_SCAN_MAX_DATA;
IW_SCAN_MAX_DATA;
char stop = ev + IW_SCAN_MAX_DATA;
		 Check all the keys to see if any are still configured,
		 changing to use WEP; deinit previously used algorithm
 take WEP into use 
 If a new key was provided, set it up 
		 This ensures a key will be activated if no key is
		  explicitly set
 Set a default key of all 0 
 No key data - just set the default TX key index 
	 For now we just support WEP, so only set that security level...
 40 and 104 bit WEP 
	 Do not reset port if card is in Managed mode since resetting will
	  generate new IEEE 802.11 authentication which may end up in looping
	  with IEEE 802.1X.  If your hardware requires a reset after WEP
	  configuration (for example... Prism2), implement the reset_port in
 some Cisco APs use idx>0 for unicast in dynamic WEP 
 | SEC_ENCRYPT;
  sec.encrypt = 0;
    sec.encrypt = 1;
skip_host_crypt:
memcpy(sec.keys[idx], ext->key, ext->key_len);
  sec.encode_alg[idx] = SEC_ALG_WEP;
  sec.encode_alg[idx] = SEC_ALG_TKIP;
 sec.encode_alg[idx] = SEC_ALG_CCMP;
 Don't set sec level for group keys. 
need to support wpa2 here
		
                    Host AP driver does not use these parameters and allows
                                     wpa_supplicant to control them internally.
printk("======>%s():data->value is %d\n",__func__,data->value);
	ieee->open_wep = (data->value&IW_AUTH_ALG_OPEN_SYSTEM)?1:0;
printk("return error out, len:%d\n", len);
 SPDX-License-Identifier: GPL-2.0
  Host AP crypto routines
  Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
  Portions Copyright (C) 2004, Intel Corporation <jketreno@linux.intel.com>
	 must not run ops->deinit() while there may be pending encrypt or
	  decrypt operations. Use a list of delayed deinits to avoid needing
	  locking.
 SPDX-License-Identifier: GPL-2.0
  This file is created to process BA Action Frame. According to 802.11 spec, there are 3 BA action types at all. And as BA is
  related to TS, this part need some structure defined in QOS side code. Also TX RX is going to be resturctured, so how to send
  ADDBAREQ ADDBARSP and DELBA packet is still on consideration. Temporarily use MANAGE QUEUE instead of Normal Queue.
  WB 2008-05-27
 function:  Activate BA entry. And if Time is nozero, start timer.
    input:  struct ba_record          pBA  BA entry to be enabled
 	     u16			Time indicate time delay.
   output:  none
 function:  deactivate BA entry, including its timer.
    input:  struct ba_record       pBA  BA entry to be disabled
   output:  none
 function: deactivete BA entry in Tx Ts, and send DELBA.
    input:
 	     struct tx_ts_record pTxTs Tx Ts which is to deactivate BA entry.
   output:  none
   notice:  As struct tx_ts_record  structure will be defined in QOS, so wait to be merged. FIXME
These two BA entries must exist in TS structure
 Delete pending BA
 Delete admitted BA
 function: deactivete BA entry in Tx Ts, and send DELBA.
    input:
 	     struct rx_ts_record  pRxTs Rx Ts which is to deactivate BA entry.
   output:  none
   notice:  As struct rx_ts_record  structure will be defined in QOS, so wait to be merged. FIXME, same with above
 function: reset BA entry
    input:
 	     struct ba_record pBA entry to be reset
   output:  none
These functions need porting here or not?
 function:  construct ADDBAREQ and ADDBARSP frame here together.
    input:  u8		Dst	ADDBA frame's destination
 	     struct ba_record  pBA	BA_RECORD entry which stores the necessary information for BA.
 	     u16		StatusCode  status code in RSP and I will use it to indicate whether it's RSP or REQ(will I?)
 	     u8			type	indicate whether it's RSP(ACT_ADDBARSP) ow REQ(ACT_ADDBAREQ)
   output:  none
   return:  sk_buff		skb     return constructed skb to xmit
category(1) + action field(1) + Dialog Token(1) + BA Parameter Set(2) +  BA Timeout Value(2) +  BA Start SeqCtrl(2)(or StatusCode(2))
need to add something others? FIXME
I wonder whether it's necessary. Apparently kernel will not do it when alloc a skb.
action frame
tag += sizeof( struct rtl_80211_hdr_3addr); 
 Dialog Token
 Status Code
 BA Parameter Set
 BA Timeout Value
 BA Start SeqCtrl
return NULL;
 function:  construct DELBA frame
    input:  u8		dst	DELBA frame's destination
 	     struct ba_record  pBA	BA_RECORD entry which stores the necessary information for BA
 	     enum tr_select	TxRxSelect  TX RX direction
 	     u16		ReasonCode  status code.
   output:  none
   return:  sk_buff		skb     return constructed skb to xmit
len = head len + DELBA Parameter Set(2) + Reason Code(2)
need to add something others? FIXME
	memset(skb->data, 0, len+sizeof( struct rtl_80211_hdr_3addr));
action frame
 DELBA Parameter Set
 Reason Code
 function: send ADDBAReq frame out
    input:  u8		dst	ADDBAReq frame's destination
 	     struct ba_record  pBA	BA_RECORD entry which stores the necessary information for BA
   output:  none
   notice: If any possible, please hide pBA in ieee. And temporarily use Manage Queue as softmac_mgmt_xmit() usually does
construct ACT_ADDBAREQ frames so set statuscode zero.
add statistic needed here.
and skb will be freed in softmac_mgmt_xmit(), so omit all dev_kfree_skb_any() outside softmac_mgmt_xmit()
WB
 function: send ADDBARSP frame out
    input:  u8		dst	DELBA frame's destination
 	     struct ba_record  pBA	BA_RECORD entry which stores the necessary information for BA
 	     u16		StatusCode RSP StatusCode
   output:  none
   notice: If any possible, please hide pBA in ieee. And temporarily use Manage Queue as softmac_mgmt_xmit() usually does
construct ACT_ADDBARSP frames
same above
 function: send ADDBARSP frame out
    input:  u8		dst	DELBA frame's destination
 	     struct ba_record  pBA	BA_RECORD entry which stores the necessary information for BA
 	     enum tr_select     TxRxSelect TX or RX
 	     u16		ReasonCode DEL ReasonCode
   output:  none
   notice: If any possible, please hide pBA in ieee. And temporarily use Manage Queue as softmac_mgmt_xmit() usually does
construct ACT_ADDBARSP frames
same above
 function: RX ADDBAReq
    input:  struct sk_buff    skb	incoming ADDBAReq skb.
   return:  0(pass), other(fail)
   notice:  As this function need support of QOS, I comment some code out. And when qos is ready, this code need to be support.
category+action
+DialogToken
some other capability is not ready now.
||
	(!ieee->pStaQos->bEnableRxImmBA)	)
 Search for related traffic stream.
 If there is no matched TS, reject the ADDBA request.
 To Determine the ADDBA Req content
 We can do much more check here, including buffer_size, AMSDU_Support, Policy, StartSeqCtrl...
 I want to check StartSeqCtrl to make sure when we start aggregation!!!
 Admit the ADDBA Request
for half N mode we only aggregate 1 frame
 End of procedure.
we send RSP out.
 function: RX ADDBARSP
    input:  struct sk_buff    skb	incoming ADDBAReq skb.
   return:  0(pass), other(fail)
   notice:  As this function need support of QOS, I comment some code out. And when qos is ready, this code need to be support.
 Check the capability
 Since we can always receive A-MPDU, we just check if it is under HT mode.
 Search for related TS.
 If there is no TS found, we wil reject ADDBA Rsp by sending DELBA frame.
 Check if related BA is waiting for setup.
 If not, reject by sending DELBA frame.
 Since BA is already setup, we ignore all other ADDBA Response.
 Determine ADDBA Rsp content here.
 We can compare the value of BA parameter set that Peer returned and Self sent.
 If it is OK, then admitted. Or we can send DELBA to cancel BA mechanism.
 Since this is a kind of ADDBA failed, we delay next ADDBA process.
 Admitted condition
 Delay next ADDBA process.
 End of procedure
 function: RX DELBA
    input:  struct sk_buff    skb	incoming ADDBAReq skb.
   return:  0(pass), other(fail)
   notice:  As this function need support of QOS, I comment some code out. And when qos is ready, this code need to be support.
PlatformCancelTimer(Adapter, &pTxTs->ts_add_ba_timer);
 ADDBA initiate. This can only be called by TX side.
 Set parameters to "Pending" variable set
 DialogToken: Only keep the latest dialog token
 Do not support A-MSDU with A-MPDU now!!
 Policy: Delayed or Immediate
 TID
 buffer_size: This need to be set according to A-MPDU vector
 buffer_size: This need to be set according to A-MPDU vector
 Timeout value: Set 0 to disable Timer
 Block Ack will start after 3 packets later.
 function:  BA setup timer
    input:  unsigned long	 data		acturally we send struct tx_ts_record or struct rx_ts_record to these timer
   return:  NULL
   notice:
 SPDX-License-Identifier: GPL-2.0
 Not implement yet
 This is used for WMMSA and ACM , that would send ADDTSReq frame.
 Not implement yet
 This is used for WMMSA and ACM.
 This function would be call when TS is no TxRx for some period of time.
 function:  I still not understand this function, so wait for further implementation
    input:  unsigned long	 data		acturally we send struct tx_ts_record or struct rx_ts_record to these timer
   return:  NULL
   notice:
u32 flags = 0;
 Indicate the pending packets sequentially according to SeqNum until meet the gap.
 Set rx_timeout_indicate_seq to 0xffff to indicate no pending packets in buffer now.
 Indicate packets
 function:  Add BA timer function
    input:  unsigned long	 data		acturally we send struct tx_ts_record or struct rx_ts_record to these timer
   return:  NULL
   notice:
For BA Originator
 This indicate the rx_indicate_seq is not used now!!
 This indicate the rx_timeout_indicate_seq is not used now!!
 For BA Recipient
 Initialize Tx TS related info.
 The timers for the operation of Traffic Stream and Block Ack.
 DLS related timer will be add here in the future!!
 Initialize Rx TS related info.
 Initialize unused Rx Reorder List.
DIRECTION_VALUE	dir;
FIXME
ap mode
for(dir = DIR_UP; dir <= DIR_BI_DIR; dir++)
		IEEE80211_DEBUG(IEEE80211_DL_TS, "ADD:%pM, TID:%d, dir:%d\n", pRet->Addr, pRet->TSpec.ts_info.ucTSID, pRet->TSpec.ts_info.ucDirection);
					printk("Bingo! got it\n");
Rx:1, Tx:0
 We do not build any TS for Broadcast or Multicast stream.
 So reject these kinds of search here.
 In WMM case: we use 4 TID only
 Create a new Traffic stream for current TxRx
 This is for EDCA and WMM to add a new TS.
 For HCCA or WMMSA, TS cannot be addmit without negotiation.
 Prepare TS Info related field
 Traffic type: WMM is reserved in this field
 TSID
 Direction: if there is DirectLink, this need additional consideration.
 Access policy
 Aggregation
 Aggregation
 User priority
 Ack policy
 Schedule
 if there is DirectLink, we need to do additional operation here!!
u32 flags = 0;
pRxReorderEntry = list_entry(&pRxTS->rx_pending_pkt_list.prev,RX_REORDER_ENTRY,List);
set 10 ticks
 SPDX-License-Identifier: GPL-2.0
 IEEE 802.11 SoftMAC layer
  Copyright (c) 2005 Andrea Merello <andrea.merello@gmail.com>
  Mostly extracted from the rtl8180-sa2400 driver for the
  in-kernel generic ieee802.11 stack.
  Few lines might be stolen from other part of the ieee80211
  stack. Copyright who own it's copyright
  WPA code stolen from the ipw2200 driver.
  Copyright who own it's copyright.
 returns the total length needed for placing the RATE MFIE
  tag and the EXTENDED RATE MFIE tag if needed.
  It includes two bytes per tag for the tag itself and its len
 place the MFIE rate, tag to the memory (double) pointer.
  Then it updates the pointer so that
  it points after the new MFIE tag added.
 We may add an option for custom rates that specific HW might support 
 We may add an option for custom rates that specific HW might support 
 0 
 5 
 0 
 5 
  if the queue is full but we have newer frames then
  just overwrites the oldest.
  if (nh == ieee->mgmt_queue_tail)
 		return -1;
return 0;
 20080125 MH For broadcom, MGNT frame set as OFDM 6M. 
 2005.01.26, by rcnjko. 
	
	 Data rate of ProbeReq is already decided. Annie, 2005-03-31
	if( pMgntInfo->bScanInProgress || (pMgntInfo->bDualModeScanStep!=0) ) {
	if(pMgntInfo->dot11CurrentWirelessMode==WIRELESS_MODE_A)
	rate = 0x0c;
	else
	rate = 0x02;
	}
 called with 2nd param 0, no mgmt lock required 
 avoid watchdog triggers 
dev_kfree_skb_any(skb);
 check whether the managed packet queued greater than 5 
 insert the skb packet to the management queue 
			 as for the completion function, it does not need
			  to check it any more.
dev_kfree_skb_any(skb);
 avoid watchdog triggers 
dev_kfree_skb_any(skb);
 FIXME: is this OK? 
unsigned long flags;
dev_kfree_skb_any(skb);
	ieee->beacon_timer.expires = jiffies +
		(MSECS( ieee->current_network.beacon_interval -5));
spin_lock_irqsave(&ieee->beacon_lock,flags);
		if(!timer_pending(&ieee->beacon_timer))
			add_timer(&ieee->beacon_timer);
spin_unlock_irqrestore(&ieee->beacon_lock,flags);
dev_kfree_skb_any(skb);
 this performs syncro scan blocking the caller until all channels
  in the allowed channel map has been checked.
 scan completed 
		 this function can be called in two situations
		  1- We have switched to ad-hoc mode and we are
		     performing a complete syncro scan before conclude
		     there are no interesting cell and to create a
		     new one. In this case the link state is
		     IEEE80211_NOLINK until we found an interesting cell.
		     If so the ieee8021_new_net, called by the RX path
		     will set the state to IEEE80211_LINKED, so we stop
		     scanning
		  2- We are linked and the root uses run iwlist scan.
		     So we switch to IEEE80211_LINKED_SCANNING to remember
		     that we are still logically linked (not interested in
		     new network events, despite for updating the net list,
		     but we are temporarily 'unlinked' as the driver shall
		     not filter RX frames and the channel is changing.
		  So the only situation in witch are interested is to check
		  if the state become LINKED because of the #1 situation
		 this prevent excessive time wait when we
		  need to wait for a syncro scan to end..
if current channel is not in channel map, set to default channel.
 no good chans 
	unsigned long flags;
ieee->sync_scan_hurryup = 1;
	spin_lock_irqsave(&ieee->lock, flags);
	spin_unlock_irqrestore(&ieee->lock, flags);
 called with ieee->lock held 
 called with wx_mutex held 
auth->algorithm = ieee->open_wep ? WLAN_AUTH_OPEN : WLAN_AUTH_SHARED_KEY;
 0x80; 
 HT ralated element 
	printk("===============>tmp_ht_cap_len is %d,tmp_ht_info_len is %d, tmp_generic_ie_len is %d\n",tmp_ht_cap_len,tmp_ht_info_len,tmp_generic_ie_len);
channel
	+ tmp_ht_cap_len
	+ tmp_ht_info_len
	+ tmp_generic_ie_len
		+ wmm_len+2
 FIXME 
 add short preamble here 
as Windows will set pairwise key same as the group key which is not allowed in Linux, so set this for IOT issue. WB 2008.07.07
skb->dev = ieee->dev;
unsigned long flags;
,rsn_ie;
short info_addr = 0;
int i;
u16 suite_count = 0;
u8 suit_select = 0;
unsigned int wpa_len = beacon->wpa_ie_len;
for HT
 Include High Throuput capability && Realtek proprietary 
 essid tagged val 
 rates tagged val 
 essid tagged val 
 rates tagged val 
for HW security, John
add short_preamble here
QOS
 For CCX 1 S13, CKIP. Added by Annie, 2006-08-14.
 "4500-client"
 Ref. CCX test plan v3.61, 3.2.3.1 step 13.
 We want to make the device type as "4500-client". 060926, by CCW.
 CCX1 spec V1.13, A01.1 CKIP Negotiation (page23):
 "The CKIP negotiation is started with the associate request from the client to the access point,
  containing an Aironet element with both the MIC and KP bits set."
HT cap element
choose what wpa_supplicant gives to associate.
	printk("<=====%s(), %p, %p\n", __func__, ieee->dev, ieee->dev->dev_addr);
	IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA, skb->data, skb->len);
	 don't scan, and avoid having the RX path possibly
	  try again to associate. Even do not react to AUTH or
	  ASSOC response. Just wait for the retry wq to be scheduled.
	  Here we will check if there are good nets to associate
	  with, so we retry or just get back to NO_LINK and scanning
BUGON when you try to add_timer twice, using mod_timer may be better, john0709
dev_kfree_skb_any(skb);
	int hlen = sizeof(struct ieee80211_authentication);
dev_kfree_skb_any(skb);
dev_kfree_skb_any(skb);
HTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);
 To prevent the immediately calling watch_dog after association.
	int i;
	struct net_device dev = ieee->dev;
ieee->UpdateHalRATRTableHandler(dev, ieee->dot11HTOperationalRateSet);
ieee->set_chan(ieee->dev, ieee->current_network.channel);
	 we are interested in new new only if we are not associated
	  and we are not associating  authenticating
		 if the user specified the AP MAC, we need also the essid
		  This could be obtained by beacons or, if the network does not
		  broadcast it, it can be put manually.
(memcmp(ieee->current_network.bssid, zero,ETH_ALEN)!=0 );
ieee->current_network.ssid[0] != '\0';
		 if the user set the AP check if match.
		  if the network does not broadcast essid we check the user supplyed ANY essid
		  if the network does broadcast and the user does not set essid it is OK
		  if the network does broadcast and the user did set essid check if essid match
		     if the ap is not set, check that the user set the bssid
		      and the network does broadcast and that those two bssid matches
			 if the essid is hidden replace it with the
			  essid provided by the user.
ieee->pHTInfo->IOTAction = 0;
 Join the network for the first time 
for HT by amy 080514
 (ieee->pHTInfo->bEnableHT && ieee->current_network.bssht.bdSupportHT))
WB, 2008.09.09:bCurrentHTSupport and bEnableHT two flags are going to put together to check whether we are in HT now, so needn't to check bEnableHT flags here. That's is to say we will set to HT support whenever joined AP has the ability to support HT. And whether we are in HT or not, please check bCurrentHTSupport&&bEnableHT now please.
	ieee->pHTInfo->bCurrentHTSupport = true;
HTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);
		 if the state become different that NOLINK means
		  we had found what we are searching for
 corrupted 
 point to the len field 
 point to the last data byte of the tag 
 point to the next tag 
IEEE80211DMESG("Card MAC address is "MACSTR, MAC2STR(src));
 ssid not found in tagged param 
IEEE80211DMESG("Rx probe");
DMESG("Dest is "MACSTR, MAC2STR(dest));
IEEE80211DMESG("Was for me!");
IEEE80211DMESG("Rx probe");
DMESG("Dest is "MACSTR, MAC2STR(dest));
unsigned long flags;
FIXME
 EXPORT_SYMBOL(ieee80211_sta_ps_send_null_frame); 
	if(ieee->ps == IEEE80211_PS_DISABLED ||
		ieee->iw_mode != IW_MODE_INFRA ||
		ieee->state != IEEE80211_LINKED)
		return 0;
should we use ps_timeout value or beacon_interval
	#warning CHECK_LOCK_HERE
 2 wake, 1 sleep, 0 do nothing 
	printk("send null 1\n");
#warning CHECK_LOCK_HERE
 Null frame with PS bit set 
		 if the card report not success we can't be sure the AP
		  has not RXed so we can't assume the AP believe us awake
 21112005 - tx again null without PS bit if lost 
	IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA|IEEE80211_DL_BA, skb->data, skb->len);
 default support N mode, disable halfNmode 
 WEP or TKIP encryption 
 Dummy wirless mode setting- avoid encryption issue 
 N mode setting 
 bg mode setting - TODO 
	struct ieee80211_info_element info_element;
 station support qos 
 Let the register setting defaultly with Legacy station 
filling the PeerHTCap. 
 aid could not been allocated 
		 FIXME for now repeat all the association procedure
		 both for disassociation and deauthentication
HTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);
dev_kfree_skb_any(skb);
 The following are for a simpler TX queue management.
  Instead of using netif_[stopwake]_queue, the driver
  will use these two functions (plus a reset one) that
  will internally call the kernel netif_ and take care
  of the ieee802.11 fragmentation.
  So, the driver receives a fragment at a time and might
  call the stop function when it wants, without taking
  care to have enough room to TX an entire packet.
  This might be useful if each fragment needs its own
  descriptor. Thus, just keeping a total free memory > than
  the max fragmentation threshold is not enough. If the
  ieee802.11 stack passed a TXB struct, then you would need
  to keep N free descriptors where
  N = MAX_PACKET_SIZE  MIN_FRAG_THRESHOLD.
  In this way you need just one and the 802.11 stack
  will take care of buffering fragments and pass them to
  to the driver later, when it wakes the queue.
 called with 2nd parm 0, no tx mgmt lock required 
 update the tx status 
 if xmit available, just xmit it immediately, else just insert it to the wait queue 
 insert the skb packet to the wait queue 
			 as for the completion function, it does not need
			  to check it any more.
printk("error:no descriptor left@queue_index %d\n", queue_index);
ieee80211_stop_queue(ieee);
ieee->stats.tx_packets++;
ieee->stats.tx_bytes += txb->fragments[i]->len;
ieee->dev->trans_start = jiffies;
exit:
 called with ieee->lock acquired 
(i+1)<ieee->tx_pending.txb->nr_frags);
dev_kfree_skb_any(skb);
unsigned long flags;
spin_lock_irqsave(&ieee->lock,flags);
spin_unlock_irqrestore(&ieee->lock,flags);
 called in user context only 
	 iwconfig mode ad-hoc will schedule this and return
	  on the other hand this will block further iwconfig SET
	  operations because of the wx_mutex hold.
	  Anyway some most set operations set a flag to speed-up
	  (abort) this wq (when syncro scanning) before sleeping
	  on the semaphore
 check if we have this cell in our network list 
	if((IS_DOT11D_ENABLE(ieee)) && (ieee->state == IEEE80211_NOLINK))
	 if not then the state is not linked. Maybe the user switched to
	  ad-hoc mode just after being in monitor mode, or just after
	  being very few time in managed mode (so the card have had no
	  time to scan all the chans..) or we have just run up the iface
	  after setting ad-hoc mode. So we have to give another try..
	  Here, in ibss mode, should be safe to do this without extra care
	  (in bss mode we had to make sure no-one tried to associate when
	  we had just checked the ieee->state and we was going to start the
	  scan) because in ibss mode the ieee80211_new_net function, when
	  finds a good net, just set the ieee->state to IEEE80211_LINKED,
	  so, at worst, we waste a bit of time to initiate an unneeded syncro
	  scan, that will stop at the first round because it sees the state
	  associated.
 the network definitively is not here.. create a new cell 
 By default, WMM function will be disabled in IBSS mode
 this is called only in user context, with wx_mutex held 
 Ref: 802.11d 11.1.3.3
 STA shall not start a BSS unless properly formed Beacon frame including a Country IE.
	 check if we have already found the net we
	  are interested in (if any).
	  if not (we are disassociated and we are not
	  in associating  authenticating phase) start the background scanning.
	 ensure no-one start an associating process (thus setting
	  the ieee->state to ieee80211_ASSOCIATING) while we
	  have just checked it and we are going to enable scan.
	  The ieee80211_new_net function is always called with
	  lock held (from both ieee80211_softmac_check_all_nets and
	  the rx path), so we cannot be in the middle of such function
 called only in userspace context 
HTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);
	 until we do not set the state to IEEE80211_NOLINK
	 there are no possibility to have someone else trying
	 to start an association procedure (we get here with
	 ieee->state = IEEE80211_ASSOCIATING).
	 When we set the state to IEEE80211_NOLINK it is possible
	 that the RX path run an attempt to associate, but
	 both ieee80211_softmac_check_all_nets and the
	 RX path works with ieee->lock held so there are no
	 problems. If we are still disassociated then start a scan.
	 the lock here is necessary to ensure no one try to start
	 an association procedure when we have just checked the
	 state and we are going to start the scan.
added as we disconnect from the previous BSS, Remove all TS
 no channel found 
	printk("===>%s(), chan:%d\n", __func__, ieee->current_network.channel);
	ieee->set_chan(ieee->dev,ieee->current_network.channel);
reinitialize AC_xx_PARAM registers.
	 if the user set the MAC of the ad-hoc cell and then
	  switch to managed mode, shall we  make sure that association
	  attempts does not fail just because the user provide the essid
	  and the nic is still checking for the AP MAC ??
added for  AP roaming
so IEEE2100-like driver are happy
support MCS 0~7
support MCS 8~15
added by amy
  Start of WPA code.                                   
  this is stolen from the ipw2200 driver               
	 This is called when wpa_supplicant loads and closes the driver
 make sure WPA is enabled 
 silently ignore
else
	ret = -EOPNOTSUPP;
		 HACK:
		 
		  wpa_supplicant calls set_wpa_enabled when the driver
		  is loaded and unloaded, regardless of if WPA is being
		  used.  No other calls are made which can be used to
		  determine if encryption will be used or not prior to
		  association being expected.  If encryption is not being
		  used, drop_unencrypted is set to false, else true -- we
		  can use this to determine if the CAP_PRIVACY_ON bit should
		  be set.
		 We only change SEC_LEVEL for open mode. Others
		  are set by ipw_wpa_set_encryption.
 added for WPA2 mixed mode
 implementation borrowed from hostap driver 
 FIXME FIXME
sec.encrypt = 0;
 FIXME FIXME
	sec.encrypt = 1;
 IPW HW cannot build TKIP MIC, host decryption still needed. 
set WEP40 first, it will be modified according to WEP104 or WEP40 at other place
	 Do not reset port if card is in Managed mode since resetting will
	  generate new IEEE 802.11 authentication which may end up in looping
	  with IEEE 802.1X.  If your hardware requires a reset after WEP
	  configuration (for example... Prism2), implement the reset_port in
dev_kfree_skb_any(skb);
IEEE_DEBUG_INFO("wpa_supplicant: len=%d\n", p->length);
 SPDX-License-Identifier: GPL-2.0
  Original code based Host AP (software wireless LAN access point) driver
  for Intersil Prism22.53 - hostap.o module, common routines
  Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
  <jkmaline@cc.hut.fi>
  Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
  Copyright (c) 2004, Intel Corporation
  Few modifications for Realtek's Wi-Fi drivers by
  Andrea Merello <andrea.merello@gmail.com>
  A special thanks goes to Realtek for their support !
 Called only as a tasklet (software IRQ) 
 Called only as a tasklet (software IRQ) 
 Reserve enough space to fit maximum frame length 
 LLC  +
 alignment  +
 WEP  +
 WDS  +
 QOS Control );
		 received a fragment of a frame for which the head fragment
 Called only as a tasklet (software IRQ) 
 ieee80211_rx_frame_mgtmt
  Responsible for handling management control frames
	 On the struct stats definition there is written that
	  this is not mandatory.... but seems that the probe
	  response parser uses it
 if ((ieee->state == IEEE80211_LINKED) && (memcmp(hdr->addr3, ieee->current_network.bssid, ETH_ALEN))) 
 use ADDR1 to perform address matching for Management frames 
  hostap_update_sta_ps(ieee, (struct hostap_ieee80211_hdr_4addr )
			 Process beacon frames also in kernel driver to
		 send management frames to the user space daemon for
 See IEEE 802.1H for LLCSNAP encapsulationdecapsulation 
 Ethernet-II snap header (RFC1042 for most EtherTypes) 
 Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) 
 No encapsulation header if EtherType < 0x600 (=length) 
 Called by ieee80211_rx_frame_decrypt 
 check that the frame is unicast frame to us 
 ToDS frame with own addr BSSID and DA 
 FromDS frame with own addr as DA 
 check for port access entity Ethernet type 
	pos = skb->data + 24;
 Called only as a tasklet (software IRQ), by ieee80211_rx 
 Called only as a tasklet (software IRQ), by ieee80211_rx 
 this function is stolen from ipw2200 driver
TO2DS and QoS
QoS
 no QoS
	if (memcmp(entry->mac, mac, ETH_ALEN)){
	if(tid != 0) {
		printk(KERN_WARNING ":)))))))))))%x %x %x, fc(%x)\n", tid, last_seq, seq, header->frame_ctl);
	}
 out-of-order fragment 
	BUG_ON(!(fc & IEEE80211_FCTL_RETRY));
 convert hdr + possible LLC headers into Ethernet header 
			 remove RFC1042 or Bridge-Tunnel encapsulation and
 Leave Ethernet header part of hdr and full payload 
 Indicate the packets to upper layer 
 802.11 crc not sufficient 
 Rx Reorder initialize condition.
 Drop out the packet which SeqNum is smaller than WinStart 
	
	  Sliding window manipulation. Conditions includes:
	  1. Incoming SeqNum is equal to WinStart =>Window shift 1
	  2. Incoming SeqNum is larger than the WinEnd => Window shift N
	
	  Indication process.
	  After Packet dropping and Sliding Window shifting as above, we can now just indicate the packets
	  with the SeqNum smaller than latest WinStart and buffer other packets.
	 For Rx Reorder condition:
	  1. All packets with SeqNum smaller than WinStart => Indicate
	  2. All packets with SeqNum larger than or equal to WinStart => Buffer it.
 Current packet is going to be indicated.
		printk("========================>%s(): SeqNum is %d\n",__func__,SeqNum);
 Current packet is going to be inserted into pending list.
IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): We RX no ordered packed, insert to ordered list\n",__func__);
 Make a reorder entry and insert into a the packet list.
		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): pREorderEntry->SeqNum is %d\n",__func__,pReorderEntry->SeqNum);
			
			  Packets are dropped if there is not enough reorder entries.
			  This part shall be modified!! We can just indicate all the
			  packets in buffer and get reorder entries.
 Check if there is any packet need indicate.
 This protect buffer from overflow. 
	printk("========================>%s(): pReorderEntry->SeqNum is %d\n",__func__,pReorderEntry->SeqNum);
 Handling pending timer. Set this timer to prevent from long time Rx buffering.
 Cancel previous pending timer.
	del_timer_sync(&pTS->rx_pkt_pending_timer);
 Indicate packets
 Set new pending timer.
 just for debug purpose 
 Null packet, don't indicate it to upper layer
 + (Frame_WEP(frame)!=0 ?Adapter->MgntInfo.SecurityInfo.EncryptionHeadOverhead:0);
IEEE80211_DEBUG_DATA(IEEE80211_DL_RX,skb->data,skb->len);
 Offset 12 denote 2 mac address 
==m==>change the length order
 move the data point to data content 
 Allocate new skb for releasing to upper layer 
{just for debug added by david
printk("AMSDU::rxb->nr_subframes = %d\n",rxb->nr_subframes);
}
 All received frames are sent to this function. @skb contains the frame in
  IEEE 802.11 format, i.e., in the format it was sent over air.
struct rtl_80211_hdr_3addrqos hdr;
added by amy for reorder
bool bIsAggregateFrame = false;
added by amy for reorder
	u16 qos_ctl = 0;
 cheat the hdr type
IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA, skb->data, skb->len);
	 Put this code here so that we avoid duplicating it in all
 defined in iw_handler.h 
 If spy monitoring on 
 No qual value 
 Update spy records 
 IW_WIRELESS_SPY 
		 Use station specific key to override default keys if the
		  receiver address is a unicast address ("individual RA"). If
		  bcrx_sta_key parameter is set, station specific key is used
		  even with broadmulticast targets (this is against IEEE
		  802.11, but makes it easier to use different keys with
		 allow NULL decrypt to indicate an station specific override
			 This seems to be triggered by some (multicast?)
			  frames from other than current BSS, so just drop the
			  frames silently instead of filling system log with
 if QoS enabled, should check the sequence for each of the AC
IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): QOS ENABLE AND RECEIVE QOS DATA , we will get Ts, tid:%d\n",__func__, tid);
	IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): pRxTS->rx_last_frag_num is %d,frag is %d,pRxTS->rx_last_seq_num is %d,seq is %d\n",__func__,pRxTS->rx_last_frag_num,frag,pRxTS->rx_last_seq_num,WLAN_GET_SEQ_SEQ(sc));
IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA, skb->data, skb->len);
 Data frame - extract srcdst addresses 
 Frame from BSSID of the AP for which we are a client 
IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA, skb->data, skb->len);
	 Nullfunc frames may have PS-bit set, so they must be passed to
add by David,2006.8.4
 skb: hdr + (possibly fragmented, possibly encrypted) payload 
 skb: hdr + (possibly fragmented) plaintext payload 
 PR: FIXME: hostap has additional conditions in the "if" below:
 ieee->host_decrypt && (fc & IEEE80211_FCTL_WEP) &&
			 copy first fragment (including full headers) into
			 append frame payload to the end of the fragment
			 more fragments expected - leave the skb in fragment
			  cache for now; it will be delivered to upper layers
		 this was the last fragment and the frame will be
	 skb: hdr + (possible reassembled) full MSDU payload; possibly still
added by amy for AP roaming
ieee->ieee802_1x &&
			 pass unencrypted EAPOL frames even if encryption is
	if(ieee80211_is_eapol_frame(ieee, skb, hdrlen)) {
		printk(KERN_WARNING "RX: IEEE802.1X EPAOL frame!\n");
	}
added by amy for reorder
added by amy for reorder
 skb: hdr + (possible reassembled) full plaintext payload 
ethertype = (payload[6] << 8) | payload[7];
 to parse amsdu packets 
 qos data packets & reserved bit is 1 
 only to free rxb, and not submit the packets to upper layer 
added by amy for reorder
	 Returning 0 indicates to caller that we have not handled the SKB--
	  so it is still allocated and can be used again by underlying
 Make the structure we read from the beacon packet to have
 the right values
  Parse a QoS parameter element
  Parse a QoS information element
  Write QoS parameters from the ac parameters.
u8 cw_min;
u8 cw_max;
 WMM spec P.11: The minimum value for AIFSN shall be 2 
  we have a generic data element which it may contain QoS information or
  parameters element. check the information element length to decide
  which type to read
 MFIE_STRING(ERP_INFO);
 070305, rcnjko: I update country IE watch dog here because
 some AP (e.g. Cisco 1242) don't include country IE in their
 probe response frame.
	u16 broadcom_len = 0;
			 We stop processing but don't return an error here
			  because some misbehaviour APs break this rule. ie.
 + ((aid % 8)? 0 : 1) ;
IEEE80211_DEBUG_MGMT("MFIE_TYPE_TIM: partially ignored\n");
for HTcap and HTinfo parameters
if(tmp_htcap_len !=0  ||  tmp_htinfo_len != 0)
added by amy for atheros AP
added by amy for LEAP of cisco
 CCXv4 Table 59-1 MBSSID Masks.
HT related element.
If peer is HT, but not WMM, call QosSetLegacyWMMParamWithHT()
 windows driver will update WMM parameters each beacon received once connected
 Linux driver is a bit different.
 CCX 1 spec v1.13, A01.1 CKIP Negotiation (page23):
 "A Cisco access point advertises support for CKIP in beacon and probe response packets,
  by adding an Aironet element and setting one or both of the CKIP negotiation bits."
addr2 is same as addr3 when from an AP
 TODO 
 Step 1. Scale mapping.
RT_TRACE(COMP_DBG, DBG_LOUD, ("##### After Mapping:  LastSS: %d, CurrSS: %d, RetSS: %d\n", LastSS, CurrSS, RetSS));
 Step 2. Smoothing.
RT_TRACE(COMP_DBG, DBG_LOUD, ("$$$$$ After Smoothing:  LastSS: %d, CurrSS: %d, RetSS: %d\n", LastSS, CurrSS, RetSS));
 0-100 index 
 in dBm.
 Translate to dBm (x=0.5y-95).
char rates_str[64];
char p;
 Pull out fixed field data 
 Where to pull this? beacon->listen_interval;
Initialize HT parameters
ieee80211_ht_initialize(&network->bssht);
 for A band (No DS info) 
stats->signal = ieee80211_SignalStrengthTranslate(stats->signal);
	 A network is only a duplicate if the channel, BSSID, ESSID
	  and the capability field (in particular IBSS and BSS) all match.
	  We treat all <hidden> with the same BSSID and channel
((src->ssid_len == dst->ssid_len) &&
!memcmp(src->ssid, dst->ssid, src->ssid_len) &&
 qos related parameters 
qos_active = src->qos_data.active;
old_param = dst->qos_data.old_param_count;
 dst->last_associate is not overwritten 
sure to exist in beacon or probe response frame.
dst->QoS_Enable = src->QoS_Enable;
added by amy for LEAP
u8 wmm_info;
 For Asus EeePc request,
 (1) if wireless adapter receive get any 802.11d country code in AP beacon,
	   wireless adapter should follow the country code.
 (2)  If there is no any country code in beacon,
       then wireless adapter should do active scan from ch1~11 and
       passive scan from ch12~14
 Case 1: Country code
 Case 2: No any country code.
 Filter over channel ch12~14
 Case 1: Country code
 Case 2: No any country code.
 Filter over channel ch12~14
	 The network parsed correctly -- so now we scan our known networks
	  to see if we can find it in our list.
	 
	  NOTE:  This search is definitely not optimized.  Once its doing
	         the "right thing" we'll optimize it for efficiency if
	 Search for this entry in the list and update it if it is
hidden AP
	 If we didn't find a match, then get a new network slot to initialize
 If there are no more slots, expire the oldest 
 Otherwise just pull from the free list 
		 we have an entry and we are going to update it. But this entry may
		  be already expired. In this case we do the same as we found a new
		  net and call the new_net handler
YJ,add,080819,for hidden ap
if(strncmp(network->ssid, "linksys-c",9) == 0)
	printk("====>2 network->ssid=%s FLAG=%d target.ssid=%s FLAG=%d\n", network->ssid, network->flags, target->ssid, target->flags);
YJ,add,080819,for hidden ap,end
 SPDX-License-Identifier: GPL-2.0
  Host AP crypt: host-based CCMP encryption implementation for Host AP driver
  Copyright (c) 2003-2004, Jouni Malinen <jkmaline@cc.hut.fi>
 scratch buffers for virt_to_page() (crypto API) 
	 qc_included = ((WLAN_FC_GET_TYPE(fc) == IEEE80211_FTYPE_DATA) &&
	 	       (WLAN_FC_GET_STYPE(fc) & 0x08));
 fixed by David :2006.9.6 
	 In CCM, the initial vectors (IV) used for CTR mode encryption and CBC
	  mode authentication are not allowed to collide, yet both are derived
	  from the same vector. We only set L := 1 here to indicate that the
	  data size can be represented in (L+1) bytes. The CCM layer will take
	  care of storing the data length in the top (L+1) bytes and setting
	  and clearing the other bits as is required to derive the two IVs.
 Nonce: QC | A2 | PN 
	 AAD:
	  FC with bits 4..6 and 11..13 masked to zero; 14 is always one
	  A1 | A2 | A3
	  SC with bits 4..15 (seq#) masked to zero
	  A4 (if present)
	  QC (if present)
 all bits masked 
 rest of QC masked 
 mic = skb_put(skb, CCMP_MIC_LEN); 
 Ext IV included ;
 Remove hdr and MIC 
 SPDX-License-Identifier: GPL-2.0
   Copyright(c) 2004 Intel Corporation. All rights reserved.
   Portions of this file are based on the WEP enablement code provided by the
   Host AP project hostap-drivers v0.1.3
   Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
   <jkmaline@cc.hut.fi>
   Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
   Contact Information:
   James P. Ketrenos <ipw2100-admin@linux.intel.com>
   Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
 Default fragmentation threshold is maximum payload size 
 Default to enabling full open WEP with host based encryptdecrypt 
 Default to supporting 802.1x 
 added by WB 
ieee->hwsec_support = 1; use module_param instead.
 disable hwsec, switch it on when necessary. 
		 By this point in code ieee80211_networks_allocate() has been
		  successfully called so the memory allocated should be freed
 may move to other place. 
 These function were added to load crypte module autoly 
 struct list_head p, q; 
	del_timer_sync(&ieee->SwBwTimer);
	    IEEE80211_DL_INFO	|
		    IEEE80211_DL_WX	|
		    IEEE80211_DL_SCAN	|
		    IEEE80211_DL_STATE	|
		    IEEE80211_DL_MGMT	|
		    IEEE80211_DL_FRAG	|
		    IEEE80211_DL_EAP	|
		    IEEE80211_DL_DROP	|
		    IEEE80211_DL_TX	|
		    IEEE80211_DL_RX	|
IEEE80211_DL_QOS    |
		    IEEE80211_DL_HT	|
		    IEEE80211_DL_TS	|
			    IEEE80211_DL_BA	|
		    IEEE80211_DL_REORDER|
			    IEEE80211_DL_TRACE  |
IEEE80211_DL_DATA	|
 awayls open this flags to show error out 
 SPDX-License-Identifier: GPL-2.0
 IEEE 802.11 SoftMAC layer
  Copyright (c) 2005 Andrea Merello <andrea.merello@gmail.com>
  Mostly extracted from the rtl8180-sa2400 driver for the
  in-kernel generic ieee802.11 stack.
  Some pieces of code might be stolen from ipw2100 driver
  copyright of who own it's copyright ;-)
  PS wx handler mostly stolen from hostap, copyright who
  own it's copyright ;-)
 FIXME: add A freqs 
 if setting by freq convert to channel 
 hack to fall through 
 Set the channel 
 NM 0.7.0 will not accept channel any more. 
 fwrq->m = ieee->current_network.channel; 
 fwrq->e = 0; 
 We want avoid to give to the user inconsistent infos
 dev->flags & IFF_UP; 
 use ifconfig hw ether 
	 just to avoid to give inconsistent infos in the
	  get wx method. not really needed otherwise
 We want avoid to give to the user inconsistent infos
 FIXME: we might want to limit rate also in management protocols. 
 no auto select 
 To prevent the immediately calling watch_dog after scan. 
 intentionally forget to up sem 
	 this is just to be sure that the GET wx callback
	  has consisten infos. not needed otherwise
 first flush current network.ssid 
 this is mostly stolen from hostap 
 ieee->ps_period = wrqu->power.value  1000; 
 ieee->ps_timeout = wrqu->power.value  1000; 
 wrq->value  1024; 
 ieee->ps = IEEE80211_PS_DISABLED; 
 this is stolen from hostap 
 ret = -EOPNOTSUPP; 
 goto exit; 
 ieee->current_network.dtim_period  ieee->current_network.beacon_interval  1024; 
 SPDX-License-Identifier: GPL-2.0
  Host AP crypt: host-based TKIP encryption implementation for Host AP driver
  Copyright (c) 2003-2004, Jouni Malinen <jkmaline@cc.hut.fi>
 scratch buffers for virt_to_page() (crypto API) 
 Initialize the 80-bit TTAK from TSC (IV32) and TA[0..5] 
	
	  Make temporary area overlap WEP seed so that the final copy can be
	  avoided on little endian hosts.
 Step 1 - make copy of TTAK and bring in TSC 
 Step 2 - 96-bit bijective mixing using S-box 
	
	  Step 3 - bring in last of TK bits, assign 24-bit WEP IV value
	  WEPSeed[0..2] is transmitted as WEP IV
 Ext IV included ;
				
				  Previously cached Phase1 result was already
				  lost, so it needs to be recalculated for the
				  next packet.
	
	  Update real counters only after Michael MIC verification has
	  completed.
 Remove IV and ICV 
 DA 
 SA 
 DA 
 SA 
 DA 
 SA 
 DA 
 SA 
 priority 
 reserved 
 { david, 2006.9.1
 fix the wpa process with wmm enabled.
 }
 TODO: needed parameters: count, keyid, key type, TSC 
 { david, 2006.9.1
 fix the wpa process with wmm enabled.
 }
	
	  Update TSC counters for RX now that the packet verification has
	  completed.
 TSC is initialized to 1 
 Return the sequence number of the last transmitted frame. 
 IV + ExtIV 
 MIC + ICV 
    printk("============>%s()\n", __func__);
 SPDX-License-Identifier: GPL-2.0
 Implement 802.11d. 
 Reset to the state as we are just entering a regulatory domain. 
 Clear old channel map 
 Set new channel map 
  Update country IE from Beacon or Probe Resopnse and configure PHY for
  operation in the regulatory domain.
  TODO: Configure Tx power.
  Assumption:
  1. IS_DOT11D_ENABLE() is TRUE.
  2. Input IE is an valid one.
 skip 3-byte country string. 
			 It is not in a monotonically increasing order, so
			  stop processing.
			 It is not a valid set of channel id, so stop
			  processing.
 Reset country IE if previous one is gone. 
 SPDX-License-Identifier: GPL-2.0
  As this function is mainly ported from Windows driver, so leave the name
  little changed. If any confusion caused, tell me. Created by WB. 2008.05.08
 Long GI, 20MHz
 Short GI, 20MHz
 Long GI, 40MHz
 Short GI, 40MHz
cosa 03202008
static u8 DLINK_ATHEROS[3] = {0x00, 0x1c, 0xf0};
  20080401 MH For Cisco G mode RX TP We need to change FW duration. Should we
  put the code in other place??
  static u8 WIFI_CISCO_G_AP[3] = {0x00, 0x40, 0x96};
 function:  This function update default settings in pHTInfo structure
    input:  PRT_HIGH_THROUGHPUT	pHTInfo
   output:  none
   return:  none
   notice:  These value need be modified if any changes.
const typeof( ((struct ieee80211_device )0)->pHTInfo ) __mptr = &pHTInfo;
printk("pHTinfo:%p, &pHTinfo:%p, mptr:%p,  offsetof:%x\n", pHTInfo, &pHTInfo, __mptr, offsetof(struct ieee80211_device, pHTInfo));
printk("===>ieee:%p,\n", ieee);
 ShortGI support
 40MHz channel support
 CCK rate support in 40MHz channel
 AMSDU related
 AMPDU related
 0: 2n13(8K), 1:2n14(16K), 2:2n15(32K), 3:2n16(64k)
 0: No restriction, 1: 18usec, 2: 14usec, 3: 12usec, 4: 1usec, 5: 2usec, 6: 4usec, 7:8usec
 MIMO Power Save
 0: Static Mimo Ps, 1: Dynamic Mimo Ps, 3: No Limitation, 2: Reserved(Set to 3 automatically.)
 8190 only. Assign rate operation mode to firmware
	
	  8190 only, Realtek proprietary aggregation mode
	  Set MPDUDensity=2,   1: Set MPDUDensity=2(32k)  for Realtek AP and set MPDUDensity=0(8k) for others
0: Set MPDUDensity=2,   1: Set MPDUDensity=2(32k)  for Realtek AP and set MPDUDensity=0(8k) for others
 For Rx Reorder Control
usb rx FW aggregation timeout threshold.It's in units of 64us
 function:  This function print out each field on HT capability
            IE mainly from (BeaconProbeRspAssocReq)
    input:  u8	CapIE       Capability IE to be printed out
 	     u8	TitleString mainly print out caller function
   output:  none
   return:  none
   notice:  Driver should not print out this message by default.
 For 11n EWC definition, 2007.07.17, by Emily
EWC IE
 function:  This function print out each field on HT Information
            IE mainly from (BeaconProbeRsp)
    input:  u8	InfoIE       Capability IE to be printed out
 	     u8	TitleString mainly print out caller function
   output:  none
   return:  none
   notice:  Driver should not print out this message by default.
 For 11n EWC definition, 2007.07.17, by Emily
 Not EWC IE
 function:  This function returns current datarate.
    input:  struct ieee80211_device	ieee
 	     u8				nDataRate
   output:  none
   return:  tx rate
   notice:  quite unsure about how to use this function wb
PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
if(nDataRate > 11 && nDataRate < 28 )
 nDataRate = nDataRate - 12;
(27, 44)
nDataRate = nDataRate - 28;
(43, 60)
nDataRate = nDataRate - 44;
(59, 76)
nDataRate = nDataRate - 60;
 function:  This function returns peer IOT.
    input:  struct ieee80211_device	ieee
   output:  none
   return:
   notice:
 function:  Check whether driver should declare received rate up to MCS13
            only since some chipset is not good at receiving MCS14~15 frame
            from some AP.
    input:  struct ieee80211_device	ieee
 	     u8 			PeerMacAddr
   output:  none
   return:  return 1 if driver should declare MCS13 only(otherwise return 0)
  Function:	HTIOTActIsDisableMCS15
  Overview:	Check whether driver should declare capability of receiving
               MCS15
  Input:
 			PADAPTER		Adapter,
  Output:		None
  Return:	true if driver should disable MCS15
  2008.04.15	Emily
 Apply for 819u only
 Alway disable MCS15 by Jerry Chang's request.by Emily, 2008.04.15
 Enable MCS15 if the peer is Cisco AP. by Emily, 2008.05.12
	if(pBssDesc->bCiscoCapExist)
		retValue = false;
	else
 Jerry Chang suggest that 8190 1x2 does not need to disable MCS15
  Function:	HTIOTActIsDisableMCSTwoSpatialStream
  Overview:	Check whether driver should declare capability of receiving
               All 2 ss packets
  Input:
 			PADAPTER		Adapter,
  Output:		None
  Return:	true if driver should disable all two spatial stream packet
  2008.04.21	Emily
 Apply for 819u only
 function:  Check whether driver should disable EDCA turbo mode
    input:  struct ieee80211_device	ieee
 	     u8			PeerMacAddr
   output:  none
   return:  return 1 if driver should disable EDCA turbo mode
            (otherwise return 0)
 default enable EDCA Turbo mode. 
 function:  Check whether we need to use OFDM to sned MGNT frame for
            broadcom AP
    input:  struct ieee80211_network network   current network we live
   output:  none
   return:  return 1 if true
 20080125 MH Judeg if we need to use OFDM to sned MGNT frame for broadcom AP.
 20080128 MH We must prevent that we select null bssid to link.
 function:  Construct Capablility Element in Beacon... if HTEnable is turned on
    input:  struct ieee80211_device	ieee
 	     u8		     posHTCap pointer to store Capability Ele
 	     u8		     len store length of CE
 	     u8			     IsEncrypt whether encrypt, needed further
   output:  none
   return:  none
   notice:  posHTCap can't be null and should be initialized before.
u8 bIsDeclareMCS13;
 For 11n EWC definition, 2007.07.17, by Emily
HT capability info
 This feature is not supported now!!
	pCapELE->ChlWidth		= (pHT->bRegBW40MHz?1:0);
 This feature is not supported now!!
 We can receive Short GI!!
 We can receive Short GI!!
DbgPrint("TX HT capinfo ele BW=%d SG20=%d SG40=%d\n\r",
pCapELE->ChlWidth, pCapELE->ShortGI20Mhz, pCapELE->ShortGI40Mhz);
 Do not support now!!
 Do not support now!!
 Do not support now!!
	
	  MAC HT parameters info
	  TODO: Nedd to take care of this part
 8us
 2 is for 32 K and 3 is 64K
 2 is for 32 K and 3 is 64K
 no density
Supported MCS set
	
	  2008.06.12
	  For RTL819X, if pairwisekey = weptkip, ap is ralink, we support only MCS0~7.
Extended HT Capability Info
TXBF Capabilities
Antenna Selection Capabilities
add 2 to give space for element ID and len when construct frames
	IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA | IEEE80211_DL_HT, posHTCap, len -2);
	
	  Print each field in detail. Driver should not print out this message
	  by default
	HTDebugHTCapability(posHTCap, (u8)"HTConstructCapability()");
 function:  Construct Information Element in Beacon... if HTEnable is turned on
    input:  struct ieee80211_device	ieee
 	     u8		     posHTCap pointer to store Information Ele
 	     u8		     len   store len of
 	     u8			     IsEncrypt whether encrypt, needed further
   output:  none
   return:  none
   notice:  posHTCap can't be null and be initialized before.
            Only AP and IBSS sta should do this
ap mode is not currently supported
same above
STA should not generate High Throughput Information Element
IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA | IEEE80211_DL_HT, posHTInfo, len - 2);
HTDebugHTInfo(posHTInfo, "HTConstructInforElement");
  According to experiment, Realtek AP to STA (based on rtl8190) may achieve
  best performance if both STA and AP set limitation of aggregation size to
  32K, that is, set AMPDU density to 2 (Ref: IEEE 11n specification).
  However, if Realtek STA associates to other AP, STA should set limitation of
  aggregation size to 8K, otherwise, performance of traffic stream from STA to
  AP will be much less than the traffic stream from AP to STA if both of the
  stream runs concurrently at the same time.
   Frame Format
   Element ID		Length		OUI		Type1		Reserved
   1 byte		1 byte		3 bytes		1 byte		1 byte
   OUI		= 0x00, 0xe0, 0x4c,
   Type	= 0x02
   Reserved	= 0x00
   2007.8.21 by Emily
 function:  Construct  Information Element in Beacon... in RT2RT condition
    input:  struct ieee80211_device	ieee
 	     u8		  posRT2RTAgg pointer to store Information Ele
 	     u8		  len   store len
   output:  none
   return:  none
   notice:
	posRT2RTAgg = 0x10;posRT2RTAgg = 0x02;
	if (ieee->bSupportRemoteWakeUp)
		posRT2RTAgg |= 0x08;RT_HT_CAP_USE_WOW;
	len = 6 + 2;
	return;
#ifdef TODO
#if (HAL_CODE_BASE == RTL8192 && DEV_BUS_TYPE == USB_INTERFACE)
Emily. If it is required to Ask Realtek AP to send AMPDU during AES mode, enable this
	
#else
	 Do Nothing
#endif
	posRT2RTAgg->Length = 6;
#endif
}
A pointer to MCS rate bitmap
static u8 HT_PickMCSRate(struct ieee80211_device ieee, u8 pOperateMCS)
{
	if (!pOperateMCS) {
		IEEE80211_DEBUG(IEEE80211_DL_ERR,
				"pOperateMCS can't be null in %s\n",
				__func__);
		return false;
	}
	switch (ieee->mode) {
	case IEEE_A:
	case IEEE_B:
	case IEEE_G:
		legacy rate routine handled at selectedrate
		no MCS rate
		memset(pOperateMCS, 0, 16);
		break;
	case IEEE_N_24G:	assume CCK rate ok
	case IEEE_N_5G:
		 Legacy part we only use 6, 5.5,2,1 for N_24G and 6 for N_5G.
		 Legacy part shall be handled at SelectRateSet().
		HT part
		 TODO: may be different if we have different number of antenna
		pOperateMCS[0] &= RATE_ADPT_1SS_MASK;	support MCS 0~7
		pOperateMCS[1] &= RATE_ADPT_2SS_MASK;
		pOperateMCS[3] &= RATE_ADPT_MCS32_MASK;
		break;
	should never reach here
	default:
		break;
	}
	return true;
}
Pointer to MCS rate bitmap
Pointer to MCS rate filter
u8 HTGetHighestMCSRate(struct ieee80211_device ieee, u8 pMCSRateSet, u8 pMCSFilter)
{
	u8		i, j;
	u8		bitMap;
	u8		mcsRate = 0;
	u8		availableMcsRate[16];
	if (!pMCSRateSet || !pMCSFilter) {
		IEEE80211_DEBUG(IEEE80211_DL_ERR,
				"pMCSRateSet or pMCSFilter can't be null in %s\n",
				__func__);
		return false;
	}
	for (i = 0; i < 16; i++)
		availableMcsRate[i] = pMCSRateSet[i] & pMCSFilter[i];
	for (i = 0; i < 16; i++) {
		if (availableMcsRate[i] != 0)
			break;
	}
	if (i == 16)
		return false;
	for (i = 0; i < 16; i++) {
		if (availableMcsRate[i] != 0) {
			bitMap = availableMcsRate[i];
			for (j = 0; j < 8; j++) {
				if ((bitMap % 2) != 0) {
					if (HTMcsToDataRate(ieee, (8  i + j)) > HTMcsToDataRate(ieee, mcsRate))
						mcsRate = (8  i + j);
				}
				bitMap >>= 1;
			}
		}
	}
	return (mcsRate | 0x80);
}
static u8 HTFilterMCSRate(struct ieee80211_device ieee, u8 pSupportMCS,
			  u8 pOperateMCS)
{
	u8 i = 0;
	 filter out operational rate set not supported by AP, the length of it is 16
	for (i = 0; i <= 15; i++)
		pOperateMCS[i] = ieee->Regdot11HTOperationalRateSet[i] & pSupportMCS[i];
	 TODO: adjust our operational rate set  according to our channel bandwidth, STBC and Antenna number
	 
	HT_PickMCSRate(ieee, pOperateMCS);
	 For RTL819X, if pairwisekey = weptkip, we support only MCS0~7.
	if (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))
		pOperateMCS[1] = 0;
	 
	for (i = 2; i <= 15; i++)
		pOperateMCS[i] = 0;
	return true;
}
void HTOnAssocRsp(struct ieee80211_device ieee)
{
	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
	struct ht_capability_ele       pPeerHTCap = NULL;
	PHT_INFORMATION_ELE		pPeerHTInfo = NULL;
	u16	nMaxAMSDUSize = 0;
	u8	pMcsFilter = NULL;
	static u8				EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};		 For 11n EWC definition, 2007.07.17, by Emily
	static u8				EWC11NHTInfo[] = {0x00, 0x90, 0x4c, 0x34};	 For 11n EWC definition, 2007.07.17, by Emily
	if (!pHTInfo->bCurrentHTSupport) {
		IEEE80211_DEBUG(IEEE80211_DL_ERR,
				"<=== %s: HT_DISABLE\n",
				__func__);
		return;
	}
	IEEE80211_DEBUG(IEEE80211_DL_HT, "===> HTOnAssocRsp_wq(): HT_ENABLE\n");
	IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA, pHTInfo->PeerHTCapBuf, sizeof(struct ht_capability_ele));
	IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA, pHTInfo->PeerHTInfoBuf, sizeof(HT_INFORMATION_ELE));
	HTDebugHTCapability(pHTInfo->PeerHTCapBuf,"HTOnAssocRsp_wq");
	HTDebugHTInfo(pHTInfo->PeerHTInfoBuf,"HTOnAssocRsp_wq");
	
	if (!memcmp(pHTInfo->PeerHTCapBuf, EWC11NHTCap, sizeof(EWC11NHTCap)))
		pPeerHTCap = (struct ht_capability_ele )(&pHTInfo->PeerHTCapBuf[4]);
	else
		pPeerHTCap = (struct ht_capability_ele )(pHTInfo->PeerHTCapBuf);
	if (!memcmp(pHTInfo->PeerHTInfoBuf, EWC11NHTInfo, sizeof(EWC11NHTInfo)))
		pPeerHTInfo = (PHT_INFORMATION_ELE)(&pHTInfo->PeerHTInfoBuf[4]);
	else
		pPeerHTInfo = (PHT_INFORMATION_ELE)(pHTInfo->PeerHTInfoBuf);
	
	 Configurations:
	
	IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA | IEEE80211_DL_HT, pPeerHTCap, sizeof(struct ht_capability_ele));
	IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA|IEEE80211_DL_HT, pPeerHTInfo, sizeof(HT_INFORMATION_ELE));
	 Config Supported Channel Width setting
	
	HTSetConnectBwMode(ieee, (enum ht_channel_width)(pPeerHTCap->ChlWidth), (enum ht_extension_chan_offset)(pPeerHTInfo->ExtChlOffset));
	pHTInfo->bCurTxBW40MHz = (pPeerHTInfo->RecommemdedTxWidth == 1);
	 
	pHTInfo->bCurShortGI20MHz = pHTInfo->bRegShortGI20MHz &&
				    (pPeerHTCap->ShortGI20Mhz == 1);
	pHTInfo->bCurShortGI40MHz = pHTInfo->bRegShortGI40MHz &&
				   (pPeerHTCap->ShortGI40Mhz == 1);
	 
	 
	pHTInfo->bCurSuppCCK = pHTInfo->bRegSuppCCK &&
			       (pPeerHTCap->DssCCk == 1);
	 
	pHTInfo->bCurrent_AMSDU_Support = pHTInfo->bAMSDU_Support;
	nMaxAMSDUSize = (pPeerHTCap->MaxAMSDUSize == 0) ? 3839 : 7935;
	if (pHTInfo->nAMSDU_MaxSize > nMaxAMSDUSize)
		pHTInfo->nCurrent_AMSDU_MaxSize = nMaxAMSDUSize;
	else
		pHTInfo->nCurrent_AMSDU_MaxSize = pHTInfo->nAMSDU_MaxSize;
	 
	pHTInfo->bCurrentAMPDUEnable = pHTInfo->bAMPDUEnable;
	 
	if (!pHTInfo->bRegRT2RTAggregation) {
		 Decide AMPDU Factor according to protocol handshake
		if (pHTInfo->AMPDU_Factor > pPeerHTCap->MaxRxAMPDUFactor)
			pHTInfo->CurrentAMPDUFactor = pPeerHTCap->MaxRxAMPDUFactor;
		else
			pHTInfo->CurrentAMPDUFactor = pHTInfo->AMPDU_Factor;
	} else {
		 
		if (ieee->current_network.bssht.bdRT2RTAggregation) {
			if (ieee->pairwise_key_type != KEY_TYPE_NA)
				 Realtek may set 32k in security mode and 64k for others
				pHTInfo->CurrentAMPDUFactor = pPeerHTCap->MaxRxAMPDUFactor;
			else
				pHTInfo->CurrentAMPDUFactor = HT_AGG_SIZE_64K;
		} else {
			if (pPeerHTCap->MaxRxAMPDUFactor < HT_AGG_SIZE_32K)
				pHTInfo->CurrentAMPDUFactor = pPeerHTCap->MaxRxAMPDUFactor;
			else
				pHTInfo->CurrentAMPDUFactor = HT_AGG_SIZE_32K;
		}
	}
	 
	if (pHTInfo->MPDU_Density > pPeerHTCap->MPDUDensity)
		pHTInfo->CurrentMPDUDensity = pHTInfo->MPDU_Density;
	else
		pHTInfo->CurrentMPDUDensity = pPeerHTCap->MPDUDensity;
	if (ieee->pairwise_key_type != KEY_TYPE_NA)
		pHTInfo->CurrentMPDUDensity	= 7;  8us
	 Force TX AMSDU
	 Lanhsin: mark for tmp to avoid deauth by ap from  s3
	if(memcmp(pMgntInfo->Bssid, NETGEAR834Bv2_BROADCOM, 3)==0)
	if (0) {
		pHTInfo->bCurrentAMPDUEnable = false;
		pHTInfo->ForcedAMSDUMode = HT_AGG_FORCE_ENABLE;
		pHTInfo->ForcedAMSDUMaxSize = 7935;
		pHTInfo->IOTAction |=  HT_IOT_ACT_TX_USE_AMSDU_8K;
	}
	 Rx Reorder Setting
	pHTInfo->bCurRxReorderEnable = pHTInfo->bRegRxReorderEnable;
	 
	 
	if (pPeerHTCap->MCS[0] == 0)
		pPeerHTCap->MCS[0] = 0xff;
	HTFilterMCSRate(ieee, pPeerHTCap->MCS, ieee->dot11HTOperationalRateSet);
	 
	pHTInfo->PeerMimoPs = pPeerHTCap->MimoPwrSave;
	if (pHTInfo->PeerMimoPs == MIMO_PS_STATIC)
		pMcsFilter = MCS_FILTER_1SS;
	else
		pMcsFilter = MCS_FILTER_ALL;
	WB add for MCS8 bug
	pMcsFilter = MCS_FILTER_1SS;
	ieee->HTHighestOperaRate = HTGetHighestMCSRate(ieee, ieee->dot11HTOperationalRateSet, pMcsFilter);
	ieee->HTCurrentOperaRate = ieee->HTHighestOperaRate;
	 
	pHTInfo->CurrentOpMode = pPeerHTInfo->OptMode;
}
 TODO: Should this funciton be called when receiving of Disassociation?
void HTInitializeHTInfo(struct ieee80211_device ieee)
{
	PRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;
	 
	IEEE80211_DEBUG(IEEE80211_DL_HT, "===========>%s()\n", __func__);
	pHTInfo->bCurrentHTSupport = false;
	 40MHz channel support
	pHTInfo->bCurBW40MHz = false;
	pHTInfo->bCurTxBW40MHz = false;
	 Short GI support
	pHTInfo->bCurShortGI20MHz = false;
	pHTInfo->bCurShortGI40MHz = false;
	pHTInfo->bForcedShortGI = false;
	 
	pHTInfo->bCurSuppCCK = true;
	 AMSDU related
	pHTInfo->bCurrent_AMSDU_Support = false;
	pHTInfo->nCurrent_AMSDU_MaxSize = pHTInfo->nAMSDU_MaxSize;
	 AMPUD related
	pHTInfo->CurrentMPDUDensity = pHTInfo->MPDU_Density;
	pHTInfo->CurrentAMPDUFactor = pHTInfo->AMPDU_Factor;
	 Initialize all of the parameters related to 11n
	memset(&pHTInfo->SelfHTCap, 0, sizeof(pHTInfo->SelfHTCap));
	memset(&pHTInfo->SelfHTInfo, 0, sizeof(pHTInfo->SelfHTInfo));
	memset(&pHTInfo->PeerHTCapBuf, 0, sizeof(pHTInfo->PeerHTCapBuf));
	memset(&pHTInfo->PeerHTInfoBuf, 0, sizeof(pHTInfo->PeerHTInfoBuf));
	pHTInfo->bSwBwInProgress = false;
	 Set default IEEE spec for Draft N
	pHTInfo->ePeerHTSpecVer = HT_SPEC_VER_IEEE;
	 Realtek proprietary aggregation mode
	pHTInfo->bCurrentRT2RTAggregation = false;
	pHTInfo->bCurrentRT2RTLongSlotTime = false;
	pHTInfo->IOTPeer = 0;
	pHTInfo->IOTAction = 0;
	MCS rate initialized here
	{
		u8 RegHTSuppRateSets = &ieee->RegHTSuppRateSet[0];
		RegHTSuppRateSets[0] = 0xFF;	support MCS 0~7
		RegHTSuppRateSets[1] = 0xFF;	support MCS 8~15
		RegHTSuppRateSets[4] = 0x01;	support MCS 32
	}
}
to be initialized
void HTInitializeBssDesc(PBSS_HT pBssHT)
{
	pBssHT->bdSupportHT = false;
	memset(pBssHT->bdHTCapBuf, 0, sizeof(pBssHT->bdHTCapBuf));
	pBssHT->bdHTCapLen = 0;
	memset(pBssHT->bdHTInfoBuf, 0, sizeof(pBssHT->bdHTInfoBuf));
	pBssHT->bdHTInfoLen = 0;
	pBssHT->bdHTSpecVer = HT_SPEC_VER_IEEE;
	pBssHT->bdRT2RTAggregation = false;
	pBssHT->bdRT2RTLongSlotTime = false;
}
usually current network
void HTResetSelfAndSavePeerSetting(struct ieee80211_device ieee,	struct ieee80211_network pNetwork)
{
	PRT_HIGH_THROUGHPUT		pHTInfo = ieee->pHTInfo;
	u16						nMaxAMSDUSize;
	struct ht_capability_ele       pPeerHTCap = (struct ht_capability_ele )pNetwork->bssht.bdHTCapBuf;
	PHT_INFORMATION_ELE		pPeerHTInfo = (PHT_INFORMATION_ELE)pNetwork->bssht.bdHTInfoBuf;
	u8	pMcsFilter;
	u8	bIOTAction = 0;
	
	  Save Peer Setting before Association
	
	IEEE80211_DEBUG(IEEE80211_DL_HT, "==============>%s()\n", __func__);
	unmark bEnableHT flag here is the same reason why unmarked in function ieee80211_softmac_new_net. WB 2008.09.10
	if( pHTInfo->bEnableHT &&  pNetwork->bssht.bdSupportHT)
	if (pNetwork->bssht.bdSupportHT) {
		pHTInfo->bCurrentHTSupport = true;
		pHTInfo->ePeerHTSpecVer = pNetwork->bssht.bdHTSpecVer;
		 Save HTCap and HTInfo information Element
		if (pNetwork->bssht.bdHTCapLen > 0 &&	pNetwork->bssht.bdHTCapLen <= sizeof(pHTInfo->PeerHTCapBuf))
			memcpy(pHTInfo->PeerHTCapBuf, pNetwork->bssht.bdHTCapBuf, pNetwork->bssht.bdHTCapLen);
		if (pNetwork->bssht.bdHTInfoLen > 0 && pNetwork->bssht.bdHTInfoLen <= sizeof(pHTInfo->PeerHTInfoBuf))
			memcpy(pHTInfo->PeerHTInfoBuf, pNetwork->bssht.bdHTInfoBuf, pNetwork->bssht.bdHTInfoLen);
		 Check whether RT to RT aggregation mode is enabled
		if (pHTInfo->bRegRT2RTAggregation) {
			pHTInfo->bCurrentRT2RTAggregation = pNetwork->bssht.bdRT2RTAggregation;
			pHTInfo->bCurrentRT2RTLongSlotTime = pNetwork->bssht.bdRT2RTLongSlotTime;
		} else {
			pHTInfo->bCurrentRT2RTAggregation = false;
			pHTInfo->bCurrentRT2RTLongSlotTime = false;
		}
		 Determine the IOT Peer Vendor.
		HTIOTPeerDetermine(ieee);
		 
		pHTInfo->IOTAction = 0;
		bIOTAction = HTIOTActIsDisableMCS14(ieee, pNetwork->bssid);
		if (bIOTAction)
			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_MCS14;
		bIOTAction = HTIOTActIsDisableMCS15(ieee);
		if (bIOTAction)
			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_MCS15;
		bIOTAction = HTIOTActIsDisableMCSTwoSpatialStream(ieee, pNetwork->bssid);
		if (bIOTAction)
			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_ALL_2SS;
		bIOTAction = HTIOTActIsDisableEDCATurbo(ieee, pNetwork->bssid);
		if (bIOTAction)
			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_EDCA_TURBO;
		bIOTAction = HTIOTActIsMgntUseCCK6M(pNetwork);
		if (bIOTAction)
			pHTInfo->IOTAction |= HT_IOT_ACT_MGNT_USE_CCK_6M;
		bIOTAction = HTIOTActIsCCDFsync(pNetwork->bssid);
		if (bIOTAction)
			pHTInfo->IOTAction |= HT_IOT_ACT_CDD_FSYNC;
	} else {
		pHTInfo->bCurrentHTSupport = false;
		pHTInfo->bCurrentRT2RTAggregation = false;
		pHTInfo->bCurrentRT2RTLongSlotTime = false;
		pHTInfo->IOTAction = 0;
	}
}
void HTUpdateSelfAndPeerSetting(struct ieee80211_device ieee,	struct ieee80211_network pNetwork)
{
	PRT_HIGH_THROUGHPUT	        pHTInfo = ieee->pHTInfo;
	struct ht_capability_ele       pPeerHTCap = (struct ht_capability_ele )pNetwork->bssht.bdHTCapBuf;
	PHT_INFORMATION_ELE		pPeerHTInfo = (PHT_INFORMATION_ELE)pNetwork->bssht.bdHTInfoBuf;
	if (pHTInfo->bCurrentHTSupport) {
		 
		if (pNetwork->bssht.bdHTInfoLen != 0)
			pHTInfo->CurrentOpMode = pPeerHTInfo->OptMode;
		 
	}
}
EXPORT_SYMBOL(HTUpdateSelfAndPeerSetting);
coming skb->data
u8 HTCCheck(struct ieee80211_device ieee, u8 pFrame)
{
	if (ieee->pHTInfo->bCurrentHTSupport) {
		if ((IsQoSDataFrame(pFrame) && Frame_Order(pFrame)) == 1) {
			IEEE80211_DEBUG(IEEE80211_DL_HT, "HT CONTROL FILED EXIST!!\n");
			return true;
		}
	}
	return false;
}
static void HTSetConnectBwModeCallback(struct ieee80211_device ieee)
{
	PRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;
	IEEE80211_DEBUG(IEEE80211_DL_HT, "======>%s()\n", __func__);
	if (pHTInfo->bCurBW40MHz) {
		if (pHTInfo->CurSTAExtChnlOffset == HT_EXTCHNL_OFFSET_UPPER)
			ieee->set_chan(ieee->dev, ieee->current_network.channel + 2);
		else if (pHTInfo->CurSTAExtChnlOffset == HT_EXTCHNL_OFFSET_LOWER)
			ieee->set_chan(ieee->dev, ieee->current_network.channel - 2);
		else
			ieee->set_chan(ieee->dev, ieee->current_network.channel);
		ieee->SetBWModeHandler(ieee->dev, HT_CHANNEL_WIDTH_20_40, pHTInfo->CurSTAExtChnlOffset);
	} else {
		ieee->set_chan(ieee->dev, ieee->current_network.channel);
		ieee->SetBWModeHandler(ieee->dev, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);
	}
	pHTInfo->bSwBwInProgress = false;
}
void HTSetConnectBwMode(struct ieee80211_device ieee, enum ht_channel_width Bandwidth, enum ht_extension_chan_offset Offset)
{
	PRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;
	u32 flags = 0;
	if (!pHTInfo->bRegBW40MHz)
		return;
	 To reduce dummy operation
	if((pHTInfo->bCurBW40MHz==false && Bandwidth==HT_CHANNEL_WIDTH_20) ||
	   (pHTInfo->bCurBW40MHz==true && Bandwidth==HT_CHANNEL_WIDTH_20_40 && Offset==pHTInfo->CurSTAExtChnlOffset))
		return;
	spin_lock_irqsave(&(ieee->bw_spinlock), flags);
	if (pHTInfo->bSwBwInProgress) {
		spin_unlock_irqrestore(&(ieee->bw_spinlock), flags);
		return;
	}
	if in half N mode, set to 20M bandwidth please 09.08.2008 WB.
	if (Bandwidth == HT_CHANNEL_WIDTH_20_40 && (!ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))) {
			 Handle Illegal extension channel offset!!
		if (ieee->current_network.channel < 2 && Offset == HT_EXTCHNL_OFFSET_LOWER)
			Offset = HT_EXTCHNL_OFFSET_NO_EXT;
		if (Offset == HT_EXTCHNL_OFFSET_UPPER || Offset == HT_EXTCHNL_OFFSET_LOWER) {
			pHTInfo->bCurBW40MHz = true;
			pHTInfo->CurSTAExtChnlOffset = Offset;
		} else {
			pHTInfo->bCurBW40MHz = false;
			pHTInfo->CurSTAExtChnlOffset = HT_EXTCHNL_OFFSET_NO_EXT;
		}
	} else {
		pHTInfo->bCurBW40MHz = false;
		pHTInfo->CurSTAExtChnlOffset = HT_EXTCHNL_OFFSET_NO_EXT;
	}
	pHTInfo->bSwBwInProgress = true;
	 
	HTSetConnectBwModeCallback(ieee);
	spin_unlock_irqrestore(&(ieee->bw_spinlock), flags);
}
 SPDX-License-Identifier: GPL-2.0
   Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
   Contact Information:
   James P. Ketrenos <ipw2100-admin@linux.intel.com>
   Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
   Few modifications for Realtek's Wi-Fi drivers by
   Andrea Merello <andrea.merello@gmail.com>
   A special thanks goes to Realtek for their support !
  802.11 Data Frame
  802.11 frame_contorl for data frames - 2 bytes
       ,-----------------------------------------------------------------------------------------.
  bits | 0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  a  |  b  |  c  |  d  |  e   |
       |----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|------|
  val  | 0  |  0  |  0  |  1  |  x  |  0  |  0  |  0  |  1  |  0  |  x  |  x  |  x  |  x  |  x   |
       |----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|------|
  desc | ^-ver-^  |  ^type-^  |  ^-----subtype-----^  | to  |from |more |retry| pwr |more |wep   |
       |          |           | x=0 data,x=1 data+ack | DS  | DS  |frag |     | mgm |data |      |
       '-----------------------------------------------------------------------------------------'
                                                     \
                                                     |
  802.11 Data Frame                                  |
            ,--------- 'ctrl' expands to >-----------'
            |
         ,--'---,-------------------------------------------------------------.
   Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
         |------|------|---------|---------|---------|------|---------|------|
   Desc. | ctrl | dura |  DARA  |   TA    |    SA   | Sequ |  Frame  |  fcs |
         |      | tion | (BSSID) |         |         | ence |  data   |      |
         `--------------------------------------------------|         |------'
   Total: 28 non-data bytes                                 `----.----'
                                                                 |
          .- 'Frame data' expands to <---------------------------'
          |
          V
         ,---------------------------------------------------.
   Bytes |  1   |  1   |    1    |    3     |  2   |  0-2304 |
         |------|------|---------|----------|------|---------|
   Desc. | SNAP | SNAP | Control |Eth Tunnel| Type | IP      |
         | DSAP | SSAP |         |          |      | Packet  |
         | 0xAA | 0xAA |0x03 (UI)|0x00-00-F8|      |         |
         `-----------------------------------------|         |
   Total: 8 non-data bytes                         `----.----'
                                                        |
          .- 'IP Packet' expands, if WEP enabled, to <--'
          |
          V
         ,-----------------------.
   Bytes |  4  |   0-2296  |  4  |
         |-----|-----------|-----|
   Desc. | IV  | Encrypted | ICV |
         |     | IP Packet |     |
         `-----------------------'
   Total: 8 non-data bytes
   802.3 Ethernet Data Frame
         ,-----------------------------------------.
   Bytes |   6   |   6   |  2   |  Variable |   4  |
         |-------|-------|------|-----------|------|
   Desc. | Dest. | Source| Type | IP Packet |  fcs |
         |  MAC  |  MAC  |      |           |      |
         `-----------------------------------------'
   Total: 18 non-data bytes
   In the event that fragmentation is required, the incoming payload is split into
   N parts of size ieee->fts.  The first fragment contains the SNAP header and the
   remaining packets are just data.
   If encryption is enabled, each fragment payload size is reduced by enough space
   to add the prefix and postfix (IV and ICV totalling 8 bytes in the case of WEP)
   So if you have 1500 bytes of payload with ieee->fts set to 500 without
   encryption it will take 3 frames.  With WEP it will take 4 frames as the
   payload of each frame is reduced to 492 bytes.
  SKB visualization
   ,- skb->data
  |
  |    ETHERNET HEADER        ,-<-- PAYLOAD
  |                           |     14 bytes from skb->data
  |  2 bytes for Type --> ,T. |     (sizeof ethhdr)
  |                       | | |
  |,-Dest.--. ,--Src.---. | | |
  |  6 bytes| | 6 bytes | | | |
  v         | |         | | | |
  0         | v       1 | v | v           2
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
      ^     | ^         | ^ |
      |     | |         | | |
      |     | |         | `T' <---- 2 bytes for Type
      |     | |         |
      |     | '---SNAP--' <-------- 6 bytes for SNAP
      |     |
      `-IV--' <-------------------- 4 bytes for IV (WEP)
       SNAP HEADER
	 To encrypt, frame format is:
	  IV (4 bytes), clear payload (including SNAP), ICV (4 bytes)
 PR: FIXME: Copied from hostap. Check fragmentationMSDUMPDU encryption.
	 Host-based IEEE 802.11 fragmentation for TX is not yet supported, so
	  call both MSDU and MPDU encryption functions from here.
int i;
 Classify the to-be send data packet
 Need to acquire the sent queue index.
check packet and mode later
 1M can only use Long Preamble. 11B spec
 If using legacy rate, it shall use 20MHz channel.
BandWidthAutoSwitch is for auto switch to 20 or 40 in long distance
 Common Settings
 Since protection frames are always sent by legacy rate, ShortGI will never be used.
 Most of protection using RTSCTS
 20MHz: Don't care;  40MHz: Duplicate.
 RTS frame bandwidth is always 20MHz
only unicast frame will use rtscts
check addr3 as infrastructure add3 is DA.
 b, g mode  {
 (1) RTS_Threshold is compared to the MPDU, not MSDU.
 (2) If there are more than one frag in  this MSDU, only the first frag uses protection frame.
		Other fragments are protected by previous fragment.
		So we only need to check the length of first fragment.
 Use CTS-to-SELF in protection mode.
otherwise return;
 11n High throughput case.
check ERP protection
 CTS-to-SELF
check HT op mode
 Rate is 24Mbps.
check rts
 Rate is 24Mbps.
to do list: check MIMO power save condition.
check AMPDU aggregation for TXOP
 Rate is 24Mbps.
 According to 8190 design, firmware sends CF-End only if RTSCTS is enabled. However, it degrads
 throughput around 10M, so we disable of this mechanism. 2007.08.03 by Emily
check IOT action
 Totally no protection case!!
 For test , CTS replace with RTS
 we deal qos data only  {
 Ensure zero initialized 
	 If there is no driver handler to take the TXB, dont' bother
	  creating it...
 Save source and destination addresses 
 Advance the SKB to the start of the payload 
 Determine total amount of storage required for TXB packets 
if(ieee->current_network.QoS_Enable)
			 To DS: Addr1 = BSSID, Addr2 = SA,
			  Addr3 = DA
			 not FromTo DS: Addr1 = DA, Addr2 = SA,
			  Addr3 = BSSID
		 Determine fragmentation size based on destination (multicast
		  and broadcast are not fragmented)
default:392
if (ieee->current_network.QoS_Enable)
set in the ieee80211_classify
		 Determine amount of payload per fragment.  Regardless of if
		  this stack is providing the full 802.11 header, one will
		  eventually be affixed to this fragment -- so we must account for
		  it when determining the amount of payload space.
 Each fragment may need to have room for encryption prepostfix 
		 Number of fragments is the total bytes_per_frag 
		  payload_per_fragment
		 When we allocate the TXB we allocate enough space for the reserve
		  and full fragment bytes (bytes_per_frag doesn't include prefix,
		  postfix, header, FCS, etc.)
if (ieee->current_network.QoS_Enable)
UP2AC(skb->priority);
			 If this is not the last fragment, then add the MOREFRAGS
			  bit to the frame control
 The last fragment takes the remaining length 
if(ieee->current_network.QoS_Enable)
 add 1 only indicate to corresponding seq number control 2006712
 Put a SNAP header on the first fragment 
 Advance the SKB... 
			 Encryption routine will move the header forward in order
			  to insert the IV between the header and the payload
WB add to fill data tcb_desc here. only first fragment is considered, need to change, and you may remove to other place.
 SPDX-License-Identifier: GPL-2.0
  Fieldbus Device Driver Core
 move to <linuxfieldbus_dev.h> when taking this out of staging 
 Maximum number of fieldbus devices 
 the dev_t structure to store the dynamically allocated fieldbus devices 
	
	  card_name was provided by child driver, could potentially be long.
	  protect against buffer overrun.
 data changed ? 
 SPDX-License-Identifier: GPL-2.0
  Arcx Anybus-S Controller driver
  Copyright (C) 2018 Arcx Inc
 move to <linuxanybuss-controller.h> when taking this out of staging 
 protects CONTROL register 
	
	  CPLD_CONTROL is write-only, so cache its value in
	  cd->control_reg
	
	  hw work-around:
	  the hardware is 'too fast', so a reset followed by an immediate
	  not-reset will _not_ change the anybus reset line in any way,
	  losing the reset. to prevent this from happening, introduce
	  a minimum reset duration.
	  Verified minimum safe duration required using a scope
	  on 14-June-2018: 100 us.
  parallel bus limitation:
  the anybus is 8-bit wide. we can't assume that the hardware will translate
  word accesses on the parallel bus to multiple byte-accesses on the anybus.
  the imx WEIM bus does not provide this type of translation.
  to be safe, we will limit parallel bus accesses to a single byte
  at a time for now.
	
	  single-byte parallel bus accesses are atomic, so don't
	  require any synchronization.
 CPLD control memory, sits at index 0 
 identify cpld 
 -ENODEV is fine, it just means no card detected 
 export can power readout as a regulator 
 make controller info visible to userspace 
 SPDX-License-Identifier: GPL-2.0
  HMS Profinet Client Driver
  Copyright (C) 2018 Arcx Inc
 move to <linuxfieldbus_dev.h> when taking this out of staging 
 move to <linuxanybuss-client.h> when taking this out of staging 
  ---------------------------------------------------------------
  Anybus Profinet mailbox messages - definitions
  ---------------------------------------------------------------
  note that we're depending on the layout of these structures being
  exactly as advertised.
 serializes card enable 
 Initialization Sequence, Generic Anybus Mode 
	
	  switch anybus off then on, this ensures we can do a complete
	  configuration cycle in case anybus was already on.
 SPDX-License-Identifier: GPL-2.0
  HMS Anybus-S Host Driver
  Copyright (C) 2018 Arcx Inc
  Architecture Overview
  =====================
  This driver (running on the CPUSoC) and the Anybus-S card communicate
  by reading and writing data tofrom the Anybus-S Dual-Port RAM (dpram).
  This is memory connected to both the SoC and Anybus-S card, which both sides
  can access freely and concurrently.
  Synchronization happens by means of two registers located in the dpram:
  IND_AB: written exclusively by the Anybus card; and
  IND_AP: written exclusively by this driver.
  Communication happens using one of the following mechanisms:
  1. reserve, readwrite, release dpram memory areas:
 	using an IND_ABIND_AP protocol, the driver is able to reserve certain
 	memory areas. no dpram memory can be read or written except if reserved.
 	(with a few limited exceptions)
  2. send and receive data structures via a shared mailbox:
 	using an IND_ABIND_AP protocol, the driver and Anybus card are able to
 	exchange commands and responses using a shared mailbox.
  3. receive software interrupts:
 	using an IND_ABIND_AP protocol, the Anybus card is able to notify the
 	driver of certain events such as: bus onlineoffline, data available.
 	note that software interrupt event bits are located in a memory area
 	which must be reserved before it can be accessed.
  The manual[1] is silent on whether these mechanisms can happen concurrently,
  or how they should be synchronized. However, section 13 (Driver Example)
  provides the following suggestion for developing a driver:
  a) an interrupt handler which updates global variables;
  b) a continuously-running task handling area requests (1 above)
  c) a continuously-running task handling mailbox requests (2 above)
  The example conspicuously leaves out software interrupts (3 above), which
  is the thorniest issue to get right (see below).
  The naive, straightforward way to implement this would be:
  - create an isr which updates shared variables;
  - create a work_struct which handles software interrupts on a queue;
  - create a function which does reserveupdateunlock in a loop;
  - create a function which does mailbox sendreceive in a loop;
  - call the above functions from the driver's readwriteioctl;
  - synchronize using mutexesspinlocks:
 	+ only one area request at a time
 	+ only one mailbox request at a time
 	+ protect AB_IND, AB_IND against data hazards (e.g. read-after-write)
  Unfortunately, the presence of the software interrupt causes subtle yet
  considerable synchronization issues; especially problematic is the
  requirement to reserverelease the area which contains the status bits.
  The driver architecture presented here sidesteps these synchronization issues
  by accessing the dpram from a single kernel thread only. User-space throws
  "tasks" (i.e. 1, 2 above) into a task queue, waits for their completion,
  and the kernel thread runs them to completion.
  Each task has a task_function, which is calledrun by the queue thread.
  That function communicates with the Anybus card, and returns either
  0 (OK), a negative error code (error), or -EINPROGRESS (waiting).
  On OK or error, the queue thread completes and dequeues the task,
  which also releases the user space thread which may still be waiting for it.
  On -EINPROGRESS (waiting), the queue thread will leave the task on the queue,
  and revisit (call again) whenever an interrupt event comes in.
  Each task has a state machine, which is run by calling its task_function.
  It ensures that the task will go through its various stages over time,
  returning -EINPROGRESS if it wants to wait for an event to happen.
  Note that according to the manual's driver example, the following operations
  may run independent of each other:
  - area reservereadwriterelease	(point 1 above)
  - mailbox operations			(point 2 above)
  - switching power onoff
  To allow them to run independently, each operation class gets its own queue.
  Userspace processes A, B, C, D post tasks to the appropriate queue,
  and wait for task completion:
 	process A	B	C	D
 		|	|	|	|
 		v	v	v	v
 	|<-----	========================================
 	|		|	   |		|
 	|		v	   v		v-------<-------+
 	|	+--------------------------------------+	|
 	|	| power q     | mbox q    | area q     |	|
 	|	|------------|------------|------------|	|
 	|	| task       | task       | task       |	|
 	|	| task       | task       | task       |	|
 	|	| task wait  | task wait  | task wait  |	|
 	|	+--------------------------------------+	|
 	|		^	   ^		^		|
 	|		|	   |		|		^
 	|	+--------------------------------------+	|
 	|	|	     queue thread	       |	|
 	|	|--------------------------------------|	|
 	|	| single-threaded:		       |	|
 	|	| loop:				       |	|
 	v	|   for each queue:		       |	|
 	|	|     run task state machine	       |	|
 	|	|     if task waiting:		       |	|
 	|	|       leave on queue		       |	|
 	|	|     if task done:		       |	|
 	|	|       complete task, remove from q   |	|
 	|	|   if software irq event bits set:    |	|
 	|	|     notify userspace		       |	|
 	|	|     post clear event bits task------>|>-------+
 	|	|   wait for IND_AB changed event OR   |
 	|	|            task added event	  OR   |
 	|	|	     timeout		       |
 	|	| end loop			       |
 	|	+--------------------------------------+
 	|	+		wake up		       +
 	|	+--------------------------------------+
 	|		^			^
 	|		|			|
 	+-------->-------			|
 						|
 		+--------------------------------------+
 		|	interrupt service routine      |
 		|--------------------------------------|
 		| wake up queue thread on IND_AB change|
 		+--------------------------------------+
  Note that the Anybus interrupt is dual-purpose:
  - after a reset, triggered when the card becomes ready;
  - during normal operation, triggered when AB_IND changes.
  This is why the interrupt service routine doesn't just wake up the
  queue thread, but also completes the card_boot completion.
  [1] https:www.anybus.comdocslibrariesprovider7default-document-library
 	manuals-design-guideshms-hmsi-27-275.pdf
 move to <linuxanybuss-.h> when taking this out of staging 
  ---------------------------------------------------------------
  Anybus mailbox messages - definitions
  ---------------------------------------------------------------
  note that we're depending on the layout of these structures being
  exactly as advertised.
 ------------- ref counted tasks ------------- 
 ------------------------ anybus hardware ------------------------ 
 protects IN side of powerq, mboxq, areaq 
	
	  irq handler needs exclusive access to the IND_AB register,
	  because the act of reading the register acks the interrupt.
	 
	  store the register value in cd->ind_ab (an atomic_t), so that the
	  queue thread is able to read it without causing an interrupt ack
	  side-effect (and without spuriously acking an interrupt).
 ------------------------ power onoff tasks --------------------- 
	
	  anybus docs: prevent false 'init done' interrupt by
	  doing a dummy read of IND_AB register while in reset.
 ---------------------------- area tasks ------------------------ 
 area not released yet 
 we don't own the area yet 
 we own the area, do what we're here to do 
 ask to release the area, must use unlocked release 
 ask to take the area 
 -------------------------- mailbox tasks ----------------------- 
 output message not here 
 grab the returned header and msg 
 tell anybus we've consumed the message 
 mbox input area busy 
 write the header and msg to input area 
 tell anybus we gave it a message 
	
	  prevent uninitialized memory in the header from being sent
	  across the anybus
	
	  mailbox mechanism worked ok, but maybe the mbox response
	  contains an error ?
 ------------------------ anybus queues ------------------------ 
 process software interrupt 
	
	  reset the event cause bits.
	  this must be done while owning the fbctrl area, so we'll
	  enqueue a task to do that.
	
	  this kernel thread has exclusive access to the anybus's memory.
	  only exception: the IND_AB register, which is accessed exclusively
	  by the interrupt service routine (ISR). This thread must not touch
	  the IND_AB register, but it does require access to its value.
	 
	  the interrupt service routine stores the register's value in
	  cd->ind_ab (an atomic_t), where we may safely access it, with the
	  understanding that it can be modified by the ISR at any time.
		
		  make a local copy of IND_AB, so we can go around the loop
		  again in case it changed while processing queues and softint.
		
		  time out so even 'stuck' tasks will run eventually,
		  and can time out.
 ------------------------ anybus exports ------------------------ 
 success 
 success 
 ------------------------ bus functions ------------------------ 
	
	  use a dpram test to check if a card is present, this is only
	  possible while in reset.
	
	  startup sequence:
	    a) perform dummy IND_AB read to prevent false 'init done' irq
	      (already done by test_dpram() above)
	    b) release reset
	    c) wait for first interrupt
	    d) interrupt came in: ready to go !
	
	  according to the anybus docs, we're allowed to read these
	  without handshaking  reserving the area
 put card back reset until a client driver releases it 
 fire up the queue thread 
	
	  now advertise that we've detected a client device (card).
	  the bus infrastructure will match it to a client driver.
 SPDX-License-Identifier: GPL-2.0
  Greybus operations
  Copyright 2015-2016 Google Inc.
 TODO -> delete from list 
 need to NULL terminate the list of attributes 
 Initialize the node 
 Set the module id 
 Copy the provided descriptor 
 set the kset 
	
	  Initialize and add the kobject to the kernel.  All the default files
	  will be created here.  As we have already specified a kset for this
	  kobject, we don't have to set a parent for the kobject, the kobject
	  will be placed beneath that kset automatically.
	
	  Notify the object was created
 SPDX-License-Identifier: GPL-2.0
  Greybus operations
  Copyright 2015-2016 Google Inc.
 SPDX-License-Identifier: GPL-2.0
  UART driver for the Greybus "generic" UART module.
  Copyright 2014 Google Inc.
  Copyright 2014 Linaro Ltd.
  Heavily based on driversusbclasscdc-acm.c and
  driversusbserialusb-serial.c.
 16 is more than enough 
 leave some space in fifo 
 input control lines 
 output control lines 
 overrun is special, not associated with a char 
	
	  the port the tty layer may be waiting for credits
 Maybe should use an invalid value instead 
 FIXME: needs to clear unsupported bits in the termios 
 initialize the uart to be 9600n81 
 SPDX-License-Identifier: GPL-2.0
  Greybus audio driver
  Copyright 2015-2016 Google Inc.
  Copyright 2015-2016 Linaro Ltd.
 mixer control 
 update uinfo 
 update ucontrol 
 update ucontrol 
  although below callback functions seems redundant to above functions.
  same are kept to allow provision for different handling in case
  of DAPM related sequencing, etc.
 update uinfo 
 update ucontrol 
 update ucontrol 
 Ensure GB speaker is connected 
 Ensure GB module supports jack slot 
 Ensure GB module supports jack slot 
 since count=1, and reg is dummy 
 debug enum info 
 since count=1, and reg is dummy 
 debug enum info 
 Find relevant module 
 map name to widget id 
 allocate memory for kcontrol 
 create relevant kcontrols 
 Prefix dev_id to widget control_name 
 Prefix dev_id to widget_name 
 fetch no. of kcontrols, widgets & routes 
 update block offset 
 process control 
 process widgets 
 process route 
 parse jack capabilities 
 release kcontrols 
 release widget controls 
 release widgets 
 release routes 
 SPDX-License-Identifier: GPL-2.0
  Power Supply driver for a Greybus module.
  Copyright 2014-2015 Google Inc.
  Copyright 2014-2015 Linaro Ltd.
  General power supply properties that could be absent from various reasons,
  like kernel versions or vendor specific versions
 cache time in milliseconds, if cache_time is set to 0 cache is disable 
  update interval initial and maximum value, between the two will
  back-off exponential
 do some exponential back-off in the update interval 
	
	  Check gbpsy->pm_acquired to make sure only one pair of 'get_sync'
	  and 'put_autosuspend' runtime pm call for state property change.
 this return the intval plus the strval properties 
 validate received properties 
 Store available properties, skip the ones we do not support 
	
	  now append the properties that we already got information in the
	  get_description operation. (char  ones)
	
	  Properties of type const char , were already fetched on
	  get_description operation and should be cached in gb
 check if cache is good enough or it has expired 
 check if there a change that need to be reported 
	
	  if the poll interval is not set, disable polling, this is helpful
	  specially at unregister time.
 cache immediately the new value 
 guarantee that we have an unique name, before register 
 everything went fine, mark it for release code to know 
	
	  we will only handle events after setup is done and before release is
	  running. For that just check update_interval.
		
		  we need to make sure we invalidate cache, if not no new
		  values for the properties will be fetch and the all propose
		  of this event is missed
 We aren't ready to receive an incoming request yet 
 We are ready to receive an incoming request now, enable RX as well 
 SPDX-License-Identifier: GPL-2.0
  GPIO Greybus driver.
  Copyright 2014 Google Inc.
  Copyright 2014 Linaro Ltd.
 The following has to be an array of line_max entries 
 --> make them just a flags field 
 0 = output, 1 = input 
 0 = low, 1 = high 
 max line number 
 Now find out how many lines there are 
 Allocate base dynamically 
 The event comes from the outside so no parent handler 
 SPDX-License-Identifier: GPL-2.0
  Greybus operations
  Copyright 2015-2016 Google Inc.
 helpers 
 public API 
 Add it to the list 
  module initdeinit
 SPDX-License-Identifier: GPL-2.0
  Greybus Audio Device Class Protocol helpers
  Copyright 2015-2016 Google Inc.
 TODO: Split into separate calls 
 SPDX-License-Identifier: GPL-2.0
  USB host driver for the Greybus "generic" USB module.
  Copyright 2014 Google Inc.
  Copyright 2014 Linaro Ltd.
 Greybus USB request types 
 FIXME: handle unspecified lengths 
 Greybus core has verified response size 
	
	  FIXME: The USB bridged-PHY protocol driver depends on changes to
	         USB core which are not yet upstream.
	 
	         Disable for now.
 SPDX-License-Identifier: GPL-2.0
  Greybus Bridged-Phy Bus driver
  Copyright 2014 Google Inc.
  Copyright 2014 Linaro Ltd.
 for old kernels we need get_sync to resume parent devices 
	
	  Drivers should call put on the gbphy dev before returning
	  from probe if they support runtime pm.
	
	  Create a bunch of children devices, one per cport, and bind the
	  bridged phy drivers to them.
 SPDX-License-Identifier: GPL-2.0
  SPI bridge PHY driver.
  Copyright 2014-2016 Google Inc.
  Copyright 2014-2016 Linaro Ltd.
 SPDX-License-Identifier: GPL-2.0
  Loopback bridge driver for the Greybus loopback module.
  Copyright 2014 Google Inc.
  Copyright 2014 Linaro Ltd.
 We need to take a lock in atomic context 
 Per connection stats 
 Minmax values in jiffies 
 Maximum size of any one send data buffer we support 
 interface sysfs attributes 
 Report 0 for min and max if no transfer succeeded 		\
 round closest 		\
 Time to send and receive one message 
 Number of requests sent per second on this cport 
 Quantity of data sent and received on this cport 
 Latency across the UniPro link from APBridge's perspective 
 Firmware induced overhead in the GPBridge 
 Number of errors encountered during loop 
 Number of requests successfully completed async 
 Number of requests timed out async 
 Timeout minimum in useconds 
 Timeout minimum in useconds 
  Type of loopback message to send based on protocol type definitions
  0 => Don't send message
  2 => Send ping message continuously (message without payload)
  3 => Send transfer message continuously (message with payload,
 					   payload returned in response)
  4 => Send a sink message (message with payload, no payload in response)
 Size of transfer message payload: 0-4096 bytes 
 Time to wait between two messages: 0-1000 ms 
 Maximum iterations for a given operation: 1-(2^32-1), 0 implies infinite 
 The current index of the for (i = 0; i < iteration_max; i++) loop 
 A flag to indicate synchronous or asynchronous operations 
 Timeout of an individual asynchronous request 
 Maximum number of in-flight operations before back-off 
 Calculate the total time the message took 
 Wake up waiters 
 Release resources 
 By convention, the AP initiates the version operation 
 -EMSGSIZE 
 Reset per-connection stats 
 Should be initialized at least once per transaction set 
 Express latency in terms of microseconds 
 Log latency stastic 
 Raw latency log on a per thread basis 
 Log the firmware supplied latency values 
 Limit the maximum number of in-flight async operations 
 Optionally terminate 
 Wait for synchronous and asynchronus completion 
 Mark complete unless user-space has poked us 
 Else operations to perform 
 We are effectively single threaded here 
 Reported values to user-space for minmax timeouts 
 Calculate maximum payload 
 Create per-connection sysfs and debugfs data-points 
 Allocate kfifo 
 Fork worker thread 
	
	  FIXME: gb_loopback_async_wait_all() is redundant now, as connection
	  is disabled at the beginning and so we can't have any more
	  incomingoutgoing requests.
 SPDX-License-Identifier: GPL-2.0
  Greybus Audio Sound SoC helper APIs
 ...find all widgets with the same stream and link them 
		
		  check if widget is already linked,
		  if (w->linked)
		 	return;
		 Add the DAPM path and set widget's linked status
		  snd_soc_dapm_add_path(w->dapm, src, sink, NULL, NULL);
		  w->linked = 1;
 For each DAI widget... 
	
	  remove source and sink paths associated to this widget.
	  While removing the path, remove reference to it from both
	  source and sink widgets so that path is removed only once.
 below logic can be optimized to identify widget pointer 
 SPDX-License-Identifier: GPL-2.0
  Greybus SPI library
  Copyright 2014-2016 Google Inc.
  Copyright 2014-2016 Linaro Ltd.
 if this is a write_read, for symmetry read the same as write 
	
	  if we transferred all content of the last transfer, reset values and
	  check if this was the last transfer in the message
 Routines to transfer data 
 Find number of transfers queued and txrx length in the message 
	
	  In addition to space for all message descriptors we need
	  to have enough to hold all tx data.
 Response consists only of incoming data 
 place tx data after last gb_xfer 
 Fill in the transfers array 
 make sure we do not timeout in a slow transfer 
 Copy tx data 
 Copy rx data 
 Nothing to do for now 
 Nothing to do for now 
 Routines to get controller information 
  Map Greybus spi mode bitsflagsbpw into Linux ones.
  All bits are same for now and so these macro's return same values.
 Allocate master with space for data 
 get master configuration 
 Allow spi-core to allocate it dynamically 
 Attach methods 
 now, fetch the devices configuration 
 SPDX-License-Identifier: GPL-2.0
  Greybus Camera protocol driver.
  Copyright 2015 Google Inc.
  Copyright 2015 Linaro Ltd.
  struct gb_camera - A Greybus Camera Device
  @connection: the greybus connection for camera management
  @data_connection: the greybus connection for camera data
  @data_cport_id: the data CPort ID on the module side
  @mutex: protects the connection and state fields
  @state: the current module state
  @debugfs: debugfs entries for camera protocol operations testing
  @module: Greybus camera module registered to HOST processor.
 GB format to media code map 
  Validate the stream configuration response verifying padding is correctly
  set and the returned number of streams is supported
 Validate the returned response structure 
 -----------------------------------------------------------------------------
  Hardware Configuration
  TODO: Compute the number of lanes dynamically based on bandwidth
  requirements.
	
	  Create the data connection between the camera module data CPort and
	  APB CDSI1. The CDSI1 CPort ID is hardcoded by the ES2 bridge.
 Set the UniPro link to high speed mode. 
	
	  Configure the APB-A CSI-2 transmitter.
	 
	  Hardcode the number of lanes to 4 and compute the bus clock frequency
	  based on the module bandwidth requirements with a safety margin.
 Stop the APB1 CSI transmitter. 
 Set the UniPro link to low speed mode. 
 Destroy the data connection. 
 -----------------------------------------------------------------------------
  Camera Protocol Operations
		
		  When unconfiguring streams release the PM runtime reference
		  that was acquired when streams were configured. The bundle
		  won't be suspended until the PM runtime reference acquired at
		  the beginning of this function gets released right before
		  returning.
	
	  Make sure the bundle won't be suspended until streams get
	  unconfigured after the stream is configured successfully
 Setup CSI-2 connection from APB-A to AP 
 -----------------------------------------------------------------------------
  Interface with HOST gmp camera.
 -----------------------------------------------------------------------------
  DebugFS
	
	  hex_dump_to_buffer() doesn't return the number of bytes dumped prior
	  to v4.0, we need our own implementation :-(
 Retrieve number of streams to configure 
 For each stream to configure parse width, height and format 
 width 
 height 
 Image format code 
 Request id 
 Stream mask 
 number of frames 
 For read-only entries the operation is triggered by a read. 
	
	  Create root debugfs entry and a file entry for each camera operation.
 -----------------------------------------------------------------------------
  Init & Cleanup
	
	  The camera bundle must contain exactly two CPorts, one for the
	  camera management protocol and one for the camera data protocol.
 SPDX-License-Identifier: GPL-2.0
  BOOTROM Greybus driver.
  Copyright 2016 Google Inc.
  Copyright 2016 Linaro Ltd.
 Timeout, in jiffies, within which the next request must be received 
  FIXME: Reduce this timeout once svc core handles parallel processing of
  events from the SVC, which are handled sequentially today.
 Protects bootrom->fw 
 TODO: Power-off Module ? 
  The es2 chip doesn't have VIDPID programmed into the hardware and we need to
  hack that up to distinguish different modules and their firmware blobs.
  This fetches VIDPID (over bootrom protocol) for es2 chip only, when VIDPID
  already sent during hotplug are 0.
  Otherwise, we keep intf->vendor_idproduct_id same as what's passed
  during hotplug.
	
	  NOTE: This is hacked, so that the same values of VIDPID can be used
	  by next firmware level as well. The uevent for bootrom will still
	  have VIDPID as 0, though after this point the sysfs files will start
	  showing the updated values. But yeah, that's a bit racy as the same
	  sysfs files would be showing 0 before this point.
 This returns path of the firmware blob on the disk 
 Already have a firmware, free it 
 Bootrom protocol is only supported for loading Stage 2 firmware 
	
	  Create firmware name
	 
	  XXX Name it properly..
 FIXME:
 Turn to dev_dbg later after everyone has valid bootloaders with good
 ids, but leave this as dev_info for now to make it easier to track
 down "empty" vidpid modules.
 Disable timeouts 
 Refresh timeout 
 Disable timeouts 
 Refresh timeout 
 Disable timeouts 
 Return error if the blob was invalid 
	
	  XXX Should we return error for insecure firmware?
	
	  Refresh timeout, the Interface shall load the new personality and
	  send a new hotplug request, which shall get rid of the bootrom
	  connection. As that can take some time, increase the timeout a bit.
 Refresh timeout 
 Tell bootrom we're ready. 
 Disable timeouts 
	
	  Release firmware:
	 
	  As the connection and the delayed work are already disabled, we don't
	  need to lock access to bootrom->fw here.
 SPDX-License-Identifier: GPL-2.0
  Greybus Lights protocol driver.
  Copyright 2015 Google Inc.
  Copyright 2015 Linaro Ltd.
 If the channel is flash we need to get the attached torch channel 
 For not flash we need to convert brightness to intensity 
 Set attributes based in the channel flags 
 we need to keep module alive when turning to active state 
	
	  on the other hand if going to inactive we still hold a reference and
	  need to put it, so we could go to suspend.
 we need to keep module alive when turning to active state 
	
	  on the other hand if going to inactive we still hold a reference and
	  need to put it, so we could go to suspend.
 V4L2 specific helpers 
 For v4l2 val is the default value 
 Set the possible values to faults, in our case all faults 
 Flash specific operations 
 we can only attach torch to a flash channel 
 Move torch brightness to the destination 
 append mode name to flash name 
 Only the flash mode have the timeout constraints settings 
	
	  If light have torch mode channel, this channel will be the led
	  classdev of the registered above flash classdev
	
	  Intensity constraints for flash related modes: flash, torch,
	  indicator.  They will be needed for v4l2 registration.
	
	  On flash type, max brightness is set as the number of intensity steps
	  available.
 Only the flash mode have the timeout constraints settings 
 Normal LED channel, just register in led classdev and we are done 
	
	  Flash Type need more work, register flash classdev, indicator as
	  flash classdev, torch will be led classdev of the flash classdev.
 The same as register, handle channels differently 
	
	  If it is not a flash related channel (flash, torch or indicator) we
	  are done here. If not, continue and fetch flash related
	  configurations.
 First we collect all the configurations for all channels 
	
	  Then, if everything went ok in getting configurations, we register
	  the classdev, flash classdev and v4l2 subsystem, if a flash device is
	  found.
 We aren't ready to receive an incoming request yet 
	
	  Setup all the lights devices over this connection, if anything goes
	  wrong tear down all lights
 We are ready to receive an incoming request now, enable RX as well 
 Enable & register lights 
 SPDX-License-Identifier: GPL-2.0
  Greybus Firmware Download Protocol Driver.
  Copyright 2016 Google Inc.
  Copyright 2016 Linaro Ltd.
 Estimated minimum buffer size, actual size can be smaller than this 
 Timeout, in jiffies, within which fetch or release firmware must be called 
 Timeout, in jiffies, within which the firmware shall download 
	
	  The request timed out and the module may send a fetch-fw or
	  release-fw request later. Lets block the id we allocated for this
	  request, so that the AP doesn't refer to a later fw-request (with
	  same firmware_id) for the old timedout fw-request.
	 
	  NOTE:
	 
	  This also means that after 255 timeouts we will fail to service new
	  firmware downloads. But what else can we do in that case anyway? Lets
	  just hope that it never happens.
  Incoming requests are serialized for a connection, and the only race possible
  is between the timeout handler freeing this and an incoming request.
  The operations on the fw-request list are protected by the mutex and
  get_fw_req() increments the reference count before returning a fw_req pointer
  to the users.
  free_firmware() also takes the mutex while removing an entry from the list,
  it guarantees that every user of fw_req has taken a kref-reference by now and
  we wouldn't have any new users.
  Once the last user drops the reference, the fw_req structure is freed.
 Caller must call put_fw_req() after using struct fw_request 
 Already disabled from timeout handlers 
 This returns path of the firmware blob on the disk 
 Allocate ids from 1 to 255 (u8-max), 0 is an invalid id 
 Timeout, in jiffies, within which firmware should get loaded 
 firmware_tag must be null-terminated 
 Make sure work handler isn't running in parallel 
 We timed-out before reaching here ? 
	
	  Firmware download must finish within a limited time interval. If it
	  doesn't, then we might have a buggy Module on the other side. Abort
	  download.
 Refresh timeout 
	
	  Make sure we have a reference to the pending requests, before they
	  are freed from the timeout handler.
 Release pending firmware packages 
 SPDX-License-Identifier: GPL-2.0
  Greybus Component Authentication Protocol (CAP) Driver.
  Copyright 2016 Google Inc.
  Copyright 2016 Linaro Ltd.
  Number of minor devices this driver supports.
  There will be exactly one required per Interface.
 connection getting disabled 
  All users of cap take a reference (from within list_mutex lock), before
  they get a pointer to play with. And the structure will be freed only after
  the last user has put the reference to it.
 Caller must call put_cap() after using struct gb_cap 
 Char device fops 
 cap structure can't get freed until file descriptor is closed 
	
	  Serialize ioctls.
	 
	  We don't want the user to do multiple authentication operations in
	  parallel.
	 
	  This is also used to protect ->disabled, which is used to check if
	  the connection is getting disconnected, so that we don't start any
	  new operations.
 Add a char device to allow userspace to interact with cap 
 Add a soft link to the previously added char-dev within the bundle 
	
	  Disallow any new ioctl operations on the char device and wait for
	  existing ones to finish.
 All pending greybus operations should have finished by now 
 Disallow new users to get access to the cap structure 
	
	  All current users of cap would have taken a reference to it by
	  now, we can drop our reference and wait the last user will get
	  cap freed.
 SPDX-License-Identifier: GPL-2.0
  SDMMC Greybus driver.
  Copyright 2014-2015 Google Inc.
  Copyright 2014-2015 Linaro Ltd.
 lock for this host 
 lock to cancel ongoing transfer 
 kernel vdd starts at 0x80 and we need to translate to greybus ones 0x01 
 get the max block size that could fit our payload 
 get ocr supported values 
 get frequency range values 
 check is a stop transmission is pending 
 some controllers need to know at command time data details 
 no response expected 
 long response expected 
 Check if it is a cancel to ongoing transfer 
 for now we make a map 1:1 between max request and segment size 
 SPDX-License-Identifier: GPL-2.0
  APBridge ALSA SoC dummy codec driver
  Copyright 2016 Google Inc.
  Copyright 2016 Linaro Ltd.
 find the dai 
 register cport 
 fixed for now 
 hw_params 
 prepare 
 find the dai 
 fixed for now 
 find the dai 
 register cport 
 fixed for now 
 hw_params 
 prepare 
 find the dai 
 fixed for now 
 parse dai_id from AIF widget's stream_name 
  codec DAI ops
 to prevent suspend in case of active audio 
	
	  assuming, currently only 48000 Hz, 16BIT_LE, stereo
	  is supported, validate params before configuring codec
 find the data connection 
 find the dai 
 find the dai 
 start playback 
 start capture 
 stop playback 
 stop capture 
 Add to module's jack list 
 Add to module's jack list 
	
	  Currently, max 4 buttons are supported with following key mapping
	  BTN_0 = KEY_MEDIA
	  BTN_1 = KEY_VOICECOMMAND
	  BTN_2 = KEY_VOLUMEUP
	  BTN_3 = KEY_VOLUMEDOWN
	 FIXME
	  verify if this is really required
	set_bit(INPUT_PROP_NO_DUMMY_RELEASE,
		module->button.jack.jack->input_dev->propbit);
 card already instantiated, create widgets here only 
		
		  register jack devices for this module
		  from codec->jack_list
 fixed for now 
 fixed for now 
 free jack devices for this module jack_list 
 release control semaphore 
  component driver ops
 init dai_list used to maintain runtime stream info 
 Empty function for now 
 SPDX-License-Identifier: GPL-2.0
  PWM Greybus driver.
  Copyright 2014 Google Inc.
  Copyright 2014 Linaro Ltd.
 max pwm number 
 Query number of pwms present 
 Allocate base dynamically 
 SPDX-License-Identifier: GPL-2.0
  HID class driver for the Greybus.
  Copyright 2014 Google Inc.
  Copyright 2014 Linaro Ltd.
 Greybus HID device's structure 
 Routines to get controller's information over greybus 
 Operations performed on greybus 
 Routines dealing with reports 
	
	  hid->driver_lock is held as we are in probe function,
	  we just need to setup the input fields, so using
	  hid_report_raw_event is safe.
 add report_id to the number of transferred bytes 
 HID Callbacks 
 Save some power 
 HID structure to pass callbacks 
	hid->bus = BUS_GREYBUS;  Need a bustype for GREYBUS in <linuxinput.h> 
 Set HID device's name 
 SPDX-License-Identifier: GPL-2.0
  Arche Platform driver to enable Unipro link.
  Copyright 2014-2015 Google Inc.
  Copyright 2014-2015 Linaro Ltd.
 Default state = pulled highlow 
 WD = falling edge (low) 
 WD = rising edge (high), > 30msec 
 As of now not used ?? 
 Cold boot process started 
 Not used 
 Control GPIO signals to and from AP <=> SVC 
 bi-dir,maps to WAKE_MOD & WAKE_FRAME signals 
 Protect wake_detect_state 
 Protect state 
 Requires calling context to hold arche_pdata->platform_state_mutex 
 Requires arche_pdata->wake_lock is held by calling context 
Child nodes are independent, so do not exit coldboot operation 
 Enable HUB3613 into HUB mode. 
 Enable interrupt here, to read event back from SVC 
 Something is wrong 
 It should complete power cycle, so first make sure it is poweroff 
 Bring APB out of reset: cold boot sequence 
 Enable HUB3613 into HUB mode. 
 wakedetect rising 
		
		  If wakedetect line goes high after low, within less than
		  30msec, then standby boot sequence is initiated, which is not
		  supportedimplemented as of now. So ignore it.
				
				  Check we are not in middle of irq thread
				  already
 wakedetect falling 
			
			  In the beginning, when wakedetect goes low
			  (first time), we assume it is meant for coldboot
			  and set the flag. If wakedetect line stays low
			  beyond 30msec, then it is coldboot else fallback
			  to standby boot.
  Requires arche_pdata->platform_state_mutex to be held
 bring SVC out of reset 
  Requires arche_pdata->platform_state_mutex to be held
  Requires arche_pdata->platform_state_mutex to be held
 If in fw_flashing mode, then no need to repeate things again 
 As part of exit, put APB back in reset state 
  If SVC goes down, bring down APB's as well 
		 First we want to make sure we power off everything
		  and then activate back again
		
		  Here we only control SVC.
		 
		  In case of FW_FLASHING mode we do not want to control
		  APBs, as in case of V2, SPI bus is shared between both
		  the APBs. So let user chose which APB he wants to flash.
 setup svc reset gpio 
 setup the clock request gpio first 
 setup refclk2 to follow the pin 
 Explicitly power off if requested 
 TODO: Should we do anything more here ?? 
	
	  If timing profile premits, we may shutdown bridge
	  completely
	 
	  TODO: sequence ??
	 
	  Also, need to make sure we meet precondition for unipro suspend
	  Precondition: Definition ???
	
	  Atleast for ES2 we have to meet the delay requirement between
	  unipro switch and AP bridge init, depending on whether bridge is in
	  OFF state or standby state.
	 
	  Based on whether bridge is in standby or OFF state we may have to
	  assert multiple signals. Please refer to WDM spec, for more info.
	 
 Use PIDVID of SVC device 
 Use PIDVID of SVC device 
 SPDX-License-Identifier: GPL-2.0
  Greybus audio driver
  Copyright 2015 Google Inc.
  Copyright 2015 Linaro Ltd.
  gb_snd management functions
 currently supports 4 buttons only 
 Management Cport 
  This is the basic hook get things initialized and registered w gb
 There should be at least one Management and one Data cport 
	
	  There can be only one Management connection and any number of data
	  connections.
 Create all connections 
 There must be a management cport 
 Initialize management connection 
	
	  FIXME: malloc for topology happens via audio_gb driver
	  should be done within codec driver itself
 process topology data 
 Initialize data connections 
 register module with gbcodec 
 inform above layer for uevent 
 prepare for the audio manager 
 todo 
 todo 
 cleanup module related resources first 
 inform uevent to above layers 
 SPDX-License-Identifier: GPL-2.0
  Greybus driver for the Raw protocol
  Copyright 2015 Google Inc.
  Copyright 2015 Linaro Ltd.
 Number of minor devices this driver supports 
 Maximum size of any one send data buffer we support 
  Maximum size of the data in the receive buffer we allow before we start to
  drop messages on the floor
  Add the raw data message to the list of received messages.
 Verify size of payload 
 FIXME - handle removing a connection when the char device node is open.
  Character device node interfaces.
  Note, we are using readwrite to only allow a single readwrite per message.
  This means for read(), you have to provide a big enough buffer for the full
  message to be copied into.  If the buffer isn't big enough, the read() will
  fail with -ENOSPC.
 SPDX-License-Identifier: GPL-2.0
  Greybus Firmware Core Bundle Driver.
  Copyright 2016 Google Inc.
  Copyright 2016 Linaro Ltd.
 Parse CPorts and create connections 
 Disallow multiple Firmware Management CPorts 
 Disallow multiple Firmware Download CPorts 
 Disallow multiple SPI CPorts 
 Disallow multiple CAP CPorts 
 Firmware Management connection is mandatory 
 We may still be able to work with the Interface 
 We may still be able to work with the Interface 
 We may still be able to work with the Interface 
 We may still be able to work with the Interface 
 FIXME: Remove this after S2 Loader gets runtime PM support 
 FIXME: Remove this after S2 Loader gets runtime PM support 
 SPDX-License-Identifier: GPL-2.0
  Greybus Audio Device Class Protocol helpers
  Copyright 2015-2016 Google Inc.
 SPDX-License-Identifier: GPL-2.0
  Greybus Vibrator protocol driver.
  Copyright 2014 Google Inc.
  Copyright 2014 Linaro Ltd.
 vibrator minor number 
 Greybus Vibrator operation types 
 Vibrator was switched ON earlier 
	
	  For now we create a device in sysfs for the vibrator, but odds are
	  there is a "real" device somewhere in the kernel for this, but I
	  can't find it at the moment...
 SPDX-License-Identifier: GPL-2.0
  Arche Platform driver to control APB.
  Copyright 2014-2015 Google Inc.
  Copyright 2014-2015 Linaro Ltd.
 Control GPIO signals to and from AP <=> AP Bridges 
 V2: SPI Bus control  
  Note that these low level api's are active high
  Note: Please do not modify the below sequence, as it is as per the spec
 Hold APB in reset state 
 Enable power to APB 
 On DB3 clock was not mandatory 
 deassert reset to APB : Active-low signal 
 for flashing device should be in reset state 
	
	  Even if it is in OFF state,
	  then we do not want to change the state
	
	  As per WDM spec, do nothing
	 
	  Pasted from WDM spec,
	   - A falling edge on POWEROFF_L is detected (a)
	   - WDM enters standby mode, but no output signals are changed
 TODO: POWEROFF_L is input to WDM module  
 disable the clock 
 As part of exit, put APB back in reset state 
 TODO: May have to send an event to SVC about this exit 
		
		  First we want to make sure we power off everything
		  and then enter FW flashing state
 It's not mandatory to support power management interface 
 Do not make clock mandatory as of now (for DB3) 
 Regulators are optional, as we may have fixed supply coming in 
 Only applicable for platform >= V2 
 Initially set APB to OFF state 
 Check whether device needs to be enabled on boot 
 Create sysfs interface to allow user to change state dynamically 
	
	  If timing profile permits, we may shutdown bridge
	  completely
	 
	  TODO: sequence ??
	 
	  Also, need to make sure we meet precondition for unipro suspend
	  Precondition: Definition ???
	
	  Atleast for ES2 we have to meet the delay requirement between
	  unipro switch and AP bridge init, depending on whether bridge is in
	  OFF state or standby state.
	 
	  Based on whether bridge is in standby or OFF state we may have to
	  assert multiple signals. Please refer to WDM spec, for more info.
	 
 SPDX-License-Identifier: GPL-2.0
  Greybus Firmware Management Protocol Driver.
  Copyright 2016 Google Inc.
  Copyright 2016 Linaro Ltd.
 Common id-map for interface and backend firmware requests 
 connection getting disabled 
 Interface Firmware specific fields 
 Backend Firmware specific fields 
  Number of minor devices this driver supports.
  There will be exactly one required per Interface.
  All users of fw_mgmt take a reference (from within list_mutex lock), before
  they get a pointer to play with. And the structure will be freed only after
  the last user has put the reference to it.
 Caller must call put_fw_mgmt() after using struct fw_mgmt 
	
	  The firmware-tag should be NULL terminated, otherwise throw error but
	  don't fail.
	
	  The firmware-tag should be NULL terminated, otherwise throw error and
	  fail.
 Allocate ids from 1 to 255 (u8-max), 0 is an invalid id 
 No pending load and validate request ? 
 Invalid request-id ? 
	
	  The firmware-tag should be NULL terminated, otherwise throw error and
	  fail.
 Reset version as that should be non-zero only for success case 
	
	  The firmware-tag should be NULL terminated, otherwise throw error and
	  fail.
 Allocate ids from 1 to 255 (u8-max), 0 is an invalid id 
 No pending load and validate request ? 
 Invalid request-id ? 
 Char device fops 
 fw_mgmt structure can't get freed until file descriptor is closed 
 Reject any operations after mode-switch has started 
		
		  Disallow new ioctls as the fw-core bundle driver is going to
		  get disconnected soon and the character device will get
		  removed.
	
	  Serialize ioctls.
	 
	  We don't want the user to do few operations in parallel. For example,
	  updating Interface firmware in parallel for the same Interface. There
	  is no need to do things in parallel for speed and we can avoid having
	  complicated code for now.
	 
	  This is also used to protect ->disabled, which is used to check if
	  the connection is getting disconnected, so that we don't start any
	  new operations.
 Add a char device to allow userspace to interact with fw-mgmt 
 Add a soft link to the previously added char-dev within the bundle 
	
	  Disallow any new ioctl operations on the char device and wait for
	  existing ones to finish.
 All pending greybus operations should have finished by now 
 Disallow new users to get access to the fw_mgmt structure 
	
	  All current users of fw_mgmt would have taken a reference to it by
	  now, we can drop our reference and wait the last user will get
	  fw_mgmt freed.
 SPDX-License-Identifier: GPL-2.0
  I2C bridge driver for the Greybus "generic" I2C module.
  Copyright 2014 Google Inc.
  Copyright 2014 Linaro Ltd.
  Map Greybus i2c functionality bits into Linux ones
 All bits the same for now 
  Do initial setup of the i2c device.  This includes verifying we
  can support it (based on the protocol version it advertises).
  If that's OK, we get and cached its functionality bits.
  Note: gb_i2c_dev->connection is assumed to have been valid.
  Map Linux i2c_msg flags into Greybus i2c transfer op flags.
 All flags the same for now 
	
	  In addition to space for all message descriptors we need
	  to have enough to hold all outbound message data.
 Response consists only of incoming data 
 Fill in the ops array 
 Copy over the outgoing data; it starts after the last op 
  Some i2c transfer operations return results that are expected.
 Looks good; up our i2c adapter 
 SPDX-License-Identifier: GPL-2.0
  Greybus driver for the log protocol
  Copyright 2016 Google Inc.
 Verify size of payload 
 Ensure the buffer is 0 terminated 
	
	  Print with dev_dbg() so that it can be easily turned off using
	  dynamic debugging (and prevent any DoS)
 SPDX-License-Identifier: BSD-3-Clause
  Loopback test application
  Copyright 2015 Google Inc.
  Copyright 2015 Linaro Ltd.
 list termination 
 Helper macros to calculate the aggregate results for all devices 
calculate the aggregate results of all enabled devices 
	
	  file name will test_name_size_iteration_max.csv
	  every time the same test with the same parameters is run we will then
	  append to the same CSV with datestamp - representing each test
	  dataset.
 Don't include '.' and '..' 
 at least one device did not finish yet 
 do nothing   }
 Dummy read to clear the event 
	
	  Cancel any running tests on enabled devices. If
	  stop_all option is given, stop test on all devices.
 Set operation size 
 Set iterations 
 the test starts by writing test_id to the type file. 
 SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
  Sample code to test CAP protocol
  Copyright(c) 2016 Google Inc. All rights reserved.
  Copyright(c) 2016 Linaro Ltd. All rights reserved.
 Make sure arguments are correct 
 Get UID 
 Get certificate 
 Authenticate 
 SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
  Sample code to test firmware-management protocol
  Copyright(c) 2016 Google Inc. All rights reserved.
  Copyright(c) 2016 Linaro Ltd. All rights reserved.
 Get Interface Firmware Version 
 Try Interface Firmware load over Unipro 
 Initiate Mode-switch to the newly loaded firmware 
 Get Backend Firmware Version 
 Try Backend Firmware Update over Unipro 
 Set Timeout 
 SPDX-License-Identifier: GPL-2.0
  USB Skeleton driver - 2.2
  Copyright (C) 2001-2004 Greg Kroah-Hartman (greg@kroah.com)
  This driver is based on the 2.6.3 version of driversusbusb-skeleton.c
  but has been rewritten to be easier to read and use.
 Define these values to match your devices 
 table of devices that work with this driver 
 Terminating entry 
 Get a minor range for your devices from the usb maintainer 
 our private defines. if this grows any larger, use your own .h file 
  MAX_TRANSFER is chosen so that the VM is not stressed by
  allocations > PAGE_SIZE and the number of packets in a page
  is an integer 512 is the largest possible packet on EHCI
 arbitrarily chosen 
 Structure to hold all of our device specific stuff 
 the usb device for this device 
 the interface for this device 
 limiting the number of writes in progress 
 in case we need to retract our submissions 
 the urb to read data with 
 the buffer to receive data 
 the size of the receive buffer 
 number of bytes in the buffer 
 already copied to user space 
 the address of the bulk in endpoint 
 the address of the bulk out endpoint 
 the last request tanked 
 a read is going on 
 lock for errors 
 synchronize IO with disconnect 
 to wait for an ongoing read 
 increment our usage count for the device 
 save our object in the file's private structure 
 allow the device to be autosuspended 
 decrement the count on our device 
 wait for io to stop 
 read out errors, leave subsequent opens a clean slate 
 syncasync unlink faults aren't errors 
 prepare a read 
 tell everybody to leave the URB alone 
 submit bulk in urb, which means no data to deliver 
 do it 
 no concurrent readers 
 disconnect() was called 
 if IO is under way, we must not touch things 
 nonblocking IO shall not wait 
		
		  IO may take forever
		  hence wait in an interruptible state
 errors must be reported 
 any error is reported once 
 to preserve notifications about reset 
 report it 
	
	  if the buffer is filled we may satisfy the read
	  else we need to start IO
 we had read data 
			
			  all data has been used
			  actual IO needs to be done
		
		  data is available
		  chunk tells us how much shall be copied
		
		  if we are asked for more than we have,
		  we start IO but don't wait
 no data in the buffer 
 syncasync unlink faults aren't errors 
 free up our allocated buffer 
 verify that we actually have some data to write 
	
	  limit the number of URBs in flight to stop a user from using up all
	  RAM
 any error is reported once 
 to preserve notifications about reset 
 create a urb, and a buffer for it, and copy the data to the urb 
 this lock makes sure we don't submit URBs to gone devices 
 disconnect() was called 
 initialize the urb properly 
 send the data out the bulk port 
	
	  release our reference to this urb, the USB core will eventually free
	  it entirely
  usb class driver info in order to get a minor number from the usb core,
  and to have the device registered with the driver core
 allocate memory for our device state and initialize it 
 set up the endpoint information 
 use only the first bulk-in and bulk-out endpoints 
 save our data pointer in this interface device 
 we can register the device now, as it is ready 
 something prevented us from registering this driver 
 let the user know what node this device is now attached to 
 this frees allocated memory 
 give back our minor 
 prevent more IO from starting 
 decrement our usage count 
 we are sure no URBs are active - no locking needed 
 SPDX-License-Identifier: GPL-2.0
  LED Triggers for USB Activity
  Copyright 2014 Michal Sojka <sojka@merica.cz>
 led_trigger_blink_oneshot() handles trig == NULL gracefully 
 SPDX-License-Identifier: GPL-2.0+
  OTG Finite State Machine from OTG spec
  Copyright (C) 2007,2008 Freescale Semiconductor, Inc.
  Author:	Li Yang <LeoLi@freescale.com>
 		Jerry Huang <Chang-Ming.Huang@freescale.com>
 Change USB protocol when there is a protocol change 
 stop old protocol 
 start new protocol 
 Called when leaving a state.  Do state clean up jobs here 
 Get host request flag from connected USB device 
 Continue HNP polling 
 Host request flag is set 
 Set b_hnp_enable 
	
	  The memory of host_req_flag should be allocated by
	  controller driver, otherwise, hnp polling is not started.
 Called when entering a state 
		
		  Driver is responsible for starting ADP probing
		  if ADP sensing times out.
		
		  When HNP is triggered while a_bus_req = 0, a_host will
		  suspend too fast to complete a_set_b_hnp_en
 State change judgement 
 State machine state change judgement 
 SPDX-License-Identifier: GPL-2.0
  ulpi.c - USB ULPI PHY bus
  Copyright (C) 2015 Intel Corporation
  Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
 -------------------------------------------------------------------------- 
 -------------------------------------------------------------------------- 
 Some ULPI devices don't have a vendor id so rely on OF match 
 -------------------------------------------------------------------------- 
 -------------------------------------------------------------------------- 
  __ulpi_register_driver - register a driver with the ULPI bus
  @drv: driver being registered
  @module: ends up being THIS_MODULE
  Registers a driver with the ULPI bus.
  ulpi_unregister_driver - unregister a driver with the ULPI bus
  @drv: driver to unregister
  Unregisters a driver with the ULPI bus.
 -------------------------------------------------------------------------- 
 Find a ulpi bus underneath the parent or the grandparent 
 Test the interface 
 Some ULPI devices don't have a vendor id so rely on OF match 
 needed early for ops 
  ulpi_register_interface - instantiate new ULPI device
  @dev: USB controller's device interface
  @ops: ULPI register access
  Allocates and registers a ULPI device and an interface for it. Called from
  the USB controller that provides the ULPI interface.
  ulpi_unregister_interface - unregister ULPI interface
  @ulpi: struct ulpi_interface
  Unregisters a ULPI device and it's interface that was created with
  ulpi_create_interface().
 -------------------------------------------------------------------------- 
 SPDX-License-Identifier: GPL-2.0
  Common USB debugging functions
  Copyright (C) 2010-2011 Texas Instruments Incorporated - https:www.ti.com
  Authors: Felipe Balbi <balbi@ti.com>,
 	    Sebastian Andrzej Siewior <bigeasy@linutronix.de>
  usb_decode_ctrl - Returns human readable representation of control request.
  @str: buffer to return a human-readable representation of control request.
        This buffer should have about 200 bytes.
  @size: size of str buffer.
  @bRequestType: matches the USB bmRequestType field
  @bRequest: matches the USB bRequest field
  @wValue: matches the USB wValue field (CPU byte order)
  @wIndex: matches the USB wIndex field (CPU byte order)
  @wLength: matches the USB wLength field (CPU byte order)
  Function returns decoded, formatted and human-readable description of
  control request packet.
  The usage scenario for this is for tracepoints, so function as a return
  use the same value as in parameters. This approach allows to use this
  function in TP_printk
  Important: wValue, wIndex, wLength parameters before invoking this function
  should be processed by le16_to_cpu macro.
 SPDX-License-Identifier: GPL-2.0
  USB GPIO Based Connection Detection Driver
  Copyright (C) 2019 MediaTek Inc.
  Author: Chunfeng Yun <chunfeng.yun@mediatek.com>
  Some code borrowed from driversextconextcon-usb-gpio.c
 ms 
 us 
  "DEVICE" = VBUS and "HOST" = !ID, so we have:
  Both "DEVICE" and "HOST" can't be set as active at the same time
  so if "HOST" is active (i.e. ID is 0)  we keep "DEVICE" inactive
  even if VBUS is on.
   Role          |   ID  |  VBUS
  ------------------------------------
   [1] DEVICE    |   H   |   H
   [2] NONE      |   H   |   L
   [3] HOST      |   L   |   H
   [4] HOST      |   L   |   L
  In case we have only one of these signals:
  - VBUS only - we want to distinguish between [1] and [2], so ID is always 1
  - ID only - we want to distinguish between [1] and [4], so VBUS = ID
 check ID and VBUS 
	
	  If the USB connector is a child of a USB port and that port already provides the VBUS
	  supply, there's no need for the USB connector to provide it again.
 Perform initial detection 
 SPDX-License-Identifier: GPL-2.0
  Provides code common for host and device side USB.
  If either host side (ie. CONFIG_USB=y) or device side USB stack
  (ie. CONFIG_USB_GADGET=y) is compiled in the kernel, this module is
  compiled-in as well.  Otherwise, if either of the two stacks is
  compiled as module, this file is compiled as module as well.
  usb_ep_type_string() - Returns human readable-name of the endpoint type.
  @ep_type: The endpoint type to return human-readable name for.  If it's not
    any of the types: USB_ENDPOINT_XFER_{CONTROL, ISOC, BULK, INT},
    usually got by usb_endpoint_type(), the string 'unknown' will be returned.
  usb_speed_string() - Returns human readable-name of the speed.
  @speed: The speed to return human-readable name for.  If it's not
    any of the speeds defined in usb_device_speed enum, string for
    USB_SPEED_UNKNOWN will be returned.
  usb_get_maximum_speed - Get maximum requested speed for a given USB
  controller.
  @dev: Pointer to the given USB controller device
  The function gets the maximum speed string from property "maximum-speed",
  and returns the corresponding enum usb_device_speed.
  usb_get_maximum_ssp_rate - Get the signaling rate generation and lane count
 	of a SuperSpeed Plus capable device.
  @dev: Pointer to the given USB controller device
  If the string from "maximum-speed" property is super-speed-plus-genXxY where
  'X' is the generation number and 'Y' is the number of lanes, then this
  function returns the corresponding enum usb_ssp_rate.
  usb_state_string - Returns human readable name for the state.
  @state: The state to return a human-readable name for. If it's not
 	any of the states devices in usb_device_state_string enum,
 	the string UNKNOWN will be returned.
  usb_get_role_switch_default_mode - Get default mode for given device
  @dev: Pointer to the given device
  The function gets string from property 'role-switch-default-mode',
  and returns the corresponding enum usb_dr_mode.
  usb_decode_interval - Decode bInterval into the time expressed in 1us unit
  @epd: The descriptor of the endpoint
  @speed: The speed that the endpoint works as
  Function returns the interval expressed in 1us unit for servicing
  endpoint for data transfers.
 uframes per NAK 
 uframes per NAK 
  of_usb_get_dr_mode_by_phy - Get dual role mode for the controller device
  which is associated with the given phy device_node
  @np:	Pointer to the given phy device_node
  @arg0: phandle args[0] for phy's with #phy-cells >= 1, or -1 for
         phys which do not have phy-cells
  In dts a usb controller associates with phy devices.  The function gets
  the string from property 'dr_mode' of the controller associated with the
  given phy device node, and returns the correspondig enum usb_dr_mode.
  of_usb_host_tpl_support - to get if Targeted Peripheral List is supported
  for given targeted hosts (non-PC hosts)
  @np: Pointer to the given device_node
  The function gets if the targeted hosts support TPL or not
  of_usb_update_otg_caps - to update usb otg capabilities according to
  the passed properties in DT.
  @np: Pointer to the given device_node
  @otg_caps: Pointer to the target usb_otg_caps to be set
  The function updates the otg capabilities
 Choose the lesser one if it's already been set 
		
		  otg-rev is mandatory for otg properties, if not passed
		  we set it to be 0 and assume it's a legacy otg device.
		  Non-dt platform can set it afterwards.
  usb_of_get_companion_dev - Find the companion device
  @dev: the device pointer to find a companion
  Find the companion device from platform bus.
  Takes a reference to the returned struct device which needs to be dropped
  after use.
  Return: On success, a pointer to the companion device, %NULL on failure.
 SPDX-License-Identifier: GPL-2.0+
  Safe Encapsulated USB Serial Driver
       Copyright (C) 2010 Johan Hovold <jhovold@gmail.com>
       Copyright (C) 2001 Lineo
       Copyright (C) 2001 Hewlett-Packard
  By:
       Stuart Lynne <sl@lineo.com>, Tom Rushworth <tbr@lineo.com>
  The encapsultaion is designed to overcome difficulties with some USB
  hardware.
  While the USB protocol has a CRC over the data while in transit, i.e. while
  being carried over the bus, there is no end to end protection. If the
  hardware has any problems getting the data into or out of the USB transmit
  and receive FIFO's then data can be lost.
  This protocol adds a two byte trailer to each USB packet to specify the
  number of bytes of valid data and a 10 bit CRC that will allow the receiver
  to verify that the entire USB packet was received without error.
  Because in this case the sender and receiver are the class and function
  drivers there is now end to end protection.
  There is an additional option that can be used to force all transmitted
  packets to be padded to the maximum packet size. This provides a work
  around for some devices which have problems with small USB packets.
  Assuming a packetsize of N:
       0..N-2  data and optional padding
       N-2     bits 7-2 - number of bytes of valid data
               bits 1-0 top two bits of 10 bit CRC
       N-1     bottom 8 bits of 10 bit CRC
       | Data Length       | 10 bit CRC                                |
       + 7 . 6 . 5 . 4 . 3 . 2 . 1 . 0 | 7 . 6 . 5 . 4 . 3 . 2 . 1 . 0 +
  The 10 bit CRC is computed across the sent data, followed by the trailer
  with the length set and the CRC set to zero. The CRC is then OR'd into
  the trailer.
  When received a 10 bit CRC is computed over the entire frame including
  the trailer and should be equal to zero.
  Two module parameters are used to control the encapsulation, if both are
  turned of the module works as a simple serial device with NO
  encapsulation.
  See linuxdriversusbdserial_fd for a device function driver
  implementation of this.
 Itsy 
 Calypso 
 Iris 
 Collie 
 Collie 
 Collie 
 Sharp tmp 
 terminating entry  
 Initial FCS value 
 Good final FCS value 
  fcs_compute10 - memcpy and calculate 10 bit CRC across buffer
  @sp: pointer to buffer
  @len: number of bytes
  @fcs: starting FCS
  Perform a memcpy and calculate fcs using ppp 10bit CRC algorithm. Return
  new 10 bit FCS.
 pad if necessary 
 set count 
 compute fcs and insert into trailer 
 SPDX-License-Identifier: GPL-2.0
  Prolific PL2303 USB to serial adaptor driver
  Copyright (C) 2001-2007 Greg Kroah-Hartman (greg@kroah.com)
  Copyright (C) 2003 IBM Corp.
  Original driver for 2.2.x by anonymous
  See Documentationusbusb-serial.rst for more information on using this
  driver
 BenqSiemens S81 
 Terminating entry 
  Use interrupt endpoint from first interface if available.
  This is needed due to the looney way its endpoints are set up.
 check out the endpoints of the other interface 
	
	  Legacy PL2303H, variants 0 and 1 (difference unknown).
 variant 0 
 variant 1 
 variant 0 
			
			  Assume it's an HXN-type if the device doesn't
			  support the old read request value.
  Returns the nearest supported baud rate that can be set directly without
  using divisors.
  NOTE: If unsupported baud rates are set directly, the PL2303 seems to
        use 9600 baud.
	
	  Apparently the formula is:
	    baudrate = 12M  32  (mantissa  4^exponent)
	  where
	    mantissa = buf[8:0]
	    exponent = buf[11:9]
 Avoid dividing by zero if baud > 3212M. 
 divide by 4 
 Exponent is maxed. Trim mantissa and leave. 
 Calculate and return the exact baud rate. 
	
	  Apparently, for the TA version the formula is:
	    baudrate = 12M  32  (mantissa  2^exponent)
	  where
	    mantissa = buf[10:0]
	    exponent = buf[15:13 16]
 Avoid dividing by zero if baud > 3212M. 
 divide by 2 
 Exponent is maxed. Trim mantissa and leave. 
 Calculate and return the exact baud rate. 
	
	  Use direct method for supported baud rates, otherwise use divisors.
	  Newer chip types do not support divisor encoding.
 Save resulting baud rate 
 Report back no change occurred 
 For reference buf[0]:buf[3] baud rate value 
 For reference buf[4]=0 is 1 stop bits 
 For reference buf[4]=1 is 1.5 stop bits 
 For reference buf[4]=2 is 2 stop bits 
		
		  NOTE: Comply with "real" UARTs  RS232:
		        use 1.5 instead of 2 stop bits with 5 data bits
 For reference buf[5]=0 is none parity 
 For reference buf[5]=1 is odd parity 
 For reference buf[5]=2 is even parity 
 For reference buf[5]=3 is mark parity 
 For reference buf[5]=4 is space parity 
	
	  Some PL2303 are known to lose bytes if you change serial settings
	  even to the same values as before. Thus we actually need to filter
	  in this specific case.
	 
	  Note that the tty_termios_hw_change check above is not sufficient
	  as a previously requested baud rate may differ from the one
	  actually used (and stored in old_termios).
	 
	  NOTE: No additional locking needed for line_settings as it is
	        only used in set_termios, which is serialised against itself.
 change control lines if we are switching to or from B0 
 reset upstream data pipes 
 Setup termios 
 Save off the uart status for others to look at 
 success 
 this urb is terminated, clean up 
 update line status 
	
	  Break takes precedence over parity, which takes precedence over
	  framing errors.
 overrun is special, not associated with a char 
 see pl2303_calc_num_ports 
 SPDX-License-Identifier: GPL-2.0
  Ours Technology Inc. OTi-6858 USB to serial adapter driver.
  Copyleft  (C) 2007 Kees Lemmens (adapted for kernel 2.6.20)
  Copyright (C) 2006 Tomasz Michal Lukaszewski (FIXME: add e-mail)
  Copyright (C) 2001-2004 Greg Kroah-Hartman (greg@kroah.com)
  Copyright (C) 2003 IBM Corp.
  Many thanks to the authors of pl2303 driver: all functions in this file
  are heavily based on pl2303 code, buffering code is a 1-to-1 copy.
  Warning! You use this driver on your own risk! The only official
  description of this device I have is datasheet from manufacturer,
  and it doesn't contain almost any information needed to write a driver.
  Almost all knowlegde used while writing this driver was gathered by:
   - analyzing traffic between device and the M$ Windows 2000 driver,
   - trying different bit combinations and checking pin states
     with a voltmeter,
   - receiving malformed frames and producing buffer overflows
     to learn how errors are reported,
  So, THIS CODE CAN DESTROY OTi-6858 AND ANY OTHER DEVICES, THAT ARE
  CONNECTED TO IT!
  See Documentationusbusb-serial.rst for more information on using this
  driver
  TODO:
   - implement correct flushing for ioctls and oti6858_close()
   - check how errors (rx overflow, parity error, framing error) are reported
   - implement oti6858_break_ctl()
   - implement more ioctls
   - testimplement flow control
   - allow setting custom baud rates
 requests 
 format of the control packet 
 baud rate = 96000000  (16  divisor), LE 
 1.5 stop bits if FMT_DATA_BITS_5 
 always equals 0x43 
 settings of flow control lines 
 output pin 
 input pin, active low 
 input pin, active low 
 output pin 
 input pin, active low 
 input pin, active low 
 number of bytes in rx buffer ;
 function prototypes 
 device info 
 USB port with which associated 
 we will try again 
 we will try again 
 FIXME: check the FIFO length 
	 manufacturer claims that this device can work with baud rates
	  up to 3 Mbps; I've tested it only on 115200 bps, so I can't
	  guarantee that any other baud rate will work (especially
	  the higher ones)
 change control lines if we are switching to or from B0 
	 FIXME:
	spin_lock_irqsave(&priv->lock, flags);
	control = priv->line_control;
	if ((cflag & CBAUD) == B0)
		priv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);
	else
		priv->line_control |= (CONTROL_DTR | CONTROL_RTS);
	if (control != priv->line_control) {
		control = priv->line_control;
		spin_unlock_irqrestore(&priv->lock, flags);
		set_control_lines(serial->dev, control);
	} else {
		spin_unlock_irqrestore(&priv->lock, flags);
	}
 assume default (after power-on reset) values 
 38400 bps 
 8N1 
 DTR, RTS 
 RTS, CTS, DSR, DTR, RI, DCD 
 setup termios 
 clear out any remaining data in the buffer 
 cancel scheduled setup 
 shutdown our urbs 
 FIXME: check if this is correct (active highlow) 
 FIXME: check if this is correct (active highlow) 
 success 
 this urb is terminated, clean up 
		dev_dbg(&urb->dev->dev, "%s(): submitting interrupt urb\n", __func__); 
 schedule the interrupt urb 
 success 
 this urb is terminated, clean up 
 error in the urb, so we have to resubmit it 
 schedule the interrupt urb if we are still open 
 SPDX-License-Identifier: GPL-2.0+
  F81532F81534 USB to Serial Ports Bridge
  F81532 => 2 Serial Ports
  F81534 => 4 Serial Ports
  Copyright (C) 2016 Feature Integration Technology Inc., (Fintek)
  Copyright (C) 2016 Tom Tsai (Tom_Tsai@fintek.com.tw)
  Copyright (C) 2016 Peter Hong (Peter_Hong@fintek.com.tw)
  The F81532F81534 had 1 control endpoint for setting, 1 endpoint bulk-out
  for all serial port TX and 1 endpoint bulk-in for all serial port read in
  (Read DataMSRLSR).
  Write URB is fixed with 512bytes, per serial port used 128Bytes.
  It can be described by f81534_prepare_write_buffer()
  Read URB is 512Bytes max, per serial port used 128Bytes.
  It can be described by f81534_process_read_urb() and maybe received with
  128x1,2,3,4 bytes.
 Serial Port register Address 
 Default URB timeout for USB operations 
  We used interal SPI bus to access FLASH section. We must wait the SPI bus to
  idle if we performed any command.
  SPI Bus status register: F81534_BUS_REG_STATUS
 	Bit 01	: BUSY
 	Bit 2	: IDLE
  F81532534 Clock registers (offset +08h)
  Bit0:	UART Enable (always on)
  Bit2-1:	Clock source selector
 			00: 1.846MHz.
 			01: 18.46MHz.
 			10: 24MHz.
 			11: 14.77MHz.
  Bit4:	Auto direction(RTS) control (RTS pin Low when TX)
  Bit5:	Invert direction(RTS) when Bit4 enabled (RTS pin high when TX)
 Terminating entry 
 Pin output value for M2M1M0(SD) 
	
	  Our device maybe not reply when heavily loading, We'll retry for
	  F81534_USB_MAX_RETRY times.
	
	  Our device maybe not reply when heavily loading, We'll retry for
	  F81534_USB_MAX_RETRY times.
  If we try to access the internal flash via SPI bus, we should check the bus
  status for every command. e.g., F81534_BUS_REG_STARTF81534_BUS_REG_END
 Continuous read mode 
 To write F81534_BUS_REG_END when final byte 
			
			  Dummy code, force IC to generate a read pulse, the
			  set of value 0xf1 is dont care (any value is ok)
	
	  The block layout is fixed with 4x128 Bytes, per 128 Bytes a port.
	  index 0: port phy idx (e.g., 0,1,2,3)
	  index 1: only F81534_TOKEN_WRITE
	  index 2: serial TX out length
	  index 3: fix to 0
	  index 4~127: serial out data block
 Check is any data in write_fifo 
 Check HW is TXEMPTY 
 Round to nearest divisor 
 128 FIFO & TL: 1x 
 128 FIFO & TL: 8x 
 TL: 1 
 TL: 8 
 no change 
 'Set' takes precedence over 'Clear' 
 Always enable UART_MCR_OUT2 
  This function will search the data area with token F81534_CUSTOM_VALID_TOKEN
  for latest configuration index. If nothing found
  (index = F81534_CUSTOM_NO_CUSTOM_DATA), We'll load default configure in
  F81534_DEF_CONF_ADDRESS_START section.
  Due to we only use block0 to save data, so index should be 0 or
  F81534_CUSTOM_NO_CUSTOM_DATA.
 We'll use the custom data when the data is valid. 
  The F81532534 will not report serial port to USB serial subsystem when
  HW DCDDSRCTSRIRX pin connected to ground.
  To detect RX pin status, we'll enable MCR interal loopback, disable it and
  delayed for 60ms. It connected to ground If LSR register report UART_LSR_BI.
  We had 2 generation of F81532534 IC. All has an internal storage.
  1st is pure USB-to-TTL RS232 IC and designed for 4 ports only, no any
  internal data will used. All mode and gpio control should manually set
  by AP or Driver and all storage space value are 0xff. The
  f81534_calc_num_ports() will run to final we marked as "oldest version"
  for this IC.
  2rd is designed to more generic to use any transceiver and this is our
  mass production type. We'll save data in F81534_CUSTOM_ADDRESS_START
  (0x2f00) with 9bytes. The 1st byte is a indicater. If the token is
  F81534_CUSTOM_VALID_TOKEN(0xf0), the IC is 2nd gen type, the following
  4bytes save port mode (0:RS2321:RS485 Invert2:RS485), and the last
  4bytes save GPIO state(value from 0~7 to represent 3 GPIO output pin).
  The f81534_calc_num_ports() will run to "new style" with checking
  F81534_PORT_UNAVAILABLE section.
 Check had custom setting 
	
	  We'll read custom data only when data available, otherwise we'll
	  read default value instead.
 Read default board setting 
 New style, find all possible ports 
 Nothing found, oldest version IC 
 Assign phy-to-logic mapping 
	
	  Setup bulk-out endpoint multiplexing. All ports share the same
	  bulk-out endpoint.
 Update input line counters 
 Get MSR initial value 
 Force update current state 
 Submit Read URBs for first port opened 
 Kill Read URBs when final port closed 
	
	  The block layout is 128 Bytes
	  index 0: port phy idx (e.g., 0,1,2,3),
	  index 1: It's could be
	 			F81534_TOKEN_RECEIVE
	 			F81534_TOKEN_TX_EMPTY
	 			F81534_TOKEN_MSR_CHANGE
	  index 2: serial in size (data+lsr, must be even)
	 			meaningful for F81534_TOKEN_RECEIVE only
	  index 3: current MSR with this device
	  index 4~127: serial in data block (data+lsr, must be even)
 Try to submit writer 
		
		  Newer IC configure will make transceiver in shutdown mode on
		  initial power on. We need enable it before using UARTs.
	
	  We'll make tx frame error when baud rate from 384~500kps. So we'll
	  delay all tx data frame with 1bit.
 Assign logic-to-phy mapping 
	
	  The F81532534 will hang-up when enable LSR interrupt in IER and
	  occur data overrun. So we'll disable the LSR interrupt in probe()
	  and submit the LSR worker to clear LSR state when reported LSR error
	  bit with bulk-in data in f81534_process_per_serial_block().
 Read current MSR from device 
	
	  We'll register port 0 bulkin when port had opened, It'll take all
	  port received data, MSR register change and TX_EMPTY information.
 SPDX-License-Identifier: GPL-2.0+
  spcp8x5 USB to serial adaptor driver
  Copyright (C) 2010-2013 Johan Hovold (jhovold@gmail.com)
  Copyright (C) 2006 Linxb (xubin.lin@worldplus.com.cn)
  Copyright (C) 2006 S1 Corp.
  Original driver for 2.6.10 pl2303 driver by
    Greg Kroah-Hartman (greg@kroah.com)
  Changes for 2.6.20 by Harald Klein <hari@vt100.at>
 Terminating entry 
 spcp8x5 spec register define 
 verdor command here , we should define myself 
 how come ??? 
 check that they really want us to change something 
 set DTRRTS active 
 Set Baud Rate 
	case 1200000:	buf[0] = 0x0f;	break; 
	case 2400000:	buf[0] = 0x10;	break; 
	case 6000000:	buf[0] = 0x12;	break; 
 Set Data Length : 00:5bit, 01:6bit, 10:7bit, 11:8bit 
 Set Stop bit2 : 0:1bit 1:2bit 
 Set Parity bit3-4 01:Odd 11:Even 
 enable hardware flow control 
 SPDX-License-Identifier: GPL-2.0+
  TI 34105052 USB Serial Driver
  Copyright (C) 2004 Texas Instruments
  This driver is based on the Linux io_ti driver, which is
    Copyright (C) 2000-2002 Inside Out Networks
    Copyright (C) 2001-2002 Greg Kroah-Hartman
  For questions or problems with this driver, contact Texas Instruments
  technical support, or Al Borchers <alborchers@steinerpoint.com>, or
  Peter Berger <pberger@brimson.com>.
 Configuration ids 
 Vendor and product ids 
 TI ez430 development tool 
 no EEPROM, no firmware 
 no EEPROM, no firmware 
 EEPROM, no firmware 
 firmware is running 
 Fish River Island II 
 Multi-Tech vendor and product ids 
 Abbott Diabetics vendor and product ids 
 Honeywell vendor and product IDs 
 Honeywell HGI80 
 Moxa UPORT 11x0 vendor and product IDs 
 Commands 
 Module identifiers 
 Modem status 
 Line status 
 Line control 
 Modem control 
 Mask settings 
 Parity 
 Stop bits 
 Bits per character 
 232485 modes 
 Pipe transfer mode and timeout 
 Config struct 
 Get port status 
 Purge modes 
 ReadWrite data 
 Interrupt struct 
 Interrupt codes 
 Download firmware max packet size 
 Firmware image header 
 UART addresses 
 UART 1 base address 
 UART 2 base address 
 UART MCR register offset 
 UART MCR register offset 
 read urb states 
 232 or 485 modes 
 terminator 
 terminator 
 determine device type 
 if we have only 1 configuration and 1 endpoint, download firmware 
 3410 must be reset, 5052 resets itself 
 the second configuration must be set 
	
	  The TUSB5052 LSR does not tell when the transmitter shift register
	  has emptied so add a one-character drain delay.
 only one open on any port on a device at a time 
 start interrupt urb the first time a port is opened on this device 
	 reset the data toggle on the bulk endpoints to work around bug in
 start read urb 
 last port is closed, shut down interrupt urb 
	
	  TUSB5052 does not have the TEMT bit to tell if the shift register
	  is empty.
 these flags must be set 
 CMSPAR isn't supported by this driver 
 RTS flow control must be off to drop RTS for baud rate B0 
 FIXME: Should calculate resulting baud here and report it back 
 SET_CONFIG asserts RTS and DTR, reset them correctly 
 if baud rate is B0, clear RTS and DTR 
 continue to read unless stopping 
 send any buffered data 
 TODO: reschedule ti_send 
 more room in the buffer for new writes, wakeup 
 handle CTS flow control 
 try ID specific firmware first, then try generic firmware 
 SPDX-License-Identifier: GPL-2.0
  USB Serial Converter Bus specific functions
  Copyright (C) 2002 Greg Kroah-Hartman (greg@kroah.com)
	
	  drivers are already assigned to ports in serial_probe so it's
	  a simple check here.
 make sure suspendresume doesn't race against port_probe 
	
	  Make sure suspendresume doesn't race against port_remove.
	 
	  Note that no further runtime PM callbacks will be made if
	  autopm_get fails.
 SPDX-License-Identifier: GPL-2.0
  USB Serial Console driver
  Copyright (C) 2001 - 2002 Greg Kroah-Hartman (greg@kroah.com)
  Thanks to Randy Dunlap for the original version of this code.
  ------------------------------------------------------------
  USB Serial console driver
  Much of the code here is copied from driverscharserial.c
  and implements a phony serial console in the same way that
  serial.c does so that in case some software queries it,
  it will get the same results.
  Things that are different from the way the serial port code
  does things, is that we call the lower level usb-serial
  driver code to initialize the device, and we set the initial
  console speeds based on the command line arguments.
  ------------------------------------------------------------
  The parsing of the command line works exactly like the
  serial.c code, except that the specifier is "ttyUSB" instead
  of "ttyS".
 Sane default 
	
	  no need to check the index here: if the index is wrong, console
	  code won't call us
 no device is connected yet, sorry :( 
			
			  allocate a fake tty so the driver can initialize
			  the termios structure, then later call set_termios to
			  configure according to command line arguments
		 only call the device specific open if this
	 Now that any required fake tty operations are completed restore
	 The console is special in terms of closing the device so
 search for LF so we can insert CR if necessary 
		 pass on to the driver specific version of this function if
 append CR after LF 
		
		  Call register_console() if this is the first device plugged
		  in.  If we call it earlier, then the callback to
		  console_setup() will fail, as there is not a device seen by
		  the USB subsystem yet.
		
		  Register console.
		  NOTES:
		  console_setup() is called (back) immediately (from
		  register_console). console_write() is called immediately
		  from register_console iff CON_PRINTBUFFER is set in flags.
 SPDX-License-Identifier: GPL-2.0
  usb-serial driver for Quatech USB 2 devices
  Copyright (C) 2012 Bill Pemberton (wfp5p@virginia.edu)
   These devices all have only 1 bulk in and 1 bulk out that is shared
   for all serial ports.
 default urb timeout for usb operations 
 status bytes for the device 
 following 1 byte is line status 
 following 1 byte is modem status 
 following 2 bytes are ?? 
 following 1 byte is port to change to 
 no following info 
 no following info 
 pass through previous 2 control bytes 
 size of read buffer 
 size of write buffer 
 control bytes used for a write 
 RS232 single port 
 RS232 dual port 
 RS232422485 dual port 
 RS232 four port 
 RS232422485 four port 
 RS232 eight port 
 RS232422485 eight port 
 Terminating entry 
 Terminating entry 
 current port for incoming data 
 shared among all ports 
 Round to nearest divisor 
 no change 
 'set' takes precedence over 'clear' 
 we didn't recognize the device 
 set the port to RS232 mode 
 open the port 
 set to default speed and 8bit word size 
 flush the port transmit buffer 
 flush the port receive buffer 
 close the port 
 bytes_written = (ch[1] << 4) + ch[0]; 
 power on unit 
 Disable flow control 
 drop RTS and DTR 
 May be called from qt2_process_read_urb() for an unbound port. 
 update input line counters 
 May be called from qt2_process_read_urb() for an unbound port. 
 SPDX-License-Identifier: GPL-2.0
  Fintek F81232 USB to serial adaptor driver
  Fintek F81532A534A535536 USB to 24812 serial adaptor driver
  Copyright (C) 2012 Greg Kroah-Hartman (gregkh@linuxfoundation.org)
  Copyright (C) 2012 Linux Foundation
 1 port UART device 
 In-Box 2 port UART device 	\
 In-Box 4 port UART device 	\
 In-Box 8 port UART device 	\
 In-Box 12 port UART device  \
 Non-Flash type  \
 2 port UART device  \
 4 port UART device  \
 8 port UART device  \
 12 port UART device 
 Global control device 
 Terminating entry 
 Terminating entry 
 Terminating entry 
 Terminating entry 
 Maximum baudrate for F81232 
 USB Control EP parameter 
  F81232 Clock registers (106h)
  Bit1-0:	Clock source selector
 			00: 1.846MHz.
 			01: 18.46MHz.
 			10: 24MHz.
 			11: 14.77MHz.
 Serial port self GPIO control, 2bytes [control&output data][input data] 
 1: input, 0: output 
 no change 
 'set' takes precedence over 'clear' 
 force enable interrupt with OUT2 
 msr change 
 tx-empty 
 rx data available 
 lsr change 
 we can forget it. the LSR will read from bulk-in 
 success 
 this urb is terminated, clean up 
	
	  When opening the port we get a 1-byte packet with the current LSR,
	  which we discard.
 bulk-in data: [LSR(1Byte)+DATA(1Byte)][LSR(1Byte)+DATA(1Byte)]... 
 bulk-in data: [LEN][Data.....][LSR] 
 get LCR 
 Enable DLAB 
 low 
 high 
 fifo on, trigger8, clear TXRX
 MSR Interrupt only, LSR will read from Bulk-in odd byte 
 Don't change anything if nothing has changed 
 force get current MSR changed state 
 Setup termios 
	
	  Enable all available serial ports, define as following:
	  bit 15	: Reset behavior (when HUB got soft reset)
	 			0: maintain all serial port enabled state.
	 			1: disable all serial port.
	  bit 0~11	: Serial port enable bit.
 tri-state with pull-high, default RS232 Mode 
 SPDX-License-Identifier: GPL-2.0
  Xsens MT USB driver
  Copyright (C) 2013 Xsens <info@xsens.com>
 SPDX-License-Identifier: GPL-2.0+
  Belkin USB Serial Adapter Driver
   Copyright (C) 2000		William Greathouse (wgreathouse@smva.com)
   Copyright (C) 2000-2001	Greg Kroah-Hartman (greg@kroah.com)
   Copyright (C) 2010		Johan Hovold (jhovold@gmail.com)
   This program is largely derived from work by the linux-usb group
   and associated source files.  Please see the usbserial files for
   individual credits and copyrights.
  See Documentationusbusb-serial.rst for more information on using this
  driver
  TODO:
  -- Add true modem control line query capability.  Currently we track the
     states reported by the interrupt and the states we request.
  -- Add support for flush commands
 function prototypes for a Belkin USB Serial Adapter F5U103 
 Terminating entry 
 All of the device info needed for the serial converters 
  Belkin USB Serial Adapter F5U103 specific driver functions
 default urb timeout 
 assumes that struct usb_serial serial is available 
 see comments at top of file 
 success 
 this urb is terminated, clean up 
 Handle known interrupt data 
 ignore data[0] and data[1] 
 Record Control Line states 
 Update line status 
		 Break takes precedence over parity, which takes precedence
 Overrun is special, not associated with a char. 
 Will hold the new flags 
 get a local copy of the current port settings 
 Set the baud rate 
 reassert DTR and (maybe) RTS on transition from B0 
 don't set RTS if using hardware flow control 
 Clip to maximum speed 
 Turn it back into a resulting real baud rate 
 Report the actual baud rate back to the caller 
 Disable flow control 
 Drop RTS and DTR 
 set the parity 
 set the number of data bits 
 set the number of stop bits 
 Set flow control 
 save off the modified port settings 
 SPDX-License-Identifier: GPL-2.0+
  MCT (Magic Control Technology Corp.) USB RS232 Converter Driver
    Copyright (C) 2000 Wolfgang Grandegger (wolfgang@ces.ch)
  This program is largely derived from the Belkin USB Serial Adapter Driver
  (see belkin_sa.[ch]). All of the information about the device was acquired
  by using SniffUSB on Windows98. For technical details see mct_u232.h.
  William G. Greathouse and Greg Kroah-Hartman provided great help on how to
  do the reverse engineering and how to write a USB serial device driver.
  TO BE DONE, TO BE CHECKED:
    DTRRTS signal handling may be incomplete or incorrect. I have mainly
    implemented what I have seen with SniffUSB or found in belkin_sa.c.
    For further TODOs check also belkin_sa.c.
  Function prototypes
  All of the device info needed for the MCT USB-RS232 converter.
 Terminating entry 
 Modem Line Setting (TIOCM) 
 Line Control Register 
 Line Status Register 
 Modem Status Register 
 Throttling flags 
  Handle vendor specific USB requests
 default urb timeout 
  Later day 2.6.0-test kernels have new baud rates like B230400 which
  we do not know how to support. We ignore them for the moment.
 this one not tested 
		 FIXME: Can we use any divider - should we do
		   divider = 115200value;
FIXME: What value speed results 
	 Mimic the MCT-supplied Windows driver (version 1.21P.0104), which
	   always sends two extra USB 'device request' messages after the
	   'baud rate change' message.  The actual functionality of the
	   request codes in these messages is not fully understood but these
	   particular codes are never seen in any operation besides a baud
	   rate change.  Both of these messages send a single byte of data.
	   In the first message, the value of this byte is always zero.
	   The second message has been determined experimentally to control
	   whether data will be transmitted to a device which is not asserting
	   the 'CTS' signal.  If the second message's data byte is zero, data
	   will be transmitted even if 'CTS' is not asserted (i.e. no hardware
	   flow control).  if the second message's data byte is nonzero (a
	   value of 1 is used by this driver), data will not be transmitted to
	   a device which is not asserting 'CTS'.
 mct_u232_set_baud_rate 
 mct_u232_set_line_ctrl 
 mct_u232_set_modem_ctrl 
 mct_u232_get_modem_stat 
 Translate Control Line states 
 mct_u232_msr_to_icount 
 Translate Control Line states 
 mct_u232_msr_to_state 
  Driver's tty interface functions
 check first to simplify error handling 
 Use second interrupt-in endpoint for reading. 
	 Compensate for a hardware bug: although the Sitecom U232-P25
	  device reports a maximum output packet size of 32 bytes,
	  it seems to be able to accept only 16 bytes (and that's what
	  SniffUSB says too...)
	 Do a defined restart: the normal serial device seems to
	  always turn on DTR and RTS here, so do the same. I'm not
	  sure if this is really necessary. But it should not harm
	  either.
 Read modem status and update control state 
 mct_u232_open 
 mct_u232_close 
 success 
 this urb is terminated, clean up 
	
	  Work-a-round: handle the 'usual' bulk-in pipe here
	
	  The interrupt-in pipe signals exceptional conditions (modem line
	  signal changes and errors). data[0] holds MSR, data[1] holds LSR.
 Record Control Line states 
 Not yet handled. See belkin_sa.c for further information 
 Now to report any errors 
	
	  fill in the flip buffer here, but I do not know the relation
	  to the currentnext receive buffer or characters.  I need
	  to look in to this before committing any code.
 Overrun Error 
 Parity Error 
 Framing Error 
 Break Indicator 
 mct_u232_read_int_callback 
 get a local copy of the current port settings 
	
	  Update baud rate.
	  Do not attempt to cache old rates and skip settings,
	  disconnects screw such tricks up completely.
	  Premature optimization is the root of all evil.
 reassert DTR and RTS on transition from B0 
 Drop RTS and DTR 
	
	  Update line control register (LCR)
 set the parity 
 set the number of data bits 
 set the number of stop bits 
 save off the modified port settings 
 mct_u232_set_termios 
 mct_u232_break_ctl 
 SPDX-License-Identifier: GPL-2.0
  USB Debug cable driver
  Copyright (C) 2006 Greg Kroah-Hartman <greg@kroah.com>
 This HW really does not support a serial break, so one will be
  emulated when ever the break state is set to true.
 SPDX-License-Identifier: GPL-2.0+
  USB Keyspan PDA  Xircom  Entrega Converter driver
  Copyright (C) 1999 - 2001 Greg Kroah-Hartman	<greg@kroah.com>
  Copyright (C) 1999, 2000 Brian Warner	<warner@lothar.com>
  Copyright (C) 2000 Al Borchers		<borchers@steinerpoint.com>
  Copyright (C) 2020 Johan Hovold <johan@kernel.org>
  See Documentationusbusb-serial.rst for more information on using this
  driver
 no clue 
 For Xircom PGSDB9 and older Entrega version of the same device 
 "PGMFHUB" serial 
 Terminating entry 
 Terminating entry 
 Terminating entry 
 write_room 
 value: 0 means "remaining room" 
 index 
	
	  Ask the device to tell us when the tx buffer becomes
	  sufficiently empty.
 request_unthrottle 
 index 
	
	  Need to check available space after requesting notification in case
	  buffer is already empty so that no notification is sent.
 success 
 this urb is terminated, clean up 
 see if the message is data or a status interrupt 
 rest of message is rx data 
 status interrupt 
 modemline change 
 tx unthrottle interrupt 
	
	  Stop receiving characters. We just turn off the URB request, and
	  let chars pile up in the device. If we're doing hardware
	  flowcontrol, the device will signal the other end when its buffer
	  fills up. If we're doing XONXOFF, this would be a good time to
	  send an XOFF, although it might make sense to foist that off upon
	  the device too.
 just restart the receive interrupt URB 
 Default to 9600 
 set baud 
 type 
 value 
 index 
 &data 
 size 
 timeout 
 start break 
 clear break 
 set break 
	
	  cflag specifies lots of stuff: number of stop bits, parity, number
	  of data bits, baud. What can the device actually handle?:
	  CSTOPB (1 stop bit or 2)
	  PARENB (parity)
	  CSIZE (5bit .. 8bit)
	  There is minimal hw support for parity (a PSW bit seems to hold the
	  parity of whatever is in the accumulator). The UART either deals
	  with 10 bits (start, 8 data, stop) or 11 bits (start, 8 data,
	  1 special, stop). So, with firmware changes, we could do:
	  8N1: 10 bit
	  8N2: 11 bit, extra bit always (mark?)
	  8[EOMS]1: 11 bit, extra bit is parity
	  7[EOMS]1: 10 bit, b0b7 is parity
	  7[EOMS]2: 11 bit, b0b7 is parity, extra bit always (mark?)
	 
	  HW flow control is dictated by the tty->termios.c_cflags & CRTSCTS
	  bit.
	 
	  For now, just do baud.
 It hasn't changed so.. 
	
	  Only speed can change so copy the old hw parameters then encode
	  the new speed.
  Modem control pins: DTR and RTS are outputs and can be controlled.
  DCD, RI, DSR, CTS are inputs and can be read. All outputs can also be
  read. The byte passed is: DTR(b7) DCD RI DSR CTS RTS(b2) unused unused.
 get pins 
 set pins 
	
	  Guess how much room is left in the device's ring buffer. If our
	  write will result in no room left, ask the device to give us an
	  interrupt when the room available rises above a threshold but also
	  query how much room is currently available (in case our guess was
	  too conservative and the buffer is already empty when the
	  unthrottle work is scheduled).
	
	  We might block because of:
	  the TX urb is in-flight (wait until it completes)
	  the device is full (wait until it says there is room)
 find out how much room is in the Tx ring 
	
	  Stop the interrupt URB first as its completion handler may submit
	  the write URB.
 download the firmware to a "fake" device (pre-renumeration) 
 download the firmware here ... 
	
	  After downloading firmware renumeration will occur in a moment and
	  the new device will bind to the real driver.
 We want this device to fail to have a driver assigned to it. 
 SPDX-License-Identifier: GPL-2.0
  USB HandSpring Visor, Palm m50x, and Sony Clie driver
  (supports all of the Palm OS USB devices)
 	Copyright (C) 1999 - 2004
 	    Greg Kroah-Hartman (greg@kroah.com)
  See Documentationusbusb-serial.rst for more information on using this
  driver
  Version Information
 function prototypes for a handspring visor 
 Terminating entry 
 Terminating entry 
 Terminating entry 
 Terminating entry 
 All of the device info needed for the Handspring Visor,
 All of the device info needed for the Clie UX50, TH55 Palm 5.0 devices 
 device info for the Sony Clie OS version 3.5 
  Handspring Visor specific driver functions
 this is needed for some brain dead Sony devices 
 Start reading from the device 
 success 
 this urb is terminated, clean up 
	
	  This information is still unknown what it can be used for.
	  If anyone has an idea, please let the author know...
	 
	  Rumor has it this endpoint is used to notify when data
	  is ready to be read from the bulk ones.
 send a get connection info request 
 Handle devices that report invalid stuff here. 
	
	  save off our num_ports info so that we can use it in the
	  calc_num_ports callback
	 ask for the number of bytes available, but ignore the
	
	  some Samsung Android phones in modem mode have the same ID
	  as SPH-I500, but they are ACM devices, so dont bind to them
	
	  Only swap the bulk endpoints for the Handspring devices with
	  interrupt in endpoints, which for now are the Treo devices.
	
	  It appears that Treos and Kyoceras want to use the
	  1st bulk in endpoint to communicate with the 2nd bulk out endpoint,
	  so let's swap the 1st and 2nd bulk in and interrupt endpoints.
	  Note that swapping the bulk out endpoints would break lots of
	  apps that want to communicate on the second port.
	
	  TH55 registers 2 ports.
	  Communication in from the UX50TH55 uses the first bulk-in
	  endpoint, while communication out to the UX50TH55 uses the second
	  bulk-out endpoint.
	
	  FIXME: Should we swap the descriptors instead of using the same
	         bulk-out endpoint for both ports?
	
	  Note that PEG-300 series devices expect the following two calls.
 get the config number 
 get the interface number 
 SPDX-License-Identifier: GPL-2.0
  Qualcomm USB Auxiliary Serial Port driver
  Copyright (C) 2008 Greg Kroah-Hartman <greg@kroah.com>
  Copyright (C) 2010 Dan Williams <dcbw@redhat.com>
  Devices listed here usually provide a CDC ACM port on which normal modem
  AT commands and PPP can be used.  But when that port is in-use by PPP it
  cannot be used simultaneously for status or signal strength.  Instead, the
  ports here can be queried for that information using the Qualcomm DM
  protocol.
 NOTE: for now, only use this driver for devices that provide a CDC-ACM port
  for normal AT commands, but also provide secondary USB interfaces for the
  QCDM-capable ports.  Devices that do not provide a CDC-ACM port should
  probably be driven by option.ko.
 UTStarcomPantechCuritel devices 
 aka Pantech PX-500 
 CMOTECH devices 
 LG devices 
 VX4400VX6000Rumor 
 Sanyo devices 
 SCP-3800 (Katana LX) 
 Samsung devices 
 SCH-U520 
 NMEA 
 WMC 
 DIAG 
 SPDX-License-Identifier: GPL-2.0
  Some of this code is credited to Linux USB open source files that are
  distributed with Linux.
  Copyright:	2007 Metrologic Instruments. All rights reserved.
  Copyright:	2011 Azimut Ltd. <http:azimutrzn.ru>
 Product information. 
 Deactivate DTR and RTS. 
 Activate RTS. 
 Activate DTR. 
 default urb timeout. 
 Private data structure. 
 Device table list. 
 MS7820 
 Terminating entry. 
 UNI-Directional mode commands for device configure 
 Success status, read from the port. 
 urb has been terminated. 
 Set the data read from the usb port into the serial port buffer. 
 Loop through the data copying each byte to the tty layer. 
 Force the data to the tty layer. 
 Set any port variables. 
 Try to resubmit the urb. 
 Set the private data information for the port. 
 Clear the urb pipe. 
 Start reading from the device 
 Send activate cmd to device 
 Set the modem control value. 
 Send the command to the usb port. 
 Set the private information for the port to stop reading data. 
 Set the RTS and DTR values. 
 Set the private information for the port to resume reading data. 
 Submit the urb to read from the port. 
 SPDX-License-Identifier: GPL-2.0+
   REINER SCT cyberJack pinpade-com USB Chipcard Reader Driver
   Copyright (C) 2001  REINER SCT
   Author: Matthias Bruestle
   Contact: support@reiner-sct.com (see MAINTAINERS)
   This program is largely derived from work by the linux-usb group
   and associated source files.  Please see the usbserial files for
   individual credits and copyrights.
   Thanks to Greg Kroah-Hartman (greg@kroah.com) for his help and
   patience.
   In case of problems, please write to the contact e-mail address
   mentioned above.
   Please note that later models of the cyberjack reader family are
   supported by a libusb-based userspace device driver.
   Homepage: http:www.reiner-sct.desupporttreiber_cyberjack.php#linux
 Function prototypes 
 Terminating entry 
 Lock for SMP 
 Bytes still to read 
 Buffer for collecting data to write 
 Overall data size we already got 
 Data already sent 
 To much data for buffer. Reset buffer. 
 Copy data 
 We have enough data to begin transmission 
 set up our urb 
 send the data out the bulk port 
 Throw away data. No better idea what to do with it. 
 FIXME: .... 
 the urb might have been killed. 
 React only to interrupts signaling a bulk_in transfer 
 This is a announcement of coming bulk_ins. 
 "+=" is probably more fault tolerant than "=" 
 Reduce urbs to do by one. 
 Just to be sure 
 Continue to read if we have still urbs to do. 
 || (urb->actual_length==port->bulk_in_endpointAddress)) {
 only do something if we have more data to send 
 set up our urb 
 send the data out the bulk port 
 Throw away data. No better idea what to do with it. 
 SPDX-License-Identifier: GPL-2.0+
  USB ConnectTech WhiteHEAT driver
 	Copyright (C) 2002
 	    Connect Tech Inc.
 	Copyright (C) 1999 - 2001
 	    Greg Kroah-Hartman (greg@kroah.com)
  See Documentationusbusb-serial.rst for more information on using this
  driver
 WhiteHEAT specific commands 
  Version Information
   ID tables for whiteheat are unusual, because we want to different
   things for different versions of the device.  Eventually, this
   will be doable from a single table.  But, for now, we define two
   separate ID tables, and then a third table that combines them
   just for the purpose of exporting the autoloading information.
 Terminating entry 
 Terminating entry 
 Terminating entry 
 function prototypes for the Connect Tech WhiteHEAT prerenumeration device 
 function prototypes for the Connect Tech WhiteHEAT serial converter 
	wait_queue_head_t	wait_command;  for handling sleeping whilst
						 waiting for a command to
 FIXME: no locking on mcr 
 local function prototypes 
 2 second timeout for a command 
  Connect Tech's White Heat prerenumeration driver functions
 steps to download the firmware to the WhiteHEAT device:
 - hold the reset (by writing to the reset bit of the CPUCS register)
 - download the VEND_AX.HEX file to the chip using VENDOR_REQUEST-ANCHOR_LOAD
 - release the reset (by writing to the CPUCS register)
 - download the WH.HEX file for all addresses greater than 0x1b3f using
   VENDOR_REQUEST-ANCHOR_EXTERNAL_RAM_LOAD
 - hold the reset
 - download the WH.HEX file for all addresses less than 0x1b40 using
   VENDOR_REQUEST_ANCHOR_LOAD
 - release the reset
 - device renumerated itself and comes up as new device id with all
   firmware download completed.
 We want this device to fail to have a driver assigned to it 
  Connect Tech's White Heat serial driver functions
	
	  When the module is reloaded the firmware is still there and
	  the endpoints are still in the usb core unchanged. This is the
	  unlinking bug in disguise. Same for the call below.
 See the comment on the usb_clear_halt() above 
 Firmware likely not running 
 free up our private data for our command port 
 send an open port command 
 Work around HCD bugs 
  Connect Tech's White Heat callback routines
		 These are unsolicited reports from the firmware, hence no
 Continue trying to always read 
  Connect Tech's White Heat firmware interface
 wait for the command to complete 
 determine the parity 
 figure out the stop bits requested 
 figure out the flow control settings 
 determine software flow control 
 get the baud rate wanted 
 fixme: should set validated settings 
 handle any settings that aren't specified in the tty structure 
 now send the message to the device 
  Connect Tech's White Heat utility functions
 Work around HCD bugs 
 SPDX-License-Identifier: GPL-2.0
  Opticon USB barcode to serial driver
  Copyright (C) 2011 - 2012 Johan Hovold <jhovold@gmail.com>
  Copyright (C) 2011 Martin Jansen <martin.jansen@opticon.com>
  Copyright (C) 2008 - 2009 Greg Kroah-Hartman <gregkh@suse.de>
  Copyright (C) 2008 - 2009 Novell Inc.
 max number of write urbs in flight 
 This driver works for the Opticon 1D barcode reader
 This structure holds all of the individual device information 
 protects the following flags 
	
	  Data from the device comes with a 2 byte header:
	 
	  <0x00><0x00>data...
	       This is real data to be sent to the tty layer
	  <0x00><0x01>level
	       This is a CTS level change, the third byte is the CTS
	       value (0 for low, 1 for high).
	 Send the message to the vendor control endpoint
 Clear RTS line 
 clear the halt status of the endpoint 
	 Request CTS line state, sometimes during opening the current
 free up the transfer buffer, as usb_free_urb() does not do this 
 setup packet may be set if we're using it for writing 
	 The connected devices do not have a bulk write endpoint,
 send it down the pipe 
	 we are done with this urb, so let the host driver
	
	  We really can take almost anything the user throws at us
	  but let's pick a nice big number to tell the tty
	  layer that we have lots of free space, unless we don't.
 We only support RTS so we only handle that 
 SPDX-License-Identifier: GPL-2.0+
  Keyspan USB to Serial Converter driver
  (C) Copyright (C) 2000-2001	Hugh Blemings <hugh@blemings.org>
  (C) Copyright (C) 2002	Greg Kroah-Hartman <greg@kroah.com>
  See http:blemings.orghughkeyspan.html for more information.
  Code in this driver inspired by and in a number of places taken
  from Brian Warner's original Keyspan-PDA driver.
  This driver has been put together with the support of Innosys, Inc.
  and Keyspan, Inc the manufacturers of the Keyspan USB-serial products.
  Thanks Guys :)
  Thanks to Paulus for miscellaneous tidy ups, some largish chunks
  of much nicer andor completely new code and (perhaps most uniquely)
  having the patience to sit down and explain why and where he'd changed
  stuff.
  Tip 'o the hat to IBM (and previously Linuxcare :) for supporting
  staff in their work on open source projects.
 Values used for baud rate calculation - device specific 
 a guess 
 Some constants used to characterise each device.  
  Device info for the Keyspan serial converter, used by the overall
  usb-serial probe function.
 Product IDs for the products supported, pre-renumeration 
  Product IDs post-renumeration.  Note that the 28x and 28xb have the same
  id's post-renumeration but behave identically so it's not an issue. As
  such, the 28xb is not listed in any of the device tables.
 product ID value 
 Number of physical ports 
 1 if endpoint flipping used on input, 0 if not 
 1 if endpoint flipping used on output, 0 if not 
		
		  Table mapping input data endpoint IDs to physical port
		  number and flip if used
 Same for output endpoints 
 Input acknowledge endpoints 
 Output control endpoints 
 Endpoint used for input status 
 Endpoint used for input data 49WG only 
 Endpoint used for global control functions 
  Now for each device type we setup the device detail structure with the
  appropriate information (provided in Keyspan's documentation)
  We don't need a separate entry for the usa28xb as it appears as a 28x
  anyway.
 single 'global' data in EP 
 uses control EP 
 28xb not required as it renumerates as a 28x 
 Terminating entry 
 usb_device_id table for the pre-firmware download keyspan devices 
 Terminating entry 
 Terminating entry 
 Terminating entry 
 Terminating entry 
 Per device and per port private data 
	 added to support 49wg, where data from all 4 ports comes in
 XXX this one probably will need a lock 
 for EP0 control message 
 Keep track of which input & output endpoints to use 
	 Keep duplicate of device details in each port
	   structure as well - simplifies some of the
 Input endpoints and buffer for this port 
 Output endpoints and buffer for this port 
 Input ack endpoint 
 Output control endpoint 
 Settings for the port 
 Handshaking pins (outputs) 
 Handshaking pins (inputs) 
 need to resend control packet 
 Include Keyspan message headers.  All current Keyspan Adapters
   make use of one of five message formats which are referred
   to as USA-26, USA-28, USA-49, USA-90, USA-67 by Keyspan and
	 Baud rate calculation takes baud rate as an integer
 If no match or invalid, don't change 
 FIXME - more to do here to ensure rate changes cleanly 
 FIXME - calculate exact rate from divisor ? 
 set CTSRTS handshake etc. 
 MarkSpace not supported 
 Write function is similar for the four protocols used
 Check we have a valid urbendpoint before we use it... 
 no bulk out, so return 0 bytes written 
		 First byte in buffer is "last flag" (except for usa19hx)
 send the data out the bulk port 
		 Flip for next time if usa26 or usa28 interface
 0x80 bit is error flag 
			 no errors on individual bytes, only
 some bytes had errors, every byte has status 
 XXX should handle break (0x10) 
 Resubmit urb so we continue receiving 
 Outdat handling is common for all devices 
 Check port number from message and retrieve private data 
 Update handshaking pin state information 
 Resubmit urb so we continue receiving 
 Resubmit urb so we continue receiving 
 Check port number from message and retrieve private data 
 Update handshaking pin state information 
 Resubmit urb so we continue receiving 
	 This is actually called glostat in the Keyspan
 Check port number from message and retrieve private data 
 Update handshaking pin state information 
 Resubmit urb so we continue receiving 
 0x80 bit is error flag 
 no error on any byte 
 some bytes had errors, every byte has status 
 XXX should handle break (0x10) 
 Resubmit urb so we continue receiving 
 inbound data is in the form P#, len, status, data 
 Check port number from message 
 0x80 bit is error flag 
 no error on any byte 
			
			  some bytes had errors, every byte has status
 XXX should handle break (0x10) 
 Resubmit urb so we continue receiving 
 not used, usa-49 doesn't have per-port control endpoints 
		 if current mode is DMA, looks like usa28 format
 0x80 bit is error flag 
				 no errors on individual bytes, only
 some bytes had errors, every byte has status 
 XXX should handle break (0x10) 
 Resubmit urb so we continue receiving 
 Now do something useful with the data 
 Update handshaking pin state information 
 Resubmit urb so we continue receiving 
 Status messages from the 28xg 
 Now do something useful with the data 
 Check port number from message and retrieve private data 
 Update handshaking pin state information 
 Resubmit urb so we continue receiving 
 FIXME: locking 
 Check both endpoints to see if any are available. 
 Set some sane defaults 
 force baud and lcr to be set on open 
 Reset low level data toggle and start reading from endpoints 
		 make sure endpoint data toggle is synchronized
 Reset low level data toggle on out endpoints 
		 usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),
	 get the terminal config for the setup message now so we don't
		 Baud rate calculation takes baud rate as an integer
 If no match or invalid, leave as default 
 set CTSRTS handshake etc. 
 mdelay(100); 
 keyspan_set_termios(port, NULL); 
 pilot-xfer seems to work best with this delay 
 download the firmware to a pre-renumeration device 
 Select firmware image on the basis of idProduct 
	 after downloading firmware Renumeration will occur in a
 we don't want this device to have a driver assigned to it. 
 Helper functions used by keyspan_setup_urbs 
 endpoint not needed 
 No ISO 
 control EP filled in when used 
 msg_usa26 callbacks 
 msg_usa28 callbacks 
 msg_usa49 callbacks 
 msg_usa90 callbacks 
 msg_usa67 callbacks 
	 Generic setup urbs function that uses
 Setup values for the various callback routines 
	 Allocate and set up urbs for each one that is in use,
 usa19 function doesn't require prescaler 
 baud rate times 16 (actual rate used internally) 
 divisor 
 inverse of divisor (programmed into 8051) 
 prevent divide by zero...  
	 Any "standard" rate over 57k6 is marginal on the USA-19
 calculate the divisor and the counter (its inverse) 
 return the counter values if non-null 
 usa19hs function doesn't require prescaler 
 baud rate times 16 (actual rate used internally) 
 divisor 
 prevent divide by zero...  
 calculate the divisor 
 return the counter values if non-null 
 baud rate times 16 (actual rate used internally) 
 clock with 138 prescaler 
 divisor using 138 prescaler 
 resulting baud rate using 138 prescaler 
 error using 138 prescaler 
 prevent divide by zero 
	 Calculate prescaler by trying them all and looking
 start with largest possible difference 
 0 is an invalid prescaler, used as a flag 
 return the divisor and prescaler if non-null 
  dev_dbg(&port->dev, "%s - %d %d\n", __func__, prescaler, div); 
 USA-28 supports different maximum baud rates on each port 
 baud rate times 16 (actual rate used internally) 
 divisor 
 inverse of divisor (programmed into 8051) 
 prevent divide by zero 
 calculate the divisor and the counter (its inverse) 
	 check for out of range, based on portnum,
		 return the counter values if not NULL
 Make sure we have an urb then send the message 
	 Save reset port val for resend.
  dev_dbg(&port->dev, "%s - already writing\n", __func__); 
 Only set baud rate if it's changed 
 Values for 9600 baud 
 note USA_PARITY_NONE == 0 
 Opening port 
 Closing port 
 Sending intermediate configs 
 Do handshaking outputs 
 send the data out the device on control endpoint 
 only do something if we have a bulk out endpoint 
	 Save reset port val for resend.
 Values for 9600 baud 
 If parity is enabled, we must calculate it ourselves. 
 XXX for now 
 Do handshaking outputs, DTR is inverted relative to RTS 
	msg.returnStatus = 1;
 Opening port 
 Closing port 
 Sending intermediate configs 
 send the data out the device on control endpoint 
 Work out which port within the device is being setup 
 Make sure we have an urb then send the message 
	 Save reset port val for resend.
  dev_dbg(&port->dev, "%s - already writing\n", __func__); 
 Only set baud rate if it's changed 
 Values for 9600 baud 
 msg.setPrescaler = 0xff; 
 note USA_PARITY_NONE == 0 
 Opening port 
 Closing port 
 Sending intermediate configs 
 Do handshaking outputs 
	 if the device is a 49wg, we send control message on usb
 49wg control message 
 send the data out the device on control endpoint 
 only do something if we have a bulk out endpoint 
	 Save reset port val for resend.
 Only set baud rate if it's changed 
 modes must always be correctly specified 
 note USA_PARITY_NONE == 0 
 Opening port 
 Closing port 
 Sending intermediate configs 
 Do handshaking outputs 
 send the data out the device on control endpoint 
 Work out which port within the device is being setup 
 Make sure we have an urb then send the message 
	 Save reset port val for resend.
  dev_dbg(&port->dev, "%s - already writing\n", __func__); 
 Only set baud rate if it's changed 
 Values for 9600 baud 
 note USA_PARITY_NONE == 0 
 Opening port 
 Closing port 
 Sending intermediate configs 
 Do handshaking outputs 
 send the data out the device on control endpoint 
 Gets called by the "real" driver (ie once firmware is loaded
 Setup private data for serial driver 
 Make sure to unlink the URBs submitted in attach. 
 Setup values for the various callback routines 
 Do indat endpoints first, once for each flip 
 outdat endpoints also have flip 
 inack endpoint 
 outcont endpoint 
 Structs for the devices, pre and post renumeration. 
 SPDX-License-Identifier: GPL-2.0
  USB Empeg empeg-car player driver
 	Copyright (C) 2000, 2001
 	    Gary Brubaker (xavyer@ix.netcom.com)
 	Copyright (C) 1999 - 2001
 	    Greg Kroah-Hartman (greg@kroah.com)
  See Documentationusbusb-serial.rst for more information on using this
  driver
 function prototypes for an empeg-car player 
 Terminating entry 
 continue on with initialization 
	
	  The empeg-car player wants these particular tty settings.
	  You could, for example, change the baud rate, however the
	  player only supports 115200 (currently), so there is really
	  no point in support for changes to the tty settings.
	  (at least for now)
	 
	  The default requirements for this device are:
 disable ignore break 
 disable break causes interrupt 
 disable mark parity errors 
 disable clear high bit of input characters 
 disable translate NL to CR 
 disable ignore CR 
 disable translate CR to NL 
 disable enable XONXOFF flow control 
 disable postprocess output characters 
 disable echo input characters 
 disable echo new line 
 disable erase, kill, werase, and rprnt special characters 
 disable interrupt, quit, and suspend special characters 
 disable non-POSIX special characters 
 no size 
 disable parity bit 
 clear current baud rate 
 character size 8 bits 
 SPDX-License-Identifier: GPL-2.0
  Navman Serial USB driver
  Copyright (C) 2006 Greg Kroah-Hartman <gregkh@suse.de>
  TODO:
 	Add termios method that uses copy_hw but also kills all echo
 	flags as the navman is rx only so cannot echo.
 Talon Technology device 
 Mobile Action i-gotU 
 success 
 this urb is terminated, clean up 
	
	  This device can't write any data, only read from the device
 SPDX-License-Identifier: GPL-2.0
  USB Serial Converter driver
  Copyright (C) 2009 - 2013 Johan Hovold (jhovold@gmail.com)
  Copyright (C) 1999 - 2012 Greg Kroah-Hartman (greg@kroah.com)
  Copyright (C) 2000 Peter Berger (pberger@brimson.com)
  Copyright (C) 2000 Al Borchers (borchers@steinerpoint.com)
  This driver was originally based on the ACM driver by Armin Fuerst (which was
  based on a driver by Brad Keryan)
  See Documentationusbusb-serial.rst for more information on using this
  driver
 should be enough for a while 
 There is no MODULE_DEVICE_TABLE for usbserial.c.  Instead
   the MODULE_DEVICE_TABLE declarations in each serial driver
   cause the "hotplug" program to pull in whatever module is necessary
   via modprobe, and modprobe will load usbserial because the serial
   drivers depend on it.
  Look up the serial port structure.  If it is found and it hasn't been
  disconnected, return with the parent usb_serial structure's disc_mutex held
  and its refcount incremented.  Otherwise return NULL.
 unwind the already allocated minors 
 return the minor range that this device had 
 Now that nothing is using the ports, they can be freed 
  Driver tty interface functions
  serial_install - install tty
  @driver: the driver (USB in our case)
  @tty: the tty being created
  Initialise the termios structure for this tty.  We use the default
  USB serial settings but permit them to be overridden by
  serial->type->init_termios on first open.
  This is the first place a new tty gets used.  Hence this is where we
  acquire references to the usb_serial structure and the driver module,
  where we store a pointer to the port.  All these actions are reversed
  in serial_cleanup().
 allow the driver to update the initial settings 
  serial_port_shutdown - shut down hardware
  @tport: tty port to shut down
  Shut down a USB serial port. Serialized against activate by the
  tport mutex and kept to matching openclose pairs
  of calls by the initialized flag.
  Not called if tty is console.
  serial_cleanup - free resources post closehangup
  @tty: tty to clean up
  Do the resource freeing and refcount dropping for the port.
  Avoid freeing the console.
  Called asynchronously after the last tty kref is dropped.
	 The console is magical.  Do not hang up the console hardware
	  or there will be tears.
  We would be calling tty_wakeup here, but unfortunately some line
  disciplines have an annoying habit of calling tty->write from
  the write wakeup callback (e.g. n_hdlc.c).
 Caller must hold table_lock 
 Check if the usb id matches a known device 
 No carrier control - don't block 
 if this device type has a probe function, call it 
 descriptor matches, let's find the endpoints needed 
 found all that we need 
 create our ports, we need as many as the max endpoints 
	 we don't use num_ports here because some devices have more
		 Keep this for private driver use for the moment but
 set up the endpoint information 
 if this device type has an attach function, call it 
			 quietly accept this device, but don't bind to a
 register all of the individual ports with the driver core 
 sibling interface is cleaning up 
 must set a flag, to signal subdrivers 
 let the last holder of this object cause it to be cleaned up 
 suspend when called for first sibling interface 
	
	  serial->type->suspend() MUST return 0 in system sleep context,
	  otherwise, the resume callback has to recover device from
	  previous suspend failure.
 resume when called for last sibling interface 
 resume when called for last sibling interface 
 Initialize our global data 
 register the generic driver, if we should 
 Prevent individual ports from being unbound. 
 Add this device to our list of devices 
  usb_serial_register_drivers - register drivers for a usb-serial module
  @serial_drivers: NULL-terminated array of pointers to drivers to be registered
  @name: name of the usb_driver for this set of @serial_drivers
  @id_table: list of all devices this @serial_drivers set binds to
  Registers all the drivers in the @serial_drivers array, and dynamically
  creates a struct usb_driver with the name @name and id_table of @id_table.
	
	  udriver must be registered before any of the serial drivers,
	  because the store_new_id() routine for the serial drivers (in
	  bus.c) probes udriver.
	 
	  Performance hack: We don't want udriver to be probed until
	  the serial drivers are registered, because the probe would
	  simply fail for lack of a matching serial driver.
	  So we leave udriver's id_table set to NULL until we are all set.
	 
	  Suspendresume support is implemented in the usb-serial core,
	  so fill in the PM-related fields in udriver.
 we only set the reset_resume field if the serial_driver has one 
 Now set udriver's id_table and look for matches 
  usb_serial_deregister_drivers - deregister drivers for a usb-serial module
  @serial_drivers: NULL-terminated array of pointers to drivers to be deregistered
  Deregisters all the drivers in the @serial_drivers array and deregisters and
  frees the struct usb_driver that was created by the call to
  usb_serial_register_drivers().
 SPDX-License-Identifier: GPL-2.0+
  Digi AccelePort USB-4 and USB-2 Serial Converters
  Copyright 2000 by Digi International
  Shamelessly based on Brian Warner's keyspan_pda.c and Greg Kroah-Hartman's
  usb-serial driver.
  Peter Berger (pberger@brimson.com)
  Al Borchers (borchers@steinerpoint.com)
 Defines 
 port output buffer length -- must be <= transfer buffer length - 2 
 so we can be sure to send the full buffer in one urb 
 port input buffer length -- must be >= transfer buffer length - 3 
 so we can be sure to hold at least one full buffer from one urb 
 retry timeout while sleeping 
 timeout while waiting for tty output to drain in close 
 this delay is used twice in close, so the total delay could 
 be twice this value 
 AccelePort USB Defines 
 ids 
 USB-2 
 USB-4 
 commands
  "INB": can be used on the in-band endpoint
  "OOB": can be used on the out-of-band endpoint
 INB, OOB 
 INB, OOB 
 INB, OOB 
 INB, OOB 
 INB, OOB 
 INB, OOB 
 INB, OOB 
 INB, OOB 
      OOB 
      OOB 
 INB, OOB 
 INB, OOB 
 INB, OOB 
 INB, OOB 
      OOB 
 INB, OOB 
 INB, OOB 
 INB, OOB 
 INB      
 INB      
 INB      
      OOB 
 baud rates 
 arguments 
 clears xoff condition 
 in band status codes 
 out of band status 
 input signals 
 Structures 
 out-of-band port 
 index of out-of-band port 
 wait queue for close 
 Local Function Declarations 
 Terminating entry 
 Terminating entry 
 Terminating entry 
 device info needed for the Digi serial converter 
 Functions 
   Cond Wait Interruptible Timeout Irqrestore
   Do spin_unlock_irqrestore and interruptible_sleep_on_timeout
   so that wake ups are not lost if they occur between the unlock
   and the sleep.  In other words, spin_unlock_irqrestore and
   interruptible_sleep_on_timeout are "atomic" with respect to
   wake ups.  This is used to implement condition variables.
   interruptible_sleep_on_timeout is deprecated and has been replaced
   with the equivalent code.
   Digi Write OOB Command
   Write commands on the out of band port.  Commands are 4
   bytes each, multiple commands can be sent at once, and
   no command will be split across USB packets.  Returns 0
   if successful, -EINTR if interrupted while sleeping and
   the interruptible flag is true, or a negative error
   returned by usb_submit_urb.
 len must be a multiple of 4, so commands are not split 
   Digi Write In Band Command
   Write commands on the given port.  Commands are 4
   bytes each, multiple commands can be sent at once, and
   no command will be split across USB packets.  If timeout
   is non-zero, write in band command will return after
   waiting unsuccessfully for the URB status to clear for
   timeout ticks.  Returns 0 if successful, or a negative
   error returned by digi_write.
 len must be a multiple of 4 and small enough to 
 guarantee the write will send buffered data first, 
 so commands are in order with data and not split 
 write any buffered data first 
   Digi Set Modem Signals
   Sets or clears DTR and RTS on the port, according to the
   modem_signals argument.  Use TIOCM_DTR and TIOCM_RTS flags
   for the modem_signals argument.  Returns 0 if successful,
   -EINTR if interrupted while sleeping, or a non-zero error
   returned by usb_submit_urb.
   Digi Transmit Idle
   Digi transmit idle waits, up to timeout ticks, for the transmitter
   to go idle.  It returns 0 if successful or a negative error.
   There are race conditions here if more than one process is calling
   digi_transmit_idle on the same port at the same time.  However, this
   is only called from close, and only one process can be in close on a
   port at a time, so its ok.
 stop receiving characters by not resubmitting the read urb 
 restart read chain 
 turn throttle off 
 set baud rate 
 reassert DTR and (maybe) RTS on transition from B0 
 don't set RTS if using hardware flow control 
 and throttling input 
 drop DTR and RTS on transition to B0 
 set parity 
 set word size 
 set stop bits 
 set input flow control 
 On USB-4 it is necessary to assert RTS prior 
 to selecting RTS input flow control.  
 set output flow control 
 set receive enabledisable 
 length 
 pad 
 copy user data (which can sleep) before getting spin lock 
 be sure only one write proceeds at a time 
 there are races on the port private buffer 
 wait for urb status clear to submit another urb 
 buffer data if count is 1 (probably put_char) if possible 
 allow space for any buffered data and for new data, up to 
 transfer buffer size - 2 (for command and length bytes) 
 copy in buffered data first 
 copy in new data 
 return length of new data written, or error 
 port and serial sanity check 
 handle oob callback 
 try to send any buffered data on this port 
 Adjust DTR and RTS 
 be sure the device is started up 
 read modem signals automatically whenever they change 
 flush fifos 
 set termios settings 
 if disconnected, just clear flags 
 FIXME: Transmit idle belongs in the wait_unti_sent path 
 disable input flow control 
 disable output flow control 
 disable reading modem signals automatically 
 disable receive 
 flush fifos 
 wait for final commands on oob port to complete 
 shutdown any outstanding bulk writes 
   Digi Startup Device
   Starts reads on all ports.  Must be called AFTER startup, with
   urbs initialized.  Returns 0 if successful, non-zero error otherwise.
 be sure this happens exactly once 
 start reading from each bulk in endpoint for the device 
 set USB_DISABLE_SPD flag for write bulk urbs 
 stop reads and writes on all ports 
 port sanity check, do not resubmit if port is not valid 
 do not resubmit urb if it has any status error 
 handle oob or inb callback, do not resubmit if error 
 continue read 
   Digi Read INB Callback
   Digi Read INB Callback handles reads on the in band ports, sending
   the data on to the tty subsystem.  When called we know port and
   port->private are not NULL and port->serial has been validated.
   It returns 0 if successful, 1 if successful but the port is
   throttled, and -1 if the sanity checks failed.
 shortmultiple packet check 
 check for throttle; if set, do not resubmit read urb 
 indicate the read chain needs to be restarted on unthrottle 
 receive data 
 get flag from port_status 
 overrun is special, not associated with a char 
 break takes precedence over parity, 
 which takes precedence over framing errors 
 data length is len-1 (one byte of len is port_status) 
   Digi Read OOB Callback
   Digi Read OOB Callback handles reads on the out of band port.
   When called we know port and port->private are not NULL and
   the port->serial is valid.  It returns 0 if successful, and
   -1 if the sanity checks failed.
 handle each oob command 
 convert from digi flags to termiox flags 
 port must be open to use tty struct 
 SPDX-License-Identifier: GPL-2.0
  USB Serial Converter Generic functions
  Copyright (C) 2010 - 2013 Johan Hovold (jhovold@gmail.com)
  Copyright (C) 1999 - 2002 Greg Kroah-Hartman (greg@kroah.com)
 Initially all zeroes. 
  usb_serial_generic_write_start - start writing buffered data
  @port: usb-serial port
  @mem_flags: flags to use for memory allocations
  Serialised using USB_SERIAL_WRITE_BUSY flag.
  Return: Zero on success or if busy, otherwise a negative errno value.
 try sending off another urb 
  usb_serial_generic_write - generic write function
  @tty: tty for the port
  @port: usb-serial port
  @buf: data to write
  @count: number of bytes to write
  Return: The number of characters buffered, which may be anything from
  zero to @count, or a negative errno value.
 B0 
	
	  Use a poll-period of roughly the time it takes to send one
	  character or at least one jiffy.
	
	  The per character mucking around with sysrq path it too slow for
	  stuff like 3G modems, so shortcircuit it in the 99.9999999% of
	  cases where the USB serial is not a console anyway.
	
	  Make sure URB processing is done before marking as free to avoid
	  racing with unthrottle() on another CPU. Matches the barriers
	  implied by the test_and_clear_bit() in
	  usb_serial_generic_submit_read_urb().
	
	  Make sure URB is marked as free before checking the throttled flag
	  to avoid racing with unthrottle() on another CPU. Matches the
	  smp_mb__after_atomic() in unthrottle().
	
	  Matches the smp_mb__after_atomic() in
	  usb_serial_generic_read_bulk_callback().
	
	  Use tty-port initialised flag to detect all hangups including the
	  one generated at USB-device disconnect.
 atomic copy
 atomic copy 
 atomic copy 
  usb_serial_handle_dcd_change - handle a change of carrier detect state
  @port: usb-serial port
  @tty: tty for the port
  @status: new carrier detect status, nonzero if active
 SPDX-License-Identifier: GPL-2.0
  USB Serial "Simple" driver
  Copyright (C) 2001-2006,2008,2013 Greg Kroah-Hartman <greg@kroah.com>
  Copyright (C) 2005 Arthur Huillet (ahuillet@users.sf.net)
  Copyright (C) 2005 Thomas Hergenhahn <thomas.hergenhahn@suse.de>
  Copyright (C) 2009 Outpost Embedded, LLC
  Copyright (C) 2010 Zilogic Systems <code@zilogic.com>
  Copyright (C) 2013 Wei Shuai <cpuwolf@gmail.com>
  Copyright (C) 2013 Linux Foundation
 Medtronic CareLink USB driver 
 MMT-7305WW 
 ZIO Motherboard USB driver 
 Funsoft Serial USB driver 
 Infineon Flashloader driver 
 Google Serial USB SubClass 
 Libtransistor USB console 
 ViVOpay USB Serial Driver 
 ViVOpay 8800 
 Motorola USB Phone driver 
 unknown Motorola phone 	\
 unknown Motorola phone 	\
 Motorola KRZR K1m 		\
 Motorola VE240 phone 	\
 Motorola V950 phone 
 Motorola Tetra driver 
 Motorola Solutions TETRA PEI  \
 MTP6550  \
 MTP3xxx  \
 MTP85xx  \
 TPG2200 
 Novatel Wireless GPS driver 
 NovAtel FlexPack GPS 
 HP4x (4849) Generic Serial driver 
 Suunto ANT+ USB Driver 
 Dynastream ANT USB-m Stick 
 Siemens USBMPI adapter 
 All of the above structures mushed into two lists 
 SPDX-License-Identifier: GPL-2.0
  USB Driver for Sierra Wireless
  Copyright (C) 2006, 2007, 2008  Kevin Lloyd <klloyd@sierrawireless.com>,
  Copyright (C) 2008, 2009  Elina Pasheva, Matthew Safar, Rory Filer
			<linux@sierrawireless.com>
  IMPORTANT DISCLAIMER: This driver is not commercially supported by
  Sierra Wireless. Use at your own risk.
  Portions based on the option driver by Matthias Urlichs <smurf@smurf.noris.de>
  Whom based his on the Keyspan driver by Hugh Blemings <hugh@blemings.org>
 Uncomment to log function calls 
 #define DEBUG 
 MAX_TRANSFER is chosen so that the VM is not stressed by
   allocations > PAGE_SIZE and the number of packets in a page
 array of interface numbers 
 number of elements in array 
 __u8 request      
 __u8 request type 
 __u16 value       
 __u16 index       
 void data        
 __u16 size 	     
 int timeout 	     
 __u8 request      
 __u8 request type 
 __u16 value       
 __u16 index       
 void data        
 __u16 size 	     
 int timeout       
 Dummy interface present on some SKUs should be ignored 
	
	  If this interface supports more than 1 alternate
	  select the 2nd one
 We know the alternate setting is 1 for the MC8785 
 interfaces with higher memory requirements 
 'ignorelist' of interfaces not served by this driver 
 AirprimeSierra PC 5220 
 HP ev2200 a.k.a MC5720 
 HP ev2210 a.k.a MC5725 
 HP hs2300 a.k.a MC8775 
 Sierra Wireless EM5625 
 Sierra Wireless MC5720 
 Sierra Wireless MC5720 
 Sierra Wireless MC5725 
 Sierra Wireless MC5725 
 Sierra Wireless EM5725 
 Sierra Wireless MC5727 
 Sierra Wireless MC5727 
 Sierra Wireless AirCard 595 
 Sierra Wireless AirCard 597E 
 Sierra Wireless AirCard 580 
 Sierra Wireless USB Dongle 595U 
 Sierra Wireless USB Dongle 250U 
 Sierra Wireless C597 
 Sierra Wireless T598 
 Sierra Wireless T11 
 Sierra Wireless AC402 
 Sierra Wireless MC5728 
 Sierra Wireless Device 
 Sierra Wireless MC8755 
 Sierra Wireless MC8765 
 Sierra Wireless MC8755 
 Sierra Wireless MC8765 
 Sierra Wireless MC8755 
 Sierra Wireless MC8765 
 Sierra Wireless MC8775 & AC 875U 
 Sierra Wireless MC8775 
 Sierra Wireless MC8775 
 Sierra Wireless MC8775 
 Sierra Wireless AirCard 875 
 Sierra Wireless AirCard 875U 
 Sierra Wireless AirCard 875E 
 Sierra Wireless MC8780 
 Sierra Wireless MC8781 
 Sierra Wireless MC8780 
 Sierra Wireless MC8781 
 Sierra Wireless MC8780 
 Sierra Wireless MC8781 
 Sierra Wireless MC8785 
 Sierra Wireless MC8785 Composite 
 Sierra Wireless MC8790, MC8791, MC8792 Composite 
 Sierra Wireless MC8791 Composite 
 Sierra Wireless MC8790, MC8791, MC8792 
 Sierra Wireless AirCard 880 
 Sierra Wireless AirCard 881 
 Sierra Wireless AirCard 880 E 
 Sierra Wireless AirCard 881 E 
 Sierra Wireless AirCard 880 U 
 Sierra Wireless AirCard 881 U 
 Sierra Wireless AirCard 885 E 
 Sierra Wireless AirCard 885 E 
 Sierra Wireless C885 
 Sierra Wireless C888, Air Card 501, USB 303, USB 304 
 Sierra Wireless C22C33 
 Sierra Wireless HSPA Non-Composite Device 
 Sierra Wireless Device 
 Sierra Wireless Direct IP modems 
 Sierra Wireless AR8550 
 AT&T Direct IP LTE modems 
 AirprimeSierra Wireless Direct IP modems 
 lock the structure 
 number of out urbs in flight 
 Input endpoints and buffers for this port 
 Settings for the port 
 Handshaking pins (outputs) 
 Handshaking pins (inputs) 
 If composite device then properly report interface 
		 Control message is sent only to interfaces with
		  interrupt_in endpoints
 send control message 
 Otherwise the need to do non-composite mapping 
 free up the transfer buffer, as usb_free_urb() does not do this 
 Write 
 verify that we actually have some data to write 
 Handle the need to send a zero length packet 
 send it down the pipe 
	 we are done with this urb, so let the host driver
 Resubmit urb so we continue receiving 
 Resubmit urb so we continue receiving IRQ data 
	 try to give a good number back based on if we have any free urbs at
 NOTE: This overcounts somewhat. 
 at least one rx urb submitted 
 Fill URB using supplied data 
	
	  Need to take susp_lock to make sure port is not already being
	  resumed, but no need to hold it due to initialized
 clear halt condition 
 Set Device mode to D0 
 Check NMEA and set 
 Assume low memory requirements 
 Determine actual memory requirements 
 Get interface number for composite device 
		 This is really the usb-serial port number of the interface
		  rather than the interface number.
 Stop readingwriting urbs 
 Caller must hold susp_lock. 
 SPDX-License-Identifier: GPL-2.0+
  USB Compaq iPAQ driver
 	Copyright (C) 2001 - 2002
 	    Ganesh Varadarajan <ganesh@veritas.com>
 Function prototypes for an ipaq 
 Socket USB Sync 
 HP USB Sync 
 HP USB Sync 1611 
 HP USB Sync 1612 
 HP USB Sync 1620 
 HP USB Sync 1621 
 HP USB Sync 1622 
 HP USB Sync 1630 
 HP USB Sync 1631 
 HP USB Sync 1632 
 HP USB Sync 1640 
 HP USB Sync 1641 
 HP USB Sync 1642 
 HP USB Sync 1650 
 HP USB Sync 1651 
 HP USB Sync 1652 
 NEC USB Sync 
 NEC USB Sync 
 NEC USB Sync 
 NEC USB Sync 
 NEC USB Sync 
 LGE USB Sync 
 Microsoft USB Sync 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2002 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Pocket PC 2003 
 Windows Powered Smartphone 2002 
 Windows Powered Smartphone 2002 
 Windows Powered Smartphone 2002 
 Windows Powered Smartphone 2002 
 Windows Powered Smartphone 2002 
 Windows Powered Smartphone 2002 
 Windows Powered Smartphone 2002 
 Windows Powered Smartphone 2003 
 Windows Powered Smartphone 2003 
 Windows Powered Smartphone 2003 
 Windows Powered Smartphone 2003 
 Windows Powered Smartphone 2003 
 Windows Powered Smartphone 2003 
 Windows Powered Smartphone 2003 
 Windows Powered Smartphone 2003 
 Windows Powered Smartphone 2003 
 Windows Powered Smartphone 2003 
 Windows Powered Smartphone 2003 
 Windows Powered Smartphone 2003 
 Windows Powered Smartphone 2003 
 Windows Powered Smartphone 2003 
 Windows Powered Smartphone 2003 
 Windows Powered Smartphone 2003 
 Windows Powered Smartphone 2003 
 Windows Powered Smartphone 2003 
 Windows Powered Smartphone 2003 
 Windows Powered Smartphone 2003 
 Compaq iPAQ USB Sync 
 Compaq iPAQ USB Sync 
 Hitachi USB Sync 
 USB Sync 0301 
 USB Sync 0302 
 USB Sync 0303 
 GPS Pocket PC USB Sync 
 MyGuide 7000 XL USB Sync 
 FUJITSU USB Sync 
 FUJITSU USB Sync 
 Panasonic USB Sync 
 SHARP WS003SH USB Modem 
 SHARP WS004SH USB Modem 
 SHARP WS007SH USB Modem 
 SHARP S01SH USB Modem 
 SHARP WS011SH USB Modem 
 Samsung NEXiO USB Sync 
 Samsung NEXiO USB Sync 
 Samsung NEXiO USB Sync 
 Samsung NEXiO USB Sync 
 Samsung NEXiO USB Sync 
 Samsung MITs USB Sync 
 Samsung MITs USB Sync 
 Samsung MITs USB Sync 
 Samsung MITs USB Sync 
 Samsung MITs USB Sync 
 Samsung MITs USB Sync 
 Samsung MITs USB Sync 
 Samsung MITs USB Sync 
 Samsung MITs USB Sync 
 JVC USB Sync 
 JVC USB Sync 
 c10 Series 
 c20 Series 
 Acer n10 Handheld USB Sync 
 Acer n20 Handheld USB Sync 
 Acer n30 Handheld USB Sync 
 HHP PDT 
 ViewSonic Color Pocket PC V35 
 ViewSonic Color Pocket PC V36 
 ViewSonic Color Pocket PC V37 
 ViewSonic Color Pocket PC V38 
 ViewSonic Pocket PC 
 ViewSonic Communicator Pocket PC 
 ViewSonic Smartphone 
 ViewSonic Pocket PC V30 
 Symbol USB Sync 
 Symbol USB Sync 0x2001 
 Symbol USB Sync 0x2002 
 Symbol USB Sync 0x2003 
 Symbol USB Sync 0x2004 
 Symbol USB Sync 0x2005 
 Symbol USB Sync 0x2006 
 Symbol USB Sync 0x2007 
 Symbol USB Sync 0x2008 
 Symbol USB Sync 0x2009 
 Symbol USB Sync 0x200A 
 Intermec Mobile Computer 
 CASIO USB Sync 2001 
 CASIO USB Sync 2002 
 CASIO USB Sync 2003 
 TOSHIBA USB Sync 0700 
 TOSHIBA Pocket PC e310 
 TOSHIBA Pocket PC e740 
 TOSHIBA Pocket PC e330 Series 
 TOSHIBA Pocket PC e350 Series 
 TOSHIBA Pocket PC e750 Series 
 TOSHIBA Pocket PC e400 Series 
 TOSHIBA Pocket PC e800 Series 
 Linkup Systems USB Sync 
 BCOM USB Sync 0065 
 BCOM USB Sync 0066 
 BCOM USB Sync 0067 
 Portatec USB Sync 
 Trimble GeoExplorer 
 TDS Data Collector 
 ASUS USB Sync 
 ASUS USB Sync 
 ASUS USB Sync 
 ASUS USB Sync 
 ASUS USB Sync 
 ASUS USB Sync 
 HTC USB Sync 
 HTC USB Modem 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 PocketPC USB Sync 
 HTC SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 SmartPhone USB Sync 
 "High Tech Computer Corp" 
 Fujitsu Siemens Computers USB Sync 
 Motorola iDEN Smartphone 
 Cesscom Luxian Series 
 Motorola PowerPad Pocket PC Device 
 Freedom Scientific USB Sync 
 Cyberbank USB Sync 
 Wistron USB Sync 
 Wistron USB Sync 
 Wistron USB Sync 
 Wistron USB Sync 
 E-TEN USB Sync 
 E-TEN P3XX Pocket PC 
 E-TEN P5XX Pocket PC 
 E-TEN P6XX Pocket PC 
 E-TEN P7XX Pocket PC 
 Psion Teklogix Sync 753x 
 Psion Teklogix Sync netBookPro 
 Psion Teklogix Sync 7525 
 VES USB Sync 
 Rugged Pocket PC 2003 
 Rugged Pocket PC 2003 
 USB Sync 03 
 USB Sync 03 
 Askey USB Sync 
 Motorola MPx200 Smartphone 
 Motorola MPc GSM 
 Motorola MPx220 Smartphone 
 Motorola MPc CDMA 
 Motorola MPx100 Smartphone 
 Mio DigiWalker PPC StrongARM 
 Mio DigiWalker 338 
 Mio DigiWalker 338 
 Mio DigiWalker USB Sync 
 MiTAC USB Sync 528 
 Mio DigiWalker SmartPhone USB Sync 
 MiTAC USB Sync 
 Generic PPC StrongARM 
 Generic PPC USB Sync 
 Itautec USB Sync 
 Generic SmartPhone USB Sync 
 Itautec USB Sync 
 YAKUMO USB Sync 
 Vobis USB Sync 
 MEDION Winodws Moble USB Sync 
 Legend USB Sync 
 Lenovo USB Sync 
 Mobile Media Technology USB Sync 
 Mobile Media Technology USB Sync 
 Mobile Media Technology USB Sync 
 Mobile Media Technology USB Sync 
 Dell Axim USB Sync 
 Dell Axim USB Sync 
 Dell Axim USB Sync 
 Dell Axim USB Sync 
 Dell Axim USB Sync 
 Dell Axim USB Sync 
 Dell Axim USB Sync 
 Dell Axim USB Sync 
 Dell Axim USB Sync 
 Smartphone 
 SAGEM Wireless Assistant 
 Terminating entry 
 All of the device info needed for the Compaq iPAQ 
	
	  Send out control message observed in win98 sniffs. Not sure what
	  it does, but from empirical observations, it seems that the device
	  will start the chat sequence once one of these messages gets
	  through. Since this has a reasonably high failure rate, we retry
	  several times.
	
	  Some of the devices in ipaq_id_table[] are composite, and we
	  shouldn't bind to all the interfaces. This test will rule out
	  some obviously invalid possibilities.
	
	  A few devices have four endpoints, seemingly Yakuma devices, and
	  we need the second pair.
	
	  Other devices have 3 endpoints, but we only use the first bulk in
	  and out endpoints.
		
		  FIXME: HP iPaq rx3715, possibly others, have 1 config that
		  is labeled as 2
 SPDX-License-Identifier: GPL-2.0+
  USB Cypress M8 driver
  	Copyright (C) 2004
  	    Lonnie Mendez (dignome@gmail.com)
 	Copyright (C) 2003,2004
 	    Neil Whelchel (koyama@firstlight.net)
  See Documentationusbusb-serial.rst for more information on using this
  driver
  See http:geocities.comi0xox0i for information on this driver and the
  earthmate usb device.
 Thanks to Neil Whelchel for writing the first cypress m8 implementation
 Thanks to cypress for providing references for the hid reports. 
 Thanks to Jiang Zhang for providing links and for general help. 
 Code originates and was built up from ftdi_sio, belkin, pl2303 and others.
 write buffer size defines 
 Terminating entry 
 Terminating entry 
 Terminating entry 
 Terminating entry 
 b0:status, b1:payload count 
 b0[7:3]:status, b0[2:0]:payload count 
 private lock 
 identifier of device, for quirksetc 
 used for statistics 
 used for statistics 
 used for statistics 
 always set this to 1 before issuing a command 
 write fifo 
 write urb in use indicator 
 interval to use for write urb 
 interval to use for read urb 
 true if communication is (still) ok 
 holds dtr  rts value 
 received from last read - info on dsr,cts,cd,ri,etc 
 stores the current configuration byte 
 throttling - used from whiteheatftdi_sio 
 format to use for packet send  receive 
 If true, the CYPRESS_GET_CONFIG is unsafe 
	int baud_rate;			    stores current baud rate in
 used for TIOCMIWAIT 
 function prototypes for the Cypress USB to serial device 
  Cypress serial helper functions
 FRWD Dongle hidcom needs to skip reset and speed checks 
 FRWD Dongle uses 115200 bps 
	
	  The general purpose firmware for the Cypress M8 allows for
	  a maximum speed of 57600bps (I have no idea whether DeLorme
	  chose to use the general purpose firmware or not), if you
	  need to modify this speed setting for your own project
	  please add your own chiptype and modify the code likewise.
	  The Cypress HID->COM device will work successfully up to
	  115200bps (but the actual throughput is around 3kBps).
		
		  Mike Isely <isely@pobox.com> 2-Feb-2008: The
		  Cypress app note that describes this mechanism
		  states the the low-speed part can't handle more
		  than 800 bytessec, in which case 4800 baud is the
		  safest speed for a part like that.
			 300 and 600 baud rates are supported under
			  the generic firmware, but are not used with
 This function can either set or retrieve the current serial line settings 
 0 means 'Hang up' so doesn't change the true bit rate 
 fill the feature_buffer with new configuration 
 assign data bits in 2 bit space ( max 3 ) 
 1 bit gap 
 assign stop bits in 1 bit space 
 assign parity flag in 1 bit space 
 assign parity type in 1 bit space 
 1 bit gap 
 assign reset at end of byte, 1 bit space 
 If we asked for a speed change encode it 
			 Not implemented for this device,
			   and if we try to do it we're likely
			 store the config in one byte, and later
 cypress_serial_control 
  Cypress serial driver functions
	 Skip reset for FRWD device. It is a workaound:
	   device hangs if it receives SET_CONFIGURE in Configured
	 Default packet format setting is determined by packet size.
	   Anything with a size larger then 9 must have a separate
	   count field since the 3 bit count field is otherwise too
	   small.  Otherwise we can use the slightly more compact
	   format.  This is in accordance with the cypress_m8 serial
	 All Earthmate devices use the separated-count packet
		 The old original USB Earthmate seemed able to
		   handle GET_CONFIG requests; everything they've
		   produced since that time crashes if this command is
 clear halts before open 
 reset readwrite statistics 
 Set termios 
 setup the port and start reading from the device 
 cypress_open 
 drop dtr and rts 
 cypress_close 
	 line control commands, which need to be executed immediately,
	   are not put into the buffer for obvious reasons.
 cypress_write 
 clear buffer 
 this is for the CY7C64013... 
 this is for the CY7C63743... 
 do not count the line control and size bytes 
 cypress_send 
 returns how much space is available in the soft buffer 
 Unsupported features need clearing 
 set number of data bits, parity, stop bits 
 when parity is disabled the parity type bit is ignored 
 1 means 2 stop bits, 0 means 1 stop bit 
 1 means odd parity, 0 means even parity 
 drop dtr and rts 
	 we perform a CYPRESS_GET_CONFIG so that the current settings are
	  filled into the private structure this should confirm that all is
	 Here we can define custom tty settings for devices; the main tty
 define custom termios settings for NMEA protocol 
 input modes - 
 disable ignore break 
 disable break causes interrupt 
 disable mark parity errors 
 disable clear high bit of input char 
 disable translate NL to CR 
 disable ignore CR 
 disable translate CR to NL 
 disable enable XONXOFF flow control 
 output modes 
 disable postprocess output char 
 line discipline modes 
 disable echo input characters 
 disable echo new line 
			| ICANON       disable erase, kill, werase, and rprnt
			| ISIG         disable interrupt, quit, and suspend
 disable non-POSIX special characters 
 CT_CYPHIDCOM: Application should handle this for device 
 if necessary, set lines 
 cypress_set_termios 
 returns amount of data still left in soft buffer 
 success 
 precursor to disconnect so just go away 
 Can't call usb_clear_halt while in_interrupt 
 something ugly is going on... 
 This is for the CY7C64013... 
 This is for the CY7C63743... 
 check to see if status has changed 
	 hangup, as defined in acm.c... this might be a bad place for it
	 There is one error bit... I'm assuming it is a parity error
	  indicator as the generic firmware will set this bit to 1 if a
	  parity error occurs.
 process read if there is data other than line status 
 control and status byte(s) are also counted 
 Continue trying to always read 
 cypress_read_int_callback 
 success 
 this urb is terminated, clean up 
 Cannot call usb_clear_halt while in_interrupt 
 send any buffered data 
 SPDX-License-Identifier: GPL-2.0
  mos7720.c
    Controls the Moschip 7720 usb to dual port serial converter
  Copyright 2006 Moschip Semiconductor Tech. Ltd.
  Developed by:
  	Vijaya Kumar <vijaykumar.gn@gmail.com>
 	Ajay Kumar <naanuajay@yahoo.com>
 	Gurudeva <ngurudeva@yahoo.com>
  Cleaned up from the original by:
 	Greg Kroah-Hartman <gregkh@suse.de>
  Originally based on driversusbserialio_edgeport.c which is:
 	Copyright (C) 2000 Inside Out Networks, All rights reserved.
 	Copyright (C) 2001-2002 Greg Kroah-Hartman <greg@kroah.com>
 default urb timeout 
 Interrupt Routines Defines	
 URB Count 
 URB Size 
 This structure holds all of the local serial port information 
 last LCR value received 
 last MCR value received 
 last MSR value received 
 loop back to the owner 
 terminating entry 
 initial values for parport regs 
 SLCTIN, nINIT 
 SPP mode 
 moschip calls this 'NIBBLE' mode 
 moschip calls this 'CB-FIFO mode 
 back to containing struct 
 to instance of this struct 
 usb sync call pending 
 usb sync call completed 
 restore deferred writes 
 back to containing struct 
 parallel port regs... 
 updated in int-in callback 
 lock guards against dereferencing NULL ptr in parport ops callbacks 
 CONFIG_USB_SERIAL_MOS7715_PARPORT 
 for clarity in register access fns 
 serial port regs 
 parallel port regs 
 device control regs 
 serial port 2 (7720 only) 
  Return the correct value for the Windex field of the setup packet
  for a control endpoint message.  See the 7715 datasheet.
 MOS7720_THR 
 MOS7720_RHR 
 MOS7720_IER 
 MOS7720_FCR 
 MOS7720_ISR 
 MOS7720_LCR 
 MOS7720_MCR 
 MOS7720_LSR 
 MOS7720_MSR 
 MOS7720_SPR 
 MOS7720_DLL 
 MOS7720_DLM 
 MOS7720_DPR 
 MOS7720_DSR 
 MOS7720_DCR 
 MOS7720_ECR 
 MOS7720_SP1_REG 
 MOS7720_SP2_REG (7720 only) 
 MOS7720_PP_REG (7715 only) 
 MOS7720_SP_CONTROL_REG 
  Return the correct value for the upper byte of the Wvalue field of
  the setup packet for a control endpoint message.
 control reg 
 parallel port reg (7715 only) 
 serial port reg 
  Write data byte to the specified device register.  The data is embedded in
  the value field of the setup packet. serial_portnum is ignored for registers
  not specific to a particular serial port.
  Read data byte from the specified device register.  The data returned by the
  device is embedded in the value field of the setup packet.  serial_portnum is
  ignored for registers that are not specific to a particular serial port.
  This is the common top part of all parallel port callback operations that
  send synchronous messages to the device.  This implements convoluted locking
  that avoids two scenarios: (1) a port operation is called after usbserial
  has called our release function, at which point struct mos7715_parport has
  been destroyed, and (2) the device has been disconnected, but usbserial has
  not called the release function yet because someone has a serial port open.
  The shared release_lock prevents the first, and the mutex and disconnected
  flag maintained by usbserial covers the second.  We also use the msg_pending
  flag to ensure that all synchronous usb message calls have completed before
  our release function can return.
 release fn called, port struct destroyed 
 synch usb call pending 
 ensure writes from restore are submitted before new requests 
 device disconnected 
  This is the common bottom part of all parallel port functions that send
  synchronous messages to the device.
 if device disconnected, game over 
 release called 
 N.B. Parport core code requires that this function not block 
 release called 
 N.B. Parport core code requires that this function not block 
 release called 
  Allocate and initialize parallel port control struct, initialize
  the parallel port hardware device, and register with the parport subsystem.
 allocate and initialize parallel port control struct 
 hijack private pointer 
 cycle parallel port reset bit 
 initialize device registers 
 register with parport core 
 CONFIG_USB_SERIAL_MOS7715_PARPORT 
  mos7720_interrupt_callback
 	this is the callback function for when we have received data on the
 	interrupt endpoint.
 success 
 this urb is terminated, clean up 
	 Moschip get 4 bytes
	  Byte 1 IIR Port 1 (port.number is 0)
	  Byte 2 IIR Port 2 (port.number is 1)
	  Byte 3 --------------
	 the above description is inverted
 No Interrupt Pending in both the ports 
 dev_dbg(dev, "Serial Port 1: Modem status change\n"); 
 dev_dbg(dev, "Serial Port 2: Modem status change\n"); 
  mos7715_interrupt_callback
 	this is the 7715's callback function for when we have received data on
 	the interrupt endpoint.
 success 
 this urb is terminated, clean up 
	 Structure of data from 7715 device:
	  Byte 1: IIR serial Port
	  Byte 2: unused
	  Byte 2: DSR parallel port
 serial port interrupt pending 
 dev_dbg(dev, "Serial Port: Modem status change\n"); 
 update local copy of DSR reg 
  mos7720_bulk_in_callback
 	this is the callback function for when we have received data on the
 	bulk in endpoint.
  mos7720_bulk_out_data_callback
 	this is the callback function for when we have finished sending serial
 	data on the bulk out endpoint.
		
		  The 7715 uses the first bulk inout endpoint pair for the
		  parallel port, and the second for the serial port. We swap
		  the endpoint descriptors here so that the the first and
		  only registered port structure uses the serial-port
		  endpoints.
 Initialising the write urb pool 
	  Initialize MCS7720 -- Write Init values to corresponding Registers
	  
	   Register Index
	   0 : MOS7720_THRMOS7720_RHR
	   1 : MOS7720_IER
	   2 : MOS7720_FCR
	   3 : MOS7720_LCR
	   4 : MOS7720_MCR
	   5 : MOS7720_LSR
	   6 : MOS7720_MSR
	   7 : MOS7720_SPR
	  
	   0x08 : SP12 Control Reg
 initialize our port settings 
 Must set to enable ints! 
 send a open port command 
  mos7720_chars_in_buffer
 	this function is called by the tty driver when it wants to know how many
 	bytes of data we currently have outstanding in the port (data that has
 	been written, but hasn't made it out the port yet)
 Freeing Write URBs 
	 While closing port, shutdown all bulk read, write  
  mos7720_write_room
 	this function is called by the tty driver when it wants to know how many
 	bytes of data we can accept for a specific port.
 FIXME: Locking 
 try to find a free urb in the list 
 fill urb with data and submit  
 send it down the pipe 
 if we are implementing XONXOFF, send the stop character 
 if we are implementing RTSCTS, toggle that line 
 if we are implementing XONXOFF, send the start character 
 if we are implementing RTSCTS, toggle that line 
 FIXME: this function does not work 
	 
	       Init Sequence for higher rates
	
	               Set for higher rates           
 writing baud rate verbatum into uart clock field clearly not right 
	
	               Set DLLDLM
 baud rate information 
 Define table of divisors for moschip 7720 hardware	   
  These assume a 3.6864MHz crystal, the standard 16, and 
 2094.545455 => 230450   => .0217 % over 
 1713.011152 => 230398.5 => .00065% under 
  calc_baud_rate_divisor
 	this function calculates the proper baud rate divisor for the specified
 	baud rate.
	 After trying for all the standard baud rates    
 get the divisor 
 Check for round off 
  send_cmd_write_baud_rate
 	this function sends the proper command to change the baud rate of the
 	specified port.
 Calculate the Divisor 
 Enable access to divisor latch 
 Write the divisor 
 Disable access to divisor latch 
  change_port_settings
 	This routine is called to set the UART on the device to match
       the specified new settings.
 1 stop bit 
 No parity 
 Change the number of bits 
 Change the Parity bit 
 Change the Stop bit 
 Mask for bitschar field 
 Mask for stop bits field 
 Mask for parity field 
 Update the LCR with the correct value 
 Disable Interrupts 
 Send the updated LCR value to the mos7720 
 set up the MCR register and send it to the mos7720 
		 To set hardware flow control to the specified 
 Determine divisor based on baud rate 
 pick a default, any default... 
 Enable Interrupts 
	 FIXME: needs to write actual resulting baud back not just
 Enable Interrupts 
  mos7720_set_termios
 	this function is called by the tty driver when it wants to change the
 	termios structure.
 change the port settings to the new ones specified 
  get_lsr_info - get line status register info
  Purpose: Let user call ioctl() to get info when the UART physically
  	    is emptied.  On bus types like RS485, the transmitter must
  	    release the bus after transmitting. This must be done when
  	    the transmit shift register is empty, not be done when the
  	    transmit holding register is empty.  This functionality
  	    allows an RS485 driver to be written in user space.
 0x002 
 0x004 
 0x020 
 0x040 
 0x080 
 0x100 
 start the interrupt urb 
 LSR For Port 1 
 close the parallel port 
 prevent NULL ptr dereference in port callbacks 
 wait for synchronous usb calls to return 
		
		  If delayed work is currently scheduled, wait for it to
		  complete. This also implies barriers that ensure the
		  below serial clearing is not hoisted above the ->work.
 SPDX-License-Identifier: GPL-2.0
  Renesas Electronics uPD78F0730 USB to serial converter driver
  Copyright (C) 2014,2016 Maksim Salau <maksim.salau@gmail.com>
  Protocol of the adaptor is described in the application note U19660EJ1V0AN00
  μPD78F0730 8-bit Single-Chip Microcontroller
  USB-to-Serial Conversion Software
  <https:www.renesas.comen-eudocDocumentServer026U19660EJ1V0AN00.pdf>
  The adaptor functionality is limited to the following:
  - data bits: 7 or 8
  - stop bits: 1 or 2
  - parity: even, odd or none
  - flow control: none
  - baud rates: 0, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 153600
  - signals: DTR, RTS and BREAK
 V850ESJX3-STICK 
 YRPBRL78G13, YRPBRL78G14 
 Analog Devices EVAL-ADXL362Z-DB 
  Each adaptor is associated with a private structure, that holds the current
  state of control signals (DTR, RTS and BREAK).
 mutex to protect line_signals 
 Op-codes of control commands 
 Data sizes in UPD78F0730_CMD_LINE_CONTROL command 
 Stop-bit modes in UPD78F0730_CMD_LINE_CONTROL command 
 Parity modes in UPD78F0730_CMD_LINE_CONTROL command 
 Flow control modes in UPD78F0730_CMD_LINE_CONTROL command 
 Control signal bits in UPD78F0730_CMD_SET_DTR_RTS command 
 Port modes in UPD78F0730_CMD_OPEN_CLOSE command 
 Error character substitution modes in UPD78F0730_CMD_SET_ERR_CHR command 
  Declaration of command structures
 UPD78F0730_CMD_LINE_CONTROL command 
 UPD78F0730_CMD_SET_DTR_RTS command 
 UPD78F0730_CMD_SET_XON_OFF_CHR command 
 UPD78F0730_CMD_OPEN_CLOSE command 
 UPD78F0730_CMD_SET_ERR_CHR command 
 If the baud rate is not supported, switch to the default one 
 SPDX-License-Identifier: GPL-2.0+
   KOBIL USB Smart Card Terminal Driver
   Copyright (C) 2002  KOBIL Systems GmbH
   Author: Thomas Wahrenbruch
   Contact: linuxusb@kobil.de
   This program is largely derived from work by the linux-usb group
   and associated source files.  Please see the usbserial files for
   individual credits and copyrights.
   Thanks to Greg Kroah-Hartman (greg@kroah.com) for his help and
   patience.
  Supported readers: USB TWIN, KAAN Standard Plus and SecOVID Reader Plus
  (Adapter K), B1 Professional and KAAN Professional (Adapter B)
www.kobil.com"
 Function prototypes 
 Terminating entry 
 buffer for the APDU to send 
 index of the last char in buf 
 index of the next char to send in buf 
 Default to echo off and other sane device settings 
 do NOT translate CR to CR-NL (0x0A -> 0x0A 0x0D) 
 allocate memory for transfer buffer 
 get hardware version 
 get firmware version 
 Setting Baudrate, Parity and Stopbits 
 reset all queues 
 start reading (Adapter B 'cause PNP string) 
 FIXME: Add rtsdtr methods 
 Copy data to buffer 
	 only send complete block. TWIN, KAAN SIM and adapter K
 stop reading (except TWIN and KAAN SIM) 
 max 8 byte in one urb (endpoint size) 
 copy data to transfer buffer 
 start reading (except TWIN and KAAN SIM) 
 FIXME 
 This device doesn't support ioctl calls 
 allocate memory for transfer buffer 
 FIXME: locking ? 
 This device doesn't support ioctl calls 
 This device doesn't support ioctl calls 
 This device doesn't support ioctl calls 
 SPDX-License-Identifier: GPL-2.0
  AIRcable USB Bluetooth Dongle Driver.
  Copyright (C) 2010 Johan Hovold <jhovold@gmail.com>
  Copyright (C) 2006 Manuel Francisco Naranjo (naranjo.manuel@gmail.com)
  The device works as an standard CDC device, it has 2 interfaces, the first
  one is for firmware access and the second is the serial one.
  The protocol is very simply, there are two possibilities reading or writing.
  When writing the first urb must have a Header that starts with 0x20 0x29 the
  next two bytes must say how much data will be sent.
  When reading the process is almost equal except that the header starts with
  0x00 0x20.
  The device simply need some stuff to understand data coming from the usb
  buffer: The First and Second byte is used for a Header, the Third and Fourth
  tells the  device the amount of information the package holds.
  Packages are 60 bytes long Header Stuff.
  When writing to the device the first two bytes of the header are 0x20 0x29
  When reading the bytes are 0x00 0x20, or 0x00 0x10, there is an strange
  situation, when too much data arrives to the device because it sends the data
  but with out the header. I will use a simply hack to override this situation,
  if there is data coming that does not contain any header, then that is data
  that must go directly to the tty, as there is no documentation about if there
  is any other control code, I will simply check for the first
  one.
  I have taken some info from a Greg Kroah-Hartman article:
  http:www.linuxjournal.comarticle6573
  And from Linux Device Driver Kit CD, which is a great work, the authors taken
  the work to recompile lots of information an knowledge in drivers development
  and made it all available inside a cd.
  URL: http:kernel.orgpublinuxkernelpeoplegregkhddk
 Vendor and Product ID 
 Protocol Stuff 
 rx_flags 
 ID table that will be registered with USB core 
 Ignore the first interface, which has no bulk endpoints. 
 SPDX-License-Identifier: GPL-2.0
  Silicon Laboratories CP210x USB to RS232 serial adaptor driver
  Copyright (C) 2005 Craig Shelley (craig@microtron.org.uk)
  Copyright (C) 2010-2021 Johan Hovold (johan@kernel.org)
  Support to set flow control line levels using TIOCMGET and TIOCMSET
  thanks to Karl Hiramoto karl@hiramoto.org. RTSCTS hardware flow
  control thanks to Munir Nassar nassarmu@real-time.com
  Function Prototypes
 Renesas RX610 RX-Stick 
 AKTAKOM ACE-1001 cable 
 Pirelli Broadband S.p.A, DP-L10 SIPGSM Mobile 
 Pirelli Broadband S.p.A, DP-L10 SIPGSM Mobile 
 CipherLab USB CCD Barcode Scanner 1000 
 NetGear Managed Switch M4100 series, M5300 series, M7100 series 
 Gemalto Prox-PUCU contactless smartcard reader 
 Digianswer AS , ZigBee802.15.4 MAC Device 
 Siemens RUGGEDCOM USB Serial Console 
 Teraoka AD2000 
 Ingenico 3070 
 MEI (TM) Cashflow-SC BillVoucher Acceptor 
 MEI series 2000 Combo Acceptor 
 Dynastream ANT development board 
 Dynastream ANT2USB 
 Dynastream ANT development board 
 OWL Wireless Electricity Monitor CM-160 
 Knock-off DCU-11 cable 
 Siemens MC60 Cable 
 Nokia CA-42 USB 
 Vstabi 
 Arkham Technology DS101 Bus Monitor 
 Arkham Technology DS101 Adapter 
 SPORTident BSM7-D-USB main station 
 Pololu USB-serial converter 
 Cygnal Debug Adapter 
 Software Bisque Paramount ME build-in converter 
 Enfora EDG1228 
 Enfora GSM2228 
 Lorenz Messtechnik devices 
 Argussoft In-System Programmer 
 IMS USB to RS422 Converter Cable 
 Crumb128 board 
 Cygnal Integrated Products, Inc., Optris infrared thermometer 
 Degree Controls Inc 
 Tracient RFID 
 Suunto sports instrument 
 Arygon NFCMifare Reader 
 Burnside Telecom Deskmobile 
 Tams Master Easy Control 
 West Mountain Radio RIGblaster P&P 
 West Mountain Radio RIGtalk 
 West Mountain Radio RIGblaster Advantage 
 B&G H3000 link cable 
 Helicomm IP-Link 1220-DVM 
 Timewave HamLinkUSB 
 CESINEL MEDCAL N Power Quality Monitor 
 CESINEL MEDCAL NT Power Quality Monitor 
 CESINEL MEDCAL S Power Quality Monitor 
 AVIT Research USB to TTL 
 MJS USB Toslink Switcher 
 ThinkOptics WavIt 
 Multiplex RC Interface 
 MSD Dash Hawk 
 INSYS USB Modem 
 Lipowsky Industrie Elektronik GmbH, Baby-JTAG 
 IAI Corp. RCB-CV-USB USB to RS485 Adaptor 
 Lipowsky Industrie Elektronik GmbH, Baby-LIN 
 Aerocomm Radio 
 Zephyr Bioharness 
 C1007 HF band RFID controller 
 Lipowsky Industrie Elektronik GmbH, HARP-1 
 Modem EDGE(GSM) Comander 2 
 Cygnal Integrated Products, Inc., Fasttrax GPS demonstration module 
 Nanotec Plug & Drive 
 Telegesis ETRX2USB 
 CESINEL FALCO 6105 AC Power Supply 
 CESINEL MEDCAL EFD Earth Fault Detector 
 CESINEL MEDCAL ST Network Analyzer 
 Starizona MicroTouch 
 Procyon AVS 
 Siemens MC35PU GPRS Modem 
 Cygnal Integrated Products, Inc. 
 Amber Wireless AMB2560 
 Mark-10 Digital Force Gauge 
 DekTec DTA Plus VHFUHF BoosterAttenuator 
 Kyocera GPS Module 
 IRZ Automation Teleport SG-10 GSMGPRS Modem 
 BEI USB Sensor Interface (VCP) 
 Juniper Networks BX Series System Console 
 Balluff RFID 
 Starizona Hyperion 
 CESINEL MEDCAL PT Network Analyzer 
 LifeScan OneTouch Verio IQ 
 CESINEL ReCon T Energy Logger 
 AC-Services IBUS-IF 
 AC-Services CIS-IBUS 
 Virtenio Preon32 
 AC-Services CAN-IF 
 AC-Services OBD-IF 
 CEL EM357 ZigBee USB Stick - LR 
 CEL EM357 ZigBee USB Stick 
 MMB Networks ZigBee USB Device 
 Planet Innovation Ingeni ZigBee USB Device 
 Acuity Brands nLight Air Adapter 
 CESINEL MEDCAL STII Network Analyzer 
 CESINEL MEDCAL S II Network Analyzer 
 Ketra N1 Wireless Interface 
 Brim Brothers charging dock 
 CEL MeshWorks DevKit Device 
 KCF Technologies PRN 
 CESINEL FTBC Flexible Thyristor Bridge Controller 
 Qivicon ZigBee USB Radio Stick 
 HubZ dual ZigBee and Z-Wave dongle 
 CEL EM3588 ZigBee USB Stick 
 CEL EM3588 ZigBee USB Stick Long Range 
 Qivicon ZigBee USB Radio Stick 
 Silicon Labs factory default 
 Silicon Labs factory default 
 Silicon Labs Windows Update (CP2101-4CP2102N) 
 Silicon Labs factory default 
 Infinity GPS-MIC-1 Radio Monophone 
 Silicon Labs Windows Update (CP2105) 
 Silicon Labs Windows Update (CP2108) 
 Elan Digital Systems USBscope50 
 Elan Digital Systems USBwave12 
 Elan Digital Systems USBpulse100 
 Elan Digital Systems USBcount50 
 Silicon Labs MobiData GPRS USB Modem 
 Silicon Labs MobiData GPRS USB Modem 100EU 
 Link G4 ECU 
 Link G4+ ECU 
 Baltech card reader 
 Owen AC4 USB-RS485 Converter 
 ELDAT Easywave RX09 
 Clipsal 5500PACA C-Bus Pascal Automation Controller 
 Clipsal 5800PC C-Bus Wireless PC Interface 
 Clipsal 5500PCU C-Bus USB interface 
 Clipsal 5000CT2 C-Bus Black and White Touchscreen 
 Clipsal C-5000CT2 C-Bus Spectrum Colour Touchscreen 
 Clipsal L51xx C-Bus Architectural Dimmer 
 Clipsal 5560884 C-Bus Multi-room Audio Matrix Switcher 
 Lunatico Seletek 
 Lunatico Seletek 
 Jablotron serial interface 
 W-IE-NE-R Plein & Baus GmbH PL512 Power Supply 
 W-IE-NE-R Plein & Baus GmbH RCM Remote Control for MARATON Power Supply 
 W-IE-NE-R Plein & Baus GmbH MPOD Multi Channel Power Supply 
 W-IE-NE-R Plein & Baus GmbH CML Control, Monitoring and Data Logger 
 Kamstrup Optical Eye3-wire 
 Kamstrup M-Bus Master MultiPort 250D 
 Wavesense Jazz blood glucose meter 
 Vaisala USB Instrument Cable 
 ELV USB-I2C-Interface 
 ELV Marble Sound Board 1 
 ELV ALC 8xxx Battery Charger 
 ELV TFD500 Data Logger 
 GE B850 CP2105 Recorder interface 
 GE B650 CP2104 PMC interface 
 GE Healthcare Remote Alarm Box 
 GE B850B650B450 CP2104 DP UART interface 
 GE B850 CP2105 DP UART interface 
 GE CS1000 M.2 Key E serial interface 
 GE CS1000 Display serial interface 
 LORD WSDA-200-USB 
 Parrot NMEA GPS Flight Recorder 
 Schweitzer Engineering C662 Cable 
 Corsair USB Dongle 
 Silicon Labs 358x factory default 
 WAGO 750-923 USB Service Cable 
 Seluxit ApS RF Dongle 
 Festo CPX-USB 
 Festo CMSP 
 Lake Shore Model 121 Current Source 
 Lake Shore Model 218A Temperature Monitor 
 Lake Shore Model 219 Temperature Monitor 
 Lake Shore Model 233 Temperature Transmitter 
 Lake Shore Model 235 Temperature Transmitter 
 Lake Shore Model 335 Temperature Controller 
 Lake Shore Model 336 Temperature Controller 
 Lake Shore Model 350 Temperature Controller 
 Lake Shore Model 371 AC Bridge 
 Lake Shore Model 411 Handheld Gaussmeter 
 Lake Shore Model 425 Gaussmeter 
 Lake Shore Model 455A Gaussmeter 
 Lake Shore Model 475A Gaussmeter 
 Lake Shore Model 465 Three Axis Gaussmeter 
 Lake Shore Model 625A Superconducting MPS 
 Lake Shore Model 642A Magnet Power Supply 
 Lake Shore Model 648 Magnet Power Supply 
 Lake Shore Model 737 VSM Controller 
 Lake Shore Model 776 Hall Matrix 
 GW Instek GDM-834x Digital Multimeter 
 Aruba Networks 7xxx USB Serial Console 
 Link Instruments MSO-19 
 Link Instruments MSO-28 
 Link Instruments MSO-28 
 National Instruments USB Serial Console 
 DW700 GPS USB interface 
 Terminating Entry 
 Config request types 
 Config request codes 
 CP210X_IFC_ENABLE 
 CP210X_(SET|GET)_BAUDDIV 
 CP210X_(SET|GET)_LINE_CTL 
 CP210X_SET_BREAK 
 CP210X_(SET_MHS|GET_MDMSTS) 
 CP210X_(GET|SET)_CHARS 
 CP210X_VENDOR_SPECIFIC values 
 Part number definitions 
 CP210X_GET_COMM_STATUS returns these 0x13 bytes 
  CP210X_PURGE - 16 bits passed in wValue of USB request.
  SiLabs app note AN571 gives a strange description of the 4 bits:
  bit 0 or bit 2 clears the transmit queue and 1 or 3 receive.
  writing 1 to all, however, purges cp2108 well enough to avoid the hang.
 CP210X_EMBED_EVENTS 
 CP210X_GET_FLOWCP210X_SET_FLOW readwrite these 0x10 bytes 
 cp210x_flow_ctl::ulControlHandshake 
 cp210x_flow_ctl::ulFlowReplace 
 CP210X_VENDOR_SPECIFIC, CP210X_GET_DEVICEMODE call reads these 0x2 bytes. 
  CP210X_VENDOR_SPECIFIC, CP210X_GET_PORTCONFIG call reads these 0xf bytes
  on a CP2105 chip. Structure needs padding due to unusedunspecified bytes.
  CP210X_VENDOR_SPECIFIC, CP210X_GET_PORTCONFIG call reads these 0xd bytes
  on a CP2104 chip. Structure needs padding due to unusedunspecified bytes.
 GPIO modes 
 CP2105 port configuration values 
 CP2104 port configuration values 
  CP210X_VENDOR_SPECIFIC, CP210X_GET_PORTCONFIG call reads these 0x49 bytes
  on a CP2108 chip.
  See https:www.silabs.comdocumentspublicapplication-notesan978-cp210x-usb-to-uart-api-specification.pdf
 CP2102N configuration array indices 
 CP2102N QFN20 port configuration values 
  CP210X_VENDOR_SPECIFIC, CP210X_WRITE_LATCH call writes these 0x02 bytes
  for CP2102N, CP2103, CP2104 and CP2105.
  CP210X_VENDOR_SPECIFIC, CP210X_WRITE_LATCH call writes these 0x04 bytes
  for CP2108.
  Helper to get interface number when we only have struct usb_serial.
  Reads a variable-sized block of CP210X_ registers, identified by req.
  Returns data into buf in native USB byte order.
  Reads any 8-bit CP210X_ register identified by req.
  Reads a variable-sized vendor block of CP210X_ registers, identified by val.
  Returns data into buf in native USB byte order.
  Writes any 16-bit CP210X_ register (req) whose value is passed
  entirely in the wValue field of the USB request.
  Writes a variable-sized block of CP210X_ registers, identified by req.
  Data in buf must be in native USB byte order.
  Writes any 32-bit CP210X_ register identified by req.
  Writes a variable-sized vendor block of CP210X_ registers, identified by val.
  Data in buf must be in native USB byte order.
 Clear both queues; cp2108 needs this to avoid an occasional hang 
 Disabling the interface disables event-insertion mode. 
 unimplemented 
  Read how many bytes are waiting in the TX queue.
  Quantises the baud rate as per AN205 Table 1
  CP2101 supports the following baud rates:
 	300, 600, 1200, 1800, 2400, 4800, 7200, 9600, 14400, 19200, 28800,
 	38400, 56000, 57600, 115200, 128000, 230400, 460800, 921600
  CP2102 and CP2103 support the following additional rates:
 	4000, 16000, 51200, 64000, 76800, 153600, 250000, 256000, 500000,
 	576000
  The device will map a requested rate to a supported one, but the result
  of requests for rates greater than 1053257 is undefined (see AN205).
  CP2104, CP2105 and CP2110 support most rates up to 2M, 921k and 1M baud,
  respectively, with an error less than 1%. The actual rates are determined
  by
 	div = round(freq  (2 x prescale x request))
 	actual = freq  (2 x prescale x div)
  For CP2104 and CP2105 freq is 48Mhz and prescale is 4 for request <= 365bps
  or 1 otherwise.
  For CP2110 freq is 24Mhz and prescale is 4 for request <= 300bps or 1
  otherwise.
	
	  This maps the requested rate to the actual rate, a valid rate on
	  cp2102 or cp2103, or to an arbitrary rate in [1M, max_speed].
	 
	  NOTE: B0 is not implemented.
	
	  Some CP2102N interpret ulXonLimit as ulFlowReplace (erratum
	  CP2102N_E104). Report back that flow control is not supported.
 CP2101 only supports CS8, 1 stop bit and non-stick parity. 
	
	  Enable event-insertion mode only if input parity checking is
	  enabled for now.
	
	  Use SET_FLOW to set DTR and enabledisable auto-RTS when hardware
	  flow control is enabled.
 hardware does not support an input mode 
 push-pull pins cannot be changed to be inputs 
 make sure to release pin if it is being driven low 
 Succeed only if in correct mode (this can't be set at runtime) 
  This function is for configuring GPIO using shared pins, where other signals
  are made unavailable by configuring the use of GPIO. This is believed to be
  only applicable to the cp2105 at this point, the other devices supported by
  this driver that provide GPIO do so in a way that does not impact other
  signals and are thus expected to have very different initialisation.
  2 banks of GPIO - One for the pins taken from each serial port 
 mark all GPIOs of this interface as reserved 
 mark all GPIOs of this interface as reserved 
 mark all pins which are not in GPIO mode 
 GPIO 0 
 GPIO 1 
 driver implementation for CP2105 only supports outputs 
 mark all pins which are not in GPIO mode 
 GPIO 0 
 GPIO 1 
 GPIO 2 
	
	  Like CP2102N, CP2104 has also no strict input and output pin
	  modes.
	  Do the same input mode emulation as CP2102N.
		
		  Set direction to "input" iff pin is open-drain and reset
		  value is 1.
	
	  Mark all pins which are not in GPIO mode.
	 
	  Refer to table 9.1 "GPIO Mode alternate Functions" in the datasheet:
	  https:www.silabs.comdocumentspublicdata-sheetscp2108-datasheet.pdf
	 
	  Alternate functions of GPIO0 to GPIO3 are determine by enhancedfxn_ifc[0]
	  and the similarly for the other pins; enhancedfxn_ifc[1]: GPIO4 to GPIO7,
	  enhancedfxn_ifc[2]: GPIO8 to GPIO11, enhancedfxn_ifc[3]: GPIO12 to GPIO15.
	
	  Like CP2102N, CP2108 has also no strict input and output pin
	  modes. Do the same input mode emulation as CP2102N.
		
		  Set direction to "input" iff pin is open-drain and reset
		  value is 1.
	
	  Retrieve device configuration from the device.
	  The array received contains all customization settings done at the
	  factorymanufacturer. Format of the array is documented at the
	  time of writing at:
	  https:www.silabs.comcommunityinterfaceknowledge-base.entry.html20170331cp2102n_setconfig-xsfa
 Make sure this is a config format we understand. 
	
	  Get default pin states after reset. Needed so we can determine
	  the direction of an open-drain pin.
 0 indicates open-drain mode, 1 is push-pull 
 0 indicates GPIO mode, 1 is alternate function 
 QFN20 is special... 
 GPIO 0 
 GPIO 1 
 GPIO 2 
 GPIO 3 
		
		  For the QFN28 package, GPIO4-6 are controlled by
		  the low three bits of the modelatch fields.
		  Contrary to the document linked above, the bits for
		  the SUSPEND pins are elsewhere.  No alternate
		  function is available for these pins.
	
	  The CP2102N does not strictly has input and output pin modes,
	  it only knows open-drain and push-pull modes which is set at
	  factory. An open-drain pin can function both as an
	  input or an output. We emulate input mode for open-drain pins
	  by making sure they are not driven low, and we do not allow
	  push-pull pins to be set as an input.
		
		  Set direction to "input" iff pin is open-drain and reset
		  value is 1.
		
		  The GPIOs are not tied to any specific port so only register
		  once for interface 0.
 Nothing to do 
 ECI 
 SCI 
	
	  Some (possibly counterfeit) CP2102 do not support event-insertion
	  mode and respond differently to malformed vendor requests.
	  Specifically, they return one instead of two bytes when sent a
	  two-byte part-number request.
 SPDX-License-Identifier: GPL-2.0+
  IPWireless 3G UMTS TDD Modem driver (USB connected)
    Copyright (C) 2004 Roelf Diedericks <roelfd@inet.co.za>
    Copyright (C) 2004 Greg Kroah-Hartman <greg@kroah.com>
  All information about the device was acquired using SnoopyPro
  on MSFT's OS, and examing the MSFT drivers' debug output
  (insanely left _on_ in the enduser version)
  It was written out of frustration with the IPWireless USB modem
  supplied by Axity3GSentech South Africa not supporting
  Linux whatsoever.
  Nobody provided any proprietary information that was not already
  available for this device.
  The modem adheres to the "3GPP TS  27.007 AT command set for 3G
  User Equipment (UE)" standard, available from
  http:www.3gpp.orgftpSpecshtml-info27007.htm
  The code was only tested the IPWireless handheld modem distributed
  in South Africa by Sentech.
  It may work for Woosh Inc in .nz too, as it appears they use the
  same kit.
  There is still some work to be done in terms of handling
  DCD, DTR, RTS, CTS which are currently faked.
  It's good enough for PPP at this point. It's based off all kinds of
  code found in usbserial and usbclass
 real device node major id, experimental range 
 we support 256 devices, dunno why, it'd be insane :) 
 magic number for ipw struct 
 Message sizes 
 vendorproduct pairs that are known work with this driver
 Vendor commands: 
 baud rates 
 data bits 
 ok so the define is misleading, I know, but forces 8,n,1 
 I mean, is there a point to any other setting these days? :) 
 usb control request types : 
 control bulk rx channel transmissions, value=10 (onoff) 
 set baud, value=requested ipw_sio_bxxxx 
 set databits, parity. value=ipw_dtb_x 
 setclear dtrrts value=ipw_pin_xxx 
 get serial port status byte, call with value=0 
 initializes ? value=0 (appears as first thing todo on open) 
 purge all transmissions?, call with value=numchar_to_purge 
 set xonxoff limits value=0, and a buffer of 0x10 bytes 
 set the flowcontrol special chars, value=0, buf=6 bytes, 
 last 2 bytes contain flowcontrol chars e.g. 00 00 00 00 11 13 
 values used for request IPW_SIO_SET_PIN 
 unconfirmed 
 values used for request IPW_SIO_RXCTL 
 various 16 byte hardcoded transferbuffers used by flow control 
 Interpretation of modem status lines 
 These need sorting out by individually connecting pins and checking
  results. FIXME!
  When data is being sent we see 0x30 in the lower byte; this must
  contain DSR and CTS ...
	 --1: Tell the modem to initialize (we think) From sniffs this is
	 	always the first thing that gets sent to the modem during
 index 
 reset the bulk pipes 
--2: Start reading from the device 
--3: Tell the modem to open the floodgates on the rx bulk channel 
 index 
--4: setup the initial flowcontrol 
--3: purge 
	 send RXBULK_off (tell modem to stop transmitting bulk data on
 index 
 Module information 
 SPDX-License-Identifier: GPL-2.0+
  USB IR Dongle driver
 	Copyright (C) 2001-2002	Greg Kroah-Hartman (greg@kroah.com)
 	Copyright (C) 2002	Gary Brubaker (xavyer@ix.netcom.com)
 	Copyright (C) 2010	Johan Hovold (jhovold@gmail.com)
  This driver allows a USB IrDA device to be used as a "dumb" serial device.
  This can be useful if you do not have access to a full IrDA stack on the
  other side of the connection.  If you do have an IrDA stack on both devices,
  please use the usb-irda driver, as it contains the proper error checking and
  other goodness of a full IrDA stack.
  Portions of this driver were taken from driversnetirdairda-usb.c, which
  was written by Roman Weissgaerber <weissg@vienna.at>, Dag Brattli
  <dag@brattli.net>, and Jean Tourrilhes <jt@hpl.hp.com>
  See Documentationusbusb-serial.rst for more information on using this
  driver
 if overridden by the user, then use their value for the size of the read and
 if overridden by the user, then use the specified number of XBOFs 
 Not that this lot means you can only have one per system 
 KC Technology, KC-180 
 XTNDAccess 
 ACTiSys ACT-IR2000U 
 Terminating entry 
------------------------------------------------------------------
  Function irda_usb_find_class_desc(dev, ifnum)
     Returns instance of IrDA class descriptor, or NULL if not found
  The class descriptor is some extra info that IrDA USB devices will
  offer to us, describing their IrDA characteristics. We will use that in
  irda_usb_init_qos()
  Based on the same function in driversnetirdairda-usb.c
 reference irda-usb.c 
	
	  The first byte of the packet we send to the device contains an
	  outbound header which indicates an additional number of BOFs and
	  a baud rate change.
	 
	  See section 5.4.2.2 of the USB IrDA spec.
	
	  The first byte of the packet we get from the device
	  contains a busy indicator and baud rate change.
	  See section 5.4.1.2 of the USB IrDA spec.
	
	  FIXME, we should compare the baud request against the
	  capability stated in the IR header that we got in the
	  startup function.
 Only speed changes are supported 
	
	  send the baud change out on an "empty" data packet
 SPDX-License-Identifier: GPL-2.0+
  USB FTDI SIO driver
 	Copyright (C) 2009 - 2013
 	    Johan Hovold (jhovold@gmail.com)
 	Copyright (C) 1999 - 2001
 	    Greg Kroah-Hartman (greg@kroah.com)
           Bill Ryder (bryder@sgi.com)
 	Copyright (C) 2002
 	    Kuba Ober (kuba@mareimbrium.org)
  See Documentationusbusb-serial.rst for more information on using this
  driver
  See http:ftdi-usb-sio.sourceforge.net for up to date testing info
 	and extra documentation
  Change entries from 2004 and earlier can be found in versions of this
  file in kernel versions prior to the 2.6.24 release.
 Bill Ryder - bryder@sgi.com - wrote the FTDI_SIO implementation 
 Thanx to FTDI for so kindly providing details of the protocol required 
   to talk to the device 
 Thanx to gkh and the rest of the usb dev group for all code I have
 type of device, either SIO or FT8U232AM 
 baud base clock for divisor setting 
	int custom_divisor;	 custom_divisor kludge, this is for
				   baud_base (different from what goes to the
	u16 last_set_data_value;  the last data state set - needed for doing
				   a break
 some ASYNC_xxxx flags are supported 
 saved modem control outputs 
 Used for TIOCMIWAIT 
 If transmitter is empty or not 
	u16 interface;		 FT2232C, FT2232H or FT4232H port interface
	speed_t force_baud;	 if non-zero, force the baud rate to
	int force_rtscts;	 if non-zero, force RTS-CTS to always
 latency setting in use 
 Avoid mess by parallel calls of config ioctl() and change_speed() 
 protects GPIO state 
 is the gpiochip in kernel registered 
 true if the user requested a gpio 
 which pins are in gpio mode 
 pin directions cache 
 pin value for outputs 
 struct ftdi_sio_quirk is used by devices requiring special attention. 
 Special settings for probed ports. 
  The 8U232AM has the same API as the sio except for:
  - it can support MUCH higher baudrates; up to:
    o 921600 for RS232 and 2000000 for RS422485 at 48MHz
    o 230400 at 12MHz
    so .. 8U232AM's baudrate setting codes are different
  - it has a two byte status code.
  - it returns characters every 16ms (the FTDI does it every 40ms)
  the bcdDevice value is used to differentiate FT232BM and FT245BM from
  the earlier FT8U232AM and FT8U232BM.  For now, include all known VIDPID
  combinations in both tables.
  FIXME: perhaps bcdDevice can also identify 12MHz FT8U232AM devices,
  but I don't know if those ever went into mass production. [Ian Abbott]
  Device ID not listed? Test it using
  sysbususb-serialdriversftdi_sionew_id and send a patch or report.
	
	  ELV devices:
 Papouch devices based on FTDI chip 
 Crucible Devices 
 Cressi Devices 
 Brainboxes Devices 
 ekey Devices 
 Infineon Devices 
 GE Healthcare devices 
 Active Research (Actisense) devices 
 ICP DAS I-756xU devices 
 EZPrototypes devices 
 Sienna devices 
 IDS GmbH devices 
 U-Blox devices 
 FreeCalypso USB adapters 
 Terminating entry 
 the serial part of FT8U100AX 
 Used for TIOCMIWAIT 
 End TIOCMIWAIT 
 function prototypes for a FTDI serial converter 
 default urb timeout 
 shorter urb timeout 
  Utility functions
 divisor shifted 3 bits to the left 
 round x.78 up to x+1 
 +0.125 
 +0.5 
 +0.25 
 special case for maximum baud rate 
 divisor shifted 3 bits to the left 
 Deal with special cases for highest baud rates. 
 1.0 
 1.5 
 hi-speed baud rate is 10-bit sampling instead of 16-bit 
 Deal with special cases for highest baud rates. 
 1.0 
 1.5 
	
	  Set this bit to turn off a divide by 2.5 on baud rate generator
	  This enables baud rates up to 12Mbaud but cannot reach below 1200
	  baud with this bit set
 no change 
 'set' takes precedence over 'clear' 
 FIXME: locking on last_dtr_rts 
	
	  Observe deprecated async-compatible custom_divisor hack, update
	  baudrate if needed.
 SIO chip 
 baud 
 8U232AM chip 
 FT232BM chip 
 FT2232C chip 
 FT232RL chip 
 FT-X series 
 FT2232H chip 
 FT4232H chip 
 FT232H chip 
 priv->chip_type 
		 Probably the BM type needs the MSB of the encoded fractional
 warn about deprecation unless clearing 
 Determine type of FTDI chip based on USB config and descriptor. 
 Assume it is not the original SIO device for now. 
 Multiple interfaces.
 Hi-speed - baud clock runs at 120MHz 
 Hi-speed - baud clock runs at 120MHz 
 Determine interface code. 
		 BM-type devices have a bug where bcdDevice gets set
 Old device.  Assume it's the original SIO. 
 Assume it's an FT8U232AM (or FT8U245AM) 
		
		  It might be a BM type because of the iSerialNumber bug.
		  If iSerialNumber==0 and the latency timer is readable,
		  assume it is BM type.
 Assume it's an FT232BM (or FT245BM) 
 Assume it's an FT232RL 
 Assume it's an FT232H 
 Assume it's an FT-X series device 
  Determine the maximum packet size for the device. This depends on the chip
  type and the USB host capabilities. The value should be obtained from the
  device descriptor as the chip will use the appropriate values for the host.
	
	  NOTE: Some customers have programmed FT232RFT245R devices
	  with an endpoint size of 0 - not good. In this case, we
	  want to override the endpoint descriptor setting and use a
	  value of 64 for wMaxPacketSize.
 Set max packet size based on last descriptor. 
  Sysfs Attribute
 Write a new value of the latency timer, in units of milliseconds. 
 Write an event character directly to the FTDI register.  The ASCII
	 XXX I've no idea if the original SIO supports the event_char
 XXX see create_sysfs_attrs 
 Set default pin states, as we cannot get them from device 
 Read EEPROM two bytes at a time 
	
	  FT232H CBUS Memory Map
	 
	  0x1a: X- (upper nibble -> AC5)
	  0x1b: -X (lower nibble -> AC6)
	  0x1c: XX (upper nibble -> AC9 | lower nibble -> AC8)
 FIXME: FT234XD alone has 1 GPIO, but how to recognize this IC? 
 Determine which pins are configured for CBUS bitbanging 
 Exiting CBUS-mode does not reset pin states. 
 CONFIG_GPIOLIB 
  FTDI driver specific functions
 Probe function to check for special devices 
 Setup for the USB-UIRT device, which requires hardwired
 Called from usbserial:serial_probe 
 Setup for the HE-TIRA1 device, which requires hardwired
  Module parameter to control latency timer for NDI FTDI-based USB devices.
  If this value is not set in etcmodprobe.d its value will be set
  to 1ms.
 Setup for the NDI FTDI-based USB devices, which requires hardwired
  baudrate (19200 gets mapped to 1200000).
  Called from usbserial:serial_probe.
 FIXME: errors are not returned 
  First port on JTAG adaptors such as Olimex arm-usb-ocd or the FICOpenMoko
  Neo1973 Debug Board is reserved for JTAG interface and can be accessed from
  userspace using openocd.
  First two ports on JTAG adaptors using an FT4232 such as STMicroelectronics's
  ST Micro Connect Lite are reserved for JTAG or other non-UART interfaces and
  can be accessed from userspace.
  The next two ports are enabled as UARTs by default, where port 2 is
  a conventional RS-232 UART.
 No error checking for this (will get errors later anyway) 
 See ftdi_sio.h for description of what is reset 
	 Termios defaults are set by usb_serial_init. We don't change
	   port->tty->termios - this would lose speed settings, etc.
 ftdi_set_termios  will send usb control messages 
 Disable flow control 
 drop RTS and DTR 
 The SIO requires the first byte to have:
   B0 1
   B1 0
   B2..7 length of message excluding byte 0
  The new devices do not require this byte
	 Compare new line status to the old one, signal if different
	   N.B. packet may be processed more than once, but differences
 save if the transmitter is empty or not 
 status only 
	
	  Break and error status must only be processed for packets with
	  data payload to avoid over-reporting.
		
		  Break takes precedence over parity, which takes precedence
		  over framing errors. Note that break is only associated
		  with the last character in the buffer and only when it's a
		  NUL.
 Overrun is special, not associated with a char 
 break_state = -1 to turn on break, and 0 to turn off break 
 see driverschartty_io.c to see it used 
 last_set_data_value NEVER has the break bit set in it 
 old_termios contains the original termios settings and tty->termios contains
  the new setting to be used
  WARNING: set_termios calls this with old_termios in kernel space
	 Force baud rate if this device requires it, unless it is set to
 Force RTS-CTS if this device requires it. 
	
	  All FTDI UART chips are limited to CS78. We shouldn't pretend to
	  support CS56 and revert the CSIZE setting instead.
	 
	  CS5 however is used to control some smartcard readers which abuse
	  this limitation to switch modes. Original FTDI chips fall back to
	  eight data bits.
	 
	  TODO: Implement a quirk to only allow this with mentioned
	        readers. One I know of (Argolis Smartreader V1)
	        returns "USB smartcard server" as iInterface string.
	        The vendor didn't bother with a custom VIDPID of
	        course.
	 NOTE These routines can get interrupted by
	   ftdi_sio_read_bulk_callback  - need to examine what this means -
 Set number of data bits, parity, stop bits 
	 This is needed by the break command since it uses the same command
 Now do the baudrate 
 Disable flow control 
 Drop RTS and DTR 
 set the baudrate determined before 
 Ensure RTS and DTR are raised when baudrate changed from 0 
 Set hardware-assisted flow control 
  Get modem-control status.
  Returns the number of status bytes retrieved (device dependant), or
  negative error code.
	
	  The 8U232AM returns a two byte value (the SIO a 1 byte value) in
	  the same format as the data returned from the in point.
 NOTE: We allow short responses and handle that below. 
 SPDX-License-Identifier: GPL-2.0+
  KLSI KL5KUSB105 chip RS232 converter driver
    Copyright (C) 2010 Johan Hovold <jhovold@gmail.com>
    Copyright (C) 2001 Utz-Uwe Haus <haus@uuhaus.de>
  All information about the device was acquired using SniffUSB ans snoopUSB
  on Windows98.
  It was written out of frustration with the PalmConnect USB Serial adapter
  sold by Palm Inc.
  Neither Palm, nor their contractor (MCCI) or their supplier (KLSI) provided
  information that was not already available.
  It seems that KLSI bought some silicon-design information from ScanLogic,
  whose SL11R processor is at the core of the KL5KUSB chipset from KLSI.
  KLSI has firmware available for their devices; it is probable that the
  firmware differs from that used by KLSI in their products. If you have an
  original KLSI device and can provide some information on it, I would be
  most interested in adding support for it here. If you have any information
  on the protocol used (or find errors in my reverse-engineered stuff), please
  let me know.
  The code was only tested with a PalmConnect USB adapter; if you
  are adventurous, try it with any KLSI-based device and let me know how it
  breaks so that I can fix it!
 TODO:
 	check modem line signals
 	implement handshaking or decide that we do not support it
  Function prototypes
  All of the device info needed for the KLSI converters.
 Terminating entry 
 always 5, it seems 
 modem line settings 
  Handle vendor specific USB requests
 default urb timeout 
 value 
 index 
  Read line control via vendor command and return result through
  the state pointer.
 value 
 index 
  Driver's tty interface functions
 set initial values for control structures 
	 Do a defined restart:
	  Set up sane default baud rate and send the 'READ_ON'
	  vendor command.
	  FIXME: set modem line control (how?)
	  Then read the modem line control and store values in
	  priv->line_state.
 READ_ON and urb submission 
 index 
 index 
 send READ_OFF 
 index 
 shutdown our bulk reads and writes 
 We need to write a complete 64-byte data block and encode the
  number actually sent in the first double-byte, LSB-order. That
  leaves at most 62 bytes of payload.
 The data received is preceded by a length double-byte in LSB-first order.
 empty urbs seem to happen, we ignore them 
 lock while we are modifying the settings 
	
	  Update baud rate
 handled below 
	
	  FIXME: implement B0 handling
	 
	  Maybe this should be simulated by sending read disable and read
	  enable messages?
 set the number of data bits 
	
	  Update line control register (LCR)
 Not currently supported 
	
	  Set flow control: well, I do not really now how to handle DTRRTS.
	  Just do what we have seen with SniffUSB on Win98.
 Not currently supported 
 now commit changes to device 
 better return value? EAGAIN? 
 SPDX-License-Identifier: GPL-2.0
  USB ZyXEL omni.net driver
  Copyright (C) 2013,2017 Johan Hovold <johan@kernel.org>
  See Documentationusbusb-serial.rst for more information on using this
  driver
  Please report both successes and troubles to the author at omninet@kroah.com
 This one seems to be a re-branded ZyXEL device 
 function prototypes 
 Terminating entry 
  The protocol.
  The omni.net always exchange 64 bytes of data with the host. The first
  four bytes are the control header.
  oh_seq is a sequence number. Don't know ifhow it's used.
  oh_len is the length of the data bytes in the packet.
  oh_xxx Bit-mapped, related to handshaking and status info.
 	I normally set it to 0x03 in transmitted frames.
 	7: Active when the TA is in a CONNECTed state.
 	6: unknown
 	5: handshaking, unknown
 	4: handshaking, unknown
 	3: unknown, usually 0
 	2: unknown, usually 0
 	1: handshaking, unknown, usually set to 1 in transmitted frames
 	0: handshaking, unknown, usually set to 1 in transmitted frames
  oh_pad Probably a pad byte.
  After the header you will find data bytes if oh_len was greater than zero.
 Sequence number for bulk_out URBs 
 We need only the second bulk-out for our single-port device. 
 always 64 bytes 
 SPDX-License-Identifier: GPL-2.0+
  USB Wishbone-Serial adapter driver
  Copyright (C) 2013 Wesley W. Terpstra <w.terpstra@gsi.de>
  Copyright (C) 2013 GSI Helmholtz Centre for Heavy Ion Research GmbH
  Etherbone must be told that a new stream has begun before data arrives.
  This is necessary to restart the negotiation of Wishbone bus parameters.
  Similarly, when the stream ends, Etherbone must be told so that the cycle
  line can be driven low in the case that userspace failed to do so.
 Send to EP0OUT 
 wValue = device is open(1) or closed(0) 
 There is no data stage 
 Timeout till operation fails 
 SPDX-License-Identifier: GPL-2.0+
  Garmin GPS driver
  Copyright (C) 2006-2011 Hermann Kneissel herkne@gmx.de
  The latest version of the driver can be found at
  http:sourceforge.netprojectsgarmin-gps
  This driver has been derived from v2.1 of the visor driver.
 the mode to be set when the port ist opened 
  Version Information
 error codes returned by the driver 
 invalid packet structure 
 size of the header of a packet using the usb protocol 
 max. possible size of a packet using the serial protocol 
  max. possible size of a packet with worst case stuffing 
 size of a buffer able to hold a complete (no stuffing) packet
  (the document protocol does not contain packets with a larger
   size, but in theory a packet may be 64k+12 bytes - if in
   later protocol versions larger packet sizes occur, this value
   should be increased accordingly, so the input buffer is always
 size of a buffer able to hold a complete (incl. stuffing) packet 
 where to place the packet id of a serial packet, so we can
  prepend the usb-packet header without the need to move the
 max. size of incoming private packets (header+1 param) 
 our own layer-id to use for some control mechanisms 
 packet ids used in private layer 
 structure used to queue incoming packets 
 the real size of the data array, always > 0 
 structure used to keep the current state of the driver 
 tty -> usb 
 usb -> tty 
 Flags used in garmin_data.flags: 
 function prototypes 
 some special packets to be send or received 
 packets currently unused, left as documentation 
	 the same device id seems to be used by all
 Terminating entry 
  check if the usb-packet in buf contains an abort-transfer command.
  (if yes, all queued data will be dropped)
  packet queue handling
  queue a received (usb-)packet for later processing
 process only packets containing data ... 
		 in serial mode, if someone is waiting for data from
 get the next pending packet 
 free up all queued data 
  garmin serial protocol handling handling
 send an ack packet back to the tty 
  called for a complete packet received from tty layer
  the complete packet (pktid ... cksum) is in garmin_data_p->inbuf starting
  at GSP_INITIAL_OFFSET.
  count - number of bytes in the input buffer including space reserved for
          the usb header: GSP_INITIAL_OFFSET + number of bytes in packet
          (including pkt-id, data-length a. cksum)
 sanity check, remove after test ... 
	 if this was an abort-transfer command, flush all
  Called for data received from tty
  buf contains the data read, it may span more than one packet or even
  incomplete packets
  input record should be a serial-record, but it may not be complete.
  Copy it into our local buffer, until an etx is seen (or an error
  occurs).
  Once the record is complete, convert into a usb packet and send it
  to the bulk pipe, send an ack back to the tty.
  If the input is an ack, just send the last queued packet to the
  tty layer.
  if the input is an abort command, drop all queued data.
 dleSeen: set if last byte read was a DLE 
	 skip: if set, skip incoming data until possible start of
	        new packet
	 dev_dbg(dev, "%s - dle=%d skip=%d size=%d count=%d\n",
 start of a new pkt 
 packet complete 
 copy flags back to structure 
  Sends a usb packet to the tty
  Assumes, that all packages and at an usb-packet boundary.
  return <0 on error, 0 if packet is incomplete or > 0 if packet was sent
 garmin_data_p->outbuffer now contains a complete packet 
 the serial protocol should be able to handle this packet 
		 can't add stuffing DLEs in place, move data to end
  Process the next pending data packet - if there is one
  garmin native mode
  Called for data received from tty
  The input data is expected to be in garmin usb-packet format.
  buf contains the data read, it may span more than one packet
  or even incomplete packets
 if buffer contains header, copy rest of data 
			 seems to be an invalid packet, ignore rest
 do we have a complete packet ? 
				 if this was an abort-transfer command,
  private packets
  Garmin specific driver functions
  clear all cached data
 flush all queued data 
	
	  using the initialization method from gpsbabel. See comments in
	  gpsbabeljeepsgpslibusb.c gusb_reset_toggles()
 shutdown any bulk reads that might be going on 
 shutdown our urbs 
 keep reset state so we know that we must start a new session 
	 Ignore errors that resulted from garmin_write_bulk with
 free up the transfer buffer, as usb_free_urb() does not do this 
 send it down the pipe 
	 we are done with this urb, so let the host driver
 check for our private packets 
 drop all unfinished transfers 
 MODE_NATIVE 
	
	  Report back the bytes currently available in the output buffer.
 abort-transfer cmd is active 
		 if throttling is active or postprecessing is required
		   put the received data in the input queue, otherwise
 ignore system layer packets ... 
 Continue trying to read until nothing more is received  
 success 
 this urb is terminated, clean up 
 bulk data available 
 bulk-in transfer still active 
 save the serial number 
  Sends the next queued packt to the tty port (garmin native mode only)
  and then sets a timer to call itself again until all queued data
  is sent.
	 set flag, data received will be put into a queue
	 in native mode send queued data to tty, in
  The timer is currently only used to send queued packets to
  the tty in cases where the protocol provides no own handshaking
  to initiate the transfer.
 send the next queued packet to the tty port 
 All of the device info needed 
 SPDX-License-Identifier: GPL-2.0
  Symbol USB barcode to serial driver
  Copyright (C) 2013 Johan Hovold <jhovold@gmail.com>
  Copyright (C) 2009 Greg Kroah-Hartman <gregkh@suse.de>
  Copyright (C) 2009 Novell Inc.
 protects the following flags 
 success 
 this urb is terminated, clean up 
	
	  Data from the device comes with a 1 byte header:
	 
	  <size of data> <data>...
 Continue trying to always read if we should 
 Start reading from the device 
 SPDX-License-Identifier: GPL-2.0
  USB Driver layer for GSM modems
  Copyright (C) 2005  Matthias Urlichs <smurf@smurf.noris.de>
  Portions copied from the Keyspan driver by Hugh Blemings <hugh@blemings.org>
  History: see the git log.
  Work sponsored by: Sigos GmbH, Germany <info@sigos.de>
  This driver exists because the "normal" serial driver doesn't work too well
  with GSM modems. Issues:
  - data loss -- one single Receive URB is not nearly enough
  - controlling the baud rate doesn't make sense
  Generate DTRRTS signals on the port using the SET_CONTROL_LINE_STATE request
  in CDC ACM.
 FIXME: locking 
 FIXME: what locks portdata fields ? 
 spurious 
 send the data 
 don't resubmit on fatal errors 
 Resubmit urb so we continue receiving 
 busy also in error unless we are killed 
		 FIXME: This locking is insufficient as this_urb may
 Start reading from the IN endpoint 
 this balances a get in the generic USB serial code 
	
	  Need to take susp_lock to make sure port is not already being
	  resumed, but no need to hold it due to initialized
 No ISO 
 Caller must hold susp_lock. 
 SPDX-License-Identifier: GPL-2.0+
  Edgeport USB Serial Converter driver
  Copyright (C) 2000 Inside Out Networks, All rights reserved.
  Copyright (C) 2001-2002 Greg Kroah-Hartman <greg@kroah.com>
  Supports the following devices:
 	Edgeport4
 	Edgeport4t
 	Edgeport2
 	Edgeport4i
 	Edgeport2i
 	Edgeport421
 	Edgeport21
 	Rapidport4
 	Edgeport8
 	Edgeport2D8
 	Edgeport4D8
 	Edgeport8i
  For questions or problems with this driver, contact Inside Out
  Networks technical support, or Peter Berger <pberger@brimson.com>,
  or Al Borchers <alborchers@steinerpoint.com>.
 info for the iosp messages 
 16654 UART defines 
 5 seconds 
 Devices that this driver supports 
 Terminating entry 
 receive port state 
 Expect header byte 1 
 Expect header byte 2 
 Expect 'RxBytesRemaining' data 
 Expect header byte 3 (for status hdrs only) 
 Transmit Fifo
  This Transmit queue is an extension of the edgeport Rx buffer.
  The maximum amount of data buffered in both the edgeport
  Rx buffer (maxTxCredits) and this buffer will never exceed maxTxCredits.
 index to head pointer (write) 
 index to tail pointer (read)  
 Bytes in queue 
 Max size of queue (equal to Max number of TxCredits) 
 allocated Buffer 
 This structure holds all of the local port information 
 our current credits for this port 
 the max size of the port 
 transmit fifo -- size will be maxTxCredits 
 write URB for this port 
 'true' while a write URB is outstanding 
 last LCR value received 
 last MCR value received 
 last MSR value received 
 last LSR value received 
 last value set as XON char in Edgeport 
 last value set as XOFF char in Edgeport 
 for handling sleeping while waiting for chase to finish 
 for handling sleeping while waiting for open to finish 
 for handling sleeping while waiting for command to finish 
 loop back to the owner of this object 
 This structure holds all of the individual device information 
 string name of this device 
 the manufacturer descriptor 
 the boot firmware descriptor 
 Product Info 
 Edgeport compatible descriptor 
 flag if EPiC device or not 
 the interrupt endpoint handle 
 the buffer we use for the interrupt endpoint 
 our interrupt urb 
 the bulk in endpoint handle 
 the buffer we use for the bulk in endpoint 
 our bulk read urb 
 the bulk out endpoint handle 
 the number of bytes that we need to read from this device 
 the current state of the bulk receive processor 
 receive header byte 1 
 receive header byte 2 
 receive header byte 3 
 the port that we are currently receiving data for 
 the receive status code 
 the receive status paramater 
 the number of port bytes left to read 
 loop back to the owner of this object 
 baud rate information 
  Define table of divisors for Rev A EdgePort4 hardware
  These assume a 3.6864MHz crystal, the standard 16, and
  MCR.7 = 0.
 2094.545455 => 230450   => .0217 % over 
 1713.011152 => 230398.5 => .00065% under 
 Number of outstanding Command Write Urbs 
 function prototypes 
 									
  update_edgeport_E2PROM()	Compare current versions of		
 				Boot ROM and Manufacture 		
 				Descriptors with versions		
 				embedded in this driver			
 									
 Check Boot Image Version 
 Dump Product Info structure 
 check if this is 2nd generation hardware 
 Determine Product type and set appropriate flags 
 Edgeport2 RS422RS485 
 Edgeport4 RS422 
 Edgeport4 RS422 
            U S B  C A L L B A C K   F U N C T I O N S                
            U S B  C A L L B A C K   F U N C T I O N S                
  edge_interrupt_callback
 	this is the callback function for when we have received data on the
 	interrupt endpoint.
 success 
 this urb is terminated, clean up 
 process this interrupt-read even if there are no ports open 
					 we have pending bytes on the
 grab the txcredits for the ports if available 
					 tell the tty driver that something
					 Since we have more credit, check
  edge_bulk_in_callback
 	this is the callback function for when we have received data on the
 	bulk in endpoint.
 decrement our rxBytes available by the number that we just got 
 check to see if there's any more data for us to read 
  edge_bulk_out_data_callback
 	this is the callback function for when we have finished sending
 	serial data on the bulk out endpoint.
 Release the Write URB 
 Check if more data needs to be sent 
  BulkOutCmdCallback
 	this is the callback function for when we have finished sending a
 	command	on the bulk out endpoint.
 clean up the transfer buffer 
 Free the command urb 
 tell the tty driver that something has changed 
 we have completed the command 
  Driver tty interface functions
  SerialOpen
 	this function is called by the tty driver when a port is opened
 	If successful, we return 0
 	Otherwise we return a negative error number.
	 see if we've set up our endpoint info yet (can't set it up
 not set up yet, so do it now 
 set up our interrupt urb 
 set up our bulk in urb 
		 start interrupt read for this edgeport
		  this interrupt will continue as long
 initialize our wait queues 
 initialize our port settings 
 Can't send any data yet 
 Must always set this bit to enable ints! 
 send a open port command 
 now wait for the port to be completely opened 
 open timed out 
 create the txfifo 
 Allocate a URB for the write 
  block_until_chase_response
 	This function will block the close until one of the following:
 		1. Response to our Chase comes from Edgeport
 		2. A timeout of 10 seconds without activity has expired
 		   (1K of Edgeport data @ 2400 baud ==> 4 sec to empty)
 Save Last credits 
 Did we get our Chase response 
 did we get all of our credit back? 
 Block the thread for a while 
 No activity.. count down. 
 Reset timeout value back to 10 seconds 
  block_until_tx_empty
 	This function will block the close until one of the following:
 		1. TX count are 0
 		2. The edgeport has stopped
 		3. A timeout of 3 seconds without activity has expired
 Save Last count 
 Is the Edgeport Buffer empty? 
 Block the thread for a while 
 No activity.. count down. 
 Reset timeout value back to seconds 
  edge_close
 	this function is called by the tty driver when a port is closed
 block until tx is empty 
 flush and chase 
 block until chase finished 
 close the port 
 port->close = true; 
		 if this urb had a transfer buffer already
  SerialWrite
 	this function is called by the tty driver when data should be written
 	to the port.
 	If successful, we return the number of bytes written, otherwise we
 	return a negative error number.
 get a pointer to the Tx fifo 
 calculate number of bytes to put in fifo 
	 catch writes of 0 bytes which the tty driver likes to give us,
	 queue the data
	  since we can never overflow the buffer we do not have to check for a
	  full condition
	 
	  the copy is done is two parts -- first fill to the end of the buffer
	  then copy the reset from the start of the buffer
 now copy our data 
 update the index and size 
 wrap the index 
 update the index and size 
		 No need to check for wrap since we can not get to end of
		  the fifo in this part
  send_more_port_data()
 	This routine attempts to write additional UART transmit data
 	to a port over the USB bulk pipe. It is called (1) when new
 	data has been written to a port's TxBuffer from higher layers
 	(2) when the peripheral sends us additional TxCredits indicating
 	that it can accept more	Tx data for a given port; and (3) when
 	a bulk write completes successfully and we want to see if we
 	can transmit more.
	 since the amount of data in the fifo will always fit into the
	  edgeport buffer we do not need to check the write length
	 
	  Do we have enough credits for this port to make it worthwhile
	  to bother queueing a write. If it's too small, say a few bytes,
	  it's better to wait for more credits so we can do a larger write.
 lock this write 
 get a pointer to the write_urb 
 make sure transfer buffer is freed 
	 build the data header for the buffer and port that we are about
 now copy our data 
 fill up the urb with all of our data and submit it 
 decrement the number of credits we have by the number we just sent 
 something went wrong 
 revert the credits as something bad happened. 
  edge_write_room
 	this function is called by the tty driver when it wants to know how
 	many bytes of data we can accept for a specific port.
 total of both buffers is still txCredit 
  edge_chars_in_buffer
 	this function is called by the tty driver when it wants to know how
 	many bytes of data we currently have outstanding in the port (data that
 	has been written, but hasn't made it out the port yet)
  SerialThrottle
 	this function is called by the tty driver when it wants to stop the data
 	being read from the port.
 if we are implementing XONXOFF, send the stop character 
 if we are implementing RTSCTS, toggle that line 
  edge_unthrottle
 	this function is called by the tty driver when it wants to resume the
 	data being read from the port (called after SerialThrottle is called)
 if we are implementing XONXOFF, send the start character 
 if we are implementing RTSCTS, toggle that line 
  SerialSetTermios
 	this function is called by the tty driver when it wants to change
  the termios structure
 change the port settings to the new ones specified 
  get_lsr_info - get line status register info
  Purpose: Let user call ioctl() to get info when the UART physically
  	    is emptied.  On bus types like RS485, the transmitter must
  	    release the bus after transmitting. This must be done when
  	    the transmit shift register is empty, not be done when the
  	    transmit holding register is empty.  This functionality
  	    allows an RS485 driver to be written in user space.
 0x002 
 0x004 
 0x020 
 0x040 
 0x080 
 0x100 
  SerialIoctl
 	this function handles any ioctl calls to the driver
  SerialBreak
 	this function sends a break to the port
 flush and chase 
 block until chase finished 
  process_rcvd_data
 	this function handles the data received on the bulk in pipe.
 failsafe incase we get a message that we don't understand 
			 Process depending on whether this header is
				 Decode this status header and go to
				  EXPECT_HDR1 (if we can process the status
				  with only 2 bytes), or go to EXPECT_HDR3 to
					 This status needs additional bytes.
					  Save what we have and then wait for
					  more data.
				 We have all the header bytes, process the
 Expect data 
 Expect data to start next buffer 
 BufLen >= RxBytesRemaining 
 Start another header next time 
			 spit this data back into the tty driver if this
 Expect 3rd byte of status header 
			 We have all the header bytes, process the
  process_rcvd_status
 	this function handles the any status messages received on the
 	bulk in pipe.
 switch the port pointer to the one being currently talked about 
			 we want to do EXT status regardless of port
			 Currently, the only EXT_STATUS is Chase, so process
			  here instead of one more call to one more subroutine
			  Ifwhen more EXT_STATUS, there'll be more work to do
			  Also, we currently clear flag and close the port
			  regardless of content of above's Byte3.
			  We could choose to do something else when Byte3 says
			  Timeout on Chase from Edgeport, like wait longer in
			  block_until_chase_response, but for now we don't.
 Port->RxCheckRsp = true; 
		 send the current line settings to the port so we are
 we have completed the open 
	 If port is closed, silently discard all rcvd status. We can
	  have cases where buffered status is received AFTER the close
	  port command is sent to the Edgeport.
 Not currently sent by Edgeport 
 byte2 is LSR Register 
 byte3 is broken data byte 
	
	 	case IOSP_EXT_4_STATUS:
	 		dev_dbg(dev, "%s - Port %u LSR Status = %02x Data = %02x\n",
	 			__func__, edge_serial->rxPort, byte2, byte3);
	 		break;
		
		  Process this new modem status and generate appropriate
		  events, etc, based on the new status. This routine
		  also saves the MSR in Port->ShadowMsr.
  edge_tty_recv
 	this function passes data on to the tty flip buffer
  handle_new_msr
 	this function handles any change to the msr register for a port.
 update input line counters 
 Save the new modem status 
  handle_new_lsr
 	this function handles any change to the lsr register for a port.
		
		  Parity and Framing errors only count if they
		  occur exclusive of a break being
		  received.
 Place LSR data byte into Rx buffer 
 update input line counters 
  sram_write
 	writes a number of bytes to the Edgeport device's sram starting at the
 	given address.
 	If successful returns the number of bytes written, otherwise it returns
 	a negative error number of the problem.
 need to split these writes up into 64 byte chunks 
		dev_dbg(&serial->dev->dev, "%s - writing %x, %x, %d\n", __func__, extAddr, addr, current_length); 
  rom_write
 	writes a number of bytes to the Edgeport device's ROM starting at the
 	given address.
 	If successful returns the number of bytes written, otherwise it returns
 	a negative error number of the problem.
 need to split these writes up into 64 byte chunks 
  rom_read
 	reads a number of bytes from the Edgeport device starting at the given
 	address.
 	Returns zero on success or a negative error number.
 need to split these reads up into 64 byte chunks 
  send_iosp_ext_cmd
 	Is used to send a IOSP message to the Edgeport device
 something bad happened, let's free up the memory 
  write_cmd_usb
 	this function writes the given buffer out to the bulk write endpoint.
 Allocate our next urb 
 something went wrong 
 command timed out 
  send_cmd_write_baud_rate
 	this function sends the proper command to change the baud rate of the
 	specified port.
 Alloc memory for the string of commands. 
 Enable access to divisor latch 
 Write the divisor itself 
 Restore original value to disable access to divisor latch 
 something bad happened, let's free up the memory 
  calc_baud_rate_divisor
 	this function calculates the proper baud rate divisor for the specified
 	baud rate.
	 We have tried all of the standard baud rates
	  lets try to calculate the divisor for this baud rate
 get divisor 
  send_cmd_write_uart_register
   this function builds up a uart register message and sends to the device.
 Alloc memory for the string of commands. 
 Build a cmd in the buffer to write the given register 
 something bad happened, let's free up the memory 
  change_port_settings
 	This routine is called to set the UART on the device to match the
 	specified new settings.
 figure out the flow control settings 
	 if we are implementing XONXOFF, set the start and stop character
 if we are implementing INBOUND XONXOFF 
 if we are implementing OUTBOUND XONXOFF 
 Set flow control to the configured value 
 Send the updated LCR value to the EdgePort 
 set up the MCR register and send it to the EdgePort 
 Determine divisor based on baud rate 
 pick a default, any default... 
 Speed change was not possible - put back the old speed 
  unicode_to_ascii
 	Turns a string from Unicode into ASCII.
 	Doesn't do a good job with any characters that are outside the normal
 	ASCII range, but it's only for debugging...
 	NOTE: expects the unicode in LE format
 never happens, but... 
 space for nul 
  get_manufacturing_desc
 	reads in the manufacturing descriptor and stores it into the serial
 	structure.
  get_boot_desc
 	reads in the bootloader descriptor and stores it into the serial
 	structure.
  load_application_firmware
 	This is called to load the application firmware to the device
  edge_startup
 create our private serial structure 
 get the name for the device from the device 
 Read the epic descriptor 
 memcpy descriptor to Supports structures 
 get the manufacturing descriptor for this device 
 get the boot descriptor 
 set the number of ports from the manufacturing description 
 serial->num_ports = serial->product_info.NumPorts; 
 If not an EPiC device 
 now load the application firmware into this device 
 Check current Edgeport EEPROM and update if necessary 
 set the configuration to use #1 
		dev_dbg(ddev, "set_configuration 1\n"); 
		usb_set_configuration (dev, 1); 
	 we set up the pointers to the endpoints in the edge_open function,
		 EPIC thing, set up our interrupt polling now and our read
 we found a interrupt in endpoint 
 not set up yet, so do it now 
 set up our interrupt urb 
 we found a bulk in endpoint 
 not set up yet, so do it now 
 set up our bulk in urb 
 we found a bulk out endpoint 
		 start interrupt read for this edgeport this interrupt will
  edge_disconnect
 	This function is called whenever the device is removed from the usb bus.
  edge_release
 	This function is called when the device structure is deallocated.
 SPDX-License-Identifier: GPL-2.0
  usb-serial driver for Quatech SSU-100
  based on ftdi_sio.c and the original serqt_usb.c from Quatech
 Quatech VID 
 SSU100 
 Terminating entry 
 these do not deal with device that have more than 1 port 
 no change 
 'set' takes precedence over 'clear' 
 will hold the new flags 
 set to 9600 
 Disable flow control 
 drop RTS and DTR 
 update input line counters 
		 we always want to update icount, but we only want to
 status only 
 SPDX-License-Identifier: GPL-2.0+
 	mxuport.c - MOXA UPort series driver
 	Copyright (c) 2006 Moxa Technologies Co., Ltd.
 	Copyright (c) 2013 Andrew Lunn <andrew@lunn.ch>
 	Supports the following Moxa USB to serial converters:
 	 2 ports : UPort 1250, UPort 1250I
 	 4 ports : UPort 1410, UPort 1450, UPort 1450I
 	 8 ports : UPort 1610-8, UPort 1650-8
 	16 ports : UPort 1610-16, UPort 1650-16
 Definitions for the vendor ID and device ID 
 Definitions for USB info 
 Definitions for firmware info 
 Definitions for USB vendor request 
 Set baud rate 
 Set line status 
 Set XonXoff chars 
 Set RTS 
 Set DTR 
 Set auto XonXoff 
 Set RX host enable 
 Set openclose port 
 Purge RxTx buffer 
 Set MCR register 
 Set Break signal 
 Start firmware download 
 Stop firmware download 
 Query if new firmware ready 
 Set fifo disable 
 Set interface 
 Set hi-performance 
 Erase flash block 
 Write flash page 
 Prepare write flash 
 Confirm write flash 
 Locate the device 
 Start firmware download 
 Rom file data 
 Stop firmware download 
 Firmware data 
 Try to reset the device 
 Get firmware version 
 Read flash page 
 Get ROM process state 
 Data in input buffer 
 Data in output buffer 
 Get modem status register 
 Definitions for UPort event type 
 None 
 Tx buffer threshold 
 Send next 
 Modem status 
 Line status 
 Modem control 
 Definitions for serial event type 
 CTS changed state 
 DSR changed state 
 RLSD changed state 
 Definitions for modem control event type 
 XOFF received 
 Definitions for line control of communication 
 Flag, not valid register value
 Definitions for holding reason 
 This structure holds all of the local port information 
 Last MCR state 
 Last MSR state 
 Protects mcr_state 
 Protects msr_state 
 Table of devices that work with this driver 
 Terminating entry 
  Add a four byte header containing the port number and the number of
  bytes of data in the message. Return the number of bytes in the
  buffer.
 Read the given buffer in from the control pipe. 
 Write the given buffer out to the control pipe.  
 Send a vendor request without any data 
  mxuport_throttle - throttle function of driver
  This function is called by the tty driver when it wants to stop the
  data being read from the port. Since all the data comes over one
  bulk in endpoint, we cannot stop submitting urbs by setting
  port->throttle. Instead tell the device to stop sending us data for
  the port.
  mxuport_unthrottle - unthrottle function of driver
  This function is called by the tty driver when it wants to resume
  the data being read from the port. Tell the device it can resume
  sending us received data from the port.
  Processes one chunk of data received for a port.  Mostly a copy of
  usb_serial_generic_process_read_urb().
 Update MSR status 
  When something interesting happens, modem control lines XONXOFF
  etc, the device sends an event. Process these events.
		
		  Sent as part of the flow control on device buffers.
		  Not currently used.
		
		  Event to indicate a change in XONXOFF from the
		  peer.  Currently not used. We just continue
		  sending the device data and it will buffer it if
		  needed. This event could be used for flow control
		  between the host and the device.
  One URB can contain data for multiple ports. Demultiplex the data,
  checking the port exists, is opened and the message is valid.
  One URB can contain events for multiple ports. Demultiplex the event,
  checking the port exists, and is opened.
  This is called when we have received data on the bulk in
  endpoint. Depending on which port it was received on, it can
  contain serial data or events.
  Ask the device how many bytes it has queued to be sent out. If
  there are none, return true.
		
		  Do not update mxport->mcr_state when doing hardware
		  flow control.
		
		  Should not happen, but somebody might try passing
		  MX_RTS_NO_CHANGE, which is not valid.
 0x002 
 0x004 
 0x020 
 0x040 
 0x080 
 0x100 
 SW flow control settings 
 HW flow control settings 
 Raise DTR and RTS 
 Drop DTR and RTS 
 Set data bit of termios 
 Set parity of termios 
 Set stop bit of termios 
 Note: Little Endian 
  Determine how many ports this device has dynamically.  It will be
  called after the probe() callback is called, but before attach().
	
	  Setup bulk-out endpoint multiplexing. All ports share the same
	  bulk-out endpoint.
 Get the version of the firmware currently running. 
 Get firmware version from SDRAM 
 Given a firmware blob, download it to the device. 
 Load our firmware 
 Use the firmware already in the device 
	
	  Contains the features of this hardware. Store away for
	  later use, eg, number of ports.
 Set the port private data 
 Set FIFO (Enable) 
 Set transmission mode (Hi-Performance) 
 Set interface (RS-232) 
	
	  All data from the ports is received on the first bulk in
	  endpoint, with a multiplex header. The second bulk in is
	  used for events.
	 
	  Start to read from the device.
 Set receive host (enable) 
 Initial port termios 
	
	  TODO: use RQ_VENDOR_GET_MSR, once we know what it
	  returns.
 Send a break to the port. 
 SPDX-License-Identifier: GPL-2.0+
  Infinity Unlimited USB Phoenix driver
  Copyright (C) 2010 James Courtier-Dutton (James@superbug.co.uk)
  Copyright (C) 2007 Alain Degreffe (eczema@ecze.com)
  Original code taken from iuutool (Copyright (C) 2006 Juan Carlos BorrÃ¡s)
   And tested with help of WB Electronics
 Terminating entry 
 turbo parameter 
 store irq state 
 store IUART SIGNAL for tiocmget call 
 if 1 reset is needed 
 number of poll 
 buffer for writing to device 
 num of byte to write to device 
 used for initialize speed 
 vcc (either 3 or 5 V) 
 FIXME: locking on tiomstatus 
 This is used to provide a carrier detect mechanism
  When a card is present, the response is 0x00
  When no card , the reader respond with TIOCM_CD
  This is known as CD autodetect mechanism
 error stop all 
 Prepare the reset sequence 
 send the sequence 
 Status Function
  Return value is
  0x00 = no card
  0x01 = smartcard
  0x02 = sim card
 error stop all 
 send the data out the bulk port 
 send the data out the bulk port 
 8bit 
 8bit 
 3bit 
 2bit 
 8bit 
 1bit 
 7bit 
 24bit = 3bytes 
 0x4C 
 Adr = 0x09 
 0x4C 
 Adr = 0x0C 
 0x4C 
 Adr = 0x12 
  0x4C 
 Adr = 0x13 
  0x4C 
 Adr = 0x40 
  0x4C 
 Adr = 0x41 
  0x4C 
 Adr = 0x42 
  0x4C 
 Adr = 0x44 
  0x4C 
 Adr = 0x45 
  0x4C 
 Adr = 0x46 
  0x4C 
 Adr = 0x47 
 reschedule needed 
 error stop all 
 if len > 0 call readbuf 
 need to update status  ? 
 reset waiting ? 
 Writebuf is waiting 
 if nothing to write call again rxcmd 
 fill the buffer 
 error stop all 
  iuu_reset() the card after iuu_uart_on() 
  Disables the IUU UART (a.k.a. the Phoenix voiderface) 
baud = (((priv->clk  35)  baud_base)  100000); 
  magic number here:  ENTER_FIRMWARE_UPDATE; 
  magic number here:  CHANGE_BAUD; 
 Just use the ospeed. ispeed should be the same. 
 compute the parity parameter 
 Using mark space 
 set it 
	 set the termios value to the real one, so the user now what has
	  changed. We support few fields so its easies to copy the old hw
	  settings back over and then adjust them
 Set failed - return old bits 
 Re-encode speed, parity and csize 
 iuu_led (port,255,0,0,0); 
  This is not UART related but IUU USB driver related or something 
  like that. Basically no IUU will accept any commands from the USB 
  host unless it has received the following message 
 sprintf(buf ,"%c%c%c%c",0x03,0x02,0x02,0x0); 
  3.680 Mhz 
  6.00 Mhz 
 Ratio of 6000000 to 3500000 for baud 9600 
  3.579 Mhz 
 set the cardin cardout signals 
 how to change VCC 
  Sysfs Attributes
  End Sysfs Attributes
 SPDX-License-Identifier: GPL-2.0+
  MaxLinearExar USB to Serial driver
  Copyright (c) 2020 Manivannan Sadhasivam <mani@kernel.org>
  Copyright (c) 2021 Johan Hovold <johan@kernel.org>
  Based on the initial driver written by Patong Yang:
    https:lore.kernel.orgr20180404070634.nhspvmxcjwfgjkcv@advantechmxl-desktop
    Copyright (c) 2018 Patong Yang <patong.mxl@gmail.com>
 XR21V141X register blocks 
 XR21V141X UART registers 
 XR21V141X UART Manager registers 
 zero-based index or interface number 
  According to datasheet, below is the recommended sequence for enabling UART
  module in XR21V141X:
  Enable Tx FIFO
  Enable Tx and Rx
  Enable Rx FIFO
	
	  Modem control pins are active low, so reading '0' means it is active
	  and '1' means not active.
 Modem control pins are active low, so set & clr are swapped 
 Writing '0' to gpio_{setclr} bits has no effect, so no need to do 
 Tx and Rx clock mask values obtained from section 3.3.4 of datasheet 
	
	  XR21V141X uses fractional baud rate generator with 48MHz internal
	  oscillator and 19-bit programmable divisor. So theoretically it can
	  generate most commonly used baud rates with high accuracy.
	
	  According to the datasheets, the UART needs to be disabled while
	  writing to the FLOW_CONTROL register (XR21V141X), or any register
	  but GPIO_SET, GPIO_CLEAR, TX_BREAK and ERROR_STATUS (XR21B142X).
 Set GPIO mode for controlling the pins manually by default. 
 CS5 and CS6 are not supported, so just restore old setting 
	
	  XR21V141X does not have a CUSTOM_DRIVER flag and always enters CDC
	  mode upon receiving CDC requests.
 Setup termios 
	
	  Configure all pins as GPIO except for Receive and Transmit Toggle.
	
	  Configure DTR and RTS as outputs and make sure they are deasserted
	  (active low), and configure RI, CD, DSR and CTS as inputs.
 SPDX-License-Identifier: GPL-2.0+
  Clean ups from Moschip version and a few ioctl implementations by:
 	Paul B Schroeder <pschroeder "at" uplogix "dot" com>
  Originally based on driversusbserialio_edgeport.c which is:
       Copyright (C) 2000 Inside Out Networks, All rights reserved.
       Copyright (C) 2001-2002 Greg Kroah-Hartman <greg@kroah.com>
  16C50 UART register defines
 5 bitschar 
 6 bitschar 
 7 bitschar 
 8 bitschar 
 Mask for bitschar field 
 1 stop bit 
 1.5 stop bits (if 5   bitschar) 
 2 stop bits   (if 6-8 bitschar) 
 Mask for stop bits field 
 No parity 
 Odd parity 
 Even parity 
 Force parity bit to 1 
 Force parity bit to 0 
 Mask for parity field 
 Set Break condition 
 Enable access to divisor latch 
 Assert DTR 
 Assert RTS 
 Loopback only: Sets state of RI 
 Enable interrupt outputs 
 Set internal (digital) loopback mode 
 Enable any char to exit XOFF mode 
 Current state of CTS 
 Current state of DSR 
 Current state of RI 
 Current state of CD 
  Defines used for sending commands to port
 default urb timeout 
 Requests 
 Zero_Flag_Reg1    58 
 Zero_Flag_Reg5    62 
 For higher baud Rates use TIOCEXBAUD 
  Vendor id and device id defines
  NOTE: Do not add new defines, add entries directly to the id_table instead.
 Interrupt Routine Defines    
   Emulation of the bit mask on the LINE STATUS REGISTER.
 Serial Port register Address 
  URB POOL related defines
 URB Count 
 URB Size  
 LED onoff milliseconds
 ATEN UC2324 
 ATEN UC2322 
 Moxa UPort 2210 
 ASIX MCS7810 
 MosChip MCS7820 
 MosChip MCS7840 
 ASIX MCS7840 3 port 
 terminating entry 
 This structure holds all of the local port information 
Actual port number in the device(1,2,etc) 
 read URB for this port 
 last LCR value received 
 last MCR value received 
 loop back to the owner of this object 
 Offsets 
 For device(s) with LED indicator 
 Timer for LED on 
 Timer for LED off 
  mos7840_set_reg_sync
  	To set the Control register by calling usb_fill_control_urb function
 	by passing usb_sndctrlpipe function as parameter.
  mos7840_get_reg_sync
  	To set the Uart register by calling usb_fill_control_urb function by
 	passing usb_rcvctrlpipe function as parameter.
  mos7840_set_uart_reg
 	To set the Uart register by calling usb_fill_control_urb function by
 	passing usb_sndctrlpipe function as parameter.
	 For the UART control registers, the application number need
  mos7840_get_uart_reg
 	To set the Control register by calling usb_fill_control_urb function
 	by passing usb_rcvctrlpipe function as parameter.
 Wval  is same as application number 
            U S B  C A L L B A C K   F U N C T I O N S                
            U S B  C A L L B A C K   F U N C T I O N S                
 Success 
 This urb is terminated, clean up 
 Turn off LED 
  mos7840_bulk_in_callback
 	this is the callback function for when we have received data on the
 	bulk in endpoint.
  mos7840_bulk_out_data_callback
 	this is the callback function for when we have finished sending
 	serial data on the bulk out endpoint.
       D R I V E R  T T Y  I N T E R F A C E  F U N C T I O N S       
  mos7840_open
 	this function is called by the tty driver when a port is opened
 	If successful, we return 0
 	Otherwise we return a negative error number.
 Initialising the write urb pool 
  Initialize MCS7840 -- Write Init values to corresponding Registers
  Register Index
  1 : IER
  2 : FCR
  3 : LCR
  4 : MCR
  0x08 : SP12 Control Reg
 NEED to check the following Block 
 End of block to be checked 
 Driver done bit 
 rx_disable 
 do register settings here 
 Set all regs to the device default values. 
	
	  First Disable all interrupts.
 Set FIFO_CONTROL_REGISTER to the default value 
 data latch enable in LCR 0x80 
 clearing Bulkin and Bulkout Fifo 
 Finally enable all interrupts 
 clearing rx_disable 
 rx_negate 
 set up our bulk in urb 
 initialize our port settings 
 Must set to enable ints! 
  mos7840_chars_in_buffer
 	this function is called by the tty driver when it wants to know how many
 	bytes of data we currently have outstanding in the port (data that has
 	been written, but hasn't made it out the port yet)
  mos7840_close
 	this function is called by the tty driver when a port is closed
 Freeing Write URBs 
  mos7840_break
 	this function sends a break to the port
 FIXME: no locking on shadowLCR anywhere in driver 
  mos7840_write_room
 	this function is called by the tty driver when it wants to know how many
 	bytes of data we can accept for a specific port.
  mos7840_write
 	this function is called by the tty driver when data should be written to
 	the port.
 	If successful, we return the number of bytes written, otherwise we
       return a negative error number.
 __u16 Data; 
 try to find a free urb in the list 
 fill urb with data and submit  
 send it down the pipe 
  mos7840_throttle
 	this function is called by the tty driver when it wants to stop the data
 	being read from the port.
 if we are implementing XONXOFF, send the stop character 
 if we are implementing RTSCTS, toggle that line 
  mos7840_unthrottle
 	this function is called by the tty driver when it wants to resume
 	the data being read from the port (called after mos7840_throttle is
 	called)
 if we are implementing XONXOFF, send the start character 
 if we are implementing RTSCTS, toggle that line 
 FIXME: What locks the port registers ? 
  mos7840_calc_baud_rate_divisor
 	this function calculates the proper baud rate divisor for the specified
 	baud rate.
  mos7840_send_cmd_write_baud_rate
 	this function sends the proper command to change the baud rate of the
 	specified port.
 reset clk_uart_sel in spregOffset 
 NOTE: need to see the pther register to modify 
 setting hw flow control bit to 1 
 setting hw flow control bit to 0 
 baudRate <= 115200) 
 Calculate the Divisor 
 Enable access to divisor latch 
 Write the divisor 
 Disable access to divisor latch 
  mos7840_change_port_settings
 	This routine is called to set the UART on the device to match
       the specified new settings.
 Change the number of bits 
 Change the Parity bit 
 Change the Stop bit 
 Update the LCR with the correct value 
 Disable Interrupts 
 Send the updated LCR value to the mos7840 
 set up the MCR register and send it to the mos7840 
 Determine divisor based on baud rate 
 pick a default, any default... 
 Enable Interrupts 
  mos7840_set_termios
 	this function is called by the tty driver when it wants to change
 	the termios structure
 change the port settings to the new ones specified 
  mos7840_get_lsr_info - get line status register info
  Purpose: Let user call ioctl() to get info when the UART physically
  	    is emptied.  On bus types like RS485, the transmitter must
  	    release the bus after transmitting. This must be done when
  	    the transmit shift register is empty, not be done when the
  	    transmit holding register is empty.  This functionality
  	    allows an RS485 driver to be written in user space.
  SerialIoctl
 	this function handles any ioctl calls to the driver
 return number of bytes available 
  Check if GPO (pin 42) is connected to GPI (pin 33) as recommended by ASIX
  for MCS7810 by bit-banging a 16-bit word.
  Note that GPO is really RTS of the third port so this will toggle RTS of
  port two or three on two- and four-port devices.
 failed to identify 7810 
 Store MCR setting 
 Send the 1-bit test pattern out to MCS7810 test pin 
 Read the test pattern back 
 If this is a MCS7810 device, both test patterns must match 
 Restore MCR setting 
 Skip device-type detection if we already have device flags. 
 For a MCS7840 device GPIO0 must be set to 1 
 Zero Length flag enable 
	 we set up the pointers to the endpoints in the mos7840_open 
	 Initialize all port interrupt end point to port 0 int
	  endpoint. Our device has only one interrupt end point
	 minor is not initialised until later by
	  usb-serial.c:get_free_serial() and cannot therefore be used
 Port 2 in the 2-port case uses registers of port 3 
 enable rx_disable bit in control register 
 setting driver done bit 
	Data |= 0x04;	 sp1_bit to have cts change reflect in
rx_disable bit 
	 Write default values in DCR (i.e 0x01 in DCR0, 0x05 in DCR2
 write values in clkstart0x0 and clkmulti 0x20 
 write value 0x0 to scratchpad register 
 Zero Length flag register 
 Initialize LED timers 
 Turn off LED 
 Turn off LED 
 SPDX-License-Identifier: GPL-2.0
  Qualcomm Serial USB driver
 	Copyright (c) 2008 QUALCOMM Incorporated.
 	Copyright (c) 2009 Greg Kroah-Hartman <gregkh@suse.de>
 	Copyright (c) 2009 Novell Inc.
 standard device layouts supported by this driver 
 Gobi 2000 
 Gobi 1000 
 Sierra Wireless 
 Huawei 
 Gobi 1000 devices 
 Acer Gobi QDL device 
 Acer Gobi Modem Device 
 HP un2400 Gobi Modem Device 
 HP un2400 Gobi QDL Device 
 Panasonic Gobi Modem device 
 Panasonic Gobi QDL device 
 Dell Gobi Modem device 
 Dell Gobi QDL device 
 NovatelVerizon USB-1000 
 Novatel Gobi Modem device 
 Novatel Gobi Modem device 
 Novatel Gobi Modem device 
 Novatel Gobi Modem device 
 Novatel Gobi Modem device 
 Novatel Gobi Modem device 
 Novatel Gobi QDL device 
 Asus Gobi Modem device 
 Asus Gobi QDL device 
 ONDA Gobi Modem device 
 ONDA Gobi QDL device 
 OQO Gobi QDL device 
 Generic Gobi Modem device 
 Generic Gobi Modem device 
 Generic Gobi Modem device 
 Generic Gobi Modem device 
 Generic Gobi Modem device 
 Generic Gobi QDL device 
 Generic Gobi Modem device 
 Generic Gobi QDL device 
 Generic Gobi QDL device 
 Generic Gobi QDL device 
 Unknown Gobi QDL device 
 Telit Gobi QDL device 
 Gobi 2000 devices 
 Novatel Gobi 2000 QDL device 
 Novatel Gobi 2000 QDL device 
 Novatel Gobi 2000 QDL device 
 Novatel Gobi 2000 QDL device 
 Novatel Gobi 2000 QDL device 
 Dell Gobi 2000 QDL device (N0218, VU936) 
 Dell Gobi 2000 Modem device (N0218, VU936) 
 Generic Gobi 2000 QDL device 
 Generic Gobi 2000 Modem device 
 Sony Gobi 2000 QDL device (N0279, VU730) 
 Sony Gobi 2000 Modem device (N0279, VU730) 
 Samsung Gobi 2000 QDL device (VL176) 
 Samsung Gobi 2000 Modem device (VL176) 
 HP Gobi 2000 QDL device (VP412) 
 HP Gobi 2000 Modem device (VP412) 
 Acer Gobi 2000 QDL device (VP413) 
 Acer Gobi 2000 Modem device (VP413) 
 Asus Gobi 2000 QDL device (VR305) 
 Asus Gobi 2000 Modem device (VR305) 
 Top Global Gobi 2000 QDL device (VR306) 
 Top Global Gobi 2000 Modem device (VR306) 
 iRex Technologies Gobi 2000 QDL device (VR307) 
 iRex Technologies Gobi 2000 Modem device (VR307) 
 Sierra Wireless Gobi 2000 QDL device (VT773) 
 Sierra Wireless Gobi 2000 Modem device (VT773) 
 Sierra Wireless Gobi 2000 Modem device (VT773) 
 Sierra Wireless Gobi 2000 Modem device (VT773) 
 Sierra Wireless Gobi 2000 Modem device (VT773) 
 Sierra Wireless Gobi 2000 Modem device (VT773) 
 Sierra Wireless Gobi 2000 Modem device (VT773) 
 Sierra Wireless Gobi 2000 Modem device (VT773) 
 Sierra Wireless Gobi 2000 Modem device (VT773) 
 Sierra Wireless Gobi 2000 Modem device (VT773) 
 Sierra Wireless Gobi 2000 Modem device (VT773) 
 Sierra Wireless Gobi 2000 Modem device (MC8305) 
 CMDTech Gobi 2000 QDL device (VU922) 
 CMDTech Gobi 2000 Modem device (VU922) 
 Gobi 2000 QDL device 
 Gobi 2000 Modem device 
 Gobi 3000 devices 
 HP un2430 Gobi 3000 QDL 
 Gobi 3000 QDL 
 Gobi 3000 Composite 
 Novatel Gobi 3000 QDL 
 Novatel Gobi 3000 Composite 
 Dell Gobi 3000 QDL 
 Dell Gobi 3000 Composite 
 Dell DW5570 QDL (MC8805) 
 Sierra Wireless QDL 
 Sierra Wireless Modem 
 Sierra Wireless QDL 
 Sierra Wireless Modem 
 Sierra Wireless Gobi 3000 QDL 
 Sierra Wireless Gobi 3000 QDL 
 Sierra Wireless Gobi 3000 Modem device (MC8355) 
 Sierra Wireless Gobi 3000 QDL 
 Sierra Wireless Gobi 3000 Modem device 
 Sierra Wireless Gobi 3000 QDL 
 Sierra Wireless Gobi 3000 Modem device 
 Sierra Wireless MC7770 
 Sony Gobi 3000 QDL 
 Sony Gobi 3000 Composite 
 Option GTM681W 
 non-Gobi Sierra Wireless devices 
 HP lt4111 LTEEV-DOHSPA+ Gobi 4G Module 
 Sierra Wireless MC7700 
 Sierra Wireless MC7750 
 Sierra Wireless MC7710 
 Sierra Wireless MC7304MC7354 
 Sierra Wireless EM7700 
 Sierra Wireless EM7355 QDL 
 Sierra Wireless EM7355 
 Sierra Wireless Modem 
 Sierra Wireless MC7305MC7355 
 Netgear AirCard 340U 
 Sierra Wireless Modem 
 Sierra Wireless Modem 
 Netgear AirCard 341U 
 Sierra Wireless Modem 
 Sierra Wireless Modem 
 Sierra Wireless Modem 
 Sierra Wireless EM7305 QDL 
 Sierra Wireless EM7305 
 Sierra Wireless MC74xx 
 Sierra Wireless MC74xx 
 Sierra Wireless EM74xx 
 Sierra Wireless EM74xx 
 Sierra Wireless EM74xx QDL 
 Sierra Wireless EM74xx 
 Sierra Wireless EM7565 QDL 
 Sierra Wireless EM7565 
 Sierra Wireless EM9191 QDL 
 Dell Wireless 5806 Gobi(TM) 4G LTE Mobile Broadband Card 
 Dell Wireless 5570 HSPA+ (42Mbps) Mobile Broadband Card 
 Dell Wireless 5570e HSPA+ (42Mbps) Mobile Broadband Card 
 Dell Wireless 5808 Gobi(TM) 4G LTE Mobile Broadband Card 
 Dell Wireless 5808e Gobi(TM) 4G LTE Mobile Broadband Card 
 Dell Wireless 5809e Gobi(TM) 4G LTE Mobile Broadband Card 
 Dell Wireless 5809e Gobi(TM) 4G LTE Mobile Broadband Card (rev3) 
 Dell Wireless 5811e QDL 
 Dell Wireless 5811e QDL 
 Dell Wireless 5816e QDL 
 Dell Wireless 5816e 
 Dell Wireless 5819 
 Dell Wireless 5819 
 Dell Wireless 5818 
 Dell Wireless 5818 
 Huawei devices 
 HP lt4112 LTEHSPA+ Gobi 4G Modem (Huawei me906e) 
 Terminating entry 
	
	  Quectel EC20 Mini PCIe LTE module layout:
	  0: DMDIAG (use libqcdm from ModemManager for communication)
	  1: NMEA
	  2: AT-capable modem port
	  3: Modem interface
	  4: NDIS
 Don't claim the QMInet interface 
 we only support vendor specific functions 
 QDL mode 
 Gobi 2000 has a single altsetting, older ones have two 
 Success 
 default to enabling interface 
	
	  Composite mode; don't bind to the QMInet interface as that
	  gets handled by other drivers.
		
		  Gobi 1K USB layout:
		  0: DMDIAG (use libqcdm from ModemManager for communication)
		  1: serial port (doesn't respond)
		  2: AT-capable modem port
		  3: QMInet
 handle non-standard layouts 
		
		  Gobi 2K+ USB layout:
		  0: QMInet
		  1: DMDIAG (use libqcdm from ModemManager for communication)
		  2: AT-capable modem port
		  3: NMEA
 Don't claim the QMInet interface 
			
			  NMEA (serial line 9600 8N1)
			  # echo "\$GPS_START" > devttyUSBx
			  # echo "\$GPS_STOP"  > devttyUSBx
		
		  Sierra Wireless layout:
		  0: DMDIAG (use libqcdm from ModemManager for communication)
		  2: NMEA
		  3: AT-capable modem port
		  8: QMInet
 don't claim any unsupported interface 
		
		  Huawei devices map functions by subclass + protocol
		  instead of interface numbers. The protocol identify
		  a specific function, while the subclass indicate a
		  specific firmware source
		 
		  This is a list of functions known to be non-serial.  The rest
		  are assumed to be serial and will be handled by this driver
 QMI combined (qmi_wwan) 
 QMI data (qmi_wwan) 
 QMI control (qmi_wwan) 
 NCM like (huawei_cdc_ncm) 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2007, Frank A Kingswood <frank@kingswood-consulting.co.uk>
  Copyright 2007, Werner Cornelius <werner@cornelius-consult.de>
  Copyright 2009, Boris Hajduk <boris@hajduk.org>
  ch341.c implements a serial port driver for the Winchiphead CH341.
  The CH341 device can be used to implement an RS232 asynchronous
  serial port, an IEEE-1284 parallel printer port or a memory-like
  interface. In all cases the CH341 supports an I2C interface as well.
  This driver only supports the asynchronous serial interface.
 flags for IO-Bits 
 interrupt pipe definitions 
 always 4 interrupt bytes 
 first irq byte normally 0x08 
 second irq byte base 0x7d + below 
 third irq byte base 0x94 + below 
 fourth irq byte normally 0xee 
 second interrupt byte 
 multiple status since last interrupt event 
 status returned in third interrupt answer byte, inverted in data
 all bits 
 Break support - the information used to implement this was gleaned from
  the NetFreeBSD uchcom.c driver by Takanori Watanabe.  Domo arigato.
 access lock 
 set baud rate 
 Supported range is 46 to 3000000 bps. 
  The device line speed is given by the following equation:
 	baudrate = 48000000  (2^(12 - 3  ps - fact)  div), where
 		0 <= ps <= 3,
 		0 <= fact <= 1,
 		2 <= div <= 256 if fact = 0, or
 		9 <= div <= 256 if fact = 1
	
	  Clamp to supported range, this makes the (ps < 0) and (div < 2)
	  sanity checks below redundant.
	
	  Start with highest possible base clock (fact = 1) that will give a
	  divisor strictly less than 512.
 Determine corresponding divisor, rounding down. 
 Some devices require a lower base clock if ps < 3. 
 Halve base clock (fact = 0) if required. 
	
	  Pick next divisor if resulting rate is closer to the requested one,
	  scale up to avoid rounding errors on low rates.
	
	  Prefer lower base clock (fact = 0) if even divisor.
	 
	  Note that this makes the receiver more tolerant to errors.
	
	  CH341A buffers data until a full endpoint-size packet (32 bytes)
	  has been received unless bit 7 is set.
	
	  Chip versions before version 0x30 as read using
	  CH341_REQ_READ_VERSION used separate registers for line control
	  (stop bits, parity and word length). Version 0x30 and above use
	  CH341_REG_LCR only and CH341_REG_LCR2 is always set to zero.
 -------------------------------------------------------------------------- 
 expect two bytes 0x27 0x00 
	
	  A subset of CH34x devices does not support all features. The
	  prescaler is limited and there is no support for sending a RS232
	  break condition. A read failure when trying to set up the latter is
	  used to detect these devices.
	
	  Some CH340 devices appear unable to change the initial LCR
	  settings, so set a sane 8N1 default.
 drop DTR and RTS 
 open this device, set default parameters 
 Old_termios contains the original termios settings and
  tty->termios contains the new setting to be used.
 redundant changes may cause the chip to lose bytes 
  A subset of all CH34x devices don't support a real break condition and
  reading CH341_REG_BREAK fails (see also ch341_detect_quirks). This function
  simulates a break condition by lowering the baud rate to the minimum
  supported by the hardware upon enabling the break condition and sending
  a NUL byte.
  Incoming data is corrupted while the break condition is being simulated.
  Normally the duration of the break condition can be controlled individually
  by userspace using TIOCSBRK and TIOCCBRK or by passing an argument to
  TCSBRKP. Due to how the simulation is implemented the duration can't be
  controlled. The duration is always about (1s  46bd  9bit) = 196ms.
		
		  Compute expected transmission duration including safety
		  margin. The original baud rate is only restored after the
		  computed point in time.
		 
		  11 bits = 1 start, 8 data, 1 stop, 1 margin
 Wait until NUL byte is written 
 Restore original baud rate 
 success 
 this urb is terminated, clean up 
 reconfigure ch341 serial port after bus-reset 
 SPDX-License-Identifier: GPL-2.0+
  Edgeport USB Serial Converter driver
  Copyright (C) 2000-2002 Inside Out Networks, All rights reserved.
  Copyright (C) 2001-2002 Greg Kroah-Hartman <greg@kroah.com>
  Supports the following devices:
 	EP1 EP2 EP4 EP21 EP22 EP221 EP42 EP421 WATCHPORT
  For questions or problems with this driver, contact Inside Out
  Networks technical support, or Peter Berger <pberger@brimson.com>,
  or Al Borchers <alborchers@steinerpoint.com>.
 different hardware types 
 IOCTL_PRIVATE_TI_GET_MODE Definitions 
 Device has not entered start device 
 Staying in boot mode		   
 Made it to download mode		   
#define TI_MODE_TRANSITIONING	3   
				      Currently in boot mode but
				      transitioning to download mode
 read urb state 
 Product information read from the Edgeport 
 Current TI Mode  
 Type of hardware 
  Edgeport firmware header
  "build_number" has been set to 0 in all three of the images I have
  seen, and Digi Tech Support suggests that it is safe to ignore it.
  "length" is the number of bytes of actual data following the header.
  "checksum" is the low order byte resulting from adding the values of
  all the data bytes.
	u32 ump_read_timeout;		
					  Number of milliseconds the UMP will
					  wait without data before completing
					  a read short
 Port type, 0: RS232, etc. 
 Type of I2C in UMP 
	u8 TiReadI2C;			
					  Set to TRUE if we have read the
					  I2c in Boot Mode
 Devices that this driver supports 
 The 4, 8 and 16 port devices show up as multiple 2 port devices 
 Devices that this driver supports 
 RS232 
 sysfs attributes 
  Some release of Edgeport firmware "down3.bin" after version 4.80
  introduced code to automatically disconnect idle devices on some
  Edgeport models after periods of inactivity, typically ~60 seconds.
  This occurs without regard to whether ports on the device are open
  or not.  Digi International Tech Support suggested:
  1.  Adding driver "heartbeat" code to reset the firmware timer by
      requesting a descriptor record every 15 seconds, which should be
      effective with newer firmware versions that require it, and benign
      with older versions that do not. In practice 40 seconds seems often
      enough.
  2.  The heartbeat code is currently required only on Edgeport416 models.
 Timeouts in msecs: firmware downloads take longer 
 clear txrx buffers and fifo in TI UMP 
  read_download_mem - Read edgeport memory from TI chip
  @dev: usb device pointer
  @start_address: Device CPU address at which to read
  @length: Length of above data
  @address_type: Can read both XDATA and I2C
  @buffer: pointer to input data buffer
	
	  Read in blocks of 64 bytes
	  (TI firmware can't handle more than 64 byte reads)
		
		  NOTE: Must use swab as wIndex is sent in little-endian
		        byte order regardless of host byte order.
 Update pointerslength 
 Read edgeport memory to a given block 
 Write given block to TI EPROM memory 
 Must do a read before write 
 Write edgeport I2C memory to TI chip	
 We can only send a maximum of 1 aligned byte page at a time 
 calculate the number of bytes left in the first page 
	
	  Write first page.
	 
	  NOTE: Must use swab as wIndex is sent in little-endian byte order
	        regardless of host byte order.
	
	  We should be aligned now -- can write max page size bytes at a
	  time.
		
		  Write next page.
		 
		  NOTE: Must use swab as wIndex is sent in little-endian byte
		        order regardless of host byte order.
  Examine the UMP DMA registers and LSR
  Check the MSBit of the X and Y DMA byte count registers.
  A zero in this bit indicates that the TX DMA buffers are empty
  then check the TX Empty bit in the UART.
	
	  Sigh, that's right, just one byte, as not all platforms can
	  do DMA from stack
 Read the DMA Count Registers 
 and the LSR 
 If either buffer has data or we are transmitting then return TRUE 
 We return Not Active if we get any kind of error 
	
	  There may be multiple configurations on this device, in which case
	  we would need to read and parse all of them to find out which one
	  we want. However, we just support one config at this point,
	  configuration # 1, which is Config Descriptor 0.
 Read a descriptor header from I2C based on type 
 Search for requested descriptor in I2C 
 Validate descriptor checksum 
 Make sure that the I2C image is good 
 Read the first byte (Signature0) must be 0x52 or 0x10 
 Validate the I2C 
 Skip type 2 record 
 Read the descriptor data 
 Read the descriptor data 
 Build firmware header used for firmware update 
	
	  In order to update the I2C firmware we must change the type 2 record
	  to type 0xF2.  This will force the UMP to come up in Boot Mode.
	  Then while in boot mode, the driver will download the latest
	  firmware (padded to 15.5k) into the UMP ram.  And finally when the
	  device comes back up in download mode the driver will cause the new
	  firmware to be copied from the UMP Ram to I2C and the firmware will
	  update the record type from 0xf2 to 0x02.
	
	  Allocate a 15.5k buffer + 2 bytes for version number (Firmware
	  Record)
 Set entire image of 0xffs 
 Copy version number into firmware record 
 Pointer to fw_down memory image 
 Build new header 
 Try to figure out what type of I2c we have 
 Try to read type 2 
 Try to read type 3 
 Download given firmware image to the device (IN BOOT MODE) 
 Transfer firmware image 
 Read the next buffer from file 
 Transfer data 
 Advance buffer pointer 
 FIXME!!! 
  DownloadTIFirmware - Download run-time operating firmware to the TI5052
  This routine downloads the main operating code into the TI5052, using the
  boot code already burned into E2PROM or ROM.
 If on-board version is newer, "fw_version" will be updated later. 
	
	  This routine is entered by both the BOOT mode and the Download mode
	  We can determine which code is running by the reading the config
	  descriptor and if we have only one bulk pipe it is in boot mode
 Default to type 2 i2c 
	
	  Setup initial mode -- the default mode 0 is TI_MODE_CONFIGURING
	  if we have more than one endpoint we are definitely in download
	  mode
 Otherwise we will remain in configuring mode 
	
	  Validate Hardware version number
	  Read Manufacturing Descriptor from TI Based Edgeport
 Check version number of ION descriptor 
 Search for type 2 record (firmware record) 
		
		  Validate version number
		  Read the descriptor data
		
		  Check version number of download with current
		  version in I2c
		
		  Check if we have an old version in the I2C and
		  update if necessary
			
			  In order to update the I2C firmware we must
			  change the type 2 record to type 0xF2. This
			  will force the UMP to come up in Boot Mode.
			  Then while in boot mode, the driver will
			  download the latest firmware (padded to
			  15.5k) into the UMP ram. Finally when the
			  device comes back up in download mode the
			  driver will cause the new firmware to be
			  copied from the UMP Ram to I2C and the
			  firmware will update the record type from
			  0xf2 to 0x02.
			
			  Change the I2C Firmware record type to
			  0xf2 to trigger an update
			
			  verify the write -- must do this in order
			  for write to complete before we do the
			  hardware reset
 Reset UMP -- Back to BOOT MODE 
 return an error on purpose. 
 Same or newer fw version is already loaded 
 Search for type 0xF2 record (firmware blank record) 
			
			  In order to update the I2C firmware we must change
			  the type 2 record to type 0xF2. This will force the
			  UMP to come up in Boot Mode.  Then while in boot
			  mode, the driver will download the latest firmware
			  (padded to 15.5k) into the UMP ram. Finally when the
			  device comes back up in download mode the driver
			  will cause the new firmware to be copied from the
			  UMP Ram to I2C and the firmware will update the
			  record type from 0xf2 to 0x02.
			
			  Update I2C with type 0xf2 record with correct
			  size and checksum
			
			  verify the write -- must do this in order for
			  write to complete before we do the hardware reset
 Tell firmware to copy download image into I2C 
 The device is running the download code 
 Configure the TI device so we can use the BULK pipes for download 
	
	  We have an ION device (I2c Must be programmed)
	  Determine I2C image type
 Check for ION Vendor ID and that the I2C is valid 
		
		  Validate Hardware version number
		  Read Manufacturing Descriptor from TI Based Edgeport
 Check for version 2 
		
		  In order to update the I2C firmware we must change the type
		  2 record to type 0xF2. This will force the UMP to come up
		  in Boot Mode.  Then while in boot mode, the driver will
		  download the latest firmware (padded to 15.5k) into the
		  UMP ram. Finally when the device comes back up in download
		  mode the driver will cause the new firmware to be copied
		  from the UMP Ram to I2C and the firmware will update the
		  record type from 0xf2 to 0x02.
		 
		  Do we really have to copy the whole firmware image,
		  or could we do this in place!
 Allocate a 15.5k buffer + 3 byte header 
 Initialize the buffer to 0xff (pad the buffer) 
 update length and checksum after padding 
 Download the operational code  
 Device will reboot 
 Eprom is invalid or blank stay in boot mode 
 1 or 0 not bitmask 
 Convert TI LSR to standard UART flags 
 overrun 
 parity error 
 framing error 
 break detected 
 rx data available 
 tx hold reg empty 
 update input line counters 
 Save the new modem status 
 handle CTS flow control 
		
		  Parity and Framing errors only count if they
		  occur exclusive of a break being received.
 Place LSR data byte into Rx buffer 
 update input line counters 
 success 
 this urb is terminated, clean up 
			
			  Save the LSR event for bulk read completion routine
 MSR 
 Copy MSR from UMP 
 success 
 this urb is terminated, clean up 
 Adjust buffer lengthpointer 
 continue read unless stopped 
 success 
 this urb is terminated, clean up 
 send any buffered data 
 turn off loopback 
 set up the port settings 
 open up the port 
 milliseconds to timeout for DMA transfer 
 milliseconds to timeout for DMA transfer 
 Tell TI to open and start the port 
 Start the DMA? 
 Clear TX and RX buffers in UMP 
 Read Initial MSR 
 Set Initial MCR 
 we are the first port to open, post the interrupt urb 
	
	  reset the data toggle on the bulk endpoints to work around bug in
	  host controllers where things get out of sync some times
 start up our bulk read urb 
	
	  The bulkreadcompletion routine will check
	  this flag and dump add read data
 last port is now closed, let's shut down our interrupt urb 
 set up our urb 
 send the data out the bulk port 
 TODO: reschedule edge_send 
	
	  wakeup any process waiting for writes to complete
	  there is now more room in the buffer for new writes
 if we are implementing XONXOFF, send the stop character 
	
	  if we are implementing RTSCTS, stop reads
	  and the Edgeport will clear the RTS line
 if we are implementing XONXOFF, send the start character 
	
	  if we are implementing RTSCTS, restart reads
	  are the Edgeport will assert the RTS line
 These flags must be set 
 figure out the flow control settings 
	
	  if we are implementing XONXOFF, set the start and stop
	  character in the device
 if we are implementing INBOUND XONXOFF 
 if we are implementing OUTBOUND XONXOFF 
 Round the baud rate 
 pick a default, any default... 
 Avoid a zero divisor. 
 FIXME: Recompute actual baud from divisor here 
 move the word values into big endian mode 
 change the port settings to the new ones specified 
 0x002 
 0x004 
 0x020 
 0x040 
 0x080 
 0x100 
 Off 
 On 
 Descriptor address request is enough to reset the firmware timer 
 Make sure we have the required endpoints when in download mode. 
 create our private serial structure 
 bind but do not register any ports 
 Currently only the EP416 models require heartbeat support 
	
	  The LSR does not tell when the transmitter shift register has
	  emptied so add a one-character drain delay.
 Sysfs Attributes 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2009 by Bart Hartgers (bart.hartgers+ark3116@gmail.com)
  Original version:
  Copyright (C) 2006
    Simon Schulz (ark3116_driver <at> auctionant.de)
  ark3116
  - implements a driver for the arkmicro ark3116 chipset (vendor=0x6547,
    productid=0x0232) (used in a datacable called KQ-U8A)
  Supports full modem status lines, break, hardware flow control. Does not
  support software flow control, since I do not know how to enable it in hw.
  This driver is a essentially new implementation. I initially dug
  into the old ark3116.c driver and suddenly realized the ark3116 is
  a 16450 with a USB interface glued to it. See comments at the
  bottom of this file.
 usb timeout of 1 second 
 USB to IrDA adapter 
 1 for irda device 
 protects hw register updates 
 baudrate divisor 
 line control register value 
	__u32			hcr;	 handshake control register (0x8)
 modem control register value 
 protects the status values below 
 modem status register value 
 line status register value 
 0xfe 0x40 are magic values taken from original driver 
 0xfe 0xc0 are magic values taken from original driver 
	 Original ark3116 made some exceptions in rounding here
	  because windows did the same. Assume that is not really
	  necessary.
	  Crystal is 12MHz, probably because of USB, but we divide by 4?
 setup the hardware 
 disable DMA 
 handshake control 
 modem control 
 setup baudrate 
 setup for 9600 8N1 
 device is closed, so URBs and DMA should be down 
 set data bit count 
 handshake control 
 calc baudrate 
 Update state: synchronize 
 keep old LCR_SBC bit 
 handshake control 
 baudrate 
 need to write lcr anyway 
		 disable DMA since transmitreceive is
		  shadowed by UART_DLL
 restore lcr 
		 magic baudrate thingy: not sure what it does,
		  but windows does this as well.
 enable DMA 
 check for software flow control 
 Don't rewrite B0 
 disable DMA 
 deactivate interrupts 
 remove any data still left: also clears error state 
 read modem status 
 read line status 
 activate interrupts 
 enable DMA 
 setup termios 
	 we need to take the mutex here, to make sure that the value
	  in priv->mcr is actually the one that is in the hardware
 LCR is also used for other things: protect access 
 update input line counters 
 combine bits 
 this urb is terminated, clean up 
 success 
 discovered this by trail and error... 
		
		  Not sure what this data meant...
 Data comes in via the bulk (data) URB, errorsinterrupts via the int URB.
  This means that we cannot be sure which data byte has an associated error
  condition, so we report an error for all data in the next bulk read.
  Actually, there might even be a window between the bulk data leaving the
  ark and readingresetting the lsr in the read_bulk_callback where an
  interrupt for the next data block could come in.
  Without somekind of ordering on the ark, we would have to report the
  error for the next block of data as well...
  For now, let's pretend this can't happen.
 update line status 
 overrun is special, not associated with a char 
  The following describes what I learned from studying the old
  ark3116.c driver, disassembling the windows driver, and some lucky
  guesses. Since I do not have any datasheet or other
  documentation, inaccuracies are almost guaranteed.
  Some specs for the ARK3116 can be found here:
  http:web.archive.orgweb20060318000438
    www.arkmicro.comenproductsview.php?id=10
  On that page, 2 GPIO pins are mentioned: I assume these are the
  OUT1 and OUT2 pins of the UART, so I added support for those
  through the MCR. Since the pins are not available on my hardware,
  I could not verify this.
  Also, it states there is "on-chip hardware flow control". I have
  discovered how to enable that. Unfortunately, I do not know how to
  enable XONXOFF (software) flow control, which would need support
  from the chip as well to work. Because of the wording on the web
  page there is a real possibility the chip simply does not support
  software flow control.
  I got my ark3116 as part of a mobile phone adapter cable. On the
  PCB, the following numbered contacts are present:
   1:- +5V
   2:o DTR
   3:i RX
   4:i DCD
   5:o RTS
   6:o TX
   7:i RI
   8:i DSR
  10:- 0V
  11:i CTS
  On my chip, all signals seem to be 3.3V, but 5V tolerant. But that
  may be different for the one you have ;-).
  The windows driver limits the registers to 0-F, so I assume there
  are actually 16 present on the device.
  On an UART interrupt, 4 bytes of data come in on the interrupt
  endpoint. The bytes are 0xe8 IIR LSR MSR.
  The baudrate seems to be generated from the 12MHz crystal, using
  4-times subsampling. So quot=12e6(4baud). Also see description
  of register E.
  Registers 0-7:
  These seem to be the same as for a regular 16450. The FCR is set
  to UART_FCR_DMA_SELECT (0x8), I guess to enable transfers between
  the UART and the USB bridgeDMA engine.
  Register 8:
  By trial and error, I found out that bit 0 enables hardware CTS,
  stopping TX when CTS is +5V. Bit 1 does the same for RTS, making
  RTS +5V when the 3116 cannot transfer the data to the USB bus
  (verified by disabling the reading URB). Note that as far as I can
  tell, the windows driver does NOT use this, so there might be some
  hardware bug or something.
  According to a patch provided here
  https:lore.kernel.orglkml200907261419.50702.linux@rainbow-software.org
  the ARK3116 can also be used as an IrDA dongle. Since I do not have
  such a thing, I could not investigate that aspect. However, I can
  speculate ;-).
  - IrDA encodes data differently than RS232. Most likely, one of
    the bits in registers 9..E enables the IR ENDEC (encoderdecoder).
  - Depending on the IR transceiver, the input and output need to be
    inverted, so there are probably bits for that as well.
  - IrDA is half-duplex, so there should be a bit for selecting that.
  This still leaves at least two registers unaccounted for. Perhaps
  The chip can do XONXOFF or CRC in HW?
  Register 9:
  Set to 0x00 for IrDA, when the baudrate is initialised.
  Register A:
  Set to 0x01 for IrDA, at init.
  Register B:
  Set to 0x01 for IrDA, 0x00 for RS232, at init.
  Register C:
  Set to 00 for IrDA, at init.
  Register D:
  Set to 0x41 for IrDA, at init.
  Register E:
  Somekind of baudrate override. The windows driver seems to set
  this to 0x00 for normal baudrates, 0x01 for 460800, 0x02 for 921600.
  Since 460800 and 921600 cannot be obtained by dividing 3MHz by an integer,
  it could be somekind of subdivisor thingy.
  However,it does not seem to do anything: selecting 921600 (divisor 3,
  reg E=2), still gets 1 MHz. I also checked if registers 9, C or F would
  work, but they don't.
  Register F: unknown
 SPDX-License-Identifier: GPL-2.0
  USB Driver for GSM modems
  Copyright (C) 2005  Matthias Urlichs <smurf@smurf.noris.de>
  Portions copied from the Keyspan driver by Hugh Blemings <hugh@blemings.org>
  History: see the git log.
  Work sponsored by: Sigos GmbH, Germany <info@sigos.de>
  This driver exists because the "normal" serial driver doesn't work too well
  with GSM modems. Issues:
  - data loss -- one single Receive URB is not nearly enough
  - nonstandard flow (Option devices) control
  - controlling the baud rate doesn't make sense
  This driver is named "option" because the most common device it's
  used for is a PC-Card (with an internal OHCI-USB interface, behind
  which the GSM interface sits), made by Option Inc.
  Some of the "one port" devices actually exhibit multiple USB instances
  on the USB bus. This is not a bug, these ports are used for different
  device features.
 Function prototypes 
 Vendor and product IDs 
 YISO PRODUCTS 
  NOVATEL WIRELESS PRODUCTS
  Note from Novatel Wireless:
  If your Novatel modem does not work on linux, don't
  change the option module, but check our website. If
  that does not help, contact ddeschepper@nvtl.com
 MERLIN EVDO PRODUCTS 
 MERLIN HSDPAHSPA PRODUCTS 
 EXPEDITE PRODUCTS 
 OVATION PRODUCTS 
  Note from Novatel Wireless:
  All PID in the 5xxx range are currently reserved for
  auto-install CDROMs, and should not be added to this
  module.
  #define NOVATELWIRELESS_PRODUCT_U727		0x5010
  #define NOVATELWIRELESS_PRODUCT_MC727_NEW	0x5100
 AMOI PRODUCTS 
 Dell modems 
 Novatel E362 
 Novatel E362 
 Novatel E371 
 These Quectel products use Qualcomm's vendor ID 
 These u-blox products use Qualcomm's vendor ID 
 These Yuga products use Qualcomm's vendor ID 
 These Quectel products use Quectel's vendor ID 
 ZTE PRODUCTS 
 TLAYTECH PRODUCTS 
 TOSHIBA PRODUCTS 
 Yes, ALINK_VENDOR_ID 
 ALCATEL PRODUCTS 
 Airplus products 
 LongcheerLongsung vendor ID; makes whitelabel devices that
  many other vendors like 4G Systems, Alcatel, ChinaBird,
  Mobidata, etc sell under their own brand names.
 4G Systems products 
 This is the 4G XS Stick W14 a.k.a. Mobilcom Debitel Surf-Stick 
 Fujisoft products 
 iBall 3.5G connect wireless modem 
 Zoom 
 SpeedUp SU9800 usb 3g modem 
 Haier products 
 Gemalto's Cinterion products (formerly Siemens) 
 same for HC28J 
 Olivetti products 
 Celot products 
 Samsung products 
 YUGA products  www.yuga-info.com gavin.kx@qq.com 
 Viettel products 
 ZD Incorporated 
 LG products 
 MediaTek products 
 Cellient products 
 Hyundai Petatel Inc. products 
 TP-LINK Incorporated products 
 Changhong products 
 Inovia 
 VIA Telecom 
 WeTelecom products 
 Device flags 
 Highest interface number which can be used with NCTRL() and RSVD() 
 Interface does not support modem-control requests 
 Interface is reserved 
 Interface must have two endpoints 
 Device needs ZLP 
 Huawei E1820 
 Motorola devices 
 mdm6600 
 mdm9600 
 mdm ram dl 
 mdm qc dl 
 Novatel Ovation MC551 a.k.a. Verizon USB551L 
 Dell Wireless 5700 Mobile Broadband CDMAEVDO Mini-Card == Novatel Expedite EV620 CDMAEV-DO 
 Dell Wireless 5500 Mobile Broadband HSDPA Mini-Card == Novatel Expedite EU740 HSDPA3G 
 Dell Wireless 5505 Mobile Broadband HSDPA Mini-Card == Novatel Expedite EU740 HSDPA3G 
 Dell Wireless 5700 Mobile Broadband CDMAEVDO ExpressCard == Novatel Merlin XV620 CDMAEV-DO 
 Dell Wireless 5510 Mobile Broadband HSDPA ExpressCard == Novatel Merlin XU870 HSDPA3G 
 Dell Wireless 5700 Mobile Broadband CDMAEVDO Mini-Card == Novatel Expedite E720 CDMAEV-DO 
 Dell Wireless 5700 Mobile Broadband CDMAEVDO Mini-Card == Novatel Expedite ET620 CDMAEV-DO 
 Dell Wireless 5720 == Novatel EV620 CDMAEV-DO 
 Dell Wireless 5720 == Novatel EV620 CDMAEV-DO 
 Dell Wireless 5720 == Novatel EV620 CDMAEV-DO 
 Dell Wireless HSDPA 5520 == Novatel Expedite EU860D 
 Dell Wireless HSDPA 5520 
 Dell Wireless 5520 Voda I Mobile Broadband (3G HSDPA) Minicard 
 Dell Wireless 5730 Mobile Broadband EVDOHSPA Mini-Card 
 Dell Wireless 5730 Mobile Broadband EVDOHSPA Mini-Card 
 Dell Wireless 5730 Mobile Broadband EVDOHSPA Mini-Card 
 ADU-E100, ADU-310 
 ZTE AC8700 
 4G LTE usb-modem U901 
 Onda H600ZTE MF330 
 ONYX 3G device 
 SIMCom SIM5218 
 Quectel products using Qualcomm vendor ID 
 Yuga products use Qualcomm vendor ID 
 u-blox products using Qualcomm vendor ID 
 Quectel products using Quectel vendor ID 
 EM160R-GL 
 Telit LE910C1-EUX 
 Telit LE910C1-EUX (ECM) 
 Telit FN980 (rmnet) 
 Telit FN980 (MBIM) 
 Telit FN980 (RNDIS) 
 Telit FN980 (ECM) 
 Telit FT980-KS 
 Telit FN980 (PCIe) 
 Telit FD980 
 Telit LN920 (rmnet) 
 Telit LN920 (MBIM) 
 Telit LN920 (RNDIS) 
 Telit LN920 (ECM) 
 Telit ME910 (ECM) 
 Telit ME910G1 
 Telit ME910G1 (ECM) 
 Telit LE910Cx (RNDIS) 
 Telit LE910Cx (MBIM) 
 Telit LE910Cx (rmnet) 
 Telit LE910Cx (RNDIS) 
 Telit LN940 (QMI) 
 Telit LN940 (MBIM) 
 Telit LE910-S1 (RNDIS) 
 Telit LE910-S1 (ECM) 
 Telit SBL FN980 flashing device 
 ZTE WCDMA products 
 ZTE EuFi890 
 ZTE MF820S 
 ZTE MF821 
 ONDA MT8205 
 ZTE MF880 
 Telewell TW-LTE 4G 
 GosunCn ZTE WeLink ME3630 (RNDIS mode) 
 GosunCn ZTE WeLink ME3630 (MBIM mode) 
 ZTE P685M 
 ZTE MF91 
 Telewell TW-LTE 4G v2 
 GosunCn ZTE WeLink ME3630 (ECMNCM mode) 
 ZTE MF871A 
 ZTE CDMA products 
 Yes, ALINK_VENDOR_ID 
 Toshiba 3G HSDPA == Novatel Expedite EU870D MiniCard 
 Simcom SIM7500SIM7600 MBIM mode 
 Simcom SIM7500SIM7600 RNDIS mode 
 Simcom SIM7070SIM7080SIM7090 AT+ECM mode 
 Simcom SIM7070SIM7080SIM7090 AT-only mode 
 Pirelli  
 Cinterion 
 HC28 enumerates with Siemens or Cinterion VID depending on FW revision 
 CT-650 CDMA 450 1xEVDO modem 
 Samsung GT-B3730 LTE USB modem.
 docomo L-02C modem 
 MediaTek MT6276M modem & app port 
 TP-Link LTE Module 
 TP-Link MA260 
 D-Link DWM-156 (variant) 
 D-Link DWM-158 
 D-Link DWM-157 C1 
 D-Link DWM-221 B1 
 D-Link DWM-222 
 D-Link DWM-222 A2 
 D-Link DWM-152C1 
 D-Link DWM-156C1 
 D-Link DWM-156A3 
 Wistron Neweb D19Q1 
 ASKEY WWHC050 
 Olicard 600 
 BroadMobi BM806U 
 BroadMobi BM818 
 OLICARD300 - MT6225 
 HP lt2523 (Novatel E371) 
 HP lt4132 (Huawei ME906s-158) 
 Foxconn T77W968 
 Foxconn T77W968 ESIM 
 Foxconn T99W265 MBIM 
 Fibocom NL668 (IOT version) 
 Fibocom NL678 series 
 Fibocom NL678 series 
 Fibocom FG150 Diag 
 Fibocom FG150 AT 
 Fibocom NL668-AMNL652-EU (laptop MBIM) 
 LongSung M5710 
 GosunCn GM500 RNDIS 
 GosunCn GM500 MBIM 
 GosunCn GM500 ECMNCM 
 Terminating entry 
 The card has three separate interfaces, which the serial driver
  recognizes separately, thus num_port=1.
 Never bind to the CD-Rom emulation interface	
	
	  Don't bind reserved interfaces (like network ones) which often have
	  the same classsubclassprotocol as the serial interfaces.  Look at
	  the Windows driver .INF files for reserved interface numbers.
	
	  Allow matching on bNumEndpoints for devices whose interface numbers
	  can change (e.g. Quectel EP06).
 Store the device flags so we can use them during attach. 
 Retrieve device flags stored at probe. 
 Resubmit urb so we continue receiving IRQ data 
 SPDX-License-Identifier: GPL-2.0
  Bus for USB Type-C Alternate Modes
  Copyright (C) 2018 Intel Corporation
  Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
 -------------------------------------------------------------------------- 
 Common API 
  typec_altmode_notify - Communication between the OS and alternate mode driver
  @adev: Handle to the alternate mode
  @conf: Alternate mode specific configuration value
  @data: Alternate mode specific data
  The primary purpose for this function is to allow the alternate mode drivers
  to tell which pin configuration has been negotiated with the partner. That
  information will then be used for example to configure the muxes.
  Communication to the other direction is also possible, and low level device
  drivers can also send notifications to the alternate mode drivers. The actual
  communication will be specific for every SVID.
  typec_altmode_enter - Enter Mode
  @adev: The alternate mode
  @vdo: VDO for the Enter Mode command
  The alternate mode drivers use this function to enter mode. The port drivers
  use this to inform the alternate mode drivers that the partner has initiated
  Enter Mode command. If the alternate mode does not require VDO, @vdo must be
  NULL.
 Moving to USB Safe State 
 Enter Mode 
  typec_altmode_exit - Exit Mode
  @adev: The alternate mode
  The partner of @adev has initiated Exit Mode command.
 Moving to USB Safe State 
 Exit Mode command 
  typec_altmode_attention - Attention command
  @adev: The alternate mode
  @vdo: VDO for the Attention command
  Notifies the partner of @adev about Attention command.
  typec_altmode_vdm - Send Vendor Defined Messages (VDM) to the partner
  @adev: Alternate mode handle
  @header: VDM Header
  @vdo: Array of Vendor Defined Data Objects
  @count: Number of Data Objects
  The alternate mode drivers use this function for SVID specific communication
  with the partner. The port drivers use it to deliver the Structured VDMs
  received from the partners to the alternate mode drivers.
 -------------------------------------------------------------------------- 
 API for the alternate mode drivers 
  typec_altmode_get_plug - Find cable plug alternate mode
  @adev: Handle to partner alternate mode
  @index: Cable plug index
  Increment reference count for cable plug alternate mode device. Returns
  handle to the cable plug alternate mode, or NULL if none is found.
  typec_altmode_put_plug - Decrement cable plug alternate mode reference count
  @plug: Handle to the cable plug alternate mode
 -------------------------------------------------------------------------- 
 API for the port drivers 
  typec_match_altmode - Match SVID and mode to an array of alternate modes
  @altmodes: Array of alternate modes
  @n: Number of elements in the array, or -1 for NULL terminated arrays
  @svid: Standard or Vendor ID to match with
  @mode: Mode to match with
  Return pointer to an alternate mode with SVID matching @svid, or NULL when no
  match is found.
 -------------------------------------------------------------------------- 
 Fail if the port does not support the alternate mode 
 SPDX-License-Identifier: GPL-2.0
  USB Type-C MultiplexerDeMultiplexer Switch support
  Copyright (C) 2018 Intel Corporation
  Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
          Hans de Goede <hdegoede@redhat.com>
	
	  Device graph (OF graph) does not give any means to identify the
	  device type or the device class of the remote port parent that @fwnode
	  represents, so in order to identify the type or the class of @fwnode
	  an additional device property is needed. With typec switches the
	  property is named "orientation-switch" (@id). The value of the device
	  property is ignored.
	
	  At this point we are sure that @fwnode is a typec switch in all
	  cases. If the switch hasn't yet been registered for some reason, the
	  function "defers probe" for now.
  fwnode_typec_switch_get - Find USB Type-C orientation switch
  @fwnode: The caller device node
  Finds a switch linked with @dev. Returns a reference to the switch on
  success, NULL if no matching connection was found, or
  ERR_PTR(-EPROBE_DEFER) when a connection was found but the switch
  has not been enumerated yet.
  typec_switch_put - Release USB Type-C orientation switch
  @sw: USB Type-C orientation switch
  Decrement reference count for @sw.
  typec_switch_register - Register USB Type-C orientation switch
  @parent: Parent device
  @desc: Orientation switch description
  This function registers a switch that can be used for routing the correct
  data pairs depending on the cable plug orientation from the USB Type-C
  connector to the USB controllers. USB Type-C plugs can be inserted
  right-side-up or upside-down.
  typec_switch_unregister - Unregister USB Type-C orientation switch
  @sw: USB Type-C orientation switch
  Unregister switch that was registered with typec_switch_register().
 ------------------------------------------------------------------------- 
	
	  Check has the identifier already been "consumed". If it
	  has, no need to do any extra connection identification.
 Accessory Mode muxes 
 Alternate Mode muxes 
  fwnode_typec_mux_get - Find USB Type-C Multiplexer
  @fwnode: The caller device node
  @desc: Alt Mode description
  Finds a mux linked to the caller. This function is primarily meant for the
  Type-C drivers. Returns a reference to the mux on success, NULL if no
  matching connection was found, or ERR_PTR(-EPROBE_DEFER) when a connection
  was found but the mux has not been enumerated yet.
  typec_mux_put - Release handle to a Multiplexer
  @mux: USB Type-C Connector MultiplexerDeMultiplexer
  Decrements reference count for @mux.
  typec_mux_register - Register Multiplexer routing USB Type-C pins
  @parent: Parent device
  @desc: Multiplexer description
  USB Type-C connectors can be used for alternate modes of operation besides
  USB when AccessoryAlternate Modes are supported. With some of those modes,
  the pins on the connector need to be reconfigured. This function registers
  multiplexer switches routing the pins on the connector.
  typec_mux_unregister - Unregister Multiplexer Switch
  @mux: USB Type-C Connector MultiplexerDeMultiplexer
  Unregister mux that was registered with typec_mux_register().
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2020, The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0
  USB Type-C Connector Class
  Copyright (C) 2017, Intel Corporation
  Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
 ------------------------------------------------------------------------- 
 Common attributes 
 Product types defined in USB PD Specification R3.0 V2.0 
 ------------------------------------------------------------------------- 
 Alternate Modes 
 Bind the port alt mode to the partnerplug alt mode. 
 Bind the partnerplug alt mode to the port alt mode. 
  typec_altmode_update_active - Report EnterExit mode
  @adev: Handle to the alternate mode
  @active: True when the mode has been entered
  If a partner or cable plug executes EnterExit Mode command successfully, the
  drivers use this routine to report the updated state of the mode.
  typec_altmode2port - Alternate Mode to USB Type-C port
  @alt: The Alternate Mode
  Returns handle to the port that a cable plug or partner with @alt is
  connected to.
 Make sure that the partner exits the mode before disabling 
 Note: If there is no driver, the mode will not be entered 
 Enabled by default 
 Link partners and plugs with the ports 
 The partners are bind to drivers 
 Plug alt modes need a class to generate udev events. 
  typec_unregister_altmode - Unregister Alternate Mode
  @adev: The alternate mode to be unregistered
  Unregister device created with typec_partner_register_altmode(),
  typec_plug_register_altmode() or typec_port_register_altmode().
 ------------------------------------------------------------------------- 
 Type-C Partners 
  typec_partner_set_identity - Report result from Discover Identity command
  @partner: The partner updated identity values
  This routine is used to report that the result of Discover Identity USB power
  delivery command has become available.
  typec_partner_set_pd_revision - Set the PD revision supported by the partner
  @partner: The partner to be updated.
  @pd_revision:  USB Power Delivery Specification Revision supported by partner
  This routine is used to report that the PD revision of the port partner has
  become available.
  typec_partner_set_num_altmodes - Set the number of available partner altmodes
  @partner: The partner to be updated.
  @num_altmodes: The number of altmodes we want to specify as available.
  This routine is used to report the number of alternate modes supported by the
  partner. This value is not enforced in alternate mode registration routines.
  @partner.num_altmodes is set to -1 on partner registration, denoting that
  a valid value has not been set for it yet.
  Returns 0 on success or negative error number on failure.
  typec_partner_register_altmode - Register USB Type-C Partner Alternate Mode
  @partner: USB Type-C Partner that supports the alternate mode
  @desc: Description of the alternate mode
  This routine is used to register each alternate mode individually that
  @partner has listed in response to Discover SVIDs command. The modes for a
  SVID listed in response to Discover Modes command need to be listed in an
  array in @desc.
  Returns handle to the alternate mode on success or ERR_PTR on failure.
  typec_partner_set_svdm_version - Set negotiated Structured VDM (SVDM) Version
  @partner: USB Type-C Partner that supports SVDM
  @svdm_version: Negotiated SVDM Version
  This routine is used to save the negotiated SVDM Version.
  typec_register_partner - Register a USB Type-C Partner
  @port: The USB Type-C Port the partner is connected to
  @desc: Description of the partner
  Registers a device for USB Type-C Partner described in @desc.
  Returns handle to the partner on success or ERR_PTR on failure.
		
		  Creating directory for the identity only if the driver is
		  able to provide data to it.
  typec_unregister_partner - Unregister a USB Type-C Partner
  @partner: The partner to be unregistered
  Unregister device created with typec_register_partner().
 ------------------------------------------------------------------------- 
 Type-C Cable Plugs 
  typec_plug_set_num_altmodes - Set the number of available plug altmodes
  @plug: The plug to be updated.
  @num_altmodes: The number of altmodes we want to specify as available.
  This routine is used to report the number of alternate modes supported by the
  plug. This value is not enforced in alternate mode registration routines.
  @plug.num_altmodes is set to -1 on plug registration, denoting that
  a valid value has not been set for it yet.
  Returns 0 on success or negative error number on failure.
  typec_plug_register_altmode - Register USB Type-C Cable Plug Alternate Mode
  @plug: USB Type-C Cable Plug that supports the alternate mode
  @desc: Description of the alternate mode
  This routine is used to register each alternate mode individually that @plug
  has listed in response to Discover SVIDs command. The modes for a SVID that
  the plug lists in response to Discover Modes command need to be listed in an
  array in @desc.
  Returns handle to the alternate mode on success or ERR_PTR on failure.
  typec_register_plug - Register a USB Type-C Cable Plug
  @cable: USB Type-C Cable with the plug
  @desc: Description of the cable plug
  Registers a device for USB Type-C Cable Plug described in @desc. A USB Type-C
  Cable Plug represents a plug with electronics in it that can response to USB
  Power Delivery SOP Prime or SOP Double Prime packages.
  Returns handle to the cable plug on success or ERR_PTR on failure.
  typec_unregister_plug - Unregister a USB Type-C Cable Plug
  @plug: The cable plug to be unregistered
  Unregister device created with typec_register_plug().
 Type-C Cables 
  typec_cable_get - Get a reference to the USB Type-C cable
  @port: The USB Type-C Port the cable is connected to
  The caller must decrement the reference count with typec_cable_put() after
  use.
  typec_cable_put - Decrement the reference count on USB Type-C cable
  @cable: The USB Type-C cable
  typec_cable_is_active - Check is the USB Type-C cable active or passive
  @cable: The USB Type-C Cable
  Return 1 if the cable is active or 0 if it's passive.
  typec_cable_set_identity - Report result from Discover Identity command
  @cable: The cable updated identity values
  This routine is used to report that the result of Discover Identity USB power
  delivery command has become available.
  typec_register_cable - Register a USB Type-C Cable
  @port: The USB Type-C Port the cable is connected to
  @desc: Description of the cable
  Registers a device for USB Type-C Cable described in @desc. The cable will be
  parent for the optional cable plug devises.
  Returns handle to the cable on success or ERR_PTR on failure.
		
		  Creating directory for the identity only if the driver is
		  able to provide data to it.
  typec_unregister_cable - Unregister a USB Type-C Cable
  @cable: The cable to be unregistered
  Unregister device created with typec_register_cable().
 ------------------------------------------------------------------------- 
 USB Type-C ports 
 --------------------------------------- 
 Driver callbacks to report role updates 
  typec_set_data_role - Report data role change
  @port: The USB Type-C Port where the role was changed
  @role: The new data role
  This routine is used by the port drivers to report data role changes.
  typec_set_pwr_role - Report power role change
  @port: The USB Type-C Port where the role was changed
  @role: The new data role
  This routine is used by the port drivers to report power role changes.
  typec_set_vconn_role - Report VCONN source change
  @port: The USB Type-C Port which VCONN role changed
  @role: Source when @port is sourcing VCONN, or Sink when it's not
  This routine is used by the port drivers to report if the VCONN source is
  changes.
  typec_set_pwr_opmode - Report changed power operation mode
  @port: The USB Type-C Port where the mode was changed
  @opmode: New power operation mode
  This routine is used by the port drivers to report changed power operation
  mode in @port. The modes are USB (default), 1.5A, 3.0A as defined in USB
  Type-C specification, and "USB Power Delivery" when the power levels are
  negotiated with methods defined in USB Power Delivery specification.
  typec_find_pwr_opmode - Get the typec power operation mode capability
  @name: power operation mode string
  This routine is used to find the typec_pwr_opmode by its string @name.
  Returns typec_pwr_opmode if success, otherwise negative error code.
  typec_find_orientation - Convert orientation string to enum typec_orientation
  @name: Orientation string
  This routine is used to find the typec_orientation by its string name @name.
  Returns the orientation value on success, otherwise negative error code.
  typec_find_port_power_role - Get the typec port power capability
  @name: port power capability string
  This routine is used to find the typec_port_type by its string name.
  Returns typec_port_type if success, otherwise negative error code.
  typec_find_power_role - Find the typec one specific power role
  @name: power role string
  This routine is used to find the typec_role by its string name.
  Returns typec_role if success, otherwise negative error code.
  typec_find_port_data_role - Get the typec port data capability
  @name: port data capability string
  This routine is used to find the typec_port_data by its string name.
  Returns typec_port_data if success, otherwise negative error code.
 ------------------------------------------ 
 API for MultiplexerDeMultiplexer Switches 
  typec_set_orientation - Set USB Type-C cable plug orientation
  @port: USB Type-C Port
  @orientation: USB Type-C cable plug orientation
  Set cable plug orientation for @port.
  typec_get_orientation - Get USB Type-C cable plug orientation
  @port: USB Type-C Port
  Get current cable plug orientation for @port.
  typec_set_mode - Set mode of operation for USB Type-C connector
  @port: USB Type-C connector
  @mode: Accessory Mode, USB Operation or Safe State
  Configure @port for Accessory Mode @mode. This function will configure the
  muxes needed for @mode.
 --------------------------------------- 
  typec_get_negotiated_svdm_version - Get negotiated SVDM Version
  @port: USB Type-C Port.
  Get the negotiated SVDM Version. The Version is set to the port default
  value stored in typec_capability on partner registration, and updated after
  a successful Discover Identity if the negotiated value is less than the
  default value.
  Returns usb_pd_svdm_ver if the partner has been registered otherwise -ENODEV.
  typec_get_drvdata - Return private driver data pointer
  @port: USB Type-C port
  typec_port_register_altmode - Register USB Type-C Port Alternate Mode
  @port: USB Type-C Port that supports the alternate mode
  @desc: Description of the alternate mode
  This routine is used to register an alternate mode that @port is capable of
  supporting.
  Returns handle to the alternate mode on success or ERR_PTR on failure.
 No altmodes specified 
  typec_register_port - Register a USB Type-C Port
  @parent: Parent device
  @cap: Description of the port
  Registers a device for USB Type-C Port described in @cap.
  Returns handle to the port on success or ERR_PTR on failure.
  typec_unregister_port - Unregister a USB Type-C Port
  @port: The port to be unregistered
  Unregister device created with typec_register_port().
 SPDX-License-Identifier: GPL-2.0
  USB Type-C Connector Class Port Mapping Utility
  Copyright (C) 2021, Intel Corporation
  Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	
	  To speed things up, first checking only the group_position. It seems
	  to often have the first unique value in the _PLD.
  typec_link_port - Link a port to its connector
  @port: The port device
  Find the connector of @port and create symlink named "connector" for it.
  Returns 0 on success, or errno in case of a failure.
  NOTE. The function increments the reference count of @port on success.
  typec_unlink_port - Unlink port from its connector
  @port: The port device
  Removes the symlink "connector" and decrements the reference count of @port.
 SPDX-License-Identifier: GPL-2.0
  STMicroelectronics STUSB160x Type-C controller family driver
  Copyright (C) 2020, STMicroelectronics
  Author(s): Amelie Delaunay <amelie.delaunay@st.com>
 RC 
 RW 
 RC 
 RO 
 RC 
 RO 
 RO 
 RC 
 RO 
 RW 
 RW 
 RW 
 RW 
 RW 
 RW 
 RO 
 RO 
 RW 
 RW 
 RO - Reserved 
 STUSB160X_ALERT_STATUSSTUSB160X_ALERT_STATUS_MASK_CTRL bitfields 
 STUSB160X_CC_CONNECTION_STATUS_TRANS bitfields 
 STUSB160X_CC_CONNECTION_STATUS bitfields 
 STUSB160X_MONITORING_STATUS_TRANS bitfields 
 STUSB160X_MONITORING_STATUS bitfields 
 STUSB160X_CC_OPERATION_STATUS bitfields 
 STUSB160X_HW_FAULT_STATUS_TRANS bitfields 
 STUSB160X_HW_FAULT_STATUS bitfields 
 STUSB160X_CC_CAPABILITY_CTRL bitfields 
 STUSB160X_VCONN_SWITCH_CTRL bitfields 
 STUSB160X_VCONN_MONITORING_CTRL bitfields 
 STUSB160X_VBUS_MONITORING_RANGE_CTRL bitfields 
 STUSB160X_RESET_CTRL bitfields 
 STUSB160X_VBUS_DISCHARGE_TIME_CTRL bitfields 
 STUSB160X_VBUS_DISCHARGE_STATUS bitfields 
 STUSB160X_VBUS_ENABLE_STATUS bitfields 
 STUSB160X_CC_POWER_MODE_CTRL bitfields 
 STUSB160X_VBUS_MONITORING_CTRL bitfields 
 Manage VCONN input supply 
 Manage VCONN monitoring and power path 
 Unmask CC_CONNECTION events 
 Change the default Type-C power mode 
 (chip->port_type == TYPEC_PORT_DRP) 
 Change the default Type-C Source power operation mode capability 
 Manage Type-C Source Vconn supply 
 Mask all events interrupts - to be unmasked with interrupt support 
 Read status at least once to clear any stale interrupts 
	
	  Supported port type can be configured through device tree
	  else it is read from chip registers in stusb160x_get_caps.
 Skip DRPSource capabilities in case of Sink only 
	
	  Supported power operation mode can be configured through device tree
	  else it is read from chip registers in stusb160x_get_caps.
 Power delivery not yet supported 
	
	  This fwnode has a "compatible" property, but is never populated as a
	  struct device. Instead we simply parse it to read the properties.
	  This it breaks fw_devlink=on. To maintain backward compatibility
	  with existing DT files, we work around this by deleting any
	  fwnode_links tofrom this fwnode.
	
	  When both VDD and VSYS power supplies are present, the low power
	  supply VSYS is selected when VSYS voltage is above 3.1 V.
	  Otherwise VDD is selected.
 Get configuration from chip 
 Get optional re-configuration from device tree 
	
	  Default power operation mode initialization: will be updated upon
	  attachdetach interrupt
		
		  If Source or Dual power role, need to enable VDD supply
		  providing Vbus if present. In case of interrupt support,
		  VDD supply will be dynamically managed upon attachdetach
		  interrupt.
 Mask interrupts 
 Check if attachdetach occurred during low power 
 Unmask interrupts 
 SPDX-License-Identifier: GPL-2.0+
  TI HD3SS3220 Type-C DRP Port Controller Driver
  Copyright (C) 2019 Renesas Electronics Corp.
 Register HD3SS3220_REG_CN_STAT_CTRL
 Register HD3SS3220_REG_GEN_CTRL
 For backward compatibility check the connector child node first 
 SPDX-License-Identifier: GPL-2.0
  USB Type-C Connector System Software Interface driver
  Copyright (C) 2017, Intel Corporation
  Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
  UCSI_TIMEOUT_MS - PPM communication timeout
  Ideally we could use MIN_TIME_TO_RESPOND_WITH_BUSY (which is defined in UCSI
  specification) here as reference, but unfortunately we can't. It is very
  difficult to estimate the time it takes for the system to process the command
  before it is actually passed to the PPM.
  UCSI_SWAP_TIMEOUT_MS - Timeout for role swap requests
  5 seconds is close to the time it takes for CapsCounter to reach 0, so even
  if the PPM does not generate Connector Change events before that with
  partners that do not support USB Power Delivery, this should still work.
 Acknowledge the command that failed 
 Restore UCSI notification enable mask after system resume 
 -------------------------------------------------------------------------- 
 -------------------------------------------------------------------------- 
 First get all the alternate modes 
		
		  We are collecting all altmodes first and then registering.
		  Some type-C device will return zero length data beyond last
		  alternate modes. We should not return if length is zero.
 We got all altmodes, now break out and register them 
	
	  Update the original altmode table as some ppms may report
	  multiple DP altmodes.
 now register altmodes 
		
		  This code is requesting one alt mode at a time, but some PPMs
		  may still return two. If that happens both alt modes need be
		  registered and the offset for the next alt mode has to be
		  incremented.
 UCSI max payload means only getting at most 4 PDOs at a time 
 number of bytes to 32-bit PDOs 
 get the remaining PDOs, if any 
 Ignoring the errors in this case. 
 Only notify USB controller if partner supports USB data 
 Complete pending power role swap 
 Complete pending data role swap 
  ucsi_connector_change - Process Connector Change Event
  @ucsi: UCSI Interface
  @num: Connector number
 -------------------------------------------------------------------------- 
 If the PPM is still doing something else, reset it again. 
 PPM most likely stopped responding. Resetting everything. 
 Something has gone wrong while swapping the role 
 Caller must call fwnode_handle_put() after use 
 Delay other interactions with the con until registration is complete 
 Get connector capability 
 Register the connector 
 Alternate modes 
 Get the status 
 ucsi_send_command() returns length on success 
 Check if there is already something connected 
 Only notify USB controller if partner supports USB data 
  ucsi_init - Initialize UCSI interface
  @ucsi: UCSI to be initialized
  Registers all ports @ucsi has and enables all notification events.
 Reset the PPM 
 Enable basic notifications 
 Get PPM capabilities 
 Allocate the connectors. Released in ucsi_unregister() 
 Register all connectors 
 Enable all notifications 
  ucsi_get_drvdata - Return private driver data pointer
  @ucsi: UCSI interface
  ucsi_set_drvdata - Assign private driver data pointer
  @ucsi: UCSI interface
  @data: Private data pointer
  ucsi_create - Allocate UCSI instance
  @dev: Device interface to the PPM (Platform Policy Manager)
  @ops: IO routines
  ucsi_destroy - Free UCSI instance
  @ucsi: UCSI instance to be freed
  ucsi_register - Register UCSI interface
  @ucsi: UCSI instance
  ucsi_unregister - Unregister UCSI interface
  @ucsi: UCSI interface to be unregistered
  Unregister UCSI interface that was created with ucsi_register().
 Make sure that we are not in the middle of driver initialization 
 Disable notifications 
 SPDX-License-Identifier: GPL-2.0
  UCSI DisplayPort Alternate Mode Support
  Copyright (C) 2018, Intel Corporation
  Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
  Note. Alternate mode control is optional feature in UCSI. It means that even
  if the system supports alternate modes, the OS may not be aware of them.
  In most cases however, the OS will be able to see the supported alternate
  modes, but it may still not be able to configure them, not even enter or exit
  them. That is because UCSI defines alt mode details and alt mode "overriding"
  as separate options.
  In case alt mode details are supported, but overriding is not, the driver
  will still display the supported pin assignments and configuration, but any
  changes the user attempts to do will lead into failure with return value of
  -EOPNOTSUPP.
	
	  We can't send the New CAM command yet to the PPM as it needs the
	  configuration value as well. Pretending that we have now entered the
	  mode, and letting the alt mode driver continue.
  We do not actually have access to the Status Update VDO, so we have to guess
  things.
	
	  If pin assignement D is supported, claiming always
	  that Multi-function is preferred.
 We can't rely on the firmware with the capabilities. 
 Claiming that we support all pin assignments 
 SPDX-License-Identifier: GPL-2.0
  UCSI driver for Cypress CCGx Type-C controller
  Copyright (C) 2017-2018 NVIDIA Corporation. All rights reserved.
  Author: Ajay Gupta <ajayg@nvidia.com>
  Some code borrowed from driversusbtypecucsiucsi_acpi.c
 bootloader 
 FW partition-1 (contains secondary fw) 
 FW partition-2 (contains primary fw) 
 CCGx events & async msg codes 
 ccg firmware 
 update secondary using bootloader 
 update primary using secondary 
 update secondary using primary 
 update not required 
  Firmware version 3.1.10 or earlier, built for NVIDIA has known issue
  of missing interrupt when a device is connected for runtime resume
 Altmode offset for NVIDIA Function Test Board (FTB) 
 CCGx response codes 
 ms delay for cmd timeout  
 version info for boot, primary and secondary 
 CCG HPI communication flags 
 to sync between user and driver thread 
 fw build with vendor information 
 check any max_read_len limitation on i2c adapter 
	
	  Flush CCGx RESPONSE queue by acking interrupts. Above ucsi control
	  register write will push response which must be cleared.
	
	  Copy original connector altmodes to new structure.
	  We need this before second loop since second loop
	  checks for duplicate altmodes.
 already checked and considered 
 Found Non DP altmode 
 Found duplicate DP mode 
 Didn't find any duplicate DP altmode 
	
	  If CAM is UCSI_MULTI_DP_INDEX then this is DP altmode
	  with multiple DP mode. Find out CAM for best pin assignment
	  among all DP mode. Priorite pin E->D->C after making sure
	  the partner supports that pin.
			
			  alt will always be non NULL since this is
			  UCSI_SET_NEW_CAM command and so there will be
			  at least one con->partner_altmode[i] with svid
			  matching with new_port->svid.
 prioritize pin E->D->C 
  Change the order of vdo values of NVIDIA test device FTB
  (Function Test Board) which reports altmode list with vdo=0x3
  first and then vdo=0x. Current logic to assign mode value is
  based on order in altmode list and it causes a mismatch of CON
  and SOP altmodes since NVIDIA GPU connector has order of vdo=0x1
  first and then vdo=0x3
 wait for interrupt status to get updated 
 Caller must hold uc->lock 
 Copy the data into the flash readwrite memory. 
 Use the FLASH_ROW_READ_WRITE register to trigger 
 writing of data to the desired flash row 
 Check if the fw build is for supported vendors 
 Check if the new fw build is for supported vendors 
	
	  check if signed fw
	  last part of fw image is fw cfg table and signature
 compare input version with FWCT version 
	
	  check if signed fw
	  last part of fw image is fw cfg table and signature
 flash fw config table and signature first 
	
	  CCG firmware image (.cyacd) file line format
	 
	  :00rrrrllll[dd....]ccrn
	 
	  :00   header
	  rrrr is row number to flash				(4 char)
	  llll is data len to flash				(4 char)
	  dd   is a data field represents one byte of data	(512 char)
	  cc   is checksum					(2 char)
	  \r\n newline
	 
	  Total length: 3 + 4 + 4 + 512 + 2 + 2 = 527
	 
  CCG4 has two copies of the firmware in addition to the bootloader.
  If the device is running FW1, FW2 can be updated with the new version.
  Dual firmware mode allows the CCG device to stay in a PD contract and support
  USB PD and Type-C functionality while a firmware update is in progress.
 Only fail FW flashing when FW build information is not provided 
 reset ccg device and initialize ucsi 
	
	  Firmware version 3.1.10 or earlier, built for NVIDIA has known issue
	  of missing interrupt when a device is connected for runtime resume.
	  Schedule a work to call ISR as a workaround.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  UCSI ACPI driver
  Copyright (C) 2017, Intel Corporation
  Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
 This will make sure we can use ioremap() 
	
	  NOTE: The memory region for the data structures is used also in an
	  operation region, which means ACPI has already reserved it. Therefore
	  it can not be requested here, and we can not use
	  devm_ioremap_resource().
 SPDX-License-Identifier: GPL-2.0
  Power Supply for UCSI
  Copyright (C) 2020, Intel Corporation
  Author: K V, Abhilash <abhilash.k.v@intel.com>
  Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
 Power Supply access to expose source power information 
 UCSI can't tell bw DCPCDP or USB23x13x2 SDP chargers 
 SPDX-License-Identifier: GPL-2.0
  USB Typec-C DisplayPort Alternate Mode driver
  Copyright (C) 2018 Intel Corporation
  Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
  DisplayPort is trademark of VESA (www.vesa.org)
 Pin assignments that use USB3.1 Gen2 signaling to carry DP protocol 
 Pin assignments that use DP v1.3 signaling to carry DP protocol 
 DP only pin assignments 
 Pin assignments where one channel is for USB 
 device lock 
 Only DP signaling supported 
 NOTE: First acting as DP source 
 Determining the initial pin assignment. 
 Is USB together with DP preferred 
 Only send Configure command if a configuration has been set 
 FIXME: Port can only be DFP_U. 
 Make sure we have compatiple pin configurations 
 typec_port fwnode 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 NVIDIA Corporation. All rights reserved.
  NVIDIA USB Type-C Alt Mode Driver
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2020 MediaTek Inc.
  Author: ChiYuan Huang <cy_huang@richtek.com>
 MT6360_REG_VCONNCTRL1 
 MT6360_REG_RXCTRL2 
 MT6360_REG_CTDCTRL2 
 after reset command, wait 1~2ms to wait IC action 
 write all alert to masked 
 config I2C timeout reset enable , and timeout to 200ms 
 config CC Detect Debounce : 26.7val us 
 DRP Toggle Cycle : 51.2 + 6.4val ms 
 DRP Duyt Ctrl : dcSRC: 1024 
 Enable VCONN Current Limit function 
 Enable cc open 40ms when pmic send vsysuv signal 
 Enable Rpdet oneshot detection 
 Set shipping mode off, AUTOIDLE on 
 SPDX-License-Identifier: GPL-2.0
  typec_wcove.c - WhiskeyCove PMIC USB Type-C PHY driver
  Copyright (C) 2017 Intel Corporation
  Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
 Register offsets 
 Register bits 
 device lock 
 Unmask everything 
 NOTE Setting maximum number of retries (7) 
 FIXME: Check that USBC_RXINFO_RXBYTES(info) matches the header 
 Read.. 
 ..check.. 
 REVISIT: Report an error? 
 REVISIT: Report an error? 
 REVISIT: See if tcpm code can be made to consider Type-C HW FSMs 
		
		  FIXME: Need to check if TX is ongoing and report
		  TX_DIREGARDED if needed?
 Flush all buffers 
 REVISIT: if (usbc_irq2 & USBC_IRQ2_RX_CR) 
 ..and clear. 
 REVISIT: Clear WhiskeyCove CHGR Type-C interrupt 
  The following power levels should be safe to use with Joule board.
 Mask everything 
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2015-2017 Google, Inc
  USB Type-C Port Controller Interface.
	
	  APPLY_RC state is when ROLE_CONTROL.CC1 != ROLE_CONTROL.CC2 and vbus autodischarge on
	  disconnect is disabled. Bail out when ROLE_CONTROL.CC1 != ROLE_CONTROL.CC2.
 Handle vendor drp toggling 
 Obtain Rp setting from role control 
	
	  When port has drp toggling enabled, ROLE_CONTROL would only have the initial
	  terminations for the toggling and does not indicate the final cc
	  terminations when ConnectionResult is 0 i.e. drp toggling stops and
	  the connection is resolved. Infer port role from TCPC_CC_STATUS based on the
	  terminations seen. The port role is then used to set the cc terminations.
 Disable DRP for the OPEN setting to take effect 
 Local port is source 
 Role control would have the Rp setting when DRP was enabled 
 Local port is source 
 Role control would have the Rp setting when DRP was enabled 
 Handle vendor set vconn 
	
	  Indicates that vbus is going to go away due PR_SWAP, hard reset etc.
	  Do not discharge vbus here.
 To prevent disconnect when the source is fast role swap is capable. 
 3.5V for non-pd sink 
 To prevent disconnect during FRS, set disconnect threshold to 3.5V 
 Bypass when ret > 0 
 Disable both source and sink first before enabling anything 
	
	  TCPCI spec forbids direct access of TCPC_TX_DATA.
	  But, since some of the chipsets offer this capability,
	  it's fair to support both.
 Payload + header + TCPC_TX_BYTE_CNT 
 nRetryCount is 3 in PD2.0 spec where 2 in PD3.0 spec 
 XXX 
 Handle vendor init 
 Clear all events 
 Enable Vbus detection 
 Enable VSAFE0V status interrupt when detecting VSAFE0V is supported 
	
	  Clear alert status for everything except RX_STATUS, which shouldn't
	  be cleared until we have successfully retrieved message.
		
		  If power status mask has been reset, then the TCPC
		  has reset.
		
		  'cnt' corresponds to READABLE_BYTE_COUNT in section 4.4.14
		  of the TCPCI spec [Rev 2.0 Ver 1.0 October 2017] and is
		  defined in table 4-36 as one greater than the number of
		  bytes received. And that number includes the header. So:
 Read complete, clear RX status alert bit 
 0x80 .. 0xFF are vendor defined 
 XXX 
 Disable chip interrupts before requesting irq 
 Disable chip interrupts before unregistering port 
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2016-2017 Google, Inc
  Fairchild FUSB302 Type-C Chip Driver
  When the device is SNK, BC_LVL interrupt is used to monitor cc pins
  for the current capability offered by the SRC. As FUSB302 chip fires
  the BC_LVL interrupt on PD signalings, cc lvl should be handled after
  a delay to avoid measuring on PD activities. The delay is slightly
  longer than PD_T_PD_DEBPUNCE (10-20ms).
 210mV 
 420mV 
 798mV 
 1638mV 
 1638mV 
 2604mV 
 lock for sharing chip states 
 chip status 
 port status 
 lock for log buffer access 
  Logging
  initialize interrupt on the chip
  - unmasked interrupt: VBUS_OK
	
	  USB2 Charger detection may still be in progress when we get here,
	  this can take upto 600ms, wait 800ms max.
 first disable toggling 
 mask interrupts for SRC or SNK 
 configure toggling mode: nonesnksrcdrp 
 mask TOGDONE interrupt 
 Datasheet says vconn MUST be off when toggling 
 unmask TOGDONE interrupt 
 start toggling 
 during toggling, consider cc as Open 
 reset the cc status 
 adjust current for SRC 
 enabledisable interrupts, BC_LVL for SNK and COMP_CHNG for SRC 
 SOP tokens 
 plug 2 for header 
 packsym tells the FUSB302 chip that the next X bytes are payload 
 CRC 
 EOP 
 turn tx off after sending message 
 start transmission 
 nRetryCount 3 in P2.0 spec, whereas 2 in PD3.0 spec 
 set polarity and pull_up, pull_down 
 fusb302_set_cc_polarity() has set the correct measure block 
 restart toggling if the cc status on the active line is OPEN 
 update tcpm with the new cc value 
 turn off toggling 
 unmask bc_lvl interrupt 
 On error returns < 0, otherwise a typec_cc_status value 
 Step 1: Set switches so that we measure the right CC pin 
 Step 2: Set compararator volt to differentiate between Open and Rd 
 Step 3: Set compararator input to differentiate between Rd and Ra. 
	
	  - set polarity (measure cc, vconn, tx)
	  - set pull_up, pull_down
	  - set cc1, cc2, and update to tcpm_port
	  - set I_COMP interrupt on
	
	  The toggle-engine will stop in a src state if it sees either Ra or
	  Rd. Determine the status for both CC pins, starting with the one
	  where toggling stopped, as that is where the switches point now.
 we must turn off toggling before we can measure the other pin 
 get the status of the other pin 
 determine polarity based on the status of both pins 
 set polarity and pull_up, pull_down 
 update tcpm with the new cc value 
 set MDAC to Rd threshold, and unmask I_COMP for unplug detection 
 unmask comp_chng interrupt 
 doesn't support 
 first SOP token 
 add 4 to length to include the CRC 
 another 4 bytes to read CRC out 
	
	  Check if we've read off a GoodCRC message. If so then indicate to
	  TCPM that the previous transmission has completed. Otherwise we pass
	  the received message over to TCPM for processing.
	 
	  We make this check here instead of basing the reporting decision on
	  the IRQ event type, as it's possible for the chip to report the
	  TX_SUCCESS and GCRCSENT events out of order on occasion, so we need
	  to check the message type to ensure correct reporting to TCPM.
 Disable our level triggered IRQ until our irq_work has cleared it 
 grab a snapshot of intr flags 
		
		  as BC_LVL interrupt can be affected by PD activity,
		  apply delay to for the handler to wait for the PD
		  signaling to finish.
 cc level > Rd_threshold, detach 
	
	  Devicetree platforms should get extcon via phandle (not yet
	  supported). On ACPI platforms, we get the name from a device prop.
	  This device prop is for kernel internal use only and is expected
	  to be set by the platform code which also registers the i2c client
	  for the fusb302.
 Make sure any pending irq_work is finished before the bus suspends 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2018, Richtek Technology Corporation
  Richtek RT1711H Type-C Chip Driver
 Autoidle timeout = (tout  2 + 1)  6.4ms 
 I2C timeout = (tout + 1)  12.5ms 
 0x80 .. 0xFF are vendor defined 
 CK 300K from 320K, shipping off, auto_idle enable, tout = 32ms 
 I2C reset : (val + 1)  12.5ms 
 tTCPCfilter : (26.7  val) us 
  tDRP : (51.2 + 6.4  val) ms 
 dcSRC.DRP : 33% 
 Clear cc change event triggered by starting toggling 
 Disable chip interrupts before requesting irq 
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2015-2017 Google, Inc
  USB Power Delivery protocol stack.
 Anything >0 represents an active state 
  Initial current capability of the new source when vSafe5V is applied during PD3.0 Fast Role Swap.
  Based on "Table 6-14 Fixed Supply PDO - Sink" of "USB Power Delivery Specification Revision 3.0,
  Version 1.2"
 Events from low level driver 
 Alternate mode support 
 current SVID index		
 number of alternate modes	
  @min_volt: Actual min voltage at the local port
  @req_min_volt: Requested min voltage to the port partner
  @max_volt: Actual max voltage at the local port
  @req_max_volt: Requested max voltage to the port partner
  @max_curr: Actual max current at the local port
  @req_max_curr: Requested max current of the port partner
  @req_out_volt: Requested output voltage to the port partner
  @req_op_curr: Requested operating current to the port partner
  @supported: Parter has at least one APDO hence supports PPS
  @active: PPS mode is active
 tcpm state machine lock 
 work only if pd_supported == false 
	
	  Set to true when vbus is greater than VSAFE5V min.
	  Set to false when vbus falls below vSinkDisconnect max threshold.
	
	  Set to true when vbus is less than VSAFE0V max.
	  Set to false when vbus is greater than VSAFE0V max.
 Set to true when Discover_Identity Command is expected to be sent in Ready states. 
 Set to true when VDM State Machine has following actions. 
 swap command lock 
 Partner capabilitiesrequests 
 Local capabilities 
 Requested current  voltage to the port partner 
 Actual current  voltage limit of the local port 
 Used to export TA voltage and current 
 PD state for Vendor Defined Messages 
 next Vendor Defined Message to send 
 VDO to retry if UFP responder replied busy 
 PPS 
 Alternate mode data 
 Deadline in jiffies to exit src_try_wait state 
 port belongs to a self powered device 
 Sink FRS 
 Sink caps have been queried 
 Collision Avoidance and Atomic Message Sequence 
 Auto vbus discharge status 
	
	  When set, port requests PD_P_SNK_STDBY_MW upon entering SNK_DISCOVERY and
	  the actual currrent limit after RX of PD_CTRL_PSRDY for PD link,
	  SNK_READY for non-pd link.
 log buffer access lock 
 Fall through to return SRC_UNATTACHED 
  Logging
 Do not log while disconnected and unattached 
	
	  TCPCI: Move to APPLY_RC state to prevent disconnect during PR_SWAP
	  when Vbus auto discharge on disconnect is enabled.
  Determine RP value to set based on maximum current supported
  by a port if configured as source.
  Returns CC value to report to link partner.
	
	  Search for first entry with matching voltage.
	  It should report the maximum supported current.
		
		  USB PD rev 2.0, 8.3.2.2.1:
		  USB PD rev 3.0, 8.3.2.1.3:
		  "... Note that every AMS is Interruptible until the first
		  Message in the sequence has been successfully sent (GoodCRC
		  Message received)."
 Some AMS don't expect responses. Finish them here. 
  Transform the PDO to be compliant to PD rev2.0.
  Return 0 if the PDO type is not defined in PD rev2.0.
  Otherwise, return the converted PDO.
 No source capabilities defined, sink only 
 No sink capabilities defined, source only 
		
		  Don't re-queue the state machine work item if we're currently
		  in the state machine and we're immediately changing states.
		  tcpm_state_machine_work() will continue running the state
		  machine.
 Interruptible AMS 
 Non-Interruptible AMS 
 tSinkTx is enforced in vdm_run_state_machine 
  VDMVDO handling functions
 Make sure we are not still processing a previous VDM packet 
 Set ready, vdm state machine will actually send 
 Already logged in svdm_consume_svids() 
			
			  PD2.0 Spec 6.10.3: respond with NAK as DFP (data host)
			  PD3.1 Spec 6.4.4.2.5.1: respond with NAK if "invalid field" or
			  "wrong configuation" or "Unrecognized"
 Attention command does not have response 
 silently drop message if we are not connected 
 6.4.4.3.1 
 6.4.4.3.2 
 6.4.4.3.3 
 Back to USB Operation 
 Unrecognized SVDM 
 Back to USB Operation 
 Unrecognized SVDM 
 Informing the alternate mode drivers about everything 
 If UFP responded busy retry after timeout 
		
		  Here a SVDM is received (INIT or RSP or unknown). Set the vdm_sm_running in
		  advance because we are dropping the lock but may send VDMs soon.
		  For the cases of INIT received:
		   - If no response to send, it will be cleared later in this function.
		   - If there are responses to send, it will be cleared in the state machine.
		  For the cases of RSP received:
		   - If no further INIT to send, it will be cleared later in this function.
		   - Otherwise, it will be cleared in the state machine if timeout or it will go
		     back here until no further INIT to send.
		  For the cases of unknown type received:
		   - We will send NAK and the flag will be cleared in the state machine.
	
	  We are done with any state stored in the port struct now, except
	  for any port struct changes done by the tcpm_queue_vdm() call
	  below, which is a separate operation.
	 
	  So we can safely release the lock here; and we MUST release the
	  lock here to avoid an AB BA lock inversion:
	 
	  If we keep the lock here then the lock ordering in this path is:
	  1. tcpm_pd_rx_handler take the tcpm port lock
	  2. One of the typec_altmode_ calls below takes the alt-mode's lock
	 
	  And we also have this ordering:
	  1. alt-mode driver takes the alt-mode's lock
	  2. alt-mode driver calls tcpm_altmode_enter which takes the
	     tcpm port lock
	 
	  Dropping our lock here avoids this.
	
	  We must re-take the lock here to balance the unlock in
	  tcpm_pd_rx_handler, note that no changes, other then the
	  tcpm_queue_vdm call, are made while the lock is held again.
	  All that is done after the call is unwinding the call stack until
	  we return to tcpm_pd_rx_handler and do the unlock there.
 set VDM header with VID & CMD 
 its not a structured VDM command 
 Only transmit VDM if attached 
		
		  if there's traffic or we're not in PDO ready state don't send
		  a VDM.
 TODO: AMS operation for Unstructured VDM 
		
		  A partner which does not support USB PD will not reply,
		  so this is not a fatal error. At the same time, some
		  devices may not return GoodCRC under some circumstances,
		  so we need to retry.
 Prepare and send VDM 
	
	  Continue running as long as the port is not busy and there was
	  a state change.
 Should at least contain vSafe5v 
 The vSafe5V Fixed Supply Object Shall always be the first object 
			
			  The remaining Fixed Supply Objects, if
			  present, shall be sent in voltage order;
			  lowest to highest.
			
			  The Battery Supply Objects and Variable
			  supply, if present shall be sent in Minimum
			  Voltage order; lowest to highest.
			
			  The Programmable Power Supply APDOs, if present,
			  shall be sent in Maximum Voltage order;
			  lowest to highest.
  PD (data, control) command handling functions
 Just handling non-battery alerts for now 
			
			  Do not check SinkTxOk here in case the Source doesn't set its Rp to
			  SinkTxOk in time.
 8.3.3.4.1.1 and 6.8.1 power transitioning 
 process the Message 6.8.1 
 PD 3.0 Spec 8.3.3.4.1.1 and 6.8.1 
 6.8.1 process the Message 
		
		  Adjust revision in subsequent message headers, as required,
		  to comply with 6.2.1.1.5 of the USB PD 3.0 spec. We don't
		  support Rev 1.0 so just do nothing in that scenario.
 Unexpected Source Capabilities 
		
		  This message may be received even if VBUS is not
		  present. This is quite unexpected; see USB PD
		  specification, sections 8.3.3.6.3.1 and 8.3.3.6.3.2.
		  However, at the same time, we must be ready to
		  receive this message and respond to it 15ms after
		  receiving PS_RDY during power swap operations, no matter
		  if VBUS is available or not (USB PD specification,
		  section 6.5.9.2).
		  So we need to accept the message either way,
		  but be prepared to keep waiting for VBUS after it was
		  handled.
		
		  Adjust revision in subsequent message headers, as required,
		  to comply with 6.2.1.1.5 of the USB PD 3.0 spec. We don't
		  support Rev 1.0 so just reject in that scenario.
 We don't do anything with this at the moment... 
 Unexpected Sink Capabilities 
 Currently unsupported 
	
	  Stop VDM state machine if interrupted by other Messages while NOT_SUPP is allowed in
	  VDM AMS if waiting for VDM responses and will be handled later.
				
				  Seen after power swap. Keep waiting for VBUS
				  in a transitional state.
 USB PD specification, Figure 8-43 
 Threshold was relaxed before sending Request. Restore it back. 
 Revert data back from any requested PPS updates 
 Threshold was relaxed before sending Request. Restore it back. 
		
		  XXX
		  6.3.9: If an alternate mode is active, a request to swap
		  alternate modes shall trigger a port reset.
 Currently not supported 
 stopping VDM state machine if interrupted by other Messages 
 unexpected Status or PPS_Status Message 
		
		  USB PD standard, 6.6.1.2:
		  "... if MessageID value in a received Message is the
		  same as the stored value, the receiver shall return a
		  GoodCRC Message with that MessageID value and drop
		  the Message (this is a retry of an already received
		  Message). Note: this shall not apply to the Soft_Reset
		  Message which always has a MessageID value of zero."
		
		  If both ends believe to be DFPhost, we have a data role
		  mismatch.
  Send queued message without affecting state.
  Return true if state machine should go back to sleep,
  false otherwise.
	
	  Select the source PDO providing the most power which has a
	  matchig sink cap.
 Prefer higher voltages if available 
	
	  Select the source PPS APDO providing the most power while staying
	  within the board's limits. We skip the first PDO as this is always
	  5V 3A.
			
			  Now search through the sink PDOs to find a matching
			  PPS APDO. Again skip the first sink PDO as this will
			  always be 5V 3A.
 Prefer higher voltages if available 
 Select maximum available current within the sink pdo's limit 
 Set mismatch bit if offered power is less than operating power 
	
	  Relax the threshold as voltage will be adjusted after Accept Message plus tSrcTransition.
	  It is safer to modify the threshold here.
		
		  Try raising current to meet power needs. If that's not enough
		  then try upping the voltage. If that's still not enough
		  then we've obviously chosen a PPS APDO which really isn't
		  suitable so abandon ship.
 Relax the threshold as voltage will be adjusted right after Accept Message. 
 Make sure we don't report stale identity information 
	
	  USB Type-C specification, version 1.2,
	  chapter 4.5.2.2.8.1 (Attached.SRC Requirements)
	  Enable VCONN only if the non-RD port is set to RA.
	
	  First Rx ID should be 0; set this to a sentinel of -1 so that
	  we can check tcpm_pd_rx_handler() if we had seen it before.
 also disables charging 
 SRC states 
		
		  Requirements:
		  - Do not drive vconn or vbus
		  - Terminate CC pins (both) to Rd
		  Action:
		  - Wait for tDRPTry (PD_T_DRP_TRY).
		    Until then, ignore any state changes.
 SNK -> SRC POWERFAST_ROLE_SWAP finished 
			
			  Per standard, we should clear the reset counter here.
			  However, that can result in state machine hang-ups.
			  Reset it only in READY state to improve stability.
 port->hard_reset_count = 0; 
		
		  Error recovery for a PD_DATA_SOURCE_CAP reply timeout.
		 
		  PD 2.0 sinks are supposed to accept src-capabilities with a
		  3.0 header and simply ignore any src PDOs which the sink does
		  not understand such as PPS but some 2.0 sinks instead ignore
		  the entire PD_DATA_SOURCE_CAP message, causing contract
		  negotiation to fail.
		 
		  After PD_N_HARD_RESET_COUNT hard-reset attempts, we try
		  sending src-capabilities with a lower PD revision to
		  make these broken sinks work.
 XXX: regulator_set_voltage(vbus, ...) 
		
		  If previous AMS is interrupted, switch to the upcoming
		  state.
		
		  6.4.4.3.1 Discover Identity
		  "The Discover Identity Command Shall only be sent to SOP when there is an
		  Explicit Contract."
		  For now, this driver only supports SOP for DISCOVER_IDENTITY, thus using
		  port->explicit_contract to decide whether to send the command.
		
		  6.3.5
		  Sending ping messages is not necessary if
		  - the source operates at vSafe5V
		  or
		  - The system is not operating in PD mode
		  or
		  - Both partners are connected using a Type-C connector
		 
		  There is no actual need to send PD messages since the local
		  port type-c and the spec does not clearly say whether PD is
		  possible when type-c is connected to Type-AB
 Nothing to do... 
 SNK states 
 Wait for VBUS, but not forever 
		
		  TCPM stays in this state indefinitely until VBUS
		  is detected as long as Rp is not detected for
		  more than a time period of tPDDebounce.
 SRC -> SNK POWERFAST_ROLE_SWAP finished 
		
		  For DRP, timeouts differ. Also, handling is supposed to be
		  different and much more complex (dead battery detection;
		  see USB power delivery specification, section 8.3.3.6.1.5.1).
		
		  If VBUS has never been low, and we time out waiting
		  for source cap, try a soft reset first, in case we
		  were already in a stable contract before this boot.
		  Do this only once.
 Restore back to the original state 
 Let the Source send capabilities again. 
 Restore back to the original state 
			
			  If this was called due to updates to sink
			  capabilities, and pps is no longer valid, we should
			  safely fall back to a standard PDO.
		 From the USB PD spec:
		  "The Sink Shall transition to Sink Standby before a positive or
		  negative voltage transition of VBUS. During Sink Standby
		  the Sink Shall reduce its power draw to pSnkStdby."
		 
		  This is not applicable to PPS though as the port can continue
		  to draw negotiated power without switching to standby.
		
		  If previous AMS is interrupted, switch to the upcoming
		  state.
		
		  6.4.4.3.1 Discover Identity
		  "The Discover Identity Command Shall only be sent to SOP when there is an
		  Explicit Contract."
		  For now, this driver only supports SOP for DISCOVER_IDENTITY, thus using
		  port->explicit_contract.
 Accessory states 
 Hard_Reset states 
		
		  State machine will be directed to HARD_RESET_START,
		  thus set upcoming_state to INVALID_STATE.
		
		  7.1.5 Response to Hard Resets
		  Hard Reset Signaling indicates a communication failure has occurred and the
		  Source Shall stop driving VCONN, Shall remove Rp from the VCONN pin and Shall
		  drive VBUS to vSafe0V as shown in Figure 7-9.
		
		  If tcpc fails to notify vbus off, TCPM will wait for PD_T_SAFE_0V +
		  PD_T_SRC_RECOVER before turning vbus back on.
		  From Table 7-12 Sequence Description for a Source Initiated Hard Reset:
		  4. Policy Engine waits tPSHardReset after sending Hard Reset Signaling and then
		  tells the Device Policy Manager to instruct the power supply to perform a
		  Hard Reset. The transition to vSafe0V Shall occur within tSafe0V (t2).
		  5. After tSrcRecover the Source applies power to VBUS in an attempt to
		  re-establish communication with the Sink and resume USB Default Operation.
		  The transition to vSafe5V Shall occur within tSrcTurnOn(t4).
 Do not dischargedisconnect during hard reseet 
		
		  VBUS may or may not toggle, depending on the adapter.
		  If it doesn't toggle, transition to SNK_HARD_RESET_SINK_ON
		  directly after timeout.
 Assume we're disconnected if VBUS doesn't come back. 
 Note: There is no guarantee that VBUS is on in this state 
		
		  XXX:
		  The specification suggests that dual mode ports in sink
		  mode should transition to state PE_SRC_Transition_to_default.
		  See USB power delivery specification chapter 8.3.3.6.1.3.
		  This would mean to to
		  - turn off VCONN, reset power supply
		  - request hardware reset
		  - turn on VCONN
		  - Transition to state PE_Src_Startup
		  SNK only ports shall transition to state Snk_Startup
		  (see chapter 8.3.3.3.8).
		  Similar, dual-mode ports in source mode should transition
		  to PE_SNK_Transition_to_default.
 Soft_Reset states 
 DR_Swap states 
 PR_Swap states 
		
		  Prevent vbus discharge circuit from turning on during PR_SWAP
		  as this is not a disconnect.
 allow time for Vbus discharge, must be < tSrcSwapStdby 
 allow CC debounce 
		
		  USB-PD standard, 6.2.1.4, Port Power Role:
		  "During the Power Role Swap Sequence, for the initial Source
		  Port, the Port Power Role field shall be set to Sink in the
		  PS_RDY Message indicating that the initial Source’s power
		  supply is turned off"
 Set the vbus disconnect threshold for implicit contract 
		
		  Prevent vbus discharge circuit from turning on during PR_SWAP
		  as this is not a disconnect.
		
		  allow time VBUS ramp-up, must be < tNewSrc
		  Also, this window overlaps with CC debounce as well.
		  So, Wait for the max of two which is PD_T_NEWSRC
		
		  USB PD standard, 6.2.1.4:
		  "Subsequent Messages initiated by the Policy Engine,
		  such as the PS_RDY Message sent to indicate that Vbus
		  is ready, will have the Port Power Role field set to
		  Source."
 AMS intermediate state 
 Chunk state 
 If we were queued due to a delayed state change, update it now 
	
	  Continue running as long as we have (non-delayed) state changes
	  to make.
		
		  EXIT condition is based primarily on vbus disconnect and CC is secondary.
		  "A port that has entered into USB PD communications with the Source and
		  has seen the CC voltage exceed vRd-USB may monitor the CC pin to detect
		  cable disconnect in addition to monitoring VBUS.
		 
		  A port that is monitoring the CC voltage for disconnect (but is not in
		  the process of a USB PD PR_Swap or USB PD FR_Swap) shall transition to
		  Unattached.SNK within tSinkDisconnect after the CC voltage remains below
		  vRd-USB for tPDDebounce."
		 
		  When set_auto_vbus_discharge_threshold is enabled, CC pins go
		  away before vbus decays to disconnect threshold. Allow
		  disconnect to be driven by vbus disconnect when auto vbus
		  discharge is enabled.
 Do nothing, waiting for timeout 
 CC line is unstable, wait for debounce 
 Hand over to state machine if needed 
 Do nothing, waiting for tCCDebounce 
		
		  CC state change is expected in PR_SWAP
		  Ignore it.
 Do nothing, CC change expected 
		
		  State set back to default mode once the timer completes.
		  Ignore CC changes here.
		
		  While acting as sink and auto vbus discharge is enabled, Allow disconnect
		  to be driven by vbus disconnect.
	
	  When vbus_present is true i.e. Voltage at VBUS is greater than VSAFE5V implicitly
	  states that vbus is not at VSAFE0V, hence clear the vbus_vsafe0v flag here.
 Do nothing, waiting for timeout 
 Do nothing, Waiting for Rd to be detected 
 Do nothing, waiting for PD_DEBOUNCE to do be done 
 Do nothing, waiting for tCCDebounce 
 Do nothing, waiting for Rp 
 Do nothing, waiting for sink detection 
		
		  State set back to default mode once the timer completes.
		  Ignore vbus changes here.
 Do nothing, waiting for timeout 
 Hand over to state machine if needed 
 Do nothing, waiting for PD_DEBOUNCE to do be done 
 Do nothing, expected 
		
		  Do nothing when vbus off notification is received.
		  TCPM can wait for PD_T_NEWSRC in PR_SWAP_SNK_SRC_SOURCE_ON
		  for the vbus source to ramp up.
 Do nothing, waiting for sink detection 
		
		  Force to unattached state to re-initiate connection.
		  DRP port should move to Unattached.SNK instead of Unattached.SRC if
		  sink removed. Although sink removal here is due to source's vbus collapse,
		  treat it the same way for consistency.
		
		  State set back to default mode once the timer completes.
		  Ignore vbus changes here.
 Do nothing, vbus drop expected 
		
		  After establishing the vSafe0V voltage condition on VBUS, the Source Shall wait
		  tSrcRecover before re-applying VCONN and restoring VBUS to vSafe5V.
 Do nothing, vsafe0v is expected during transition 
	
	  If we keep receiving hard reset requests, executing the hard reset
	  must have failed. Revert to error recovery if that happens.
				
				  When TCPC does not support detecting vsafe0v voltage level,
				  treat vbus absent as vsafe0v. Else invoke is_vbus_vsafe0v
				  to see if vbus has discharge to VSAFE0V.
			
			  In fast role swap case TCPC autonomously sources vbus. Set vbus_source
			  true as TCPM wouldn't have called tcpm_set_vbus.
			 
			  When vbus is sourced on the command on TCPM i.e. TCPM called
			  tcpm_set_vbus to source vbus, vbus_source would already be true.
 Not FRS capable 
 Sink caps queried 
 Send when the state machine is idle 
 No need to send DISCOVER_IDENTITY anymore 
 Retry if the port is not idle 
	
	  XXX
	  6.3.9: If an alternate mode is active, a request to swap
	  alternate modes shall trigger a port reset.
	  Reject data role swap request in this case.
		
		  If the partner is not PD capable, reset the port to
		  trigger a role change. This can only work if a preferred
		  role is configured, and if it matches the requested role.
 Round down operating current to align with PPS valid steps 
 Round down output voltage to align with PPS valid steps 
 Trying to deactivate PPS when already deactivated so just bail 
 Trigger PPS request or move back to standard PDO contract 
	
	  XXX
	  Should possibly wait for VBUS to settle if it was enabled locally
	  since tcpm_reset_port() will disable VBUS.
	
	  1. When vbus_present is true, voltage on VBUS is already at VSAFE5V.
	  So implicitly vbus_vsafe0v = false.
	 
	  2. When vbus_present is false and TCPC does NOT support querying
	  vsafe0v status, then, it's best to assume vbus is at VSAFE0V i.e.
	  vbus_vsafe0v is true.
	 
	  3. When vbus_present is false and TCPC does support querying vsafe0v,
	  then, query tcpc for vsafe0v status.
	
	  Some adapters need a clean slate at startup, and won't recover
	  otherwise. So do not try to be fancy and force a clean disconnect.
 XXX: Maintain PD connection if possible? 
	
	  This fwnode has a "compatible" property, but is never populated as a
	  struct device. Instead we simply parse it to read the properties.
	  This it breaks fw_devlink=on. To maintain backward compatibility
	  with existing DT files, we work around this by deleting any
	  fwnode_links tofrom this fwnode.
 USB data support is optional 
 Get Source PDOs for the PD port or Source Rp value for the non-PD port 
 Get the preferred power role for DRP 
 Get sink pdos 
 FRS can only be supported by DRP ports 
 sink-vdos is optional 
 If sink-vdos is found, sink-vdos-v1 is expected for backward compatibility. 
 Power Supply access to expose source power information 
 Type-C spec release 1.2 
 USB-PD spec release 3.0 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020, Google LLC
  MAXIM TCPCI based TCPC driver
  LongMessage not supported, hence 32 bytes for buf to be read from RECEIVE_BUFFER.
  DEVICE_CAPABILITIES_2.LongMessage = 0, the value in READABLE_BYTE_COUNT reg shall be
  less than or equal to 31. Since, RECEIVE_BUFFER len = 31 + 1(READABLE_BYTE_COUNT).
 Enable VSAFE0V detection 
 Enable Extended alert for detecting Fast Role Swap Signal 
 Enable vbus voltage monitoring and voltage alerts 
	
	  READABLE_BYTE_COUNT: Indicates the number of bytes in the RX_BUF_BYTE_x registers
	  plus one (for the RX_BUF_FRAME_TYPE) Table 4-36.
	  Read the count and frame type.
	
	  Read count + 1 as RX_BUF_BYTE_x is hidden and can only be read through
	  TCPC_RX_BYTE_CNT
	
	  Read complete, clear RX status alert bit.
	  Clear overflow as well if set.
	
	  For Fast Role Swap case, Boost turns on autonomously without
	  AP intervention, but, needs AP to enable source mode explicitly
	  for AP to regain control.
 Reinit regs as Hard reset sets them to default value 
 Enable USB switches when partner is USB communications capable 
	
	  Clear alert status for everything except RX_STATUS, which shouldn't
	  be cleared until we have successfully retrieved message.
 Do not return if the ALERT is already set. 
	
	  Generic TCPCI overwrites the regs once this driver initializes
	  them. Prevent this by returning -1.
 Chip level tcpci callbacks 
 SPDX-License-Identifier: GPL-2.0
  Driver for TI TPS6598x USB Power Delivery controller family
  Copyright (C) 2017, Intel Corporation
  Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
 Register offsets 
 TPS_REG_SYSTEM_CONF bits 
 TPS_REG_RX_IDENTITY_SOP 
 Standard Task return codes 
 Unrecognized commands will be replaced with "!CMD" 
 device lock 
  Max data bytes for Data1, Data2, and other registers. See ch 1.3.2:
  https:www.ti.comlitugslvuan1aslvuan1a.pdf
 XXX: handle accessories 
 XXX: Using 1s for now, but it may not be enough for every command. 
 Handle plug insert or removal 
 Handle plug insert or removal 
	
	  Checking can the adapter handle SMBus protocol. If it can not, the
	  driver needs to take care of block reads separately.
 Make sure the controller has application firmware running 
 Switch CD321X chips to the correct system power state 
 CD321X chips have all interrupts masked initially 
 Enable power status, data status and plug event interrupts 
	
	  This fwnode has a "compatible" property, but is never populated as a
	  struct device. Instead we simply parse it to read the properties.
	  This breaks fw_devlink=on. To maintain backward compatibility
	  with existing DT files, we work around this by deleting any
	  fwnode_links tofrom this fwnode.
 SPDX-License-Identifier: GPL-2.0
  TI TPS6598x USB Power Delivery Controller Trace Support
  Copyright (C) 2021, Intel Corporation
  Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
 SPDX-License-Identifier: GPL-2.0
  Driver for Intel PMC USB mux control
  Copyright (C) 2020 Intel Corporation
  Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
 Response status bits 
 "Usage" OOB Message field values 
 Alt Mode Request 
 Common Mode Data bits 
 DP specific Mode Data bits 
 TBT specific Mode Data bits 
 Display HPD Request bits 
  Input Output Manager (IOM) PORT STATUS
 activity type: Safe Mode 
 activity type: Display Port 
 activity type: Display Port Multi Function Device 
 activity type: Thunderbolt 
 Upstream Facing Port Information 
 Display Port Hot Plug Detect status 
 SoC expects the USB Type-C port numbers to start with 0 
	
	  Error bit will always be 0 with the USBC command.
	  Status can be checked from the response message if the
	  function intel_scu_ipc_dev_command succeeds.
 Configure HPD first if HPD,IRQ comes together 
 USB4 Mode 
		 Configure data rate to rounded in the case of Active TBT3
		  and USB4 cables.
 Clear DisplayPort HPD if it's still asserted. 
 Role swap 
 REVISIT: Try with usb3_port set to 0? 
 IOM ACPI IDs and IOM_PORT_STATUS_OFFSET 
 TigerLake 
 AlderLake 
 The IOM microcontroller has a limitation of max 4 ports. 
	
	  For every physical USB connector (USB2 and USB3 combo) there is a
	  child ACPI device node under the PMC mux ACPI device object.
 SPDX-License-Identifier: GPL-2.0+
  Pericom PI3USB30532 Type-C cross switch  mux driver
  Copyright (c) 2017-2018 Hans de Goede <hdegoede@redhat.com>
 protects the cached conf register 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2003-2008 Takahiro Hirofuchi
  Copyright (C) 2015-2016 Nobuo Iwata
  TODO
 	- update root hub emulation
 	- move the emulation code to userland ?
 		porting to other operating systems
 		minimize kernel code
 	- add suspendresume code
 	- clean up everything
 See usb gadget dummy hcd 
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
 USB_PORT_STAT_CONNECTION 
  Returns 0 if the status hasn't changed, or the number of bytes in buf.
  Ports are 0-indexed from the HCD point of view,
  and 1-indexed from the USB core pointer of view.
  @buf: a bitmap to show which port status has been changed.
   bit  0: reserved
   bit  1: the status of port 0 has been changed.
   bit  2: the status of port 1 has been changed.
   ...
 check pseudo status register for each port 
 The status of a port has been changed, 
 usb 3.0 root hub device descriptor 
 Worst case: 0.4 micro sec
	
	  NOTE:
	  wIndex (bits 0-7) shows the port number and begins from 1?
	
	  wIndex can be 0 for some request types (typeReq). rhport is
	  in valid range when wIndex >= 1 and < VHCI_HC_PORTS.
	 
	  Reference port_status[] only with valid rhport when
	  invalid_rhport is false.
 store old status and compare now and old later 
 20msec signaling 
 we do not care about resume. 
		 whoever resets or resumes must GetPortStatus to
		  complete it!!
			
			  A few drivers do usb reset during probe when
			  the device could be in VDEV_ST_USED state
			
			  Since this is dummy we don't have an actual link so
			  there is nothing to do for the SET_LINK_STATE cmd
 TODO: add suspendresume support! 
 Applicable only for USB2.0 hub 
 Applicable only for USB3.0 hub 
 if it's already enabled, disable 
 50msec reset signaling 
 We'll always return 0 since this is a dummy hub 
 "protocol stall" on error 
 Only dump valid port status 
 refuse enqueue for dead connection 
	
	  The enumeration process is as follows;
	 
	   1. Get_Descriptor request to DevAddrs(0) EndPoint(0)
	      to get max packet length of default pipe
	 
	   2. Set_Address request to DevAddr(0) EndPoint(0)
	 
 set_address may come when a device is reset 
 This request is successfully completed. 
 If not -EINPROGRESS, possibly unlinked. 
 NOT REACHED 
		 usb_hcd_giveback_urb() should be called with
		  irqs disabled
  vhci_rx gives back the urb after receiving the reply of the urb.  If an
  unlink pdu is sent or not, vhci_rx receives a normal return pdu and gives
  back its urb. For the driver unlinking the urb, the content of the urb is
  not important, but the calling to its completion handler is important; the
  completion of unlinking is notified by the completion handler.
  CLIENT SIDE
  - When vhci_hcd receives RET_SUBMIT,
 	- case 1a). the urb of the pdu is not unlinking.
 		- normal case
 		=> just give back the urb
 	- case 1b). the urb of the pdu is unlinking.
 		- usbip.ko will return a reply of the unlinking request.
 		=> give back the urb now and go to case 2b).
  - When vhci_hcd receives RET_UNLINK,
 	- case 2a). a submit request is still pending in vhci_hcd.
 		- urb was really pending in usbip.ko and urb_unlink_urb() was
 		  completed there.
 		=> free a pending submit request
 		=> notify unlink completeness by giving back the urb
 	- case 2b). a submit request is not pending in vhci_hcd.
 		- urb was already given back to the core driver.
 		=> do not give back the urb
  SERVER SIDE
  - When usbip receives CMD_UNLINK,
 	- case 3a). the urb of the unlink request is now in submission.
 		=> do usb_unlink_urb().
 		=> after the unlink is completed, send RET_UNLINK.
 	- case 3b). the urb of the unlink request is not in submission.
 		- may be already completed or never be received
 		=> send RET_UNLINK
		 URB was never linked! or will be soon given back by
 send unlink request here? 
 tcp connection is closed 
		
		  If tcp connection is alive, we have sent CMD_UNLINK.
		  vhci_rx will receive RET_UNLINK and give back the URB.
		  Otherwise, we give back it here.
 tcp connection is alive 
 setup CMD_UNLINK pdu 
		 send cmd_unlink and try to cancel the pending URB in the
 give back URB of unsent unlink request 
 give back URB of unanswered unlink request 
  The important thing is that only one context begins cleanup.
  This is why error handling and cleanup become simple.
  We do not want to consider race condition as possible.
 need this? see stub_dev.c 
 kill threads related to this sdev 
 active connection is closed 
	
	  rh_port_disconnect() is a trigger of ...
	    usb_disable_device():
	 	disable all the endpoints for a USB device.
	    usb_disable_endpoint():
	 	disable endpoints. pending urbs are unlinked(dequeued).
	 
	  NOTE: After calling rh_port_disconnect(), the USB device drivers of a
	  detached device should release used urbs in a cleanup function (i.e.
	  xxx_disconnect()). Therefore, vhci_hcd does not need to release
	  pushed urbs and their private data in this function.
	 
	  NOTE: vhci_dequeue() must be considered carefully. When shutting down
	  a connection, vhci_shutdown_connection() expects vhci_dequeue()
	  gives back pushed urbs and frees their private data by request of
	  the cleanup function of a USB driver. When unlinking a urb with an
	  active connection, vhci_dequeue() does not give back the urb which
	  is actually given back by vhci_rx after receiving its return pdu.
	 
		
		  Mark the first roothub as being USB 2.0.
		  The USB 3.0 roothub will be registered later by
		  vhci_hcd_probe()
	
	  Support SG.
	  sg_tablesize is an arbitrary value to alleviate memory pressure
	  on the host.
 initialize private data of usb_hcd 
 no limit 
 vhci_hcd is now ready to be controlled through sysfs 
 1. remove the userland interface of vhci_hcd 
 2. shutdown all the ports of vhci_hcd 
 FIXME: suspendresume 
 Change a group of bulk endpoints to support multiple stream IDs 
 Reverts a group of bulk endpoints back to not using stream IDs. 
	
	  Allocate and initialize hcd.
	  Our private data is also allocated automatically.
	
	  Finish generic HCD structure initialization and register.
	  Call the driver's reset() and start() routines.
	
	  Disconnects the root hub,
	  then reverses the effects of usb_add_hcd(),
	  invoking the HCD's stop() methods.
 what should happen for USBIP under suspendresume? 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2015 Karol Kosik <karo9@interia.eu>
  Copyright (C) 2015-2016 Samsung Electronics
                Igor Kotrasinski <i.kotrasinsk@samsung.com>
 1. setup usbip_header 
 1. setup usbip_header 
 2. setup transfer buffer 
 FIXME - copypasted from stub_tx, refactor 
 else - no buffer to send 
 3. setup iso_packet_descriptor 
 called with spinlocks held 
 called with spinlocks held 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2003-2008 Takahiro Hirofuchi
  Copyright (C) 2015 Nobuo Iwata
		
		  NOTE: shutdown must come first.
		  Shutdown the device.
 Reset the device. 
 Mark the device as unusable. 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2003-2008 Takahiro Hirofuchi
  usbip_status shows the status of usbip-host as long as this driver is bound
  to the target device.
  usbip_sockfd gets a socket descriptor of an established TCP connection that
  is used to transfer usbip requests by kernel threads. -1 is a magic number
  by which usbip connection is finished.
 unlock and create threads and get tasks 
 get task structs now 
 lock and update sdev->ud state 
	
	  When removing an exported device, kernel panic sometimes occurred
	  and then EIP was sk_wait_data of stub_rx thread. Is this because
	  sk_wait_data returned though stub_rx thread was already finished by
	  step 1?
 1. stop threads 
	
	  2. close the socket
	 
	  tcp_socket is freed after threads are killed so that usbip_xmit does
	  not touch NULL socket.
 3. free used data 
 4. free stub_unlink 
 try to reset the device 
  stub_device_alloc - allocate a new stub_device struct
  @udev: usb_device of a new device
  Allocates and initializes a new stub_device struct.
 yes, it's a new device 
	
	  devid is defined with devnum when this driver is first allocated.
	  devnum may change later if a device is reset. However, devid never
	  changes during a usbip connection.
	 Not sure if this is our device. Allocate here to avoid
	  calling alloc while holding busid_table lock.
 check we should claim or not by busid_table 
		
		  Return value should be ENODEV or ENOXIO to continue trying
		  other matched drivers by the driver core.
		  See driver_probe_device() in driverbasedd.c
 set private data to usb_device 
 release the busid_lock 
	
	  Claim this hub port.
	  It doesn't matter what value we pass as owner
	  (struct dev_state) as long as it is unique.
 we already have busid_priv, just lock busid_lock 
 lock is released - go to free 
 release the busid_lock 
 wait for the stop of the event handler 
  called in usb_disconnect() or usb_deregister()
  but only if actconfig(active configuration) exists
 get stub_device 
 release busid_lock 
 release busid_lock before call to remove device files 
	
	  NOTE: rxtx threads are invoked for each usb_device.
 release port 
 If usb reset is called from event handler 
 we already have busid_priv, just lock busid_lock 
 release busid_lock 
 shutdown the current connection 
 we already have busid_priv, just lock busid_lock 
 free sdev 
 release busid_lock 
 These functions need usb_port_suspend and usb_port_resume,
 CONFIG_PM 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2003-2008 Takahiro Hirofuchi
 be in spin_lock_irqsave(&sdev->priv_lock, flags) 
  stub_complete - completion handler of a usbip urb
  @urb: pointer to the urb completed
  When a urb has completed, the USB core driver calls this function mostly in
  the interrupt context. To return the result of a urb, the completed urb is
  linked to the pending list of returning.
 OK 
	
	  If the server breaks single SG request into the several URBs, the
	  URBs must be reassembled before sending completed URB to the vhci.
	  Don't wake up the tx thread until all the URBs are completed.
 Only save the first error status 
 link a urb to the queue of tx. 
 It will be freed in stub_device_cleanup_urbs(). 
 wake up tx_thread 
 1. setup usbip_header 
 2. setup transfer buffer 
			 If the server split a single SG request into several
			  URBs because the server's HCD doesn't support SG,
			  reassemble the split URB buffers into a single
			  return command.
			
			  For isochronous packets: actual length is the sum of
			  the actual length of the individual, packets, but as
			  the packet offsets are not changed there will be
			  padding between the packets. To optimally use the
			  bandwidth the padding is not transmitted.
 3. setup iso_packet_descriptor 
 1. setup usbip_header 
		
		  send_ret_submit comes earlier than send_ret_unlink.  stub_rx
		  looks at only priv_init queue. If the completion of a URB is
		  earlier than the receive of CMD_UNLINK, priv is moved to
		  priv_tx queue and stub_rx does not find the target priv. In
		  this case, vhci_rx receives the result of the submit request
		  and then receives the result of the unlink request. The
		  result of the submit is given back to the usbcore as the
		  completion of the unlink request. The request of the
		  unlink is ignored. This is ok because a driver who calls
		  usb_unlink_urb() understands the unlink was too late by
		  getting the status of the given-backed URB which has the
		  status of usb_submit_urb().
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2015 Karol Kosik <karo9@interia.eu>
  Copyright (C) 2015-2016 Samsung Electronics
                Igor Kotrasinski <i.kotrasinsk@samsung.com>
  Based on dummy_hcd.c, which is:
  Copyright (C) 2003 David Brownell
  Copyright (C) 2003-2005 Alan Stern
bytes  12 
bytes  19 
bytes  13 uframes;
 Bus speed is 500000 bytesms, so use a little less 
 error 
  handle_control_request() - handles all control transfers
  @udc: pointer to vudc
  @urb: the urb request to handle
  @setup: pointer to the setup data for a USB device control
 	 request
  @status: pointer to request handling status
  Return 0 - if the request was handled
 	  1 - if the request wasn't handles
 	  error code on error
  Adapted from driversusbgadgetudcdummy_hcd.c
 endpoint halt 
 endpoint halt 
			
			  device: remote wakeup, selfpowered
			  interface: nothing
			  endpoint: halt
 Adapted from dummy_hcd.c ; caller must hold lock 
 if there's no request queued, the device is NAKing; return 
		
		  1..N packets of ep->ep.maxpacket each ... the last one
		  may be short (including zero length).
		 
		  writer can send a zlp explicitly (length 0) or implicitly
		  (length mod maxpacket zero, and 'zero' flag); they always
		  terminate reads.
 send multiple of maxpacket first, then remainder 
		
		  short packets terminate, maybe with overflowunderflow.
		  it's only really an error to write too much.
		 
		  partially filling a buffer optionally blocks queue advances
		  (so completion handlers can clean up the queue) but we don't
		  need to emulate such data-in-flight.
 many requests terminate without a short packet 
 also check if we need to send zlp 
 device side completion --> continuable 
 requests might have been unlinked... 
 host side completion --> terminate 
 rescan to continue with any other queued io 
 unknown speed, or not set yet 
 is it next frame now? 
 FIXME: how to make it accurate? 
 We have to clear ep0 flags separately as it's not on the list 
 Used up bandwidth? 
 TODO - flush any stale requests 
 no delays (max 64kb data stage) 
 TODO: support 
			
			  TODO: figure out bandwidth guarantees
			  for now, give unlimited bandwidth
 TODO - also wait on empty usb_request queues? 
 All timer functions are run with udc->lock held 
 we may want to kick timer to unqueue urbs 
 timer itself will take care of stopping 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2015 Karol Kosik <karo9@interia.eu>
  Copyright (C) 2015-2016 Samsung Electronics
                Igor Kotrasinski <i.kotrasinsk@samsung.com>
                Krzysztof Opasiak <k.opasiak@samsung.com>
 ep0  + 15  out eps )
 urb-related structures alloc  free 
 utilities ; almost verbatim from dummy_hcd.c 
 called with spinlock held 
 caller must hold lock 
 gadget ops 
		
		  This is the first place where we can ask our
		  gadget driver for descriptors.
 Invalidate descriptors 
 Wait for eh completion 
 endpoint ops 
 ep is always valid here - see usb_ep_free_request() 
 shutdown  reset  error handlers 
 device setup  cleanup 
 create ep0 and 15 in, 15 out general purpose eps 
 ep0 
 All other eps 
 platform driver ops 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2003-2008 Takahiro Hirofuchi
 1. setup usbip_header 
 2. setup transfer buffer 
 3. setup iso_packet_descriptor 
 This is only for isochronous case 
 1. setup usbip_header 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2015 Karol Kosik <karo9@interia.eu>
  Copyright (C) 2015-2016 Samsung Electronics
                Igor Kotrasinski <i.kotrasinsk@samsung.com>
                Krzysztof Opasiak <k.opasiak@samsung.com>
			
			  The udc was added successfully but its probe
			  function failed for some reason.
		
		  Just do platform_device_del() here, put_vudc_device()
		  calls the platform_device_put()
		
		  Just do platform_device_del() here, put_vudc_device()
		  calls the platform_device_put()
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2015 Karol Kosik <karo9@interia.eu>
  Copyright (C) 2015-2016 Samsung Electronics
                Igor Kotrasinski <i.kotrasinsk@samsung.com>
	
	  FIXME - we only setup pipe enough for usbip functions
	  to behave nicely
 Not found, completed  not queued 
 base.ep is pipeendpoint(pipe) 
 we don't know the type, there may be isoc data! 
 validate packet size and number of packets 
 FIXME: more pipe setup to please usbip_common 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2003-2008 Takahiro Hirofuchi
  Copyright (C) 2015-2016 Samsung Electronics
                Krzysztof Opasiak <k.opasiak@samsung.com>
 FIXME 
 NOT REACHED 
 Receive data over TCPIP. 
 there may be more cases to tweak the flags. 
	
	  Some members are not still implemented in usbip. I hope this issue
	  will be discussed when usbip is ported to other operating systems.
 NOT REACHED 
 NOT REACHED 
 does not need all members. but copy all simply. 
 must free buffer 
 some members of urb must be substituted before. 
 my Bluetooth dongle gets ISO URBs which are np = 0 
  This functions restores the padding which was removed for optimizing
  the bandwidth during transfer over tcpip
  buffer and iso packets need to be stored and be in propeper endian in urb
  before calling this function
 if no packets or length of data is 0, then nothing to unpack 
	
	  if actual_length is transfer_buffer_length then no padding is
	  present.
	
	  loop over all packets from last to first (to prevent overwriting
	  memory when padding) and move them into the proper place
 some members of urb must be substituted before. 
 the direction of urb must be OUT. 
 the direction of urb must be IN. 
 no need to recv xbuff 
 should not happen, probably malicious packet 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2003-2008 Takahiro Hirofuchi
  Copyright (C) 2015-2016 Nobuo Iwata
 Hardening for Spectre-v1 
 TODO: refine locking ?
  output example:
  hub port sta spd dev       sockfd local_busid
  hs  0000 004 000 00000000  000003 1-2.3
  ................................................
  ss  0008 004 000 00000000  000004 2-3.4
  ................................................
  Output includes socket fd instead of socket pointer address to avoid
  leaking kernel memory address in:
 	sysdevicesplatformvhci_hcd.0status and in debug output.
  The socket pointer address is not used at the moment and it was made
  visible as a convenient way to find IP address from socket pointer
  address by looking up procnet{tcp,tcp6}. As this opens a security
  hole, the change is made to use sockfd instead.
 hub == HUB_SPEED_SUPER 
 Sysfs entry to show port status 
	
	  Half the ports are for SPEED_HIGH and half for SPEED_SUPER,
	  thus the  2.
 Sysfs entry to shutdown a virtual connection 
 lock 
 unlock 
 unlock 
 Sysfs entry to establish a virtual connection 
  To start a new USBIP attachment, a userland program needs to setup a TCP
  connection and then write its socket descriptor with remote device
  information into this sysfs file.
  A remote device is virtually attached to the root-hub port of @rhport with
  @speed. @devid is embedded into a request to specify the remote device in a
  server host.
  write() returns 0 on success, else negative errno.
	
	  @rhport: port number of vhci_hcd
	  @sockfd: socket descriptor of an established TCP connection
	  @devid: unique device identifier in a remote host
	  @speed: usb device speed in a remote host
 check received parameters 
 Extract socket from fd. 
 create threads before locking 
 get task structs now 
 now begin lock until setting vdev status set 
 end of the lock 
		
		  Will be retried from userspace
		  if there's another free port.
 end the lock 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2003-2008 Takahiro Hirofuchi
 get URB from transmitted urb queue. caller must hold vdev->priv_lock 
 no info output 
 unpack the pdu to a urb 
 recv transfer buffer 
 recv iso_packet_descriptor 
 restore the padding in iso packets 
		
		  I get the result of a unlink request. But, it seems that I
		  already received the result of its submit result and gave
		  back the URB.
 If unlink is successful, status is -ECONNRESET 
 recv a pdu 
 receive a pdu header 
 ignore if connection was idle 
 NOT REACHED 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2003-2008 Takahiro Hirofuchi
  busid_tables defines matching busids that usbip can grab. A user can change
  dynamically what device is locally used and what device is exported to a
  remote host.
	
	  This also sets the bus_table[i].status to
	  STUB_BUSID_OTHER, which is 0.
  Find the index of the busid by name.
  Must be called with busid_table_lock held.
 Returns holding busid_lock. Should call put_busid_priv() to unlock 
 get busid_lock before returning 
 already registered? 
 found 
 busid needs to include \0 termination 
 device_attach() callers should hold parent lock for USB 
 update status to STUB_BUSID_OTHER so probe ignores the device 
 now run rebind - no need to hold locks. driver files are removed 
 buf length should be less that BUSID_SIZE 
 mark the device for deletion so probe ignores it during rescan 
 release the busid lock 
 delete device from busid_table 
	
	  deregister() calls stub_disconnect() for all devices. Device
	  specific data is cleared in stub_disconnect().
 initiate scan to attach devices 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2003-2008 Takahiro Hirofuchi
	
	  The stalled endpoint is specified in the wIndex value. The endpoint
	  of the urb is the target of this clear_halt request (i.e., control
	  endpoint).
 the stalled endpoint direction is IN or OUT?. USB_DIR_IN is 0x80.  
  clear_halt, set_interface, and set_configuration require special tricks.
 tweak clear_halt 
 tweak set_interface 
 tweak set_configuration 
  stub_recv_unlink() unlinks the URB by a call to usb_unlink_urb().
  By unlinking the urb asynchronously, stub_rx can continuously
  process coming urbs.  Even if the urb is unlinked, its completion
  handler will be called and stub_tx will send a return pdu.
  See also comments about unlinking strategy in vhci_hcd.c.
		
		  This matched urb is not completed yet (i.e., be in
		  flight in usb hcd hardwaredriver). Now we are
		  cancelling it. The unlinking flag means that we are
		  now not going to return the normal result pdu of a
		  submission request, but going to return a result pdu
		  of the unlink request.
		
		  In the case that unlinking flag is on, prev->seqnum
		  is changed from the seqnum of the cancelling urb to
		  the seqnum of the unlink request. This will be used
		  to make the result pdu of the unlink request.
		
		  usb_unlink_urb() is now out of spinlocking to avoid
		  spinlock recursion since stub_complete() is
		  sometimes called in this context but not in the
		  interrupt context.  If stub_complete() is executed
		  before we call usb_unlink_urb(), usb_unlink_urb()
		  will return an error value. In this case, stub_tx
		  will return the result pdu of this unlink request
		  though submission is completed and actual unlinking
		  is not executed. OK?
		 In the above case, urb->status is not -ECONNRESET,
		  so a driver in a client host will know the failure
		  of the unlink request ?
	
	  The urb of the unlink target is not found in priv_init queue. It was
	  already completed and its results iswas going to be sent by a
	  CMD_RET pdu. In this case, usb_unlink_urb() is not needed. We only
	  return the completeness of this unlink request to vhci_hcd.
 A request is valid. 
	
	  After a stub_priv is linked to a list_head,
	  our error handler can free allocated data.
 validate number of packets 
 NOT REACHED 
 enforce simplestandard policy 
 all non-iso endpoints 
	
	  Smatch reported the error case where use_sg is true and buf_len is 0.
	  In this case, It adds SDEV_EVENT_ERROR_MALLOC and stub_priv will be
	  released by stub event handler and connection will be shut down.
 allocate urb transfer buffer, if needed 
 Check if the server's HCD supports SG 
				
				  If the server's HCD doesn't support SG, break
				  a single SG request into several URBs and map
				  each SG list entry to corresponding URB
				  buffer. The previously allocated SG list is
				  stored in priv->sgl (If the server's HCD
				  support SG, SG list is stored only in
				  urb->sg) and it is used as an indicator that
				  the server split single SG request into
				  several URBs. Later, priv->sgl is used by
				  stub_complete() and stub_send_ret_submit() to
				  reassemble the divied URBs.
 allocate urb array 
 setup a urb 
 copy urb setup packet 
			 The URBs which is previously allocated will be freed
			  in stub_device_cleanup_urbs() if error occurs.
 set other members from the base header of pdu 
 no need to submit an intercepted request, but harmless? 
 urb is now ready to submit 
			
			  Pessimistic.
			  This connection will be discarded.
 recv a pdu 
 receive a pdu header 
 NOTREACHED 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2015 Karol Kosik <karo9@interia.eu>
  Copyright (C) 2015-2016 Samsung Electronics
                Igor Kotrasinski <i.kotrasinsk@samsung.com>
                Krzysztof Opasiak <k.opasiak@samsung.com>
 called with udc->lock held 
 assuming request queue is empty; request is now on top 
  Exposes device descriptor from the gadget driver.
 Don't export what we don't have 
 unlock and create threads and get tasks 
 get task structs now 
 lock and update udc->ud state 
 SPDX-License-Identifier: GPL-2.0
  Standalone EHCI usb debug driver
  Originally written by:
   Eric W. Biederman" <ebiederm@xmission.com> and
   Yinghai Lu <yhlu.kernel@gmail.com>
  Changes for earlylate printk and HW errata:
   Jason Wessel <jason.wessel@windriver.com>
   Copyright (C) 2009 Wind River Systems, Inc.
 The code here is intended to talk directly to the EHCI debug port
  and does not require that you have any kind of USB host controller
  drivers or USB device drivers compiled into the kernel.
  If you make a change to anything in here, the following test cases
  need to pass where a USB debug device works in the following
  configurations.
  1. boot args:  earlyprintk=dbgp
      o kernel compiled with # CONFIG_USB_EHCI_HCD is not set
      o kernel compiled with CONFIG_USB_EHCI_HCD=y
  2. boot args: earlyprintk=dbgp,keep
      o kernel compiled with # CONFIG_USB_EHCI_HCD is not set
      o kernel compiled with CONFIG_USB_EHCI_HCD=y
  3. boot args: earlyprintk=dbgp console=ttyUSB0
      o kernel has CONFIG_USB_EHCI_HCD=y and
        CONFIG_USB_SERIAL_DEBUG=y
  4. boot args: earlyprintk=vga,dbgp
      o kernel compiled with # CONFIG_USB_EHCI_HCD is not set
      o kernel compiled with CONFIG_USB_EHCI_HCD=y
  For the 4th configuration you can turn on or off the DBGP_DEBUG
  such that you can debug the dbgp device's driver code.
 Cannot use debug device during ehci reset 
 Local version of HC_LENGTH macro as ehci struct is not available here 
 bits 7 : 0 
  USB Packet IDs (PIDs)
 token 
 handshake 
 data 
 Special 
 times are in msec 
	
	  Now that we have observed the completed transaction,
	  clear the done bit.
 Sleep to give the debug port a chance to breathe 
		 A -DBGP_TIMEOUT failure here means the device has
		  failed, perhaps because it was unplugged, in which
		  case we do not want to hang the system so the dbgp
		  will be marked as unsafe to use.  EHCI reset is the
		  only way to recover if you unplug the dbgp device.
	
	  If the port is getting full or it has dropped data
	  start pacing ourselves, not necessary but it's friendly.
 If I get a NACK reissue the transmission 
 Compute the control message 
 Send the setup message 
 Read the result 
 Find a PCI capability 
 Claim ownership, but do not enable yet 
 Start the ehci running 
 Ensure everything is routed to the EHCI 
 Wait until the controller is no longer halted 
 Reset the EHCI controller 
 Return 0 on success
  Return -ENODEV for any general failure
  Return -EIO if wait for port fails
 Wait for a device to show up in the debug port 
			 Last ditch effort to try to force enable
			  the debug device by using the packet test
 Enable the debug port 
 Completely transfer the debug device to the debug controller 
 Find the debug device and make it device number 127 
 Move the device to 127 if it isn't already there 
 Enable the debug interface 
	 Perform a small write to get the evenodd data state in sync
 Reset the usb debug port 
 force reset to complete 
 Device went away? 
 bomb out completely if something weird happened 
 If we've finished resetting, then break out of the loop 
 The code in early_ehci_bios_handoff() is derived from the usb pci
  quirk initialization, but altered so as to use the early PCI
 BIOS semaphore 
 legacy controlstatus 
 if boot firmware now owns EHCI, spin till it hands it over. 
		 well, possibly buggy BIOS... try to shut it down,
 just in case, always disable EHCI SMIs 
	 Only reset the controller if it is not already in the
 Things didn't work so remove my claim 
 double check if the mem space is enabled 
	
	  FIXME I don't have the bar size so just guess PAGE_SIZE is more
	  than enough.  1K is the biggest I have seen.
		 If the ehci controller is not in the run state do extended
		  checks to see if the acpi or some other initialization also
	 This means the console is not initialized, or should get
	  shutdown so as to allow for reuse of the usb device, which
 USB 
 CONFIG_KGDB 
 SPDX-License-Identifier: GPL-2.0
  xhci-dbc.c - xHCI debug capability early driver
  Copyright (C) 2016 Intel Corporation
  Author: Lu Baolu <baolu.lu@linux.intel.com>
 XDBC_TRACE 
 Check if the mem space is enabled: 
 Disable BIOS SMIs and clear all SMI events: 
 Initialize event ring segment table: 
 Initialize ERST registers: 
 Debug capability contexts: 
 Popluate the strings: 
 Serial string: 
 Product string: 
 Manufacture string: 
 String0: 
 Populate info Context: 
 Populate bulk out endpoint context: 
 Populate bulk in endpoint context: 
 Set DbC context and info registers: 
 Reset port to avoid bus hang: 
 Wait for port connection: 
 Wait for debug device to be configured: 
 Check port number: 
	
	  Add a barrier between writes of trb fields and flipping
	  the cycle bit:
 Allocate the table page: 
 Get and store the transfer buffer: 
 Allocate the event ring: 
 Allocate INOUT endpoint transfer rings: 
 Locate the host controller: 
 Map the IO memory: 
 Locate DbC registers: 
 Check whether cable unplugged: 
 Write back the value to clear RW1C bits: 
 Handle external reset events: 
 Handle configure-exit event: 
 Handle endpoint stall event: 
 Handle the events in the event ring: 
		
		  Add a barrier between reading the cycle flag and any
		  reads of the event's flagsdata below:
 Update event ring dequeue pointer: 
 Check completion of the previous request: 
	
	  It's time to shut down the DbC, so that the debug
	  port can be reused by the host controller:
 SPDX-License-Identifier: GPL-2.0
 -- linux-c --
  Cypress USB Thermometer driver 
  Copyright (c) 2004 Erik Rigtorp <erkki@linux.nu> <erik@rigtorp.com>
  This driver works with Elektor magazine USB Interface as published in 
  issue #291. It should also work with the original starter kitdemo board
  from Cypress.
 Structure to hold all of our device specific stuff 
 save off the usb device pointer 
 the interface for this device 
 Vendor requests 
 They all operate on one byte at a time 
 Reads form ROM, value = address 
 Reads form RAM, value = address 
 Write to RAM, value = address, index = data 
 Reads from port, value = address 
 Write to port, value = address, index = data  
 Send a vendor command to device 
 RAM location for brightness value 
 RAM location for brightness semaphore 
 Set brightness 
 Inform µC that we have changed the brightness setting 
 RAM location for temperature 
 RAM location for temperature sign 
 read temperature 
 read sign 
 check button 
 first remove the files, then NULL the pointer 
 usb specific object needed to register this driver with the usb subsystem 
 SPDX-License-Identifier: GPL-2.0
  Emagic EMI 2|6 usb audio interface firmware loader.
  Copyright (C) 2002
  	Tapio Laxström (tapio.laxstrom@iptime.fi)
 include firmware (variables)
 FIXME: This is quick and dirty solution! 
 if you want SPDIF comment next line 
#undef SPDIF	 if you want MIDI uncomment this line  
 Emagic Soft-und Hardware GmBH 
 EMI 6|2m without firmware 
 Vendor specific request code for Anchor UploadDownload (This one is implemented in the core) 
 This command is not implemented in the core. Requires firmware 
 This command is not implemented in the core. Requires firmware. Emagic extension 
 This is the highest internal RAM address for the AN2131Q 
 EZ-USB Control and Status Register.  Bit 0 controls 8051 reset  
 thanks to driversusbserialkeyspan_pda.c code 
	 Note: usb_control_msg returns negative value on error or length of the
 thanks to driversusbserialkeyspan_pda.c code 
 Address to write 
 Assert reset (stop the CPU in the EMI) 
 1. We need to put the loader for the FPGA into the EZ-USB 
 De-assert reset (let the CPU run) 
 let device settle 
	 2. We upload the FPGA firmware into the EMI
	  Note: collect up to 1023 (yes!) bytes and send them with
 intel hex records are terminated with type 0 element 
 Assert reset (stop the CPU in the EMI) 
 3. We need to put the loader for the firmware into the EZ-USB (again...) 
 De-assert reset (let the CPU run) 
 let device settle 
 4. We put the part of the firmware that lies in the external RAM into the EZ-USB 
 Assert reset (stop the CPU in the EMI) 
 De-assert reset (let the CPU run) 
 let device settle 
	 return 1 to fail the driver inialization
 Terminating entry 
 do not return the driver context, let real audio driver do that 
 vi:ai:syntax=c:sw=8:ts=8:tw=80
 SPDX-License-Identifier: GPL-2.0+
 Siemens ID Mouse driver v0.6
  Copyright (C) 2004-5 by Florian 'Floe' Echtler  <echtler@fs.tum.de>
                      and Andreas  'ad'  Deresch <aderesch@fs.tum.de>
  Derived from the USB Skeleton driver 1.1,
  Copyright (C) 2003 Greg Kroah-Hartman (greg@kroah.com)
  Additional information provided by Martin Reising
  <Martin.Reising@natural-computing.de>
 image constants 
 minor number for misc USB devices 
 vendor and device IDs 
 device ID table 
 Siemens ID Mouse (Professional) 
 Cherry FingerTIP ID Board       
 terminating null entry          
 sensor commands 
 LSB of value = blink pulse width 
 structure to hold all of our device specific stuff 
 save off the usb device pointer 
 the interface for this device 
 the buffer to receive data 
 the maximum bulk packet size 
 same as above, but reported by the device 
 the address of the bulk in endpoint 
 if the port is open or not 
 if the device is not disconnected 
 locks this structure 
 local function prototypes 
 file operation pointers 
 class driver information 
 usb specific object needed to register this driver with the usb subsystem 
 reset the device and set a fast blink rate 
 initialize the sensor - sending this command twice 
 significantly reduces the rate of failed reads     
 start the readout - sending this command twice 
 presumably enables the high dynamic range mode 
 loop over a blocking bulk read to get data from the device 
 Maybe this error was caused by the increased packet size? 
 Reset to the original value and tell userspace to retry.  
 reset the device 
 check for valid image 
 right border should be black (0x00) 
 lower border should be white (0xFF) 
 should be IMGSIZE == 65040 
 PM operations are nops as this driver does IO only during open() 
 get the interface from minor number and driver information 
 get the device information block from the interface 
 lock this device 
 check if already open 
 already open, so fail 
 create a new image and check for success 
 increment our usage count for the driver 
 save our object in the file's private structure 
 unlock this device 
 lock our device 
 the device was unplugged before the file was released 
 lock this object 
 verify that the device wasn't unplugged 
 unlock the device 
 check if we have gotten the data or the hid interface 
 allocate memory for our device state and initialize it 
 set up the endpoint information - use only the first bulk-in endpoint 
 works _much_ faster 
 allow device read, write and ioctl 
 we can register the device now, as it is ready 
 something prevented us from registering this device 
 be noisy 
 give back our minor 
 lock the device 
 prevent device read, write and ioctl 
 if the device is opened, idmouse_release will clean this up 
 unlock 
 SPDX-License-Identifier: GPL-2.0+
  LEGO USB Tower driver
  Copyright (C) 2003 David Glance <davidgsf@sourceforge.net>
                2001-2004 Juergen Stuber <starblue@users.sourceforge.net>
  derived from USB Skeleton driver - 0.5
  Copyright (C) 2001 Greg Kroah-Hartman (greg@kroah.com)
  History:
  2001-10-13 - 0.1 js
    - first version
  2001-11-03 - 0.2 js
    - simplified buffering, one-shot URBs for writing
  2001-11-10 - 0.3 js
    - removed IOCTL (setting powermode is more complicated, postponed)
  2001-11-28 - 0.4 js
    - added vendor commands for mode of operation and power level in open
  2001-12-04 - 0.5 js
    - set IR mode by default (by oversight 0.4 set VLL mode)
  2002-01-11 - 0.5? pcchan
    - make read buffer reusable and work around bytes_to_write issue between
      uhci and legusbtower
  2002-09-23 - 0.52 david (david@csse.uwa.edu.au)
    - imported into lejos project
    - changed wake_up to wake_up_interruptible
    - changed to use lego0 rather than tower0
    - changed dbg() to use __func__ rather than deprecated __func__
  2003-01-12 - 0.53 david (david@csse.uwa.edu.au)
    - changed read and write to write everything or
      timeout (from a patch by Chris Riesen and Brett Thaeler driver)
    - added ioctl functionality to set timeouts
  2003-07-18 - 0.54 davidgsf (david@csse.uwa.edu.au)
    - initial import into LegoUSB project
    - merge of existing LegoUSB.c driver
  2003-07-18 - 0.56 davidgsf (david@csse.uwa.edu.au)
    - port to 2.6 style driver
  2004-02-29 - 0.6 Juergen Stuber <starblue@users.sourceforge.net>
    - fix locking
    - unlink read URBs which are no longer needed
    - allow increased buffer size, eliminates need for timeout on write
    - have read URB running continuously
    - added poll
    - forbid seeking
    - added nonblocking IO
    - changed back __func__ to __func__
    - read and log tower firmware version
    - reset tower on probe, avoids failure of first write
  2004-03-09 - 0.7 Juergen Stuber <starblue@users.sourceforge.net>
    - timeout read now only after inactivity, shorten default accordingly
  2004-03-11 - 0.8 Juergen Stuber <starblue@users.sourceforge.net>
    - log major, minor instead of possibly confusing device filename
    - whitespace cleanup
  2004-03-12 - 0.9 Juergen Stuber <starblue@users.sourceforge.net>
    - normalize whitespace in debug messages
    - take care about endianness in control message responses
  2004-03-13 - 0.91 Juergen Stuber <starblue@users.sourceforge.net>
    - make default intervals longer to accommodate current EHCI driver
  2004-03-19 - 0.92 Juergen Stuber <starblue@users.sourceforge.net>
    - replaced atomic_t by memory barriers
  2004-04-21 - 0.93 Juergen Stuber <starblue@users.sourceforge.net>
    - wait for completion of write urb in release (needed for remotecontrol)
    - corrected poll for write direction (missing negation)
  2004-04-22 - 0.94 Juergen Stuber <starblue@users.sourceforge.net>
    - make device locking interruptible
  2004-04-30 - 0.95 Juergen Stuber <starblue@users.sourceforge.net>
    - check for valid udev on resubmitting and unlinking urbs
  2004-08-03 - 0.96 Juergen Stuber <starblue@users.sourceforge.net>
    - move reset into open to clean out spurious data
 The defaults are chosen to work with the latest versions of leJOS and NQC.
 Some legacy software likes to receive packets in one piece.
  In this case read_buffer_size should exceed the maximal packet length
  (417 for datalog uploads), and packet_timeout should be set.
 Some legacy software likes to send packets in one piece.
  In this case write_buffer_size should exceed the maximal packet length
  (417 for firmware and program downloads).
  A problem with long writes is that the following read may time out
  if the software is not prepared to wait long enough.
 Some legacy software expects reads to contain whole LASM packets.
  To achieve this, characters which arrive before a packet timeout
  occurs will be returned in a single read operation.
  A problem with long reads is that the software may time out
  if it is not prepared to wait long enough.
  The packet timeout should be greater than the time between the
  reception of subsequent characters, which should arrive about
  every 5ms for the standard 2400 baud.
  Set it to 0 to disable.
 Some legacy software expects blocking reads to time out.
  Timeout occurs after the specified time of read and write inactivity.
  Set it to 0 to disable.
 As of kernel version 2.6.4 ehci-hcd uses an
  "only one interrupt transfer per frame" shortcut
  to simplify the scheduling of periodic transfers.
  This conflicts with our standard 1ms intervals for in and out URBs.
  We use default intervals of 2ms for in and 8ms for out transfers,
  which is fast enough for 2400 baud and allows a small additional load.
  Increase the interval to allow more devices that do interrupt transfers,
  or set to 0 to use the standard interval from the endpoint descriptors.
 Define these values to match your device 
 Vendor requests 
 table of devices that work with this driver 
 Terminating entry 
 Structure to hold all of our device specific stuff 
 locks this structure 
 save off the usb device pointer 
 the starting minor number for this device 
 number of times this port has been opened 
 this much came in 
 this much will be returned on read 
 local function prototypes 
 file operations needed when we register this driver 
  usb class driver info in order to get a minor number from the usb core,
  and to have the device registered with the driver core
 usb specific object needed to register this driver with the usb subsystem 
 	lego_usb_tower_debug_data
 	tower_delete
 free data structures 
 	tower_open
 lock this device 
 allow opening only once 
 reset the tower 
 initialize in direction 
 save device in the file's private structure 
 	tower_release
 the device was unplugged before the file was released 
 unlock here as tower_delete frees dev 
 wait until write transfer is finished 
 shutdown transfers 
 	tower_check_for_read_packet
       To get correct semantics for signals and non-blocking IO
       with packetizing we pretend not to see any data in the read buffer
       until it has been there unchanged for at least
       dev->packet_timeout_jiffies, or until the buffer is full.
 	tower_poll
 	tower_llseek
 unseekable 
 	tower_read
 lock this object 
 verify that the device wasn't unplugged 
 verify that we actually have some data to read 
 wait for data 
 reset read timeout during read or write activity 
 check for read timeout 
 copy the data from read_buffer into userspace 
 unlock the device 
 	tower_write
 lock this object 
 verify that the device wasn't unplugged 
 verify that we actually have some data to write 
 wait until previous transfer is finished 
 write the data into interrupt_out_buffer from userspace 
 send off the urb 
 unlock the device 
 	tower_interrupt_in_callback
 maybe we can recover 
 	tower_interrupt_out_callback
 syncasync unlink faults aren't errors 
 	tower_probe
 	Called by the usb core when a new device is connected that it thinks
 	this driver might be interested in.
 allocate memory for our device state and initialize it 
 get the firmware version and log it 
 we can register the device now, as it is ready 
 something prevented us from registering this driver 
 let the user know what node this device is now attached to 
 	tower_disconnect
 	Called by the usb core when the device is removed from the system.
 give back our minor and prevent further open() 
 stop IO 
 if the device is not opened, then we clean up right now 
 wake up pollers 
 SPDX-License-Identifier: GPL-2.0
   Native support for the IO-Warrior USB devices
   Copyright (c) 2003-2005, 2020  Code Mercenaries GmbH
   written by Christian Lucht <lucht@codemercs.com> and
   Christoph Jung <jung@codemercs.com>
   based on
   usb-skeleton.c by Greg Kroah-Hartman  <greg@kroah.com>
   brlvger.c by Stephane Dalton  <sdalton@videotron.ca>
            and Stephane Doyon   <s.doyon@videotron.ca>
   Released under the GPLv2.
 low speed iowarrior 
 full speed iowarrior 
 fuller speed iowarrior 
 OEMed devices 
 Get a minor range for your devices from the usb maintainer 
 SKELETON_MINOR_BASE 192 + 16, not official yet
 interrupt input queue size 
   maximum number of urbs that are submitted for writes at the same time,
   this applies to the IOWarrior56 only!
   IOWarrior24 and IOWarrior40 use synchronous usb_control_msg calls.
--------------
     data     
--------------
 Structure to hold all of our device specific stuff 
 locks this structure 
 save off the usb device pointer 
 the interface for this device 
 the starting minor number for this device 
 endpoint for reading (needed for IOW56 only) 
 endpoint for reading 
 the urb for reading data 
 buffer for data to be read 
 to detect lost packages 
 size is MAX_INTERRUPT_BUFFER  packet size 
 wait-queue for writing to the device 
 number of write-urbs submitted 
 signals an index 'rollover' 
 this is 1 as long as the device is connected 
 this is 1 if the device is currently open 
 the serial number string of the chip connected 
 number of bytes in a report 
--------------
    globals   
--------------
#if 0
#endif
---------------------
 driver registration 
---------------------
 table of devices that work with this driver 
 Terminating entry 
  USB callback handler for reading data
 success 
 aux_idx become previous intr_idx 
 queue is not empty and it's interface 0 
 + 1 for serial number 
 equal values on interface 0 will be ignored 
 aux_idx become next intr_idx 
 queue full, dropping oldest input 
 +1 for serial number 
 tell the blocking read about the new data 
  USB Callback handler for write-ops
 syncasync unlink faults aren't errors 
 free up our allocated buffer 
 tell a waiting writer the interrupt-out-pipe is available again 
 	iowarrior_delete
---------------------
 fops implementation 
---------------------
   iowarrior_read
 verify that the device wasn't unplugged 
 read count must be packet size (+ time stamp) 
 repeat until no buffer overrun in callback handler occur 
 queue empty 
next line will return when there is either new data, or the device is unplugged
we were interrupted by a signal
The device was unplugged
 Can this happen ???
  iowarrior_write
 for IOW24 and IOW56 we need a buffer 
 verify that the device wasn't unplugged 
 if count is 0 we're already done 
 We only accept full reports 
 IOW24 and IOW40 use a synchronous call 
 The IOW56 uses asynchronous IO and more urbs 
 Wait until we are below the limit for submitted urbs 
 we were interrupted by a signal 
 The device was unplugged 
 We were closed while waiting for an URB 
 submit was ok 
 what do we have here ? An unsupported Product-ID ? 
 	iowarrior_ioctl
 checks for bytes readwritten and copy_tofrom_user results 
 verify that the device wasn't unplugged 
 Report available information for the device 
 needed for power consumption 
 directly from the descriptor 
 0==UNKNOWN, 1==LOW(usb1.1) ,2=FULL(usb1.1), 3=HIGH(usb2.0) 
 serial number string has been read earlier 8 chars or empty string 
 no information available 
 the MaxPower is stored in units of 2mA to make it fit into a byte-value 
 return that we did not understand this ioctl call 
 unlock the device 
 	iowarrior_open
 Only one process can open each device, no sharing. 
 setup interrupt handler for receiving values 
 increment our usage count for the driver 
 save our object in the file's private structure 
 	iowarrior_release
 lock our device 
 close called more than once 
 we're closing now 
			
			   The device is still connected so we only shutdown
			   pending read-write-ops.
 The device was unplugged, cleanup resources 
  File operations needed when we register this driver.
  This assumes that this driver NEEDS file operations,
  of course, which means that the driver is expected
  to have a node in the dev directory. If the USB
  device were for a network interface then the driver
  would use "struct net_driver" instead, and a serial
  device would use "struct tty_driver".
  usb class driver info in order to get a minor number from the usb core,
  and to have the device registered with devfs and the driver core
---------------------------------
  probe and disconnect functions 
---------------------------------
 	iowarrior_probe
 	Called by the usb core when a new device is connected that it thinks
 	this driver might be interested in.
 allocate memory for our device state and initialize it 
 we have to check the report_size often, so remember it in the endianness suitable for our machine 
	
	  Some devices need the report size to be different than the
	  endpoint size.
 create the urb and buffer for reading 
 create an internal buffer for interrupt data from the device 
 Get the serial-number of the chip 
 Set the idle timeout to 0, if this is interface 0 
 allow device read and ioctl 
 we can register the device now, as it is ready 
 something prevented us from registering this driver 
 let the user know what node this device is now attached to 
 	iowarrior_disconnect
 	Called by the usb core when the device is removed from the system.
 prevent device read, write and ioctl 
		 There is a process that holds a filedescriptor to the device ,
		   so we only shutdown read-write-ops going on.
		   Deleting the device is postponed until close() was called.
 no process is using the device, cleanup now 
 usb specific object needed to register this driver with the usb subsystem 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
 Test: wait for 15secs -> suspend -> 15secs delay -> resume 
 Test: wait for 15secs -> GetDescriptor request 
		
		  GetDescriptor SETUP request -> 15secs delay -> IN & STATUS
		 
		  Note, this test is only supported on root hubs since the
		  SetPortFeature handling can only be done inside the HCD's
		  hub_control callback function.
 Terminating entry 
 SPDX-License-Identifier: GPL-2.0+
 	uss720.c  --  USS720 USB Parport Cable.
 	Copyright (C) 1999, 2005, 2010
 	    Thomas Sailer (t.sailer@alumni.ethz.ch)
   Based on parport_pc.c
   History:
    0.1  04.08.1999  Created
    0.2  07.08.1999  Some fixes mainly suggested by Tim Waugh
 		      Interrupt handling currently disabled because
 		      usb_request_irq crashes somewhere within ohci.c
 		      for no apparent reason (that is for me, anyway)
 		      ECP currently untested
    0.3  10.08.1999  fixing merge errors
    0.4  13.08.1999  Added VendorProduct ID of Brad Hard's cable
    0.5  20.09.1999  usb_control_msg wrapper used
         Nov01.2000  usb_device_table support by Adam J. Richter
         08.04.2001  Identify version on module load.  gb
    0.6  02.09.2005  Fix "scheduling in interrupt" problem by making saverestore
                     context asynchronous
 --------------------------------------------------------------------- 
 USB registers 
 --------------------------------------------------------------------- 
 --------------------------------------------------------------------- 
 if nAck interrupts are enabled and we have an interrupt, call the interrupt procedure 
 rq->urb->transfer_flags |= URB_ASYNC_UNLINK; 
 --------------------------------------------------------------------- 
 --------------------------------------------------------------------- 
 ECR modes 
 Safely change the mode bits in the ECR 
 Bits <7:5> contain the mode. 
 We have to go through mode 000 or 001 
		 This mode resets the FIFO, so we may
 Parallel Port FIFO mode 
 ECP Parallel Port mode 
 Poll slowly. 
 The FIFO is stuck. 
 Set the mode. 
  Clear TIMEOUT BIT in EPP MODE
  Access functions.
 if nAck interrupts are enabled and we have an interrupt, call the interrupt procedure 
 Use soft copy 
 --------------------------------------------------------------------- 
 --------------------------------------------------------------------- 
 our known interfaces have 3 alternate settings 
	
	  Allocate parport interface 
 set the USS720 control register to manual mode, no ECP compression, enable all ints 
 PS2 mode 
 debugging 
 table of cables that work through this driver 
 Terminating entry 
 --------------------------------------------------------------------- 
 --------------------------------------------------------------------- 
 SPDX-License-Identifier: GPL-2.0
  Driver for Meywa-Denki & KAYAC YUREX
  Copyright (C) 2010 Tomoki Sekiyama (tomoki.sekiyama@gmail.com)
 table of devices that work with this driver 
 Terminating entry 
 Structure to hold all of our device specific stuff 
 URB for interrupt in 
 buffer for intterupt in 
 URB for control msg 
 req for control msg 
 buffer for control msg 
 BBU from device 
 on success, sender woken up by CMD_ACK int in, or timeout 
  usb class driver info in order to get a minor number from the usb core,
  and to have the device registered with the driver core
success
 The device is terminated or messed up, give up 
 handle received message 
 allocate memory for our device state and initialize it 
 set up the endpoint information 
 allocate control URB 
 allocate buffer for control req 
 allocate buffer for control msg 
 configure control URB 
 allocate interrupt URB 
 allocate buffer for interrupt in 
 configure interrupt URB 
 save our data pointer in this interface device 
 we can register the device now, as it is ready 
 this frees allocated memory 
 give back our minor 
 prevent more IO from starting 
 wakeup waiters 
 decrement our usage count 
 increment our usage count for the device 
 save our object in the file's private structure 
 decrement the count on our device 
 already disconnected 
 verify that we actually have some data to write 
 already disconnected 
 send the data as the control msg 
 make sure URB is idle after timeout or (spurious) CMD_ACK 
 SPDX-License-Identifier: GPL-2.0
  EZ-USB specific functions used by some of the USB to Serial drivers.
  Copyright (C) 1999 - 2002 Greg Kroah-Hartman (greg@kroah.com)
 EZ-USB Control and Status Register.  Bit 0 controls 8051 reset 
 Commands for writing to memory 
  Once someone one needs these fx2 functions, uncomment them
  and add them to ezusb.h and all should be good.
 SPDX-License-Identifier: GPL-2.0
                           USBLCD Kernel Driver                             
                             Version 1.05                                   
              (C) 2005 Georges Toth <g.toth@e-biz.lu>                       
      This file is licensed under the GPL. See COPYING in the package.      
  Based on usb-skeleton.c 2.0 by Greg Kroah-Hartman (greg@kroah.com)        
  28.02.05 Complete rewrite of the original usblcd.c driver,                
           based on usb_skeleton.c.                                         
           This new driver allows more than one USB-LCD to be connected     
           and controlled, at once                                          
 init: probe_lcd 
	struct usb_interface	interface;		 the interface for
	unsigned char		bulk_in_buffer;	 the buffer to receive
	size_t			bulk_in_size;		 the size of the
	__u8			bulk_in_endpointAddr;	 the address of the
	__u8			bulk_out_endpointAddr;	 the address of the
	struct semaphore	limit_sem;		 to stop writes at
							   full throttle from
	struct usb_anchor	submitted;		 URBs to wait for
 increment our usage count for the device 
 grab a power reference 
 save our object in the file's private structure 
 decrement the count on our device 
 do a blocking bulk read to get data from the device 
 if the read was successful, copy the data to userspace 
 syncasync unlink faults aren't errors 
 free up our allocated buffer 
 verify that we actually have some data to write 
 create a urb, and a buffer for it, and copy the data to the urb 
 initialize the urb properly 
 send the data out the bulk port 
	 release our reference to this urb,
  usb class driver info in order to get a minor number from the usb core,
  and to have the device registered with the driver core
 allocate memory for our device state and initialize it 
 set up the endpoint information 
 use only the first bulk-in and bulk-out endpoints 
 save our data pointer in this interface device 
 we can register the device now, as it is ready 
 something prevented us from registering this driver 
 let the user know what node this device is now attached to 
 give back our minor 
 decrement our usage count 
 SPDX-License-Identifier: GPL-2.0
  driversusbmisclvstest.c
  Test pattern generation for Link Layer Validation System Tests
  Copyright (C) 2014 ST Microelectronics
  Pratyush Anand <pratyush.anand@gmail.com>
 root hub interface 
 if lvs device connected 
 port no at which lvs device is present 
 urb buffer 
 class descriptor 
 urb for polling interrupt pipe 
 LVH RH work 
 RH port status 
 Examine each root port 
 valid only for SS root hub 
 how many number of ports this root hub has 
 submit urb to poll interrupt endpoint 
 used in scheduled work 
 SPDX-License-Identifier: GPL-2.0+
  Driver for SMSC USB4604 USB HSIC 4-port 2.0 hub controller driver
  Based on usb3503 driver
  Copyright (c) 2012-2013 Dongjin Kim (tobetter@gmail.com)
  Copyright (c) 2016 Linaro Ltd.
 Wait for i2c logic to come up 
 SPDX-License-Identifier: GPL-2.0
 in milliseconds 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 FIXME make these public somewhere; usbdevfs.h? 
 Parameter for usbtest driver. 
 inputs 
 0..(TEST_CASES-1) 
 outputs 
  Compat parameter to the usbtest driver.
  This supports older user space binaries compiled with 64 bit compiler.
 inputs 
 0..(TEST_CASES-1) 
 outputs 
 IOCTL interface to the driver. 
 COMPAT IOCTL interface to the driver. 
-------------------------------------------------------------------------
 let probe() bind using module params 
 Some devices that can be used for testing will have "real" drivers.
  Entries for those need to be enabled here by hand, after disabling
  that "real" driver.
#define	IBOT2		 grab iBOT2 webcams 
#define	KEYSPAN_19Qi	 grab un-renumerated serial adapter 
-------------------------------------------------------------------------
 bulkintr source 
 bulkintr sink 
 try iso inout 
 try interrupt inout 
 this is accessed only through usbfs ioctl calls.
  one ioctl to issue a test ... one lock per device.
  tests create other threads if they need them.
  urbs and buffers are allocated dynamically,
  and data generated deterministically.
 set up all urbs so they can be used with either bulk or interrupt 
 msectransfer 
-------------------------------------------------------------------------
		 take the first altsetting with in-bulk + out-bulk;
		  ignore other endpoints and altsettings.
-------------------------------------------------------------------------
 Support for testing basic non-queued IO streams.
  These just package urbs as requests that can be easily canceled.
  Each urb's data buffer is dynamically allocated; callers can fill
  them with non-zero test data (or test for it) when appropriate.
	 To test unaligned transfers add an offset and fill the
	 For inbound transfers use guard byte so that test fails if
 mod63 
 all-zeroes has no synchronization issues 
		 mod63 stays in sync with short-terminated transfers,
		  or otherwise when host and gadget agree on how large
		  each usb transfer request should be.  resync is done
		  with set_interface or set_config.
 mod63 
 always fail unsupported patterns 
 FIXME if endpoint halted, clear halt (and log) 
-------------------------------------------------------------------------
 We use scatterlist primitives to test queued IO.
  Yes, this also tests the scatterlist primitives.
 kmalloc pages are always physically contiguous! 
 already zeroed 
 FIXME check resulting data pattern 
 FIXME if endpoint halted, clear halt (and log) 
	 FIXME for unlink or fault handling tests, don't report
	  failure if retval is as we expected ...
-------------------------------------------------------------------------
 unqueued control message testing
  there's a nice set of device functional requirements in chapter 9 of the
  usb 2.0 spec, which we can apply to ANY device, even ones that don't use
  special test firmware.
  we know the device is configured (or suspended) by the time it's visible
  through usbfs.  we can't change that, so we won't test enumeration (which
  worked 'well enough' to get here, this time), power management (ditto),
  or remote wakeup (which needs human interaction).
 this bit 'must be 1' but often isn't 
 reserved == 0 
 read it all 
 max partial read 
 bits[1:15] is used and others are reserved 
 reserved == 0 
	
	  only bit[1] of bmAttributes is used for LTM and others are
	  reserved
 reserved == 0 
 bits[0:3] of wSpeedSupported is used and others are reserved 
 reserved == 0 
 reserved == 0 
 sanity test for standard requests working with usb_control_mesg() and some
  of the utility functions which use it.
  this doesn't test how endpoint halts behave or data toggles get set, since
  we won't do IO to bulkinterrupt endpoints here (which is how to change
  halt or toggle).  toggle testing is impractical without support from hcds.
  this avoids failing devices linux would normally work with, by not testing
  configaltsetting operations for devices that only support their defaults.
  such devices rarely support those needless operations.
  NOTE that since this is a sanity test, it's not examining boundary cases
  to see if usbcore, hcd, and device all behave right.  such testing would
  involve varied read sizes and other operation sequences.
	 [9.2.3] if there's more than one altsetting, we need to be able to
	  set and get each one.  mostly trusts the descriptors from usbcore.
 9.2.3 constrains the range here 
 [real world] getset unimplemented if there's only one 
 [9.4.10] set_interface 
 [9.4.4] get_interface always works 
 [real world] get_config unimplemented if there's only one 
		 [9.4.2] get_configuration always works
		  ... although some cheap devices (like one TI Hub I've got)
		  won't return config descriptors except before set_config.
 there's always [9.4.3] a device descriptor [9.6.1] 
	
	  there's always [9.4.3] a bos device descriptor [9.6.2] in USB
	  3.0 spec
		
		  get generic device-level capability descriptors [9.6.2]
		  in USB 3.0 spec
 there's always [9.4.3] at least one config descriptor [9.6.3] 
		 FIXME cross-checking udev->config[i] to make sure usbcore
		  parsed it right (etc) would be good testing paranoia
 and sometimes [9.2.6.6] speed dependent descriptors 
 device qualifier [9.6.2] 
 usb2.0 but not high-speed capable; fine 
 might not have [9.6.2] any other-speed configs [9.6.4] 
 FIXME fetch strings from at least the device descriptor 
 [9.4.5] get_status always works 
	 FIXME configuration.bmAttributes says if we could try to setclear
	  the device's remote wakeup feature ... if we can, test that here
 FIXME get status for each endpoint in the interface 
-------------------------------------------------------------------------
 use ch9 requests to test whether:
    (a) queues work for control, keeping N subtests queued and
        active (auto-resubmit) for M loops through the queue.
    (b) protocol stalls (control-only) will autorecover.
        it's not like bulkintr; no halt clearing.
    (c) short control reads are reported and handled.
    (d) queues are always processed in-order
 how many test subcases here? 
	 queue must transfer and complete in fifo order, unless
	  usb_unlink_urb() is used to unlink something not at the
	  physical queue head (not tested).
 succeed or fault in only one way? 
 async unlink for cleanup? 
 some faults are allowed, not required 
 happened 
 didn't 
 sometimes more than one fault is allowed 
 unexpected status codes mean errors; ideally, in hardware 
			 FIXME this "unlink everything" exit route should
			  be a separate test case.
 unlink whatever's still pending 
 resubmit if we need to, else mark this as done 
 signal completion when nothing's queued 
	 allocate and init the urbs we'll queue.
	  as with bulkintr sglists, sglen is the queue depth; it also
	  controls which subtests run (more tests than sglen) or rerun.
		 sign of this variable means:
		   -: tested code must return this (negative) error code
		   +: tested code may return this (negative too) error code
		 requests here are mostly expected to succeed on any
		  device, but some are chosen to trigger protocol stalls
		  or short reads.
 get device descriptor 
 get first config descriptor (only) 
 get altsetting (OFTEN STALLS) 
 index = 0 means first interface 
 get interface status 
 interface 0 
 get device status 
 get device qualifier (MAY STALL) 
 get first config descriptor, plus interface 
 get interface descriptor (ALWAYS STALLS) 
 interface == 0 
		 NOTE: two consecutive stalls in the queue here.
 clear endpoint halt (MAY STALL) 
 wValue 0 == ep halt 
 wIndex 0 == ep0 (shouldn't halt!) 
 get endpoint status 
 endpoint 0 
 trigger short read (EREMOTEIO) 
 NOTE: two consecutive _different_ faults in the queue. 
 get endpoint descriptor (ALWAYS STALLS) 
 endpoint == 0 
 NOTE: sometimes even a third fault in the queue! 
 get string 0 descriptor (MAY STALL) 
 string == 0, for language IDs 
 may succeed when > 4 languages 
 or EPIPE, if no strings 
 short read, resembling case 10 
 last data packet "should" be DATA1, not DATA0 
 short read; try to fill the last packet 
 device descriptor size == 18 bytes 
 queue the urbs 
 FIXME  set timer and time out; provide a disconnect hook 
 wait for the last one to complete 
-------------------------------------------------------------------------
 we "know" -EPIPE (stall) never happens 
	 keep the endpoint busy.  there are lots of hchcd-internal
	  states, and testing should get to all of them over time.
	 
	  FIXME want additional tests for when endpoint is STALLing
	  due to errors, or is just NAKing requests.
	 unlinking that should always work.  variable delay tests more
	  hcd states and code paths, even with little other system load.
				 we can't unlink urbs while they're completing
				  or if they've completed, and we haven't
				  resubmitted. "normal" drivers would prevent
				  resubmission, but since we're testing unlink
				  paths, we can't.
 test sync and async paths 
-------------------------------------------------------------------------
 What error should we report if the URB completed normally? 
 One more than the actual value 
 Allocate and init the urbs we'll queue 
 Submit all the URBs and then unlink URBs num - 4 and num - 2. 
 The extra count 
-------------------------------------------------------------------------
 shouldn't look or act halted 
 should look and act halted 
 shouldn't look or act halted now 
 set halt (protocol test only), verify it worked 
 clear halt anyways, else further tests will fail 
 clear halt (tests API + protocol), verify it worked 
 NOTE:  could also verify SET_INTERFACE clear halts ... 
 clear initial data toggle to DATA0 
 transfer 3 data packets, should be DATA0, DATA1, DATA0 
 clear halt resets device side data toggle, host should react to it 
 host should use DATA0 again after clear halt 
	
	  Create a URB that causes a transfer of uneven amount of data packets
	  This way the clear toggle has an impact on the data toggle sequence.
	  Use 2 maxpacket length packets and one zero packet.
-------------------------------------------------------------------------
 Control OUT tests use the vendor control requests from Intel's
  USB 2.0 compliance test device:  write a buffer, read it back.
  Intel's spec only _requires_ that it work for one packet, which
  is pretty weak.   Some HCDs place limits here; most devices will
  need to be able to handle more than one OUT data packet.  We'll
  try whatever we're told to try.
	 NOTE:  hardware might well act differently if we pushed it
	  with lots back-to-back queued requests.
 write patterned data 
 read it back -- assuming nothing intervened!!  
 fail if we can't verify 
		 [real world] the "zero bytes IN" case isn't really used.
		  hardware can easily trip up in this weird case, since its
		  status stage is IN, not OUT like other ep0in transfers.
-------------------------------------------------------------------------
 ISOBULK tests ... mimics common usage
   - buffer length is split into N packets (mostly maxpacket sized)
   - multi-buffers according to sglen
 disconnected 
 endpoint disabled 
	 For inbound transfers use guard byte so that test fails if
 here, only the last packet will be short 
 urb->context = SET BY CALLER 
	
	  Isochronous transfers are expected to fail sometimes.  As an
	  arbitrary limit, we will report an error if any submissions
	  fail or if the transfer failure rate is > 10%.
 Run tests. 
	
	  Just a bunch of test cases that every HCD is expected to handle.
	 
	  Some may need specific firmware, though it'd be good to have
	  one firmware image to handle all the test cases.
	 
	  FIXME add more tests!  cancel requests, verify the data, control
	  queueing, concurrent read+write threads, and so on.
 Simple non-queued bulk IO tests 
 FIRMWARE:  bulk sink (maybe accepts short writes) 
 FIRMWARE:  bulk source (maybe generates short writes) 
 FIRMWARE:  bulk sink (maybe accepts short writes) 
 FIRMWARE:  bulk source (maybe generates short writes) 
 Queued bulk IO tests 
 FIRMWARE:  bulk sink (maybe accepts short writes) 
 FIRMWARE:  bulk source (maybe generates short writes) 
 FIRMWARE:  bulk sink (maybe accepts short writes) 
 FIRMWARE:  bulk source (maybe generates short writes) 
 non-queued sanity tests for control (chapter 9 subset) 
 NOP )
 queued control messaging 
 simple non-queued unlinks (ring with one urb) 
 NOP )
 NOP )
 ep halt tests 
 NOP )
 control write tests 
 iso write tests 
 FIRMWARE:  iso sink 
 iso read tests 
 FIRMWARE:  iso source 
 FIXME scatterlist cancel (needs helper thread) 
 Tests for bulk IO using DMA mapping by core and odd address 
 Tests for bulk IO using premapped coherent buffer and odd address 
 control write tests with unaligned buffer 
 unaligned iso tests 
 unlink URBs from a bulk-OUT queue 
 Simple non-queued interrupt IO tests 
 FIRMWARE: interrupt sink (maybe accepts short writes) 
 FIRMWARE: interrupt source (maybe generates short writes) 
 We do performance test, so ignore data compare 
 Test data Toggleseq_nr clear between bulk out transfers 
-------------------------------------------------------------------------
 We only have this one interface to user space, through usbfs.
  User mode code can scan usbfs to find N different devices (maybe on
  different busses) to use when testing, and allocate one thread per
  test.  So discovery is simplified, and we have no device naming issues.
  Don't use these only as stressload tests.  Use them along with with
  other USB bus activity:  plugging, unplugging, mousing, mp3 playback,
  video capture, and so on.  Run different tests at different times, in
  different sequences.  Nothing here should interact with other devices,
  except indirectly by consuming USB bandwidth and CPU resources for test
  threads and request completion.  But the only way to know that for sure
  is to test when HC queues are in use by many devices.
  WARNING:  Because usbfs grabs udev->dev.sem before calling this ioctl(),
  it locks out usbcore in certain code paths.  Notably, if you disconnect
  the device-under-test, hub_wq will wait block forever waiting for the
  ioctl to complete ... so that usb_disconnect() can abort the pending
  urbs and then call usbtest_disconnect().  To abort a test, you're best
  off just killing the userspace task and waiting for it to exit.
 FIXME USBDEVFS_CONNECTINFO doesn't say how fast the device is. 
 FIXME: What if a system sleep starts while a test is running? 
	 some devices, like ez-usb default devices, need a non-default
	  altsetting to have any active endpoints.  some tests change
	  altsettings; force a default so most tests don't need to check.
-------------------------------------------------------------------------
 specify devices by module parameters? 
 vendor match required, product match optional 
 cacheline-aligned scratch for io 
	 NOTE this doesn't yet test the handful of difference that are
	  visible with high speed interrupts:  bigger maxpacket (1K) and
	  "high bandwidth" modes (up to 3 packetsuframe).
 may find bulk or ISO pipes 
 Basic testing only needs a device that can source or sink bulk traffic.
  Any device can test control transfers (default with GENERIC binding).
  Several entries work with the default EP0 implementation that's built
  into EZ-USB chips.  There's a default vendor ID which can be overridden
  by (very) small config EEPROMS, but otherwise all these devices act
  identically until firmware is loaded:  only EP0 works.  It turns out
  to be easy to make other endpoints work, without modifying that EP0
  behavior.  For now, we expect that kind of firmware.
 an21xx or fx versions of ez-usb 
 fx2 version of ez-usb 
 ezusb family device with dedicated usb test firmware,
 iso and ctrl_out need autoconf 
 iso_ep's are #8 inout 
 peripheral running Linux and 'zero.c' test firmware, or
  its user-mode cousin. different versions of this use
  different hardware with the same vendorproduct codes.
  host side MUST rely on the endpoint descriptors.
 this is a nice source of high speed bulk data;
  uses an FX2, with firmware provided in the device
 we can use any device to test control traffic 
-------------------------------------------------------------
	 EZ-USB devices which download firmware to replace (or in our
	  case augment) the default device implementation.
 generic EZ-USB FX controller 
 CY3671 development board with EZ-USB FX 
 generic EZ-USB FX2 controller (or development board) 
 re-enumerated usb test device firmware 
 "Gadget Zero" firmware runs under Linux 
 so does a user-mode variant 
 ... and a user-mode variant that talks iso 
 Keyspan 19qi uses an21xx (original EZ-USB) 
 this does not coexist with the real Keyspan 19qi driver! 
-------------------------------------------------------------
 iBOT2 makes a nice source of high speed bulk-in data 
 this does not coexist with a real iBOT2 driver! 
-------------------------------------------------------------
 module params can specify devices to use for control tests 
-------------------------------------------------------------
-------------------------------------------------------------------------
 SPDX-License-Identifier: GPL-2.0+
  Fast-charge control for Apple "MFi" devices
  Copyright (C) 2019 Bastien Nocera <hadess@hadess.net>
 Standard include files 
 Apple 
 The product ID is defined as starting with 0x12nn, as per the
  "Choosing an Apple Device USB Configuration" section in
  release R9 (2012) of the "MFi Accessory Hardware Specification"
  To distinguish an Apple device, a USB host can check the device
  descriptor of attached USB devices for the following fields:
  ■ Vendor ID: 0x05AC
  ■ Product ID: 0x12nn
  Those checks will be done in .match() and .probe().
 Driver-local specific stuff 
 Vendor‐defined power request 
 wValue, current offset 
 wIndex, current offset 
 See comment above mfi_fc_id_table[] 
 SPDX-License-Identifier: GPL-2.0
  USB 7 Segment Driver
  Copyright (C) 2008 Harrison Metzger <harrisonmetz@gmail.com>
  Based on usbled.c by Greg Kroah-Hartman (greg@kroah.com)
 table of devices that work with this driver 
 the different text display modes the device is capable of 
 for PM 
 sysfs_streq can't replace this completely
  If the device was in hex mode, and the user wanted a 0,
  if str commands are used, we would assume the end of string
  so mem commands are used.
  (power mode) 
 (set mode) 
 The device is right to left, where as you write left to right 
 (write text) 
 mode  
 The device is right to left, where as you write left to right 
 (set decimal) 
 decimals 
 PM 
 currently active 
 have not issued autopm_get 
set defaults 
 ascii mode 
 6 characters 
 scanmode for 6 chars 
 SPDX-License-Identifier: GPL-2.0+
  PlayStation 2 Trance Vibrator driver
  Copyright (C) 2006 Sam Hocevar <sam@zoy.org>
 Standard include files 
 ASCII Corporation 
 Trance Vibrator 
 Driver-local specific stuff 
 Set speed 
 vendor request: set speed 
 speed value 
 USB subsystem object 
 SPDX-License-Identifier: GPL-2.0+
  Generic USB driver for report based interrupt inout devices
  like LD Didactic's USB devices. LD Didactic's USB devices are
  HID devices which do not use HID report definitons (they use
  raw interrupt in and our reports only for communication).
  This driver uses a ring buffer for time critical reading of
  interrupt in reports and provides read and write methods for
  raw interrupt reports (similar to the Windows HID driver).
  Devices based on the book USB COMPLETE by Jan Axelson may need
  such a compatibility to the Windows HID driver.
  Copyright (C) 2005 Michael Hund <mhund@ld-didactic.de>
  Derived from Lego USB Tower driver
  Copyright (C) 2003 David Glance <advidgsf@sourceforge.net>
 		 2001-2004 Juergen Stuber <starblue@users.sourceforge.net>
 Define these values to match your devices 
 USB Vendor ID of LD Didactic GmbH 
 USB Product ID of CASSY-S modules with 8 bytes endpoint size 
 USB Product ID of CASSY-S modules with 64 bytes endpoint size 
 USB Product ID of Pocket-CASSY 
 USB Product ID of Pocket-CASSY 2 (reserved) 
 USB Product ID of Mobile-CASSY 
 USB Product ID of Mobile-CASSY 2 (reserved) 
 USB Product ID of Micro-CASSY Voltage 
 USB Product ID of Micro-CASSY Current 
 USB Product ID of Micro-CASSY Time (reserved) 
 USB Product ID of Micro-CASSY Temperature 
 USB Product ID of Micro-CASSY pH 
 USB Product ID of Power Analyser CASSY 
 USB Product ID of Converter Controller CASSY 
 USB Product ID of Machine Test CASSY 
 USB Product ID of Joule and Wattmeter 
 USB Product ID of Digital Multimeter P (reserved) 
 USB Product ID of UMI P 
 USB Product ID of UMI C 
 USB Product ID of UMI B 
 USB Product ID of X-Ray Apparatus 55481 
 USB Product ID of X-Ray Apparatus 554800 
 USB Product ID of X-Ray Apparatus CT 554821
 USB Product ID of VideoCom 
 USB Product ID of Motor (reserved) 
 USB Product ID of COM3LAB 
 USB Product ID of Terminal Adapter 
 USB Product ID of Network Analyser 
 USB Product ID of Converter Control Unit 
 USB Product ID of Machine Test System 
 USB Product ID of MOST Protocol Analyser 
 USB Product ID of MOST Protocol Analyser 2 
 USB Product ID of ABS ESP 
 USB Product ID of Automotive Data Buses 
 USB Product ID of Microcontroller technique 
 USB Product ID of Automotive Hybrid 
 USB Product ID of Heat control 
 table of devices that work with this driver 
 Terminating entry 
 All interrupt in transfers are collected in a ring buffer to
  avoid racing conditions and get better performance of the driver.
 The write_buffer can contain more than one interrupt out transfer.
 As of kernel version 2.6.4 ehci-hcd uses an
  "only one interrupt transfer per frame" shortcut
  to simplify the scheduling of periodic transfers.
  This conflicts with our standard 1ms intervals for in and out URBs.
  We use default intervals of 2ms for in and 2ms for out transfers,
  which should be fast enough.
  Increase the interval to allow more devices that do interrupt transfers,
  or set to 1 to use the standard interval from the endpoint descriptors.
 Structure to hold all of our device specific stuff 
 locks this structure 
 save off the usb interface pointer 
 number of times this port has been opened 
 	ld_usb_abort_transfers
       aborts transfers and frees associated data structures
 shutdown transfer 
 	ld_usb_delete
 free data structures 
 	ld_usb_interrupt_in_callback
 maybe we can recover 
 actual_buffer gets urb->actual_length + interrupt_in_buffer 
 resubmit if we're still running 
 	ld_usb_interrupt_out_callback
 syncasync unlink faults aren't errors 
 	ld_usb_open
 lock this device 
 allow opening only once 
 initialize in direction 
 save device in the file's private structure 
 	ld_usb_release
 the device was unplugged before the file was released 
 unlock here as ld_usb_delete frees dev 
 wait until write transfer is finished 
 	ld_usb_poll
 	ld_usb_read
 verify that we actually have some data to read 
 lock this object 
 verify that the device wasn't unplugged 
 wait for data 
 actual_buffer contains actual_length + interrupt_in_buffer 
 copy one interrupt_in_buffer from ring_buffer into userspace 
 unlock the device 
 	ld_usb_write
 verify that we actually have some data to write 
 lock this object 
 verify that the device wasn't unplugged 
 wait until previous transfer is finished 
 write the data into interrupt_out_buffer from userspace 
 try HID_REQ_SET_REPORT=9 on control_endpoint instead of interrupt_out_endpoint 
 send off the urb 
 unlock the device 
 file operations needed when we register this driver 
  usb class driver info in order to get a minor number from the usb core,
  and to have the device registered with the driver core
 	ld_usb_probe
 	Called by the usb core when a new device is connected that it thinks
 	this driver might be interested in.
 allocate memory for our device state and initialize it 
 workaround for early firmware versions on fast computers 
 usb_string makes SETUP+STALL to leave always ControlReadLoop 
 we can register the device now, as it is ready 
 something prevented us from registering this driver 
 let the user know what node this device is now attached to 
 	ld_usb_disconnect
 	Called by the usb core when the device is removed from the system.
 give back our minor 
 if the device is not opened, then we clean up right now 
 wake up pollers 
 usb specific object needed to register this driver with the usb subsystem 
 SPDX-License-Identifier: GPL-2.0
 cypress_cy7c63.c
 Copyright (c) 2006-2007 Oliver Bock (bock@tfh-berlin.de)
	This driver is based on the Cypress USB Driver by Marcus Maul
	(cyport) and the 2.0 version of Greg Kroah-Hartman's
	USB Skeleton driver.
	This is a generic driver for the Cypress CY7C63xxx family.
	For the time being it enables you to read from and write to
	the single IO ports of the device.
	Supported vendors:	AK Modul-Bus Computer GmbH
				(Firmware "Port-Chip")
	Supported devices:	CY7C63001A-PC
				CY7C63001C-PXC
				CY7C63001C-SXC
	Supported functions:	ReadWrite Ports
	For up-to-date information please visit:
	http:www.obock.dekernelcypress
 table of devices that work with this driver 
 structure to hold all of our device specific stuff 
 used to send usb control messages to device 
 allocate some memory for the io buffer
 prepare usb control message and send it upstream 
 store returned data (more READs to be added) 
 write port value 
 validate input data 
 attribute callback handler (write) 
 attribute callback handler (write) 
 read port value 
 attribute callback handler (read) 
 attribute callback handler (read) 
 allocate memory for our device state and initialize it 
 save our data pointer in this interface device 
 let the user know that the device is now attached 
	 the intfdata can be set to NULL only after the
 SPDX-License-Identifier: GPL-2.0+
  Apple Cinema Display driver
  Copyright (C) 2006  Michael Hanselmann (linux-kernel@hansmi.ch)
  Thanks to Caskey L. Dickson for his work with acdctl.
 table of devices that work with this driver 
 Terminating entry 
 Structure to hold all of our device specific stuff 
 usb device 
 usb request block 
 backlight device 
 interrupt URB data buffer 
 control message data buffer 
 concurrent read and write 
 success 
 This urb is terminated, clean up 
 Poll again in about 125ms if there's still a button pressed 
 set up the endpoint information 
 use only the first interrupt-in endpoint 
 allocate memory for our device state and initialize it 
 Allocate buffer for control messages 
 Allocate interrupt URB 
 Allocate buffer for interrupt data 
 Configure interrupt URB 
 Register backlight device 
 Try to get brightness 
 Set brightness in backlight device 
 save our data pointer in the interface device 
 SPDX-License-Identifier: GPL-2.0
  Driver for loading USB isight firmware
  Copyright (C) 2008 Matthew Garrett <mjg@redhat.com>
  The USB isight cameras in recent Apples are roughly compatible with the USB
  video class specification, and can be driven by uvcvideo. However, they
  need firmware to be loaded beforehand. After firmware loading, the device
  detaches from the USB bus and reattaches with a new device ID. It can then
  be claimed by the uvc driver.
  The firmware is non-free and must be extracted by the user. Tools to do this
  are available at http:bersace03.free.frift
  The isight firmware loading was reverse engineered by Johannes Berg
  <johannes@sipsolutions.de>, and this driver is based on code by Ronald
  Bultje <rbultje@ronald.bitfreak.net>
 success 
 SPDX-License-Identifier: GPL-2.0+
  Driver for SMSC USB3503 USB 2.0 hub controller driver
  Copyright (c) 2012-2013 Dongjin Kim (tobetter@gmail.com)
 Wait T_HUBINIT == 4ms for hub logic to stabilize 
 SP_ILOCK: set connect_n, config_n for config 
 PDS : Set the ports which are disabled in self-powered mode. 
 CFG1 : Set SELF_BUS_PWR, this enables self-powered operation. 
 SP_LOCK: clear connect_n, config_n for hub connect 
 Datasheet defines a hardware reset to be at least 100us 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020, Broadcom 
  Interrupt from override register, propagate from override bit
  to GPIO.
  Interrupt from GPIO, propagate from GPIO to override bit.
	
	  Enable the override, clear any changed condition and
	  propagate the state to the GPIO for all out pins.
 sync and enable all in pins. 
 Enable interrupt for out pins 
 SPDX-License-Identifier: GPL-2.0
  Emagic EMI 2|6 usb audio interface firmware loader.
  Copyright (C) 2002
  	Tapio Laxström (tapio.laxstrom@iptime.fi)
  emi26.c,v 1.13 20020308 13:10:26 tapio Exp
 Emagic Soft-und Hardware GmBH 
 EMI 2|6 without firmware 
 EMI 2|6 without firmware 
 Vendor specific request code for Anchor UploadDownload (This one is implemented in the core) 
 This command is not implemented in the core. Requires firmware 
 This command is not implemented in the core. Requires firmware. Emagic extension 
 This is the highest internal RAM address for the AN2131Q 
 EZ-USB Control and Status Register.  Bit 0 controls 8051 reset  
 thanks to driversusbserialkeyspan_pda.c code 
	 Note: usb_control_msg returns negative value on error or length of the
 thanks to driversusbserialkeyspan_pda.c code 
 printk(KERN_DEBUG "%s - %d", __func__, reset_bit); 
 Address to write 
 Assert reset (stop the CPU in the EMI) 
 1. We need to put the loader for the FPGA into the EZ-USB 
 De-assert reset (let the CPU run) 
 let device settle 
	 2. We upload the FPGA firmware into the EMI
	  Note: collect up to 1023 (yes!) bytes and send them with
 intel hex records are terminated with type 0 element 
 Assert reset (stop the CPU in the EMI) 
 3. We need to put the loader for the firmware into the EZ-USB (again...) 
 let device settle 
 De-assert reset (let the CPU run) 
 4. We put the part of the firmware that lies in the external RAM into the EZ-USB 
 Assert reset (stop the CPU in the EMI) 
 De-assert reset (let the CPU run) 
 let device settle 
	 return 1 to fail the driver inialization
 Terminating entry 
 do not return the driver context, let real audio driver do that 
 vi:ai:syntax=c:sw=8:ts=8:tw=80
 SPDX-License-Identifier: GPL-2.0+
  Driver for Microchip USB251xB USB 2.0 Hi-Speed Hub Controller
  Configuration via SMBus.
  Copyright (c) 2017 SKIDATA AG
  This work is based on the USB3503 driver by Dongjin Kim and
  a not-accepted patch by Fabien Lahoudere, see:
  https:patchwork.kernel.orgpatch9257715
 Internal Register Set Addresses & Default Values acc. to DS00001692C 
 USB251{3Bi,4Bi,7i} only 
 USB2517i only 
 USB2517i only 
 ASCII string 
 >=1us RESET_N asserted 
 wait for hub recoverystabilization 
 >=500us after RESET_N deasserted 
 write registers 
		 The first data byte transferred tells the hub how many data
		  bytes will follow (byte count).
 Configure Over-Current sens when self-powered 
 Disable Over-Current sense when bus-powered 
 100 us
 4 ms 
 16 ms 
 8 ms (DEFAULT) 
	
	  The datasheet documents the register as 'Port Swap' but in real the
	  register controls the USB DPDM signal swapping for each port.
	 The following parameters are currently not exposed to devicetree, but
	  may be as soon as needed.
 sentinel 
 CONFIG_OF 
 CONFIG_OF 
	
	  usb251x SMBus-slave SCL lane is muxed with CFG_SEL0 pin. So if anyone
	  tries to work with the bus at the moment the hub reset is released,
	  it may cause an invalid config being latched by usb251x. Particularly
	  one of the config modes makes the hub loading a default registers
	  value without SMBus-slave interface activation. If the hub
	  accidentally gets this mode, this will cause the driver SMBus-
	  functions failure. Normally we could just lock the SMBus-segment the
	  hub i2c-interface resides for the device-specific reset timing. But
	  the GPIO controller, which is used to handle the hub reset, might be
	  placed at the same i2c-bus segment. In this case an error should be
	  returned since we can't safely use the GPIO controller to clear the
	  reset state (it may affect the hub configuration) and we can't lock
	  the i2c-bus segment (it will cause a deadlock).
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
  chaoskey - driver for ChaosKey device from Altus Metrum.
  This device provides true random numbers using a noise source based
  on a reverse-biased p-n junction in avalanche breakdown. More
  details can be found at http:chaoskey.org
  The driver connects to the kernel hardware RNG interface to provide
  entropy for devrandom and other kernel activities. It also offers
  a separate dev entry to allow for direct access to the random
  bit stream.
  Copyright © 2015 Keith Packard <keithp@keithp.com>
 Version Information 
 OpenMoko 
 ChaosKey 
 Araneus 
 Alea I 
 max size of USB full speed packet 
 normal stallwait timeout 
 first stallwait timeout for Alea 
 IOWARRIOR_MINOR_BASE + 16, not official yet 
 Driver-local specific stuff 
 open count 
 device not disconnected 
 ongoing IO 
 track first read for Alea 
 size of buf 
 bytes of buf read 
 bytes of buf consumed 
 product + serial 
 Embedded struct for hwrng 
 registered with hwrng API 
 for timeouts 
 for performing IO 
 Find the first bulk IN endpoint and its packet size 
 Validate endpoint and size 
 Looks good, allocate and initialize 
	 Construct a name using the product and serial values. Each
	  device needs a unique name for the hwrng code
 get the interface from minor number and driver information 
 must be seen first before validity is announced 
 Fill the buffer. Called with dev->lock held
	 Return immediately if someone called before the buffer was
 Bail if the device has been removed 
 Make sure the device is awake 
	 The first read on the Alea takes a little under 2 seconds.
	  Reads after the first read take only a few microseconds
	  though.  Presumably the entropy-generating circuit needs
	  time to ramp up.  So, we wait longer on the first read.
 Let the device go back to sleep eventually 
		 Grab the rng_lock briefly to ensure that the hwrng interface
		  gets priority over other user access
			 Consume the bytes that were copied so we don't leak
			  data to user space
	 Hold the rng_lock until we acquire the device lock so that
	  this operation gets priority over other user access to the
	  device
	 Try to fill the buffer if empty. It doesn't actually matter
	  if _chaoskey_fill works; we'll just return zero bytes as
	  the buffer will still be empty
	
	  We may have lost power.
	  In that case the device that needs a long time
	  for the first requests needs an extended timeout
	  again
 file operation pointers 
 class driver information 
 usb specific object needed to register this driver with the usb subsystem 
 SPDX-License-Identifier: GPL-2.0
  USB FTDI client driver for Elan Digital Systems's Uxxx adapters
  Copyright(C) 2006 Elan Digital Systems Limited
  http:www.elandigitalsystems.com
  Author and Maintainer - Tony Olech - Elan Digital Systems
  tony.olech@elandigitalsystems.com
  This driver was written by Tony Olech(tony.olech@elandigitalsystems.com)
  based on various USB client drivers in the 2.6.15 linux kernel
  with constant reference to the 3rd Edition of Linux Device Drivers
  published by O'Reilly
  The U132 adapter is a USB to CardBus adapter specifically designed
  for PC cards that contain an OHCI host controller. Typical PC cards
  are the Orange Mobile 3G Option GlobeTrotter Fusion card.
  The U132 adapter will NOT work with PC cards that do not contain
  an OHCI controller. A simple way to test whether a PC card has an
  OHCI controller as an interface is to insert the PC card directly
  into a laptop(or desktop) with a CardBus slot and if "lspci" shows
  a new USB controller and "lsusb -v" shows a new OHCI Host Controller
  then there is a good chance that the U132 adapter will support the
  PC card.(you also need the specific client driver for the PC card)
  Please inform the Author and Maintainer about any PC cards that
  contain OHCI Host Controller and work when directly connected to
  an embedded CardBus slot but do not work when they are connected
  via an ELAN U132 adapter.
  ftdi_module_lock exists to protect access to global variables
  end of the global variables protected by ftdi_module_lock
 FIXME ohci.h is ONLY for internal use by the OHCI driver.
  If you're going to try stuff like this, you need to split
  out shareable stuff (register declarations?) into its own
  file, maybe name <linuxusbohci.h>
 Define these values to match your devices
 table of devices that work with this driver
 Terminating entry  }
 only the jtag(firmware upgrade device) interface requires
  a device file and corresponding minor number, but the
  interface is created unconditionally - I suppose it could
  be configured or not according to a module parameter.
  But since we(now) require one interface per device,
  and since it unlikely that a normal installation would
  require more than a couple of elan-ftdi devices, 8 seems
  like a reasonable limit to have here, and if someone
  really requires more than 8 devices, then they can frig the
  code and recompile
 Structure to hold all of our device specific stuff
  the sw_lock is initially held and will be freed
  after the FTDI has been synchronized
  file_operations for the jtag interface
  the usage count for the device is incremented on open()
  and decremented on release()
 decrement the count on our device 
  blocking bulk reads are used to get data from the device
	usb_free_urb(urb);         release our reference to this urb,
  The engine tries to empty the FTDI fifo
  all responses found in the fifo data are dispatched thus
  the response buffer can only ever hold a maximum sized
  response from the Uxxx.
  create a urb, and a buffer for it, and copy the data to the urb
  usb class driver info in order to get a minor number from the usb core,
  and to have the device registered with the driver core
  the following definitions are for the
  ELAN FPGA state machgine processor that
  lies on the other side of the FTDI chip
  send the long flush sequence
  send the reset sequence
 ... allow extra time 
 power down each port 
 start controller operations 
 handle root hub init quirks ... 
  we use only the first bulk-in and bulk-out endpoints
 SPDX-License-Identifier: GPL-2.0+
  adutux - driver for ADU devices from Ontrak Control Systems
  This is an experimental driver. Use at your own risk.
  This driver is not supported by Ontrak Control Systems.
  Copyright (c) 2003 John Homppi (SCO, leave this notice here)
  derived from the Lego USB Tower driver 0.56:
  Copyright (c) 2003 David Glance <davidgsf@sourceforge.net>
                2001 Juergen Stuber <stuber@loria.fr>
  that was derived from USB Skeleton driver - 0.5
  Copyright (c) 2001 Greg Kroah-Hartman (greg@kroah.com)
 Define these values to match your device 
 table of devices that work with this driver 
 ADU100 
 ADU120 
 ADU130 
 ADU200 
 ADU208 
 ADU218 
 Terminating entry 
 we can have up to this number of device plugged in at once 
  The locking scheme is a vanilla 3-lock:
    adu_device.buflock: A spinlock, covers what IRQs touch.
    adutux_mutex:       A Static lock to cover open_count. It would also cover
                        any globals, but we don't have them in 2.6.
    adu_device.mtx:     A mutex to hold across sleepers like copy_from_user.
                        It covers all of adu_device, except the open_count
                        and what .buflock covers.
 Structure to hold all of our device specific stuff 
 save off the usb device pointer 
 the starting minor number for this device 
 number of times this port has been opened 
  adu_abort_transfers
       aborts transfers and frees associated data structures
 shutdown transfer 
 XXX Anchor these instead 
 free data structures 
 always wake up so we recover from errors 
 check that nobody else is using the device 
 save device in the file's private structure 
 initialize in direction 
 fixup first read by having urb waiting for it 
 we ignore failure 
 end of fixup for first read 
 initialize out direction 
 decrement our usage count for the device 
 not interruptible 
 the device was unplugged before the file was released 
 ... and we're the last user 
 verify that the device wasn't unplugged 
 verify that some data was requested 
 drain secondary buffer 
 we check the primary buffer 
 we secure access to the primary 
 we have a free buffer so use it 
 even the primary was empty - we may need to do IO 
 somebody is doing IO 
 we must initiate input 
 we wait for IO to complete 
 if the primary buffer is empty then use it 
 we ignore failure 
 unlock the device 
 verify that the device wasn't unplugged 
 verify that we actually have some data to write 
 write the data into interrupt_out_buffer from userspace 
 send off the urb 
 file operations needed when we register this driver 
  usb class driver info in order to get a minor number from the usb core,
  and to have the device registered with devfs and the driver core
  adu_probe
  Called by the usb core when a new device is connected that it thinks
  this driver might be interested in.
 allocate memory for our device state and initialize it 
 debug code prime the buffer 
 debug code prime the buffer 
 debug code prime the buffer 
 we can register the device now, as it is ready 
 something prevented us from registering this driver 
 let the user know what node this device is now attached to 
  adu_disconnect
  Called by the usb core when the device is removed from the system.
 not interruptible 
 if the device is not opened, then we clean up right now 
 usb specific object needed to register this driver with the usb subsystem 
 SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
  sisusb - usb kernel driver for SiS315(E) based USB2VGA dongles
  VGA text mode console part
  Copyright (C) 2005 by Thomas Winischhofer, Vienna, Austria
  If distributed as part of the Linux kernel, this code is licensed under the
  terms of the GPL v2.
  Otherwise, the following license terms apply:
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:
   1) Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
   2) Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation andor other materials provided with the distribution.
   3) The name of the author may not be used to endorse or promote products
      derived from this software without specific psisusbr written permission.
   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  Author: Thomas Winischhofer <thomas@winischhofer.net>
  Portions based on vgacon.c which are
 	Created 28 Sep 1997 by Geert Uytterhoeven
       Rewritten by Martin Mares <mj@ucw.cz>, July 1998
       based on code Copyright (C) 1991, 1992  Linus Torvalds
 			    1995  Jay Estabrook
  A note on using in_atomic() in here: We can't handle console
  calls from non-schedulable context due to our USB-dependend
  nature. For now, this driver just ignores any calls if it
  detects this state.
 vc_data -> sisusb conversion table 
 Forward declaration 
 Reset cursor and start address 
	 Hardware bug: Text cursor appears twice or not at all
	  at some positions. Work around it with the cursor skew
	  bits.
	 We can't handle console calls in non-schedulable
	  context due to our locks and the USB transport.
	  So we simply ignore them. This should only affect
	  some calls to printk.
 con_startup console interface routine 
 con_init console interface routine 
	 This is called by do_take_over_console(),
	  ie by usunder our control. It is
	  only called after text mode and fonts
	  are set uprestored.
 We only support 640x400 
 We only support width = 8 
	 Increment usage count for our sisusb.
	  Doing so saves us from uppingdowning
	  the disconnect semaphore; we can't
	  lose our sisusb until this is undone
	  in con_deinit. For all other console
	  interface functions, it suffices to
	  use sisusb->lock and do a quick check
	  of sisusb for device disconnection.
 con_deinit console interface routine 
	 This is called by do_take_over_console()
	  and others, ie not under our control.
 Clear ourselves in mysisusbs 
 Free our font buffer if all consoles are gone 
 decrement the usage count on our sisusb 
 interface routine 
 Interface routine 
	 Invert a region. This is called with a pointer
	  to the console's internal screen buffer. So we
	  simply do the inversion there and rely on
	  a call to putc(s) to update the real screen.
 2 bytes per each character 
 Interface routine 
 sisusb->lock is down 
 Interface routine 
 sisusb->lock is down 
	 Need to put the characters into the buffer ourselves,
	  because the vt does this AFTER calling us.
 Interface routine 
 sisusb->lock is down 
	 Need to clear buffer ourselves, because the vt does
	  this AFTER calling us.
 interface routine 
	 Returnvalue 0 means we have fully restored screen,
	 	and vt doesn't need to call do_update_region().
	  Returnvalue != 0 naturally means the opposite.
 sisusb->lock is down 
 Don't write to screen if in gfx mode 
	 That really should not happen. It would mean we are
	  being called while the vc is using its private buffer
	  as origin.
 Check that we don't copy too much 
 Restore the screen contents 
 interface routine 
	 Save the current screen contents to vc's private
	  buffer.
 sisusb->lock is down 
 Check that we don't copy too much 
 Save the screen contents to vc's private buffer 
 interface routine 
 Return value not used by vt 
 sisusb->lock is down 
 interface routine 
 sisusb->lock is down 
 Normal blanking: Clear screen 
 VESA blanking 
 Unblank 
 interface routine 
 sisusb->lock is down 
 Interface routine 
 sisusb->lock is down 
 sisusb->lock is down 
	 Scroll an area which does not match the
	  visible screen's dimensions. This needs
	  to be done separately, as it does not
	  use hardware panning.
 Interface routine 
	 Returning != 0 means we have done the scrolling successfully.
	  Returning 0 makes vt do the scrolling on its own.
	  Note that con_scroll is only called if the console is
	  visible. In that case, the origin should be our buffer,
	  not the vt's private one.
 sisusb->lock is down 
 Special case 
 limit amount to maximum realistic size 
 Interface routine 
	 Returning != 0 means we were successful.
	  Returning 0 will vt make to use its own
	 	screenbuffer as the origin.
 sisusb->lock is down 
 Interface routine 
	 We are quite unflexible as regards resizing. The vt code
	  handles sizes where the line length isn't equal the pitch
	  quite badly. As regards the rows, our panning tricks only
	  work well if the number of rows equals the visible number
	  of rows.
 sisusb->lock is down 
	
	  The default font is kept in slot 0.
	  A user font is loaded in slot 2 (256 ch)
	  or 2+3 (512 ch).
 Default font is always 256 
 Reset 
 Write to plane 2 
 Memory mode a0-bf 
 Reset 
 Select plane read 2 
 Disable oddeven 
 Address range a0-bf 
		
		  In 512-character mode, the character map is not contiguous if
		  we want to remain EGA compatible -- which we do
 Reset 
 Write to planes 0+1 
 Memory mode a0-bf 
 Reset end 
 Select plane read 0 
 Enable oddeven 
 Address range b8-bf 
		 Font is shared among all our consoles.
		  And so is the hi_font_mask.
		 color plane enable register:
			256-char: enable intensity bit
		
		  Adjust the screen to fit a font of a certain height
 Number of video rows 
 Scan lines to actually display-1 
			printk(KERN_DEBUG "sisusb recalc rows %d maxscan %d fh %d sl %d\n",
 Now adjust our consoles' size 
 Interface routine 
 sisusb->lock is down 
	 Save the user-provided font into a buffer. This
	  is used for restoring text mode after quitting
	  from X and for the con_getfont routine.
 do_font_op ups sisusb->lock 
 Interface routine 
 sisusb->lock is down 
 Copy 256 chars only, like vgacon 
   The console `switch' structure for the sisusb console
 Our very own dummy console driver 
 Erm.. that should not happen 
 If gfxcore not initialized or no consoles given, quit graciously 
 Set up text mode (and upload  default font) 
 Initialize some gfx registers 
 Save sisusb for our interface routines 
 Initial console setup 
 Use a 32K buffer (matches b8000-bffff area) 
 Allocate screen buffer 
 Now grab the desired console(s) 
	 This is called if the device is disconnected
	  and while disconnect and lock semaphores
	  are up. This should be save because we
	  can't lose our sisusb any other way but by
	  disconnection (and hence, the disconnect
	  sema is for protecting all other access
	  functions from disconnection, not the
	  other way round).
	 Now what do we do in case of disconnection:
	  One alternative would be to simply call
	  give_up_console(). Nah, not a good idea.
	  give_up_console() is obviously buggy as it
	  only discards the consw pointer from the
	  driver_map, but doesn't adapt vc->vc_sw
	  of the affected consoles. Hence, the next
	  call to any of the console functions will
	  eventually take a trip to oops county.
	  Also, give_up_console for some reason
	  doesn't decrement our module refcount.
	  Instead, we switch our consoles to a private
	  dummy console. This, of course, keeps our
	  refcount up as well, but it works perfectly.
				 At this point, con_deinit for all our
				  consoles is executed by do_take_over_console().
 SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
  sisusb - usb kernel driver for SiS315(E) based USB2VGA dongles
  Display mode initializing code
  Copyright (C) 2001-2005 by Thomas Winischhofer, Vienna, Austria
  If distributed as part of the Linux kernel, this code is licensed under the
  terms of the GPL v2.
  Otherwise, the following license terms apply:
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:
   1) Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
   2) Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation andor other materials provided with the distribution.
   3) The name of the author may not be used to endorse or promote products
      derived from this software without specific prior written permission.
   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  Author:	Thomas Winischhofer <thomas@winischhofer.net>
         POINTER INITIALIZATION            
          HELPER: SetReg, GetReg           
      HELPER: DisplayOn, DisplayOff        
        HELPER: Init Port Addresses        
             HELPER: GetSysFlags           
         HELPER: Init PCI & Engines        
	  - Enable 2D (0x40)
	   - Enable 3D (0x02)
	   - Enable 3D vertex command fetch (0x10)
	   - Enable 3D command parser (0x08)
	   - Enable 3D GL transformation engine (0x80)
        HELPER: SET SEGMENT REGISTERS      
           HELPER: SearchModeID            
            HELPER: ENABLE CRT1            
 Enable CRT1 gating 
           HELPER: GetColorDepth           
             HELPER: GetOffset             
                   SEQ                     
                  MISC                     
                  CRTC                     
                   ATT                     
                   GRC                     
 256 color disable 
          CLEAR EXTENDED REGISTERS         
              Get rate index               
                  SYNC                     
                  CRTC2                   
               OFFSET & PITCH              
  (partly overruled by SetPitch() in XF86) 
                  VCLK                     
                  FIFO                     
 disable auto-threshold 
              MODE REGISTERS               
 DAC speed 
 Disable DPMS 
 data = (Hsync  8) - ((Htotal  8)  2) + 3 
                 LOAD DAC                  
         SET CRT1 REGISTER GROUP           
                 SiSSetMode()              
 Set mode on CRT1 
 Store mode number 
 SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
  sisusb - usb kernel driver for SiS315(E) based USB2VGA dongles
  Main part
  Copyright (C) 2005 by Thomas Winischhofer, Vienna, Austria
  If distributed as part of the Linux kernel, this code is licensed under the
  terms of the GPL v2.
  Otherwise, the following license terms apply:
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:
   1) Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
   2) Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation andor other materials provided with the distribution.
   3) The name of the author may not be used to endorse or promote products
      derived from this software without specific psisusbr written permission.
   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  Author:	Thomas Winischhofer <thomas@winischhofer.net>
 Forward declarations  clean-up routines 
 Level 0: USB transport layer 
 1. out-bulks 
 out-urb management 
 Return 1 if all free, 0 otherwise 
 Kill all busy URBs 
 Return 1 if ok, 0 if error (not all complete within timeout) 
 completion callback 
 Set up URB 
 Set up context 
 Declare this urbbuffer in use 
 Submit URB 
 If OK, and if timeout > 0, wait for completion 
 URB timed out... kill it and report error 
 Otherwise, report urb status 
 2. in-bulks 
 completion callback 
 URB timed out... kill it and report error 
 URB completed within timeout 
 Level 1:  
 Send a bulk message of variable size
  To copy the data from userspace, give pointer to "userbuffer",
  to copy from (non-DMA) kernel memory, give "kernbuffer". If
  both of these are NULL, it is assumed, that the transfer
  buffer "sisusb->obuf[index]" is set up with the data to send.
  Index is ignored if either kernbuffer or userbuffer is set.
  If async is nonzero, URBs will be sent without waiting for
  completion of the previous URB.
  (return 0 on success)
 Sanity check 
	 If we copy data from kernel or userspace, force the
	  allocation of a bufferurb. If we have the data in
	  the transfer buffer[index] already, reuse the bufferURB
	  if the length is > buffer size. (So, transmitting
	  large data amounts directly from the transfer buffer
	  treats the buffer as a ring buffer. However, we need
	  to sync in this case.)
 Will not happen if async 
 Force new allocation in next iteration 
 Some URBsbuffers might be busy 
 All URBs and all buffers are available 
 Receive a bulk message of variable size
  To copy the data to userspace, give pointer to "userbuffer",
  to copy to kernel memory, give "kernbuffer". One of them
  MUST be set. (There is no technique for letting the caller
  read directly from the ibuf.)
 Sanity check 
 Eventually correct endianness 
 1. send the packet 
		 2. if packet len == 6, it means we read, so wait for 32bit
		     return value and write it to packet->data
 Eventually correct endianness 
 1. send the packet 
		 2. if packet len == 6, it means we read, so wait for 32bit
		     return value and write it to packet->data
 access video memory and mmio (return 0 on success) 
 Low level 
 The following routines assume being used to transfer byte, word,
  long etc.
  This means that
    - the write routines expect "data" in machine endianness format.
      The data will be converted to leXX in sisusb_xxx_packet.
    - the read routines can expect read data in machine-endianess.
 The xxx_bulk routines copy a buffer of variable size. They treat the
  buffer as chars, therefore lsbmsb has to be corrected if using the
  bytewordlongetc routines for speed-up
  If data is from userland, set "userbuffer" (and clear "kernbuffer"),
  if data is in kernel space, set "kernbuffer" (and clear "userbuffer");
  if neither "kernbuffer" nor "userbuffer" are given, it is assumed
  that the data already is in the transfer buffer "sisusb->obuf[index]".
	 if neither kernbuffer not userbuffer are given, assume
	  data in obuf
 Remember: Read data in packet is in machine-endianess! So for
  byte, word, 24bit, long no endian correction is necessary.
 High level: Gfx (indexed) register access 
 Writeread video ram 
 access pci config registers (reg numbers 0, 4, 8, etc) 
 Clear video RAM 
 allocate free bufferurb and clear the buffer 
	 We can write a length > buffer size here. The buffer
	  data will simply be re-used (like a ring-buffer).
 Free the bufferurb 
 Initialize the graphics core (return 0 on success)
  This resets the graphics hardware and puts it into
  a defined mode (640x480@60Hz)
 default: cha, bw = 64 
 else error 
 else error 
 not on 330 
 not on 330 
 sic! 
 error 
 ram size found 
 Clear video ram 
 seq 
 misc 
 crtc 
 att 
 grc 
 clr ext 
 sync 
 crtc 
 offsetpitch 
 VCLK 
 FIFO 
 mode regs 
 adjust frame 
 enable display 
 enable engines 
 disable cmdqueue 
 we just set std mode #44 
 Enable VGA 
 Enable GPU access to VRAM 
 Reset registers 
 Disable refresh 
 TODO 
  TODO  
 Enable refresh 
 Do some magic 
 Init BAR 0 (VRAM) 
 Init BAR 1 (MMIO) 
 Init BAR 2 (io ports) 
 Enable memory and io access 
 Some further magic 
 Initialize the graphics device (return 0 on success)
  This initializes the net2280 as well as the PCI registers
  of the graphics board.
 Read PCI BARs and see if they have been set up 
 No? So reset the device 
 Initialize the graphics core 
 Set up default text mode:
  - Set text mode (0x03)
  - Upload default font
  - Upload user font (if available)
\\ V__";
 sisusb->lock is down 
 Set mode 0x03 
 Upload default font 
 Upload user font (and reset current slot) 
 sisusb->lock is down 
 fops 
 Increment usage count for our sisusb 
 Wait for all URBs to finish if device still present 
 decrement the usage count on our device 
 Sanity check 
		 Read io ports
		  Byte, word and long(32) can be read. As this
		  emulates inX instructions, the data returned is
		  in machine-endianness.
		 Read video ram
		  Remember: Data delivered is never endian-corrected
		 Read MMIO
		  Remember: Data delivered is never endian-corrected
		 Read PCI config register
		  Return value delivered in machine endianness.
 Sanity check 
		 Write io ports
		  Byte, word and long(32) can be written. As this
		  emulates outX instructions, the data is expected
		  in machine-endianness.
		 Write video ram.
		  Buffer is copied 1:1, therefore, on big-endian
		  machines, the data must be swapped by userland
		  in advance (if applicable; no swapping in 8bpp
		  mode or if YUV data is being transferred).
		 Write MMIO.
		  Buffer is copied 1:1, therefore, on big-endian
		  machines, the data must be swapped by userland
		  in advance.
		 Write PCI config register.
		  Given value expected in machine endianness.
 Error 
 Sanity check 
	 All our commands require the device
	  to be initialized.
 Gfx core must be initialized 
 Gfx core must be initialized, SiS_Pr must exist 
 Gfx core must be initialized, SiS_Pr must exist 
 Gfx core must be initialized, SiS_Pr must exist 
 Sanity check 
 Allocate memory for our private 
 Everything else is zero 
 Register device 
 Allocate buffers 
 Allocate URBs 
 Allocate our SiS_Pr 
 Do remaining init stuff 
 This should not happen 
 Wait for all URBs to complete and kill them in case (MUST do) 
 decrement our usage count 
 SPDX-License-Identifier: GPL-2.0
  Driver for the NXP ISP1760 chip
  However, the code might contain some bugs. What doesn't work for sure is:
  - ISO
  - OTG
 e The interrupt line is configured as active low, level.
  (c) 2007 Sebastian Siewior <bigeasy@linutronix.de>
  (c) 2011 Arvid Brodin <arvid.brodin@enea.com>
  Copyright 2021 Linaro, Rui Miguel Silva <rui.silva@linaro.org>
 urb state
 Philips Proprietary Transfer Descriptor (PTD) 
 ATL 
 DW0 
 DW1 
 DW2 
 DW3 
 Errata 1 
 the rest is HCD-private 
 QTD_ENQUEUED:	waiting for transfer (inactive) 
 QTD_PAYLOAD_ALLOC:	chip mem has been allocated for payload 
	 QTD_XFER_STARTED:	valid ptd has been written to isp176x - only
 QTD_XFER_COMPLETE:	payload has been transferred successfully 
 QTD_RETIRE:		transfer errorabort qtd 
 Queue head, one for each active endpoint 
 See USB2.0 spec section 11.17.5 
  Access functions for isp176x registers regmap fields
  We need, in isp176x, to write directly the values to the portsc1
  register so it will make the other values to trigger.
  Access functions for isp176x memory (offset >= 0x0400).
  bank_reads8() reads memory locations prefetched by an earlier write to
  HC_MEMORY_REG (see isp176x datasheet). Unless you want to do fancy multi-
  bank optimizations, you should use the more generic mem_read() below.
  For access to ptd memory, use the specialized ptd_read() and ptd_write()
  below.
  These functions copy via MMIO data tofrom the device. memcpy_{to|from}io()
  doesn't quite work because some people have to enforce 32-bit access
	 in case we have 3, 2 or 1 by left. The dst buffer may not be fully
	  allocated.
  ISP1763 does not have the banks direct host controller memory access,
  needs to use the HC_DATA register. Add data readwrite according to this,
  and also adjust 16bit access.
 Write the starting device address to the hcd memory register 
 Delay between consecutive access 
 As long there are at least 16-bit to read ... 
 If there are no more bytes to read, return 
	 in case we have 3, 2 or 1 bytes left. The buffer is allocated and the
	  extra bytes should not be read by the HW.
 Write the starting device address to the hcd memory register 
 Delay between consecutive access 
 Get and write the data; then adjust the data ptr and len 
 If there are no more bytes to process, return 
	
	  The only way to get here is if there is a single byte left,
	  get it and write it to the data reg;
  Read and write ptds. 'ptd_offset' should be one of ISO_PTD_OFFSET,
  INT_PTD_OFFSET, and ATL_PTD_OFFSET. 'slot' should be less than 32.
 Normalize the data obtained 
	
	  Make sure dw0 gets written last (after other dw's and after payload)
	   since it contains the enable bit
 memory management of the 60kb on the chip from 0x1000 to 0xffff 
 reset a non-running (STS_HALT == 1) controller 
 one-time init, only for memory state 
	
	  hw default: 1K periodic list heads, one per frame.
	  periodic_size can shrink by USBCMD update if hcc_params allows.
 controllers may cache some of the periodic schedule ... 
 full frame cache 
 N microframes cached 
	
	  we do not care about the read value here we just want to
	  change bus pattern.
	
	  The RESET_HC bit in the SW_RESET register is supposed to reset the
	  host controller without touching the CPU interface registers, but at
	  least on the ISP1761 it seems to behave as the RESET_ALL bit and
	  reset the whole device. We thus can't use it here, so let's reset
	  the host controller through the EHCI USB Command register. The device
	  has been reset in core code anyway, so this shouldn't matter.
 Step 11 passed 
 ATL reset 
 magic numbers that can affect system performance 
 0-3 qtd retries; 0 == don't stop 
 nak throttle; see 4.9 
 1-3 transactionsuframe; 4.10.3 
 (small) 256 frame schedule 
 according to 3.6.2, max packet len can not be > 0x400 
 DW0 
 DW1 
 split transaction 
 SE bit for Split INT transfers 
 DW2 
 DW3 
 Cerr 
	
	  Most of this is guessing. ISP1761 datasheet is quite unclear, and
	  the algorithm from the original Philips driver code, which was
	  pretty much used in this driver before as well, is quite horrendous
	  and, i believe, incorrect. The code below follows the datasheet and
	  USB2.0 spec as far as I can tell, and plugunplug seems to be much
	  more reliable this way (fingers crossed...).
 urb->interval is in units of microframes (18 ms) 
			usof = 0x01;  One bit set =>
 Two bits set => interval 12 ms 
 Four bits set => interval 14 ms 
 All bits set => interval 18 ms 
 urb->interval is in units of frames (1 ms) 
		usof = 0x0f;		 Execute Start Split on any of the
		
		  First 8 bits in dw5 is uSCS and "specifies which uSOF the
		  complete split needs to be sent. Valid only for IN." Also,
		  "All bits can be set to one for every transfer." (p 82,
		  ISP1761 data sheet.) 0x1c is from Philips driver. Where did
		  that number come from? 0xff seems to work fine...
 ptd->dw5 = 0x1c; 
 Execute Complete Split on any uFrame 
 Ensure equal or shorter period than requested 
 Mask off too large values and lowest unused 3 bits 
 complete() can reenter this HCD 
 Make sure done map has not triggered from some unlinked transfer 
 Defer calling of urb_done() since it releases lock 
 Try again on next call 
 Make sure this endpoint's TT buffer is clean before queueing ptds 
			if ((curr_slot > 31) && (free_slot == -1))
				dev_dbg(hcd->self.controller, "%s: No slot "
					"available for transfer\n", __func__);
 Start xfer for this endpoint if not already done 
	
	  check finishedretired xfers, transfer payloads, call urb_done()
	
	  Schedule packets for transfer.
	 
	  According to USB2.0 specification:
	 
	  1st prio: interrupt xfers, up to 80 % of bandwidth
	  2nd prio: control xfers
	  3rd prio: bulk xfers
	 
	  ... but let's use a simpler scheme here (mostly because ISP1761 doc
	  is very unclear on how to prioritize traffic):
	 
	  1) Enqueue any queued control transfers, as long as payload chip mem
	     and PTD ATL slots are available.
	  2) Enqueue any queued INT transfers, as long as payload chip mem
	     and PTD INT slots are available.
	  3) Enqueue any queued bulk transfers, as long as payload chip mem
	     and PTD ATL slots are available.
	 
	  Use double buffering (ENQUEUE_DEPTH==2) as a compromise between
	  conservation of chip mem and performance.
	 
	  I'm sure this scheme could be improved upon!
	 FIXME: ISP1761 datasheet does not say what to do with these. Do we
 Default unknown error 
 Could not write data 
				urb->status = -EPROTO;  timeout, bad CRC, PID
 Stall 
 Unknown 
		dev_dbg(hcd->self.controller, "%s: ptd error:\n"
			"        dw0: %08x dw1: %08x dw2: %08x dw3: %08x\n"
			"        dw4: %08x dw5: %08x dw6: %08x dw7: %08x\n",
			__func__,
			ptd->dw0, ptd->dw1, ptd->dw2, ptd->dw3,
			ptd->dw4, ptd->dw5, ptd->dw6, ptd->dw7);
 Transfer Error, but active and no HALT -> reload 
		
		  NAKs are handled in HW by the chip. Usually if the
		  device is not able to send data fast enough.
		  This happens mostly on slower hardware.
 INT ptd 
			 This should not trigger, and could be removed if
 ATL ptd 
			 This should not trigger, and could be removed if
 QTD_RETRY, for atls only 
 RL counter = ERR counter 
					 Clear failed; let's hope things work
  Workaround for problem described in chip errata 2:
  Sometimes interrupts are not generated when ATL (not INT?) completion occurs.
  One solution suggested in the errata is to use SOF interrupts _instead_of_
  ATL done interrupts (the "instead of" might be important since it seems
  enabling ATL interrupts also causes the chip to sometimes - rarely - "forget"
  to set the PTD's done bit in addition to not generating an interrupt!).
  So if we use SOF + ATL interrupts, we sometimes get stale PTDs since their
  done bit is not being set. This is bad - it blocks the endpoint until reboot.
  If we use SOF interrupts only, we get latency between ptd completion and the
  actual handling. This is very noticeable in testusb runs which takes several
  minutes longer without ATL interrupts.
  A better solution is to run the code below every SLOT_CHECK_PERIOD ms. If it
  finds active ATL slots which are older than SLOT_TIMEOUT ms, it checks the
  slot's ACTIVE and VALID bits. If these are not set, the ptd is considered
  completed and its done map bit is set.
  The values of SLOT_TIMEOUT and SLOT_CHECK_PERIOD have been arbitrarily chosen
  not to cause too much lag when this HW bug occurs, while still hopefully
  ensuring that the check does not falsely trigger.
	
	  ISP1763 have some differences in the setup and order to enable
	  the ports, disable otg, setup buffers, and ATL, INT, ISO status.
	  So, just handle it a separate sequence.
 Set PTD interrupt AND & OR maps 
 step 23 passed 
	
	  XXX
	  Spec says to write FLAG_CF as last config action, priv code grabs
	  the semaphore while doing so.
 PTD Register Init Part 2, Step 28 
 Setup registers controlling PTD checking 
	 GRR this is run-once init(), being done every time the HC starts.
	  So long as they're part of class devices, we can't do it init()
	  since the class device isn't created that early.
  Packetize urb->transfer_buffer into list of packets of size wMaxPacketSize.
  Also calculate the PID type (SETUPINOUT) for each packet.
	
	  URBs map to sequences of QTDs:  one logical transaction
 XXX This looks like usb storage  SCSI bug 
 for zero length DATA stages, STATUS is always IN 
	
	  buffer gets wrapped in one or more qtds;
	  last one may be "short" (including zero len)
	  and may serve as a control status ack
	
	  control requests may need a terminating data "status" ack;
	  bulk ones may need a terminating short packet (zero length).
 never any data in such packets 
 FIXME: Check bandwidth  
	 We need to forcefully reclaim the slot since some transfers never
  Retire the qtds beginning at 'qtd' and belonging all to the same urb, killing
  any active transfer belonging to the urb in the process.
 Clear failed; let's hope things work anyway 
 if !PM, root hub timers won't get shut down ... 
 init status to no-changes 
	
	  Return status information even for ports with OWNER set.
	  Otherwise hub_wq wouldn't see the disconnect event when a
	  high-speed device is switched over to the companion
	  controller by the user.
 FIXME autosuspend idle root hubs 
 priv 1.0, 2.3.9 says 20ms max 
 ports removable, and usb 1.0 legacy PortPwrCtrlMask 
 per-port overcurrent reporting 
 per-port power control 
 no power switching 
 if reset finished and it's still not enabled -- handoff 
	
	  FIXME:  support SetPortFeatures USB_PORT_FEAT_INDICATOR.
	  HCS_INDICATOR may say we can change LEDs to offambergreen.
	  (track current state ourselves) ... blink for diagnostics,
	  power, "this is the one", etc.  EHCI spec supports this.
 no hub-wide featurestatus flags 
		
		  Even if OWNER is set, so the port is owned by the
		  companion controller, hub_wq needs to be able to clear
		  the port-change status bits (especially
		  USB_PORT_STAT_C_CONNECTION).
 XXX error? 
 resume signaling for 20 msec 
 we auto-clear this feature 
 XXX error ?
 GetPortStatus clears reset 
 no hub-wide featurestatus flags 
 wPortChange bits 
 whoever resumes must GetPortStatus to complete it!! 
 Remote Wakeup received? 
 resume signaling for 20 msec 
 check the port again 
 resume completed? 
 stop resume signaling 
 whoever resets must GetPortStatus to complete it!! 
 force reset to complete 
			 REVISIT:  some hardware needs 550+ usec to clear
			  this bit; seems too long to spin routinely...
 see what we found out 
		
		  Even if OWNER is set, there's no harm letting hub_wq
		  see the wPortStatus values (they should all be 0 except
		  for PORT_POWER anyway).
 status may be from integrated TT 
 no hub-wide featurestatus flags 
			 line status bits may report this as low speed,
			  which can be fine if this root hub has a
			  transaction translator built in.
				
				  caller must wait, then call GetPortStatus
				  usb 2.0 spec says 50 ms resets on root
 "stall" on error 
 Disable IRQ 
 This driver doesn't support wakeup requests 
 SPDX-License-Identifier: GPL-2.0
  Glue code for the ISP1760 driver and bus
  Currently there is support for
  - OpenFirmware
  - PCI
  - PDEV (generic platform device centralized driver model)
  (c) 2007 Sebastian Siewior <bigeasy@linutronix.de>
  Copyright 2021 Linaro, Rui Miguel Silva <rui.silva@linaro.org>
 Grab the PLX PCI shared memory of the ISP 1761 we need  
 map available memory 
 bad pci latencies can contribute to overruns 
	 Try to check whether we can access Scratch Register of
	  Host Controller or not. The initial PCI access is retried until
	  local init for the PCI bridge is completed
		by default host is in 16bit mode, so
		  io operations at this stage must be 16 bit
	 Host Controller presence is detected by writing to scratch register
	  and reading back and checking the contents are same or not
 Grab the PLX PCI mem maped port start address we need  
 configure PLX PCI chip to pass interrupts 
 done with PLX IO access 
		
		  Some systems wire up only 8 of 16 data lines or
		  16 of the 32 data lines
 SPDX-License-Identifier: GPL-2.0
  Driver for the NXP ISP1760 chip
  Copyright 2021 Linaro, Rui Miguel Silva
  Copyright 2014 Laurent Pinchart
  Copyright 2007 Sebastian Siewior
  Contacts:
 	Sebastian Siewior <bigeasy@linutronix.de>
 	Laurent Pinchart <laurent.pinchart@ideasonboard.com>
 	Rui Miguel Silva <rui.silva@linaro.org>
 Low-level chip reset 
	
	  Reset the host controller, including the CPU interface
	  configuration.
 Setup HW Mode Control: This assumes a level active-low interrupt 
	
	  The ISP1761 has a dedicated DC IRQ line but supports sharing the HC
	  IRQ line for both the host and device controllers. Hardcode IRQ
	  sharing for now and disable the DC interrupts globally to avoid
	  spurious interrupts during HCD registration.
	
	  PORT 1 Control register of the ISP1760 is the OTG control register
	  on ISP1761.
	 
	  TODO: Really support OTG. For now we configure port 1 in device mode
  ISP176061:
  60kb divided in:
  - 32 blocks @ 256  bytes
  - 20 blocks @ 1024 bytes
  -  4 blocks @ 8192 bytes
  ISP1763:
  20kb divided in:
  - 8 blocks @ 256  bytes
  - 2 blocks @ 1024 bytes
  - 4 blocks @ 4096 bytes
	
	  If neither the HCD not the UDC is enabled return an error, as no
	  device would be registered.
 SPDX-License-Identifier: GPL-2.0
  Driver for the NXP ISP1761 device controller
  Copyright 2021 Linaro, Rui Miguel Silva
  Copyright 2014 Ideas on Board Oy
  Contacts:
 	Laurent Pinchart <laurent.pinchart@ideasonboard.com>
 	Rui Miguel Silva <rui.silva@linaro.org>
 -----------------------------------------------------------------------------
  Endpoint Management
  isp1760_udc_select_ep - Select an endpoint for register access
  @ep: The endpoint
  @udc: Reference to the device controller
  The ISP1761 endpoint registers are banked. This function selects the target
  endpoint for banked register access. The selection remains valid until the
  next call to this function, the next direct access to the EPINDEX register
  or the next reset, whichever comes first.
  Called with the UDC spinlock held.
 Called with the UDC spinlock held. 
	
	  Proceed to the status stage. The status stage data packet flows in
	  the direction opposite to the data stage data packets, we thus need
	  to select the OUTIN endpoint for INOUT transfers.
	
	  The hardware will terminate the request automatically and go back to
	  the setup stage without notifying us.
 Called without the UDC spinlock held. 
	
	  When completing control OUT requests, move to the status stage after
	  calling the request complete callback. This gives the gadget an
	  opportunity to stall the control transfer if needed.
 Stall both the IN and OUT endpoints. 
 A protocol stall completes the control transaction. 
 -----------------------------------------------------------------------------
  Data Endpoints
 Called with the UDC spinlock held. 
		
		  There's no data to be read from the FIFO, acknowledge the RX
		  interrupt by clearing the buffer.
		 
		  TODO: What if another packet arrives in the meantime ? The
		  datasheet doesn't clearly document how this should be
		  handled.
	
	  Make sure not to read more than one extra byte, otherwise data from
	  the next packet might be removed from the FIFO.
	
	  TODO: The short_not_ok flag isn't supported yet, but isn't used by
	  any gadget driver either.
	
	  Complete the request if all data has been received or if a short
	  packet has been received.
	
	  Make sure not to write more than one extra byte, otherwise extra data
	  will stay in the FIFO and will be transmitted during the next control
	  request. The endpoint control CLBUF bit is supposed to allow flushing
	  the FIFO for this kind of conditions, but doesn't seem to work.
		
		  This can happen for the control endpoint when the reply to
		  the GET_STATUS IN control request is sent directly by the
		  setup IRQ handler. Just proceed to the status stage.
	
	  Complete the request if all data has been sent and we don't need to
	  transmit a zero length packet.
	
	  Transmit the next packet or start the next request, if any.
	 
	  TODO: If the endpoint is stalled the next request shouldn't be
	  started, but what about the next packet ?
 When halting the control endpoint, stall both IN and OUT. 
 Reset the data PID by cycling the endpoint enable bit. 
		
		  Disabling the endpoint emptied the transmit FIFO, fill it
		  again if a request is pending.
		 
		  TODO: Does the gadget framework require synchronizatino with
		  the TX IRQ handler ?
 -----------------------------------------------------------------------------
  Control Endpoint
 TODO: Handle remote wakeup feature. 
			
			  If the endpoint is wedged only the gadget can clear
			  the halt feature. Pretend success in that case, but
			  keep the endpoint halted.
 TODO: Handle remote wakeup and test mode features 
		
		  SET_CONFIGURATION (and SET_INTERFACE) must reset the halt
		  feature on all endpoints. There is however no need to do so
		  explicitly here as the gadget driver will disable and
		  reenable endpoints, clearing the halt feature.
 Move to the data stage. 
 -----------------------------------------------------------------------------
  Gadget Endpoint Operations
	
	  Validate the descriptor. The control endpoint can't be enabled
	  manually.
 TODO Synchronize with the IRQ handler 
		
		  Halting the control endpoint is only valid as a delayed error
		  response to a SETUP packet. Make sure EP0 is in the right
		  stage and that the gadget isn't trying to clear the halt
		  condition.
 Refuse to halt IN endpoints with active transfers. 
		
		  Stalling EP0 completes the control transaction, move back to
		  the SETUP state.
	
	  Set the CLBUF bit twice to flush both buffers in case double
	  buffering is enabled.
 -----------------------------------------------------------------------------
  Device States
 Called with the UDC spinlock held. 
 Called with the UDC spinlock held. 
 TODO Reset all endpoints ? 
	
	  The device controller currently shares its interrupt with the host
	  controller, the DC_IRQ polarity and signaling mode are ignored. Set
	  the to active-low level-triggered.
	 
	  Configure the control, in and out pipes to generate interrupts on
	  ACK tokens only (and NYET for the out pipe). The default
	  configuration also generates an interrupt on the first NACK token.
	
	  The bus reset has reset most registers to their default value,
	  reinitialize the UDC hardware.
 -----------------------------------------------------------------------------
  Gadget Operations
 The hardware doesn't support low speed. 
 DMA isn't supported yet, don't enable the DMA clock. 
 -----------------------------------------------------------------------------
  Interrupt Handling
 The VBUS interrupt is only triggered when VBUS appears. 
 -----------------------------------------------------------------------------
  Registration
		
		  Hardcode the maximum packet sizes for now, to 64 bytes for
		  the control endpoint and 512 bytes for all other endpoints.
		  This fits in the 8kB FIFO without double-buffering.
	
	  Check that the controller is present by writing to the scratch
	  register, modifying the bus pattern by reading from the chip ID
	  register, and reading the scratch register value back. The chip ID
	  and scratch register contents must match the expected values.
 Reset the device controller. 
	
	  Initialize the gadget static fields and register its device. Gadget
	  fields that vary during the life time of the gadget are initialized
	  by the UDC core.
 SPDX-License-Identifier: GPL-2.0
 Prevent changing of max_speed after the driver is binded 
	
	  Make sure this function is from within our _this_ gadget and not
	  from another gadget or a random directory.
	  Also a function instance can only be linked once.
 stash the function until we bind it to the gadget 
	
	  ideally I would like to forbid to unlink functions while a gadget is
	  bound to an UDC. Since this isn't possible at the moment, we simply
	  force an unbind, the function is available here and then we can
	  remove the function.
 frees a whole chunk 
 the gi->lock is hold by the caller 
 and now the gadget bind 
 init all strings 
 Go through all configs, attach all functions 
 the gi->lock is hold by the caller 
 SPDX-License-Identifier: GPL-2.0+
  epautoconf.c -- endpoint autoconfiguration for usb gadget drivers
  Copyright (C) 2004 David Brownell
  usb_ep_autoconfig_ss() - choose an endpoint matching the ep
  descriptor and ep companion descriptor
  @gadget: The device to which the endpoint must belong.
  @desc: Endpoint descriptor, with endpoint direction and transfer mode
     initialized.  For periodic transfers, the maximum packet
     size must also be initialized.  This is modified on
     success.
  @ep_comp: Endpoint companion descriptor, with the required
     number of streams. Will be modified when the chosen EP
     supports a different number of streams.
  This routine replaces the usb_ep_autoconfig when needed
  superspeed enhancments. If such enhancemnets are required,
  the FD should call usb_ep_autoconfig_ss directly and provide
  the additional ep_comp parameter.
  By choosing an endpoint to use with the specified descriptor,
  this routine simplifies writing gadget drivers that work with
  multiple USB device controllers.  The endpoint would be
  passed later to usb_ep_enable(), along with some descriptor.
  That second descriptor won't always be the same as the first one.
  For example, isochronous endpoints can be autoconfigured for high
  bandwidth, and then used in several lower bandwidth altsettings.
  Also, high and full speed descriptors will be different.
  Be sure to examine and test the results of autoconfiguration
  on your hardware.  This code may not make the best choices
  about how to use the USB controller, and it can't know all
  the restrictions that may apply. Some combinations of driver
  and hardware won't be able to autoconfigure.
  On success, this returns an claimed usb_ep, and modifies the endpoint
  descriptor bEndpointAddress.  For bulk endpoints, the wMaxPacket value
  is initialized as if the endpoint were used at full speed and
  the bmAttribute field in the ep companion descriptor is
  updated with the assigned number of streams if it is
  different from the original value. To prevent the endpoint
  from being returned by a later autoconfig call, claims it by
  assigning ep->claimed to true.
  On failure, this returns a null endpoint descriptor.
 Second, look at endpoints until an unclaimed one looks usable 
 Fail 
	
	  If the protocol driver hasn't yet decided on wMaxPacketSize
	  and wants to know the maximum possible, provide the info.
 report address 
  usb_ep_autoconfig() - choose an endpoint matching the
  descriptor
  @gadget: The device to which the endpoint must belong.
  @desc: Endpoint descriptor, with endpoint direction and transfer mode
 	initialized.  For periodic transfers, the maximum packet
 	size must also be initialized.  This is modified on success.
  By choosing an endpoint to use with the specified descriptor, this
  routine simplifies writing gadget drivers that work with multiple
  USB device controllers.  The endpoint would be passed later to
  usb_ep_enable(), along with some descriptor.
  That second descriptor won't always be the same as the first one.
  For example, isochronous endpoints can be autoconfigured for high
  bandwidth, and then used in several lower bandwidth altsettings.
  Also, high and full speed descriptors will be different.
  Be sure to examine and test the results of autoconfiguration on your
  hardware.  This code may not make the best choices about how to use the
  USB controller, and it can't know all the restrictions that may apply.
  Some combinations of driver and hardware won't be able to autoconfigure.
  On success, this returns an claimed usb_ep, and modifies the endpoint
  descriptor bEndpointAddress.  For bulk endpoints, the wMaxPacket value
  is initialized as if the endpoint were used at full speed. Because of
  that the users must consider adjusting the autoconfigured descriptor.
  To prevent the endpoint from being returned by a later autoconfig call,
  claims it by assigning ep->claimed to true.
  On failure, this returns a null endpoint descriptor.
 report (variable) full speed bulk maxpacket 
 min() doesn't work on bitfields with gcc-3.5 
  usb_ep_autoconfig_release - releases endpoint and set it to initial state
  @ep: endpoint which should be released
  This function can be used during function bind for endpoints obtained
  from usb_ep_autoconfig(). It unclaims endpoint claimed by
  usb_ep_autoconfig() to make it available for other functions. Endpoint
  which was released is no longer valid and shouldn't be used in
  context of function which released it.
  usb_ep_autoconfig_reset - reset endpoint autoconfig state
  @gadget: device for which autoconfig state will be reset
  Use this for devices where one configuration may need to assign
  endpoint resources very differently from the next one.  It clears
  state such as ep->claimed and the record of assigned endpoints
  used by usb_ep_autoconfig().
 SPDX-License-Identifier: LGPL-2.1+
  Copyright (C) 2003 David Brownell
  usb_gadget_get_string - fill out a string descriptor 
  @table: of c strings encoded using UTF-8
  @id: string id, from low byte of wValue in get string descriptor
  @buf: at least 256 bytes, must be 16-bit aligned
  Finds the UTF-8 string matching the ID, and converts it into a
  string descriptor in utf16-le.
  Returns length of descriptor (always even) or negative errno
  If your driver needs stings in multiple languages, you'll probably
  "switch (wIndex) { ... }"  in your ep0 string descriptor logic,
  using this routine after choosing which set of UTF-8 strings to use.
  Note that US-ASCII is a strict subset of UTF-8; any string bytes with
  the eighth bit set will be multibyte UTF-8 characters, not ISO-88591
  characters (which are also widely used in C strings).
 descriptor 0 has the language id 
 unrecognized: stall. 
 string descriptors have length, tag, then UTF16-LE text 
  usb_validate_langid - validate usb language identifiers
  @langid: usb language identifier
  Returns true for valid language identifier, otherwise false.
 bit [9:0] 
 bit [15:10] 
 SPDX-License-Identifier: GPL-2.0+
  composite.c - infrastructure for Composite USB Gadgets
  Copyright (C) 2006-2008 David Brownell
 #define VERBOSE_DEBUG 
  struct usb_os_string - represents OS String to be reported by a gadget
  @bLength: total length of the entire descritor, always 0x12
  @bDescriptorType: USB_DT_STRING
  @qwSignature: the OS String proper
  @bMS_VendorCode: code used by the host for subsequent requests
  @bPad: not used, must be zero
  The code in this file is utility code, used to build a gadget driver
  from one or more "function" drivers, one or more "configuration"
  objects, and a "usb_composite_driver" by gluing them together along
  with the relevant device-wide data.
  function_descriptors() - get function descriptors for speed
  @f: the function
  @speed: the speed
  Returns the descriptors or NULL if not set.
	
	  NOTE: we try to help gadget drivers which might not be setting
	  max_speed appropriately.
	
	  if we can't find any descriptors at all, then this gadget deserves to
	  Oops with a NULL pointer dereference
  next_desc() - advance to the next desc_type descriptor
  @t: currect pointer within descriptor array
  @desc_type: descriptor type
  Return: next desc_type descriptor or NULL
  Iterate over @t until either desc_type descriptor found or
  NULL (that indicates end of list) encountered
  for_each_desc() - iterate over desc_type descriptors in the
  descriptors list
  @start: pointer within descriptor array.
  @iter_desc: desc_type descriptor to use as the loop cursor
  @desc_type: wanted descriptr type
  config_ep_by_speed_and_alt() - configures the given endpoint
  according to gadget speed.
  @g: pointer to the gadget
  @f: usb function
  @_ep: the endpoint to configure
  @alt: alternate setting number
  Return: error code, 0 on success
  This function chooses the right descriptors for a given
  endpoint according to gadget speed and saves it in the
  endpoint desc field. If the endpoint already has a descriptor
  assigned to it - overwrites it with currently corresponding
  descriptor. The endpoint maxpacket field is updated according
  to the chosen descriptor.
  Note: the supplied function should hold all the descriptors
  for supported speeds
 cursor for speed desc 
 select desired speed 
 find correct alternate setting descriptor 
 find descriptors 
 commit results 
	
	  Companion descriptor should follow EP descriptor
	  USB 3.0 spec, #9.6.7
 mult: bits 1:0 of bmAttributes 
  config_ep_by_speed() - configures the given endpoint
  according to gadget speed.
  @g: pointer to the gadget
  @f: usb function
  @_ep: the endpoint to configure
  Return: error code, 0 on success
  This function chooses the right descriptors for a given
  endpoint according to gadget speed and saves it in the
  endpoint desc field. If the endpoint already has a descriptor
  assigned to it - overwrites it with currently corresponding
  descriptor. The endpoint maxpacket field is updated according
  to the chosen descriptor.
  Note: the supplied function should hold all the descriptors
  for supported speeds
  usb_add_function() - add a function to a configuration
  @config: the configuration
  @function: the function being added
  Context: single threaded during gadget setup
  After initialization, each configuration must have one or more
  functions added to it.  Adding a function involves calling its @bind()
  method to allocate resources such as interface and string identifiers
  and endpoints.
  This function returns the value of the function's bind(), which is
  zero for success else a negative errno value.
 REVISIT require function->bind? 
	 We allow configurations that don't work at both speeds.
	  If we run into a lowspeed Linux system, treat it the same
	  as full speed ... it's the function drivers that will need
	  to avoid bulk and ISO transfers.
  usb_function_deactivate - prevent function and gadget enumeration
  @function: the function that isn't yet ready to respond
  Blocks response of the gadget driver to host enumeration by
  preventing the data line pullup from being activated.  This is
  normally called during @bind() processing to change from the
  initial "ready to respond" state, or when a required resource
  becomes available.
  For example, drivers that serve as a passthrough to a userspace
  daemon can block enumeration unless that daemon (such as an OBEX,
  MTP, or print server) is ready to handle host requests.
  Not all systems support software control of their USB peripheral
  data pullups.
  Returns zero on success, else negative errno.
  usb_function_activate - allow function and gadget enumeration
  @function: function on which usb_function_activate() was called
  Reverses effect of usb_function_deactivate().  If no more functions
  are delaying their activation, the gadget driver will respond to
  host enumeration procedures.
  Returns zero on success, else negative errno.
  usb_interface_id() - allocate an unused interface ID
  @config: configuration associated with the interface
  @function: function handling the interface
  Context: single threaded during gadget setup
  usb_interface_id() is called from usb_function.bind() callbacks to
  allocate new interface IDs.  The function driver will then store that
  ID in interface, association, CDC union, and other descriptors.  It
  will also handle any control requests targeted at that interface,
  particularly changing its altsetting via set_alt().  There may
  also be class-specific or vendor-specific requests to handle.
  All interface identifier should be allocated using this routine, to
  ensure that for example different functions don't wrongly assign
  different meanings to the same identifier.  Note that since interface
  identifiers are configuration-specific, functions used in more than
  one configuration (or more than once in a given configuration) need
  multiple versions of the relevant descriptors.
  Returns the interface ID which was allocated; or -ENODEV if no
  more interface IDs can be allocated.
		
		  USB 3.x supports up to 900mA, but since 900 isn't divisible
		  by 8 the integral division will effectively cap to 896mA.
 write the config descriptor 
 wTotalLength is written later 
 There may be e.g. OTG descriptors 
 add each function's descriptors 
 This is a lookup by config INDEX 
 skip OS Descriptors config which is handled separately 
 ignore configs that won't work at this speed 
 ignore configs that won't work at this speed 
  bos_desc() - prepares the BOS descriptor.
  @cdev: pointer to usb_composite device to generate the bos
 	descriptor for
  This function generates the BOS (Binary Device Object)
  descriptor and its device capabilities descriptors. The BOS
  descriptor should be supported by a SuperSpeed device.
 Get Controller configuration 
	
	  A SuperSpeed device shall include the USB2.0 extension descriptor
	  and shall support LPM when operating in USB2.0 HS mode.
	
	  The Superspeed USB Capability descriptor shall be implemented by all
	  SuperSpeed devices.
 LTM is not supported yet 
 The SuperSpeedPlus USB Device Capability descriptor 
		
		  Paired RX and TX sublink speed attributes share
		  the same SSID.
		
		  Use 1 SSID if the gadget supports up to gen2x1 or not
		  specified:
		  - SSID 0 for symmetric RXTX sublink speed of 10 Gbps.
		 
		  Use 1 SSID if the gadget supports up to gen1x2:
		  - SSID 0 for symmetric RXTX sublink speed of 5 Gbps.
		 
		  Use 2 SSIDs if the gadget supports up to gen2x2:
		  - SSID 0 for symmetric RXTX sublink speed of 5 Gbps.
		  - SSID 1 for symmetric RXTX sublink speed of 10 Gbps.
 POLICY: same bcdUSB and device type info at both speeds 
 ASSUME same EP0 fifo size at both speeds 
-------------------------------------------------------------------------
				
				  We disable the FDs of the previous
				  configuration only if the new configuration
				  is a valid one
 Zero configuration value - need to reset the config 
 Initialize all interfaces by setting them to altsetting zero. 
		
		  Record which endpoints are used by the function. This is used
		  to dispatch control requests targeted at that endpoint to the
		  function's setup callback instead of the current
		  configuration's setup callback.
 when we return, be sure our power usage is valid 
 Prevent duplicate configuration identifiers 
  usb_add_config() - add a configuration to a device.
  @cdev: wraps the USB gadget
  @config: the configuration, with bConfigurationValue assigned
  @bind: the configuration's bind function
  Context: single threaded during gadget setup
  One of the main tasks of a composite @bind() routine is to
  add each of the configurations it supports, using this routine.
  This function returns the value of the configuration's @bind(), which
  is zero for success else a negative errno value.  Binding configurations
  assigns global resources including string IDs, and per-configuration
  resources such as interface IDs and endpoints.
 may free memory for "f" 
 set_alt(), or next bind(), sets up ep->claimed as needed 
 may free memory for "c" 
  usb_remove_config() - remove a configuration from a device.
  @cdev: wraps the USB gadget
  @config: the configuration
  Drivers must call usb_gadget_disconnect before calling this function
  to disconnect the device from the host and make sure the host will not
  try to enumerate the device while we are changing the config list.
-------------------------------------------------------------------------
 We support strings in multiple languages ... string descriptor zero
  says which languages are supported.  The typical case will be that
  only one language (probably English) is used, with i18n handled on
  the host side.
	 Yes, not only is USB's i18n support probably more than most
	  folk will ever care about ... also, it's all supported here.
	  (Except for UTF8 support for Unicode's "Astral Planes".)
 0 == report all available language codes 
	 String IDs are device-scoped, so we look up each string
	  table we're told about.  These lookups are infrequent;
	  simpler-is-better here.
  usb_string_id() - allocate an unused string ID
  @cdev: the device whose string descriptor IDs are being allocated
  Context: single threaded during gadget setup
  @usb_string_id() is called from bind() callbacks to allocate
  string IDs.  Drivers for functions, configurations, or gadgets will
  then store that ID in the appropriate descriptors and string table.
  All string identifier should be allocated using this,
  @usb_string_ids_tab() or @usb_string_ids_n() routine, to ensure
  that for example different functions don't wrongly assign different
  meanings to the same identifier.
		 string id 0 is reserved by USB spec for list of
 255 reserved as well? -- mina86 
  usb_string_ids_tab() - allocate unused string IDs in batch
  @cdev: the device whose string descriptor IDs are being allocated
  @str: an array of usb_string objects to assign numbers to
  Context: single threaded during gadget setup
  @usb_string_ids() is called from bind() callbacks to allocate
  string IDs.  Drivers for functions, configurations, or gadgets will
  then copy IDs from the string table to the appropriate descriptors
  and string table for other languages.
  All string identifier should be allocated using this,
  @usb_string_id() or @usb_string_ids_n() routine, to ensure that for
  example different functions don't wrongly assign different meanings
  to the same identifier.
  usb_gstrings_attach() - attach gadget strings to a cdev and assign ids
  @cdev: the device whose string descriptor IDs are being allocated
  and attached.
  @sp: an array of usb_gadget_strings to attach.
  @n_strings: number of entries in each usb_strings array (sp[]->strings)
  This function will create a deep copy of usb_gadget_strings and usb_string
  and attach it to the cdev. The actual string (usb_string.s) will not be
  copied but only a referenced will be made. The struct usb_gadget_strings
  array may contain multiple languages and should be NULL terminated.
  The ->language pointer of each struct usb_gadget_strings has to contain the
  same amount of entries.
  For instance: sp[0] is en-US, sp[1] is es-ES. It is expected that the first
  usb_string entry of es-ES contains the translation of the first usb_string
  entry of en-US. Therefore both entries become the same id assign.
  usb_string_ids_n() - allocate unused string IDs in batch
  @c: the device whose string descriptor IDs are being allocated
  @n: number of string IDs to allocate
  Context: single threaded during gadget setup
  Returns the first requested ID.  This ID and next @n-1 IDs are now
  valid IDs.  At least provided that @n is non-zero because if it
  is, returns last requested ID which is now very useful information.
  @usb_string_ids_n() is called from bind() callbacks to allocate
  string IDs.  Drivers for functions, configurations, or gadgets will
  then store that ID in the appropriate descriptors and string table.
  All string identifier should be allocated using this,
  @usb_string_id() or @usb_string_ids_n() routine, to ensure that for
  example different functions don't wrongly assign different meanings
  to the same identifier.
-------------------------------------------------------------------------
	
	  REVIST The same ep0 requests are shared with function drivers
	  so they don't have to maintain the same ->complete() stubs.
	 
	  Because of that, we need to check for the validity of ->context
	  here, even though we know we've set it to something useful.
 header length 
 header length 
 not implemented 
 not implemented 
  The setup() callback implements all the ep0 functionality that's
  not handled lower down, in hardware or the hardware driver(like
  device and endpoint feature flags, and their status).  It's all
  housekeeping for the gadget function we're implementing.  Most of
  the work is in config and function specific setup.
	 partial re-init of the response message; the function or the
	  gadget might need to intercept e.g. a control-OUT completion
	  when we delegate to it.
	
	  Don't let non-standard requests match any of the cases below
	  by accident.
 we handle all standard USB descriptors 
 any number of configs can work 
 function drivers must handle getset altsetting 
		
		  If there's no get_alt() method, we know only altsetting zero
		  works. There is no need to check if set_alt() is not NULL
		  as we check this in usb_add_function().
 lots of interfaces only need altsetting zero... 
		
		  USB 3.0 additions:
		  Function driver should handle get_status request. If such cb
		  wasn't supplied we respond with default value = 0
		  Note: function driver should supply such cb only for the
		  first interface of the function
 This is the length of the get_status reply 
	
	  Function drivers should handle SetFeatureClearFeature
	  (FUNCTION_SUSPEND) request. function_suspend cb should be supplied
	  only for the first interface of the function
		
		  OS descriptors handling
 Number of ext compat interfaces 
 24 Bext compat desc 
 header 
		 functions always handle their interfaces and endpoints...
		  punt other recipients (other, WUSB, ...) to the current
		  configuration code.
 try current config's setup 
 try the only function in the current config 
 respond with data transfer before status phase? 
 device either stalls (value < 0) or reports success 
	 REVISIT:  should we have config and device level
	  disconnect callbacks?
	
	  Section 1.4.13 Standard Downstream Port of the USB battery charging
	  specification v1.2 states that a device connected on a SDP shall only
	  draw at max 100mA while in a connected, but unconfigured state.
-------------------------------------------------------------------------
	 composite_disconnect() must already have been called
	  by the underlying peripheral controller driver!
	  so there's no io concurrency that could affect the
	  state protected by cdev->lock.
	
	  these variables may have been set in
	  usb_composite_overwrite_options()
 preallocate control response and buffer 
	
	  As per USB compliance update, a device that is actively drawing
	  more than 100mA from USB must report itself as bus-powered in
	  the GetStatus(DEVICE) call.
	 interface and string IDs start at zero via kzalloc.
	  we force endpoints to start unassigned; few controller
	  drivers will zero ep->driver_data.
	
	  Some UDC backends have a dynamic EP allocation scheme.
	 
	  In that case, the dispose() callback is used to notify the
	  backend that the EPs are no longer in use.
	 
	  Note: The UDC backend can remove the EP from the ep_list as
	 	 a result, so we need to use the _safe list iterator.
	 composite gadget needs to assign strings for whole device (like
	  serial number), register function drivers, potentially update
	  power state and consumption, etc
 has userspace failed to provide a serial number? 
-------------------------------------------------------------------------
	 REVISIT:  should we have config level
	  suspendresume callbacks?
	 REVISIT:  should we have config level
	  suspendresume callbacks?
-------------------------------------------------------------------------
  usb_composite_probe() - register a composite driver
  @driver: the driver to register
  Context: single threaded during gadget setup
  This function is used to register drivers using the composite driver
  framework.  The return value is zero, or a negative errno value.
  Those values normally come from the driver's @bind method, which does
  all the work of setting up the driver to match the hardware.
  On successful return, the gadget is ready to respond to requests from
  the host, unless one of its components invokes usb_gadget_disconnect()
  while it was binding.  That would usually be done in order to wait for
  some userspace participation.
  usb_composite_unregister() - unregister a composite driver
  @driver: the driver to unregister
  This function is used to unregister drivers using the composite
  driver framework.
  usb_composite_setup_continue() - Continue with the control transfer
  @cdev: the composite device who's control transfer was kept waiting
  This function must be called by the USB function driver to continue
  with the control transfer's datastatus stage in case it had requested to
  delay the datastatus stages. A USB function's setup handler (e.g. set_alt())
  can request the composite framework to delay the setup request's datastatus
  stages by returning USB_GADGET_DELAYED_STATUS.
 SPDX-License-Identifier: GPL-2.0+
  usbgadgetconfig.c -- simplify building config descriptors
  Copyright (C) 2003 David Brownell
  usb_descriptor_fillbuf - fill buffer with descriptors
  @buf: Buffer to be filled
  @buflen: Size of buf
  @src: Array of descriptor pointers, terminated by null pointer.
  Copies descriptors into the buffer, returning the length or a
  negative error code if they can't all be copied.  Useful when
  assembling descriptors for an associated set of interfaces used
  as part of configuring a composite device; or in other cases where
  sets of descriptors need to be marshaled.
 fill buffer from src[] until null descriptor ptr 
  usb_gadget_config_buf - builts a complete configuration descriptor
  @config: Header for the descriptor, including characteristics such
 	as power requirements and number of interfaces.
  @desc: Null-terminated vector of pointers to the descriptors (interface,
 	endpoint, etc) defining all functions in this device configuration.
  @buf: Buffer for the resulting configuration descriptor.
  @length: Length of buffer.  If this is not big enough to hold the
 	entire configuration descriptor, an error code will be returned.
  This copies descriptors into the response buffer, building a descriptor
  for that configuration.  It returns the buffer length or a negative
  status code.  The config.wTotalLength field is set to match the length
  of the result, but other descriptor fields (including power usage and
  interface count) must be set by the caller.
  Gadget drivers could use this when constructing a config descriptor
  in response to USB_REQ_GET_DESCRIPTOR.  They will need to patch the
  resulting bDescriptorType value if USB_DT_OTHER_SPEED_CONFIG is needed.
 config descriptor first 
 then interfaceendpointclassvendor... 
 patch up the config descriptor 
  usb_copy_descriptors - copy a vector of USB descriptors
  @src: null-terminated vector to copy
  Context: initialization code, which may sleep
  This makes a copy of a vector of USB descriptors.  Its primary use
  is to support usb_function objects which can have multiple copies,
  each needing different descriptors.  Functions may have static
  tables of descriptors, which are used as templates and customized
  with identifiers (for interfaces, strings, endpoints, and more)
  as needed by a given function instance.
 count descriptors and their sizes; then add vector size 
	 fill in pointers starting at "tmp",
	  to descriptors copied starting at "mem";
	  and return "ret"
	 super-speed-plus descriptor falls back to super-speed one,
	  if such a descriptor was provided, thus avoiding a NULL
	  pointer dereference if a 5gbps capable gadget is used with
	  a 10gbps capable config (device port + cable + host port)
 SPDX-License-Identifier: GPL-2.0
  u_f.c -- USB function utilities for Gadget stack
  Copyright (c) 2013 Samsung Electronics Co., Ltd.
 		http:www.samsung.com
  Author: Andrzej Pietrasiewicz <andrzejtp2010@gmail.com>
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0+
  multi.c -- Multifunction Composite driver
  Copyright (C) 2008 David Brownell
  Copyright (C) 2008 Nokia Corporation
  Copyright (C) 2009 Samsung Electronics
  Author: Michal Nazarewicz (mina86@mina86.com)
 Device Descriptor 
 Linux Foundation 
 Multifunction Composite Gadget 
 .bcdUSB = DYNAMIC 
 0xEF ,
 Vendor and product id can be overridden by module parameters.  
 end of list 
 en-us 
 Configurations 
  Number of buffers we will use.
  2 is usually enough for good buffering pipeline
 CONFIG_USB_GADGET_DEBUG_FILES 
 no prefix , fsg_mod_data);
 RNDIS 
 CDC ECM 
 implicit port_num is zero 
 Gadget Bind 
	
	  If both ecm and rndis are selected then:
	 	1) rndis borrows the net interface from ecm
	 	2) since the interface is shared it must not be bound
	 	twice - in ecm's _and_ rndis' binds, so do it here.
 set up serial link layer 
 set up mass storage function 
 allocate string IDs 
 register configurations 
 we're done 
 error recovery 
 Some noise 
 SPDX-License-Identifier: GPL-2.0+
  inode.c -- user mode filesystem api for usb gadget controllers
  Copyright (C) 2003-2004 David Brownell
  Copyright (C) 2003 Agilent Technologies
 #define VERBOSE_DEBUG 
  The gadgetfs API maps each endpoint to a file descriptor so that you
  can use standard synchronous readwrite calls for IO.  There's some
  O_NONBLOCK and O_ASYNCFASYNC style io support.  Example usermode
  drivers show how this works in practice.  You can also use AIO to
  eliminate IO gaps between requests, to help when streaming data.
  Key parts that must be USB-specific are protocols defining how the
  readwrite operations relate to the hardware state machines.  There
  are two types of files.  One type is for the device, implementing ep0.
  The other type is for each IN or OUT endpoint.  In both cases, the
  user mode driver must configure the hardware before using it.
  - First, dev_config() is called when devgadget$CHIP is configured
    (by writing configuration and device descriptors).  Afterwards it
    may serve as a source of device events, used to handle all control
    requests other than basic enumeration.
  - Then, after a SET_CONFIGURATION control request, ep_config() is
    called when each devgadgetep file is configured (by writing
    endpoint descriptors).  Afterwards these files are used to write()
    IN data or to read() OUT data.  To halt the endpoint, a "wrong
    direction" request is issued (like reading an IN endpoint).
  Unlike "usbfs" the only ioctl()s are for things that are rare, and maybe
  not possible on all hardware.  For example, precise fault handling with
  respect to data left in endpoint fifos after aborted operations; or
  selective clearing of endpoint halts, to implement SET_INTERFACE.
----------------------------------------------------------------------
 devgadget$CHIP represents ep0 and the whole device 
 DISABLED is the initial state. 
	 Only one open() of devgadget$CHIP; only one file tracks
	  ep0device io modes and binding to the controller.  Driver
	  must always write descriptors to initialize the device, then
	  the device becomes UNCONNECTED until enumeration.
	 From then on, ep0 fd is in either of two basic modes:
	  - (UN)CONNECTED: read usb_gadgetfs_event(s) from it
	  - SETUP: readwrite will transfer control data and succeed;
	    or if "wrong direction", performs protocol stall
	 UNBOUND means the driver closed ep0, so the device won't be
	  accessible again (DEV_DISABLED) until all fds are closed.
 enough for the whole queue: most events invalidate others 
 P: lock 
	 drivers reading ep0 MUST handle control requests (SETUP)
	  reported that way; else the host will time out.
 the rest is basically write-once 
 except this scratch io buffer for ep0 
 needs no more cleanup 
----------------------------------------------------------------------
 other devgadget$ENDPOINT files represent endpoints 
 must hold dev->lock before accessing ep or req 
 needs no more cleanup 
----------------------------------------------------------------------
 most "how to use the hardware" policy choices are in userspace:
  mapping endpoint roles (which the driver needs) to the capabilities
  which the usb controller has.  most of those capabilities are exposed
  implicitly, starting with the driver name and then endpoint names.
----------------------------------------------------------------------
 NOTE:  don't use dev_printk calls before binding to the gadget
  at the end of ep0 configuration, or after unbind.
 too wordy: dev_printk(level , &(d)->gadget->dev , fmt , ## args) 
 DEBUG 
 DEBUG 
----------------------------------------------------------------------
 SYNCHRONOUS ENDPOINT OPERATIONS (bulkintriso)
  After opening, configure non-control endpoints.  Then use normal
  stream read() and write() requests; and maybe ioctl() to get more
  precise FIFO status when recovering from cancellation.
 tasklock endpoint, returning when it's connected.
  still need dev->lock to use epdata->ep.
 not configured yet 
 clean disconnect 
 case STATE_EP_DISABLED:		 "can't happen" 
 error! 
 clean up if this can be reopened 
----------------------------------------------------------------------
 ASYNCHRONOUS ENDPOINT IO OPERATIONS (bulkintriso) 
 spin_lock(&epdata->dev->lock);
 spin_unlock(&epdata->dev->lock);
 completing the iocb can drop the ctx and mm, don't touch mm after 
 lock against disconnect (and ideally, cancel) 
	 if this was a write or a read returning no data then we
	  don't need to copy anything to userspace, so we can
	  complete the aio request immediately.
 ep_copy_to_user() won't report both; we hide some faults 
 mm teardown waits for iocbs in exit_aio() 
	 each kiocb is coupled to one usb_request, but we can't
	  allocate or submit those if the host disconnected.
 halt any endpoint by doing a "wrong direction" io call 
 halt any endpoint by doing a "wrong direction" io call 
----------------------------------------------------------------------
 used after endpoint configuration 
 ENDPOINT INITIALIZATION
      fd = open ("devgadget$ENDPOINT", O_RDWR)
      status = write (fd, descriptors, sizeof descriptors)
  That write establishes the endpoint configuration, configuring
  the controller to process bulk, interrupt, or isochronous transfers
  at the right maxpacket size, and so on.
  The descriptors are message type 1, identified by a host order u32
  at the beginning of what's written.  Descriptor order is: fulllow
  speed descriptor, then optional high speed descriptor.
 we might need to change message format someday 
	 NOTE:  audio endpoint extensions not accepted here;
	  just don't include the extra bytes.
 fulllow speed descriptor, then high speed 
 fails if caller didn't provide that descriptor... 
----------------------------------------------------------------------
 EP0 IMPLEMENTATION can be partly in userspace.
  Drivers that use this facility receive various events, including
  control requests the kernel doesn't handle.  Drivers that don't
  use this facility may be too simple-minded for real applications.
 for control OUT, data must still get to userspace 
 clean up as appropriate 
 report fd mode change before acting on it 
 control DATA stage 
 stall IN 
 ack SET_CONFIGURATION etc 
 assume that was SET_CONFIGURATION 
 collect OUT data 
 FIXME state could change from under us 
 NOTE userspace can't yet choose to stall 
 else normal: return event data 
 return queued events right away 
 ep0 io has special semantics during STATE_DEV_SETUP 
			 NOTE this doesn't guard against broken drivers;
			  concurrent ep0 readers may lose events.
 wait for events 
 these events purge the queue 
 previous request timed out 
 same effect 
 these events can't be repeated 
 indices start at zero, for simplicity 
 report fd mode change before acting on it 
 data andor status stage for control request 
 can stall some OUT transfers 
 caller must F_SETOWN before signal delivery happens
 closing ep0 === shutdown all 
	 at this point "good" hardware has disconnected the
	  device from USB; the host won't see it any more.
	  alternatively, all host requests will time out.
 other endpoints were all decoupled from this device 
 report fd mode change before acting on it 
 Not bound to a UDC 
----------------------------------------------------------------------
 The in-kernel gadget driver handles most ep0 issues, in particular
  enumerating the single configuration (as provided from user space).
  Unrecognized ep0 requests may be handled in user space.
 assumes ep0 uses the same value for both speeds ... 
 only one configuration 
	 host may have given up waiting for response.  we can miss control
	  requests handled lower down (deviceendpoint status and features);
	  then ep0_{read,write} will report the wrong status. controller
	  driver will have aborted pending io.
 all others are errors
 currently one config, two speeds 
 mA  );
 user mode expected to disable endpoints
		 report SET_CONFIGURATION like any other control request,
		  except that usermode may not stall this.  the next
		  request mustn't be allowed start until this finishes:
		  endpoints and threads set up, etc.
		 
		  NOTE:  older PXA hardware (before PXA 255: without UDCCFR)
		  has badracey automagic that prevents synchronizing here.
		  even kernel mode drivers often miss them.
 PXA automagically handles this request too 
 if there's an ep0 reader, don't stall 
 read DATA stage for OUT right away 
 we can't currently stall these 
 state changes when reader collects event 
 proceed with data transfer and status phases? 
 device stalls when value < 0 
 dev->state must prevent interference 
 break link to FS 
 break link to controller 
 break link to dcache 
 we've already been disconnected ... no io is active 
 preallocate control response and buffer 
 VERY odd... host died??
----------------------------------------------------------------------
 DEVICE INITIALIZATION
      fd = open ("devgadget$CHIP", O_RDWR)
      status = write (fd, descriptors, sizeof descriptors)
  That write establishes the device configuration, so the kernel can
  bind to the controller ... guaranteeing it can handle enumeration
  at all necessary speeds.  Descriptor order is:
  . message tag (u32, host order) ... for now, must be zero; it
 	would change to support features like multi-config devices
  . fulllow speed config ... all wTotalLength bytes (with interface,
 	class, altsetting, endpoint, and other descriptors)
  . high speed config ... all descriptors, for high speed operation;
 	this one's optional except for high-speed hardware
  . device descriptor
  Endpoints are not yet enabled. Drivers must wait until device
  configuration and interface altsetting changes create
  the need to configure (or unconfigure) them.
  After initialization, the device stays active for as long as that
  $CHIP file is open.  Events must then be read from that descriptor,
  such as configuration notifications.
 FIXME if gadget->is_otg, _must_ include an otg descriptor 
 FIXME check lengths: walk to end 
 we might need to change message format someday 
 full or low speed config 
 optional high speed config 
 could support multiple configs, using another encoding! 
 device descriptor (tweaked for paranoia) 
 triggers gadgetfs_bind(); then we can enumerate. 
		 at this point "good" hardware has for the first time
		  let the USB the host see us.  alternatively, if users
		  unplugreplug that will clear all the error state.
		 
		  note:  everything running before here was guaranteed
		  to choke driver model style diagnostics.  from here
		  on, they can work ... except in cleanup paths that
		  kick in after the ep0 descriptor is closed.
----------------------------------------------------------------------
 FILESYSTEM AND SUPERBLOCK OPERATIONS
  Mounting the filesystem creates a controller file, used first for
  device configuration then later for event monitoring.
 FIXME PAM etc could set this security policy without mount options
  if epfiles inherited ownership and permissons from ep0 ...
 creates in fs root directory, so non-renamable and non-linkable.
  so inode and dentry are paired, until device reconfig.
 superblock 
 root inode 
	 the ep0 file is named after the controller we expect;
	  user mode code can use it for sanity checks, like we do.
	 other endpoint files are available after hardware setup,
	  from binding to a controller.
 "mount -t gadgetfs path devgadget" ends up here 
----------------------------------------------------------------------
----------------------------------------------------------------------
 SPDX-License-Identifier: GPL-2.0+
  serial.c -- USB gadget serial driver
  Copyright (C) 2003 Al Borchers (alborchers@steinerpoint.com)
  Copyright (C) 2008 by David Brownell
  Copyright (C) 2008 by Nokia Corporation
 Defines 
-------------------------------------------------------------------------
 Thanks to NetChip Technologies for donating this product ID.
 DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!
 Instead:  allocate your own, using normal USB-IF procedures.
 NetChip 
 Linux-USB Serial Gadget 
 ... as CDC-ACM 
 ... as CDC-OBEX 
 string IDs are assigned dynamically 
 updated; f(use_acm) ,
 end of list 
 en-us 
 .bcdUSB = DYNAMIC 
 .bDeviceClass = f(use_acm) 
 .bMaxPacketSize0 = f(hardware) 
 .idProduct =	f(use_acm) 
 .iManufacturer = DYNAMIC 
 .iProduct = DYNAMIC 
-------------------------------------------------------------------------
 Module 
 called for no-arg enable == default 
-------------------------------------------------------------------------
 .label = f(use_acm) 
 .bConfigurationValue = f(use_acm) 
 .iConfiguration = DYNAMIC 
	 Allocate string descriptor numbers ... note that string
	  contents can be overridden by the composite_dev glue.
 register our configuration 
 init() was not called, yet 
	 We could export two configs; that'd be much cleaner...
	  but neither of these product IDs was defined that way.
 SPDX-License-Identifier: GPL-2.0+
  acm_ms.c -- Composite driver, with ACM and mass storage support
  Copyright (C) 2008 David Brownell
  Copyright (C) 2008 Nokia Corporation
  Author: David Brownell
  Modified: Klaus Schwarzkopf <schwarzkopf@sensortherm.de>
  Heavily based on multi.c and cdc2.c
-------------------------------------------------------------------------
  DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!
  Instead:  allocate your own, using normal USB-IF procedures.
 Linux Foundation 
 Composite Gadget: ACM + MS
-------------------------------------------------------------------------
 .bcdUSB = DYNAMIC 
 0xEF ,
 .bMaxPacketSize0 = f(hardware) 
 Vendor and product id can be overridden by module parameters.  
 .bcdDevice = f(hardware) 
 .iManufacturer = DYNAMIC 
 .iProduct = DYNAMIC 
 NO SERIAL NUMBER 
.bNumConfigurations =	DYNAMIC
 string IDs are assigned dynamically 
 end of list 
 en-us 
 Configurations 
  Number of buffers we will use.
  2 is usually enough for good buffering pipeline
 CONFIG_USB_GADGET_DEBUG_FILES 
 no prefix , fsg_mod_data);
-------------------------------------------------------------------------
  We _always_ have both ACM and mass storage functions.
 .iConfiguration = DYNAMIC 
-------------------------------------------------------------------------
 set up mass storage function 
	
	  Allocate string descriptor numbers ... note that string
	  contents can be overridden by the composite_dev glue.
 register our configuration 
 error recovery 
 SPDX-License-Identifier: GPL-2.0
 Target based USB-Gadget
  UAS protocol handling, target callbacks, configfs handling,
  BBB (USB Mass Storage Class Bulk-Only (BBB) and Transport protocol handling.
  Author: Sebastian Andrzej Siewior <bigeasy at linutronix dot de>
 NetChip 
 Linux-USB File-backed Storage Gadget 
 .bcdUSB = DYNAMIC 
 SPDX-License-Identifier: GPL-2.0
  dbgp.c -- EHCI Debug Port device gadget
  Copyright (C) 2010 Stephane Duverger
  Released under the GPLv2.
 verbose messages 
 NetChip 
 undefined 
 SPDX-License-Identifier: GPL-2.0
  USB Raw Gadget driver.
  See Documentationusbraw-gadget.rst for more details.
  Copyright (c) 2020 Google, Inc.
  Author: Andrey Konovalov <andreyknvl@gmail.com>
----------------------------------------------------------------------
 See the comment in raw_event_queue_fetch() for locking details. 
	
	  This function can be called concurrently. We first check that
	  there's at least one event queued by decrementing the semaphore,
	  and then take the lock to protect queue struct fields.
	
	  queue->size must have the same value as queue->sema counter (before
	  the down_interruptible() call above), so this check is a fail-safe.
----------------------------------------------------------------------
 Reference to misc device: 
 Protected by lock: 
 Matches kref_put() in raw_release(). 
----------------------------------------------------------------------
	 If the endpoint has fixed function (named as e.g. "ep12out-bulk"),
	  parse the endpoint address from its name. We deliberately use
	  deprecated simple_strtoul() function here, as the number isn't
	  followed by '\0' nor '\n'.
 Otherwise the endpoint is configurable (named as e.g. "ep-a"). 
 Matches kref_put() in gadget_unbind(). 
 Matches kref_get() in gadget_bind(). 
 These are currently unused but present in case UDC driver requires them. 
----------------------------------------------------------------------
 Nonblocking IO is not supported yet. 
 Matches kref_get() in raw_ioctl_run(). 
 Matches dev_new() in raw_open(). 
----------------------------------------------------------------------
 Matches kref_put() in raw_release(). 
	
	  Endpoints with a maxpacket length of 0 can cause crashes in UDC
	  drivers.
----------------------------------------------------------------------
 SPDX-License-Identifier: GPL-2.0+
  printer.c -- Printer gadget driver
  Copyright (C) 2003-2005 David Brownell
  Copyright (C) 2006 Craig W. Nadler
-------------------------------------------------------------------------
 DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!
  Instead:  allocate your own, using normal USB-IF procedures.
 Thanks to NetChip Technologies for donating this product ID.
 NetChip 
 Linux-USB Printer Gadget 
 Some systems will want different product identifiers published in the
  device descriptor, either numbers or strings or both.  These string
  parameters are in UTF-8 (superset of ASCII's 7 bit characters).
 Number of requests to allocate per endpoint, not used for ep0. 
-------------------------------------------------------------------------
  DESCRIPTORS ... most are static, but strings and (full) configuration
  descriptors are built on demand.
 .bcdUSB = DYNAMIC 
-------------------------------------------------------------------------
 descriptors that are built on-demand 
 static strings, in UTF-8 
 end of list 
 en-us 
		
		  we don't free this memory in case of error
		  as printer cleanup func will do this for us
 SPDX-License-Identifier: GPL-2.0+
  cdc2.c -- CDC Composite driver, with ECM and ACM support
  Copyright (C) 2008 David Brownell
  Copyright (C) 2008 Nokia Corporation
-------------------------------------------------------------------------
 DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!
  Instead:  allocate your own, using normal USB-IF procedures.
 Thanks to NetChip Technologies for donating this product ID.
  It's for devices with only this composite CDC configuration.
 NetChip 
 CDC Composite: ECM + ACM 
-------------------------------------------------------------------------
 .bcdUSB = DYNAMIC 
 .bMaxPacketSize0 = f(hardware) 
 Vendor and product id can be overridden by module parameters.  
 .bcdDevice = f(hardware) 
 .iManufacturer = DYNAMIC 
 .iProduct = DYNAMIC 
 NO SERIAL NUMBER 
 string IDs are assigned dynamically 
 end of list 
 en-us 
-------------------------------------------------------------------------
  We _always_ have both CDC ECM and CDC ACM functions.
 .iConfiguration = DYNAMIC 
-------------------------------------------------------------------------
	 Allocate string descriptor numbers ... note that string
	  contents can be overridden by the composite_dev glue.
 register our configuration 
 SPDX-License-Identifier: GPL-2.0
  nokia.c -- Nokia Composite Gadget Driver
  Copyright (C) 2008-2010 Nokia Corporation
  Contact: Felipe Balbi <felipe.balbi@nokia.com>
  This gadget driver borrows from serial.c which is:
  Copyright (C) 2003 Al Borchers (alborchers@steinerpoint.com)
  Copyright (C) 2008 by David Brownell
  Copyright (C) 2008 by Nokia Corporation
 Defines 
  Number of buffers we will use.
  2 is usually enough for good buffering pipeline
 CONFIG_USB_DEBUG 
 no prefix , fsg_mod_data);
 Nokia 
 Nokia Gadget 
 string IDs are assigned dynamically 
 end of list 
 en-us 
 .bcdUSB = DYNAMIC 
 .iManufacturer = DYNAMIC 
 .iProduct = DYNAMIC 
-------------------------------------------------------------------------
 Module 
-------------------------------------------------------------------------
 .iConfiguration = DYNAMIC 
 .iConfiguration = DYNAMIC 
 set up mass storage function 
 finally register the configuration 
 SPDX-License-Identifier: GPL-2.0+
 	webcam.c -- USB webcam gadget driver
 	Copyright (C) 2009-2010
 	    Laurent Pinchart (laurent.pinchart@ideasonboard.com)
-------------------------------------------------------------------------
 module parameters specific to the Video streaming endpoint 
 --------------------------------------------------------------------------
  Device descriptor
 Linux Foundation 
 Webcam AV gadget 
 0.10 
 string IDs are assigned dynamically 
 en-us 
 .bcdUSB = DYNAMIC 
 dynamic 
 dynamic 
 dynamic 
 dynamic 
 dynamic 
 dynamic 
 dynamic 
 dynamic 
 dynamic 
 dynamic 
 --------------------------------------------------------------------------
  USB configuration
 dynamic 
	 Allocate string descriptor numbers ... note that string contents
	  can be overridden by the composite_dev glue.
 Register our configuration. 
 --------------------------------------------------------------------------
  Driver
 SPDX-License-Identifier: GPL-2.0+
  mass_storage.c -- Mass Storage USB Gadget
  Copyright (C) 2003-2008 Alan Stern
  Copyright (C) 2009 Samsung Electronics
                     Author: Michal Nazarewicz <mina86@mina86.com>
  All rights reserved.
  The Mass Storage Gadget acts as a USB Mass Storage device,
  appearing to the host as a disk drive or as a CD-ROM drive.  In
  addition to providing an example of a genuinely useful gadget
  driver for a USB device, it also illustrates a technique of
  double-buffering for increased throughput.  Last but not least, it
  gives an easy way to probe the behavior of the Mass Storage drivers
  in a USB host.
  Since this file serves only administrative purposes and all the
  business logic is implemented in f_mass_storage. file.  Read
  comments in this file for more detailed description.
-------------------------------------------------------------------------
  Thanks to NetChip Technologies for donating this product ID.
  DO NOT REUSE THESE IDs with any other driver!!  Ever!!
  Instead:  allocate your own, using normal USB-IF procedures.
 NetChip 
 Linux-USB File-backed Storage Gadget 
-------------------------------------------------------------------------
 .bcdUSB = DYNAMIC 
 Vendor and product id can be overridden by module parameters.  
 end of list 
 en-us 
 Configurations 
  Number of buffers we will use.
  2 is usually enough for good buffering pipeline
 CONFIG_USB_GADGET_DEBUG_FILES 
 no prefix , mod_data);
 Gadget Bind 
 Some noise 
 SPDX-License-Identifier: GPL-2.0+
  ether.c -- Ethernet gadget driver, with CDC and non-CDC options
  Copyright (C) 2003-2005,2008 David Brownell
  Copyright (C) 2003-2004 Robert Schwebel, Benedikt Spranger
  Copyright (C) 2008 Nokia Corporation
 #define VERBOSE_DEBUG 
  Ethernet gadget driver -- with CDC and non-CDC options
  Builds on hardware support for a full duplex link.
  CDC Ethernet is the standard USB solution for sending Ethernet frames
  using USB.  Real hardware tends to use the same framing protocol but look
  different for control features.  This driver strongly prefers to use
  this USB-IF standard as its open-systems interoperability solution;
  most host side USB stacks (except from Microsoft) support it.
  This is sometimes called "CDC ECM" (Ethernet Control Model) to support
  TLA-soup.  "CDC ACM" (Abstract Control Model) is for modems, and a new
  "CDC EEM" (Ethernet Emulation Model) is starting to spread.
  There's some hardware that can't talk CDC ECM.  We make that hardware
  implement a "minimalist" vendor-agnostic CDC core:  same framing, but
  link-level setup only requires activating the configuration.  Only the
  endpoint descriptors, and productvendor IDs, are relevant; no control
  operations are available.  Linux supports it, but other host operating
  systems may not.  (This is a subset of CDC Ethernet.)
  It turns out that if you add a few descriptors to that "CDC Subset",
  (Windows) host side drivers from MCCI can treat it as one submode of
  a proprietary scheme called "SAFE" ... without needing to know about
  specific productvendor IDs.  So we do that, making it easier to use
  those MS-Windows drivers.  Those added descriptors make it resemble a
  CDC MDLM device, but they don't change device behavior at all.  (See
  MCCI Engineering report 950198 "SAFE Networking Functions".)
  A third option is also in use.  Rather than CDC Ethernet, or something
  simpler, Microsoft pushes their own approach: RNDIS.  The published
  RNDIS specs are ambiguous and appear to be incomplete, and are also
  needlessly complex.  They borrow more from CDC ACM than CDC ECM.
  This driver aims for interoperability by using CDC ECM unless
 		can_support_ecm()
  returns false, in which case it supports the CDC Subset.  By default,
  that returns true; most hardware has no problems with CDC ECM, that's
  a good default.  Previous versions of this driver had no default; this
  version changes that, removing overhead for new controller support.
 	IF YOUR HARDWARE CAN'T SUPPORT CDC ECM, UPDATE THAT ROUTINE!
-------------------------------------------------------------------------
 DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!
  Instead:  allocate your own, using normal USB-IF procedures.
 Thanks to NetChip Technologies for donating this product ID.
  It's for devices with only CDC Ethernet configurations.
 NetChip 
 Linux-USB Ethernet Gadget 
 For hardware that can't talk CDC, we use the same vendor ID that
  ARM Linux has used for ethernet-over-usb, both with sa1100 and
  with pxa250.  We're protocol-compatible, if the host-side drivers
  use the endpoint descriptors.  bcdDevice (version) is nonzero, so
  drivers that need to hard-wire endpoint numbers have a hook.
  The protocol is a minimal subset of CDC Ether, which works on any bulk
  hardware that's not deeply broken ... even on hardware that can't talk
  RNDIS (like SA-1100, with no interrupt endpoint, or anything that
  doesn't handle control-OUT).
 For hardware that can talk RNDIS and either of the above protocols,
  use this ID ... the windows INF files will know it.  Unless it's
  used with CDC Ethernet, Linux 2.4 hosts will need updates to choose
  the non-RNDIS configuration.
 NetChip 
 EthernetRNDIS Gadget 
 For EEM gadgets 
 Linux Foundation 
 EEM Gadget 
-------------------------------------------------------------------------
 .bcdUSB = DYNAMIC 
 .bMaxPacketSize0 = f(hardware) 
	 Vendor and product id defaults change according to what configs
	  we support.  (As does bNumConfigurations.)  These values can
	  also be overridden by module parameters.
 .bcdDevice = f(hardware) 
 .iManufacturer = DYNAMIC 
 .iProduct = DYNAMIC 
 NO SERIAL NUMBER 
 end of list 
 en-us 
-------------------------------------------------------------------------
  We may not have an RNDIS configuration, but if we do it needs to be
  the first one present.  That's to make Microsoft's drivers happy,
  and to follow DOCSIS 1.0 (cable modem standard).
 FIXME alloc iConfiguration string, set it in c->strings 
 .iConfiguration = DYNAMIC 
-------------------------------------------------------------------------
  We _always_ have an ECM, CDC Subset, or EEM configuration.
 FIXME alloc iConfiguration string, set it in c->strings 
 .label = f(hardware) 
 .iConfiguration = DYNAMIC 
-------------------------------------------------------------------------
 set up main config label and device descriptor 
 EEM 
 ECM 
 CDC Subset 
 RNDIS plus ECM-or-Subset 
	 Allocate string descriptor numbers ... note that string
	  contents can be overridden by the composite_dev glue.
 register our configuration(s); RNDIS first, if it's used 
 SPDX-License-Identifier: GPL-2.0
  gmidi.c -- USB MIDI Gadget Driver
  Copyright (C) 2006 Thumtronics Pty Ltd.
  Developed for Thumtronics by Grey Innovation
  Ben Williamson <ben.williamson@greyinnovation.com>
  This code is based in part on:
  Gadget Zero driver, Copyright (C) 2003-2004 David Brownell.
  USB Audio driver, Copyright (C) 2002 by Takashi Iwai.
  USB MIDI driver, Copyright (C) 2002-2005 Clemens Ladisch.
  Refer to the USB Device Class Definition for MIDI Devices:
  http:www.usb.orgdevelopersdevclass_docsmidi10.pdf
 #define VERBOSE_DEBUG 
-------------------------------------------------------------------------
 Thanks to Grey Innovation for donating this product ID.
  DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!
  Instead:  allocate your own, using normal USB-IF procedures.
 Grey Innovation 
 Linux-USB "MIDI Gadget" 
 string IDs are assigned dynamically 
 .bcdUSB = DYNAMIC 
 .iManufacturer =	DYNAMIC 
 .iProduct =		DYNAMIC 
 end of list 
 en-us 
 .iConfiguration = DYNAMIC 
 SPDX-License-Identifier: GPL-2.0+
  zero.c -- Gadget Zero, for USB development
  Copyright (C) 2003-2008 David Brownell
  Copyright (C) 2008 by Nokia Corporation
  Gadget Zero only needs two bulk endpoints, and is an example of how you
  can write a hardware-agnostic gadget driver running inside a USB device.
  Some hardware details are visible, but don't affect most of the driver.
  Use it with the Linux host side "usbtest" driver to get a basic functional
  test of your device-side usb stack, or with "usb-skeleton".
  It supports two similar configurations.  One sinks whatever the usb host
  writes, and in return sources zeroes.  The other loops whatever the host
  writes back, so the host can read it.
  Many drivers will only have one configuration, letting them be much
  simpler if they also don't support high speed operation (like this
  driver does).
  Why is this driver using two configurations, rather than setting up
  two interfaces with different functions?  To help verify that multiple
  configuration infrastructure is working correctly; also, so that it can
  work with low capability USB controllers without four bulk endpoints.
  driver assumes self-powered hardware, and
  has no way for users to trigger remote wakeup.
 #define VERBOSE_DEBUG 
-------------------------------------------------------------------------
  Normally the "loopback" configuration is second (index 1) so
  it's not the default.  Here's where to change that order, to
  work better with hosts where config changes are problematic or
  controllers (like original superh) that only support one config.
-------------------------------------------------------------------------
 Thanks to NetChip Technologies for donating this product ID.
  DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!
  Instead:  allocate your own, using normal USB-IF procedures.
 NetChip 
 Linux-USB "Gadget Zero" 
 OTG test device IDs 
 If the optional "autoresume" mode is enabled, it provides good
  functional coverage for the "USBCV" test harness from USB-IF.
  It's always set if OTG mode is enabled.
 Maximum Autoresume time 
 Interval between two remote wakeups 
-------------------------------------------------------------------------
 .bcdUSB = DYNAMIC 
 string IDs are assigned dynamically 
 default serial number takes at least two packets 
 end of list 
 en-us 
-------------------------------------------------------------------------
 unconfigured devices can't issue wakeups 
	 Normally the host would be woken up for something
	  more significant than just a timer firing; likely
	  because of some direct user request.
-------------------------------------------------------------------------
 .iConfiguration = DYNAMIC 
 .iConfiguration      = DYNAMIC 
	 Allocate string descriptor numbers ... note that string
	  contents can be overridden by the composite_dev glue.
 support autoresume for remote wakeup testing 
 support OTG systems 
	 Register primary, then secondary configuration.  Note that
	  SH3 only allows one config...
 SPDX-License-Identifier: GPL-2.0+
  hid.c -- HID Composite driver
  Based on multi.c
  Copyright (C) 2010 Fabien Chouteau <fabien.chouteau@barco.com>
-------------------------------------------------------------------------
 XXX NetChip 
 Linux-USB HID gadget 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 .bcdUSB = DYNAMIC 
 .bDeviceClass =		USB_CLASS_COMM, 
 .bDeviceSubClass =	0, 
 .bDeviceProtocol =	0, 
 .bMaxPacketSize0 = f(hardware) 
 Vendor and product id can be overridden by module parameters.  
 .bcdDevice = f(hardware) 
 .iManufacturer = DYNAMIC 
 .iProduct = DYNAMIC 
 NO SERIAL NUMBER 
 string IDs are assigned dynamically 
 end of list 
 en-us 
 Configurations 
 .iConfiguration = DYNAMIC 
 Gadget Bind 
	 Allocate string descriptor numbers ... note that string
	  contents can be overridden by the composite_dev glue.
 register our configuration 
 Some noise 
 SPDX-License-Identifier: GPL-2.0+
  ncm.c -- NCM gadget driver
  Copyright (C) 2010 Nokia Corporation
  Contact: Yauheni Kaliuta <yauheni.kaliuta@nokia.com>
  The driver borrows from ether.c which is:
  Copyright (C) 2003-2005,2008 David Brownell
  Copyright (C) 2003-2004 Robert Schwebel, Benedikt Spranger
  Copyright (C) 2008 Nokia Corporation
 #define DEBUG 
 #define VERBOSE_DEBUG 
-------------------------------------------------------------------------
 DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!
  Instead:  allocate your own, using normal USB-IF procedures.
 Thanks to NetChip Technologies for donating this product ID.
  It's for devices with only CDC Ethernet configurations.
 NetChip 
 Linux-USB Ethernet Gadget 
-------------------------------------------------------------------------
 .bcdUSB = DYNAMIC 
 .bMaxPacketSize0 = f(hardware) 
	 Vendor and product id defaults change according to what configs
	  we support.  (As does bNumConfigurations.)  These values can
	  also be overridden by module parameters.
 .bcdDevice = f(hardware) 
 .iManufacturer = DYNAMIC 
 .iProduct = DYNAMIC 
 NO SERIAL NUMBER 
 string IDs are assigned dynamically 
 end of list 
 en-us 
-------------------------------------------------------------------------
 FIXME alloc iConfiguration string, set it in c->strings 
 .label = f(hardware) 
 .iConfiguration = DYNAMIC 
-------------------------------------------------------------------------
	 Allocate string descriptor numbers ... note that string
	  contents can be overridden by the composite_dev glue.
 SPDX-License-Identifier: GPL-2.0+
  g_ffs.c -- user mode file system API for USB composite function controllers
  Copyright (C) 2010 Samsung Electronics
  Author: Michal Nazarewicz <mina86@mina86.com>
 Linux Foundation 
 FunctionFS Gadget 
 .bcdUSB = DYNAMIC 
 String IDs are assigned dynamically 
 end of list 
 en-us 
	
	  Allocate in one chunk for easier maintenance
  The caller of this function takes ffs_lock
  The caller of this function takes ffs_lock
  It is assumed that gfs_bind is called from a context where ffs_lock is held
 TODO: gstrings_attach? 
 TODO 
  It is assumed that gfs_unbind is called from a context where ffs_lock is held
  It is assumed that gfs_do_config is called from a context where
  ffs_lock is held
	
	  After previous do_configs there may be some invalid
	  pointers in c->interface array.  This happens every time
	  a user space function with fewer interfaces than a user
	  space function that was run before the new one is run.  The
	  compasit's set_config() assumes that if there is no more
	  then MAX_CONFIG_INTERFACES interfaces in a configuration
	  then there is a NULL pointer after the last interface in
	  c->interface array.  We need to make sure this is true.
 SPDX-License-Identifier: GPL-2.0+
  audio.c -- Audio gadget driver
  Copyright (C) 2008 Bryan Wu <cooloney@kernel.org>
  Copyright (C) 2008 Analog Devices, Inc
 #define VERBOSE_DEBUG 
 Playback(USB-IN) Default Stereo - FlFr 
 Playback Default 48 KHz 
 Playback Default 16bitssample 
 Capture(USB-OUT) Default Stereo - FlFr 
 Capture Default 64 KHz 
 Capture Default 16bitssample 
 Playback(USB-IN) Default Stereo - FlFr 
 Playback Default 48 KHz 
 Playback Default 16bitssample 
 Capture(USB-OUT) Default Stereo - FlFr 
 Capture Default 48 KHz 
 Capture Default 16bitssample 
 CONFIG_GADGET_UAC1_LEGACY 
 CONFIG_GADGET_UAC1_LEGACY 
 string IDs are assigned dynamically 
 end of list 
 en-us 
-------------------------------------------------------------------------
 DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!
  Instead:  allocate your own, using normal USB-IF procedures.
 Thanks to Linux Foundation for donating this product ID. 
 Linux Foundation 
 Linux-USB Audio Gadget 
-------------------------------------------------------------------------
 .bcdUSB = DYNAMIC 
 .bMaxPacketSize0 = f(hardware) 
	 Vendor and product id defaults change according to what configs
	  we support.  (As does bNumConfigurations.)  These values can
	  also be overridden by module parameters.
 .bcdDevice = f(hardware) 
 .iManufacturer = DYNAMIC 
 .iProduct = DYNAMIC 
 NO SERIAL NUMBER 
-------------------------------------------------------------------------
 FIXME alloc iConfiguration string, set it in c->strings 
 .iConfiguration = DYNAMIC 
-------------------------------------------------------------------------
 CONFIG_GADGET_UAC1_LEGACY 
 CONFIG_GADGET_UAC1_LEGACY 
 SPDX-License-Identifier: GPL-2.0+
  USB Peripheral Controller driver for Aeroflex Gaisler GRUSBDC.
  2013 (c) Aeroflex Gaisler AB
  This driver supports GRUSBDC USB Device Controller cores available in the
  GRLIB VHDL IP core library.
  Full documentation of the GRUSBDC core can be found here:
  https:www.gaisler.comproductsgrlibgrip.pdf
  Contributors:
  - Andreas Larsson <andreas@gaisler.com>
  - Marko Isomaki
  A GRUSBDC core can have up to 16 IN endpoints and 16 OUT endpoints each
  individually configurable to any of the four USB transfer types. This driver
  only supports cores in DMA mode.
 USB speed and corresponding string calculated from status register value 
 Size of hardware buffer calculated from epctrl register value 
 ---------------------------------------------------------------------- 
 Debug printout functionality 
 !VERBOSE_DEBUG 
 VERBOSE_DEBUG 
 ---------------------------------------------------------------------- 
 Debugfs functionality 
 !CONFIG_USB_GADGET_DEBUG_FS 
 CONFIG_USB_GADGET_DEBUG_FS 
 ---------------------------------------------------------------------- 
 DMA and request handling 
 Allocates a new struct gr_dma_desc, sets paddr and zeroes the rest 
 Frees the chain of struct gr_dma_desc for the given request 
  Frees allocated resources and calls the appropriate completion functionsetup
  package handler for a finished request.
  Must be called with dev->lock held and irqs disabled.
 For OUT, req->req.actual gets updated bit by bit 
		
		  Copy to user buffer in this case where length was not evenly
		  divisible by ep->ep.maxpacket and the last descriptor was
		  actually used.
 We got more data than was requested 
 Prevent changes to ep->queue during callback 
  Starts DMA for endpoint ep if there are requests in the queue.
  Must be called with dev->lock held and with !ep->stopped.
 A descriptor should already have been allocated 
	
	  The DMA controller can not handle smaller OUT buffers than
	  ep->ep.maxpacket. It could lead to buffer overruns if an unexpectedly
	  long packet are received. Therefore an internal bounce buffer gets
	  used when such a request gets enabled.
 Make sure all is settled before handing it over to DMA 
 Set the descriptor pointer in the hardware 
 Announce available descriptors 
  Finishes the first request in the ep's queue and, if available, starts the
  next request in queue.
  Must be called with dev->lock held, irqs disabled and with !ep->stopped.
 Regardless of ep->dma_start 
  Abort DMA for an endpoint. Sets the abort DMA bit which causes an ongoing DMA
  transfer to be canceled and clears GR_DMACTRL_DA.
  Must be called with dev->lock held.
  Allocates and sets up a struct gr_dma_desc and putting it on the descriptor
  chain.
  Size is not used for OUT endpoints. Hardware can not be instructed to handle
  smaller buffer than MAXPL in the OUT direction.
  Sets up a chain of struct gr_dma_descriptors pointing to buffers that
  together covers req->req.length bytes of the buffer at DMA address
  req->req.dma for the OUT direction.
  The first descriptor in the chain is enabled, the rest disabled. The
  interrupt handler will later enable them one by one when needed so we can
  find out when the transfer is finished. For OUT endpoints, all descriptors
  therefore generate interrutps.
 Bytes left to provide descriptors for 
 Bytes accommodated for 
 Signals that no allocation is done yet 
 Prepare using bounce buffer 
  Sets up a chain of struct gr_dma_descriptors pointing to buffers that
  together covers req->req.length bytes of the buffer at DMA address
  req->req.dma for the IN direction.
  When more data is provided than the maximum payload size, the hardware splits
  this up into several payloads automatically. Moreover, ep->bytes_per_buffer
  is always set to a multiple of the maximum payload (restricted to the valid
  number of maximum payloads during high bandwidth isochronous or interrupt
  transfers)
  All descriptors are enabled from the beginning and we only generate an
  interrupt for the last one indicating that the entire request has been pushed
  to hardware.
 Bytes left in req to provide descriptors for 
 Bytes in req accommodated for 
 Signals that no allocation is done yet 
 Allow for zero length packets 
	
	  Send an extra zero length packet to indicate that no more data is
	  available when req->req.zero is set and the data length is even
	  multiples of ep->ep.maxpacket.
	
	  For IN packets we only want to know when the last packet has been
	  transmitted (not just put into internal buffers).
 Must be called with dev->lock held 
 Can't touch registers when suspended 
 Set up DMA mapping in case the caller didn't 
 Start DMA if not started, otherwise interrupt handler handles it 
  Queue a request from within the driver.
  Must be called with dev->lock held.
 ---------------------------------------------------------------------- 
 General helper functions 
  Dequeue ALL requests.
  Must be called with dev->lock held and irqs disabled.
  Reset the hardware state of this endpoint.
  Must be called with dev->lock held.
  Generate STALL on ep0inout.
  Must be called with dev->lock held.
  Halts, halts and wedges, or clears halt for an endpoint.
  Must be called with dev->lock held.
 Never actually halt ep0, and therefore never clear halt for ep0 
 ep0 halt from gadget - generate protocol stall 
 Set HALT 
 Things might have been queued up in the meantime 
 Must be called with dev->lock held 
  Should only be called when endpoints can not generate interrupts.
  Must be called with dev->lock held.
 Make sure that we do not deny one of our interrupts 
  Stop all device activity and disable data line pullup.
  Must be called with dev->lock held and irqs disabled.
 ---------------------------------------------------------------------- 
 ep0 setup packet handling 
 Nothing needs to be done here 
  Queue a response on ep0in.
  Must be called with dev->lock held.
  Queue a 2 byte response on ep0in.
  Must be called with dev->lock held.
  Queue a ZLP response on ep0in.
  Must be called with dev->lock held.
  This is run when a SET_ADDRESS request is received. First writes
  the new address to the control register which is updated internally
  when the next IN packet is ACKED.
  Must be called with dev->lock held.
  Returns negative for STALL, 0 for successful handling and positive for
  delegation.
  Must be called with dev->lock held.
 Self powered | remote wakeup 
 Allow remote wakeup 
 The hardware does not support USB_TEST_FORCE_ENABLE 
 Disallow remote wakeup 
 Delegate the rest 
  Returns negative for STALL, 0 for successful handling and positive for
  delegation.
  Must be called with dev->lock held.
	
	  Should return STALL for invalid interfaces, but udc driver does not
	  know anything about that. However, many gadget drivers do not handle
	  GET_STATUS so we need to take care of that.
		
		  No possible valid standard requests. Still let gadget drivers
		  have a go at it.
 Delegate the rest 
  Returns negative for STALL, 0 for successful handling and positive for
  delegation.
  Must be called with dev->lock held.
 Delegate the rest 
 Must be called with dev->lock held 
  The main function dealing with setup requests on ep0.
  Must be called with dev->lock held and irqs disabled
 Restore from ep0 halt 
 Got expected ZLP 
 Handle SETUP packet 
 Check for data stage 
 Positive status flags delegation 
 Generate STALL on both ep0out and ep0in if requested 
 Not configured unless gadget OK:s it 
 Get ready for next stage 
 ---------------------------------------------------------------------- 
 VBUS and USB reset handling 
 Must be called with dev->lock held and irqs disabled  
 Turn on full interrupts and pullup 
 Must be called with dev->lock held 
 Make sure we do not ignore an interrupt 
 Take care of the case we are already plugged in at this point 
 Must be called with dev->lock held and irqs disabled 
 Report disconnect 
 Must be called with dev->lock held and irqs disabled 
 ---------------------------------------------------------------------- 
 Irq handling 
  Handles interrupts from in endpoints. Returns whether something was handled.
  Must be called with dev->lock held, irqs disabled and with !ep->stopped.
 Not put in hardware buffers yet 
 Not transmitted yet, still in hardware buffers 
 Write complete 
  Handles interrupts from out endpoints. Returns whether something was handled.
  Must be called with dev->lock held, irqs disabled and with !ep->stopped.
 Not received yet 
 Read complete 
 Short packet or >= expected size - we are done 
			
			  Send a status stage ZLP to ack the DATA stage in the
			  OUT direction. This needs to be done before
			  gr_dma_advance as that can lead to a call to
			  ep0_setup that can change dev->ep0state.
 Not done yet. Enable the next descriptor to receive more. 
  Handle state changes. Returns whether something was handled.
  Must be called with dev->lock held and irqs disabled.
 VBUS valid detected 
 Disconnect 
 USB reset detected 
 Speed change 
 Going into suspend 
 Coming out of suspend 
 Non-interrupt context irq handler 
	
	  Check IN ep interrupts. We check these before the OUT eps because
	  some gadgets reuse the request that might already be currently
	  outstanding and needs to be completed (mainly setup requests).
 Check OUT ep interrupts 
 Check status interrupts 
	
	  Check AMBA DMA errors. Only check if we didn't find anything else to
	  handle because this shouldn't happen if we did everything right.
 Interrupt context irq handler 
 ---------------------------------------------------------------------- 
 USB ep ops 
 Enable endpoint. Not for ep0in and ep0out that are handled separately. 
 'ep0' IN and OUT are reserved 
 Make sure we are clear for enabling 
 Check that directions match 
 Check ep num 
	
	  Bits 10-0 set the max payload. 12-11 set the number of
	  additional transactions.
		
		  Maximum possible size of all payloads in one microframe
		  regardless of direction when using high-bandwidth mode.
		
		  The biggest multiple of maximum packet size that fits into
		  the buffer. The hardware will split up into many packets in
		  the IN direction.
		
		  Only single packets will be placed the buffers in the OUT
		  direction.
 Disable endpoint. Not for ep0in and ep0out that are handled separately. 
 'ep0' IN and OUT are reserved 
  Frees a request, but not any DMA buffers associated with it
  (gr_finish_request should already have taken care of that).
 Leads to memory leak 
 Queue a request from the gadget 
	
	  The ep0 pointer in the gadget struct is used both for ep0in and
	  ep0out. In a data stage in the out direction ep0out needs to be used
	  instead of the default ep0in. Completion functions might use
	  driver_data, so that needs to be copied as well.
 Dequeue JUST ONE request 
 We can't touch (DMA) registers when suspended 
 Make sure it's actually queued on this endpoint 
 This request is currently being processed 
 Not being processed - gr_finish_request dequeues it 
 Helper for gr_set_halt and gr_set_wedge 
 Halting an IN endpoint should fail if queue is not empty 
 Halt endpoint 
 Halt and wedge endpoint 
  Return the total number of bytes currently stored in the internal buffers of
  the endpoint.
 Empty data from internal buffers of an endpoint. 
 ---------------------------------------------------------------------- 
 USB Gadget ops 
 Remote wakeup feature not enabled by host
 Hook up the driver 
 Get ready for host detection 
 Other operations not supported 
 ---------------------------------------------------------------------- 
 Module probe, removal and of-matching 
 Must be called with dev->lock held 
 Complete gets set as used 
 Completion treated separately 
 Must be called with dev->lock held 
 Must be disabled by default 
 Enable ep0out and ep0in 
 Shuts everything down 
 Some core configurations has separate irqs for IN and OUT events 
 Determine number of endpoints and data interface mode 
 --- Effects of the following calls might need explicit cleanup --- 
 Create DMA pool for descriptors 
 Inside lock so that no gadget can use this udc until probe is done 
 Clear all interrupt enables that might be left on since last boot 
 SPDX-License-Identifier: GPL-2.0+
  amd5536.c -- AMD 5536 UDC highfull speed USB device controller
  Copyright (C) 2005-2007 AMD (https:www.amd.com)
  Author: Thomas Dahlmann
  This file does the core driver implementation for the UDC that is based
  on Synopsys device controller IP (different than HS OTG IP) that is either
  connected through PCI bus or integrated to SoC platforms.
 Driver strings 
 description 
 structure to hold endpoint function pointers 
 received setup data 
 pointer to device object 
 irq spin lock for soft reset 
 stall spin lock 
 slave mode: pending bytes in rx fifo after nyet,
 used if EPIN irq came but no req was available
 count soft resets after suspend to avoid loop 
 timer 
 set_rde -- Is used to control enabling of RX DMA. Problem is
  that UDC has only one bit (RDE) to enabledisable RX DMA for
  all OUT endpoints. So we have to handle race conditions like
  when OUT data reaches the fifo but no request was queued yet.
  This cannot be solved by letting the RX DMA disabled until a
  request gets queued because there may be other OUT packets
  in the FIFO (important for not blocking control traffic).
  The value of set_rde controls the correspondig timer.
  set_rde -1 == not used, means it is alloed to be set to 0 or 1
  set_rde  0 == do not touch RDE, do no start the RDE timer
  set_rde  1 == timer function will look whether FIFO has data
  set_rde  2 == set by timer function to enable RX DMA on next call
 endpoint names used for print 
 buffer fill mode 
 tx buffer size for high speed 
---------------------------------------------------------------------------
 Prints UDC device registers and endpoint irq registers 
 Masks unused interrupts 
 mask all dev interrupts 
 mask all ep interrupts 
 Enables endpoint 0 interrupts 
 read irq mask 
 enable ep0 irq's 
 Enables device interrupts for SET_INTF and SET_CONFIG 
 read irq mask 
 enable SET_INTERFACE, SET_CONFIG and other needed irq's 
 Calculates fifo start of endpoint based on preceding endpoints 
 traverse ep's 
 read fifo size 
 CNAK pending field: bit0 = ep0in, bit16 = ep0out 
 Enables endpoint, is called by gadget driver 
 set traffic type 
 set max packet size 
 IN ep 
 ep ix in UDC CSR register space 
 set buffer size (tx fifo entries) 
 double buffering: fifo size = 2 x max packet size 
 calc. tx fifo base addr 
 flush fifo 
 OUT ep 
 ep ix in UDC CSR register space 
 set max packet size UDC CSR	
 alloc and init BNA dummy request 
 set ep values 
 max packet 
 ep number 
 ep direction 
 ep type 
 ep config 
 ep interface 
 ep alt 
 write reg 
 enable ep irq 
	
	  clear NAK by writing CNAK
	  avoid BNA for OUT DMA, don't clear NAK until DMA desc. written
 Resets endpoint 
 set NAK 
 disable interrupt 
 unset P and IN bit of potential former DMA 
 flush the fifo 
 reset desc pointer 
 Disables endpoint, is called by gadget driver 
 Allocates request packet, called by gadget driver 
 ep0 in requests are allocated from data pool here 
 prevent from using desc. - set HOST BUSY 
 frees pci pool descriptors of a DMA chain 
 do not free first desc., will be done by free for request 
 Frees request packet, called by gadget driver 
 free dma chain if created 
 Init BNA dummy descriptor for HOST BUSY and pointing to itself 
 set last bit 
 set next pointer to itself 
 set HOST BUSY 
 Allocate BNA dummy descriptor 
 alloc the dummy request 
 Write data to TX fifo for IN packets 
 dwords first 
 remaining bytes must be written by byte access 
 dummy write confirm 
 Read dwords from RX fifo for OUT transfers 
 Read bytes from RX fifo for OUT transfers 
 dwords first 
 remaining bytes must be read by byte access 
 Read data from RX fifo for OUT transfers 
 received number bytes 
 last packet ? 
 read rx fifo bytes 
 Creates or re-inits a DMA chain 
 unset L bit in first desc for OUT 
 alloc only new desc's if not already available 
 shorter chain already allocated before 
 gen. required number of descriptors and buffers 
 create or determine next desc. 
 first td 
 assign buffer 
 short packet ? 
 short packet 
 link td and assign tx bytes 
			
			  else
			 	req->td_data->next = virt_to_phys(td);
 write tx bytes 
 first desc 
 second desc 
			
			  else
			 	last->next = virt_to_phys(td);
 write tx bytes 
 set last bit 
 last desc. points to itself 
 createre-init a DMA descriptor or a DMA descriptor chain 
 set buffer pointer 
 set last bit 
 buildre-init dma chain if maxpkt scatter mode, not for EP0 
 write tx bytes 
		
		  if bytes < max packet then tx bytes must
		  be written in packet per buffer mode
 write tx bytes 
 reset frame num 
 set HOST BUSY 
 set HOST READY 
 clear NAK by writing CNAK 
 Completes request packet ... caller MUST hold lock 
 unmap DMA 
 set new status if pending 
 remove from ep queue 
 Iterates to the end of a DMA chain and returns last descriptor 
 Iterates to the end of a DMA chain and counts bytes received 
 received number bytes 
 received number bytes 
 Enabling RX DMA 
 stop RDE timer 
 set RDE 
 Queues a request packet, called by gadget driver 
 check the inputs 
 map dma (usually done before) 
 on empty queue just do first transfer 
 zlp 
 IN zlp's are handled by hardware 
			
			  if set_config or set_intf is waiting for ack by zlp
			  then set CSR_DONE
 setup command is ACK'ed now by zlp 
 clear NAK by writing CNAK in EP0_IN 
 write desc pointer to enable DMA 
 set HOST READY 
 disabled rx dma while descriptor update 
 stop RDE timer 
 clear RDE 
				
				  if BNA occurred then let BNA dummy desc.
				  point to current desc.
 write desc pointer 
 clear NAK by writing CNAK 
 enable ep irq 
 enable ep irq 
		
		  prep_dma not used for OUT ep's, this is not possible
		  for PPB modes, because of chain creation reasons
 add request to ep queue 
 open rxfifo if out data queued 
 enable DMA 
 stop OUT naking 
				
				  read pending bytes afer nyet:
				  referring to isr
 finish 
 Empty request queue of an endpoint; caller holds spinlock 
 Dequeues a request packet, called by gadget driver 
 request in processing or next one 
 stop potential receive DMA 
				
				  Cancel transfer later in ISR
				  if descriptor was touched.
 Halt or clear halt of endpoint 
 halt or clear halt 
			
			  set STALL
			  rxfifo empty not taken into acount
 setup poll timer 
 ep is halted by set_halt() before 
 clear stall bit 
 clear NAK by writing CNAK 
 gadget interface 
 fifo ops not implemented 
-------------------------------------------------------------------------
 Get frame counter (not implemented) 
 Initiates a remote wakeup 
 Remote wakeup gadget interface 
 Setups endpoint parameters, adds endpoints to linked list 
 make gadget ep lists 
 fifo config 
 Inits UDC context 
 stop RDE timer 
 stop poll stall timer 
 disable DMA 
 enable dynamic CSR programming 
 set self powered 
 set remote wakeupable 
 init registers at driver load time 
 init controller by soft reset 
 mask not needed interrupts 
 put into initial config 
 link up all endpoints 
 program speed 
 Sets initial endpoint parameters 
 read enum speed 
 set basic ep parameters 
 txfifo size is calculated at enable time 
 fifo size 
		
		  ep will be reset only if ep was not enabled before to avoid
		  disabling ep interrupts when ENUM interrupt occurs but ep is
		  not enabled by gadget driver
			
			  ep->dma is not really used, just to indicate that
			  DMA is active: remove this
			  dma regs = dev control regs
 nak OUT endpoints until enable - not for ep0 
 set NAK 
 EP0 max packet 
	
	  with suspend bug workaround, ep0 params for gadget driver
	  are set at gadget driver bind() call
 init cfgaltint 
 Bringup after Connect event, initial bringup to be ready for ep0 events 
 Return if already connected 
 put into initial config 
 enable device setup interrupts 
  Calls gadget with disconnect event and resets the UDC and makes
  initial bringup to be ready for ep0 events
 Return if already disconnected 
 mask interrupts 
 empty queues 
 disable ep0 
 init controller by soft reset 
 re-enable dev interrupts 
 back to full speed ? 
 Reset the UDC core 
	
	  reset possible waiting interrupts, because int.
	  status is lost after soft reset,
	  ep int. status reset
 device int. status reset 
	 Don't do this for Broadcom UDC since this is a reserved
	  bit.
 RDE timer callback to set RDE bit 
		
		  open the fifo if fifo was filled on last timer call
		  conditionally
 set RDE to receive setup data 
			
			  if fifo empty setup polling, do not just
			  open the fifo
			
			  fifo contains data now, setup timer for opening
			  the fifo when timer expires to be able to receive
			  setup packets, when data packets gets queued by
			  gadget layer then timer will forced to expire with
			  set_rde=0 (RDE is set in udc_queue())
 debug: lhadmot_timer_start = 221070 
 RDE was set by udc_queue() 
 Handle halt state, used in stall poll timer 
 set stall as long not halted 
 STALL cleared ? 
			
			  FIXME: MSC spec requires that stall remains
			  even on receivng of CLEAR_FEATURE HALT. So
			  we would set STALL again here to be compliant.
			  But with current mass storage drivers this does
			  not work (would produce endless host retries).
			  So we clear halt on CLEAR_FEATURE.
			 
			DBG(ep->dev, "ep %d: set STALL again\n", ep->num);
			tmp |= AMD_BIT(UDC_EPCTL_S);
 clear NAK by writing CNAK 
 Stall timer callback to poll S bit and set it again after 
	
	  only one IN and OUT endpoints are handled
	  IN poll stall
 OUT poll stall 
 setup timer again when still halted 
 Inits endpoint 0 so that SETUP packets are processed 
 flush fifo 
 set ep0 directions 
 set buffer size (tx fifo entries) of EP0_IN 
 set max packet size of EP0_IN 
 set max packet size of EP0_OUT 
 set max packet size of EP0 in UDC CSR 
 write dma desc address 
 stop RDE timer 
 stop pollstall timer 
 enable DMA 
 clear NAK by writing CNAK for EP0IN 
 clear NAK by writing CNAK for EP0OUT 
 Make endpoint 0 ready for control traffic 
 enable ep0 interrupts 
 enable device setup interrupts 
 Called by gadget driver to register itself 
	 Some gadget drivers use both ep0 directions.
	  NOTE: to gadget driver, ep0 is just one endpoint...
 get ready for ep0 traffic 
 clear SD 
 shutdown requests and disconnect from gadget 
 empty queues and init hardware 
 Called by gadget driver to unregister itself 
 set SD 
 Clear pending NAK bits 
 check epin's 
 clear NAK by writing CNAK 
 ...	and ep0out 
 clear NAK by writing CNAK 
 Enabling RX DMA after setup packet 
		
		  only enable RXDMA when no data endpoint enabled
		  or data is queued
			
			  setup timer for enabling RDE (to not enable
			  RXFIFO DMA for data endpoints to early)
 Interrupt handler for data OUT traffic 
 BNA event ? 
 clear BNA 
 HE event ? 
 clear HE 
 next request 
 fifo mode 
 read fifo 
 finish 
 next request 
 DMA 
 check for DMA done 
 packet per buffer mode - rx bytes 
			
			  if BNA occurred then recover desc. from
			  BNA dummy desc.
 buffer fill mode - rx bytes 
 received number bytes 
 packet per buffer mode - rx bytes 
 received number bytes 
 every desc. counts bytes 
 last desc. counts bytes 
						
						  on 64k packets the RXBYTES
						  field is zero
 complete request 
 next request 
				
				  DMA may be already started by udc_queue()
				  called by gadget drivers completion
				  routine. This happens when queue
				  holds one request only.
 next dma 
 write desc pointer 
 enable DMA 
				
				  implant BNA dummy descriptor to allow
				  RXFIFO opening by RDE
 write desc pointer 
				
				  schedule timer for setting RDE if queue
				  remains empty to allow ep0 packets pass
				  through
			
			 RX DMA must be reenabled for each desc in PPBDU mode
			 and must be enabled for PPBNDU mode in case of BNA
 check pending CNAKS 
 CNAk processing when rxfifo empty only 
 clear OUT bits in ep status 
 Interrupt handler for data IN traffic 
 BNA ? 
 clear BNA 
 HE event ? 
 clear HE 
 DMA completion 
			
			  length bytes transferred
			  check dma done of last desc. in PPBDU mode
 assume all bytes transferred 
 complete req 
 further request available ? 
 disable interrupt 
	
	  status reg has IN bit set and TDC not set (if TDC was handled,
	  IN must not be handled (UDC defect) ?
 next request 
 FIFO mode 
 write fifo 
 complete req 
 DMA 
					
					  unset L bit of first desc.
					  for chain
 write desc pointer 
 set HOST READY 
 set poll demand bit 
 disable interrupt 
 clear status bits 
 Interrupt handler for Control OUT traffic 
 clear irq 
 check BNA and clear if set 
 type of data: SETUP or DATA 0 bytes 
 setup data 
 set NAK for EP0_IN 
 get setup data 
 clear OUT bits in ep status 
 set HOST READY 
 read fifo 
 determine direction of control data 
 enable RDE 
			
			  implant BNA dummy descriptor to allow RXFIFO opening
			  by RDE
 write desc pointer 
			
			  setup timer for enabling RDE (to not enable
			  RXFIFO DMA for data to early)
		
		  mass storage reset must be processed here because
		  next packet may be a CLEAR_FEATURE HALT which would not
		  clear the stall bit when no STALL handshake was received
		  before (autostall can cause this)
			
			  clear stall bits
			  only one IN and OUT endpoints are handled
 call gadget with setup data received 
 ep0 in returns data (not zlp) on IN phase 
 clear NAK by writing CNAK in EP0_IN 
 if unsupported request then stall 
 clear NAK by writing CNAK in EP0_OUT 
 clear OUT bits in ep status 
 data packet 0 bytes 
 clear OUT bits in ep status 
 get setup data: only 0 packet 
 no req if 0 packet, just reactivate 
 set HOST READY 
 enable RDE 
 control write 
 re-program desc. pointer for possible ZLPs 
 enable RDE 
 received number bytes 
 out data for fifo mode not working 
 0 packet or real data ? 
 dummy read confirm 
 check pending CNAKS 
 CNAk processing when rxfifo empty only 
 Interrupt handler for Control IN traffic 
 clear irq 
 DMA completion 
 clear TDC bit 
 status reg has IN bit set ? 
 clear IN bit 
 halt ep0in 
 next request 
 write desc pointer 
 set HOST READY 
 set poll demand bit 
 all bytes will be transferred 
 complete req 
 write fifo 
 lengh bytes transferred 
 complete req 
 clear IN bit 
 Interrupt handler for global device events 
 SET_CONFIG irq ? 
 read config value 
 make usb request for gadget driver 
 programm the NE registers 
 ep ix in UDC CSR register space 
 OUT ep 
 ep ix in UDC CSR register space 
 ep cfg 
 write reg 
 clear stall bits 
 call gadget zero with setup data received 
 SET_INTERFACE ? 
 read interface and alt setting values 
 make usb request for gadget driver 
 programm the NE registers 
 ep ix in UDC CSR register space 
 OUT ep 
 ep ix in UDC CSR register space 
 UDC CSR reg 
 set ep values 
 ep interface 
 tmp = AMD_ADDBITS(tmp, 2, UDC_CSR_NE_INTF); 
 ep alt 
 write reg 
 clear stall bits 
 call gadget zero with setup data received 
 USB reset 
 allow soft reset when suspend occurs 
 mask not needed interrupts 
 call gadget to resume and reset configs etc. 
 disable ep0 to empty req queue 
 soft reset when rxfifo not empty 
		
		  DMA reset to kill potential old DMA hw hang,
		  POLL bit is already reset by ep_init() through
		  disconnect()
 put into initial config 
 enable device setup interrupts 
 enable suspend interrupt 
 USB suspend 
 new speed ? 
 disable ep0 to empty req queue 
 link up all endpoints 
 init ep 0 
 enable ep0 interrupts 
 session valid change interrupt 
 check that session is not valid to detect disconnect 
 disable suspend interrupt 
 cleanup on disconnect 
 Interrupt Service Routine, see Linux Kernel Doc for parameters 
 check for ep irq 
		
		  data endpoint
		  iterate ep's
 clear irq status 
 irq for out ep ? 
 check for dev irq 
 clear irq 
 Tears down device 
 Cleanup on device remove 
 remove timer 
 remove pollstall timer 
 free all the dma pools 
 create dma pools on init 
 consistent DMA mode setting ? 
 DMA setup 
 EP0 in dma regs = dev control regs 
 dma desc for setup data 
 setup 
 data: 0 packets !? 
 general probe 
 device struct setup 
 init registers, interrupts, ... 
 Print this device info for AMD chips only
 timer init 
 set SD 
 print dev register info 
 SPDX-License-Identifier: GPL-2.0+
  Intel PXA25x and IXP4xx on-chip full speed USB device controllers
  Copyright (C) 2002 Intrinsyc, Inc. (Frank Becker)
  Copyright (C) 2003 Robert Schwebel, Pengutronix
  Copyright (C) 2003 Benedikt Spranger, Pengutronix
  Copyright (C) 2003 David Brownell
  Copyright (C) 2003 Joshua Wise
 #define VERBOSE_DEBUG 
 UDC Control Register 
 UDC Undocumented - Reserved1 
 UDC Undocumented - Reserved2 
 UDC Undocumented - Reserved3 
 UDC Endpoint 0 ControlStatus Register 
 UDC Endpoint 1 (IN) ControlStatus Register 
 UDC Endpoint 2 (OUT) ControlStatus Register 
 UDC Endpoint 3 (IN) ControlStatus Register 
 UDC Endpoint 4 (OUT) ControlStatus Register 
 UDC Endpoint 5 (Interrupt) ControlStatus Register 
 UDC Endpoint 6 (IN) ControlStatus Register 
 UDC Endpoint 7 (OUT) ControlStatus Register 
 UDC Endpoint 8 (IN) ControlStatus Register 
 UDC Endpoint 9 (OUT) ControlStatus Register 
 UDC Endpoint 10 (Interrupt) ControlStatus Register 
 UDC Endpoint 11 (IN) ControlStatus Register 
 UDC Endpoint 12 (OUT) ControlStatus Register 
 UDC Endpoint 13 (IN) ControlStatus Register 
 UDC Endpoint 14 (OUT) ControlStatus Register 
 UDC Endpoint 15 (Interrupt) ControlStatus Register 
 UDC Frame Number Register High 
 UDC Frame Number Register Low 
 UDC Byte Count Reg 2 
 UDC Byte Count Reg 4 
 UDC Byte Count Reg 7 
 UDC Byte Count Reg 9 
 UDC Byte Count Reg 12 
 UDC Byte Count Reg 14 
 UDC Endpoint 0 Data Register 
 UDC Endpoint 1 Data Register 
 UDC Endpoint 2 Data Register 
 UDC Endpoint 3 Data Register 
 UDC Endpoint 4 Data Register 
 UDC Endpoint 5 Data Register 
 UDC Endpoint 6 Data Register 
 UDC Endpoint 7 Data Register 
 UDC Endpoint 8 Data Register 
 UDC Endpoint 9 Data Register 
 UDC Endpoint 10 Data Register 
 UDC Endpoint 11 Data Register 
 UDC Endpoint 12 Data Register 
 UDC Endpoint 13 Data Register 
 UDC Endpoint 14 Data Register 
 UDC Endpoint 15 Data Register 
 UDC Interrupt Control Register 0 
 UDC Interrupt Control Register 1 
 UDC Status Interrupt Register 0 
 UDC Status Interrupt Register 1 
 UDC enable 
 UDC active 
 Device resume 
 Resume interrupt request 
 Suspend interrupt request 
 Suspendresume interrupt mask 
 Reset interrupt request 
 Reset interrupt mask 
 OUT packet ready 
 IN packet ready 
 Flush Tx FIFO 
 Device remote wakeup feature 
 Sent stall 
 Force stall 
 Receive FIFO no empty 
 Setup active 
 Transmit FIFO service 
 Transmit packet complete 
 Flush Tx FIFO 
 Transmit FIFO underrun 
 Sent stall 
 Force stall 
 Transmit short packet 
 Receive FIFO service 
 Receive packet complete 
 DMA enable 
 Sent stall 
 Force stall 
 Receive FIFO not empty 
 Receive short packet 
 Transmit FIFO service 
 Transmit packet complete 
 Flush Tx FIFO 
 Transmit FIFO underrun 
 Transmit short packet 
 Receive FIFO service 
 Receive packet complete 
 FIXME: is this right?, datasheed says '2' 
 Receive overflow 
 Receive overflow 
 DMA enable 
 Receive FIFO not empty 
 Receive short packet 
 Transmit FIFO service 
 Transmit packet complete 
 Flush Tx FIFO 
 Transmit FIFO underrun 
 Sent stall 
 Force stall 
 Transmit short packet 
 Interrupt mask ep 0 
 Interrupt mask ep 1 
 Interrupt mask ep 2 
 Interrupt mask ep 3 
 Interrupt mask ep 4 
 Interrupt mask ep 5 
 Interrupt mask ep 6 
 Interrupt mask ep 7 
 Interrupt mask ep 8 
 Interrupt mask ep 9 
 Interrupt mask ep 10 
 Interrupt mask ep 11 
 Interrupt mask ep 12 
 Interrupt mask ep 13 
 Interrupt mask ep 14 
 Interrupt mask ep 15 
 Interrupt request ep 0 
 Interrupt request ep 1 
 Interrupt request ep 2 
 Interrupt request ep 3 
 Interrupt request ep 4 
 Interrupt request ep 5 
 Interrupt request ep 6 
 Interrupt request ep 7 
 Interrupt request ep 8 
 Interrupt request ep 9 
 Interrupt request ep 10 
 Interrupt request ep 11 
 Interrupt request ep 12 
 Interrupt request ep 13 
 Interrupt request ep 14 
 Interrupt request ep 15 
  This driver handles the USB Device Controller (UDC) in Intel's PXA 25x
  series processors.  The UDC for the IXP 4xx series is very similar.
  There are fifteen endpoints, in addition to ep0.
  Such controller drivers work with a gadget driver.  The gadget driver
  returns descriptors, implements configuration and data protocols used
  by the host to interact with this device, and allocates endpoints to
  the different protocol interfaces.  The controller driver virtualizes
  usb hardware so that the gadget drivers will be more portable.
  This UDC hardware wants to implement a bit too much USB protocol, so
  it constrains the sorts of USB configuration change events that work.
  The errata for these chips are misleading; some "fixed" bugs from
  pxa250 a0a1 b0b1b2 sure act like they're still there.
  Note that the UDC hardware supports DMA (except on IXP) but that's
  not used here.  IN-DMA (to host) is simple enough, when the data is
  suitably aligned (16 bytes) ... the network stack doesn't do that,
  other software can.  OUT-DMA is buggy in most chip versions, as well
  as poorly designed (data toggle not automatic).  So this driver won't
  bother using DMA.  (Mostly-working IN-DMA support was available in
  kernels before 2.6.23, but was never enabled or well tested.)
 cpu-specific register addresses are compiled in to this code 
 IXP doesn't yet support <linuxclk.h> 
 ---------------------------------------------------------------------------
 	endpoint related parts of the api to the usb controller hardware,
 	used by gadget driver; and the inner talker-to-hardware core.
  ---------------------------------------------------------------------------
 one GPIO should control a D+ pullup, so host sees this device (or not) 
  IXP4xx has its buses wired up in a way that relies on never doing any
  byte swaps, independent of whether it runs in big-endian or little-endian
  mode, as explained by Krzysztof Hałasa.
  We only support pxa25x in little-endian mode, but it is very likely
  that it works the same way.
 The UDCCR reg contains mask and interrupt status bits,
  so using '|=' isn't safe as it may ack an interrupt.
 udccr contains the bits we dont want to change 
  endpoint enabledisable
  we need to verify the descriptors used to enable endpoints.  since pxa25x
  endpoint configurations are fixed, and are pretty much always enabled,
  there's not a lot to manage here.
  because pxa25x can't selectively initialize bulk (or interrupt) endpoints,
  (resetting endpoint halt and toggle), SET_INTERFACE is unusable except
  for a single interface (with only the default altsetting) and for gadget
  drivers that don't halt endpoints (not reset by set_interface).  that also
  means that if you use ISO, you must violate the USB spec rule that all
  iso endpoints must be in non-default altsettings.
 xfer types must match, except that interrupt ~= bulk 
 hardware _could_ do smaller, but driver doesn't 
 flush fifo (mostly for OUT buffers) 
 ... reset halt state too, if we could ... 
 flush fifo (mostly for IN buffers) 
-------------------------------------------------------------------------
 for the pxa25x, these can just wrap kmallockfree.  gadget drivers
  must still pass correctly initialized endpoints, since other controller
  drivers may care about how it's currently set up (dma issues etc).
 	pxa25x_ep_alloc_request - allocate a request data structure
 	pxa25x_ep_free_request - deallocate a request data structure
-------------------------------------------------------------------------
 	done - retire a request; caller blocked irqs
 don't modify queue heads during completion callback 
 how big will this packet be? 
  write to an IN endpoint fifo, as many packets as possible.
  irqs will use this to write the rest later.
  caller guarantees at least one packet buffer is ready (or a zlp).
 last packet is usually short (or a zlp) 
 interruptiso maxpacket may not fill the fifo 
		 let loose that packet. maybe try writing another one,
		  double buffering might work.  TSP, TPC, and TFS
		  bit values are the same for all normal IN endpoints.
 requests complete when all IN data is in the FIFO 
 TODO experiment: how robust can fifo mode tweaking be?
 double buffering is off in the default fifo mode, which
 prevents TFS from being set here.
 caller asserts req->pending (ep0 irq status nyet cleared); starts
  ep0 data stage.  these chips want very simple state transitions.
 last packet "must be" short (or a zlp) 
		 This seems to get rid of lost status irqs in some cases:
		  host responds quickly, or next request involves config
		  change automagic, or should have been hidden, or ...
		 
		  FIXME get rid of all udelays possible...
 clear OPR, generate ack 
  read_fifo -  unload packet(s) from the fifo we use for usb OUT
  transfers and put them into the request.  caller should have made
  sure there's at least one packet ready.
  returns true if the request completed because of short packet or the
  request buffer having filled (and maybe overran till end-of-packet).
		 make sure there's a packet in the FIFO.
		  UDCCS_{BO,IO}_RPC are all the same bit value.
		  UDCCS_{BO,IO}_RNE are all the same bit value.
 read all bytes from this packet 
 zlp 
				 this happens when the driver's buffer
				  is smaller than what the host sent.
				  discard the extra data.
 RPCRSPRNE could now reflect the other packet buffer 
 iso is one request per packet 
 more like "is_done" 
 completion 
 finished that packet.  the next one may be waiting... 
  special ep0 version of the above.  no UBCR0 or double buffering; status
  handshaking is magic.  most device protocols don't need control-OUT.
  CDC vendor commands (and RNDIS), mass storage CBCBI, and some other
  protocols do use them.
			 this happens when the driver's buffer
			  is smaller than what the host sent.
			  discard the extra data.
 completion 
 finished that packet.  the next one may be waiting... 
-------------------------------------------------------------------------
	 iso is always one packet per request, that's the only way
	  we can report per-packet status.  that also helps with dma.
 kickstart this io queue? 
 ep0 ) {
 messy ... 
 can the FIFO can satisfy the request immediately? 
 pio or dma irq handler advances the queue. 
 	nuke - dequeue ALL requests
 called with irqs blocked 
 dequeue JUST ONE request 
 make sure it's actually queued on this endpoint 
-------------------------------------------------------------------------
		 this path (reset toggle+halt) is needed to implement
		  SET_INTERFACE on normal hardware.  but it can't be
		  done from software on the PXA UDC, and the hardware
		  forgets to do it as part of SET_INTERFACE automagic.
 FST bit is the same for control, bulk in, bulk out, interrupt in 
 ep0 needs special care 
 and bulkintr endpoints like dropping stalls too 
 pxa can't report unclaimed bytes from IN fifos 
 toggle and halt bits stay unchanged 
 for OUT, just read and discard the FIFO contents. 
 most IN status is the same, but ISO can't stall 
 ---------------------------------------------------------------------------
 	device-scoped parts of the api to the usb controller hardware
  ---------------------------------------------------------------------------
 host may not have enabled remote wakeup 
 We disable the UDC -- and its 48 MHz clock -- whenever it's not
  in active use.
 Enable clock for USB device 
 Disable clock for USB device 
 VBUS reporting logically comes from a transceiver 
 drivers may have software control over D+ pullup 
 not all boards support pullup control 
 boards may consume current from VBUS, up to 100-500mA based on config.
  the 500uA suspend ceiling means that exclusively vbus-powered PXA designs
  violate USB specs.
-------------------------------------------------------------------------
 basic device status 
 registers for device and ep0 
 dump endpoint queues 
 TODO translate all five groups of udccs bits! 
 ep0 should only have one transfer queued 
 !CONFIG_USB_GADGET_DEBUG_FILES 
 CONFIG_USB_GADGET_DEBUG_FILES 
-------------------------------------------------------------------------
 	udc_disable - disable USB device controller
 block all irqs 
 if hardware supports it, disconnect from usb 
 	udc_reinit - initialize software state
 deviceep0 records init 
 basic endpoint records init 
 the rest was statically initialized, and is read-only 
 until it's enabled, this UDC should be completely invisible
  to any USB host.
 try to clear these bits before we enable the udc 
UDCCR_RSTIR|UDCCR_RESIR);
	
	  sequence taken from chapter 12.5.10, PXA250 AppProcDevManual:
	  - enable UDC
	  - if RESET is already in progress, ack interrupt
	  - unmask reset interrupt
 UDC_RES2 is defined ) {
		 pxa255 (a0+) can avoid a set_config race that could
		  prevent gadget drivers from configuring correctly
		 "USB test mode" for pxa250 errata 40-42 (stepping a0, a1)
		  which could result in missing packets and interrupts.
		  supposedly one bit per endpoint, controlling whether it
		  double buffers or not; ACMAREN bits fit into the holes.
		  zero bits (like USIR0_IRx) disable double buffering.
 enable suspendresume and reset irqs 
 enable ep0 irqs 
 if hardware supports it, pullup D+ and wait for reset 
 when a driver is successfully registered, it will receive
  control requests including set_configuration(), which enables
  non-control requests.  then usb traffic follows until a
  disconnect is reported.  then a host may connect again, or
  the driver might get unbound.
 first hook up the driver ... 
	 ... then enable host detection and ep0; and we're ready
	  for set_configuration as well as eventual disconnect.
 connect to bus through transceiver 
 don't disconnect drivers more than once 
 prevent new request submissions, kill any outstanding requests  
 report reset; the driver is already quiesced 
 re-init driver-visible data structures 
 don't disconnect drivers more than once 
 prevent new request submissions, kill any outstanding requests  
 report disconnect; the driver is already quiesced 
 re-init driver-visible data structures 
-------------------------------------------------------------------------
 Lubbock has separate connect and disconnect irqs.  More typical designs
  use one GPIO as the VBUS IRQ, and another to control the D+ pullup.
-------------------------------------------------------------------------
	 hardware SET_{CONFIGURATION,INTERFACE} automagic resets endpoint
	  fifos, and pending transactions mustn't be continued in any case.
 clear stall status 
 previous request unfinished?  non-error iff back-to-back ... 
 late-breaking status? 
 start control request? 
 read SETUP packet 
 cope with automagic for some standard requests. 
 hardware restricts gadget drivers here! 
					 reflect hardware's automagic
					  up to the gadget driver.
					 if !has_cfr, there's no synch
					  else use AREN (later) not SA|OPR
					  USIR0_IR0 acts edge sensitive
 ... and here, even more ... 
					 udc hardware is broken by design:
					   - altsetting may only be zero;
					   - hw resets all interfaces' eps;
					   - ep reset doesn't include halt(?).
 hardware was supposed to hide this 
 hardware automagic preventing STALL... 
					 hardware sometimes neglects to tell
					  tell us about config change events,
					  so later ones may fail...
					 TODO experiment:  if has_cfr,
					  hardware didn't ACK; maybe we
					  could actually STALL!
				 the watchdog timer helps deal with cases
				  where udc seems to clear FST wrongly, and
				  then NAKs instead of STALLing.
 deferred io == no response yet 
 expect at least one data or status stage irq 
			 pxa210250 erratum 131 for B0B1 says RNE lies.
			  still observed on a pxa255 a0.
 read SETUP data, but don't trust it too much 
			 some random early IRQ:
			  - we acked FST
			  - IPR cleared
			  - OPR got set, without SA (likely status stage)
 GET_DESCRIPTOR etc 
 irq was IPR clearing  {
 this IN packet might finish the request 
 else IN token before response was written 
 SET_DESCRIPTOR etc 
 this OUT packet might finish the request 
 else more OUT packets expected 
 else OUT token before read was issued 
 irq was IPR clearing  {
		 ack control-IN status (maybe in-zlp was skipped)
		  also appears after some config change events.
 TODO check FST handling
 irq from TPC, SST, or (ISO) TUR 
 irq from RPC (or for ISO, ROF) 
 fifos can hold packets, ready for reading... 
 	pxa25x_udc_irq - interrupt handler
  avoid delays in ep0 processing. the control handshaking isn't always
  under software control (pxa250c0 and the pxa255 are better), and delays
  could cause usb protocol errors.
 SUSpend Interrupt Request 
 RESume Interrupt Request 
 ReSeT Interrupt Request - USB reset 
				 reset driver and endpoints,
				  in case that's not yet done
 driver and endpoints are still reset 
 control traffic 
 endpoint data transfers 
 we could also ask for 1 msec SOF (SIR) interrupts 
-------------------------------------------------------------------------
 this uses load-time allocation and initialization (instead of
  doing it at run-time) to save code, eliminate fault paths, and
  be more obviously correct.
 control endpoint 
 first group of endpoints 
 second group of endpoints 
 third group of endpoints 
 !CONFIG_USB_PXA25X_SMALL 
 intelarmxscale 
 intelarmixp4xx 
 and PXA26x 
 or PXA260_B1 
 or PXA26x_B0 
 or PXA260_A0 
 	probe - binds to the platform device
 insist on IntelARMXScale 
 trigger chiprev-specific logic 
 A0A1 "not released"; ep 13, 15 unusable 
 OUT-DMA is broken ... 
 iop3xx, ixp4xx, ... 
 other non-static parts of init 
 irq setup after old hardware state is cleaned up 
-------------------------------------------------------------------------
 USB suspend (controlled by the host) and system suspend (controlled
  by the PXA) don't necessarily work well together.  If USB is active,
  the 48 MHz clock is required; so the system can't enter 33 MHz idle
  mode, or any deeper PM saving state.
  For now, we punt and forcibly disconnect from the USB host when PXA
  enters any suspend state.  While we're disconnected, we always disable
  the 48MHz USB clock ... allowing PXA sleep andor 33 MHz idle states.
  Boards without software pullup control shouldn't use those states.
  VBUS IRQs should probably be ignored so that the PXA device just acts
  "dead" to USB hosts until system resume.
-------------------------------------------------------------------------
 SPDX-License-Identifier: GPL-2.0+
  omap_udc.c -- for OMAP full speed udc; most chips support OTG.
  Copyright (C) 2004 Texas Instruments, Inc.
  Copyright (C) 2004-2005 David Brownell
  OMAP2 & DMA support by Kyungmin Park <kyungmin.park@samsung.com>
 bulk DMA seems to be behaving for both IN and OUT 
 ISO too 
  The OMAP UDC needs _very_ early endpoint setup:  before enabling the
  D+ pullup to allow enumeration.  That's too early for the gadget
  framework to use from usb_endpoint_enable(), which happens after
  enumeration as part of activating an interface.  (But if we add an
  optional new "UDC not yet running" state to the gadget driver model,
  even just during driver binding, the endpoint autoconfig logic is the
  natural spot to manufacture new endpoints.)
  So instead of using endpoint enable calls to control the hardware setup,
  this driver defines a "fifo mode" parameter.  It's used during driver
  initialization to choose among a set of pre-defined endpoint configs.
  See omap_udc_setup() for available modes, or to add others.  That code
  lives in an init section, so use this driver as a module if you need
  to change the fifo mode after the kernel boots.
  Gadget drivers normally ignore endpoints they don't care about, and
  won't include them in configuration descriptors.  That means only
  misbehaving hosts would even notice they exist.
 "modprobe omap_udc fifo_mode=42", or else as a kernel
  boot parameter "omap_udc:fifo_mode=42"
 "modprobe omap_udc use_dma=y", or else as a kernel
  boot parameter "omap_udc:use_dma=y"
 !USE_DMA 
 save a bit of code 
 !USE_DMA 
-------------------------------------------------------------------------
 there's a notion of "current endpoint" for modifying endpoint
  state, and PIO access to its FIFO.
 when select, MUST deselect later !! 
 6 wait states before TX will happen 
-------------------------------------------------------------------------
 catch various bogus parameters 
 hardware wants period = 1; USB allows 2^(Interval-1) 
 xfer types must match, except that interrupt ~= bulk 
 set endpoint to initial state 
 maybe assign a DMA channel to this endpoint 
 FIXME ISO can dma, but prefers first channel 
 PIO OUT may RX packets 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 don't modify queue heads during completion callback 
-------------------------------------------------------------------------
 FIXME change rw fifo calling convention 
 return:  0 = still running, 1 = completed, negative = errno 
 PIO-IN isn't double buffered except for iso 
 last packet is often short (sometimes a zlp) 
	 NOTE:  requests complete when all IN data is in a
	  FIFO (or sometimes later, if a zlp was needed).
	  Use usb_ep_fifo_status() where needed.
 return:  0 = still running, 1 = queue empty, negative = errno 
 partial packet reads may not be errors 
 overflowed this request?  flush extra data 
-------------------------------------------------------------------------
	 IN-DMA needs this on faultcancel paths, so 15xx misreports
	  the last transfer's bytecount by more than a FIFO's worth.
 Each USB transfer request using DMA maps to one or more DMA transfers.
  When DMA completion isn't request completion, the UDC continues with
  the next DMA transfer for that USB transfer.
 measure length in either bytes or packets 
 return if this request needs to send data or zlp 
 tx completion 
 set up this DMA transfer, enable the fifo, start 
 if this wasn't short, request may need another transfer 
 rx completion 
 IN dma: tx to host 
 can see TXN_DONE after dma abort 
 OUT dma: rx from host 
 can see RXN_EOT after dma abort 
 omap15xx does this unasked... 
 if ch_status & OMAP_DMA_DROP_IRQ ... 
 if ch_status & OMAP1_DMA_TOUT_IRQ ... 
 complete current transfer ... 
 "pulse" activated 
 preferred for ISO 
 EMIFF or SDRC 
 TIPB 
 TIPB 
 EMIFF or SDRC 
 channel type P: hw synch (fifo) 
 restart any queue, even if the claim failed  
 IN: 6 wait states before it'll tx 
 abort any active usb transfer request 
	 NOTE: re-setting RX_REQTX_REQ because of a chip bug (before
	  OMAP 1710 ES2.0) where reading the DMA_CFG can clear them.
 wait till current packet DMA finishes, and fifo empties 
 clear FIFO; hosts probably won't empty it 
 dma empties the fifo 
 has_dma still set, till endpoint is fully quiesced 
-------------------------------------------------------------------------
 catch various bogus parameters 
	 this isn't bogus, but OMAP DMA isn't the only hardware to
	  have a hard time with partial packet reads...  reject it.
 maybe kickstart non-iso io queues 
 empty DATA stage? 
				 chip became CONFIGURED or ADDRESSED
				  earlier; drivers may already have queued
				  requests to non-control endpoints
				 STATUS for zero length DATA stages is
				  always an IN ... even for IN transfers,
				  a weird case which seem to stall OMAP.
 cleanup 
 non-empty DATA stage 
 if ISO: SOF IRQs must be enableddisabled! 
 IN: 6 wait states before it'll tx 
 irq handler advances the queue 
 make sure it's actually queued on this endpoint 
		 releasing the channel cancels the request,
		  reclaiming the channel restarts the queue
-------------------------------------------------------------------------
 just use protocol stalls for ep0; real halts are annoying 
 NOP 
 otherwise, all active non-ISO endpoints can halt 
 IN endpoints must already be idle 
 fifo_status ... report bytes in fifo 
 fifo_flush ... flush fifo 
-------------------------------------------------------------------------
		 NOTE:  OTG spec erratum says that OTG devices may
		  issue wakeups without host enable.
 NOTE:  non-OTG systems may use SRP TOO... 
  Called by whatever detects VBUS sessions:  external transceiver
  driver, or maybe GPIO0 VBUS IRQ.  May request 48 MHz clock.
 "software" detect, ignored if !VBUS_MODE_1510 
-------------------------------------------------------------------------
 dequeue ALL requests; caller holds udc->lock 
 caller holds udc->lock 
-------------------------------------------------------------------------
	 Enable HNP early, avoiding races on suspend irq path.
	  ASSUMES OTG state machine B_BUS_REQ input is true.
	 Clear any pending requests and then scrub any rxtx state
	  before starting to handle the SETUP request.
	 INOUT packets mean we're in the DATA or STATUS stage.
	  This driver uses only uses protocol stalls (ep0 never halts),
	  and if we got this far the gadget driver already had a
	  chance to stall.  Tries to be forgiving of host oddities.
	 
	  NOTE:  the last chance gadget drivers have to stall control
	  requests is during their request completion callback.
 IN == TX to host 
				 write next IN packet from response,
				  or set up the status stage.
 else:  6 wait states before it'll tx 
 ack status stage of OUT transfer 
 OUT == RX from host 
				 read next OUT packet of request, maybe
				  reactiviting the fifo; stall on errors.
 activate status stage 
 that may have STALLed ep0... 
 ack status stage of IN transfer 
 SETUP starts all control transfers 
 read the (latest) SETUP message 
 two bytes at a time 
		 Delegate almost all control requests to the gadget driver,
		  except for a handful of ch9 statusfeature requests that
		  hardware doesn't autodecode _and_ the gadget API hides.
 udc needs to know when ep != 0 is valid 
			 update udc NOW since gadget driver may start
			  queueing requests immediately; clear config
			  later if it fails the request.
 clear endpoint halt 
				 NOTE:  assumes the host behaves sanely,
				  only clearing real halts.  Else we may
				  need to kill pending transfers and then
				  restart the queue... very messy for DMA!
 set endpoint halt 
				 this has rude side-effects (aborts) and
				  can't really work if DMA-IN is active
 can't halt if fifo isn't empty... 
 USB_ENDPOINT_HALT status? 
 ep0 never stalls 
 only active endpoints count 
 iso never stalls 
 FIXME don't assume non-halted endpoints!! 
			 return interface status.  if we were pedantic,
			  we'd detect non-existent interfaces, and stall.
 return two zero bytes 
 next, status stage 
 activate the ep0out fifo right away 
			 gadget drivers see classvendor specific requests,
			  {SET,GET}_{INTERFACE,DESCRIPTOR,CONFIGURATION},
			  and more
			 The gadget driver may return an error here,
			  causing an immediate protocol stall.
			 
			  Else it must issue a response, either queueing a
			  response buffer for the DATA stage, or halting ep0
			  (causing a protocol stall, not a real halt).  A
			  zero length buffer means no DATA stage.
			 
			  It's fine to issue that response after the setup()
			  call returns, and this IRQ was handled.
-------------------------------------------------------------------------
			 driver for any external transceiver will
			  have called omap_vbus_session() already
 if (driver->connect) call it 
 ep0 traffic is legal from now on 
 FIXME tell isp1301 to suspendresume (?) 
 HNP could be under way already 
 Device state change (usb ch9 stuff) 
 EP0 control transfers 
 DMA transfer completion 
 workaround for seemingly-lost IRQs for RX ACKs... 
 handle OUT first, to avoid some wasteful NAKs 
 min 6 clock delay before clearing EP_SEL ... 
		 enabling fifo _after_ clearing ACK, contrary to docs,
		  reduces lossage; timer still needed though (sigh).
 then IN transfers 
 min 6 clock delay before clearing EP_SEL ... 
 then 6 clocks before it'd tx 
 handle all non-DMA ISO transfers 
		 NOTE: like the other controller drivers, this isn't
		  currently reporting lost or damaged frames.
 done(ep, req, -EPROTO) ;
 done(ep, req, status) ;
 6 wait states before next EP 
-------------------------------------------------------------------------
 No known omap7xx boards with vbus sense 
 reset state 
 hook up the driver 
 connect to bus through transceiver 
	 boards that don't have VBUS sensing can't autogate 48MHz;
	  can't enter deep sleep while a gadget driver is active.
-------------------------------------------------------------------------
 much more SRP stuff 
 OTG controller registers 
 syscon2 is write-only 
 UDC controller registers 
-------------------------------------------------------------------------
 Before this controller can enumerate, we need to pick an endpoint
  configuration, or "fifo_mode"  That involves allocating 2KB of packet
  buffer space among the endpoints we'll be operating.
  NOTE: as of OMAP 1710 ES2.0, writing a new endpoint config when
  UDC_SYSCON_1.CFG_LOCK is set can now work.  We won't use that
  capability yet though.
 OUT endpoints first, then IN 
 in case of ep init table bugs 
 chip setup ... bit values are same for IN, OUT 
		 double-buffering "not supported" on 15xx,
		  and ignored for PIO-IN on newer chips
		  (for more reliable behavior)
 next endpoint's buffer starts after this one's 
 set up driver data structures 
 abolish any previous hardware state 
 UDC_PULLUP_EN gates the chip clock 
 OTG_SYSCON_1 |= DEV_IDLE_EN; 
 ep0 is special; put it right after the SETUP buffer 
 after SETUP , 64 
 initially disable all non-ep0 endpoints 
 mixed isobulk 
 mixed bulkiso 
 add more modes as needed 
 NOTE:  "knows" the order of the resources! 
 can't use omap_udc_enable_clock yet 
 can't use omap_udc_enable_clock yet 
 use the mode given to us by board init code 
			 just set up software VBUS detect, and then
			  later rig it so we always report VBUS.
			  FIXME without really sensing VBUS, we can't
			  know when to turn PULLUP_EN onoff; and that
			  means we always "need" the 48MHz clock.
		 The transceiver may package some GPIO logic or handle
		  loopback andor transceiverless setup; if we find one,
		  use it.  Except for OTG, we don't _need_ to talk to one;
		  but not having one probably means no VBUS detection.
 POWERUP DEFAULT == 0 
 internal loopback 
 transceiverless 
 a "gadget" abstractsvirtualizes the controller 
 "udc" is now valid 
 starting with omap1710 es2.0, clear toggle is a separate bit 
 USB general purpose IRQ:  ep0, state changes, dma, etc 
 USB "non-iso" IRQ (PIO for all but ep0) 
 suspendresumewakeup from sysfs (echo > powerstate) or when the
  system is forced into deep sleep
  REVISIT we should probably reject suspend requests when there's a host
  session active, rather than disconnecting, at least on boards that can
  report VBUS irqs (UDC_DEVSTAT.UDC_ATT).  And in any case, we need to
  make host resumes and VBUS detection trigger OMAP wakeup events; that
  may involve talking to an external transceiver (e.g. isp1301).
	 we're requesting 48 MHz clock if the pullup is enabled
	  (== we're attached to the host) and we're not suspended,
	  which would prevent entry to deep sleep...
 maybe the host would enumerate us if we nudged it 
-------------------------------------------------------------------------
 SPDX-License-Identifier: GPL-2.0+
  MAX3420 Device Controller driver for USB.
  Author: Jaswinder Singh Brar <jaswinder.singh@linaro.org>
  (C) Copyright 2019-2020 Linaro Ltd
  Based on:
 	o MAX3420E datasheet
 		https:datasheets.maximintegrated.comendsMAX3420E.pdf
 	o MAX342{0,1}E Programming Guides
 		https:pdfserv.maximintegrated.comenanAN3598.pdf
 		https:pdfserv.maximintegrated.comenanAN3785.pdf
 Same for all Endpoints 
 Buffer size for endpoint name 
 read register from MAX3420 
 write register to MAX3420 
 SPI commands: 
 Control endpoint configuration.
 Set Remote-WkUp Signal
 Clear Remote-WkUp Signal
 clear all pending requests 
 Disable IRQ to CPU 
	 Need this delay if bus-powered,
	  but even for self-powered it helps stability
 configure SPI 
 Chip Reset 
 Poll for OSC to stabilize 
 Enable PULL-UP only when Vbus detected 
 Enable only EP0 interrupts 
 Enable IRQ to CPU 
 its a vbus change interrupt 
 Get device status 
 Data+Status phase form udc 
 Status phase from udc 
 Requests with no data phase, status phase from udc 
 Stall EP0 
 250ms 
 If bus-vbus_active and disconnected 
 get done with the EP0 ZLP 
 Pluck the descriptor from queue 
 Only if wakeup allowed by host 
 hook up the driver 
 For EP0 
 EP1 is OUT 
 EP2 & EP3 are IN 
 Setup gadget structure 
 setup Endpoints 
 configure SPI 
 no vbus irq implies self-powered design 
 Detect current vbus status 
 SPDX-License-Identifier: GPL-2.0+
  at91_udc -- driver for at91-series USB peripheral controller
  Copyright (C) 2004 by Thomas Rathbone
  Copyright (C) 2005 by HP Labs
  Copyright (C) 2005 by David Brownell
  This controller is simple and PIO-only.  It's used in many AT91-series
  full speed USB controllers, including the at91rm9200 (arm920T, with MMU),
  at91sam926x (arm926ejs, with MMU), and several no-mmu versions.
  This driver expects the board has been wired with two GPIOs supporting
  a VBUS sensing IRQ, and a D+ pullup.  (They may be omitted, but the
  testing hasn't covered such cases.)
  The pullup is most important (so it's integrated on sam926x parts).  It
  provides software control over whether the host enumerates the device.
  The VBUS sensing helps during enumeration, and allows both USB clocks
  (and the transceiver) to stay gated off until they're necessary, saving
  power.  During USB suspend, the 48 MHz clock is gated off in hardware;
  it may also be gated off by software during some Linux sleep states.
-------------------------------------------------------------------------
 NOTE:  not collecting per-endpoint irq statistics... 
 iff type is control then print current direction 
 don't access registers when interface isn't clocked 
-------------------------------------------------------------------------
 ep0 is always ready; other endpoints need a non-empty queue 
-------------------------------------------------------------------------
 bits indicating OUT fifo has data ready 
  Endpoint FIFO CSR bits have a mix of bits, making it unsafe to just write
  back most of the value you just read (because of side effects, including
  bits that may change after reading and before writing).
  Except when changing a specific bit, always write values which:
   - clear SET_FX bits (setting them could change something)
   - set CLR_FX bits (clearing them could change something)
  There are also state bits like FORCESTALL, EPEDS, DIR, and EPTYPE
  that shouldn't normally be changed.
  NOTE at91sam9260 docs mention synch between UDPCK and MCK clock domains,
  implying a need to wait for one write to complete (test relevant bits)
  before starting the next write.  This shouldn't be an issue given how
  infrequently we write, except maybe for write-then-read idioms.
 pull OUT packet data from the endpoint's fifo 
	
	  there might be nothing to read if ep_queue() calls us,
	  or if we already emptied both pingpong buffers
 release and swap pingpong mem bank 
	
	  avoid extra trips through IRQ logic for packets already in
	  the fifo ... maybe preventing an extra (expensive) OUT-NAK
		
		  One dummy read to delay the code because of a HW glitch:
		  CSR returns bad RXCOUNT when read too soon after updating
		  RX_DATA_BK flags.
 load fifo for an IN packet 
	
	  TODO: allow for writing two packets to the fifo ... that'll
	  reduce the amount of IN-NAKing, but probably won't affect
	  throughput much.  (Unlike preventing OUT-NAKing!)
	
	  If ep_queue() calls us, the queue is empty and possibly in
	  odd states like TXCOMP not yet cleared (we do it, saving at
	  least one IRQ) or the fifo not yet being free.  Those aren't
	  issues normally (IRQ handler fast path).
	
	  Write the packet, maybe it's a ZLP.
	 
	  NOTE:  incrementing req->actual before we receive the ACK means
	  gadget driver IN bytecounts can be wrong in fault cases.  That's
	  fixable with PIO drivers like this one (save "count" here, and
	  do the increment later on TX irq), but not for most DMA hardware.
	 
	  So all gadget drivers must accept that potential error.  Some
	  hardware supports precise fifo status reporting, letting them
	  recover when the actual bytecount matters (e.g. for USB Test
	  and Measurement Class devices).
 terminate any request in the queue 
-------------------------------------------------------------------------
 initialize endpoint to match this descriptor 
	
	  resetinit endpoint fifo.  NOTE:  leaves fifo_bank alone,
	  since endpoint resets don't reset hw pingpong state.
 restore the endpoint's pristine config 
 reset fifos and endpoint 
  this is a PIO-only driver, so there's nothing
  interesting for request or buffer allocation.
 try to kickstart any empty and idle queue 
		
		  If this control request has a non-empty DATA stage, this
		  will start that stage.  It works just like a non-control
		  request (until the status stage starts, maybe early).
		 
		  If the data stage is empty, then this starts a successful
		  INSTATUS stage.  (Unsuccessful ones use set_halt.)
			
			  defer changing CONFG until after the gadget driver
			  reconfigures the endpoints.
 INSTATUS stage is otherwise triggered by irq 
 make sure it's actually queued on this endpoint 
	
	  fail with still-busy IN endpoints, ensuring correct sequencing
	  of data tx then stall.  note that the fifo rx bytecount isn't
	  completely accurate as a tx bytecount.
 there's only imprecise fifo status reporting 
-------------------------------------------------------------------------
 NOTE:  some "early versions" handle ESR differently ... 
 reinit == restore initial software state 
 initialize one queue per endpoint 
  activatedeactivate link with host; minimize power usage for
  inactive links by cutting clocks and transceiver power.
 vbus is here!  turn everything on that's ready 
 VDBG("vbus %s\n", is_active ? "on" : "off"); 
	
	  VBUS-powered devices may also also want to support bigger
	  power budgets after an appropriate SET_CONFIGURATION.
 .vbus_power		= at91_vbus_power, 
-------------------------------------------------------------------------
 STALLSENT bit == ISOERR 
 read and ack SETUP; hard-fail for bogus packets 
 REVISIT this happens sometimes under load; why?? 
	
	  A few standard requests get handled here, ones that touch
	  hardware ... notably for device and endpoint features.
 FADDR is set later, when we ack host STATUS 
 CONFG is toggled later, if gadget driver succeeds 
	
	  Hosts may set or clear remote wakeup status, and
	  devices may report they're VBUS powered.
 then STATUS starts later, automatically 
	
	  Interfaces have no feature settings; this is pretty useless.
	  we won't even insist the interface exists...
 then STATUS starts later, automatically 
	
	  Hosts may clear bulkintr endpoint halt after the gadget
	  driver sets it (not widely used); or set it (for testing)
 then STATUS starts later, automatically 
 pass request up to the gadget driver 
 immediate successful (IN) STATUS after zero length DATA 
 host ACKed an IN packet that we sent 
 write more IN DATA? 
		
		  Ack after:
		   - last IN DATA packet (including GET_STATUS)
		   - INSTATUS for OUT DATA
		   - INSTATUS for any zero-length DATA stage
		  except for the IN DATA case, the host should send
		  an OUT status later, which we'll ack.
			
			  SET_ADDRESS takes effect only after the STATUS
			  (to the original address) gets acked.
 OUT packet arrived ... 
 OUT DATA stage 
 send INSTATUS 
				
				  AT91 hardware has a hard time with this
				  "deferred response" mode for control-OUT
				  transfers.  (For control-IN it's fine.)
				 
				  The normal solution leaves OUT data in the
				  fifo until the gadget driver is ready.
				  We couldn't do that here without disabling
				  the IRQ that tells about SETUP packets,
				  e.g. when the host gets impatient...
				 
				  Working around it by copying into a buffer
				  would almost be a non-deferred response,
				  except that it wouldn't permit reliable
				  stalling of the request.  Instead, demand
				  that gadget drivers not use this mode.
 STATUS stage for control-IN; ack.  
 "early" status stage 
 USB reset irq:  not maskable 
 Atmel code clears this irq twice 
 enable ep0 
			
			  NOTE:  this driver keeps clocks off unless the
			  USB host is present.  That saves power, but for
			  boards that don't support VBUS detection, both
			  clocks need to be active most of the time.
 host initiated suspend (3+ms bus idle) 
 VDBG("bus suspend\n"); 
			
			  NOTE:  when suspending a VBUS-powered device, the
			  gadget driver should switch into slow clock mode
			  and then into standby to avoid drawing more than
			  500uA power (2500uA for some high-power configs).
 host initiated resume 
 VDBG("bus resume\n"); 
			
			  NOTE:  for a VBUS-powered device, the gadget driver
			  would normally want to switch out of slow clock
			  mode into normal mode.
 endpoint IRQs are cleared by handling them 
-------------------------------------------------------------------------
 vbus needs at least brief debouncing 
	
	  If we are polling vbus it is likely that the gpio is on an
	  bus such as i2c or spi which may sleep, so schedule some work
	  to read the vbus gpio
-------------------------------------------------------------------------
 force disconnect on reboot 
 sentinel  }
 init software state 
 get interface and function clocks 
 don't do anything until we have both gadget driver and VBUS 
 Clear all pending interrupts - UDP may be used by bootloader. 
 request UDC and maybe VBUS irqs 
		
		  Get the initial state of VBUS - we cannot expect
		  a pending interrupt.
	 Unless we can act normally to the host (letting it wake us up
	  whenever it has work for us) force disconnect.  Wakeup requires
	  PLLB for USB events (signaling for reset, wakeup, or incoming
	  tokens) and VBUS irqs (on systems which support them).
 maybe reconnect to host; if so, clocks on 
 SPDX-License-Identifier: GPL-2.0+
  Xilinx USB peripheral controller driver
  Copyright (C) 2004 by Thomas Rathbone
  Copyright (C) 2005 by HP Labs
  Copyright (C) 2005 by David Brownell
  Copyright (C) 2010 - 2014 Xilinx, Inc.
  Some parts of this driver code is based on the driver for at91-series
  USB peripheral controller (at91_udc.c).
 Register offsets for the USB device.
 EP0 Config Reg Offset 
 Setup Packet Address 
 Address Register 
 Control Register 
 Status Register 
 Frame Number Register 
 Interrupt Enable Register 
 Buffer Ready Register 
 Test Mode Register 
 DMA Soft Reset Register 
 DMA Control Register 
 DMA source Address Reg 
 DMA destination Addr Reg 
 DMA Length Register 
 DMA Status Register 
 Endpoint Configuration Space offsets 
 Endpoint Config Status  
 Buffer 0 Count 
 Buffer 1 Count 
 USB ready Mask 
 Remote wake up mask 
 Interrupt register related masks.
 Global Intr Enable 
 DMA done Mask 
 DMA Error Mask 
 DMA Error Mask 
 USB Resume Mask 
 USB Reset Mask 
 USB Suspend Mask 
 USB Disconnect Mask 
 FIFO Buff Ready Mask 
 FIFO Buff Free Mask 
 Setup packet received 
 EP 1 Buff 2 Processed 
 EP 1 Buff 1 Processed 
 EP 0 Buff 2 Processed 
 EP 0 Buff 1 Processed 
 USB Speed Mask 
 Suspend,Reset,Suspend and Disconnect Mask 
 Buffers  completion Mask 
 Mask for buffer 0 and buffer 1 completion for all Endpoints 
 EP buffer offset 
 Endpoint Configuration Status Register 
 Endpoint Valid bit 
 Endpoint Stall bit 
 Endpoint Data toggle 
 USB device specific global configuration constants.
 Maximum End Points 
 End point Zero 
 DPRAM is the source address for DMA transfer 
 DMA busy 
 DMA Error 
  When this bit is set, the DMA buffer ready bit is set by hardware upon
  DMA transfer completion.
 DMA bufready ctrl bit 
 Phase States 
 Setup Phase 
 Data Phase 
 Status Phase 
 Endpoint 0 maximum packet length 
 Buffer size for GET_STATUS command 
 Buffer size for endpoint name 
 container_of helper macros 
  struct xusb_req - Xilinx USB device request structure
  @usb_req: Linux usb request structure
  @queue: usb device request queue
  @ep: pointer to xusb_endpoint structure
  struct xusb_ep - USB end point structure.
  @ep_usb: usb endpoint instance
  @queue: endpoint message queue
  @udc: xilinx usb peripheral driver instance pointer
  @desc: pointer to the usb endpoint descriptor
  @rambase: the endpoint buffer address
  @offset: the endpoint register offset value
  @name: name of the endpoint
  @epnumber: endpoint number
  @maxpacket: maximum packet size the endpoint can store
  @buffer0count: the size of the packet recieved in the first buffer
  @buffer1count: the size of the packet received in the second buffer
  @curbufnum: current buffer of endpoint that will be processed next
  @buffer0ready: the busy state of first buffer
  @buffer1ready: the busy state of second buffer
  @is_in: endpoint direction (IN or OUT)
  @is_iso: endpoint type(isochronous or non isochronous)
  struct xusb_udc -  USB peripheral driver structure
  @gadget: USB gadget driver instance
  @ep: an array of endpoint structures
  @driver: pointer to the usb gadget driver instance
  @setup: usb_ctrlrequest structure for control requests
  @req: pointer to dummy request for get status command
  @dev: pointer to device structure in gadget
  @usb_state: device in suspended state or not
  @remote_wkp: remote wakeup enabled by host
  @setupseqtx: tx status
  @setupseqrx: rx status
  @addr: the usb device base address
  @lock: instance of spinlock
  @dma_enabled: flag indicating whether the dma is included in the system
  @clk: pointer to struct clk
  @read_fn: function pointer to read device registers
  @write_fn: function pointer to write to device registers
 Endpoint buffer start addresses in the core 
 Control endpoint configuration.
  xudc_write32 - little endian write to device registers
  @addr: base addr of device registers
  @offset: register offset
  @val: data to be written
  xudc_read32 - little endian read from device registers
  @addr: addr of device register
  Return: value at addr
  xudc_write32_be - big endian write to device registers
  @addr: base addr of device registers
  @offset: register offset
  @val: data to be written
  xudc_read32_be - big endian read from device registers
  @addr: addr of device register
  Return: value at addr
  xudc_wrstatus - Sets up the usb device status stages.
  @udc: pointer to the usb device controller structure.
  xudc_epconfig - Configures the given endpoint.
  @ep: pointer to the usb device endpoint structure.
  @udc: pointer to the usb peripheral controller structure.
  This function configures a specific endpoint with the given configuration
  data.
	
	  Configure the end point direction, type, Max Packet Size and the
	  EP buffer location.
 Set the Buffer count and the Buffer ready bits.
  xudc_start_dma - Starts DMA transfer.
  @ep: pointer to the usb device endpoint structure.
  @src: DMA source address.
  @dst: DMA destination address.
  @length: number of bytes to transfer.
  Return: 0 on success, error code on failure
  This function starts DMA transfer by writing to DMA source,
  destination and lenth registers.
	
	  Set the addresses in the DMA source and
	  destination registers and then set the length
	  into the DMA length register.
	
	  Wait till DMA transaction is complete and
	  check whether the DMA transaction was
	  successful.
		
		  We can't sleep here, because it's also called from
		  interrupt context.
  xudc_dma_send - Sends IN data using DMA.
  @ep: pointer to the usb device endpoint structure.
  @req: pointer to the usb request structure.
  @buffer: pointer to data to be sent.
  @length: number of bytes to send.
  Return: 0 on success, -EAGAIN if no buffer is free and error
 	   code on failure.
  This function sends data using DMA.
 Get the Buffer address and copy the transmit data.
 Get the Buffer address and copy the transmit data.
 None of ping pong buffers are ready currently .
  xudc_dma_receive - Receives OUT data using DMA.
  @ep: pointer to the usb device endpoint structure.
  @req: pointer to the usb request structure.
  @buffer: pointer to storage buffer of received data.
  @length: number of bytes to receive.
  Return: 0 on success, -EAGAIN if no buffer is free and error
 	   code on failure.
  This function receives data using DMA.
 Get the Buffer address and copy the transmit data 
 Get the Buffer address and copy the transmit data 
 None of the ping-pong buffers are ready currently 
  xudc_eptxrx - Transmits or receives data to or from an endpoint.
  @ep: pointer to the usb endpoint configuration structure.
  @req: pointer to the usb request structure.
  @bufferptr: pointer to buffer containing the data to be sent.
  @bufferlen: The number of data bytes to be sent.
  Return: 0 on success, -EAGAIN if no buffer is free.
  This function copies the transmitreceive data tofrom the end point buffer
  and enables the buffer for transmissionreception.
 Put the transmit buffer into the correct ping-pong buffer.
 Get the Buffer address and copy the transmit data.
		
		  Enable the buffer for transmission.
 Get the Buffer address and copy the transmit data.
		
		  Enable the buffer for transmission.
 None of the ping-pong buffers are ready currently 
  xudc_done - Exeutes the endpoint data transfer completion tasks.
  @ep: pointer to the usb device endpoint structure.
  @req: pointer to the usb request structure.
  @status: Status of the data transfer.
  Deletes the message from the queue and updates data transfer completion
  status.
 unmap request if DMA is present
  xudc_read_fifo - Reads the data from the given endpoint buffer.
  @ep: pointer to the usb device endpoint structure.
  @req: pointer to the usb request structure.
  Return: 0 if request is completed and -EAGAIN if not completed.
  Pulls OUT packet data from the endpoint buffer.
		
		  This happens when the driver's buffer
		  is smaller than what the host sent.
		  discard the extra data.
 Completion 
 DMA error, dequeue the request 
  xudc_write_fifo - Writes data into the given endpoint buffer.
  @ep: pointer to the usb device endpoint structure.
  @req: pointer to the usb request structure.
  Return: 0 if request is completed and -EAGAIN if not completed.
  Loads endpoint buffer for an IN packet.
 completion 
 DMA error, dequeue the request 
  xudc_nuke - Cleans up the data transfer message list.
  @ep: pointer to the usb device endpoint structure.
  @status: Status of the data transfer.
  xudc_ep_set_halt - Stallsunstalls the given endpoint.
  @_ep: pointer to the usb device endpoint structure.
  @value: value to indicate stallunstall.
  Return: 0 for success and error value on failure
 Stall the device.
 Unstall the device.
 Reset the toggle bit.
  __xudc_ep_enable - Enables the given endpoint.
  @ep: pointer to the xusb endpoint structure.
  @desc: pointer to usb endpoint descriptor.
  Return: 0 for success and error value on failure
 Bit 3...0:endpoint number 
 NON- ISO 
 NON- ISO 
 NON- ISO 
 ISO 
 Enable the End point.
 Enable buffer completion interrupts for endpoint 
 for OUT endpoint set buffers ready to receive 
  xudc_ep_enable - Enables the given endpoint.
  @_ep: pointer to the usb endpoint structure.
  @desc: pointer to usb endpoint descriptor.
  Return: 0 for success and error value on failure
  xudc_ep_disable - Disables the given endpoint.
  @_ep: pointer to the usb endpoint structure.
  Return: 0 for success and error value on failure
 Restore the endpoint's pristine config 
 Disable the endpoint.
  xudc_ep_alloc_request - Initializes the request queue.
  @_ep: pointer to the usb endpoint structure.
  @gfp_flags: Flags related to the request call.
  Return: pointer to request structure on success and a NULL on failure.
  xudc_free_request - Releases the request from queue.
  @_ep: pointer to the usb device endpoint structure.
  @_req: pointer to the usb request structure.
  __xudc_ep0_queue - Adds the request to endpoint 0 queue.
  @ep0: pointer to the xusb endpoint 0 structure.
  @req: pointer to the xusb request structure.
  Return: 0 for success and error value on failure
 Enable EP0 buffer to receive data 
  xudc_ep0_queue - Adds the request to endpoint 0 queue.
  @_ep: pointer to the usb endpoint 0 structure.
  @_req: pointer to the usb request structure.
  @gfp_flags: Flags related to the request call.
  Return: 0 for success and error value on failure
  xudc_ep_queue - Adds the request to endpoint queue.
  @_ep: pointer to the usb endpoint structure.
  @_req: pointer to the usb request structure.
  @gfp_flags: Flags related to the request call.
  Return: 0 for success and error value on failure
  xudc_ep_dequeue - Removes the request from the queue.
  @_ep: pointer to the usb device endpoint structure.
  @_req: pointer to the usb request structure.
  Return: 0 for success and error value on failure
 Make sure it's actually queued on this endpoint 
  xudc_ep0_enable - Enables the given endpoint.
  @ep: pointer to the usb endpoint structure.
  @desc: pointer to usb endpoint descriptor.
  Return: error always.
  endpoint 0 enable should not be called by gadget layer.
  xudc_ep0_disable - Disables the given endpoint.
  @ep: pointer to the usb endpoint structure.
  Return: error always.
  endpoint 0 disable should not be called by gadget layer.
  xudc_get_frame - Reads the current usb frame number.
  @gadget: pointer to the usb gadget structure.
  Return: current frame number for success and error value on failure.
  xudc_wakeup - Send remote wakeup signal to host
  @gadget: pointer to the usb gadget structure.
  Return: 0 on success and error on failure
 Remote wake up not enabled by host 
 set remote wake up bit 
	
	  wait for a while and reset remote wake up bit since this bit
	  is not cleared by HW after sending remote wakeup to host.
  xudc_pullup - startstop USB traffic
  @gadget: pointer to the usb gadget structure.
  @is_on: flag to start or stop
  Return: 0 always
  This function startsstops SIE engine of IP based on is_on.
  xudc_eps_init - initialize endpoints.
  @udc: pointer to the usb device controller structure.
		
		  The configuration register address offset between
		  each endpoint is 0x10.
 Initialize one queue per endpoint 
  xudc_stop_activity - Stops any further activity on the device.
  @udc: pointer to the usb device controller structure.
  xudc_start - Starts the device.
  @gadget: pointer to the usb gadget structure
  @driver: pointer to gadget driver structure
  Return: zero on success and error on failure
 hook up the driver 
 Enable the control endpoint. 
 Set device address and remote wakeup to 0 
  xudc_stop - stops the device.
  @gadget: pointer to the usb gadget structure
  Return: zero always
 Set device address and remote wakeup to 0 
  xudc_clear_stall_all_ep - clears stall of every endpoint.
  @udc: pointer to the udc structure.
 Reset the toggle bit.
  xudc_startup_handler - The usb device controller interrupt handler.
  @udc: pointer to the udc structure.
  @intrstatus: The mask value containing the interrupt sources.
  This function handles the RESET,SUSPEND,RESUME and DISCONNECT interrupts.
 Set device address and remote wakeup to 0 
 Enable the suspend, resume and disconnect 
 Enable the reset, resume and disconnect 
 Enable the reset, suspend and disconnect 
 Enable the reset, resume and suspend 
  xudc_ep0_stall - Stall endpoint zero.
  @udc: pointer to the udc structure.
  This function stalls endpoint zero.
  xudc_setaddress - executes SET_ADDRESS command
  @udc: pointer to the udc structure.
  This function executes USB SET_ADDRESS command
  xudc_getstatus - executes GET_STATUS command
  @udc: pointer to the udc structure.
  This function executes USB GET_STATUS command
 Get device status 
  xudc_set_clear_feature - Executes the set feature and clear feature commands.
  @udc: pointer to the usb device controller structure.
  Processes the SET_FEATURE and CLEAR_FEATURE commands.
			
			  The Test Mode will be executed
			  after the status phase.
 Make sure direction matches.
 Clear the stall.
 Unstall the endpoint.
  xudc_handle_setup - Processes the setup packet.
  @udc: pointer to the usb device controller structure.
  Process setup packet and delegate to gadget layer.
 Load up the chapter 9 command buffer.
 Clear previous requests 
 Execute the get command.
 Execute the put command.
 Data+Status phase form udc 
 Status phase from udc 
 Requests with no data phase, status phase from udc 
  xudc_ep0_out - Processes the endpoint 0 OUT token.
  @udc: pointer to the usb device controller structure.
		
		  This resets both state machines for the next
		  Setup packet.
 Copy the data to be received from the DPRAM. 
 Data transfer completed get ready for Status stage 
 Enable EP0 buffer to receive data 
  xudc_ep0_in - Processes the endpoint 0 IN token.
  @udc: pointer to the usb device controller structure.
 Set the address of the device.
			
			  We're done with data transfer, next
			  will be zero length OUT with data toggle of
			  1. Setup data_toggle.
 Copy the data to be transmitted into the DPRAM. 
  xudc_ctrl_ep_handler - Endpoint 0 interrupt handler.
  @udc: pointer to the udc structure.
  @intrstatus:	It's the mask value for the interrupt sources on endpoint 0.
  Processes the commands received during enumeration phase.
  xudc_nonctrl_ep_handler - Non control endpoint interrupt handler.
  @udc: pointer to the udc structure.
  @epnum: End point number for which the interrupt is to be processed
  @intrstatus:	mask value for interrupt sources of endpoints other
 		than endpoint 0.
  Processes the buffer completion interrupts.
 Process the End point interrupts.
  xudc_irq - The main interrupt handler.
  @irq: The interrupt number.
  @_udc: pointer to the usb device controller structure.
  Return: IRQ_HANDLED after the interrupt is handled.
	
	  Event interrupts are level sensitive hence first disable
	  IER, read ISR and figure out active interrupts.
 Read the Interrupt Status Register.
 Call the handler for the event interrupt.
		
		  Check if there is any action to be done for :
		  - USB Reset received {XUSB_STATUS_RESET_MASK}
		  - USB Suspend received {XUSB_STATUS_SUSPEND_MASK}
		  - USB Resume received {XUSB_STATUS_RESUME_MASK}
		  - USB Disconnect received {XUSB_STATUS_DISCONNECT_MASK}
 Check the buffer completion interrupts 
 Enable Reset, Suspend, Resume and Disconnect  
  xudc_probe - The device probe function for driver initialization.
  @pdev: pointer to the platform device structure.
  Return: 0 for success and error value on failure
 Create a dummy request for GET_STATUS, SET_ADDRESS 
 Map the registers 
 Setup gadget structure 
		
		  Clock framework support is optional, continue on,
		  anyways if we don't find a matching clock
 Check for IP endianness 
 Set device address to 0.
 Enable the interrupts.
  xudc_remove - Releases the resources allocated during the initialization.
  @pdev: pointer to the platform device structure.
  Return: 0 always
 Match table for of_platform binding 
 end of list  },
 SPDX-License-Identifier: GPL-2.0+
  USB Gadget driver for LPC32xx
  Authors:
     Kevin Wells <kevin.wells@nxp.com>
     Mike James
     Roland Stigge <stigge@antcom.de>
  Copyright (C) 2006 Philips Semiconductors
  Copyright (C) 2009 NXP Semiconductors
  Copyright (C) 2012 Roland Stigge
  Note: This driver is based on original work done by Mike James for
        the LPC3180.
  USB device configuration structure
 0=active low drive for VBUS via ISP1301 
 Connection change event (optional) 
 Suspendresume event (optional) 
 Enabledisable remote wakeup 
  controller driver data structures
 16 endpoints (not to be confused with 32 hardware endpoints) 
  IRQ indices make reading the code a little easier
 RX (from host) 
 TX (to host) 
 Returns the interrupt mask for the selected hardware endpoint 
 EP0 states 
 Wait for setup packet 
 Expect dev->host transfer 
 Expect host->dev transfer 
 DD (DMA Descriptor) structure, requires word alignment, this is already
  defined in the LPC32XX USB device header file, but this version is slightly
 5 spare 
  Logical endpoint structure
 Physical hardware EP 
 Maps to hardware endpoint 
  Common UDC structure
 Board and device specific 
 DMA support 
 Common EP and control data 
 VBUS detection, pullup, and power flags 
 Work queues related to I2C support 
 USB device peripheral - various 
  Endpoint request
  USB device controller register offsets
 DMA support registers only below 
 Set, clear, or get enabled state of the DMA request status. If
 DMA UDCA head pointer 
 EP DMA status, enable, and disable. This is used to specifically
 DMA master interrupts enable and pending interrupts 
 DMA end of transfer interrupt enable, disable, status 
 New DD request interrupt enable, disable, status 
 DMA error interrupt enable, disable, status 
  USBD_DEVINTSTUSBD_DEVINTENUSBD_DEVINTCLRUSBD_DEVINTSET
  USBD_DEVINTPRI register definitions
  USBD_EPINTSTUSBD_EPINTENUSBD_EPINTCLRUSBD_EPINTSET
  USBD_EPINTPRI register definitions
 End point selection macro (RX) 
 End point selection macro (TX) 
  USBD_REEPUSBD_DMARSTUSBD_DMARCLRUSBD_DMARSETUSBD_EPDMAST
  USBD_EPDMAENUSBD_EPDMADIS
  USBD_NDDRTINTSTUSBD_NDDRTINTCLRUSBD_NDDRTINTSET
  USBD_EOTINTSTUSBD_EOTINTCLRUSBD_EOTINTSET
  USBD_SYSERRTINTSTUSBD_SYSERRTINTCLRUSBD_SYSERRTINTSET
  register definitions
 Endpoint selection macro 
  SBD_DMAINTSTUSBD_DMAINTEN
  USBD_RXPLEN register definitions
  USBD_CTRL register definitions
  USBD_CMDCODE register definitions
  USBD_DMARSTUSBD_DMARCLRUSBD_DMARSET register definitions
 DD (DMA Descriptor) structure, requires word alignment 
 dd_setup bit defines 
 dd_status bit defines 
 Not serviced 
 Being serviced 
 Normal completion 
 Data underrun (short packet) 
 Data overrun 
 System error 
 Packet valid 
 LS byte extracted (ATLE) 
 MS byte extracted (ATLE) 
  Protocol engine bits below
 Device Interrupt Bit Definitions 
 Rx & Tx Packet Length Definitions 
 USB Control Definitions 
 Command Codes 
 Device Address Register Definitions 
 Device Configure Register Definitions 
 Device Mode Register Definitions 
 Device Status Register Definitions 
 Error Code Register Definitions 
 Error Status Register Definitions 
 Endpoint Select Register Definitions 
 Endpoint Status Register Definitions 
 Clear Buffer Register Definitions 
 DMA Interrupt Bit Definitions 
  proc interface support
 Primary initialization sequence for the ISP1301 transceiver 
 LPC32XX only supports DAT_SE0 USB mode 
 This sequence is important 
 Disable transparent UART mode first 
 Set full speed and SE0 mode 
	
	  The PSW_OE enable bit state is reversed in the ISP1301 User's Guide
 Driver VBUS_DRV high or low depending on board setup 
	 Bi-directional mode with suspend control
	  Enable both pulldowns for now - the pullup will be enable when VBUS
 Discharge VBUS (just in case) 
 Enables or disables the USB device pullup via the ISP1301 transceiver 
 Enable pullup for bus signalling 
 Enable pullup for bus signalling 
 defer slow i2c pull up setting 
 Powers up or down the ISP1301 transceiver 
 There is no "global power down" register for stotg04 
		 Power up ISP1301 - this ISP1301 will automatically wakeup
 Power down ISP1301 
  USB protocol engine commanddata readwrite helper functions
 Issues a single command to the USB device state machine 
 EP may lock on CLRI if this read isn't done 
 Write command code 
 Issues 2 commands (or command and data) to the USB device state machine 
 Issues a single command to the USB device state machine and reads
 Write a command and read data from the protocol engine 
 Write command code 
  USB device interrupt mask support functions
 Enable one or more USB device interrupts 
 Disable one or more USB device interrupts 
 Clear one or more USB device interrupts 
  Endpoint interrupt disableenable functions
 Enable one or more USB endpoint interrupts 
 Disable one or more USB endpoint interrupts 
 Clear one or more USB endpoint interrupts 
 Enable DMA for the HW channel 
 Disable DMA for the HW channel 
  Endpoint realizeunrealize functions
 Before an endpoint can be used, it needs to be realized
  in the USB protocol engine - this realizes the endpoint.
 Wait until endpoint is realized in hardware 
 Unrealize an EP 
  Endpoint support functions
 Select and clear endpoint interrupt 
 Disables the endpoint in the USB protocol engine 
 Stalls the endpoint - endpoint will return STALL 
 Clear stall or reset endpoint 
 Select an endpoint for endpoint status, clear, validate 
  Endpoint buffer management functions
 Clear the current endpoint's buffer 
 Validate the current endpoint's buffer 
 Clear EP interrupt 
  USB EP DMA support
 Allocate a DMA Descriptor 
 Free a DMA Descriptor 
  USB setup and shutdown functions
 Enables or disables most of the USB system clocks when low power mode is
  needed. Clocks are typically started on a connection event, and disabled
 Setreset USB device address 
	 Address will be latched at the end of the status phase, or
 Setup up a IN request for DMA transfer - this consists of determining the
  list of DMA addresses for the transfer, allocating DMA Descriptors,
 There will always be a request waiting here 
 Place the DD Descriptor into the UDCA 
 Enable DMA and interrupt for the HW EP 
 Clear ZLP if last packet is not of MAXP size 
 Setup up a OUT request for DMA transfer - this consists of determining the
  list of DMA addresses for the transfer, allocating DMA Descriptors,
 There will always be a request waiting here 
 Place the DD Descriptor into the UDCA 
 Enable DMA and interrupt for the HW EP 
 Disable device 
 Disable all device interrupts (including EP0) 
 Disable and reset all endpoint interrupts 
 Disable and clear all interrupts and DMA 
 Disable DMA interrupts 
 Start with known state 
 Enable device 
 EP interrupts on high priority, FRAME interrupt on low priority 
 Clear any pending device interrupts 
 Setup UDCA - not yet used (DMA) 
 Only enable EP0 in and out for now, EP0 only works in FIFO mode 
 Device interrupt setup 
	 Set device address to 0 - called twice to force a latch in the USB
 Enable master DMA interrupts 
  USB device board specific events handled via callbacks
 Connection change event - notify board function of change 
 Just notify of a connection change event (optional) 
 Suspendresume event - notify board function of change 
 Just notify of a Suspendresume change event (optional) 
 Remote wakeup enabledisable - notify board function of change 
 Reads data from FIFO, adjusts for alignment and data size 
 Use optimal data transfer method based on source address and size 
 32-bit aligned 
 Copy 32-bit aligned data first 
 Handle any remaining bytes 
 8-bit aligned 
 Each byte has to be handled independently 
 16-bit aligned 
 Copy 32-bit sized objects first with 16-bit alignment 
 Handle any remaining bytes 
 Read data from the FIFO for an endpoint. This function is for endpoints (such
  as EP0) that don't use DMA. This function should only be called if a packet
  is known to be ready to read for the endpoint. Note that the endpoint must
 Setup read of endpoint 
 Wait until packet is ready 
 Mask out count 
 Clear the buffer 
 Stuffs data into the FIFO, adjusts for alignment and data size 
 Use optimal data transfer method based on source address and size 
 32-bit aligned 
 Copy 32-bit aligned data first 
 Handle any remaining bytes 
 8-bit aligned 
 Each byte has to be handled independently 
 16-bit aligned 
 Copy 32-bit aligned data first 
 Handle any remaining bytes 
 Write data to the FIFO for an endpoint. This function is for endpoints (such
  as EP0) that don't use DMA. Note that the endpoint must be selected in the
 Setup write of endpoint 
 Need at least 1 byte to trigger TX 
 USB device reset - resets USB to a default state with just EP0
 Re-init device controller and EP0 
 Send a ZLP on EP0 
 Get current frame number 
 Set the device as configured - enables all endpoints 
 Set the device as unconfigured - disables all endpoints 
 reinit == restore initial software state 
 Must be called with lock 
 Free DDs 
 Must be called with lock 
 IN endpoint 0 transfer 
 Nothing to send 
 Send a ZLP 
 Just send what we can 
 Write data to the EP0 FIFO and start transfer 
 Increment data pointer 
 Stay in data transfer state 
 Transfer request is complete 
 OUT endpoint 0 transfer 
 Just dequeue request 
 Get data from FIFO 
 Copy data to buffer 
 This is the last packet 
 Must be called with lock 
  Activate or kill host pullup
  Can be called with or without lock
 Must be called without lock 
 Clear all DMA statuses for this EP 
 Remove the DD pointer in the UDCA 
 Disable and reset endpoint and interrupt 
 Must be called without lock 
 Verify EP data 
 Don't touch EP0 
 Is driver ready? 
 Initialize endpoint to match the selected descriptor 
 Map hardware endpoint from base and direction 
 IN endpoints are offset 1 from the OUT endpoint 
	 Realize the endpoint, interrupt is enabled later when
 Clear all DMA statuses for this EP 
  Allocate a USB request list
  Can be called with or without lock
  De-allocate a USB request list
  Can be called with or without lock
 Must be called without lock 
 For the request, build a list of DDs 
 Error allocating DD 
 Setup the DMA descriptor 
 Special handling for ISO EPs 
 Kickstart empty queues 
 Handle expected data direction 
 IN packet to host 
 OUT packet from host 
 IN packet to host and kick off transfer 
 OUT packet from host and kick off list 
 Must be called without lock 
 make sure it's actually queued on this endpoint 
 Must be called without lock 
 Don't halt an IN EP 
 stall 
 End stall 
 set the halt feature and ignores clear requests 
 Send a ZLP on a non-0 IN EP 
 Clear EP status 
 Send ZLP via FIFO mechanism 
  Handle EP completion for ZLP
  This function will only be called when a delayed ZLP needs to be sent out
  after a DMA transfer has filled both buffers.
 If this interrupt isn't enabled, return now 
 Get endpoint status 
	
	  This should never happen, but protect against writing to the
	  buffer when full.
 If there isn't a request waiting, something went wrong 
 Start another request if ready 
 DMA end of transfer completion 
 DMA descriptor should always be retired for this call 
 Disable DMA 
 System error? 
		 The error could have occurred on a packet of a multipacket
		  transfer, so recovering the transfer is not possible. Close
 Handle the current DD's status 
 DD not serviced? This shouldn't happen! 
 Interrupt only fires on EOT - This shouldn't happen! 
 Really just a short packet, not an underrun 
 This is a good status and what we expect 
 Data overrun, system error, or unknown 
 ISO endpoints are handled differently 
	 Send a ZLP if necessary. This will be done for non-int
		
		  If at least 1 buffer is available, send the ZLP now.
		  Otherwise, the ZLP send needs to be deferred until a
		  buffer is available.
 Let the EP interrupt handle the ZLP 
 Transfer request is complete 
 Start another request if ready 
  Endpoint 0 functions
 Power down transceiver 
 Power up transceiver 
 Not supported 
 Something's wrong 
 Not an IN endpoint 
 Get status of the endpoint 
 Return data 
 Nuke previous transfers 
 Get setup packet 
 Native endianness 
 Set direction of EP0 
 Handle SETUP packet 
 Nothing else handled 
 Tell board about event 
 Find hardware endpoint from logical endpoint 
 Let GadgetFS handle the descriptor instead 
		 device-2-host (IN) or no data setup command, process
 Configuration is set after endpoints are realized 
 Set configuration 
 Clear configuration 
 Disable NAK interrupts 
 setup processing failed, force stall 
 ZLP IN packet on data phase 
 IN endpoint 0 transfer 
 Clear EP interrupt 
 Stalled? Clear stall and reset buffers 
 Is a buffer available? 
 Handle based on current state 
 Unknown state for EP0 oe end of DATA IN phase 
 OUT endpoint 0 transfer 
 Clear EP interrupt 
 Stalled? 
 A NAK may occur if a packet couldn't be received yet 
 Setup packet incoming? 
 Data available? 
 Handle based on current state 
 Unknown state for EP0 
 Must be called without lock 
  vbus is here!  turn everything on that's ready
  Must be called without lock
 Doesn't need lock 
		
		   Wait for all the endpoints to disable,
		   before disabling clocks. Don't wait if
		   endpoints are not enabled.
 Can be called with or without lock 
 Doesn't need lock 
 nothing to free 
 Can be 0 or 1, has special handling 
 2 or 3, will be set later 
 4 or 5, will be set later 
 6 or 7, will be set later 
 8 or 9, will be set later 
 10 or 11, will be set later 
 12 or 13, will be set later 
 ISO and status interrupts 
 Read the device status register 
 Device specific handling needed? 
	 Start of frame? (devstat & FRAME_INT):
	  The frame interrupt isn't really needed for ISO support,
 Error? 
		 All types of errors, from cable removal during transfer to
		  misc protocol and bit errors. These are mostly for just info,
		  as the USB hardware will work around these. If these errors
 EP interrupts 
 Read the device status register 
 Endpoints 
 Special handling for EP0 
 Handle EP0 IN 
 Handle EP0 OUT 
 All other EPs 
 Handle other EP interrupts 
 Handle EP DMA EOT interrupts 
  VBUS detection, pullup handler, and Gadget cable state notification
 Discharge VBUS real quick 
 Give VBUS some time (100mS) to discharge 
 Disable VBUS discharge resistor 
 Clear interrupt 
 Get the VBUS status from the transceiver 
 VBUS on or off? 
 VBUS changed? 
 Force VBUS process once to check for cable insertion 
 enable interrupts 
		
		   Wait for all the endpoints to disable,
		   before disabling clocks. Don't wait if
		   endpoints are not enabled.
 Force disconnect on reboot 
  Callbacks to be overridden by options passed via OF (TODO)
	 Do nothing, it might be nice to enable an LED
 Device suspend if susp != 0 
 Enable or disable USB remote wakeup 
 init software state 
	
	  Resources are mapped as follows:
	   IORESOURCE_MEM, base address and size of USB space
	   IORESOURCE_IRQ, USB device low priority interrupt number
	   IORESOURCE_IRQ, USB device high priority interrupt number
	   IORESOURCE_IRQ, USB device interrupt number
	   IORESOURCE_IRQ, USB transceiver interrupt number
 Get IRQs 
 Get USB device clock 
 Enable USB device clock 
 Setup deferred workqueue data 
 All clocks are now on 
 Allocate memory for the UDCA 
 Setup the DD DMA memory pool 
 Clear USB peripheral and initialize gadget endpoints 
	 Request IRQs - low and high priority USB device IRQs are routed to
	 The transceiver interrupt is used for VBUS detection and will
 Initialize wait queue 
 Disable clocks for now 
 Power down ISP 
 Disable clocking 
		 Keep clock flag on, so we know to re-enable clocks
 Kill global USB clock 
 Enable global USB clock 
 Enable clocking 
 ISP back to normal power mode 
 SPDX-License-Identifier: GPL-2.0
  M66592 UDC (USB gadget)
  Copyright (C) 2006-2007 Renesas Solutions Corp.
  Author : Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
-------------------------------------------------------------------------
 isochronous pipes may be used as bulk pipes 
-------------------------------------------------------------------------
 if complete is true, gadget driver complete function is not call 
 trigger once 
 big endian 
 little endian 
 High spd 
 This is a workaound for SH7722 2nd cut 
 big endian 
 little endian 
 3.3v 
 1.5v 
 High spd 
-------------------------------------------------------------------------
 prepare parameters 
 write fifo 
 update parameters 
 check transfer finish 
 prepare parameters 
 write fifo 
 update parameters 
 check transfer finish 
 prepare parameters 
 update parameters 
 check transfer finish 
 read fifo 
 exit 
 AV: what happens if we get called again before that gets through? 
 Wait for the completion of status stage 
 if return value is true, call class driver's setup() 
 read fifo 
 check request 
 bus reset 
		
		  When USB clock stops, it cannot read register. Even if a
		  clock stops, the interrupt occurs. So this driver turn on
		  a clock by this timing and do re-reading of register.
 start vbus sampling 
-------------------------------------------------------------------------
 control 
-------------------------------------------------------------------------
 hook up the driver 
 start vbus sampling 
-------------------------------------------------------------------------
 initialize ucd 
-------------------------------------------------------------------------
 SPDX-License-Identifier: GPL-2.0
  Fusb300 UDC (USB gadget)
  Copyright (C) 2010 Faraday Technology Corp.
  Author : Yuan-hsin Chen <yhchen@faraday-tech.com>
 set fusb300_set_start_entry first before fusb300_set_epaddrofs 
 write data to cx fifo 
 length is less than max packet size 
 if IN 
 OUT 
 ep0 
 read data from cx fifo 
 exit 
 check request 
 clear sequence number 
 don't modify queue heads during completion callback 
 wait SW owner 
 check idma is done 
 finish out transfer 
 COMABT_INT has a highest priority 
 split on 
 enable high-speed LPM 
set u1 u2 timmer
 enable all grp1 interrupt 
------------------------------------------------------------------------
 hook up the driver 
--------------------------------------------------------------------------
 initialize udc 
 SPDX-License-Identifier: GPL-2.0+
  Driver for PLX NET2272 USB device controller
  Copyright (C) 2005-2006 PLX Technology, Inc.
  Copyright (C) 2006-2011 Analog Devices, Inc.
  use_dma: the NET2272 can use an external DMA controller.
  Note that since there is no generic DMA api, some functions,
  notably request_dma, start_dma, and cancel_dma will need to be
  modified for your platform's particular dma controller.
  If use_dma is disabled, pio will be used instead.
  dma_ep: selects the endpoint for use with dma (1=ep-a, 2=ep-b)
  The NET2272 can only use dma for a single endpoint at a time.
  At some point this could be modified to allow either endpoint
  to take control of dma as it becomes available.
  Note that DMA should not be used on OUT endpoints unless it can
  be guaranteed that no short packets will arrive on an IN endpoint
  while the DMA operation is pending.  Otherwise the OUT DMA will
  terminate prematurely (See NET2272 Errata 630-0213-0101)
  dma_mode: net2272 dma mode setting (see LOCCTL1 definiton):
 	mode 0 == Slow DREQ mode
 	mode 1 == Fast DREQ mode
 	mode 2 == Burst mode
  fifo_mode: net2272 buffer configuration:
       mode 0 == ep-{a,b,c} 512db each
       mode 1 == ep-a 1k, ep-{b,c} 512db
       mode 2 == ep-a 1k, ep-b 1k, ep-c 512db
       mode 3 == ep-a 1k, ep-b disabled, ep-c 512db
  enable_suspend: When enabled, the driver will respond to
  USB suspend requests by powering down the NET2272.  Otherwise,
  USB suspend requests will be ignored.  This is acceptible for
  self-powered devices.  For bus powered devices set this to 1.
---------------------------------------------------------------------------
 net2272_ep_reset() has already been called 
 set speed-dependent max packet 
 set type, direction, address; reset fifo counters 
 catch some particularly blatant driver bugs 
 for OUT transfers, block the rx fifo until a read is posted 
 enable irqs 
 disable irqs, endpoint 
	 init to our chosen defaults, notably so that we NAK OUT
	  packets until the driver queues a read.
 scrub most status bits, and flush any fifo state 
 fifo size is handled seperately 
---------------------------------------------------------------------------
 don't modify queue heads during completion callback 
 no byte-swap required; chip endian set during init 
 write final byte by placing the NET2272 into 8-bit mode 
 returns: 0: still running, 1: completed, negative: errno 
	
	  Keep loading the endpoint until the final packet is loaded,
	  or the endpoint buffer is full.
	
	  Clear interrupt status
	   - Packet Transmitted interrupt will become set again when the
	     host successfully takes another packet
 force pagesel 
 see if we are done 
 validate short or zlp packet 
 remove any zlp from the buffer 
 Ensure we get the final byte 
	
	  To avoid false endpoint available race condition must read
	  ep stat0 twice in the case of a short transfer
 completion 
			 re-initialize endpoint transfer registers
			  otherwise they may result in erroneous pre-validation
			  for subsequent control reads
 returns 0 on success, else negative errno 
 The NET2272 only supports a single dma channel 
	
	  EP_TRANSFER (used to determine the number of bytes received
	  in an OUT transfer) is 24 bits wide; don't ask for more than that.
 initialize platform's dma 
 NET2272 addr, buffer addr, length, etc. 
 Setup PLX 9054 DMA mode 
 start platform's dma controller 
 returns 0 on success, else negative errno 
	 don't use dma for odd-length transfers
	  otherwise, we'd need to deal with the last byte with pio
 The NET2272 can only use DMA on one endpoint at a time 
	 Make sure we only DMA an even number of bytes (we'll use
	  pio to complete the transfer)
 device-to-host transfer 
 initialize platform's dma controller 
 unable to obtain DMA channel; return error and use pio mode 
 host-to-device transfer 
 initialize platform's dma controller 
 unable to obtain DMA channel; return error and use pio mode 
 allow the endpoint's buffer to fill 
		 this transfer completed and data's already in the fifo
		  return error so pio gets used.
 deassert dreq 
 Don't use per-packet interrupts: use dma interrupts only 
 wait for dma to stabalize 
 dma abort generates an interrupt 
---------------------------------------------------------------------------
 set up dma mapping in case the caller didn't 
 kickstart this io queue? 
 maybe there's no control data, just status ack 
 Return zlp, don't let it block subsequent packets 
 Buffer is empty check for a blocking zlp, handle it 
				
				  Request is going to terminate with a short packet ...
				  hope the client is ready for it!
 clear short packet naking 
 try dma first 
			 dma failed (most likely in use by another endpoint)
			  fallback to pio
 dequeue ALL requests 
 called with spinlock held 
 dequeue JUST ONE request 
 make sure it's still queued on this endpoint 
 queue head may be partially complete 
---------------------------------------------------------------------------
 not ep0  && usb_endpoint_xfer_isoc(ep->desc))
 setclear 
---------------------------------------------------------------------------
---------------------------------------------------------------------------
 Main Control Registers 
 DMA 
 USB Control Registers 
 Endpoint Registers 
---------------------------------------------------------------------------
 always ep-a, ep-c ... maybe not ep-b 
 ep-c is always 2 512 byte buffers 
---------------------------------------------------------------------------
 clear irq state 
	 Set the NET2272 ep fifo data width to 16-bit mode and for correct byte swapping
	  note that the higher level gadget drivers are expected to convert data to little endian.
	  Enable byte swap for your local buscpu if needed by setting BYTE_SWAP in LOCCTL here
 basic endpoint init 
 when a driver is successfully registered, it will receive
  control requests including set_configuration(), which enables
  non-control requests.  then usb traffic follows until a
  disconnect is reported.  then a host may connect again, or
  the driver might get unbound.
 hook up the driver ... 
	 ... then enable host detection and ep0; and we're ready
	  for set_configuration as well as eventual disconnect.
 don't disconnect if it's not connected 
	 stop hardware; prevent new request submissions;
	  and kill any outstanding requests.
 report disconnect; the driver is already quiesced 
---------------------------------------------------------------------------
 handle ep-aep-b dma completions 
 Ensure DREQ is de-asserted 
 device-to-host transfer completed 
 validate a short packet or zlp if necessary 
 host-to-device transfer completed 
 terminated with a short packet? 
 abort system dma 
		 EP_TRANSFER will contain the number of bytes
		  actually received.
		  NOTE: There is no overflow detection on EP_TRANSFER:
		  We can't deal with transfers larger than 2^24 bytes!
 get any remaining data 
---------------------------------------------------------------------------
 ack all, and handle what we care about 
	 data packet(s) received (in the fifo, OUT)
	  direction must be validated, otherwise control read status phase
	  could be interpreted as a valid packet
 data packet(s) transmitted (IN) 
  USB Test Packet:
  JKJKJKJK  9
  JJKKJJKK  8
  JJJJKKKK  8
  JJJJJJJKKKKKKK  8
  JJJJJJJK  8
  {JKKKKKKK  10}, JK
	 Disable all net2272 interrupts:
	  Nothing but a power cycle should stop the test.
 Force tranceiver to high-speed 
 wait for status phase to complete 
 Enable test mode 
 load test packet 
 switch to 8 bit mode 
 Validate test packet 
 starting a control request? 
 make sure any leftover interrupt state is cleared 
		
		  Ensure Control Read pre-validation setting is beyond maximum size
		   - Control Writes can leave non-zero values in EP_TRANSFER. If
		     an EP0 transfer following the Control Write is a Control Read,
		     the NET2272 sees the non-zero EP_TRANSFER as an unexpected
		     pre-validation count.
		   - Setting EP_TRANSFER beyond the maximum EP0 transfer size ensures
		     the pre-validation count cannot cause an unexpected validatation
		
		  If you have a big endian cpu make sure le16_to_cpus
		  performs the proper byte swapping here...
 ack the irq 
		 watch control traffic at the token level, and force
		  synchronization before letting the status phase happen.
 don't bother with a request object! 
 don't bother with a request object! 
 don't bother with a request object! 
 stall ep0 on error 
 endpoint dma irq? 
 endpoint data irq? 
 does this endpoint's FIFO and queue need tending? 
 some interrupts we can just ignore 
 after disconnect there's nothing else to do! 
		
		  Ignore disconnects and resets if the speed hasn't been set.
		  VBUS can bounce and there's always an initial reset.
 clear any other statusirqs 
 some status we can just ignore 
 see if PCI int for us by checking irqstat 
 check dma interrupts 
 Platformdevcice interrupt handler 
	
	  Quick test to see if CPU can communicate properly with the NET2272.
	  Verifies connection using writes and reads to writeread and
	  read-only registers.
	 
	  This routine is strongly recommended especially during early bring-up
	  of new hardware, however for designs that do not apply Power On System
	  Tests (POST) it may discarded (or perhaps minimized).
 Verify NET2272 writeread SCRATCH register can write and read 
 To be nice, we write the original SCRATCH value back: 
 Verify NET2272 CHIPREV register is read-only: 
	
	  Verify NET2272's "NET2270 legacy revision" register
	   - NET2272 has two revision registers. The NET2270 legacy revision
	     register should read the same value, regardless of the NET2272
	     silicon revision.  The legacy register applies to NET2270
	     firmware being applied to the NET2272.
		
		  Unexpected legacy revision value
		  - Perhaps the chip is a NET2270?
	
	  Verify NET2272 silicon revision
	   - This revision register is appropriate for the silicon version
	     of the NET2272
		
		  NET2272 Rev 1 has DMA related errata:
		   - Newer silicon (Rev 1A or better) required
 NET2272 silicon version may not work with this firmware 
		
		  Return Success, even though the chip rev is not an expected value
		   - Older, pre-built firmware can attempt to operate on newer silicon
		   - Often, new silicon is perfectly compatible
 Success: NET2272 checks out OK 
---------------------------------------------------------------------------
 alloc, and start init 
 the "gadget" abstractsvirtualizes the controller 
 See if there... 
 done 
  wrap this driver around the specified device, but
  don't respond over USB until a gadget driver binds to us
	
	  BAR 0 holds PLX 9054 config registers
	  BAR 1 is io memory; unused here
	  BAR 2 holds EPLD config registers
	  BAR 3 holds NET2272 registers
 Find and map all address spaces 
 BAR1 unused 
 Set PLX 9054 bus width (16 bits) 
 Enable PLX 9054 Interrupts 
 reset 
 BAR1 unused 
	
	  BAR 0 holds FGPA config registers
	  BAR 1 holds NET2272 registers
 Find and map all address spaces, bar2-3 unused in rdk 2 
 Set 2272 bus width (16 bits) and reset 
 Print fpga version number 
 Enable FPGA Interrupts 
 disable PLX 9054 interrupts 
 clean up resources allocated during probe() 
 BAR1 unused 
	 disable fpga interrupts
	writel(readl(dev->rdk1.plx9054_base_addr + INTCSR) &
			~(1 << PCI_INTERRUPT_ENABLE),
			dev->rdk1.plx9054_base_addr + INTCSR);
 clean up resources allocated during probe() 
 Table of matching PCI IDs 
 RDK 1 card 
 RDK 2 card 
---------------------------------------------------------------------------
 FIXME .suspend, .resume 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2011 Marvell International Ltd. All rights reserved.
  Author: Chao Xie <chao.xie@marvell.com>
 	   Neil Zhang <zhangwm@marvell.com>
 timeout value -- usec 
 for endpoint 0 operations 
 ep0 in and out 
 ep0 dQH 
 configure ep0 endpoint capabilities in dQH 
 TX 
 RX 
 protocol ep0 stall, will automatically be cleared on new transaction 
 set TX and RX to stall 
 update ep0 state 
 Clear the errors and Halt condition 
  done() - retire a request; caller blocked irqs
  @status : request status to be set, only works when
  request is still in progress.
 Removed the req from fsl_ep->queue 
 req.status should be set as -EINPROGRESS in ep_queue() 
 Free dtd for the request 
 check if the pipe is empty 
 start with setting the semaphores 
 read the endpoint status 
			
			  Reread the ATDTW semaphore bit to check if it is
			  cleared. When hardware see a hazard, it will clear
			  the bit or else we remain set to 1 and we can
			  proceed with priming of endpoint if not already
			  primed.
 Clear the semaphore 
 Write dQH next pointer and terminate bit to 0 
 clear active and halt bit, in case set from a previous error 
 Ensure that updates to the QH will occur before priming. 
 Prime the Endpoint 
 how big will this transfer be? 
	
	  Be careful that no _GFP_HIGHMEM is set,
	  or we can not use dma_to_virt
 initialize buffer page pointers 
 zlp is needed if req->req.zero is set 
 Fill in the transfer size; set active bit 
 Enable interrupt for the last dtd of a request 
 generate dTD linked list for a request 
 set terminate bit to 1 for the last dTD 
	
	  disable HW zero length termination select
	  driver handles zero length packet through req->req.zero
 Check if the Endpoint is Primed 
 Set the max packet length, interrupt on Setup and Mult fields 
 Calculate transactions needed for high bandwidth iso 
 3 transactions at most 
 Get the endpoint queue head address 
 Enable the endpoint for Rx or Tx and set the endpoint type 
	
	  Implement Guideline (GL# USB-7) The unused endpoint type must
	  be programmed to bulk.
 Get the endpoint queue head address 
 Reset the max packet length and the interrupt on Setup 
 Disable the endpoint for Rx or Tx and reset the endpoint type 
 nuke all pending requests (does flush) 
 Write 1 to the Flush register 
 Wait until flushing completed 
			
			  ENDPTFLUSH bit should be cleared to indicate this
			  operation is complete
 queues (submits) an IO request to an endpoint 
 catch various bogus parameters 
 map virtual address to hardware 
 build dtds and push them to device queue 
 Update ep0 state 
 irq handler advances the queue 
 Write dQH next pointer and terminate bit to 0 
 clear active and halt bit, in case set from a previous error 
 Ensure that updates to the QH will occure before priming. 
 Prime the Endpoint 
 dequeues (cancels, unlinks) an IO request from an endpoint 
 Stop the ep before we deal with the queue 
 make sure it's actually queued on this endpoint 
 The request is in progress, or completed but not dequeued 
 flush current transfer 
 The request isn't the last request in this ep queue 
 Point the QH to the first TD of next request 
 The request hasn't been processed, patch up the TD chain 
 Enable EP 
	
	  Attempt to halt IN ep will fail if any transfer requests
	  are still queue
 flush fifo 
 Disable interrupts 
 Reset the Run the bit in the command register to stop VUSB 
 Enable interrupts 
 Set the Run bit in the command register 
 Stop the controller 
 Reset the controller to get default values 
 wait for reset to complete 
 set controller to device mode 
 turn setup lockout off, require setup tripwire in usbcmd 
 Configure the Endpoint List Address 
 Tries to wake up the host connected to this gadget 
 Remote wakeup feature not enabled by host 
 not suspended? 
 trigger force resume 
 Clock is disabled, need re-init registers 
 stop all the transfer in queue
 Clock is disabled, need re-init registers 
 stop all the transfer in queue
 device controller usb_gadget_ops structure 
 returns the current frame number 
 tries to wake up the host connected to this gadget 
 notify controller that VBUS is powered or not 
 D+ pullup, software-controlled connectdisconnect to USB host 
 initialize ep0 
 initialize other endpoints 
 delete all endpoint requests, called with spinlock held 
 called with spinlock held 
 endpoint fifo flush 
 report reset; the driver is already quiesced 
 stop all USB activities 
 report disconnect; the driver is already quiesced 
 hook up the driver ... 
 When boot with cable attached, there will be no vbus irq occurred 
 stop all usb activities 
 unbind gadget driver 
 fill in the reqest structure 
 prime the data phase 
 no mem 
 update usb state 
 get interface status 
 We process some standard setup requests here 
 delegate USB standard requests to the gadget driver 
 USB requests handled by gadget 
 DATA phase from gadget, STATUS phase from udc 
 no DATA phase, IN STATUS phase from gadget 
 complete DATA or STATUS phase of ep0 prime status phase if needed 
 set the new address 
 receive status phase 
 send status phase 
 Clear bit in ENDPTSETUPSTAT 
 while a hazard exists when setup package arrives 
 Set Setup Tripwire 
 Copy the setup packet to local buffer 
 Clear Setup Tripwire 
	
	  We use separate loops for ENDPTSETUPSTAT and ENDPTCOMPLETE
	  because the setup packets are to be read ASAP
 Process all Setup packet received interrupts 
	 Don't clear the endpoint setup status register here.
	  It is cleared as a setup packet is read out of the buffer
 Process non-setup transaction complete interrupts 
 process the req queue until an uncomplete request 
 write back status to req 
 ep0 request completion 
 default to 0 on reset 
 The address bits are past bit 25-31. Set the address 
 Clear all the setup token semaphores 
 Clear all the endpoint complete status bits 
 wait until all endptprime bits cleared 
 Write 1s to the Flush register 
 reset all the queues, stop all USB activities 
		
		  re-initialize
		  controller reset
 reset all the queues, stop all USB activities 
 reset ep0 dQH and endptctrl 
 enable interrupt and set controller to run state 
 report resume to the driver 
 Get the speed 
 Increment the error count 
 Disable ISR when stopped bit is set 
 Clear all the interrupts occurred 
 polling VBUS and init phy may cause too much time
 release device structure 
 free memory allocated in probe 
 free dev, wait for the release() finished 
 udc only have one sysclk. 
 we will acces controller register, so enable the clk 
	
	  some platform will use usb to download image, it may not disconnect
	  usb gadget before loading kernel. So first stop udc here.
 create dTD dma_pool resource 
 initialize ep0 status request structure 
 allocate a small amount of memory to get valid address 
 initialize gadget structure 
 usb_gadget_ops 
 gadget ep0 
 ep_list 
 speed 
 support dual speed 
 the "gadget" abstractsvirtualizes the controller 
 gadget name 
 VBUS detect: we can disableenable clock on demand.
	
	  When clock gating is supported, we can disable clk and phy.
	  If not, it means that VBUS detection is not supported, we
	  have to enable vbus active all the time to let controller work.
 if OTG is enabled, the following will be done in OTG driver
	
	  only cable is unplugged, udc can suspend.
	  So do not care about clock_gating == 1.
 stop all usb activities 
 if OTG is enabled, the following will be done in OTG driver
 reset controller mode to IDLE 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2004-2007,2011-2012 Freescale Semiconductor, Inc.
  All rights reserved.
  Author: Li Yang <leoli@freescale.com>
          Jiang Bo <tanya.jiang@freescale.com>
  Description:
  Freescale high-speed USB SOC DR module device controller driver.
  This can be found on MPC8349EMPC8313EMPC5121E cpus.
  The driver is previously named as mpc_udc.  Based on bare board
  code from Dave Liu and Shlomi Gridish.
 it is initialized in probe()  
  On some SoCs, the USB controller registers can be big or little endian,
  depending on the version of the chip. In order to be able to run the
  same kernel binary on 2 different versions of an SoC, the BELE decision
  must be made at run time. _fsl_readl and fsl_writel are pointers to the
  BE or LE readl() and writel() functions, and fsl_readl() and fsl_writel()
  call through those pointers. Platform code for SoCs that have BE USB
  registers should set pdata->big_endian_mmio flag.
  This also applies to controller-to-cpu accessors for the USB descriptors,
  since their endianness is also SoC dependant. Platform code for SoCs that
  have BE USB descriptors should set pdata->big_endian_desc flag.
 !CONFIG_PPC32 
 CONFIG_PPC32 
 	Internal Used Function
-----------------------------------------------------------------
  done() - retire a request; caller blocked irqs
  @status : request status to be set, only works when
 	request is still in progress.
 Removed the req from fsl_ep->queue 
 req.status should be set as -EINPROGRESS in ep_queue() 
 Free dtd for the request 
-----------------------------------------------------------------
  nuke(): delete all requests related to this ep
  called with spinlock held
 Flush fifo 
 Whether this eq has request linked 
------------------------------------------------------------------
	Internal Hardware related function
 Config PHY interface 
 controller version 1.6 or above 
 controller version 1.6 or above 
				mdelay(FSL_UTMI_PHY_DLY);  Delay for UTMI
 Stop and reset the usb controller 
 Wait for reset to complete 
 Set the controller as device mode 
 clear mode bits 
 Disable Setup Lockout 
 Clear the setup status 
 Config control enable io output, cpu endian register 
	 Turn on cache snooping hardware, since some PowerPC platforms
 Setup Snooping for all the 4GB space 
 starts from 0x0, size 2G 
 starts from 0x8000000, size 2G 
 Enable DR irq and set controller to run state 
 Enable DR irq reg 
 Clear stopped bit 
 Set the controller as device mode 
 Set controller to Run 
	 if we're in OTG mode, and the Host is currently using the port,
	  stop now and don't rip the controller out from under the
	  ehci driver
 disable all INTR 
 Set stopped bit for isr 
 disable IO output 
	usb_sys_regs->control = 0; 
 set controller to Stop 
 set the stall bit 
 clear the stall bit and reset data toggle 
 Get stall status of a specific ep
	Internal Structure Build up functions
------------------------------------------------------------------
 struct_ep_qh_setup(): set the Endpoint Capabilites field of QH
  @zlt: Zero Length Termination Select (1: disable; 0: enable)
  @mult: Mult field
 set the Endpoint Capabilites in QH 
 Interrupt On Setup (IOS). for control ep  
 Setup qh structure and ep register for ep0. 
	 the initialization of an ep includes: fields in QH, Regs,
		Endpoint Management Functions
-------------------------------------------------------------------------
  when configurations are set, or when interface settings change
  for example the do_set_interface() in gadget layer,
  the driver will enable or disable the relevant endpoints
  ep0 doesn't use this routine. It is always enabled.
 catch various bogus parameters 
	 Disable automatic zlp generation.  Driver is responsible to indicate
	  explicitly through req->req.zero.  This is needed to enable multi-td
 Assume the max packet size from gadget is always correct 
		 mult = 0.  Execute N Transactions as demonstrated by
		  the USB variable length packet protocol where N is
		  computed using the Maximum Packet Length (dQH) and
 Calculate transactions needed for high bandwidth iso 
 3 transactions at most 
 Controller related setup 
	 Init EPx Queue Head (Ep Capabilites field in QH
 Init endpoint ctrl register 
---------------------------------------------------------------------
  @ep : the ep being unconfigured. May not be ep0
  Any pending and uncomplete req will complete with status (-ESHUTDOWN)
 disable ep on controller 
 nuke all pending requests (does flush) 
---------------------------------------------------------------------
  allocate a request object used by this endpoint
  the main operation is to insert the req->queue to the eq->queue
  Returns the request, or null if one could not be allocated
 Actually add a dTD chain to an empty dQH and let go 
 Write dQH next pointer and terminate bit to 0 
 Clear active and halt bit 
 Ensure that updates to the QH will occur before priming. 
 Prime endpoint by writing correct bit to ENDPTPRIME 
 Add dTD chain to the dQH of an EP 
	 VDBG("QH addr Register 0x%8x", dr_regs->endpointlistaddr);
 check if the pipe is empty 
 Add td to the end 
 Ensure dTD's next dtd pointer to be updated 
 Read prime bit, if 1 goto done 
 Set ATDTW bit in USBCMD 
 Read correct status bit 
 Write ATDTW bit to 0 
 Fill in the dTD structure
  @req: request that the transfer belongs to
  @length: return actually data length of the dTD
  @dma: return dma address of the dTD
  @is_last: return flag if it is the last dTD of the request
 how big will this transfer be? 
 Clear reserved field 
 Init all of buffer page pointers 
 zlp is needed if req->req.zero is set 
 Fill in the transfer size; set active bit 
 Enable interrupt for the last dtd of a request 
 Generate dtd chain for a request 
 queues (submits) an IO request to an endpoint 
 catch various bogus parameters 
 build dtds and push them to device queue 
 irq handler advances the queue 
 dequeues (cancels, unlinks) an IO request from an endpoint 
 Stop the ep before we deal with the queue 
 make sure it's actually queued on this endpoint 
 The request is in progress, or completed but not dequeued 
 flush current transfer 
 The request isn't the last request in this ep queue 
 prime with dTD of next request 
 The request hasn't been processed, patch up the TD chain 
 Enable EP 
-------------------------------------------------------------------------
-----------------------------------------------------------------
  modify the endpoint halt feature
  @ep: the non-isochronous endpoint being stalled
  @value: 1--set halt  0--clear halt
  Returns zero, or a negative error code.
 operation not supported 
	 Attempt to halt IN ep will fail if any transfer requests
 Wait until flush complete 
 See if we need to flush again 
 flush fifo 
-------------------------------------------------------------------------
		Gadget Driver Layer Operations
----------------------------------------------------------------------
  Get the current frame number (from DR frame_index Reg )
-----------------------------------------------------------------------
  Tries to wake up the host connected to this gadget
 Remote wakeup feature not enabled by host 
 not suspended? 
 trigger force resume 
 Notify controller that VBUS is powered, Called by whatever
 constrain controller's VBUS power usage
  This call is used by gadget drivers during SET_CONFIGURATION calls,
  reporting how much power the device may consume.  For example, this
  could affect how quickly batteries are recharged.
  Returns zero on success, else negative errno.
 Change Data+ pullup status
  this func is used by usb_gadget_connectdisconnect
	.set_selfpowered = fsl_set_selfpowered,	 
  Empty complete function used by this driver to fill in the req->complete
  field when creating a request since the complete field is mandatory.
 Set protocol stall on ep0, protocol stall will automatically be cleared
 must set tx and rx to stall at the same time 
 Prime a status phase for ep0 
  ch9 Set address
 Save the new address to device struct 
 Update usb state 
 Status phase 
  ch9 Get status
 Status, cpu endian 
 Get device status 
 Get interface status 
 We don't have interface information in udc driver 
 Get endpoint status 
 stall if endpoint doesn't exist 
 Borrow the per device status_req 
 Fill in the reqest structure 
 prime the data phase 
 no mem 
 We process some stardard setup requests here 
 Data+Status phase from udc 
 Status phase from udc 
 Status phase from udc 
			 Note: The driver has not include OTG support yet.
 Requests handled by gadget 
 Data phase from gadget, status phase from udc 
		
		  If the data stage is IN, send status prime immediately.
		  See 2.0 Spec chapter 8.5.3.3 for detail.
 No data phase, IN status from gadget 
 Process request for Data or Status phase of ep0
 Set the new address 
 already primed at setup_received_irq 
 send status phase 
 Tripwire mechanism to ensure a setup packet payload is extracted without
 Clear bit in ENDPTSETUPSTAT 
 while a hazard exists when setup package arrives 
 Set Setup Tripwire 
 Copy the setup packet to local buffer 
 Convert little endian setup buffer to CPU endian 
 Clear Setup Tripwire 
 process-ep_req(): free the completed Tds for this req 
 Clear the errors and Halt condition 
 FIXME: continue with next queued TD? 
 Process a DTD completion interrupt 
 Clear the bits in the register 
 If the ep is configured 
 process the req queue until an uncomplete request 
 write back status to req 
 Process a port change interrupt 
 Bus resetting is finished 
 Get the speed 
 Update USB state 
 Process suspend interrupt 
 report suspend to the driver, serial.c does not support this 
 report resume to the driver, serial.c does not support this 
 Clear up all ep queues 
 report disconnect; the driver is already quiesced 
 Process reset interrupt 
 Clear the device address 
 Clear usb state 
 default to 0 on reset 
 Clear all the setup token semaphores 
 Clear all the endpoint complete status bits 
 Wait until all endptprime bits cleared 
 Write 1s to the flush register 
 Bus is reseting 
		 Reset all the queues, include XD, dTD, EP queue
		 initialize usb hw reg except for regs for EP, not
 Reset all internal used Queues 
 Enable DR IRQ reg, Set Run bit, change udc state 
  USB device controller interrupt handler
 Disable ISR for OTG host mode 
 Clear notification bits 
 VDBG("irq_src [0x%8x]", irq_src); 
 Need to resume? 
 USB Interrupt 
 Setup package, we only support ep0 as control ep 
 completion of dtd 
 SOF (for ISO transfer) 
 Port Change 
 Reset Received 
 Sleep Enable (Suspend) 
----------------------------------------------------------------
  Hook to gadget drivers
  Called by initialization code of gadget drivers
 lock is needed but whether should use this lock or another 
 hook up the driver 
 Suspend the controller until OTG enable it 
 connect to bus through transceiver 
 Enable DR IRQ reg and set USBCMD reg Run bit 
 Disconnect from gadget driver 
 stop DR, disable intr 
 in fact, no needed 
 stand operation 
-------------------------------------------------------------------------
		PROC File System Support
 ------basic driver information ---- 
 ------ DR Registers ----- 
 ------fsl_udc, fsl_ep, fsl_request structure information ----- 
 other gadget->eplist ep 
 end for each_entry of ep req 
 end for else 
 end for if(ep->queue) 
 end (ep->desc) 
 !CONFIG_USB_GADGET_DEBUG_FILES 
 CONFIG_USB_GADGET_DEBUG_FILES 
-------------------------------------------------------------------------
 Release udc structures 
	Internal structure setup functions
------------------------------------------------------------------
  init resource for global controller called by fsl_udc_probe()
  On success the udc handle is initialized, on failure it is
  unchanged (reset).
  Return 0 on success and -1 on allocation failure
 initialized QHs, take care of alignment 
 Initialize ep0 status request structure 
 FIXME: fsl_alloc_request() ignores ep argument 
 allocate a small amount of memory to get valid address 
 default to 0 on reset 
----------------------------------------------------------------
  Setup the fsl_ep struct for eps
  Link fsl_ep->ep to gadget->ep_list
  ep0out is not used so do nothing here
  ep0in should be taken care
	 for ep0: maxP defined in desc
	  for other eps, maxP is set by epautoconfig() called by gadget layer
 the queue lists any req for this ep 
 gagdet.ep_list used for ep_autoconfig so no ep0 
 Driver probe function
  all initialization operations implemented here except enabling usb_intr reg
  board setup should have been done in the platform code
	
	  do platform specific init: check the clock, grabconfig pins, etc.
 Set accessors only after pdata->init() ! 
 Read Device Controller Capability Parameters register 
 Get max device endpoints 
 DEN is bidirectional ep number, max_ep doubles the number 
 Initialize the udc structure including QH member and other member 
		 initialize usb hw reg except for regs for EP,
 Setup gadget structure 
 Setup gadget.dev and register with kernel 
 setup QH and epctrl for ep0 
 setup udc->eps[] for ep0 
	 for ep0: the desc defined here;
	  for other eps, gadget layer called ep_enable with defined desc
	 setup the udc->eps[] for non-control endpoints and link
 use dma_pool for TD management 
 Driver removal function
  Free resources and finish pending transactions
 DR has been stopped in usb_gadget_unregister_driver() 
 Free allocated memory 
 free udc --wait for the release() finished 
	
	  do platform specific un-initialization:
	  release iomux pins, etc.
-----------------------------------------------------------------
  Modify Power management attributes
  Used by OTG statemachine to disable gadget temporarily
-----------------------------------------------------------------
  Invoked on USB resume. May be called in_interrupt.
  Here we start the DR controller and enable the irq
 Enable DR irq reg and set controller Run 
	
	  If the controller is already stopped, then this must be a
	  PM suspend.  Remember this fact, so that we will leave the
	  controller stopped at PM resume time.
 stop the controller 
	
	  If the controller was stopped at suspend time, then
	  don't resume it now.
-------------------------------------------------------------------------
	Register entry point for the peripheral controller driver
 sentinel 
 these suspend and resume are not usb suspend and resume 
 udc suspendresume called from OTG driver 
 SPDX-License-Identifier: GPL-2.0
  R8A66597 UDC (USB gadget)
  Copyright (C) 2006-2009 Renesas Solutions Corp.
  Author : Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
-------------------------------------------------------------------------
 isochronous pipes may be used as bulk pipes 
 already allocated pipe  
-------------------------------------------------------------------------
 if complete is true, gadget driver complete function is not call 
 check current BFRE bit 
 change BFRE bit 
 initialize for internal BFRE flag 
 Check transfer type 
 set SUDMAC parameters 
 set r8a66597_ep paramters 
 dma mapping 
 PIO mode 
 DMA mode 
 PIO mode 
 trigger once 
 trigger once 
 High spd 
 disable interrupts 
 clear status 
-------------------------------------------------------------------------
 prepare parameters 
 write fifo 
 update parameters 
 check transfer finish 
 prepare parameters 
 write fifo 
 update parameters 
 check transfer finish 
 prepare parameters 
 update parameters 
 check transfer finish 
 read fifo 
 exit 
 AV: what happens if we get called again before that gets through? 
 Wait for the completion of status stage 
 if return value is true, call class driver's setup() 
 read fifo 
 check request 
 bus reset 
 timeout = 10 msec 
 prepare parameters 
 clear 
 check transfer finish 
 Clear the interrupt flag for next transfer 
 start vbus sampling 
-------------------------------------------------------------------------
 control 
-------------------------------------------------------------------------
 hook up the driver 
 start vbus sampling 
-------------------------------------------------------------------------
 initialize ucd 
 make sure controller is disabled 
-------------------------------------------------------------------------
 SPDX-License-Identifier: GPL-2.0+
  amd5536udc_pci.c -- AMD 5536 UDC highfull speed USB device controller
  Copyright (C) 2005-2007 AMD (https:www.amd.com)
  Author: Thomas Dahlmann
  The AMD5536 UDC is part of the x86 southbridge AMD Geode CS5536.
  It is a USB Highspeed DMA capable USB device controller. Beside ep0 it
  provides 4 IN and 4 OUT endpoints (bulk or interrupt type).
  Make sure that UDC is assigned to port 4 by BIOS settings (port can also
  be used as host port) and UOC bits PAD_EN and APU are set (should be done
  by BIOS init).
  UDC DMA requires 32-bit aligned buffers so DMA with gadget ether does not
  work without updating NET_IP_ALIGN. Or PIO mode (module param "use_dma=0")
  can be used with gadget ether.
  This file does pci device registration, and the core driver implementation
  is done in amd5536udc.c
  The driver is split so as to use the core UDC driver which is based on
  Synopsys device controller IP (different than HS OTG IP) in UDCs
  integrated to SoC platforms.
 Driver strings 
 system 
 udc specific 
 pointer to device object 
 description 
 Reset all pci context 
 gadget driver must not be registered 
 dma pool cleanup 
 reset controller 
 Called by pci bus driver to init pci context 
 one udc only 
 init 
 pci setup 
 PCI resource allocation 
 udc csr registers base 
 dev registers base 
 ep registers base 
 fifo's base 
 chip revision for Hs AMD5536 
 init dma pools 
 general probing 
 PCI device parameters 
 PCI functions 
 SPDX-License-Identifier: GPL-2.0
  snps_udc_plat.c - Synopsys UDC Platform Driver
  Copyright (C) 2016 Broadcom
 description 
 Flush the receieve fifo 
	 Mask interrupts. Required more so when the
	  UDC is connected to a DRD phy.
 Disconnect gadget driver 
 empty queues 
 udc csr registers base 
 dev registers base 
 ep registers base 
 fifo's base 
 Register for extcon if supported 
 init dma pools 
 gadget driver must not be registered 
 dma pool cleanup 
 SPDX-License-Identifier: GPL-2.0
  FOTG210 UDC Driver supports Bulk transfer so far
  Copyright (C) 2013 Faraday Technology Corporation
  Author : Yuan-Hsin Chen <yhchen@faraday-tech.com>
 don't modify queue heads during completion callback 
	 Driver should map an ep to a fifo and then map the fifo
	  to the ep. What a brain-damaged design!
 map a fifo to an ep 
 map the ep to the fifo 
 enable fifo 
	 Note: Driver needs to set and clear INOUTEPMPSR_RESET_TSEQ
	 	 bit. Controller wouldn't clear this bit. WTF!!!
 set transfer length and direction 
 set device DMA target FIFO number 
 set DMA memory address 
 enable MDMA_EROR and MDMA_CMPLT interrupt 
 start DMA 
 reset fifo 
 check if dma is done 
 update actual transfer length 
 if IN 
 OUT 
 ep0 
 check if IN FIFO is empty before stall 
 read 8-byte setup packet only 
 exit 
 check request 
	 Complete the request when it's full or a short packet arrived.
	  Like other drivers, short_not_ok isn't handled.
 the highest priority in this source register 
 hook up the driver 
 enable device global interrupt 
 disable global interrupt and set int polarity to active high 
 disable device global interrupt 
 enable only grp2 irqs we handle 
 disable all fifo interrupt 
 disable cmd end 
 initialize udc 
 SPDX-License-Identifier: GPL-2.0+
  Handles the Intel 27x USB Device Controller (UDC)
  Inspired by original driver by Frank Becker, David Brownell, and others.
  Copyright (C) 2008 Robert Jarzmik
  This driver handles the USB Device Controller (UDC) in Intel's PXA 27x
  series processors.
  Such controller drivers work with a gadget driver.  The gadget driver
  returns descriptors, implements configuration and data protocols used
  by the host to interact with this device, and allocates endpoints to
  the different protocol interfaces.  The controller driver virtualizes
  usb hardware so that the gadget drivers will be more portable.
  This UDC hardware wants to implement a bit too much USB protocol. The
  biggest issues are:  that the endpoints have to be set up before the
  controller can be enabled (minor, and not uncommon); and each endpoint
  can only have one configuration, interface and alternative interface
  number (major, and very unusual). Once set up, these cannot be changed
  without a controller reset.
  The workaround is to setup all combinations necessary for the gadgets which
  will work with this driver. This is done in pxa_udc structure, statically.
  See pxa_udc, udc_usb_ep versus pxa_ep, and matching function find_pxa_ep.
  (You could modify this if needed.  Some drivers have a "fifo_mode" module
  parameter to facilitate such changes.)
  The combinations have been tested with these gadgets :
   - zero gadget
   - file storage gadget
   - ether gadget
  The driver doesn't use DMA, only IO access and IRQ callbacks. No use is
  made of UDC's double buffering either. USB "On-The-Go" is not implemented.
  All the requests are handled the same way :
   - the drivers tries to handle the request directly to the IO
   - if the IO fifo is not big enough, the remaining is sendreceived in
     interrupt handling.
  Debug filesystem
 basic device status 
 registers for device and ep0 
 dump endpoint queues 
  is_match_usb_pxa - check if usb_ep and pxa_ep match
  @udc_usb_ep: usb endpoint
  @ep: pxa endpoint
  @config: configuration required in pxa_ep
  @interface: interface required in pxa_ep
  @altsetting: altsetting required in pxa_ep
  Returns 1 if all criteria match between pxa and usb endpoint, 0 otherwise
  find_pxa_ep - find pxa_ep structure matching udc_usb_ep
  @udc: pxa udc
  @udc_usb_ep: udc_usb_ep structure
  Match udc_usb_ep and all pxa_ep available, to see if one matches.
  This is necessary because of the strong pxa hardware restriction requiring
  that once pxa endpoints are initialized, their configuration is freezed, and
  no change can be made to their address, direction, or in which configuration,
  interface or altsetting they are active ... which differs from more usual
  models which have endpoints be roughly just addressable fifos, and leave
  configuration events up to gadget drivers (like all control messages).
  Note that there is still a blurred point here :
    - we rely on UDCCR register "active interface" and "active altsetting".
      This is a nonsense in regard of USB spec, where multiple interfaces are
      active at the same time.
    - if we knew for sure that the pxa can handle multiple interface at the
      same time, assuming Intel's Developer Guide is wrong, this function
      should be reviewed, and a cache of couples (iface, altsetting) should
      be kept in the pxa_udc structure. In this case this function would match
      against the cache of couples instead of the "last altsetting" set up.
  Returns the matched pxa_ep structure or NULL if none found
  update_pxa_ep_matches - update pxa_ep cached values in all udc_usb_ep
  @udc: pxa udc
  Context: interrupt handler
  Updates all pxa_ep fields in udc_usb_ep structures, if this field was
  previously set up (and is not NULL). The update is necessary is a
  configuration change or altsetting change was issued by the USB host.
  pio_irq_enable - Enables irq generation for one endpoint
  @ep: udc endpoint
  pio_irq_disable - Disables irq generation for one endpoint
  @ep: udc endpoint
  udc_set_mask_UDCCR - set bits in UDCCR
  @udc: udc device
  @mask: bits to set in UDCCR
  Sets bits in UDCCR, leaving DME and FST bits as they were.
  udc_clear_mask_UDCCR - clears bits in UDCCR
  @udc: udc device
  @mask: bit to clear in UDCCR
  Clears bits in UDCCR, leaving DME and FST bits as they were.
  ep_write_UDCCSR - set bits in UDCCSR
  @ep: udc endpoint
  @mask: bits to set in UDCCR
  Sets bits in UDCCSR (UDCCSR0 and UDCCSR).
  A specific case is applied to ep0 : the ACM bit is always set to 1, for
  SET_INTERFACE and SET_CONFIGURATION.
  ep_count_bytes_remain - get how many bytes in udc endpoint
  @ep: udc endpoint
  Returns number of bytes in OUT fifos. Broken for IN fifos (-EOPNOTSUPP)
  ep_is_empty - checks if ep has byte ready for reading
  @ep: udc endpoint
  If endpoint is the control endpoint, checks if there are bytes in the
  control endpoint fifo. If endpoint is a data endpoint, checks if bytes
  are ready for reading on OUT endpoint.
  Returns 0 if ep not empty, 1 if ep empty, -EOPNOTSUPP if IN endpoint
  ep_is_full - checks if ep has place to write bytes
  @ep: udc endpoint
  If endpoint is not the control endpoint and is an IN endpoint, checks if
  there is place to write bytes into the endpoint.
  Returns 0 if ep not full, 1 if ep full, -EOPNOTSUPP if OUT endpoint
  epout_has_pkt - checks if OUT endpoint fifo has a packet available
  @ep: pxa endpoint
  Returns 1 if a complete packet is available, 0 if not, -EOPNOTSUPP for IN ep.
  set_ep0state - Set ep0 automata state
  @udc: udc device
  @state: state
  ep0_idle - Put control endpoint into idle state
  @dev: udc device
  inc_ep_stats_reqs - Update ep stats counts
  @ep: physical endpoint
  @is_in: ep direction (USB_DIR_IN or 0)
  inc_ep_stats_bytes - Update ep stats counts
  @ep: physical endpoint
  @count: bytes transferred on endpoint
  @is_in: ep direction (USB_DIR_IN or 0)
  pxa_ep_setup - Sets up an usb physical endpoint
  @ep: pxa27x physical endpoint
  Find the physical pxa27x ep, and setup its UDCCR
  pxa_eps_setup - Sets up all usb physical endpoints
  @dev: udc device
  Setup all pxa physical endpoints, except ep0
  pxa_ep_alloc_request - Allocate usb request
  @_ep: usb endpoint
  @gfp_flags:
  For the pxa27x, these can just wrap kmallockfree.  gadget drivers
  must still pass correctly initialized endpoints, since other controller
  drivers may care about how it's currently set up (dma issues etc).
  pxa_ep_free_request - Free usb request
  @_ep: usb endpoint
  @_req: usb request
  Wrapper around kfree to free _req
  ep_add_request - add a request to the endpoint's queue
  @ep: usb endpoint
  @req: usb request
  Context: ep->lock held
  Queues the request in the endpoint's queue, and enables the interrupts
  on the endpoint.
  ep_del_request - removes a request from the endpoint's queue
  @ep: usb endpoint
  @req: usb request
  Context: ep->lock held
  Unqueue the request from the endpoint's queue. If there are no more requests
  on the endpoint, and if it's not the control endpoint, interrupts are
  disabled on the endpoint.
  req_done - Complete an usb request
  @ep: pxa physical endpoint
  @req: pxa request
  @status: usb request status sent to gadget API
  @pflags: flags of previous spinlock_irq_save() or NULL if no lock held
  Context: ep->lock held if flags not NULL, else ep->lock released
  Retire a pxa27x usb request. Endpoint must be locked.
  ep_end_out_req - Ends endpoint OUT request
  @ep: physical endpoint
  @req: pxa request
  @pflags: flags of previous spinlock_irq_save() or NULL if no lock held
  Context: ep->lock held or released (see req_done())
  Ends endpoint OUT request (completes usb request).
  ep0_end_out_req - Ends control endpoint OUT request (ends data stage)
  @ep: physical endpoint
  @req: pxa request
  @pflags: flags of previous spinlock_irq_save() or NULL if no lock held
  Context: ep->lock held or released (see req_done())
  Ends control endpoint OUT request (completes usb request), and puts
  control endpoint into idle state
  ep_end_in_req - Ends endpoint IN request
  @ep: physical endpoint
  @req: pxa request
  @pflags: flags of previous spinlock_irq_save() or NULL if no lock held
  Context: ep->lock held or released (see req_done())
  Ends endpoint IN request (completes usb request).
  ep0_end_in_req - Ends control endpoint IN request (ends data stage)
  @ep: physical endpoint
  @req: pxa request
  @pflags: flags of previous spinlock_irq_save() or NULL if no lock held
  Context: ep->lock held or released (see req_done())
  Ends control endpoint IN request (completes usb request), and puts
  control endpoint into status state
  nuke - Dequeue all requests
  @ep: pxa endpoint
  @status: usb request status
  Context: ep->lock released
  Dequeues all requests on an endpoint. As a side effect, interrupts will be
  disabled on that endpoint (because no more requests).
  read_packet - transfer 1 packet from an OUT endpoint into request
  @ep: pxa physical endpoint
  @req: usb request
  Takes bytes from OUT endpoint and transfers them info the usb request.
  If there is less space in request than bytes received in OUT endpoint,
  bytes are left in the OUT endpoint.
  Returns how many bytes were actually transferred
 zlp 
  write_packet - transfer 1 packet from request into an IN endpoint
  @ep: pxa physical endpoint
  @req: usb request
  @max: max bytes that fit into endpoint
  Takes bytes from usb request, and transfers them into the physical
  endpoint. If there are no bytes to transfer, doesn't write anything
  to physical endpoint.
  Returns how many bytes were actually transferred.
  read_fifo - Transfer packets from OUT endpoint into usb request
  @ep: pxa physical endpoint
  @req: usb request
  Context: interrupt handler
  Unload as many packets as possible from the fifo we use for usb OUT
  transfers and put them into the request. Caller should have made sure
  there's at least one packet ready.
  Doesn't complete the request, that's the caller's job
  Returns 1 if the request completed, 0 otherwise
 completion 
 finished that packet.  the next one may be waiting... 
  write_fifo - transfer packets from usb request into an IN endpoint
  @ep: pxa physical endpoint
  @req: pxa usb request
  Write to an IN endpoint fifo, as many packets as possible.
  irqs will use this to write the rest later.
  caller guarantees at least one packet buffer is ready (or a zlp).
  Doesn't complete the request, that's the caller's job
  Returns 1 if request fully transferred, 0 if partial transfer
 last packet is usually short (or a zlp) 
 interruptiso maxpacket may not fill the fifo 
 requests complete when all IN data is in the FIFO 
  read_ep0_fifo - Transfer packets from control endpoint into usb request
  @ep: control endpoint
  @req: pxa usb request
  Special ep0 version of the above read_fifo. Reads as many bytes from control
  endpoint as can be read, and stores them into usb request (limited by request
  maximum length).
  Returns 0 if usb request only partially filled, 1 if fully filled
  write_ep0_fifo - Send a request to control endpoint (ep0 in)
  @ep: control endpoint
  @req: request
  Context: interrupt handler
  Sends a request (or a part of the request) to the control endpoint (ep0 in).
  If the request doesn't fit, the remaining part will be sent from irq.
  The request is considered fully written only if either :
    - last write transferred all remaining bytes, but fifo was not fully filled
    - last write was a 0 length write
  Returns 1 if request fully written, 0 if request only partially sent
 Sends either a short packet or a 0 length packet 
  pxa_ep_queue - Queue a request into an IN endpoint
  @_ep: usb endpoint
  @_req: usb request
  @gfp_flags: flags
  Context: thread context or from the interrupt handler in the
  special case of ep0 setup :
    (irq->handle_ep0_ctrl_req->gadget_setup->pxa_ep_queue)
  Returns 0 if succedeed, error otherwise
	 iso is always one packet per request, that's the only way
	  we can report per-packet status.  that also helps with dma.
  pxa_ep_dequeue - Dequeue one request
  @_ep: usb endpoint
  @_req: usb request
  Return 0 if no error, -EINVAL or -ECONNRESET otherwise
 make sure it's actually queued on this endpoint 
  pxa_ep_set_halt - Halts operations on one endpoint
  @_ep: usb endpoint
  @value:
  Returns 0 if no error, -EINVAL, -EROFS, -EAGAIN otherwise
		
		  This path (reset toggle+halt) is needed to implement
		  SET_INTERFACE on normal hardware.  but it can't be
		  done from software on the PXA UDC, and the hardware
		  forgets to do it as part of SET_INTERFACE automagic.
 FST, FEF bits are the same for control and non control endpoints 
  pxa_ep_fifo_status - Get how many bytes in physical endpoint
  @_ep: usb endpoint
  Returns number of bytes in OUT fifos. Broken for IN fifos.
  pxa_ep_fifo_flush - Flushes one endpoint
  @_ep: usb endpoint
  Discards all data in one endpoint(IN or OUT), except control endpoint.
 for OUT, just read and discard the FIFO contents. 
 most IN status is the same, but ISO can't stall 
  pxa_ep_enable - Enables usb endpoint
  @_ep: usb endpoint
  @desc: usb endpoint descriptor
  Nothing much to do here, as ep configuration is done once and for all
  before udc is enabled. After udc enable, no physical endpoint configuration
  can be changed.
  Function makes sanity checks and flushes the endpoint.
 flush fifo (mostly for OUT buffers) 
  pxa_ep_disable - Disable usb endpoint
  @_ep: usb endpoint
  Same as for pxa_ep_enable, no physical endpoint configuration can be
  changed.
  Function flushes the endpoint and related requests.
  dplus_pullup - Connect or disconnect pullup resistor to D+ pin
  @udc: udc device
  @on: 0 if disconnect pullup resistor, 1 otherwise
  Context: any
  Handle D+ pullup resistor, make the device visible to the usb bus, and
  declare it as a full speed usb device
  pxa_udc_get_frame - Returns usb frame number
  @_gadget: usb gadget
  pxa_udc_wakeup - Force udc device out of suspend
  @_gadget: usb gadget
  Returns 0 if successful, error code otherwise
 host may not have enabled remote wakeup 
  should_enable_udc - Tells if UDC should be enabled
  @udc: udc device
  Context: any
  The UDC should be enabled if :
   - the pullup resistor is connected
   - and a gadget driver is bound
   - and vbus is sensed (or no vbus sense is available)
  Returns 1 if UDC should be enabled, 0 otherwise
  should_disable_udc - Tells if UDC should be disabled
  @udc: udc device
  Context: any
  The UDC should be disabled if :
   - the pullup resistor is not connected
   - or no gadget driver is bound
   - or no vbus is sensed (when vbus sesing is available)
  Returns 1 if UDC should be disabled
  pxa_udc_pullup - Offer manual D+ pullup control
  @_gadget: usb gadget using the control
  @is_active: 0 if disconnect, else connect D+ pullup resistor
  Context: task context, might sleep
  Returns 0 if OK, -EOPNOTSUPP if udc driver doesn't handle D+ pullup
  pxa_udc_vbus_session - Called by external transceiver to enabledisable udc
  @_gadget: usb gadget
  @is_active: 0 if should disable the udc, 1 if should enable
  Enables the udc, and optionnaly activates D+ pullup resistor. Or disables the
  udc, and deactivates D+ pullup resistor.
  Returns 0
  pxa_udc_vbus_draw - Called by gadget driver after SET_CONFIGURATION completed
  @_gadget: usb gadget
  @mA: current drawn
  Context: task context, might sleep
  Called after a configuration was chosen by a USB host, to inform how much
  current can be drawn by the device from VBus line.
  Returns 0 or -EOPNOTSUPP if no transceiver is handling the udc
  pxa_udc_phy_event - Called by phy upon VBus event
  @nb: notifier block
  @action: phy action, is vbus connect or disconnect
  @data: the usb_gadget structure in pxa_udc
  Called by the USB Phy when a cable connect or disconnect is sensed.
  Returns 0
  udc_disable - disable udc device controller
  @udc: udc device
  Context: any
  Disables the udc device : disables clocks, udc interrupts, control endpoint
  interrupts.
  udc_init_data - Initialize udc device data structures
  @dev: udc device
  Initializes gadget endpoint list, endpoints locks. No action is taken
  on the hardware.
 deviceep0 records init 
 PXA endpoints init 
 USB endpoints init 
  udc_enable - Enables the udc device
  @udc: udc device
  Enables the udc device : enables clocks, udc interrupts, control endpoint
  interrupts, sets usb as UDC client and setups endpoints.
	
	  Caller must be able to sleep in order to cope with startup transients
 enable suspendresume and reset irqs 
 enable ep0 irqs 
  pxa27x_udc_start - Register gadget driver
  @g: gadget
  @driver: gadget driver
  When a driver is successfully registered, it will receive control requests
  including set_configuration(), which enables non-control requests.  Then
  usb traffic follows until a disconnect is reported.  Then a host may connect
  again, or the driver might get unbound.
  Note that the udc is not automatically enabled. Check function
  should_enable_udc().
  Returns 0 if no error, -EINVAL, -ENODEV, -EBUSY otherwise
 first hook up the driver ... 
  stop_activity - Stops udc endpoints
  @udc: udc device
  Disables all udc endpoints (even control endpoint), report disconnect to
  the gadget user.
  pxa27x_udc_stop - Unregister the gadget driver
  @g: gadget
  Returns 0 if no error, -ENODEV, -EINVAL otherwise
  handle_ep0_ctrl_req - handle control endpoint control request
  @udc: udc device
  @req: control request
	
	  In the PXA320 manual, in the section about Back-to-Back setup
	  packets, it describes this situation.  The solution is to set OPC to
	  get rid of the status packet, and then continue with the setup
	  packet. Generalize to pxa27x CPUs.
 read SETUP packet 
 Tell UDC to enter Data Stage 
  handle_ep0 - Handle control endpoint data transfers
  @udc: udc device
  @fifo_irq: 1 if triggered by fifo service type irq
  @opc_irq: 1 if triggered by output packet complete type irq
  Context : interrupt handler
  Tries to transfer all pending request data into the endpoint andor
  transfer all pending data in the endpoint into usb requests.
  Handles states of ep0 automata.
  PXA27x hardware handles several standard usb control requests without
  driver notification.  The requests fully handled by hardware are :
   SET_ADDRESS, SET_FEATURE, CLEAR_FEATURE, GET_CONFIGURATION, GET_INTERFACE,
   GET_STATUS
  The requests handled by hardware, but with irq notification are :
   SYNCH_FRAME, SET_CONFIGURATION, SET_INTERFACE
  The remaining standard requests really handled by handle_ep0 are :
   GET_DESCRIPTOR, SET_DESCRIPTOR, specific requests.
  Requests standardized outside of USB 2.0 chapter 9 are handled more
  uniformly, by gadget drivers.
  The control endpoint state machine is _not_ USB spec compliant, it's even
  hardly compliant with Intel PXA270 developers guide.
  The key points which inferred this state machine are :
    - on every setup token, bit UDCCSR0_SA is raised and held until cleared by
      software.
    - on every OUT packet received, UDCCSR0_OPC is raised and held until
      cleared by software.
    - clearing UDCCSR0_OPC always flushes ep0. If in setup stage, never do it
      before reading ep0.
      This is true only for PXA27x. This is not true anymore for PXA3xx family
      (check Back-to-Back setup packet in developers guide).
    - irq can be called on a "packet complete" event (opc_irq=1), while
      UDCCSR0_OPC is not yet raised (delta can be as big as 100ms
      from experimentation).
    - as UDCCSR0_SA can be activated while in irq handling, and clearing
      UDCCSR0_OPC would flush the setup data, we almost never clear UDCCSR0_OPC
      => we never actually read the "status stage" packet of an IN data stage
      => this is not documented in Intel documentation
    - hardware as no idea of STATUS STAGE, it only handle SETUP STAGE and DATA
      STAGE. The driver add STATUS STAGE to send last zero length packet in
      OUT_STATUS_STAGE.
    - special attention was needed for IN_STATUS_STAGE. If a packet complete
      event is detected, we terminate the status stage without ackowledging the
      packet (not to risk to loose a potential SETUP packet)
		
		  Hardware bug : beware, we cannot clear OPC, since we would
		  miss a potential OPC irq for a setup packet.
		  So, we only do ... nothing, and hope for a next irq with
		  UDCCSR0_SA set.
 GET_DESCRIPTOR 
 SET_DESCRIPTOR 
		
		  Hardware bug : beware, we cannot clear OPC, since we would
		  miss a potential PC irq for a setup packet.
		  So, we only put the ep0 into WAIT_FOR_SETUP state.
  handle_ep - Handle endpoint data tranfers
  @ep: pxa physical endpoint
  Tries to transfer all pending request data into the endpoint andor
  transfer all pending data in the endpoint into usb requests.
  Is always called from the interrupt handler. ep->lock must not be held.
  pxa27x_change_configuration - Handle SET_CONF usb request notification
  @udc: udc device
  @config: usb configuration
  Post the request to upper level.
  Don't use any pxa specific harware configuration capabilities
  pxa27x_change_interface - Handle SET_INTERF usb request notification
  @udc: udc device
  @iface: interface number
  @alt: alternate setting number
  Post the request to upper level.
  Don't use any pxa specific harware configuration capabilities
  irq_handle_data - Handle data transfer
  @irq: irq IRQ number
  @udc: dev pxa_udc device structure
  Called from irq handler, transferts data to or from endpoint to queue
  irq_udc_suspend - Handle IRQ "UDC Suspend"
  @udc: udc device
   irq_udc_resume - Handle IRQ "UDC Resume"
   @udc: udc device
  irq_udc_reconfig - Handle IRQ "UDC Change Configuration"
  @udc: udc device
  irq_udc_reset - Handle IRQ "UDC Reset"
  @udc: udc device
  pxa_udc_irq - Main irq handler
  @irq: irq number
  @_dev: udc device
  Handles all udc interrupts
 Endpoints for gadget zero 
 Endpoints for ether gadget, file storage gadget 
 Endpoints for RNDIS, serial 
		
		  All the following endpoints are only for completion.  They
		  won't never work, as multiple interfaces are really broken on
		  the pxa.
 Endpoint for CDC Ether 
  pxa_udc_probe - probes the udc device
  @pdev: platform device
  Perform basic init : allocates udc clock, creates sysfs files, requests
  irq.
 irq setup after old hardware state is cleaned up 
  pxa_udc_remove - removes the udc device driver
  @_dev: platform device
  pxa_udc_suspend - Suspend udc device
  @_dev: platform device
  @state: suspend state
  Suspends udc : saves configuration registers (UDCCR), then disables the udc
  device.
  pxa_udc_resume - Resume udc device
  @_dev: platform device
  Resumes udc : restores configuration registers (UDCCR), then enables the udc
  device.
	
	  We do not handle OTG yet.
	 
	  OTGPH bit is set when sleep mode is entered.
	  it indicates that OTG pad is retaining its state.
	  Upon exit from sleep mode and before clearing OTGPH,
	  Software must configure the USB OTG pad, UDC, and UHC
	  to the state they were in before entering sleep mode.
 work with hotplug and coldplug 
 SPDX-License-Identifier: GPL-2.0+
  NVIDIA Tegra XUSB device mode controller
  Copyright (c) 2013-2019, NVIDIA CORPORATION.  All rights reserved.
  Copyright (c) 2015, Google Inc.
 XUSB_DEV registers 
 FPCI registers 
 IPFS registers 
 limit port speed to gen 1 
 restore port speed to gen2 
 Direct link to U0 if disconnected in RESUME or U2. 
 Wait for disconnect event. 
 Make sure interrupt handler has completed before powergating. 
 PRC doesn't complete in 100ms, toggle the vbus 
	
	  To generate zero-length packet on USB bus, SW needs schedule a
	  standalone zero-length TD. According to HW's behavior, SW needs
	  to schedule TDs in different ways for different endpoint types.
	 
	  For control endpoint:
	  - Data stage TD (IOC = 1, CH = 0)
	  - Ring doorbell and wait transfer event
	  - Data stage TD for ZLP (IOC = 1, CH = 0)
	  - Ring doorbell
	 
	  For bulk and interrupt endpoints:
	  - Normal transfer TD (IOC = 0, CH = 0)
	  - Normal transfer TD for ZLP (IOC = 1, CH = 0)
	  - Ring doorbell
 Don't ring doorbell if the stream has been rejected. 
	
	  Clear out all the TRBs part of or after the cancelled request,
	  and must correct trb cycle bit to the last un-enqueued state.
 Requests will be re-queued at the start of the cancelled request. 
	
	  Retrieve the correct cycle bit state from the first trb of
	  the cancelled request.
  Determine if the given TRB is in the range [first trb, last trb] for the
  given request.
  Determine if the given TRB is in the range [EP enqueue pointer, first TRB)
  for the given endpoint and request.
 Make sure the request is actually queued to this endpoint. 
 Request hasn't been queued in the transfer ring yet. 
 Halt DMA for this endpiont. 
 Is the hardware processing the TRB at the dequeue pointer? 
		
		  Request has been partially completed or it hasn't
		  started processing yet.
 EDTLA is > 0: request has been partially completed 
			
			  Abort the pending transfer and update the dequeue
			  pointer
 Request hasn't started processing yet. 
		
		  Request has completed, but we haven't processed the
		  completion event yet.
 Resume the endpoint. 
 Select a reasonable average TRB length based on endpoint type. 
	
	  If this is the last endpoint disabled in a de-configure request,
	  switch back to address state.
 Disable the EP if it is not disabled 
	
	  No need to reload and un-halt EP0.  This will be done automatically
	  once a valid SETUP packet is received.
	
	  Transition to configured state once the first non-control
	  endpoint is enabled.
		
		  Pause all bulk endpoints when enabling an isoch endpoint
		  to ensure the isoch endpoint is allocated enough bandwidth.
 Direct link to U0. 
	
	  Doorbells may be dropped if they are sent too soon (< ~200ns)
	  after unpausing the endpoint.  Wait for 500ns just to be safe.
 Send Device Notification packet. 
 Nothing to do with SEL values 
 Nothing to do with isoch delay 
		
		  In theory we need to clear RUN bit before status stage of
		  deconfig request sent, but this seems to be causing problems.
		  Clear RUN once all endpoints are disabled instead.
 Ensure EP0 is unhalted. 
	
	  On Tegra210, setup packets with sequence numbers 0xfffe or 0xffff
	  are invalid.  Halt EP0 until we get a valid packet.
		
		  The controller is in the process of handling another
		  setup request.  Queue subsequent requests and handle
		  the last one once the controller reports a sequence
		  number error.
	
	  TDs are complete on short packet or when the completed TRB is the
	  last TRB in the TD (the CHAIN bit is unset).
		
		  Advance the dequeue pointer past the end of the current TD
		  on short packet completion.
 Update transfer ring dequeue pointer. 
			
			  An EP is stopped when a stream is rejected.  Wait
			  for the EP to report that it is stopped and then
			  un-stop it.
		
		  Wait for the EP to be stopped so the controller stops
		  processing doorbells.
		
		  Kill any queued control request and skip to the last
		  setup packet we received.
 Disconnected. 
	
	  Reset sequence number and dequeue pointer to flush the transfer
	  ring.
	
	  EP1 would be the input endpoint corresponding to EP0, but since
	  EP0 is bi-directional, EP1 is unused.
	
	  EP1 would be the input endpoint corresponding to EP0, but since
	  EP0 is bi-directional, EP1 is unused.
 Enable bus master 
 Program BAR0 space 
 Enable interrupt assertion 
 Set a reasonable U3 exit timer value. 
 Default ping LFPS tBurst is too large. 
 Default tPortConfiguration timeout is too small. 
 Set L1 resume duration to 95 us. 
	
	  Compliacne suite appears to be violating polling LFPS tBurst max
	  of 1.4us.  Send 1.45us instead.
 Direct HSFS port instance to RxDetect. 
 Direct SS port instance to RxDetect. 
 Restore port instance. 
	
	  Enable INFINITE_SS_RETRY to prevent device from entering
	  Disabled.Error when attached to buggy SuperSpeed hubs.
 Set interrupt moderation. 
 increase SSPI transaction timeout from 32us to 512us 
 Get USB2 phy 
 Get usb-phy, if utmi phy is available 
 if utmi phy is not available, ignore USB3 phy get 
 Get USB3 phy 
 Forcibly disconnect before powergating. 
 SPDX-License-Identifier: GPL-2.0+
  linuxdriversusbgadgets3c2410_udc.c
  Samsung S3C24xx series on-chip full speed USB device controllers
  Copyright (C) 2004-2007 Herbert Pötzl - Arnaud Patard
 	Additional cleanups by Ben Dooks <ben-linux@fluff.org>
 DEBUG FUNCTION 
 io macros 
------------------------- IO ----------------------------------
 	s3c2410_udc_done
 	s3c2410_udc_write_packet
 	s3c2410_udc_write_fifo
  return:  0 = still running, 1 = completed, negative = errno
 last packet is often short (sometimes a zlp) 
 Only ep0 debug messages are interesting 
		 The order is important. It prevents sending 2 packets
 Reset signal => no need to say 'data sent' 
 Reset signal => no need to say 'data sent' 
  return:  0 = still running, 1 = queue empty, negative = errno
	 checking this with ep0 is not accurate as we already
	  read a control request
 overflowed this request?  flush extra data 
 Only ep0 debug messages are interesting 
 Seems to be needed to get it working. ouch :( 
------------------------- usb state machine -------------------------------
 start control request? 
 cope with automagic for some standard requests. 
 deliver the request to the gadget driver 
 deferred io == no response yet 
	 We make the assumption that S3C2410_UDC_IN_CSR1_REG equal to
 clear stall status 
 clear setup end 
 GET_DESCRIPTOR etc 
 SET_DESCRIPTOR etc 
 	handle_ep - Manage IO endpoints
 	s3c2410_udc_irq - interrupt handler
 Driver connected ? 
 Clear interrupts 
 Save index 
 Read status registers 
	
	  Now, handle interrupts. There's two types :
	  - Reset, Resume, Suspend coming -> usb_int_reg
	  - EP -> ep_int_reg
 RESET 
		 two kind of reset :
		  - reset start -> pwr reg = 8
		  - reset end   -> pwr reg = 0
 clear interrupt 
 RESUME 
 clear interrupt 
 SUSPEND 
 clear interrupt 
 EP 
 control traffic 
	 check on ep0csr != 0 is not a good idea as clearing in_pkt_ready
	  generate an interrupt
 Clear the interrupt bit by setting it to 1 
 endpoint data transfers 
 Clear the interrupt bit by setting it to 1 
 what else causes this interrupt? a receive! who is it? 
 restore index 
 Restore old index 
------------------------- s3c2410_ep_ops ----------------------------------
 	s3c2410_udc_ep_enable
 set max packet 
 set type, direction, address; reset fifo counters 
 don't flush in fifo or it will cause endpoint interrupt 
 enable irqs 
 print some debug message 
  s3c2410_udc_ep_disable
 disable irqs 
  s3c2410_udc_alloc_request
  s3c2410_udc_free_request
 	s3c2410_udc_queue
 kickstart this io queue? 
 ep0 ) {
 pio or dma irq handler advances the queue. 
 	s3c2410_udc_dequeue
  s3c2410_udc_set_halt
------------------------- usb_gadget_ops ----------------------------------
 	s3c2410_udc_get_frame
 	s3c2410_udc_wakeup
 	s3c2410_udc_set_selfpowered
------------------------- gadget driver handling---------------------------
  s3c2410_udc_disable
 Disable all interrupts 
 Clear the interrupt registers 
 Good bye, cruel world 
 Set speed to unknown 
  s3c2410_udc_reinit
 deviceep0 records init 
  s3c2410_udc_enable
 dev->gadget.speed = USB_SPEED_UNKNOWN; 
 Set MAXP for all endpoints 
 Set default power state 
 Enable reset and suspend interrupt interrupts 
 Enable ep0 interrupt 
 time to say "hello, world" 
 Hook the driver 
 Enable udc 
 Disable udc 
---------------------------------------------------------------------------
 control endpoint 
 first group of endpoints 
 	probe - binds to the platform device
 irq setup after old hardware state is cleaned up 
 	s3c2410_udc_remove
 SPDX-License-Identifier: GPL-2.0+
  bcm63xx_udc.c -- BCM63xx UDC highfull speed USB device controller
  Copyright (C) 2012 Kevin Cernekee <cernekee@gmail.com>
  Copyright (C) 2012 Broadcom Corporation
  RX IRQ coalescing options:
  false (default) - one IRQ per DATAx packet.  Slow but reliable.  The
  driver is able to pass the "testusb" suite and recover from conditions like:
    1) Device queues up a 2048-byte RX IUDMA transaction on an OUT bulk ep
    2) Host sends 512 bytes of data
    3) Host decides to reconfigure the device and sends SET_INTERFACE
    4) Device shuts down the endpoint and cancels the RX transaction
  true - one IRQ per transfer, for transfers <= 2048B.  Generates
  considerably fewer IRQs, but error recovery is less robust.  Does not
  reliably pass "testusb".
  TX always uses coalescing, because we can cancel partially complete TX
  transfers by repeatedly flushing the FIFO.  The hardware doesn't allow
  this on RX.
  struct iudma_ch_cfg - Static configuration for an IUDMA channel.
  @ep_num: USB endpoint number.
  @n_bds: Number of buffer descriptors in the ring.
  @ep_type: Endpoint type (control, bulk, interrupt).
  @dir: Direction (in, out).
  @n_fifo_slots: Number of FIFO entries to allocate for this channel.
  @max_pkt_hs: Maximum packet size in high speed mode.
  @max_pkt_fs: Maximum packet size in full speed mode.
	 This controller was designed to support a CDCRNDIS application.
	   It may be possible to reconfigure some of the endpoints, but
	   the hardware limitations (FIFO sizing and number of DMA channels)
	   may significantly impact flexibility andor stability.  Change
	   these values at your own risk.
	      ep_num       ep_type           n_fifo_slots    max_pkt_fs
	idx      |  n_bds     |         dir       |  max_pkt_hs  |
  struct iudma_ch - Represents the current state of a single IUDMA channel.
  @ch_idx: IUDMA channel index (0 to BCM63XX_NUM_IUDMA-1).
  @ep_num: USB endpoint number.  -1 for ep0 RX.
  @enabled: Whether bcm63xx_ep_enable() has been called.
  @max_pkt: "Chunk size" on the USB interface.  Based on interface speed.
  @is_tx: true for TX, false for RX.
  @bep: Pointer to the associated endpoint.  NULL for ep0 RX.
  @udc: Reference to the device controller.
  @read_bd: Next buffer descriptor to reap from the hardware.
  @write_bd: Next BD available for a new packet.
  @end_bd: Points to the final BD in the ring.
  @n_bds_used: Number of BD entries currently occupied.
  @bd_ring: Base pointer to the BD ring.
  @bd_ring_dma: Physical (DMA) address of bd_ring.
  @n_bds: Total number of BDs in the ring.
  ep0 has two IUDMA channels (IUDMA_EP0_RXCHAN and IUDMA_EP0_TXCHAN), as it is
  bidirectional.  The "struct usb_ep" associated with ep0 is for TX (IN)
  only.
  Each bulkintr endpoint has a single IUDMA channel and a single
  struct usb_ep.
  struct bcm63xx_ep - Internal (driver) state of a single endpoint.
  @ep_num: USB endpoint number.
  @iudma: Pointer to IUDMA channel state.
  @ep: USB gadget layer representation of the EP.
  @udc: Reference to the device controller.
  @queue: Linked list of outstanding requests for this EP.
  @halted: 1 if the EP is stalled; 0 otherwise.
  struct bcm63xx_req - Internal (driver) state of a single request.
  @queue: Links back to the EP's request list.
  @req: USB gadget layer representation of the request.
  @offset: Current byte offset into the data buffer (next byte to queue).
  @bd_bytes: Number of data bytes in outstanding BD entries.
  @iudma: IUDMA channel used for the request.
 ep's requests 
  struct bcm63xx_udc - Driverhardware private context.
  @lock: Spinlock to mediate access to this struct, and (most) HW regs.
  @dev: Generic Linux device structure.
  @pd: Platform data (boardport info).
  @usbd_clk: Clock descriptor for the USB device block.
  @usbh_clk: Clock descriptor for the USB host block.
  @gadget: USB device.
  @driver: Driver for USB device.
  @usbd_regs: Base address of the USBDUSB20D block.
  @iudma_regs: Base address of the USBD's associated IUDMA block.
  @bep: Array of endpoints, including ep0.
  @iudma: Array of all IUDMA channels used by this controller.
  @cfg: USB configuration number, from SET_CONFIGURATION wValue.
  @iface: USB interface number, from SET_INTERFACE wIndex.
  @alt_iface: USB alt interface number, from SET_INTERFACE wValue.
  @ep0_ctrl_req: Request object for bcm63xx_udc-initiated ep0 transactions.
  @ep0_ctrl_buf: Data buffer for ep0_ctrl_req.
  @ep0state: Current state of the ep0 state machine.
  @ep0_wq: Workqueue struct used to wake up the ep0 state machine.
  @wedgemap: Bitmap of wedged endpoints.
  @ep0_req_reset: USB reset is pending.
  @ep0_req_set_cfg: Need to spoof a SET_CONFIGURATION packet.
  @ep0_req_set_iface: Need to spoof a SET_INTERFACE packet.
  @ep0_req_shutdown: Driver is shutting down; requesting ep0 to halt activity.
  @ep0_req_completed: ep0 request has completed; worker has not seen it yet.
  @ep0_reply: Pending reply from gadget driver.
  @ep0_request: Outstanding ep0 request.
  Convenience functions
  Low-level IUDMA  FIFO operations
  bcm63xx_ep_dma_select - Helper function to set up the init_sel signal.
  @udc: Reference to the device controller.
  @idx: Desired init_sel value.
  The "init_sel" signal is used as a selection index for both endpoints
  and IUDMA channels.  Since these do not map 1:1, the use of this signal
  depends on the context.
  bcm63xx_set_stall - Enabledisable stall on one endpoint.
  @udc: Reference to the device controller.
  @bep: Endpoint on which to operate.
  @is_stalled: true to enable stall, false to disable.
  See notes in bcm63xx_update_wedge() regarding automatic clearing of
  haltstall conditions.
  bcm63xx_fifo_setup - (Re)initialize FIFO boundaries and settings.
  @udc: Reference to the device controller.
  These parameters depend on the USB link speed.  Settings are
  per-IUDMA-channel-pair.
 set up FIFO boundaries and packet sizes; this is done in pairs 
  bcm63xx_fifo_reset_ep - Flush a single endpoint's FIFO.
  @udc: Reference to the device controller.
  @ep_num: Endpoint number.
  bcm63xx_fifo_reset - Flush all hardware FIFOs.
  @udc: Reference to the device controller.
  bcm63xx_ep_init - Initial (one-time) endpoint initialization.
  @udc: Reference to the device controller.
  bcm63xx_ep_setup - Configure per-endpoint settings.
  @udc: Reference to the device controller.
  This needs to be rerun if the speedcfgintfaltintf changes.
  iudma_write - Queue a single IUDMA transaction.
  @udc: Reference to the device controller.
  @iudma: IUDMA channel to use.
  @breq: Request containing the transaction data.
  For RX IUDMA, this will queue a single buffer descriptor, as RX IUDMA
  does not honor SOPEOP so the handling of multiple buffers is ambiguous.
  So iudma_write() may be called several times to fulfill a single
  usb_request.
  For TX IUDMA, this can queue multiple buffer descriptors if needed.
		
		  extra_zero_pkt forces one more iteration through the loop
		  after all data is queued up, to send the zero packet
  iudma_read - Check for IUDMA buffer completion.
  @udc: Reference to the device controller.
  @iudma: IUDMA channel to use.
  This checks to see if ALL of the outstanding BDs on the DMA channel
  have been filled.  If so, it returns the actual transfer length;
  otherwise it returns -EBUSY.
  iudma_reset_channel - Stop DMA on a single channel.
  @udc: Reference to the device controller.
  @iudma: IUDMA channel to reset.
 stop DMA, then wait for the hardware to wrap up 
 repeatedly flush the FIFO data until the BD completes 
 don't leave "live" HW-owned entries for the next guy to step on 
 set up IRQs, UBUS burst size, and BD base for this channel 
  iudma_init_channel - One-time IUDMA channel initialization.
  @udc: Reference to the device controller.
  @ch_idx: Channel to initialize.
 ep0 is always active; others are controlled by the gadget driver 
  iudma_init - One-time initialization of all IUDMA channels.
  @udc: Reference to the device controller.
  Enable DMA, flush channels, and enable global IUDMA IRQs.
  iudma_uninit - Uninitialize IUDMA channels.
  @udc: Reference to the device controller.
  Kill global IUDMA IRQs, flush channels, and kill DMA.
  Other low-level USBD operations
  bcm63xx_set_ctrl_irqs - Maskunmask control path interrupts.
  @udc: Reference to the device controller.
  @enable_irqs: true to enable, false to disable.
  bcm63xx_select_phy_mode - Select between USB device and host mode.
  @udc: Reference to the device controller.
  @is_device: true for device, false for host.
  This should probably be reworked to use the driversusbotg
  infrastructure.
  By default, the AFEpullups are disabled in device mode, until
  bcm63xx_select_pullup() is called.
 configure pinmux to sense VBUS signal 
  bcm63xx_select_pullup - Enabledisable the pullup on D+
  @udc: Reference to the device controller.
  @is_on: true to enable the pullup, false to disable.
  If the pullup is active, the host will sense a FSHS device connected to
  the port.  If the pullup is inactive, the host will think the USB
  device has been disconnected.
  bcm63xx_uninit_udc_hw - Shut down the hardware prior to driver removal.
  @udc: Reference to the device controller.
  This just masks the IUDMA IRQs and releases the clocks.  It is assumed
  that bcm63xx_udc_stop() has already run, and the clocks are stopped.
  bcm63xx_init_udc_hw - Initialize the controller hardware and data structures.
  @udc: Reference to the device controller.
  Standard EP gadget operations
  bcm63xx_ep_enable - Enable one endpoint.
  @ep: Endpoint to enable.
  @desc: Contains max packet, direction, etc.
  Most of the endpoint parameters are fixed in this controller, so there
  isn't much for this function to do.
  bcm63xx_ep_disable - Disable one endpoint.
  @ep: Endpoint to disable.
  bcm63xx_udc_alloc_request - Allocate a new request.
  @ep: Endpoint associated with the request.
  @mem_flags: Flags to pass to kzalloc().
  bcm63xx_udc_free_request - Free a request.
  @ep: Endpoint associated with the request.
  @req: Request to free.
  bcm63xx_udc_queue - Queue up a new request.
  @ep: Endpoint associated with the request.
  @req: Request to add.
  @mem_flags: Unused.
  If the queue is empty, start this request immediately.  Otherwise, add
  it to the list.
  ep0 replies are sent through this function from the gadget driver, but
  they are treated differently because they need to be handled by the ep0
  state machine.  (Sometimes they are replies to control requests that
  were spoofed by this driver, and so they shouldn't be transmitted at all.)
 only one reply per request, please 
  bcm63xx_udc_dequeue - Remove a pending request from the queue.
  @ep: Endpoint associated with the request.
  @req: Request to remove.
  If the request is not at the head of the queue, this is easy - just nuke
  it.  If the request is at the head of the queue, we'll need to stop the
  DMA transaction and then queue up the successor.
  bcm63xx_udc_set_halt - Enabledisable STALL flag in the hardware.
  @ep: Endpoint to halt.
  @value: Zero to clear halt; nonzero to set halt.
  See comments in bcm63xx_update_wedge().
  bcm63xx_udc_set_wedge - Stall the endpoint until the next reset.
  @ep: Endpoint to wedge.
  See comments in bcm63xx_update_wedge().
  EP0 handling
  bcm63xx_ep0_setup_callback - Drop spinlock to invoke ->setup callback.
  @udc: Reference to the device controller.
  @ctrl: 8-byte SETUP request.
  bcm63xx_ep0_spoof_set_cfg - Synthesize a SET_CONFIGURATION request.
  @udc: Reference to the device controller.
  Many standard requests are handled automatically in the hardware, but
  we still need to pass them to the gadget driver so that it can
  reconfigure the interfacesendpoints if necessary.
  Unfortunately we are not able to send a STALL response if the host
  requests an invalid configuration.  If this happens, we'll have to be
  content with printing a warning.
  bcm63xx_ep0_spoof_set_iface - Synthesize a SET_INTERFACE request.
  @udc: Reference to the device controller.
  bcm63xx_ep0_map_write - dma_map and iudma_write a single request.
  @udc: Reference to the device controller.
  @ch_idx: IUDMA channel number.
  @req: USB gadget layer representation of the request.
  bcm63xx_ep0_complete - Set completion status and "stage" the callback.
  @udc: Reference to the device controller.
  @req: USB gadget layer representation of the request.
  @status: Status to return to the gadget driver.
  bcm63xx_ep0_nuke_reply - Abort request from the gadget driver due to
    resetshutdown.
  @udc: Reference to the device controller.
  @is_tx: Nonzero for TX (IN), zero for RX (OUT).
  bcm63xx_ep0_read_complete - Close out the pending ep0 request; return
    transfer len.
  @udc: Reference to the device controller.
  bcm63xx_ep0_internal_request - Helper function to submit an ep0 request.
  @udc: Reference to the device controller.
  @ch_idx: IUDMA channel number.
  @length: Number of bytes to TXRX.
  Used for simple transfers performed by the ep0 worker.  This will always
  use ep0_ctrl_req  ep0_ctrl_buf.
  bcm63xx_ep0_do_setup - Parse new SETUP packet and decide how to handle it.
  @udc: Reference to the device controller.
  EP0_IDLE probably shouldn't ever happen.  EP0_REQUEUE means we're ready
  for the next packet.  Anything else means the transaction requires multiple
  stages of handling.
	
	  Handle 0-byte IN STATUS acknowledgement.  The hardware doesn't
	  ALWAYS deliver these 100% of the time, so if we happen to see one,
	  just throw it away.
 Drop malformed SETUP packets 
 Process new SETUP packet arriving on ep0 
  bcm63xx_ep0_do_idle - Check for outstanding requests if ep0 is idle.
  @udc: Reference to the device controller.
  In state EP0_IDLE, the RX descriptor is either pending, or has been
  filled with a SETUP packet from the host.  This function handles new
  SETUP packets, control IRQ events (which can generate fake SETUP packets),
  and resetshutdown events.
  Returns 0 if work was done; -EAGAIN if nothing to do.
 bcm63xx_udc_pullup() is waiting for this 
		
		  This could happen if a USB RESET shows up during an ep0
		  transaction (especially if a laggy driver like gadgetfs
		  is in use).
  bcm63xx_ep0_one_round - Handle the current ep0 state.
  @udc: Reference to the device controller.
  Returns 0 if work was done; -EAGAIN if nothing to do.
 set up descriptor to receive SETUP packet 
		
		  Normal case: TX request is in ep0_reply (queued by the
		  callback), or will be queued shortly.  When it's here,
		  send it to the HW and go to EP0_IN_DATA_PHASE_COMPLETE.
		 
		  Shutdown case: Stop waiting for the reply.  Just
		  REQUEUE->IDLE.  The gadget driver is NOT expected to
		  queue anything else now.
		
		  Normal case: TX packet (ep0_reply) is in flight; wait for
		  it to finish, then go back to REQUEUE->IDLE.
		 
		  Shutdown case: Reset the TX channel, send -ESHUTDOWN
		  completion to the gadget driver, then REQUEUE->IDLE.
			
			  the "ack" sometimes gets eaten (see
			  bcm63xx_ep0_do_idle)
 Similar behavior to EP0_IN_DATA_PHASE_SETUP 
 Similar behavior to EP0_IN_DATA_PHASE_COMPLETE 
 send 0-byte ack to host 
		
		  Normal case: 0-byte OUT ack packet is in flight; wait
		  for it to finish, then go back to REQUEUE->IDLE.
		 
		  Shutdown case: just cancel the transmission.  Don't bother
		  calling the completion, because it originated from this
		  function anyway.  Then go back to REQUEUE->IDLE.
		
		  Normal case: we spoofed a SETUP packet and are now
		  waiting for the gadget driver to send a 0-byte reply.
		  This doesn't actually get sent to the HW because the
		  HW has already sent its own reply.  Once we get the
		  response, return to IDLE.
		 
		  Shutdown case: return to IDLE immediately.
		 
		  Note that the ep0 RX descriptor has remained queued
		  (and possibly unfilled) during this entire transaction.
		  The HW datapath (IUDMA) never even sees SET_CONFIGURATION
		  or SET_INTERFACE transactions.
  bcm63xx_ep0_process - ep0 worker thread  state machine.
  @w: Workqueue struct.
  bcm63xx_ep0_process is triggered any time an event occurs on ep0.  It
  is used to synchronize ep0 events and ensure that both HW and SW events
  occur in a well-defined order.  When the ep0 IUDMA queues are idle, it may
  synthesize SET_CONFIGURATION  SET_INTERFACE requests that were consumed
  by the USBD hardware.
  The worker function will continue iterating around the state machine
  until there is nothing left to do.  Usually "nothing left to do" means
  that we're waiting for a new event from the hardware.
  Standard UDC gadget operations
  bcm63xx_udc_get_frame - Read current SOF frame number from the HW.
  @gadget: USB device.
  bcm63xx_udc_pullup - Enabledisable pullup on D+ line.
  @gadget: USB device.
  @is_on: 0 to disable pullup, 1 to enable.
  See notes in bcm63xx_select_pullup().
  bcm63xx_udc_start - Start the controller.
  @gadget: USB device.
  @driver: Driver for USB device.
  bcm63xx_udc_stop - Shut down the controller.
  @gadget: USB device.
  @driver: Driver for USB device.
	
	  If we switch the PHY too abruptly after dropping D+, the host
	  will often complain:
	 
	      hub 1-0:1.0: port 1 disabled by hub (EMI?), re-enabling...
  IRQ handling
  bcm63xx_update_cfg_iface - Read current configurationinterface settings.
  @udc: Reference to the device controller.
  This controller intercepts SET_CONFIGURATION and SET_INTERFACE messages.
  The driver never sees the raw control packets coming in on the ep0
  IUDMA channel, but at least we get an interrupt event to tell us that
  new values are waiting in the USBD_STATUS register.
  bcm63xx_update_link_speed - Check to see if the link speed has changed.
  @udc: Reference to the device controller.
  The link speed update coincides with a SETUP IRQ.  Returns 1 if the
  speed has changed, so that the caller can update the endpoint settings.
 this should never happen 
  bcm63xx_update_wedge - Iterate through wedged endpoints.
  @udc: Reference to the device controller.
  @new_status: true to "refresh" wedge status; false to clear it.
  On a SETUP interrupt, we need to manually "refresh" the wedge status
  because the controller hardware is designed to automatically clear
  stalls in response to a CLEAR_FEATURE request from the host.
  On a RESET interrupt, we do want to restore all wedged endpoints.
  bcm63xx_udc_ctrl_isr - ISR for control path events (USBD).
  @irq: IRQ number (unused).
  @dev_id: Reference to the device controller.
  This is where we handle link (VBUS) down, USB reset, speed changes,
  SET_CONFIGURATION, and SET_INTERFACE events.
 VBUS toggled 
  bcm63xx_udc_data_isr - ISR for data path events (IUDMA).
  @irq: IRQ number (unused).
  @dev_id: Reference to the IUDMA channel that generated the interrupt.
  For the two ep0 channels, we have special handling that triggers the
  ep0 worker thread.  For normal bulkintr channels, either queue up
  the next buffer descriptor for the transaction (incomplete transaction),
  or invoke the completion callback (complete transactions).
 special handling for EP0 RX (0) and TX (1) 
 a single request could require multiple submissions 
 "actual" on a ZLP is 1 byte 
 queue up the next BD (same request) 
  Debug filesystem
  bcm63xx_usbd_dbg_show - Show USBD controller state.
  @s: seq_file to which the information will be written.
  @p: Unused.
  This file nominally shows up as syskerneldebugbcm63xx_udcusbd
  bcm63xx_iudma_dbg_show - Show IUDMA status and descriptors.
  @s: seq_file to which the information will be written.
  @p: Unused.
  This file nominally shows up as syskerneldebugbcm63xx_udciudma
  bcm63xx_udc_init_debugfs - Create debugfs entries.
  @udc: Reference to the device controller.
  bcm63xx_udc_cleanup_debugfs - Remove debugfs entries.
  @udc: Reference to the device controller.
  debugfs_remove() is safe to call with a NULL argument.
  Driver initexit
  bcm63xx_udc_probe - Initialize a new instance of the UDC.
  @pdev: Platform device struct from the bcm63xx BSP code.
  Note that platform data is required, because pd.port_no varies from chip
  to chip and is used to switch the correct USB port to device mode.
 request clocks, allocate buffers, and clear any pending IRQs 
 IRQ resource #0: control interrupt (VBUS, speed, etc.) 
 IRQ resources #1-6: data interrupts for IUDMA channels 0-5 
  bcm63xx_udc_remove - Remove the device from the system.
  @pdev: Platform device struct from the bcm63xx BSP code.
 SPDX-License-Identifier: GPL-2.0
  Driver for the Atmel USBA high speed USB device controller
  Copyright (C) 2005-2007 Atmel Corporation
  bbbbbbbb llllllll IZS sssss nnnn FDL\n\0
  b: buffer address
  l: buffer length
  Ii: interruptno interrupt
  Zz: zerono zero
  Ss: short okshort not ok
  s: status
  n: nr_packets
  Ff: submittednot submitted to FIFO
  Dd: usingnot using DMA
  Ll: last transactionnot last transaction
 mode 0 - uses autoconfig 
 mode 1 - fits in 8KB, generic max fifo configuration 
 mode 2 - fits in 8KB, performance max fifo configuration 
 mode 3 - fits in 8KB, mixed fifo configuration 
 mode 4 - fits in 8KB, custom fifo configuration 
 Add additional configurations here 
 No Vbus detection: Assume always present 
		
		  Bits 11:12 specify number of _additional_
		  transactions per microframe.
 Lengths from 0 to 65536 (inclusive) are supported 
	
	  Add this request to the queue and submit for DMA if
	  possible. Check if we're still alive first -- we may have
	  received a reset since last time we checked.
 May have received a reset since last time we checked 
	
	  Stop the DMA controller. When writing both CH_EN
	  and LINK to 0, the other bits are not affected.
 Wait for the FIFO to empty 
		
		  If this request is currently being transferred,
		  stop the DMA controller and reset the FIFO.
	
	  Errors should stop the queue from advancing until the
	  completion function returns.
 Process the next request if any 
	
	  We can't halt IN endpoints while there are still data to be
	  transferred
 Look at endpoints until an unclaimed one looks usable 
 Fail 
 Optimize hw fifo size based on ep type and other info 
 It might be a little bit late to set this 
 Generate ept_cfg basd on FIFO size and number of banks 
 LSB is bit 1, not 0 
 FIXME: I have no idea what to put here 
  Called with interrupts disabled and udc->lock held.
 Called with interrupts disabled and udc->lock held 
 JKJKJKJK  9 
 JJKKJJKK  8 
 JJKKJJKK  8 
 JJJJJJJKKKKKKK  8 
 JJJJJJJK  8 
 {JKKKKKKK  10}, JK 
 Start from a clean slate 
 Test_J 
 Test_K 
		
		  Test_SE0_NAK: Force high-speed mode and set up ep0
		  for Bulk IN transfers
 Test_Packet 
 Avoid overly long expressions 
 Write directly to the FIFO. No queueing is done. 
 Can't CLEAR_FEATURE TEST_MODE 
 Activate our new address 
			
			  Didn't expect a SETUP packet at this
			  point. Clean up any pending requests (which
			  may be successful).
			
			  RXRDY and TXCOMP are dropped when SETUP
			  packets arrive.  Just pretend we received
			  the status packet.
		 Free up one bank in the FIFO so that we can
		 printk(KERN_DEBUG "setup: %d: %02x.%02x\n",
			ep->state, crq.crq.bRequestType,
			
			  The USB 2.0 spec states that "if wLength is
			  zero, there is no data transfer phase."
			  However, testusb #14 seems to actually
			  expect a data phase even if wLength = 0...
 Let the host know that we failed 
 Send a zero-length packet 
		
		  try to pretend nothing happened. We might have to
		  do something here...
 Might happen if a reset comes along at the right moment 
 If we get reset while suspended... 
		
		  Unclear why we hit this irregularly, e.g. in usbtest,
		  but it's clearly harmless...
 Preallocate other endpoints 
 Clear all requested and pending interrupts... 
 ...and enable just 'reset' IRQ to get us started 
 This will also disable the DP pullup 
 debounce 
 If Vbus is present, enable the controller and wait for reset 
 ep 0 
 ep 1 
 ep 2 
 ep 3 
 ep 4 
 ep 5 
 ep 6 
 ep 0 
 ep 1 
 ep 2 
 ep 3 
 ep 4 
 ep 5 
 ep 6 
 ep 7 
 ep 8 
 ep 9 
 ep 10 
 ep 11 
 ep 12 
 ep 13 
 ep 14 
 ep 15 
 sentinel  }
 sentinel  }
 Only the first EP is 64 bytes 
			
			  Generate ept_cfg based on FIFO size and
			  banks number
 LSB is bit 1, not 0 
 Make sure we start from a clean slate 
 Not started 
	
	  Device may wake up. We stay clocked if we failed
	  to request vbus irq, assuming always on.
 FIXME: right to stop here...??? 
 Not started 
 If Vbus is present, enable the controller and wait for reset 
 SPDX-License-Identifier: GPL-2.0+
  dummy_hcd.c -- DummyLoopback USB host and device emulator driver.
  Maintainer: Alan Stern <stern@rowland.harvard.edu>
  Copyright (C) 2003 David Brownell
  Copyright (C) 2003-2005 Alan Stern
  This exposes a device side "USB gadget" API, driven by requests to a
  Linux-USB host controller driver.  USB traffic is simulated; there's
  no need for USB hardware.  Use this with two other drivers:
   - Gadget driver, responding to requests (device);
   - Host-side device driver, as already familiar in Linux.
  Having this all in one kernel can help some stages of development,
  bypassing some hardware (and driver) issues.  UML could help too.
  Note: The emulation does not include isochronous transfers!
 in mA; use 8 for low-power port testing 
 in mA 
-------------------------------------------------------------------------
 gadget side driver data structres 
 jiffies timestamp 
 ep's requests 
-------------------------------------------------------------------------
  Every device has ep0 for control requests, plus up to 30 more endpoints,
  in one of two types:
    - Configurable:  direction (inout), type (bulk, iso, etc), and endpoint
      number can be changed.  Names like "ep-a" are used for this type.
    - Fixed Function:  in other cases.  some characteristics may be mutable;
      that'd be hardware-specific.  Names like "ep12out-bulk" are used.
  Gadget drivers are responsible for not setting up conflicting endpoint
  configurations, illegal or unsupported packet lengths, and so on.
 we don't provide isochronous endpoints since we don't support them 
 everyone has ep0 
 act like a pxa250: fifteen fixed function endpoints 
	EP_INFO("ep3in-iso",
		USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO, USB_EP_CAPS_DIR_IN)),
	EP_INFO("ep4out-iso",
		USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO, USB_EP_CAPS_DIR_OUT)),
	EP_INFO("ep8in-iso",
		USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO, USB_EP_CAPS_DIR_IN)),
	EP_INFO("ep9out-iso",
		USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO, USB_EP_CAPS_DIR_OUT)),
	EP_INFO("ep13in-iso",
		USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO, USB_EP_CAPS_DIR_IN)),
	EP_INFO("ep14out-iso",
		USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO, USB_EP_CAPS_DIR_OUT)),
 or like sa1100: two fixed function endpoints 
 and now some generic EPs so we have enough in multi config 
-------------------------------------------------------------------------
	
	  DEVICEGADGET side support
	
	  HOST side support
-------------------------------------------------------------------------
 DEVICEGADGET SIDE UTILITY ROUTINES 
 called with spinlock held 
 caller must hold lock 
 prevent any more requests 
 The timer is left running so that outstanding URBs can fail 
 nuke any pending requests first, so driver io is quiesced 
 driver now does any non-usb quiescing necessary 
  set_link_state_by_speed() - Sets the current state of the link according to
 	the hcd speed
  @dum_hcd: pointer to the dummy_hcd structure to update the link state for
  This function updates the port_status according to the link state and the
  speed of the hcd.
 UDC suspend must cause a disconnect 
 device is connected and not suspended 
 UDC suspend must cause a disconnect 
 caller must hold lock 
 Currently !connected or in reset 
 Report reset and disconnect events to the driver 
-------------------------------------------------------------------------
 DEVICEGADGET SIDE DRIVER
  This only tracks gadget state.  All the work is done when the host
  side tries some (emulated) io operation.  Real device controller
  drivers would do real io using dma, fifos, irqs, timers, etc.
	
	  For HSFS devices only bits 0..10 of the wMaxPacketSize represent the
	  maximum packet size.
	  For SS devices the wMaxPacketSize is limited by 1024.
	 drivers must not request bad settings, since lower levels
	  (hardware or its drivers) may not check.  some endpoints
	  can't do iso, many have maxpacket limitations, etc.
	 
	  since this "hardware" driver is here to help debugging, we
	  have some extra sanity checks.  (there could be more though,
	  especially for "ep9out" style fixed function ones.)
 we'll fake any legal size 
 save a return statement 
 bulk is ok 
 real hardware might not handle all packet sizes 
 save a return statement 
 save a return statement 
 real hardware might not handle all packet sizes 
 save a return statement 
 save a return statement 
 few chips support control except on ep0 
	 at this point real hardware should be NAKing transfers
	  to that endpoint, until a buffer is queued to it.
 implement an emulated single-request FIFO 
	 real hardware would likely enable transfers here, in case
	  it'd been left NAKing.
 FIXME clear emulated data toggle too 
-------------------------------------------------------------------------
 there are both host and device side versions of this call ... 
 FIXME: What if the root hub is suspended but the port isn't? 
 hub notices our request, issues downstream resume, etc 
		
		  Emulate synchronize_irq(): wait for callbacks to finish.
		  This seems to be the best place to emulate the call to
		  synchronize_irq() that's in usb_gadget_remove_driver().
		  Doing it in dummy_udc_stop() would be too late since it
		  is called after the unbind callback and unbind shouldn't
		  be invoked until all the other callbacks are finished.
-------------------------------------------------------------------------
 "function" sysfs attribute 
-------------------------------------------------------------------------
  Driver registrationunregistration.
  This is basically hardware-specific; there's usually only one real USB
  device (not host) controller since that's how USB devices are intended
  to work.  So most implementations of these api calls will rely on the
  fact that only one driver will ever bind to the hardware.  But curious
  hardware can be built with discrete components, so the gadget API doesn't
  require that assumption.
  For this emulator, it might be convenient to create a usb device
  for each driver that registers:  just add to a big root hub.
 All the speeds we support 
	
	  DEVICE side init ... the layer above hardware, which
	  can't enumerate without help from the driver we're binding.
 The gadget structure is stored inside the hcd structure and will be
 Clear usb_gadget region for new registration to udc-core 
-------------------------------------------------------------------------
 HOST SIDE DRIVER
  this uses the hcd framework to hook up to host side drivers.
  its root hub will only have one device, otherwise it acts like
  a normal host controller.
  when urbs are queued, they're just stuck on a list that we
  scan in a timer callback.  that callback connects writes from
  the host with reads from the device, and so on, based on the
  usb 2.0 rules.
  The max stream number is saved as a nibble so for the 30 possible endpoints
  we only 15 bytes of memory. Therefore we are limited to max 16 streams (0
  means we use only 1 stream). The maximum according to the spec is 16bit so
  if the 16 stream limit is about to go, the array size should be incremented
  to 30 elements of type u16.
 mark as a new urb 
 kick the scheduler, it'll do the rest 
	 giveback happens automatically in timer callback,
 transfer up to a frame's worth; caller must own lock 
 if there's no request queued, the device is NAKing; return 
		 1..N packets of ep->ep.maxpacket each ... the last one
		  may be short (including zero length).
		 
		  writer can send a zlp explicitly (length 0) or implicitly
		  (length mod maxpacket zero, and 'zero' flag); they always
		  terminate reads.
 FIXME update emulated data toggle too 
 not enough bandwidth left? 
 send multiple of maxpacket first, then remainder 
		 short packets terminate, maybe with overflowunderflow.
		  it's only really an error to write too much.
		 
		  partially filling a buffer optionally blocks queue advances
		  (so completion handlers can clean up the queue) but we don't
		  need to emulate such data-in-flight.
		
		  many requests terminate without a short packet.
		  send a zlp if demanded by flags.
 device side completion --> continuable 
 requests might have been unlinked... 
 host side completion --> terminate 
 rescan to continue with any other queued io 
 high bandwidth mode 
 applies to entire frame ;
 Sec. 4.4.8.2 USB3.0 Spec 
 Sec. 4.4.7.2 USB3.0 Spec 
  handle_control_request() - handles all control transfers
  @dum_hcd: pointer to dummy (the_controller)
  @urb: the urb request to handle
  @setup: pointer to the setup data for a USB device control
 	 request
  @status: pointer to request handling status
  Return 0 - if the request was handled
 	  1 - if the request wasn't handles
 	  error code on error
 endpoint halt 
 endpoint halt 
			
			  device: remote wakeup, selfpowered
			  interface: nothing
			  endpoint: halt
  Drive both sides of the transfers; looks like irq handlers to both
  drivers except that the callbacks are invoked from soft interrupt
  context.
 simplistic model for one frame's bandwidth 
 FIXME: account for transaction and packet overhead 
bytes  12
bytes  19
bytes  13uframes;
 Bus speed is 500000 bytesms, so use a little less 
 Can't happen 
 FIXME if HZ != 1000 this will probably misbehave ... 
 look at each urb queued by the host side driver 
 stop when we reach URBs queued after the timer interrupt 
 Used up this frame's bandwidth? 
 find the gadget's ep for this request (if configured) 
 set_configuration() disagreement 
 a new urb 
 NOTE: must not be iso! 
 FIXME make sure both ends agree on maxpacket 
 handle control requests 
 paranoia, in case of stale queued data 
			 gadget driver never sees set_address or operations
			  on standard feature flags.  some hardware doesn't
			  even expose them.
			 gadget driver handles all other requests.  block
			  until setup() returns; no reentrancy issues etc.
 no delays (max 64KB data stage) 
 error, see below 
 non-control requests 
			
			  We don't support isochronous.  But if we did,
			  here are some of the issues we'd have to face:
			 
			  Is it urb->interval since the last xfer?
			  Use urb->iso_frame_desc[i].
			  Complete whether or not ep has requests queued.
			  Report random errors, to debug drivers.
 fail all xfers 
			 FIXME is it urb->interval since the last xfer?
			  this almost certainly polls too fast.
 incomplete transfer? 
 want a 1 msec delay here 
-------------------------------------------------------------------------
 usb 3.0 root hub device descriptor 
 Worst case: 0.4 micro sec
 PortPwrCtrlMask 
 20msec resume signaling 
 Not allowed for USB-3 
 Disallow INDICATOR and C_OVER_CURRENT 
		 whoever resets or resumes must GetPortStatus to
		  complete it!!
			
			  Since this is dummy we don't have an actual link so
			  there is nothing to do for the SET_LINK_STATE cmd
 TODO: add suspendresume support! 
 Applicable only for USB2.0 hub 
				 HNP would happen here; for now we
				  assume b_bus_req is always true.
 Applicable only for USB3.0 hub 
 if it's already enabled, disable 
			
			  We want to reset device status. All but the
			  Self powered feature
			
			  FIXME USB3.0: what is the correct reset signaling
			  interval? Is it still 50msec as for HS?
 Not allowed for USB-3, and ignored for USB-2 
 Disallow TEST, INDICATOR, and C_OVER_CURRENT 
 We'll always return 0 since this is a dummy hub 
 "protocol stall" on error 
-------------------------------------------------------------------------
 FIXME 'urbs' should be a per-device thing, maybe in usbcore 
	
	  HOST side init ... we emulate a root hub that'll only ever
	  talk to one device (the gadget side).  Also appears in sysfs,
	  just like more familiar pci-based HCDs.
 FIXME 'urbs' should be a per-device thing, maybe in usbcore 
-------------------------------------------------------------------------
		
		  Mark the first roothub as being USB 2.0.
		  The USB 3.0 roothub will be registered later by
		  dummy_hcd_probe()
 Change a group of bulk endpoints to support multiple stream IDs 
 Reverts a group of bulk endpoints back to not using stream IDs. 
-------------------------------------------------------------------------
			
			  The hcd was added successfully but its probe
			  function failed for some reason.
			
			  The udc was added successfully but its probe
			  function failed for some reason.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2011 LAPIS Semiconductor Co., Ltd.
 VBUS polling period (msec) 
 VBUS polling interval (msec) 
 Address offset of Registers 
 Offset to next EP 
 Endpoint control 
 Endpoint status 
 buffer size in  frame number out 
 buffer size out  maxpkt in 
 setup buffer pointer 
 Data descriptor pointer 
 WriteRead confirmation 
 Device configuration 
 Device control 
 Device status 
 Device irq status 
 Device irq mask 
 Endpoint irq status 
 Endpoint irq mask 
 LPM control  status 
 UDC_CSR_BUSY Status register 
 SOFT RESET register 
 USB_DEVICE endpoint register 
 Endpoint control register 
 Bit position 
 Mask patern 
 Value for ET field 
 Endpoint status register 
 Bit position 
 Mask patern 
 Value for OUT field 
 Device configuration register 
 Bit position 
 SPD Valee 
 Device control register 
 Bit position 
 Device status register 
 Bit position 
 Mask patern 
 value for maximum speed for SPEED field 
 Device irq register 
 Bit position 
 Mask patern 
 Endpoint irq register 
 Bit position 
 Mask patern 
 UDC_CSR_BUSY Status register 
 Bit position 
 SOFT RESET register 
 Bit position 
 USB_DEVICE endpoint register 
 Bit position 
 Mask patern 
 Index of endpoint 
 Number of endpoint 
 Total number of EPs (16 IN,16 OUT) 
 EP number of EP's really used 
 Length Value 
 Burst length 
 Threshold length 
 Value of EP Buffer Size 
 Value of EP maximum packet size 
 DMA 
 DMA for data receive 
 DMA for data transmit 
 maximum packet size for DMA 
  struct pch_udc_data_dma_desc - Structure to hold DMA descriptor information
 				  for data
  @status:		Status quadlet
  @reserved:		Reserved
  @dataptr:		Buffer descriptor
  @next:		Next descriptor
  struct pch_udc_stp_dma_desc - Structure to hold DMA descriptor information
 				 for control data
  @status:	Status
  @reserved:	Reserved
  @request:	Control Request
 DMA status definitions 
 Buffer status 
  RxTx Status 
 Last Descriptor Indication 
 Number of RxTx Bytes Mask 
  struct pch_udc_cfg_data - Structure to hold current configuration
 			     and interface information
  @cur_cfg:	current configuration in use
  @cur_intf:	current interface in use
  @cur_alt:	current alt interface in use
  struct pch_udc_ep - Structure holding a PCH USB device Endpoint information
  @ep:			embedded ep request
  @td_stp_phys:	for setup request
  @td_data_phys:	for data request
  @td_stp:		for setup request
  @td_data:		for data request
  @dev:		reference to device struct
  @offset_addr:	offset address of ep register
  @desc:		for this ep
  @queue:		queue for requests
  @num:		endpoint number
  @in:			endpoint is IN
  @halted:		endpoint halted?
  @epsts:		Endpoint status
  struct pch_vbus_gpio_data - Structure holding GPIO informaton
 					for detecting VBUS
  @port:		gpio descriptor for the VBUS GPIO
  @intr:		gpio interrupt number
  @irq_work_fall:	Structure for WorkQueue
  @irq_work_rise:	Structure for WorkQueue
  struct pch_udc_dev - Structure holding complete information
 			of the PCH USB device
  @gadget:		gadget driver data
  @driver:		reference to gadget driver bound
  @pdev:		reference to the PCI device
  @ep:			array of endpoints
  @lock:		protects all state
  @stall:		stall requested
  @prot_stall:		protcol stall requested
  @registered:		driver registered with system
  @suspended:		driver in suspended state
  @connected:		gadget driver associated
  @vbus_session:	required vbus_session state
  @set_cfg_not_acked:	pending acknowledgement 4 setup
  @waiting_zlp_ack:	pending acknowledgement 4 ZLP
  @data_requests:	DMA pool for data requests
  @stp_requests:	DMA pool for setup requests
  @dma_addr:		DMA pool for received
  @setup_data:		Received setup data
  @base_addr:		for mapped device memory
  @bar:		PCI BAR used for mapped device memory
  @cfg_data:		current cfg, intf, and alt in use
  @vbus_gpio:		GPIO informaton for detecting VBUS
 protects all state 
 stall spin lock 
  struct pch_udc_request - Structure holding a PCH USB device request packet
  @req:		embedded ep request
  @td_data_phys:	phys. address
  @td_data:		first dma desc. of chain
  @td_data_last:	last dma desc. of chain
  @queue:		associated queue
  @dma_going:		DMA in progress for request
  @dma_done:		DMA completed for request
  @chain_len:		chain length
  pch_udc_csr_busy() - Wait till idle.
  @dev:	Reference to pch_udc_dev structure
 Wait till idle 
  pch_udc_write_csr() - Write the command and status registers.
  @dev:	Reference to pch_udc_dev structure
  @val:	value to be written to CSR register
  @ep:		end-point number
 Wait till idle 
 Wait till idle 
  pch_udc_read_csr() - Read the command and status registers.
  @dev:	Reference to pch_udc_dev structure
  @ep:		end-point number
  Return codes:	content of CSR register
 Wait till idle 
 Dummy read 
 Wait till idle 
  pch_udc_rmt_wakeup() - Initiate for remote wakeup
  @dev:	Reference to pch_udc_dev structure
  pch_udc_get_frame() - Get the current frame from device status register
  @dev:	Reference to pch_udc_dev structure
  Retern	current frame
  pch_udc_clear_selfpowered() - Clear the self power control
  @dev:	Reference to pch_udc_regs structure
  pch_udc_set_selfpowered() - Set the self power control
  @dev:	Reference to pch_udc_regs structure
  pch_udc_set_disconnect() - Set the disconnect status.
  @dev:	Reference to pch_udc_regs structure
  pch_udc_clear_disconnect() - Clear the disconnect status.
  @dev:	Reference to pch_udc_regs structure
 Clear the disconnect 
 Resume USB signalling 
  pch_udc_reconnect() - This API initializes usb device controller,
 						and clear the disconnect status.
  @dev:		Reference to pch_udc_regs structure
 enable device interrupts 
 pch_udc_enable_interrupts() 
 Clear the disconnect 
 Resume USB signalling 
  pch_udc_vbus_session() - set or clearr the disconnect status.
  @dev:	Reference to pch_udc_regs structure
  @is_active:	Parameter specifying the action
 		  0:   indicating VBUS power is ending
 		  !0:  indicating VBUS power is starting
  pch_udc_ep_set_stall() - Set the stall of endpoint
  @ep:		Reference to structure of type pch_udc_ep_regs
  pch_udc_ep_clear_stall() - Clear the stall of endpoint
  @ep:		Reference to structure of type pch_udc_ep_regs
 Clear the stall 
 Clear NAK by writing CNAK 
  pch_udc_ep_set_trfr_type() - Set the transfer type of endpoint
  @ep:		Reference to structure of type pch_udc_ep_regs
  @type:	Type of endpoint
  pch_udc_ep_set_bufsz() - Set the maximum packet size for the endpoint
  @ep:		Reference to structure of type pch_udc_ep_regs
  @buf_size:	The buffer word size
  @ep_in:	EP is IN
  pch_udc_ep_set_maxpkt() - Set the Max packet size for the endpoint
  @ep:		Reference to structure of type pch_udc_ep_regs
  @pkt_size:	The packet byte size
  pch_udc_ep_set_subptr() - Set the Setup buffer pointer for the endpoint
  @ep:		Reference to structure of type pch_udc_ep_regs
  @addr:	Address of the register
  pch_udc_ep_set_ddptr() - Set the Data descriptor pointer for the endpoint
  @ep:		Reference to structure of type pch_udc_ep_regs
  @addr:	Address of the register
  pch_udc_ep_set_pd() - Set the poll demand bit for the endpoint
  @ep:		Reference to structure of type pch_udc_ep_regs
  pch_udc_ep_set_rrdy() - Set the receive ready bit for the endpoint
  @ep:		Reference to structure of type pch_udc_ep_regs
  pch_udc_ep_clear_rrdy() - Clear the receive ready bit for the endpoint
  @ep:		Reference to structure of type pch_udc_ep_regs
  pch_udc_set_dma() - Set the 'TDE' or RDE bit of device control
 			register depending on the direction specified
  @dev:	Reference to structure of type pch_udc_regs
  @dir:	whether Tx or Rx
 		  DMA_DIR_RX: Receive
 		  DMA_DIR_TX: Transmit
  pch_udc_clear_dma() - Clear the 'TDE' or RDE bit of device control
 				 register depending on the direction specified
  @dev:	Reference to structure of type pch_udc_regs
  @dir:	Whether Tx or Rx
 		  DMA_DIR_RX: Receive
 		  DMA_DIR_TX: Transmit
  pch_udc_set_csr_done() - Set the device control register
 				CSR done field (bit 13)
  @dev:	reference to structure of type pch_udc_regs
  pch_udc_disable_interrupts() - Disables the specified interrupts
  @dev:	Reference to structure of type pch_udc_regs
  @mask:	Mask to disable interrupts
  pch_udc_enable_interrupts() - Enable the specified interrupts
  @dev:	Reference to structure of type pch_udc_regs
  @mask:	Mask to enable interrupts
  pch_udc_disable_ep_interrupts() - Disable endpoint interrupts
  @dev:	Reference to structure of type pch_udc_regs
  @mask:	Mask to disable interrupts
  pch_udc_enable_ep_interrupts() - Enable endpoint interrupts
  @dev:	Reference to structure of type pch_udc_regs
  @mask:	Mask to enable interrupts
  pch_udc_read_device_interrupts() - Read the device interrupts
  @dev:	Reference to structure of type pch_udc_regs
  Retern	The device interrupts
  pch_udc_write_device_interrupts() - Write device interrupts
  @dev:	Reference to structure of type pch_udc_regs
  @val:	The value to be written to interrupt register
  pch_udc_read_ep_interrupts() - Read the endpoint interrupts
  @dev:	Reference to structure of type pch_udc_regs
  Retern	The endpoint interrupt
  pch_udc_write_ep_interrupts() - Clear endpoint interupts
  @dev:	Reference to structure of type pch_udc_regs
  @val:	The value to be written to interrupt register
  pch_udc_read_device_status() - Read the device status
  @dev:	Reference to structure of type pch_udc_regs
  Retern	The device status
  pch_udc_read_ep_control() - Read the endpoint control
  @ep:		Reference to structure of type pch_udc_ep_regs
  Retern	The endpoint control register value
  pch_udc_clear_ep_control() - Clear the endpoint control register
  @ep:		Reference to structure of type pch_udc_ep_regs
  Retern	The endpoint control register value
  pch_udc_read_ep_status() - Read the endpoint status
  @ep:		Reference to structure of type pch_udc_ep_regs
  Retern	The endpoint status
  pch_udc_clear_ep_status() - Clear the endpoint status
  @ep:		Reference to structure of type pch_udc_ep_regs
  @stat:	Endpoint status
  pch_udc_ep_set_nak() - Set the bit 7 (SNAK field)
 				of the endpoint control register
  @ep:		Reference to structure of type pch_udc_ep_regs
  pch_udc_ep_clear_nak() - Set the bit 8 (CNAK field)
 				of the endpoint control register
  @ep:		reference to structure of type pch_udc_ep_regs
  pch_udc_ep_fifo_flush() - Flush the endpoint fifo
  @ep:	reference to structure of type pch_udc_ep_regs
  @dir:	direction of endpoint
 		  0:  endpoint is OUT
 		  !0: endpoint is IN
 IN ep 
  pch_udc_ep_enable() - This api enables endpoint
  @ep:		reference to structure of type pch_udc_ep_regs
  @cfg:	current configuration information
  @desc:	endpoint descriptor
 Configure the endpoint 
  pch_udc_ep_disable() - This api disables endpoint
  @ep:		reference to structure of type pch_udc_ep_regs
 flush the fifo 
 set NAK 
 set NAK 
 reset desc pointer 
  pch_udc_wait_ep_stall() - Wait EP stall.
  @ep:		reference to structure of type pch_udc_ep_regs
 Wait till idle 
  pch_udc_init() - This API initializes usb device controller
  @dev:	Rreference to pch_udc_regs structure
 Soft Reset and Reset PHY 
 mask and clear all device interrupts 
 mask and clear all ep interrupts 
 enable dynamic CSR programmingi, self powered and device speed 
 defaul high speed 
  pch_udc_exit() - This API exit usb device controller
  @dev:	Reference to pch_udc_regs structure
 mask all device interrupts 
 mask all ep interrupts 
 put device in disconnected state 
  pch_udc_pcd_get_frame() - This API is invoked to get the current frame number
  @gadget:	Reference to the gadget driver
  Return codes:
 	0:		Success
 	-EINVAL:	If the gadget passed is NULL
  pch_udc_pcd_wakeup() - This API is invoked to initiate a remote wakeup
  @gadget:	Reference to the gadget driver
  Return codes:
 	0:		Success
 	-EINVAL:	If the gadget passed is NULL
  pch_udc_pcd_selfpowered() - This API is invoked to specify whether the device
 				is self powered or not
  @gadget:	Reference to the gadget driver
  @value:	Specifies self powered or not
  Return codes:
 	0:		Success
 	-EINVAL:	If the gadget passed is NULL
  pch_udc_pcd_pullup() - This API is invoked to make the device
 				visibleinvisible to the host
  @gadget:	Reference to the gadget driver
  @is_on:	Specifies whether the pull up is made active or inactive
  Return codes:
 	0:		Success
 	-EINVAL:	If the gadget passed is NULL
  pch_udc_pcd_vbus_session() - This API is used by a driver for an external
 				transceiver (or GPIO) that
 				detects a VBUS power session startingending
  @gadget:	Reference to the gadget driver
  @is_active:	specifies whether the session is starting or ending
  Return codes:
 	0:		Success
 	-EINVAL:	If the gadget passed is NULL
  pch_udc_pcd_vbus_draw() - This API is used by gadget drivers during
 				SET_CONFIGURATION calls to
 				specify how much power the device can consume
  @gadget:	Reference to the gadget driver
  @mA:		specifies the current limit in 2mA unit
  Return codes:
 	-EINVAL:	If the gadget passed is NULL
 	-EOPNOTSUPP:
  pch_vbus_gpio_get_value() - This API gets value of GPIO port as VBUS status.
  @dev:	Reference to the driver structure
  Return value:
 	1: VBUS is high
 	0: VBUS is low
      -1: It is not enable to detect VBUS using GPIO
  pch_vbus_gpio_work_fall() - This API keeps watch on VBUS becoming Low.
                              If VBUS is Low, disconnect is processed
  @irq_work:	Structure for WorkQueue
  pch_vbus_gpio_work_rise() - This API checks VBUS is High.
                              If VBUS is High, connect is processed
  @irq_work:	Structure for WorkQueue
  pch_vbus_gpio_irq() - IRQ handler for GPIO interrupt for changing VBUS
  @irq:	Interrupt request number
  @data:	Reference to the device structure
  Return codes:
 	0: Success
 	-EINVAL: GPIO port is invalid or can't be initialized.
  pch_vbus_gpio_init() - This API initializes GPIO port detecting VBUS.
  @dev:		Reference to the driver structure
  Return codes:
 	0: Success
 	-EINVAL: GPIO port is invalid or can't be initialized.
 Retrieve the GPIO line from the USB gadget device 
  pch_vbus_gpio_free() - This API frees resources of GPIO port
  @dev:	Reference to the driver structure
  complete_req() - This API is invoked from the driver when processing
 			of a request is complete
  @ep:		Reference to the endpoint structure
  @req:	Reference to the request structure
  @status:	Indicates the successfailure of completion
 set new status if pending 
  empty_req_queue() - This API empties the request queue of an endpoint
  @ep:		Reference to the endpoint structure
 Remove from list 
  pch_udc_free_dma_chain() - This function frees the DMA chain created
 				for the request
  @dev:	Reference to the driver structure
  @req:	Reference to the request to be freed
  Return codes:
 	0: Success
 do not free first desc., will be done by free for request 
  pch_udc_create_dma_chain() - This function creates or reinitializes
 				a DMA chain
  @ep:		Reference to the endpoint structure
  @req:	Reference to the request
  @buf_len:	The buffer length
  @gfp_flags:	Flags to be used while mapping the data buffer
  Return codes:
 	0:		success,
 	-ENOMEM:	dma_pool_alloc invocation fails
  prepare_dma() - This function creates and initializes the DMA chain
 			for the request
  @ep:		Reference to the endpoint structure
  @req:	Reference to the request
  @gfp:	Flag to be used while mapping the data buffer
  Return codes:
 	0:		Success
 	Other 0:	linux error number on failure
 Allocate and create a DMA chain 
  process_zlp() - This function process zero length packets
 			from the gadget driver
  @ep:		Reference to the endpoint structure
  @req:	Reference to the request
 IN zlp's are handled by hardware 
	 if set_config or set_intf is waiting for ack by zlp
	  then set CSR_DONE
 setup command is ACK'ed now by zlp 
  pch_udc_start_rxrequest() - This function starts the receive requirement.
  @ep:		Reference to the endpoint structure
  @req:	Reference to the request structure
 Set the status bits for all descriptors 
 Write the descriptor pointer 
  pch_udc_pcd_ep_enable() - This API enables the endpoint. It is called
 				from gadget driver
  @usbep:	Reference to the USB endpoint structure
  @desc:	Reference to the USB endpoint descriptor structure
  Return codes:
 	0:		Success
 	-EINVAL:
 	-ESHUTDOWN:
  pch_udc_pcd_ep_disable() - This API disables endpoint and is called
 				from gadget driver
  @usbep:	Reference to the USB endpoint structure
  Return codes:
 	0:		Success
 	-EINVAL:
  pch_udc_alloc_request() - This function allocates request structure.
 				It is called by gadget driver
  @usbep:	Reference to the USB endpoint structure
  @gfp:	Flag to be used while allocating memory
  Return codes:
 	NULL:			Failure
 	Allocated address:	Success
 ep0 in requests are allocated from data pool here 
 prevent from using desc. - set HOST BUSY 
  pch_udc_free_request() - This function frees request structure.
 				It is called by gadget driver
  @usbep:	Reference to the USB endpoint structure
  @usbreq:	Reference to the USB request
  pch_udc_pcd_queue() - This function queues a request packet. It is called
 			by gadget driver
  @usbep:	Reference to the USB endpoint structure
  @usbreq:	Reference to the USB request
  @gfp:	Flag to be used while mapping the data buffer
  Return codes:
 	0:			Success
 	linux error number:	Failure
 map the buffer for dma 
 no pending transfer, so start this req 
			
			 For IN trfr the descriptors will be programmed and
			 P bit will be set when
			 we get an IN token
 Now add this request to the ep's pending requests 
  pch_udc_pcd_dequeue() - This function de-queues a request packet.
 				It is called by gadget driver
  @usbep:	Reference to the USB endpoint structure
  @usbreq:	Reference to the USB request
  Return codes:
 	0:			Success
 	linux error number:	Failure
 make sure it's still queued on this endpoint 
  pch_udc_pcd_set_halt() - This function Sets or clear the endpoint halt
 			    feature
  @usbep:	Reference to the USB endpoint structure
  @halt:	Specifies whether to set or clear the feature
  Return codes:
 	0:			Success
 	linux error number:	Failure
  pch_udc_pcd_set_wedge() - This function Sets or clear the endpoint
 				halt feature
  @usbep:	Reference to the USB endpoint structure
  Return codes:
 	0:			Success
 	linux error number:	Failure
  pch_udc_pcd_fifo_flush() - This function Flush the FIFO of specified endpoint
  @usbep:	Reference to the USB endpoint structure
  pch_udc_init_setup_buff() - This function initializes the SETUP buffer
  @td_stp:	Reference to the SETP buffer structure
  pch_udc_start_next_txrequest() - This function starts
 					the next transmission requirement
  @ep:	Reference to the endpoint structure
 next request 
  pch_udc_complete_transfer() - This function completes a transfer
  @ep:		Reference to the endpoint structure
  pch_udc_complete_receiver() - This function completes a receiver
  @ep:		Reference to the endpoint structure
 next request 
 on 64k packets the RXBYTES field is zero 
 If there is a newfailed requests try that now 
  pch_udc_svc_data_in() - This function process endpoint interrupts
 				for IN endpoints
  @dev:	Reference to the device structure
  @ep_num:	Endpoint that generated the interrupt
 On IN interrupt, provide data if we have any 
  pch_udc_svc_data_out() - Handles interrupts from OUT endpoint
  @dev:	Reference to the device structure
  @ep_num:	Endpoint that generated the interrupt
 next request 
 In some cases we can get an interrupt before driver gets setup 
  pch_udc_svc_control_in() - Handle Control IN endpoint interrupts
  @dev:	Reference to the device structure
 On IN interrupt, provide data if we have any 
  pch_udc_svc_control_out() - Routine that handle Control
 					OUT endpoint interrupts
  @dev:	Reference to the device structure
 If setup data 
 OUT 
 If Mass storage Reset 
 call gadget with setup data received 
 ep0 in returns data on IN phase 
			 Gadget would have queued a request when
 if unsupported request, then stall 
  pch_udc_postsvc_epinters() - This function enables end point interrupts
 				and clears NAK status
  @dev:	Reference to the device structure
  @ep_num:	End point number
  pch_udc_read_all_epstatus() - This function read all endpoint status
  @dev:	Reference to the device structure
  @ep_intr:	Status of endpoint interrupt
 IN 
 OUT 
  pch_udc_activate_control_ep() - This function enables the control endpoints
 					for traffic after a reset
  @dev:	Reference to the device structure
 Setup the IN endpoint 
 Initialize the IN EP Descriptor 
 Setup the OUT endpoint 
 Initialize the SETUP buffer 
 Write the pointer address of dma descriptor 
 Write the pointer address of Setup descriptor 
 Initialize the dma descriptor 
  pch_udc_svc_ur_interrupt() - This function handles a USB reset interrupt
  @dev:	Reference to driver structure
 Mask all endpoint interrupts 
 clear all endpoint interrupts 
 disable ep to empty req queue. Skip the control EP's 
 Complete request queue 
  pch_udc_svc_enum_interrupt() - This function handles a USB speed enumeration
 				done interrupt
  @dev:	Reference to driver structure
 enable device interrupts 
  pch_udc_svc_intf_interrupt() - This function handles a set interface
 				  interrupt
  @dev:	Reference to driver structure
 Construct the usb request for gadget driver and inform it 
 programm the Endpoint Cfg registers 
 Only one end point cfg register 
 clear stall bits 
  pch_udc_svc_cfg_interrupt() - This function handles a set configuration
 				interrupt
  @dev:	Reference to driver structure
 make usb request for gadget driver 
 program the NE registers 
 Only one end point cfg register 
 clear stall bits 
 call gadget zero with setup data received 
  pch_udc_dev_isr() - This function services device interrupts
 			by invoking appropriate routines.
  @dev:	Reference to the device structure
  @dev_intr:	The Device interrupt status.
 USB Reset Interrupt 
 Enumeration Done Interrupt 
 Set Interface Interrupt 
 Set Config Interrupt 
 USB Suspend interrupt 
 Clear the SOF interrupt, if enabled 
 ES interrupt, IDLE > 3ms on the USB 
 RWKP interrupt 
  pch_udc_isr() - This function handles interrupts from the PCH USB Device
  @irq:	Interrupt request number
  @pdev:	Reference to the device structure
 For a hot plug, this find that the controller is hung up. 
 The controller is reset 
 Clear device interrupts 
 Clear ep interrupts 
 Process Control In interrupts, if present 
 Process Control Out interrupts, if present 
 Process data in end point interrupts 
 Process data out end point interrupts 
  pch_udc_setup_ep0() - This function enables control endpoint for traffic
  @dev:	Reference to the device structure
 enable ep0 interrupts 
 enable device interrupts 
  pch_udc_pcd_reinit() - This API initializes the endpoint structures
  @dev:	Reference to the driver structure
 Initialize the endpoints structures 
 need to set ep->ep.maxpacket and set Default Configuration?
 remove ep0 in and out from the list.  They have own pointer 
  pch_udc_pcd_init() - This API initializes the driver structure
  @dev:	Reference to the driver structure
  Return codes:
 	0:		Success
 	-ERRNO:		All kind of errors when retrieving VBUS GPIO
  init_dma_pools() - create dma pools during initialization
  @dev:	reference to struct pci_dev
 DMA setup 
 dma desc for setup data 
 setup 
 data: 0 packets !? 
 get ready for ep0 traffic 
 clear SD 
 Assures that there are no pending requests with this driver 
 set SD 
 disable the pullup so the host will think we're gone 
 gadget driver must not be registered 
 dma pool cleanup 
 cleanup DMA desc's for ep0in 
 init 
 pci setup 
 Platform specific hook 
 PCI resource allocation 
 initialize the hardware 
 device struct setup 
 Put the device in disconnected state till a driver is bound 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2011 Marvell International Ltd. All rights reserved.
 for endpoint 0 operations 
 ep0 ep context, ep0 in and out share the same ep context 
 reset ep state machine 
 reset ep0 out 
 reset ep0 in 
 set TX and RX to stall 
 update ep0 state 
  mv_u3d_done() - retire a request; caller blocked irqs
  @status : request status to be set, only works when
  request is still in progress.
 Removed the req from ep queue 
 req.status should be set as -EINPROGRESS in ep_queue() 
 Free trb for the request 
 ep0 in and out share the same ep context slot 1
 check if the pipe is empty or not 
		 Configure the trb address and set the DCS bit.
		  Both DCS bit and own bit in trb should be set.
		 Ensure that updates to the EP Context will
		  occure before Ring Bell.
 ring bell the ep 
 how big will this transfer be? 
	
	  Be careful that no _GFP_HIGHMEM is set,
	  or we can not use dma_to_virt
	  cannot use GFP_KERNEL in spin lock
 initialize buffer page pointers 
 Enable interrupt for the last trb of a request 
 how big will this transfer be? 
 initialize buffer page pointers 
 zlp is needed if req->req.zero is set 
 Enable interrupt for the last trb of a request 
 generate TRB linked list for a request
  usb controller only supports continous trb chain,
  that trb structure physical address should be continous.
	 normally the request transfer length is less than 16KB.
	  we use buil_trb_one() to optimize it.
 set up dma mapping 
 build trbs 
 and push them to device queue 
 irq handler advances the queue 
 Set the max burst size 
 control transfer only supports maxburst as one 
 Enable the endpoint for Rx or Tx and set the endpoint type 
 nuke all pending requests (does flush) 
 Disable the endpoint for Rx or Tx and reset the endpoint type 
 if endpoint is not enabled, cannot flush endpoint 
 ep0 need clear bit after flushing fifo. 
 Wait until flushing completed 
			
			  EP_FLUSH bit should be cleared to indicate this
			  operation is complete
 EP_DIR_IN 
 Wait until flushing completed 
			
			 EP_FLUSH bit should be cleared to indicate this
			 operation is complete
 queues (submits) an IO request to an endpoint 
 catch various bogus parameters 
 Software list handles usb request. 
 dequeues (cancels, unlinks) an IO request from an endpoint 
 make sure it's actually queued on this endpoint 
 The request is in progress, or completed but not dequeued 
 The request isn't the last request in this ep queue 
 Point first TRB of next request to the EP context. 
 remove the req from the ep req list 
	
	  Attempt to halt IN ep will fail if any transfer requests
	  are still queue
 Reset the RUN bit in the command register to stop USB 
 enable link LTSSM state machine 
 Enable interrupts 
 Enable ctrl ep 
 Set the Run bit in the command register 
 Stop the controller 
 Reset the controller to get default values 
 wait for reset to complete 
 Configure the Endpoint Context Address 
	
	  1. external VBUS detect: we can disableenable clock on demand.
	  2. UDC VBUS detect: we have to enable clock all the time.
	  3. No VBUS detect: we have to enable clock all the time.
			
			  after clock is disabled, we lost all the register
			   context. We have to re-init registers
 stop all the transfer in queue
 constrain controller's VBUS power usage
  This call is used by gadget drivers during SET_CONFIGURATION calls,
  reporting how much power the device may consume.  For example, this
  could affect how quickly batteries are recharged.
  Returns zero on success, else negative errno.
			
			  after clock is disabled, we lost all the register
			   context. We have to re-init registers
 stop all the transfer in queue
 hook up the driver ... 
 enable clock to access controller register 
 stop all usb activities 
 device controller usb_gadget_ops structure 
 notify controller that VBUS is powered or not 
 constrain controller's VBUS power usage 
 initialize ep0, ep0 inout use eps[1] 
 add ep0 ep_context 
 initialize other endpoints 
 delete all endpoint requests, called with spinlock held 
 endpoint fifo flush 
 stop all USB activities 
 report disconnect; the driver is already quiesced 
 Increment the error count 
 set speed 
		 if external vbus detect is not supported,
		  we handle it here.
 update usb state 
 set the new address 
 We process some stardard setup requests here 
 delegate USB standard requests to the gadget driver 
 USB requests handled by gadget 
 DATA phase from gadget, STATUS phase from u3d 
 no DATA phase, STATUS phase from gadget 
 Copy the setup packet to local buffer 
 Process all Setup packet received interrupts 
 remove req out of ep request list after completion 
 process the req queue until an uncomplete request 
 write back status to req 
 ep0 request completion 
 write vbus valid bit of bridge setting to clear 
			 if external vbus detect is not supported,
			  we handle it here.
 RX data is already in the 16KB FIFO.
 write one to clear 
 free memory allocated in probe 
 we will access controller register, so enable the u3d controller 
	
	  some platform will use usb to download image, it may not disconnect
	  usb gadget before loading kernel. So first stop u3d here.
 create TRB dma_pool resource 
 initialize ep0 status request structure 
 allocate a small amount of memory to get valid address 
 initialize gadget structure 
 usb_gadget_ops 
 gadget ep0 
 ep_list 
 speed 
 the "gadget" abstractsvirtualizes the controller 
 gadget name 
 external vbus detection 
 enable usb3 controller vbus detection 
	
	  only cable is unplugged, usb can suspend.
	  So do not care about clock_gating == 1, it is handled by
	  vbus session.
 stop all usb activities 
 SPDX-License-Identifier: GPL-2.0
  udc.c - Core UDC Framework
  Copyright (C) 2010 Texas Instruments
  Author: Felipe Balbi <balbi@ti.com>
  struct usb_udc - describes one usb device controller
  @driver: the gadget driver pointer. For use by the class code
  @dev: the child device to the actual controller
  @gadget: the gadget. For use by the class code
  @list: for use by the udc class driver
  @vbus: for udcs who care about vbus status, this value is real vbus status;
  for udcs who do not care about vbus status, this value is always true
  @started: the UDC's started state. True if the UDC had started.
  This represents the internal data structure which is used by the UDC-class
  to hold information about udc driver and gadget together.
 ------------------------------------------------------------------------- 
  usb_ep_set_maxpacket_limit - set maximum packet size limit for endpoint
  @ep:the endpoint being configured
  @maxpacket_limit:value of maximum packet size limit
  This function should be used only in UDC drivers to initialize endpoint
  (usually in probe function).
  usb_ep_enable - configure endpoint, making it usable
  @ep:the endpoint being configured.  may not be the endpoint named "ep0".
 	drivers discover endpoints through the ep_list of a usb_gadget.
  When configurations are set, or when interface settings change, the driver
  will enable or disable the relevant endpoints.  while it is enabled, an
  endpoint may be used for io until the driver receives a disconnect() from
  the host or until the endpoint is disabled.
  the ep0 implementation (which calls this routine) must ensure that the
  hardware capabilities of each endpoint match the descriptor provided
  for it.  for example, an endpoint named "ep2in-bulk" would be usable
  for interrupt transfers as well as bulk, but it likely couldn't be used
  for iso transfers or for endpoint 14.  some endpoints are fully
  configurable, with more generic names like "ep-a".  (remember that for
  USB, "in" means "towards the USB host".)
  This routine may be called in an atomic (interrupt) context.
  returns zero, or a negative error code.
 UDC drivers can't handle endpoints with maxpacket size 0 
		
		  We should log an error message here, but we can't call
		  dev_err() because there's no way to find the gadget
		  given only ep.
  usb_ep_disable - endpoint is no longer usable
  @ep:the endpoint being unconfigured.  may not be the endpoint named "ep0".
  no other task may be using this endpoint when this is called.
  any pending and uncompleted requests will complete with status
  indicating disconnect (-ESHUTDOWN) before this call returns.
  gadget drivers must call usb_ep_enable() again before queueing
  requests to the endpoint.
  This routine may be called in an atomic (interrupt) context.
  returns zero, or a negative error code.
  usb_ep_alloc_request - allocate a request object to use with this endpoint
  @ep:the endpoint to be used with with the request
  @gfp_flags:GFP_ flags to use
  Request objects must be allocated with this call, since they normally
  need controller-specific setup and may even need endpoint-specific
  resources such as allocation of DMA descriptors.
  Requests may be submitted with usb_ep_queue(), and receive a single
  completion callback.  Free requests with usb_ep_free_request(), when
  they are no longer needed.
  Returns the request, or null if one could not be allocated.
  usb_ep_free_request - frees a request object
  @ep:the endpoint associated with the request
  @req:the request being freed
  Reverses the effect of usb_ep_alloc_request().
  Caller guarantees the request is not queued, and that it will
  no longer be requeued (or otherwise used).
  usb_ep_queue - queues (submits) an IO request to an endpoint.
  @ep:the endpoint associated with the request
  @req:the request being submitted
  @gfp_flags: GFP_ flags to use in case the lower level driver couldn't
 	pre-allocate all necessary memory with the request.
  This tells the device controller to perform the specified request through
  that endpoint (reading or writing a buffer).  When the request completes,
  including being canceled by usb_ep_dequeue(), the request's completion
  routine is called to return the request to the driver.  Any endpoint
  (except control endpoints like ep0) may have more than one transfer
  request queued; they complete in FIFO order.  Once a gadget driver
  submits a request, that request may not be examined or modified until it
  is given back to that driver through the completion callback.
  Each request is turned into one or more packets.  The controller driver
  never merges adjacent requests into the same packet.  OUT transfers
  will sometimes use data that's already buffered in the hardware.
  Drivers can rely on the fact that the first byte of the request's buffer
  always corresponds to the first byte of some USB packet, for both
  IN and OUT transfers.
  Bulk endpoints can queue any amount of data; the transfer is packetized
  automatically.  The last packet will be short if the request doesn't fill it
  out completely.  Zero length packets (ZLPs) should be avoided in portable
  protocols since not all usb hardware can successfully handle zero length
  packets.  (ZLPs may be explicitly written, and may be implicitly written if
  the request 'zero' flag is set.)  Bulk endpoints may also be used
  for interrupt transfers; but the reverse is not true, and some endpoints
  won't support every interrupt transfer.  (Such as 768 byte packets.)
  Interrupt-only endpoints are less functional than bulk endpoints, for
  example by not supporting queueing or not handling buffers that are
  larger than the endpoint's maxpacket size.  They may also treat data
  toggle differently.
  Control endpoints ... after getting a setup() callback, the driver queues
  one response (even if it would be zero length).  That enables the
  status ack, after transferring data as specified in the response.  Setup
  functions may return negative error codes to generate protocol stalls.
  (Note that some USB device controllers disallow protocol stall responses
  in some cases.)  When control responses are deferred (the response is
  written after the setup callback returns), then usb_ep_set_halt() may be
  used on ep0 to trigger protocol stalls.  Depending on the controller,
  it may not be possible to trigger a status-stage protocol stall when the
  data stage is over, that is, from within the response's completion
  routine.
  For periodic endpoints, like interrupt or isochronous ones, the usb host
  arranges to poll once per interval, and the gadget driver usually will
  have queued some data to transfer at that time.
  Note that @req's ->complete() callback must never be called from
  within usb_ep_queue() as that can create deadlock situations.
  This routine may be called in interrupt context.
  Returns zero, or a negative error code.  Endpoints that are not enabled
  report errors; errors will also be
  reported when the usb peripheral is disconnected.
  If and only if @req is successfully queued (the return value is zero),
  @req->complete() will be called exactly once, when the Gadget core and
  UDC are finished with the request.  When the completion function is called,
  control of the request is returned to the device driver which submitted it.
  The completion handler may then immediately free or reuse @req.
  usb_ep_dequeue - dequeues (cancels, unlinks) an IO request from an endpoint
  @ep:the endpoint associated with the request
  @req:the request being canceled
  If the request is still active on the endpoint, it is dequeued and
  eventually its completion routine is called (with status -ECONNRESET);
  else a negative error code is returned.  This routine is asynchronous,
  that is, it may return before the completion routine runs.
  Note that some hardware can't clear out write fifos (to unlink the request
  at the head of the queue) except as part of disconnecting from usb. Such
  restrictions prevent drivers from supporting configuration changes,
  even to configuration zero (a "chapter 9" requirement).
  This routine may be called in interrupt context.
  usb_ep_set_halt - sets the endpoint halt feature.
  @ep: the non-isochronous endpoint being stalled
  Use this to stall an endpoint, perhaps as an error report.
  Except for control endpoints,
  the endpoint stays halted (will not stream any data) until the host
  clears this feature; drivers may need to empty the endpoint's request
  queue first, to make sure no inappropriate transfers happen.
  Note that while an endpoint CLEAR_FEATURE will be invisible to the
  gadget driver, a SET_INTERFACE will not be.  To reset endpoints for the
  current altsetting, see usb_ep_clear_halt().  When switching altsettings,
  it's simplest to use usb_ep_enable() or usb_ep_disable() for the endpoints.
  This routine may be called in interrupt context.
  Returns zero, or a negative error code.  On success, this call sets
  underlying hardware state that blocks data transfers.
  Attempts to halt IN endpoints will fail (returning -EAGAIN) if any
  transfer requests are still queued, or if the controller hardware
  (usually a FIFO) still holds bytes that the host hasn't collected.
  usb_ep_clear_halt - clears endpoint halt, and resets toggle
  @ep:the bulk or interrupt endpoint being reset
  Use this when responding to the standard usb "set interface" request,
  for endpoints that aren't reconfigured, after clearing any other state
  in the endpoint's io queue.
  This routine may be called in interrupt context.
  Returns zero, or a negative error code.  On success, this call clears
  the underlying hardware state reflecting endpoint halt and data toggle.
  Note that some hardware can't support this request (like pxa2xx_udc),
  and accordingly can't correctly implement interface altsettings.
  usb_ep_set_wedge - sets the halt feature and ignores clear requests
  @ep: the endpoint being wedged
  Use this to stall an endpoint and ignore CLEAR_FEATURE(HALT_ENDPOINT)
  requests. If the gadget driver clears the halt status, it will
  automatically unwedge the endpoint.
  This routine may be called in interrupt context.
  Returns zero on success, else negative errno.
  usb_ep_fifo_status - returns number of bytes in fifo, or error
  @ep: the endpoint whose fifo status is being checked.
  FIFO endpoints may have "unclaimed data" in them in certain cases,
  such as after aborted transfers.  Hosts may not have collected all
  the IN data written by the gadget driver (and reported by a request
  completion).  The gadget driver may not have collected all the data
  written OUT to it by the host.  Drivers that need precise handling for
  fault reporting or recovery may need to use this call.
  This routine may be called in interrupt context.
  This returns the number of such bytes in the fifo, or a negative
  errno if the endpoint doesn't use a FIFO or doesn't support such
  precise handling.
  usb_ep_fifo_flush - flushes contents of a fifo
  @ep: the endpoint whose fifo is being flushed.
  This call may be used to flush the "unclaimed data" that may exist in
  an endpoint fifo after abnormal transaction terminations.  The call
  must never be used except when endpoint is not being used for any
  protocol translation.
  This routine may be called in interrupt context.
 ------------------------------------------------------------------------- 
  usb_gadget_frame_number - returns the current frame number
  @gadget: controller that reports the frame number
  Returns the usb frame number, normally eleven bits from a SOF packet,
  or negative errno if this device doesn't support this capability.
  usb_gadget_wakeup - tries to wake up the host connected to this gadget
  @gadget: controller used to wake up the host
  Returns zero on success, else negative error code if the hardware
  doesn't support such attempts, or its support has not been enabled
  by the usb host.  Drivers must return device descriptors that report
  their ability to support this, or hosts won't enable it.
  This may also try to use SRP to wake the host and start enumeration,
  even if OTG isn't otherwise in use.  OTG devices may also start
  remote wakeup even when hosts don't explicitly enable it.
  usb_gadget_set_selfpowered - sets the device selfpowered feature.
  @gadget:the device being declared as self-powered
  this affects the device status reported by the hardware driver
  to reflect that it now has a local power supply.
  returns zero on success, else negative errno.
  usb_gadget_clear_selfpowered - clear the device selfpowered feature.
  @gadget:the device being declared as bus-powered
  this affects the device status reported by the hardware driver.
  some hardware may not support bus-powered operation, in which
  case this feature's value can never change.
  returns zero on success, else negative errno.
  usb_gadget_vbus_connect - Notify controller that VBUS is powered
  @gadget:The device which now has VBUS power.
  Context: can sleep
  This call is used by a driver for an external transceiver (or GPIO)
  that detects a VBUS power session starting.  Common responses include
  resuming the controller, activating the D+ (or D-) pullup to let the
  host detect that a USB device is attached, and starting to draw power
  (8mA or possibly more, especially after SET_CONFIGURATION).
  Returns zero on success, else negative errno.
  usb_gadget_vbus_draw - constrain controller's VBUS power usage
  @gadget:The device whose VBUS usage is being described
  @mA:How much current to draw, in milliAmperes.  This should be twice
 	the value listed in the configuration descriptor bMaxPower field.
  This call is used by gadget drivers during SET_CONFIGURATION calls,
  reporting how much power the device may consume.  For example, this
  could affect how quickly batteries are recharged.
  Returns zero on success, else negative errno.
  usb_gadget_vbus_disconnect - notify controller about VBUS session end
  @gadget:the device whose VBUS supply is being described
  Context: can sleep
  This call is used by a driver for an external transceiver (or GPIO)
  that detects a VBUS power session ending.  Common responses include
  reversing everything done in usb_gadget_vbus_connect().
  Returns zero on success, else negative errno.
  usb_gadget_connect - software-controlled connect to USB host
  @gadget:the peripheral being connected
  Enables the D+ (or potentially D-) pullup.  The host will start
  enumerating this gadget when the pullup is active and a VBUS session
  is active (the link is powered).
  Returns zero on success, else negative errno.
		
		  If gadget is deactivated we only save new state.
		  Gadget will be connected automatically after activation.
  usb_gadget_disconnect - software-controlled disconnect from USB host
  @gadget:the peripheral being disconnected
  Disables the D+ (or potentially D-) pullup, which the host may see
  as a disconnect (when a VBUS session is active).  Not all systems
  support software pullup controls.
  Following a successful disconnect, invoke the ->disconnect() callback
  for the current gadget driver so that UDC drivers don't need to.
  Returns zero on success, else negative errno.
		
		  If gadget is deactivated we only save new state.
		  Gadget will stay disconnected after activation.
  usb_gadget_deactivate - deactivate function which is not ready to work
  @gadget: the peripheral being deactivated
  This routine may be used during the gadget driver bind() call to prevent
  the peripheral from ever being visible to the USB host, unless later
  usb_gadget_activate() is called.  For example, user mode components may
  need to be activated before the system can talk to hosts.
  Returns zero on success, else negative errno.
		
		  If gadget was being connected before deactivation, we want
		  to reconnect it in usb_gadget_activate().
  usb_gadget_activate - activate function which is not ready to work
  @gadget: the peripheral being activated
  This routine activates gadget which was previously deactivated with
  usb_gadget_deactivate() call. It calls usb_gadget_connect() if needed.
  Returns zero on success, else negative errno.
	
	  If gadget has been connected before deactivation, or became connected
	  while it was being deactivated, we call usb_gadget_connect().
 ------------------------------------------------------------------------- 
 CONFIG_HAS_DMA 
 ------------------------------------------------------------------------- 
  usb_gadget_giveback_request - give the request back to the gadget layer
  @ep: the endpoint to be used with with the request
  @req: the request being given back
  This is called by device controller drivers in order to return the
  completed request back to the gadget layer.
 ------------------------------------------------------------------------- 
  gadget_find_ep_by_name - returns ep whose name is the same as sting passed
 	in second parameter or NULL if searched endpoint not found
  @g: controller to check for quirk
  @name: name of searched endpoint
 ------------------------------------------------------------------------- 
 endpoint already claimed? 
 "high bandwidth" works only at high speed 
 only support ep0 for portable CONTROL traffic 
 ISO:  limit 1023 bytes full speed, 1024 highsuper speed 
			 Get the number of required streams from the
			  EP companion descriptor and see if the EP
			  matches it
		 Bulk endpoints handle interrupt transfers,
		  except the toggle-quirky iso-synch kind
 INT:  limit 64 bytes full speed, 1024 highsuper speed 
  usb_gadget_check_config - checks if the UDC can support the binded
 	configuration
  @gadget: controller to check the USB configuration
  Ensure that a UDC is able to support the requested resources by a
  configuration, and that there are no resource limitations, such as
  internal memory allocated to all requested endpoints.
  Returns zero on success, else a negative errno.
 ------------------------------------------------------------------------- 
 ------------------------------------------------------------------------- 
  usb_udc_vbus_handler - updates the udc core vbus status, and try to
  connect or disconnect gadget
  @gadget: The gadget which vbus change occurs
  @status: The vbus status
  The udc driver calls it when it wants to connect or disconnect gadget
  according to vbus status.
  usb_gadget_udc_reset - notifies the udc core that bus reset occurs
  @gadget: The gadget which bus reset occurs
  @driver: The gadget driver we want to notify
  If the udc driver has bus reset handler, it needs to call this when the bus
  reset occurs, it notifies the gadget driver that the bus reset occurs as
  well as updates gadget state.
  usb_gadget_udc_start - tells usb device controller to start up
  @udc: The UDC to be started
  This call is issued by the UDC Class driver when it's about
  to register a gadget driver to the device controller, before
  calling gadget driver's bind() method.
  It allows the controller to be powered off until strictly
  necessary to have it powered on.
  Returns zero on success, else negative errno.
  usb_gadget_udc_stop - tells usb device controller we don't need it anymore
  @udc: The UDC to be stopped
  This call is issued by the UDC Class driver after calling
  gadget driver's unbind() method.
  The details are implementation specific, but it can go as
  far as powering off UDC completely and disable its data
  line pullups.
  usb_gadget_udc_set_speed - tells usb device controller speed supported by
     current driver
  @udc: The device we want to set maximum speed
  @speed: The maximum speed to allowed to run
  This call is issued by the UDC Class driver before calling
  usb_gadget_udc_start() in order to make sure that we don't try to
  connect on speeds the gadget driver doesn't support.
  usb_gadget_enable_async_callbacks - tell usb device controller to enable asynchronous callbacks
  @udc: The UDC which should enable async callbacks
  This routine is used when binding gadget drivers.  It undoes the effect
  of usb_gadget_disable_async_callbacks(); the UDC driver should enable IRQs
  (if necessary) and resume issuing callbacks.
  This routine will always be called in process context.
  usb_gadget_disable_async_callbacks - tell usb device controller to disable asynchronous callbacks
  @udc: The UDC which should disable async callbacks
  This routine is used when unbinding gadget drivers.  It prevents a race:
  The UDC driver doesn't know when the gadget driver's ->unbind callback
  runs, so unless it is told to disable asynchronous callbacks, it might
  issue a callback (such as ->disconnect) after the unbind has completed.
  After this function runs, the UDC driver must suppress all ->suspend,
  ->resume, ->disconnect, ->reset, and ->setup callbacks to the gadget driver
  until async callbacks are again enabled.  A simple-minded but effective
  way to accomplish this is to tell the UDC hardware not to generate any
  more IRQs.
  Request completion callbacks must still be issued.  However, it's okay
  to defer them until the request is cancelled, since the pull-up will be
  turned off during the time period when async callbacks are disabled.
  This routine will always be called in process context.
  usb_udc_release - release the usb_udc struct
  @dev: the dev member within usb_udc
  This is called by driver's core in order to free memory once the last
  reference is released.
 should be called with udc_lock held 
  usb_initialize_gadget - initialize a gadget and its embedded struct device
  @parent: the parent device to this udc. Usually the controller driver's
  device.
  @gadget: the gadget to be initialized.
  @release: a gadget release function.
  Returns zero on success, negative errno otherwise.
  Calls the gadget release function in the latter case.
  usb_add_gadget - adds a new gadget to the udc class driver list
  @gadget: the gadget to be added to the list.
  Returns zero on success, negative errno otherwise.
  Does not do a final usb_put_gadget() if an error occurs.
 pick up one of pending gadget drivers 
  usb_add_gadget_udc_release - adds a new gadget to the udc class driver list
  @parent: the parent device to this udc. Usually the controller driver's
  device.
  @gadget: the gadget to be added to the list.
  @release: a gadget release function.
  Returns zero on success, negative errno otherwise.
  Calls the gadget release function in the latter case.
  usb_get_gadget_udc_name - get the name of the first UDC controller
  This functions returns the name of the first UDC controller in the system.
  Please note that this interface is usefull only for legacy drivers which
  assume that there is only one UDC controller in the system and they need to
  get its name before initialization. There is no guarantee that the UDC
  of the returned name will be still available, when gadget driver registers
  itself.
  Returns pointer to string with UDC controller name on success, NULL
  otherwise. Caller should kfree() returned string.
 For now we take the first available UDC 
  usb_add_gadget_udc - adds a new gadget to the udc class driver list
  @parent: the parent device to this udc. Usually the controller
  driver's device.
  @gadget: the gadget to be added to the list
  Returns zero on success, negative errno otherwise.
  usb_del_gadget - deletes @udc from udc_list
  @gadget: the gadget to be removed.
  This will call usb_gadget_unregister_driver() if
  the @udc is still busy.
  It will not do a final usb_put_gadget().
  usb_del_gadget_udc - deletes @udc from udc_list
  @gadget: the gadget to be removed.
  Calls usb_del_gadget() and does a final usb_put_gadget().
 ------------------------------------------------------------------------- 
 For now we take the first one 
 Maybe there is someone waiting for this UDC? 
			
			  For now we ignore bind errors as probably it's
			  not a valid reason to fail other's gadget unbind
 ------------------------------------------------------------------------- 
 SPDX-License-Identifier: GPL-2.0
  Toshiba TC86C001 ("Goku-S") USB Device Controller driver
  Copyright (C) 2000-2002 Lineo
       by Stuart Lynne, Tom Rushworth, and Bruce Balden
  Copyright (C) 2002 Toshiba Corporation
  Copyright (C) 2003 MontaVista Software (source@mvista.com)
  This device has ep0 and three semi-configurable bulkinterrupt endpoints.
   - Endpoint numbering is fixed: ep{1,2,3}-bulk
   - Gadget drivers can choose ep maxpacket (8163264)
   - Gadget drivers can choose direction (IN, OUT)
   - DMA works with ep1 (OUT transfers) and ep2 (IN transfers).
 #define	VERBOSE		 extra debug messages (success too) 
 #define	USB_TRACE	 packet-level success messages 
  IN dma behaves ok under testing, though the IN-dma abort paths don't
  seem to behave quite as expected.  Used by default.
  OUT dma documents design problems handling the common "short packet"
  transfer termination policy; it couldn't be enabled by default, even
  if the OUT-dma abort problems had a resolution.
#include <linuxmoduleparam.h>
 "modprobe goku_udc use_dma=1" etc
 	0 to disable dma
 	1 to use IN dma only (normal operation)
 	2 to use IN and OUT dma
-------------------------------------------------------------------------
 enabling the no-toggle interrupt mode would need an api hook 
 bulk, or intr-with-toggle 
	 ep1ep2 dma direction is chosen early; it works in the other
	  direction, with pio.  be cautious with out-dma.
 ep1 and ep2 can do double buffering andor dma 
 double buffer except (for now) with pio in 
 double buffered 
 single buffer 
dma : 0x11
 reset dma in case we're still using it 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 don't modify queue heads during completion callback 
-------------------------------------------------------------------------
 return:  0 = still running, 1 = completed, negative = errno
 NOTE:  just single-buffered PIO-IN for now.  
 clear our "packet available" irq 
 last packet often short (sometimes a zlp, especially on ep0) 
 printk seemed to trash is_last...
#ifdef USB_TRACE
	 requests complete when all IN data is in the FIFO,
	  or sometimes later, if a zlp was needed.
 ack dataset irq matching the status we'll handle 
 usually do nothing without an OUT packet 
 use ep1ep2 double-buffering for OUT 
 "can't happen" 
 EPxSizeH == 0 
 ep0out no-out-data case for set_config, etc 
 read all bytes from this packet 
				 this happens when the driver's buffer
				  is smaller than what the host sent.
				  discard the extra data in this packet.
 completion 
 non-control endpoints now usable? 
 ep0out status stage 
 empty the second buffer asap 
 write may still be posted 
 write may still be posted 
-------------------------------------------------------------------------
 return:  0 = q running, 1 = q stopped, negative = errno
 re-init the bits affecting IN dma; careful with zlps 
			return -EL2HLT;
	 Goku DMA-OUT merges short packets, which plays poorly with
	  protocols where short packets mark the transfer boundaries.
	  The chip supports a nonstandard policy with INT_MSTWRTMOUT,
	  ending transfers after 3 SOFs; we don't turn it on.
			return -EL2HLT;
 normal hw dma completion (not abort) 
		 hardware merges short packets, and also hides packet
		  overruns.  a partial packet MAY be in the fifo here.
	 NAK future host requests, hoping the implicit delay lets the
	  dma engine finish reading (or writing) its latest packet and
	  empty the dma buffer (up to 16 bytes).
	 
	  This avoids needing to clean up a partial packet in the fifo;
	  we can't do that for IN without side effects to HALT and TOGGLE.
	 FIXME using these resets isn't usably documented. this may
	  not work unless it's followed by disabling the endpoint.
	 
	  FIXME the OUT reset path doesn't even behave consistently.
 dma already completed; no abort needed 
-------------------------------------------------------------------------
 always require a cpu-view buffer so pio works 
 can't touch registers when suspended 
 set up dma mapping in case the caller didn't 
	 for ep0 IN without premature status, zlp is required and
	  writing EOP starts the status stage (OUT).
 kickstart this io queue? 
		 dma:  done after dma completion IRQ (or error)
		  pio:  done after last fifo operation
 else pio or dma irq handler advances the queue. 
 pci writes may still be posted 
 dequeue ALL requests 
 dequeue JUST ONE request 
 we can't touch (dma) registers when suspended 
 make sure it's actually queued on this endpoint 
-------------------------------------------------------------------------
 assert (ep->num !=0)
 don't change EPxSTATUS_EP_INVALID to READY 
 data in (either) packet buffer? 
 size is only reported sanely for OUT 
 ignores 16-byte dma buffer; SizeH == 0 
 don't change EPxSTATUS_EP_INVALID to READY 
	 Non-desirable behavior:  FIFO_CLEAR also clears the
	  endpoint halt feature.  For OUT, we _could_ just read
	  the bytes out (PIO, if !ep->dma); for in, no choice.
-------------------------------------------------------------------------
 single buffering is enough 
 DMA may be available 
 nothing  ;
 no remote wakeup
 not selfpowered
-------------------------------------------------------------------------
 int_status is the same format ... 
 host will retry 
 ep0 only 
 these "can't happen" 
 basic device status 
 registers for (active) device and ep0 
 dump endpoint queues 
 CONFIG_USB_GADGET_DEBUG_FILES 
-------------------------------------------------------------------------
	 deassert reset, leave USB D+ at hi-Z (no pullup)
	  don't let INT_PWRDETECT sequence begin
writel(MST_EOPB_ENA | MST_TIMEOUT_ENA, &regs->dma_master);
 hw handles set_address, set_feature, get_status; maybe more 
 can't modify descriptors after writing UsbReady 
 expect ep0 requests when the host drops reset 
 start enumeration now, or after power detect irq 
-------------------------------------------------------------------------
 keeping it simple:
  - one bus driver, initted first;
  - one function driver, initted second
 when a driver is successfully registered, it will receive
  control requests including set_configuration(), which enables
  non-control requests.  then usb traffic follows until a
  disconnect is reported.  then a host may connect again, or
  the driver might get unbound.
 hook up the driver 
	
	  then enable host detection and ep0; and we're ready
	  for set_configuration as well as eventual disconnect.
 disconnect gadget driver after quiesceing hw and the driver 
-------------------------------------------------------------------------
 read SETUP packet and enter DATA stage 
 detect early status stages 
		 NOTE:  CLEAR_FEATURE is done in software so that we can
		  synchronize transfer restarts after bulk IN stalls.  data
		  won't even enter the fifo until the halt is cleared.
 active endpoint 
 start ep0out status stage 
 device remote wakeup: always clear 
 pass to gadget driver 
 hw wants to know when we're configured (or not) 
	 delegate everything to the gadget driver.
	  it may respond after this irq handler returns.
 expect at least one data or status stage irq 
 device-wide irqs 
 FIXME have a neater way to prevent re-enumeration
 hub reset done 
 and INT_ERR on some endpoint's crcbitstuff... problem
	 progress ep0 setup, data, or status stages.
	  no transition {EP0_STATUS, EP0_STALL} --> EP0_IDLE; saves irqs
 dma completion 
 IN 
 OUT 
 OUT 
 reset dma? then dma_advance()
 pio 
-------------------------------------------------------------------------
 tear down the binding between this driver and the pci device 
 wrap this driver around the specified pci device, but
  don't respond over USB until a gadget driver binds to us.
 alloc, and start init 
 the "gadget" abstractsvirtualizes the controller 
 now all the pci goodies ... 
 init to known state, then setup irqs 
 gadget_release is not registered yet, kfree explicitly 
-------------------------------------------------------------------------
 Toshiba 
 this UDC 
 end: all zeroes  }
 FIXME add power management support 
 SPDX-License-Identifier: GPL-2.0
 linuxdriversusbgadgets3c-hsudc.c
  Copyright (c) 2010 Samsung Electronics Co., Ltd.
 		http:www.samsung.com
  S3C24XX USB 2.0 High-speed USB controller gadget driver
  The S3C24XX USB 2.0 high-speed USB controller supports upto 9 endpoints.
  Each endpoint can be configured as either in or out endpoint. Endpoints
  can be configured for Bulk or Interrupt transfer mode.
 Non-Indexed Registers 
 Index Register 
 EP Intr Status 
 EP Intr Enable 
 Gadget Address 
 Frame Number 
 EP Direction 
 Test Register 
 System Status 
 System Control 
 EP0 Status 
 EP0 Control 
 Indexed Registers 
 EPn Status 
 EPn Control 
 Read Count 
 Write Count 
 Max Pkt Size 
 analog phy supply, 3.3V 
 digital phy supply, 1.2V 
 oscillator supply, 1.8V - 3.3V 
  struct s3c_hsudc_ep - Endpoint representation used by driver.
  @ep: USB gadget layer representation of device endpoint.
  @name: Endpoint name (as required by ep autoconfiguration).
  @dev: Reference to the device controller to which this EP belongs.
  @desc: Endpoint descriptor obtained from the gadget driver.
  @queue: Transfer request queue for the endpoint.
  @stopped: Maintains state of endpoint, set if EP is halted.
  @bEndpointAddress: EP address (including direction bit).
  @fifo: Base address of EP FIFO.
  struct s3c_hsudc_req - Driver encapsulation of USB gadget transfer request.
  @req: Reference to USB gadget transfer request.
  @queue: Used for inserting this request to the endpoint request queue.
  struct s3c_hsudc - Driver's abstraction of the device controller.
  @gadget: Instance of usb_gadget which is referenced by gadget driver.
  @driver: Reference to currenty active gadget driver.
  @dev: The device reference used by probe function.
  @lock: Lock to synchronize the usage of Endpoints (EP's are indexed).
  @regs: Remapped base address of controller's register space.
  irq: IRQ number used by the controller.
  uclk: Reference to the controller clock.
  ep0state: Current state of EP0.
  ep: List of endpoints supported by the controller.
  s3c_hsudc_complete_request - Complete a transfer request.
  @hsep: Endpoint to which the request belongs.
  @hsreq: Transfer request to be completed.
  @status: Transfer completion status for the transfer request.
  s3c_hsudc_nuke_ep - Terminate all requests queued for a endpoint.
  @hsep: Endpoint for which queued requests have to be terminated.
  @status: Transfer completion status for the transfer request.
  s3c_hsudc_stop_activity - Stop activity on all endpoints.
  @hsudc: Device controller for which EP activity is to be stopped.
  All the endpoints are stopped and any pending transfer requests if any on
  the endpoint are terminated.
  s3c_hsudc_read_setup_pkt - Read the received setup packet from EP0 fifo.
  @hsudc: Device controller from which setup packet is to be read.
  @buf: The buffer into which the setup packet is read.
  The setup packet received in the EP0 fifo is read and stored into a
  given buffer address.
  s3c_hsudc_write_fifo - Write next chunk of transfer data to EP fifo.
  @hsep: Endpoint to which the data is to be written.
  @hsreq: Transfer request from which the next chunk of data is written.
  Write the next chunk of data from a transfer request to the endpoint FIFO.
  If the transfer request completes, 1 is returned, otherwise 0 is returned.
  s3c_hsudc_read_fifo - Read the next chunk of data from EP fifo.
  @hsep: Endpoint from which the data is to be read.
  @hsreq: Transfer request to which the next chunk of data read is written.
  Read the next chunk of data from the endpoint FIFO and a write it to the
  transfer request buffer. If the transfer request completes, 1 is returned,
  otherwise 0 is returned.
  s3c_hsudc_epin_intr - Handle in-endpoint interrupt.
  @hsudc - Device controller for which the interrupt is to be handled.
  @ep_idx - Endpoint number on which an interrupt is pending.
  Handles interrupt for a in-endpoint. The interrupts that are handled are
  stall and data transmit complete interrupt.
  s3c_hsudc_epout_intr - Handle out-endpoint interrupt.
  @hsudc - Device controller for which the interrupt is to be handled.
  @ep_idx - Endpoint number on which an interrupt is pending.
  Handles interrupt for a out-endpoint. The interrupts that are handled are
  stall, flush and data ready interrupt.
 s3c_hsudc_set_halt - Set or clear a endpoint halt.
  @_ep: Endpoint on which halt has to be set or cleared.
  @value: 1 for setting halt on endpoint, 0 to clear halt.
  Set or clear endpoint halt. If halt is set, the endpoint is stopped.
  If halt is cleared, for in-endpoints, if there are any pending
  transfer requests, transfers are started.
 s3c_hsudc_set_wedge - Sets the halt feature with the clear requests ignored
  @_ep: Endpoint on which wedge has to be set.
  Sets the halt feature with the clear requests ignored.
 s3c_hsudc_handle_reqfeat - Handle set feature or clear feature requests.
  @_ep: Device controller on which the setclear feature needs to be handled.
  @ctrl: Control request as received on the endpoint 0.
  Handle set feature or clear feature control requests on the control endpoint.
  s3c_hsudc_process_req_status - Handle get status control request.
  @hsudc: Device controller on which get status request has be handled.
  @ctrl: Control request as received on the endpoint 0.
  Handle get status control request received on control endpoint.
  s3c_hsudc_process_setup - Process control request received on endpoint 0.
  @hsudc: Device controller on which control request has been received.
  Read the control request received on endpoint 0, decode it and handle
  the request.
 s3c_hsudc_handle_ep0_intr - Handle endpoint 0 interrupt.
  @hsudc: Device controller on which endpoint 0 interrupt has occured.
  Handle endpoint 0 interrupt when it occurs. EP0 interrupt could occur
  when a stall handshake is sent to host or data is sentreceived on
  endpoint 0.
  s3c_hsudc_ep_enable - Enable a endpoint.
  @_ep: The endpoint to be enabled.
  @desc: Endpoint descriptor.
  Enables a endpoint when called from the gadget driver. Endpoint stall if
  any is cleared, transfer type is configured and endpoint interrupt is
  enabled.
  s3c_hsudc_ep_disable - Disable a endpoint.
  @_ep: The endpoint to be disabled.
  @desc: Endpoint descriptor.
  Disables a endpoint when called from the gadget driver.
  s3c_hsudc_alloc_request - Allocate a new request.
  @_ep: Endpoint for which request is allocated (not used).
  @gfp_flags: Flags used for the allocation.
  Allocates a single transfer request structure when called from gadget driver.
  s3c_hsudc_free_request - Deallocate a request.
  @ep: Endpoint for which request is deallocated (not used).
  @_req: Request to be deallocated.
  Allocates a single transfer request structure when called from gadget driver.
  s3c_hsudc_queue - Queue a transfer request for the endpoint.
  @_ep: Endpoint for which the request is queued.
  @_req: Request to be queued.
  @gfp_flags: Not used.
  Start or enqueue a request for a endpoint when called from gadget driver.
  s3c_hsudc_dequeue - Dequeue a transfer request from an endpoint.
  @_ep: Endpoint from which the request is dequeued.
  @_req: Request to be dequeued.
  Dequeue a request from a endpoint when called from gadget driver.
  s3c_hsudc_initep - Initialize a endpoint to default state.
  @hsudc - Reference to the device controller.
  @hsep - Endpoint to be initialized.
  @epnum - Address to be assigned to the endpoint.
  Initialize a endpoint with default configuration.
  s3c_hsudc_setup_ep - Configure all endpoints to default state.
  @hsudc: Reference to device controller.
  Configures all endpoints to default state.
  s3c_hsudc_reconfig - Reconfigure the device controller to default state.
  @hsudc: Reference to device controller.
  Reconfigures the device controller registers to a default state.
  s3c_hsudc_irq - Interrupt handler for device controller.
  @irq: Not used.
  @_dev: Reference to the device controller.
  Interrupt handler for the device controller. This handler handles controller
  interrupts and endpoint interrupts.
 connect to bus through transceiver 
 SPDX-License-Identifier: GPL-2.0
  Renesas USB3.0 Peripheral driver (USB gadget)
  Copyright (C) 2015-2017  Renesas Electronics Corporation
 register definitions 
 n = 1 to 4 
 n = 1 to 4 
 AXI_INT_ENA and AXI_INT_STA 
 PRD's n = from 1 to 4 
 DMA_INT_ENA and DMA_INT_STA 
 DMA_CH0_CONn 
 1: In Transfer 
 LCLKSEL 
 USB_COM_CON 
 USB20_CON 
 USB30_CON 
 USB_STA 
 DRD_CON 
 USB_INT_ENA_1 and USB_INT_STA_1 
 USB_INT_ENA_2 and USB_INT_STA_2 
 USB_OTG_STA, USB_OTG_INT_STA and USB_OTG_INT_ENA 
 P0_MOD 
 P0_CON and PN_CON 
 P0_CON 
 P0_STA and PN_STA 
 P0_INT_ENA and P0_INT_STA 
 PN_MOD 
 PN_RAMMAP 
 PN_CON 
 PN_INT_STA and PN_INT_ENA 
 USB3_SSIFCMD 
 This includes PIPE 0 
  To avoid double-meaning of "0" (xferred 65536 bytes or received zlp if
  buffer size is 65536), this driver uses the maximum size per a entry is
  32768 bytes.
 Physical Region Descriptor Table 
 the end of chain 
 completion of transfer 
 Error occurred 
 Interrupt occurred 
 Last Packet 
 Setting area number (from 1 to 4) 
 unit = bytes 
 unit = bytes 
 if true, don't check vbus signal 
 check id and set EXTCON_USB_HOST 
 check vbus and set EXTCON_USB 
 Set AXI_INT 
 already waked it up 
 already waked it up 
 Enables {U2,U1} if the bits of UDIR and UREQ are set to 0 
 Enables U2 if the bits of UDIR and UREQ are set to 0 
 Enables U1 if the bits of UDIR and UREQ are set to 0 
 for A-Peripheral or forced B-device mode 
 This bit shall be set within 12ms from the start of HotReset 
 update this driver's flag 
 Update gadget driver parameter 
 Write data to the register 
 update len to use usb3_set_pX_con_send() 
 Send the data 
 Update gadget driver parameter 
 Read data from the register 
 The driver doesn't handle zero-length packet via dmac 
 prd entries should be in system memory here 
 The controller updated prd entries 
 DEV_ADDR bit field is cleared by WarmReset, HotReset and BusReset 
 stall 
 stall 
 Restarts a queue if clear feature 
 TODO 
 stall 
  usb3_handle_standard_request - handle some standard requests
  @usb3: the renesas_usb3 pointer
  @ctrl: a pointer of setup data
  Returns true if this function handled a standard request
 This hardware doesn't support Isochronous xfer 
 Call giveback function if previous transfer is not completed 
 get next usb3_req 
 Do not stop the IN pipe here to detect LSTTR interrupt 
 need to unlock because usb3_request_done_pipen() locks it 
------- usb_ep_ops -----------------------------------------------------
------- usb_gadget_ops -------------------------------------------------
 hook up the driver 
 Must set the mode before device_attach of the host 
 This device_attach() might sleep 
 Must set the mode before device_attach of the host 
 This device_attach() might sleep 
 Let this driver call usb3_connect() if needed 
------- platform_driver ------------------------------------------------
 calculate num_usb3_eps from renesas_usb3_priv 
	
	  This driver prepares pipes as follows:
	   - odd pipes = IN pipe
	   - even pipes = OUT pipe (except pipe 0)
 for control pipe 
 for bulk or interrupt pipe 
 index 0 = for IN pipes 
	
	  This driver prepares pipes as follows:
	   - all pipes = the same size as "ramsize_per_pipe"
	  Please refer to the "Method of Specifying RAM Mapping"
 out of scope if ep num = 0 
 out of memory for IN or OUT pipe 
 calculate rammap_val 
 update current ramif 
 sentinel  },
 for ep0 handling 
	
	  This is optional. So, if this driver cannot get a phy,
	  this driver will not handle a phy anymore.
 If not found, this driver will not use a role sw 
 Not started 
 Not started 
 SPDX-License-Identifier: GPL-2.0+
  driverusbgadgetfsl_qe_udc.c
  Copyright (c) 2006-2008 Freescale Semiconductor, Inc. All rights reserved.
  	Xie Xiaobo <X.Xie@freescale.com>
  	Li Yang <leoli@freescale.com>
  	Based on bareboard code from Shlomi Gridish.
  Description:
  Freescle QECPM USB Pheripheral Controller Driver
  The controller can be found on MPC8360, MPC8272, and etc.
  MPC8360 Rev 1.1 may need QE mircocode update
ep name is important in gadget, it should obey the convention of ep_match()
 everyone has ep0 
 3 configurable endpoints 
       Internal Used Function Start
-----------------------------------------------------------------
  done() - retire a request; caller blocked irqs
	 the req->queue pointer is used by ep_queue() func, in which
	  the request will be added into a udc_ep->queue 'd tail
	  so here the req will be dropped from the ep->queue
 req.status should be set as -EINPROGRESS in ep_queue() 
 don't modify queue heads during completion callback 
-----------------------------------------------------------------
  nuke(): delete all requests related to this ep
 Whether this eq has request linked 
---------------------------------------------------------------------------
  USB and Endpoint manipulate process, include parameter and register       
 @value: 1--set stall 0--clean stall 
 Set the ep's nack 
 Mask Rx and Busy interrupts 
 Unmask RX interrupts 
 alloc multi-ram for BD rings and set the ep parameters 
 data0 
 Init TX and RX bds 
 MRBLR must be divisble by 4 
 check the max package size validate for this endpoint 
	 Refer to USB2.0 spec table 9-13,
 bulk is ok 
 if ep0
 initialize ep structure 
 hardware special operation 
	 Now HW will be NAKing transfers to that EP,
----------------------------------------------------------------------------
 		USB and EP basic manipulate function end		      
		UDC transmit and receive process
 when BD PID is setup, handle the packet 
 handle the usb command base on the usb_ctrlrequest 
 note: don't clear the rxbd's buffer address 
 Get next BD 
 handle the rx frame 
 note: don't clear the rxbd's buffer address 
clear the length 
 Get next BD 
 for i=1 
 send data from a frame, no matter what tx_req 
 Disable the Tx interrupt 
 if the packet is a ZLP in status phase 
 enable the TX interrupt 
 when a bd was transmitted, the function can
 zlp needed when req->re.zero is set 
 a request already were transmitted completely 
 we should gain a new tx_req fot this endpoint 
 give a frame and a tx_req, send some data 
 give a frame struct,send a ZLP 
 if direction is DIR_IN, the status is Device->Host
  if direction is DIR_OUT, the status transaction is Device<-Host
 a request complete in ep0, whether gadget request or udc request 
 because usb and ep's status already been set in ch9setaddress() 
 receive status phase 
 send status phase 
 a request already were transmitted completely 
 if have error, transmit again 
 clear and recycle the BD 
 send the data 
 confirm the already trainsmited bd 
 clear and recycle the BD 
 handle the tx frame 
 Add a request in queue, and try to transmit a packet 
 can gain a new tx_req 
 Maybe this is a good ideal 
 handle the rx frame 
		 note: don't clear the rxbd's buffer address 
 Get next BD 
 only add the request in queue 
 Enable rx and unmask rx interrupt 
 Copy the exist BD data 
	Internal Used Function End
-----------------------------------------------------------------------
	Endpoint Management Functions For Gadget
 catch various bogus parameters 
 Nuke all pending requests (does flush) 
 catch various bogus parameters 
 map virtual address to hardware 
 push the request to device 
 EP0 
 queues (submits) an IO request to an endpoint 
 dequeues (cancels, unlinks) an IO request from an endpoint 
 make sure it's actually queued on this endpoint 
-----------------------------------------------------------------
  modify the endpoint halt feature
  @ep: the non-isochronous endpoint being stalled
  @value: 1--set halt  0--clear halt
  Returns zero, or a negative error code.
	 Attempt to halt IN ep will fail if any transfer requests
 set data toggle to DATA0 on clear halt 
------------------------------------------------------------------------
	Gadget Driver Layer Operations
 Get the current frame number 
 defined in usb_gadget.h 
-------------------------------------------------------------------------
	USB ep0 Setup process in BUS Enumeration
 report disconnect; the driver is already quiesced 
 Save the new address to device struct 
 Update usb state 
 Status phase , send a ZLP 
 Get device status 
 Get interface status 
 We don't have interface information in udc driver 
 Get endpoint status 
 stall if endpoint doesn't exist 
 data phase 
 only handle the setup request, suppose the device in normal status 
 Fix Endian (udc->local_setup_buff is cpu Endian now)
 clear the previous request in the ep0 
 Data+Status phase form udc 
 Status phase from udc 
 Requests with no data phase, status phase from udc 
 Data phase from gadget, status phase from udc 
 No data phase, IN status from gadget 
-------------------------------------------------------------------------
	USB Interrupt handlers
 report suspend to the driver ,serial.c not support this
 report resume to the driver , serial.c not support this
 ep0 tx interrupt also in here 
 confirm the transmitted bd 
 setup packect's rx is handle in the function too 
non-setup package receive
 Clear notification bits 
 USB Interrupt 
-------------------------------------------------------------------------
	Gadget driver probe and unregister.
 lock is needed but whether should use this lock or another 
 hook up the driver 
 Enable IRQ reg and Set usbcmd reg EN bit 
 stop usb controller, disable intr 
 in fact, no needed 
 stand operation 
 udc structure's alloc and setup, include ep-param alloc 
 get default address of usb parameter in MURAM from device tree 
 USB Controller register init 
 Spec says that we must enable the USB controller to change mode. 
 Mode changed, now disable it, since muram isn't initialized yet. 
 Initialize the rest. 
 the queue lists any req for this ep 
 gagdet.ep_list used for ep_autoconfig so no ep0
-----------------------------------------------------------------------
 	UDC device Driver operation functions				
 Driver probe functions 
 Initialize the udc structure including QH member and other member 
	 initialize usb hw reg except for regs for EP,
	 here comes the stand operations for probe
 gadget.ep0 is a pointer 
 modify in register gadget process 
 name: Identifies the controller hardware type. 
 initialize qe_ep struct 
		 because the ep type isn't decide here so
		 setup the qe_ep struct and link ep.ep.list
 ep0 initialization in here 
 create a buf for ZLP send, need to remain zeroed 
 buffer for data of get_status request 
 request irq and disable DR  
 wait for release() of gadget.dev to free udc 
-------------------------------------------------------------------------
 SPDX-License-Identifier: GPL-2.0
  trace.c - USB Gadget Framework Trace Support
  Copyright (C) 2016 Intel Corporation
  Author: Felipe Balbi <felipe.balbi@linux.intel.com>
 SPDX-License-Identifier: GPL-2.0+
  Driver for the PLX NET2280 USB device controller.
  Specs and errata are available from <http:www.plxtech.com>.
  PLX Technology Inc. (formerly NetChip Technology) supported the
  development of this driver.
  CODE STATUS HIGHLIGHTS
  This driver should work well with most "gadget" drivers, including
  the Mass Storage, Serial, and EthernetRNDIS gadget drivers
  as well as Gadget Zero and Gadgetfs.
  DMA is enabled by default.
  MSI is enabled by default.  The legacy IRQ is used if MSI couldn't
  be enabled.
  Note that almost all the errata workarounds here are only needed for
  rev1 chips.  Rev1a silicon (0110) fixes almost all of them.
  Copyright (C) 2003 David Brownell
  Copyright (C) 2003-2005 PLX Technology, Inc.
  Copyright (C) 2014 Ricardo Ribalda - QtechnologyAS
  Modified Seth Levy 2005 PLX Technology, Inc. to provide compatibility
 	with 2282 chip
  Modified Ricardo Ribalda Qtechnology AS  to provide compatibility
 	with usb 338x chip. Based on PLX driver
 nonzero 
 GPIO pins control three LEDs 
 Default endpoint configuration 
 Endpoints for usb3380 advance mode 
 mode 0 == ep-{a,b,c,d} 1K fifo each
  mode 1 == ep-{a,b} 2K fifo each, ep-{c,d} unavailable
  mode 2 == ep-a 2K fifo, ep-{b,c} 1K each, ep-d unavailable
 "modprobe net2280 fifo_mode=1" etc 
 enable_suspend -- When enabled, the driver will respond to
  USB suspend requests by powering down the NET2280.  Otherwise,
  USB suspend requests will be ignored.  This is acceptable for
  self-powered devices
 "modprobe net2280 enable_suspend=1" etc 
-------------------------------------------------------------------------
 erratum 0119 workaround ties up an endpoint number 
 sanity check ep-eep-f since their fifos are small 
 ep_reset() has already been called 
 set speed-dependent max packet; may kick in high bandwidth 
 set type, direction, address; reset fifo counters 
 If USB ep number doesn't match hardware ep number 
 erratum 0105 workaround prevents hs NYET 
 catch some particularly blatant driver bugs 
 Enable this endpoint 
 default full fifo lines 
 In Legacy mode, only OUT endpoints are used 
 Make sure all the registers are written before ep_rsp
 for OUT transfers, block the rx fifo until a read is posted 
		 Added for 2282, Don't use nak packets on an in endpoint,
		  this was ignored on 2280
 enable irqs 
 pio, per-packet 
 dma, per-request 
 completion 
		 for short OUT transfers, dma completions can't
		  advance the queue; do it pio-style, by hand.
		  NOTE erratum 0112 workaround #2
 pci writes may still be posted 
 device unplugged 
 disable the dma, irqs, endpoint... 
 completion 
	 init to our chosen defaults, notably so that we NAK OUT
	  packets until the driver queues a read (+note erratum 0112)
 added for 2282 
 scrub most status bits, and flush any fifo state 
 fifo size is handled separately 
 disable the dma, irqs, endpoint... 
 | BIT(DMA_ABORT), 
 completion 
 synch memory views with the device 
-------------------------------------------------------------------------
 this dma descriptor may be swapped with the previous dummy 
 not VALID 
-------------------------------------------------------------------------
 load a packet into the fifo we use for usb IN transfers.
  works for all endpoints.
  NOTE: pio with ep-a..ep-d could stuff multiple packets into the fifo
  at a time, but this code is simpler because it knows it only writes
  one packet.  ep-a..ep-d should use dma instead.
 INVARIANT:  fifo is currently empty. (testable) 
 write just one packet at a time 
 min() cannot be used on a bitfield 
		 NOTE be careful if you try to align these. fifo lines
		  should normally be full (4 bytes) and successive partial
		  lines are ok only in certain cases.
	 last fifo entry is "short" unless we wrote a full packet.
	  also explicitly validate last word in (periodic) transfers
	  when maxpacket is not a multiple of 4 bytes.
 pci writes may still be posted 
 work around erratum 0106: PCI and USB race over the OUT fifo.
  caller guarantees chiprev 0100, out endpoint is NAKing, and
  there's no real data in the fifo.
  NOTE:  also used in cases where that erratum doesn't apply:
  where the host wrote "too much" data to us.
 Make sure that stap is written 
 high speed did bulk NYET; fifo isn't filling 
 64 byte bulkinterrupt 
 NAK done; now CLEAR_NAK_OUT_PACKETS is safe 
 unload packet(s) from the fifo we use for usb OUT transfers.
  returns true iff the request completed, because of short packet
  or the request buffer having filled with full packets.
  for ep-a..ep-d this will read multiple packets out when they
  have been accepted.
	 erratum 0106 ... packets coming in during fifo reads might
	  be incompletely rejected.  not all cases have workarounds.
 else: hope we don't see the problem 
	 never overflow the rx buffer. the fifo reads packets until
	  it sees a short one; we might not be ready for them all.
 handled that data already? 
 as with DMA, data overflow gets flushed 
			 NAK_OUT_PACKETS will be set, so flushing is safe;
			  the next read will start with the next packet
 else it's a ZLP, no worries 
 LE conversion is implicit here: 
 fill out dma descriptor to match a given request 
	 don't let DMA continue after a short OUT packet,
	  so overruns can't affect the next transfer.
	  in case of overruns on max-size packets, we can't
	  stop the fifo from filling but we can flush it.
 td->dmadesc = previously set by caller 
 2280 may be polling VALID_BIT through ep->dma->dmadesc 
 erratum 0116 workaround part 1 (use POLLING) 
 erratum 0116 workaround part 2 (no AUTOSTART) 
 erratum 0116 workaround part 3:  pci arbiter away from net2280 
 FIXME can't use DMA for ZLPs 
 on this path we "know" there's no dma active (yet) 
 previous OUT packet might have been short 
 transfer allsome fifo data 
 dma irq, faking scatterlist status 
	 force packet boundaries between dma requests, but prevent the
	  controller from automagically writing a last "short" packet
	  (zero length) unless the driver explicitly said to do that.
 init req->td, pointing to the current dummy 
 swap new dummy for old, link; fill and maybe activate 
 don't modify queue heads during completion callback 
-------------------------------------------------------------------------
	 we always require a cpu-view buffer, so that we can
	  always use pio (as fallback or whatever).
 FIXME implement PIO fallback for ZLPs with DMA 
 set up dma mapping in case the caller didn't 
 kickstart this io queue? 
 use DMA if the endpoint supports it, else pio 
 maybe there's no control data, just status ack 
 PIO ... stuff the fifo, or unblock it.  
 OUT FIFO might have packet(s) buffered 
					 note:  _req->short_not_ok is
					  ignored here since PIO _always_
					  stops queue advance here, and
					  _req->status doesn't change for
					  short reads (only _req->actual)
 don't queue it 
 don't NAK, let the fifo fill 
			 preventing magic zlps is per-engine state, not
			  per-transfer; irq logic must recover hiccups.
 else the irq handler advances the queue. 
 pci writes may still be posted 
	 only look at descriptors that were "naturally" retired,
	  so fifo and list head state won't matter
		 SHORT_PACKET_TRANSFERRED_INTERRUPT handles "usb-short"
		  cases where DMA must be aborted; this code handles
		  all non-abort DMA completions.
 paranoia 
 single transfer mode 
			 AVOID TROUBLE HERE by not issuing short reads from
			  your gadget driver.  That helps avoids errata 0121,
			  0122, and 0124; not all cases trigger the warning.
 fifo gets flushed later 
 abort the current transfer 
 FIXME work around errata 0121, 0122, 0124 
 dequeue ALL requests 
 called with spinlock held 
 dequeue JUST ONE request 
 quiesce dma while we patch the queue 
 WARNING erratum 0127 may kick in ... 
 make sure it's still queued on this endpoint 
 queue head may be partially complete. 
 NOTE: misreports single-transfer mode
 invalidate 
 turn off dma on inactive queues 
 resume current request, or start new one 
-------------------------------------------------------------------------
 not ep0  && (ep->desc->bmAttributes & 0x03)
 setclear, then synch memory views with the device 
-------------------------------------------------------------------------
 pci writes may still be posted 
 ep-e, ep-f are PIO with only 64 byte fifos 
	 USB3380: Only first four endpoints have DMA channels. Allocate
	  slower interrupt endpoints from PIO hw endpoints, to allow bulkisoc
	  endpoints use DMA hw endpoints.
 USB3380: use same address for usb and hardware endpoints 
-------------------------------------------------------------------------
 FIXME move these into procfs, and use seq_file.
  Sysfs _still_ doesn't behave for arbitrarily sized files,
  and also doesn't help products using this with 2.4 kernels.
 "function" sysfs attribute 
 Main Control Registers 
 USB Control Registers 
 full speed bit (6) not working?? 
 PCI Master Control Registers 
 DMA Control Registers 
 Configurable EP Control Registers 
 Indexed Registers (none yet) 
 Statistics 
 ep0 should only have one transfer queued 
-------------------------------------------------------------------------
 another driver-specific mode might be a request type doing dma
  tofrom another device fifo instead of tofrom memory.
 keeping high bits preserves BAR2 
 always ep-{a,b,e,f} ... maybe not ep-c or ep-d 
 fifo sizes for ep0, ep-c, ep-d, ep-e, and ep-f never change 
	
	  For Defect 7374, disable data EPs (and more):
	   - This phase undoes the earlier phase of the Defect 7374 workaround,
	     returing ep regs back to normal.
 CSROUT, CSRIN, PCIOUT, PCIIN, STATIN, RCIN 
 Select an endpoint for subsequent operations: 
 Change settings on some selected endpoints 
GPEPs:
 CSRIN, PCIIN, STATIN, RCIN
	Implemented for development and debug.
 Select an endpoint for subsequent operations: 
	 Set FSM to focus on the first Control Read:
	  - Tip: Connection speed is known upon the first
 keeping it simple:
  - one bus driver, initted first;
  - one function driver, initted second
  most of the work to support multiple net2280 controllers would
  be to associate this gadget driver (yes?) with all of them, or
  perhaps to bind specific drivers to specific devices.
 disable automatic responses, and irqs 
 clear old dma and irq state 
 reset, and enable pci 
 standard fifo and endpoint allocations 
 disable automatic responses, and irqs 
 clear old dma and irq state 
 reset, and enable pci 
 always ep-{1,2,3,4} ... maybe not ep-3 or ep-4 
 basic endpoint init 
	 we want to prevent lowlevelinsecure access from the USB host,
	  but erratum 0119 means this enable bit is ignored
 basic endpoint init 
			
			  Set USB endpoint number, hardware allows same number
			  in both directions.
 Link layer set up 
 Hardware Defect and Workaround 
	
	  AA_AB Errata. Issue 4. Workaround for SuperSpeed USB
	  Hot Reset Exit Handshake may Fail in Specific Case using
	  Default Register Settings. Workaround for Enumeration test.
	
	  AB errata. Errata 11. Workaround for Default Duration of LFPS
	  Handshake Signaling for Device-Initiated U1 Exit is too short.
	  Without this, various enumeration failures observed with
	  modern superspeed hosts.
	
	  Set Recovery Idle to Recover bit:
	  - On SS connections, setting Recovery Idle to Recover Fmw improves
	    link robustness with various hosts and hubs.
	  - It is safe to set for all connection speeds; all chip revisions.
	  - R-M-W to leave other bits undisturbed.
	  - Reference PLX TT-7372
 disable dedicated endpoints 
	
	  hardware optionally handles a bunch of standard requests
	  that the API hides from drivers anyway.  have it do so.
	  endpoint statusfeatures are handled in software, to
	  help pass tests for some dubious behavior.
 enable irqs so we can see ep0 and general operation  
 don't leave any writes posted 
	
	  hardware optionally handles a bunch of standard requests
	  that the API hides from drivers anyway.  have it do so.
	  endpoint statusfeatures are handled in software, to
	  help pass tests for some dubious behavior.
 enable irqs so we can see ep0 and general operation  
 don't leave any writes posted 
 when a driver is successfully registered, it will receive
  control requests including set_configuration(), which enables
  non-control requests.  then usb traffic follows until a
  disconnect is reported.  then a host may connect again, or
  the driver might get unbound.
	 insist on high speed support from the driver, since
	  (dev->usb->xcvrdiag & FORCE_FULL_SPEED_MODE)
	  "must not be used in normal operation"
 hook up the driver ... 
	 enable host detection and ep0; and we're ready
	  for set_configuration as well as eventual disconnect.
 pci writes may still be posted 
 don't disconnect if it's not connected 
	 stop hardware; prevent new request submissions;
	  and kill any outstanding requests.
 report disconnect; the driver is already quiesced 
-------------------------------------------------------------------------
 handle ep0, ep-e, ep-f with 64 byte packets: packet per irq.
  also works for dma-capable endpoints, in pio mode or just
  to manually advance the queue after short OUT transfers.
 0 error, 1 mid-data, 2 done 
 ack all, and handle what we care about 
 Added for 2282 
	 for ep0, monitor token irqs to catch data stage length errors
	  and to synchronize on status.
	 
	  also, to defer reporting of protocol stalls ... here's where
	  data or status first appears, handling stalls here should never
	  cause trouble on the host side..
	 
	  control requests could be slightly faster without token synch for
	  status, but status can jam up that way.
 status; stop NAKing 
 reply to extra IN data tokens with a zlp 
 status; stop NAKing 
 an extra OUT token is an error 
 manual DMA queue advance after short OUT 
			 TRANSFERRED works around OUT_DONE erratum 0112.
			  we expect (N <= maxpacket) bytes; host wrote M.
			  iff (M < N) we won't ever see a DMA interrupt.
				 any preceding dma transfers must finish.
				  dma handles (M >= N), may empty the queue
				 here either (M < N), a "real" short rx;
				  or (M == N) and the queue didn't empty
				 Escape loop if no dma transfers completed
				  after few retries.
 stop DMA, leave ep NAKing 
 also flush to prevent erratum 0106 trouble 
 (re)start dma if needed, stop NAKing 
 data packet(s) received (in the fifo, OUT) 
 data packet(s) transmitted (IN) 
 if we wrote it all, we're usually done 
 send zlps until the status stage 
 there was nothing to do ...  
 done 
 stream endpoints often resubmitunlink in completion 
 maybe advance queue to next request 
			 NOTE:  net2280 could let gadget driver start the
			  status stage later. since not all controllers let
			  them control that, the api doesn't (yet) allow it.
	 is there a buffer for the next packet?
	  for best streaming performance, make sure there is one.
 load IN fifo with next packet (may be zlp) 
 Workaround for Defect 7374 (U1U2 erroneously rejected): 
 This is the first Control Read for this connection: 
		
		  Connection is NOT SS:
		  - Connection must be FS or HS.
		  - This FSM state should allow workaround software to
		  run after the next USB connection.
 Connection is SS: 
		
		  We have not yet received host's Data Phase ACK
		  - Wait and try again.
	
	  Restore data EPs to their pre-workaround settings (disabled,
	  initialized, and other details).
			
			  Workaround for SS SeqNum not cleared via
			  Endpoint Halt (Clear) bit. select endpoint
 TD 9.9 Halt Endpoint test. TD 9.22 Set feature test 
 most of these don't need individual acks 
 ep_dbg(dev, "irqstat0 %04x\n", stat); 
 starting a control request? 
 make sure any leftover request state is cleared 
 ack the irq 
		 watch control traffic at the token level, and force
		  synchronization before letting the status stage happen.
		  FIXME ignore tokens we'll NAK, until driver responds.
		  that'll mean a lot less irqs for some drivers.
		 we made the hardware handle most lowlevel requests;
		  everything else goes uplevel to the gadget code.
 hw handles device and interface status 
 don't bother with a request object! 
 hw handles device features 
 hw handles device features 
 stall ep0 on error 
		 some inout token irq should follow; maybe stall then.
		  driver must queue a request (even zlp) or halt ep0
		  before the host times out.
 endpoint data irq ? 
 do this endpoint's FIFO and queue need tending? 
 after disconnect there's nothing else to do! 
	 VBUS disconnect is indicated by VBUS_PIN and VBUS_INTERRUPT set.
	  Root Port Reset is indicated by ROOT_PORT_RESET_INTERRUPT set and
	  both HIGH_SPEED and FULL_SPEED clear (as ROOT_PORT_RESET_INTERRUPT
	  only indicates a change in the reset state).
		
		  Ignore disconnects and resets if the speed hasn't been set.
		  VBUS can bounce and there's always an initial reset.
		 vBUS can bounce ... one of many reasons to ignore the
		  notion of hotplug events on bus connectdisconnect!
	 NOTE: chip stays in PCI D0 state for now, but it could
	  enter D1 to save more power
 at high speed, note erratum 0133 
 clear any other statusirqs 
 some status we can just ignore 
 ep_dbg(dev, "irqstat1 %08x\n", stat);
 DMA status, for ep-{a,b,c,d} 
 clear ep's dma status 
 dma sync
		 OUT transfers terminate when the data from the
		  host is in our memory.  Process whatever's done.
		  On this path, we know transfer's last packet wasn't
		  less than req->length. NAK_OUT_PACKETS may be set,
		  or the FIFO may already be holding new packets.
		 
		  IN transfers can linger in the FIFO for a very
		  long time ... we ignore that for now, accounting
		  precisely (like PIO does) needs per-packet irqs
 disable dma on inactive queues; else maybe restart 
	 NOTE:  there are other PCI errors we might usefully notice.
	  if they appear very often, here's where to try recovering.
		 these are fatal errors, but "maybe" they won't
		  happen again ...
 shared interrupt, not ours 
 handle disconnect, dma, and more 
 control requests and PIO 
 re-enable interrupt to trigger any possible new interrupt 
-------------------------------------------------------------------------
 tear down the binding between this driver and the pci device 
 then clean up the resources we allocated during probe() 
 wrap this driver around the specified device, but
  don't respond over USB until a gadget driver binds to us.
 alloc, and start init 
 the "gadget" abstractsvirtualizes the controller 
 now all the pci goodies ... 
	 BAR 0 holds all the registers
	  BAR 1 is 8051 memory; unused here (note erratum 0103)
	  BAR 2 is fifo memory; unused here
	 FIXME provide firmware download interface to put
	  8051 code into the chip, e.g. to turn on PCI PM.
 put into initial config, link up all endpoints 
 See if firmware needs to set up for workaround: 
 put into initial config, link up all endpoints 
 irq setup after old hardware is cleaned up 
 DMA setup 
 NOTE:  we know only the 32 LSBs of dma addresses may be nonzero 
 no alignment requirements ,
 or page-crossing issues );
 not VALID 
 enable lower-overhead pci memory bursts during DMA 
			
			  256 write retries may not be enough...
			   BIT(PCI_RETRY_ABORT_ENABLE) |
 erratum 0115 shouldn't appear: Linux inits PCI_LATENCY_TIMER 
 ... also flushes any posted pci writes 
 done 
 make sure the board is quiescent; otherwise it will continue
  generating IRQs across the upcoming reboot.
 disable IRQs 
 disable the pullup so the host will think we're gone 
-------------------------------------------------------------------------
 end: all zeroes  }
 pci driver glue; this is a "new style" PCI driver module 
 FIXME add power management support 
 SPDX-License-Identifier: GPL-2.0+
  aspeed-vhub -- Driver for Aspeed SoC "vHub" USB gadget
  epn.c - Generic endpoints management
  Copyright 2017 IBM Corporation
 There should be no DMA ongoing 
 Calculate next chunk size 
 If DMA unavailable, using staging EP buffer 
 For IN transfers, copy data over first 
 Start DMA 
 Read EP status 
 Grab current request if any 
 In absence of a request, bail out, must have been dequeued 
	
	  Request not active, move on to processing queue, active request
	  was probably dequeued
 Check if HW has moved on 
 No current DMA ongoing 
 Grab length out of HW 
 If not using DMA, copy data out if needed 
 Adjust size 
 Check for short packet 
 That's it ? complete the request and pick a new one 
		
		  Due to lock dropping inside "done" the next request could
		  already be active, so check for that and bail if needed.
	
	  d_next == d_last means descriptor list empty to HW,
	  thus we can only have AST_VHUB_DESCS_COUNT-1 descriptors
	  in the list
 Mark request active if not already 
 If the request was already completely written, do nothing 
 While we can create descriptors 
 Grab next free descriptor 
 Calculate next chunk size 
			
			  Is this the last packet ? Because of having up to 8
			  packets in a descriptor we can't just compare "chunk"
			  with ep.maxpacket. We have to see if it's a multiple
			  of it to know if we have to send a zero packet.
			  Sadly that involves a modulo which is a bit expensive
			  but probably still better than not doing it.
 Populate descriptor 
 Interrupt if end of request or no more descriptors 
		
		  TODO: Be smarter about it, if we don't have enough
		  descriptors request an interrupt before queue empty
		  or so in order to be able to populate more before
		  the HW runs out. This isn't a problem at the moment
		  as we use 256 descriptors and only put at most one
		  request in the ring.
 Account packet 
 Tell HW about new descriptors 
 Read EP status, workaround HW race 
 Extract RPTR 
 Grab current request if any 
 Check all completed descriptors 
 Grab next completed descriptor 
 Grab len out of descriptor 
 If no active request pending, move on 
 Adjust size 
 Is that the last chunk ? 
			
			  Because we can only have one request at a time
			  in our descriptor list in this implementation,
			  d_last and ep->d_last should now be equal
 Note: done will drop and re-acquire the lock 
 More work ? 
 Paranoid checks 
 Endpoint enabled ? 
	 Map request for DMA if possible. For now, the rule for DMA is
	  that:
	 
	    For single stage mode (no descriptors):
	 
	    - The buffer is aligned to a 8 bytes boundary (HW requirement)
	    - For a OUT endpoint, the request size is a multiple of the EP
	      packet size (otherwise the controller will DMA past the end
	      of the buffer if the host is sending a too long packet).
	 
	    For descriptor mode (tx only for now), always.
	 
	  We could relax the latter by making the decision to use the bounce
	  buffer based on the size of a given segment of the request rather
	  than the whole request.
 Initialize request progress fields 
 Add request to list and kick processing if empty 
 Stop DMA activity 
 Wait for it to complete 
 If we don't have to restart the endpoint, that's it 
 Restart the endpoint 
		
		  Take out descriptors by resetting the DMA read
		  pointer to be equal to the CPU write pointer.
		 
		  Note: If we ever support creating descriptors for
		  requests that aren't the head of the queue, we
		  may have to do something more complex here,
		  especially if the request being taken out is
		  not the current head descriptors.
 Then turn it back on 
 Single mode: just turn it back on 
 Make sure it's actually queued on this endpoint 
 Fail with still-busy IN endpoints 
 Stop active DMA if any 
 Disable endpoint 
 Disable ACK interrupt 
 Nuke all pending requests 
 No more descriptor associated with request 
 Check arguments 
 Check device state 
 Grab some info from the descriptor 
 Can we use DMA descriptor mode ? 
	
	  Large send function can send up to 8 packets from
	  one descriptor with a limit of 4095 bytes.
 Encode the rest of the EP config register 
 Disable HW and reset DMA 
 Configure and enable 
 Clear DMA status, including the DMA read ptr 
 Set descriptor base 
 Set base DMA config value 
 First reset and disable all operations 
 Enable descriptor mode 
 Set base DMA config value 
 Reset and switch to single stage mode 
 Cleanup data toggle just in case 
 Cleanup and enable ACK interrupt 
 Woot, we are online ! 
 Take it out of the EP list 
 Mark the address free in the device 
 Free name & DMA buffers 
 Mark free 
 Find a free one (no device) 
 Set it up 
 SPDX-License-Identifier: GPL-2.0+
  aspeed-vhub -- Driver for Aspeed SoC "vHub" USB gadget
  dev.c - Individual devicegadget management (ie, a port = a gadget)
  Copyright 2017 IBM Corporation
 Cleanup EP0 state 
 Enable device and its EP0 interrupts 
 Enable device interrupt in the hub as well 
 Set EP0 DMA buffer address 
 Clear stall on all EPs 
 Additional cleanups 
 Disable device interrupt in the hub 
 Then disable device 
 No driver, we shouldn't be enabled ... 
	
	  Note: we used to rejectstall requests while suspended,
	  we don't do that anymore as we seem to have cases of
	  mass storage getting very upset.
 First packet, grab speed 
 SET_ADDRESS 
 GET_STATUS 
 SETCLEAR_FEATURE 
 Wakeup the host 
 Mark disconnected in the hub 
	
	  If enabled, nuke all requests if any (there shouldn't be)
	  and disable the port. This will clear the address too.
 We don't do much more until the hub enables us 
	
	  First we need to look for an existing unclaimed EP as another
	  configuration may have already associated a bunch of EPs with
	  this gadget. This duplicates the code in usb_ep_autoconfig_ss()
	  unfortunately.
	
	  We didn't find one, we need to grab one from the pool.
	 
	  First let's do some sanity checking
 Only EP0 can be a control endpoint 
 ISO:	 limit 1023 bytes full speed, 1024 highsuper speed 
	
	  Find a free EP address for that device. We can't
	  let the generic code assign these as it would
	  create overlapping numbers for IN and OUT which
	  we don't support, so also create a suitable name
	  that will allow the generic code to use our
	  assigned address.
	
	  Now grab an EP from the shared pool and associate
	  it with our device
 No driver, just disable the device and return 
 If the port isn't enabled, just enable it 
		
		  Disable and maybe re-enable HW, this will clear the address
		  and speed setting.
	
	  A USB device can have up to 30 endpoints besides control
	  endpoint 0.
	
	  The UDC core really needs us to have separate and uniquely
	  named "parent" devices for each port so we create a sub device
	  here for that purpose
 Populate gadget 
 SPDX-License-Identifier: GPL-2.0+
  aspeed-vhub -- Driver for Aspeed SoC "vHub" USB gadget
  core.c - Top level support
  Copyright 2017 IBM Corporation
	
	  If this isn't an internal EP0 request, call the core
	  to call the gadget completion.
 Beware, lock will be dropped & req-acquired by done() 
 Stale interrupt while tearing down 
 Read and ACK interrupts 
 Handle generic EPs first 
 Handle device interrupts 
 Handle top-level vHub EP0 interrupts 
 Various top level bus events 
 Enable PHY 
	 We do NOT set the VHUB_CTRL_CLK_STOP_SUSPEND bit
	 to stop the logic clock during suspend because
	 it causes the registers to become inaccessible and
	 we haven't yet figured out a good wayt to bring the
	 controller back into life to issue a wakeup.
	
	  Set some ISO & split control bits according to Aspeed
	  recommendation
	 
	  VHUB_CTRL_ISO_RSP_CTRL: When set tells the HW to respond
	  with 0 bytes data packet to ISO IN endpoints when no data
	  is available.
	 
	  VHUB_CTRL_SPLIT_IN: This makes a SOF complete a split IN
	  transaction.
 Set descriptor ring size 
 Reset all devices 
 Disable and cleanup EP ACKNACK interrupts 
 Default settings for EP0, enable HW hub EP1 
 Configure EP0 DMA buffer 
 Clear address 
 Pullup hub (activate on host) 
 Enable some interrupts 
 Remove devices 
 Mask & ack all interrupts  
 Pull device, leave PHY enabled 
 Check if we need to limit the HW to USB1 
 Mask & ack all interrupts before installing the handler 
 Find interrupt and install handler 
	
	  Allocate DMA buffers for all EP0s in one chunk,
	  one per port and one for the vHub itself
 Init vHub EP0 
 Init devices 
 Init hub emulation 
 Initialize HW 
 SPDX-License-Identifier: GPL-2.0+
  aspeed-vhub -- Driver for Aspeed SoC "vHub" USB gadget
  hub.c - virtual hub handling
  Copyright 2017 IBM Corporation
 usb 2.0 hub device descriptor
  A few things we may want to improve here:
     - We may need to indicate TT support
     - We may need a device qualifier descriptor
 	as devices can pretend to be usb1 or 2
     - Make viddid overridable
     - make it look like usb1 if usb1 mode forced
  Configuration descriptor: same comments as above
  regarding handling USB1 mode.
  We don't use sizeof() as Linux definition of
  struct usb_endpoint_descriptor contains 2
  extra bytes
  These strings converted to UTF-16 must be smaller than
  our EP0 buffer.
	
	  Mark it as self-powered, I doubt the BMC is powered off
	  the USB bus ...
	
	  Need to double check how remote wakeup actually works
	  on that chip and what triggers it.
 On the hub we have only EP 0 and 1 
	
	  Copy first to EP buffer and send from there, so
	  we can do some in-place patching if needed. We know
	  the EP buffer is big enough but ensure that doesn't
	  change. We do that now rather than later after we
	  have checked sizes etc... to avoid a gcc bug where
	  it thinks len is constant and barfs about read
	  overflows in memcpy.
 Crop requested length 
 Shoot it from the EP buffer 
 Shoot it from the EP buffer 
 First packet, grab speed 
 SET_ADDRESS 
 GET_STATUS 
 SETCLEAR_FEATURE 
 GETSET_CONFIGURATION 
 GET_DESCRIPTOR 
 GETSET_INTERFACE 
 Update HW EP1 response 
 Update port status 
 Update change bits if needed 
 Only these are relevant for change 
		
		  We only set USB_PORT_STAT_C_ENABLE if we are disabling
		  the port as per USB spec, otherwise MacOS gets upset
	
	  If the hub is set to wakup the host on connection events
	  then send a wakeup.
	
	  Wake all sleeping ports. If a port is suspended by
	  the host suspend (without explicit state suspend),
	  we let the normal host wake path deal with it later.
	
	  A device is trying to wake the world, because this
	  can recurse into the device, we break the call chain
	  using a work queue
 First mark disabled 
	
	  This will either "start" the port or reset the
	  device if already started...
 Grab the right speed 
 This should ideally be delayed ... 
		
		  On Power-on, we mark the connected flag changed,
		  if there's a connected device, some hosts will
		  otherwise fail to detect it.
 We don't do anything with these 
 We don't do power control 
 We don't have indicators 
 Clear state-change feature 
 We always have power 
 No feature, just complete the requests 
	
	  Forward to unsuspended ports without changing
	  their connection status.
	
	  Forward to unsuspended ports without changing
	  their connection status.
	
	  Is the speed known ? If not we don't care, we aren't
	  initialized yet and ports haven't been enabled.
 We aren't suspended anymore obviously 
 No speed set 
 Wakeup not enabled anymore 
	
	  Clear all port status, disable gadgets and "suspend"
	  them. They will be woken up by a port reset.
 Only keep the connected flag 
 Suspend the gadget if any 
 Cleanup HW 
 no language identifier specified 
 invalid language identifier 
 Initialize vhub Device Descriptor. 
 Initialize vhub Configuration Descriptor. 
 Initialize vhub Hub Descriptor. 
 Initialize vhub String Descriptors. 
 SPDX-License-Identifier: GPL-2.0+
  aspeed-vhub -- Driver for Aspeed SoC "vHub" USB gadget
  ep0.c - Endpoint 0 handling
  Copyright 2017 IBM Corporation
	
	  Call internal queue directly after dropping the lock. This is
	  safe to do as the reply is always the last thing done when
	  processing a SETUP packet, usually as a tail call
 Copy data directly into EP buffer 
 req->buf NULL means data is already there 
	
	  Grab the setup packet from the chip and byteswap
	  interesting fields
	
	  Check our state, cancel pending requests if needed
	 
	  Note: Under some circumstances, we can get a new setup
	  packet while waiting for the stall ack, just accept it.
	 
	  In any case, a SETUP packet in wrong state should have
	  reset the HW state machine, so let's just log, nuke
	  requests, move on.
 Calculate next state for EP0 
 If this is the vHub, we handle requests differently 
 Act upon result 
 Pass request up to the gadget driver 
	 If this is a 0-length request, it's the gadget trying to
	  send a status on our behalf. We take it from here.
 Are we done ? Complete request, otherwise wait for next interrupt 
	
	  Next chunk cropped to max packet size. Also check if this
	  is the last packet
	
	  Copy data if any (internal requests already have data
	  in the EP buffer)
 Remember chunk size and trigger send 
 Prime endpoint for receiving data 
 We are receiving... grab request 
 Are we getting more than asked ? 
 Done ? 
 Read EP0 status 
 Grab current request if any 
 There should be no request queued in that state... 
 Check the state bits corresponding to our direction 
 In that case, ignore interrupt 
		
		  We are in data phase and there's no request, something is
		  wrong, stall
 We have a request, handle data transfers 
 Nuke stale requests 
		
		  If the status phase completes with the wrong ack, stall
		  the endpoint just in case, to abort whatever the host
		  was doing.
		
		  There shouldn't be any request left, but nuke just in case
		  otherwise the stale request will block subsequent ones
 Reset to token state or stall 
 Paranoid cheks 
 Not endpoint 0 ? 
 Disabled device 
 Data, no buffer and not internal ? 
 Initialize request progress fields 
 EP0 can only support a single request at a time 
 Add request to list and kick processing if empty 
 IN request, send data 
 0-len request, send completion as rx 
 OUT request, start receiver 
 Only one request can be in the queue 
 Is it ours ? 
		
		  We don't have to deal with "active" as all
		  DMAs go to the EP buffers, not the request.
 We do stall the EP to clean things up in HW 
 Small difference between vHub and devices 
 SPDX-License-Identifier: GPL-2.0+
  bdc_udc.c - BRCM BDC USB3.0 device controller gagdet ops
  Copyright (C) 2014 Broadcom Corporation
  Author: Ashwini Pahuja
  Based on drivers under driversusbgadgetudc
 EP0 initial descripror 
 Advance the srr dqp maintained by SW 
 rollback to 0 if we are past the last 
 connect sr 
 Enable U1T in SS mode 
 Now we know the speed, configure ep0 
 device got disconnected 
	
	  Only stop ep0 from here, rest of the endpoints will be disabled
	  from gadget_disconnect
 if enabled then stop and remove requests 
 Set Unknown speed 
 TNotify wkaeup timer 
	
	  Check if host has started transferring on endpoints
	  FUNC_WAKE_ISSUED is cleared when transfer has started after resume
 flag is still set, so again send func wake 
 handler for Link state change condition 
				
				  Start a Notification timer and check if the
				  Host transferred anything on any of the EPs,
				  if not then send function wake again every
				  TNotification secs until host initiates
				  transfer to BDC, USB3 spec Table 8.13
 something changes on upstream port, handle it here 
 Port connect changed 
 Vbus not present, and not connected to Downstream port 
 Change in VBus and VBus is present 
 Attached state, do a softconnect 
 Hot reset, warm reset, 2.0 bus reset or disconn 
 Change in Link state 
	
	  In SS we might not have PRC bit set before connection, but in 2.0
	  the PRC bit is set before connection, so moving this condition out
	  of bus reset to handle both SS2.0 speeds.
 This is the connect event for U0L0 
 Main interrupt handler for bdc 
 Check if the SRR IP bit it set? 
 check for ring empty condition 
 sreport is read before using it 
 Advance the srr dqp index 
 update the hw dequeue pointer 
 Gadget ops 
	
	  Run the controller from here and when BDC is connected to
	  Host then driver will receive a USPC SR with VBUS present
	  and then driver will do a softconnect.
		
		  For a self powered device, we need to wait till we receive
		  a VBUS change and Vbus present event, then if pullup flag
		  is set, then only we present the Termintation.
		
		  Check if BDC is already connected to Host i.e Vbus=1,
		  if yes, then present TERM now, this is typical for bus
		  powered devices.
 Init the gadget interface and register the udc 
	
	  Allocate bd list for ep0 only, ep0 will be enabled on connect
	  status report when the speed is known
 Enable Interrupts 
 SPDX-License-Identifier: GPL-2.0+
  bdc_ep.c - BRCM BDC USB3.0 device controller endpoint related functions
  Copyright (C) 2014 Broadcom Corporation
  Author: Ashwini Pahuja
  Based on drivers under driversusb
 Free the bdl during ep disable 
		
		  check if the bd_table struct is allocated ?
		  if yes, then check if bd memory has been allocated, then
		  free the dma_pool and also the bd_table struct memory
 Free the bd_table structure 
 Free the bd table array 
  chain the tables, by insteting a chain bd at the end of prev_table, pointing
  to next_table
 Chain the prev table to next table 
 Allocate the bdl for ep, during config ep 
 if there is only 1 table in bd list then loop chain to self 
 Allocate memory for table array 
 Allocate memory for each table 
 Allocate memory for bd_table structure 
 Memory allocation is successful, now init the internal fields 
 Free the bd_table_array, bd_table struct, bd's 
 returns how many bd's are need for this transfer 
 1 bd needed for 0 byte transfer 
 remaining bytes after tranfering all max BD size BD's 
 How many maximum BUFF size BD's ? 
 returns the bd index(bdi) corresponding to bd dma address 
	
	  Find in which table this bd_dma_addr belongs?, go through the table
	  array and compare addresses of first and last address of bd of each
	  table
 Now we know the table, find the bdi 
 return the global bdi, to compare with ep eqp_bdi 
 returns the table index(tbi) of the given bdi 
 Find the bdi last bd in the transfer 
  How many transfer bd's are available on this ep bdl, chain bds are not
  counted in available bds
 if empty then we have all bd's available - number of chain bd's 
	
	  Depending upon where eqp and dqp pointers are, caculate number
	  of avaialble bd's
 available bd's are from eqp..max_bds + 0..dqp - chain_bds 
 available bd's are from eqp..dqp - number of chain bd's 
 if gap between eqp and dqp is less than NUM_BDS_PER_TABLE 
 If there any chain bd in between 
	
	  we need to keep one extra bd to check if ring is full or empty so
	  reduce by 1
 Notify the hardware after queueing the bd to bdl 
	
	  We don't have anyway to check if ep state is running,
	  except the software flags.
 returns the bd corresponding to bdi 
 Advance the enqueue pointer 
 if it's chain bd, then move to next 
 if the eqp is pointing to last + 1 then move back to 0 
 Setup the first bd for ep0 transfer 
 check if zlp will be needed 
 Setup the bd dma descriptor for a given request 
 First bd 
 format of first bd for ep0 is different than other 
 this should be the last bd 
 Currently only 1 INT target is supported 
 write bd 
 advance eqp pointer 
 advance the buff pointer 
 clear the STOP BD fetch bit from the first bd of this xfr 
 the new eqp will be next hw dqp 
 everything is written correctly before notifying the HW 
 Queue the xfr 
 how many bd's are avaialble on ep 
 callback to gadget layer when xfr completes 
 Disable the endpoint 
 Stop the endpoint 
	
	  Intentionally don't check the ret value of stop, it can fail in
	  disconnect scenarios, continue with dconfig
 de-queue any pending requests 
 deconfigure the endpoint 
 ep0 memory is not freed, but reused on next connect sr 
 Free the bdl memory 
 Enable the ep 
 only for ep0: config ep is called for ep0 from connect event 
 Issue a configure endpoint command 
 EP0 related code 
 Queue a status stage BD 
 Queue xfr on ep0 
 if status stage was delayed? 
 Queue a status stage BD 
		
		  if delayed status is false and 0 length transfer is requested
		  i.e. for status stage of some setup request, then just
		  return from here the status stage is queued independently
 Queue data stage 
 Queue req on ep 
 Dequeue a request from ep 
 if still connected, stop the ep to see where the HW is ? 
 if there is an issue, then no need to go further 
	
	  After endpoint is stopped, there can be 3 cases, the request
	  is processed, pending or in the middle of processing
 The current hw dequeue pointer 
 we have the dma addr of next bd that will be fetched by hardware 
	
	  curr_hw_dqpi points to actual dqp of HW and HW owns bd's from
	  curr_hw_dqbdi..eqp_bdi.
 Check if start_bdi and end_bdi are in range of HW owned BD's 
 there is a wrap from last to 0 
 If both start till end are processes, we cannot deq req 
	
	  if ep_dequeue is called after disconnect then just return
	  success from here
	
	  Due to HW limitation we need to bypadd chain bd's and issue ep_bla,
	  incase if start is pending this is the first request in the list
	  then issue ep_bla instead of marking as chain bd
		
		  Mark the start bd as Chain bd, and point the chain
		  bd to next_bd_dma
		
		  The transfer is stopped in the middle, move the
		  HW deq pointer to next_bd_dma
 HaltClear the ep based on value 
 Clear 
 Free all the ep 
 ep0 is not in this gadget list 
 USB2 spec, section 7.1.20 
  Helper function to handle Transfer status report with status as either
  success or short
 do not process thie sr if ignore flag is set 
	
	  sr_status is short and this transfer has more than 1 bd then it needs
	  special handling,  this is only applicable for bulk and ctrl
		
		  This is multi bd xfr, lets see which bd
		  caused short transfer and how many bytes have been
		  transferred so far.
		
		  We know the start_bdi and short_bdi, how many xfr
		  bds in between
 there is a wrap in the ring within a xfr 
 max_len_bds is the number of full length bds 
 length queued 
 actual length trensfered 
 Update the dequeue pointer 
 EP0 setup related packet handlers 
  Setup packet received, just store the packet and process on next DS or SS
  started SR
 Store received setup packet 
 Stall ep0 
 de-queue any pendig requests 
 SET_ADD handlers 
 Issue Address device command 
 Handler for SETCLEAR FEATURE requests for device 
 clear previous u1t 
 USB_RECIP_DEVICE end 
 SETCLEAR FEATURE handler 
 USB3 spec, sec 9.4.9 
 USB3 spec, Table 9-8 
EP0
		
		  If CLEAR_FEATURE on ep0 then don't do anything as the stall
		  condition on ep0 has already been cleared when SETUP packet
		  was received.
 GET_STATUS request handler 
 USB2.0 spec sec 9.4.5 
 USB3 spec, sec 9.4.5 
			
			  This should come from func for Func remote wkup
			  usb_status |=1;
 EP0 
 prepare a data stage for GET_STATUS 
 ep0_set_sel_cmpl 
 Queue data stage to handle 6 byte SET_SEL request 
  Queue a 0 byte bd only if wLength is more than the length and length is
  a multiple of MaxPacket then queue 0 byte BD
 Control request handler 
				
				  USB2 spec sec 9.4.7, if wValue is 0 then dev
				  is moved to addressed state
 EP0: Data stage started 
 If ep0 was stalled, the clear it first 
		
		  The ep0 state will remain WAIT_FOR_DATA_START till
		  we received ep_queue on ep0
 EP0: status stage started 
 check if ZLP was queued? 
 check if data stage is in progress ? 
 Status stage will be queued upon Data stage transmit event 
	
	  2 stage setup then only process the setup, for 3 stage setup the date
	  stage is already handled
 ep0_state will remain WAIT_FOR_STATUS_START 
 Queue a status stage BD 
 Helper function to update ep0 upon SR with xsf_succ or xsf_short 
 xfr completion status report handler 
	
	  check if this transfer is after link went from U3->U0 due
	  to remote wakeup
			
			  If the last completed transfer had wLength >Data Len,
			  and Len is multiple of MaxPacket,then queue ZLP
 queue 0 length bd 
 make sure it's still queued on this endpoint 
 endpoint operations 
 configure endpoint and also allocate resources 
 Sanity check, upper layer will not send enable for ep0 
 Upper layer will not call this for ep0, but do a sanity check 
 dir = 1 is IN 
 ep->ep_num is the index inside bdc_ep 
 Init all ep 
 init ep0 
 OUT 
 IN 
 SPDX-License-Identifier: GPL-2.0+
  bdc_cmd.c - BRCM BDC USB3.0 device controller
  Copyright (C) 2014 Broadcom Corporation
  Author: Ashwini Pahuja
 Issues a cmd to cmd processor and waits for cmd completion 
 Issue the cmd 
 Make sure the cmd params are written before asking HW to exec cmd 
 Submits cmd and analyze the return value of bdc_issue_cmd 
 Deconfigure the endpoint from HW 
 Reinitalize the bdlist after config ep command 
 Configure an endpoint 
 the hardware accepts SI in 125usec range 
		
		  FS Int endpoints can have si of 1-255ms but the controller
		  accepts 2^bInterval125usec, so convert ms to nearest power
		  of 2
  Change the HW deq pointer, if this command is successful, HW will start
  fetching the next bd from address dma_addr.
 Set the address sent bu Host in SET_ADD request 
 Send a Function Wake notification packet using FH command 
 Send a Function Wake notification packet using DNC command 
 Stall the endpoint 
 issue a stall endpoint command 
 resets the endpoint, called when host sends CLEAR_FEATURE(HALT) 
	
	  If we are not in stalled then stall Endpoint and issue clear stall,
	  his will reset the seq number for non EP0.
 if the endpoint it not stallled 
 Preserve the seq number for ep0 only 
 issue a reset endpoint command 
 Stop the endpoint, called when software wants to dequeue some request 
 Endpoint has to be in running state to execute stop ep command 
 issue a stop endpoint command 
 SPDX-License-Identifier: GPL-2.0+
  bdc_core.c - BRCM BDC USB3.0 device controller core operations
  Copyright (C) 2014 Broadcom Corporation
  Author: Ashwini Pahuja
 Poll till controller status is not OIP 
 Stop the BDC controller 
 Check if BDC is already halted 
 Issue a reset to BDC controller 
 First halt the controller 
 Run the BDC controller 
 if BDC is already in running state then do not do anything 
  Present the termination to the host, typically called from upstream port
  event with Vbus present =1
 Remove the termination 
 Set up the scratchpad buffer array and scratchpad buffers, if needed. 
 Refer to BDC spec, Table 4 for description of SPB 
 Allocate the status report ring 
 Reset the SRR 
 allocate the status report descriptors 
 Initialize the HW regs and internal data structures 
 Init the SRR 
 Reset the SRR 
 Write the dma addresses into regs
 Set the Interrupt Coalescence ~500 usec 
 Enable hardware LPM Enable 
 readback for debug 
 Disable any unwanted SR's on SRR 
 We don't want Microframe counter wrap SR 
	
	  In some error cases, driver has to reset the entire BDC controller
	  in that case reinit is passed as 1
 Enable interrupts 
 Init scratchpad to 0 
 Initialize SRR to 0 
		
		  clear ep flags to avoid post disconnect stopsdeconfigs but
		  not during S2 exit
 One time initiaization only 
 Enable status report function pointers 
 EP0 status report function pointers 
 Free the dynamic memory 
 Free SRR 
 Free scratchpad 
 Destroy the dma pools 
 Free the bdc_ep array 
  bdc reinit gives a controller reset and reinitialize the registers,
  called from disconnectbus reset scenario's, to ensure proper HW cleanup
 the reinit flag is 1 
 Allocate all the dyanmic memory 
 page size is 2^pgs KB 
 KB 
 Create a pool of bd tables 
 read from regs 
 +2: 1 for ep0 and the other is rsvd i.e. bdc_ep[0] is rsvd 
 allocate array of ep pointers 
 opposite to bdc_hw_init 
 Initialize the bdc HW and memory 
 Halt the controller 
 CONFIG_PM_SLEEP 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0+
  bdc_dbg.c - BRCM BDC USB3.0 device controller debug functions
  Copyright (C) 2014 Broadcom Corporation
  Author: Ashwini Pahuja
 SPDX-License-Identifier: GPL-2.0+
  f_hid.c -- USB HID function driver
  Copyright (C) 2010 Fabien Chouteau <fabien.chouteau@barco.com>
 protects access to hidg_ida 
-------------------------------------------------------------------------
                            HID gadget struct                            
 configuration 
	
	  use_out_ep - if true, the OUT Endpoint (interrupt out method)
	               will be used to receive reports from the host
	               using functions with the "intout" suffix.
	               Otherwise, the OUT Endpoint will not be configured
	               and the SETUPSET_REPORT method ("ssreport" suffix)
	               will be used to receive reports.
 recv report 
 recv report - interrupt out only (use_out_ep == 1) 
 recv report - setup set_report only (use_out_ep == 0) 
 send report 
-------------------------------------------------------------------------
                           Static descriptors                            
 .bInterfaceNumber	= DYNAMIC 
 .bNumEndpoints	= DYNAMIC (depends on use_out_ep) 
 .bInterfaceSubClass	= DYNAMIC 
 .bInterfaceProtocol	= DYNAMIC 
 .iInterface		= DYNAMIC 
.desc[0].bDescriptorType	= DYNAMIC 
.desc[0].wDescriptorLenght	= DYNAMIC 
 Super-Speed Support 
.wMaxPacketSize	= DYNAMIC 
	.bInterval		= 4,  FIXME: Add this field in the
				       HID gadget configuration?
				       (struct hidg_func_descriptor)
 .bMaxBurst           = 0, 
 .bmAttributes        = 0, 
 .wBytesPerInterval   = DYNAMIC 
.wMaxPacketSize	= DYNAMIC 
	.bInterval		= 4,  FIXME: Add this field in the
				       HID gadget configuration?
				       (struct hidg_func_descriptor)
 .bMaxBurst           = 0, 
 .bmAttributes        = 0, 
 .wBytesPerInterval   = DYNAMIC 
 High-Speed Support 
.wMaxPacketSize	= DYNAMIC 
	.bInterval		= 4,  FIXME: Add this field in the
				       HID gadget configuration?
				       (struct hidg_func_descriptor)
.wMaxPacketSize	= DYNAMIC 
	.bInterval		= 4,  FIXME: Add this field in the
				       HID gadget configuration?
				       (struct hidg_func_descriptor)
 Full-Speed Support 
.wMaxPacketSize	= DYNAMIC 
	.bInterval		= 10,  FIXME: Add this field in the
				        HID gadget configuration?
				        (struct hidg_func_descriptor)
.wMaxPacketSize	= DYNAMIC 
	.bInterval		= 10,  FIXME: Add this field in the
				        HID gadget configuration?
				        (struct hidg_func_descriptor)
-------------------------------------------------------------------------
                                 Strings                                 
 end of list 
 en-US 
-------------------------------------------------------------------------
                              Char Device                                
 wait for at least one buffer to complete 
 pick the first one 
	
	  Remove this from list to protect it from beign free()
	  while host disables our function
 copy to user outside spinlock 
	
	  if this request is completely handled and transfered to
	  userspace, remove its entry from the list and requeue it
	  again. Otherwise, we will revisit it again upon the next
	  call, taking into account its current read position.
 write queue 
 when our function has been disabled by host 
		
		  TODO
		  Should we fail with error here?
-------------------------------------------------------------------------
                                usb_function                             
 hardware forced ep reset 
 request dequeued 
 disconnect from host 
 send an empty report 
		
		  We assume that programs implementing the Boot protocol
		  are also compatible with the Report Protocol
 restart endpoint 
 restart endpoint 
		
		  allocate a bunch of read buffers and queue them all at once.
 maybe allocate device-global string IDs, and patch descriptors 
 allocate instance-specific interface IDs, and patch descriptors 
 allocate instance-specific endpoints 
 used only if use_out_ep == 1 
 set descriptor dynamic values 
	
	  We can use hidg_desc struct here but we should not relay
	  that its content won't change after returning from this function.
 create char device 
 allocate and initialize one new instance 
 this could be made configurable at some point 
 SPDX-License-Identifier: GPL-2.0+
  f_eem.c -- USB CDC Ethernet (EEM) link function driver
  Copyright (C) 2003-2005,2008 David Brownell
  Copyright (C) 2008 Nokia Corporation
  Copyright (C) 2009 EF Johnson Technologies
  This function is a "CDC Ethernet Emulation Model" (CDC EEM)
  Ethernet link.
-------------------------------------------------------------------------
 interface descriptor: 
 .bInterfaceNumber = DYNAMIC 
 .iInterface = DYNAMIC 
 full speed support: 
 CDC EEM control descriptors 
 high speed support: 
 CDC EEM control descriptors 
 super speed support: 
 the following 2 values can be tweaked if necessary 
 .bMaxBurst =		0, 
 .bmAttributes =	0, 
 CDC EEM control descriptors 
 string descriptors: 
 end of list 
 en-us 
-------------------------------------------------------------------------
 device either stalls (value < 0) or reports success 
 we know alt == 0, so this is an activation or a reset 
		 zlps should not occur because zero-length EEM packets
		  will be inserted in those cases where they would occur
-------------------------------------------------------------------------
 EEM function driver setupbinding 
	
	  in driversusbgadgetconfigfs.c:configfs_composite_bind()
	  configurations are bound in sequence with list_for_each_entry,
	  in each configuration its functions are bound in sequence
	  with list_for_each_entry, so we assume no race condition
	  with regard to eem_opts->bound access
 allocate instance-specific interface IDs 
 allocate instance-specific endpoints 
	 support all relevant hardware speeds... we expect that when
	  hardware is dual speed, all bulk-capable endpoints work at
	  both speeds
  Add the EEM header and ethernet checksum.
  We currently do not attempt to put multiple ethernet frames
  into a single USB transfer
	 When (len + EEM_HLEN + ETH_FCS_LEN) % in->maxpacket) is 0,
	  stick two bytes of zero-length EEM packet on the end.
 use the "no CRC" option 
	 EEM packet header format:
	  b0..13:	length of ethernet frame
	  b14:		bmCRC (0 == sentinel CRC)
	  b15:		bmType (0 == data)
 add a zero-length EEM packet, if needed 
  Remove the EEM header.  Note that there can be many EEM packets in a single
  USB transfer, so we need to break them out and handle them independently.
 remove the EEM header 
		 EEM packet header format:
		  b0..14:	EEM type dependent (data or command)
		  b15:		bmType (0 == data, 1 == command)
			 EEM command packet format:
			  b0..10:	bmEEMCmdParam
			  b11..13:	bmEEMCmd
			  b14:		reserved (must be zero)
			  b15:		bmType (1 == command)
 echo 
 echo response 
 suspend hint 
 response hint 
 response complete hint 
 tickle 
 reserved 
 check for zero-length EEM packet 
			 EEM data packet format:
			  b0..13:	length of ethernet frame
			  b14:		bmCRC (0 == sentinel, 1 == calculated)
			  b15:		bmType (0 == data)
 validate CRC 
 f_eem_item_ops 
 f_eem_opts_dev_addr 
 f_eem_opts_host_addr 
 f_eem_opts_qmult 
 f_eem_opts_ifname 
 allocate and initialize one new instance 
 descriptors are per-instance copies 
 SPDX-License-Identifier: GPL-2.0+
  f_printer.c - USB printer function driver
  Copied from driversusbgadgetlegacyprinter.c,
  which was:
  printer.c -- Printer gadget driver
  Copyright (C) 2003-2005 David Brownell
  Copyright (C) 2006 Craig W. Nadler
 same as legacy g_printer gadget 
 protects access do printer_ida 
-------------------------------------------------------------------------
 lock this structure 
 lock buffer lists during readwrite calls 
 List of free RX structs 
 List of Active RX xfers 
 List of completed xfers 
 wait until there is data to be read. 
 List of free TX structs 
 List of Active TX xfers 
 Wait until there are write buffers available to use. 
 Wait until all write buffers have been sent. 
 We don't own memory! 
-------------------------------------------------------------------------
  DESCRIPTORS ... most are static, but strings and (full) configuration
  descriptors are built on demand.
 holds our biggest descriptor 
 Printer Sub-Class 
 Bi-Directional 
  usb 2.0 devices need to expose both high speed and full speed
  descriptors, unless they only run at full speed.
  Added endpoint descriptors for 3.0 devices
 maxpacket and other transfer characteristics vary by speed. 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 Remode from Active List 
 normal completion 
 software-driven interface shutdown 
 unlink 
 disconnect etc 
 for hardware automagic (such as pxa) 
 endpoint reset 
 data overrun 
 unlink 
 disconnect etc 
	 Take the request struct off the active list and put it on the
	  free list.
-------------------------------------------------------------------------
 Change the printer status to show that it's on-line. 
 Change printer status to show that the printer is off-line. 
 This function must be called with interrupts turned off. 
		 The USB Host sends us whatever amount of data it wants to
		  so we always set the length field to the full USB_BUFSIZE.
		  If the amount of data is more than the read() caller asked
		  for it will be stored in the request buffer until it is
		  asked for by read().
 here, we unlock, and only unlock, to avoid deadlock. 
 if the req is empty, then add it into dev->rx_reqs_active. 
 This is a pointer to the current USB rx request. 
 This is the number of bytes in the current rx buffer. 
 This is a pointer to the current rx buffer. 
	 We will use this flag later to check if a printer reset happened
	  after we turn interrupts back on.
	 Check if there is any data in the read buffers. Please note that
	  current_rx_bytes is the number of bytes in the current rx buffer.
	  If it is zero then check if there are any other rx_buffers that
	  are on the completed list. We are only out of data if all rx
	  buffers are empty.
 Turn interrupts back on before sleeping. 
		
		  If no data is available check if this is a NON-Blocking
		  call or not.
 Sleep until data is available 
 We have data to return then copy it to the caller's buffer.
 Don't leave irqs off while doing memory copies 
 We've disconnected or reset so return. 
		 If we not returning all the data left in this RX request
		  buffer then adjust the amount of data left in the buffer.
		  Othewise if we are done with this RX request buffer then
		  requeue it to get any incoming data from the USB host.
 Amount of data in a TX request. 
 Check if a printer reset happens while we have interrupts on 
 Check if there is any available write buffers 
 Turn interrupts back on before sleeping. 
		
		  If write buffers are available check if this is
		  a NON-Blocking call or not.
 Sleep until a write buffer is available 
 Check if we need to send a zero length packet. 
 They will be more TX requests so no yet. 
			 If the data amount is not a multiple of the
			  maxpacket size then send a zero length packet.
 Don't leave irqs off while doing memory copies 
 We've disconnected or reset so free the req and buffer 
 here, we unlock, and only unlock, to avoid deadlock. 
 Sleep until all data has been sent 
 handle ioctls 
 could not handle ioctl 
 used after endpoint configuration 
-------------------------------------------------------------------------
 on error, disable any endpoints  
 caller is responsible for cleanup on error 
 Change our operational Interface. 
 Free the current interface 
-------------------------------------------------------------------------
  The setup() callback implements all the ep0 functionality that's not
  handled lower down.
 Get the IEEE-1284 PNP String 
 Only one printer interface is supported. 
 Get Port Status 
 Only one printer interface is supported. 
 Soft Reset 
 Only one printer interface is supported. 
 host either stalls (value < 0) or reports success 
 finish hookup to lower layer ... 
 all we really need is bulk INOUT 
 assumes that all endpoints are dual-speed 
 Setup the sysfs files for the printer gadget. 
	
	  Register a character device as an interface to a user mode
	  program that handles the printer specific functionality.
 Make sure q_len is initialized, otherwise the bound device can't support readwrite! 
 Remove Character Device 
 we must already have been disconnected ... no io may be active 
 Free all memory for this driver. 
 SPDX-License-Identifier: GPL-2.0+
  u_ether.c -- Ethernet-over-USB link layer utilities for Gadget stack
  Copyright (C) 2003-2005,2008 David Brownell
  Copyright (C) 2003-2004 Robert Schwebel, Benedikt Spranger
  Copyright (C) 2008 Nokia Corporation
 #define VERBOSE_DEBUG 
  This component encapsulates the Ethernet link glue needed to provide
  one (!) network link through the USB gadget stack, normally "usb0".
  The control and data models are handled by the function driver which
  connects to this code; such as CDC Ethernet (ECM or EEM),
  "CDC Subset", or RNDIS.  That includes all descriptor and endpoint
  management.
  Link level addressing is handled by this component using module
  parameters; if no such parameters are provided, random link level
  addresses are used.  Each end of the link uses one address.  The
  host end address is exported in various ways, and is often recorded
  in configuration databases.
  The driver which assembles each configuration using such a link is
  responsible for ensuring that each configuration includes at most one
  instance of is network link.  (The network layer provides ways for
  this single "physical" link to be used by multiple virtual links.)
 Experiments show that both Linux and Windows hosts allow up to 16k
  frame sizes. Set the max MTU size to 15k+52 to prevent allocating 32k
	 lock is held while accessing port_usb
 guard {rx,tx}_reqs 
-------------------------------------------------------------------------
 bytes guarding against rx overflows 
 double buffering by default 
 for dual-speed hardware, use deeper queues at highsuper speed 
-------------------------------------------------------------------------
 REVISIT there must be a better way than having two sets
  of debug calls ...
 DEBUG 
 DEBUG 
-------------------------------------------------------------------------
 NETWORK DRIVER HOOKUP (to the layer above this driver) 
 REVISIT can also support:
    - WOL (by tracking suspends and issuing remote wakeup)
    - msglevel (implies updated messaging)
    - ... probably more ethtool ops
	 Padding up to RX_EXTRA handles minor disagreements with host.
	  Normally we use the USB "terminate on short read" convention;
	  so allow up to (Nmaxpacket), since that memory is normally
	  already allocated.  Some hardware doesn't deal well with short
	  reads (e.g. DMA must be Nmaxpacket), so for now don't trim a
	  byte off the end (to force hardware errors on overflow).
	 
	  RNDIS uses internal framing, and explicitly allows senders to
	  pad to end-of-packet.  That's potentially nice for speed, but
	  means receivers can't recover lost synch on their own (because
	  new packets don't only start after a short RX).
	 Some platforms perform better when IP packets are aligned,
	  but on at least one, checksumming fails otherwise.  Note:
	  RNDIS headers involve variable numbers of LE32 values.
 normal completion 
			 no buffer copies needed, unless hardware can't
			  use skb buffers.
 software-driven interface shutdown 
 unlink 
 disconnect etc 
 for hardware automagic (such as pxa) 
 endpoint reset 
 data overrun 
 queuerecycle up to N requests 
 free extras 
 fill unused rxq slots with some skb 
 unlink 
 disconnect etc 
 apply outgoing CDC or RNDIS filters 
			 ignores USB_CDC_PACKET_TYPE_MULTICAST and host
			  SET_ETHERNET_MULTICAST_FILTERS requests
 ignores USB_CDC_PACKET_TYPE_DIRECTED 
	
	  this freelist can be empty if an interrupt triggered disconnect()
	  and reconfigured the gadget (shutting down this queue) after the
	  network stack decided to xmit but before we got the spinlock.
 temporarily stop TX queue when the freelist empties 
	 no buffer copies needed, unless the network stack did it
	  or the hardware can't use skb buffers.
	  or there's not enough space for extra headers we need
			 Multi frame CDC protocols may store the frame for
			  later which is not a dropped frame.
 NCM requires no zlp if transfer is dwNtbInMaxSize 
	 use zlp framing on tx for strict CDC-Ether conformance,
	  though any robust network rx path ignores extra padding.
	  and some hardware doesn't like to write zlps.
-------------------------------------------------------------------------
 fill the rx queue 
 and open the tx floodgates 
 ensure there are no more active requests 
		 NOTE:  we have no abort-queue primitive we could use
		  to cancel all pending IO.  Instead, we disable then
		  reenable the endpoints ... this idiom may leave toggle
		  wrong, but that's a self-correcting error.
		 
		  REVISIT:  we COULD just let the transfers complete at
		  their own pace; the network stack can handle old packets.
		  For the moment we leave this here, since it works.
-------------------------------------------------------------------------
  gether_setup_name - initialize one ethernet-over-usb link
  @g: gadget to associated with these links
  @ethaddr: NULL, or a buffer in which the ethernet address of the
 	host side of the link is recorded
  @netname: name for network device (for example, "usb")
  Context: may sleep
  This sets up the single network link that may be exported by a
  gadget driver using this framework.  The link layer addresses are
  set up using module parameters.
  Returns an eth_dev pointer on success, or an ERR_PTR on failure.
 network device setup 
 MTU range: 14 - 15412 
		
		  two kinds of host-initiated state changes:
		   - iff DATA transfer is active, carrier is "on"
		   - tx queueing enabled if open and carrier is "on"
 network device setup 
 MTU range: 14 - 15412 
		 two kinds of host-initiated state changes:
		   - iff DATA transfer is active, carrier is "on"
		   - tx queueing enabled if open and carrier is "on"
 Require exactly one %d, so binding will not fail with EEXIST. 
  gether_cleanup - remove Ethernet-over-USB device
  Context: may sleep
  This is called to free all resources allocated by @gether_setup().
  gether_connect - notify network layer that USB link is active
  @link: the USB link, set up with endpoints, descriptors matching
 	current device speed, and any framing wrapper(s) set up.
  Context: irqs blocked
  This is called to activate endpoints and let the network layer know
  the connection is active ("carrier detect").  It may cause the IO
  queues to open and start letting network packets flow, but will in
  any case activate the endpoints so that they respond properly to the
  USB host.
  Verify net_device pointer returned using IS_ERR().  If it doesn't
  indicate some error code (negative errno), ep->driver_data values
  have been overwritten.
 on error, disable any endpoints  
 caller is responsible for cleanup on error 
  gether_disconnect - notify network layer that USB link is inactive
  @link: the USB link, on which gether_connect() was called
  Context: irqs blocked
  This is called to deactivate endpoints and let the network layer know
  the connection went inactive ("no carrier").
  On return, the state is as if gether_connect() had never been called.
  The endpoints are inactive, and accordingly without active USB IO.
  Pointers to endpoint descriptors and endpoint private data are nulled.
	 disable endpoints, forcing (synchronous) completion
	  of all pending io.  then free the request objects
	  and forget about the endpoints.
 finish forgetting about this USB link episode 
 SPDX-License-Identifier: GPL-2.0
 Target based USB-Gadget
  UAS protocol handling, target callbacks, configfs handling,
  BBB (USB Mass Storage Class Bulk-Only (BBB) and Transport protocol handling.
  Author: Sebastian Andrzej Siewior <bigeasy at linutronix dot de>
 Start bot.c code 
 CSW completed, wait for next CBW 
			
			  the host wants to move data, we don't. Fill  empty
			  the pipe and then send the csw with reside set.
  Called after command (no data transfer) or after the write (to device)
  operation is completed
 Read request completed, now we have to send the CSW 
		
		  If 4 LUNs are present we return 3 i.e. LUN 0..3 can be
		  accessed. The upper limit is 0xf
 XXX maybe we should remove previous requests for IN + OUT 
 Start uas.c code 
 We have either all three allocated or none 
	
	  iu->status_qual = cpu_to_be16(STATUS QUALIFIER SAM-4. Where R U?);
	
	  Once we tune for performance enqueue the command req here again so
	  we can receive a second command while we processing this one. Pay
	  attention to properly sync STAUS endpoint with DATA IN + OUT so you
	  don't break HS.
 Start fabric.c code 
	
	  SPC doesn't assign a protocol identifier for USB-SCSI, so we
	  pretend to be SAS..
  If somebody feels like dropping the version property, go ahead.
	
	  Release the SCSI I_T Nexus to the emulated vHost Target Port
 Start gadget.c code 
 Assume endpoint addresses are the same for both speeds 
 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
  f_mass_storage.c -- Mass Storage USB Composite Function
  Copyright (C) 2003-2008 Alan Stern
  Copyright (C) 2009 Samsung Electronics
                     Author: Michal Nazarewicz <mina86@mina86.com>
  All rights reserved.
  The Mass Storage Function acts as a USB Mass Storage device,
  appearing to the host as a disk drive or as a CD-ROM drive.  In
  addition to providing an example of a genuinely useful composite
  function for a USB device, it also illustrates a technique of
  double-buffering for increased throughput.
  For more information about MSF and in particular its module
  parameters and sysfs interface read the
  <Documentationusbmass-storage.rst> file.
  MSF is configured by specifying a fsg_config structure.  It has the
  following fields:
 	nluns		Number of LUNs function have (anywhere from 1
 				to FSG_MAX_LUNS).
 	luns		An array of LUN configuration values.  This
 				should be filled for each LUN that
 				function will include (ie. for "nluns"
 				LUNs).  Each element of the array has
 				the following fields:
 	->filename	The path to the backing file for the LUN.
 				Required if LUN is not marked as
 				removable.
 	->ro		Flag specifying access to the LUN shall be
 				read-only.  This is implied if CD-ROM
 				emulation is enabled as well as when
 				it was impossible to open "filename"
 				in RW mode.
 	->removable	Flag specifying that LUN shall be indicated as
 				being removable.
 	->cdrom		Flag specifying that LUN shall be reported as
 				being a CD-ROM.
 	->nofua		Flag specifying that FUA flag in SCSI WRITE(10,12)
 				commands for this LUN shall be ignored.
 	vendor_name
 	product_name
 	release		Information used as a reply to INQUIRY
 				request.  To use default set to NULL,
 				NULL, 0xffff respectively.  The first
 				field should be 8 and the second 16
 				characters or less.
 	can_stall	Set to permit function to halt bulk endpoints.
 				Disabled on some USB devices known not
 				to work correctly.  You should set it
 				to true.
  If "removable" is not set for a LUN then a backing file must be
  specified.  If it is set, then NULL filename means the LUN's medium
  is not loaded (an empty string as "filename" in the fsg_config
  structure causes error).  The CD-ROM emulation includes a single
  data track and no audio tracks; hence there need be only one
  backing file per LUN.
  This function is heavily based on "File-backed Storage Gadget" by
  Alan Stern which in turn is heavily based on "Gadget Zero" by David
  Brownell.  The driver's SCSI command interface was based on the
  "Information technology - Small Computer System Interface - 2"
  document from X3T9.2 Project 375D, Revision 10L, 7-SEP-93,
  available at <http:www.t10.orgftpt10draftss2s2-r10l.pdf>.
  The single exception is opcode 0x23 (READ FORMAT CAPACITIES), which
  was based on the "Universal Serial Bus Mass Storage Class UFI
  Command Specification" document, Revision 1.0, December 14, 1998,
  available at
  <http:www.usb.orgdevelopersdevclass_docsusbmass-ufi10.pdf>.
 				Driver Design
  The MSF is fairly straightforward.  There is a main kernel
  thread that handles most of the work.  Interrupt routines field
  callbacks from the controller driver: bulk- and interrupt-request
  completion notifications, endpoint-0 events, and disconnect events.
  Completion events are passed to the main thread by wakeup calls.  Many
  ep0 requests are handled at interrupt time, but SetInterface,
  SetConfiguration, and device reset requests are forwarded to the
  thread in the form of "exceptions" using SIGUSR1 signals (since they
  should interrupt any ongoing file IO operations).
  The thread's main routine implements the standard commanddatastatus
  parts of a SCSI interaction.  It and its subroutines are full of tests
  for pending signalsexceptions -- all this polling is necessary since
  the kernel has no setjmplongjmp equivalents.  (Maybe this is an
  indication that the driver really wants to be running in userspace.)
  An important point is that so long as the thread is alive it keeps an
  open reference to the backing file.  This will prevent unmounting
  the backing file's underlying filesystem and could cause problems
  during system shutdown, for example.  To prevent such problems, the
  thread catches INT, TERM, and KILL signals and converts them into
  an EXIT exception.
  In normal operation the main thread is started during the gadget's
  fsg_bind() callback and stopped during fsg_unbind().  But it can
  also exit when it receives a signal, and there's no point leaving
  the gadget running when the thread is dead.  As of this moment, MSF
  provides no way to deregister the gadget when thread dies -- maybe
  a callback functions is needed.
  To provide maximum throughput, the driver uses a circular pipeline of
  buffer heads (struct fsg_buffhd).  In principle the pipeline can be
  arbitrarily long; in practice the benefits don't justify having more
  than 2 stages (i.e., double buffering).  But it helps to think of the
  pipeline as being a long one.  Each buffer head contains a bulk-in and
  a bulk-out request pointer (since the buffer can be used for both
  output and input -- directions always are given from the host's
  point of view) as well as a pointer to the buffer and various state
  variables.
  Use of the pipeline follows a simple protocol.  There is a variable
  (fsg->next_buffhd_to_fill) that points to the next buffer head to use.
  At any time that buffer head may still be in use from an earlier
  request, so each buffer head has a state variable indicating whether
  it is EMPTY, FULL, or BUSY.  Typical use involves waiting for the
  buffer head to be EMPTY, filling the buffer either by file IO or by
  USB IO (during which the buffer head is BUSY), and marking the buffer
  head FULL when the IO is complete.  Then the buffer will be emptied
  (again possibly by USB IO, during which it is marked BUSY) and
  finally marked EMPTY again (possibly by a completion routine).
  A module parameter tells the driver to avoid stalling the bulk
  endpoints wherever the transport specification allows.  This is
  necessary for some UDCs like the SuperH, which cannot reliably clear a
  halt on a bulk endpoint.  However, under certain circumstances the
  Bulk-only specification requires a stall.  In such cases the driver
  will halt the endpoint and set a flag indicating that it should clear
  the halt in software during the next device reset.  Hopefully this
  will permit everything to work correctly.  Furthermore, although the
  specification allows the bulk-out endpoint to halt when the host sends
  too much data, implementing this would cause an unavoidable race.
  The driver will always use the "no-stall" approach for OUT transfers.
  One subtle point concerns sending status-stage responses for ep0
  requests.  Some of these requests, such as device reset, can involve
  interrupting an ongoing file IO operation, which might take an
  arbitrarily long time.  During that delay the host might give up on
  the original ep0 request and issue a new one.  When that happens the
  driver should not notify the host about completion of the original
  request, as the host will no longer be waiting for it.  So the driver
  assigns to each ep0 request a unique tag, and it keeps track of the
  tag value of the request associated with a long-running exception
  (device-reset, interface-change, or configuration-change).  When the
  exception handler is finished, the status-stage response is submitted
  only if the current ep0 request tag is equal to the exception request
  tag.  Thus only the most recently received ep0 request will get a
  status-stage response.
  Warning: This driver source file is too long.  It ought to be split up
  into a header file plus about 3 separate .c files, to handle the details
  of the Gadget, USB Mass Storage, and SCSI protocols.
 #define VERBOSE_DEBUG 
 #define DUMP_MSGS 
------------------------------------------------------------------------
 Static strings, in UTF-8 (for simplicity we use only ASCII characters) 
 en-us 
-------------------------------------------------------------------------
 Data shared by all the FSG instances. 
 filesem protects: backing files in use 
 lock protects: state and thread_task 
 Copy of gadget->ep0 
 Copy of cdev->req 
 For exception handling 
 Gadget's private data. 
 Copy of cdev->gadget 
 Make bulk-out requests be divisible by the maxpacket size 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 These routines may be called in process context or in_irq 
	
	  Do nothing if a higher-priority exception is already in progress.
	  If a lower-or-equal priority exception is in progress, preempt it
	  and notify the main thread by sending it a signal.
-------------------------------------------------------------------------
 We can't do much more than wait for a reset 
-------------------------------------------------------------------------
 Completion handlers. These always run in_irq. 
 Request was cancelled 
 Synchronize with the smp_load_acquire() in sleep_thread() 
 Request was cancelled 
 Synchronize with the smp_load_acquire() in sleep_thread() 
 Record arrival of a new request 
		
		  Raise an exception to stop the current operation
		  and reinitialize our state.
 Respond with datastatus 
-------------------------------------------------------------------------
 All the following routines run in process context 
 Use this for bulk or interrupt transfers, not ep0 
 We can't do much more than wait for a reset 
		
		  Note: currently the net2280 driver fails zero-length
		  submissions if DMA is enabled.
 Wait until a signal arrives or bh is no longer busy 
		
		  synchronize with the smp_store_release(&bh->state) in
		  bulk_in_complete() or bulk_out_complete()
-------------------------------------------------------------------------
	
	  Get the starting Logical Block Address and check that it's
	  not too big.
 READ_10 or READ_12 
		
		  We allow DPO (Disable Page Out = don't save data in the
		  cache) and FUA (Force Unit Access = don't read from the
		  cache), but we don't implement them.
 Carry out the file reads 
 No default reply 
		
		  Figure out how much we need to read:
		  Try to read the remaining amount.
		  But don't read more than the buffer size.
		  And don't try to read past the end of the file.
 Wait for the next buffer to become available 
		
		  If we were asked to read past the end of file,
		  end with an empty buffer.
 Perform the read 
		
		  Except at the end of the transfer, nread will be
		  equal to the buffer size, which is divisible by the
		  bulk-in maxpacket size.
 If an error occurred, report it and its position 
 No more left to read 
 Send this buffer and go read some more 
 Don't know what to do if common->fsg is NULL 
 No default reply 
-------------------------------------------------------------------------
 Default is not to wait 
	
	  Get the starting Logical Block Address and check that it's
	  not too big
 WRITE_10 or WRITE_12 
		
		  We allow DPO (Disable Page Out = don't save data in the
		  cache) and FUA (Force Unit Access = write directly to the
		  medium).  We don't implement DPO; we implement FUA by
		  performing synchronous output.
 FUA 
 Carry out the file writes 
 Queue a request for more data from the host 
			
			  Figure out how much we want to get:
			  Try to get the remaining amount,
			  but not more than the buffer size.
 Beyond the end of the backing file? 
 Get the next buffer 
			
			  Except at the end of the transfer, amount will be
			  equal to the buffer size, which is divisible by
			  the bulk-out maxpacket size.
 Dunno what to do if common->fsg is NULL 
 Write the received data to the backing file 
 We stopped early 
 Wait for the data to be received 
 Did something go wrong with the transfer? 
		
		  Don't accept excess data.  The spec doesn't say
		  what to do in this case.  We'll ignore the error.
 Don't write a partial block 
 Perform the write 
 Interrupted! 
 If an error occurred, report it and its position 
 Did the host decide to stop early? 
 No default reply 
-------------------------------------------------------------------------
	 We ignore the requested LBA and write out all file's
-------------------------------------------------------------------------
	
	  Get the starting Logical Block Address and check that it's
	  not too big.
	
	  We allow DPO (Disable Page Out = don't save data in the
	  cache) but we don't implement it.
 No default reply 
 Prepare to carry out the file verify 
 Write out all the dirty buffers before invalidating them 
 Just try to read the requested blocks 
		
		  Figure out how much we need to read:
		  Try to read the remaining amount, but not more than
		  the buffer size.
		  And don't try to read past the end of the file.
 Perform the read 
-------------------------------------------------------------------------
 Unsupported LUNs are okay 
 Unsupported, no device-type 
 Additional length 
 ANSI SCSI level 2 
 SCSI-2 INQUIRY data format 
 Additional length 
 No special options 
	
	  From the SCSI-2 spec., section 7.9 (Unit attention condition):
	 
	  If a REQUEST SENSE command is received from an initiator
	  with a pending unit attention condition (before the target
	  generates the contingent allegiance condition), then the
	  target shall either:
	    a) report any pending sense data and preserve the unit
	 	attention condition on the logical unit, or,
	    b) report the unit attention condition, may discard any
	 	pending sense data, and clear the unit attention
	 	condition on the logical unit for that initiator.
	 
	  FSG normally uses option a); enable this code to use option b).
 Unsupported LUNs are okay 
 Valid, current error 
 Sense information 
 Additional sense length 
 Check the PMI and LBA fields 
 Max logical block 
 Block length 
 Check the PMI and LBA fields 
 Max logical block 
 Block length 
 It is safe to keep other fields zeroed 
 Mask away MSF 
 2048 bytes of user data, rest is EC 
 Mask away MSF 
 TOC data length 
 First track number 
 Last track number 
 Data track, copying allowed 
 Only track is number 1 
 Lead-out track is data 
 Lead-out track number 
 Mask away DBD 
	
	  Write the mode parameter header.  Fixed values are: default
	  medium type, no cache control (DPOFUA), and no block descriptors.
	  The only variable value is the WriteProtect bit.  We will fill in
	  the mode data length later.
 WP, DPOFUA 
 MODE_SENSE_10 
 WP, DPOFUA 
 Should really be FSG_BUFLEN 
 No block descriptors 
	
	  The mode pages, in numerical order.  The only page we support
	  is the Caching page.
 Page code 
 Page length 
 None of the fields are changeable 
 Write cache enable, 
 Read cache not disabled 
 No cache retention priorities 
 Don't disable prefetch 
 Minimum prefetch = 0 
 Maximum prefetch 
 Maximum prefetch ceiling 
	
	  Check that a valid page was requested and the mode data length
	  isn't too long.
  Store the mode data length 
 Mask away Immed 
 Mask LoEj, Start 
	
	  Our emulation doesn't support mounting; the medium is
	  available for use as soon as it is loaded.
 Are we allowed to unload the media? 
 Mask away Prevent 
 Only the CurrentMaximum Capacity Descriptor 
 Number of blocks 
 Block length 
 Current capacity 
 We don't support MODE SELECT 
-------------------------------------------------------------------------
 Wait for a short time and then try again 
 Wait for a short time and then try again 
 Try to submit another request if we need one 
			
			  Except at the end of the transfer, amount will be
			  equal to the buffer size, which is divisible by
			  the bulk-out maxpacket size.
 Dunno what to do if common->fsg is NULL 
 Wait for the data to be received 
 Throw away the data in a filled buffer 
 A short packet or an error ends everything 
 Nothing to send 
	
	  If we don't know whether the host wants to read or write,
	  this must be CB or CBI with an unknown command.  We mustn't
	  try to send or receive any data.  So stall both bulk pipes
	  if we can and wait for a reset.
 Nothing 
 Don't know what to do if common->fsg is NULL 
 All but the last buffer of data must have already been sent 
 Nothing to send 
 Don't know what to do if common->fsg is NULL 
 If there's no residue, simply send the last buffer 
		
		  For Bulk-only, mark the end of the data with a short
		  packet.  If we are allowed to stall, halt the bulk-in
		  endpoint.  (Note: This violates the Bulk-Only Transport
		  specification, which requires us to pad the data if we
		  don't halt the endpoint.  Presumably nobody will mind.)
	
	  We have processed all we want from the data the host has sent.
	  There may still be outstanding bulk-out requests.
 Nothing to receive 
 Did the host stop sending unexpectedly early? 
		
		  We haven't processed all the incoming data.  Even though
		  we may be allowed to stall, doing so would cause a race.
		  The controller may already have ACK'ed all the remaining
		  bulk-out packets, in which case the host wouldn't see a
		  STALL.  Not realizing the endpoint was halted, it wouldn't
		  clear the halt -- leading to problems later on.
		
		  We can't stall.  Read in the excess data and throw it
		  all away.
 Wait for the next buffer to become available 
 Store and send the Bulk-only CSW 
 Don't know what to do if common->fsg is NULL 
-------------------------------------------------------------------------
  Check whether the command is properly formed and whether its data size
  and direction agree with the values we already have.
	
	  We can't reply at all until we know the correct data direction
	  and size.
		
		  Host data size < Device data size is a phase error.
		  Carry out the command, but only transfer as much as
		  we are allowed.
 Conflicting data directions is a phase error 
 Verify the length of the command itself 
		
		  Special case workaround: There are plenty of buggy SCSI
		  implementations. Many have issues with cbw->Length
		  field passing a wrong command size. For those cases we
		  always try to work around the problem by using the length
		  sent by the host side provided it is at least as large
		  as the correct command length.
		  Examples of such cases would be MS-Windows, which issues
		  REQUEST SENSE with cbw->Length == 12 where it should
		  be 6, and xbox360 issuing INQUIRY, TEST UNIT READY and
		  REQUEST SENSE with cbw->Length == 10 where it should
		  be 6 as well.
 Check that the LUN values are consistent 
 Check the LUN 
		
		  INQUIRY and REQUEST SENSE commands are explicitly allowed
		  to use unsupported LUNs; all others may not.
	
	  If a unit attention condition exists, only INQUIRY and
	  REQUEST SENSE commands are allowed; anything else must fail.
 Check that only command bytes listed in the mask are non-zero 
 Mask away the LUN 
	 If the medium isn't mounted and the command needs to access
 wrapper of check_command for data size in blocks handling 
 Wait for the next buffer to become available for data or status 
 We're using the backing file 
	
	  Although optional, this command is used by MS-Windows.  We
	  support a minimal version: BytChk must be 0.
	
	  Some mandatory commands that we recognize but don't implement.
	  They don't mean much in this setting.  It's left as an exercise
	  for anyone interested to implement RESERVE and RELEASE in terms
	  of Posix locks.
 Set up the single reply buffer for finish_reply() 
 Error reply length 
 Otherwise it's already set 
-------------------------------------------------------------------------
 Was this a real packet?  Should it be ignored? 
 Is the CBW valid? 
		
		  The Bulk-only spec says we MUST stall the IN endpoint
		  (6.6.1), so it's unavoidable.  It also says we must
		  retain this state until the next reset, but there's
		  no way to tell the controller driver it should ignore
		  Clear-Feature(HALT) requests.
		 
		  We aren't required to halt the OUT endpoint; instead
		  we can simply accept and discard any data received
		  until the next reset.
 Is the CBW meaningful? 
		
		  We can do anything we want here, so let's stall the
		  bulk pipes if we are allowed to.
 Save the command for later 
 Wait for the next buffer to become available 
 Queue a request to read a Bulk-only CBW 
 Don't know what to do if common->fsg is NULL 
	
	  We will drain the buffer in software, which means we
	  can reuse it for the next filling.  No need to advance
	  next_buffhd_to_fill.
 Wait for the CBW to arrive 
-------------------------------------------------------------------------
 Reset interface setting and re-init endpoint state (toggle etc). 
 Deallocate the requests 
 Disable the endpoints 
 Enable the endpoints 
 Allocate the requests 
 ALT CONFIGS 
 Disable the endpoints 
-------------------------------------------------------------------------
	
	  Clear the existing signals.  Anything but SIGUSR1 is converted
	  into a high-priority EXIT exception.
 Cancel all the pending transfers 
 Wait for a transfer to become idle 
 Clear out the controller's fifos 
	
	  Reset the IO buffer states and pointers, the SCSI
	  state, and the exception.  Then invoke the handler.
 Carry out any extra actions required for the exception 
		
		  In case we were forced against our will to halt a
		  bulk endpoint, clear the halt now.  (The SuperH UDC
		  requires this.)
 Complete the status stage 
		
		  Technically this should go here, but it would only be
		  a waste of time.  Ditto for the INTERFACE_CHANGE and
		  CONFIG_CHANGE cases.
 for (i = 0; i < common->ARRAY_SIZE(common->luns); ++i) 
	if (common->luns[i]) 
		common->luns[i]->unit_attention_data = 
			SS_RESET_OCCURRED;  
 Free resources 
 Stop the thread 
-------------------------------------------------------------------------
	
	  Allow the thread to be killed by a signal, but set the signal mask
	  to block everything but INT, TERM, KILL, and USR1.
 Allow the thread to be frozen 
 The main loop 
 Eject media from all LUNs 
 Let fsg_unbind() know the thread has exited 
 DEVICE ATTRIBUTES 
 mode wil be set in fsg_lun_attr_is_visible() 
 FSG COMMON 
 Nothing needs to be done 
 Data buffers cyclic list 
	
	  "buf"s pointed to by heads after n - i are NULL
	  so releasing them won't hurt
	
	  Some peripheral controllers are known not to be able to
	  halt bulk endpoints correctly.  If one of them is present,
	  disable stalls.
 we DON'T own the name!
 enough for 100000000 different numbers, decimal 
 Prepare inquiryString 
 Assume product name dependent on the first LUN 
 If the thread isn't already dead, tell it to exit now 
-------------------------------------------------------------------------
 Don't allow to bind if we don't have at least one LUN 
 New interface 
 Find all the endpoints we will use 
 Assume endpoint addresses are the same for both speeds 
 Calculate bMaxBurst, we know packet size is 1024 
 terminate the thread 
 ALLOCATE FUNCTION 
 FIXME: make interruptible or killable somehow? 
 Module parameters 
 Configure LUNs 
 Let MSF use defaults 
 Finalise 
 SPDX-License-Identifier: GPL-2.0+
 	uvc_gadget.c  --  USB Video Class Gadget driver
 	Copyright (C) 2009-2010
 	    Laurent Pinchart (laurent.pinchart@ideasonboard.com)
 --------------------------------------------------------------------------
  Function descriptors
 string IDs are assigned dynamically 
 en-us 
 16 bytes status 
 The following 3 values can be tweaked if necessary. 
	 The wMaxPacketSize and bInterval values will be initialized from
	  module parameters.
	 The wMaxPacketSize and bInterval values will be initialized from
	  module parameters.
	 The wMaxPacketSize and bInterval values will be initialized from
	  module parameters.
	 The bMaxBurst, bmAttributes and wBytesPerInterval values will be
	  initialized from module parameters.
 --------------------------------------------------------------------------
  Control requests
 Stall too big requests. 
	 Tell the complete callback to generate an event for the next request
	  that will be enqueued by UVCIOC_SEND_RESPONSE.
	 TODO
	if (usb_endpoint_xfer_bulk(&uvc->desc.vs_ep))
		return alt ? -EINVAL : 0;
 --------------------------------------------------------------------------
  Connection  disconnection
 --------------------------------------------------------------------------
  USB probe and disconnect
 TODO reference counting. 
	 Descriptors layout
	 
	  uvc_iad
	  uvc_control_intf
	  Class-specific UVC control descriptors
	  uvc_control_ep
	  uvc_control_cs_ep
	  uvc_ss_control_comp (for SS only)
	  uvc_streaming_intf_alt0
	  Class-specific UVC streaming descriptors
	  uvc_{fs|hs}_streaming
 Count descriptors and compute their size. 
 Copy the descriptors. 
	 Sanity check the streaming endpoint module parameters.
 For SS, wMaxPacketSize has to be 1024 if bMaxBurst is not 0 
	 Fill in the FSHSSS Video Streaming specific descriptors from the
	  module parameters.
	 
	  NOTE: We assume that the user knows what they are doing and won't
	  give parameters that their UDC doesn't support.
 A high-bandwidth endpoint must specify a bInterval value of 1 
 Allocate endpoints. 
 Allocate interface IDs. 
 Copy descriptors 
 Preallocate control endpoint request. 
 Initialise video. 
 Register a V4L2 device. 
 --------------------------------------------------------------------------
  USB gadget function
 Prepare fs control class descriptors for configfs-based gadgets 
 assigned elsewhere by configfs 
 NULL-terminate 
 Prepare hs control class descriptors for configfs-based gadgets 
 assigned elsewhere by configfs 
 NULL-terminate 
 Register the function. 
 SPDX-License-Identifier: GPL-2.0
  uvc_configfs.c
  Configfs support for the uvc function.
  Copyright (c) 2014 Samsung Electronics Co., Ltd.
 		http:www.samsung.com
  Author: Andrzej Pietrasiewicz <andrzejtp2010@gmail.com>
 -----------------------------------------------------------------------------
  Global Utility Structures and Macros
 -----------------------------------------------------------------------------
  controlheader<NAME>
  controlheader
 for navigating configfs hierarchy 	\
 for navigating configfs hierarchy 	\
 -----------------------------------------------------------------------------
  controlprocessingdefault
 for navigating configfs hierarchy 	\
 for navigating configfs hierarchy 
 -----------------------------------------------------------------------------
  controlprocessing
 -----------------------------------------------------------------------------
  controlterminalcameradefault
 for navigating configfs hierarchy 	\
 for navigating configfs hierarchy 
 -----------------------------------------------------------------------------
  controlterminalcamera
 -----------------------------------------------------------------------------
  controlterminaloutputdefault
 for navigating configfs hierarchy 	\
 -----------------------------------------------------------------------------
  controlterminaloutput
 -----------------------------------------------------------------------------
  controlterminal
 -----------------------------------------------------------------------------
  controlclass{fs|ss}
 for navigating configfs hierarchy 
 for navigating configfs hierarchy 
 -----------------------------------------------------------------------------
  controlclass
 -----------------------------------------------------------------------------
  control
 for navigating configfs hierarchy 
 -----------------------------------------------------------------------------
  streaminguncompressed
  streamingmjpeg
 for navigating configfs hierarchy 
 for navigating configfs hierarchy 
 -----------------------------------------------------------------------------
  streamingheader<NAME>
  streamingheader
 for navigating configfs hierarchy 
	
	  Linking is only allowed to direct children of the format nodes
	  (streaminguncompressed or streamingmjpeg nodes). First check that
	  the grand-parent of the target matches the grand-parent of the source
	  (the streaming node), and then verify that the target parent is a
	  format node.
 for navigating configfs hierarchy 
 for navigating configfs hierarchy 	\
 -----------------------------------------------------------------------------
  streaming<mode><format><NAME>
 for navigating configfs hierarchy 	\
 for navigating configfs hierarchy 	\
 for navigating configfs hierarchy 
 for navigating configfs hierarchy 
 sign, base 2 representation, newline, terminator 
 for navigating configfs hierarchy 
 -----------------------------------------------------------------------------
  streaminguncompressed<NAME>
 for navigating configfs hierarchy 
 for navigating configfs hierarchy 
 for navigating configfs hierarchy 	\
 for navigating configfs hierarchy 	\
 for navigating configfs hierarchy 	\
 -----------------------------------------------------------------------------
  streamingmjpeg<NAME>
 for navigating configfs hierarchy 	\
 for navigating configfs hierarchy 	\
 for navigating configfs hierarchy 	\
 -----------------------------------------------------------------------------
  streamingcolor_matchingdefault
 for navigating configfs hierarchy 	\
 -----------------------------------------------------------------------------
  streamingcolor_matching
 -----------------------------------------------------------------------------
  streamingclass{fs|hs|ss}
  Iterate over a hierarchy of streaming descriptors' config items.
  The items are created by the user with configfs.
  It "processes" the header pointed to by @priv1, then for each format
  that follows the header "processes" the format itself and then for
  each frame inside a format "processes" the frame.
  As a "processing" function the @fun is used.
  __uvcg_iter_strm_cls() is used in two context: first, to calculate
  the amount of memory needed for an array of streaming descriptors
  and second, to actually fill the array.
  @h: streaming header pointer
  @priv2: an "inout" parameter (the caller might want to see the changes to it)
  @priv3: an "inout" parameter (the caller might want to see the changes to it)
  @fun: callback function for processing each level of the hierarchy
  Count how many bytes are needed for an array of streaming descriptors.
  @priv1: pointer to a header, format or frame
  @priv2: inout parameter, accumulated size of the array
  @priv3: inout parameter, accumulated number of the array elements
  @n: unused, this function's prototype must match @fun in __uvcg_iter_strm_cls
 bmaControls 
  Fill an array of streaming descriptors.
  @priv1: pointer to a header, format or frame
  @priv2: inout parameter, pointer into a block of memory
  @priv3: inout parameter, pointer to a 2-dimensional array
 for navigating configfs hierarchy 
 color_matching, NULL 
		
		  __uvcg_fill_strm() called from __uvcg_iter_stream_cls()
		  might have advanced the "data", so use a backup copy
 for navigating configfs hierarchy 
 -----------------------------------------------------------------------------
  streamingclass
 -----------------------------------------------------------------------------
  streaming
 for navigating configfs hierarchy 
 -----------------------------------------------------------------------------
  UVC function
 SPDX-License-Identifier: GPL-2.0+
  storage_common.c -- Common definitions for mass storage functionality
  Copyright (C) 2003-2008 Alan Stern
  Copyeight (C) 2009 Samsung Electronics
  Author: Michal Nazarewicz (mina86@mina86.com)
  This file requires the following identifiers used in USB strings to
  be defined (each of type pointer to char):
   - fsg_string_interface    -- name of the interface
  When USB_GADGET_DEBUG_FILES is defined the module param num_buffers
  sets the number of pipeline buffers (length of the fsg_buffhd array).
  The valid range of num_buffers is: num >= 2 && num <= 4.
 There is only one interface. 
 Adjusted during fsg_bind() 
 Adjusted during fsg_bind() 
 Adjusted during fsg_bind() 
  Three full-speed endpoint descriptors: bulk-in, bulk-out, and
  interrupt-in.
 wMaxPacketSize set by autoconfiguration 
 wMaxPacketSize set by autoconfiguration 
  USB 2.0 devices need to expose both high speed and full speed
  descriptors, unless they only run at full speed.
  That means alternate endpoint descriptors (bigger packets).
 bEndpointAddress copied from fs_bulk_in_desc during fsg_bind() 
 bEndpointAddress copied from fs_bulk_out_desc during fsg_bind() 
 NAK every 1 uframe 
 bEndpointAddress copied from fs_bulk_in_desc during fsg_bind() 
.bMaxBurst =		DYNAMIC, 
 bEndpointAddress copied from fs_bulk_out_desc during fsg_bind() 
.bMaxBurst =		DYNAMIC, 
-------------------------------------------------------------------------
  If the next two routines are called while the gadget is registered,
  the caller must own fsg->filesem for writing.
 RW if we can, RO if we must 
	
	  If we can't read the file, it's no good.
	  If we can't write the file, use it read-only.
 File size in logic-block-size blocks 
 Smallest track is 300 frames 
-------------------------------------------------------------------------
  Sync the file data, don't bother with the metadata.
  This code was copied from fsbuffer.c:sys_fdatasync().
 Convert to Minutes-Seconds-Frames 
 Convert to 2048-byte frames 
 Lead-in occupies 2 seconds 
 Frames 
 Seconds 
 Minutes 
 Reserved 
 Absolute sector 
-------------------------------------------------------------------------
 Get the complete pathname 
 Add a newline 
 No file, return 0 bytes 
  The caller must hold fsg->filesem for reading when calling this function.
	
	  Allow the write-enable status to change only while the
	  backing file is closed.
 Sync data when switching from async mode to sync 
 "Door is locked" 
 Remove a trailing newline 
 Ugh! 
 Load new medium 
 fsg_lun_open() will close existing file if any. 
 SPDX-License-Identifier: GPL-2.0+
 	uvc_video.c  --  USB Video Class Gadget driver
 	Copyright (C) 2009-2010
 	    Laurent Pinchart (laurent.pinchart@ideasonboard.com)
 --------------------------------------------------------------------------
  Video codecs
 dwClockFrequency is 48 MHz 
 Copy video data to the USB buffer. 
 Add a header at the beginning of the payload. 
 Process video data. 
 Init the header. 
 Init the pending sgs with payload 
 Assign the video data with header. 
 Add the header. 
 Process video data. 
 --------------------------------------------------------------------------
  Request handling
 If the endpoint is disabled the descriptor may be NULL. 
 Isochronous endpoints can't be halted. 
 disconnect from host. 
 req_sizePAGE_SIZE + 1 for overruns and + 1 for header 
 --------------------------------------------------------------------------
  Video streaming
  uvcg_video_pump - Pump video data into the USB requests
  This function fills the available USB requests (listed in req_free) with
  video data from the queued buffers.
		 Retrieve the first available USB request, protected by the
		  request lock.
		 Retrieve the first available video buffer and fill the
		  request, protected by the video queue irqlock.
		 With usb3 we have more requests. This will decrease the
		  interrupt load to a quarter but also catches the corner
 Queue the USB request 
  Enable or disable the video stream.
  Initialize the UVC video stream.
 Initialize the video buffers queue. 
 SPDX-License-Identifier: GPL-2.0+
  f_rndis.c -- RNDIS link function driver
  Copyright (C) 2003-2005,2008 David Brownell
  Copyright (C) 2003-2004 Robert Schwebel, Benedikt Spranger
  Copyright (C) 2008 Nokia Corporation
  Copyright (C) 2009 Samsung Electronics
                     Author: Michal Nazarewicz (mina86@mina86.com)
 #define VERBOSE_DEBUG 
  This function is an RNDIS Ethernet port -- a Microsoft protocol that's
  been promoted instead of the standard CDC Ethernet.  The published RNDIS
  spec is ambiguous, incomplete, and needlessly complex.  Variants such as
  ActiveSync have even worse status in terms of specification.
  In short:  it's a protocol controlled by (and for) Microsoft, not for an
  Open ecosystem or markets.  Linux supports it only because Microsoft
  doesn't support the CDC Ethernet standard.
  The RNDIS data transfer model is complex, with multiple Ethernet packets
  per USB message, and out of band data.  The control model is built around
  what's essentially an "RNDIS RPC" protocol.  It's all wrapped in a CDC ACM
  (modem, not Ethernet) veneer, with those ACM descriptors being entirely
  useless (they're ignored).  RNDIS expects to be the only function in its
  configuration, so it's no real help if you need composite devices; and
  it expects to be the first configuration too.
  There is a single technical advantage of RNDIS over CDC Ethernet, if you
  discount the fluff that its RPC can be made to deliver: it doesn't need
  a NOP altsetting for the data interface.  That lets it work on some of the
  "so smart it's stupid" hardware which takes over configuration changes
  from the software, and adds restrictions like "no altsettings".
  Unfortunately MSFT's RNDIS drivers are buggy.  They hang or oops, and
  have all sorts of contrary-to-specification oddities that can prevent
  them from working sanely.  Since bugfixes (or accurate specs, letting
  Linux work around those bugs) are unlikely to ever come from MSFT, you
  may want to avoid using RNDIS on purely operational grounds.
  Omissions from the RNDIS 1.0 specification include:
    - Power management ... references data that's scattered around lots
      of other documentation, which is incorrectincomplete there too.
    - There are various undocumented protocol requirements, like the need
      to send garbage in some control-OUT messages.
    - MS-Windows drivers sometimes emit undocumented requests.
 peak (theoretical) bulk transfer rate in bits-per-second 
-------------------------------------------------------------------------
 8 bytes data 
 interface descriptor: 
 .bInterfaceNumber = DYNAMIC 
 status endpoint is optional; this could be patched later 
 .iInterface = DYNAMIC 
 .bMasterInterface0 =	DYNAMIC 
 .bSlaveInterface0 =	DYNAMIC 
 the data interface has two bulk endpoints 
 .bInterfaceNumber = DYNAMIC 
 .iInterface = DYNAMIC 
 XXX, hardcoded 
 control + data
 .iFunction = DYNAMIC 
 full speed support: 
 control interface matches ACM, not Ethernet 
 data interface has no altsetting 
 high speed support: 
 control interface matches ACM, not Ethernet 
 data interface has no altsetting 
 super speed support: 
 the following 3 values can be tweaked if necessary 
 .bMaxBurst =		0, 
 .bmAttributes =	0, 
 the following 2 values can be tweaked if necessary 
 .bMaxBurst =		0, 
 .bmAttributes =	0, 
 control interface matches ACM, not Ethernet 
 data interface has no altsetting 
 string descriptors: 
 end of list 
 en-us 
-------------------------------------------------------------------------
	 Send RNDIS RESPONSE_AVAILABLE notification; a
	  USB_CDC_NOTIFY_RESPONSE_AVAILABLE "should" work too
	 
	  This is the only notification defined by RNDIS.
	 after TX:
	   - USB_CDC_GET_ENCAPSULATED_RESPONSE (ep0control)
	   - RNDIS_RESPONSE_AVAILABLE (statusirq)
 connection gone 
		 handle multiple pending RNDIS_RESPONSE_AVAILABLE
		  notifications by resending until we're done
 received RNDIS command from USB_CDC_SEND_ENCAPSULATED_COMMAND 
	spin_lock(&dev->lock);
	spin_unlock(&dev->lock);
	 composite driver infrastructure handles everything except
	  CDC class messages; interface activation uses set_alt().
	 RNDIS uses the CDC command encapsulation mechanism to implement
	  an RPC scheme, with much gettingsetting of attributes by OID.
 read the request; process it later 
 later, rndis_response_available() sends a notification 
 return the result 
 else stalls ... spec says to avoid that 
 respond with data transfer or status phase? 
 device either stalls (value < 0) or reports success 
 we know alt == 0 
 Avoid ZLPs; they can be troublesome. 
		 RNDIS should be in the "RNDIS uninitialized" state,
		  either never activated or after rndis_uninit().
		 
		  We don't want data to flow here until a nonzero packet
		  filter is set, at which point it enters "RNDIS data
		  initialized" state ... but we do want the endpoints
		  to be activated.  It's a strange little state.
		 
		  REVISIT the RNDIS gadget code has done this wrong for a
		  very long time.  We need another call to the link layer
		  code -- gether_updown(...bool) maybe -- to do it right.
-------------------------------------------------------------------------
  This isn't quite the same mechanism as CDC Ethernet, since the
  notification scheme passes less data, but the same set of link
  states must be tested.  A key difference is that altsettings are
  not used to tell whether the link should send packets or not.
-------------------------------------------------------------------------
 Some controllers can't support RNDIS ... 
 everything else is presumably fine 
 ethernet function driver setupbinding 
	
	  in driversusbgadgetconfigfs.c:configfs_composite_bind()
	  configurations are bound in sequence with list_for_each_entry,
	  in each configuration its functions are bound in sequence
	  with list_for_each_entry, so we assume no race condition
	  with regard to rndis_opts->bound access
 allocate instance-specific interface IDs 
 allocate instance-specific endpoints 
	 NOTE:  a statusnotification endpoint is, strictly speaking,
	  optional.  We don't treat it that way though!  It's simpler,
	  and some newer profiles don't treat it as optional.
 allocate notification request and buffer 
	 support all relevant hardware speeds... we expect that when
	  hardware is dual speed, all bulk-capable endpoints work at
	  both speeds
	 NOTE:  all that is done without knowing or caring about
	  the network link ... which is unavailable to this code
	  until we're activated via set_alt().
 f_rndis_item_ops 
 f_rndis_opts_dev_addr 
 f_rndis_opts_host_addr 
 f_rndis_opts_qmult 
 f_rndis_opts_ifname 
 f_rndis_opts_class 
 f_rndis_opts_subclass 
 f_rndis_opts_protocol 
 single VLA chunk 
 allocate and initialize one new instance 
 RNDIS activates when the host changes this filter 
 RNDIS has special (and complex) framing 
 descriptors are per-instance copies 
 SPDX-License-Identifier: GPL-2.0+
  f_subset.c -- "CDC Subset" Ethernet link function driver
  Copyright (C) 2003-2005,2008 David Brownell
  Copyright (C) 2008 Nokia Corporation
  This function packages a simple "CDC Subset" Ethernet port with no real
  control mechanisms; just raw data transfer over two bulk endpoints.
  The data transfer model is exactly that of CDC Ethernet, which is
  why we call it the "CDC Subset".
  Because it's not standardized, this has some interoperability issues.
  They mostly relate to driver binding, since the data transfer model is
  so simple (CDC Ethernet).  The original versions of this protocol used
  specific productvendor IDs:  byteswapped IDs for Digital Equipment's
  SA-1100 "Itsy" board, which could run Linux 2.4 kernels and supported
  daughtercards with USB peripheral connectors.  (It was used more often
  with other boards, using the Itsy identifiers.)  Linux hosts recognized
  this with CONFIG_USB_ARMLINUX; these devices have only one configuration
  and one interface.
  At some point, MCCI defined a (nonconformant) CDC MDLM variant called
  "SAFE", which happens to have a mode which is identical to the "CDC
  Subset" in terms of data transfer and lack of control model.  This was
  adopted by later Sharp Zaurus models, and by some other software which
  Linux hosts recognize with CONFIG_USB_NET_ZAURUS.
  Because Microsoft's RNDIS drivers are far from robust, we added a few
  descriptors to the CDC Subset code, making this code look like a SAFE
  implementation.  This lets you use MCCI's host side MS-Windows drivers
  if you get fed up with RNDIS.  It also makes it easier for composite
  drivers to work, since they can use class based binding instead of
  caring about specific product and vendor IDs.
-------------------------------------------------------------------------
  "Simple" CDC-subset option is a simple vendor-neutral model that most
  full speed controllers can handle:  one interface, two bulk endpoints.
  To assist host side drivers, we fancy it up a bit, and add descriptors so
  some host side drivers will understand it as a "SAFE" variant.
  "SAFE" loosely follows CDC WMC MDLM, violating the spec in various ways.
  Data endpoints live in the control interface, there's no data interface.
  And it's not used to talk to a cell phone radio.
 interface descriptor: 
 .bInterfaceNumber = DYNAMIC 
 .iInterface = DYNAMIC 
 since "usb_cdc_mdlm_detail_desc" is a variable length structure, we
  can't really use its struct.  All we do here is say that we're using
  the submode of "SAFE" which directly matches the CDC Subset.
 "SAFE" 
 network control capabilities (none) 
 network data capabilities ("raw" encapsulation) 
 this descriptor actually adds value, surprise! 
 .iMACAddress = DYNAMIC 
 no statistics 
 full speed support: 
 high speed support: 
 super speed support: 
 the following 2 values can be tweaked if necessary 
 .bMaxBurst =		0, 
 .bmAttributes =	0, 
 string descriptors: 
 end of list 
 en-us 
-------------------------------------------------------------------------
 we know alt == 0, so this is an activation or a reset 
-------------------------------------------------------------------------
 serial function driver setupbinding 
	
	  in driversusbgadgetconfigfs.c:configfs_composite_bind()
	  configurations are bound in sequence with list_for_each_entry,
	  in each configuration its functions are bound in sequence
	  with list_for_each_entry, so we assume no race condition
	  with regard to gether_opts->bound access
 allocate instance-specific interface IDs 
 allocate instance-specific endpoints 
	 support all relevant hardware speeds... we expect that when
	  hardware is dual speed, all bulk-capable endpoints work at
	  both speeds
	 NOTE:  all that is done without knowing or caring about
	  the network link ... which is unavailable to this code
	  until we're activated via set_alt().
 f_gether_item_ops 
 f_gether_opts_dev_addr 
 f_gether_opts_host_addr 
 f_gether_opts_qmult 
 f_gether_opts_ifname 
 allocate and initialize one new instance 
 export host's Ethernet address in CDC format 
 SPDX-License-Identifier: GPL-2.0+
  f_ecm.c -- USB CDC Ethernet (ECM) link function driver
  Copyright (C) 2003-2005,2008 David Brownell
  Copyright (C) 2008 Nokia Corporation
 #define VERBOSE_DEBUG 
  This function is a "CDC Ethernet Networking Control Model" (CDC ECM)
  Ethernet link.  The data transfer model is simple (packets sent and
  received over bulk endpoints using normal short packet termination),
  and the control model exposes various data and optional notifications.
  ECM is well standardized and (except for Microsoft) supported by most
  operating systems with USB host support.  It's the preferred interop
  solution for Ethernet over USB, at least for firmware based solutions.
  (Hardware solutions tend to be more minimalist.)  A newer and simpler
  "Ethernet Emulation Model" (CDC EEM) hasn't yet caught on.
  Note that ECM requires the use of "alternate settings" for its data
  interface.  This means that the set_alt() method has real work to do,
  and also means that a get_alt() method is required.
 don't notify 
 issue CONNECT next 
 issue SPEED_CHANGE next 
	 FIXME is_open needs some irq-ish locking
	  ... possibly the same as port.ioport
 peak (theoretical) bulk transfer rate in bits-per-second 
-------------------------------------------------------------------------
  Include the status endpoint if we can, even though it's optional.
  Use wMaxPacketSize big enough to fit CDC_NOTIFY_SPEED_CHANGE in one
  packet, to simplify cancellation; and a big transfer interval, to
  waste less bandwidth.
  Some drivers (like Linux 2.4 cdc-ether!) "need" it to exist even
  if they ignore the connectdisconnect notifications that real aether
  can provide.  More advanced cdc configurations might want to support
  encapsulated commands (vendor-specific, using control-OUT).
 8 byte header + data 
 interface descriptor: 
 .bFirstInterface =	DYNAMIC, 
 control + data 
 .iFunction =		DYNAMIC 
 .bInterfaceNumber = DYNAMIC 
 status endpoint is optional; this could be patched later 
 .iInterface = DYNAMIC 
 .bMasterInterface0 =	DYNAMIC 
 .bSlaveInterface0 =	DYNAMIC 
 this descriptor actually adds value, surprise! 
 .iMACAddress = DYNAMIC 
 no statistics 
 the default data interface has no endpoints ... 
 .iInterface = DYNAMIC 
 ... but the "real" data interface has two bulk endpoints 
 .iInterface = DYNAMIC 
 full speed support: 
 CDC ECM control descriptors 
 NOTE: status endpoint might need to be removed 
 data interface, altsettings 0 and 1 
 high speed support: 
 CDC ECM control descriptors 
 NOTE: status endpoint might need to be removed 
 data interface, altsettings 0 and 1 
 super speed support: 
 the following 3 values can be tweaked if necessary 
 .bMaxBurst =		0, 
 .bmAttributes =	0, 
 the following 2 values can be tweaked if necessary 
 .bMaxBurst =		0, 
 .bmAttributes =	0, 
 CDC ECM control descriptors 
 NOTE: status endpoint might need to be removed 
 data interface, altsettings 0 and 1 
 string descriptors: 
 end of list 
 en-us 
-------------------------------------------------------------------------
 notification already in flight? 
 SPEED_CHANGE data is updown speeds in bitssec 
	 NOTE on most versions of Linux, host side cdc-ethernet
	  won't listen for notifications until its netdevice opens.
	  The first notification then sits in the FIFO for a long
	  time, and the second one is queued.
 no fault 
	 composite driver infrastructure handles everything except
	  CDC class messages; interface activation uses set_alt().
		 see 6.2.30: no data, wIndex = interface,
		  wValue = packet filter bitmap
		 REVISIT locking of cdc_filter.  This assumes the UDC
		  driver won't have a concurrent packet TX irq running on
		  another CPU; or that if it does, this write is atomic...
	 and optionally:
	  case USB_CDC_SEND_ENCAPSULATED_COMMAND:
	  case USB_CDC_GET_ENCAPSULATED_RESPONSE:
	  case USB_CDC_SET_ETHERNET_MULTICAST_FILTERS:
	  case USB_CDC_SET_ETHERNET_PM_PATTERN_FILTER:
	  case USB_CDC_GET_ETHERNET_PM_PATTERN_FILTER:
	  case USB_CDC_GET_ETHERNET_STATISTIC:
 respond with data transfer or status phase? 
 device either stalls (value < 0) or reports success 
 Control interface has only altsetting 0 
 Data interface has two altsettings, 0 and 1 
		 CDC Ethernet only sends data in non-default altsettings.
		  Changing altsettings resets filters, statistics, etc.
			 Enable zlps by default for ECM conformance;
			  override for musb_hdrc (avoids txdma ovhead).
		 NOTE this can be a minor disagreement with the ECM spec,
		  which says speed notifications will "always" follow
		  connection notifications.  But we allow one connect to
		  follow another (if the first is in flight), and instead
		  just guarantee that a speed notification is always sent.
 Because the data interface supports multiple altsettings,
  this ECM function MUST implement a get_alt() method.
-------------------------------------------------------------------------
  Callbacks let us notify the host about connectdisconnect when the
  net device is opened or closed.
  For testing, note that link states on this side include both opened
  and closed variants of:
    - disconnectedunconfigured
    - configured but inactive (data alt 0)
    - configured and active (data alt 1)
  Each needs to be tested with unplug, rmmod, SET_CONFIGURATION, and
  SET_INTERFACE (altsetting).  Remember also that "configured" doesn't
  imply the host is actually polling the notification endpoint, and
  likewise that "active" doesn't imply it's actually using the data
  endpoints for traffic.
-------------------------------------------------------------------------
 ethernet function driver setupbinding 
	
	  in driversusbgadgetconfigfs.c:configfs_composite_bind()
	  configurations are bound in sequence with list_for_each_entry,
	  in each configuration its functions are bound in sequence
	  with list_for_each_entry, so we assume no race condition
	  with regard to ecm_opts->bound access
 allocate instance-specific interface IDs 
 allocate instance-specific endpoints 
	 NOTE:  a statusnotification endpoint is OPTIONAL but we
	  don't treat it that way.  It's simpler, and some newer CDC
	  profiles (wireless handsets) no longer treat it as optional.
 allocate notification request and buffer 
	 support all relevant hardware speeds... we expect that when
	  hardware is dual speed, all bulk-capable endpoints work at
	  both speeds
	 NOTE:  all that is done without knowing or caring about
	  the network link ... which is unavailable to this code
	  until we're activated via set_alt().
 f_ecm_item_ops 
 f_ecm_opts_dev_addr 
 f_ecm_opts_host_addr 
 f_ecm_opts_qmult 
 f_ecm_opts_ifname 
 allocate and initialize one new instance 
 export host's Ethernet address in CDC format 
 descriptors are per-instance copies 
 SPDX-License-Identifier: GPL-2.0
  RNDIS MSG parser
  Authors:	Benedikt Spranger, Pengutronix
 		Robert Schwebel, Pengutronix
 		This software was originally developed in conformance with
 		Microsoft's Remote NDIS Specification License Agreement.
  03122004 Kai-Uwe Bloem <linux-development@auerswald.de>
 		Fixed message length bug in init_response
  03252004 Kai-Uwe Bloem <linux-development@auerswald.de>
 		Fixed rndis_rm_hdr length bug.
  Copyright (C) 2004 by David Brownell
 		updates to merge with Linux 2.6, better match RNDIS spec
 The driver for your USB chip needs to support ep0 OUT to work with
  RNDIS, plus all three CDC Ethernet endpoints (interrupt not optional).
  Windows hosts need an INF file like Documentationusblinux.inf
  and will be happier if you provide the host_addr module parameter.
 CONFIG_USB_GADGET_DEBUG_FILES 
 Driver Version 
 Function Prototypes 
 CONFIG_USB_GADGET_DEBUG_FILES 
 supported OIDs 
 the general stuff 
 the statistical stuff 
 RNDIS_OPTIONAL_STATS 
 mandatory 802.3 
 the general stuff 
 the statistical stuff 
 RNDIS_OPTIONAL_STATS 
	 PM and wakeup are "mandatory" for USB, but the RNDIS specs
	  don't say what they mean ... and the NDIS specs are often
	  confusing andor ambiguous in this context.  (That is, more
	  so than their specs for the other OIDs.)
	 
	  FIXME someone who knows what these should do, please
	  implement them!
 power management 
 wake up host 
 RNDIS_WAKEUP 
 RNDIS_PM 
 NDIS Functions 
 usually 
 response goes here, right after the header 
 general oids (table 4-1) 
 mandatory 
 mandatory 
		 Bogus question!
		  Hardware must be ready to receive high level protocols.
		  BTW:
		  reddite ergo quae sunt Caesaris Caesari
		  et quae sunt Dei Deo!
 mandatory 
 mandatory 
 one medium, one transport... (maybe you do it better) 
 mandatory 
 mandatory 
 mandatory 
 mandatory 
 mandatory 
 mandatory 
 Created as LE 
 mandatory 
 mandatory 
 mandatory 
	 The RNDIS specification is incompletewrong.   Some versions
	  of MS-Windows expect OIDs that aren't specified there.  Other
	  versions emit undefined RNDIS messages. DOCUMENT ALL THESE!
 from WinME 
 statistics OIDs (table 4-2) 
 mandatory 
 mandatory 
 mandatory 
 mandatory 
 mandatory 
 ieee802.3 OIDs (table 4-3) 
 mandatory 
 mandatory 
 mandatory 
 Multicast base address only 
 mandatory 
 Multicast base address only 
 ieee802.3 statistics OIDs (table 4-4) 
 mandatory 
 mandatory 
 mandatory 
		 these NDIS_PACKET_TYPE_ bitflags are shared with
		  cdc_filter; it's not RNDIS-specific
		  NDIS_PACKET_TYPE_x == USB_CDC_PACKET_TYPE_x for x in:
		 	PROMISCUOUS, DIRECTED,
		 	MULTICAST, ALL_MULTICAST, BROADCAST
		 this call has a significant side effect:  it's
		  what makes the packet flow start and stop, like
		  activating the CDC Ethernet altsetting.
 I think we can ignore this 
  Response Functions
 Still LE in msg buffer 
 pr_debug("%s: OID = %08X\n", __func__, cpu_to_le32(buf->OID)); 
	
	  we need more memory:
	  gen_ndis_query_resp expects enough space for
	  rndis_query_cmplt_type followed by data.
	  oid_supported_list is the largest data reply
 Still LE in msg buffer 
 OID not supported 
 Still LE in msg buffer 
 drain the response queue 
 resent information 
 host "should" check only in RNDIS_DATA_INITIALIZED state 
 Still LE in msg buffer 
  Device to Host Comunication
 drain the response queue 
  Message Parser
	 NOTE: RNDIS is EXTREMELY chatty ... Windows constantly polls for
	  rxtx statistics and link status, in addition to KEEPALIVE traffic
	  and normal HC level polling to see if there's any IN traffic.
 For USB: responses may take up to 10 seconds 
 For USB: host does this every 5 seconds 
		 At least Windows XP emits some undefined RNDIS messages.
		  In one case those messages seemed to relate to the host
		  suspending itself.
 Garbled message can be huge, so limit what we display 
 NOTE: this gets copied into ether.c USB_BUFSIZ bytes ... 
 tmp points to a struct rndis_packet_msg_type 
 MessageType, MessageLength 
 DataOffset, DataLength 
 CONFIG_USB_GADGET_DEBUG_FILES 
 SPDX-License-Identifier: GPL-2.0+
  f_sourcesink.c - USB peripheral sourcesink configuration driver
  Copyright (C) 2003-2008 David Brownell
  Copyright (C) 2008 by Nokia Corporation
 #define VERBOSE_DEBUG 
  SOURCESINK FUNCTION ... a primary testing vehicle for USB peripheral
  controller drivers.
  This just sinks bulk packets OUT to the peripheral and sources them IN
  to the host, optionally with specific data patterns for integrity tests.
  As such it supports basic functionality and load tests.
  In terms of control messaging, this supports all the standard requests
  plus two that support control-OUT tests.  If the optional "autoresume"
  mode is enabled, it provides good functional coverage for the "USBCV"
  test harness from USB-IF.
-------------------------------------------------------------------------
 .iInterface		= DYNAMIC 
 .iInterface		= DYNAMIC 
 full speed support: 
 high speed support: 
 super speed support: 
 function-specific strings: 
 end of list 
 en-us 
-------------------------------------------------------------------------
 allocate interface ID(s) 
 allocate bulk endpoints 
 sanity check the isoc module parameters 
 fill in the FS isoc descriptors from the module parameters 
 allocate iso endpoints 
		
		  We still want to work even if the UDC doesn't have isoc
		  endpoints, so null out the alt interface that contains
		  them and continue.
 support high speed hardware 
	
	  Fill in the HS isoc descriptors from the module parameters.
	  We assume that the user knows what they are doing and won't
	  give parameters that their UDC doesn't support.
 support super speed hardware 
	
	  Fill in the SS isoc descriptors from the module parameters.
	  We assume that the user knows what they are doing and won't
	  give parameters that their UDC doesn't support.
 optionally require specific sourcesink data patterns  
 all-zeroes has no synchronization issues 
		 "mod63" stays in sync with short-terminated transfers,
		  OR otherwise when host and gadget agree on how large
		  each usb transfer request should be.  Resync is done
		  with set_interface or set_config.  (We WANT it to
		  get quickly out of sync if controllers or their drivers
		  stutter for any reason, including buffer duplication...)
 driver_data will be null if ep has been disabled 
 normal completion? 
 this endpoint is normally active while we're configured 
 hardware forced ep reset 
 request dequeued 
 disconnect from host 
	case -EOVERFLOW:		 buffer overrun on read means that
					  we didn't provide a big enough
					  buffer.
 short read 
 FIXME recover later ... somehow 
 one bulk endpoint writes (sources) zeroes IN (to the host) 
 one bulk endpoint reads (sinks) anything OUT (from the host) 
 one iso endpoint writes (sources) zeroes IN (to the host) 
 one iso endpoint reads (sinks) anything OUT (from the host) 
-------------------------------------------------------------------------
	 composite driver infrastructure handles everything except
	  the two control test requests.
	
	  These are the same vendor-specific requests supported by
	  Intel's USB 2.0 compliance test devices.  We exceed that
	  device spec by allowing multiple-packet requests.
	 
	  NOTE:  the Control-OUT data stays in req->buf ... better
	  would be copying it into a scratch buffer, so that other
	  requests may safely intervene.
 control WRITE test -- fill the buffer 
 just read that many bytes into the buffer 
 control READ test -- return the buffer 
 expect those bytes are still in the buffer; send back 
 respond with data transfer or status phase? 
 device either stalls (value < 0) or reports success 
 SPDX-License-Identifier: GPL-2.0+
  f_loopback.c - USB peripheral loopback configuration driver
  Copyright (C) 2003-2008 David Brownell
  Copyright (C) 2008 by Nokia Corporation
 #define VERBOSE_DEBUG 
  LOOPBACK FUNCTION ... a testing vehicle for USB peripherals,
  This takes messages of various sizes written OUT to a device, and loops
  them back so they can be read IN from it.  It has been used by certain
  test applications.  It supports limited testing of data queueing logic.
-------------------------------------------------------------------------
 .iInterface = DYNAMIC 
 full speed support: 
 high speed support: 
 super speed support: 
 function-specific strings: 
 end of list 
 en-us 
-------------------------------------------------------------------------
 allocate interface ID(s) 
 allocate endpoints 
 support high speed hardware 
 support super speed hardware 
 normal completion? 
			
			  We received some data from the host so let's
			  queue it so host can read the from our in ep
			
			  We have just looped back a bunch of data
			  to host. Now let's wait for some more data.
 queue the buffer back to host or for next bunch of data 
 "should never get here" 
	 NOTE:  since this driver doesn't maintain an explicit record
	  of requests it submitted (just maintains qlen count), we
	  rely on the hardware driver to clean up on disconnect or
	  endpoint disable.
 hardware forced ep reset 
 request dequeued 
 disconnect from host 
	
	  allocate a bunch of read buffers and queue them all at once.
	  we buffer at most 'qlen' transfers; We allocate buffers only
	  for out transfer and reuse them in IN transfers to implement
	  our loopback functionality
 length will be set in complete routine 
 we know alt is zero 
 SPDX-License-Identifier: GPL-2.0+
  f_midi.c -- USB MIDI class function driver
  Copyright (C) 2006 Thumtronics Pty Ltd.
  Developed for Thumtronics by Grey Innovation
  Ben Williamson <ben.williamson@greyinnovation.com>
  Rewritten for the composite framework
    Copyright (C) 2011 Daniel Mack <zonque@gmail.com>
  Based on driversusbgadgetf_audio.c,
    Copyright (C) 2008 Bryan Wu <cooloney@kernel.org>
    Copyright (C) 2008 Analog Devices, Inc
  and driversusbgadgetmidi.c,
    Copyright (C) 2006 Thumtronics Pty Ltd.
    Ben Williamson <ben.williamson@greyinnovation.com>
  We can only handle 16 cables on one single endpoint, as cable numbers are
  stored in 4-bit fields. And as the interface currently only holds one
  single endpoint, this is the maximum number of ports we can allow.
 MIDI message states 
 pseudo state 
 pseudo state 
  This is a gadget, and the INOUT naming is from the host's perspective.
  USB -> OUT endpoint -> rawmidi
  USB <- IN endpoint  <- rawmidi
 This fifo is used as a buffer ring for pre-allocated IN usb_requests 
 in_ports ];
 B.3.1  Standard AC Interface Descriptor 
 .bInterfaceNumber =	DYNAMIC 
 .bNumEndpoints =	DYNAMIC 
 .iInterface =	DYNAMIC 
 B.3.2  Class-Specific AC Interface Descriptor 
 .baInterfaceNr =	DYNAMIC 
 B.4.1  Standard MS Interface Descriptor 
 .bInterfaceNumber =	DYNAMIC 
 .iInterface =	DYNAMIC 
 B.4.2  Class-Specific MS Interface Descriptor 
 .wTotalLength =	DYNAMIC 
 B.5.1  Standard Bulk OUT Endpoint Descriptor 
 .bMaxBurst           = 0, 
 .bmAttributes        = 0, 
 B.5.2  Class-specific MS Bulk OUT Endpoint Descriptor 
 .bLength =		DYNAMIC 
 .bNumEmbMIDIJack =	DYNAMIC 
 .baAssocJackID =	DYNAMIC 
 B.6.1  Standard Bulk IN Endpoint Descriptor 
 .bMaxBurst           = 0, 
 .bmAttributes        = 0, 
 B.6.2  Class-specific MS Bulk IN Endpoint Descriptor 
 .bLength =		DYNAMIC 
 .bNumEmbMIDIJack =	DYNAMIC 
 .baAssocJackID =	DYNAMIC 
 string IDs are assigned dynamically 
 end of list 
 en-us 
  Receives a chunk of MIDI data.
 Nobody is listening - throw it on the floor. 
 normal completion 
 We received stuff. req is queued again, below 
			 Our transmit completed. See if there's more to go.
 this endpoint is normally active while we're configured 
 hardware forced ep reset 
 request dequeued 
 disconnect from host 
			 We don't need to free IN requests because it's handled
	case -EOVERFLOW:	 buffer overrun on read means that
				  we didn't provide a big enough buffer.
 short read 
 FIXME recover later ... somehow 
 we only set alt for MIDIStreaming interface 
 pre-allocate write usb requests to use on f_midi_transmit. 
 allocate a bunch of read buffers and queue them all at once. 
	
	  just disable endpoints, forcing completion of pending io.
	  all our completion handlers free their requests in this case.
 release IN requests 
  Converts MIDI commands to USB MIDI packets.
 System Real-Time Messages 
 End of SysEx 
 Ignore byte 
 System Common Messages 
		
		  Channel Voice Messages, Channel Mode Messages
		  and Control Change Messages.
 Message parameters 
 This is to allow Running State Messages 
 This is to allow Running State Messages 
 States where we have to write into the USB request 
	
	  We peek the request in order to reuse it if it fails to enqueue on
	  its endpoint
	
	  If buffer overrun, then we ignore this transmission.
	  IMPORTANT: This will cause the user-space rawmidi device to block
	  until a) usb requests have been completed or b) snd_rawmidi_write()
	  times out.
 Re-use request next time. 
 Upon success, put request at the back of the queue. 
 We only care about USB requests if IN endpoint is enabled 
 register as a sound "card" 
 Set up rawmidi 
	
	  Yes, rawmidi OUTPUT = USB IN, and rawmidi INPUT = USB OUT.
	  It's an upside-down world being a gadget.
 register it - we're ready to go 
 MIDI function driver setupbinding 
 maybe allocate device-global string ID 
 We have two interfaces, AudioControl and MIDIStreaming 
 allocate instance-specific endpoints 
 allocate temporary function list 
	
	  construct the function's descriptor set. As the number of
	  input and output MIDI ports is configurable, we have to do
	  it that way.
 add the headers - these are always the same 
 calculate the header's wTotalLength 
 configure the external IN jacks, each linked to an embedded OUT jack 
 link it to the endpoint 
 configure the external OUT jacks, each linked to an embedded IN jack 
 link it to the endpoint 
 configure the endpoint descriptors ... 
 ... and add them to the list 
	
	  support all relevant hardware speeds... we expect that when
	  hardware is dual speed, all bulk-capable endpoints work at
	  both speeds
 copy descriptors, and track endpoint copies 
 just to be sure 
 sanity check 
 allocate and initialize one new instance 
 set up ALSA midi devices 
 SPDX-License-Identifier: GPL-2.0+
  f_uac1.c -- USB Audio Class 1.0 Function (using u_audio API)
  Copyright (C) 2016 Ruslan Bilovol <ruslan.bilovol@gmail.com>
  This driver doesn't expect any real Audio codec to be present
  on the device - the audio streams are simply sinked to and
  sourced from a virtual ALSA sound card created.
  This file is based on f_uac1.c which is
    Copyright (C) 2008 Bryan Wu <cooloney@kernel.org>
    Copyright (C) 2008 Analog Devices, Inc
 UAC1 spec: 3.7.2.3 Audio Channel Cluster Format 
 needed for get_alt() 
 will be used in data stage 
 Interrupt IN endpoint of AC interface 
  DESCRIPTORS ... most are static, but strings and full
  configuration descriptors are built on demand.
  We have three interfaces - one AudioControl and two AudioStreaming
  The driver implements a simple UAC_1 topology.
  USB-OUT -> IT_1 -> OT_2 -> ALSA_Capture
  ALSA_Playback -> IT_3 -> OT_4 -> USB-IN
 B.3.1  Standard AC Interface Descriptor 
 .bNumEndpoints =	DYNAMIC 
 B.3.2  Class-Specific AC Interface Descriptor 
 .bTerminalID =	DYNAMIC 
 .bTerminalID =	DYNAMIC 
 .bSourceID =		DYNAMIC 
 .bTerminalID		= DYNAMIC 
 .bTerminalID =	DYNAMIC 
 .bSourceID =		DYNAMIC 
 AC IN Interrupt Endpoint 
 B.4.1  Standard AS Interface Descriptor 
 B.4.2  Class-Specific AS Interface Descriptor 
 .bTerminalLink =	DYNAMIC 
 .bTerminalLink =	DYNAMIC 
 Standard ISO OUT Endpoint Descriptor 
 Class-specific AS ISO OUT Endpoint Descriptor 
 Standard ISO OUT Endpoint Descriptor 
 Class-specific AS ISO OUT Endpoint Descriptor 
 en-us 
  This function is an ALSA sound card following USB Audio Class Spec 1.0.
	 composite driver infrastructure handles everything; interface
	  activation uses set_alt().
 respond with data transfer or status phase? 
 device either stalls (value < 0) or reports success 
 No if has more than 2 alt settings 
 Control If has only 1 AltSetting - 0 
 restart interrupt endpoint 
-------------------------------------------------------------------------
 bUnitID, bSourceID and bmaControls will be defined later 
 B.3.2  Class-Specific AC Interface Descriptor 
 wTotalLength and baInterfaceNr will be defined later 
 Use macro to overcome line length limitation 
 patch descriptors 
 ID's start with 1 
 audio function driver setupbinding 
 Set channel numbers 
 Set sample rates 
 allocate instance-specific interface IDs, and patch descriptors 
 allocate AC interrupt endpoint 
 allocate instance-specific endpoints 
 copy descriptors, and track endpoint copies 
-------------------------------------------------------------------------
 allocate and initialize one new instance 
 SPDX-License-Identifier: GPL-2.0+
 	uvc_queue.c  --  USB Video Class driver - Buffers management
 	Copyright (C) 2005-2010
 	    Laurent Pinchart (laurent.pinchart@ideasonboard.com)
 ------------------------------------------------------------------------
  Video buffers queue management.
  Video queues is initialized by uvcg_queue_init(). The function performs
  basic initialization of the uvc_video_queue struct and never fails.
  Video buffers are managed by videobuf2. The driver uses a mutex to protect
  the videobuf2 queue operations by serializing calls to videobuf2 and a
  spinlock to protect the IRQ queue that holds the buffers to be processed by
  the driver.
 -----------------------------------------------------------------------------
  videobuf2 queue operations
		 If the device is disconnected return the buffer to userspace
		  directly. The next QBUF call will fail with -ENODEV.
  Free the video buffers.
  Allocate the video buffers.
  Dequeue a video buffer. If nonblocking is false, block until a buffer is
  available.
  Poll the video queue.
  This function implements video queue polling and is intended to be used by
  the device poll handler.
  Get unmapped area.
  NO-MMU arch need this function to make mmap() work correctly.
  Cancel the video buffers queue.
  Cancelling the queue marks all buffers on the irq queue as erroneous,
  wakes them up and removes them from the queue.
  If the disconnect parameter is set, further calls to uvc_queue_buffer will
  fail with -ENODEV.
  This function acquires the irq spinlock and can be called from interrupt
  context.
	 This must be protected by the irqlock spinlock to avoid race
	  conditions between uvc_queue_buffer and the disconnection event that
	  could result in an interruptible wait in uvc_dequeue_buffer. Do not
	  blindly replace this logic by checking for the UVC_DEV_DISCONNECTED
	  state outside the queue code.
  Enable or disable the video buffers queue.
  The queue must be enabled before starting video acquisition and must be
  disabled after stopping it. This ensures that the video buffers queue
  state can be properly initialized before buffers are accessed from the
  interrupt handler.
  Enabling the video queue initializes parameters (such as sequence number,
  sync pattern, ...). If the queue is already enabled, return -EBUSY.
  Disabling the video queue cancels the queue and removes all buffers from
  the main queue.
  This function can't be called from interrupt context. Use
  uvcg_queue_cancel() instead.
		
		  FIXME: We need to clear the DISCONNECTED flag to ensure that
		  applications will be able to queue buffers for the next
		  streaming run. However, clearing it here doesn't guarantee
		  that the device will be reconnected in the meantime.
 called with &queue_irqlock held.. 
 SPDX-License-Identifier: GPL-2.0+
  f_obex.c -- USB CDC OBEX function driver
  Copyright (C) 2008 Nokia Corporation
  Contact: Felipe Balbi <felipe.balbi@nokia.com>
  Based on f_acm.c by Al Borchers and David Brownell.
 #define VERBOSE_DEBUG 
  This CDC OBEX function support just packages a TTY-ish byte stream.
  A user mode server will put it into "raw" mode and handle all the
  relevant protocol details ... this is just a kernel passthrough.
  When possible, we prevent gadget enumeration until that server is
  ready to handle the commands.
-------------------------------------------------------------------------
 end of list 
 en-US 
-------------------------------------------------------------------------
 High-Speed Support 
 Full-Speed Support 
-------------------------------------------------------------------------
 NOP 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 Some controllers can't support CDC OBEX ... 
	 Since the first interface is a NOP, we can ignore the
	  issue of multi-interface support on most controllers.
	 
	  Altsettings are mandatory, however...
 everything else is probably fine ... 
 allocate instance-specific interface IDs, and patch descriptors 
 allocate instance-specific endpoints 
	 support all relevant hardware speeds... we expect that when
	  hardware is dual speed, all bulk-capable endpoints work at
	  both speeds
 allocate and initialize one new instance 
 descriptors are per-instance copies 
 SPDX-License-Identifier: GPL-2.0+
  u_uac1.c -- ALSA audio utilities for Gadget stack
  Copyright (C) 2008 Bryan Wu <cooloney@kernel.org>
  Copyright (C) 2008 Analog Devices, Inc
  This component encapsulates the ALSA devices for USB audio gadget
-------------------------------------------------------------------------
  Some ALSA internal helper functions
-------------------------------------------------------------------------
  Set default hardware params
	 SNDRV_PCM_ACCESS_RW_INTERLEAVED,
	 SNDRV_PCM_FORMAT_S16_LE
	 CHANNELS: 2
	 RATE: 48000
 Store the hardware parameters 
  Playback audio buffer data by ALSA PCM device
  Open ALSA PCM and control device files
  Initial the PCM or control device
 Open control device 
 Open PCM playback device and setup substream 
 Open PCM capture device and setup substream 
  Close ALSA PCM and control device files
 Close control device 
 Close PCM playback device and setup substream 
 Close PCM capture device and setup substream 
  gaudio_setup - setup ALSA interface and preparing for USB transfer
  This sets up PCM, mixer or MIDI ALSA devices fore USB gadget using.
  Returns negative errno, or zero on success
  gaudio_cleanup - remove ALSA device interface
  This is called to free all resources allocated by @gaudio_setup().
 SPDX-License-Identifier: GPL-2.0+
  f_ncm.c -- USB CDC Network (NCM) link function driver
  Copyright (C) 2010 Nokia Corporation
  Contact: Yauheni Kaliuta <yauheni.kaliuta@nokia.com>
  The driver borrows from f_ecm.c which is:
  Copyright (C) 2003-2005,2008 David Brownell
  Copyright (C) 2008 Nokia Corporation
  This function is a "CDC Network Control Model" (CDC NCM) Ethernet link.
  NCM is intended to be used with high-speed network attachments.
  Note that NCM requires the use of "alternate settings" for its data
  interface.  This means that the set_alt() method has real work to do,
  and also means that a get_alt() method is required.
 to trigger crcnon-crc ndp signature 
 don't notify 
 issue CONNECT next 
 issue SPEED_CHANGE next 
	
	  for notification, it is accessed from both
	  callback and ethernet openclose
 For multi-frame NDP TX 
 peak (theoretical) bulk transfer rate in bits-per-second 
-------------------------------------------------------------------------
  We cannot group frames so use just the minimal size which ok to put
  one max-size ethernet frame.
  If the host can group frames, allow it to do that, 16K is selected,
  because it's used by default by the current linux host driver
 Allocation for storing the NDP, 32 should suffice for a
  16k packet. This allows a maximum of 32  507 Byte packets to
  be transmitted in a single 16kB skb, though when sending full size
  packets this limit will be plenty.
  Smaller packets are not likely to be trying to maximize the
  throughput and will be mstly sending smaller infrequent frames.
 Delay for the transmit to wait before sending an unfilled NTB frame. 
  Use wMaxPacketSize big enough to fit CDC_NOTIFY_SPEED_CHANGE in one
  packet, to simplify cancellation; and a big transfer interval, to
  waste less bandwidth.
 8 byte header + data 
 .bFirstInterface =	DYNAMIC, 
 control + data 
 .iFunction =		DYNAMIC 
 interface descriptor: 
 .bInterfaceNumber = DYNAMIC 
 .iInterface = DYNAMIC 
 .bMasterInterface0 =	DYNAMIC 
 .bSlaveInterface0 =	DYNAMIC 
 this descriptor actually adds value, surprise! 
 .iMACAddress = DYNAMIC 
 no statistics 
 can process SetEthernetPacketFilter 
 the default data interface has no endpoints ... 
 .iInterface = DYNAMIC 
 ... but the "real" data interface has two bulk endpoints 
 .iInterface = DYNAMIC 
 full speed support: 
 CDC NCM control descriptors 
 data interface, altsettings 0 and 1 
 high speed support: 
 CDC NCM control descriptors 
 data interface, altsettings 0 and 1 
 super speed support: 
 the following 3 values can be tweaked if necessary 
 .bMaxBurst =		0, 
 .bmAttributes =	0, 
 the following 2 values can be tweaked if necessary 
 .bmAttributes =	0, 
 CDC NCM control descriptors 
 data interface, altsettings 0 and 1 
 string descriptors: 
 end of list 
 en-us 
  Here are options for NCM Datagram Pointer table (NDP) parser.
  There are 2 different formats: NDP16 and NDP32 in the spec (ch. 3),
  in NDP16 offsets and sizes fields are 1 16bit word wide,
  in NDP32 -- 2 16bit words wide. Also signatures are different.
  To make the parser code the same, put the differences in the structure,
  and switch pointers to the structures when the format is changed.
 sizes in u16 units 
 index or length 
-------------------------------------------------------------------------
 doesn't make sense for ncm, fixed size used 
  Context: ncm->lock held
 notification already in flight? 
 SPEED_CHANGE data is updown speeds in bitssec 
	
	  In double buffering if there is a space in FIFO,
	  completion callback can be called right after the call,
	  so unlocking
  Context: ncm->lock held
	
	  NOTE on most versions of Linux, host side cdc-ethernet
	  won't listen for notifications until its netdevice opens.
	  The first notification then sits in the FIFO for a long
	  time, and the second one is queued.
	 
	  If ncm_notify() is called before the second (CONNECT)
	  notification is sent, then it will reset to send the SPEED
	  notificaion again (and again, and again), but it's not a problem
 now for SET_NTB_INPUT_SIZE only 
	
	  composite driver infrastructure handles everything except
	  CDC class messages; interface activation uses set_alt().
		
		  see 6.2.30: no data, wIndex = interface,
		  wValue = packet filter bitmap
		
		  REVISIT locking of cdc_filter.  This assumes the UDC
		  driver won't have a concurrent packet TX irq running on
		  another CPU; or that if it does, this write is atomic...
	
	  and optionally:
	  case USB_CDC_SEND_ENCAPSULATED_COMMAND:
	  case USB_CDC_GET_ENCAPSULATED_RESPONSE:
	  case USB_CDC_SET_ETHERNET_MULTICAST_FILTERS:
	  case USB_CDC_SET_ETHERNET_PM_PATTERN_FILTER:
	  case USB_CDC_GET_ETHERNET_PM_PATTERN_FILTER:
	  case USB_CDC_GET_ETHERNET_STATISTIC:
 and disabled in ncm descriptor: 
 case USB_CDC_GET_NET_ADDRESS: 
 case USB_CDC_SET_NET_ADDRESS: 
 case USB_CDC_GET_MAX_DATAGRAM_SIZE: 
 case USB_CDC_SET_MAX_DATAGRAM_SIZE: 
 respond with data transfer or status phase? 
 device either stalls (value < 0) or reports success 
 Control interface has only altsetting 0 
 Data interface has two altsettings, 0 and 1 
		
		  CDC Network only sends data in non-default altsettings.
		  Changing altsettings resets filters, statistics, etc.
 TODO 
			 Enable zlps by default for NCM conformance;
			  override for musb_hdrc (avoids txdma ovhead)
  Because the data interface supports multiple altsettings,
  this NCM function MUST implement a get_alt() method.
 Stop the timer 
 Set the final BlockLength and wNdpIndex 
 Increment pointer to BlockLength 
 Set the final NDP wLength 
 Increment from start to wLength 
 Merge the skbs 
 Insert NDP alignment. 
 Copy NTB across. 
 Insert zero'd datagram. 
 Add the CRC if required up front 
		 If the new skb is too big for the current NCM NTB then
		  set the current stored skb to be sent now and clear it
		  ready for new data.
		  NOTE: Assume maximum align for speed of calculation.
 Create a new skb for the NTH and datagrams. 
 dwSignature 
 wHeaderLength 
			 Allocate an skb for storing the NDP,
			  TX_MAX_NUM_DPE should easily suffice for a
			  16k packet.
 dwSignature 
 There is always a zeroed entry 
 Note: we skip opts->next_ndp_index 
 Start the timer. 
 Add the datagram position entries 
 (d)wDatagramIndex 
 (d)wDatagramLength 
 Add the new data to the skb 
		 If we get here ncm_wrap_ntb() was called with NULL skb,
		  because eth_start_xmit() was called with NULL skb by
		  ncm_tx_timeout() - hence, this is our signal to flushsend.
  The transmit should only be run if no skb data has been sent
  for a certain duration.
		 XXX This allowance of a NULL skb argument to ndo_start_xmit
		  XXX is not sane.  The gadget layer should be redesigned so
		  XXX that the dev->wrap() invocations to build SKBs is transparent
		  XXX and performed in some way outside of the ndo_start_xmit
		  XXX interface.
		 
		  This will call directly into u_ether's eth_start_xmit()
 dwSignature 
 wHeaderLength 
 skip wSequence 
 (d)wBlockLength 
 Run through all the NDP's in the NTB 
		
		  NCM 3.2
		  dwNdpIndex
		
		  walk through NDP
		  dwSignature
		
		  NCM 3.3.1
		  wLength
		  entry is 2 items
		  item size is 1632 bits, opts->dgram_item_len  2 bytes
		  minimal: struct usb_cdc_ncm_ndpX + normal entry + zero entry
		  Each entry is a dgram index and a dgram length.
 Check for another NDP (d)wNextNdpIndex 
 wDatagramIndex[0] 
			
			  wDatagramLength[0]
			  ethernet hdr + crc or larger than max frame size
 wDatagramIndex[1] 
			
			  Copy the data into a new skb.
			  This ensures the truesize is correct
-------------------------------------------------------------------------
  Callbacks let us notify the host about connectdisconnect when the
  net device is opened or closed.
  For testing, note that link states on this side include both opened
  and closed variants of:
    - disconnectedunconfigured
    - configured but inactive (data alt 0)
    - configured and active (data alt 1)
  Each needs to be tested with unplug, rmmod, SET_CONFIGURATION, and
  SET_INTERFACE (altsetting).  Remember also that "configured" doesn't
  imply the host is actually polling the notification endpoint, and
  likewise that "active" doesn't imply it's actually using the data
  endpoints for traffic.
-------------------------------------------------------------------------
 ethernet function driver setupbinding 
	
	  in driversusbgadgetconfigfs.c:configfs_composite_bind()
	  configurations are bound in sequence with list_for_each_entry,
	  in each configuration its functions are bound in sequence
	  with list_for_each_entry, so we assume no race condition
	  with regard to ncm_opts->bound access
 allocate instance-specific interface IDs 
 allocate instance-specific endpoints 
 allocate notification request and buffer 
	
	  support all relevant hardware speeds... we expect that when
	  hardware is dual speed, all bulk-capable endpoints work at
	  both speeds
	
	  NOTE:  all that is done without knowing or caring about
	  the network link ... which is unavailable to this code
	  until we're activated via set_alt().
 f_ncm_item_ops 
 f_ncm_opts_dev_addr 
 f_ncm_opts_host_addr 
 f_ncm_opts_qmult 
 f_ncm_opts_ifname 
 allocate and initialize one new instance 
 export host's Ethernet address in CDC format 
 strlen("01234567890a") 
 descriptors are per-instance copies 
 SPDX-License-Identifier: GPL-2.0+
  u_audio.c -- interface to USB gadget "ALSA sound card" utilities
  Copyright (C) 2016
  Author: Ruslan Bilovol <ruslan.bilovol@gmail.com>
  Sound card implementation was cut-and-pasted with changes
  from f_uac2.c and has:
     Copyright (C) 2011
     Yadwinder Singh (yadi.brar01@gmail.com)
     Jaswinder Singh (jaswinder.singh@linaro.org)
 Runtime data params for one stream 
 parent chip 
 if the ep is enabled 
 Ring buffer 
 Stream pitch ratio to 1000000 
 MaxPacketSize of endpoint 
 Feedback endpoint request 
 if the ep is enabled 
 VolumeMute controls and their state 
 Feature Unit ID 
 lock for control transfers 
 pre-calculated values for playback iso completion 
	
	  Because the pitch base is 1000000, the final divider here
	  will be 1000  1000000 = 1953125 << 9
	 
	  Instead of dealing with big numbers lets fold this 9 left shift
		
		  Full-speed feedback endpoints report frequency
		  in samplesframe
		  Format is encoded in Q10.10 left-justified in the 24 bits,
		  so that it has a Q10.14 format.
		 
		  ff = (freq << 14)  1000
		
		  High-speed feedback endpoints report frequency
		  in samplesmicroframe.
		  Format is encoded in Q12.13 fitted into four bytes so that
		  the binary point is located between the second and the third
		  byte fromat (that is Q16.16)
		 
		  ff = (freq << 16)  8000
		 
		  Win10 and OSX UAC2 drivers require number of samples per packet
		  in order to honor the feedback value.
		  Linux snd-usb-audio detects the applied bit-shift automatically.
 if shutting down 
	
	  We can't really do much about bad xfers.
	  Afterall, the ISOCH xfers could fail legitimately.
 Do nothing if ALSA isn't active 
		
		  For each IN packet, take the quotient of the current data
		  rate and the endpoint's interval as the base packet size.
		  If there is a residue from this division, add it to the
		  residue accumulator.
		
		  Whenever there are more bytes in the accumulator p_residue_mil than we
		  need to add one more sample frame, increase this packet's
		  size and decrease the accumulator.
 Pack USB load in ALSA ring buffer 
 update hw_ptr after data is copied to memory 
 if shutting down 
	
	  We can't really do much about bad xfers.
	  Afterall, the ISOCH xfers could fail legitimately.
 Reset 
 Clear buffer after Play stops 
 ALSA cries without these function pointers 
			
			  If usb_ep_dequeue() cannot successfully dequeue the
			  request, the request will be freed by the completion
			  callback.
 Setup feedback endpoint 
	
	  Configure the feedback endpoint's reported frequency.
	  Always start with original frequency since its deviation can't
	  be meauserd at start of playback
	
	  Always start with original frequency
 pre-calculate the playback endpoint's interval 
 pre-compute some values for iso_complete() 
  TLV callback for mixer volume controls
 UAC volume resolution is 1256 dB, TLV is 1100 dB 
 will be filled later 
 will be filled later 
 Choose any slot, with no id 
	
	  Create first PCM device
	  Create a substream only for non-zero channel streams
	
	  Create mixer and controls
	  Create only if it's required on USB side
 SPDX-License-Identifier: GPL-2.0+
  f_acm.c -- USB CDC serial (ACM) function driver
  Copyright (C) 2003 Al Borchers (alborchers@steinerpoint.com)
  Copyright (C) 2008 by David Brownell
  Copyright (C) 2008 by Nokia Corporation
  Copyright (C) 2009 by Samsung Electronics
  Author: Michal Nazarewicz (mina86@mina86.com)
 #define VERBOSE_DEBUG 
  This CDC ACM function support just wraps control functions and
  notifications around the generic serial-over-usb code.
  Because CDC ACM is standardized by the USB-IF, many host operating
  systems have drivers for it.  Accordingly, ACM is the preferred
  interop solution for serial-port type connections.  The control
  models are often not necessary, and in any case don't do much in
  this bare-bones implementation.
  Note that even MS-Windows has some support for ACM.  However, that
  support is somewhat broken because when you use ACM in a composite
  device, having multiple interfaces confuses the poor OS.  It doesn't
  seem to understand CDC Union descriptors.  The new "association"
  descriptors (roughly equivalent to CDC Unions) may sometimes help.
	 lock is mostly for pending and notify_req ... they get accessed
	  by callbacks both from tty (openclosebreak) under its spinlock,
	  and notify_req.complete() which can't use that lock.
 8-N-1 etc 
 SetControlLineState request -- CDC 1.1 section 6.2.14 (INPUT) 
 unused with full duplex 
 host is ready for data rw 
 SerialState notification -- CDC 1.1 section 6.3.5 (OUTPUT) 
-------------------------------------------------------------------------
 notification endpoint uses smallish and infrequent fixed-size messages 
 notification + 2 bytes 
 interface and class descriptors: 
 .bFirstInterface =	DYNAMIC, 
 control + data
 .iFunction =		DYNAMIC 
 .bInterfaceNumber = DYNAMIC 
 .iInterface = DYNAMIC 
 .bInterfaceNumber = DYNAMIC 
 .iInterface = DYNAMIC 
 .bDataInterface = DYNAMIC 
 .bMasterInterface0 =	DYNAMIC 
 .bSlaveInterface0 =	DYNAMIC 
 full speed support: 
 high speed support: 
 string descriptors: 
 static strings, in UTF-8 
 end of list 
 en-us 
-------------------------------------------------------------------------
 ACM control ... data handling is delegated to tty library code.
  The main task of this function is to activate and deactivate
  that code based on device state; track parameters like line
  speed, handshake state, and so on; and issue notifications.
 normal completion 
		 REVISIT:  we currently just remember this data.
		  If we change that, (a) validate it first, then
		  (b) update whatever hardware needs updating,
		  (c) worry about locking.  This is information on
		  the order of 9600-8-N-1 ... most of which means
		  nothing unless we control a real RS232 line.
	 composite driver infrastructure handles everything except
	  CDC class messages; interface activation uses set_alt().
	 
	  Note CDC spec table 4 lists the ACM request profile.  It requires
	  encapsulated command support ... we don't handle any, and respond
	  to them by stalling.  Options include getsetclear comm features
	  (not that useful) and SEND_BREAK.
 SET_LINE_CODING ... just read and save what the host sends 
 GET_LINE_CODING ... return what host sent, or initial value 
 SET_CONTROL_LINE_STATE ... save what the host sent 
		 FIXME we should not allow data to flow until the
		  host sets the ACM_CTRL_DTR bit; and when it clears
		  that bit, we should return to that no-flow state.
 respond with data transfer or status phase? 
 device either stalls (value < 0) or reports success 
 we know alt == 0, so this is an activation or a reset 
-------------------------------------------------------------------------
  acm_cdc_notify - issue CDC notification to host
  @acm: wraps host to be notified
  @type: notification type
  @value: Refer to cdc specs, wValue field.
  @data: data to be sent
  @length: size of data
  Context: irqs blocked, acm->lock held, acm_notify_req non-null
  Returns zero on success or a negative errno.
  See section 6.3.5 of the CDC 1.1 specification for information
  about the only notification we issue:  SerialState change.
 ep_queue() can complete immediately if it fills the fifo... 
	 on this call path we do NOT hold the port spinlock,
	  which is why ACM needs its own spinlock
 connect == the TTY link is open 
-------------------------------------------------------------------------
 ACM function driver setupbinding 
	 REVISIT might want instance-specific strings to help
	  distinguish instances ...
 maybe allocate device-global string IDs, and patch descriptors 
 allocate instance-specific interface IDs, and patch descriptors 
 allocate instance-specific endpoints 
 allocate notification 
	 support all relevant hardware speeds... we expect that when
	  hardware is dual speed, all bulk-capable endpoints work at
	  both speeds
 descriptors are per-instance copies 
 CONFIG_U_SERIAL_CONSOLE 
 SPDX-License-Identifier: GPL-2.0+
  f_serial.c - generic USB serial function driver
  Copyright (C) 2003 Al Borchers (alborchers@steinerpoint.com)
  Copyright (C) 2008 by David Brownell
  Copyright (C) 2008 by Nokia Corporation
  This function packages a simple "generic serial" port with no real
  control mechanisms, just raw data transfer over two bulk endpoints.
  Because it's not standardized, this isn't as interoperable as the
  CDC ACM driver.  However, for many purposes it's just as functional
  if you can arrange appropriate host side drivers.
-------------------------------------------------------------------------
 interface descriptor: 
 .bInterfaceNumber = DYNAMIC 
 .iInterface = DYNAMIC 
 full speed support: 
 high speed support: 
 string descriptors: 
 end of list 
 en-us 
-------------------------------------------------------------------------
 we know alt == 0, so this is an activation or a reset 
-------------------------------------------------------------------------
 serial function driver setupbinding 
	 REVISIT might want instance-specific strings to help
	  distinguish instances ...
 maybe allocate device-global string ID 
 allocate instance-specific interface IDs 
 allocate instance-specific endpoints 
	 support all relevant hardware speeds... we expect that when
	  hardware is dual speed, all bulk-capable endpoints work at
	  both speeds
 CONFIG_U_SERIAL_CONSOLE 
 allocate and initialize one new instance 
 SPDX-License-Identifier: GPL-2.0+
  f_uac2.c -- USB Audio Class 2.0 Function
  Copyright (C) 2011
     Yadwinder Singh (yadi.brar01@gmail.com)
     Jaswinder Singh (jaswinder.singh@linaro.org)
  Copyright (C) 2020
     Ruslan Bilovol (ruslan.bilovol@gmail.com)
 UAC2 spec: 4.1 Audio Channel Cluster Descriptor 
  The driver implements a simple UAC_2 topology.
  USB-OUT -> IT_1 -> FU -> OT_3 -> ALSA_Capture
  ALSA_Playback -> IT_2 -> FU -> OT_4 -> USB-IN
  Capture and Playback sampling rates are independently
   controlled by two clock sources :
     CLK_5 := c_srate, and CLK_6 := p_srate
 needed for get_alt() 
 will be used in data stage 
 Interrupt IN endpoint of AC interface 
 --------- USB Function Interface ------------- 
 en-us 
 Audio Control Interface 
 .bNumEndpoints = DYNAMIC 
 Clock source for IN traffic 
 .bClockID = DYNAMIC 
 Clock source for OUT traffic 
 .bClockID = DYNAMIC 
 Input Terminal for USB_OUT 
 .bTerminalID = DYNAMIC 
 .bCSourceID = DYNAMIC 
 Input Terminal for IO-In 
 .bTerminalID = DYNAMIC 
 .bCSourceID = DYNAMIC 
 Ouput Terminal for USB_IN 
 .bTerminalID = DYNAMIC 
 .bSourceID = DYNAMIC 
 .bCSourceID = DYNAMIC 
 Ouput Terminal for IO-Out 
 .bTerminalID = DYNAMIC 
 .bSourceID = DYNAMIC 
 .bCSourceID = DYNAMIC 
 .wTotalLength = DYNAMIC 
 AC IN Interrupt Endpoint 
 Audio Streaming OUT Interface - Alt0 
 Audio Streaming OUT Interface - Alt1 
 Audio Stream OUT Intface Desc 
 .bTerminalLink = DYNAMIC 
 Audio USB_OUT Format 
 STD AS ISO OUT Endpoint 
 .bmAttributes = DYNAMIC 
 .wMaxPacketSize = DYNAMIC 
 .bmAttributes = DYNAMIC 
 .wMaxPacketSize = DYNAMIC 
 .bmAttributes = DYNAMIC 
 .wMaxPacketSize = DYNAMIC 
 wBytesPerInterval = DYNAMIC 
 CS AS ISO OUT Endpoint 
 STD AS ISO IN Feedback Endpoint 
 Audio Streaming IN Interface - Alt0 
 Audio Streaming IN Interface - Alt1 
 Audio Stream IN Intface Desc 
 .bTerminalLink = DYNAMIC 
 Audio USB_IN Format 
 STD AS ISO IN Endpoint 
 .wMaxPacketSize = DYNAMIC 
 .wMaxPacketSize = DYNAMIC 
 .wMaxPacketSize = DYNAMIC 
 wBytesPerInterval = DYNAMIC 
 CS AS ISO IN Endpoint 
 playback is always async, capture only when configured
 Win10 requires max packet size + 1 frame
 updated srate is always bigger, therefore DIV_ROUND_UP always yields +1
 adding 1 frame provision for Win10
 bUnitID, bSourceID and bmaControls will be defined later 
 Use macro to overcome line length limitation 
 patch descriptors 
 ID's start with 1 
 Initialize the configurable parameters 
 Calculate wMaxPacketSize according to audio bandwidth 
 HS and SS endpoint addresses are copied from autoconfigured FS descriptors
 Non-vendor, interface interrupt 
 No if has more than 2 alt settings 
 Control If has only 1 AltSetting - 0 
 restart interrupt endpoint 
 Only Class specific requests are supposed to reach here 
 SPDX-License-Identifier: GPL-2.0+
  f_fs.c -- user mode file system API for USB composite function controllers
  Copyright (C) 2010 Samsung Electronics
  Author: Michal Nazarewicz <mina86@mina86.com>
  Based on inode.c (GadgetFS) which was:
  Copyright (C) 2003-2004 David Brownell
  Copyright (C) 2003 Agilent Technologies
 #define DEBUG 
 #define VERBOSE_DEBUG 
 Chosen by a honest dice roll ;) 
 Reference counter handling 
 Creates new ffs_data object. 
 Opened counter handling. 
 Called with ffs->mutex held; take over ownership of data. 
 The function structure 
 The endpoints structures 
 P: ffs->eps_lock 
 P: epfile->mutex 
 [0]: full speed, [1]: high speed, [2]: super speed 
 P: epfile->mutex 
 Protects ep->ep and ep->req. 
 P: ffs->eps_lock 
	
	  Buffer for holding data from partial reads which may happen since
	  we’re rounding user read requests to a multiple of a max packet size.
	 
	  The pointer is initialised with NULL value and may be set by
	  __ffs_epfile_read_data function to point to a temporary buffer.
	 
	  In normal operation, calls to __ffs_epfile_read_buffered will consume
	  data from said buffer and eventually free it.  Importantly, while the
	  function is using the buffer, it sets the pointer to NULL.  This is
	  all right since __ffs_epfile_read_data and __ffs_epfile_read_buffered
	  can never run concurrently (they are synchronised by epfile->mutex)
	  so the latter will not assign a new value to the pointer.
	 
	  Meanwhile ffs_func_eps_disable frees the buffer (if the pointer is
	  valid) and sets the pointer to READ_BUFFER_DROP value.  This special
	  value is crux of the synchronisation between ffs_func_eps_disable and
	  __ffs_epfile_read_data.
	 
	  Once __ffs_epfile_read_data is about to finish it will try to set the
	  pointer back to its old value (as described above), but seeing as the
	  pointer is not-NULL (namely READ_BUFFER_DROP) it will instead free
	  the buffer.
	 
	  == State transitions ==
	 
	  • ptr == NULL:  (initial state)
	    ◦ __ffs_epfile_read_buffer_free: go to ptr == DROP
	    ◦ __ffs_epfile_read_buffered:    nop
	    ◦ __ffs_epfile_read_data allocates temp buffer: go to ptr == buf
	    ◦ reading finishes:              na, not in ‘and reading’ state
	  • ptr == DROP:
	    ◦ __ffs_epfile_read_buffer_free: nop
	    ◦ __ffs_epfile_read_buffered:    go to ptr == NULL
	    ◦ __ffs_epfile_read_data allocates temp buffer: free buf, nop
	    ◦ reading finishes:              na, not in ‘and reading’ state
	  • ptr == buf:
	    ◦ __ffs_epfile_read_buffer_free: free buf, go to ptr == DROP
	    ◦ __ffs_epfile_read_buffered:    go to ptr == NULL and reading
	    ◦ __ffs_epfile_read_data:        na, __ffs_epfile_read_buffered
	                                     is always called first
	    ◦ reading finishes:              na, not in ‘and reading’ state
	  • ptr == NULL and reading:
	    ◦ __ffs_epfile_read_buffer_free: go to ptr == DROP and reading
	    ◦ __ffs_epfile_read_buffered:    na, mutex is held
	    ◦ __ffs_epfile_read_data:        na, mutex is held
	    ◦ reading finishes and …
	      … all data read:               free buf, go to ptr == NULL
	      … otherwise:                   go to ptr == buf and reading
	  • ptr == DROP and reading:
	    ◦ __ffs_epfile_read_buffer_free: nop
	    ◦ __ffs_epfile_read_buffered:    na, mutex is held
	    ◦ __ffs_epfile_read_data:        na, mutex is held
	    ◦ reading finishes:              free buf, go to ptr == DROP
 P: ffs->eps_lock 
 P: ffs->eps_lock 
  ffs_io_data structure 
 Devices management 
 Misc helper functions 
 Control file aka ep0 
	
	  UDC layer requires to provide a buffer even for ZLP, but should
	  not use it at all. Let's provide some poisoned pointer to catch
	  possible bug in the driver.
 Fast check if setup was canceled 
 Acquire mutex 
 Check state 
 Copy data 
 Handle data 
		
		  We're called from user space, we can use _irq
		  rather then _irqsave
 FFS_SETUP_PENDING 
 FFS_SETUP_PENDING and not stall 
		
		  We are guaranteed to be still in FFS_ACTIVE state
		  but the state of setup could have changed from
		  FFS_SETUP_PENDING to FFS_SETUP_CANCELLED so we need
		  to check for that.  If that happened we copied data
		  from user space in vain but it's unlikely.
		 
		  For sure we are not in FFS_NO_SETUP since this is
		  the only place FFS_SETUP_PENDING -> FFS_NO_SETUP
		  transition can be performed and it's protected by
		  mutex.
 unlocks spinlock 
 Called with ffs->ev.waitq.lock and ffs->mutex held, both released on exit. 
	
	  n cannot be bigger than ffs->ev.count, which cannot be bigger than
	  size of ffs->ev.types array (which is four) so that's how much space
	  we reserve.
 Fast check if setup was canceled 
 Acquire mutex 
 Check state 
	
	  We're called from user space, we can use _irq rather then
	  _irqsave
 unlocks spinlock 
 See ffs_ep0_write() 
 unlocks spinlock 
 "Normal" endpoints operations 
	
	  Dear user space developer!
	 
	  TL;DR: To stop getting below error message in your kernel log, change
	  user space code using functionfs to align read buffers to a max
	  packet size.
	 
	  Some UDCs (e.g. dwc3) require request sizes to be a multiple of a max
	  packet size.  When unaligned buffer is passed to functionfs, it
	  internally uses a larger, aligned buffer so that such UDCs are happy.
	 
	  Unfortunately, this means that host may send more data than was
	  requested in read(2) system call.  f_fs doesn’t know what to do with
	  that excess data so it simply drops it.
	 
	  Was the buffer aligned in the first place, no such problem would
	  happen.
	 
	  Data may be dropped only in AIO reads.  Synchronous reads are handled
	  by splitting a request into multiple parts.  This splitting may still
	  be a problem though so it’s likely best to align the buffer
	  regardless of it being AIO or not..
	 
	  This only affects OUT endpoints, i.e. reading data with a read(2),
	  aio_read(2) etc. system calls.  Writing data to an IN endpoint is not
	  affected.
  allocate a virtually contiguous buffer and create a scatterlist describing it
  @sg_table	- pointer to a place to be filled with sg_table contents
  @size	- required buffer size
	
	  See comment in struct ffs_epfile for full read_buffer pointer
	  synchronisation story.
 Assumes epfile->mutex is held. 
	
	  Null out epfile->read_buffer so ffs_func_eps_disable does not free
	  the buffer while we are using it.  See comment in struct ffs_epfile
	  for full read_buffer pointer synchronisation story.
 Assumes epfile->mutex is held. 
 See ffs_copy_to_iter for more context. 
	
	  At this point read_buffer is NULL or READ_BUFFER_DROP (if
	  ffs_func_eps_disable has been called in the meanwhile).  See comment
	  in struct ffs_epfile for full read_buffer pointer synchronisation
	  story.
 Are we still active? 
 Wait for endpoint to be enabled 
 Do we halt? 
 We will be using request and read_buffer 
 Allocate & copy 
		
		  Do we have buffered data from previous partial read?  Check
		  that for synchronous case only because we do not have
		  facility to ‘wake up’ a pending asynchronous read and push
		  buffered data to it which we would need to make things behave
		  consistently.
		
		  if we _do_ wait above, the epfile->ffs->gadget might be NULL
		  before the waiting completes, so do not assign to 'gadget'
		  earlier
 In the meantime, endpoint got disabled or changed. 
		
		  Controller may require buffer size to be aligned to
		  maxpacketsize of an out endpoint.
 In the meantime, endpoint got disabled or changed. 
		
		  Sanity Check: even though data_len can't be used
		  uninitialized at the time I write this comment, some
		  compilers complain about this situation.
		  In order to keep the code clean from warnings, data_len is
		  being initialized to -EINVAL during its declaration, which
		  means we can't rely on compiler anymore to warn no future
		  changes won't result in data_len being used uninitialized.
		  For such reason, we're adding this redundant sanity check
		  here.
			
			  To avoid race condition with ffs_epfile_io_complete,
			  dequeue the request first then check
			  status. usb_ep_dequeue API should guarantee no race
			  condition with req->complete callback.
		
		  Do not kfree the buffer in this function.  It will be freed
		  by ffs_user_copy_worker.
 don't free if there is iocb queued 
 Wait for endpoint to be enabled 
 In the meantime, endpoint got disabled or changed. 
 File system and super block operations 
  Mounting the file system creates a controller file, used first for
  function configuration then later for event monitoring.
 Create "regular" file 
 Super block 
 Root inode 
 EP0 file 
  Set up the superblock for a mount.
 Driver's main initcleanup functions 
 ffs_data and ffs_function construction and destruction code 
 XXX REVISIT need to update it in some places, or do we? 
 pending requests get nuked 
 Parsing and building descriptors and strings 
  This validates if data pointed by data is a valid USB descriptor as
  well as record how many interfaces, endpoints and strings are
  required by given configuration.  Returns address after the
  descriptor or NULL if data is invalid.
 At least two bytes are required: length and type 
 If we have at least as many bytes as the descriptor takes? 
 Parse descriptor depending on type. 
 function can't have any of those 
 TODO 
 We should never be here 
 Record "descriptor" entity 
		
		  Interfaces are indexed from zero so if we
		  encountered interface "n" then there are at least
		  "n+1" interfaces.
		
		  Strings are indexed from 1 (0 is reserved
		  for languages list)
 Check if descriptors for any speed were already parsed 
  Process all extended compatibilityextended property descriptors
  of a feature descriptor
 loop over all ext compatext prop descriptors 
 Process a number of complete Feature Descriptors (Ext Compat or Ext Prop) 
		
		  Record "descriptor" entity.
		  Process dwLength, bcdVersion, wIndex, get bwCount.
		  Move the data pointer to the beginning of extended
		  compatibilities proper or extended properties proper
		  portions of the data
		
		  16-bit hex "?? 00" Little Endian looks like 8-bit hex "??"
		
		  Process all functionproperty descriptors
		  of this Feature Descriptor
  Validate contents of the buffer from userspace related to OS descriptors.
			
			  According to the spec, Reserved1 must be set to 1
			  but older kernels incorrectly rejected non-zero
			  values.  We fix it here to avoid returning EINVAL
			  in response to values we used to accept.
 property name reported to the host as "WCHAR"s 
 Read fs_count, hs_count and ss_count (if present) 
 Read descriptors 
 if one is zero the other must be zero 
 Do we have at least as many strings as descriptors need? 
	
	  If we don't need any strings just return and free all
	  memory.
 Allocate everything in one chunk so there's less maintenance. 
 Initialize the VLA pointers 
 stringtabs = vlabuf = d_stringtabs for later kfree 
 For each language 
 lang_count > 0 so we can use do-while 
 For each string 
 str_count > 0 so we can use do-while 
			
			  User may provide more strings then we need,
			  if that's the case we simply ignore the
			  rest
				
				  s->id will be set while adding
				  function to configuration so for
				  now just leave garbage here.
 terminator 
 Some garbage left? 
 Done! 
 Events handling and management 
	
	  Abort any unhandled setup
	 
	  We do not need to worry about some cmpxchg() changing value
	  of ffs->setup_state without holding the lock because when
	  state is FFS_SETUP_PENDING cmpxchg() in several places in
	  the source does nothing.
	
	  Logic of this function guarantees that there are at most four pending
	  evens on ffs->ev.types queue.  This is important because the queue
	  has space for four elements only and __ffs_ep0_read_events function
	  depends on that limit as well.  If more event types are added, those
	  limits have to be revisited or guaranteed to still hold.
 Discard all similar events 
 Discard everything other then power management. 
 Bindunbind USB function hooks 
	
	  If ss_descriptors is not NULL, we are reading super speed
	  descriptors; if hs_descriptors is not NULL, we are reading high
	  speed descriptors; otherwise, we are reading full speed
	  descriptors.
		
		  We back up bEndpointAddress because autoconfig overwrites
		  it with physical endpoint address.
		
		  We back up wMaxPacketSize because autoconfig treats
		  endpoint descriptors as if they were full speed.
		
		  If we use virtual address mapping, we restore
		  original bEndpointAddress value.
		
		  Restore wMaxPacketSize which was potentially
		  overwritten by autoconfig.
 Handled in previous pass by __ffs_func_bind_do_descs() 
 String' IDs are allocated when fsf_data is bound to cdev 
		
		  USB_DT_ENDPOINT are handled in
		  __ffs_func_bind_do_descs().
 unicode data reported to the host as "WCHAR"s 
 property name reported to the host as "WCHAR"s 
	
	  Legacy gadget triggers binding in functionfs_ready_callback,
	  which already uses locking; taking the same lock here would
	  cause a deadlock.
	 
	  Configfs-enabled gadgets however do need ffs_dev_lock.
	
	  in driversusbgadgetconfigfs.c:configfs_composite_bind()
	  configurations are bound in sequence with list_for_each_entry,
	  in each configuration its functions are bound in sequence
	  with list_for_each_entry, so we assume no race condition
	  with regard to ffs_opts->bound access
 Make it a single chunk, less management later on 
 Has descriptors only for speeds gadget does not support 
 Allocate a single chunk, less management later on 
 Copy descriptors  
	 Save pointers
	  d_eps == vlabuf, func->eps used to kfree vlabuf later
	
	  Go through all the endpoint descriptors and allocate
	  endpoints first, so that later we can rewrite the endpoint
	  numbers without worrying that it may be described later on.
	
	  Now handle interface numbers allocation and interface and
	  endpoint numbers rewriting.  We can do that in one go
	  now.
 And we're done 
 XXX Do we need to release all claimed endpoints here? 
 Other USB function hooks 
	
	  Most requests directed to interface go through here
	  (notable exceptions are setget interface) so we need to
	  handle them.  All other either handled by composite or
	  passed to usb_configuration->setup() (if one is set).  No
	  matter, we will handle requests directed to endpoint here
	  as well (as it's straightforward).  Other request recipient
	  types are only handled when the user flag FUNCTIONFS_ALL_CTRL_RECIP
	  is being used.
 Endpoint and interface numbers reverse mapping 
 Devices management 
  ffs_lock must be taken by the caller of this function
  ffs_lock must be taken by the caller of this function
 Configfs support 
 Function registration interface 
 Drain any pending AIO completions 
 cleanup after autoconfig 
	
	  eps, descriptors and interfaces_nums are allocated in the
	  same chunk so only one free is required.
  ffs_lock must be taken by the caller of this function
  ffs_lock must be taken by the caller of this function
 Misc helper functions 
 SPDX-License-Identifier: GPL-2.0+
 	uvc_v4l2.c  --  USB Video Class Gadget driver
 	Copyright (C) 2009-2010
 	    Laurent Pinchart (laurent.pinchart@ideasonboard.com)
 --------------------------------------------------------------------------
  Requests handling
 --------------------------------------------------------------------------
  V4L2 ioctls
 Enable UVC video. 
	
	  Complete the alternate setting selection setup phase now that
	  userspace is ready to provide video frames.
 --------------------------------------------------------------------------
  V4L2
 SPDX-License-Identifier: GPL-2.0+
  f_audio.c -- USB Audio class function driver
  Copyright (C) 2008 Bryan Wu <cooloney@kernel.org>
  Copyright (C) 2008 Analog Devices, Inc
  DESCRIPTORS ... most are static, but strings and full
  configuration descriptors are built on demand.
  We have two interfaces- AudioControl and AudioStreaming
  TODO: only supcard playback currently
 B.3.1  Standard AC Interface Descriptor 
  The number of AudioStreaming and MIDIStreaming interfaces
  in the Audio Interface Collection
 1 input terminal, 1 output terminal and 1 feature unit 
 B.3.2  Class-Specific AC Interface Descriptor 
 Interface number of the first AudioStream interface 
 Todo: add real Mute control code 
 Todo: add real Volume control code 
 B.4.1  Standard AS Interface Descriptor 
 B.4.2  Class-Specific AS Interface Descriptor 
 Standard ISO OUT Endpoint Descriptor 
 Class-specific AS ISO OUT Endpoint Descriptor 
 en-us 
  This function is an ALSA sound card following USB Audio Class Spec 1.0.
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 endpoints handle full andor high speeds 
 Control Set command 
-------------------------------------------------------------------------
 Copy buffer is full, add it to the play_queue 
 normal completion? 
	 composite driver infrastructure handles everything; interface
	  activation uses set_alt().
 respond with data transfer or status phase? 
 device either stalls (value < 0) or reports success 
 No if has more than 2 alt settings 
 Control If has only 1 AltSetting - 0 
			
			  allocate a bunch of read buffers
			  and queue them all at once.
-------------------------------------------------------------------------
 Set channel numbers 
 Set sample rates 
 Todo: Set Sample bits and other parameters 
 audio function driver setupbinding 
 set up ASLA audio devices 
 allocate instance-specific interface IDs, and patch descriptors 
 allocate instance-specific endpoints 
 copy descriptors, and track endpoint copies 
-------------------------------------------------------------------------
 Todo: add more control selecotor dynamically 
 allocate and initialize one new instance 
 SPDX-License-Identifier: GPL-2.0+
  u_serial.c - utilities for USB gadget "serial port"TTY support
  Copyright (C) 2003 Al Borchers (alborchers@steinerpoint.com)
  Copyright (C) 2008 David Brownell
  Copyright (C) 2008 by Nokia Corporation
  This code also borrows from usbserial.c, which is
  Copyright (C) 1999 - 2002 Greg Kroah-Hartman (greg@kroah.com)
  Copyright (C) 2000 Peter Berger (pberger@brimson.com)
  Copyright (C) 2000 Al Borchers (alborchers@steinerpoint.com)
 #define VERBOSE_DEBUG 
  This component encapsulates the TTY layer glue needed to provide basic
  "serial port" functionality through the USB gadget stack.  Each such
  port is exposed through a devttyGS node.
  After this module has been loaded, the individual TTY port can be requested
  (gserial_alloc_line()) and it will stay available until they are removed
  (gserial_free_line()). Each one may be connected to a USB function
  (gserial_connect), or disconnected (with gserial_disconnect) when the USB
  host issues a config change event. Data can only flow when the port is
  connected to the host.
  A given TTY port can be made available in multiple configurations.
  For example, each one might expose a ttyGS0 node which provides a
  login application.  In one case that might use CDC ACM interface 0,
  while another configuration might use interface 3 for that.  The
  work to handle that (including descriptor management) is not part
  of this component.
  Configurations may expose more than one TTY port.  For example, if
  ttyGS0 provides login service, then ttyGS1 might provide dialer access
  for a telephone or fax link.  And ttyGS2 might be something that just
  needs a simple byte stream interface for some messaging protocol that
  is managed in userspace ... OBEX, PTP, and MTP have been mentioned.
  gserial is the lifecycle interface, used by USB functions
  gs_port is the IO nexus, used by the tty driver
  tty_struct links to the ttyfilesystem framework
  gserial <---> gs_port ... links will be null when the USB link is
  inactive; managed by gserial_{connect,disconnect}().  each gserial
  instance can wrap its own USB control protocol.
 	gserial->ioport == usb_ep->driver_data ... gs_port
 	gs_port->port_usb ... gserial
  gs_port <---> tty_struct ... links will be null when the TTY file
  isn't opened; managed by gs_open()gs_close()
 	gserial->port_tty ... tty_struct
 	tty_struct->driver_data ... gserial
 RX and TX queues can buffer QUEUE_SIZE packets before they hit the
  next layer of buffering.  For TX that's a circular buffer; for RX
  consider it a NOP.  A third layer is provided by the TTY code.
 TX only 
 console info 
  The port structure holds info for each port, one for each minor number
  (and thus for each dev node).
 guard port_ access 
 wait while writes drain 
 port suspended 
 delay start when suspended 
 REVISIT this state ... 
 8-N-1 etc 
 protect openclose 
 seconds 
 pr_vdebug 
 pr_vdebug 
-------------------------------------------------------------------------
 IO glue between TTY (upper) and USB function (lower) driver layers 
  gs_alloc_req
  Allocate a usb_request and its buffer.  Returns a pointer to the
  usb_request or NULL if there is an error.
  gs_free_req
  Free a usb_request and its buffer.
  gs_send_packet
  If there is data to send, a packet is built in the given
  buffer and the size is returned.  If there is no data to
  send, 0 is returned.
  Called with port_lock held.
  gs_start_tx
  This function finds available write requests, calls
  gs_send_packet to fill these packets with data, and
  continues until either there are no more write requests
  available or no more data to send.  This function is
  run whenever data arrives or write requests are available.
  Context: caller owns port_lock; port_usb is non-null.
__releases(&port->port_lock)
__acquires(&port->port_lock)
		 Drop lock while we call out of driver; completions
		  could be issued while we do so.  Disconnection may
		  happen too; maybe immediately before we queue this!
		 
		  NOTE that we may keep sending data for a while after
		  the TTY closed (dev->ioport->port_tty is NULL).
 abort immediately after disconnect 
  Context: caller owns port_lock, and port_usb is set
__releases(&port->port_lock)
__acquires(&port->port_lock)
 no more rx if closed 
		 drop lock while we call out; the controller driver
		  may need to call us back (e.g. for disconnect)
 abort immediately after disconnect 
  RX work takes data out of the RX queue and hands it up to the TTY
  layer until it refuses to take any more data (or is throttled back).
  Then it issues reads for any further data.
  If the RX queue becomes full enough that no usb_request is queued,
  the OUT endpoint may begin NAKing as soon as its FIFO fills up.
  So QUEUE_SIZE packets plus however many the FIFO holds (usually two)
  can be buffered before the TTY layer's buffers (currently 64 KB).
 hand any queued data to the tty 
 leave data queued if tty was rx throttled 
 presumably a transient fault 
 normal completion 
 push data to (open) tty 
 we may have pushed part of this packet already... 
 stop pushing; TTY layer can't handle more 
	 Push from tty to ldisc; this is handled by a workqueue,
	  so we won't get callbacks and can hold port_lock
	 We want our data queue to become empty ASAP, keeping data
	  in the tty and ldisc (not here).  If we couldn't push any
	  this time around, RX may be starved, so wait until next jiffy.
	 
	  We may leave non-empty queue only when there is a tty, and
	  either it is throttled or there is no more room in flip buffer.
 If we're still connected, refill the USB RX queue. 
 Queue all received data until the tty layer is ready for it. 
 presumably a transient fault 
 normal completion 
 disconnect 
	 Pre-allocate up to QUEUE_SIZE transfers, but if we can't
	  do quite that many this time, don't fail ... we just won't
	  be as speedy as we might otherwise be.
  gs_start_io - start USB IO streams
  @port: port to use
  Context: holding port_lock; port_tty and port_usb are non-null
  We only start IO when something is connected to both sides of
  this port.  If nothing is listening on the host side, we may
  be pointlessly filling up our TX buffers and FIFO.
	 Allocate RX and TX IO buffers.  We can't easily do this much
	  earlier (with GFP_KERNEL) because the requests are coupled to
	  endpoints, as are the packet sizes we'll be using.  Different
	  configurations may use different endpoints with a given port;
	  and high speed vs full speed changes packet sizes too.
 queue read requests 
		 Unblock any pending writes into our circular buffer, in case
-------------------------------------------------------------------------
 TTY Driver 
  gs_open sets up the link between a gs_port and its associated TTY.
  That link is broken only by TTY close(), and all driver methods
  know that.
 allocate circular buffer on first open 
		
		  portmaster's mutex still protects from simultaneous open(),
		  and close() can't happen, yet.
 already open?  Great. 
 if connected, start the IO stream 
 if port is suspended, wait resume to start I0 stream 
 return true on disconnect or empty buffer or if raced with open() 
	 wait for circular write buffer to drain, disconnect, or at
	  most GS_CLOSE_TIMEOUT seconds; then discard the rest
	 Iff we're disconnected, there can be no IO in flight so it's
	  ok to free the circular buffer; else just scrub it.  And don't
	  let the push async work fire again until we're re-opened.
 treat count == 0 as flush_chars() 
 undo side effects of setting TTY_THROTTLED 
		 Kickstart read queue processing.  We don't do xonxoff,
		  rtscts, or other handshaking with the host, but if the
		  read queue backs up enough we'll be NAKing OUT packets.
-------------------------------------------------------------------------
 normal completion 
 disconnect 
 disconnected 
 busy 
 wait for old opens to finish 
 ... and sysfs class devices, so mdevudev make devttyGS 
  gserial_connect - notify TTY IO glue that USB link is active
  @gser: the function, set up with endpoints and descriptors
  @port_num: which port is active
  Context: any (usually from irq)
  This is called activate endpoints and let the TTY layer know that
  the connection is active ... not unlike "carrier detect".  It won't
  necessarily start IO queues; unless the TTY is held open by any
  task, there would be no point.  However, the endpoints will be
  activated so the USB host can perform IO, subject to basic USB
  hardware flow control.
  Caller needs to have set up the endpoints and USB function in @dev
  before calling this, as well as the appropriate (speed-specific)
  endpoint descriptors, and also have allocate @port_num by calling
  @gserial_alloc_line().
  Returns negative errno or zero.
  On success, ep->driver_data will be overwritten.
 activate the endpoints 
 then tell the tty glue that IO can work 
	 REVISIT unclear how best to handle this state...
	  we don't really couple it with the Linux TTY.
 REVISIT if waiting on "carrier detect", signal. 
	 if it's already open, start IO ... and notify the serial
	  protocol about openclose status (connectdisconnect).
  gserial_disconnect - notify TTY IO glue that USB link is inactive
  @gser: the function, on which gserial_connect() was called
  Context: any (usually from irq)
  This is called to deactivate endpoints and let the TTY layer know
  that the connection went inactive ... not unlike "hangup".
  On return, the state is as if gserial_connect() had never been called;
  there is no active USB IO on these endpoints.
 tell the TTY glue not to do IO here any more 
 REVISIT as above: how best to track this? 
 disable endpoints, aborting down any active IO 
 finally, free any unusedunusable IO buffers 
 uses dynamically assigned dev_t values 
	 9600-8-N-1 ... matches defaults expected by "usbser.sys" on
	  MS-Windows.  Otherwise, most of these flags shouldn't affect
	  anything unless we were to actually hook up to a serial line.
 export the driver ... 
